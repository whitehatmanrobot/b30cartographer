                         \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )


#define ConvertDaysToMilliseconds(DAYS) ( \
    Int32x32To64( (DAYS), 86400000 ) \
    )

//
//  The following two tables map a month index to the number of days preceding
//  the month in the year.  Both tables are zero based.  For example, 1 (Feb)
//  has 31 days preceding it.  To help calculate the maximum number of days
//  in a month each table has 13 entries, so the number of days in a month
//  of index i is the table entry of i+1 minus the table entry of i.
//

CONST USHORT LeapYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+29,                             // March
    31+29+31,                          // April
    31+29+31+30,                       // May
    31+29+31+30+31,                    // June
    31+29+31+30+31+30,                 // July
    31+29+31+30+31+30+31,              // August
    31+29+31+30+31+30+31+31,           // September
    31+29+31+30+31+30+31+31+30,        // October
    31+29+31+30+31+30+31+31+30+31,     // November
    31+29+31+30+31+30+31+31+30+31+30,  // December
    31+29+31+30+31+30+31+31+30+31+30+31};

CONST USHORT NormalYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+28,                             // March
    31+28+31,                          // April
    31+28+31+30,                       // May
    31+28+31+30+31,                    // June
    31+28+31+30+31+30,                 // July
    31+28+31+30+31+30+31,              // August
    31+28+31+30+31+30+31+31,           // September
    31+28+31+30+31+30+31+31+30,        // October
    31+28+31+30+31+30+31+31+30+31,     // November
    31+28+31+30+31+30+31+31+30+31+30,  // December
    31+28+31+30+31+30+31+31+30+31+30+31};

//
//  These are known constants used to convert 1970 and 1980 times to 1601
//  times.  They are the number of seconds from the 1601 base to the start
//  of 1970 and the start of 1980.  The number of seconds from 1601 to
//  1970 is 369 years worth, or (369 * 365) + 89 leap days = 134774 days, or
//  134774 * 864000 seconds, which is equal to the large integer defined
//  below.  The number of seconds from 1601 to 1980 is 379 years worth, or etc.
//

const LARGE_INTEGER SecondsToStartOf1970 = {0xb6109100, 0x00000002};

const LARGE_INTEGER SecondsToStartOf1980 = {0xc8df3700, 0x00000002};

///////////////////////////////////////////////////////////////////////////////
//
// Above portion copy from private\ntos\rtl\time.c
//
//
///////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
void
ConvertInt64ToFileTime(
    const __int64* pint64,
    FILETIME* pft
    )
/*++

--*/
{
    
    pft->dwLowDateTime = (DWORD)(*pint64 & 0xFFFFFFFF);
    pft->dwHighDateTime = (LONG) (*pint64 >> 32);
    return;
}

//---------------------------------------------------------------------------

void
ConvertFileTimeToInt64(
    const FILETIME* pft,
    __int64* pint64
    )
/*++

--*/
{
    ULARGE_INTEGER ul;

    ul.LowPart = pft->dwLowDateTime;
    ul.HighPart = pft->dwHighDateTime;

    *pint64 = (__int64)ul.QuadPart;
    return;
}


//---------------------------------------------------------------------------

void
ConvertInt64ToUlargeInt(
    const __int64* pint64,
    ULARGE_INTEGER* pularge
    )
/*++

--*/
{
    pularge->QuadPart = *pint64;
    return;
}

//---------------------------------------------------------------------------

BOOL
MyMkTime(
    SYSTEMTIME* psysTime,
    FILETIME* pft
    )
/*++

    Similar to standard C runtime mktime() except it operate on
    SYSTEMTIME, note, BUG in mktime() that it lost one day, e.g,
    add 9 year, 25 months to 1970/1/1, mktime returns 1981/1/31
    instead of 1981/2/1

--*/
{
    DWORD dwMilliseconds;
    ULARGE_INTEGER ul100NsSince1970;

    LONGLONG ul100NsSince1601;
    LONGLONG ul100Ns;

    FILETIME ft;
    BOOL bSuccess;

    DWORD dwDaysSince1970;

    //
    // day/hour/mins/second to 100ns
    dwMilliseconds = ((psysTime->wHour * 60 + psysTime->wMinute) * 60 + psysTime->wSecond) * 1000 + psysTime->wMilliseconds;
    ul100Ns = UInt32x32To64( dwMilliseconds, 10000 );

    //
    // Convert year/month/day to days since 1980
    
    while( psysTime->wMonth > 12 )
    {
        // our month is inclusive
        psysTime->wYear ++;
        psysTime->wMonth -= 12;
    }

    dwDaysSince1970 = ElapsedYearsToDays(psysTime->wYear) - ElapsedYearsToDays(1970);

    // dwDaysSince1970 already included 1/1/1970
    dwDaysSince1970 += psysTime->wDay - 1;

    if(IsLeapYear(psysTime->wYear) == TRUE)
    {
        dwDaysSince1970 += LeapYearDaysPrecedingMonth[psysTime->wMonth - 1];
        dwDaysSince1970--;
    }
    else
    {
        dwDaysSince1970 += NormalYearDaysPrecedingMonth[psysTime->wMonth - 1];
    }

    //
    // Convert days since 1980 to 100 ns since 1980
    ul100NsSince1601 = ConvertDaysToMilliseconds(dwDaysSince1970) * 10000 + ul100Ns;
    ul100NsSince1601 += (SecondsToStartOf1970.QuadPart * 10000000);

    ConvertInt64ToFileTime(&ul100NsSince1601, &ft);
    bSuccess = FileTimeToSystemTime( &ft, psysTime );

    if(bSuccess == TRUE && pft != NULL)
    {
        *pft = ft;
    }

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\locks.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    locks.h

Abstract:

    Various C++ class for sync. object

Author:

    HueiWang    2/17/2000

--*/
#ifndef __LOCKS_H
#define __LOCKS_H

#include <windows.h>
#include <winbase.h>
#include "assert.h"

#define ARRAY_COUNT(a) sizeof(a) / sizeof(a[0])

//
// Semaphore template
//
template <int init_count, int max_count>
class CTSemaphore 
{
private:
    HANDLE m_semaphore;

public:
    CTSemaphore() : m_semaphore(NULL)
    { 
        m_semaphore = CreateSemaphore(
                                    NULL, 
                                    init_count, 
                                    max_count, 
                                    NULL
                                ); 
        assert(m_semaphore != NULL);
    }

    ~CTSemaphore()                 
    { 
        if(m_semaphore) 
        {
            CloseHandle(m_semaphore); 
        }
    }

    DWORD 
    Acquire(
        int WaitTime=INFINITE, 
        BOOL bAlertable=FALSE
        ) 
    /*++

    --*/
    { 
        return WaitForSingleObjectEx(
                                m_semaphore, 
                                WaitTime, 
                                bAlertable
                            );
    }

    BOOL
    AcquireEx(
            HANDLE hHandle, 
            int dwWaitTime=INFINITE, 
            BOOL bAlertable=FALSE
        ) 
    /*++

    --*/
    { 
        BOOL bSuccess = TRUE;
        DWORD dwStatus;
        HANDLE hHandles[] = {m_semaphore, hHandle};

        if(hHandle == NULL || hHandle == INVALID_HANDLE_VALUE)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            bSuccess = FALSE;
        }
        else
        {
            dwStatus = WaitForMultipleObjectsEx(
                                        sizeof(hHandles)/sizeof(hHandles[0]),
                                        hHandles,
                                        FALSE,
                                        dwWaitTime,
                                        bAlertable
                                    );

            if(dwStatus != WAIT_OBJECT_0)
            {
                bSuccess = FALSE;
            }
        }

        return bSuccess;
    }


    BOOL Release(long count=1)          
    { 
        return ReleaseSemaphore(m_semaphore, count, NULL); 
    }

    BOOL IsGood()
    { 
        return m_semaphore != NULL; 
    }
};


//
// Critical section C++ class.
//
class CCriticalSection 
{

    CRITICAL_SECTION m_CS;
    BOOL m_bGood;

public:
    CCriticalSection(
        DWORD dwSpinCount = 4000    // see InitializeCriticalSection...
    ) : m_bGood(TRUE)
    { 
        
        __try {
            InitializeCriticalSectionAndSpinCount(&m_CS,  dwSpinCount); 
        } 
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            SetLastError(GetExceptionCode());
            m_bGood = FALSE;
        }
    }

    ~CCriticalSection()              
    { 
        if(IsGood() == TRUE)
        {
            DeleteCriticalSection(&m_CS); 
            m_bGood = FALSE;
        }
    }

    BOOL
    IsGood() 
    { 
        return m_bGood; 
    }

    void Lock() 
    {
        EnterCriticalSection(&m_CS);
    }

    void UnLock()
    {
        LeaveCriticalSection(&m_CS);
    }

    BOOL TryLock()
    {
        return TryEnterCriticalSection(&m_CS);
    }
};

//
// Critical section locker, this class lock the critical section
// at object constructor and release object at destructor, purpose is to
// prevent forgoting to release a critical section.
//
// usage is
//
// void
// Foo( void )
// {
//      CCriticalSectionLocker l( <some CCriticalSection instance> )
//
// }
// 
//
class CCriticalSectionLocker 
{

private:
    CCriticalSection& m_cs;

public:
    CCriticalSectionLocker( CCriticalSection& m ) : m_cs(m) 
    { 
        m.Lock(); 
    }

    ~CCriticalSectionLocker() 
    { 
        m_cs.UnLock(); 
    }
};

//
// Safe counter class.
//
class CSafeCounter 
{

private:

    long m_Counter;

public:

    CSafeCounter(
        long init_value=0
        ) : 
        m_Counter(init_value) 
    /*++

    --*/
    {
    }

    ~CSafeCounter() 
    {
    }

    operator+=(long dwValue)
    {
        long dwNewValue;

        dwNewValue = InterlockedExchangeAdd( 
                                    &m_Counter, 
                                    dwValue 
                                );
        return dwNewValue += dwValue;
    }

    operator-=(long dwValue)
    {
        long dwNewValue;

        dwNewValue = InterlockedExchangeAdd( 
                                    &m_Counter, 
                                    -dwValue 
                                );
        return dwNewValue -= dwValue;
    }

    operator++() 
    {
        return InterlockedIncrement(&m_Counter);
    }

    operator++(int) 
    {
        long lValue;

        lValue = InterlockedIncrement(&m_Counter);
        return --lValue;
    }

    operator--() 
    {
        return InterlockedDecrement(&m_Counter);
    }

    operator--(int) 
    {
        long lValue;

        lValue = InterlockedDecrement(&m_Counter);
        return ++lValue;
    }

    operator long()
    {
        return InterlockedExchange(&m_Counter, m_Counter);
    }

    operator=(const long dwValue)
    {
        InterlockedExchange(&m_Counter, dwValue);
        return dwValue;
    }
};    

//-------------------------------------------------------------------------
//
// Reader/Writer lock, modified from MSDN
//

typedef enum { 
            WRITER_LOCK, 
            READER_LOCK, 
            NO_LOCK 
    } RWLOCK_TYPE;


class CRWLock 
{ 
private:
    HANDLE hMutex;
    HANDLE hWriterMutex;
    HANDLE hReaderEvent;
    long   iReadCount;
    long   iWriteCount;

    long   iReadEntry;
    long   iWriteEntry;

public:

    CRWLock()  
    { 
        BOOL bSuccess=Init(); 
        assert(bSuccess == TRUE);
    }

    ~CRWLock() 
    { 
        Cleanup();  
    }

    //-----------------------------------------------------------
    BOOL 
    Init()
    {
        hReaderEvent=CreateEvent(NULL,TRUE,FALSE,NULL);
        hMutex = CreateEvent(NULL,FALSE,TRUE,NULL);
        hWriterMutex = CreateMutex(NULL,FALSE,NULL);
        if(!hReaderEvent || !hMutex || !hWriterMutex)
            return FALSE;

        iReadCount = -1;
        iWriteCount = -1;
        iReadEntry = 0;
        iWriteEntry = 0;

        return (TRUE);
    }

    //-----------------------------------------------------------
    void 
    Cleanup()
    {
        CloseHandle(hReaderEvent);
        CloseHandle(hMutex);
        CloseHandle(hWriterMutex);

        iReadCount = -1;
        iWriteCount = -1;
        iReadEntry = 0;
        iWriteEntry = 0;
    }

    //-----------------------------------------------------------
    void 
    Acquire(
        RWLOCK_TYPE lockType
        )
    /*++

    ++*/
    {
        if (lockType == WRITER_LOCK) 
        {  
            InterlockedIncrement(&iWriteCount);
            WaitForSingleObject(hWriterMutex,INFINITE);
            WaitForSingleObject(hMutex, INFINITE);

            assert(InterlockedIncrement(&iWriteEntry) == 1);
            assert(InterlockedExchange(&iReadEntry, iReadEntry) == 0);
        } 
        else 
        {   
            if (InterlockedIncrement(&iReadCount) == 0) 
            { 
                WaitForSingleObject(hMutex, INFINITE);
                SetEvent(hReaderEvent);
            }

            WaitForSingleObject(hReaderEvent,INFINITE);
            InterlockedIncrement(&iReadEntry);
            assert(InterlockedExchange(&iWriteEntry, iWriteEntry) == 0);
        }
    }

    //-----------------------------------------------------------
    void 
    Release(
        RWLOCK_TYPE lockType
        )
    /*++

    ++*/
    {
        if (lockType == WRITER_LOCK) 
        { 
            InterlockedDecrement(&iWriteEntry);
            InterlockedDecrement(&iWriteCount);
            SetEvent(hMutex);
            ReleaseMutex(hWriterMutex);
        } 
        else if(lockType == READER_LOCK) 
        {
            InterlockedDecrement(&iReadEntry);
            if (InterlockedDecrement(&iReadCount) < 0) 
            { 
              ResetEvent(hReaderEvent);
              SetEvent(hMutex);
            }
        }
    }

    long GetReadCount()   
    { 
        return iReadCount+1;  
    }

    long GetWriteCount()  
    { 
        return iWriteCount+1; 
    }
};

//---------------------------------------------------------------------

class CCMutex 
{
    HANDLE  hMutex;

public:

    CCMutex() : hMutex(NULL) { 
        hMutex=CreateMutex(NULL, FALSE, NULL); 
    }

    ~CCMutex() { 
        CloseHandle(hMutex); 
    }  

    DWORD 
    Lock(
        DWORD dwWaitTime=INFINITE, 
        BOOL bAlertable=FALSE
        ) 
    /*++

    --*/
    { 
        return WaitForSingleObjectEx(
                                hMutex, 
                                dwWaitTime, 
                                bAlertable
                            );
    }

    BOOL 
    Unlock() 
    {
        return ReleaseMutex(hMutex);
    }
};

//---------------------------------------------------------------------------------

class CCEvent 
{

    BOOL bManual;
    HANDLE  hEvent;

public:

    CCEvent(
        BOOL bManual, 
        BOOL bInitState
        ) : 
        hEvent(NULL), 
        bManual(bManual) 
    /*++

    --*/
    {
        hEvent=CreateEvent(
                            NULL, 
                            bManual, 
                            bInitState, 
                            NULL
                        );
    }

    ~CCEvent() 
    {
        if( NULL != hEvent )
        {
            CloseHandle(hEvent);
        }
    }

    DWORD
    MsgLock(
        DWORD dwWaitTime = INFINITE
    )
    /*++

    --*/
    {
        HANDLE wait_event[1] = {hEvent};
        DWORD result ; 
        MSG msg ; 

        // The message loop lasts until we get a WM_QUIT message,
        // upon which we shall return from the function.
        while (TRUE)
        {
            // block-local variable 

            // Read all of the messages in this next loop, 
            // removing each message as we read it.
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
            { 
                // If it's a quit message, we're out of here.
                if (msg.message == WM_QUIT)  
                {
                    return WAIT_ABANDONED; 
                }

                // Otherwise, dispatch the message.
                DispatchMessage(&msg); 
            } // End of PeekMessage while loop.

            // Wait for any message sent or posted to this queue 
            // or for one of the passed handles be set to signaled.
            result = MsgWaitForMultipleObjects(
                                        1, 
                                        wait_event,
                                        TRUE, 
                                        dwWaitTime, 
                                        QS_ALLINPUT | QS_ALLPOSTMESSAGE | QS_ALLEVENTS 
                                    ); 

            // The result tells us the type of event we have.
            if (result == WAIT_OBJECT_0 + 1)
            {
                // New messages have arrived. 
                // Continue to the top of the always while loop to 
                // dispatch them and resume waiting.
                continue;
            } 
            else 
            { 
                break;
            } // End of else clause.
        } // End of the always while loop. 

        return result;
    }
    
    DWORD 
    Lock( 
        DWORD dwWaitTime=INFINITE, 
        BOOL bAlertable=FALSE
        ) 
    /*++

    --*/
    {
        return WaitForSingleObjectEx(
                                hEvent, 
                                dwWaitTime, 
                                bAlertable
                            );
    }

    BOOL 
    SetEvent() 
    {
        return ::SetEvent(hEvent);
    }

    BOOL 
    ResetEvent() 
    {
        return ::ResetEvent(hEvent);
    }

    BOOL 
    PulseEvent() 
    {
        return ::PulseEvent(hEvent);
    }

    BOOL 
    IsManual() 
    {
        return bManual;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\helptab.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpTab.h

Abstract:

    Declaration __HelpEntry structure and CHelpSessionTable. 

Author:

    HueiWang    06/29/2000

--*/
#ifndef __CHELPSESSIONTABLE_H__
#define __CHELPSESSIONTABLE_H__
#include <stdio.h>
#include <time.h>


#define REGKEY_HELPSESSIONTABLE             REG_CONTROL_HELPSESSIONENTRY
#define REGKEY_HELPENTRYBACKUP              _TEXT("Backup")

#define REGVALUE_HELPSESSIONTABLE_DIRTY     _TEXT("Dirty")
#define REGVALUE_HELPSESSION_DIRTY          REGVALUE_HELPSESSIONTABLE_DIRTY


#define COLUMNNAME_SESSIONID                _TEXT("SessionId")
#define COLUMNNAME_SESSIONNAME              _TEXT("SessionName")
#define COLUMNNAME_SESSIONPWD               _TEXT("SessionPwd")
#define COLUMNNAME_SESSIONDESC              _TEXT("SessionDesc")
#define COLUMNNAME_SESSIONCREATEBLOB        _TEXT("SessionCreateBlob")
//#define COLUMNNAME_SESSIONRESOLVERID        _TEXT("ResolverID")
#define COLUMNNAME_ENABLESESSIONRESOLVER    _TEXT("EnableResolver")
#define COLUMNNAME_SESSIONRESOLVERBLOB      _TEXT("Blob")
#define COLUMNNAME_SESSIONUSERID            _TEXT("UserSID")
#define COLUMNNAME_CREATETIME               _TEXT("CreationTime")
#define COLUMNNAME_RDSSETTING               _TEXT("RDS Setting")
#define COLUMNNAME_KEYSTATUS                _TEXT("Entry Status")
#define COLUMNNAME_EXPIRATIONTIME           _TEXT("ExpirationTime")

#define COLUMNNAME_ICSPORT                  _TEXT("ICS Port")
#define COLUMNNAME_IPADDRESS                _TEXT("IP Address")

#define ENTRY_VALID_PERIOD                  30      // 30 days.

#define REGVALUE_HELPSESSION_ENTRY_NORMAL   1
#define REGVALUE_HELPSESSION_ENTRY_NEW      2
#define REGVALUE_HELPSESSION_ENTRY_DIRTY    3
#define REGVALUE_HELPSESSION_ENTRY_DELETED  4
#define REGVALUE_HELPSESSION_ENTRY_DELETEONSTARTUP 5

//
// Default value
static FILETIME defaultCreationTime = {0, 0};

struct __HelpEntry;

typedef __HelpEntry HELPENTRY;
typedef __HelpEntry* PHELPENTRY;


// similar to CComPtr
template <class T>
class BaseAccess : public T 
{
};

//
// Template class for column value of registry DB,
// All column type must be derived from this template.
//
template <class T>
class HelpColumnValueBase {

friend bool __cdecl 
operator==( const T& v1, const HelpColumnValueBase<T>& v2 );

friend bool __cdecl 
operator==( const HelpColumnValueBase<T>& v2, const T& v1 );

private:

    // copy of current value
    T m_Value;              

    // Entry value has been modified and not yet 
    // written to registry/
    BOOL m_bDirty;         

    // Registry value name
    LPCTSTR m_pszColumnName; 

    // default value
    T m_Default;

    // HKEY to registry
    HKEY m_hEntryKey;

    // Reference to critical section, note
    // we don't want to use one critical section for
    // a value to conserve resource
    CCriticalSection& m_Lock;   
                                

    // TRUE if registry value will be updated immediately
    // to reflect changes in m_Value
    BOOL m_ImmediateUpdate;
                           
    //
    // Encrypt data
    //
    const BOOL m_bEncrypt;

    //
    // Default implementation of GetValue(),
    // GetValueSize(), GetValueType(), and
    // SetValue().  These routine is used when 
    // writting to/reading from registry.
    //
    virtual const PBYTE
    GetValue() 
    {
        return (PBYTE)&m_Value;
    }

    virtual DWORD
    GetValueSize()
    {
        return sizeof(m_Value);
    }

    virtual DWORD
    GetValueType()
    {
        return REG_BINARY;
    }

    virtual BOOL
    SetValue( PVOID pbData, DWORD cbData )
    {
        m_Value = *(T *)pbData;
        return TRUE;
    }
        
public:

    //
    // TRUE if registry value is updated right away, FALSE
    // otherwise.
    BOOL
    IsImmediateUpdate()
    {
        return (NULL != m_hEntryKey && TRUE == m_ImmediateUpdate);
    }

    // similar to CComPtr
    BaseAccess<T>* operator->() const
    {
        return (BaseAccess<T>*)&m_Value;
    }

    HelpColumnValueBase( 
        IN CCriticalSection& entryLock, // reference to critical section
        IN HKEY hEntryKey,              // HKEY to registry, can be NULL
        IN LPCTSTR pszColumnName,       // Name of registry value.
        IN T DefaultValue,              // Default value if value not in registry
        IN BOOL bImmediateUpdate,       // Update mode
        IN BOOL bEncrypt = FALSE
    ) :
        m_Lock(entryLock),
        m_hEntryKey(hEntryKey),
        m_bDirty(FALSE),
        m_pszColumnName(pszColumnName),
        m_Default(DefaultValue),
        m_Value(DefaultValue),
        m_ImmediateUpdate(bImmediateUpdate),
        m_bEncrypt(bEncrypt)
    {
    }

    //~HelpColumnValueBase()
    //{
    //    m_Default.~T();
    //}

    HelpColumnValueBase&
    operator=(const T& newVal)
    {
        DWORD dwStatus;
        T orgValue;

        CCriticalSectionLocker l(m_Lock);

        m_bDirty = TRUE;
        orgValue = m_Value;
        m_Value = newVal;

        if( TRUE == IsImmediateUpdate() )
        {
            dwStatus = DBUpdateValue(NULL);

            MYASSERT(ERROR_SUCCESS == dwStatus);

            if( ERROR_SUCCESS != dwStatus )
            {
                // restore value
                m_Value = orgValue;
            }
        }

        return *this;
    }

    HelpColumnValueBase&
    operator=(const HelpColumnValueBase& newVal)
    {
        if( this != &newVal )
        {
            CCriticalSectionLocker l(m_Lock);
            m_Value = newVal.m_Value;
        }

        return *this;
    }

    bool
    operator==(const T& v) const
    {
        return v == m_Value;
    }

    operator T()
    {
        return m_Value;
    }

    // Load value from registry
    DWORD
    DBLoadValue(
        IN HKEY hKey
    );

    // update registry value
    DWORD
    DBUpdateValue(
        IN HKEY hKey
    ); 

    // delete registry value
    DWORD
    DBDeleteValue(
        IN HKEY hKey
    );

    // Change has been made but value has not
    // been written to registry
    BOOL
    IsDirty() 
    { 
        return m_bDirty; 
    }

    // Set immediate update mode.
    void
    EnableImmediateUpdate(
        BOOL bImmediateUpdate
        )
    /*++
    --*/
    {
        m_ImmediateUpdate = bImmediateUpdate;
    } 

    // Change registry location for the value.
    HKEY
    SetRegStoreHandle(
        IN HKEY hKey
        )
    /*++

    --*/
    {
        HKEY oldKey = m_hEntryKey;

        m_hEntryKey = hKey;
        return oldKey;
    }
};

template <class T>
bool __cdecl operator==( const T& v1, const HelpColumnValueBase<T>& v2 )
{
    return v1 == v2.m_Value;
}

template <class T>
bool __cdecl operator==( const HelpColumnValueBase<T>& v2, const T& v1 )
{
    return v1 == v2.m_Value;
}

template <class T>
DWORD
HelpColumnValueBase<T>::DBDeleteValue( 
    IN HKEY hKey 
    )
/*++

Routine Description:

    Delete registry value for the column.

Parameter:

    hKey : Handle to HKEY where the value is stored, NULL will use default
           registry location passed in at object construction time or
           SetRegStoreHandle()
           
Returns

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if( NULL == hKey )
    {
        hKey = m_hEntryKey;
    }

    //
    // if no registry handle, no update is necessary,
    // assume it is a memory only value.
    //

    if( NULL != hKey )
    {
        CCriticalSectionLocker l( m_Lock );

        dwStatus = RegDeleteValue(
                                hKey,
                                m_pszColumnName
                            );

        if( ERROR_SUCCESS == dwStatus )
        {
            m_bDirty = TRUE;
        }
    }

    return dwStatus;
}

template <class T>
DWORD 
HelpColumnValueBase<T>::DBUpdateValue(
    IN HKEY hKey
    )
/*++

Routine Description:

    Update registry value.

Parameters:

    hKey : Handle to registry key, NULL if use current location

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if( NULL == hKey )
    {
        hKey = m_hEntryKey;
    }

    if( NULL != hKey )
    {
        // if value size is 0, no need to write anything to 
        // registry, instead delete it to save some
        // space and let default value take care of reading.
        if( 0 == GetValueSize() )
        {
            dwStatus = RegDeleteValue(
                                    hKey,
                                    m_pszColumnName
                                );

            if( ERROR_FILE_NOT_FOUND == dwStatus || ERROR_SUCCESS == dwStatus )
            {
                // no value in registry
                dwStatus = ERROR_SUCCESS;
                m_bDirty = FALSE;
            }
        }
        else
        {
            PBYTE pbData = NULL;
            DWORD cbData = 0;

            cbData = GetValueSize();

            if( m_bEncrypt )
            {
                pbData = (PBYTE)LocalAlloc( LPTR, cbData );

                if( NULL == pbData )
                {
                    dwStatus = GetLastError();
                    goto CLEANUPANDEXIT;
                }

                memcpy( pbData, GetValue(), cbData );
                dwStatus = TSHelpAssistantEncryptData( 
                                                    NULL,
                                                    pbData,
                                                    &cbData
                                                );
            }
            else
            {
                pbData = GetValue();
            }

            if( ERROR_SUCCESS == dwStatus )
            {
                dwStatus = RegSetValueEx( 
                                    hKey,
                                    m_pszColumnName,
                                    NULL,
                                    GetValueType(),
                                    pbData,
                                    cbData
                                );
            }

            if( m_bEncrypt && NULL != pbData )
            {
                LocalFree( pbData );
            }
        }

        if( ERROR_SUCCESS == dwStatus )
        {
            m_bDirty = FALSE;
        }
    }

CLEANUPANDEXIT:

    return dwStatus;
}


template <class T>
DWORD 
HelpColumnValueBase<T>::DBLoadValue(
    IN HKEY hKey
    )
/*++

Routine Description:

    Load value from registry.

Parameters:

    hKey : Registry handle to read the value from, NULL if uses
           current location.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    PBYTE pbData = NULL;
    DWORD cbData = 0;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwType;

    if( NULL == hKey )
    {
        hKey = m_hEntryKey;
    }

    if( NULL != hKey )
    {
        CCriticalSectionLocker l( m_Lock );

        dwStatus = RegQueryValueEx( 
                                hKey,
                                m_pszColumnName,
                                NULL,
                                &dwType,
                                NULL,
                                &cbData
                            );

        if( ERROR_SUCCESS == dwStatus )
        {
            if( dwType == GetValueType() )
            {
                // we only read registry value that has expected data
                // type
                pbData = (PBYTE) LocalAlloc( LPTR, cbData );
                if( NULL != pbData )
                {
                    dwStatus = RegQueryValueEx(
                                            hKey,
                                            m_pszColumnName,
                                            NULL,
                                            &dwType,
                                            pbData,
                                            &cbData
                                        );

                    if( ERROR_SUCCESS == dwStatus )
                    {
                        if( m_bEncrypt )
                        {
                            dwStatus = TSHelpAssistantDecryptData(
                                                            NULL,
                                                            pbData,
                                                            &cbData
                                                        );

                        }

                        if( ERROR_SUCCESS == dwStatus )
                        {
                            if( FALSE == SetValue(pbData, cbData) )
                            {
                                dwStatus = GetLastError();
                            }
                        }
                    }
                }
                else
                {
                    dwStatus = GetLastError();
                }
            }
            else
            {
                // bad data type, delete it and use default value
                (void)RegDeleteValue(
                                hKey,
                                m_pszColumnName
                            );

                dwStatus = ERROR_FILE_NOT_FOUND;
            }
        }

        if( ERROR_FILE_NOT_FOUND == dwStatus )
        {
            // pick the default value if no value in registry
            m_Value = m_Default;
            dwStatus = ERROR_SUCCESS;
        }

        if( ERROR_SUCCESS == dwStatus )
        {
            m_bDirty = FALSE;
        }
    }

    if( NULL != pbData )
    {
        LocalFree(pbData);
    }

    return dwStatus;
}


//
// GetValueType(), GetValueSize() for long registry value type.
//
inline DWORD
HelpColumnValueBase<long>::GetValueType()
{
    return REG_DWORD;
}

inline DWORD
HelpColumnValueBase<long>::GetValueSize()
{
    return sizeof(DWORD);
}

//
// GetValueType(), GetValueSize() for REMOTE_DESKTOP_SHARING_CLASS 
// registry value type.
//
inline DWORD
HelpColumnValueBase<REMOTE_DESKTOP_SHARING_CLASS>::GetValueType()
{
    return REG_DWORD;
}

inline DWORD
HelpColumnValueBase<REMOTE_DESKTOP_SHARING_CLASS>::GetValueSize()
{
    return sizeof(DWORD);
}

//
// GetValue(), GetValueType(), GetValueSize(), SetValue() implmentation
// for CComBSTR 
//
inline const PBYTE
HelpColumnValueBase<CComBSTR>::GetValue()
{
    return (PBYTE)(LPTSTR)m_Value;
}

inline DWORD
HelpColumnValueBase<CComBSTR>::GetValueType()
{
    return ( m_bEncrypt ) ? REG_BINARY : REG_SZ;
}

inline DWORD
HelpColumnValueBase<CComBSTR>::GetValueSize()
{
    DWORD dwValueSize;

    if( m_Value.Length() == 0 )
    {
        dwValueSize = 0;
    }
    else
    {
        dwValueSize = ( m_Value.Length() + 1 ) * sizeof(TCHAR);
    }

    return dwValueSize;
}

inline BOOL
HelpColumnValueBase<CComBSTR>::SetValue( PVOID pbData, DWORD cbData )
{
    m_Value = (LPTSTR)pbData;
    return TRUE;
}
   
typedef MAP< CComBSTR, PHELPENTRY > HelpEntryCache;
typedef HRESULT (WINAPI* EnumHelpEntryCallback)(
                                    IN CComBSTR& bstrHelpId,
                                    IN HANDLE userData
                                );


//
//
// CHelpSessionTable class
//
class CHelpSessionTable {

private:

    typedef struct __EnumHelpEntryParm {
        EnumHelpEntryCallback pCallback;
        CHelpSessionTable* pTable;
        HANDLE userData;
    } EnumHelpEntryParm, *PEnumHelpEntryParm;


    HKEY m_hHelpSessionTableKey;  
    /*static*/ HelpEntryCache m_HelpEntryCache;
    DWORD m_NumHelp;
    CComBSTR m_bstrFileName;
    CCriticalSection m_TableLock;

    DWORD m_dwEntryValidPeriod;

    static HRESULT
    RestoreHelpSessionTable( 
        HKEY hKey, 
        LPTSTR pszKeyName, 
        HANDLE userData 
    );

    static HRESULT
    EnumOpenHelpEntry(
        HKEY hKey,
        LPTSTR pszKeyName,
        HANDLE userData
    );
    
    HRESULT
    RestoreHelpSessionEntry(
        HKEY hKey,
        LPTSTR pszKeyName
    );

    HRESULT
    LoadHelpEntry(
        HKEY hKey,
        LPTSTR pszKeyName,
        PHELPENTRY* pHelpEntry
    );

public:

    void
    LockHelpTable() 
    {
        m_TableLock.Lock();
    }

    void
    UnlockHelpTable()
    {
        m_TableLock.UnLock();
    }

    CHelpSessionTable();
    ~CHelpSessionTable();


    // open help session table
    HRESULT
    OpenSessionTable(
        IN LPCTSTR pszFileName
    );

    // close help session table
    HRESULT
    CloseSessionTable();

    // Delete help session table
    HRESULT
    DeleteSessionTable();

    // open a help session entry
    HRESULT
    OpenHelpEntry(
        IN const CComBSTR& bstrHelpSession,
        OUT PHELPENTRY* pHelpEntry
    );

    // create a help session entry
    HRESULT
    CreateInMemoryHelpEntry(
        IN const CComBSTR& bstrHelpSession,
        OUT PHELPENTRY* pHelpEntry
    );

    HRESULT
    MemEntryToStorageEntry(
        IN PHELPENTRY pHelpEntry
    );


    // delete a help session entry
    HRESULT
    DeleteHelpEntry(
        IN const CComBSTR& bstrHelpSession
    );

    // remove help entry from cache
    HRESULT
    ReleaseHelpEntry(
        IN CComBSTR& bstrHelpSession
    );

    HRESULT
    EnumHelpEntry( 
        IN EnumHelpEntryCallback pFunc,
        IN HANDLE userData
    );

    DWORD
    NumEntries() { return m_NumHelp; }

    BOOL
    IsEntryExpired(
        PHELPENTRY pHelpEntry
    );
};
            

//
// __HelpEntry structure contains a single help entry.
//
struct __HelpEntry {

friend class CHelpSessionTable;

private:

    CHelpSessionTable& m_pHelpSessionTable;
    CCriticalSection m_Lock;
    HKEY m_hEntryKey;
    LONG m_RefCount;
    //LONG m_Status;

    HRESULT
    BackupEntry();

    HRESULT
    RestoreEntryFromBackup();

    HRESULT
    DeleteEntryBackup();
    

    LONG
    AddRef()
    {
        DebugPrintf(
                _TEXT("HelpEntry %p AddRef %d\n"),
                this,
                m_RefCount
            );
    
        return InterlockedIncrement( &m_RefCount );
    }

    LONG
    Release()
    {
        DebugPrintf(
                _TEXT("HelpEntry %p Release %d\n"),
                this,
                m_RefCount
            );

        if( 0 >= InterlockedDecrement( &m_RefCount ) )
        {
            MYASSERT( 0 == m_RefCount );
            delete this;
            return 0;
        }

        return m_RefCount;
    }

    HRESULT
    UpdateEntryValues(
        HKEY hKey
    );

    HRESULT
    LoadEntryValues(
        HKEY hKey
    );

    void
    EnableImmediateUpdate(
        BOOL bImmediate
        )
    /*++

    --*/
    {
        m_SessionName.EnableImmediateUpdate( bImmediate );
        m_SessionPwd.EnableImmediateUpdate( bImmediate );
        m_SessionDesc.EnableImmediateUpdate( bImmediate );
        //m_SessResolverGUID.EnableImmediateUpdate( bImmediate );
        m_EnableResolver.EnableImmediateUpdate( bImmediate );
        m_SessResolverBlob.EnableImmediateUpdate( bImmediate );
        m_UserSID.EnableImmediateUpdate( bImmediate );
        m_SessionRdsSetting.EnableImmediateUpdate( bImmediate );
        m_SessionId.EnableImmediateUpdate( bImmediate );
        m_CreationTime.EnableImmediateUpdate( bImmediate );
        m_ExpirationTime.EnableImmediateUpdate( bImmediate );
        m_ICSPort.EnableImmediateUpdate( bImmediate );
        m_IpAddress.EnableImmediateUpdate( bImmediate );
        m_SessionCreateBlob.EnableImmediateUpdate( bImmediate );
    }

    HKEY
    ConvertHelpEntry(
        HKEY hKey
        )
    /*++

    --*/
    {
        HKEY oldKey = m_hEntryKey;
        m_hEntryKey = hKey;

        m_SessionName.SetRegStoreHandle(m_hEntryKey);
        m_SessionPwd.SetRegStoreHandle(m_hEntryKey);
        m_SessionDesc.SetRegStoreHandle(m_hEntryKey);
        //m_SessResolverGUID.SetRegStoreHandle(m_hEntryKey);
        m_EnableResolver.SetRegStoreHandle(m_hEntryKey);
        m_SessResolverBlob.SetRegStoreHandle(m_hEntryKey);
        m_UserSID.SetRegStoreHandle(m_hEntryKey);
        m_SessionRdsSetting.SetRegStoreHandle(m_hEntryKey);
        m_SessionId.SetRegStoreHandle(m_hEntryKey);
        m_CreationTime.SetRegStoreHandle(m_hEntryKey);
        m_ExpirationTime.SetRegStoreHandle(m_hEntryKey);

        m_ICSPort.SetRegStoreHandle(m_hEntryKey);
        m_IpAddress.SetRegStoreHandle(m_hEntryKey);

        m_SessionCreateBlob.SetRegStoreHandle(m_hEntryKey);
        return oldKey;
    }

    HRESULT
    DeleteEntry()
    /*++

    --*/
    {
        DWORD dwStatus;

        CCriticalSectionLocker l(m_Lock);

        m_EntryStatus = REGVALUE_HELPSESSION_ENTRY_DELETED;
        dwStatus = m_EntryStatus.DBUpdateValue(m_hEntryKey);
    
        if( NULL != m_hEntryKey )
        {
            RegCloseKey( m_hEntryKey );
            m_hEntryKey = NULL;
        }

        MYASSERT( ERROR_SUCCESS == dwStatus );

        return HRESULT_FROM_WIN32(dwStatus);
    }

    HelpColumnValueBase<long> m_EntryStatus;
    HelpColumnValueBase<FILETIME> m_CreationTime;

    DWORD
    GetRefCount()
    {
        return m_RefCount;
    }


public:

    // Help Session ID
    HelpColumnValueBase<CComBSTR> m_SessionId;              

    // Name of help session.
    HelpColumnValueBase<CComBSTR> m_SessionName;

    // Help session password
    HelpColumnValueBase<CComBSTR> m_SessionPwd;

    // Help session description
    HelpColumnValueBase<CComBSTR> m_SessionDesc;

    // Help Session create blob
    HelpColumnValueBase<CComBSTR> m_SessionCreateBlob;

    // Resolver's CLSID
    // HelpColumnValueBase<CComBSTR> m_SessResolverGUID;

    // Enable resolver callback
    HelpColumnValueBase<long> m_EnableResolver;

    // Blob to be passed to resolver 
    HelpColumnValueBase<CComBSTR> m_SessResolverBlob;

    // SID of user that created this entry.
    HelpColumnValueBase<CComBSTR> m_UserSID;

    // Help session RDS setting.
    HelpColumnValueBase<REMOTE_DESKTOP_SHARING_CLASS> m_SessionRdsSetting;

    // Help Expiration date in absolute time
    HelpColumnValueBase<FILETIME> m_ExpirationTime;

    // ICS port
    HelpColumnValueBase<long> m_ICSPort;

    // IP Address when creating this ticket
    HelpColumnValueBase<CComBSTR> m_IpAddress;

    __HelpEntry( 
        IN CHelpSessionTable& Table,
        IN HKEY hKey,
        IN DWORD dwDefaultExpirationTime = ENTRY_VALID_PERIOD,
        IN BOOL bImmediateUpdate = FALSE
    ) : 
        m_pHelpSessionTable(Table), 
        m_hEntryKey(hKey),
        m_EntryStatus(m_Lock, hKey, COLUMNNAME_KEYSTATUS, REGVALUE_HELPSESSION_ENTRY_NEW, bImmediateUpdate),
        m_CreationTime(m_Lock, hKey, COLUMNNAME_CREATETIME, defaultCreationTime, bImmediateUpdate),
        m_SessionId(m_Lock, hKey, COLUMNNAME_SESSIONID, CComBSTR(), bImmediateUpdate),
        m_SessionName(m_Lock, hKey, COLUMNNAME_SESSIONNAME, CComBSTR(), bImmediateUpdate),
        m_SessionPwd(m_Lock, hKey, COLUMNNAME_SESSIONPWD, CComBSTR(), bImmediateUpdate, TRUE),
        m_SessionDesc(m_Lock, hKey, COLUMNNAME_SESSIONDESC, CComBSTR(), bImmediateUpdate),
        m_SessionCreateBlob(m_Lock, hKey, COLUMNNAME_SESSIONCREATEBLOB, CComBSTR(), bImmediateUpdate),
        //m_SessResolverGUID(m_Lock, hKey, COLUMNNAME_SESSIONRESOLVERID, CComBSTR(), bImmediateUpdate),
        m_EnableResolver(m_Lock, hKey, COLUMNNAME_ENABLESESSIONRESOLVER, FALSE, bImmediateUpdate),
        m_SessResolverBlob(m_Lock, hKey, COLUMNNAME_SESSIONRESOLVERBLOB, CComBSTR(), bImmediateUpdate),
        m_UserSID(m_Lock, hKey, COLUMNNAME_SESSIONUSERID, CComBSTR(), bImmediateUpdate),
        m_SessionRdsSetting(m_Lock, hKey, COLUMNNAME_RDSSETTING, DESKTOPSHARING_DEFAULT, bImmediateUpdate),
        m_ExpirationTime(m_Lock, hKey, COLUMNNAME_EXPIRATIONTIME, defaultCreationTime, bImmediateUpdate), 
        m_ICSPort(m_Lock, hKey, COLUMNNAME_ICSPORT, 0, bImmediateUpdate), 
        m_IpAddress(m_Lock, hKey, COLUMNNAME_IPADDRESS, CComBSTR(), bImmediateUpdate), 
        m_RefCount(1)
    {

        FILETIME ft;

        // Sets up entry creation time.
        GetSystemTimeAsFileTime( &ft );
        m_CreationTime = ft;

        // sets up default expiration time.

        time_t curTime;
        time(&curTime);

        // 24 hour timeout period
        curTime += (dwDefaultExpirationTime * 60 * 60 * 24);

        UnixTimeToFileTime( curTime, &ft );
        m_ExpirationTime = ft;


        #if DBG
        ULARGE_INTEGER ul1, ul2;

        ft = m_CreationTime;

        ul1.LowPart = ft.dwLowDateTime;
        ul1.HighPart = ft.dwHighDateTime;

        ft = (FILETIME)m_ExpirationTime;

        ul2.LowPart = ft.dwLowDateTime;
        ul2.HighPart = ft.dwHighDateTime;

        if( ul1.QuadPart >= ul2.QuadPart )
        {
            MYASSERT(FALSE);
        }
        #endif

        MYASSERT( FALSE == IsEntryExpired() );
    }

    ~__HelpEntry()
    {
        //m_pHelpSessionTable.ReleaseHelpEntry( (CComBSTR)m_SessionId );

        if( NULL != m_hEntryKey )
        {
            RegCloseKey( m_hEntryKey );
            m_hEntryKey = NULL;
        }
    }
    

    __HelpEntry&
    operator=(const __HelpEntry& newVal)
    {
        if( this != &newVal )
        {
            m_SessionId = newVal.m_SessionId;
            m_SessionName = newVal.m_SessionName;
            m_SessionPwd = newVal.m_SessionPwd;
            m_SessionDesc = newVal.m_SessionDesc;
            //m_SessResolverGUID = newVal.m_SessResolverGUID;
            m_EnableResolver = newVal.m_EnableResolver;
            m_SessResolverBlob = newVal.m_SessResolverBlob;
            m_UserSID = newVal.m_UserSID;
            m_CreationTime = newVal.m_CreationTime;
            m_SessionRdsSetting = newVal.m_SessionRdsSetting;
            m_ExpirationTime = newVal.m_ExpirationTime;
            m_ICSPort = newVal.m_ICSPort;
            m_IpAddress = newVal.m_IpAddress;
            m_SessionCreateBlob = newVal.m_SessionCreateBlob;
        }

        return *this;
    }

    HRESULT
    BeginUpdate()
    /*++

    Routine Description:

        Begin update save a copied of entries and disable immediate
        registry value update mode.

    Parameters:

        None.

    Returns:
        
        S_OK or error code.

    --*/
    {   
        HRESULT hRes = S_OK;

        m_Lock.Lock();

        if( NULL != m_hEntryKey )
        {
            hRes = BackupEntry();
            if( FAILED(hRes) )
            {
                // unlock entry if can't save 
                // a backup copy
                m_Lock.UnLock();
            }
            else
            {
                // ignore individual value update mode and
                // set to no immediate update
                EnableImmediateUpdate(FALSE);
            }
        }

        // note, we only commit changes to registry when caller
        // invoke CommitUpdate() so we don't need to mark entry
        // dirty in registry now.
        return hRes;
    }

    HRESULT
    CommitUpdate()
    /*++
    
    Routine Description:

        Commit all changes to registry.

    Parameters:

        None.

    Returns:

        S_OK or error code.

    --*/
    {
        HRESULT hRes = S_OK;

        if( NULL != m_hEntryKey )
        {
            hRes = UpdateEntryValues( m_hEntryKey );
        }

        // ignore individual value update mode and
        // set to immediate update
        EnableImmediateUpdate(TRUE);

        // let caller decide what to do when fail to update value.
        UnlockEntry();
        return hRes;
    }

    HRESULT
    AbortUpdate()
    /*++

    Routine Description:

        Abort changes to value and restore back to 
        original value.

    Parameters:

        None.

    Returns:

        S_OK or error code.

    --*/
    {
        HRESULT hRes;

        if( NULL != m_hEntryKey )
        {
            hRes = RestoreEntryFromBackup();
        }

        EnableImmediateUpdate(TRUE);

        // let caller decide what to do when restore failed.
        UnlockEntry();
        return hRes;
    }

    HRESULT
    Close()
    /*++

    Routine Description:

        Close a help entry and remove from cache, entry is undefined
        after close.

    Parameters:

        None.

    Returns:

        S_OK or error code.

    --*/
    {
        HRESULT hRes;

        hRes = m_pHelpSessionTable.ReleaseHelpEntry( (CComBSTR)m_SessionId );

        if( FAILED(hRes) )
        {
            if( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND) != hRes )
            {
                MYASSERT(FALSE);
            }
            
            Release();
        }

        // Always S_OK
        return S_OK;
    }

    HRESULT
    Delete()
    /*++

    Routine Description:

        Delete a help entry from table, entry is undefined after delete.

    Parameters:

        None.

    Returns:

        S_OK or error code.

    --*/
    {
        HRESULT hRes;

        // ignore error since restore will delete 'deleted' entry
        hRes = m_pHelpSessionTable.DeleteHelpEntry( (CComBSTR)m_SessionId );

        if( FAILED(hRes) )
        {
            //MYASSERT(FALSE);
            Release();
        }

        return hRes;
    }

    HRESULT
    Refresh() 
    /*++

    Routine Description:

        Reload entry from registry.

    Parameters:

        None.

    Returns:

        S_OK or error code.

    --*/
    {
        HRESULT hRes;

        LockEntry();
        hRes = LoadEntryValues(m_hEntryKey);
        UnlockEntry();

        return hRes;
    }
   
    void
    LockEntry()
    /*++

    Routine Description:

        Lock entry for update.

    Parameters:

        None.

    Returns:

        None.

    --*/
    {
        m_Lock.Lock();
    }

    void
    UnlockEntry()
    /*++

    Routine Description:

        Unlock entry.

    Parameters:

        None.

    Returns:

        None.

    --*/
    {
        m_Lock.UnLock();
    }

    //
    // Check if entry is locked for update
    BOOL
    IsUpdateInProgress();

    //
    // Get CRITICAL_SECTION used in current entry, this
    // routine is used by help session object to save resource
    CCriticalSection&
    GetLock()
    {
        return m_Lock;
    }

    // TRUE if entry is memory only, FALSE if entry
    // is backup to registry
    BOOL
    IsInMemoryHelpEntry()
    {
        return (NULL == m_hEntryKey);
    }

    BOOL
    IsEntryExpired();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\myassert.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    myassert.h

Abstract:

    define for MYASSERT

Author:

    HueiWang    2/17/2000

--*/
#ifndef __MYASSERT_H__

#define MYASSERT(exp)   ASSERT(exp)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\policy.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    policy.h

Abstract:

    Policy related function

Author:

    HueiWang    5/2/2000

--*/
#ifndef __RDSPOLICY_H__
#define __RDSPOLICY_H__

#include <windows.h>
#include <tchar.h>
#include <regapi.h>
#include <winsta.h>
#include <wtsapi32.h>
#include "helper.h"

#include "RAssistance.h"

//
// Registry key location for Salem related policy
//

#ifndef __WIN9XBUILD__

#define RDS_GROUPPOLICY_SUBTREE     TS_POLICY_SUB_TREE
#define RDS_MACHINEPOLICY_SUBTREE   REG_CONTROL_GETHELP
#define RDS_ALLOWGETHELP_VALUENAME  POLICY_TS_REMDSK_ALLOWTOGETHELP

#else

//
// TODO - for Legacy platform not including TS5, decide where this shoule be
//
//
// REGAPI uses L"", can't build on Win9x so we redefine here...
//
#define RDS_GROUPPOLICY_SUBTREE     _TEXT("Software\\Policies\\Microsoft\\Windows NT\\TerminalServices")
#define RDS_MACHINEPOLICY_SUBTREE   _TEXT("Software\\Microsoft\\Remote Desktop\\Policies")
#define RDS_ALLOWGETHELP_VALUENAME  _TEXT("fAllowToGetHelp")

#endif

#define OLD_REG_CONTROL_GETHELP REG_CONTROL_SALEM L"\\Policies"


#define RDS_HELPENTRY_VALID_PERIOD  _TEXT("ValidPeriod")

#define POLICY_ENABLE   1
#define POLICY_DISABLE  0


#ifdef __cplusplus
extern "C" {
#endif

BOOL
IsHelpAllowedOnLocalMachine(
    IN ULONG ulSessionID
);

BOOL 
IsUserAllowToGetHelp( 
    IN ULONG ulSessionId,
    IN LPCTSTR pszUserSid
);

DWORD
GetSystemRDSLevel(
    IN ULONG ulSessionId,
    OUT REMOTE_DESKTOP_SHARING_CLASS* pSharingLevel
);

DWORD
GetUserRDSLevel(
    IN ULONG ulSessionId,
    OUT REMOTE_DESKTOP_SHARING_CLASS* pLevel
);

DWORD
ConfigSystemGetHelp(
    IN BOOL bEnable
);

DWORD
ConfigSystemRDSLevel(
    IN REMOTE_DESKTOP_SHARING_CLASS level
);

DWORD
ConfigUserSessionRDSLevel(
    IN ULONG ulSessionId,
    IN REMOTE_DESKTOP_SHARING_CLASS level
);

DWORD
EnableWorkstationTSConnection(
    IN BOOL bEnable,
    IN OUT DWORD* settings
);

DWORD
GetPolicyAllowGetHelpSetting( 
    HKEY hKey,
    LPCTSTR pszKeyName,
    LPCTSTR pszValueName,
    IN DWORD* value
);

//HRESULT
//PolicyGetAllowUnSolicitedHelp( 
//    BOOL* bAllow
//);

HRESULT
PolicyGetMaxTicketExpiry( 
    LONG* value
);


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\map.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    map.h

Abstract:

    Implementation of MAP<> template based on STL's map<>

Author:

    HueiWang    2/17/2000

--*/
#ifndef __MAP_H__
#define __MAP_H__

#include "tsstl.h"
#include "locks.h"


template<class KEY, class T, class Pred = less<KEY>, class A = allocator<T> >
class MAP : public map<KEY, T, Pred, A> {
private:

    //
    // Difference between this MAP<> and STL's map<> is that this
    // template protect data via critical section, refer to STL's map<>
    // for detail of member function.
    //


    // critical section to lock the tree.
    CCriticalSection m_CriticalSection;

    // 
    //map<KEY, T, Pred, A>::iterator m_it;    

public:

    // LOCK_ITERATOR, derive from STL's map<>::iterator
    typedef struct __Iterator : map<KEY, T, Pred, A>::iterator {
        CCriticalSection& lock;

        __Iterator(
            const __Iterator& it
            ) : lock(it.lock)
        /*++

        --*/
        {
            lock.Lock();
            *this = it;
        }

        __Iterator( 
                CCriticalSection& m, 
                iterator it 
            ) : 
            lock(m) 
        { 
            lock.Lock();
            *(map<KEY, T, Pred, A>::iterator *)this = it;
        }

        ~__Iterator() 
        { 
            lock.UnLock(); 
        }

        __Iterator&
        operator=(const __Iterator& it )
        {
            if( this != &it )
            {
                // No additional Lock() here since 
                // our constructor already holding a lock
                *(map<KEY, T, Pred, A>::iterator *)this = (map<KEY, T, Pred, A>::iterator)it;
            }

            return *this;
        }

    } LOCK_ITERATOR;

    LOCK_ITERATOR
    begin() 
    /*++

    overload map<>::begin()

    --*/
    {
        // Double lock is necessary, caller could do
        // <...>::LOCK_ITERATOR it = <>.find();
        // and before LOCK_ITERATOR destructor got call, call might do
        // it = <>.find() again, that will increase lock count by 1 and
        // no way to release it.
        CCriticalSectionLocker lock( m_CriticalSection );
        return LOCK_ITERATOR(m_CriticalSection, map<KEY, T, Pred, A>::begin());
    }

    explicit 
    MAP(
        const Pred& comp = Pred(), 
        const A& al = A()
        ) : map<KEY, T, Pred, A>( comp, al ) 
    /*++

    --*/
    {
        //m_it = end();
    }

    MAP(const map& x) : map(x)
    {
        m_it = end();
    }
    
    MAP(
        const value_type *first, 
        const value_type *last,
        const Pred& comp = Pred(),
        const A& al = A()
        ) : map( first, last, comp, al )
    {
        //m_it = end();
    }

    //virtual ~MAP()
    //{
    //    map<KEY, T, Pred, A>::~map();
    //}

    //---------------------------------------------------------
    void
    Cleanup()
    {
        erase_all();
    }

    //---------------------------------------------------------
    void
    Lock()
    /*++

        Explicity lock the data tree

    --*/
    {
        m_CriticalSection.Lock();
    }

    //---------------------------------------------------------
    void
    Unlock()
    /*++
        
        lock lock the data tree

    --*/
    {        
        m_CriticalSection.UnLock();
    }

    //---------------------------------------------------------
    bool
    TryLock()
    /*++
    
        Try locking the tree, same as Win32's TryEnterCriticalSection().

    --*/
    {
        return m_CriticalSection.TryLock();
    }

    //---------------------------------------------------------
    A::reference operator[]( 
        const KEY& key 
        )
    /*++

        Overload map<>::operator[] to lock tree.

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        return map<KEY, T, Pred, A>::operator[](key);
    }

    //---------------------------------------------------------
    pair<iterator, bool> 
    insert(iterator it, const value_type& x)
    /*++

        overload map<>;;insert()

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        return map<KEY, T, Pred, A>::insert(Key);
    }

    //---------------------------------------------------------
    void
    insert(
        const value_type* first, 
        const value_type* last
        )
    /*++

        overload map<>::insert().

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        map<KEY, T, Pred, A>::insert(first, lase);
    }

    //---------------------------------------------------------
    LOCK_ITERATOR
    erase( 
        iterator it 
        )
    /*++

        overload map<>::erase()

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        return LOCK_ITERATOR(m_CriticalSection, map<KEY, T, Pred, A>::erase(it));
    }

    //---------------------------------------------------------
    void
    erase_all()
    /*++

        delete all data in the tree

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        erase( map<KEY, T, Pred, A>::begin(), end() );
        return;
    }
    
    //---------------------------------------------------------
    LOCK_ITERATOR
    erase(
        iterator first, 
        iterator last
        )
    /*++

        Overload map<>::erase()

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        return LOCK_ITERATOR(m_CriticalSection, map<KEY, T, Pred, A>::erase(first, last));
    }

    //---------------------------------------------------------
    size_type 
    erase(
        const KEY& key
        )
    /*++
    
        overload map<>::erase()

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        return map<KEY, T, Pred, A>::erase(key);
    }

    LOCK_ITERATOR
    find( 
        const KEY& key 
        )
    /*++
    
        overload map<>::find()

    --*/
    {
        CCriticalSectionLocker lock( m_CriticalSection );
        return LOCK_ITERATOR( m_CriticalSection, map<KEY, T, Pred, A>::find(key) );
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\policy.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    policy.cpp

Abstract:

    RDS Policy related function

Author:

    HueiWang    5/2/2000

--*/
#include "stdafx.h"
#include "policy.h"


#ifndef __WIN9XBUILD__

extern "C" BOOLEAN RegDenyTSConnectionsPolicy();

typedef struct __RDSLevelShadowMap {
    SHADOWCLASS shadowClass;
    REMOTE_DESKTOP_SHARING_CLASS rdsLevel;
} RDSLevelShadowMap;

static const RDSLevelShadowMap ShadowMap[] = {
    { Shadow_Disable,               NO_DESKTOP_SHARING },                       // No RDS sharing
    { Shadow_EnableInputNotify,     CONTROLDESKTOP_PERMISSION_REQUIRE },        // Interact with user permission
    { Shadow_EnableInputNoNotify,   CONTROLDESKTOP_PERMISSION_NOT_REQUIRE },    // Interact without user permission
    { Shadow_EnableNoInputNotify,   VIEWDESKTOP_PERMISSION_REQUIRE},            // View with user permission
    { Shadow_EnableNoInputNoNotify, VIEWDESKTOP_PERMISSION_NOT_REQUIRE }        // View without user permission
};


DWORD
GetPolicyAllowGetHelpSetting( 
    HKEY hKey,
    LPCTSTR pszKeyName,
    LPCTSTR pszValueName,
    IN DWORD* value
    )
/*++

Routine Description:

    Routine to query policy registry value.

Parameters:

    hKey : Currently open registry key.
    pszKeyName : Pointer to a null-terminated string containing 
                 the name of the subkey to open. 
    pszValueName : Pointer to a null-terminated string containing 
                   the name of the value to query
    value : Pointer to DWORD to receive GetHelp policy setting.

Returns:

    ERROR_SUCCESS or error code from RegOpenKeyEx().

--*/
{
    DWORD dwStatus;
    HKEY hPolicyKey = NULL;
    DWORD dwType;
    DWORD cbData;

    //
    // Open registry key for system policy
    //
    dwStatus = RegOpenKeyEx(
                        hKey,
                        pszKeyName,
                        0,
                        KEY_READ,
                        &hPolicyKey
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        // query value
        cbData = 0;
        dwType = 0;
        dwStatus = RegQueryValueEx(
                                hPolicyKey,
                                pszValueName,
                                NULL,
                                &dwType,
                                NULL,
                                &cbData
                            );

        if( ERROR_SUCCESS == dwStatus )
        {
            if( REG_DWORD == dwType )
            {
                cbData = sizeof(DWORD);

                // our registry value is REG_DWORD, if different type,
                // assume not exist.
                dwStatus = RegQueryValueEx(
                                        hPolicyKey,
                                        pszValueName,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)value,
                                        &cbData
                                    );

                ASSERT( ERROR_SUCCESS == dwStatus );
            }
            else
            {
                // bad registry key type, assume
                // key does not exist.
                dwStatus = ERROR_FILE_NOT_FOUND;
            }               
        }

        RegCloseKey( hPolicyKey );
    }

    return dwStatus;
}        


SHADOWCLASS
MapRDSLevelToTSShadowSetting(
    IN REMOTE_DESKTOP_SHARING_CLASS RDSLevel
    )
/*++

Routine Description:

    Convert TS Shadow settings to our RDS sharing level.

Parameter:

    TSShadowClass : TS Shadow setting.

Returns:

    REMOTE_DESKTOP_SHARING_CLASS

--*/
{
    SHADOWCLASS shadowClass;

    for( int i=0; i < sizeof(ShadowMap)/sizeof(ShadowMap[0]); i++)
    {
        if( ShadowMap[i].rdsLevel == RDSLevel )
        {
            break;
        }
    }

    if( i < sizeof(ShadowMap)/sizeof(ShadowMap[0]) )
    {
        shadowClass = ShadowMap[i].shadowClass;
    }
    else
    {
        MYASSERT(FALSE);
        shadowClass = Shadow_Disable;
    }

    return shadowClass;
}


REMOTE_DESKTOP_SHARING_CLASS
MapTSShadowSettingToRDSLevel(
    SHADOWCLASS TSShadowClass
    )
/*++

Routine Description:

    Convert TS Shadow settings to our RDS sharing level.

Parameter:

    TSShadowClass : TS Shadow setting.

Returns:

    REMOTE_DESKTOP_SHARING_CLASS

--*/
{
    REMOTE_DESKTOP_SHARING_CLASS level;

    for( int i=0; i < sizeof(ShadowMap)/sizeof(ShadowMap[0]); i++)
    {
        if( ShadowMap[i].shadowClass == TSShadowClass )
        {
            break;
        }
    }

    if( i < sizeof(ShadowMap)/sizeof(ShadowMap[0]) )
    {
        level = ShadowMap[i].rdsLevel;
    }
    else
    {
        MYASSERT(FALSE);
        level = NO_DESKTOP_SHARING;
    }

    return level;
}


DWORD
MapSessionIdToWinStationName(
    IN ULONG ulSessionID,
    OUT PWINSTATIONNAME pWinstationName
    ) 
/*++

Routine Description:

    Find out TS winstation name for the session specified.

Parameters:

    ulSessionID : TS Session ID to query.
    pWinstationName : Pointer to WINSTATIONNAME to receive 
                      name of WinStation for Session ID specified.

Returns:

    ERROR_SUCCESS or Error code.

-*/
{
    BOOL bSuccess;
    DWORD dwStatus;
    LPTSTR pBuffer = NULL;
    DWORD bytesReturned;

    bSuccess = WTSQuerySessionInformation(
                                    WTS_CURRENT_SERVER,
                                    ulSessionID,
                                    WTSWinStationName,
                                    &pBuffer,
                                    &bytesReturned
                                );

    if( TRUE == bSuccess )
    {
        LPTSTR pszChr;

        //
        // WINSTATIONNAME returned from WTSQuerySessionInformation 
        // has '#...' appended to it, we can't use it to query 
        // WINSTATION configuration as RegApi look for exact WINSTATION
        // name in registry and so it will return default value.
        //
        pszChr = _tcschr( pBuffer, _TEXT('#') );
        if( NULL != pszChr )
        {
            *pszChr = _TEXT('\0');
        }

        ZeroMemory( pWinstationName, sizeof( WINSTATIONNAME ) );
        CopyMemory( pWinstationName, pBuffer, bytesReturned );
        dwStatus = ERROR_SUCCESS;
    }
    else
    {
        dwStatus = GetLastError();
    }

    if( NULL != pBuffer )
    {
        WTSFreeMemory( pBuffer );
    }

    return dwStatus;
}

DWORD
GetWinStationConfig(
    IN ULONG ulSessionId,
    OUT WINSTATIONCONFIG2* pConfig
    )
/*++

Routine Description:

    Retrieve WINSTATIONCONFIG2 for session specified.

Parameters:

    ulSessionId : TS Session to query.
    pConfig : Pointer to WINSTATIONCONIF2 to receive result.

Returns:

    ERROR_SUCCESS or error code.
    
--*/
{
    WINSTATIONNAME WinStationName;
    DWORD dwStatus;
    ULONG length = 0;
    
    dwStatus = MapSessionIdToWinStationName( 
                                        ulSessionId,
                                        WinStationName
                                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        dwStatus = RegWinStationQuery(  
                                NULL, 
                                WinStationName, 
                                pConfig,
                                sizeof(WINSTATIONCONFIG2),
                                &length
                            );
    }

    return dwStatus;
}

#endif
            
BOOL 
IsUserAllowToGetHelp( 
    IN ULONG ulSessionId,
    IN LPCTSTR pszUserSid
    )
/*++

Routine Description:

    Determine if caller can 'GetHelp'

Parameters:

    ulSessionId : User's TS logon ID.
    pszUserSid : User's SID in textual form.

Returns:

    TRUE/FALSE

Note:

    Must have impersonate user first.

--*/
{
    BOOL bAllow;
    DWORD dwStatus;
    DWORD dwAllow;
    LPTSTR pszUserHive = NULL;

    MYASSERT( NULL != pszUserSid );

    //
    // Must be able to GetHelp from machine
    //
    bAllow = TSIsMachinePolicyAllowHelp();
    if( TRUE == bAllow )
    {
        pszUserHive = (LPTSTR)LocalAlloc( 
                                    LPTR, 
                                    sizeof(TCHAR) * (lstrlen(pszUserSid) + lstrlen(RDS_GROUPPOLICY_SUBTREE) + 2 )
                                );

        lstrcpy( pszUserHive, pszUserSid );
        lstrcat( pszUserHive, _TEXT("\\") );
        lstrcat( pszUserHive, RDS_GROUPPOLICY_SUBTREE );    

        //
        // Query user level AllowGetHelp setting.
        dwStatus = GetPolicyAllowGetHelpSetting( 
                                            HKEY_USERS,
                                            pszUserHive,
                                            RDS_ALLOWGETHELP_VALUENAME,
                                            &dwAllow
                                        );

        if( ERROR_SUCCESS == dwStatus )
        {
            bAllow = (POLICY_ENABLE == dwAllow);
        }
        else
        {
            // no configuration for this user, assume GetHelp
            // is enabled.
            bAllow = TRUE;
        }
    }

    if( NULL != pszUserHive )
    {
        LocalFree( pszUserHive );
    }

    return bAllow;
}

DWORD
GetSystemRDSLevel(
    IN ULONG ulSessionId,
    OUT REMOTE_DESKTOP_SHARING_CLASS* pSharingLevel
    )
/*++

Routine Description:

    Retrieve policy setting for remote desktop sharing level.

Parameters:

    ulSessionId : TS session ID, unuse if TS group policy is set.
    pSharingLever : Pointer to REMOTE_DESKTOP_SHARING_CLASS to receive 
                    machine RDS level.

Returns:

    REMOTE_DESKTOP_SHARING_CLASS

--*/
{
    DWORD dwStatus;

#ifndef __WIN9XBUILD__

    WINSTATIONCONFIG2 WSConfig;
    ULONG length = 0;

    // 
    // TS Group Policy does not have machine level shadow 
    // setting, only TSCC has this setting, and TSCC setting
    // is based on WINSTATION not entire machine.
    // 
    // We can't query TS since TS already merger all policy
    // setting into USERCONFIG which might not be correct
    //    
    
    dwStatus = GetWinStationConfig(
                                ulSessionId,
                                &WSConfig
                            );

    
    if( ERROR_SUCCESS == dwStatus )
    {
        if( TRUE == WSConfig.Config.User.fInheritShadow )
        {
            // Shadow config is inherite from user properies
            // so we query user level setting.
            dwStatus = GetUserRDSLevel( ulSessionId, pSharingLevel );
        }
        else
        {
            *pSharingLevel = MapTSShadowSettingToRDSLevel( WSConfig.Config.User.Shadow );
        }
    }

#else

    // TODO - revisit this for Win9x Build
    MYASSERT(FALSE);
    *pSharingLevel = CONTROLDESKTOP_PERMISSION_REQUIRE;
    dwStatus = ERROR_SUCCESS;

#endif
    
    return dwStatus;
}


DWORD
GetUserRDSLevel(
    IN ULONG ulSessionId,
    OUT REMOTE_DESKTOP_SHARING_CLASS* pLevel
    )
/*++

    same as GetSystemRDSLevel() except it retrieve currently logon user's
    RDS level.

--*/
{
    DWORD dwStatus;

#ifndef __WIN9XBUILD__

    BOOL bSuccess;
    WINSTATIONCONFIG WSConfig;
    DWORD dwByteReturned;

    memset( &WSConfig, 0, sizeof(WSConfig) );
    
    // Here we call WInStationQueryInformation() since WTSAPI require 
    // few calls to get the same result
    bSuccess = WinStationQueryInformation(
                                        WTS_CURRENT_SERVER,
                                        ulSessionId,
                                        WinStationConfiguration,
                                        &WSConfig,
                                        sizeof( WSConfig ),
                                        &dwByteReturned
                                    );


    if( TRUE == bSuccess )    
    {
        dwStatus = ERROR_SUCCESS;
        *pLevel = MapTSShadowSettingToRDSLevel( WSConfig.User.Shadow );
    }
    else
    {
        dwStatus = GetLastError();
    }

#else

    // TODO - revisit this for Win9x Build
    MYASSERT(FALSE);
    *pLevel = CONTROLDESKTOP_PERMISSION_REQUIRE;
    dwStatus = ERROR_SUCCESS;

#endif

    return dwStatus;
}


DWORD
ConfigSystemGetHelp(
    BOOL bEnable
    )
/*++

Routine Description:

    Enable/disable 'GetHelp' on local machine.

Parameters:

    bEnable : TRUE to enable, FALSE otherwise.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bMember;
    HKEY hKey = NULL;
    DWORD dwValue;
    BOOL bAllowHelp;

#ifndef __WIN9XBUILD__

    dwStatus = IsUserAdmin( &bMember );
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    if( FALSE == bMember )
    {
        dwStatus = ERROR_ACCESS_DENIED;
        goto CLEANUPANDEXIT;
    }

#endif

    // We only check if Group Policy has this setting and no
    // checking on TSCC deny connection setting since
    // TSCC set WINSTATION deny connection not entire machine
    // and we can't be sure which connection that connection 
    // is denied, so it is still possible that GetHelp is enabled 
    // but WINSTATION's deny connection is still set to TRUE
    // in this case, no help is available even this funtion
    // return SUCCEEDED.
    

    // verify no group policy on this
    dwStatus = GetPolicyAllowGetHelpSetting(
                                    HKEY_LOCAL_MACHINE,
                                    RDS_GROUPPOLICY_SUBTREE,
                                    RDS_ALLOWGETHELP_VALUENAME,
                                    &dwValue
                                );

    if( ERROR_SUCCESS == dwStatus )
    {
        dwStatus = ERROR_ACCESS_DENIED;
    }
    else
    {
        //
        // Write to registry
        //
        dwStatus = RegCreateKeyEx(
                                HKEY_LOCAL_MACHINE,
                                RDS_MACHINEPOLICY_SUBTREE,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                NULL                            
                            );

        if( ERROR_SUCCESS == dwStatus )
        {
            dwValue = (bEnable) ? POLICY_ENABLE : POLICY_DISABLE;

            dwStatus = RegSetValueEx(
                                hKey,
                                RDS_ALLOWGETHELP_VALUENAME,
                                0,
                                REG_DWORD,
                                (LPBYTE) &dwValue,
                                sizeof(DWORD)
                            );
        }   

        MYASSERT( ERROR_SUCCESS == dwStatus );
    }

#ifndef __WIN9XBUILD__

CLEANUPANDEXIT:

#endif
 
    if( NULL != hKey )
    {
        RegCloseKey(hKey);
    }

    return dwStatus;
}

DWORD
ConfigSystemRDSLevel(
    IN REMOTE_DESKTOP_SHARING_CLASS level
    )
/*++

Routine Description:

    This routine set machine wide RDS level.

Parameters:

    level : new RDS level.

Returns:

    ERROR_SUCCESS or error code.
--*/
{
    //
    // TODO - revisit this, on Win2K and Whilster,
    // group policy override this setting via User Properties
    // or if group policy is not set, TSCC can override this.
    // and since a user account always has some default value
    // for this, so we have no way to determine whether this is
    // a default or else, so we simple return ERROR for Win2K 
    // and Whilster platform.
    //

    //
    // TODO : For legacy platform, Win9x/NT40/TS40, we need to figure 
    // out how/where poledit put this setting, for now, 
    // just return error.
    //
    DWORD dwStatus = ERROR_INVALID_FUNCTION;
    return dwStatus;
}


DWORD
ConfigUserSessionRDSLevel(
    IN ULONG ulSessionId,
    IN REMOTE_DESKTOP_SHARING_CLASS level
    )
/*++

--*/
{
#ifndef __WIN9XBUILD__

    WINSTATIONCONFIG winstationConfig;
    SHADOWCLASS shadowClass = MapRDSLevelToTSShadowSetting( level );
    BOOL bSuccess;
    DWORD dwLength;
    DWORD dwStatus;

    memset( &winstationConfig, 0, sizeof(winstationConfig) );

    bSuccess = WinStationQueryInformation(
                                    WTS_CURRENT_SERVER,
                                    ulSessionId,
                                    WinStationConfiguration,
                                    &winstationConfig,
                                    sizeof(winstationConfig),
                                    &dwLength
                                );

    if( TRUE == bSuccess )
    {
        winstationConfig.User.Shadow = shadowClass;
    
        bSuccess = WinStationSetInformation(
                                        WTS_CURRENT_SERVER,
                                        ulSessionId,
                                        WinStationConfiguration,
                                        &winstationConfig,
                                        sizeof(winstationConfig)
                                    );
    }

    if( TRUE == bSuccess )
    {
        dwStatus = ERROR_SUCCESS;
    }
    else
    {
        dwStatus = GetLastError();
    }

    return dwStatus;

#else

    return ERROR_SUCCESS;

#endif    
}

#if 0

HRESULT
PolicyGetAllowUnSolicitedHelp( 
    BOOL* bAllow
    )
/*++

--*/
{
    HRESULT hRes;
    CComPtr<IRARegSetting> IRegSetting;
    
    hRes = IRegSetting.CoCreateInstance( CLSID_RARegSetting );
    if( SUCCEEDED(hRes) )
    {
        hRes = IRegSetting->get_AllowUnSolicited(bAllow);
    }

    MYASSERT( SUCCEEDED(hRes) );

    return hRes;
}

#endif

HRESULT
PolicyGetMaxTicketExpiry( 
    LONG* value
    )
/*++

--*/
{
    HRESULT hRes;
    CComPtr<IRARegSetting> IRegSetting;
    
    hRes = IRegSetting.CoCreateInstance( CLSID_RARegSetting );
    if( SUCCEEDED(hRes) )
    {
        hRes = IRegSetting->get_MaxTicketExpiry(value);
    }

    MYASSERT( SUCCEEDED(hRes) );
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\sessenum.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SessEnum.h

Abstract:

    SessEnum.h : Declaration of the CRemoteDesktopHelpSessionEnum

Author:

    HueiWang    2/17/2000

--*/

#ifndef __REMOTEDESKTOPHELPSESSIONENUM_H_
#define __REMOTEDESKTOPHELPSESSIONENUM_H_

#include "resource.h"       // main symbols
//#include "tsstl.h"
//#include "HelpSess.h"


typedef list< RemoteDesktopHelpSessionObj* > HelpSessionObjList;

//
// Why implement our own collection/enumerator - 
//
// 1) IEnumOnSTLImpl has a copy of data in m_pCollection,
//    ICollectionOnSTLImpl has another copy of data in m_col1.
// 2) _NewEnum() returns IUnknown*, Clone() returns IRemoteDesktopHelpSessionEnum.
// 3) Item() properties is VARIANT* but Next() return array of interface.
// 4) Can't combine two enumerator/collection type, compiler doesn't like
//    it.
// 5) ATL bug in enumerator, if empty list, it returns E_FAILED instead of
//    S_FALSE.
//

/////////////////////////////////////////////////////////////////////////////
// CRemoteDesktopHelpSessionEnum
class ATL_NO_VTABLE CRemoteDesktopHelpSessionEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CRemoteDesktopHelpSessionEnum, &CLSID_RemoteDesktopHelpSessionEnum>,
	public IDispatchImpl<IRemoteDesktopHelpSessionEnum, &IID_IRemoteDesktopHelpSessionEnum, &LIBID_RDSESSMGRLib>
{

friend class CRemoteDesktopHelpSessionMgr;
friend class CRemoteDesktopHelpSessionEnum;

public:
	CRemoteDesktopHelpSessionEnum()
	{
	}

    ~CRemoteDesktopHelpSessionEnum()
    {
        MYASSERT(0 == m_pcollection.size() );
    }

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPHELPSESSIONENUM)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRemoteDesktopHelpSessionEnum)
    COM_INTERFACE_ENTRY(IRemoteDesktopHelpSessionEnum)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


    HRESULT
    FinalConstruct()
    {
        _Module.AddRef();

        DebugPrintf( _TEXT("Module AddRef by CRemoteDesktopHelpSessionEnum()...\n") );
        return S_OK;
    }

    void
    FinalRelease()
    {
        HelpSessionObjList::iterator it;
        for(it = m_pcollection.begin(); it != m_pcollection.end(); it++)
        {
            (*it)->Release();
        }

        m_pcollection.erase( m_pcollection.begin(), m_pcollection.end() );
        _Module.Release();

        DebugPrintf( _TEXT("Module Release by CRemoteDesktopHelpSessionEnum()...\n") );
    }


// IRemoteDesktopHelpSessionEnum
public:

	STDMETHOD(get__NewEnum)(
        /*[out, retval]*/ LPUNKNOWN *pVal
    );

	STDMETHOD(get_Item)(
        /*[in]*/ long index, 
        /*[out, retval]*/ VARIANT* pItem
    );

	STDMETHOD(get_Count)(
        /*[out, retval]*/ long *pVal
    );

	STDMETHOD(Clone)(
        /*[out]*/ IRemoteDesktopHelpSessionEnum** ppEnum
    );

	STDMETHOD(Skip)(
        /*[in]*/ ULONG cCount
    );

	STDMETHOD(Reset)();

	STDMETHOD(Next)(
        /*[in]*/ ULONG uCount, 
        /*[out, size_is(uCount), length_is(*pcFetched)]*/ IRemoteDesktopHelpSession** ppIRemoteDesktopHelpSession, 
        /*[out]*/ ULONG* pcFetched
    );

private:
    HRESULT
    Add(
        RemoteDesktopHelpSessionObj* pObj
        )
    /*++

    --*/
    {
        m_pcollection.push_back(pObj);

        //
        // We just store copy of interface in our list so 
        // add one more reference to this Help object
        //
        pObj->AddRef();
        return S_OK;
    }

    HelpSessionObjList m_pcollection;
    HelpSessionObjList::iterator m_iter;
};

#endif //__REMOTEDESKTOPHELPSESSIONENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\sessenum.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SessEnum.cpp 

Abstract:

    SessEnum.cpp : Implementation of CRemoteDesktopHelpSessionEnum

Author:

    HueiWang    2/17/2000

--*/

#include "stdafx.h"
#include "Sessmgr.h"
#include "helpmgr.h"
#include "helpsess.h"
#include "SessEnum.h"

/////////////////////////////////////////////////////////////////////////////
//
// CRemoteDesktopHelpSessionEnum
//
STDMETHODIMP 
CRemoteDesktopHelpSessionEnum::Next(
    IN ULONG uCount, 
    IN OUT IRemoteDesktopHelpSession **ppIHelpSession, 
    IN ULONG *pcFetched
    )
/*++

Routine Description:

    Retrieve number of items, refer to standard COM enumerator for detail.

Parameters:

    uCount : Number of item to retrieves.
    ppIHelpSession : Pointer to buffer to receive items, buffer must be 
                     big enough to hold at least uCount items.
    pcFetched : actual number of item returned.

Returns:

    E_POINTER   Invalid input parameter
    S_FALSE     No more item in the list or number items retrieve is less than uCount.
    S_OK        Success.

    Error code from QueryInterface(), normally, internal error.

Note:


    Code modified from ATL's IEnumOnSTLImpl::Next()
    
--*/
{
	if( ppIHelpSession == NULL || uCount != 1 && pcFetched == NULL )
    {
        return E_POINTER;
    }

    if( m_iter == m_pcollection.end() )
    {
        return S_FALSE;
    }

    ULONG nActual = 0;
    HRESULT hRes = S_OK;
    IRemoteDesktopHelpSession** pelt = ppIHelpSession;

    while( SUCCEEDED(hRes) && m_iter != m_pcollection.end() && nActual < uCount )
    {
        hRes = (*m_iter)->QueryInterface( 
                                        IID_IRemoteDesktopHelpSession, 
                                        reinterpret_cast<void **>(pelt) 
                                    );
        if( FAILED(hRes) )
        {
            while( ppIHelpSession < pelt )
            {
                (*ppIHelpSession)->Release();
                ppIHelpSession++;
            }

            nActual = 0;
        }
        else
        {
            pelt++;
            m_iter++;
            nActual++;
        }
    }

    if( NULL != pcFetched )
    {
        *pcFetched = nActual;
    }

    if( SUCCEEDED(hRes) && (nActual < uCount) )
    {
        hRes = S_FALSE;
    }
        
    return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSessionEnum::Reset()
/*++

Routine Description:

    Reset enumeration from beginning, refer to standard COM enumerator for detail.

Parameters:

    None.

Returns:

    S_OK

--*/
{
	m_iter = m_pcollection.begin();
	return S_OK;
}



STDMETHODIMP 
CRemoteDesktopHelpSessionEnum::Skip(
    IN ULONG celt
    )
/*++

Routine Description:

    Skip number of items in the list and start enumeration from there.

Parameters:

    celt : number of item to skip.

Returns:

    S_OK or S_FALSE if end of the list reached.

Note:

    Refer to standard COM enumerator for detail.

--*/
{
    //
    // Code copied from ATL's IEnumOnSTLImpl::Skip()
    //
	HRESULT hr = S_OK;
	while (celt--)
	{
		if (m_iter != m_pcollection.end())
        {
			m_iter++;
        }
		else
		{
			hr = S_FALSE;
			break;
		}
	}
	return hr;
}



STDMETHODIMP 
CRemoteDesktopHelpSessionEnum::Clone( 
    OUT IRemoteDesktopHelpSessionEnum **ppIEnum 
    )
/*++

Routine Description:

    Make a copy of this enumerator.

Parameters:

    ppIEnum : Return a new enumerator

Returns:

    S_OK or E_OUTOFMEMORY.

Note:

    Refer to standard COM enumerator for detail.

--*/
{
    HRESULT hRes;

    CComObject<CRemoteDesktopHelpSessionEnum>* p = NULL;
    hRes = CComObject< CRemoteDesktopHelpSessionEnum >::CreateInstance( &p );

    if( SUCCEEDED(hRes) )
    {
        HelpSessionObjList::iterator it = m_pcollection.begin();

        // copy item to new enumerator
        for( ; it != m_pcollection.end() && SUCCEEDED(hRes); it++ )
        {
            // add will addref() to HelpSession object
            hRes = p->Add( *it );
        }

        p->Reset();
        hRes = p->QueryInterface( IID_IRemoteDesktopHelpSessionEnum, reinterpret_cast<void **>(ppIEnum) );
    }

    return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSessionEnum::get_Count(
    OUT long *pVal
    )
/*++

Routine Description:

    Return number of item in the list.

Parameters:

    pVal : return number of item

Returns:

    S_OK

Note:

    Refer to standard COM enumerator for detail.

--*/
{
	*pVal = m_pcollection.size();
	return S_OK;
}


STDMETHODIMP 
CRemoteDesktopHelpSessionEnum::get_Item(
    IN long Index, 
    OUT VARIANT *pVal
    )
/*++

Routine Description:

    Given an index, return item in the list.

Parameters

    Index : item index.
    pVal : Return (VT_DISPATCH) IRemoteDesktopHelpSession interface.

Returns:

    E_POINTER, E_FAIL, or S_OK.

Note:

    Refer to standard COM enumerator for detail, code
    copied from ICollectionOnSTLImpl::get_Item()

--*/
{
    //Index is 1-based
    if (pVal == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr = E_FAIL;

    Index--;
    HelpSessionObjList::iterator iter = m_pcollection.begin();
    while (iter != m_pcollection.end() && Index > 0)
    {
        iter++;
        Index--;
    }
    if (iter != m_pcollection.end())
    {
        VariantInit(pVal);
        
        pVal->vt = VT_DISPATCH;
        hr = (*iter)->QueryInterface( IID_IDispatch, (void **)&(pVal->pdispVal) );
    }

    return hr;
}


STDMETHODIMP 
CRemoteDesktopHelpSessionEnum::get__NewEnum(
    LPUNKNOWN *pVal
    )
/*++
Routine Description:

    Identical to Clone() except this routine exists to support
    VB scripting.

Parameters

    pVal : Return an IRemoteDesktopHelpSessionEnum interface.

Returns:

    S_OK, E_OUTOFMEMORY.

Note:

    Refer to standard COM enumerator for detail, code copied 
    from Alhen's WMI provider.

--*/
{
    HRESULT hRes;
    HelpSessionObjList::iterator it;
    VARIANT * rgVariant = NULL;
           
    typedef CComObject< CComEnum< IEnumVARIANT,&IID_IEnumVARIANT ,VARIANT, _Copy< VARIANT > > > CComEnumSessions;
    CComObject< CComEnumSessions > *pEnum = NULL;

    hRes = CComObject< CComEnumSessions >::CreateInstance( &pEnum );
    if( SUCCEEDED(hRes) )
    {
        rgVariant = new VARIANT [ m_pcollection.size() ];

        if( NULL != rgVariant )
        {
            VARIANT * pVariant	= rgVariant;

            // package a list of dispinterfaces to requester
            for( it = m_pcollection.begin(); it != m_pcollection.end() && SUCCEEDED(hRes); it++, pVariant++ )
            {
                pVariant->vt = VT_DISPATCH;

                hRes = (*it)->QueryInterface( IID_IDispatch, reinterpret_cast<void **>(&(pVariant->pdispVal)) );
            }
    
            if( SUCCEEDED (hRes) )
            {
                pEnum->AddRef();

                hRes = pEnum->Init( &rgVariant[0], &rgVariant[ m_pcollection.size() ] , NULL, AtlFlagTakeOwnership);
        
                if( SUCCEEDED( hRes ) )
                {
                    hRes = pEnum->QueryInterface ( 
                                            IID_IUnknown,
                                            reinterpret_cast<void **>(pVal) 
                                        );
		        }
            
                pEnum->Release( );
            }
        }
        else
        {
            hRes = E_OUTOFMEMORY;
        }

		if( FAILED(hRes) )
        {
            pEnum->Release();

            if( NULL != rgVariant )
            {
			    delete [] rgVariant;
            }
        }
    }

    return hRes;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\rdsgp.h ===
// rdsgp.h : Declaration of the CCRemoteDesktopSystemPolicy

#ifndef __CREMOTEDESKTOPPOLICY_H_
#define __CREMOTEDESKTOPPOLICY_H_

#include "sessmgr.h"
#include "helper.h"
#include "resource.h"       // main symbols
#include "policy.h"
#include "helpmgr.h"

/////////////////////////////////////////////////////////////////////////////
// CCRemoteDesktopSystemPolicy
class ATL_NO_VTABLE CRemoteDesktopSystemPolicy : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CRemoteDesktopSystemPolicy, &CLSID_RemoteDesktopSystemPolicy>,
	public IDispatchImpl<ISAFRemoteDesktopSystemPolicy, &IID_ISAFRemoteDesktopSystemPolicy, &LIBID_RDSESSMGRLib>
{
public:
	CRemoteDesktopSystemPolicy()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPSYSTEMPOLICY)

//
// Can't use SINGLETON here
// It is idea to use Singleton here since there can only
// be one system policy setting, we also need to support
// self-shutdown via AddRef()/Release() on _Module;However,
// ATL creates one CRemoteDesktopSystemPolicy at initialization
// time so we can't AddRef()/Release() on _Module, on the other
// hand, we can't self shutdown if we don't AddRef() or Release() 
//

//DECLARE_CLASSFACTORY_SINGLETON(CRemoteDesktopSystemPolicy)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRemoteDesktopSystemPolicy)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopSystemPolicy)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

    HRESULT
    FinalConstruct()
    {
        _Module.AddRef();
        DebugPrintf( _TEXT("Module AddRef by CRemoteDesktopSystemPolicy()...\n") );
        return S_OK;
    }

    void
    FinalRelease()
    {
        DebugPrintf( _TEXT("Module Release by CRemoteDesktopSystemPolicy()...\n") );

        _Module.Release();
    }


// IRemoteDesktopSystemPolicy
public:


    STDMETHOD(get_AllowGetHelp)( 
        /*[out, retval]*/ BOOL *pVal
    );

    STDMETHOD(put_AllowGetHelp)(
        /*[in]*/ BOOL Val
    );

    STDMETHOD(get_RemoteDesktopSharingSetting)(
        /*[out, retval]*/ REMOTE_DESKTOP_SHARING_CLASS *pLevel
    );

    STDMETHOD(put_RemoteDesktopSharingSetting)(
        /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS Level
    );

private:

    static CCriticalSection m_Lock;    
};

// rdsgp.h.h : Declaration of the CRemoteDesktopUserPolicy


/////////////////////////////////////////////////////////////////////////////
// CRemoteDesktopUserPolicy
class ATL_NO_VTABLE CRemoteDesktopUserPolicy : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CRemoteDesktopUserPolicy, &CLSID_RemoteDesktopUserPolicy>,
	public IDispatchImpl<ISAFRemoteDesktopUserPolicy, &IID_ISAFRemoteDesktopUserPolicy, &LIBID_RDSESSMGRLib>
{
public:
	CRemoteDesktopUserPolicy()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPUSERPOLICY)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRemoteDesktopUserPolicy)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopUserPolicy)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

    HRESULT
    FinalConstruct()
    {
        DebugPrintf( _TEXT("Module AddRef by CRemoteDesktopUserPolicy()...\n") );
        _Module.AddRef();

        return S_OK;
    }

    void
    FinalRelease()
    {
        DebugPrintf( _TEXT("Module Release by CRemoteDesktopUserPolicy()...\n") );

        _Module.Release();
    }


// IRemoteDesktopUserPolicy
public:

    STDMETHOD(get_AllowGetHelp)(
        /*[out, retval]*/ BOOL* pVal
    );

    STDMETHOD(get_RemoteDesktopSharingSetting)(
        /*[out, retval]*/ REMOTE_DESKTOP_SHARING_CLASS* pLevel
    );
};

#endif //__CREMOTEDESKTOPSYSTEMPOLICY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sessmgr.rc
//
#define IDR_Sessmgr                             100
#define IDR_REMOTEDESKTOPHELPSESSION            101
#define IDR_REMOTEDESKTOPHELPSESSIONENUM        102
#define IDR_REMOTEDESKTOPHELPSESSIONMGR         103
#define IDR_REMOTEDESKTOPSYSTEMPOLICY           104
#define IDR_REMOTEDESKTOPUSERPOLICY             105


#define IDS_SERVICENAME                 100
#define IDS_SERVICEDISPLAYNAME          101
#define IDS_SERVICEDESC                 102
#define IDS_ERROR_OPENSCM               103
#define IDS_ERROR_CREATESERVICE         104
#define IDS_ERROR_OPENSERVICE           105
#define IDS_ERROR_DELETESERVICE         106
#define IDS_HELPACCFULLNAME             107
#define IDS_HELPACCDESC                 108
#define IDS_HELPACCGROUP                109
#define IDS_HELPACCGROUPDESC            110
#define IDS_ERROR_INCOMPATIBLEOS        111
#define IDS_ERROR_SERVICEONLY           112
#define IDS_ERROR_CREATEACCOUNT         113
#define IDS_HELPACCNAME                 114

#define IDS_UNKNOWN                     115
#define IDS_RA_STRING                   116
#define IDS_URA_STRING                  117


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\sessmgr.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    sessmgr.cpp

Abstract:

    ATL wizard generated code.

Author:

    HueiWang    2/17/2000

--*/

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f sessmgrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <process.h>
#include <tchar.h>
#include "sessmgr.h"
#include "sessmgr_i.c"

#include <stdio.h>
//#include <new.h>

#include "global.h"
#include "HelpSess.h"
#include "HelpMgr.h"
#include "helper.h"
#include "helpacc.h"
#include <rdshost.h>
#include "policy.h"
#include "remotedesktoputils.h"

#define SETUPLOGFILE_NAME   _TEXT("sessmgr.setup.log")
#define SESSMGR_SERVICE         0
#define SESSMGR_REGSERVER       1
#define SESSMGR_UNREGSERVER     2
#define SESSMGR_SP1UPGRADE      3


BEGIN_OBJECT_MAP(ObjectMap)
//OBJECT_ENTRY(CLSID_RemoteDesktopHelpSession, CRemoteDesktopHelpSession)
OBJECT_ENTRY(CLSID_RemoteDesktopHelpSessionMgr, CRemoteDesktopHelpSessionMgr)
END_OBJECT_MAP()

CServiceModule _Module;


HANDLE g_hTSCertificateChanged = NULL;
HANDLE g_hWaitTSCertificateChanged = NULL;
HKEY g_hTSCertificateRegKey = NULL;


VOID CALLBACK
TSCertChangeCallback(
    PVOID pContext,
    BOOLEAN bTimerOrWaitFired
    )
/*++

Callback for TS certificate registry change from threadpool function.

--*/
{
    MYASSERT( FALSE == bTimerOrWaitFired );

    // Our wait is forever so can't be timeout.
    if( FALSE == bTimerOrWaitFired )
    {
        PostThreadMessage(
                    _Module.dwThreadID,
                    WM_LOADTSPUBLICKEY,
                    0,
                    0
                );
    }
    else
    {
        DebugPrintf( 
            _TEXT("TSCertChangeCallback does not expect timeout...\n") );

        MYASSERT(FALSE);
    }
}


DWORD
LoadTermSrvSecurityBlob()
/*++

Function to load TS machine specific identification blob, for now
we use TS public key.

--*/
{
    DWORD dwStatus;
    PBYTE pbTSPublicKey = NULL;
    DWORD cbTSPublicKey = 0;
    DWORD dwType;
    DWORD cbData;
    BOOL bSuccess;
    BOOL bUsesX509PublicKey = FALSE;

    if( NULL == g_hTSCertificateRegKey )
    {
        MYASSERT(FALSE);
        dwStatus = ERROR_INTERNAL_ERROR;
        goto CLEANUPANDEXIT;
    }

    //
    // Make sure TS certificate is there before
    // we directly load public key from LSA
    //
    dwStatus = RegQueryValueEx(
                            g_hTSCertificateRegKey,
                            REGVALUE_TSX509_CERT,
                            NULL,
                            &dwType,
                            NULL,
                            &cbData
                        );

    if( ERROR_SUCCESS == dwStatus )
    {
        DebugPrintf(
                _TEXT("TermSrv X509 certificate found, trying to load TS X509 public key\n")
            );

        cbTSPublicKey = 0;

        //
        // Current TLSAPI does not support retrival of 
        // X509 certificate public key and TS cert is in
        // special format not standard x509 cert chain.
        //
        dwStatus = LsCsp_RetrieveSecret(
                                LSA_TSX509_CERT_PUBLIC_KEY_NAME,
                                NULL,
                                &cbTSPublicKey
                            );

        if( LICENSE_STATUS_OK != dwStatus && 
            LICENSE_STATUS_INSUFFICIENT_BUFFER != dwStatus )
        {
            MYASSERT( FALSE );
            goto CLEANUPANDEXIT;
        }

        pbTSPublicKey = (PBYTE)LocalAlloc( LPTR, cbTSPublicKey );
        if( NULL == pbTSPublicKey )
        {
            dwStatus = GetLastError();
            goto CLEANUPANDEXIT;
        }
    
        dwStatus = LsCsp_RetrieveSecret(
                                LSA_TSX509_CERT_PUBLIC_KEY_NAME,
                                pbTSPublicKey,
                                &cbTSPublicKey
                            );
        // 
        // Critical error, We have certificate in registry 
        // but don't have public key in LSA
        // 
        MYASSERT( LICENSE_STATUS_OK == dwStatus );

        if( LICENSE_STATUS_OK != dwStatus )
        {
            DebugPrintf(
                    _TEXT("TermSrv X509 certificate found but can't load X509 public key\n")
                );

            goto CLEANUPANDEXIT;
        }


        bUsesX509PublicKey = TRUE; 
    }
    else
    {
        DebugPrintf(
                _TEXT("TermSrv X509 certificate not found\n")
            );

        //
        // Load pre-define TS public key
        //
        dwStatus = LsCsp_GetServerData(
                                LsCspInfo_PublicKey,
                                pbTSPublicKey,
                                &cbTSPublicKey
                            );

        // expecting insufficient buffer
        if( LICENSE_STATUS_INSUFFICIENT_BUFFER != dwStatus &&
            LICENSE_STATUS_OK != dwStatus )
        {
            // invalid return code.
            MYASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }

        MYASSERT( cbTSPublicKey > 0 );
        pbTSPublicKey = (PBYTE)LocalAlloc( LPTR, cbTSPublicKey );
        if( NULL == pbTSPublicKey )
        {
            dwStatus = GetLastError();
            goto CLEANUPANDEXIT;
        }
    
        dwStatus = LsCsp_GetServerData(
                                LsCspInfo_PublicKey,
                                pbTSPublicKey,
                                &cbTSPublicKey
                            );
        if( LICENSE_STATUS_OK != dwStatus )
        {
            MYASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }
    }

    if( ERROR_SUCCESS == dwStatus )
    {
        dwStatus = HashSecurityData( 
                            pbTSPublicKey, 
                            cbTSPublicKey, 
                            g_TSSecurityBlob 
                        );

        MYASSERT( ERROR_SUCCESS == dwStatus );
        MYASSERT( g_TSSecurityBlob.Length() > 0 );

        DebugPrintf(
                _TEXT("HashSecurityData() returns %d\n"), dwStatus
            );

        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }
    }

    //
    // SRV, ADS, ... SKU uses seperate thread
    // to register with license server, so we use 
    // different thread to receive certificate change notification.
    // Since TermSrv cached certificate, no reason to queue
    // notification once we successfully loaded tersrmv public key
    //
    if( !IsPersonalOrProMachine() && FALSE == bUsesX509PublicKey )
    {
        DebugPrintf(
                _TEXT("Setting up registry notification...\n")
            );

        MYASSERT( NULL != g_hTSCertificateChanged );

        ResetEvent(g_hTSCertificateChanged);

        // register a registry change notification
        // RegNotifyChangeKeyValue() only signal once.
        dwStatus = RegNotifyChangeKeyValue(
                                g_hTSCertificateRegKey,
                                TRUE,
                                REG_NOTIFY_CHANGE_LAST_SET,
                                g_hTSCertificateChanged,
                                TRUE
                            );
        if( ERROR_SUCCESS != dwStatus )
        {
            MYASSERT(FALSE);

            DebugPrintf(
                    _TEXT("RegNotifyChangeKeyValue() returns %d\n"), dwStatus
                );

            goto CLEANUPANDEXIT;
        }

        if( NULL != g_hWaitTSCertificateChanged )
        {
            if( FALSE == UnregisterWait( g_hWaitTSCertificateChanged ) )
            {
                dwStatus = GetLastError();
                DebugPrintf(
                        _TEXT("UnregisterWait() returns %d\n"),
                        dwStatus
                    );

                MYASSERT(FALSE);
            }
        
            g_hWaitTSCertificateChanged = NULL;
        }

        //
        // Queue notification to threadpool, we need to use WT_EXECUTEONLYONCE
        // since we are registering manual reset event.
        //
        bSuccess = RegisterWaitForSingleObject(
                                        &g_hWaitTSCertificateChanged,
                                        g_hTSCertificateChanged,
                                        (WAITORTIMERCALLBACK) TSCertChangeCallback,
                                        NULL,
                                        INFINITE,
                                        WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE
                                    );
        if( FALSE == bSuccess )
        {
            dwStatus = GetLastError();
            DebugPrintf(
                    _TEXT("RegisterWaitForSingleObject() returns %d\n"), dwStatus
                );

        }
    }
        
CLEANUPANDEXIT:

    if( ERROR_SUCCESS != dwStatus )
    {
        //
        // TS either update its public key or key has change
        // and we failed to reload it, there is no reason to 
        // to continue create help ticket since public key already
        /// mismatached, set service status and log error event
        //
        g_TSSecurityBlob.Empty();
    }

    if( NULL != pbTSPublicKey )
    {
        LocalFree(pbTSPublicKey);
    }

    return HRESULT_FROM_WIN32( dwStatus );        
}


DWORD
LoadAndSetupTSCertChangeNotification()
{
    DWORD dwStatus;
    DWORD dwDisp;
    BOOL bSuccess;

    //
    // Only setup registry change notification if we
    // runs on higher SKU
    //
    g_hTSCertificateChanged = CreateEvent( NULL, TRUE, FALSE, NULL );
    if( NULL == g_hTSCertificateChanged )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    // Open parameters key under TermServices if key isn't
    // there, create it, this does not interfere with TermSrv
    // since we only create the reg. key not updating values
    // under it.
    //
    dwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REGKEY_TSX509_CERT ,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE | KEY_READ,
                            NULL,
                            &g_hTSCertificateRegKey,
                            &dwDisp
                        );

    if( ERROR_SUCCESS != dwStatus )
    {
        MYASSERT(FALSE);
        DebugPrintf(
                _TEXT("RegCreateKeyEx on %s failed with 0x%08x\n"),
                REGKEY_TSX509_CERT,
                dwStatus
            );
        goto CLEANUPANDEXIT;
    }

    //
    // Load security blob from TS, currently, we use TS public key 
    // as security blob
    //
    dwStatus = LoadTermSrvSecurityBlob();
    if( ERROR_SUCCESS != dwStatus )
    {
        MYASSERT(FALSE);
    }

CLEANUPANDEXIT:

    return dwStatus;
}

LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

void
LogSetup(
    IN FILE* pfd,
    IN LPCTSTR format, ...
    )
/*++

Routine Description:

    sprintf() like wrapper around OutputDebugString().

Parameters:

    hConsole : Handle to console.
    format : format string.

Returns:

    None.

Note:

    To be replace by generic tracing code.

++*/
{
    TCHAR  buf[8096];   // max. error text
    DWORD  dump;
    va_list marker;
    va_start(marker, format);

    try {
        _vsntprintf(
                buf,
                sizeof(buf)/sizeof(buf[0])-1,
                format,
                marker
            );

        if( NULL == pfd )
        {
            OutputDebugString(buf);
        }
        else
        {
            _fputts( buf, pfd );
            fflush( pfd );
        }
    }
    catch(...) {
    }

    va_end(marker);
    return;
}


DWORD WINAPI 
NotifySessionLogoff( 
    LPARAM pParm
    )
/*++

Routine Description:

    Routine to notified all currently loaded help that a user has 
    logoff/disconnect from session, routine is kick off via thread pools' 
    QueueUserWorkItem().

Parameters:

    pContext : logoff or disconnected Session ID 

Returns:

    None.

Note :

    We treat disconnect same as logoff since user might be actually
    active on the other session logged in with same credential, so
    we rely on resolver.

--*/
{
   
    DebugPrintf(_TEXT("NotifySessionLogoff() started...\n"));

    //
    // Tell service don't shutdown, we are in process.
    //
    _Module.AddRef();

    CRemoteDesktopHelpSessionMgr::NotifyHelpSesionLogoff( pParm );

    _Module.Release();
    return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////

void
AddAccountToFilterList( 
    LPCTSTR lpszAccountName
    )
/*++

Routine Description:

    Add HelpAssistant account into account filter list, this is temporary
    until we have long term solution.

Parameters:

    lpszAccountName : Name of HelpAssistant account.

Returns:

    None.

Note:

    Account filter list is on

    HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList
    <name of SALEM account>    REG_DWORD    0x00000000

--*/
{
    HKEY hKey = NULL;
    DWORD dwStatus;
    DWORD dwValue = 0;

    dwStatus = RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        _TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\UserList"),
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        dwStatus = RegSetValueEx(
                                hKey,
                                lpszAccountName,
                                0,
                                REG_DWORD,
                                (LPBYTE) &dwValue,
                                sizeof(DWORD)
                            );
    }

    //MYASSERT( ERROR_SUCCESS == dwStatus );

    if( NULL != hKey )
    {
        RegCloseKey( hKey );
    }

    return;
}

void
CServiceModule::LogSessmgrEventLog(
    DWORD dwEventType,
    DWORD dwEventCode,
    CComBSTR& bstrNoviceDomain,
    CComBSTR& bstrNoviceAccount,
    CComBSTR& bstrRaType,
    CComBSTR& bstrExpertIPFromClient,
    CComBSTR& bstrExpertIPFromTS,
    DWORD dwErrCode
    )
/*++

Description:

    Log a Salem specific event log, this includes all event log in sessmgr.

Parameters:

    dwEventCode : Event code.
    bstrNoviceDomain : Ticket owner's domain name.
    bstrNoviceAccount : Ticket owner's user account name.
    bstrExpertIPFromClient : Expert's IP address send from mstacax.
    bstrExpertIPFromTS : Expert IP address we query from TermSrv.
    dwErrCode : Error code.

Returns:

    None.

Note:
    
    Max. sessmgr specific log require at most 5 parameters but must
    contain novice domain, account name and also expert IP address
    send to mstscax and expert IP address we query from TermSrv.

--*/
{
    TCHAR szErrCode[256];
    LPCTSTR eventString[6];
    
    _stprintf( szErrCode, L"0x%x", dwErrCode );
    eventString[0] = (LPCTSTR)bstrNoviceDomain;
    eventString[1] = (LPCTSTR)bstrNoviceAccount;
    eventString[2] = (LPCTSTR)bstrRaType;
    eventString[3] = (LPCTSTR)bstrExpertIPFromClient;
    eventString[4] = (LPCTSTR)bstrExpertIPFromTS;
    eventString[5] = szErrCode;

    LogEventString(
                dwEventType,
                dwEventCode,
                sizeof(eventString)/sizeof(eventString[0]),
                eventString,
                sizeof(dwErrCode),
                &dwErrCode
            );

    return;
}


/////////////////////////////////////////////////////////////////////////////
void 
CServiceModule::LogEventWithStatusCode(
    IN DWORD dwEventType,
    IN DWORD dwEventId,
    IN DWORD dwErrorCode
    )
/*++


--*/
{
    TCHAR szErrCode[256];
    LPCTSTR eventString[1];

    eventString[0] = szErrCode;

    _stprintf( szErrCode, L"0x%x", dwErrorCode );
    LogEventString(
                dwEventType,
                dwEventId,
                1,
                eventString
            );

    return;
}
       

/////////////////////////////////////////////////////////////////////////////

void 
CServiceModule::LogInfoEvent(
    IN DWORD code
    )
/*++

--*/
{
    LogEventString(
            EVENTLOG_INFORMATION_TYPE, 
            code, 
            0, 
            NULL
        );
}

/////////////////////////////////////////////////////////////////////////////

void 
CServiceModule::LogWarningEvent(
    IN DWORD code
    )
/*++

--*/
{

    LogEventString(
            EVENTLOG_WARNING_TYPE, 
            code, 
            0, 
            NULL
        );

}

/////////////////////////////////////////////////////////////////////////////

void 
CServiceModule::LogErrorEvent(
    IN DWORD errCode
    )
/*++

--*/
{

    LogEventString(
            EVENTLOG_ERROR_TYPE, 
            errCode, 
            0, 
            NULL
        );

}

/////////////////////////////////////////////////////////////////////////////

void
CServiceModule::LogEventString(
    IN DWORD dwEventType,
    IN DWORD dwEventId,
    IN DWORD wNumString,
    IN LPCTSTR* lpStrings,
    DWORD dwBinaryDataSize, /* 0 */
    LPVOID lpRawData /* NULL */
    )
/*++


--*/
{

    HANDLE hAppLog=NULL;
    BOOL bSuccess=FALSE;
    WORD wElogType = (WORD) dwEventType;

    try {
        if(hAppLog=RegisterEventSource(NULL, m_szServiceDispName)) 
        {
            bSuccess = ReportEvent(
                                hAppLog,
                                wElogType,
                                0,
                                dwEventId,
                                NULL,
                                (WORD)wNumString,
                                dwBinaryDataSize,
                                (const TCHAR **) lpStrings,
                                lpRawData
                            );

            DeregisterEventSource(hAppLog);
        }
    }
    catch(...) {
    }

    return;
}


inline HRESULT 
CServiceModule::SetupEventViewerSource(
    IN FILE* pSetupLog
    )
/*++

--*/
{
    HKEY hKey = NULL; 
    DWORD dwData; 
    TCHAR szBuffer[MAX_PATH + 2];
    DWORD dwStatus;


    LogSetup( pSetupLog, L"Entering SetupEventViewerSource()...\n" );

    _stprintf( 
            szBuffer, 
            _TEXT("%s\\%s"),
            REGKEY_SYSTEM_EVENTSOURCE,
            m_szServiceDispName
        );
            

    // Add your source name as a subkey under the Application 
    // key in the EventLog registry key. 

    dwStatus = RegCreateKey(
                        HKEY_LOCAL_MACHINE, 
                        szBuffer,
                        &hKey
                    );
    if( ERROR_SUCCESS != dwStatus )
    {
        LogSetup( 
                pSetupLog, 
                L"RegCreateKey() fail to create key %s with %d\n", 
                szBuffer, 
                dwStatus 
            );

        goto CLEANUPANDEXIT;
    }

    dwStatus = GetModuleFileName(
                            NULL,
                            szBuffer,
                            MAX_PATH+1
                        );

    if( 0 == dwStatus )
    {
        LogSetup( 
                pSetupLog,
                L"GetModuleFileName() failed with error code %s\n",
                dwStatus = GetLastError()
            );
    
        goto CLEANUPANDEXIT;
    }

    // Add the name to the EventMessageFile subkey. 
 
    dwStatus = RegSetValueEx(
                        hKey,
                        L"EventMessageFile",
                        0,
                        REG_SZ,
                        (LPBYTE) szBuffer,
                        (_tcslen(szBuffer)+1)*sizeof(TCHAR)
                    );

    if( ERROR_SUCCESS != dwStatus )
    {
        LogSetup( 
                pSetupLog,
                L"Failed to create EventMessageFile value, error code %d\n",
                dwStatus 
            );
    
        goto CLEANUPANDEXIT;
    }

    // Set the supported event types in the TypesSupported subkey. 
    dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE; 

    dwStatus = RegSetValueEx(
                        hKey,
                        L"TypesSupported",
                        0,
                        REG_DWORD,
                        (LPBYTE) &dwData,
                        sizeof(DWORD)
                    );

    if( ERROR_SUCCESS != dwStatus )
    {
        LogSetup( 
                pSetupLog,
                L"Failed to create TypesSupported value, error code %d\n",
                dwStatus 
            );
    }

CLEANUPANDEXIT:

    if( NULL != hKey )
    {
        RegCloseKey(hKey); 
    }

    LogSetup( 
            pSetupLog, 
            L"Exiting SetupEventViewerSource() with status code %d...\n", 
            dwStatus 
        );

    return HRESULT_FROM_WIN32(dwStatus);
} 


// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT 
CServiceModule::RegisterServer(FILE* pSetupLog, BOOL bRegTypeLib, BOOL bService)
{
    CRegKey key;
    HRESULT hr;
    CRegKey keyAppID;
    LONG lRes;

    LogSetup( 
            pSetupLog, 
            L"\nEntering CServiceModule::RegisterServer %d, %d\n",
            bRegTypeLib,
            bService
        );

    hr = CoInitialize(NULL);

    if (FAILED(hr))
    {
        LogSetup( pSetupLog, L"CoInitialize() failed with 0x%08x\n", hr );
        goto CLEANUPANDEXIT;
    }

    // Remove any previous service since it may point to
    // the incorrect file
    //Uninstall();

    // Add service entries
    UpdateRegistryFromResource(IDR_Sessmgr, TRUE);

    // Adjust the AppID for Local Server or Service
    lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
    {
        LogSetup( pSetupLog, L"Open key AppID failed with %d\n", lRes );
        hr = HRESULT_FROM_WIN32(lRes);
        goto CLEANUPANDEXIT;
    }

    lRes = key.Open(keyAppID, _T("{038ABBA4-4138-4AC4-A492-4A3DF068BD8A}"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
    {
        LogSetup( pSetupLog, L"Open key 038ABBA4-4138-4AC4-A492-4A3DF068BD8A failed with %d\n", lRes );
        hr = HRESULT_FROM_WIN32(lRes);
        goto CLEANUPANDEXIT;
    }

    key.DeleteValue(_T("LocalService"));
    
    if (bService)
    {
        LogSetup( pSetupLog, L"Installing service...\n" );

        BOOL bInstallSuccess;

        key.SetValue(m_szServiceName, _T("LocalService"));
        key.SetValue(_T("-Service"), _T("ServiceParameters"));

        if( IsInstalled(pSetupLog) )
        {
            // update service description.
            bInstallSuccess = UpdateService( pSetupLog );
        }
        else
        {
            //
            // Create service
            //
            bInstallSuccess = Install(pSetupLog);
        }

        if( FALSE == bInstallSuccess )
        {
            LogSetup( pSetupLog, L"Install or update service description failed %d\n", GetLastError() );
            
            MYASSERT( FALSE );
            hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
        }
        else
        {
            LogSetup( pSetupLog, L"successfully installing service...\n" );

            if( IsInstalled(pSetupLog) == FALSE )
            {
                LogSetup( pSetupLog, L"IsInstalled() return FALSE after Install()\n" );

                MYASSERT(FALSE);
                hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
            }

            SetupEventViewerSource(pSetupLog);
        }
    }

    if( SUCCEEDED(hr) )
    {
        // Add object entries
        hr = CComModule::RegisterServer(bRegTypeLib);

        if( FAILED(hr) )
        {
            LogSetup( pSetupLog, L"CComModule::RegisterServer() on type library failed with 0x%08x\n", hr );
        }
    }

    CoUninitialize();

CLEANUPANDEXIT:
    LogSetup( pSetupLog, L"Leaving CServiceModule::RegisterServer 0x%08x\n", hr );
    return hr;
}

inline HRESULT CServiceModule::UnregisterServer(FILE* pSetupLog)
{
    LogSetup( pSetupLog, L"\nEntering CServiceModule::UnregisterServer\n" );

    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        LogSetup( pSetupLog, L"CoInitialize() failed with 0x%08x\n", hr );
        goto CLEANUPANDEXIT;
    }

    // Remove service entries
    UpdateRegistryFromResource(IDR_Sessmgr, FALSE);
    // Remove service
    Uninstall(pSetupLog);
    // Remove object entries
    CComModule::UnregisterServer(TRUE);
    CoUninitialize();


CLEANUPANDEXIT:

    LogSetup( pSetupLog, L"Leaving CServiceModule::UnregisterServer() - 0x%08x\n", hr );
    return S_OK;
}

inline void 
CServiceModule::Init(
    _ATL_OBJMAP_ENTRY* p, 
    HINSTANCE h, 
    UINT nServiceNameID, 
    UINT nServiceDispNameID,
    UINT nServiceDescID, 
    const GUID* plibid
    )
/*++

ATL Wizard generated code

--*/
{
    CComModule::Init(p, h, plibid);

    m_bService = TRUE;
    m_dwServiceStartupStatus = ERROR_SUCCESS;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));
    LoadString(h, nServiceDescID, m_szServiceDesc, sizeof(m_szServiceDesc) / sizeof(TCHAR));
    LoadString(h, nServiceDispNameID, m_szServiceDispName, sizeof(m_szServiceDispName)/sizeof(TCHAR));

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SESSIONCHANGE;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    return l;
}

BOOL CServiceModule::IsInstalled(FILE* pSetupLog)
{
    LogSetup( pSetupLog, L"\nEntering CServiceModule::IsInstalled()\n" );

    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            LogSetup( pSetupLog, L"OpenService() Succeeded\n" );
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        else
        {
            LogSetup( pSetupLog, L"OpenService() failed with %d\n", GetLastError() );
        }

        ::CloseServiceHandle(hSCM);
    }
    else
    {
        LogSetup( pSetupLog, L"OpenSCManager() failed with %d\n", GetLastError() );
    }

    LogSetup( pSetupLog, L"Leaving IsInstalled() - %d\n", bResult );
    return bResult;
}

inline BOOL CServiceModule::UpdateService(FILE* pSetupLog)
{
    DWORD dwStatus = ERROR_SUCCESS;
    SERVICE_DESCRIPTION serviceDesc;
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;


    LogSetup( pSetupLog, L"\nEntering CServiceModule::UpdateServiceDescription()...\n" );

    hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"OpenSCManager() failed with %d\n", dwStatus );
        goto CLEANUPANDEXIT;
    }

    hService = ::OpenService( hSCM, m_szServiceName, SERVICE_CHANGE_CONFIG );

    if (hService == NULL)
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"OpenService() failed with %d\n", dwStatus );
        goto CLEANUPANDEXIT;
    }

    serviceDesc.lpDescription = (LPTSTR)m_szServiceDesc;

    if( FALSE == ChangeServiceConfig2( hService, SERVICE_CONFIG_DESCRIPTION, (LPVOID)&serviceDesc ) )
    {
        dwStatus = GetLastError();

        LogSetup( pSetupLog, L"ChangeServiceConfig2() failed with %d\n", dwStatus );
        MYASSERT( ERROR_SUCCESS == dwStatus );
    }

    //
    // Performance : Set service to be demand start for upgrade
    //
    if( FALSE == ChangeServiceConfig(
                                hService,
                                SERVICE_NO_CHANGE,
                                SERVICE_DEMAND_START,
                                SERVICE_NO_CHANGE,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                m_szServiceDispName
                            ) )
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"ChangeServiceConfig() failed with %d\n", dwStatus );
        MYASSERT( ERROR_SUCCESS == dwStatus );
    }


CLEANUPANDEXIT:

    if( NULL != hService )
    {
        ::CloseServiceHandle(hService);
    }

    if( NULL != hSCM )
    {
        ::CloseServiceHandle(hSCM);
    }

    LogSetup( pSetupLog, L"Leaving UpdateServiceDescription::Install() - %d\n", dwStatus );
    return dwStatus == ERROR_SUCCESS;
}

inline BOOL CServiceModule::Install(FILE* pSetupLog)
{
    DWORD dwStatus = ERROR_SUCCESS;
    SERVICE_DESCRIPTION serviceDesc;
    SC_HANDLE hSCM;
    TCHAR szFilePath[_MAX_PATH];
    SC_HANDLE hService;

    LogSetup( pSetupLog, L"\nEntering CServiceModule::Install()...\n" );
    if (IsInstalled(pSetupLog))
    {
        LogSetup( pSetupLog, L"Service already installed\n" );
        dwStatus = ERROR_SUCCESS;
        goto CLEANUPANDEXIT;
    }

    hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"OpenSCManager() failed with %d\n", dwStatus );
        goto CLEANUPANDEXIT;
    }

    // Get the executable file path
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    hService = ::CreateService(
                            hSCM, 
                            m_szServiceName, 
                            m_szServiceDispName,
                            SERVICE_ALL_ACCESS, 
                            SERVICE_WIN32_OWN_PROCESS,
                            SERVICE_DEMAND_START, 
                            SERVICE_ERROR_NORMAL,
                            szFilePath, 
                            NULL, 
                            NULL, 
                            _T("RPCSS\0"), 
                            NULL, 
                            NULL
                        );

    if (hService == NULL)
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"CreateService() failed with %d\n", dwStatus );

        ::CloseServiceHandle(hSCM);
        goto CLEANUPANDEXIT;
    }


    serviceDesc.lpDescription = (LPTSTR)m_szServiceDesc;

    if( FALSE == ChangeServiceConfig2( hService, SERVICE_CONFIG_DESCRIPTION, (LPVOID)&serviceDesc ) )
    {
        dwStatus = GetLastError();

        LogSetup( pSetupLog, L"ChangeServiceConfig2() failed with %d\n", dwStatus );
        MYASSERT( ERROR_SUCCESS == dwStatus );
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

CLEANUPANDEXIT:

    LogSetup( pSetupLog, L"Leaving CServiceModule::Install() - %d\n", dwStatus );
    return dwStatus == ERROR_SUCCESS;
}

inline BOOL CServiceModule::Uninstall(FILE* pSetupLog)
{
    BOOL bStatus = TRUE;
    SC_HANDLE hService;
    SC_HANDLE hSCM;
    SERVICE_STATUS status;


    LogSetup( pSetupLog, L"\nEntering CServiceModule::Uninstall()...\n" );

    if (!IsInstalled(pSetupLog))
    {
        LogSetup( pSetupLog, L"Service is not installed...\n" );
        goto CLEANUPANDEXIT;
    }

    hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
        LogSetup( pSetupLog, L"OpenSCManager() failed with %d\n", GetLastError() );
        bStatus = FALSE;
        goto CLEANUPANDEXIT;
    }

    hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);

        LogSetup( pSetupLog, L"OpenService() failed with %d\n", GetLastError() );
        bStatus = FALSE;
        goto CLEANUPANDEXIT;
    }

    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    bStatus = ::DeleteService(hService);

    if( FALSE == bStatus )
    {
        LogSetup( pSetupLog, L"DeleteService() failed with %d\n", GetLastError() );
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

CLEANUPANDEXIT:

    LogSetup( pSetupLog, L"Leaving CServiceModule::Uninstall()\n" );
    return bStatus;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }
    if (m_bService == FALSE)
        Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;

    m_hServiceStatus = RegisterServiceCtrlHandlerEx(m_szServiceName, HandlerEx, this);
    if (m_hServiceStatus == NULL)
    {
        //LogEvent(_T("Handler not installed"));
        return;
    }


    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = SERVICE_STARTUP_WAITHINT;

    SetServiceStatus(SERVICE_START_PENDING);

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
}

inline void CServiceModule::Handler(DWORD dwOpcode)
{

    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus(SERVICE_STOP_PENDING);
        if( PostThreadMessage(dwThreadID, WM_QUIT, 0, 0) == FALSE )
        {
            DWORD dwStatus = GetLastError();
        }
        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        break;
    //default:
    //    LogEvent(_T("Bad service request"));
    }
}


inline DWORD WINAPI
CServiceModule::HandlerEx(
    DWORD dwControl,
    DWORD dwEventType,
    LPVOID lpEventData,
    LPVOID lpContext
    )
/*++

--*/
{
    DWORD dwRetCode;

    switch (dwControl)
    {
        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        case SERVICE_CONTROL_INTERROGATE:
        case SERVICE_CONTROL_SHUTDOWN:

            dwRetCode = NO_ERROR;
            _Handler(dwControl);

            break;

#if DISABLESECURITYCHECKS
        // this is require for Salem Unit test, we need to update
        // user session status but for pcHealth, resolver will
        // always popup invitation dialog so no need to track
        // user session status.
        case SERVICE_CONTROL_SESSIONCHANGE:

            MYASSERT( NULL != lpEventData );

            if( NULL != lpEventData )
            {
                switch( dwEventType )
                {
                    case WTS_SESSION_LOGON:
                        DebugPrintf(
                            _TEXT("Session %d has log on...\n"),
                            ((WTSSESSION_NOTIFICATION *)lpEventData)->dwSessionId
                            );
                        break;

                    case WTS_SESSION_LOGOFF:
                    case WTS_CONSOLE_DISCONNECT:
                    case WTS_REMOTE_DISCONNECT:

                        DebugPrintf(
                            _TEXT("Session %d has log off...\n"),
                            ((WTSSESSION_NOTIFICATION *)lpEventData)->dwSessionId
                            );

                        //
                        // Deadlock if we use other thread to process logoff or
                        // disconnect.
                        //
                        // Notification thread lock pending help table and need 
                        // to run Resolver in COM, COM is in the middle of
                        // dispatching create help ticket call which also need
                        // lock to pending help table, this causes deadlock
                        //
                        PostThreadMessage( 
                                _Module.dwThreadID, 
                                WM_SESSIONLOGOFFDISCONNECT, 
                                0, 
                                (LPARAM)((WTSSESSION_NOTIFICATION *)lpEventData)->dwSessionId
                            );
                }
            }

            dwRetCode = NO_ERROR;
            break;
#endif

        default:

            dwRetCode = ERROR_CALL_NOT_IMPLEMENTED;            
    }

    return dwRetCode;
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode); 
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

HANDLE CServiceModule::gm_hIdle = NULL;
HANDLE CServiceModule::gm_hIdleMonitorThread = NULL;
HANDLE CServiceModule::gm_hICSAlertEvent = NULL;

unsigned __stdcall
StartupInitThread( void* ptr )
{
    HRESULT hRes = S_OK;
    DWORD dwErrCode = ERROR_SUCCESS;

    hRes = g_HelpSessTable.OpenSessionTable(NULL);

    if( SUCCEEDED(hRes) )
    {
        CRemoteDesktopHelpSessionMgr::NotifyPendingHelpServiceStartup();
    }
    else
    {
        dwErrCode = SESSMGR_E_HELPSESSIONTABLE;
    }

    if( FAILED(hRes) )
    {
        _Module.LogEventWithStatusCode( 
                                EVENTLOG_ERROR_TYPE,
                                dwErrCode,
                                hRes
                            );

        hRes = dwErrCode;
    }

    _endthreadex( hRes );
    return hRes;
}

ULONG
CServiceModule::AddRef() 
{
    CCriticalSectionLocker l( m_Locks );
    m_RefCount++;

    if( m_RefCount > 0 )
    {
        ResetEvent( gm_hIdle );
    }

    return m_RefCount;
}

ULONG
CServiceModule::Release()
{
    CCriticalSectionLocker l( m_Locks );
    m_RefCount--;

    if( m_RefCount <= 0 )
    {
        // Only signal idle when there is no more pending help
        if( g_HelpSessTable.NumEntries() == 0 )
        {
            SetEvent( gm_hIdle );
        }
    }

    return m_RefCount;
}

unsigned int WINAPI 
CServiceModule::IdleMonitorThread( void* ptr )
{
    DWORD dwStatus = ERROR_SUCCESS;
    CServiceModule* pServiceModule = (CServiceModule *)ptr;
    HANDLE hWaitHandles[] = {gm_hICSAlertEvent, gm_hIdle};

    CoInitialize(NULL);
    

    if( pServiceModule != NULL )
    {
        while (TRUE)
        {
            dwStatus = WaitForMultipleObjects(
                                        sizeof( hWaitHandles ) / sizeof( hWaitHandles[0] ),
                                        hWaitHandles,
                                        FALSE,
                                        EXPIRE_HELPSESSION_PERIOD
                                    );

            if( WAIT_TIMEOUT == dwStatus )
            {
                // expire help ticket, refer to session logoff/disconnect
                // comment above on why PostThreadMessage.
                PostThreadMessage( 
                        _Module.dwThreadID, 
                        WM_EXPIREHELPSESSION, 
                        0, 
                        0
                    );

            }
            else if( WAIT_OBJECT_0 == dwStatus )
            {
                // ICS has signal us something has changed.

                ResetEvent( gm_hICSAlertEvent );
            }
            else if( WAIT_OBJECT_0 + 1 == dwStatus )
            {
                // we have been idel for too long, time to try shutdown.
                // idle event will only be signal when there is no
                // pending help so we don't have to worry about address
                // changes.

                Sleep( IDLE_SHUTDOWN_PERIOD );
                dwStatus = WaitForSingleObject( gm_hIdle, 0 );
                if( WAIT_OBJECT_0 == dwStatus )
                {
                    // no one holding object, time to shutdown
                    dwStatus = ERROR_SUCCESS;
                    break;
                }
            }
            else if( WAIT_FAILED == dwStatus )
            {
                // some bad thing happen, shutdown.
                //MYASSERT(FALSE);
                break;
            }

        }
    }

    // TOBE enable with ICS work
    //pServiceModule->LogInfoEvent( SESSMGR_I_SERVICE_IDLESTOP );

    pServiceModule->Handler(SERVICE_CONTROL_STOP);

    CoUninitialize();
    _endthreadex( dwStatus );
    return dwStatus;
}

BOOL
CServiceModule::InitializeSessmgr()
{
    CCriticalSectionLocker l( m_Locks );

    //
    // Already initialize.
    //
    if( m_Initialized )
    {
        return TRUE;
    }

    //
    // Service failed to startup, just return without initialize
    // anything
    //
    if( !_Module.IsSuccessServiceStartup() )
    {
        return FALSE;
    }

    DWORD dwStatus;
    unsigned int junk;
    
    //
    // Start ICSHELPER library.
    //
    dwStatus = StartICSLib();
    if( ERROR_SUCCESS != dwStatus )
    {
        // Log an error event, we still need to startup
        // so that we can report error back to caller
        LogEventWithStatusCode(
                        EVENTLOG_ERROR_TYPE,
                        SESSMGR_E_ICSHELPER,
                        dwStatus
                    );

        _Module.m_dwServiceStartupStatus = SESSMGR_E_ICSHELPER;
    }
    else
    {
        CRemoteDesktopHelpSessionMgr::NotifyPendingHelpServiceStartup();
    }

    m_Initialized = TRUE;
    return _Module.IsSuccessServiceStartup();
}

void CServiceModule::Run()
{
    //
    // Mark we are not initialized yet...
    //
    m_Initialized = FALSE;
    _Module.dwThreadID = GetCurrentThreadId();

    DWORD dwStatus;
    unsigned int dwJunk;
    WSADATA wsData;
    ISAFRemoteDesktopCallback* pIResolver = NULL;

    LPWSTR pszSysAccName = NULL;
    DWORD cbSysAccName = 0;
    LPWSTR pszSysDomainName = NULL;
    DWORD cbSysDomainName = 0;
    SID_NAME_USE SidType;

    HRESULT hr;

    //
    // **** DO NOT CHANGE SEQUENCE ****
    //
    // Refer to XP RAID 407457 for detail
    //
    // A thread named SessMgr!DpNatHlpThread is calling into dpnhupnp.dll, 
    // which is doing COM-related stuff, this is happening before the 
    // sessmgr!CServiceModule__Run method calls CoInitializeSecurity.   
    // When you do COM stuff before calling CoInitSec, COM do it for you, 
    // and you end up accepting the defaults
    //

    hr = g_HelpAccount.Initialize();
    if( FAILED(hr) )
    {
        dwStatus = SESSMGR_E_HELPACCOUNT;

        LogEventWithStatusCode(
                        EVENTLOG_ERROR_TYPE,
                        SESSMGR_E_GENERALSTARTUP,
                        hr
                    );

        _Module.m_dwServiceStartupStatus = SESSMGR_E_HELPACCOUNT;
        MYASSERT(FALSE);
    }

    hr = LoadLocalSystemSID();
    if( FAILED(hr) )
    {
        LogEventWithStatusCode(
                        EVENTLOG_ERROR_TYPE,
                        SESSMGR_E_GENERALSTARTUP,
                        hr
                    );

        _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
        MYASSERT(FALSE);
    }

    //
    // We always need to startup otherwise will cause caller to timeout
    // or AV.
    //
    hr = CoInitialize(NULL);

//  If you are running on NT 4.0 or higher you can use the following call
//  instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
//  HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    _ASSERTE(SUCCEEDED(hr));

    CSecurityDescriptor sd;
    sd.InitializeFromThreadToken();     // get a default DACL

#ifndef DISABLESECURITYCHECKS
    if( _Module.IsSuccessServiceStartup() ) 
    {
        BOOL bSuccess;
        CComBSTR bstrHelpAccName;

        //
        // Retrieve System account name, might not be necessary since this
        // pre-defined account shouldn't be localizable.
        //
        pszSysAccName = NULL;
        cbSysAccName = 0;
        pszSysDomainName = NULL;
        cbSysDomainName = 0;

        bSuccess = LookupAccountSid( 
                                NULL, 
                                g_pSidSystem, 
                                pszSysAccName, 
                                &cbSysAccName, 
                                pszSysDomainName, 
                                &cbSysDomainName, 
                                &SidType 
                            );

        if( TRUE == bSuccess ||
            ERROR_INSUFFICIENT_BUFFER == GetLastError() )
        {
            pszSysAccName = (LPWSTR) LocalAlloc( LPTR, (cbSysAccName + 1) * sizeof(WCHAR) );
            pszSysDomainName = (LPWSTR) LocalAlloc( LPTR, (cbSysDomainName + 1) * sizeof(WCHAR) );

            if( NULL != pszSysAccName && NULL != pszSysDomainName )
            {
                bSuccess = LookupAccountSid( 
                                        NULL, 
                                        g_pSidSystem, 
                                        pszSysAccName, 
                                        &cbSysAccName, 
                                        pszSysDomainName, 
                                        &cbSysDomainName, 
                                        &SidType 
                                    );

                if( TRUE == bSuccess )
                {
                    hr = sd.Allow( pszSysAccName, COM_RIGHTS_EXECUTE );
                }
            }
        }
            
        if( FALSE == bSuccess )
        {
            dwStatus = GetLastError();
            hr = HRESULT_FROM_WIN32( dwStatus );
            MYASSERT( SUCCEEDED(hr) );
        }

        //
        // Add access permission to help assistant account
        if( SUCCEEDED(hr) )
        {
            //
            // Allow access to HelpAssistant account
            //
            hr = g_HelpAccount.GetHelpAccountNameEx( bstrHelpAccName );
            if( SUCCEEDED(hr) )
            {
                hr = sd.Allow( (LPCTSTR)bstrHelpAccName, COM_RIGHTS_EXECUTE );
                MYASSERT( SUCCEEDED(hr) );
            }
        }

        //
        // If we failed in setting DACL, we still need to startup but without
        // full security, however, our interface will fail because service
        // does not initialize correctly.
        //
        if( FAILED(hr) )
        {
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_RESTRICTACCESS,
                            hr
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_RESTRICTACCESS;
        }
    }        
#endif

    //
    // We still need to startup or client might behave weird; interface call 
    // will be block by checking service startup status.
    //
    hr = CoInitializeSecurity(
                        sd, 
                        -1, 
                        NULL, 
                        NULL,
                        RPC_C_AUTHN_LEVEL_PKT, 
                        RPC_C_IMP_LEVEL_IMPERSONATE, 
                        NULL, 
                        EOAC_NONE, 
                        NULL
                    );

    _ASSERTE(SUCCEEDED(hr));

    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE);
    _ASSERTE(SUCCEEDED(hr));

    //
    // Load unknown string for event loggging
    //
    g_UnknownString.LoadString( IDS_UNKNOWN );

    //
    // Load RA and URA string for event log
    //
    g_RAString.LoadString( IDS_RA_STRING );
    g_URAString.LoadString( IDS_URA_STRING );

    if( _Module.IsSuccessServiceStartup() )
    {
        //
        // Startup TLSAPI in order to get public key
        //
        dwStatus = TLSInit();
        if( LICENSE_STATUS_OK != dwStatus )
        {
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_GENERALSTARTUP,
                            dwStatus
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
            MYASSERT(FALSE);
        }
    }

    if( _Module.IsSuccessServiceStartup() )
    {
        //
        // Load TermSrv public key, on PRO/PER we load public key from
        // non-x509 certificate, on other SKU, we register a registry change
        // notification and post ourself a message regarding public key
        // change.
        // 
        dwStatus = LoadAndSetupTSCertChangeNotification();
    
        MYASSERT( ERROR_SUCCESS == dwStatus  );
        if( ERROR_SUCCESS != dwStatus )
        {
            // Log an error event, we still need to startup
            // so that we can report error back to caller
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_GENERALSTARTUP,
                            dwStatus
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
        }
    }

    if( _Module.IsSuccessServiceStartup() )
    {
        //
        // Create an event for ICS to signal us
        // any address change
        //
        gm_hICSAlertEvent = CreateEvent(
                                    NULL,
                                    TRUE,
                                    FALSE,
                                    NULL
                                );

        if( NULL == gm_hICSAlertEvent )
        {
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_GENERALSTARTUP,
                            GetLastError()
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
            MYASSERT(FALSE);
        }
    }

    if( _Module.IsSuccessServiceStartup() )
    {
        //
        // Initialize encryption library
        //
        dwStatus = TSHelpAssistantInitializeEncryptionLib();
        if( ERROR_SUCCESS != dwStatus )
        {
            // Log an error event, we still need to startup
            // so that we can report error back to caller
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_INIT_ENCRYPTIONLIB,
                            dwStatus
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_INIT_ENCRYPTIONLIB;
            MYASSERT(FALSE);
        }
    }

    if( _Module.IsSuccessServiceStartup() )
    {
        //
        // startup WSA so we can invoke gethostname()
        // critical error if we can startup WSA
        if( WSAStartup(0x0101, &wsData) != 0 )
        {
            // Log an error event, we still need to startup
            // so that we can report error back to caller
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_WSASTARTUP,
                            GetLastError()
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_WSASTARTUP;
        }        
    }

    if( _Module.IsSuccessServiceStartup() )
    {
        hr = g_HelpSessTable.OpenSessionTable(NULL);
        if( FAILED(hr) )
        {
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_HELPSESSIONTABLE,
                            hr
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_HELPSESSIONTABLE;
            MYASSERT(FALSE);
        }
    }

    if( _Module.IsSuccessServiceStartup() )
    {
        //
        // Service might startup from system restore, re-setup HelpAssistant account
        // settings
        if( g_HelpSessTable.NumEntries() == 0)
        {
            g_HelpAccount.EnableHelpAssistantAccount(FALSE);
            g_HelpAccount.EnableRemoteInteractiveRight(FALSE);
        }
        else
        {
            //
            // make sure HelpAssistant account is enabled and can logon locally
            //
            g_HelpAccount.EnableHelpAssistantAccount(TRUE);
            g_HelpAccount.EnableRemoteInteractiveRight(TRUE);
            g_HelpAccount.SetupHelpAccountTSSettings();
        }

        //
        // Create an manual reset event for background thread to terminate
        // service
        //
        gm_hIdle = CreateEvent( 
                            NULL, 
                            TRUE, 
                            (g_HelpSessTable.NumEntries() == 0) ? TRUE : FALSE, 
                            NULL 
                        );

        if( NULL == gm_hIdle )
        {
            LogEventWithStatusCode(
                            EVENTLOG_ERROR_TYPE,
                            SESSMGR_E_GENERALSTARTUP,
                            GetLastError()
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
            MYASSERT(FALSE);
        }

        // Create nackground thread thread 
        gm_hIdleMonitorThread = (HANDLE)_beginthreadex(
                                                    NULL,
                                                    0,
                                                    IdleMonitorThread,
                                                    (HANDLE)this,
                                                    0,
                                                    &dwJunk
                                                );

        if( NULL == gm_hIdleMonitorThread )
        {
            _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
        }
    }

    //LogEvent(_T("Service started"));
    if (m_bService)
        SetServiceStatus(SERVICE_RUNNING);

    // TOBE enable with ICS work
    //LogInfoEvent(SESSMGR_I_SERVICE_START);


    //
    // Load resolver, this will put one ref. count on it
    // so it won't got unload until we are done.
    //
    hr = CoCreateInstance( 
                        SESSIONRESOLVERCLSID,
                        NULL,
                        CLSCTX_SERVER,
                        IID_ISAFRemoteDesktopCallback,
                        (void **)&pIResolver
                    );

    MYASSERT( SUCCEEDED(hr) );

    if( FAILED(hr) )
    {
        //
        // Can't initialize session resolver, 
        // session resolver will not be able to
        // do caching.
        //
        LogEventWithStatusCode( 
                        EVENTLOG_WARNING_TYPE,
                        SESSMGR_E_SESSIONRESOLVER,
                        hr
                    );

        _Module.m_dwServiceStartupStatus = SESSMGR_E_SESSIONRESOLVER;
    }
    else
    {
        //
        // Create global interface table
        //
        hr = InitializeGlobalInterfaceTable();

        if( SUCCEEDED(hr) )
        {
            //
            // register resolver interface with GIT, resolver has some 
            // data structure that depends on single instance.
            //
            hr = RegisterResolverWithGIT(pIResolver);
        }

        if( FAILED(hr) )
        {
            //
            // Not critical, Resolver function is disabled.
            LogEventWithStatusCode( 
                            EVENTLOG_WARNING_TYPE,
                            SESSMGR_E_REGISTERSESSIONRESOLVER,
                            hr
                        );

            _Module.m_dwServiceStartupStatus = SESSMGR_E_REGISTERSESSIONRESOLVER;
        }
    }

    MSG msg;
    while (GetMessage(&msg, 0, 0, 0))
    {
        switch( msg.message )
        {
            case WM_EXPIREHELPSESSION:
                DebugPrintf(_TEXT("Executing TimeoutHelpSesion()...\n"));
                CRemoteDesktopHelpSessionMgr::TimeoutHelpSesion();
                break;

            case WM_SESSIONLOGOFFDISCONNECT:
                DebugPrintf(_TEXT("Executing NotifySessionLogoff() %d...\n"), msg.lParam);
                NotifySessionLogoff( msg.lParam );
                break;

            case WM_LOADTSPUBLICKEY:
                DebugPrintf( _TEXT("Executing LoadTermSrvSecurityBlob() ...\n") );
                dwStatus = LoadTermSrvSecurityBlob();

                if( ERROR_SUCCESS != dwStatus )
                {
                    // Log an error event, we still need to startup
                    // so that we can report error back to caller
                    LogEventWithStatusCode(
                                    EVENTLOG_ERROR_TYPE,
                                    SESSMGR_E_GENERALSTARTUP,
                                    dwStatus
                                );

                    _Module.m_dwServiceStartupStatus = SESSMGR_E_GENERALSTARTUP;
                }
                break;

            case WM_HELPERRDSADDINEXIT:
                DebugPrintf( _TEXT("WM_HELPERRDSADDINEXIT()...\n") );
                CRemoteDesktopHelpSessionMgr::NotifyExpertLogoff( msg.wParam, (BSTR)msg.lParam );
                break;
                
            default:
                DispatchMessage(&msg);
        }
    }

    CleanupMonitorExpertList();

    if( g_hWaitTSCertificateChanged )
    {
        UnregisterWait( g_hWaitTSCertificateChanged );
        g_hWaitTSCertificateChanged = NULL;
    }

    if( g_hTSCertificateChanged )
    {
        CloseHandle( g_hTSCertificateChanged );
        g_hTSCertificateChanged = NULL;
    }

    if( g_hTSCertificateRegKey )
    {
        RegCloseKey( g_hTSCertificateRegKey );
        g_hTSCertificateRegKey = NULL;
    }

    //
    // 
    if( NULL != pIResolver )
    {
        pIResolver->Release();
    }

    _Module.RevokeClassObjects();

    // TOBE enable with ICS work
    //LogInfoEvent(SESSMGR_I_SERVICE_STOP);

    CoUninitialize();


    if( NULL != gm_hIdle )
    {
        CloseHandle( gm_hIdle );
    }

    if( WSACleanup() != 0 )
    {
        // shutting down, ignore WSA error
        #if DBG
        OutputDebugString( _TEXT("WSACleanup() failed...\n") );
        #endif
    }

    #if DBG
    OutputDebugString( _TEXT("Help Session Manager Exited...\n") );
    #endif

    // Close the help session table, help session table 
    // open by init. thread
    g_HelpSessTable.CloseSessionTable();

    // Stop ICS library, ignore error code.
    StopICSLib();
    TSHelpAssistantEndEncryptionLib();

    UnInitializeGlobalInterfaceTable();

    if( NULL != pszSysAccName )
    {
        LocalFree( pszSysAccName );
    }

    if( NULL != pszSysDomainName )
    {
        LocalFree( pszSysDomainName );
    }

    TLSShutdown();

}

HRESULT
CreatePendingHelpTable(     
    FILE* pSetupLog 
    )
/*++

Routine to create pending help table registry key, if registry key already exist,
set the DACL to system context only.

--*/
{
    PACL pAcl=NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    DWORD cbAcl = 0;
    PSID  pSidSystem = NULL;
    HKEY hKey = NULL;


    LogSetup( pSetupLog, L"\nEntering CreatePendingHelpTable\n" );

    pSecurityDescriptor = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, sizeof(SECURITY_DESCRIPTOR));
    if( NULL == pSecurityDescriptor )
    {
        LogSetup( pSetupLog, L"Can't alloc memory for SECURITY_DESCRIPTOR\n" );
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the security descriptor.
    //
    if (!InitializeSecurityDescriptor(
                    pSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    )) 
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"InitializeSecurityDescriptor() failed with %d\n", dwStatus );
        goto CLEANUPANDEXIT;
    }

    dwStatus = CreateSystemSid( &pSidSystem );
    if( ERROR_SUCCESS != dwStatus )
    {
        LogSetup( pSetupLog, L"CreateSystemSid() failed with %d\n", dwStatus );
        goto CLEANUPANDEXIT;
    }

    cbAcl = GetLengthSid( pSidSystem ) + sizeof(ACL) + (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    pAcl = (PACL) LocalAlloc( LPTR, cbAcl );
    if( NULL == pAcl )
    {
        LogSetup( pSetupLog, L"Can't alloc memory for ACL\n" );
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the ACL.
    //
    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) 
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"InitializeAcl() failed with error code %d\n", dwStatus );
        goto CLEANUPANDEXIT;
    }

    //
    if (!AddAccessAllowedAce(pAcl,
                        ACL_REVISION,
                        GENERIC_READ | GENERIC_WRITE | GENERIC_ALL,
                        pSidSystem
                        )) 
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"AddAccessAllowedAce() failed with error code %d\n", dwStatus );
        goto CLEANUPANDEXIT;
    }

    if (!SetSecurityDescriptorDacl(pSecurityDescriptor,
                                  TRUE, pAcl, FALSE)) 
    {
        dwStatus = GetLastError();
        LogSetup( pSetupLog, L"SetSecurityDescriptorDacl() failed with error code %d\n", dwStatus );
        goto CLEANUPANDEXIT;
    }   

    //
    // Create/open the pending table registry key
    //
    dwStatus = RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE, 
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL
                    );

    if( ERROR_SUCCESS != dwStatus )
    {
        LogSetup( pSetupLog, L"RegCreateKeyEx() failed with error code %d\n", dwStatus );
        goto CLEANUPANDEXIT;
    }  

    //
    // Set table (registry) DACL
    //
    dwStatus = RegSetKeySecurity(
                            hKey,
                            DACL_SECURITY_INFORMATION, 
                            pSecurityDescriptor
                        );

    if( ERROR_SUCCESS != dwStatus )
    {
        LogSetup( pSetupLog, L"RegSetKeySecurity() failed with error code %d\n", dwStatus );
    }

CLEANUPANDEXIT:

    if( NULL != hKey )
    {
        RegCloseKey(hKey);
    }

    if( pAcl != NULL )
    {
        LocalFree(pAcl);
    }

    if( pSecurityDescriptor != NULL )
    {
        LocalFree( pSecurityDescriptor );
    }

    if( pSidSystem != NULL )
    {
        FreeSid( pSidSystem );
    }

    LogSetup( pSetupLog, L"CreatePendingHelpTable() return %d\n", dwStatus );

    return HRESULT_FROM_WIN32(dwStatus);
}


void
UpgradeSessmgr( 
    FILE* pSetupLog
    )
/*++

    Routine to upgrade session manager

--*/
{
    LogSetup( pSetupLog, L"\nEntering UpgradeSessmgr\n" );

    //
    // Migrate fAllowToGetHelp policy in HKLM\Software\Microsoft\Remote Desktop\Policies 
    // to termsrv so listening thread can look at single place.
    //
    DWORD dwValue;
    DWORD dwStatus;
    DWORD dwSize;
    DWORD dwType;
    HKEY hKey;
    BOOL bUpgradeFromB1 = FALSE;

    LogSetup( pSetupLog, L"Setting policy registry key\n" );

    //
    // Open TS registry key under HKLM\System\CurrentControlSet\Control\Terminal Serv...
    //
    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_GETHELP,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        dwStatus = GetPolicyAllowGetHelpSetting(
                                    HKEY_LOCAL_MACHINE,
                                    OLD_REG_CONTROL_GETHELP,
                                    RDS_ALLOWGETHELP_VALUENAME,
                                    &dwValue
                                );

        if( ERROR_SUCCESS == dwStatus )
        {
            LogSetup( pSetupLog, L"B1 policy value %d\n", dwValue );

            //
            // Delete the old policy key, ignore error.
            //
            RegDelKey( HKEY_LOCAL_MACHINE, OLD_REG_CONTROL_GETHELP );

            //
            // This value exists in old Salem policy key, system must be
            // upgrading from B1.
            //
            dwStatus = RegSetValueEx(
                            hKey,
                            RDS_ALLOWGETHELP_VALUENAME,
                            0,
                            REG_DWORD,
                            (PBYTE)&dwValue,
                            sizeof(dwValue)
                        );

            bUpgradeFromB1 = TRUE;
        }
        else
        {
            LogSetup( pSetupLog, L"B1 policy key does not exist\n" );

            dwSize = sizeof(dwValue);

            //
            // Upgrade from B2 and beyond, check to see if fAllowToGetHelp exist
            // if not, set it to 1.
            // 
            dwStatus = RegQueryValueEx(
                                    hKey,
                                    RDS_ALLOWGETHELP_VALUENAME,
                                    0,
                                    &dwType,
                                    (PBYTE)&dwValue,
                                    &dwSize
                                );

            if( ERROR_FILE_NOT_FOUND == dwStatus || REG_DWORD != dwType )
            {
                //
                // default is not allow to get help if 
                // value does not exist.
                //
                dwValue = 1;
                dwStatus = RegSetValueEx(
                                    hKey,
                                    RDS_ALLOWGETHELP_VALUENAME,
                                    0,
                                    REG_DWORD,
                                    (PBYTE)&dwValue,
                                    sizeof(dwValue)
                                );
            }
            else
            {
                LogSetup( pSetupLog, L"Existing fAllowToGetHelp Policy value %d\n", dwValue );
            }
        }

        LogSetup( pSetupLog, L"Setting fAllowGetHelp policy key result - %d\n", dwStatus );
      
        RegCloseKey( hKey );
    }
    else
    {
        LogSetup( 
                pSetupLog, 
                L"Can't open registry key %s, error code %d\n", 
                REG_CONTROL_GETHELP, 
                dwStatus 
            );
    }

    if( TRUE == bUpgradeFromB1 )
    {
        //
        // B1, help assistant account password is clear text, this will fix the 
        // security leak.
        //
        LogSetup( pSetupLog, L"Upgrade from B1, delete all pending help and reset account password\n" );

        RegDelKey(
                HKEY_LOCAL_MACHINE,
                REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE
            );

        g_HelpAccount.ResetHelpAccountPassword();
    }

    LogSetup( pSetupLog, L"Leaving UpgradeSessmgr\n" );
    return;
}

#define UNINSTALL_BEFORE_INSTALL   _TEXT("UninstallBeforeInstall")

HRESULT
InstallUninstallSessmgr(
    DWORD code
    )
/*++


--*/
{
    FILE* pSetupLog;
    TCHAR LogFile[MAX_PATH+1];
    HRESULT hRes = S_OK;
    DWORD dwStatus = ERROR_SUCCESS;

    HKEY hKey = NULL;
    DWORD dwValue = 1;
    DWORD dwType;
    DWORD cbData = sizeof(dwValue);


    GetWindowsDirectory( LogFile, MAX_PATH );
    lstrcat( LogFile, L"\\" );
    lstrcat( LogFile, SETUPLOGFILE_NAME );

    pSetupLog = _tfopen( LogFile, L"a+t" );
    MYASSERT( NULL != pSetupLog );

    LogSetup( pSetupLog, L"\n\n********* Install/uninstall sessmgr service *********\n" );
    
    //
    // no checking on return, if failure, we just do OutputDebugString();
    //
    switch( code )
    {
        case SESSMGR_UNREGSERVER:
            {

                LogSetup( pSetupLog, L"Uninstalling sessmgr service\n" );

                //
                // Delete all pending help session.
                //
                dwStatus = RegDelKey( 
                                    HKEY_LOCAL_MACHINE, 
                                    REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE 
                                );

                LogSetup( pSetupLog, L"Delete pending table return %d\n", dwStatus );

                //
                // We might not be running in system context so deleting registry and
                // cleanup LSA key will fail, write a key to our control location to
                // mark such that delete everything before install
                //
                dwStatus = RegOpenKeyEx( 
                                    HKEY_LOCAL_MACHINE, 
                                    REGKEYCONTROL_REMDSK, 
                                    0,
                                    KEY_ALL_ACCESS, 
                                    &hKey 
                                );

                if( ERROR_SUCCESS == dwStatus )
                {
                    dwStatus = RegSetValueEx(
                                        hKey,
                                        UNINSTALL_BEFORE_INSTALL,
                                        0,
                                        REG_DWORD,
                                        (BYTE *) &dwValue,
                                        sizeof(dwValue)
                                    );

                    if( ERROR_SUCCESS != dwStatus )
                    {
                        LogSetup( pSetupLog, L"Failed to set value, error code %d\n", dwStatus );
                        MYASSERT(FALSE);
                    }

                    RegCloseKey( hKey );
                }
                else
                {
                    // This is OK since we havn't been install before.
                    LogSetup( pSetupLog, L"Failed to open control key, error code %d\n", dwStatus );
                }

                //
                // Initialize to get help account name.
                //
                hRes = g_HelpAccount.Initialize();
                LogSetup( pSetupLog, L"Initialize help account return 0x%08x\n", hRes );

                // 
                // ignore error, try to delete the account
                hRes = g_HelpAccount.DeleteHelpAccount();
                LogSetup( pSetupLog, L"Delete help account return 0x%08x\n", hRes );

                MYASSERT( SUCCEEDED(hRes) );

                hRes = _Module.UnregisterServer(pSetupLog);

                LogSetup( pSetupLog, L"UnregisterServer() returns 0x%08x\n", hRes );

                if( ERROR_SUCCESS == StartICSLib() )
                {
                    // Non-critical if we can't startup the lib since after we shutdown,
                    // we would have close all the port
                    CloseAllOpenPorts();
                    StopICSLib();
                }
            }
            break;

        case SESSMGR_REGSERVER:     
            {
                LogSetup( pSetupLog, L"Installing as non-service\n" );

                #if DBG

                AddAccountToFilterList( HELPASSISTANTACCOUNT_NAME );
                MYASSERT( ERROR_SUCCESS == g_HelpAccount.CreateHelpAccount() ) ;

                hRes = _Module.RegisterServer(pSetupLog, TRUE, FALSE);

                #else

                hRes = E_INVALIDARG;

                #endif
            }
            break;

        //case SESSMGR_UPGRADE:
            //
            // TODO - ICS work, add upgrade special code.
            //

        case SESSMGR_SERVICE:        
            {
                LogSetup( pSetupLog, L"Installing sessmgr service\n" );
                hRes = S_OK;

                //
                // Clean up again, we might not be running in system 
                // context at the time of uninstall so clean up will failed.
                //
                dwStatus = RegOpenKeyEx( 
                                    HKEY_LOCAL_MACHINE, 
                                    REGKEYCONTROL_REMDSK, 
                                    0,
                                    KEY_ALL_ACCESS, 
                                    &hKey 
                                );

                if( ERROR_SUCCESS == dwStatus )
                {
                    //
                    // Check to see if previous uninstall failed, 
                    // we only need to check value exists.
                    //
                    dwStatus = RegQueryValueEx(
                                        hKey,
                                        UNINSTALL_BEFORE_INSTALL,
                                        0,
                                        &dwType,
                                        (BYTE *) &dwValue,
                                        &cbData
                                    );

                    if( ERROR_SUCCESS != dwStatus || REG_DWORD != dwType )
                    {
                        //
                        // No previous uninstall information, no need to delete anything
                        //
                        LogSetup( pSetupLog, L"UninstallBeforeInstall value not found or invalid, code %d\n", dwStatus );
                    }
                    else
                    {
                        LogSetup( pSetupLog, L"UninstallBeforeInstall exists, cleanup previous uninstall\n" );

                        //
                        // Previous uninstall failed, delete all pending help session,
                        // and clean up encryption key
                        //
                        dwStatus = RegDelKey( 
                                        HKEY_LOCAL_MACHINE, 
                                        REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE 
                                    );
                        //
                        // It's OK to fail here since we reset encryption key making existing 
                        // ticket useless and will be deleted on expire.
                        //

                        LogSetup( pSetupLog, L"Delete pending table return %d\n", dwStatus );

                        dwStatus = TSHelpAssistantInitializeEncryptionLib();
                        if( ERROR_SUCCESS == dwStatus ) 
                        {
                            dwStatus = TSHelpAssisantEndEncryptionCycle();
    
                            if( ERROR_SUCCESS != dwStatus )
                            {
                                LogSetup( pSetupLog, L"TSHelpAssisantEndEncryptionCycle() returns 0x%08x\n", dwStatus );
                                LogSetup( pSetupLog, L"sessmgr setup can't continue\n" );

                                // Critical security error, existing ticket might still be valid
                                hRes = HRESULT_FROM_WIN32( dwStatus );
                            }

                            TSHelpAssistantEndEncryptionLib();
                        }
                        else
                        {
                            LogSetup( pSetupLog, L"TSHelpAssistantInitializeEncryptionLib return %d\n", dwStatus );
                            LogSetup( pSetupLog, L"sessmgr setup can't continue\n" );

                            // Critical security error, existing ticket might still be valid
                            hRes = HRESULT_FROM_WIN32( dwStatus );
                        }
                    }

                    if( SUCCEEDED(hRes) )
                    {
                        //
                        // Delete reg. value to uninstall before install only when successfully 
                        // resetting encryption key
                        //
                        RegDeleteValue( hKey, UNINSTALL_BEFORE_INSTALL );
                    }

                    RegCloseKey( hKey );
                }

                if( SUCCEEDED(hRes) )
                {
                    hRes = g_HelpAccount.CreateHelpAccount();
                    if( SUCCEEDED(hRes) )
                    {
                        CComBSTR bstrHelpAccName;

                        hRes = g_HelpAccount.GetHelpAccountNameEx( bstrHelpAccName );
                        MYASSERT( SUCCEEDED(hRes) );

                        if( FAILED(hRes) )
                        {
                            // not a critical error, we can still use help
                            LogSetup( pSetupLog, L"Failed to retrieve HelpAssistantaccount name - 0x%08x\n", hRes );
                        }
                        else
                        {
                            LogSetup( pSetupLog, L"HelpAssistant account name - %s\n", bstrHelpAccName );

                            // Add HelpAssistantAccount into account filter list
                            AddAccountToFilterList( bstrHelpAccName );
                        }

                        //
                        // Two type of SP install, one thru SP1 installer and the other is 
                        // normal NT setup including all SP fixes.
                        // We disable account on setup and let service startup to re-enable it
                        //
                        g_HelpAccount.EnableHelpAssistantAccount(FALSE);

                        //
                        // Upgrade session manager
                        // 
                        UpgradeSessmgr(pSetupLog);

                        LogSetup( pSetupLog, L"Successfully setup account\n" );
                        hRes = _Module.RegisterServer(pSetupLog, TRUE, TRUE);

                        if( FAILED(hRes) )
                        {
                            LogSetup( pSetupLog, L"Failed to register/installing service - 0x%08x\n", hRes );
                        }
                    }
                    else
                    {
                        LogSetup( pSetupLog, L"Creating Help Assistant account failed with 0x%08x\n", hRes );

                        (void) g_HelpAccount.DeleteHelpAccount();
                        hRes = E_FAIL;
                    }
                }

                if( SUCCEEDED(hRes) )
                {
                    hRes = CreatePendingHelpTable(pSetupLog);
                    if( FAILED(hRes) )
                    {
                        LogSetup( 
                                pSetupLog, 
                                L"CreatePendingHelpTable() failed - 0x%08x\n", 
                                hRes 
                            );
                    }
                }
            }
            break;

        default:

            LogSetup( pSetupLog, L"Invalid setup operation %d\n", code );

            hRes = E_UNEXPECTED;
    }


    LogSetup( pSetupLog, L"\n*** Finish Setup with Status 0x%08x ***\n", hRes );

    if( pSetupLog )
    {
        fflush( pSetupLog );
        fclose( pSetupLog);
    }

    return hRes;
}


/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    HRESULT hRes;
    CComBSTR bstrErrMsg;
    CComBSTR bstrServiceDesc;
    DWORD dwStatus;
    
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, IDS_SERVICEDISPLAYNAME, IDS_SERVICEDESC, &LIBID_RDSESSMGRLib);
    _Module.m_bService = TRUE;

    TCHAR szTokens[] = _T("-/");

    //
    // We don't do OS version checking as in Win9x case, some of our 
    // call uses API not exists on Win9x so will get unresolve
    // reference when running on Win9x box.
    //

    bstrServiceDesc.LoadString( IDS_SERVICEDISPLAYNAME );

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            return InstallUninstallSessmgr( SESSMGR_UNREGSERVER );
        } 
        else if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            return InstallUninstallSessmgr( SESSMGR_REGSERVER );
        }
        else if (lstrcmpi(lpszToken, _T("Service"))==0)
        {
            return InstallUninstallSessmgr( SESSMGR_SERVICE );
        }
        else if ( lstrcmpi(lpszToken, _T("SP1Upgrade"))==0)
        {
            // BUGL 602653, HelpAssistant account is not disable at clean install
            // disable account here and let service start up to re-enable.
            return EnableLocalAccount( HELPASSISTANTACCOUNT_NAME, FALSE );
        }

        lpszToken = FindOneOf(lpszToken, szTokens);
    }


    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
    {
        _Module.LogErrorEvent( SESSMGR_E_SETUP );
        return lRes;
    }

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{038ABBA4-4138-4AC4-A492-4A3DF068BD8A}"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
    {
        _Module.LogErrorEvent( SESSMGR_E_SETUP );
        return lRes;
    }

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\rdsgp.cpp ===
// policy.cpp : Implementation of CCRemoteDesktopSystemPolicy
#include "stdafx.h"
#include "rdsgp.h"

CCriticalSection CRemoteDesktopSystemPolicy::m_Lock;    

/////////////////////////////////////////////////////////////////////////////
// CRemoteDesktopSystemPolicy

STDMETHODIMP
CRemoteDesktopSystemPolicy::get_AllowGetHelp( 
    /*[out, retval]*/ BOOL *pVal
    )
/*++

Routine Description:

    Retrieve where system is allowed to be in 'GetHelp' mode.

Parameters:

    pVal : Pointer to BOOL to receive whether system can be
           in GetHelp mode.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;
    
    *pVal = TSIsMachinePolicyAllowHelp();
    return hRes;
}


STDMETHODIMP
CRemoteDesktopSystemPolicy::put_AllowGetHelp(
    /*[in]*/ BOOL Val
    )
/*++

Routine Description:

    Set Allow to get help on local system, caller must
    be Administrator or member of Administrators group.

Parameters:

    Val : TRUE to enable GetHelp, FALSE otherwise.

Returns:

    S_OK
    HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED )
    error code.

--*/
{
    HRESULT hRes = S_OK;

    hRes = ImpersonateClient();

    if( SUCCEEDED(hRes) )
    {
        hRes = HRESULT_FROM_WIN32( ConfigSystemGetHelp( Val ) );
        EndImpersonateClient();
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopSystemPolicy::get_RemoteDesktopSharingSetting(
    /*[out, retval]*/ REMOTE_DESKTOP_SHARING_CLASS *pLevel
    )
/*++

Routine Description:

    Retrieve RDS sharing level on local system, function
    retrieve setting from Group Policy first, then from 
    WINSTATION setting.

Parameters:
    
    pLevel : Pointer to REMOTE_DESKTOP_SHARING_CLASS to receive
             RDS sharing level.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;

    hRes = HRESULT_FROM_WIN32( GetSystemRDSLevel( GetUserTSLogonId(), pLevel ) );

    return hRes;
}


STDMETHODIMP
CRemoteDesktopSystemPolicy::put_RemoteDesktopSharingSetting(
    /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS Level
    )
/*++

Routine Description:

    Set machine level RDS sharing level, this level 
    will override user setting.

Parameters:
    
    Level : new REMOTE_DESKTOP_SHARING_CLASS level

Returns:

    S_OK or error code.

Note:

    Function depends on platform and setting from Group Policy
    and TSCC settings.

--*/
{
    HRESULT hRes;

    hRes = ImpersonateClient();

    if( SUCCEEDED(hRes) )
    {
        hRes = HRESULT_FROM_WIN32( ConfigSystemRDSLevel(Level) );
        EndImpersonateClient();
    }

    return hRes;
}


/////////////////////////////////////////////////////////////////////////////
// CRemoteDesktopUserPolicy

STDMETHODIMP
CRemoteDesktopUserPolicy::get_AllowGetHelp(
    /*[out, retval]*/ BOOL* pVal
    )
/*++

Routine Description:

    Retrieve whether currently logon user can 
    'GetHelp'

Parameters:

    pVal : Pointer to BOOL to receive user's GetHelp setting.

Returns:

    S_OK or error code

--*/
{
    HRESULT hRes;
    CComBSTR bstrUserSid;

    hRes = ImpersonateClient();

    GetUserSidString( bstrUserSid );
    if( SUCCEEDED(hRes) )
    {
        *pVal = IsUserAllowToGetHelp(GetUserTSLogonId(), (LPCTSTR) CComBSTRtoLPTSTR(bstrUserSid) );
        EndImpersonateClient();
    }

    return hRes;
}

STDMETHODIMP
CRemoteDesktopUserPolicy::get_RemoteDesktopSharingSetting(
    /*[out, retval]*/ REMOTE_DESKTOP_SHARING_CLASS* pLevel
    )
/*++

Routine Description:

    Retrieve currently logon user's desktop sharing level.

Parameters:

    pLevel : Pointer to REMOTE_DESKTOP_SHARING_CLASS to receive user's RDS level.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes;

    hRes = ImpersonateClient();

    if( SUCCEEDED(hRes) )
    {
        hRes = HRESULT_FROM_WIN32( GetUserRDSLevel(GetUserTSLogonId(), pLevel) );
        EndImpersonateClient();
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TERMSRV_ROOT=$(PROJECT_ROOT)
SESSMGR_IDL_OUTPUTDIR=$(TERMSRV_ROOT)\common\remdskidl\obj\$(TARGET_DIRECTORY)
ICS_DIR=$(REMDSK_ROOT)\server\ics\icshelper

INCPATHRC=$(INCPATHRC);$(SESSMGR_IDL_OUTPUTDIR)

INCLUDES=\
        $(INCLUDES);\
        $(TERMSRV_ROOT)\inc;\
        $(REMDSK_ROOT)\common;\
        $(ICS_DIR);\
        $(SESSMGR_IDL_OUTPUTDIR);\
        $(DS_INC_PATH)\crypto; \
        $(PROJECT_ROOT)\admtools\tscc\cfgcomp; \
        $(PROJECT_ROOT)\admtools\tscc\cfgcomp\$(O); \
        $(PROJECT_ROOT)\common\license\inc;\
        $(BASEDIR)\public\internal\admin\inc;

#DEBUG_CRTS=1

#C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE -DFEATURE_USERBLOBS

USE_MSVCRT=1
USE_NATIVE_EH=1
USE_STL=1
NOT_LEAN_AND_MEAN=1
ATL_VER=30
USE_STATIC_ATL=1
USE_VCCOM=1
USE_PDB=1

MAJORCOMP=RemoteDesktop
MINORCOMP=SessMgr

TARGETNAME=$(MINORCOMP)
TARGETPATH=obj
TARGETTYPE=PROGRAM
UMTYPE=windows

PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_SOURCEFILE=..\stdafx.cpp
PRECOMPILED_CXX = 1

PASS0_HEADERDIR=$(O)
MC_SOURCEDIR=$(O)

SOURCES= \
    sessmgrmc.mc \
    SessMgrnt.rc \
    HelpMgr.cpp \
    HelpSess.cpp \
    HelpAcc.cpp \
    global.cpp \
    HelpTab.cpp \
    sessmgr.cpp \
    Helper.cpp \
    policy.cpp

TARGETLIBS=\
    $(ICS_DIR)\$(O)\raics.lib \
    $(TERMSRV_ROOT)\winsta\tsremdsk\$(O)\tsremdsk.lib \
    $(PROJECT_ROOT)\lib\$(O)\RDuuid.lib \
    $(TERMSRV_ROOT)\lib\$(O)\cryptlib.lib \
    $(TERMSRV_ROOT)\lib\$(O)\tsctrcu.lib \
    $(TERMSRV_ROOT)\lib\$(O)\tlsapip.lib \
    $(BASEDIR)\public\sdk\lib\*\ntlsapi.lib \
    $(BASEDIR)\public\sdk\lib\*\secur32.lib \
    $(BASEDIR)\public\sdk\lib\*\netapi32.lib \
    $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
    $(BASEDIR)\public\sdk\lib\*\netapi32.lib \
    $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib \
    $(BASEDIR)\public\sdk\lib\*\rpcns4.lib \
    $(BASEDIR)\public\sdk\lib\*\user32.lib \
    $(BASEDIR)\public\sdk\lib\*\shell32.lib \
    $(BASEDIR)\public\sdk\lib\*\oleaut32.lib \
    $(BASEDIR)\public\sdk\lib\*\ole32.lib \
    $(BASEDIR)\public\sdk\lib\*\uuid.lib \
    $(BASEDIR)\public\sdk\lib\*\ntdll.lib \
    $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	$(BASEDIR)\public\sdk\lib\*\crypt32.lib \
    $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
    $(BASEDIR)\public\sdk\lib\*\ws2_32.lib \
    $(BASEDIR)\public\sdk\lib\*\winmm.lib \
    $(BASEDIR)\public\sdk\lib\*\iphlpapi.lib \
    $(TERMSRV_LIB_PATH)\regapi.lib  \
    $(BASEDIR)\public\sdk\lib\*\winsta.lib \
    $(BASEDIR)\public\sdk\lib\*\wtsapi32.lib \
    $(BASEDIR)\public\sdk\lib\*\rasapi32.lib \
    $(REMDSK_ROOT)\common\lib\$(O)\rdskcmn.lib \
    $(BASEDIR)\public\sdk\lib\*\wsock32.lib

#    ..\idl\obj\*\sessmgr.lib \

SYNCHRONIZE_BLOCK=1
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\unittest\server\refcount\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\tsstl.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    tsstl.h

Abstract:

    Include all necessary STL include file

Author:

    HueiWang    2/17/2000

--*/

#ifndef _STL_H_
#define _STL_H_


#include <algorithm>
#include <deque>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

#endif	/* _STL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\unittest\server\refcount\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	refcount.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\unittest\server\refcount\refcount.cpp ===
// refcount.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include <atlbase.h>
#include <rdshost.h>
#include <rdshost_i.c>

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    DWORD cnt;
 	CoInitialize(NULL);

    IRemoteDesktopServerHost *host;
    IRemoteDesktopServer *srvr;

    HRESULT hr;
    hr = CoCreateInstance(
                CLSID_RemoteDesktopServerHost,
                NULL, CLSCTX_ALL,       
                __uuidof(IRemoteDesktopServerHost),
                (LPVOID*)&host
                );
    if (!SUCCEEDED(hr)) {
        fprintf(stderr, "CoCreateInstance:  %08X", hr);
        exit(-1);
    }

    hr = host->GetRemoteDesktopServer(&srvr);
    if (!SUCCEEDED(hr)) {
        fprintf(stderr, "GetRemoteDesktopServer:  %08X", hr);
        exit(-1);
    }

    srvr->StartListening();
    srvr->StopListening();
    /*
    srvr->StartListening();
    srvr->StopListening();
    */
    cnt = srvr->Release();
    cnt = host->Release();

    CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__97A939A5_466D_43B0_9150_CFBCC67F024B__INCLUDED_)
#define AFX_STDAFX_H__97A939A5_466D_43B0_9150_CFBCC67F024B__INCLUDED_

#ifndef __WIN9XBUILD__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>

#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <ntsecapi.h>
#include <lmcons.h>
#include <lm.h>

#include <wtsapi32.h>
#include <winsta.h>

#include "license.h"
#include "tlsapi.h"
#include "lscsp.h"

#endif

#include "safsessionresolver.h"
#include "tsremdsk.h"
#include "tsstl.h"
#include "locks.h"
#include "map.h"

#include "myassert.h"

#include "icshelpapi.h"


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

#ifndef __WIN9XBUILD__


#ifndef DBG

#define IDLE_SHUTDOWN_PERIOD        10 * 1000 * 60  // 10 min wait
#define EXPIRE_HELPSESSION_PERIOD   60 * 60 * 1000  // Clean up help session every hrs

#else

#define IDLE_SHUTDOWN_PERIOD        1000 * 60 * 5   // 1 min. time out
#define EXPIRE_HELPSESSION_PERIOD   5 * 60 * 1000   // Clean up help session every 5 min.

#endif

#define SESSMGR_NOCONNECTIONEVENT_NAME L"Global\\RemoteDesktopSessMgr"
#define SERVICE_STARTUP_WAITHINT    1000*30 // 30 second wait
#define REGKEY_SYSTEM_EVENTSOURCE L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System"
#define MAX_FETCHIPADDRESSRETRY     5
#define DEFAULT_MAXTICKET_EXPIRY    30 * 24 * 60 * 60   // Default max. ticket valid period


class CServiceModule : public CComModule
{
public:

    static DWORD WINAPI
    HandlerEx(
        DWORD dwControl,
        DWORD dwEventType,
        LPVOID lpEventData,
        LPVOID lpContext
    );
    
	HRESULT 
    RegisterServer(
        FILE* pSetupLog,
        BOOL bRegTypeLib, 
        BOOL bService
    );

	HRESULT 
    UnregisterServer(FILE* pSetupLog);

    HRESULT 
    SetupEventViewerSource( 
        FILE* pSetupLog
    );

	void 
    Init(
        _ATL_OBJMAP_ENTRY* p, 
        HINSTANCE h, 
        UINT nServiceNameID, 
        UINT nServiceDispNameID, 
        UINT nServiceDescID, 
        const GUID* plibid = NULL
    );

    void Start();
	void 
    ServiceMain(
        DWORD dwArgc, 
        LPTSTR* lpszArgv
    );

    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled(FILE* pSetupLog);
    BOOL Install(FILE* pSetupLog);
    BOOL Uninstall(FILE* pSetupLog);
	LONG Unlock();
    BOOL UpdateService(FILE* pSetupLog);

    void
    LogInfoEvent(
        DWORD dwCode
    );

    void
    LogWarningEvent(
        DWORD dwCode
    );

    void 
    LogErrorEvent(
        DWORD dwCode
    );

    void
    LogEventWithStatusCode(
        DWORD dwEventType,
        DWORD dwEventId,
        DWORD dwCode
    );

    void
    LogEventString(
        DWORD dwEventType,
        DWORD dwEventId,
        DWORD dwNumString,
        LPCTSTR* lpStrings,
        DWORD dwBinaryDataSize = 0,
        LPVOID lpRawData = NULL
    );

    void
    LogSessmgrEventLog(
        DWORD dwEventType,
        DWORD dwEventCode,
        CComBSTR& bstrNoviceDomain,
        CComBSTR& bstrNoviceAccount,
        CComBSTR& bstrRaType,
        CComBSTR& bstrExpertIPFromClient,
        CComBSTR& bstrExpertIPFromTS,
        DWORD dwErrCode
    );

    void 
    SetServiceStatus(DWORD dwState);

    void 
    SetupAsLocalServer();

    ULONG
    AddRef();

    ULONG
    Release();
 
    CServiceModule() : m_RefCount(0), CComModule() {}

    DWORD
    GetServiceStartupStatus()
    {
        return m_dwServiceStartupStatus;
    }

    BOOL
    IsSuccessServiceStartup() 
    {
        return ERROR_SUCCESS == m_dwServiceStartupStatus;
    }


    BOOL
    InitializeSessmgr();

   
//Implementation
private:


    static HANDLE gm_hIdle;
    static HANDLE gm_hIdleMonitorThread;
    static HANDLE gm_hICSAlertEvent;

	static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);
    static unsigned int WINAPI IdleMonitorThread( void* ptr );
    //static unsigned int WINAPI StartupInitThread( void* ptr );

// data members
public:

    //
    // Refer to CreateService() for 256
    //
    TCHAR m_szServiceDesc[257];
    TCHAR m_szServiceName[257];
    TCHAR m_szServiceDispName[257];

    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
	DWORD dwThreadID;
	BOOL m_bService;

    CCriticalSection m_Locks;
    long m_RefCount;
    BOOL m_Initialized;

    DWORD m_dwServiceStartupStatus;
};

extern CServiceModule _Module;

#else

class CExeModule : public CComModule
{
private:
    CSafeCounter m_RefCount;

public:
    CExeModule() : m_RefCount(0) {}

	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;

    ULONG
    AddRef() { return ++m_RefCount; }

    ULONG
    Release() { return --m_RefCount; }
   
};

extern CExeModule _Module;

#endif

#include <atlcom.h>
#include "sessmgrmc.h"
#include "sessmgr.h"
#include "helper.h"
#include "helptab.h"
#include "helpmgr.h"
#include "helpsess.h"
#include "tsremdsk.h"
#include "rderror.h"

class CComBSTRtoLPTSTR {

private:

    LPTSTR m_pszString;

    LPTSTR
    ConvertString( LPWSTR pszString )
    {
    #ifdef UNICODE

        return pszString;
        
    #else

        char* pszAnsiString = NULL;
        int length = wcslen(pszString);
        int bufSize;

        if( length > 0 )
        {
            bufSize = WideCharToMultiByte(
                                    GetACP(),
                                    WC_DEFAULTCHAR,
                                    (LPWSTR)pszString,
                                    -1,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL
                                );

            if(bufSize != 0)
            {
                pszAnsiString = (LPSTR)LocalAlloc(LPTR, (bufSize + 1) * sizeof(char));

                if( NULL != pszAnsiString )
                {
                    bufSize = WideCharToMultiByte(
                                            GetACP(),
                                            WC_DEFAULTCHAR,
                                            pszString,
                                            length,
                                            pszAnsiString,
                                            bufSize,
                                            NULL,
                                            NULL
                                        );

                    if( bufSize == 0 )
                    {
                        LocalFree( pszAnsiString );
                        pszAnsiString = NULL;
                        MYASSERT(FALSE);
                    }
                }
            }
        }

        return pszAnsiString;

    #endif
    }


public:

    CComBSTRtoLPTSTR( CComBSTR& bstr )
    {
        m_pszString = ConvertString( bstr );

        if( NULL == m_pszString )
        {
            throw GetLastError();
        }
    }

    ~CComBSTRtoLPTSTR()
    {
        #ifndef UNICODE
        if( NULL != m_pszString )
        {
            LocalFree( m_pszString );
        }
        #endif
    }

    operator LPCTSTR()
    {
        return m_pszString;
    }

    operator LPTSTR()
    {
        return m_pszString;
    }
};


#ifndef AllocMemory

#define AllocMemory(size) \
    LocalAlloc(LPTR, size)

#endif

#ifndef FreeMemory

#define FreeMemory(ptr) \
    if(ptr)             \
    {                   \
        LocalFree(ptr); \
        ptr=NULL;       \
    }

#endif

#ifndef ReallocMemory

#define ReallocMemory(ptr, size)                 \
            LocalReAlloc(ptr, size, LMEM_ZEROINIT)

#endif


#define REGKEYCONTROL_REMDSK   _TEXT("Software\\Microsoft\\Remote Desktop")
#define CLASS_PRIVATE
#define CLASS_PUBLIC
#define CLASS_STATIC

struct __declspec(uuid("A55737AB-5B26-4A21-99B7-6D0C606F515E")) SESSIONRESOLVER;
#define SESSIONRESOLVERCLSID    __uuidof(SESSIONRESOLVER)


#define HELPSESSION_UNSOLICATED _TEXT("UnsolicitedHelp")
#define HELPSESSION_NORMAL_RA _TEXT("SolicitedHelp")

//
// HYDRA_CERT_REG_KEY 
// HYDRA_X509_CERTIFICATE
// X509_CERT_PUBLIC_KEY_NAME
// defined in lscsp.h
//

#define REGKEY_TSX509_CERT              _TEXT(HYDRA_CERT_REG_KEY) 
#define REGVALUE_TSX509_CERT            _TEXT(HYDRA_X509_CERTIFICATE)

#define LSA_TSX509_CERT_PUBLIC_KEY_NAME X509_CERT_PUBLIC_KEY_NAME


//
// Message for notify session logoff or disconnect,
// WPARAM : Not use
// LPARAM : the logoff or disconnecting session.
// 
#define WM_SESSIONLOGOFFDISCONNECT    (WM_APP + 1)

//
// Message for expiring help ticket
// WPARAM : Not use
// LPARAM : Not use
// 
#define WM_EXPIREHELPSESSION          (WM_SESSIONLOGOFFDISCONNECT + 1)

//
// Notification message to reload termsrv public key
// WPARAM : Not use
// LPARAM : Not use
// 
#define WM_LOADTSPUBLICKEY            (WM_EXPIREHELPSESSION + 1)


//
// Notification for rdsaddin terminates
// WPARAM : Not use
// LPARAM : Pointer to help session (ticket) object.
// 
#define WM_HELPERRDSADDINEXIT       (WM_LOADTSPUBLICKEY + 1)




//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__97A939A5_466D_43B0_9150_CFBCC67F024B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\lsview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tslsview.rc
//
#define IDS_STR_COL1                    1
#define IDS_STR_COL2                    2
#define IDS_STR_COL3                    3
#define IDS_TYPE_ENT                    4
#define IDS_TYPE_DOMAIN                 5
#define IDS_TRAYSTOP                    6
#define IDS_TRAYGREEN                   7
#define IDS_TIP                         8
#define IDS_TITLE                       9
#define IDS_BUBBLE                      10
#define IDS_TRAYFILE                    11
#define IDS_FILTER                      12
#define IDS_YELLOW                      13
#define IDS_ERROR_QS                    14
#define IDS_EXTENSION                   15

#define IDI_TSLSVIEW                    50
#define IDC_ICON_STOP                   51
#define IDC_ICON_GO                     52
#define IDC_ICON_CAUTION                53
#define IDC_ICON_NONE                   54


#define IDM_MINIMIZE                    70
#define IDM_RESTORE                     71
#define IDM_EXIT                        72
#define IDR_TRAYMENU                    73

#define IDD_CDEXT                       90
#define IDC_CHECK1                      91
#define ID_EDT_NUM                      92
#define IDC_SPIN1                       93

#define IDC_STATIC                      -1

#define IDD_LSVIEW                      101
#define IDR_MENU_LSVIEW                 102
#define IDC_LSVIEW_LIST                 1000
#define ID_FILE_CREATELOGFILE           40001
#define ID_FILE_EXIT                    40002
#define ID_HELP_ABOUT                   40003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\lsview\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
// C RunTime Header Files
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <commctrl.h>
#include <dlgs.h>
#include "resource.h"
#include <stdlib.h>

#include<commdlg.h>
#include <license.h>
#include <tlsapi.h>
#include <tlsapip.h>

//////////////////////////////////////////////////////////////////////////////
typedef struct __ServerEnumData {
    DWORD dwNumServer;
    long dwDone;
    HWND hList;
} ServerEnumData;

typedef struct _list
{
    LPTSTR pszMachineName;
    LPTSTR pszTimeFormat;
    LPTSTR pszType;
    _list *pNext;
} LIST , *PLIST;

typedef struct _DataObject
{
    BOOL bIsChecked;
    BOOL bNotifyOnce;
    DWORD dwTimeInterval;
    WCHAR wchFileName[ MAX_PATH ];
} DATAOBJECT , *PDATAOBJECT;


#define SIZEOF( x ) sizeof( x ) / sizeof( x[0] )
#ifdef DBG
#define ODS OutputDebugString

#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[80]; \
    wsprintf( tchErr , x , y ); \
    ODS( tchErr ); \
    }


#else

#define ODS
#define DBGMSG
#endif



// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\lsview\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	tslsview.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\lsview\tslsview.cpp ===
// tslsview.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
//#include "resource.h"

//=---------globals------------
static HINSTANCE g_hinst;
static BOOL g_fInitialized;
ServerEnumData g_sed;
PLIST g_pHead;
static HANDLE g_hEvent;
static BOOL g_bAutomaticLog;
static DWORD g_dwInterval;

TCHAR szLsViewKey[] = TEXT( "Software\\Microsoft\\Windows NT\\CurrentVersion\\LsView" );
//-----------------------------

//-------------function prototypes ----------------
BOOL CALLBACK Dlg_Proc( HWND hwnd , UINT msg , WPARAM wp, LPARAM lp );
BOOL OnInitApp( HWND );
void OnTimedEvent( HWND hDlg );
DWORD DiscoverServers( LPVOID ptr );
BOOL ServerEnumCallBack( TLS_HANDLE hHandle,
                         LPCTSTR pszServerName,
                         HANDLE dwUserData );

void OnReSize( HWND hwnd ,
               WPARAM wp ,
               LPARAM lp );
BOOL DeleteList( PLIST );
BOOL AddItem( LPTSTR , LPTSTR , LPTSTR  );
void CreateLogFile( HWND );
BOOL Tray_Init( HWND hwnd , BOOL );
BOOL Tray_ToGreen( HWND hwnd );
BOOL Tray_ToYellow( HWND hwnd , LPTSTR szMsg );
BOOL Tray_ToRed( HWND hwnd );
BOOL Tray_Remove( HWND hwnd );
BOOL Tray_ToXXX( HWND hwnd , LPTSTR szTip , UINT resid );
BOOL Tray_Notify( HWND hwnd , WPARAM wp , LPARAM lp );
UINT_PTR CALLBACK OFNHookProc( HWND hdlg , UINT uiMsg, WPARAM wParam, LPARAM lParam );
BOOL RetrieveDataObject( PDATAOBJECT pObj );
BOOL StoreDataObject( PDATAOBJECT pObj );
BOOL LogFile( LPTSTR szFileName );
//-------------------------------------------------

//=---------constants------------
const UINT kTimerId = 23456;
const UINT kDefaultElapseTime = 1000 * 60 * 5;
const UINT kMaxMinutes = 71582;
const UINT kBubbleTimeout = 10 * 1000;
#define TN_MESSAGE ( WM_USER + 60 )
//-----------------------------

//-------------------------------------------------------------------------
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR    lpCmdLine,
                     int       nCmdShow)
{    
    
    INITCOMMONCONTROLSEX icc = { sizeof( INITCOMMONCONTROLSEX ) ,
                                 ICC_LISTVIEW_CLASSES };

    HANDLE hMutex = CreateMutex( NULL , FALSE , TEXT("TSLSVIEW2" ) );

    if( GetLastError() == ERROR_ALREADY_EXISTS )
    {
        TCHAR szTitle[ 60 ];

        DBGMSG( TEXT( "TSLSVIEW: App instance already running\n" ) , 0 );

        LoadString( hInstance , 
                    IDS_TITLE ,
                    szTitle ,
                    SIZEOF( szTitle ) );

        HWND hWnd = FindWindow( NULL , szTitle );

        if( hWnd != NULL )
        {
            SetForegroundWindow( hWnd );
        }

        return 0;
    }

    if( !InitCommonControlsEx( &icc ) )
    {
        DBGMSG( TEXT("InitCommonControlsEx failed with 0x%x\n") , GetLastError( ) );

        return 0;
    }

    g_hinst = hInstance;

    g_fInitialized = FALSE;

    g_hEvent = CreateEvent( NULL , FALSE , TRUE , NULL );

    g_pHead = ( PLIST )new LIST[1];

    if( g_pHead == NULL )
    {
        ODS( TEXT( "LSVIEW out of memory\n" ) );

        return 0;
    }

    g_pHead->pszMachineName = NULL;
    g_pHead->pszTimeFormat = NULL;
    g_pHead->pszType = NULL;
    g_pHead->pNext = NULL;
    
    DialogBox( hInstance ,
               MAKEINTRESOURCE( IDD_LSVIEW ),
               NULL,
               ( DLGPROC )Dlg_Proc );

    
    CloseHandle( hMutex );

    CloseHandle( g_hEvent );

    DeleteList( g_pHead );

    return 0;
}

//-------------------------------------------------------------------------
BOOL CALLBACK Dlg_Proc( HWND hwnd , UINT msg , WPARAM wp, LPARAM lp )
{
    TCHAR szTitle[ 60 ];

    switch( msg )
    {
    case WM_COMMAND:
        switch( LOWORD( wp ) )
        {
        case ID_FILE_EXIT:
            EndDialog( hwnd , 0 );
            break;

        case ID_FILE_CREATELOGFILE:

            if( WaitForSingleObject( g_hEvent , 0 ) == WAIT_TIMEOUT )
            {
                TCHAR szBuffer[ 255 ];

                LoadString( g_hinst ,
                            IDS_ERROR_QS ,
                            szBuffer ,
                            SIZEOF( szBuffer )
                           );

                LoadString( g_hinst ,
                            IDS_TITLE ,
                            szTitle ,
                            SIZEOF( szTitle )
                          );

                MessageBox( hwnd , szBuffer, szTitle , MB_OK | MB_ICONINFORMATION );
            }
            else
            {
                SetEvent( g_hEvent );

                CreateLogFile( hwnd );
            }
            break;

        case ID_HELP_ABOUT:

            LoadString( g_hinst ,
                        IDS_TITLE ,
                        szTitle ,
                        SIZEOF( szTitle )
                      );

            ShellAbout( hwnd ,
                        szTitle ,
                        NULL ,
                        LoadIcon( g_hinst , MAKEINTRESOURCE( IDI_TSLSVIEW ) )
                        );
            break;

        case IDM_MINIMIZE:
            ShowWindow( hwnd , SW_MINIMIZE );
            break;

        case IDM_RESTORE:
            ShowWindow( hwnd , SW_RESTORE );
            break;

        case IDM_EXIT:
            DestroyWindow( hwnd );
            break;
        }      

        break;

    case WM_CLOSE:
    case WM_DESTROY:

        Tray_ToRed( hwnd );

        KillTimer( hwnd , kTimerId );

        Tray_Remove( hwnd );

        EndDialog( hwnd , 0 );

        break;

    case WM_INITDIALOG:
        OnInitApp( hwnd );
        break;

    case WM_TIMER:
        if( wp == ( WPARAM )kTimerId )
        {
            OnTimedEvent( hwnd );
        }

        break;

    case WM_SIZE:
        
        OnReSize( hwnd , wp , lp );

        break;

    case TN_MESSAGE:

        Tray_Notify( hwnd , wp , lp );

        break;

    }
    return FALSE;
}
//-------------------------------------------------------------------------
BOOL InitListView( HWND hwnd )
{
    int rgIds[] = { IDS_STR_COL1 ,
                  IDS_STR_COL2 ,
                  IDS_STR_COL3 ,
                   -1 };

    LV_COLUMN lvc;
    TCHAR tchBuffer[ 60 ];

    HWND hListView = GetDlgItem( hwnd , IDC_LSVIEW_LIST ) ;

    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    
    for( int idx=0; rgIds[idx] != -1; ++idx )
    {
        LoadString( g_hinst ,
                    ( UINT )rgIds[idx],
                    tchBuffer,
                    SIZEOF( tchBuffer ) );

        if( idx == 1 )
        {
            lvc.cx = 225;
        }
        else
        {
            lvc.cx = 75;
        }

        lvc.pszText = tchBuffer;
        lvc.iSubItem = idx;

        ListView_InsertColumn( hListView ,
                               idx ,
                               &lvc );

    }

    DWORD dwStyle = ( DWORD )SendMessage( hListView ,
                                          LVM_GETEXTENDEDLISTVIEWSTYLE ,
                                          0 ,
                                          0 );

    dwStyle |= ( LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES ) ;

    SendMessage( hListView , LVM_SETEXTENDEDLISTVIEWSTYLE , 0 , dwStyle );

    return TRUE;
}

//-------------------------------------------------------------------------
BOOL OnInitApp( HWND hwnd )
{
    DATAOBJECT dobj;

    // set up listview extended mode

    InitListView( hwnd );

    LONG_PTR lptrIcon;

    lptrIcon = ( LONG_PTR )LoadImage( g_hinst ,
                                      MAKEINTRESOURCE( IDI_TSLSVIEW ),
                                      IMAGE_ICON,
                                      16,
                                      16,
                                      0
                                      );


    SetClassLongPtr( hwnd , GCLP_HICONSM , lptrIcon );

    lptrIcon = ( LONG_PTR )LoadImage( g_hinst ,
                                      MAKEINTRESOURCE( IDI_TSLSVIEW ),
                                      IMAGE_ICON,
                                      0,
                                      0,
                                      0
                                      );

    SetClassLongPtr( hwnd , GCLP_HICON , lptrIcon );

    ZeroMemory( &dobj , sizeof( dobj ) );

    if( RetrieveDataObject( &dobj ) )
    {
        g_bAutomaticLog = dobj.bIsChecked;
        
        g_dwInterval = dobj.dwTimeInterval * 1000 * 60;
    }

    if( dobj.dwTimeInterval == 0 )
    {
        g_dwInterval = ( DWORD )kDefaultElapseTime;
    }
    
    // setup initial trayicon

    Tray_Init( hwnd , dobj.bNotifyOnce );

    if( !dobj.bNotifyOnce )
    {
        dobj.bNotifyOnce = TRUE;

        StoreDataObject( &dobj );
    }

    // set cursor to hourglass
       
    OnTimedEvent( hwnd );

    SetTimer( hwnd ,
              kTimerId,
              g_dwInterval,
              NULL
            );             



    return TRUE;
}

//-------------------------------------------------------------------------
void OnTimedEvent( HWND hDlg )
{
    ODS( L"LSVIEW: OnTimedEvent fired " );

    g_sed.dwNumServer = 0;
    g_sed.dwDone = 0;
    g_sed.hList = GetDlgItem( hDlg , IDC_LSVIEW_LIST );
    
    // remove all listview items
    DWORD dwValue;    

    dwValue = WaitForSingleObject( g_hEvent , 0 );

    if( dwValue == WAIT_TIMEOUT )
    {
        ODS( TEXT("still looking for servers\n" ) );
        
        return;
    }

    SetEvent( g_hEvent );

    ODS( TEXT("launching thread\n" ) );

    HANDLE hThread = CreateThread( NULL ,
                                   0 ,
                                   ( LPTHREAD_START_ROUTINE )DiscoverServers,
                                   ( LPVOID )&g_sed ,
                                   0,
                                   &dwValue
                                   );

    if( hThread == NULL )
    {
        DBGMSG( TEXT( "Failed to create DiscoverServer thread last error 0x%x\n" ) , GetLastError( ) );

        Tray_ToRed( hDlg );
    }

    CloseHandle( hThread );
}

//-------------------------------------------------------------------------
DWORD DiscoverServers( LPVOID ptr )
{
    WaitForSingleObject( g_hEvent , INFINITE );

    ODS( L"LSVIEW -- entering DiscoverServers\n" );

        

    if (!g_fInitialized)
    {
        TLSInit();
        g_fInitialized = TRUE;
    }

    LPWSTR *ppszEnterpriseServer = NULL;
    DWORD dwCount;
    DWORD index;
    
    // we could be writing out to a file we should wait




    if( g_pHead != NULL )
    {
        DeleteList( g_pHead->pNext );

        g_pHead->pNext = NULL;
    }
    //
    // Look for all license servers in domain
    //

    ServerEnumData *pEnumData = ( ServerEnumData * )ptr;

    TCHAR szBuffer[ 60 ];

    LoadString( g_hinst ,
                IDS_YELLOW ,
                szBuffer ,
                SIZEOF( szBuffer )
                );

    Tray_ToYellow( GetParent( pEnumData->hList ) , szBuffer );


    HRESULT hResult = EnumerateTlsServer( 
                               ServerEnumCallBack,
                               ptr,
                               3000,
                               FALSE
                               );

    hResult = GetAllEnterpriseServers( 
                               &ppszEnterpriseServer,
                               &dwCount
                               );

    if( hResult == ERROR_SUCCESS && dwCount != 0 && ppszEnterpriseServer != NULL )
    {

        TLS_HANDLE TlsHandle = NULL;


        //
        // Inform dialog
        //
        for(index = 0; index < dwCount && pEnumData->dwDone == 0; index++)
        {

            if( ppszEnterpriseServer[index] == NULL )
            {
                continue;
            }

            if(ServerEnumCallBack( 
                                NULL,
                                (LPTSTR)ppszEnterpriseServer[index],
                                pEnumData ) == TRUE 
                                )
            {
                continue;
            }

            TlsHandle = TLSConnectToLsServer(
                                (LPTSTR)ppszEnterpriseServer[index]
                                );

            if(TlsHandle == NULL )
            {
                continue;
            }

            ServerEnumCallBack( TlsHandle,
                                (LPTSTR)ppszEnterpriseServer[index],
                                pEnumData
                                );


            TLSDisconnectFromServer(TlsHandle);
        }
    

        if( ppszEnterpriseServer != NULL )
        {
            for( index = 0; index < dwCount; index ++)
            {
                if( ppszEnterpriseServer[ index ] != NULL )
                {
                    LocalFree( ppszEnterpriseServer[ index ] );
                }
            }

            LocalFree( ppszEnterpriseServer );
        }

    }


    ListView_DeleteAllItems( pEnumData->hList );  
    
    PLIST pTemp;

    if( g_pHead != NULL )
    {
        pTemp = g_pHead->pNext;

        while( pTemp != NULL )
        {      
            int nItem = ListView_GetItemCount( pEnumData->hList );

            LVITEM lvi;

            ZeroMemory( &lvi , sizeof( LVITEM ) );

            lvi.mask = LVIF_TEXT;
            lvi.pszText = pTemp->pszMachineName;
            lvi.cchTextMax = lstrlen( pTemp->pszMachineName );
            lvi.iItem = nItem;
            lvi.iSubItem = 0;

            ListView_InsertItem( pEnumData->hList ,
                                 &lvi
                               );

            // Set item for second column
            lvi.pszText = pTemp->pszTimeFormat;
            lvi.iSubItem = 1;
            lvi.cchTextMax = sizeof( pTemp->pszTimeFormat );

            ListView_SetItem( pEnumData->hList ,
                                 &lvi
                               );       

            // Set item for third column
            lvi.pszText = pTemp->pszType;
            lvi.iSubItem = 2;
            lvi.cchTextMax = sizeof( pTemp->pszType );

            ListView_SetItem( pEnumData->hList ,
                                 &lvi
                               );       

            pTemp = pTemp->pNext;
        }
    }

    if( g_bAutomaticLog )
    {
        DATAOBJECT db;

        ZeroMemory( &db , sizeof( DATAOBJECT ) );

        if( RetrieveDataObject( &db ) )
        {
            LogFile( db.wchFileName );
        }
    }

    ODS( L"LSVIEW : DiscoverServers completing\n" );

    // motion for green

    Tray_ToGreen( GetParent( pEnumData->hList ) );

    SetEvent( g_hEvent );

    ExitThread( hResult );

    return ( DWORD )hResult;
}

//-------------------------------------------------------------------------
BOOL ServerEnumCallBack( TLS_HANDLE hHandle,
                         LPCTSTR pszServerName,
                         HANDLE dwUserData )
                        
{
    int i;
    
    ServerEnumData* pEnumData = (ServerEnumData *)dwUserData;

    BOOL bCancel;

    if( pEnumData == NULL )
    {
        return FALSE;
    }

    bCancel = ( InterlockedExchange( &(pEnumData->dwDone) ,
                                     pEnumData->dwDone) == 1);

    if( bCancel == TRUE )
    {
        return TRUE;
    }


    if( hHandle != NULL )
    {
        DWORD dwStatus;
        DWORD dwErrCode;
        DWORD dwVersion;


        TCHAR szServer[ MAX_COMPUTERNAME_LENGTH + 1 ];
        TCHAR szMcType[ MAX_COMPUTERNAME_LENGTH + 1 ];
        TCHAR szTimeFormat[ 256 ];
        DWORD dwBufSize = SIZEOF( szServer);
        
        dwStatus = TLSGetServerNameEx( hHandle,
                                     szServer,
                                     &dwBufSize,
                                     &dwErrCode);

        TLSGetVersion(hHandle, &dwVersion);

        if( dwVersion & TLS_VERSION_ENTERPRISE_BIT )
        {
            LoadString( g_hinst , 
                        IDS_TYPE_ENT,
                        szMcType,
                        SIZEOF( szMcType ) );
            
        }
        else
        {
            LoadString( g_hinst , 
                        IDS_TYPE_DOMAIN,
                        szMcType,
                        SIZEOF( szMcType ) );

        }

        SYSTEMTIME st;

        TCHAR szDate[ 80 ];
        TCHAR szTime[ 80 ];

        GetLocalTime( &st );

        GetDateFormat( LOCALE_USER_DEFAULT ,
                       DATE_LONGDATE ,
                       &st,
                       NULL,
                       szDate,
                       SIZEOF( szDate ) );        

        GetTimeFormat( LOCALE_USER_DEFAULT,                       
                       TIME_NOSECONDS,
                       &st,
                       NULL,
                       szTime,
                       SIZEOF( szTime ) );

        wsprintf( szTimeFormat , TEXT( "%s %s") , szDate , szTime );

        AddItem( szServer , szTimeFormat , szMcType );

     
        // copy every other character because I have no clue on how to cast

        
        
        if( dwStatus == ERROR_SUCCESS && dwErrCode == ERROR_SUCCESS )
        {
            //
            // Make NT4 RPC call to ensure this server is compatible
            // with our version
            //
            pEnumData->dwNumServer++;
        }
    }


    //
    // Continue enumeration
    //
    return InterlockedExchange(&(pEnumData->dwDone), pEnumData->dwDone) == 1;
}

//-------------------------------------------------------------------------
void OnReSize( HWND hwnd , WPARAM wp , LPARAM lp )
{
    HWND hList = GetDlgItem( hwnd , IDC_LSVIEW_LIST );
    
    if( hList != NULL )
    {
        MoveWindow( hList , 
                    0 , 
                    0 ,
                    LOWORD( lp ),
                    HIWORD( lp ) ,
                    TRUE
                  );

    

        if( wp == SIZE_RESTORED  || wp == SIZE_MAXIMIZED )
        {
            ListView_RedrawItems( hList , 
                                  0 ,
                                  ListView_GetItemCount( hList )
                                );
        }
    }

}


//------------------------------------------------------------------------
// link list methods
//------------------------------------------------------------------------
BOOL AddItem( LPTSTR szMachineName , LPTSTR szTimeFormat , LPTSTR szType )
{
    ODS( TEXT("LSVIEW : Adding an item\n" ) );

    if( g_pHead == NULL )
    {
        return FALSE;
    }

    PLIST pNewItem = ( PLIST )new LIST[1];

    if( pNewItem == NULL )
    {
        ODS( TEXT( "LSVIEW AddItem out of memory\n" ) );

        return FALSE;
    }

    pNewItem->pNext = NULL;

    if( szMachineName != NULL )
    {
        pNewItem->pszMachineName = ( LPTSTR )new TCHAR[ lstrlen( szMachineName ) + 1 ];

        if( pNewItem->pszMachineName != NULL )
        {
            lstrcpy( pNewItem->pszMachineName , szMachineName );
        }
    }
    else
    {
        pNewItem->pszMachineName = NULL;
    }

    if( szTimeFormat != NULL )
    {
        pNewItem->pszTimeFormat = ( LPTSTR )new TCHAR[ lstrlen( szTimeFormat ) + 1 ];

        if( pNewItem->pszTimeFormat != NULL )
        {
            lstrcpy( pNewItem->pszTimeFormat , szTimeFormat );
        }
    }
    else
    {
        pNewItem->pszTimeFormat = NULL;
    }

    if( szType != NULL )
    {
        pNewItem->pszType = ( LPTSTR )new TCHAR[ lstrlen( szType ) + 1 ];

        if( pNewItem->pszType != NULL )
        {
            lstrcpy( pNewItem->pszType , szType );
        }
    }
    else
    {
        pNewItem->pszType = NULL;
    }

    //=--- find the next available entry

    PLIST pTemp = g_pHead;

    while( pTemp->pNext != NULL )
    {
        pTemp = pTemp->pNext;
    }

    pTemp->pNext = pNewItem;


    return TRUE;
}

//------------------------------------------------------------------------
BOOL DeleteList( PLIST pStart )
{
    PLIST pPleaseKillMe;

    if( pStart == NULL )
    {
        return TRUE;
    }   

    while( pStart != NULL )
    {
        pPleaseKillMe = pStart->pNext;

        if( pStart->pszMachineName != NULL )
        {
            delete[] pStart->pszMachineName;

        }
        if( pStart->pszTimeFormat != NULL )
        {
            delete[] pStart->pszTimeFormat;
        }          
        if( pStart->pszType != NULL )
        {
            delete[] pStart->pszType;
        }

        delete pStart;

        pStart = pPleaseKillMe;
    }


    return TRUE;

}

//------------------------------------------------------------------------
void CreateLogFile( HWND hwnd )
{
    // start the save as dialog
    OPENFILENAME ofn;
    TCHAR szBuffer[ 60 ];
    TCHAR szFilter[ 60 ] = { 0 };
    TCHAR szFileName[ MAX_PATH ];
    TCHAR szExt[ 10 ];
    DATAOBJECT dobj;

    ZeroMemory( &ofn , sizeof( OPENFILENAME ) );

    ZeroMemory( &dobj , sizeof( DATAOBJECT ) );

    RetrieveDataObject( &dobj );

    if( dobj.bIsChecked )
    {
        lstrcpy( szFileName , dobj.wchFileName );
    }
    else
    {
        szFileName[0] = 0;
    }


    LoadString( g_hinst ,
                IDS_FILTER ,
                szFilter ,
                SIZEOF( szFilter )
                );

    LoadString( g_hinst ,
                IDS_EXTENSION ,
                szExt ,
                SIZEOF( szExt )
                );


    ofn.lStructSize = sizeof( OPENFILENAME );
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile  = MAX_PATH;
    ofn.Flags = OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;
    ofn.lpTemplateName = MAKEINTRESOURCE( IDD_CDEXT );
    ofn.lpstrDefExt = szExt;
    ofn.hInstance = g_hinst;
    ofn.FlagsEx = OFN_EX_NOPLACESBAR;
    ofn.lpfnHook = OFNHookProc;

    // ok let's make them wait

    WaitForSingleObject( g_hEvent , INFINITE );

    // motion for yellow

    LoadString( g_hinst ,
                IDS_TRAYFILE ,
                szBuffer ,
                SIZEOF( szBuffer )
                );

    Tray_ToYellow( hwnd , szBuffer );

    if( GetSaveFileName( &ofn ) )
    {

        LogFile( szFileName );
    }
    else
    {
        DBGMSG( TEXT( "Last error was 0x%x\n" ) , CommDlgExtendedError( ) );
    }

    // motion for green

    Tray_ToGreen( hwnd );

    SetEvent( g_hEvent );

}

//-------------------------------------------------------------------------
UINT_PTR CALLBACK OFNHookProc( 
  HWND hdlg,      // handle to child dialog box window
  UINT uiMsg,     // message identifier
  WPARAM wParam,  // message parameter
  LPARAM lParam   // message parameter
  )
{
    DATAOBJECT dobj;
    TCHAR szDigits[ 16 ];

    switch( uiMsg )
    {
    
    case WM_INITDIALOG:
        {
            ODS( TEXT("OFNHookProc WM_INITDIALOG\n" ) );            

            ZeroMemory( &dobj , sizeof( DATAOBJECT ) );

            SendMessage( GetDlgItem( hdlg , IDC_SPIN1 ) , UDM_SETRANGE32 , ( WPARAM ) 1 , ( LPARAM )71582 );
    
            SendMessage( GetDlgItem( hdlg , IDC_SPIN1 ) , UDM_SETPOS32 , 1 , 0 );

            RetrieveDataObject( &dobj );
            
            CheckDlgButton( hdlg ,
                            IDC_CHECK1 ,
                            dobj.bIsChecked ? BST_CHECKED : BST_UNCHECKED
                          );
            
            dobj.dwTimeInterval = ( g_dwInterval / 60 ) / 1000 ;

            if( dobj.dwTimeInterval > 0 )
            {  
                wsprintf( szDigits , TEXT("%d" ), dobj.dwTimeInterval );
                
                SetWindowText( GetDlgItem( hdlg , ID_EDT_NUM ) , szDigits );
            }
        }

        break;

    case WM_NOTIFY:
        {
            ODS( TEXT("OFNHookProc WM_NOTIFY\n" ) );            

            LPOFNOTIFY pOnotify = ( LPOFNOTIFY )lParam;

            if( pOnotify != NULL && pOnotify->hdr.code == CDN_FILEOK )
            {
                DBGMSG( TEXT("File name to store in registry %s\n") , pOnotify->lpOFN->lpstrFile );

                lstrcpy( dobj.wchFileName , pOnotify->lpOFN->lpstrFile );

                GetWindowText( GetDlgItem( hdlg , ID_EDT_NUM ) , szDigits , SIZEOF(  szDigits ) );

                if( szDigits[0] == 0 )
                {
                    // reset to default elaspe time

                    dobj.dwTimeInterval = 5;
                }
                else
                {
                    dobj.dwTimeInterval = _wtoi( szDigits );
                }

                dobj.bIsChecked = IsDlgButtonChecked( hdlg , IDC_CHECK1 ) == BST_CHECKED;

                g_bAutomaticLog = dobj.bIsChecked;

                if( dobj.dwTimeInterval < 1 )
                {
                    dobj.dwTimeInterval = 1;
                }

                if( dobj.dwTimeInterval > kMaxMinutes )
                {
                    dobj.dwTimeInterval = kMaxMinutes;
                }

                g_dwInterval = dobj.dwTimeInterval * 60 * 1000;

                KillTimer( GetParent( GetParent( hdlg ) ) , kTimerId );

                SetTimer( GetParent( GetParent( hdlg ) ) , kTimerId , g_dwInterval , NULL );            

                StoreDataObject( &dobj );
            }           
            
        }
      
        break;
    }

    return 0;
}


//-------------------------------------------------------------------------
BOOL Tray_Init( HWND hwnd , BOOL bNotify )
{
    NOTIFYICONDATA nid;

    TCHAR szTip[ 60 ];
    TCHAR szBubble[ 255 ];
    TCHAR szTitle[ 60 ];

    ZeroMemory( &nid , sizeof( NOTIFYICONDATA ) );

    LoadString( g_hinst ,
                IDS_TIP ,
                szTip ,
                SIZEOF( szTip )
                );

    if( !bNotify )
    {
        LoadString( g_hinst ,
                    IDS_BUBBLE ,
                    szBubble ,
                    SIZEOF( szBubble )
                  );
        
        LoadString( g_hinst ,
                    IDS_TITLE ,
                    szTitle ,
                    SIZEOF( szTitle )
                 );
        
        nid.uFlags = NIF_TIP | NIF_INFO;
    }
    
    nid.cbSize = sizeof( NOTIFYICONDATA );
    nid.hWnd = hwnd;
    nid.uID = TN_MESSAGE;
    nid.uFlags |= NIF_ICON | NIF_MESSAGE;
    nid.uCallbackMessage = TN_MESSAGE;
    nid.hIcon = LoadIcon( g_hinst , MAKEINTRESOURCE( IDC_ICON_NONE ) );

    lstrcpy( nid.szTip , szTip );
    lstrcpy( nid.szInfo , szBubble );
    lstrcpy( nid.szInfoTitle , szTitle );

    nid.dwInfoFlags = NIIF_INFO;
    nid.uTimeout = kBubbleTimeout;    

    return Shell_NotifyIcon( NIM_ADD , &nid );
}

//-------------------------------------------------------------------------
BOOL Tray_ToGreen( HWND hwnd )
{
    TCHAR szBuffer[ 260 ];

    LoadString( g_hinst ,
                IDS_TRAYGREEN ,
                szBuffer ,
                SIZEOF( szBuffer)
                );

    return Tray_ToXXX( hwnd , szBuffer , IDC_ICON_GO );       
}

//-------------------------------------------------------------------------
BOOL Tray_ToYellow( HWND hwnd , LPTSTR szMsg )
{
    return Tray_ToXXX( hwnd , szMsg , IDC_ICON_CAUTION );    
}

//-------------------------------------------------------------------------
BOOL Tray_ToRed( HWND hwnd )
{
    TCHAR szBuffer[ 260 ];

    LoadString( g_hinst ,
                IDS_TRAYSTOP ,
                szBuffer ,
                SIZEOF( szBuffer)
                );

    return Tray_ToXXX( hwnd , szBuffer , IDC_ICON_STOP );
}

//-------------------------------------------------------------------------
BOOL Tray_Remove( HWND hwnd )
{
    NOTIFYICONDATA nid;

    ZeroMemory( &nid , sizeof( NOTIFYICONDATA ) );
    
    nid.cbSize = sizeof( NOTIFYICONDATA );
    nid.hWnd = hwnd;
    nid.uID = TN_MESSAGE;
 
    return Shell_NotifyIcon( NIM_DELETE , &nid );
}

//-------------------------------------------------------------------------
BOOL Tray_ToXXX( HWND hwnd , LPTSTR szTip , UINT resid )
{
    NOTIFYICONDATA nid;

    ZeroMemory( &nid , sizeof( NOTIFYICONDATA ) );
    
    nid.cbSize = sizeof( NOTIFYICONDATA );
    nid.hWnd = hwnd;
    nid.uID = TN_MESSAGE;
    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
    nid.uCallbackMessage = TN_MESSAGE;
    nid.hIcon = LoadIcon( g_hinst , MAKEINTRESOURCE( resid ) );
    lstrcpy( nid.szTip , szTip );

    return Shell_NotifyIcon( NIM_MODIFY , &nid );
}

//-------------------------------------------------------------------------
BOOL Tray_Notify( HWND hwnd , WPARAM wp , LPARAM lp )
{
    switch( lp ) 
    {
    case WM_LBUTTONDBLCLK:
        
        OpenIcon( hwnd );
        SetForegroundWindow( hwnd );
        break;

    case WM_RBUTTONDOWN:
        {
            HMENU hmenuParent = LoadMenu( g_hinst, MAKEINTRESOURCE( IDR_TRAYMENU ) );
            if( hmenuParent != NULL ) 
            {
                HMENU hpopup = GetSubMenu( hmenuParent , 0 );

                RemoveMenu( hmenuParent , 0 , MF_BYPOSITION );

                DestroyMenu( hmenuParent );

                // Display the tray icons context menu at 
                // the current cursor location

                if( hpopup != NULL )
                {
                    POINT pt;

                    GetCursorPos( &pt );

                    SetForegroundWindow( hwnd );

                    TrackPopupMenuEx( hpopup,
                                      0,
                                      pt.x,
                                      pt.y,
                                      hwnd,
                                      NULL);

                    DestroyMenu(hpopup);
                }
            }
            
        }
        break;

    }
    
    return FALSE;
}

//-------------------------------------------------------------------------
//  pObj is a pointer a DATAOBJECT buffer
//-------------------------------------------------------------------------
BOOL StoreDataObject( PDATAOBJECT pObj )
{
    DWORD dwStatus;

    HKEY hKey;

    dwStatus = RegCreateKeyEx( HKEY_CURRENT_USER ,
                               szLsViewKey,
                               0,
                               NULL,
                               0,
                               KEY_WRITE,
                               NULL,
                               &hKey,
                               NULL );

    if( dwStatus != ERROR_SUCCESS )
    {
        // format a message and display an error

        return FALSE;
    }

    dwStatus = RegSetValueEx( hKey,
                              TEXT( "DataObject" ),
                              0,
                              REG_BINARY,                            
                              ( CONST BYTE * )pObj,
                              sizeof( DATAOBJECT ) );

    if( dwStatus != ERROR_SUCCESS )
    {
        return FALSE;
    }

    RegCloseKey( hKey );

    return TRUE;

}


//-------------------------------------------------------------------------
// pObj is a pointer to a DATAOBJECT buffer
//-------------------------------------------------------------------------
BOOL RetrieveDataObject( PDATAOBJECT pObj )
{
    DWORD dwStatus;

    DWORD dwSizeOfDO = sizeof( DATAOBJECT );

    HKEY hKey;

    dwStatus = RegOpenKeyEx( HKEY_CURRENT_USER ,
                             szLsViewKey,
                             0,
                             KEY_READ,
                             &hKey );
 
    if( dwStatus != ERROR_SUCCESS )
    {
        // could obtain information which is ok.

        return FALSE;
    }

    dwStatus = RegQueryValueEx( hKey,
                                TEXT( "DataObject" ),
                                0, 
                                0,
                                ( LPBYTE )pObj,
                                &dwSizeOfDO );

    if( dwStatus != ERROR_SUCCESS )
    {
        DBGMSG( TEXT( "LSVIEW:RetrieveDataObject RegOpenKey succeed QueryValueEx failed 0x%x\n" ) , dwStatus );

        return FALSE;
    }

    RegCloseKey( hKey );

    return TRUE;

}

//-------------------------------------------------------------------------
BOOL LogFile( LPTSTR szFileName )
{
    FILE *fp = NULL;
    
    if( ( fp = _wfopen( szFileName , TEXT( "w" ) ) ) != NULL )
    {
        DBGMSG( TEXT( "File name is %ws\n" ) , szFileName ) ;

        // delimiter not specified use tabs,
        // loop through list and construct a line

        if( g_pHead != NULL )
        {
            PLIST pItem = g_pHead->pNext;

            while( pItem != NULL )
            {
                WCHAR wchBuffer[ 260 ];
                CHAR chBuffer[ 260 ];

                wsprintf( wchBuffer ,
                          TEXT( "%ws\t%ws\t%ws\n" ) ,
                          pItem->pszMachineName ,
                          pItem->pszTimeFormat ,
                          pItem->pszType );

                // DBCS is a hard when streaming; convert this to MBCS

                WideCharToMultiByte( CP_ACP ,
                                     0,
                                     wchBuffer,
                                     SIZEOF( wchBuffer ),
                                     chBuffer,
                                     sizeof( chBuffer ),
                                     NULL,
                                     NULL
                                     );

                fprintf( fp , chBuffer );

                pItem = pItem->pNext;
            }
        }

        fclose( fp );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\clx\null.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\bmplib\main.c ===
#include    <windows.h>

#include    "bmplib.h"

/*
 *  This came from: \\index1\src\nt\private\samples\wincap32\dibutil.c
 */

#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD)(lpbi)) == sizeof(BITMAPINFOHEADER))
#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)
#define DIB_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')

WORD DIBNumColors(LPSTR lpDIB)
{
    WORD wBitCount;  // DIB bit count

    // If this is a Windows-style DIB, the number of colors in the
    // color table can be less than the number of bits per pixel
    // allows for (i.e. lpbi->biClrUsed can be set to some value).
    // If this is the case, return the appropriate value.
    

    if (IS_WIN30_DIB(lpDIB))
    {
        DWORD dwClrUsed;

        dwClrUsed = ((LPBITMAPINFOHEADER)lpDIB)->biClrUsed;
        if (dwClrUsed)

        return (WORD)dwClrUsed;
    }

    // Calculate the number of colors in the color table based on
    // the number of bits per pixel for the DIB.
    
    if (IS_WIN30_DIB(lpDIB))
        wBitCount = ((LPBITMAPINFOHEADER)lpDIB)->biBitCount;
    else
        wBitCount = ((LPBITMAPCOREHEADER)lpDIB)->bcBitCount;

    // return number of colors based on bits per pixel

    switch (wBitCount)
    {
        case 1:
            return 2;

        case 4:
            return 16;

        case 8:
            return 256;

        default:
            return 0;
    }
}


WORD PaletteSize(LPSTR lpDIB)
{
    // calculate the size required by the palette
    if (IS_WIN30_DIB (lpDIB))
        return (DIBNumColors(lpDIB) * sizeof(RGBQUAD));
    else
        return (DIBNumColors(lpDIB) * sizeof(RGBTRIPLE));
}

LPSTR FindDIBBits(LPSTR lpDIB)
{
   return (lpDIB + *(LPDWORD)lpDIB + PaletteSize(lpDIB));
}


/*************************************************************************
 *
 * DIBToBitmap()
 *
 * Parameters:
 *
 * HDIB hDIB        - specifies the DIB to convert
 *
 * HPALETTE hPal    - specifies the palette to use with the bitmap
 *
 * Return Value:
 *
 * HBITMAP          - identifies the device-dependent bitmap
 *
 * Description:
 *
 * This function creates a bitmap from a DIB using the specified palette.
 * If no palette is specified, default is used.
 *
 * NOTE:
 *
 * The bitmap returned from this funciton is always a bitmap compatible
 * with the screen (e.g. same bits/pixel and color planes) rather than
 * a bitmap with the same attributes as the DIB.  This behavior is by
 * design, and occurs because this function calls CreateDIBitmap to
 * do its work, and CreateDIBitmap always creates a bitmap compatible
 * with the hDC parameter passed in (because it in turn calls
 * CreateCompatibleBitmap).
 *
 * So for instance, if your DIB is a monochrome DIB and you call this
 * function, you will not get back a monochrome HBITMAP -- you will
 * get an HBITMAP compatible with the screen DC, but with only 2
 * colors used in the bitmap.
 *
 * If your application requires a monochrome HBITMAP returned for a
 * monochrome DIB, use the function SetDIBits().
 *
 * Also, the DIBpassed in to the function is not destroyed on exit. This
 * must be done later, once it is no longer needed.
 *
 ************************************************************************/

HBITMAP 
BMPAPI
DIBToBitmap(
    LPVOID   pDIB, 
    HPALETTE hPal
    )
{
    LPSTR       lpDIBHdr, lpDIBBits;  // pointer to DIB header, pointer to DIB bits
    HBITMAP     hBitmap;            // handle to device-dependent bitmap
    HDC         hDC;                    // handle to DC
    HPALETTE    hOldPal = NULL;    // handle to a palette

    // if invalid handle, return NULL 

    if (!pDIB)
        return NULL;

    // lock memory block and get a pointer to it

    lpDIBHdr = pDIB;

    // get a pointer to the DIB bits

    lpDIBBits = FindDIBBits(lpDIBHdr);

    // get a DC 

    hDC = GetDC(NULL);
    if (!hDC)
    {
        return NULL;
    }

    // select and realize palette

    if (hPal)
        hOldPal = SelectPalette(hDC, hPal, FALSE);

    RealizePalette(hDC);

    // create bitmap from DIB info. and bits
    hBitmap = CreateDIBitmap(hDC, (LPBITMAPINFOHEADER)lpDIBHdr, CBM_INIT,
            lpDIBBits, (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS);

    // restore previous palette
    if (hOldPal)
        SelectPalette(hDC, hOldPal, FALSE);

    // clean up
    ReleaseDC(NULL, hDC);

    // return handle to the bitmap
    return hBitmap;
}

/*************************************************************************
 *
 * BitmapToDIB()
 *
 * Parameters:
 *
 * HBITMAP hBitmap  - specifies the bitmap to convert
 *
 * HPALETTE hPal    - specifies the palette to use with the bitmap
 *
 * Return Value:
 *
 * HANDLE           - identifies the device-dependent bitmap
 *
 * Description:
 *
 * This function creates a DIB from a bitmap using the specified palette.
 *
 ************************************************************************/

HANDLE 
BMPAPI
BitmapToDIB(
    HBITMAP hBitmap, 
    HPALETTE hPal
    )
{
    BITMAP              bm;         // bitmap structure
    BITMAPINFOHEADER    bi;         // bitmap header
    LPBITMAPINFOHEADER  lpbi;       // pointer to BITMAPINFOHEADER
    DWORD               dwLen;      // size of memory block
    HANDLE              hDIB, h;    // handle to DIB, temp handle
    HDC                 hDC;        // handle to DC
    WORD                biBits;     // bits per pixel

    // check if bitmap handle is valid

    if (!hBitmap)
        return NULL;

    // fill in BITMAP structure, return NULL if it didn't work

    if (!GetObject(hBitmap, sizeof(bm), (LPSTR)&bm))
        return NULL;

    // if no palette is specified, use default palette

    if (hPal == NULL)
        hPal = GetStockObject(DEFAULT_PALETTE);

    // calculate bits per pixel

    biBits = bm.bmPlanes * bm.bmBitsPixel;

    // make sure bits per pixel is valid

    if (biBits <= 1)
        biBits = 1;
    else if (biBits <= 4)
        biBits = 4;
    else if (biBits <= 8)
        biBits = 8;
    else // if greater than 8-bit, force to 24-bit
        biBits = 24;

    // initialize BITMAPINFOHEADER

    bi.biSize = sizeof(BITMAPINFOHEADER);
    bi.biWidth = bm.bmWidth;
    bi.biHeight = bm.bmHeight;
    bi.biPlanes = 1;
    bi.biBitCount = biBits;
    bi.biCompression = BI_RGB;
    bi.biSizeImage = 0;
    bi.biXPelsPerMeter = 0;
    bi.biYPelsPerMeter = 0;
    bi.biClrUsed = 0;
    bi.biClrImportant = 0;

    // calculate size of memory block required to store BITMAPINFO

    dwLen = bi.biSize + PaletteSize((LPSTR)&bi);

    // get a DC

    hDC = GetDC(NULL);

    if (!hDC)
    {
        return NULL;
    }

    // select and realize our palette

    hPal = SelectPalette(hDC, hPal, FALSE);
    RealizePalette(hDC);

    // alloc memory block to store our bitmap

    hDIB = GlobalAlloc(GHND, dwLen);

    // if we couldn't get memory block

    if (!hDIB)
    {
      // clean up and return NULL

      SelectPalette(hDC, hPal, TRUE);
      RealizePalette(hDC);
      ReleaseDC(NULL, hDC);
      return NULL;
    }

    // lock memory and get pointer to it

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

    /// use our bitmap info. to fill BITMAPINFOHEADER

    *lpbi = bi;

    // call GetDIBits with a NULL lpBits param, so it will calculate the
    // biSizeImage field for us    

    GetDIBits(hDC, hBitmap, 0, (UINT)bi.biHeight, NULL, (LPBITMAPINFO)lpbi,
        DIB_RGB_COLORS);

    // get the info. returned by GetDIBits and unlock memory block

    bi = *lpbi;
    GlobalUnlock(hDIB);

    // if the driver did not fill in the biSizeImage field, make one up 
    if (bi.biSizeImage == 0)
        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;

    // realloc the buffer big enough to hold all the bits

    dwLen = bi.biSize + PaletteSize((LPSTR)&bi) + bi.biSizeImage;

    if (h = GlobalReAlloc(hDIB, dwLen, 0))
        hDIB = h;
    else
    {
        // clean up and return NULL

        GlobalFree(hDIB);
        hDIB = NULL;
        SelectPalette(hDC, hPal, TRUE);
        RealizePalette(hDC);
        ReleaseDC(NULL, hDC);
        return NULL;
    }

    // lock memory block and get pointer to it */

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

    // call GetDIBits with a NON-NULL lpBits param, and actualy get the
    // bits this time

    if (GetDIBits(hDC, hBitmap, 0, (UINT)bi.biHeight, (LPSTR)lpbi +
            (WORD)lpbi->biSize + PaletteSize((LPSTR)lpbi), (LPBITMAPINFO)lpbi,
            DIB_RGB_COLORS) == 0)
    {
        // clean up and return NULL

        GlobalUnlock(hDIB);
        hDIB = NULL;
        SelectPalette(hDC, hPal, TRUE);
        RealizePalette(hDC);
        ReleaseDC(NULL, hDC);
        return NULL;
    }

    bi = *lpbi;

    // clean up 
    GlobalUnlock(hDIB);
    SelectPalette(hDC, hPal, TRUE);
    RealizePalette(hDC);
    ReleaseDC(NULL, hDC);

    // return handle to the DIB
    return hDIB;
}

/*************************************************************************
 *
 * SaveDIB()
 *
 * Saves the specified DIB into the specified file name on disk.  No
 * error checking is done, so if the file already exists, it will be
 * written over.
 *
 * Parameters:
 *
 * HDIB hDib - Handle to the dib to save
 *
 * LPSTR lpFileName - pointer to full pathname to save DIB under
 *
 * Return value: 0 if successful, or one of:
 *        ERR_INVALIDHANDLE
 *        ERR_OPEN
 *        ERR_LOCK
 *
 *************************************************************************/

BOOL 
BMPAPI
SaveDIB(
    LPVOID pDib,
    LPCSTR lpFileName
    )
{
    BITMAPFILEHEADER    bmfHdr;     // Header for Bitmap file
    LPBITMAPINFOHEADER  lpBI;       // Pointer to DIB info structure
    HANDLE              fh;         // file handle for opened file
    DWORD               dwDIBSize;
    DWORD               dwWritten;

    if (!pDib)
        return FALSE;

    fh = CreateFile(lpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (fh == INVALID_HANDLE_VALUE)
        return FALSE;

    // Get a pointer to the DIB memory, the first of which contains
    // a BITMAPINFO structure

    lpBI = (LPBITMAPINFOHEADER)pDib;
    if (!lpBI)
    {
        CloseHandle(fh);
        return FALSE;
    }

    // Check to see if we're dealing with an OS/2 DIB.  If so, don't
    // save it because our functions aren't written to deal with these
    // DIBs.

    if (lpBI->biSize != sizeof(BITMAPINFOHEADER))
    {
        CloseHandle(fh);
        return FALSE;
    }

    // Fill in the fields of the file header

    // Fill in file type (first 2 bytes must be "BM" for a bitmap)

    bmfHdr.bfType = DIB_HEADER_MARKER;  // "BM"

    // Calculating the size of the DIB is a bit tricky (if we want to
    // do it right).  The easiest way to do this is to call GlobalSize()
    // on our global handle, but since the size of our global memory may have
    // been padded a few bytes, we may end up writing out a few too
    // many bytes to the file (which may cause problems with some apps,
    // like HC 3.0).
    //
    // So, instead let's calculate the size manually.
    //
    // To do this, find size of header plus size of color table.  Since the
    // first DWORD in both BITMAPINFOHEADER and BITMAPCOREHEADER conains
    // the size of the structure, let's use this.

    // Partial Calculation

    dwDIBSize = *(LPDWORD)lpBI + PaletteSize((LPSTR)lpBI);  

    // Now calculate the size of the image

    // It's an RLE bitmap, we can't calculate size, so trust the biSizeImage
    // field

    if ((lpBI->biCompression == BI_RLE8) || (lpBI->biCompression == BI_RLE4))
        dwDIBSize += lpBI->biSizeImage;
    else
    {
        DWORD dwBmBitsSize;  // Size of Bitmap Bits only

        // It's not RLE, so size is Width (DWORD aligned) * Height

        dwBmBitsSize = WIDTHBYTES((lpBI->biWidth)*((DWORD)lpBI->biBitCount)) *
                lpBI->biHeight;

        dwDIBSize += dwBmBitsSize;

        // Now, since we have calculated the correct size, why don't we
        // fill in the biSizeImage field (this will fix any .BMP files which 
        // have this field incorrect).

        lpBI->biSizeImage = dwBmBitsSize;
    }


    // Calculate the file size by adding the DIB size to sizeof(BITMAPFILEHEADER)
                   
    bmfHdr.bfSize = dwDIBSize + sizeof(BITMAPFILEHEADER);
    bmfHdr.bfReserved1 = 0;
    bmfHdr.bfReserved2 = 0;

    // Now, calculate the offset the actual bitmap bits will be in
    // the file -- It's the Bitmap file header plus the DIB header,
    // plus the size of the color table.
    
    bmfHdr.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + lpBI->biSize +
            PaletteSize((LPSTR)lpBI);

    // Write the file header

    WriteFile(fh, (LPSTR)&bmfHdr, sizeof(BITMAPFILEHEADER), &dwWritten, NULL);

    // Write the DIB header and the bits -- use local version of
    // MyWrite, so we can write more than 32767 bytes of data
    
    WriteFile(fh, (LPSTR)lpBI, dwDIBSize, &dwWritten, NULL);

    CloseHandle(fh);

    if (dwWritten == 0)
        return FALSE; // oops, something happened in the write
    else
        return TRUE; // Success code
}

/*************************************************************************
 *
 * Function:  ReadDIBFile (int)
 *
 *  Purpose:  Reads in the specified DIB file into a global chunk of
 *            memory.
 *
 *  Returns:  A handle to a dib (hDIB) if successful.
 *            NULL if an error occurs.
 *
 * Comments:  BITMAPFILEHEADER is stripped off of the DIB.  Everything
 *            from the end of the BITMAPFILEHEADER structure on is
 *            returned in the global memory handle.
 *
 *
 * NOTE: The DIB API were not written to handle OS/2 DIBs, so this
 * function will reject any file that is not a Windows DIB.
 *
 *************************************************************************/

HANDLE 
BMPAPI
ReadDIBFile(
    HANDLE hFile
    )
{
    BITMAPFILEHEADER    bmfHeader;
    DWORD               dwBitsSize;
    UINT                nNumColors;   // Number of colors in table
    HANDLE              hDIB;        
    HANDLE              hDIBtmp;      // Used for GlobalRealloc() //MPB
    LPBITMAPINFOHEADER  lpbi;
    DWORD               offBits;
    DWORD               dwRead;

    // get length of DIB in bytes for use when reading

    dwBitsSize = GetFileSize(hFile, NULL);

    // Allocate memory for header & color table. We'll enlarge this
    // memory as needed.

    hDIB = GlobalAlloc(GMEM_MOVEABLE, (DWORD)(sizeof(BITMAPINFOHEADER) +
            256 * sizeof(RGBQUAD)));

    if (!hDIB)
        return NULL;

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

    if (!lpbi) 
    {
        GlobalFree(hDIB);
        return NULL;
    }

    // read the BITMAPFILEHEADER from our file

    if (!ReadFile(hFile, (LPSTR)&bmfHeader, sizeof (BITMAPFILEHEADER),
            &dwRead, NULL))
        goto ErrExit;

    if (sizeof (BITMAPFILEHEADER) != dwRead)
        goto ErrExit;

    if (bmfHeader.bfType != 0x4d42)  // 'BM'
        goto ErrExit;

    // read the BITMAPINFOHEADER

    if (!ReadFile(hFile, (LPSTR)lpbi, sizeof(BITMAPINFOHEADER), &dwRead,
            NULL))
        goto ErrExit;

    if (sizeof(BITMAPINFOHEADER) != dwRead)
        goto ErrExit;

    // Check to see that it's a Windows DIB -- an OS/2 DIB would cause
    // strange problems with the rest of the DIB API since the fields
    // in the header are different and the color table entries are
    // smaller.
    //
    // If it's not a Windows DIB (e.g. if biSize is wrong), return NULL.

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
        goto ErrExit;

    // Now determine the size of the color table and read it.  Since the
    // bitmap bits are offset in the file by bfOffBits, we need to do some
    // special processing here to make sure the bits directly follow
    // the color table (because that's the format we are susposed to pass
    // back)

    if (!(nNumColors = (UINT)lpbi->biClrUsed))
    {
        // no color table for 24-bit, default size otherwise

        if (lpbi->biBitCount != 24)
            nNumColors = 1 << lpbi->biBitCount; // standard size table
    }

    // fill in some default values if they are zero

    if (lpbi->biClrUsed == 0)
        lpbi->biClrUsed = nNumColors;

    if (lpbi->biSizeImage == 0)
    {
        lpbi->biSizeImage = ((((lpbi->biWidth * (DWORD)lpbi->biBitCount) +
                31) & ~31) >> 3) * lpbi->biHeight;
    }

    // get a proper-sized buffer for header, color table and bits

    GlobalUnlock(hDIB);
    hDIBtmp = GlobalReAlloc(hDIB, lpbi->biSize + nNumColors *
            sizeof(RGBQUAD) + lpbi->biSizeImage, 0);

    if (!hDIBtmp) // can't resize buffer for loading
        goto ErrExitNoUnlock; //MPB
    else
        hDIB = hDIBtmp;

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

    // read the color table

    ReadFile (hFile, (LPSTR)(lpbi) + lpbi->biSize,
            nNumColors * sizeof(RGBQUAD), &dwRead, NULL);

    // offset to the bits from start of DIB header

    offBits = lpbi->biSize + nNumColors * sizeof(RGBQUAD);

    // If the bfOffBits field is non-zero, then the bits might *not* be
    // directly following the color table in the file.  Use the value in
    // bfOffBits to seek the bits.

    if (bmfHeader.bfOffBits != 0L)
        SetFilePointer(hFile, bmfHeader.bfOffBits, NULL, FILE_BEGIN);

    if (ReadFile(hFile, (LPSTR)lpbi + offBits, lpbi->biSizeImage, &dwRead,
            NULL))
        goto OKExit;


ErrExit:
    GlobalUnlock(hDIB);    

ErrExitNoUnlock:    
    GlobalFree(hDIB);
    return NULL;

OKExit:
    GlobalUnlock(hDIB);
    return hDIB;
}

//====================================
BOOL
BMPAPI
SaveBitmapInFile(
    HBITMAP hBitmap,
    LPCSTR  szFileName
    )
{
    BOOL rv = FALSE;
    HANDLE hDIB = NULL;
    LPVOID pDIB = NULL;

    if (!hBitmap)
         goto exitpt;

    hDIB = BitmapToDIB(hBitmap, NULL);
    if (!hDIB)
    {
//         TRC(ERR, "Can't get DIB bits\n");
         goto exitpt;
    }

    pDIB = GlobalLock(hDIB);
    if (!pDIB)
        goto exitpt;

    if (!SaveDIB(pDIB, szFileName))
        goto exitpt;

    rv = TRUE;
exitpt:
    if (pDIB)
        GlobalUnlock(hDIB);

    if (hDIB)
        GlobalFree(hDIB);

    return rv;
}

HANDLE
ReadDIBFromFile(LPCSTR szFileName)
{
    HANDLE hFile;
    HANDLE hDIB = NULL;

    hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        hDIB = ReadDIBFile(hFile);
        CloseHandle(hFile);

    }

    return hDIB;
}

/*
 *  size and color depth are already checked
 *  the number of colors is 16 or 256
 */
BOOL
_CompareBits16to256(
    LPBITMAPINFO pbmi1, // 16 color bitmap
    LPBITMAPINFO pbmi2, // 256 color bitmap
    HDC hdcOutput
    )
{
    BOOL    rv = TRUE;
    INT     nX, nY;
    INT     nWidth, nHeight;
    INT     nLineSize1, nLineSize2;
    RGBQUAD *pColorTable1;
    RGBQUAD *pColorTable2;
    LPSTR   pBits1, pBits2;
    HBRUSH  hRedBrush = NULL;

    if (!pbmi1 || !pbmi2)
    {
//        TRC(ERR, "NULL pointers passed\n");
        rv = FALSE;
        goto exitpt;
    }

    nLineSize1 = WIDTHBYTES(pbmi1->bmiHeader.biWidth*4);
    nLineSize2 = WIDTHBYTES(pbmi1->bmiHeader.biWidth*8);
    pColorTable1 = (RGBQUAD *)(((LPSTR)pbmi1) + pbmi1->bmiHeader.biSize);
    pColorTable2 = (RGBQUAD *)(((LPSTR)pbmi2) + pbmi2->bmiHeader.biSize);
    pBits1 = FindDIBBits((LPSTR)pbmi1);
    pBits2 = FindDIBBits((LPSTR)pbmi2);
    nWidth = pbmi1->bmiHeader.biWidth;
    nHeight = pbmi1->bmiHeader.biHeight;

    hRedBrush = CreateHatchBrush(HS_FDIAGONAL, RGB(255, 0, 0));
    SetBkMode(hdcOutput, TRANSPARENT);
    SetBrushOrgEx(hdcOutput, 0, 0, NULL);
    SetROP2(hdcOutput, R2_COPYPEN);
    

    for (nY = 0; nY < pbmi1->bmiHeader.biHeight; nY++)
    {
        for (nX = 0; nX < pbmi1->bmiHeader.biWidth; nX += 2)
        {
            PBYTE pPix1 = pBits1 + nLineSize1 * nY + nX / 2;
            PBYTE pPix2 = pBits2 + nLineSize2 * nY + nX;
            BYTE  Pix1 = (*pPix1) >> 4;
            BYTE  Pix2 = (*pPix2);

            RGBQUAD *pQuad1 = pColorTable1 + (Pix1);
            RGBQUAD *pQuad2 = pColorTable2 + (Pix2);
            BOOL cmp =
                 pQuad1->rgbBlue  == pQuad2->rgbBlue &&
                 pQuad1->rgbGreen == pQuad2->rgbGreen &&
                 pQuad1->rgbRed   == pQuad2->rgbRed;

            if (cmp)
            {
                Pix1 = (*pPix1) & 0xf;
                Pix2 = (*(pPix2 + 1));
                pQuad1 = pColorTable1 + (Pix1);
                pQuad2 = pColorTable2 + (Pix2);
                cmp = 
                     pQuad1->rgbBlue  == pQuad2->rgbBlue &&
                     pQuad1->rgbGreen == pQuad2->rgbGreen &&
                     pQuad1->rgbRed   == pQuad2->rgbRed;
            }


            if (!cmp)
            {
                HRGN hrgn;

                hrgn = CreateRectRgn(nX - 3, nHeight - nY - 3, 
                                     nX + 4, nHeight - nY + 4);
                if ( NULL != hrgn )
                {
                    FillRgn(hdcOutput, hrgn, hRedBrush);
                    DeleteObject(hrgn);
                }
            }
            rv = rv && cmp;
        }
    }
exitpt:
    if (hRedBrush)
        DeleteObject(hRedBrush);

    return rv;
}


BOOL
_CompareBits16(
    LPBITMAPINFO pbmi1, 
    LPBITMAPINFO pbmi2, 
    HDC hdcOutput
    )
{
    BOOL    rv = TRUE;
    INT     nX, nY;
    INT     nWidth, nHeight;
    INT     nLineSize;
    RGBQUAD *pColorTable1;
    RGBQUAD *pColorTable2;
    LPSTR   pBits1, pBits2;
    HBRUSH  hRedBrush = NULL;

    if (!pbmi1 || !pbmi2)
    {
//        TRC(ERR, "NULL pointers passed\n");
        rv = FALSE;
        goto exitpt;
    }

    nLineSize = WIDTHBYTES(pbmi1->bmiHeader.biWidth*4);
    pColorTable1 = (RGBQUAD *)(((LPSTR)pbmi1) + pbmi1->bmiHeader.biSize);
    pColorTable2 = (RGBQUAD *)(((LPSTR)pbmi2) + pbmi2->bmiHeader.biSize);
    pBits1 = FindDIBBits((LPSTR)pbmi1);
    pBits2 = FindDIBBits((LPSTR)pbmi2);
    nWidth = pbmi1->bmiHeader.biWidth;
    nHeight = pbmi1->bmiHeader.biHeight;

    hRedBrush = CreateHatchBrush(HS_FDIAGONAL, RGB(255, 0, 0));
    SetBkMode(hdcOutput, TRANSPARENT);
    SetBrushOrgEx(hdcOutput, 0, 0, NULL);
    SetROP2(hdcOutput, R2_COPYPEN);
    

    for (nY = 0; nY < pbmi1->bmiHeader.biHeight; nY++)
    {
        for (nX = 0; nX < pbmi1->bmiHeader.biWidth; nX += 2)
        {
            PBYTE pPix1 = pBits1 + nLineSize * nY + nX / 2;
            PBYTE pPix2 = pBits2 + nLineSize * nY + nX / 2;
            BYTE  Pix1 = (*pPix1) & 0xf;
            BYTE  Pix2 = (*pPix2) & 0xf;

            RGBQUAD *pQuad1 = pColorTable1 + (Pix1);
            RGBQUAD *pQuad2 = pColorTable2 + (Pix2);
            BOOL cmp =
                 pQuad1->rgbBlue  == pQuad2->rgbBlue &&
                 pQuad1->rgbGreen == pQuad2->rgbGreen &&
                 pQuad1->rgbRed   == pQuad2->rgbRed;

            if (cmp)
            {
                Pix1 = (*pPix1) >> 4;
                Pix2 = (*pPix2) >> 4;
                pQuad1 = pColorTable1 + (Pix1);
                pQuad2 = pColorTable2 + (Pix2);
                cmp = 
                     pQuad1->rgbBlue  == pQuad2->rgbBlue &&
                     pQuad1->rgbGreen == pQuad2->rgbGreen &&
                     pQuad1->rgbRed   == pQuad2->rgbRed;
            }


            if (!cmp)
            {
                HRGN hrgn;

                hrgn = CreateRectRgn(nX - 3, nHeight - nY - 3, 
                                     nX + 4, nHeight - nY + 4);
                if ( NULL != hrgn )
                {
                    FillRgn(hdcOutput, hrgn, hRedBrush);
                    DeleteObject(hrgn);
                }
            }
            rv = rv && cmp;
        }
    }
exitpt:
    if (hRedBrush)
        DeleteObject(hRedBrush);

    return rv;
}

BOOL
_CompareBits256(
    LPBITMAPINFO pbmi1, 
    LPBITMAPINFO pbmi2, 
    HDC hdcOutput
    )
{
    BOOL    rv = TRUE;
    INT     nX, nY;
    INT     nWidth, nHeight;
    INT     nLineSize;
    RGBQUAD *pColorTable1;
    RGBQUAD *pColorTable2;
    LPSTR   pBits1, pBits2;
    HBRUSH  hRedBrush = NULL;

    if (!pbmi1 || !pbmi2)
    {
//        TRC(ERR, "NULL pointers passed\n");
        rv = FALSE;
        goto exitpt;
    }

    nLineSize = WIDTHBYTES(pbmi1->bmiHeader.biWidth*8);
    pColorTable1 = (RGBQUAD *)(((LPSTR)pbmi1) + pbmi1->bmiHeader.biSize);
    pColorTable2 = (RGBQUAD *)(((LPSTR)pbmi2) + pbmi2->bmiHeader.biSize);
    pBits1 = FindDIBBits((LPSTR)pbmi1);
    pBits2 = FindDIBBits((LPSTR)pbmi2);
    nWidth = pbmi1->bmiHeader.biWidth;
    nHeight = pbmi1->bmiHeader.biHeight;

    hRedBrush = CreateHatchBrush(HS_FDIAGONAL, RGB(255, 0, 0));
    SetBkMode(hdcOutput, TRANSPARENT);
    SetBrushOrgEx(hdcOutput, 0, 0, NULL);
    SetROP2(hdcOutput, R2_COPYPEN);
    

    for (nY = 0; nY < pbmi1->bmiHeader.biHeight; nY++)
    {
        for (nX = 0; nX < pbmi1->bmiHeader.biWidth; nX++)
        {
            PBYTE pPix1 = pBits1 + nLineSize * nY + nX;
            PBYTE pPix2 = pBits2 + nLineSize * nY + nX;

            RGBQUAD *pQuad1 = pColorTable1 + (*pPix1);
            RGBQUAD *pQuad2 = pColorTable2 + (*pPix2);
            BOOL cmp =
                 pQuad1->rgbBlue  == pQuad2->rgbBlue &&
                 pQuad1->rgbGreen == pQuad2->rgbGreen &&
                 pQuad1->rgbRed   == pQuad2->rgbRed;

            if (!cmp)
            {
                HRGN hrgn;

                hrgn = CreateRectRgn(nX - 3, nHeight - nY - 3, 
                                     nX + 4, nHeight - nY + 4);
                if ( NULL != hrgn )
                {
                    FillRgn(hdcOutput, hrgn, hRedBrush);
                    DeleteObject(hrgn);
                }
            }
            rv = rv && cmp;
        }
    }
exitpt:
    if (hRedBrush)
        DeleteObject(hRedBrush);

    return rv;
}

//
//  Supports only 4 and 8 color bit DIBs
//
BOOL
BMPAPI
CompareTwoDIBs(
    LPVOID  pDIB1,
    LPVOID  pDIB2,
    HBITMAP *phbmpOutput
    )
{
    BOOL    rv = FALSE;
    LPBITMAPINFO pbmi1 = NULL;
    LPBITMAPINFO pbmi2 = NULL;
    HBITMAP hbmpOutput = NULL;
    HDC     hdcScreen;
    HDC     hdcMem     = NULL;
    HBITMAP hbmpOld    = NULL;

    if (!phbmpOutput)
        goto exitpt;

    // use the second bitmap for the base of the result
    hbmpOutput = DIBToBitmap(pDIB2, NULL);
    if (!hbmpOutput)
    {
//        TRC(ERR, "Can't create output bitmap\n");
        goto exitpt;
    }

    pbmi1 = pDIB1;
    pbmi2 = pDIB2;
    if (!pbmi1 || !pbmi2)
    {
//        TRC(ERR, "Can't lock DIBs\n");
        goto exitpt;
    }

    hdcScreen = GetDC(NULL);
    if (hdcScreen)
    {
        hdcMem = CreateCompatibleDC(hdcScreen);
        ReleaseDC(NULL, hdcScreen);
    }

    if (!hdcMem)
    {
//        TRC(ERR, "Can't get a DC\n");
        goto exitpt;
    }

    hbmpOld = SelectObject(hdcMem, hbmpOutput);

    // check the size and color depth of the two bitmaps
    if (pbmi1->bmiHeader.biWidth != pbmi2->bmiHeader.biWidth ||
        pbmi1->bmiHeader.biHeight != pbmi2->bmiHeader.biHeight)
    {
//        TRC(INF, "The two bitmaps have different size\n");
        goto exitpt;
    }

    // check that we are going to be able to compare the two dibs
    if (
         (pbmi1->bmiHeader.biBitCount != 4 &&
          pbmi1->bmiHeader.biBitCount != 8) ||
         (pbmi2->bmiHeader.biBitCount != 4 &&
          pbmi2->bmiHeader.biBitCount != 8)
       )
    {
//        TRC(FATAL, "Unsupported format\n");
        goto exitpt;
    }


    if (pbmi1->bmiHeader.biBitCount == pbmi2->bmiHeader.biBitCount)
    {
        // compare the DIB bits
        if (pbmi1->bmiHeader.biBitCount == 4)
           rv = _CompareBits16(pbmi1, pbmi2, hdcMem);
        else
           rv = _CompareBits256(pbmi1, pbmi2, hdcMem);
    } else if (pbmi1->bmiHeader.biBitCount != pbmi2->bmiHeader.biBitCount)
    {
        if (pbmi1->bmiHeader.biBitCount == 4)
           rv = _CompareBits16to256(pbmi1, pbmi2, hdcMem);
        else
           rv = _CompareBits16to256(pbmi2, pbmi1, hdcMem);
    }

    // if different, save the result bitmap
    if (!rv)
    {
        SelectObject(hdcMem, hbmpOld);
        hbmpOld = NULL;
    }

exitpt:
    if (hdcMem)
    {
        if (hbmpOld)
            SelectObject(hdcMem, hbmpOld);
        ReleaseDC(NULL, hdcMem);
    }

    if (rv && hbmpOutput)
    {
        // bitmaps are equal, delete the resulting bitmap
        DeleteObject(hbmpOutput);
        hbmpOutput = NULL;
    }

    if (phbmpOutput)
        *phbmpOutput = hbmpOutput;

    return rv;

}


BOOL
BMPAPI
CompareTwoBitmapFiles(
    LPCSTR szFile1,
    LPCSTR szFile2,
    LPCSTR szResultFileName
    )
{
    BOOL    rv = FALSE;
    HANDLE  hDIB1 = NULL;
    HANDLE  hDIB2 = NULL;
    HBITMAP hbmpOutput = NULL;
    LPVOID  pDIB1 = NULL;
    LPVOID  pDIB2 = NULL;

    hDIB1 = ReadDIBFromFile(szFile1);
    if (!hDIB1)
    {
//        TRC(ERR, "Can't read DIB file %s\n", szFile1);
        goto exitpt;
    }

    hDIB2 = ReadDIBFromFile(szFile2);
    if (!hDIB2)
    {
//        TRC(ERR, "Can't read DIB file %s\n", szFile2);
        goto exitpt;
    }

    pDIB1 = GlobalLock(hDIB1);
    if (!pDIB1)
        goto exitpt;

    pDIB2 = GlobalLock(hDIB2);
    if (!pDIB2)
        goto exitpt;

    rv = CompareTwoDIBs(pDIB1, pDIB2, &hbmpOutput);

    if (!rv && hbmpOutput)
    {
        SaveBitmapInFile(hbmpOutput, szResultFileName);
    }

exitpt:
    if (hbmpOutput)
        DeleteObject(hbmpOutput);

    if (pDIB1)
         GlobalUnlock(hDIB1);

    if (pDIB2)
         GlobalUnlock(hDIB2);

    if (hDIB1)
        GlobalFree(hDIB1);

    if (hDIB2)
        GlobalFree(hDIB2);

    return rv;
}

BOOL
GetScreenDIB(
    INT left,
    INT top,
    INT right,
    INT bottom,
    HANDLE  *phDIB
    )
{
    HDC     hScreenDC   = NULL;
    HDC     hMemDC      = NULL;
    BOOL    rv          = FALSE;
    HANDLE  hDIB        = NULL;
    HBITMAP hDstBitmap  = NULL;
    HBITMAP hOldDstBmp  = NULL;

    if (!phDIB)
        goto exitpt;

    hScreenDC = GetDC(NULL);
    if (!hScreenDC)
        goto exitpt;

    hMemDC    = CreateCompatibleDC(hScreenDC);
    if (!hMemDC)
        goto exitpt;

    // Adjust the order of the rectangle
    if (left > right)
    {
        INT c = left;
        left = right;
        right = c;
    }
    if (top > bottom)
    {
        INT c = top;
        top = bottom;
        bottom = top;
    }


    hDstBitmap = CreateCompatibleBitmap(
                    hScreenDC, 
                    right - left, 
                    bottom - top);

    if (!hDstBitmap)
        goto exitpt;

    hOldDstBmp = SelectObject(hMemDC, hDstBitmap);

    if (!BitBlt( hMemDC,
                 0, 0,              // dest x,y
                 right - left,      // dest width
                 bottom - top,      // dest height
                 hScreenDC,
                 left, top,              // source coordinates
                 SRCCOPY))
        goto exitpt;

    hDIB = BitmapToDIB(hDstBitmap, NULL);
    if (hDIB)
        rv = TRUE;

exitpt:
    if (hOldDstBmp)
        SelectObject(hMemDC, hOldDstBmp);

    if (hDstBitmap)
        DeleteObject(hDstBitmap);

    if (hScreenDC)
        ReleaseDC(NULL, hScreenDC);

    if (hMemDC)
        DeleteDC(hMemDC);

    if (phDIB)
        (*phDIB) = hDIB;

    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\bmplib\bmplib.h ===
#define BMPAPI  __stdcall

HBITMAP 
BMPAPI
DIBToBitmap(
    LPVOID   pDIB, 
    HPALETTE hPal
    );

HANDLE
BMPAPI
BitmapToDIB(
    HBITMAP hBitmap,
    HPALETTE hPal
    );

BOOL
BMPAPI
SaveDIB(
    LPVOID pDib,
    LPCSTR lpFileName
    );

HANDLE
BMPAPI
ReadDIBFile(
    HANDLE hFile
    );

BOOL
BMPAPI
SaveBitmapInFile(
    HBITMAP hBitmap,
    LPCSTR  szFileName
    );

BOOL
BMPAPI
CompareTwoDIBs(
    LPVOID pDIB1,
    LPVOID pDIB2,
    HBITMAP *phbmpOutput
    );

BOOL
BMPAPI
CompareTwoBitmapFiles(
    LPCSTR szFile1,
    LPCSTR szFile2,
    LPCSTR szResultFileName
    );

BOOL
GetScreenDIB(
    INT left,
    INT top,
    INT right,
    INT bottom,
    HANDLE  *phDIB
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\clx\clxexport.h ===
#ifndef __CLXEXPORT_H
#define __CLXEXPORT_H

#ifdef  OS_WIN32
    #define CLXAPI        __stdcall
#else   // !OS_WIN32
    #define CLXAPI        CALLBACK __loadds
#endif  // !OS_WIN32

typedef DWORD CLXAPI    CLXVC_SENDDATA(LPVOID pData, DWORD dwSize);
typedef CLXVC_SENDDATA  *PCLXVC_SENDDATA;

typedef DWORD CLXAPI    CLXVC_RECVDATA(LPCSTR szChannelName, LPVOID pData, DWORD dwSize);
typedef CLXVC_RECVDATA  *PCLXVC_RECVDATA;

typedef BOOL  CLXAPI    CLXREGISTERVC(LPCSTR szChannelName,
                                      PCLXVC_SENDDATA pSendDataFn, 
                                      PCLXVC_RECVDATA *ppRecvDataFn);
typedef CLXREGISTERVC   *PCLXREGISTERVC;

typedef VOID  CLXAPI    CLXUNREGISTERVC(LPCSTR szChannelName);
typedef CLXUNREGISTERVC *PCLXUNREGISTERVC;

// Exported by clxtshar.dll
#define CLX_REGISTER_VC     "ClxRegisterVC"

BOOL
CLXAPI
CLXRegisterVC(
    LPCSTR              szChannelName,
    PCLXVC_SENDDATA     pSendData,
    PCLXVC_RECVDATA     *ppRecvData
    );

#define CLX_UNREGISTER_VC   "ClxUnregisterVC"

VOID
CLXAPI
CLXUnregisterVC(
    LPCSTR  szChannelName
    );

#define CLX_GETCLIENTDATA   "ClxGetClientData"

typedef struct _CLX_CLIENT_DATA {
    HDC     hScreenDC;
    HBITMAP hScreenBitmap;
    HWND    hwndMain;
    HWND    hwndDialog;
    HWND    hwndInput;
} CLX_CLIENT_DATA, *PCLX_CLIENT_DATA;

BOOL
CLXAPI
ClxGetClientData(
    PCLX_CLIENT_DATA pClntData
    );

#endif  // !__CLXEXPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\clx\clxapi.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ClxApi.h                                                                 */
/*                                                                          */
/* Client extension header file                                             */
/*                                                                          */
/* Copyright(c) Microsoft 1997                                              */
/*                                                                          */
/* Notes:                                                                   */
/*                                                                          */
/*  CLINFO_VERSION                                                          */
/*      1               Initial version                                     */
/*      2               hwndMain added to CLINFO struct                     */
/*                                                                          */
/****************************************************************************/

#ifndef __CLXAPI_H__
#define __CLXAPI_H__

#include <extypes.h>

#define CLINFO_VERSION              2

#define CLX_DISCONNECT_LOCAL        1
#define CLX_DISCONNECT_BY_USER      2
#define CLX_DISCONNECT_BY_SERVER    3
#define CLX_DISCONNECT_NL_ERROR     4
#define CLX_DISCONNECT_SL_ERROR     5
#define CLX_DISCONNECT_UNKNOWN      6


typedef struct _tag_CLINFO
{
    DWORD   cbSize;                 // Size of CLINFO structure (bytes)
    DWORD   dwVersion;              // CLINFO_VERSION

    LPTSTR  pszServer;              // Test server name / address
    LPTSTR  pszCmdLine;             // /clxcmdline= switch data

    HWND    hwndMain;               // Main window handle

} CLINFO, *PCLINFO;

typedef enum
{
    CLX_EVENT_CONNECT,              // Connect event
    CLX_EVENT_DISCONNECT,           // Disconnect event
    CLX_EVENT_LOGON,                // Logon event

} CLXEVENT;

#ifndef PVOID
typedef void * PVOID;
typedef unsigned long ULONG;
typedef char *PCHAR, *PCH, *LPSTR;
#endif

#ifndef DWORD
typedef unsigned long DWORD;
typedef char *LPSTR;
#endif

#ifndef IN
#define IN
#endif

typedef BOOL (WINAPI * PCLX_INITIALIZE)(PCLINFO, PVOID);
typedef BOOL (WINAPI * PCLX_CONNECT)(PVOID, LPTSTR);
typedef VOID (WINAPI * PCLX_EVENT)(PVOID, CLXEVENT, ULONG); 
typedef VOID (WINAPI * PCLX_DISCONNECT)(PVOID);
typedef VOID (WINAPI * PCLX_TERMINATE)(PVOID); 
typedef VOID (WINAPI * PCLX_TEXTOUT)(PVOID, PVOID, int);
typedef VOID (WINAPI * PCLX_GLYPHOUT)(PVOID, UINT, UINT, PVOID);
typedef VOID (WINAPI * PCLX_BITMAP)(PVOID, UINT, UINT, PVOID, UINT, PVOID);
typedef VOID (WINAPI * PCLX_DIALOG)(PVOID, HWND);


#define CLX_INITIALIZE      _T("ClxInitialize")
#define CLX_CONNECT         _T("ClxConnect")
#define CLX_EVENT           _T("ClxEvent")
#define CLX_DISCONNECT      _T("ClxDisconnect")
#define CLX_TERMINATE       _T("ClxTerminate")

#define CLX_TEXTOUT         _T("ClxTextOut")
#define CLX_GLYPHOUT        _T("ClxGlyphOut")
#define CLX_BITMAP          _T("ClxBitmap")
#define CLX_DIALOG          _T("ClxDialog")

#endif // __CLXAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\glyphspy\bmpdb.c ===
#include	"..\lib\bmpdb.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\clx\clxtshar.h ===
/*++
 *  File name:
 *      clxtshar.h
 *  Contents:
 *      Header file for clxtshar.dll
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#ifndef _CLXTSHAR_H
#define _CLXTSHAR_H

#ifdef  OS_WIN16
#include    <ctype.h>
#include    <tchar.h>

#define UINT_PTR    UINT
#define LONG_PTR    LONG
#define TEXT(_s_)   _s_
#define LPCTSTR LPCSTR
#define TCHAR   char
#define CHAR    char
#define INT     int
#define LOADDS  __loadds
//#define EXPORT  __export LOADDS __far
//#define CLXAPI
#define HUGEMOD __huge
#define HUGEMEMCPY  hmemcpy
#define MAKEWORD(_hi, _lo)  ((((WORD)((_hi) & 0xFF)) << 8)|((_lo) & 0xFF))

#define BST_UNCHECKED      0x0000
#define BST_CHECKED        0x0001
#define BST_INDETERMINATE  0x0002
#define BST_PUSHED         0x0004
#define BST_FOCUS          0x0008

#endif  // OS_WIN16
#ifdef  OS_WIN32
//#define EXPORT
#define LOADDS
//#define CLXAPI  __declspec(dllexport)
#define HUGEMOD
#define HUGEMEMCPY  memcpy
#endif  // OS_WIN32

#ifdef  UNICODE
#define _CLX_strstr(s1, s2)     wcsstr(s1, s2)
#define _CLX_strchr(s, c)       wcschr(s, c)
#define _CLX_strlen(s)          wcslen(s)
#define _CLX_strcpy(s1, s2)     wcscpy(s1, s2)
#define _CLX_strncpy(s1, s2, n) wcsncpy(s1, s2, n)
#define _CLX_atol(s)            _wtol(s)
#define _CLX_vsnprintf(s, n, f, a)  _vsnwprintf(s, n, f, a)
#define _CLX_strcmp(s1, s2)     wcscmp(s1, s2)
BOOL    _CLX_SetDlgItemTextA(HWND hDlg, INT nDlgItem, LPCSTR lpString);
#else   // !UNICODE
#define _CLX_strstr(s1, s2)     strstr(s1, s2)
#define _CLX_strchr(s, c)       strchr(s, c)
#define _CLX_strlen(s)          strlen(s)
#define _CLX_strcpy(s1, s2)     strcpy(s1, s2)
#define _CLX_strncpy(s1, s2, n) strncpy(s1, s2, n)
#define _CLX_atol(s)            atol(s)
#define _CLX_vsnprintf(s, n, f, a)  _vsnprintf(s, n, f, a)
#define _CLX_strcmp(s1, s2)     strcmp(s1, s2)
#endif

#ifndef OS_WINCE
#define _CLXALLOC(_size_)           GlobalAllocPtr(GMEM_FIXED, _size_)
#define _CLXFREE(_ptr_)             GlobalFreePtr(_ptr_)
#define _CLXREALLOC(_ptr_, _size_)  GlobalReAllocPtr(_ptr_, _size_, 0)
typedef HINSTANCE                   _CLXWINDOWOWNER;
                                                // Windows are identified by
                                                // hInstance
#else   // OS_WINCE
#define _CLXALLOC(_size_)           LocalAlloc(LMEM_FIXED, _size_)
#define _CLXFREE(_ptr_)             LocalFree(_ptr_)
#define _CLXREALLOC(_ptr_, _size_)  LocalReAlloc(_ptr_, _size_, 0)
typedef DWORD                       _CLXWINDOWOWNER;
                                                // Identified by process Id

#define WSAGETSELECTERROR(lParam)       HIWORD(lParam)
#define WSAGETSELECTEVENT(lParam)       LOWORD(lParam)

BOOL    _StartAsyncThread(VOID);
VOID    _CloseAsyncThread(VOID);
INT     WSAAsyncSelect(SOCKET s, HWND hWnd, UINT uiMsg, LONG lEvent);
INT     AsyncRecv(SOCKET s, PVOID pBuffer, INT nBytesToRead, INT *pnErrorCode);
BOOL
CheckDlgButton(
    HWND hDlg,
    INT  nIDButton,
    UINT uCheck);

#define isalpha(c)  ((c >= 'A' && c <= 'Z') ||\
                    (c >= 'a' && c <= 'z'))
#endif  // OS_WINCE

#include <clxapi.h>
#include <wuiids.h>

#include "..\lib\feedback.h"
#include "..\lib\clntdata.h"
#include "clxexport.h"

// Context structure
typedef struct _CLXINFO {
    HWND    hwndMain;           // Clients main window
    HDC     hdcShadowBitmap;    // Client's shadow bitmap
    HBITMAP hShadowBitmap;      // -- " --
// members used in local mode
    HWND    hwndSMC;            // SmClient window handle
#ifdef  OS_WIN32
#ifndef OS_WINCE
    HANDLE  hMapF;              // Map file for passing data to smclient
    UINT    nMapSize;           // Currently allocated map file
    DWORD   dwProcessId;        // Our process ID
#endif  // !OS_WINCE
#endif  // OS_WIN32

// Used in RCLX mode WIN16/WIN32
    HWND    hwndInput;          // client input window
    BOOL    alive;              // TRUE if client is connected to Hydra server
    SOCKET  hSocket;            // Used only in RCLX mode
    struct  sockaddr_in sinTestSrv;
                                // cached address of TestServer
    HWND    hwndDialog;         // RDP client's dialog
    RCLXCONNECTINFO RClxInfo;   // Connection info
    UINT_PTR uiReconnectTimer;   // Timer for reconnect retrys

// Receiving messages
    BOOL    bPrologReceived;
    UINT32  nBytesReceived;
    RCLXREQPROLOG    RClxReqProlog;
    BYTE    *pRequest;
    UINT32  nReqAllocSize;
    BOOL    bClientInfoSent;
    BOOL    bCloseTrys;
    LONG    bClipboardReenter;

#ifndef OS_WINCE
#ifdef  OS_WIN32
    BOOL    bSendMsgThreadExit; // Used by _ClxSendMessage
    HANDLE  semSendReady;
    HANDLE  semSendCompleted;
    HANDLE  semSendDone;
    HANDLE  hSendMsgThread;
    MSG     msg;
#endif  // OS_WIN32
#endif  // !OS_WINCE
} CLXINFO, *PCLXINFO;

/*
 *  Clipboard help functions (clputil.c)
 */
VOID
Clp_GetClipboardData(
    UINT    format,
    HGLOBAL hClipData,
    UINT32  *pnClipDataSize,
    HGLOBAL *phNewData);

BOOL
Clp_SetClipboardData(
    UINT    formatID,
    HGLOBAL hClipData,
    UINT32  nClipDataSize,
    BOOL    *pbFreeHandle);

/*
 *  Internal functions definitions
 */
BOOL RClx_Connect(PCLXINFO pClx);
VOID RClx_Disconnect(PCLXINFO pClx);
BOOL RClx_SendBuffer(SOCKET hSocket, PVOID pBuffer, DWORD nSize);
BOOL RClx_SendEvent(PCLXINFO pClx, CLXEVENT Event, DWORD dwParam);
BOOL
RClx_SendClipboard(
    PCLXINFO    pClx,
    UINT        uiFormat,
    UINT32      nSize,
    VOID        HUGEMOD *pClipboard);
BOOL
RClx_SendTextOut(
    PCLXINFO pClx, 
    PVOID   pText, 
    INT     textLength);
BOOL RClx_SendBitmap(
        PCLXINFO pClx,
        UINT cxSize,
        UINT cySize,
        PVOID pBuffer,
        UINT  nBmiSize,
        PVOID pBmi);
VOID RClx_CreateWindow(HINSTANCE hInstance);
VOID RClx_DestroyWindow(VOID);
BOOL RClx_ReadRequest(PCLXINFO pClx);
VOID RClx_ProcessRequest(PCLXINFO pClx);

VOID    _StripGlyph(LPBYTE pData, UINT *pxSize, UINT ySize);
HWND    _ParseCmdLine(LPCTSTR szCmdLine);
VOID
CLXAPI
ClxEvent(PCLXINFO pClx, CLXEVENT Event, ULONG uResult);
HWND    _FindTopWindow(LPCTSTR, LPCTSTR, _CLXWINDOWOWNER);
#ifndef OS_WINCE
HWND    _FindSMCWindow(PCLXINFO);
HWND    _CheckWindow();
#endif  // !OS_WINCE

#ifdef  OS_WIN32
#ifndef OS_WINCE

#define CLX_ONE_PAGE    4096        // Map-file alignment

BOOL    _OpenMapFile(PCLXINFO pClx, UINT nSize);
BOOL    _ReOpenMapFile(PCLXINFO pClx, UINT newSize);
BOOL    _SaveInMapFile(HANDLE hMapF, 
                       LPVOID *str, 
                       INT strsize, 
                       DWORD dwProcessId);
BOOL    _CheckRegistrySettings(VOID);
#endif  // !OS_WINCE
#endif  // OS_WIN32

#ifdef  OS_WIN16
BOOL    _CheckIniSettings(VOID);
__inline INT     GetLastError(VOID)       { return -1; }
#endif  // OS_WIN16

VOID    _GetIniSettings(VOID);
VOID __cdecl LocalPrintMessage(INT errlevel, LPCTSTR format, ...);
VOID    _ClxAssert( LPCTSTR filename, INT line);
HWND    _FindWindow(HWND hwndParent, LPCTSTR srchclass);
VOID    _SetClipboard(UINT uiFormat, PVOID pClipboard, UINT32 nSize);
VOID    _OnBackground(PCLXINFO);
BOOL    _GarbageCollecting(PCLXINFO, BOOL bNotifiyForErrorBox);

BOOL
WS_Init(VOID);

VOID
_AttemptToCloseTheClient(VOID);

VOID
_GetDIBFromBitmap(
    HDC     hdcMemSrc,
    HBITMAP hBitmap,
    HANDLE  *phDIB,
    INT     left,
    INT     top,
    INT     right,
    INT     bottom);

DWORD
_ClxSendMsgThread(VOID *param);

LRESULT
_ClxSendMessage(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam
);

VOID
_ClxDestroySendMsgThread(PCLXINFO pClx);

DWORD
_CLXSendDataVC(
    LPCSTR szChannelName,
    LPVOID pData,
    DWORD  dwSize
    );

// This structure is used by _FindTopWindow
typedef struct _SEARCHWND {
    LPCTSTR  szClassName;       // The class name of searched window,
                                // NULL - ignore
    LPCTSTR  szCaption;          // Window caption, NULL - ignore
    _CLXWINDOWOWNER   hInstance;          
                                // instance of the owner, NULL - ignore
    HWND    hWnd;               // Found window handle
} SEARCHWND, *PSEARCHWND;

enum {ERROR_MESSAGE = 0, WARNING_MESSAGE, INFO_MESSAGE, ALIVE_MESSAGE};

typedef struct _CLXVCHANNEL {
    CHAR                szName[MAX_VCNAME_LEN];
    PCLXVC_SENDDATA     pSendDataFn;
    struct _CLXVCHANNEL *pNext;
} CLXVCHANNEL, *PCLXVCHANNEL;

#ifndef SD_RECEIVE
#define SD_RECEIVE      0x00
#define SD_SEND         0x01
#define SD_BOTH         0x02
#endif  // SD_RECEIVE

#define _CLXWINDOW_CLASS            "CLXTSHARClass"
#define RCLX_RECONNECT_TIMERID      11000
#define RCLX_BACKGNDTIMERID         11001
#define RCLX_TIMERELAPSETIME        15000    // 15 seconds between retrys
#define RCLX_RECONNECTELAPSETIME    5000

PCLXINFO    g_pClx     = NULL;
PCLXVCHANNEL g_pVChannels = NULL;
// Used in RCLX mode
CHAR        g_szTestServer[_MAX_PATH] = "";
u_short     g_nPort    = RCLX_DEFAULT_PORT;    
                                    // Read this from cmdline
HWND        g_hWindow  = NULL;      // Window for receving winsock messages
HINSTANCE   g_hInstance = NULL;     // Dll instance
UINT32      g_nMyReconId = 0;      // RCLX recon mode, contains ID to reconnect
_CLXWINDOWOWNER     g_hRDPInst;     // instance of RDP client
UINT_PTR    g_uiBackgroundTimer = 0;// Background processing timer
INT         g_VerboseLevel = 1;     // default verbose level: only errors
INT         g_GlyphEnable  = 0;

// UI texts, captions and so
TCHAR g_strClientCaption[_MAX_PATH];
TCHAR g_strDisconnectDialogBox[_MAX_PATH];
TCHAR g_strYesNoShutdown[_MAX_PATH];

// BitMask is used by _StripGlyph
const BYTE BitMask[] = {0x0, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF};

#define IS_RCLX     (g_szTestServer[0])

#define TRACE(_x_)  LocalPrintMessage _x_
#ifndef OS_WINCE
#define ASSERT(_x_) if (!(_x_)) _ClxAssert( __FILE__, __LINE__)
#endif

#endif  // !_CLXTSHAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\clx\clxtshar.c ===
/*+
 *  File name:
 *      clxtshar.c
 *  Contents:
 *      Client extension loaded by RDP client
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#include    <windows.h>
#include    <windowsx.h>
#include    <winsock.h>
#include    <string.h>
#include    <malloc.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <stdarg.h>
#ifndef OS_WINCE
    #include    <direct.h>
#endif  // OS_WINCE

#ifndef OS_WINCE
#ifdef  OS_WIN32
    #include    <process.h>
#endif  // OS_WIN32
#endif  // !OS_WINCE

#include    "clxexport.h"
#include    "clxtshar.h"

#define WM_CLIPBOARD    (WM_USER)   // Internal notifcation to send
                                    // our clipboard

#ifdef  OS_WIN32
#ifndef OS_WINCE
/*++
 *  Function:
 *      DllMain
 *  Description:
 *      Dll entry point for win32 (no WinCE)
 --*/
int APIENTRY DllMain(HINSTANCE hDllInst,
                    DWORD   dwReason,
                    LPVOID  fImpLoad)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hDllInst;
        TRACE((INFO_MESSAGE, TEXT("Clx attached\n")));

        // Check the key "Allow Background Input"
        // If not set pop a message for that
        if (!_CheckRegistrySettings())
            MessageBox(NULL, "CLXTSHAR.DLL: Can't find registry key:\n"
            "HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\"
            "Allow Background Input.\n"
            "In order to work properly "
            "CLX needs this key to be set to 1", "Warning", 
            MB_OK);

        _GetIniSettings();
    }

    if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE((INFO_MESSAGE, TEXT("Clx detached\n")));
    }

    return TRUE;    
}
#endif  // !OS_WINCE
#endif  // OS_WIN32

#ifdef  OS_WINCE
/*++
 *  Function:
 *      dllentry
 *  Description:
 *      Dll entry point for wince
 --*/
BOOL __stdcall dllentry(HINSTANCE hDllInst,
                    DWORD   dwReason,
                    LPVOID  fImpLoad)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hDllInst;
        TRACE((INFO_MESSAGE, TEXT("Clx attached\n")));
        if (!_StartAsyncThread())
            TRACE((ERROR_MESSAGE,
                   TEXT("Can't start AsyncThread. TCP unusable\n")));

        _GetIniSettings();
    }

    if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE((INFO_MESSAGE, TEXT("Clx detached\n")));
        _CloseAsyncThread();
    }

    return TRUE;
}
#endif  // OS_WIN32

#ifdef  OS_WIN16
/*++
 *  Function:
 *      LibMain
 *  Description:
 *      Dll entry point for win16
 --*/
int CALLBACK LibMain(HINSTANCE hInstance,
                     WORD dataSeg,
                     WORD heapSize,
                     LPSTR pCmdLine)
{

    // Check if we are already initialized
    // Only one client is allowed in Win16 environment
    // so, only one dll can be loaded at a time
    if (g_hInstance)
        goto exitpt;

    g_hInstance = hInstance;

    // Check the key "Allow Background Input"
    // If not set pop a message for that
    if (!_CheckIniSettings())
        MessageBox(NULL, "CLXTSHAR.DLL: Can't find key: "
        "Allow Background Input in mstsc.ini, section \"\"\n"
        "In order to work properly "
        "CLX needs this key to be set to 1", "Warning",
        MB_OK);

        _GetIniSettings();

exitpt:

    return TRUE;
}
#endif  // OS_WIN16

/*++
 *  Function:
 *      ClxInitialize
 *  Description:
 *      Initilizes a context for the current session
 *      reads the command line paramters and determines
 *      the mode wich will run the extension: local or RCLX (Remote CLient
 *      eXecution)
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClInfo     - RDP client info
 *      ppClx       - context info
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      !mstsc after the dll is loaded
 --*/
BOOL 
CLXAPI
ClxInitialize(PCLINFO pClInfo, PCLXINFO *ppClx)
{
    BOOL rv = FALSE;
    HWND hwndSMC;

#ifdef  OS_WIN32
#ifndef OS_WINCE

    // We have enough problems in stress with early unloaded
    // dll, reference it now and keep it up until the process
    // dies
    LoadLibrary("clxtshar.dll");

#endif  // !OS_WINCE
#endif  // OS_WIN32

    hwndSMC = _ParseCmdLine(pClInfo->pszCmdLine);

    if (IS_RCLX && !WS_Init())
    {
        TRACE((ERROR_MESSAGE, TEXT("Can't init winsock\n")));
        goto exitpt;
    }

    if (g_pClx) 
    // Should not be called twice
    {
        TRACE((WARNING_MESSAGE, TEXT("g_pClx is not null. Reentered ?!\n")));
        goto exitpt;
    }

    *ppClx = (PCLXINFO)_CLXALLOC(sizeof(**ppClx));

    g_pClx = (*ppClx);

    if (!*ppClx)
        goto exitpt;

    // Clear the structure
    memset(*ppClx, 0, sizeof(**ppClx));

    // put init of g_pClx here
    g_pClx->bClipboardReenter = (ULONG)-1;
    //


    // Remember client's input window
    (*ppClx)->hwndMain = pClInfo->hwndMain;

    if (pClInfo->hwndMain)
#ifdef  OS_WINCE
        g_hRDPInst = GetCurrentProcessId();
#else   // !OS_WINCE
#ifdef  _WIN64
        g_hRDPInst = (HINSTANCE)GetWindowLongPtr((*ppClx)->hwndMain, GWLP_HINSTANCE);
#else   // !_WIN64
#ifdef  OS_WIN32
	    g_hRDPInst = (HINSTANCE)GetWindowLong((*ppClx)->hwndMain, GWL_HINSTANCE);
#endif  // OS_WIN32
#endif  // _WIN64
#ifdef  OS_WIN16
	    g_hRDPInst = (HINSTANCE)GetWindowWord((*ppClx)->hwndMain, GWW_HINSTANCE);
#endif  // OS_WIN16
#endif  // !OS_WINCE

#ifndef OS_WINCE
#ifdef  OS_WIN32
    // and dwProcessId
    (*ppClx)->dwProcessId = GetCurrentProcessId();
#endif  // OS_WIN32
#endif  // !OS_WINCE

    if (IS_RCLX)
    {
        (*ppClx)->hSocket = INVALID_SOCKET;
        RClx_CreateWindow(g_hInstance);
    } 
#ifdef  OS_WIN32
#ifndef OS_WINCE
    else {
        if (!((*ppClx)->hwndSMC = hwndSMC))
            (*ppClx)->hwndSMC = _FindSMCWindow(*ppClx);
    }
#endif  // !OS_WINCE
#endif  // OS_WIN32

   if (g_hWindow) // REMOVED: && g_nMyReconId)
        PostMessage(g_hWindow, WM_TIMER, 0, 0);

    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      ClxEvent
 *  Description:
 *      Notifies tclient.dll that some event happend.
 *      Connect/disconnect.
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx        - context
 *      Event       - can be one of the following:
 *                    CLX_EVENT_CONNECT
 *                    CLX_EVENT_DISCONNECT
 *                    CLX_EVENT_LOGON
 *  Called by:
 *      !mstsc  on event
 *      alse some of the internal functions call this, especialy
 *      to notify that the client can't connect:
 *      ClxTerminate
 *      _GarbageCollecting when an error box is popped
 --*/
VOID
CLXAPI
ClxEvent(PCLXINFO pClx, CLXEVENT Event, ULONG ulResult)
{
    UINT uiMessage = 0;
#ifdef  OS_WIN16
    ULONG   lResult = ulResult;
#else   // !OS_WIN16
    LONG_PTR lResult = ulResult;
#endif

    if (!pClx)
        goto exitpt;

#ifdef  VLADIMIS
#pragma message("Disable this peace before checkin")
    if (Event == CLX_EVENT_SHADOWBITMAPDC)
    {
        pClx->hdcShadowBitmap = (HDC)lResult;
        goto exitpt;
    } else if (Event == CLX_EVENT_SHADOWBITMAP)
    {
        pClx->hShadowBitmap = (HBITMAP)lResult;
        goto exitpt;
    }
#endif // VLADIMIS

    if (IS_RCLX)
    {
        RClx_SendEvent(pClx, Event, ulResult);
    } 
#ifndef OS_WINCE
    else {

        if (!_CheckWindow(pClx))
            goto exitpt;

        if (Event == CLX_EVENT_DISCONNECT)
            uiMessage = WM_FB_DISCONNECT;
        else if (Event == CLX_EVENT_CONNECT)
        {
            uiMessage = WM_FB_CONNECT;
            lResult   = (LONG_PTR)pClx->hwndMain;
        }
        else if (Event == CLX_EVENT_LOGON)
        // lResult contains the session ID
            uiMessage = WM_FB_LOGON;

        if (uiMessage)
        {
#ifdef  OS_WIN32
            _ClxSendMessage(pClx->hwndSMC, 
                        uiMessage, 
                        (WPARAM)lResult, 
                        pClx->dwProcessId);

#endif  // OS_WIN32
#ifdef	OS_WIN16
	    if (g_hRDPInst)
	        SendMessage(pClx->hwndSMC,
                        uiMessage,
                        g_hRDPInst,
                        (LPARAM)lResult);
#endif	// OS_WIN16
        }
    }
#endif  // !OS_WINCE

exitpt:
    ;
}

/*++
 *  Function:
 *      ClxTextOut
 *  Description:
 *      Notifies tclient.dll that TEXTOUT order is recieved.
 *      Passes the string to the dll. Supported only in Win32
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx        - context
 *      pText       - buffer containing the string
 *      textLength  - string length
 *  Called by:
 *      !mstsc on receiving textout order
 --*/
VOID
CLXAPI
ClxTextOut(PCLXINFO pClx, PVOID pText, INT textLength)
{
    if (!pClx || !(*((UINT16 *)pText)))
        goto exitpt;

    if (IS_RCLX)
    {
        RClx_SendTextOut(pClx, pText, textLength);
        goto exitpt;
    }

#ifdef  OS_WIN32
#ifndef OS_WINCE
    if (!_CheckWindow(pClx))
        goto exitpt;

    if (!pClx->hMapF)
        if (!_OpenMapFile(pClx, 0))
            goto exitpt;

    if (_SaveInMapFile(pClx->hMapF, pText, textLength, pClx->dwProcessId))
        _ClxSendMessage(pClx->hwndSMC, 
                    WM_FB_TEXTOUT, 
                    (WPARAM)pClx->dwProcessId, 
                    (LPARAM)pClx->hMapF);
#endif  // !OS_WINCE
#endif  // OS_WIN32

exitpt:
    ;
}

/*++
 *  Function:
 *      ClxTerminate
 *  Description:
 *      Frees all alocations from ClxInitialize
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx    - context
 *  Called by:
 *      !mstsc before the dll is unloaded and client exit
 --*/
VOID
CLXAPI
ClxTerminate(PCLXINFO pClx)
{
    PCLXVCHANNEL pNext;

    if (!pClx)
        goto exitpt;

    ClxEvent(pClx, CLX_EVENT_DISCONNECT, 0);

    if (IS_RCLX)
    {
        pClx->alive = FALSE;
        RClx_Disconnect(pClx);
    } 
#ifdef  OS_WIN32
#ifndef OS_WINCE
    else {
        if(pClx->hMapF)
	    CloseHandle(pClx->hMapF);
        _ClxDestroySendMsgThread(g_pClx);
    }
#endif  // !OS_WINCE
#endif  // OS_WIN32

    if (pClx->uiReconnectTimer)
    {
        KillTimer(g_hWindow, pClx->uiReconnectTimer);
        pClx->uiReconnectTimer = 0;
    }

    if (pClx->pRequest)
        _CLXFREE(pClx->pRequest);

    _CLXFREE(pClx);
    g_pClx = NULL;

    // dispose g_pVChannels;
    while(g_pVChannels)
    {
        pNext = g_pVChannels->pNext;
        free(g_pVChannels);
        g_pVChannels = pNext;
    }

    RClx_DestroyWindow();

    if (IS_RCLX)
        WSACleanup();

exitpt:
    ;
}

/*
 * Void functions exported to the RDP client
 */
VOID
CLXAPI
ClxConnect(PCLXINFO pClx, LPTSTR lpsz)
{
}

VOID
CLXAPI
ClxDisconnect(PCLXINFO pClx)
{
}


/*++
 *  Function:
 *      ClxDialog
 *  Description:
 *      The RDP client is ready with the connect dialog.
 *      In RCLX mode this means that we can connect to the test controler
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx    - connection context
 *      hwnd    - handle to the dialog window
 *  Called by:
 *      !mstsc when the connect dialog is ready
 --*/
VOID
CLXAPI
ClxDialog(PCLXINFO pClx, HWND hwnd)
{
    if (!pClx)
        goto exitpt;

    pClx->hwndDialog = hwnd;

    if (hwnd == NULL)
    // Dialog disappears
        goto exitpt;

    if (g_hWindow)
        PostMessage(g_hWindow, WM_TIMER, 0, 0);
    else
        TRACE((ERROR_MESSAGE, TEXT("No g_hWindow in ClxDialog\n")));

exitpt:
    ;
}

/*++
 *  Function:
 *      ClxBitmap
 *  Description:
 *      Send a received bitmap to tclient.dll
 *      Works on Win16/Win32/WinCE in RCLX mode
 *      and on Win32 for local mode
 *  Arguments:
 *      pClx        - context
 *      cxSize, cySize - size of the bitmap
 *      pBuffer     - bitmap bits
 *      nBmiSize    - size of BITMAPINFO
 *      pBmi        - BITMAPINFO
 *  Called by:
 *      UHDrawMemBltOrder!mstsc
 *      ClxGlyphOut
 --*/
VOID
CLXAPI
ClxBitmap(
        PCLXINFO pClx,
        UINT cxSize,
        UINT cySize,
        PVOID pBuffer,
        UINT  nBmiSize,
        PVOID pBmi)
{
#ifndef OS_WINCE
#ifdef  OS_WIN32
    UINT   nSize, nBmpSize;
    PBMPFEEDBACK pView;
#endif  // OS_WIN32
#endif  // !OS_WINCE

    if (!g_GlyphEnable)
        goto exitpt;

    if (!pClx)
        goto exitpt;

    if (nBmiSize && !pBmi)
        goto exitpt;

    if (IS_RCLX)
    {
        RClx_SendBitmap(pClx, cxSize, cySize, pBuffer, nBmiSize, pBmi);
        goto exitpt;
    }
#ifdef  OS_WIN32
#ifndef OS_WINCE
    if (!_CheckWindow(pClx))
        goto exitpt;

    if (!nBmiSize)
        nBmpSize = (cxSize * cySize ) >> 3;
    else
    {
        nBmpSize = ((PBITMAPINFO)pBmi)->bmiHeader.biSizeImage;
        if (!nBmpSize)
            nBmpSize = (cxSize * cySize * 
                        ((PBITMAPINFO)pBmi)->bmiHeader.biBitCount) >> 3;
    }

    nSize = nBmpSize + nBmiSize + sizeof(*pView);
    if (!nSize)
        goto exitpt;

    if (!pClx->hMapF)
        if (!_OpenMapFile(pClx, nSize))
            goto exitpt;

    if (nSize > pClx->nMapSize)
        if (!_ReOpenMapFile(pClx, nSize))
            goto exitpt;

    pView = MapViewOfFile(pClx->hMapF,
                          FILE_MAP_ALL_ACCESS,
                          0,
                          0,
                          nSize);

    if (!pView)
        goto exitpt;

    pView->lProcessId = pClx->dwProcessId;
    pView->bmpsize = nBmpSize;
    pView->bmiSize = nBmiSize;
    pView->xSize = cxSize;
    pView->ySize = cySize;

    if (pBmi)
        CopyMemory(&(pView->BitmapInfo), pBmi, nBmiSize);

    CopyMemory((BYTE *)(&(pView->BitmapInfo)) + nBmiSize, pBuffer, nBmpSize);

    if (!nBmiSize)
    {
        // This is glyph, strip it to the skin
        _StripGlyph((BYTE *)(&pView->BitmapInfo), &cxSize, cySize);
        nBmpSize = (cxSize * cySize ) >> 3;
        pView->bmpsize = nBmpSize;
        pView->xSize = cxSize;
    }

    UnmapViewOfFile(pView);

    _ClxSendMessage(pClx->hwndSMC, 
                WM_FB_BITMAP, 
                (WPARAM)pClx->dwProcessId, 
                (LPARAM)pClx->hMapF);

#endif  // !OS_WINCE
#endif  // OS_WIN32

exitpt:
    ;
}

/*++
 *  Function:
 *      ClxGlyphOut
 *  Description:
 *      Send a glyph to tclient.dll
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx        - context
 *      cxBits,cyBits - glyph size
 *      pBuffer     - the glyph
 *  Called by:
 *      GHOutputBuffer!mstsc
 --*/
VOID
CLXAPI
ClxGlyphOut(
        PCLXINFO pClx,
        UINT cxBits,
        UINT cyBits,
        PVOID pBuffer)
{
    if (g_GlyphEnable)
        ClxBitmap(pClx, cxBits, cyBits, pBuffer, 0, NULL);
}

/*++
 *  Function:
 *      ClxGlyphOut
 *  Description:
 *      Send a glyph to tclient.dll
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx        - context
 *      cxBits,cyBits - glyph size
 *      pBuffer     - the glyph
 *  Called by:
 *      GHOutputBuffer!mstsc
 --*/
BOOL
CLXAPI
ClxGetClientData(
    PCLX_CLIENT_DATA pClntData
    )
{
    BOOL rv = FALSE;

    if (!pClntData)
    {
        TRACE((ERROR_MESSAGE, TEXT("ClxGetClientData: parameter is NULL\n")));
        goto exitpt;
    }

    memset(pClntData, 0, sizeof(*pClntData));

    if (!g_pClx)
    {
        TRACE((ERROR_MESSAGE, TEXT("ClxGetClientData: Clx has no context\n")));
        goto exitpt;
    }

    pClntData->hScreenDC        = g_pClx->hdcShadowBitmap;
    pClntData->hScreenBitmap    = g_pClx->hShadowBitmap;
    pClntData->hwndMain         = g_pClx->hwndMain;
    pClntData->hwndDialog       = g_pClx->hwndDialog;
    pClntData->hwndInput        = g_pClx->hwndInput;

    rv = TRUE;
exitpt:
    return rv;    
}

/*++
 *  Function:
 *      _ParseCmdLine
 *  Description:
 *      Retreives WHND of tclient.dll feedback window
 *      passed by the command line
 *      or retreives TestServer name if clxtshar will be
 *      executed in RCLX mode
 *      Win32/Win16/WinCE
 *  Arguments:
 *      szCmdLine   - command line
 *  Return value:
 *      The window handle
 *  Called by:
 *      ClxInitialize
 --*/
HWND _ParseCmdLine(LPCTSTR szCmdLine)
{
    HWND        hwnd = NULL;
    LPCTSTR     pszwnd, pszdot, pszend;
    INT         nCounter;

    if (!szCmdLine)
        goto exitpt;

    TRACE((INFO_MESSAGE, TEXT("Command line: %s\n"), szCmdLine));

    // Check for _RECONIDOPT(ReconID) option
    pszwnd = _CLX_strstr(szCmdLine, TEXT(_RECONIDOPT));
    if (!pszwnd)
        goto skip_reconidopt;

    pszwnd += _CLX_strlen(TEXT(_RECONIDOPT));
    g_nMyReconId = _CLX_atol(pszwnd);
    
skip_reconidopt:
    // Check for _HWNDOPT(hSMC) option
    pszwnd = _CLX_strstr(szCmdLine, TEXT(_HWNDOPT));

    if (!pszwnd)
        goto exitpt;

    // Goto the parameter
    pszwnd += _CLX_strlen(TEXT(_HWNDOPT));

    // Find the end of the paramter
    pszend = _CLX_strchr(pszwnd, TEXT(' '));
    if (!pszend)
        pszend = pszwnd + _CLX_strlen(pszwnd);

    // Check if paramter is valid host name, i.e. not a number
    pszdot = _CLX_strchr(pszwnd, TEXT('.'));

    if (isalpha(*pszwnd) || (pszdot && (pszdot < pszend)))
    {
    // This is RCLX mode, grab the TestServer name
#ifdef  OS_WIN16
        INT len;
#else   // !OS_WIN16
        LONG_PTR len;
#endif  // OS_WIN16

        len = pszend - pszwnd;
        if (!len || len >= sizeof(g_szTestServer))
        {
            TRACE((WARNING_MESSAGE,
                   TEXT("TestServer name is too long\n")));
            goto exitpt;
        }

        for (nCounter = 0; 
             nCounter < len;
             g_szTestServer[nCounter] = (CHAR)(pszwnd[nCounter]), nCounter++)
            ;

        g_szTestServer[len] = 0;

#ifdef  UNICODE
        TRACE((INFO_MESSAGE,
               L"RCLX mode, connecting to test controler: %S\n",
               g_szTestServer));
#else   // !UNICODE
        TRACE((INFO_MESSAGE,
               "RCLX mode, connecting to test controler: %s\n",
               g_szTestServer));
#endif  // !UNICODE

    } else {
    // local execution, hwnd passed

#ifdef  _WIN64
        hwnd = (HWND) _atoi64(pszwnd);
#else   // !_WIN64
        hwnd = (HWND) _CLX_atol(pszwnd);
#endif  // !_WIN64

        TRACE((INFO_MESSAGE,
           TEXT("Local mode. Sending messages to smclient. HWND=0x%x\n"), 
           hwnd));
    }

exitpt:
    return hwnd;
}

#ifndef OS_WINCE
/*++
 *  Function:
 *      _EnumWindowsProcForSMC
 *  Description:
 *      Searches for the feedback window by class name
 *      When found, sends a WM_FB_ACCEPTME to ensure that
 *      this is the right window handle
 *      Win32/Win16/!WinCE
 *  Arguments:
 *      hWnd    - current window
 *      lParam  - unused
 *  Return value:
 *      FALSE if found
 *  Called by:
 *      _FindSMCWindow thru EnumWindows
 --*/
BOOL CALLBACK LOADDS _EnumWindowsProcForSMC( HWND hWnd, LPARAM lParam )
{
    TCHAR    classname[128];

    BOOL    bCont = TRUE;

    if (GetClassName(hWnd, classname, sizeof(classname)))
    {
        if (!
            _CLX_strcmp(classname, TEXT(_TSTNAMEOFCLAS)) &&
#ifdef  OS_WIN32
             SendMessage(hWnd, WM_FB_ACCEPTME, 0, GetCurrentProcessId()))
#endif
#ifdef  OS_WIN16
             SendMessage(hWnd, WM_FB_ACCEPTME, (WPARAM)g_hRDPInst, 0))
#endif
        {
            *((HWND*)lParam) = hWnd;
            bCont = FALSE;
        }
    }
    return bCont;
}

/*++
 *  Function:
 *      _FindSMCWindow
 *  Description:
 *      Finds the tclient feedback window
 *      Win32/Win16/!WinCE
 *  Arguments:
 *      pClx    - context
 *  Return value:
 *      The window handle
 *  Called by:
 *      ClxInitialize, _CheckWindow
 --*/
HWND _FindSMCWindow(PCLXINFO pClx)
{
    HWND hwndFound = NULL;

    EnumWindows(_EnumWindowsProcForSMC, (LPARAM)&hwndFound);

    return hwndFound;
}

/*++
 *  Function:
 *      _CheckWindow
 *  Description:
 *      Checks the feedback window and if neccessary finds it
 *      Win32/Win16/!WinCE
 *  Arguments:
 *      pClx    - context
 *  Return value:
 *      Feedback window handle
 *  Called by:
 *      ClxEvetm ClxTextOut, ClxBitmap
 --*/
HWND _CheckWindow(PCLXINFO pClx)
{
    if (!pClx->hwndSMC)
    {
        pClx->hwndSMC = _FindSMCWindow(pClx);

        if (pClx->hwndSMC)
        {
            TRACE((INFO_MESSAGE, 
            TEXT("SMC window found:0x%x\n"), 
            pClx->hwndSMC));
        }
    } else {
#ifdef  _WIN64
        if (!GetWindowLongPtr(pClx->hwndSMC, GWLP_HINSTANCE))
#else   // !_WIN64
#ifdef  OS_WIN32
        if (!GetWindowLong(pClx->hwndSMC, GWL_HINSTANCE))
#endif
#ifdef  OS_WIN16
        if (!GetWindowWord(pClx->hwndSMC, GWW_HINSTANCE))
#endif
#endif  // _WIN64
        {
            TRACE((WARNING_MESSAGE, TEXT("SMC window lost\n")));
            pClx->hwndSMC = NULL;
        }
    }

    return (pClx->hwndSMC);
}
#endif  // !OS_WINCE

#ifdef  OS_WIN32
#ifndef OS_WINCE
/*++
 *  Function:
 *      _OpenMapFile
 *  Description:
 *      Opens a shared memeory for passing feedback to tclient.dll
 *      Win32/!Win16/!WinCE
 *  Return value:
 *      TRUE if handle is allocated successfully
 *  Called by:
 *      ClxTextOut, ClxBitmap
 --*/
BOOL _OpenMapFile(PCLXINFO pClx, UINT nSize)
{
    HANDLE hMapF;
    UINT nPageAligned;

    if (!nSize)
        nPageAligned = ((sizeof(FEEDBACKINFO) / CLX_ONE_PAGE) + 1) * 
                                                            CLX_ONE_PAGE;
    else
        nPageAligned = ((nSize / CLX_ONE_PAGE) + 1) * CLX_ONE_PAGE;

    hMapF = CreateFileMapping(INVALID_HANDLE_VALUE,   //PG.SYS
                              NULL,                 // no security
                              PAGE_READWRITE,
                              0,                    // Size high
                              nPageAligned,         // Size low (1 page)
                              NULL);           

    pClx->nMapSize = (hMapF)?nPageAligned:0;
        
    pClx->hMapF = hMapF;
    return (hMapF != NULL);
}

/*++
 *  Function:
 *      _ReOpenMapFile
 *  Description:
 *      Closes and opens a new shared memory with larger size
 *      Win32/!Win16/!WinCE
 *  Arguments:
 *      pClx    - context
 *      newSize - size of the new memory
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      ClxBitmap
 --*/
BOOL _ReOpenMapFile(PCLXINFO pClx, UINT newSize)
{
    HANDLE hNewMapF;
    UINT    nPageAligned;

    nPageAligned = ((newSize / CLX_ONE_PAGE) + 1) * CLX_ONE_PAGE;
    if (pClx->hMapF)
        CloseHandle(pClx->hMapF);
    hNewMapF = CreateFileMapping(INVALID_HANDLE_VALUE,   //PG.SYS
                              NULL,                 // no security
                              PAGE_READWRITE,
                              0,                    // Size high
                              nPageAligned,         // Size low
                              NULL);

    pClx->nMapSize = (hNewMapF)?nPageAligned:0;
    pClx->hMapF = hNewMapF;

    return (hNewMapF != NULL);
}

/*++
 *  Function:
 *      _SaveinMapFile
 *  Description:
 *      Saves a string into the shared memory
 *      Win32/!Win16/!WinCE
 *  Arguments:
 *      hMapF       - handle to the map file
 *      str         - the string
 *      strsize     - size of the string
 *      dwProcessId - our process Id
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      ClxTextOut
 --*/
BOOL _SaveInMapFile(HANDLE hMapF, LPVOID *str, int strsize, DWORD dwProcessId)
{
    BOOL rv = FALSE, count = 0;
    PFEEDBACKINFO pView;
    DWORD laste;

    pView = MapViewOfFile(hMapF,
                          FILE_MAP_ALL_ACCESS,
                          0,
                          0,
                          sizeof(*pView));

    if (!pView)
        goto exitpt;

    pView->dwProcessId = dwProcessId;

    strsize = (strsize > sizeof(pView->string)/sizeof(WCHAR))?
              sizeof(pView->string)/sizeof(WCHAR):
              strsize;
    CopyMemory(pView->string, str, strsize*sizeof(WCHAR)); 
    ((WCHAR *)(pView->string))[strsize] = 0;
    pView->strsize = strsize;

    UnmapViewOfFile(pView);

    rv = TRUE;

exitpt:

    return rv;
}

/*++
 *  Function:
 *      _CheckRegistrySettings
 *  Description:
 *      Checks if the registry settings are OK for running clxtshar
 *      "Allow Background Input" must be set to 1 for proper work
 *      Win32/!Win16/!WinCE
 *  Return value:
 *      TRUE if the settings are OK
 *  Called by:
 *      DllMain
 --*/
BOOL _CheckRegistrySettings(VOID)
{
    HKEY    key;
    DWORD   disposition;
    DWORD   keyType;
    DWORD   value;
    DWORD   cbData;
    BOOL    rv = FALSE;
    LONG    sysrc;

    sysrc = RegCreateKeyEx(HKEY_CURRENT_USER,
                           REG_BASE,
                           0,                   /* reserved             */
                           NULL,                /* class                */
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,                /* security attributes  */
                           &key,
                           &disposition);

    cbData = sizeof(value);
    sysrc = RegQueryValueEx(key,
                ALLOW_BACKGROUND_INPUT,
                0,              // reserved
                &keyType,       // returned type
                (LPBYTE)&value, // data pointer
                &cbData);

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, 
            TEXT("RegQueryValueEx failed, status = %d\n"), sysrc));
        goto exitpt;
    }

    if (keyType != REG_DWORD || cbData != sizeof(value))
    {
        TRACE((WARNING_MESSAGE, 
            TEXT("Mismatch in type/size of registry entry\n")));
        goto exitpt;
    }

    rv = (value == 1);

exitpt:
    return rv;
}

#endif  // !OS_WINCE
#endif  // OS_WIN32

#ifdef  OS_WIN16
/*++
 *  Function:
 *      _CheckRegistrySettings
 *  Description:
 *      Checks if the ini settings are OK for running clxtshar
 *      "Allow Background Input" must be set to 1 for proper work
 *      !Win32/Win16/!WinCE
 *  Return value:
 *      TRUE if the settings are OK
 *  Called by:
 *      DllMain
 --*/
BOOL    _CheckIniSettings(VOID)
{
    UINT nABI;

    nABI = GetPrivateProfileInt("", 
                                ALLOW_BACKGROUND_INPUT, 
                                0, 
                                "mstsc.ini");

    return (nABI == 1);
}
#endif  // OS_WIN16

/*++
 *  Function:
 *      _GetIniSettings
 *  Description:
 *      Gets the verbose level for printing debug messages
 *      ini file: smclient.ini
 *      section : clx
 *      key     : verbose, value: 0-4 (0-(default) no debug spew, 4 all debug)
 *      key     : GlyphEnable, value: 0(default), 1 - Enables/Disables glyph sending
 *      Win32/Win16/WinCE
 *  Called by:
 *      DllMain, dllentry, LibMain
 --*/
VOID _GetIniSettings(VOID)
{
#ifdef  OS_WINCE
    g_VerboseLevel = 4;
    g_GlyphEnable  = 1;
#else   // !OS_WINCE
    CHAR    szIniFileName[_MAX_PATH];
    const   CHAR  smclient_ini[] = "\\smclient.ini";
    const   CHAR  clx_ini_section[] = "clx";

    *szIniFileName = 0;
    if (!_getcwd (
        szIniFileName,
        sizeof(szIniFileName) - strlen(smclient_ini) - 1)
    )
    {
        TRACE((ERROR_MESSAGE, TEXT("Current directory length too long.\n")));
    }
    strcat(szIniFileName, smclient_ini);

    // Get the timeout value
    g_VerboseLevel = GetPrivateProfileInt(
            clx_ini_section,
            "verbose",
            g_VerboseLevel,
            szIniFileName);

    g_GlyphEnable = GetPrivateProfileInt(
            clx_ini_section,
            "GlyphEnable",
            g_GlyphEnable,
            szIniFileName);
#endif  // !OS_WINCE

    GetPrivateProfileString(
        TEXT("tclient"),
        TEXT("UIYesNoDisconnect"),
        TEXT(YES_NO_SHUTDOWN),
        g_strYesNoShutdown,
        sizeof(g_strYesNoShutdown),
        szIniFileName
    );

    GetPrivateProfileString(
        TEXT("tclient"),
        TEXT("UIDisconnectDialogBox"),
        TEXT(DISCONNECT_DIALOG_BOX),
        g_strDisconnectDialogBox,
        sizeof(g_strDisconnectDialogBox),
        szIniFileName
    );

    GetPrivateProfileString(
        TEXT("tclient"),
        TEXT("UIClientCaption"),
        TEXT(CLIENT_CAPTION),
        g_strClientCaption,
        sizeof(g_strClientCaption),
        szIniFileName
    );
}

/*++
 *  Function:
 *      _StripGlyph
 *  Description:
 *      Strips leading and trailing blank ... BITS
 *      Yes, bits. The glyph must be aligned from left and right on bit
 *      And glyph width must be aligned on word
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pData   - the glyph bits
 *      pxSize  - glyph width
 *      ySize   - glyph height
 *  Called by:
 *      ClxBitmap
 --*/
VOID _StripGlyph(LPBYTE pData, UINT *pxSize, UINT ySize)
{
    UINT xSize = *pxSize;
    UINT leftBytes, leftBits;
    UINT riteBytes, riteBits;
    UINT xBytes = xSize >> 3;
    UINT xScan, yScan, xFinal;
    BOOL bScan, bAddByte;
    BYTE mask;
    BYTE *pSrc, *pDst;

    if (!pData || !xBytes || !ySize)
        goto exitpt;

    leftBytes = riteBytes = 0;
    leftBits  = riteBits  = 0;
    *pxSize = 0;        // Insurance for bad exit

    // Scan from left for first nonzero byte
    bScan = TRUE;
    while(bScan)
    {
        for (yScan = 0; yScan < ySize && bScan; yScan ++)
            bScan = (pData[yScan*xBytes + leftBytes] == 0);

        if (bScan)
        {
            leftBytes++;
            bScan = (leftBytes < xBytes);
        }
    }

    // Trash if blank
    if (leftBytes == xBytes)
        goto exitpt;

    // Scan from left for most left nonzero bit
    for(yScan = 0; yScan < ySize; yScan ++)
    {
        UINT bitc = 0;
        BYTE b = pData[yScan*xBytes + leftBytes];

        while (b)
        {
            b >>= 1;
            bitc ++;
        }
        if (bitc > leftBits)
            leftBits = bitc;
    }

    if (!leftBits)
    // There's something wrong
        goto exitpt;

    leftBits = 8 - leftBits;

    // So far so good. Check the ri(gh)te side
    bScan = TRUE;
    while(bScan)
    {
        for(yScan = 0 ; yScan < ySize && bScan; yScan ++)
            bScan = (pData[(yScan + 1)*xBytes - 1 - riteBytes] == 0);

        if (bScan)
        {
            riteBytes ++;
            bScan = (riteBytes < xBytes);
        }
    }

    // Scan from rite for most rite nonzero bit
    for(yScan = 0; yScan < ySize; yScan ++) 
    {
        UINT bitc = 0;
        BYTE b = pData[(yScan+1)*xBytes - 1 - riteBytes];

        while(b)
        {
            b <<= 1;
            bitc ++;
        }
        if (bitc > riteBits)
            riteBits = bitc;
    }
    riteBits = 8 - riteBits;

    // Cool, now get the final width
    xFinal = xSize - riteBits - leftBits - ((leftBytes + riteBytes) << 3);
    // align it and get bytes
    xFinal = (xFinal + 8) >> 3;

    // Now smoothly move the bitmap to the new location
    pDst = pData;
    mask = BitMask[leftBits];
    bAddByte = xFinal & 1;

    for (yScan = 0; yScan < ySize; yScan ++)
    {

        pSrc = pData + yScan*xBytes + leftBytes;
        for(xScan = 0; xScan < xFinal; xScan ++, pDst++, pSrc++)
        {
            BYTE b = *pSrc;
            BYTE r;

            r = (pSrc[1] & mask) >> (8 - leftBits);

            b <<= leftBits;
            b |= r;
            (*pDst) = b;
        }
        pDst[-1] &= BitMask[8 - (riteBits + leftBits) % 8];

        if (bAddByte)
        {
            (*pDst) = 0;
            pDst++;
        }
    }

    // BUG: Yes, this is a real bug. But removing it means to
    // rerecord all glyph database and the impact for
    // glyph recognition is not so bad
    //if (bAddByte)
    //    xFinal++;

    *pxSize = xFinal << 3;
exitpt:
    ;
}


/*++
 *  Function:
 *      LocalPrintMessage
 *  Description:
 *      Prints debugging and warning/error messages
 *      Win32/Win16/WinCE
 *  Arguments:
 *      errlevel    - level of the message to print
 *      format      - print format
 *  Called by:
 *      every TRACE line
 --*/
VOID __cdecl LocalPrintMessage(INT errlevel, LPCTSTR format, ...)
{
    TCHAR szBuffer[256];
    TCHAR *type;
    va_list     arglist;
    int nchr;

    if (errlevel >= g_VerboseLevel)
        goto exitpt;

    va_start (arglist, format);
    nchr = _CLX_vsnprintf (szBuffer, sizeof(szBuffer), format, arglist);
    va_end (arglist);

    switch(errlevel)
    {
    case INFO_MESSAGE:      type = TEXT("CLX INF:"); break;
    case ALIVE_MESSAGE:     type = TEXT("CLX ALV:"); break;
    case WARNING_MESSAGE:   type = TEXT("CLX WRN:"); break;
    case ERROR_MESSAGE:     type = TEXT("CLX ERR:"); break;
    default: type = TEXT("UNKNOWN:");
    }

    OutputDebugString(type);
    OutputDebugString(szBuffer);
exitpt:
    ;
}


/*++
 *  Function:
 *      _ClxAssert
 *  Description:
 *      Asserts boolean expression
 *      Win32/Win16/WinCE
 *  Arguments:
 *      bCond       - boolean condition
 *      filename    - source file of the assertion
 *      line        - line of the assertion
 *  Called by:
 *      every ASSERT line
 --*/
VOID    _ClxAssert( LPCTSTR filename, INT line)
{
    TRACE((ERROR_MESSAGE, 
            TEXT("ASSERT: %s line %d\n"), filename, line));

    DebugBreak();
}
/*
 *  RCLX (Remote CLient eXecution) functions
 */

/*++
 *  Function:
 *      RClx_SendClientInfo
 *  Description:
 *      Sends platform specific information to the test controller
 *      Allows reconnection to a previous thread on the test ctrler
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx    - context
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      _ClxWndProc on WM_TIMER message
 --*/
BOOL
RClx_SendClientInfo(PCLXINFO pClx)
{
    LPCSTR szClientInfo;
    RCLXCLIENTINFOFEED ClntInfo;
    RCLXFEEDPROLOG  FeedProlog;
    BOOL rv = FALSE;

    ASSERT(pClx->hSocket != INVALID_SOCKET);

    TRACE((ALIVE_MESSAGE,
           TEXT("Sending Client info\n")));

#ifdef  OS_WIN16
    szClientInfo = "WIN16";
#endif  // OS_WIN16
#ifdef  OS_WIN32
#ifndef OS_WINCE
    szClientInfo = "WIN32";
#else
    szClientInfo = "WINCE";
#endif  // OS_WINCE
#endif  // OS_WIN32
    strcpy(ClntInfo.szClientInfo, szClientInfo);

    if (!g_nMyReconId)
    {
        ClntInfo.nReconnectAct = 0;
        ClntInfo.ReconnectID   = 0;
    } else {
        ClntInfo.nReconnectAct = 1;
        ClntInfo.ReconnectID   = g_nMyReconId;
    }

    FeedProlog.FeedType = FEED_CLIENTINFO;
    FeedProlog.HeadSize = sizeof(ClntInfo);
    FeedProlog.TailSize = 0;

    rv = RClx_SendBuffer(pClx->hSocket,
                         &FeedProlog,
                         sizeof(FeedProlog));

    rv = RClx_SendBuffer(pClx->hSocket,
                         &ClntInfo,
                         sizeof(ClntInfo));

    if (rv)
        pClx->bClientInfoSent = TRUE;

    return rv;
}

/*++
 *  Function:
 *      RClx_Connect
 *  Description:
 *      Connects to the TestServer. The connect call is blocking
 *      After the connection succeeds "selects" the socket for
 *      async read, write is blocking
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx    - context
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      _ClxWndProc on WM_TIMER message
 --*/
BOOL RClx_Connect(PCLXINFO pClx)
{
    SOCKET  hRemote;
    BOOL    rv = FALSE;
    INT     optval;

    ASSERT(pClx);

    if (pClx->hSocket != INVALID_SOCKET)
    {
        TRACE((WARNING_MESSAGE, 
            TEXT("RClx_Connect called more than once\n")));
        rv = TRUE;
        goto exitpt;
    }

#ifdef  UNICODE
    TRACE((INFO_MESSAGE, 
           L"Connecting to: %S:%d\n", g_szTestServer, g_nPort));
#else   // !UNICODE
    TRACE((INFO_MESSAGE,
           "Connecting to: %s:%d\n", g_szTestServer, g_nPort));
#endif  // !UNICODE

    hRemote = socket(AF_INET, SOCK_STREAM, 0);
    if (hRemote == INVALID_SOCKET)
    {
        TRACE((ERROR_MESSAGE, 
            TEXT("Can't create socket: %d\n"), WSAGetLastError()));
        goto exitpt;
    }

    optval = 1;
    setsockopt(hRemote, 
               IPPROTO_TCP, 
               TCP_NODELAY, 
               (const char *)&optval, 
               sizeof(optval));
    setsockopt(hRemote, 
               SOL_SOCKET,  
               SO_DONTLINGER, 
               (const char *)&optval, 
               sizeof(optval));

    if ((!pClx->sinTestSrv.sin_addr.s_addr ||
        pClx->sinTestSrv.sin_addr.s_addr == INADDR_NONE) &&
        (pClx->sinTestSrv.sin_addr.s_addr = inet_addr(g_szTestServer)) 
                                                == INADDR_NONE)
    {
        struct hostent *phostent;

        if ((phostent = gethostbyname(g_szTestServer)) == NULL)
        {
#ifdef  UNICODE
            TRACE((ERROR_MESSAGE,
                   L"gethostbyname for %S failed: %d\n",
                   g_szTestServer, WSAGetLastError()));
#else   // !UNICODE
            TRACE((ERROR_MESSAGE,
                   "gethostbyname for %s failed: %d\n",
                   g_szTestServer, WSAGetLastError()));
#endif  // !UNICODE
            goto cleanup;
        }
        pClx->sinTestSrv.sin_addr.s_addr = *(u_long*)(phostent->h_addr);
    }

    pClx->sinTestSrv.sin_family = PF_INET;
    pClx->sinTestSrv.sin_port = htons(g_nPort);

    if (connect(hRemote, 
                (SOCKADDR *)&(pClx->sinTestSrv), 
                sizeof(pClx->sinTestSrv)) 
                == SOCKET_ERROR)
    {
#ifdef  UNICODE
        TRACE((WARNING_MESSAGE,
               L"Can't connect to %S: %d\n",
               g_szTestServer, WSAGetLastError()));
#else   // !UNICODE
        TRACE((WARNING_MESSAGE,
               "Can't connect to %s: %d\n",
               g_szTestServer, WSAGetLastError()));
#endif  // !UNICODE
        goto cleanup;
    }

    pClx->bClientInfoSent = FALSE;

    pClx->hSocket = hRemote;
    if (WSAAsyncSelect(hRemote, g_hWindow, WM_WSOCK, FD_CLOSE|FD_READ) ==
        SOCKET_ERROR)
    {
        TRACE((ERROR_MESSAGE,
               TEXT("WSAAsyncSelect failed: %d\n"),
               WSAGetLastError()));
        goto cleanup;
    }

    // If the socket is disconnected somewhere between connect and select
    // we'll miss the notification, so try to read
    // and have chance to fail
    PostMessage(g_hWindow, WM_WSOCK, hRemote, FD_READ);

    rv = TRUE;
exitpt:
    return rv;
cleanup:
    pClx->hSocket = hRemote;
    RClx_Disconnect(pClx);
    return rv;
}


/*++
 *  Function:
 *      RClx_Disconnect
 *  Description:
 *      Gracefully closes the socket to the TestServer. Deinitializes
 *      some vars in the context. Removes garbage windows
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx    - context
 *  Called by:
 *      ClxTerminate
 *      RClx_Connect on error
 *      RClx_SendEvent on EVENT_DIACONNECT
 *      _ClxWndProc on WM_WSOCK and error
 --*/
VOID RClx_Disconnect(PCLXINFO pClx)
{
    INT     recvresult;
    CHAR    tBuf[128];

    if (pClx && pClx->hSocket != INVALID_SOCKET)
    {
        WSAAsyncSelect(pClx->hSocket, g_hWindow, 0, 0);

        shutdown(pClx->hSocket, SD_SEND);
        do {
            recvresult = recv(pClx->hSocket, tBuf, sizeof(tBuf), 0);
        } while (recvresult && recvresult != SOCKET_ERROR);

        closesocket(pClx->hSocket);
        pClx->hSocket = INVALID_SOCKET;
    }

    // Zero some vars
    pClx->hwndInput = NULL;
    pClx->RClxInfo.szHydraServer[0] = 0;

    if (pClx->alive)
    {
        // attempt to close the client
        _AttemptToCloseTheClient();
        g_pClx->bCloseTrys = TRUE;
    }
    else if (g_hWindow && !g_nMyReconId)
    // Retry to connect
    {
        TRACE((INFO_MESSAGE, 
            TEXT("Disconnected from test server.Trying to reconnect\n")));

        // If there's no timer looping
        // Start connecting by posting a message
        if (!pClx->uiReconnectTimer)
            pClx->uiReconnectTimer = SetTimer(g_hWindow, RCLX_RECONNECT_TIMERID,
                                              RCLX_RECONNECTELAPSETIME, NULL);

        if (!pClx->uiReconnectTimer)
            PostMessage(g_hWindow, WM_TIMER, 0, 0);
    }
}

/*++
 *  Function:
 *      RClx_SendBuffer
 *  Description:
 *      Sends a buffer thru socket. The socket must be BLOCKING
 *      so, all the buffer is sent after this function exits
 *      Win32/Win16/WinCE
 *  Arguments:
 *      hSocket     - the socket
 *      pBuffer     - the buffer
 *      nSize       - buffer size
 *  Return value:
 *      TRUE on success, FALSE if the connection failed
 *  Called by:
 *      RClx_SendEvent
 *      RClx_SendBitmap
 *        
 --*/
BOOL 
RClx_SendBuffer(SOCKET hSocket, PVOID pBuffer, DWORD nSize)
{
    INT     result = 0;
    DWORD   nBytesToSend = nSize;
    UINT   nBytesToSend2;
    BYTE    HUGEMOD *pBuffPtr = pBuffer;

    ASSERT(hSocket != INVALID_SOCKET);
    ASSERT(pBuffer);

    if (!nSize)
        goto exitpt;

    do {
#ifdef  OS_WIN16
        nBytesToSend2 = (UINT)((nBytesToSend > 0x1000)?0x1000:nBytesToSend);
#else
        nBytesToSend2 = nBytesToSend;
#endif  // OS_WIN16

        result = send(hSocket, pBuffPtr, nBytesToSend2, 0);

        if (result != SOCKET_ERROR)
        {
            nBytesToSend -= result;
            pBuffPtr += result;
        } else
        if (WSAGetLastError() == WSAEWOULDBLOCK)
        {
        // The socket is blocked, wait on select until it's writable
            FD_SET fd;

            FD_ZERO(&fd);
            FD_SET(hSocket, &fd);

            select(-1, NULL, &fd, NULL, NULL);
        }
    } while ((result != SOCKET_ERROR || WSAGetLastError() == WSAEWOULDBLOCK) && 
             nBytesToSend);

exitpt:
    return (result != SOCKET_ERROR);
}


/*++
 *  Function:
 *      RClx_SendEvent
 *  Description:
 *      Sends an event to the TestServer
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx    - context
 *      Event   - the event
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      ClxEvent
 --*/
BOOL RClx_SendEvent(PCLXINFO pClx, CLXEVENT Event, DWORD dwParam)
{
    BOOL rv = FALSE;

    if (Event == CLX_EVENT_DISCONNECT)
    {
        pClx->alive = FALSE;
        RClx_Disconnect(pClx);
    }

    if (Event == CLX_EVENT_CONNECT)
    {
        RCLXFEEDPROLOG FeedProlog;

        pClx->alive = TRUE;
        FeedProlog.FeedType = FEED_CONNECT;
        FeedProlog.HeadSize = 0;
        FeedProlog.TailSize = 0;
        rv = RClx_SendBuffer(pClx->hSocket, 
                             &FeedProlog, 
                             sizeof(FeedProlog));
    }

    if (Event == CLX_EVENT_LOGON)
    {
        RCLXFEEDPROLOG FeedProlog;
        UINT32  uSessionID  = dwParam;

        pClx->alive = TRUE;
        FeedProlog.FeedType = FEED_LOGON;
        FeedProlog.HeadSize = sizeof(uSessionID);
        FeedProlog.TailSize = 0;
        rv = RClx_SendBuffer(pClx->hSocket,
                             &FeedProlog,
                             sizeof(FeedProlog));

        rv = RClx_SendBuffer(pClx->hSocket,
                             &uSessionID,
                             sizeof(uSessionID));
    }

    return rv;
}

/*++
 *  Function:
 *      RClx_SendClipbaord
 *  Description:
 *      Sends the current clipbaord content to the test controller
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx        - context
 *      uiFormat    - desired clipboard format
 *      nSize       - size of the data
 *      pClipboard  - the clipboard data
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      _ClxWndProc on WM_CLIPBOARD message
 --*/
BOOL
RClx_SendClipboard(
    PCLXINFO    pClx, 
    UINT        uiFormat, 
    UINT32      nSize, 
    VOID        HUGEMOD *pClipboard)
{
    BOOL rv = FALSE;

    RCLXFEEDPROLOG FeedProlog;
    RCLXCLIPBOARDFEED RClxClipboard;

    ASSERT(pClx);
    // if nSize == 0, then pClipboard == 0
    ASSERT((nSize && pClipboard) || (!nSize && !pClipboard));

    RClxClipboard.uiFormat = uiFormat;
    RClxClipboard.nClipBoardSize = nSize;

    FeedProlog.FeedType = FEED_CLIPBOARD;
    FeedProlog.HeadSize = sizeof(RClxClipboard);
    FeedProlog.TailSize = nSize;
    rv = RClx_SendBuffer(pClx->hSocket,
                         &FeedProlog,
                         sizeof(FeedProlog));

    if (!rv)
        goto exitpt;

    TRACE((INFO_MESSAGE,
           TEXT("Sending the clipboard, FormatID=%d, Size=%ld\n"),
           uiFormat, nSize));

    rv = RClx_SendBuffer(pClx->hSocket,
                         &RClxClipboard,
                         sizeof(RClxClipboard));

    if (!rv)
        goto exitpt;

    if (pClipboard)
        rv = RClx_SendBuffer(pClx->hSocket,
                             pClipboard,
                             nSize);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      RClx_SendTextOut
 *  Description:
 *      Sends text out order to the smclient in RCLX mode
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx        - context
 *      pText       - unicode string
 *      textLength  - the string length
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      ClxTextOut
 --*/
BOOL
RClx_SendTextOut(PCLXINFO pClx, PVOID pText, INT textLength)
{
    BOOL rv = FALSE;
    RCLXFEEDPROLOG FeedProlog;
    RCLXTEXTFEED   FeedText;
    UINT16  *szString; 

    ASSERT(pClx);
    if (!pText || !textLength)
        goto exitpt;

    FeedProlog.FeedType = FEED_TEXTOUT;
    FeedProlog.HeadSize = sizeof(FeedText);
    FeedProlog.TailSize = (textLength + 1) * sizeof(UINT16);

    szString = _alloca((textLength + 1) * sizeof(UINT16));
    if (!szString)
        goto exitpt;

    memcpy(szString, pText, textLength * sizeof(UINT16));
    szString[textLength] = 0;

    rv = RClx_SendBuffer(pClx->hSocket,
                         &FeedProlog,
                         sizeof(FeedProlog));

    if (!rv)
        goto exitpt;

    rv = RClx_SendBuffer(pClx->hSocket,
                         &FeedText,
                         sizeof(FeedText));

    if (!rv)
        goto exitpt;

    rv = RClx_SendBuffer(pClx->hSocket,
                         szString,
                         FeedProlog.TailSize);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      RClx_SendBitmap
 *  Description:
 *      Sends a bitmap to the TestController
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx    - context
 *      cxSize  - bitmap width
 *      cySize  - bitmap height
 *      pBuffer - pointer to bitmap bits
 *      nBmiSize- BitmapInfo length
 *      pBmi    - pointer to BITMAPINFO
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      ClxBitmap
 --*/
BOOL RClx_SendBitmap(
        PCLXINFO pClx,
        UINT cxSize,
        UINT cySize,
        PVOID pBuffer,
        UINT  nBmiSize,
        PVOID pBmi)
{
    BOOL rv = FALSE;
    RCLXFEEDPROLOG FeedProlog;
    RCLXBITMAPFEED FeedBitmap;
    UINT   nExtraBmi;
    UINT   nBmpSize;
    BYTE *pLocalBits;

    ASSERT(pClx);
    ASSERT(pClx->hSocket != INVALID_SOCKET);

    if (nBmiSize > sizeof(FeedBitmap.BitmapInfo))
    {
        TRACE((WARNING_MESSAGE,
               TEXT("BitmapInfo size larger than expected. Ignoring\n")));
        goto exitpt;
    }

    // Get bitmap size
    if (!nBmiSize)
    {
        nBmpSize = (cxSize * cySize ) >> 3;
    } else {
        nBmpSize = (UINT)(((PBITMAPINFO)pBmi)->bmiHeader.biSizeImage);
        if (!nBmpSize)
            nBmpSize = (cxSize * cySize *
                        ((PBITMAPINFO)pBmi)->bmiHeader.biBitCount) >> 3;
    }

    pLocalBits = _alloca(nBmpSize);
    if (!pLocalBits)
        goto exitpt;

    memcpy(pLocalBits, pBuffer, nBmpSize);

    if (!nBmiSize)
    {
         // this is glyph, strip it !
        _StripGlyph(pLocalBits, &cxSize, cySize);
        nBmpSize = (cxSize * cySize ) >> 3;
    }

    // Prepare the prolog
    FeedProlog.FeedType = FEED_BITMAP;
    nExtraBmi = sizeof(FeedBitmap.BitmapInfo) - nBmiSize;
    FeedProlog.HeadSize = sizeof(FeedBitmap) - nExtraBmi;
    FeedProlog.TailSize = nBmpSize;

    FeedBitmap.bmpsize = nBmpSize;
    FeedBitmap.bmisize = nBmiSize;
    FeedBitmap.xSize   = cxSize;
    FeedBitmap.ySize   = cySize;
    memcpy(&FeedBitmap.BitmapInfo, 
           pBmi, 
           sizeof(FeedBitmap.BitmapInfo) - nExtraBmi);

    if (!RClx_SendBuffer(pClx->hSocket, 
                         &FeedProlog, 
                         sizeof(FeedProlog)))
    {
        TRACE((ERROR_MESSAGE,
               TEXT("FEED_BITMAP:Can't send the prolog. WSAGetLastError=%d\n"),
                    WSAGetLastError()));
        goto exitpt;
    }
    if (!RClx_SendBuffer(pClx->hSocket, 
                         &FeedBitmap, 
                         FeedProlog.HeadSize))
    {
        TRACE((ERROR_MESSAGE,
               TEXT("FEED_BITMAP:Can't send the header.\n")));
        goto exitpt;
    }
    if (!RClx_SendBuffer(pClx->hSocket, pLocalBits, FeedProlog.TailSize))
    {
        TRACE((ERROR_MESSAGE,
               TEXT("FEED_BITMAP:Can't send the bits.\n")));
        goto exitpt;
    }

    rv = TRUE;
exitpt:
    return rv;
}


/*++
 *  Function:
 *      _ClxWndProc
 *  Description:
 *      Dispatche messages procedure. Dispatches WM_TIMER and
 *      WM_WSOCK - socket message. WM_TIMER drives _OnBackground
 *      and connection retrys
 *      Win32/Win16/WinCE
 *  Arguments:
 *      hwnd        - window handle, same as g_hWindow
 *      uiMessage   - message Id
 *      wParam      - word param
 *      lParam      - long param
 *  Return value:
 *      LRESULT     - standard for window procs
 --*/
LRESULT CALLBACK LOADDS _ClxWndProc( HWND hwnd,
                              UINT uiMessage,
                              WPARAM wParam,
                              LPARAM lParam)
{
    SOCKET   hSocket;
    PCLXINFO    pClx = g_pClx;
    
    switch (uiMessage)
    {
    case WM_WSOCK:
        if (!pClx)
        {
            TRACE((WARNING_MESSAGE,
                   TEXT("Winsock message before context initialization\n")));
            goto exitpt;
        }

        hSocket = (SOCKET)wParam;
        if (hSocket != pClx->hSocket)
        {
            TRACE((WARNING_MESSAGE,
                   TEXT("Notification for unknown socket\n")));
            goto exitpt;
        }

        if (WSAGETSELECTERROR(lParam))
        {
            TRACE((WARNING_MESSAGE,
                   TEXT("Winsock error: %d\n"), WSAGETSELECTERROR(lParam)));
            RClx_Disconnect(pClx);
            goto exitpt;
        }

        if (WSAGETSELECTEVENT(lParam) == FD_CLOSE)
        {
            TRACE((INFO_MESSAGE,
                   TEXT("Connection to the test server lost\n")));
            RClx_Disconnect(pClx);
        } else if (WSAGETSELECTEVENT(lParam) == FD_READ)
        {
            if (!RClx_ReadRequest(pClx) && 
                WSAGetLastError() != WSAEWOULDBLOCK)
            {
                TRACE((WARNING_MESSAGE,
                       TEXT("Socket read error: %d\n"), WSAGetLastError()));
                RClx_Disconnect(pClx);
            }
        } else {
            TRACE((WARNING_MESSAGE,
                   TEXT("Unexpected winsock notification #%d\n"), 
                   WSAGETSELECTEVENT(lParam)));
            goto exitpt;
        }

        break;
    case WM_TIMER:    // Start connection or background process
    {
        BOOL bRunRdp = FALSE;
        HWND hConBtn, hServerBox;
#ifndef  OS_WINCE
        // no resolution box in CE
        HWND hResolutionBox;
#endif
        CHAR szResSelect[20];

        if (!pClx)
        {
            TRACE((WARNING_MESSAGE,
                   TEXT("Timer message before context initialization\n")));
            goto exitpt;
        }

        if (g_uiBackgroundTimer == (UINT_PTR)wParam)
        // This is our background thread
        {
            _OnBackground(pClx);
            goto exitpt;
        }

        if (!g_nMyReconId && !pClx->hwndDialog)
        {
            pClx->hwndDialog = _FindTopWindow(NULL,
                                              g_strClientCaption,
                                              g_hRDPInst);
            goto check_timer;
        }

        if (!g_nMyReconId && pClx->hwndDialog &&
            !GetDlgItem(pClx->hwndDialog, UI_IDC_CONNECT))
        {
            TRACE((INFO_MESSAGE, TEXT("No dialog box yet. Waiting...\n")));
            goto check_timer;
        }

        if (pClx->alive && pClx->hSocket == INVALID_SOCKET)
        {
            TRACE((INFO_MESSAGE, 
                   TEXT("Client is alive, no socket to the test server\n")));

            //_AttemptToCloseTheClient();

            goto exitpt;
        }

        // Check if we are connected
        if (pClx->hSocket == INVALID_SOCKET && (!RClx_Connect(pClx)))
                goto check_timer;

        // We are connected, send the client info
        if (!pClx->bClientInfoSent)
            RClx_SendClientInfo(pClx);

        // if we are reconnecting we don't have UI to set params
        if (g_nMyReconId)
            break;

        // Check if connect dialog is OK
        if (!pClx->hwndDialog)
            goto check_timer;

        if (!strlen(pClx->RClxInfo.szHydraServer))
        {
            TRACE((INFO_MESSAGE, 
                TEXT("Connect info is not received yet\n")));
            goto check_timer;
        }

        // set something in server listbox, to enable connect button
        {
            HWND hwndCombo = GetDlgItem(pClx->hwndDialog, UI_IDC_SERVER);

            SetDlgItemText(pClx->hwndDialog, UI_IDC_SERVER, TEXT("vladimis"));
#ifdef  OS_WIN32
            PostMessage(pClx->hwndDialog,
                        WM_COMMAND,
                        MAKEWPARAM(UI_IDC_SERVER, CBN_EDITCHANGE),
                        (LPARAM)hwndCombo);
#endif
#ifdef  OS_WIN16
            PostMessage(pClx->hwndDialog,
                        WM_COMMAND,
                        UI_IDC_SERVER,
                        MAKELONG(hwndCombo, CBN_EDITCHANGE));
#endif
        }

        // Check the connect button state
        hConBtn = GetDlgItem(pClx->hwndDialog, UI_IDC_CONNECT);

        if (!hConBtn)
        {
            TRACE((WARNING_MESSAGE, 
                TEXT("Can't get Connect button\n")));
            goto check_timer;
        }

        if (!IsWindowEnabled(hConBtn))
        {
            TRACE((INFO_MESSAGE,
                TEXT("Connect button is not enabled yet\n")));
            goto check_timer;
        }

        if (
        // Check for valid controls
           (hServerBox = GetDlgItem(pClx->hwndDialog, UI_IDC_SERVER))
#ifndef OS_WINCE
        // no resolution box in WinCE
            &&
           (hResolutionBox = GetDlgItem(pClx->hwndDialog, UI_IDC_RESOLUTION))
#endif  // !OS_WINCE
          )
        {
            TRACE((INFO_MESSAGE, 
                TEXT("The client is ready to launch.\n")));
        } else
            goto check_timer;

        bRunRdp = TRUE;

check_timer:
        if (!bRunRdp)
        {
            TRACE((INFO_MESSAGE, 
                TEXT("Can't start the client yet. Waiting\n")));
            if (!pClx->uiReconnectTimer)
                pClx->uiReconnectTimer = SetTimer(hwnd, RCLX_RECONNECT_TIMERID, 
                                                  RCLX_RECONNECTELAPSETIME, NULL);

            if (!pClx->uiReconnectTimer)
            {
                TRACE((WARNING_MESSAGE, 
                    TEXT("Can't create timer. Start timer simulation\n")));
                PostMessage(hwnd, WM_TIMER, 0, 0);
            }
            goto exitpt;
        } else {
            if (pClx->uiReconnectTimer)
            {
                KillTimer(g_hWindow, pClx->uiReconnectTimer);
                pClx->uiReconnectTimer = 0;
            }
        }

        // Check that we have clear view for launch
        // no error boxes laying arround
        if (_GarbageCollecting(pClx, TRUE))
            goto exitpt;
        
#ifdef  UNICODE
        TRACE((INFO_MESSAGE, 
               TEXT("Trying to connect to Hydra server: %S\n"),
               pClx->RClxInfo.szHydraServer));
#else
        TRACE((INFO_MESSAGE, 
               TEXT("Trying to connect to Hydra server: %s\n"),
               pClx->RClxInfo.szHydraServer));
#endif  // UNICODE

        // Set server name
#ifdef  UNICODE
        _CLX_SetDlgItemTextA
#else   // !UNICODE
        SetDlgItemText
#endif  // !UNICODE
            (pClx->hwndDialog, UI_IDC_SERVER, pClx->RClxInfo.szHydraServer);
        // Set the resolution
        _snprintf(szResSelect, sizeof(szResSelect), "%dx%d", 
                  pClx->RClxInfo.xResolution, 
                  pClx->RClxInfo.yResolution);

#ifndef  OS_WINCE
        // no resolution box
        SendMessage(hResolutionBox, CB_SELECTSTRING, 0, (LPARAM)szResSelect);
#endif  // !OS_WINCE

        // set the low speed option
        CheckDlgButton(pClx->hwndDialog,
                       UI_IDC_CONNECTION, 
                       (pClx->RClxInfo.bLowSpeed)?BST_CHECKED:BST_UNCHECKED
                      );

        // set the persistent cache option
        CheckDlgButton(pClx->hwndDialog,
                       UI_IDC_BITMAP_PERSISTENCE,
                       (pClx->RClxInfo.bPersistentCache)?BST_CHECKED
                                                        :BST_UNCHECKED
                      );

        // Now connect
        PostMessage(pClx->hwndDialog, WM_COMMAND, UI_IDC_CONNECT, 0);

    }
        break;
    case WM_CLIPBOARD:
    {
        HGLOBAL ghClipboard = NULL;
        HGLOBAL ghNewData   = NULL;
        BOOL    bOpened    = FALSE;
        BOOL    bRetry     = TRUE;
        VOID    HUGEMOD *pClipboard = NULL;
        UINT32  nSize = 0;
        UINT    uiFormat = 0;
        BOOL    bReentered;

#ifndef OS_WIN32
        pClx->bClipboardReenter++;
        bReentered = pClx->bClipboardReenter != 0;
#else
        bReentered = InterlockedIncrement(&pClx->bClipboardReenter) != 0;
#endif  // OS_WIN32

        if (bReentered)
        {
            TRACE((WARNING_MESSAGE, TEXT("WM_CLIPBOARD reentered\n")));
            bRetry = FALSE;
            goto clpcleanup;
        }

        // lParam contains the desired format
        uiFormat = (UINT)lParam;

        // WinCE version doesn't support clipboard
#ifndef OS_WINCE
        if (!OpenClipboard(hwnd))
        {
            TRACE((ERROR_MESSAGE, TEXT("Can't open the clipboard. retrying\n")));
            goto clpcleanup;
        }
        bOpened = TRUE;

        // if uiFormat is zero then return empty clipbrd body 
        // with the first available format
        if (!uiFormat)
        {
            uiFormat = EnumClipboardFormats(uiFormat);

            TRACE((INFO_MESSAGE,
                   TEXT("Responging on format request. FormatID=%d\n"),
                   uiFormat));

            goto send_clipboard;
        }

        ghClipboard = GetClipboardData((UINT)uiFormat);
        if (!ghClipboard)
        {
            TRACE((WARNING_MESSAGE, TEXT("Clipboard is empty.\n")));
        } else {
            Clp_GetClipboardData(uiFormat,
                                 ghClipboard,
                                 &nSize,
                                 &ghNewData);
            if (ghNewData)
                ghClipboard = ghNewData;

            pClipboard = GlobalLock(ghClipboard);
            if (!pClipboard)
            {
                TRACE((ERROR_MESSAGE, 
                    TEXT("Can't lock the clipboard. retrying\n")));
                goto clpcleanup;
            }
        }

send_clipboard:

#else   // !OS_WINCE
        TRACE((WARNING_MESSAGE, TEXT("WinCE: clipboard not supported\n")));
#endif  // !OS_WINCE

        if (!RClx_SendClipboard(pClx, uiFormat, nSize, pClipboard))
        {
            TRACE((ERROR_MESSAGE, TEXT("Can't send the clipboard\n")));
            bRetry = FALSE;
            goto clpcleanup;
        }

        bRetry = FALSE;

clpcleanup:
#ifndef OS_WINCE
        if (pClipboard)
            GlobalUnlock(ghClipboard);

        if (bOpened)
            CloseClipboard();

        if (ghNewData)
            GlobalFree(ghNewData);

#endif  // !OS_WINCE

#ifndef OS_WIN32
        pClx->bClipboardReenter--;
#else
        InterlockedDecrement(&pClx->bClipboardReenter);
#endif  // OS_WIN32

        if (bRetry)
        // Retry to send the clipboard
            PostMessage(hwnd, WM_CLIPBOARD, 0, lParam);
    }
        break;
    case WM_CLOSE:
        if (!DestroyWindow(hwnd))
        {
            TRACE((ERROR_MESSAGE,
                   TEXT("Can't destroy window. GetLastError: %d\n"),
                   _CLXWINDOW_CLASS,
                   GetLastError()));
        }
        break;
    default:
        return DefWindowProc(hwnd, uiMessage, wParam, lParam);
    }

exitpt:
    return 0;
}


/*++
 *  Function:
 *      RClx_CreateWindow
 *  Description:
 *      Creates g_hWindow for dispatching winsocket and timer
 *      messages
 *      Win32/Win16/WinCE
 *  Arguments:
 *      hInstance       - Dll instance handle
 *  Called by:
 *      ClxInitialize
 --*/
VOID RClx_CreateWindow(HINSTANCE hInstance)
{
    WNDCLASS    wc;
#ifdef  OS_WIN32
    DWORD       dwLastErr;
#endif

    memset(&wc, 0, sizeof(wc));

    wc.lpfnWndProc      = _ClxWndProc;
    wc.hInstance        = hInstance;
    wc.lpszClassName    = TEXT(_CLXWINDOW_CLASS);


    if (!RegisterClass (&wc) 
#ifdef  OS_WIN32
            &&
        (dwLastErr = GetLastError()) &&
        dwLastErr != ERROR_CLASS_ALREADY_EXISTS
#endif  // OS_WIN32
        )
    {
        TRACE((WARNING_MESSAGE,
              TEXT("Can't register class. GetLastError=%d\n"),
              GetLastError()));
        goto exitpt;
    }

    g_hWindow = CreateWindow(
                       TEXT(_CLXWINDOW_CLASS),
                       NULL,         // Window name
                       0,            // dwStyle
                       0,            // x
                       0,            // y
                       0,            // nWidth
                       0,            // nHeight
                       NULL,         // hWndParent
                       NULL,         // hMenu
                       hInstance,
                       NULL);        // lpParam

    if (!g_hWindow)
    {
        TRACE((WARNING_MESSAGE, 
            TEXT("Can't create window to handle socket messages\n")));
        goto exitpt;
    }

    g_uiBackgroundTimer = SetTimer(g_hWindow,
                                     RCLX_BACKGNDTIMERID,
                                     RCLX_TIMERELAPSETIME,
                                     NULL);

exitpt:
    ;
}

/*++
 *  Function:
 *      RClx_DestroyWindow
 *  Description:
 *      Destroys g_hWindow created in RClx_CreateWindow
 *      Win32/Win16/WinCE
 *  Called by:
 *      ClxTerminate
 --*/
VOID RClx_DestroyWindow(VOID)
{
    if (g_hWindow)
    {
        if (g_uiBackgroundTimer)
        {
            KillTimer(g_hWindow, g_uiBackgroundTimer);
            g_uiBackgroundTimer = 0;
        }

        PostMessage(g_hWindow, WM_CLOSE, 0, 0);

        if (!UnregisterClass(TEXT(_CLXWINDOW_CLASS), g_hInstance))
        {
            TRACE((WARNING_MESSAGE,
                   TEXT("Can't unregister class: %s. GetLastError: %d\n"),
                   _CLXWINDOW_CLASS,
                   GetLastError()));
        }
        
        g_hWindow = NULL;
    }
}


/*++
 *  Function:
 *      RClx_ReadRequest
 *  Description:
 *      CLXINFO contains a buffer for incoming requests
 *      this function trys to receive it all. If the socket blocks
 *      the function exits with OK and next time FD_READ is received will
 *      be called again. If a whole request is received it calls 
 *      RClx_ProcessRequest
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx    - the context
 *  Return value:
 *      TRUE    if reading doesn't fail
 *  Called by:
 *      _ClxWndProc on FD_READ event
 --*/
BOOL RClx_ReadRequest(PCLXINFO pClx)
{
    INT     recvres;
    INT     nErrorCode = 0;
    BYTE    HUGEMOD *pRecv = NULL;
    UINT32  nRecv = 0;
    BYTE    TempBuff[256];

    ASSERT(pClx);
    ASSERT(pClx->hSocket != INVALID_SOCKET);

    do {
        if (!pClx->bPrologReceived)
        {
            pRecv = (BYTE HUGEMOD *)&(pClx->RClxReqProlog) 
                                    + pClx->nBytesReceived;
            nRecv = sizeof(pClx->RClxReqProlog) - pClx->nBytesReceived;
#ifndef OS_WINCE
            recvres = recv(pClx->hSocket,
                           pRecv,
                           (int)nRecv,
                           0);
            nErrorCode = WSAGetLastError();
#else   // OS_WINCE
            recvres = AsyncRecv(pClx->hSocket,
                            pRecv,
                            nRecv,
                            &nErrorCode);
#endif  // OS_WINCE

            if (recvres != SOCKET_ERROR)
                pClx->nBytesReceived += recvres;
            else
                if (nErrorCode != WSAEWOULDBLOCK)
                  TRACE((ERROR_MESSAGE, TEXT("recv error: %d, request for 0x%lx bytes\n"),
                        nErrorCode,
                        nRecv
                        ));

            if (pClx->nBytesReceived == sizeof(pClx->RClxReqProlog))
            {
                UINT32 nReqSize = pClx->RClxReqProlog.ReqSize;

                pClx->nBytesReceived = 0;
                pClx->bPrologReceived = TRUE;

                if (nReqSize)
                // If request body is empty, don't allocate
                {
                  if (!pClx->pRequest)
retry_alloc:
                  {
                    pClx->pRequest = 
                                    _CLXALLOC(nReqSize);
                    if (pClx->pRequest)
                        pClx->nReqAllocSize = nReqSize;
                    else
                        pClx->nReqAllocSize = 0;
                  }
                  else if (nReqSize > pClx->nReqAllocSize)
                  {
                    pClx->pRequest = 
                                    _CLXREALLOC(pClx->pRequest, 
                                                nReqSize);
                    if (pClx->pRequest)
                        pClx->nReqAllocSize = nReqSize;
                    else
                    {
                        pClx->nReqAllocSize = 0;
                        goto retry_alloc;
                    }
                  }
                  if (!pClx->pRequest)
                  {
                    TRACE((WARNING_MESSAGE,     
                           TEXT("Can't alloc 0x%lx bytes for receiving a request. GetLastError=%d. Skipping\n"), 
                           nReqSize,
                           GetLastError()));
                  }
                }
            }
        } else {
            if (pClx->nBytesReceived == pClx->RClxReqProlog.ReqSize)
                goto process_req;

            if (pClx->pRequest)
            {
                pRecv = (BYTE HUGEMOD *)pClx->pRequest 
                                    + pClx->nBytesReceived;
                nRecv = pClx->RClxReqProlog.ReqSize - pClx->nBytesReceived;
            } else {
                // point to a temp buffer if pReques is not allocated
                pRecv = TempBuff;
                nRecv = sizeof(TempBuff);
            }

#ifdef  OS_WIN16
            // WFW has problems with receiving big buffers
            if (nRecv >= 0x1000)
                nRecv = 0x1000;

#endif  // OS_WIN16

#ifndef  OS_WINCE
            recvres = recv(pClx->hSocket,
                           pRecv,
                           (int)nRecv,
                           0);
            nErrorCode = WSAGetLastError();
#else   // OS_WINCE
            recvres = AsyncRecv(pClx->hSocket,
                           pRecv,
                           nRecv,
                           &nErrorCode);
#endif  // OS_WINCE

            if (recvres != SOCKET_ERROR)
            {
                pClx->nBytesReceived += recvres;
            } else {
              if (nErrorCode != WSAEWOULDBLOCK)
              {
                TRACE((ERROR_MESSAGE, 
                        TEXT("recv error: %d, request for 0x%lx bytes\n"),
                        nErrorCode,
                        nRecv
                        ));
                TRACE((ERROR_MESSAGE, 
                        TEXT("ReqProlog was received. Type=%d, Size=%d\n"),
                        pClx->RClxReqProlog.ReqType,
                        pClx->RClxReqProlog.ReqSize
                        ));
              }
            }
process_req:
            if (pClx->nBytesReceived == pClx->RClxReqProlog.ReqSize)
            {
                pClx->nBytesReceived = 0;
                pClx->bPrologReceived = FALSE;
                RClx_ProcessRequest(pClx);
            }
        }
    } while ((recvres != 0 || nRecv == 0) &&  // recvres will be 0 if nRecv is 0
              recvres != SOCKET_ERROR);

    // return FALSE if error is occured

    if (!recvres)
        return FALSE;       // connection was gracefully closed

    if (recvres == SOCKET_ERROR)
    {
        if (nErrorCode == WSAEWOULDBLOCK)
            return TRUE;    // the call will block, but ok
        else
            return FALSE;   // other SOCKET_ERROR
    }

    return TRUE;            // it is ok
}

/*++
 *  Function:
 *      RClx_DataArrived
 *  Description:
 *      Processes request for data
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx        - context
 *      pRClxData   - the request
 *  Called by:
 *      RClx_ProcessRequest
 --*/
VOID
RClx_DataArrived(PCLXINFO pClx, PRCLXDATA pRClxData)
{
    ASSERT(pRClxData);

    switch(pRClxData->uiType)
    {
        case DATA_BITMAP:
        {
            PREQBITMAP  pReqBitmap = (PREQBITMAP)pRClxData->Data;
            RCLXDATA    Response;
            RCLXFEEDPROLOG RespProlog;
            HANDLE      hDIB = NULL;
            DWORD       dwDIBSize = 0;

            TRACE((INFO_MESSAGE,
                    TEXT("REQDATA_BITMAP arrived\n")));

            if (pRClxData->uiSize != sizeof(*pReqBitmap))
                ASSERT(0);

            // process differently on WINCE (no shadow bitmap)
            //
            if (pClx->hdcShadowBitmap)
                _GetDIBFromBitmap(pClx->hdcShadowBitmap,
                              pClx->hShadowBitmap,
                              &hDIB,
                              (INT)pReqBitmap->left,
                              (INT)pReqBitmap->top,
                              (INT)pReqBitmap->right,
                              (INT)pReqBitmap->bottom);
            else {
                TRACE((WARNING_MESSAGE, TEXT("Shadow bitmap is NULL\n")));
            }

            if (!hDIB)
                dwDIBSize = 0;
            else
                dwDIBSize = (DWORD)GlobalSize(hDIB);

            RespProlog.FeedType = FEED_DATA;
            RespProlog.HeadSize = sizeof(Response) + dwDIBSize;
            RespProlog.TailSize = 0;

            Response.uiType = DATA_BITMAP;
            Response.uiSize = dwDIBSize;

            RClx_SendBuffer(pClx->hSocket, &RespProlog, sizeof(RespProlog));
            RClx_SendBuffer(pClx->hSocket, &Response, sizeof(Response));

            if (hDIB)
            {
                LPVOID      pDIB = GlobalLock(hDIB);
                if (pDIB)
                {
                    RClx_SendBuffer(pClx->hSocket, pDIB, dwDIBSize);
                    GlobalUnlock(hDIB);
                }
                GlobalFree(hDIB);
            }
        }
            break;
        case DATA_VC:
        {
            LPSTR   szChannelName;
            LPVOID  pData;
            DWORD   dwSize;

            szChannelName = (LPSTR)(pRClxData->Data);
            pData         = ((BYTE *)(pRClxData->Data)) + MAX_VCNAME_LEN;
            dwSize        = pRClxData->uiSize - MAX_VCNAME_LEN;

            if (pRClxData->uiSize < MAX_VCNAME_LEN)
            {
                TRACE((ERROR_MESSAGE, TEXT("DATA_VC: uiSize too small\n")));
                goto exitpt;
            }
            
            if (strlen(szChannelName) > MAX_VCNAME_LEN - 1)
            {
                TRACE((ERROR_MESSAGE, TEXT("DATA_VC: channel name too long\n")));
                goto exitpt;
            }
            _CLXSendDataVC(szChannelName, pData, dwSize);
        }
            break;
        default:
            TRACE((WARNING_MESSAGE,
                   TEXT("Unknown data request type. Ignoring\n")));
    }
exitpt:
    ;
}

/*++
 *  Function:
 *      RClx_ProcessRequest
 *  Description:
 *      Dispatches a request received by RClx_ReadRequest
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx    - context
 *  Called by:
 *      RClx_ReadRequest
 --*/
VOID RClx_ProcessRequest(PCLXINFO pClx)
{
    PRCLXMSG pClxMsg;
    DWORD    ReqType;
    HWND     hContainer;
    PRCLXREQPROLOG pReqProlog;
    LPVOID pReq;

    ASSERT(pClx);
    pReqProlog = &(pClx->RClxReqProlog);
    ASSERT(pReqProlog);
    pReq = pClx->pRequest;

    ReqType = pReqProlog->ReqType;
    switch(ReqType)
    {
        case REQ_MESSAGE:
            if (!pReq || pReqProlog->ReqSize != sizeof(*pClxMsg))
            {
                TRACE((WARNING_MESSAGE,
                       TEXT("REQ_MESSAGE with different size. Ignoring\n")));
                goto exitpt;
            }
            pClxMsg = (PRCLXMSG)pReq;

            if(!pClx->hwndInput)
            {

                hContainer = _FindWindow(pClx->hwndMain, TEXT(NAME_CONTAINERCLASS));

                if (hContainer)
                    pClx->hwndInput = _FindWindow(hContainer, TEXT(NAME_INPUT));
                else
                    pClx->hwndInput = NULL;

                if (!pClx->hwndInput)
                {
                    TRACE((WARNING_MESSAGE, 
                           TEXT("Can't find input window.")
                           TEXT(" Discarding any user input\n" )));
                    goto exitpt;
                }
            }

            SendMessage(pClx->hwndInput, 
                        (UINT)pClxMsg->message, 
                        (WPARAM)pClxMsg->wParam,
                        (LPARAM)pClxMsg->lParam);
            break;

        case REQ_CONNECTINFO:

            if (!pReq || pReqProlog->ReqSize != sizeof(RCLXCONNECTINFO))
            {
                TRACE((WARNING_MESSAGE,
                       TEXT("REQ_CONNECTINFO with different size. Ignoring\n")));
                goto exitpt;
            }
            TRACE((INFO_MESSAGE, TEXT("CONNECTINFO received\n")));

            memcpy(&pClx->RClxInfo, pReq, sizeof(pClx->RClxInfo));

            // Kick _ClxWndProc to connect
            PostMessage(g_hWindow, WM_TIMER, 0, 0);
            break;

        case REQ_GETCLIPBOARD:

            if (!pReq || pReqProlog->ReqSize != sizeof(RCLXCLIPBOARD))
            {
                TRACE((WARNING_MESSAGE,
                       TEXT("REQ_GETCLIPBOARD with different size. Ignoring\n")));

                goto exitpt;
            }

            TRACE((INFO_MESSAGE, TEXT("REQ_GETCLIPBOARD received. FormatId=%d\n"),
                ((PRCLXCLIPBOARD)pReq)->uiFormat
                ));

            // Kick _ClxWndProc to send our clipboard
            PostMessage(g_hWindow, WM_CLIPBOARD, 0, 
                (LPARAM)((PRCLXCLIPBOARD)pReq)->uiFormat);
                // lParam contains the required format

            break;

        case REQ_SETCLIPBOARD:
        {
            UINT32 nClipSize;

            if (!pReq || pReqProlog->ReqSize < sizeof(RCLXCLIPBOARD))
            {
                TRACE((WARNING_MESSAGE,
                       TEXT("REQ_SETCLIPBOARD with wrong size. Ignoring\n")));

                goto exitpt;
            }

            TRACE((INFO_MESSAGE, TEXT("REQ_SETCLIPBOARD received. FormatId=%d, Clipboard size = %d\n"), 
                    ((PRCLXCLIPBOARD)pReq)->uiFormat,
                    pReqProlog->ReqSize - sizeof(UINT)
                    ));
            nClipSize = pReqProlog->ReqSize - sizeof(((PRCLXCLIPBOARD)pReq)->uiFormat);
            _SetClipboard(
                (UINT)((PRCLXCLIPBOARD)pReq)->uiFormat,
                ((PRCLXCLIPBOARD)pReq)->pNewClipboard,
                nClipSize);
        }
            break;
        case REQ_DATA:
        {
            PRCLXDATA pRClxData = (PRCLXDATA)pReq;

            ASSERT(pRClxData);
            if (pReqProlog->ReqSize != pRClxData->uiSize + (UINT32)sizeof(*pRClxData))
                ASSERT(0);
            RClx_DataArrived(pClx, pRClxData);
        }
            break;
        default:
            TRACE((WARNING_MESSAGE,
                   TEXT("Unknown request type. Ignoring\n")));
    }

exitpt:
    ;
}


/*++
 *  Function:
 *      _EnumWindowsProc
 *  Description:
 *      Used to find a specific window
 *      Win32/Win16/WinCE
 *  Arguments:
 *      hWnd    - current enumerated window handle
 *      lParam  - pointer to SEARCHWND passed from
 *                _FindTopWindow
 *  Return value:
 *      TRUE on success but window is not found
 *      FALSE if the window is found
 *  Called by:
 *      _FindTopWindow thru EnumWindows
 --*/
BOOL CALLBACK LOADDS _EnumWindowsProc( HWND hWnd, LPARAM lParam )
{
    TCHAR    classname[128];
    TCHAR    caption[128];
    BOOL    rv = TRUE;
    _CLXWINDOWOWNER   hInst;
    PSEARCHWND pSearch = (PSEARCHWND)lParam;

    if (pSearch->szClassName && 
        !GetClassName(hWnd, classname, sizeof(classname)/sizeof(TCHAR)))
    {
        goto exitpt;
    }

    if (pSearch->szCaption && !GetWindowText(hWnd, caption, sizeof(caption)/sizeof(TCHAR)))
    {
        goto exitpt;
    }

#ifdef  OS_WINCE
    {
        DWORD procId = 0;
        GetWindowThreadProcessId(hWnd, &procId);
        hInst = procId;
    }
#else   // !OS_WINCE
#ifdef  _WIN64
    hInst = (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE);
#else   // !_WIN64
#ifdef  OS_WIN32
    hInst = (HINSTANCE)GetWindowLong(hWnd, GWL_HINSTANCE);
#endif  // OS_WIN32
#endif  // !OS_WINCE
#ifdef  OS_WIN16
    hInst = (HINSTANCE)GetWindowWord(hWnd, GWW_HINSTANCE);
#endif
#endif  // _WIN64
    if (
        (!pSearch->szClassName || !         // Check for classname
          _CLX_strcmp(classname, pSearch->szClassName)) 
    &&
        (!pSearch->szCaption || !
          _CLX_strcmp(caption, pSearch->szCaption))
    &&
        hInst == pSearch->hInstance)
    {
        ((PSEARCHWND)lParam)->hWnd = hWnd;
        rv = FALSE;
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _FindTopWindow
 *  Description:
 *      Find specific window by classname and/or caption and/or process Id
 *      Win32/Win16/WinCE
 *  Arguments:
 *      classname   - class name to search for, NULL ignore
 *      caption     - caption to search for, NULL ignore
 *      hInst       - instance handle, NULL ignore
 *  Return value:
 *      window handle found, NULL otherwise
 *  Called by:
 *      SCConnect, SCDisconnect, GetDisconnectResult
 --*/
HWND _FindTopWindow(LPCTSTR classname, LPCTSTR caption, _CLXWINDOWOWNER hInst)
{
    SEARCHWND search;

    search.szClassName = classname;
    search.szCaption = caption;
    search.hWnd = NULL;
    search.hInstance = hInst;

    EnumWindows(_EnumWindowsProc, (LPARAM)&search);

    return search.hWnd;
}

/*++
 *  Function:
 *      _FindWindow
 *  Description:
 *      Find child window by classname
 *      Win32/Win16/WinCE
 *  Arguments:
 *      hwndParent      - the parent window handle
 *      srchclass       - class name to search for, NULL - ignore
 *  Return value:
 *      window handle found, NULL otherwise
 *  Called by:
 *      
 --*/
HWND _FindWindow(HWND hwndParent, LPCTSTR srchclass)
{
    HWND hWnd, hwndTop, hwndNext;
    BOOL bFound;
    TCHAR classname[128];

    hWnd = NULL;

    hwndTop = GetWindow(hwndParent, GW_CHILD);
    if (!hwndTop) 
    {
        TRACE((INFO_MESSAGE, TEXT("GetWindow failed. hwnd=0x%x\n"), hwndParent));
        goto exiterr;
    }

    bFound = FALSE;
    hwndNext = hwndTop;
    do {
        hWnd = hwndNext;
        if (srchclass && !GetClassName(hWnd, classname, sizeof(classname)/sizeof(TCHAR)))
        {
            TRACE((INFO_MESSAGE, TEXT("GetClassName failed. hwnd=0x%x\n")));
            goto nextwindow;
        }

        if (!srchclass || !_CLX_strcmp(classname, srchclass))
            bFound = TRUE;
nextwindow:
#ifndef OS_WINCE
        hwndNext = GetNextWindow(hWnd, GW_HWNDNEXT);
#else   // OS_WINCE
        hwndNext = GetWindow(hWnd, GW_HWNDNEXT);
#endif  // OS_WINCE
    } while (hWnd && hwndNext != hwndTop && !bFound);

    if (!bFound) goto exiterr;

    return hWnd;
exiterr:
    return NULL;
}


/*++
 *  Function:
 *      _OnBackground
 *  Description:
 *      Simulates a background thread. Called when a message from the
 *      background timer is received
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx        - the context
 *  Called by:
 *      _ClxWndProc on WM_TIMER message from g_uiBackgroundTimer is received
 --*/
VOID _OnBackground(PCLXINFO pClx)
{
    // Try to limit this call, eats lot of the CPU
    _GarbageCollecting(pClx, TRUE);
}

/*
 * GarbageCollecting - closes all message boxes asking this and that
 * like "shall i close the connection" or "there's some error"
 * This function is forced by g_uiBackgroundTimer message
 */

/*++
 *  Function:
 *      _GarbageCollecting
 *  Description:
 *      Closes all message boxes asking this and that
 *      like "shall i close the connection" or "there's some error"
 *      This function is forced by g_uiBackgroundTimer message
 *      Win32/Win16/WinCE
 *  Arguments:
 *      pClx                - the context
 *      bNotifyForErrorBox  - if TRUE calls ClxEvent with 
 *                            "disconnected" event
 *  Return value:
 *      TRUE if error boxes are found
 *  Called by:
 *
 --*/
BOOL _GarbageCollecting(PCLXINFO pClx, BOOL bNotifyForErrorBox)
{
    HWND hBox;
    BOOL rv = FALSE;

    // Clean all extra message boxes, like saying that
    // we cannot connect because of this and that

    if (!g_hRDPInst)
        goto exitpt;

    hBox = _FindTopWindow(NULL,
                          g_strDisconnectDialogBox,
                          g_hRDPInst);
    if (hBox)
    {
        rv = TRUE;
        PostMessage(hBox, WM_CLOSE, 0, 0);

        if (bNotifyForErrorBox)
        // Notifiy that we are disconnected
            ClxEvent(pClx, CLX_EVENT_DISCONNECT, 0);
    }

    hBox = _FindTopWindow(NULL,
                          TEXT(FATAL_ERROR_5),
                          g_hRDPInst);

    if (hBox)
    {
        rv = TRUE;
        PostMessage(hBox, WM_CLOSE, 0, 0);

        if (bNotifyForErrorBox)
        // Notifiy that we are disconnected
            ClxEvent(pClx, CLX_EVENT_DISCONNECT, 0);
    }

    if (pClx->bCloseTrys)
    {
        _AttemptToCloseTheClient();
    }

exitpt:
    if (rv)
        TRACE((INFO_MESSAGE, "Error boxes found\n"));

    return rv;
}

/*++
 *  Function:
 *      _SetClipboard
 *  Description:
 *      Sets the clipboard content in RCLX mode
 *      Win32/Win16/WinCE
 *  Arguments:
 *      uiFormat    - clipboard format
 *      pClipboard  - new clipboard content
 *      nSize       - the clipboard size
 *  Called by:
 *      RClx_ProcessRequest on REQ_SETCLIPBOARD
 --*/
VOID
_SetClipboard(UINT uiFormat, PVOID pClipboard, UINT32 nSize)
{
    HGLOBAL ghNewClipboard = NULL;
    BOOL    bOpened = FALSE;
    BOOL    bFreeClipHandle = TRUE;
    LPVOID  pNewClipboard = NULL;

    // WinCE - no clipboard
#ifndef OS_WINCE
    if (!nSize)
    {
        // Just empty the clipboard
        if (OpenClipboard(NULL))
        {
            bOpened = TRUE;
            EmptyClipboard();
        } else {
            TRACE((ERROR_MESSAGE, TEXT("Can't lock the clipbord. GetLastError=%d\n"),
                  GetLastError()));
        }
        goto exitpt;
    }

    if (!pClipboard)
    {
        TRACE((ERROR_MESSAGE, TEXT("_SetClipboard: pClipboard is NULL\n")));
        goto exitpt;
    }

    ghNewClipboard = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, nSize);

    if (!ghNewClipboard)
    {
        TRACE((ERROR_MESSAGE, TEXT("Can't alloc(GlobalAlloc) %d bytes\n"),
                nSize));
        goto exitpt;
    }

    pNewClipboard = GlobalLock(ghNewClipboard);
    if (!pNewClipboard)
    {
        TRACE((ERROR_MESSAGE, TEXT("Can't lock the clipbord. GetLastError=%d\n"),
            GetLastError()));
        goto exitpt;
    }

    // Copy the data
    HUGEMEMCPY(pNewClipboard, pClipboard, nSize);

    if (!OpenClipboard(NULL))
    {
        TRACE((ERROR_MESSAGE, TEXT("Can't open the clipboard. GetLastError=%d\n"),
                GetLastError()));
        goto exitpt;
    }

    bOpened = TRUE;

    // Empty the clipboard, so we'll have only one entry
    EmptyClipboard();

    GlobalUnlock(ghNewClipboard);
    pNewClipboard = NULL;
    if (!Clp_SetClipboardData(uiFormat, 
                              ghNewClipboard, 
                              nSize, 
                              &bFreeClipHandle))
        TRACE((ERROR_MESSAGE, TEXT("SetClipboardData failed. GetLastError=%d\n"), GetLastError()));
    else
        TRACE((INFO_MESSAGE, TEXT("Clipboard is loaded successfuly. %ld bytes\n"),
                nSize));

exitpt:
    if (pNewClipboard)
        GlobalUnlock(ghNewClipboard);

    if (bOpened)
        CloseClipboard();

    // Do not free already set clipboard
    if (ghNewClipboard && bFreeClipHandle)
        GlobalFree(ghNewClipboard);

#else   // !OS_WINCE
        TRACE((WARNING_MESSAGE, TEXT("WinCE: clipboard not supported\n")));
#endif  // !OS_WINCE
}

#ifdef  OS_WINCE

SOCKET  g_hSocket = 0;
LONG    g_lEvent  = 0;
HWND    g_hNotifyWindow = NULL;
UINT    g_uiMessage = 0;
HANDLE  g_hAsyncThread = NULL;
BYTE    g_pRecvBuffer[1024];
INT     g_nRecvStart, g_nRecvLength;
BOOL    g_bGoAsync = FALSE;
CRITICAL_SECTION g_AsyncCS;
/*++
 *  Function:
 *      WSAAsyncSelect
 *  Description:
 *      Windows CE doesn't have this function. Here we are using extra thread
 *      for implementation of this mechanism
 *      WinCE only
 *  Arguments:
 *      s       - socket handle
 *      hWnd    - notification window
 *      wMsg    - message to send when event occured
 *      lEvent  - event mask, on what event this will work
 *  Return value:
 *      On error returns SOCKET_ERROR
 *  Called by:
 *      RClx_Connect, RClx_Disconnect
 --*/
INT WSAAsyncSelect (SOCKET s, HWND hWnd, UINT uiMsg, LONG lEvent)
{
    INT rv = SOCKET_ERROR;

    if (!g_hAsyncThread)
    {
        TRACE((ERROR_MESSAGE,
               TEXT("WSAAsyncSelect: no AsyncThread\n")));
        goto exitpt;
    }

    if (s == INVALID_SOCKET)
    {
        TRACE((ERROR_MESSAGE,
               TEXT("WSAAsyncSelect: INVALID_SOCKET passed\n")));
        goto exitpt;
    }

    if ((lEvent & FD_WRITE) || (lEvent & FD_CONNECT))
    {
        TRACE((ERROR_MESSAGE,
               TEXT("WSAAsyncSelec: FD_WRITE & FD_CONNECT not supported\n")));
        goto exitpt;
    }

    EnterCriticalSection(&g_AsyncCS);
    g_hSocket       = s;
    g_lEvent        = lEvent;
    g_hNotifyWindow = hWnd;
    g_uiMessage     = uiMsg;
    LeaveCriticalSection(&g_AsyncCS);

    ResumeThread(g_hAsyncThread);
    rv = 0;

exitpt:
    return rv;
}

/*++
 *  Function:
 *      AsyncRecv
 *  Description:
 *      Used to receive w/o blocking. WSAAsync Select must be called
 *      with FD_READ flag
 *      WinCE only
 *  Arguments:
 *      s               - socket handle
 *      pBuffer         - buffer for received bytes
 *      nBytesToRead    - how many bytes to receive
 *      pnErrorCode     - pointer to error code
 *  Return value:
 *      On error returns SOCKET_ERROR
 *  Called by:
 *      RClx_ReadRequest
 --*/
INT AsyncRecv(SOCKET s, PVOID pBuffer, INT nBytesToRead, INT *pnErrorCode)
{
    INT rv = SOCKET_ERROR;

    if (!g_hAsyncThread)
    {
        TRACE((ERROR_MESSAGE,
               TEXT("WSAAsyncSelect: no AsyncThread\n")));
        goto exitpt;
    }

    ASSERT(s == g_hSocket);

    (*pnErrorCode) = 0;

    EnterCriticalSection(&g_AsyncCS);
    if (!g_nRecvLength)
    {
        (*pnErrorCode) = WSAEWOULDBLOCK;
    }
    else
    {
        INT nToCopy;

        nToCopy = (nBytesToRead < g_nRecvLength)?nBytesToRead:g_nRecvLength;
        memcpy(pBuffer, g_pRecvBuffer + g_nRecvStart, nToCopy);
        rv = nToCopy;
        g_nRecvLength -= nToCopy;
        g_nRecvStart  += nToCopy;
    }
    // Resume the thread
    if (!g_nRecvLength)
        ResumeThread(g_hAsyncThread);

    LeaveCriticalSection(&g_AsyncCS);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _SelectWorker
 *  Description:
 *      Simulates WSAAsyncSelect message notification
 *      Lifetime: between ClxInitialize and ClxTerminate
 *      WinCE only
 *  Arguments:
 *      lParam  - unused parameter
 *  Return value:
 *      allways 0
 *  Called by:
 *      _StartAsyncThread as a thread function
 --*/
UINT _SelectWorker(LPVOID lpParam)
{
    SOCKET  hSocket;
    LONG    lEvent;
    FD_SET  fdRead;
    HWND    hwndNotify;
    UINT    uiMsg;
    INT     Status;

    while(g_bGoAsync)
    {
        FD_ZERO(&fdRead);

        EnterCriticalSection(&g_AsyncCS);
        hSocket = g_hSocket;
        lEvent  = g_lEvent;
        hwndNotify = g_hNotifyWindow;
        uiMsg   = g_uiMessage;
        LeaveCriticalSection(&g_AsyncCS);

        if (hSocket == INVALID_SOCKET || !lEvent || !hwndNotify || !uiMsg)
            goto wait;

        if (lEvent & FD_READ)
            FD_SET(hSocket, &fdRead);

        Status = select(-1, &fdRead, NULL, NULL, NULL);

        if (Status == SOCKET_ERROR && (lEvent & FD_CLOSE))
            PostMessage(hwndNotify, uiMsg, hSocket, FD_CLOSE);

        if (FD_ISSET(hSocket, &fdRead) && (lEvent & FD_READ))
        {
            EnterCriticalSection(&g_AsyncCS);
            if (!g_nRecvLength)
            // Read into the buffer
            {
                g_nRecvStart = 0;
                g_nRecvLength = recv(hSocket, g_pRecvBuffer, sizeof(g_pRecvBuffer), 0);
                if (g_nRecvLength == SOCKET_ERROR)
                    g_nRecvLength = 0;
            }
            LeaveCriticalSection(&g_AsyncCS);
            if (g_nRecvLength)
                PostMessage(hwndNotify, uiMsg, hSocket, FD_READ);
            else if (lEvent & FD_CLOSE)
                PostMessage(hwndNotify, uiMsg, hSocket, FD_CLOSE);
        }

wait:
        ASSERT(g_hAsyncThread);
        SuspendThread(g_hAsyncThread);
    }

    return 0;
}

/*++
 *  Function:
 *      _StartAsyncThread
 *  Description:
 *      Starts thread for simulating WSAAsyncSelect
 *      WinCE only
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      dllentry on DLL_ATTACH_PROCESS
 --*/
BOOL _StartAsyncThread(VOID)
{
    DWORD   dwThreadId;
    
    InitializeCriticalSection(&g_AsyncCS);

    g_bGoAsync = TRUE;
    g_hAsyncThread =
        CreateThread(
                NULL,      // security
                 0,         // stack size (default)
                 _SelectWorker,
                 NULL,      // parameter
                 0,         // flags
                 &dwThreadId);

    return (g_hAsyncThread != NULL);
}

/*++
 *  Function:
 *      _CloseAsyncThread
 *  Description:
 *      Destroys the thread created in _StartAsyncThread
 *      WinCE only
 *  Called by:
 *      dllentry on DLL_DETTACH_PROCESS
 --*/
VOID _CloseAsyncThread(VOID)
{
    if (g_hAsyncThread)
    {
        g_bGoAsync = FALSE;        
        ResumeThread(g_hAsyncThread);
        TRACE((INFO_MESSAGE, TEXT("Closing Async Thread\n")));
        if (WaitForSingleObject(g_hAsyncThread, 15000) == WAIT_TIMEOUT)
        {
            TRACE((WARNING_MESSAGE, 
                   TEXT("Async Thread is still alive. Retrying once more time\n")));
            ResumeThread(g_hAsyncThread);
            if (WaitForSingleObject(g_hAsyncThread, 30000) == WAIT_TIMEOUT)
            {
                TRACE((ERROR_MESSAGE,
                       TEXT("Async thread is again alive. KILL THE THREAD !!!\n")));
                TerminateThread(g_hAsyncThread, 1);
            }
        }
        g_hAsyncThread = NULL;
    }

    DeleteCriticalSection(&g_AsyncCS);
}

BOOL
CheckDlgButton(
    HWND hDlg,
    INT  nIDButton,
    UINT uCheck)
{
    LONG lres = SendDlgItemMessage(hDlg, nIDButton, BM_SETCHECK, uCheck, 0);

    return (lres == 0);
}
#endif  // OS_WINCE

#ifdef UNICODE
/*++
 *  Function:
 *      _CLX_SetDlgItemTextA
 *  Description:
 *      Ascii version for SetDlgItemText
 *      WinCE only, UNICODE only
 *  Arguments:
 *      hDlg        - dialog handle
 *      nDlgItem    - dialog item
 *      lpString    - item text
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      _ClxWndProc on WM_TIMER message
 --*/
BOOL _CLX_SetDlgItemTextA(HWND hDlg, INT nDlgItem, LPCSTR lpString)
{
    WCHAR lpStringW[128];
    INT ccLen = strlen(lpString);

    lpStringW[0] = 0;

    MultiByteToWideChar(
            CP_ACP,
            MB_ERR_INVALID_CHARS,
            lpString,
            -1,
            lpStringW,
            ccLen + 1);

    return SetDlgItemText(hDlg, nDlgItem, lpStringW);
}
#endif  // UNICODE

#ifndef OS_WINCE

/*
 *
 *  Clipboard functions
 *
 */
HGLOBAL Clp_GetMFData(HANDLE    hData,
                      UINT32    *pDataLen);
HGLOBAL Clp_SetMFData(UINT32    dataLen,
                      PVOID     pData);

// next is directly cut & paste from clputil.c
typedef struct {
    UINT32  mm;
    UINT32  xExt;
    UINT32  yExt;
} CLIPBOARD_MFPICT, *PCLIPBOARD_MFPICT;

VOID
Clp_GetClipboardData(
    UINT    format, 
    HGLOBAL hClipData, 
    UINT32  *pnClipDataSize, 
    HGLOBAL *phNewData)
{
    HGLOBAL hData   = hClipData;
    UINT32  dataLen = 0;
    WORD    numEntries;
    DWORD   dwEntries;
    PVOID   pData;

    *phNewData = NULL;
    *pnClipDataSize = 0;
    if (format == CF_PALETTE)
    {
        /****************************************************************/
        /* Find out how many entries there are in the palette and       */
        /* allocate enough memory to hold them all.                     */
        /****************************************************************/
        if (GetObject(hData, sizeof(numEntries), (LPSTR)&numEntries) == 0)
        {
            numEntries = 256;
        }

        dataLen = sizeof(LOGPALETTE) +
                               (((UINT32)numEntries - 1) * sizeof(PALETTEENTRY));

        *phNewData = GlobalAlloc(GHND, dataLen);
        if (*phNewData == 0)
        {
            TRACE((ERROR_MESSAGE, "Failed to get %d bytes for palette", dataLen));
            goto exitpt;
        }
        else
        {
            /************************************************************/
            /* now get the palette entries into the new buffer          */
            /************************************************************/
            pData = GlobalLock(*phNewData);
            dwEntries = GetPaletteEntries((HPALETTE)hData,
                                           0,
                                           numEntries,
                                           (PALETTEENTRY*)pData);
            GlobalUnlock(*phNewData);
            if (dwEntries == 0)
            {
                TRACE((ERROR_MESSAGE, "Failed to get any palette entries"));
                goto exitpt;
            }
            dataLen = (UINT32)dwEntries * sizeof(PALETTEENTRY);

        }
    } else if (format == CF_METAFILEPICT)
    {
        *phNewData = Clp_GetMFData(hData, &dataLen);
        if (!*phNewData)
        {
            TRACE((ERROR_MESSAGE, "Failed to set MF data"));
            goto exitpt;
        }
    } else {
        if (format == CF_DIB)
        {
            // Get the exact DIB size
            BITMAPINFOHEADER *pBMI = (BITMAPINFOHEADER *)GlobalLock(hData);

            if (pBMI)
            {
                if (pBMI->biSizeImage)
                    dataLen = pBMI->biSize + pBMI->biSizeImage;
                GlobalUnlock(hData);
            }
        }

        /****************************************************************/
        /* just get the length of the block                             */
        /****************************************************************/
        if (!dataLen)
            dataLen = (DWORD)GlobalSize(hData);
    }

    *pnClipDataSize = dataLen;

exitpt:
    ;
}

BOOL
Clp_SetClipboardData(
    UINT formatID, 
    HGLOBAL hClipData, 
    UINT32 nClipDataSize,
    BOOL *pbFreeHandle)
{
    BOOL            rv = FALSE;
    PVOID           pData = NULL;
    HGLOBAL         hData = NULL;
    LOGPALETTE      *pLogPalette = NULL;
    UINT            numEntries;
    UINT            memLen;

    ASSERT(pbFreeHandle);
    *pbFreeHandle = TRUE;

    if (formatID == CF_METAFILEPICT)
    {
        /********************************************************************/
        /* We have to put a handle to the metafile on the clipboard - which */
        /* means creating a metafile from the received data first           */
        /********************************************************************/
        pData = GlobalLock(hClipData);
        if (!pData)
        {
            TRACE((ERROR_MESSAGE, "Failed to lock buffer\n"));
            goto exitpt;
        }

        hData = Clp_SetMFData(nClipDataSize, pData);
        if (!hData)
        {
            TRACE((ERROR_MESSAGE, "Failed to set MF data\n"));
        }
        else if (SetClipboardData(formatID, hData) != hData)
        {
            TRACE((ERROR_MESSAGE, "SetClipboardData. GetLastError=%d\n", GetLastError()));
        }

        GlobalUnlock(hClipData);

    } else if (formatID == CF_PALETTE)
    {
        /********************************************************************/
        /* We have to put a handle to the palette on the clipboard - again  */
        /* this means creating one from the received data first             */
        /*                                                                  */
        /* Allocate memory for a LOGPALETTE structure large enough to hold  */
        /* all the PALETTE ENTRY structures, and fill it in.                */
        /********************************************************************/
        numEntries = (UINT)(nClipDataSize / sizeof(PALETTEENTRY));
        memLen     = (sizeof(LOGPALETTE) +
                                   ((numEntries - 1) * sizeof(PALETTEENTRY)));
        pLogPalette = malloc(memLen);
        if (!pLogPalette)
        {
            TRACE((ERROR_MESSAGE, "Failed to get %d bytes", memLen));
            goto exitpt;
        }

        pLogPalette->palVersion    = 0x300;
        pLogPalette->palNumEntries = (WORD)numEntries;

        /********************************************************************/
        /* get a pointer to the data and copy it to the palette             */
        /********************************************************************/
        pData = GlobalLock(hClipData);
        if (pData == NULL)
        {
            TRACE((ERROR_MESSAGE, "Failed to lock buffer"));
            goto exitpt;
        }
        HUGEMEMCPY(pLogPalette->palPalEntry, pData, nClipDataSize);

        /********************************************************************/
        /* unlock the buffer                                                */
        /********************************************************************/
        GlobalUnlock(hClipData);

        /********************************************************************/
        /* now create a palette                                             */
        /********************************************************************/
        hData = CreatePalette(pLogPalette);
        if (!hData)
        {
            TRACE((ERROR_MESSAGE, "CreatePalette failed\n"));
            goto exitpt;
        }

        /********************************************************************/
        /* and set the palette handle to the Clipboard                      */
        /********************************************************************/
        if (SetClipboardData(formatID, hData) != hData)
        {
            TRACE((ERROR_MESSAGE, "SetClipboardData. GetLastError=%d\n", GetLastError()));
        }
    } else {
        /****************************************************************/
        /* Just set it onto the clipboard                               */
        /****************************************************************/
        if (SetClipboardData(formatID, hClipData) != hClipData)
        {
            TRACE((ERROR_MESSAGE, "SetClipboardData. GetLastError=%d, hClipData=0x%x\n", GetLastError(), hClipData));
            goto exitpt;
        }

        // Only in this case we don't need to free the handle
        *pbFreeHandle = FALSE;
    }

    rv = TRUE;

exitpt:
    if (!pLogPalette)
    {
        free(pLogPalette);
    }

    return rv;
}

HGLOBAL Clp_GetMFData(HANDLE   hData,
                      UINT32   *pDataLen)
{
    UINT32          lenMFBits = 0;
    BOOL            rc        = FALSE;
    LPMETAFILEPICT  pMFP      = NULL;
    HDC             hMFDC     = NULL;
    HMETAFILE       hMF       = NULL;
    HGLOBAL         hMFBits   = NULL;
    HANDLE          hNewData  = NULL;
    CHAR            *pNewData  = NULL;
    PVOID           pBits     = NULL;

    /************************************************************************/
    /* Lock the memory to get a pointer to a METAFILEPICT header structure  */
    /* and create a METAFILEPICT DC.                                        */
    /************************************************************************/
    pMFP = (LPMETAFILEPICT)GlobalLock(hData);
    if (pMFP == NULL)
        goto exitpt;

    hMFDC = CreateMetaFile(NULL);
    if (hMFDC == NULL)
        goto exitpt;

    /************************************************************************/
    /* Copy the MFP by playing it into the DC and closing it.               */
    /************************************************************************/
    if (!PlayMetaFile(hMFDC, pMFP->hMF))
    {
        CloseMetaFile(hMFDC);
        goto exitpt;
    }
    hMF = CloseMetaFile(hMFDC);
    if (hMF == NULL)
        goto exitpt;

    /************************************************************************/
    /* Get the MF bits and determine how long they are.                     */
    /************************************************************************/
#ifdef OS_WIN16
    hMFBits   = GetMetaFileBits(hMF);
    lenMFBits = GlobalSize(hMFBits);
#else
    lenMFBits = GetMetaFileBitsEx(hMF, 0, NULL);
#endif
    if (lenMFBits == 0)
        goto exitpt;

    /************************************************************************/
    /* Work out how much memory we need and get a buffer                    */
    /************************************************************************/
    *pDataLen = sizeof(CLIPBOARD_MFPICT) + lenMFBits;
    hNewData = GlobalAlloc(GHND, *pDataLen);
    if (hNewData == NULL)
        goto exitpt;

    pNewData = GlobalLock(hNewData);

    /************************************************************************/
    /* Copy the MF header and bits into the buffer.                         */
    /************************************************************************/
    ((PCLIPBOARD_MFPICT)pNewData)->mm   = pMFP->mm;
    ((PCLIPBOARD_MFPICT)pNewData)->xExt = pMFP->xExt;
    ((PCLIPBOARD_MFPICT)pNewData)->yExt = pMFP->yExt;

#ifdef OS_WIN16
    pBits = GlobalLock(hMFBits);
    HUGEMEMCPY((pNewData + sizeof(CLIPBOARD_MFPICT)),
              pBits,
              lenMFBits);
    GlobalUnlock(hMFBits);
#else
    lenMFBits = GetMetaFileBitsEx(hMF, lenMFBits,
                                  (pNewData + sizeof(CLIPBOARD_MFPICT)));
    if (lenMFBits == 0)
        goto exitpt;
#endif

    /************************************************************************/
    /* all OK                                                               */
    /************************************************************************/
    rc = TRUE;

exitpt:
    /************************************************************************/
    /* Unlock any global mem.                                               */
    /************************************************************************/
    if (pMFP)
    {
        GlobalUnlock(hData);
    }
    if (pNewData)
    {
        GlobalUnlock(hNewData);
    }

    /************************************************************************/
    /* if things went wrong, then free the new data                         */
    /************************************************************************/
    if ((rc == FALSE) && (hNewData != NULL))
    {
        GlobalFree(hNewData);
        hNewData = NULL;
    }

    return(hNewData);

}


HGLOBAL Clp_SetMFData(UINT32 dataLen,
                      PVOID  pData)
{
    BOOL           rc           = FALSE;
    HGLOBAL        hMFBits      = NULL;
    PVOID          pMFMem       = NULL;
    HMETAFILE      hMF          = NULL;
    HGLOBAL        hMFPict      = NULL;
    LPMETAFILEPICT pMFPict      = NULL;

    /************************************************************************/
    /* Allocate memory to hold the MF bits (we need the handle to pass to   */
    /* SetMetaFileBits).                                                    */
    /************************************************************************/
    hMFBits = GlobalAlloc(GHND, dataLen - sizeof(CLIPBOARD_MFPICT));
    if (hMFBits == NULL)
        goto exitpt;

    /************************************************************************/
    /* Lock the handle and copy in the MF header.                           */
    /************************************************************************/
    pMFMem = GlobalLock(hMFBits);
    if (pMFMem == NULL)
        goto exitpt;

    HUGEMEMCPY(pMFMem,
           (PVOID)((CHAR *)pData + sizeof(CLIPBOARD_MFPICT)),
               dataLen - sizeof(CLIPBOARD_MFPICT) );

    GlobalUnlock(hMFBits);

    /************************************************************************/
    /* Now use the copied MF bits to create the actual MF bits and get a    */
    /* handle to the MF.                                                    */
    /************************************************************************/
#ifdef OS_WIN16
    hMF = SetMetaFileBits(hMFBits);
#else
    hMF = SetMetaFileBitsEx(dataLen - sizeof(CLIPBOARD_MFPICT), pMFMem);
#endif
    if (hMF == NULL)
        goto exitpt;

    /************************************************************************/
    /* Allocate a new METAFILEPICT structure, and use the data from the     */
    /* header.                                                              */
    /************************************************************************/
    hMFPict = GlobalAlloc(GHND, sizeof(METAFILEPICT));
    pMFPict = (LPMETAFILEPICT)GlobalLock(hMFPict);
    if (!pMFPict)
        goto exitpt;

    pMFPict->mm   = (int)((PCLIPBOARD_MFPICT)pData)->mm;
    pMFPict->xExt = (int)((PCLIPBOARD_MFPICT)pData)->xExt;
    pMFPict->yExt = (int)((PCLIPBOARD_MFPICT)pData)->yExt;
    pMFPict->hMF  = hMF;

    GlobalUnlock(hMFPict);

    rc = TRUE;

exitpt:
    /************************************************************************/
    /* tidy up                                                              */
    /************************************************************************/
    if (!rc)
    {
        if (hMFPict)
        {
            GlobalFree(hMFPict);
        }
        if (hMFBits)
        {
            GlobalFree(hMFBits);
        }
    }

    return(hMFPict);

}
#endif  // !OS_WINCE

BOOL
WS_Init(VOID)
{
    WORD    versionRequested;
    WSADATA wsaData;
    INT     intRC;
    BOOL    rv = FALSE;

    versionRequested = MAKEWORD(1, 1);

    intRC = WSAStartup(versionRequested, &wsaData);

    if (intRC != 0)
        goto exitpt;

    rv = TRUE;

exitpt:
    return rv;
}

VOID
_AttemptToCloseTheClient(VOID)
{
    HWND hYesNo = NULL;
    static BOOL bSpeedupTimer = FALSE;

    if (!bSpeedupTimer)
    {
        KillTimer(g_hWindow, g_uiBackgroundTimer);
        g_uiBackgroundTimer = SetTimer(g_hWindow,
                                     RCLX_BACKGNDTIMERID,
                                     RCLX_TIMERELAPSETIME/15+1000,
                                     NULL);

        bSpeedupTimer = TRUE;
    }



    hYesNo = _FindTopWindow(NULL,
                            g_strYesNoShutdown,
                            g_hRDPInst);

    if (hYesNo)
    {
        PostMessage(hYesNo, WM_KEYDOWN, VK_RETURN, 0);
    } else {
        PostMessage(g_pClx->hwndMain, WM_CLOSE, 0, 0);
        // Don't know how, but this helps for NT4 client
        PostMessage(g_pClx->hwndMain, WM_LBUTTONDOWN, 0, 0);
    }

}

/*
 *  This came from: \\index1\src\nt\private\samples\wincap32\dibutil.c
 */

#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)
#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD)(lpbi)) == sizeof(BITMAPINFOHEADER))

WORD DIBNumColors(LPSTR lpDIB)
{
    WORD wBitCount;  // DIB bit count

    // If this is a Windows-style DIB, the number of colors in the
    // color table can be less than the number of bits per pixel
    // allows for (i.e. lpbi->biClrUsed can be set to some value).
    // If this is the case, return the appropriate value.


    if (IS_WIN30_DIB(lpDIB))
    {
        DWORD dwClrUsed;

        dwClrUsed = ((LPBITMAPINFOHEADER)lpDIB)->biClrUsed;
        if (dwClrUsed)

        return (WORD)dwClrUsed;
    }

    // Calculate the number of colors in the color table based on
    // the number of bits per pixel for the DIB.

    if (IS_WIN30_DIB(lpDIB))
        wBitCount = ((LPBITMAPINFOHEADER)lpDIB)->biBitCount;
    else
        wBitCount = ((LPBITMAPCOREHEADER)lpDIB)->bcBitCount;

    // return number of colors based on bits per pixel

    switch (wBitCount)
    {
        case 1:
            return 2;

        case 4:
            return 16;

        case 8:
            return 256;

        default:
            return 0;
    }
}

WORD PaletteSize(LPSTR lpDIB)
{
    // calculate the size required by the palette
    if (IS_WIN30_DIB (lpDIB))
        return (DIBNumColors(lpDIB) * sizeof(RGBQUAD));
    else
        return (DIBNumColors(lpDIB) * sizeof(RGBTRIPLE));
}

/*************************************************************************
 *
 * BitmapToDIB()
 *
 * Parameters:
 *
 * HBITMAP hBitmap  - specifies the bitmap to convert
 *
 * HPALETTE hPal    - specifies the palette to use with the bitmap
 *
 * Return Value:
 *
 * HANDLE           - identifies the device-dependent bitmap
 *
 * Description:
 *
 * This function creates a DIB from a bitmap using the specified palette.
 *
 ************************************************************************/

HANDLE BitmapToDIB(HBITMAP hBitmap, HPALETTE hPal)
{
    BITMAP              bm;         // bitmap structure
    BITMAPINFOHEADER    bi;         // bitmap header
    LPBITMAPINFOHEADER  lpbi;       // pointer to BITMAPINFOHEADER
    DWORD               dwLen;      // size of memory block
    HANDLE              hDIB, h;    // handle to DIB, temp handle
    HDC                 hDC;        // handle to DC
    WORD                biBits;     // bits per pixel

    // check if bitmap handle is valid

    if (!hBitmap)
        return NULL;

    // fill in BITMAP structure, return NULL if it didn't work

    if (!GetObject(hBitmap, sizeof(bm), (LPSTR)&bm))
        return NULL;

    // if no palette is specified, use default palette

    if (hPal == NULL)
        hPal = GetStockObject(DEFAULT_PALETTE);

    // calculate bits per pixel

    biBits = bm.bmPlanes * bm.bmBitsPixel;

    // make sure bits per pixel is valid

    if (biBits <= 1)
        biBits = 1;
    else if (biBits <= 4)
        biBits = 4;
    else if (biBits <= 8)
        biBits = 8;
    else // if greater than 8-bit, force to 24-bit
        biBits = 24;

    // initialize BITMAPINFOHEADER

    bi.biSize = sizeof(BITMAPINFOHEADER);
    bi.biWidth = bm.bmWidth;
    bi.biHeight = bm.bmHeight;
    bi.biPlanes = 1;
    bi.biBitCount = biBits;
    bi.biCompression = BI_RGB;
    bi.biSizeImage = 0;
    bi.biXPelsPerMeter = 0;
    bi.biYPelsPerMeter = 0;
    bi.biClrUsed = 0;
    bi.biClrImportant = 0;

    // calculate size of memory block required to store BITMAPINFO

    dwLen = bi.biSize + PaletteSize((LPSTR)&bi);

    // get a DC

    hDC = GetDC(NULL);

    if ( !hDC )
        return NULL;

    // select and realize our palette

    hPal = SelectPalette(hDC, hPal, FALSE);
    RealizePalette(hDC);

    // alloc memory block to store our bitmap

    hDIB = GlobalAlloc(GHND, dwLen);

    // if we couldn't get memory block

    if (!hDIB)
    {
      // clean up and return NULL

      SelectPalette(hDC, hPal, TRUE);
      RealizePalette(hDC);
      ReleaseDC(NULL, hDC);
      return NULL;
    }

    // lock memory and get pointer to it

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

    /// use our bitmap info. to fill BITMAPINFOHEADER

    *lpbi = bi;

    // call GetDIBits with a NULL lpBits param, so it will calculate the
    // biSizeImage field for us    

    GetDIBits(hDC, hBitmap, 0, (UINT)bi.biHeight, NULL, (LPBITMAPINFO)lpbi,
        DIB_RGB_COLORS);

    // get the info. returned by GetDIBits and unlock memory block

    bi = *lpbi;
    GlobalUnlock(hDIB);

    // if the driver did not fill in the biSizeImage field, make one up 
    if (bi.biSizeImage == 0)
        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;

    // realloc the buffer big enough to hold all the bits

    dwLen = bi.biSize + PaletteSize((LPSTR)&bi) + bi.biSizeImage;

    if (h = GlobalReAlloc(hDIB, dwLen, 0))
        hDIB = h;
    else
    {
        // clean up and return NULL

        GlobalFree(hDIB);
        hDIB = NULL;
        SelectPalette(hDC, hPal, TRUE);
        RealizePalette(hDC);
        ReleaseDC(NULL, hDC);
        return NULL;
    }

    // lock memory block and get pointer to it */

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

    // call GetDIBits with a NON-NULL lpBits param, and actualy get the
    // bits this time

    if (GetDIBits(hDC, hBitmap, 0, (UINT)bi.biHeight, (LPSTR)lpbi +
            (WORD)lpbi->biSize + PaletteSize((LPSTR)lpbi), (LPBITMAPINFO)lpbi,
            DIB_RGB_COLORS) == 0)
    {
        // clean up and return NULL

        GlobalUnlock(hDIB);
        hDIB = NULL;
        SelectPalette(hDC, hPal, TRUE);
        RealizePalette(hDC);
        ReleaseDC(NULL, hDC);
        return NULL;
    }

    bi = *lpbi;

    // clean up 
    GlobalUnlock(hDIB);
    SelectPalette(hDC, hPal, TRUE);
    RealizePalette(hDC);
    ReleaseDC(NULL, hDC);

    // return handle to the DIB
    return hDIB;
}

/*++
 *  Function:
 *      _GetDIBFromBitmap
 *  Description:
 *      Copies a rectangle from hBitmap and converts it to DIB data
 *
 *  Arguments:
 *      hBitmap - the main bitmap
 *      ppDIB   - pointer to DIB data
 *      left, top, right, bottom - describes the rectangle
 *                               - if all are == -1, returns the whole bitmap
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      _ClxWndProc on WM_TIMER message
 --*/
VOID
_GetDIBFromBitmap(
    HDC     hdcMemSrc,
    HBITMAP hBitmap,
    HANDLE  *phDIB,
    INT     left,
    INT     top,
    INT     right,
    INT     bottom)
{
    HANDLE  hDIB = NULL;

    HDC     hdcMemDst = NULL;
    HDC     hdcScreen = NULL;
    HBITMAP hDstBitmap = NULL;
    HBITMAP hOldDstBmp = NULL;

    if (!hdcMemSrc)
        goto exitpt;

    if (left == -1 && right == -1 && top == -1 && bottom == -1 && hBitmap)
    {
        BITMAP bitmapInfo; 

        if (sizeof(bitmapInfo) != 
                GetObject(hBitmap, sizeof(bitmapInfo), &bitmapInfo))
            goto exitpt;

        left    = top = 0;
        right   = bitmapInfo.bmWidth;
        bottom  = bitmapInfo.bmHeight;
    }

    // reorder left...bottom if needed
    if (left > right)
    {
        INT change = left;
        left = right;
        right = change;
    }

    if (top > bottom)
    {
        INT change = top;
        top = bottom;
        bottom = change;
    }

    hdcScreen = GetDC(NULL);
    hdcMemDst = CreateCompatibleDC(hdcScreen);
    hDstBitmap = CreateCompatibleBitmap(hdcScreen, right - left, bottom - top);

    if (!hdcMemDst || !hDstBitmap)
    {
        TRACE(( ERROR_MESSAGE, TEXT("Can't create destination DC to get client's DIB\n")));
        goto exitpt;
    }
    
    hOldDstBmp = SelectObject(hdcMemDst, hDstBitmap);

    if (!BitBlt( hdcMemDst,
            0, 0,   // dest x,y
            right - left,   // dest width
            bottom - top,   // dest height
            hdcMemSrc,
            left, top,     // source coordinates
            SRCCOPY))
        goto exitpt;

    TRACE((INFO_MESSAGE, TEXT("Getting DIB (%d, %d, %d, %d)\n"), 
            left, top, right, bottom));

    hDIB = BitmapToDIB(hDstBitmap, NULL); 

exitpt:
    if (hdcMemDst)
    {
        if (hOldDstBmp)
            SelectObject(hdcMemDst, hOldDstBmp);

        DeleteDC(hdcMemDst);
    }

    if (hdcScreen)
        ReleaseDC(NULL, hdcScreen);

    if (hDstBitmap)
        DeleteObject(hDstBitmap);

    *phDIB      = hDIB;

    if (!hDIB)
        TRACE((ERROR_MESSAGE, TEXT("Can't get client's DIB. GetLastError=%d\n"), GetLastError()));

}

#ifndef OS_WINCE
#ifdef  OS_WIN32
DWORD
__stdcall
_ClxSendMsgThread(VOID *param)
{
    while(1)
    {
        if (!g_pClx || WaitForSingleObject(g_pClx->semSendReady, INFINITE) !=
            WAIT_OBJECT_0)
                goto exitpt;

        if (!g_pClx || g_pClx->bSendMsgThreadExit)
            goto exitpt;

        SendMessage(g_pClx->msg.hwnd,
                    g_pClx->msg.message,
                    g_pClx->msg.wParam,
                    g_pClx->msg.lParam);

        // release the owner of the message
        ReleaseSemaphore(g_pClx->semSendCompleted, 1, NULL);
        // release next waiting worker
        ReleaseSemaphore(g_pClx->semSendDone, 1, NULL);
    }

exitpt:
    return 0;
}

/*++
 *  Function:
 *      _ClxSendMessage
 *  Description:
 *      Calls SendMessage from separate thread
 *      prevents deadlock on SendMessage (#319816)
 *
 *  Arguments:
 *      hBitmap - the main bitmap
 *      ppDIB   - pointer to DIB data
 *      left, top, right, bottom - describes the rectangle
 *                               - if all are == -1, returns the whole bitmap
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      _ClxWndProc on WM_TIMER message
 --*/
LRESULT
_ClxSendMessage(
  HWND hWnd,      // handle of destination window
  UINT Msg,       // message to send
  WPARAM wParam,  // first message parameter
  LPARAM lParam   // second message parameter
)
{
    LRESULT  rv = 0;
    PCLXINFO pClx = g_pClx;
    DWORD    dwThreadId;

    if (!pClx)
        goto exitpt;

    if (!pClx->semSendDone)
        pClx->semSendDone = CreateSemaphore(NULL, 1, 10, NULL);
    if (!pClx->semSendReady)
        pClx->semSendReady = CreateSemaphore(NULL, 0, 10, NULL);
    if (!pClx->semSendCompleted)
        pClx->semSendCompleted = CreateSemaphore(NULL, 0, 10, NULL);

    if (!pClx->semSendDone || !pClx->semSendReady || !pClx->semSendCompleted)
        goto exitpt;

    if (!pClx->hSendMsgThread)
    {
        pClx->hSendMsgThread = CreateThread(
                NULL,
                0,
                _ClxSendMsgThread, 
                NULL,
                0, 
                &dwThreadId);
    }

    if (!pClx->hSendMsgThread)
        goto exitpt;

    // Wait 10 mins send to complete
    if (WaitForSingleObject(pClx->semSendDone, 600000) !=
        WAIT_OBJECT_0)
        goto exitpt;

    pClx->msg.hwnd = hWnd;
    pClx->msg.message = Msg;
    pClx->msg.wParam = wParam;
    pClx->msg.lParam = lParam;

    // Signal the thread for available message
    ReleaseSemaphore(pClx->semSendReady, 1, NULL);

    // Wait for the send to complete
    WaitForSingleObject(pClx->semSendCompleted, 600000);

exitpt:
    return rv;
}
 
VOID
_ClxDestroySendMsgThread(PCLXINFO pClx)
{
    if (!pClx)
        goto exitpt;

    if (!pClx->semSendDone || !pClx->semSendReady || !pClx->hSendMsgThread ||
        !pClx->semSendCompleted)
        goto exitpt;

    // Wait 10 mins send to complete
    WaitForSingleObject(pClx->semSendDone, 600000);

    pClx->bSendMsgThreadExit = TRUE;

    // signal the thread to exit
    ReleaseSemaphore(pClx->semSendReady, 1, NULL);
    
    // wait for the thread to exit
    if (WaitForSingleObject(pClx->hSendMsgThread, 1200000) != WAIT_OBJECT_0)
    {
        TRACE((ERROR_MESSAGE, TEXT("SendThread can't exit, calling TerminateThread\n")));
        TerminateThread(pClx->hSendMsgThread, 0);
    }
    CloseHandle(pClx->hSendMsgThread);
exitpt:

    if (pClx->semSendCompleted)
    {
        CloseHandle(pClx->semSendCompleted);
        pClx->semSendCompleted = NULL;
    }

    if (pClx->semSendDone)
    {
        CloseHandle(pClx->semSendDone);
        pClx->semSendDone = NULL;
    }

    if (pClx->semSendReady)
    {
        CloseHandle(pClx->semSendReady);
        pClx->semSendReady = NULL;
    }

    pClx->hSendMsgThread = 0;

    ;
}

#endif  // OS_WIN32
#endif  // !OS_WINCE

//////////////////////////////////////////////////////////////////////
//
//  VC Channel support for RCLX mode
//

DWORD
CLXAPI
CLXDataReceivedVC(
    LPCSTR  szChannelName,
    LPVOID  pData,
    DWORD   dwSize
    )
{
    DWORD    rv = (DWORD)-1;
    PCLXINFO pClx;
    CHAR     szName[MAX_VCNAME_LEN];
    PCLXVCHANNEL pVChannel;
    RCLXDATA    Response;
    RCLXFEEDPROLOG  Prolog;
    BOOL rc;

    // Check if this channel is already registered
    pVChannel = g_pVChannels;
    // find the channel entry
    while(pVChannel && _stricmp(pVChannel->szName, szChannelName))
    {
        pVChannel = pVChannel->pNext;
    }

    if (!pVChannel)
    {
        TRACE((WARNING_MESSAGE, TEXT("Channel %s is not registered\n"), szChannelName));
        goto exitpt;
    }

    if (!IS_RCLX)
    {
        TRACE((WARNING_MESSAGE, TEXT("CLXDataReceivedVC: not in RCLX mode\n")));
        goto exitpt;
    }

    if (!g_pClx)
    {
        TRACE((ERROR_MESSAGE, TEXT("CLXDataReceivedVC: pClx is NULL\n")));
        goto exitpt;
    }

    if (strlen(szChannelName) > MAX_VCNAME_LEN - 1)
    {
        TRACE((ERROR_MESSAGE, TEXT("Channel name \"%s\"bigger than %d chars\n"),
            szChannelName, MAX_VCNAME_LEN));
        goto exitpt;
    }

    pClx = g_pClx;

    Prolog.FeedType = FEED_DATA;
    Prolog.HeadSize = sizeof(Response) + sizeof(szName) + dwSize;
    Prolog.TailSize = 0;

    Response.uiType = DATA_VC;
    Response.uiSize = sizeof(szName) + dwSize;

    strcpy(szName, szChannelName);

    TRACE((ALIVE_MESSAGE, 
            TEXT("Sending VC data, DataSize=%d, HeadSize=%d, TailSize=%d, Name=%s\n"),
            dwSize,
            Prolog.HeadSize,
            Prolog.TailSize,
            szName));
    rc =        RClx_SendBuffer(pClx->hSocket, &Prolog, sizeof(Prolog));
    rc = rc &&  RClx_SendBuffer(pClx->hSocket, &Response, sizeof(Response));
    rc = rc &&  RClx_SendBuffer(pClx->hSocket, szName, sizeof(szName));
    rc = rc &&  RClx_SendBuffer(pClx->hSocket, pData, dwSize);

    if (!rc)
    {
        TRACE((WARNING_MESSAGE, TEXT("Unable to sent message\n")));
        goto exitpt;
    }
    rv = 0;

exitpt:
    return rv;
}

DWORD
_CLXSendDataVC(
    LPCSTR szChannelName,
    LPVOID pData,
    DWORD  dwSize
    )
{
    DWORD rv = (DWORD)-1;
    // Check if this channel is already registered
    PCLXVCHANNEL pVChannel = g_pVChannels;

    // find the channel entry
    while(pVChannel && _stricmp(pVChannel->szName, szChannelName))
    {
        pVChannel = pVChannel->pNext;
    }

    if (!pVChannel)
    {
        TRACE((WARNING_MESSAGE, TEXT("Channel %s is not registered\n"), szChannelName));
        goto exitpt;
    }
    
    ASSERT(pVChannel->pSendDataFn);

    rv = (pVChannel->pSendDataFn)(pData, dwSize);

exitpt:
    return rv;
}

BOOL
CLXAPI
ClxRegisterVC(
    LPCSTR              szChannelName,
    PCLXVC_SENDDATA     pSendData,
    PCLXVC_RECVDATA     *ppRecvData
    )
{
    BOOL rv = FALSE;
    PCLXVCHANNEL pVChannel;
    UINT counter;

    if (!szChannelName || !pSendData || !ppRecvData ||
        strlen(szChannelName) > MAX_VCNAME_LEN - 1)
    {
        TRACE((ERROR_MESSAGE, TEXT("ClxRegisterVC: invalid parameters\n")));
        goto exitpt;
    }

    pVChannel = malloc(sizeof(*pVChannel));
    if (!pVChannel)
        goto exitpt;

    strcpy(pVChannel->szName, szChannelName);

    // zero the rest of the name
    for(counter = strlen(szChannelName); counter < MAX_VCNAME_LEN; counter++)
        pVChannel->szName[counter] = 0;

    pVChannel->pSendDataFn = pSendData;

    *ppRecvData = CLXDataReceivedVC;
    
    // Push this in the queue
    pVChannel->pNext = g_pVChannels;
    g_pVChannels = pVChannel;
        
    rv = TRUE;

exitpt:
    return rv;
}

VOID
CLXAPI
ClxUnregisterVC(
    LPCSTR  szChannelName
    )
{
    PCLXVCHANNEL pVChannel = g_pVChannels;
    PCLXVCHANNEL pPrev = NULL;

    // find the channel and remove it from the queue
    while(pVChannel && _stricmp(pVChannel->szName, szChannelName))
    {
        pPrev = pVChannel;
        pVChannel = pVChannel->pNext;
    }

    if (!pVChannel)
    {
        TRACE((WARNING_MESSAGE, TEXT("Can't find channel name: %s\n"), 
                szChannelName));
        goto exitpt;
    }

    if (!pPrev)
        g_pVChannels = pVChannel->pNext;
    else
        pPrev->pNext = pVChannel->pNext;

exitpt:
    ;
}

//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\glyphspy\dialog.c ===
/*++
 *  File name:
 *      dialog.c
 *  Contents:
 *      Implements dialog boxes for add to/browse bitmap database
 --*/
#include <windows.h>

#include "..\lib\bmpdb.h"
#include "resource.h"

PBMPENTRY   g_pBitmap;
PGROUPENTRY g_pGrpList;
PBMPENTRY   g_pBmpList;
char        g_szAddTextId[256];

char szBuffer[1024] = "null";

/*++
 *  Function:
 *      _StripLine
 *  Description:
 *      Strips trailing and leading white space cahracters
 *      in a string
 *  Arguments:
 *      line    - the string
 *  Called by:
 *      _AddGlyphDlgProc
 --*/
void _StripLine(char *line)
{
    int last = strlen(line);
    char *first = line;

    if (last) last--;

    while(last && isspace(line[last]))
    {
        line[last] = 0;
        last--;
    }

    while(isspace(*first))
        first++;

    if (line != first)
        memmove(line, first, strlen(first) + 1 );
}

/*++
 *  Function:
 *      DrawGlyph
 *  Description:
 *      Draws the glyph (monochrome bitmap) g_pBitmap
 *      in the client window area
 *  Arguments:
 *      hWnd    - the handle to the window
 *  Called by:
 *      PaintGlyph
 --*/
void
DrawGlyph (HWND hWnd)
{
	HDC		hDC = NULL;
    HDC     glyphDC = NULL;
    HBITMAP hOldBmp;
	RECT	rect;
    INT     xCenter, yCenter;
    INT     xSize, ySize;

    if (!g_pBitmap)
        goto exitpt1;

	GetClientRect (hWnd, &rect);
	hDC = GetDC (hWnd);

    if ( !hDC )
        goto exitpt;

    glyphDC = CreateCompatibleDC(hDC);

    if (!glyphDC)
        goto exitpt;

    hOldBmp = SelectObject(glyphDC, g_pBitmap->hBitmap);

    xSize = (g_pBitmap->xSize > (UINT)rect.right )?rect.right :g_pBitmap->xSize;
    ySize = (g_pBitmap->ySize > (UINT)rect.bottom)?rect.bottom:g_pBitmap->ySize;

    xCenter = (rect.right - xSize) / 2;
    yCenter = (rect.bottom- ySize) / 2;

    BitBlt(hDC,                 // Dest DC
           xCenter,             // Dest x
           yCenter,             // Dest y
           xSize,               // Width
           ySize,               // Height
           glyphDC,             // Source
           0,                   // Src x
           0,                   // Src y
           SRCCOPY);            // Rop

    SelectObject(glyphDC, hOldBmp);

    DeleteDC( glyphDC );
exitpt:
    if ( hDC )
    	ReleaseDC (hWnd, hDC);
exitpt1:
    ;
}

/*++
 *  Function:
 *      PaintGlyph
 *  Description:
 *      Repaints the glyph. Usualy called on WM_PAINT message
 *  Arguments:
 *      hWnd    - the window
 *  Called by:
 *      _CommentListClicked, _AddGlyphDlgProc, _BrowseDlgProc
 --*/
void
PaintGlyph (HWND hWnd)
{
	InvalidateRect (hWnd, NULL, TRUE);
	UpdateWindow (hWnd);
	DrawGlyph (hWnd);
}

/*++
 *  Function:
 *      _AddWideToLB
 *  Description:
 *      Adds wide string to list box
 *  Arguments:
 *      hwndLB      - list box handle
 *      wszString   - string to add
 *  Called by:
 *      _DeleteItem, _BrowseDlgItem
 --*/
VOID
_AddWideToLB(HWND hwndLB, LPCWSTR wszString)
{
    char    lpszString[256];

    WideCharToMultiByte(
        CP_ACP,
        0,
        wszString,
        -1,
        lpszString,
        sizeof(lpszString),
        NULL, NULL);

    SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)lpszString);
}

/*++
 *  Function:
 *      _DeleteItem
 *  Description:
 *      Deletes an entry from the list box and database
 *  Arguments:
 *      hDlg        - dialog handle
 *      hWndIDList  - list box with IDs
 *      hWndCommentList - list box with comment strings
 *  Called by:
 *      _BrowseDlgItem
 --*/
VOID
_DeleteItem(HWND hDlg, HWND hWndIDList, HWND hWndCommentList)
{
    PGROUPENTRY pGroup;
    PBMPENTRY   pBitmap;
    FOFFSET     lBmpOffs;
    LRESULT     iIDIndex, iCmntIndex, iIdx;

    iIDIndex = SendMessage (hWndIDList, LB_GETCURSEL, 0, 0);
    iIdx = iCmntIndex = SendMessage (hWndCommentList, LB_GETCURSEL, 0, 0);

    if (iIDIndex == LB_ERR || iCmntIndex == LB_ERR)
        goto exitpt;

    pGroup = g_pGrpList;
    while(pGroup && iIDIndex)
    {
        pGroup = pGroup->pNext;
        iIDIndex--;
    }

    pBitmap = g_pBmpList;
    while (pBitmap && iCmntIndex)
    {
        pBitmap = pBitmap->pNext;
        iCmntIndex --;
    }

    if (!pBitmap || !pGroup)
        goto exitpt;

    DeleteBitmapByPointer(pBitmap->FOffsMe);
    // Is this is the last bitmap in the group ?
    if (iIdx == 0 && pBitmap->pNext == NULL)
        DeleteGroupByPointer(pGroup->FOffsMe);
        
    
//  Refresh the boxes
    FreeGroupList(g_pGrpList);
    SendMessage(hWndIDList, LB_RESETCONTENT, 0, 0);
    
    g_pGrpList  = GetGroupList();
    pGroup = g_pGrpList;
    while (pGroup)
    {
        _AddWideToLB(hWndIDList, pGroup->WText);
        pGroup = pGroup->pNext;
    }

exitpt:
    ;
}

/*++
 *  Function:
 *      _IDListClicked
 *  Description:
 *      Processes selecting an item from the list box with IDs
 *      Fills the comment list box
 *  Arguments:
 *      hDlg        - handle to the dialog
 *      hWndCommentList - list box with comments
 *      hWndIDList  - list box with IDs
 *  Called by:
 *      _BrowseDlgProc
 --*/
VOID
_IDListClicked(HWND hDlg, HWND hWndCommentList, HWND hWndIDList)
{
	LRESULT     iIDIndex;
    PBMPENTRY   pBitmap;
    PGROUPENTRY pGroup;

    iIDIndex = SendMessage (hWndIDList, LB_GETCURSEL, 0, 0);

    // Clear the comment list box
    SendMessage(hWndCommentList, LB_RESETCONTENT, 0, 0);
    FreeBitmapList(g_pBmpList);

	if (iIDIndex != LB_ERR)
	{
        LRESULT iIdx = iIDIndex;

        // Find the choosen group
        pGroup = g_pGrpList;
        while(pGroup && iIdx)
        {
            iIdx--;
            pGroup = pGroup->pNext;
        }

        // Read the bitmap group
        if (pGroup)
        {
            HDC hDC = GetDC(hDlg);

            if ( hDC )
            {
                pBitmap = g_pBmpList = GetBitmapList(hDC, pGroup->FOffsBmp);
                ReleaseDC(hDlg, hDC);
                while(pBitmap)
                {
                    SendMessage (hWndCommentList, LB_ADDSTRING, 0, (LPARAM)pBitmap->szComment);
                    pBitmap = pBitmap->pNext;
                }
            }
        }
        EnableWindow (GetDlgItem (hDlg, IDC_DELETE), FALSE);
	}
}

/*++
 *  Function:
 *      _CommentListClicked
 *  Description:
 *      Processes selecting an item from comment list box
 *      Shows the bitmap under this comment and ID
 *  Arguments:
 *      hDlg        - dialog handle
 *      hWndGlyph   - glyph window
 *      hWndCommentList - list box with comments
 *  Called by:
 *      _BrowseDlgProc
 --*/
VOID
_CommentListClicked(HWND hDlg, HWND hWndGlyph, HWND hWndCommentList)
{
    LRESULT     iCommIndex;
    PBMPENTRY   pBitmap;

    iCommIndex = SendMessage (hWndCommentList, LB_GETCURSEL, 0, 0);

    g_pBitmap = NULL;
    if (iCommIndex != LB_ERR)
    {
        LRESULT iIdx = iCommIndex;

        pBitmap = g_pBmpList;
        while (pBitmap && iIdx)
        {
            pBitmap = pBitmap->pNext;
            iIdx --;
        }

        g_pBitmap = pBitmap;

        EnableWindow (GetDlgItem (hDlg, IDC_DELETE), TRUE);
    }
    PaintGlyph (hWndGlyph);
}

/*++
 *  Function:
 *      _AddGlyphDlgProc
 *  Description:
 *      Processes the messages for Add Glyph dialog box
 *  Arguments:
 *      hDlg    - dialog handle
 *      uiMsg   - message ID
 *      wParam  - word parameter
 *      lParam  - long parameter
 *  Return value:
 *      TRUE if the message is processed
 --*/
INT_PTR
CALLBACK
_AddGlyphDlgProc (HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
	static HWND hWndGlyph = NULL;

	switch (uiMsg)
	{
	case WM_INITDIALOG:
		hWndGlyph = GetDlgItem (hDlg, IDC_GLYPH);

		SendDlgItemMessage (hDlg, IDC_IDEDIT, EM_LIMITTEXT, (WPARAM)MAX_STRING_LENGTH, 0);
		SendDlgItemMessage (hDlg, IDC_COMMENT, EM_LIMITTEXT, (WPARAM)MAX_STRING_LENGTH, 0);
		return TRUE;

	case WM_PAINT:
		PaintGlyph (hWndGlyph);
		break;

	case WM_COMMAND:
		switch (LOWORD (wParam))
		{
		case IDOK:
			GetDlgItemText (
				hDlg, 
				IDC_IDEDIT, 
				g_szAddTextId, 
				sizeof (g_szAddTextId) - 1
				);
            _StripLine(g_szAddTextId);

			GetDlgItemText (
				hDlg, 
				IDC_COMMENT, 
				g_pBitmap->szComment, 
				sizeof (g_pBitmap->szComment) - 1
				);
            _StripLine(g_pBitmap->szComment);

            if (!g_szAddTextId[0])
            {
                MessageBox(hDlg, "Please enter ID !", "Warning", MB_OK);
            } else if (!g_pBitmap->szComment[0])
            {
                MessageBox(hDlg, "Please enter comment !", "Warning", MB_OK);
            } else {
			    EndDialog (hDlg, TRUE);
            }
			return TRUE;

		case IDCANCEL:
			EndDialog (hDlg, FALSE);
			return TRUE;
		}
	}

	return FALSE;
}

/*++
 *  Function:
 *      AddBitmapDialog
 *  Description:
 *      Pops an "Add Glyph(bitmap)" dialog
 *  Arguments:
 *      hInst       - our instance
 *      hWnd        - main window handle
 *      pBitmap     - selected bitmap
 *  Called by:
 *      glyphspy.c!_ClickOnGlyph
 --*/
VOID
AddBitmapDialog(HINSTANCE hInst, HWND hWnd, PBMPENTRY   pBitmap)
{
    g_pBitmap = pBitmap;

    if (!g_pBitmap)
        goto exitpt;

    if (DialogBox (
            hInst,
            MAKEINTRESOURCE (IDD_ADDGLYPH),
            hWnd,
            _AddGlyphDlgProc
            ))
    {
        // Add the entry to the DB
        if (!AddBitMapA(g_pBitmap, g_szAddTextId))
        {
            MessageBox(hWnd, "Can't add the glyph to the database !", "Warning", MB_OK);
        }
    }
exitpt:
    ;
}

/*++
 *  Function:
 *      _BrowseDlgProc
 *  Description:
 *      Processes the messages for "Browse Glyphs(bitmaps)" dialog
 *  Arguments:
 *      hDlg        - dialog handle
 *      uiMsg       - message ID
 *      wParam      - word parameter
 *      lParam      - long parameter
 *  Return value:
 *      TRUE if the message is processed
 --*/
INT_PTR
CALLBACK
_BrowseDlgProc (HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
	static HWND hWndGlyph = NULL;
	static HWND hWndIDList = NULL;
    static HWND hWndCommentList = NULL;
	int i;
	int iIndex;
    PGROUPENTRY pGroup;
    BOOL    rv = FALSE;

	switch (uiMsg)
	{
	case WM_INITDIALOG:
		hWndGlyph = GetDlgItem (hDlg, IDC_GLYPH);
		hWndIDList = GetDlgItem (hDlg, IDC_IDLIST);
        hWndCommentList = GetDlgItem(hDlg, IDC_COMMENTLIST);

		EnableWindow (GetDlgItem (hDlg, IDC_DELETE), FALSE);

        g_pGrpList  = GetGroupList();
        pGroup = g_pGrpList;
		while (pGroup)
		{
			_AddWideToLB(hWndIDList, pGroup->WText);
            pGroup = pGroup->pNext;
		}
        rv = TRUE;
        break;

	case WM_PAINT:
		PaintGlyph (hWndGlyph);
		break;

	case WM_COMMAND:
		switch (LOWORD (wParam))
		{
		case IDOK:
			EndDialog (hDlg, TRUE);
            rv = TRUE;
            break;

		case IDC_DELETE:
			_DeleteItem(hDlg, hWndIDList, hWndCommentList);
            _IDListClicked(hDlg, hWndCommentList, hWndIDList);
            _CommentListClicked(hDlg, hWndGlyph, hWndCommentList);
            rv = TRUE;
            break;

		case IDC_IDLIST:
			if (HIWORD (wParam) == LBN_SELCHANGE)
			{
				_IDListClicked(hDlg, hWndCommentList, hWndIDList);
                _CommentListClicked(hDlg, hWndGlyph, hWndCommentList);
			}
            rv = TRUE;
            break;
        case IDC_COMMENTLIST:
            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                _CommentListClicked(hDlg, hWndGlyph, hWndCommentList);
            }
            rv = TRUE;
            break;
		}
	}

	return rv;
}


/*++
 *  Function:
 *      BrowseBitmapsDialog
 *  Description:
 *      Pops "Browse Glyphs(bitmaps) database"
 *  Arguments:
 *      hInst       - our instance
 *      hWnd        - main window handle
 *  Called by:
 *      glyphspy.c!_GlyphSpyWndProc on ID_YEAH_BROWSE
 --*/
VOID
BrowseBitmapsDialog(HINSTANCE hInst, HWND hWnd)
{

    g_pGrpList  = NULL;
    g_pBitmap   = NULL;
    g_pBmpList  = NULL;

    DialogBox (
        hInst,
        MAKEINTRESOURCE (IDD_BROWSE),
        hWnd,
        _BrowseDlgProc
        );

    FreeBitmapList(g_pBmpList);
    FreeGroupList(g_pGrpList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\glyphspy\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by spyglyph.rc
//
#define IDD_BROWSE                      101
#define IDD_ADDGLYPH                    102
#define IDR_MENU1                       103
#define IDC_COMMENT                     1000
#define IDC_IDLIST                      1002
#define IDC_DELETE                      1003
#define IDC_GLYPH                       1004
#define IDC_IDEDIT                      1005
#define IDC_COMMENTLIST                 1006
#define ID_YEAH_START                   40001
#define ID_YEAH_BROWSE                  40002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\bmpcache.h ===
/*++
 *  File name:
 *      bmpcache.h
 *  Contents:
 *      bmpcache.c exported functions
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

VOID    InitCache(VOID);
VOID    DeleteCache(VOID);
BOOL    Glyph2String(PBMPFEEDBACK pBmpFeed, LPWSTR wszString, UINT max);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\bmpdb.h ===
/*++
 *  File name:
 *      bmpdb.h
 *  Contents:
 *      bmpdb structures
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/
#define MAX_STRING_LENGTH   128

typedef long    FOFFSET;

typedef struct _BMPENTRY {
    UINT    nDataSize;                  // Total size of pData (bmpSize+bmiSize)
    UINT    bmpSize;                    // Size of bits. Located at pData
                                        // After BITMAPINFO (if any)
    UINT    bmiSize;                    // Size of BITMAPINFO header
                                        // if zero -> monocrome bitmap
                                        // BITMAPINFO is located in begining of
                                        // pData
    UINT    xSize, ySize;
    UINT    nChkSum;
    BOOL    bDeleted;                   // Valuable in DB
    char    szComment[MAX_STRING_LENGTH];
    HBITMAP hBitmap;                    // Valuable in linked list

    FOFFSET FOffsMe;                    // My pointer in DB
    FOFFSET FOffsNext;                  // DB
    struct  _BMPENTRY   *pNext;         // linked list

    PVOID   pData;                      // Pointer to BMP data, in DB it is 
                                        // immediatly after this structure

} BMPENTRY, *PBMPENTRY;

typedef struct _GROUPENTRY {
    WCHAR       WText[MAX_STRING_LENGTH];
    BOOL        bDeleted;

    FOFFSET     FOffsMe;                // My pointer in DB
    FOFFSET     FOffsBmp;               // DB
    PBMPENTRY   pBitmap;                // linked list

    FOFFSET     FOffsNext;              // DB
    struct      _GROUPENTRY *pNext;     // linked list

} GROUPENTRY, *PGROUPENTRY;

typedef BOOL (_cdecl *PFNENUMGROUPS)(FOFFSET nOff, 
                                     PGROUPENTRY pGroup, 
                                     PVOID pParam); 
typedef BOOL (_cdecl *PFNENUMBITMAPS)(FOFFSET nOff, 
                                      PBMPENTRY pBitmap, 
                                      PVOID pParam);

BOOL    OpenDB(BOOL bWrite);
VOID    CloseDB(VOID);
BOOL    ReadGroup(FOFFSET nOffset, PGROUPENTRY pGroup);
BOOL    WriteGroup(FOFFSET nOffset, PGROUPENTRY pGroup);
VOID    EnumerateGroups(PFNENUMGROUPS pfnEnumGrpProc, PVOID pParam);
BOOL    ReadBitmapHeader(FOFFSET nOffset, PBMPENTRY pBitmap);
BOOL    WriteBitmapHeader(FOFFSET nOffset, PBMPENTRY pBitmap);
PBMPENTRY ReadBitmap(FOFFSET nOffset);
VOID    FreeBitmap(PBMPENTRY pBmp);
VOID    EnumerateBitmaps(FOFFSET nOffset, 
                         PFNENUMBITMAPS pfnEnumProc, 
                         PVOID pParam);
FOFFSET FindGroup(LPWSTR szWText);
FOFFSET FindBitmap(LPWSTR szWText, char *szComment);

UINT    CheckSum(PVOID pData, UINT nLen);

BOOL    AddBitMap(PBMPENTRY pBitmap, LPCWSTR szWText);
BOOL    AddBitMapA(PBMPENTRY pBitmap, LPCSTR szAText);

BOOL    DeleteBitmap(LPWSTR szWText, char *szComment);
BOOL    DeleteBitmapByPointer(FOFFSET nBmpOffs);
BOOL    DeleteGroupByPointer(FOFFSET nGrpOffs);

PGROUPENTRY GetGroupList(VOID);
VOID    FreeGroupList(PGROUPENTRY pList);
PBMPENTRY GetBitmapList(HDC hDC, FOFFSET nOffs);
VOID    FreeBitmapList(PBMPENTRY pList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\glyphspy\glyphspy.c ===
/*++
 *  File name:
 *      glyphspy.c
 *  Contents:
 *      UI for spying and recording glyphs reveived by RDP client
 --*/

#include    <windows.h>
#include    <stdio.h>
#include    <stdarg.h>
#include    <malloc.h>

#include    "..\lib\feedback.h"
#include    "..\lib\bmpdb.h"
#include    "resource.h"

#define CLIENT_EXE  "mstsc.exe"
#define TRACE(_x_)  {_MyPrintMessage _x_;}

// Dialog functions
VOID AddBitmapDialog(HINSTANCE hInst, HWND hWnd, PBMPENTRY   pBitmap);
VOID BrowseBitmapsDialog(HINSTANCE hInst, HWND hWnd);

/*
 *  Global data
 */
HWND        g_hMainWindow;      // Main window handle
HINSTANCE   g_hInstance;        // executable instance
HINSTANCE   g_hPrevInstance;    // previous instance
DWORD       g_pidRDP = 0;       // Process Id of the RDP client
HANDLE      g_hRDP = NULL;      // Process handle of the client

#define     HISTSIZE    150     // Size of the history list

UINT        g_nCurSize = 0;     // Current size
UINT        g_nScrollPos = 0;   // Vertical scroll position

BMPENTRY    g_Bmp[HISTSIZE];    // The history list

/*++
 *  Function:
 *      _CompareBitmaps
 *  Description:
 *      Compares two bitmaps
 *  Arguments:
 *      pBmp    - bitmap to compare to
 *      pData   - bits of the second bitmap
 *      xSize   - size of the second bitmap
 *      ySize
 *      bmiSize - BITMAPINFO size
 *      nBytesLen - size of the second bitmap bits
 *  Return value:
 *      TRUE if equal
 *  Called by:
 *      _AddToHistList
 --*/
BOOL _CompareBitmaps(
        PBMPENTRY pBmp, 
        PVOID pData, 
        UINT xSize, 
        UINT ySize, 
        UINT bmiSize,
        UINT nBytesLen)
{
    BOOL rv = FALSE;

    if (xSize != pBmp->xSize || ySize != pBmp->ySize || 
        bmiSize != pBmp->bmiSize ||
        nBytesLen != pBmp->nDataSize)

        goto exitpt;

    if (!memcmp(pBmp->pData, pData, nBytesLen))
        rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      _AddToHistList
 *  Description:
 *      Adds a bitmap to the history list
 *  Arguments:
 *      pBmpFeed    - bitmap to add
 *  Called by:
 *      _GetBitmap
 --*/
void _AddToHistList(PBMPFEEDBACK pBmpFeed)
{
    PVOID   pNewData, pBmpData;
    HBITMAP hBmp;
    UINT    i, nTotalSize;

    if (!pBmpFeed || !pBmpFeed->xSize || !pBmpFeed->ySize ||
        !pBmpFeed->bmpsize)
        goto exitpt;


    pBmpData = (BYTE *)(&(pBmpFeed->BitmapInfo)) + pBmpFeed->bmiSize;
    nTotalSize = pBmpFeed->bmpsize + pBmpFeed->bmiSize;

    for (i = 0; i < g_nCurSize; i++)
        if (_CompareBitmaps(g_Bmp + i,
                            &pBmpFeed->BitmapInfo, 
                            pBmpFeed->xSize, 
                            pBmpFeed->ySize, 
                            pBmpFeed->bmiSize,
                            nTotalSize))
            goto exitpt;

    
    pNewData = malloc(nTotalSize);
    if (!pNewData)
        goto exitpt;

    memcpy(pNewData, &pBmpFeed->BitmapInfo, nTotalSize);
    
    if (!pBmpFeed->bmiSize)
        hBmp = CreateBitmap(pBmpFeed->xSize, pBmpFeed->ySize, 
                        1, 1,
                        pBmpData);
    else {
        HDC hDC;

        hDC = GetDC(g_hMainWindow);
        if ( hDC )
        {
            hBmp = CreateDIBitmap(hDC,
                              &(pBmpFeed->BitmapInfo.bmiHeader),
                              CBM_INIT,
                              pBmpData,
                              &(pBmpFeed->BitmapInfo),
                              DIB_PAL_COLORS);
            ReleaseDC(g_hMainWindow, hDC);
        }
    }

    if (g_nCurSize == HISTSIZE)
    // Delete the last entry
    {
        DeleteObject(g_Bmp[g_nCurSize - 1].hBitmap);
        free(g_Bmp[g_nCurSize - 1].pData);
    } else {
        g_nCurSize++;
    }
    if (g_nCurSize)
        memmove(g_Bmp + 1, g_Bmp, (g_nCurSize - 1)*sizeof(g_Bmp[0]));

    g_Bmp[0].hBitmap    = hBmp;
    g_Bmp[0].xSize      = pBmpFeed->xSize;
    g_Bmp[0].ySize      = pBmpFeed->ySize;
    g_Bmp[0].nDataSize  = pBmpFeed->bmpsize + pBmpFeed->bmiSize;
    g_Bmp[0].bmiSize    = pBmpFeed->bmiSize;
    g_Bmp[0].bmpSize    = pBmpFeed->bmpsize;
    g_Bmp[0].pData      = pNewData;

exitpt:
    ;
}

/*++
 *  Function:
 *      _FreeHistList
 *  Description:
 *      Deletes and frees all resources allocated by history list
 *  Called by:
 *      _GlyphSpyWndProc on WM_CLOSE
 --*/
void _FreeHistList(void)
{
    UINT    i;

    for(i = 0; i < g_nCurSize; i++)
    {
        DeleteObject(g_Bmp[i].hBitmap);
        free(g_Bmp[i].pData);
    }
    g_nCurSize = 0;
}

/*++
 *  Function:
 *      _MyPrintMessage
 *  Description:
 *      Print function for debugging purposes
 *  Arguments:
 *      format  - message format
 *      ...     - format arguments
 *  Called by:
 *      TRACE macro
 --*/
void _MyPrintMessage(char *format, ...)
{
    char szBuffer[256];
    va_list     arglist;
    int nchr;

    va_start (arglist, format);
    nchr = _vsnprintf (szBuffer, sizeof(szBuffer), format, arglist);
    va_end (arglist);
    OutputDebugString(szBuffer);

}

/*++
 *  Function:
 *      _StartClient
 *  Description:
 *      Starts an RDP client process
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      _GlyphSpyWndProc on ID_YEAH_START
 --*/
BOOL _StartClient(VOID)
{
    STARTUPINFO si;
    PROCESS_INFORMATION procinfo;
    BOOL    rv = TRUE;

    if (g_pidRDP)
    {
        rv = FALSE;
        goto exitpt;
    }

    FillMemory(&si, sizeof(si), 0);
    si.cb = sizeof(si);
    si.wShowWindow = SW_SHOWMINIMIZED;

    if (!CreateProcessA(CLIENT_EXE,
                      " /CLXDLL=CLXTSHAR.DLL", // Command line
                      NULL,             // Security attribute for process
                      NULL,             // Security attribute for thread
                      FALSE,            // Inheritance - no
                      0,                // Creation flags
                      NULL,             // Environment
                      NULL,             // Current dir
                      &si,
                      &procinfo))
    {
        rv = FALSE;
    } else {
        g_pidRDP = procinfo.dwProcessId;
        g_hRDP = procinfo.hProcess;
    } 
    CloseHandle(procinfo.hThread);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _CloseClient
 *  Description:
 *      Closes the handle to the client process
 *  Called by:
 *      _GlyphSpyWndProc on WM_FB_DISCONNECT and ID_YEAH_START
 --*/
VOID _CloseClient(VOID)
{
    if (g_pidRDP)
    {
        g_pidRDP = 0;
        CloseHandle(g_hRDP);
    }
}

/*++
 *  Function:
 *      _GetBitmap
 *  Description:
 *      Opens the shared memory and retreives the bitmap
 *      passed by clxtshar
 *  Arguments:
 *      dwProcessId - senders process Id
 *      hMapF       - handle to the shared memory
 *  Called by:
 *      _GlyphSpyWndProc on WM_FB_GLYPHOUT
 --*/
VOID _GetBitmap(DWORD dwProcessId, HANDLE hMapF)
{
    PBMPFEEDBACK pView;
    HANDLE hDupMapF;
    UINT    nSize;

    if (dwProcessId != g_pidRDP)
        goto exitpt;

    if (!DuplicateHandle(  g_hRDP,
                           hMapF,
                           GetCurrentProcess(),
                           &hDupMapF,
                           FILE_MAP_READ,
                           FALSE,
                           0))
    {
        TRACE(("Can't dup file handle, GetLastError = %d\n", GetLastError()));
        goto exitpt;
    }

    pView = MapViewOfFile(hDupMapF,
                          FILE_MAP_READ,
                          0,
                          0,
                          sizeof(*pView));

    if (!pView)
    {
        TRACE(("Can't map a view,  GetLastError = %d\n", GetLastError()));
        goto exitpt1;
    }

    // Get size
    nSize = pView->bmiSize + sizeof(*pView) + pView->bmpsize - sizeof(pView->BitmapInfo);

    // unmap
    UnmapViewOfFile(pView);

    // remap the whole structure
    pView = MapViewOfFile(hDupMapF,
                          FILE_MAP_READ,
                          0,
                          0,
                          nSize);

    if (!pView)
    {
        TRACE(("Can't map a view,  GetLastError = %d\n", GetLastError()));
        goto exitpt1;
    }

    _AddToHistList(pView);
    
    UnmapViewOfFile(pView);
    CloseHandle(hDupMapF);

exitpt:
    return;
exitpt1:
    UnmapViewOfFile(pView);
    CloseHandle(hDupMapF);
}

/*++
 *  Function:
 *      _RepaintWindow
 *  Description:
 *      Redraws the window client area
 *  Arguments:
 *      hWnd    - window handle
 *  Called by:
 *      _GlyphSpyWndProc on WM_PAINT
 --*/
void _RepaintWindow(HWND hWnd)
{
    HDC glyphDC = NULL;
    HDC theDC;
    HBITMAP hOldBmp;
    PAINTSTRUCT ps;
    UINT    nBmpCntr, yPtr;
    RECT    rcClient;

    theDC = BeginPaint(hWnd, &ps);
    if (!theDC)
        goto exitpt;

    GetClientRect(hWnd, &rcClient);

    glyphDC = CreateCompatibleDC(theDC);   

    if (!g_nCurSize)
        goto exitpt;

    if (!glyphDC)
        goto exitpt;

    hOldBmp = SelectObject(glyphDC, g_Bmp[0].hBitmap);

    nBmpCntr = g_nScrollPos;
    yPtr = 0;
    while (nBmpCntr < g_nCurSize && yPtr < (UINT)rcClient.bottom)
    {
        SelectObject(glyphDC, g_Bmp[nBmpCntr].hBitmap);

        BitBlt(theDC,               // Dest DC
                0,                  // Dest x
                yPtr,                  // Dest y
                g_Bmp[nBmpCntr].xSize,            // Width
                g_Bmp[nBmpCntr].ySize,            // Height
                glyphDC,            // Source
                0,                  // Src x
                0,                  // Src y
                SRCCOPY);           // Rop

        yPtr += g_Bmp[nBmpCntr].ySize;
        nBmpCntr++;
    }

    SelectObject(glyphDC, hOldBmp);
    EndPaint(hWnd, &ps);
exitpt:

    if ( glyphDC )
        DeleteDC(glyphDC);
}

/*++
 *  Function:
 *      _SetVScroll
 *  Description:
 *      Changes the position of the vertical scroll
 *  Arguments:
 *      nScrollCode - Scroll action
 *      nPos        - argument
 *  Called by:
 *      _GlyphOutWndProc on WM_VSCROLL
 --*/
VOID _SetVScroll(int nScrollCode, short int nPos)
{
    int nScrollPos = g_nScrollPos;

    switch(nScrollCode)
    {
    case SB_BOTTOM: 
        nScrollPos = g_nCurSize - 1;
    break;
//    case SB_ENDSCROLL: 
    case SB_LINEDOWN: 
        nScrollPos++;
    break;
    case SB_LINEUP: 
        nScrollPos--;
    break;
    case SB_PAGEDOWN: 
        nScrollPos += 3;
    break;
    case SB_PAGEUP: 
        nScrollPos -= 3;
    break;
    case SB_THUMBPOSITION: 
        nScrollPos = nPos;
    break;
    case SB_THUMBTRACK:
        nScrollPos = nPos;
    break;
    case SB_TOP:
        nScrollPos = 0;
    break;
    }

    g_nScrollPos = nScrollPos;
    if (nScrollPos < 0)
        g_nScrollPos = 0;

    if (nScrollPos >= (int)g_nCurSize)
        g_nScrollPos = g_nCurSize - 1;
}

/*++
 *  Function:
 *      _ClickOnGlyph
 *  Description:
 *      When the mouse click on glyph a dialog
 *      pops up offering adding the glyph to the database
 *  Arguments:
 *      hWnd        - client window handle
 *      xPos,yPos   - location where the mouse was clicked
 *  Called by:
 *      _GlyphSpyWndProc on WM_LBUTTONDOWN
 --*/
VOID _ClickOnGlyph(HWND hWnd, UINT xPos, UINT yPos)
{
    UINT X0 = 0;
    UINT  nPointed;
    BMPENTRY    Bitmap;

    for(nPointed = g_nScrollPos; nPointed < g_nCurSize && X0 < yPos; nPointed++)
        X0 += g_Bmp[nPointed].ySize;

    nPointed --;
    if (X0 > yPos && xPos <= (UINT)g_Bmp[nPointed].xSize)
    {
        memset(&Bitmap, 0, sizeof(Bitmap));

        Bitmap.nDataSize = g_Bmp[nPointed].nDataSize;
        Bitmap.bmiSize = g_Bmp[nPointed].bmiSize;
        Bitmap.bmpSize = g_Bmp[nPointed].bmpSize;
        Bitmap.xSize = g_Bmp[nPointed].xSize;
        Bitmap.ySize = g_Bmp[nPointed].ySize;
        Bitmap.pData = malloc(Bitmap.nDataSize);

        if (!Bitmap.pData)
            goto exitpt;

        memcpy(Bitmap.pData, g_Bmp[nPointed].pData, Bitmap.nDataSize);

        if (!Bitmap.bmiSize)
            // Monochrome bitmap
            Bitmap.hBitmap = CreateBitmap(
                            Bitmap.xSize,
                            Bitmap.ySize,
                            1, 1,
                            Bitmap.pData);
        else {
            HDC hDC = GetDC(g_hMainWindow);

            if ( hDC )
            {
                Bitmap.hBitmap =
                    CreateDIBitmap(hDC,
                               (BITMAPINFOHEADER *)
                               Bitmap.pData,
                               CBM_INIT,
                               ((BYTE *)(Bitmap.pData)) + Bitmap.bmiSize,
                               (BITMAPINFO *)
                               Bitmap.pData,
                               DIB_PAL_COLORS);

                ReleaseDC(g_hMainWindow, hDC);
            }
        }

        if (!Bitmap.hBitmap)
        {
            free(Bitmap.pData);
            goto exitpt;
        }

        // Open dialog for adding
        AddBitmapDialog(g_hInstance, hWnd, &Bitmap);

        DeleteObject(Bitmap.hBitmap);
        free(Bitmap.pData);
    }

exitpt:
    ;
}

/*++
 *  Function:
 *      _GlyphSpyWndProc
 *  Description:
 *      Dispatches the messages for glyphspy window
 *  Arguments:
 *      hWnd        - window handle
 *      uiMessage   - message id
 *      wParam, lParam - parameters
 *  Return value:
 *      0 - message is processed
 --*/
LRESULT CALLBACK _GlyphSpyWndProc( HWND hWnd,
                                   UINT uiMessage,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    LRESULT rv = 0;

    switch(uiMessage)
    {
    case WM_CREATE:
        OpenDB(TRUE);       // Open glyph DB for Read/Write
    break;

    case WM_FB_GLYPHOUT:
        _GetBitmap((DWORD)wParam, (HANDLE)lParam);

        // Set scroll range
        if (g_nCurSize)
            SetScrollRange(hWnd, SB_VERT, 0, g_nCurSize - 1, TRUE);
        // Repaint the window
        InvalidateRect(hWnd, NULL, TRUE);
    break;

    case WM_FB_ACCEPTME:
        if ((DWORD)lParam == g_pidRDP)
            rv = 1;
    break;
    
    case WM_FB_DISCONNECT:
        _CloseClient();
        break;

    case WM_PAINT:
        _RepaintWindow(hWnd);
    break;

    case WM_VSCROLL:
        _SetVScroll((int) LOWORD(wParam), (short int) HIWORD(wParam));
        SetScrollPos(hWnd, SB_VERT, g_nScrollPos, TRUE);
        InvalidateRect(hWnd, NULL, TRUE);
    break;

    case WM_LBUTTONDOWN:
        _ClickOnGlyph(hWnd, LOWORD(lParam), HIWORD(lParam));
    break;

    case WM_MOUSEWHEEL:
        if (((short)HIWORD(wParam)) > 0)
            _SetVScroll(SB_PAGEUP, 0);
        else
            _SetVScroll(SB_PAGEDOWN, 0);

        SetScrollPos(hWnd, SB_VERT, g_nScrollPos, TRUE);
        InvalidateRect(hWnd, NULL, TRUE);
    break;

    case WM_COMMAND:
        switch (wParam)
        {
        case ID_YEAH_START:
            if (!_StartClient())
            {
                if (MessageBox(hWnd, 
                        "RDP Client is already started. "
                        "Do you wish to start another ?", 
                        "Warning", MB_YESNO) == IDYES)
                {
                    _CloseClient();
                    _StartClient();
                }
            }
            break;
        case ID_YEAH_BROWSE:
            BrowseBitmapsDialog(g_hInstance, hWnd);
            break;
        }
    break;

    case WM_CLOSE:
        _FreeHistList();
        CloseDB();                  // Close the glyph DB
        PostQuitMessage(0);
    break;

    default:
        rv = DefWindowProc(hWnd, uiMessage, wParam, lParam);
    }

    return rv;
}

/*++
 *  Function:
 *      _CreateMYWindow
 *  Description:
 *      Creates glyphspy client window
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      WinMain
 --*/
BOOL _CreateMYWindow(void)
{
    WNDCLASS wc;
    BOOL rv = TRUE;

//    if (!g_hPrevInstance)
    {
        memset(&wc, 0, sizeof(wc));

        // Main window classname
        wc.style            = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc      = _GlyphSpyWndProc;
        wc.hInstance        = g_hInstance;
        wc.lpszClassName    = _TSTNAMEOFCLAS;
        wc.hIcon            = LoadIcon(g_hInstance, IDI_APPLICATION);
        wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
        wc.lpszMenuName     = MAKEINTRESOURCE(IDR_MENU1);
        wc.hbrBackground    = GetStockObject(WHITE_BRUSH);

        if (!RegisterClass (&wc))
        {
            rv = FALSE;
            goto exitpt;
        }
    }
    g_hMainWindow = CreateWindow(
                    _TSTNAMEOFCLAS,
                    "GlyphSpy",            // Window name
                    WS_OVERLAPPEDWINDOW|WS_VSCROLL,    // dwStyle
                    CW_USEDEFAULT,          // x
                    CW_USEDEFAULT,          // y
                    CW_USEDEFAULT,          // nWidth
                    CW_USEDEFAULT,          // nHeight
                    HWND_DESKTOP,           // hWndParent
                    NULL,                   // hMenu
                    g_hInstance,
                    NULL);                  // lpParam

    if (!g_hMainWindow)
        rv = FALSE;

    SetScrollRange(g_hMainWindow, SB_VERT, 0, 0, FALSE);

    ShowWindow(g_hMainWindow, SW_SHOW);
    UpdateWindow(g_hMainWindow);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      WinMain
 *  Description:
 *      Startup function
 --*/
int
WINAPI
WinMain(HINSTANCE hInstance,
        HINSTANCE hPrevInst,
        LPSTR     lpszCmdLine,
        int       nCmdShow)
{
    MSG msg;

    g_hInstance = hInstance;
    g_hPrevInstance = hInstance;
    
    if (!_CreateMYWindow())
        goto exitpt;


    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage (&msg);
        DispatchMessage (&msg);
    }

exitpt:
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\clntdata.h ===
/*++
 *  File name:
 *      clntdata.h
 *  Contents:
 *      RDP client specific definitions
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 *
 --*/

#ifndef _CLNTDATA_H
#define _CLNTDATA_H

#ifdef  OS_WIN16
#define _TEXTSMC(_x_)      _x_
#else   // !OS_WIN16
#define _TEXTSMC(_x_)     L##_x_
#endif  // !OS_WIN16

// Default vals of various string we are waiting for
#define RUN_MENU                _TEXTSMC("Shut Down...")
#define START_LOGOFF            _TEXTSMC("\\p\\p\\p\\72\\*72\\72\\*72\\72\\*72\\n")
#define RUN_ACT                 _TEXTSMC("r")
#define RUN_BOX                 _TEXTSMC("Type the name of a program")
#define WINLOGON_USERNAME       _TEXTSMC("Options <<")
#define WINLOGON_ACT            _TEXTSMC("\\&u\\&")
#define PRIOR_WINLOGON          _TEXTSMC("Options >>")
#define PRIOR_WINLOGON_ACT      _TEXTSMC("\\&o\\&")
#define WINDOWS_NT_SECURITY     _TEXTSMC("Windows NT Security")
#define WINDOWS_NT_SECURITY_ACT _TEXTSMC("l")
#define ARE_YOU_SURE            _TEXTSMC("Are you sure")
#define SURE_LOGOFF_ACT         _TEXTSMC("\\n")
#define LOGON_ERROR_MESSAGE     _TEXTSMC("\\n")
#define LOGON_DISABLED_MESSAGE  _TEXTSMC("Terminal Server Sessions Disabled")

// This string is in RegisterChat only. English version only
// OBSELETE.
#define LOGOFF_COMMAND          _TEXTSMC("logoff")

#define REG_BASE    "SOFTWARE\\Microsoft\\Terminal Server Client"
#define REG_DEFAULT "SOFTWARE\\Microsoft\\Terminal Server Client\\Default"
#define ALLOW_BACKGROUND_INPUT  "Allow Background Input"

#define NAME_MAINCLASS      "UIMainClass"       // Clients main window class
#define NAME_CONTAINERCLASS "UIContainerClass"
#define NAME_INPUT          "IHWindowClass"     // IH (InputHalndle) class name
#define NAME_OUTPUT         "OPWindowClass"     // OP (OutputRequestor) 
                                                // class name
#define CLIENT_CAPTION      "Terminal Services Client"    
                                                // clients caption
#define CONNECT_CAPTION     "Connect"           // Connect button
#define DISCONNECT_DIALOG_BOX   "Terminal Services Client Disconnected"
                                                // Caption of the box when
                                                // the client is disconnected
#define STATIC_CLASS        "Static"
#define BUTTON_CLASS        "Button"
#define YES_NO_SHUTDOWN     "Disconnect Windows session"
#define FATAL_ERROR_5       "Fatal Error (Error Code: 5)"
                                                // Caption of disconnect box

#define CLIENT_EXE          "mstsc.exe"         // Client executable

#endif  // _CLNTDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\bmpcache.c ===
/*++
 *  File name:
 *      bmpcache.c
 *  Contents:
 *      Bitmap cache interface for tclinet
 *      Bitmap compare code
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/
#include    <windows.h>
#include    <memory.h>

#include    "protocol.h"
#include    "tclient.h"
#include    "gdata.h"
#include    "bmpdb.h"

PGROUPENTRY g_pCache = NULL;

// The bitmap manager is not thread safe
#define ENTER_CRIT  EnterCriticalSection(g_lpcsGuardWaitQueue);
#define LEAVE_CRIT  LeaveCriticalSection(g_lpcsGuardWaitQueue);

/*++
 *  Function:
 *      InitCache
 *  Description:
 *      Inits global data and the cache manager
 *  Called by:
 *      InitDone
 --*/
VOID InitCache(VOID)
{
    ENTER_CRIT
    OpenDB(FALSE);
    g_pCache = GetGroupList();
    LEAVE_CRIT
}

/*++
 *  Function:
 *      DeleteCache
 *  Description:
 *      Deletes all linked lists and closes the manager opened
 *      by InitCache
 *  Called by:
 *      InitDone
 --*/
VOID DeleteCache(VOID)
{
    PGROUPENTRY pIter;

    ENTER_CRIT

    // Clean the cache
    pIter = g_pCache;
    while(pIter)
    {
        FreeBitmapList(pIter->pBitmap);
        pIter = pIter->pNext;
    }
    FreeGroupList(g_pCache);
    g_pCache = NULL;
    CloseDB();

    LEAVE_CRIT
}

/*++
 *  Function:
 *      BitmapCacheLookup
 *  Description:
 *      Retrieves all bitmaps with specific ID
 --*/
PBMPENTRY   BitmapCacheLookup(LPCWSTR szWText)
{
    PGROUPENTRY pIter;
    PBMPENTRY   rv = NULL;
    FOFFSET     lGrpOffs;

    ENTER_CRIT

    pIter = g_pCache;
    while(pIter && wcscmp(pIter->WText, szWText))
    {
        pIter = pIter->pNext;
    }
    
    if (!pIter)
        goto exitpt;

    if (!pIter->pBitmap)
        pIter->pBitmap = GetBitmapList(NULL, pIter->FOffsBmp);

    rv = pIter->pBitmap;

exitpt:
    LEAVE_CRIT
    return rv;
}

/*++
 *  Function:
 *      Glyph2String
 *  Description:
 *      Gets the ID for matching bimtap
 *  Arguments:
 *      pBmpFeed    - Bitmap
 *      wszString   - buffer for the ID
 *      max         - buffer length
 *  Return value:
 *      TRUE if matching bitmap is found
 *  Called by:
 *      GlyphReceived running within feedback thread
 --*/
BOOL    Glyph2String(PBMPFEEDBACK pBmpFeed, LPWSTR wszString, UINT max)
{
    UINT        nChkSum, nFeedSize;
    PGROUPENTRY pGroup;
    PBMPENTRY   pBitmap;
    BOOL        rv = FALSE;

    nFeedSize = pBmpFeed->bmpsize + pBmpFeed->bmiSize;
    nChkSum = CheckSum(&(pBmpFeed->BitmapInfo), nFeedSize);

    ENTER_CRIT

    pGroup = g_pCache;
    // Go thru all groups
    while (pGroup)
    {
        pBitmap = pGroup->pBitmap;
        if (!pBitmap)
            // Read the bitmap list if necessesary
            pBitmap = pGroup->pBitmap = GetBitmapList(NULL, pGroup->FOffsBmp);

        // and bitmaps
        while(pBitmap)
        {
            // Compare the bitmaps
            if (pBitmap->nChkSum  == nChkSum &&
                pBitmap->xSize    == pBmpFeed->xSize && 
                pBitmap->ySize    == pBmpFeed->ySize &&
                pBitmap->bmiSize  == pBmpFeed->bmiSize &&
                pBitmap->bmpSize  == pBmpFeed->bmpsize &&
                !memcmp(pBitmap->pData, &(pBmpFeed->BitmapInfo), nFeedSize))
            {
                // OK, copy the string

                UINT strl = wcslen(pGroup->WText);

                if (strl > max - 1)
                    strl = max - 1;

                wcsncpy(wszString, pGroup->WText, strl);
                wszString[strl] = 0;
                rv = TRUE;
                goto exitpt;
            }
            pBitmap = pBitmap->pNext;
        }

        pGroup = pGroup->pNext;
    }

exitpt:
    LEAVE_CRIT
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\clputil.c ===
/*++
 *  File name:
 *
 *  Contents:
 *      Clipboard functions
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/
#include    <windows.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <io.h>
#include    <fcntl.h>
#include    <sys/stat.h>

#ifdef	_CLPUTIL
enum {ERROR_MESSAGE = 0, WARNING_MESSAGE, INFO_MESSAGE, ALIVE_MESSAGE};
#define	TRACE(_x_)	LocalPrintMessage _x_
#else	// !_CLPUTIL

#include    "protocol.h"
/*
 *  Externals
 */
extern void (__cdecl *g_pfnPrintMessage) (INT, LPCSTR, ...);

#define TRACE(_x_)  if (g_pfnPrintMessage) {\
                        g_pfnPrintMessage(INFO_MESSAGE, "Worker:%d ", GetCurrentThreadId());\
                        g_pfnPrintMessage _x_; }

#endif	// !_CLPUTIL


typedef struct _CLIPBOARDFORMATS {
    UINT    uiFormat;
    LPCSTR  szFormat;
} CLIPBOARDFORMATS, *PCLIPBOARDFORMATS;

const CLIPBOARDFORMATS KnownFormats[] =
{
{CF_TEXT,       "Text"},
{CF_BITMAP,     "Bitmap"},
{CF_METAFILEPICT, "MetaFile"},
{CF_SYLK,       "Sylk"},
{CF_DIF,        "DIF"},
{CF_TIFF,       "TIFF"},
{CF_OEMTEXT,    "OEMText"},
{CF_DIB,        "DIB"},
{CF_PALETTE,    "Palette"},
{CF_PENDATA,    "PenData"},
{CF_RIFF,       "Riff"},
{CF_WAVE,       "Wave"},
{CF_UNICODETEXT,"Unicode"},
{CF_ENHMETAFILE,"ENHMetafile"},
{CF_HDROP,      "HDROP"},
{CF_LOCALE,     "Locale"},
{CF_DIBV5,      "DIBV5"}
};

typedef struct {
    UINT32  mm;
    UINT32  xExt;
    UINT32  yExt;
} CLIPBOARD_MFPICT, *PCLIPBOARD_MFPICT;

/*
 *  Clipboard functions definitions
 */
VOID
Clp_ListAllFormats(VOID);

//VOID
//Clp_ListAllAvailableFormats(VOID);

UINT
Clp_GetClipboardFormat(CHAR *szFormatLookup);

VOID
Clp_PutIntoClipboard(CHAR *g_szFileName);

VOID
Clp_GetClipboardData(
    UINT format,
    HGLOBAL hClipData,
    INT *pnClipDataSize,
    HGLOBAL *phNewData);

BOOL
Clp_SetClipboardData(
    UINT formatID, 
    HGLOBAL hClipData, 
    INT nClipDataSize,
    BOOL *pbFreeHandle);

HGLOBAL 
Clp_GetMFData(HANDLE   hData,
              PUINT     pDataLen);

HGLOBAL 
Clp_SetMFData(UINT   dataLen,
              PVOID  pData);

VOID
_cdecl LocalPrintMessage(INT errlevel, CHAR *format, ...);

VOID
Clp_ListAllFormats(VOID)
{
    UINT format = 0;
    CHAR szFormatName[_MAX_PATH];

    while ((format = EnumClipboardFormats(format)))
    {
        *szFormatName = 0;
        GetClipboardFormatName(format, szFormatName, _MAX_PATH);

        if (!(*szFormatName))
        // No format, check for known format
        {
            INT fmti, fmtnum;

            fmtnum = sizeof(KnownFormats)/sizeof(KnownFormats[0]);
            for (fmti = 0; 
                    KnownFormats[fmti].uiFormat != format
                 && 
                    fmti < fmtnum;
                 fmti ++);

            if (fmti < fmtnum)
                strcpy(szFormatName, KnownFormats[fmti].szFormat);
        }

        if (*szFormatName)
        {
            TRACE((INFO_MESSAGE, "%s[%d(0x%X)]\n", szFormatName, format, format));
        } else {
            TRACE((ERROR_MESSAGE, "Can't find format name for: 0x%x\n", format));
        }
    }
}
/*
VOID
Clp_ListAllAvailableFormats(VOID)
{
    UINT format = 0;
    CHAR szFormatName[_MAX_PATH];

    while ((format = EnumClipboardFormats(format)))
    {
        if (!IsClipboardFormatAvailable(format))
        // Skip the unavalable formats
            continue;
        
        *szFormatName = 0;
        GetClipboardFormatName(format, szFormatName, _MAX_PATH);

        if (!(*szFormatName))
        // No format, check for known format
        {
            INT fmti, fmtnum;

            fmtnum = sizeof(KnownFormats)/sizeof(KnownFormats[0]);
            for (fmti = 0;
                    KnownFormats[fmti].uiFormat != format
                 &&
                    fmti < fmtnum;
                 fmti ++);

            if (fmti < fmtnum)
                strcpy(szFormatName, KnownFormats[fmti].szFormat);
        }

        if (*szFormatName)
            TRACE((INFO_MESSAGE, "%s\n", szFormatName));
        else
            TRACE((ERROR_MESSAGE, "Can't find format name for: 0x%x\n", format));
    }
}
*/
UINT
Clp_GetClipboardFormat(CHAR *szFormatLookup)
// Returns the clipboard ID
{
    UINT format = 0;
    CHAR szFormatName[_MAX_PATH];
    BOOL bFound = FALSE;

    *szFormatName = 0;
    while (!bFound && (format = EnumClipboardFormats(format)))
    {
        if (!IsClipboardFormatAvailable(format))
        // Skip the unavalable formats
            continue;

        *szFormatName = 0;
        GetClipboardFormatName(format, szFormatName, _MAX_PATH);

        if (!(*szFormatName))
        // No format, check for known format
        {
            INT fmti, fmtnum;

            fmtnum = sizeof(KnownFormats)/sizeof(KnownFormats[0]);
            for (fmti = 0;
                    KnownFormats[fmti].uiFormat != format
                 &&
                    fmti < fmtnum;
                 fmti ++);

            if (fmti < fmtnum)
                strcpy(szFormatName, KnownFormats[fmti].szFormat);
        }
        bFound = (_stricmp(szFormatName, szFormatLookup) == 0); 
    }

    return format;
}

VOID
Clp_PutIntoClipboard(CHAR *szFileName)
{
    INT     hFile = -1;
    LONG    clplength = 0;
    UINT    uiFormat = 0;
    HGLOBAL ghClipData = NULL;
    PBYTE   pClipData = NULL;
    BOOL    bClipboardOpen = FALSE;
    BOOL    bFreeClipHandle = TRUE;

    hFile = _open(szFileName, _O_RDONLY|_O_BINARY);
    if (hFile == -1)
    {
        TRACE((ERROR_MESSAGE, "Error opening file: %s. errno=%d\n", szFileName, errno));
        goto exitpt;
    }

    clplength = _filelength(hFile) - sizeof(uiFormat);
    if (_read(hFile, &uiFormat, sizeof(uiFormat)) != sizeof(uiFormat))
    {
        TRACE((ERROR_MESSAGE, "Error reading from file. errno=%d\n", errno));
        goto exitpt;
    }

    ghClipData = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, clplength);
    if (!ghClipData)
    {
        TRACE((ERROR_MESSAGE, "Can't allocate %d bytes\n", clplength));
        goto exitpt;
    }

    pClipData = GlobalLock(ghClipData);
    if (!pClipData)
    {
        TRACE((ERROR_MESSAGE, "Can't lock handle 0x%x\n", ghClipData));
        goto exitpt;
    }

    if (_read(hFile, pClipData, clplength) != clplength)
    {
        TRACE((ERROR_MESSAGE, "Error reading from file. errno=%d\n", errno));
        goto exitpt;
    }

    GlobalUnlock(ghClipData);

    if (!OpenClipboard(NULL))
    {
        TRACE((ERROR_MESSAGE, "Can't open the clipboard. GetLastError=%d\n",
                GetLastError()));
        goto exitpt;
    }

    bClipboardOpen = TRUE;

    // Empty the clipboard, so we'll have only one entry
    EmptyClipboard();

    if (!Clp_SetClipboardData(uiFormat, ghClipData, clplength, &bFreeClipHandle))
    {
        TRACE((ERROR_MESSAGE, "SetClipboardData failed.\n"));
    } else {
        TRACE((INFO_MESSAGE, "Clipboard is loaded successfuly. File: %s, %d bytes\n",
                szFileName,
                clplength));
    }


exitpt:
    // Do the cleanup

    // Close the clipboard
    if (bClipboardOpen)
        CloseClipboard();

    // Release the clipboard handle
    if (pClipData)
        GlobalUnlock(ghClipData);

    if (ghClipData && bFreeClipHandle)
        GlobalFree(ghClipData);

    // Close the file
    if (hFile != -1)
        _close(hFile);
}

VOID
Clp_GetClipboardData(
    UINT format, 
    HGLOBAL hClipData, 
    INT *pnClipDataSize, 
    HGLOBAL *phNewData)
{
    HGLOBAL hData   = hClipData;
    DWORD   dataLen = 0;
    WORD    numEntries;
    DWORD   dwEntries;
    PVOID   pData;

    *phNewData = NULL;
    *pnClipDataSize = 0;
    if (format == CF_PALETTE)
    {
        /****************************************************************/
        /* Find out how many entries there are in the palette and       */
        /* allocate enough memory to hold them all.                     */
        /****************************************************************/
        if (GetObject(hData, sizeof(numEntries), (LPSTR)&numEntries) == 0)
        {
            numEntries = 256;
        }

        dataLen = sizeof(LOGPALETTE) +
                               ((numEntries - 1) * sizeof(PALETTEENTRY));

        *phNewData = GlobalAlloc(GHND, dataLen);
        if (*phNewData == 0)
        {
            TRACE((ERROR_MESSAGE, "Failed to get %d bytes for palette", dataLen));
            goto exitpt;
        }
        else
        {
            /************************************************************/
            /* now get the palette entries into the new buffer          */
            /************************************************************/
            pData = GlobalLock(*phNewData);
            dwEntries = (WORD)GetPaletteEntries((HPALETTE)hData,
                                           0,
                                           numEntries,
                                           (PALETTEENTRY*)pData);
            GlobalUnlock(*phNewData);
            if (dwEntries == 0)
            {
                TRACE((ERROR_MESSAGE, "Failed to get any palette entries"));
                goto exitpt;
            }
            dataLen = dwEntries * sizeof(PALETTEENTRY);

        }
    } else if (format == CF_METAFILEPICT)
    {
        *phNewData = Clp_GetMFData(hData, &dataLen);
        if (!*phNewData)
        {
            TRACE((ERROR_MESSAGE, "Failed to set MF data"));
            goto exitpt;
        }
    } else {
        if (format == CF_DIB)
        {
            // Get the exact DIB size
            BITMAPINFOHEADER *pBMI = GlobalLock(hData);

            if (pBMI)
            {
                if (pBMI->biSizeImage)
                    dataLen = pBMI->biSize + pBMI->biSizeImage;
                GlobalUnlock(hData);
            }
        }

        /****************************************************************/
        /* just get the length of the block                             */
        /****************************************************************/
        if (!dataLen)
            dataLen = (DWORD)GlobalSize(hData);
    }

    *pnClipDataSize = dataLen;

exitpt:
    ;
}

BOOL
Clp_SetClipboardData(
    UINT formatID,
    HGLOBAL hClipData,
    INT nClipDataSize,
    BOOL *pbFreeHandle)
{
    BOOL            rv = FALSE;
    PVOID           pData = NULL;
    HGLOBAL         hData = NULL;
    LOGPALETTE      *pLogPalette = NULL;
    UINT            numEntries, memLen;

    if (!pbFreeHandle)
        goto exitpt;

    *pbFreeHandle = TRUE;

    if (formatID == CF_METAFILEPICT)
    {
        /********************************************************************/
        /* We have to put a handle to the metafile on the clipboard - which */
        /* means creating a metafile from the received data first           */
        /********************************************************************/
        pData = GlobalLock(hClipData);
        if (!pData)
        {
            TRACE((ERROR_MESSAGE, "Failed to lock buffer\n"));
            goto exitpt;
        }

        hData = Clp_SetMFData(nClipDataSize, pData);
        if (!hData)
        {
            TRACE((ERROR_MESSAGE, "Failed to set MF data\n"));
        }
        else if (SetClipboardData(formatID, hData) != hData)
        {
            TRACE((ERROR_MESSAGE, "SetClipboardData. GetLastError=%d\n", GetLastError()));
        }

        GlobalUnlock(hClipData);

    } else if (formatID == CF_PALETTE)
    {
        /********************************************************************/
        /* We have to put a handle to the palette on the clipboard - again  */
        /* this means creating one from the received data first             */
        /*                                                                  */
        /* Allocate memory for a LOGPALETTE structure large enough to hold  */
        /* all the PALETTE ENTRY structures, and fill it in.                */
        /********************************************************************/
        numEntries = (nClipDataSize / sizeof(PALETTEENTRY));
        memLen     = (sizeof(LOGPALETTE) +
                                   ((numEntries - 1) * sizeof(PALETTEENTRY)));
        pLogPalette = malloc(memLen);
        if (!pLogPalette)
        {
            TRACE((ERROR_MESSAGE, "Failed to get %d bytes", memLen));
            goto exitpt;
        }

        pLogPalette->palVersion    = 0x300;
        pLogPalette->palNumEntries = (WORD)numEntries;

        /********************************************************************/
        /* get a pointer to the data and copy it to the palette             */
        /********************************************************************/
        pData = GlobalLock(hClipData);
        if (pData == NULL)
        {
            TRACE((ERROR_MESSAGE, "Failed to lock buffer"));
            goto exitpt;
        }
        memcpy(pLogPalette->palPalEntry, pData, nClipDataSize);

        /********************************************************************/
        /* unlock the buffer                                                */
        /********************************************************************/
        GlobalUnlock(hClipData);

        /********************************************************************/
        /* now create a palette                                             */
        /********************************************************************/
        hData = CreatePalette(pLogPalette);
        if (!hData)
        {
            TRACE((ERROR_MESSAGE, "CreatePalette failed\n"));
            goto exitpt;
        }

        /********************************************************************/
        /* and set the palette handle to the Clipboard                      */
        /********************************************************************/
        if (SetClipboardData(formatID, hData) != hData)
        {
            TRACE((ERROR_MESSAGE, "SetClipboardData. GetLastError=%d\n", GetLastError()));
        }
    } else {
        /****************************************************************/
        /* Just set it onto the clipboard                               */
        /****************************************************************/
        if (SetClipboardData(formatID, hClipData) != hClipData)
        {
            TRACE((ERROR_MESSAGE, "SetClipboardData. GetLastError=%d, hClipData=0x%x\n", GetLastError(), hClipData));
            goto exitpt;
        }

        // Only in this case we don't need to free the handle
        *pbFreeHandle = FALSE;

    }

    rv = TRUE;

exitpt:
    if (!pLogPalette)
    {
        free(pLogPalette);
    }

    return rv;
}

HGLOBAL Clp_GetMFData(HANDLE   hData,
                     PUINT     pDataLen)
{
    UINT            lenMFBits = 0;
    BOOL            rc        = FALSE;
    LPMETAFILEPICT  pMFP      = NULL;
    HDC             hMFDC     = NULL;
    HMETAFILE       hMF       = NULL;
    HGLOBAL         hMFBits   = NULL;
    HANDLE          hNewData  = NULL;
    CHAR            *pNewData  = NULL;
    PVOID           pBits     = NULL;

    /************************************************************************/
    /* Lock the memory to get a pointer to a METAFILEPICT header structure  */
    /* and create a METAFILEPICT DC.                                        */
    /************************************************************************/
    pMFP = (LPMETAFILEPICT)GlobalLock(hData);
    if (pMFP == NULL)
        goto exitpt;

    hMFDC = CreateMetaFile(NULL);
    if (hMFDC == NULL)
        goto exitpt;

    /************************************************************************/
    /* Copy the MFP by playing it into the DC and closing it.               */
    /************************************************************************/
    if (!PlayMetaFile(hMFDC, pMFP->hMF))
    {
        CloseMetaFile(hMFDC);
        goto exitpt;
    }
    hMF = CloseMetaFile(hMFDC);
    if (hMF == NULL)
        goto exitpt;

    /************************************************************************/
    /* Get the MF bits and determine how long they are.                     */
    /************************************************************************/
#ifdef OS_WIN16
    hMFBits   = GetMetaFileBits(hMF);
    lenMFBits = GlobalSize(hMFBits);
#else
    lenMFBits = GetMetaFileBitsEx(hMF, 0, NULL);
#endif
    if (lenMFBits == 0)
        goto exitpt;

    /************************************************************************/
    /* Work out how much memory we need and get a buffer                    */
    /************************************************************************/
    *pDataLen = sizeof(CLIPBOARD_MFPICT) + lenMFBits;
    hNewData = GlobalAlloc(GHND, *pDataLen);
    if (hNewData == NULL)
        goto exitpt;

    pNewData = GlobalLock(hNewData);

    /************************************************************************/
    /* Copy the MF header and bits into the buffer.                         */
    /************************************************************************/
    ((PCLIPBOARD_MFPICT)pNewData)->mm   = pMFP->mm;
    ((PCLIPBOARD_MFPICT)pNewData)->xExt = pMFP->xExt;
    ((PCLIPBOARD_MFPICT)pNewData)->yExt = pMFP->yExt;

#ifdef OS_WIN16
    pBits = GlobalLock(hMFBits);
    memcpy((pNewData + sizeof(CLIPBOARD_MFPICT)),
              pBits,
              lenMFBits);
    GlobalUnlock(hMFBits);
#else
    lenMFBits = GetMetaFileBitsEx(hMF, lenMFBits,
                                  (pNewData + sizeof(CLIPBOARD_MFPICT)));
    if (lenMFBits == 0)
        goto exitpt;
#endif

    /************************************************************************/
    /* all OK                                                               */
    /************************************************************************/
    rc = TRUE;

exitpt:
    /************************************************************************/
    /* Unlock any global mem.                                               */
    /************************************************************************/
    if (pMFP)
    {
        GlobalUnlock(hData);
    }
    if (pNewData)
    {
        GlobalUnlock(hNewData);
    }

    /************************************************************************/
    /* if things went wrong, then free the new data                         */
    /************************************************************************/
    if ((rc == FALSE) && (hNewData != NULL))
    {
        GlobalFree(hNewData);
        hNewData = NULL;
    }

    return(hNewData);

}


HGLOBAL Clp_SetMFData(UINT   dataLen,
                      PVOID  pData)
{
    BOOL           rc           = FALSE;
    HGLOBAL        hMFBits      = NULL;
    PVOID          pMFMem       = NULL;
    HMETAFILE      hMF          = NULL;
    HGLOBAL        hMFPict      = NULL;
    LPMETAFILEPICT pMFPict      = NULL;

    /************************************************************************/
    /* Allocate memory to hold the MF bits (we need the handle to pass to   */
    /* SetMetaFileBits).                                                    */
    /************************************************************************/
    hMFBits = GlobalAlloc(GHND, dataLen - sizeof(CLIPBOARD_MFPICT));
    if (hMFBits == NULL)
        goto exitpt;

    /************************************************************************/
    /* Lock the handle and copy in the MF header.                           */
    /************************************************************************/
    pMFMem = GlobalLock(hMFBits);
    if (pMFMem == NULL)
        goto exitpt;

    memcpy(pMFMem,
           (PVOID)((CHAR *)pData + sizeof(CLIPBOARD_MFPICT)),
               dataLen - sizeof(CLIPBOARD_MFPICT) );

    GlobalUnlock(hMFBits);

    /************************************************************************/
    /* Now use the copied MF bits to create the actual MF bits and get a    */
    /* handle to the MF.                                                    */
    /************************************************************************/
#ifdef OS_WIN16
    hMF = SetMetaFileBits(hMFBits);
#else
    hMF = SetMetaFileBitsEx(dataLen - sizeof(CLIPBOARD_MFPICT), pMFMem);
#endif
    if (hMF == NULL)
        goto exitpt;

    /************************************************************************/
    /* Allocate a new METAFILEPICT structure, and use the data from the     */
    /* header.                                                              */
    /************************************************************************/
    hMFPict = GlobalAlloc(GHND, sizeof(METAFILEPICT));
    pMFPict = (LPMETAFILEPICT)GlobalLock(hMFPict);
    if (!pMFPict)
        goto exitpt;

    pMFPict->mm   = (long)((PCLIPBOARD_MFPICT)pData)->mm;
    pMFPict->xExt = (long)((PCLIPBOARD_MFPICT)pData)->xExt;
    pMFPict->yExt = (long)((PCLIPBOARD_MFPICT)pData)->yExt;
    pMFPict->hMF  = hMF;

    GlobalUnlock(hMFPict);

    rc = TRUE;

exitpt:
    /************************************************************************/
    /* tidy up                                                              */
    /************************************************************************/
    if (!rc)
    {
        if (hMFPict)
        {
            GlobalFree(hMFPict);
        }
        if (hMFBits)
        {
            GlobalFree(hMFBits);
        }
    }

    return(hMFPict);

}

BOOL
Clp_EmptyClipboard(VOID)
{
    BOOL rv = FALSE;

    if (OpenClipboard(NULL))
    {
        EmptyClipboard();
        rv = TRUE;
        CloseClipboard();
    }

    return rv;
}

BOOL
Clp_CheckEmptyClipboard(VOID)
{
    BOOL rv = TRUE;

    if (OpenClipboard(NULL))
    {
        if (EnumClipboardFormats(0))
        // format is available, not empty
            rv = FALSE;
        CloseClipboard();
    }

    return rv;
}

// Checks for known format names and returns it's ID
UINT
_GetKnownClipboardFormatIDByName(LPCSTR szFormatName)
{
    INT     fmti, fmtnum;
    UINT    rv = 0;

    fmtnum = sizeof(KnownFormats)/sizeof(KnownFormats[0]);
    for (fmti = 0;
            fmti < fmtnum
         && 
            _stricmp(szFormatName, KnownFormats[fmti].szFormat);
         fmti ++)
        ;

    if (fmti < fmtnum)
        rv = KnownFormats[fmti].uiFormat;

    return rv;
}

VOID
_cdecl LocalPrintMessage(INT errlevel, CHAR *format, ...)
{
    CHAR szBuffer[256];
    CHAR *type;
    va_list     arglist;
    INT nchr;

    va_start (arglist, format);
    nchr = _vsnprintf (szBuffer, sizeof(szBuffer), format, arglist);
    va_end (arglist);

    switch(errlevel)
    {
    case INFO_MESSAGE: type = "INF"; break;
    case ALIVE_MESSAGE: type = "ALV"; break;
    case WARNING_MESSAGE: type = "WRN"; break;
    case ERROR_MESSAGE: type = "ERR"; break;
    default: type = "UNKNOWN";
    }

    printf("%s:%s", type, szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\extraexp.h ===
/*++
 *  File name:
 *
 *  Contents:
 *      Extra functions exported by tclient.dll
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#ifndef PROTOCOLAPI
#define PROTOCOLAPI __declspec(dllimport)
#endif

#define TSFLAG_COMPRESSION  1
#define TSFLAG_BITMAPCACHE  2
#define TSFLAG_FULLSCREEN   4

PROTOCOLAPI
LPCSTR 
SMCAPI 
SCConnectEx(
        LPCWSTR  lpszServerName,
        LPCWSTR  lpszUserName,
        LPCWSTR  lpszPassword,
        LPCWSTR  lpszDomain,
        LPCWSTR  lpszShell,
        INT      xRes,
        INT      yRes,
        INT      ConnectionFlags,
        PVOID    *ppCI);

PROTOCOLAPI
LPCSTR 
SMCAPI 
SCCheck(
        PVOID ConnectionInfo, 
        LPCSTR szCmd, 
        LPCWSTR szwParam
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCSendtextAsMsgs(
        PVOID ConnectionInfo, 
        LPCWSTR szLine
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCSaveClipboard(
        PVOID ConnectionInfo,
        LPCSTR szFormatName,
        LPCSTR szFileName
        );

PROTOCOLAPI
BOOL   
SMCAPI  
SCIsDead(
        PVOID pCI
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCClientTerminate(
        PVOID pCI
        );

/* ASCII versions */

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCConnectA (
        CHAR *lpszServerName,
        CHAR *lpszUserName,
        CHAR *lpszPassword,
        CHAR *lpszDomain,
        INT  xResolution,
        INT  yResolution,
        PVOID *ppConnectData
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCConnectExA (
        CHAR *lpszServerName,
        CHAR *lpszUserName,
        CHAR *lpszPassword,
        CHAR *lpszDomain,
        CHAR *lpszShell,
        INT  xResolution,
        INT  yResolution,
        INT  ConnectionFlags,
        PVOID *ppConnectData
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCStartA(
        PVOID pConnectData, 
        CHAR *command
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCCheckA(
        PVOID pConnectData, 
        CHAR *command, 
        CHAR *param
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCSendtextAsMsgsA(
        PVOID pConnectData, 
        CHAR  *line
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCSwitchToProcess(
        PVOID pCI, 
        LPCWSTR lpszParam
        );

PROTOCOLAPI
LPCSTR 
SMCAPI  
SCSendMouseClick(
        PVOID pCI, 
        UINT xPos, 
        UINT yPos
        );

PROTOCOLAPI
UINT   
SMCAPI 
SCGetSessionId(
        PVOID pCI
        );

PROTOCOLAPI
LPCSTR
SMCAPI
SCGetClientScreen(
        PVOID pCI,
        INT left,
        INT top,
        INT right,
        INT bottom,
        UINT  *puiSize,
        PVOID *ppDIB
        );


PROTOCOLAPI
LPCSTR
SMCAPI
SCSaveClientScreen(
        PVOID pCI,
        INT left,
        INT top,
        INT right,
        INT bottom,
        LPCSTR szFileName
        );

PROTOCOLAPI
LPCSTR
SMCAPI
SCSendVCData(
        PVOID     pCI,
        LPCSTR   szVCName,
        PVOID    pData,
        UINT     uiSize
        );

PROTOCOLAPI
LPCSTR
SMCAPI
SCRecvVCData(
        PVOID        pCI,
        LPCSTR       szVCName,
        PVOID        pData,
        UINT         uiBlockSize,
        UINT         *puiBytesRead
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\bmpdb.c ===
/*++
 *  File name:
 *      bmpdb.c
 *  Contents:
 *      Bitmap database manager
 *      Almost all functions ARE NOT thread safe
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/
#include    <windows.h>
#include    <io.h>
#include    <fcntl.h>
#include    <sys/types.h>
#include    <sys/stat.h>
#include    <string.h>
#include    <stdio.h>
#include    <malloc.h>

#include    "bmpdb.h"

#define DB_NAME     "bmpcache.db"   // Database name
#define TEMPDB_NAME "bmpcache.tmp"  // Temp file, used to recopy the database

// Global data
int     g_hDB = 0;                  // Handle to the opened database
int     g_hTempDB;                  // Temp handle
BOOL    g_bNeedToPack;              // True if some entrys are deleted

/*
 *      Internal functions definition
 --*/
void _PackDB(void);

/*++
 *  Function:
 *      OpenDB
 *  Description:
 *      Opens and initializes the database
 *  Arguments:
 *      bWrite  - TRUE if the caller wants to write in the database
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      InitCache
 --*/
BOOL OpenDB(BOOL bWrite)
{
    int hFile, rv = TRUE;
    int oflag;

    if (g_hDB)
        // Already initialized
        goto exitpt;

    oflag = (bWrite)?_O_RDWR|_O_CREAT:_O_RDONLY;

    hFile = _open(DB_NAME, oflag|_O_BINARY, _S_IREAD|_S_IWRITE);

    if (hFile == -1)
        rv = FALSE;
    else
        g_hDB = hFile;

    g_bNeedToPack = FALSE;

exitpt:
    return rv;
}

/*++
 *  Function:
 *      CloseDB
 *  Description:
 *      Closes the database deletes entry if necessary
 *  Called by:
 *      DeleteCache
 --*/
VOID CloseDB(VOID)
{
    if (!g_hDB)
        goto exitpt;

    if (g_bNeedToPack)
        _PackDB();
    else
        _close(g_hDB);

    g_hDB = 0;
exitpt:
    ;
}


/*++
 *  Function:
 *      ReadGroup (Thread dependent)
 *  Description:
 *      Read the structure which represents
 *      a bitmap group with the same IDs
 *  Arguments:
 *      nOffset - offset in the DB file
 *      pGroup  - pointer to the result
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      internaly
 --*/
BOOL ReadGroup(FOFFSET nOffset, PGROUPENTRY pGroup)
{
    int rv = FALSE;

    if (!g_hDB)
        goto exitpt;

    if (_lseek(g_hDB, nOffset, SEEK_SET) != nOffset)
        goto exitpt;

    if (_read(g_hDB, pGroup, sizeof(*pGroup)) != sizeof(*pGroup))
        goto exitpt;

    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      WriteGroup (Thread dep)
 *  Description:
 *      Writes GROUPENTRY in the DB file
 *  Arguments:
 *      nOffset - where to store
 *      pGroup  - what to store
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      internaly
 --*/
BOOL WriteGroup(FOFFSET nOffset, PGROUPENTRY pGroup)
{
    BOOL rv = FALSE;

    if (!g_hDB || !pGroup)
        goto exitpt;

    if (_lseek(g_hDB, nOffset, SEEK_SET) != nOffset)
        goto exitpt;

    if (_write(g_hDB, pGroup, sizeof(*pGroup)) != sizeof(*pGroup))
        goto exitpt;

    rv = TRUE;
exitpt:
    return rv;
}


/*++
 *  Function:
 *      EnumerateGroups (thread dep)
 *  Description:
 *      Enumerates all groups from the DB
 *  Arguments:
 *      pfnEnumGrpProc  - Callback function
 *      pParam          - Parameter passed to the callback
 *  Called by:
 *      internaly
 --*/
VOID EnumerateGroups(PFNENUMGROUPS pfnEnumGrpProc, PVOID pParam)
{
    GROUPENTRY  Group;
    BOOL        bRun;
    FOFFSET     nOffs = 0;

    bRun = ReadGroup(nOffs, &Group);
    
    while(bRun) {
        if (!Group.bDeleted)
            bRun = pfnEnumGrpProc(nOffs, &Group, pParam) && 
                  (Group.FOffsNext != 0);
        if (bRun)
        {
            nOffs = Group.FOffsNext;
            if (nOffs)
                bRun = ReadGroup(nOffs, &Group);
            else
                bRun = FALSE;
        }
    }
}

/*++
 *  Function:
 *      ReadBitmapHeader (Thread dep)
 *  Description:
 *      Read only the header of the bitmap
 *  Arguments:
 *      nOffset - where in the file
 *      pBitmap - returned structure
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      Internaly
 --*/
BOOL ReadBitmapHeader(FOFFSET nOffset, PBMPENTRY pBitmap)
{
    BOOL rv = FALSE;

    if (!g_hDB || !pBitmap)
        goto exitpt;

    if (_lseek(g_hDB, nOffset, SEEK_SET) != nOffset)
        goto exitpt;

    if (_read(g_hDB, pBitmap, sizeof(*pBitmap)) != sizeof(*pBitmap))
        goto exitpt;

    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      WriteBitmapHeader (Thread dep)
 *  Description:
 *      Writes only the bitmap header
 *  Arguments:
 *      nOffset - where to store
 *      pBitmap - what to store
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      internaly
 --*/
BOOL WriteBitmapHeader(FOFFSET nOffset, PBMPENTRY pBitmap)
{
    BOOL rv = FALSE;

    if (!g_hDB || !pBitmap)
        goto exitpt;

    if (_lseek(g_hDB, nOffset, SEEK_SET) != nOffset)
        goto exitpt;

    if (_write(g_hDB, pBitmap, sizeof(*pBitmap)) != sizeof(*pBitmap))
        goto exitpt;

    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      ReadBitmap (Thread dependent)
 *  Description:
 *      Read the whole bitmap and allocates memory for it
 *  Arguments:
 *      nOffset - from where
 *  Return value:
 *      Pointer to the result, NULL on error
 *  Called by:
 *      internaly
 --*/
PBMPENTRY ReadBitmap(FOFFSET nOffset)
{
    PBMPENTRY rv = NULL;

    if (!g_hDB)
        goto exitpt;

    rv = malloc(sizeof(*rv));
    if (rv)
    {
        rv->pData = NULL;

        if (!ReadBitmapHeader(nOffset, rv))
            goto exitpt1;

        rv->pData = malloc(rv->nDataSize);
        if (rv->pData &&
            _read(g_hDB, rv->pData, rv->nDataSize) != (long)rv->nDataSize)
        {
            goto exitpt1;
        }
    }
exitpt:
    return rv;
exitpt1:
    if (rv)
    {
        if (rv->pData)
            free(rv->pData);
        free(rv);
    }

    return NULL;
}

/*++
 *  Function:
 *      FreeBitmap
 *  Description:
 *      Frees the resources allocated in ReadBitmap
 *  Arguments:
 *      pBmp    - The bitmap
 *  Called by:
 *      internaly
 --*/
VOID FreeBitmap(PBMPENTRY pBmp)
{
    if (pBmp)
    {
        if (pBmp->pData)
            free(pBmp->pData);
        free(pBmp);
    }
}

/*++
 *  Function:
 *      EnumerateBitmaps
 *  Description:
 *      Enumaretes all bitmaps within a group
 *  Arguments:
 *      nOffset     - Location
 *      pfnEnumProc - Callback
 *      pParam      - callback parameter
 *  Called by:
 *      internaly
 --*/
VOID EnumerateBitmaps(FOFFSET nOffset, PFNENUMBITMAPS pfnEnumProc, PVOID pParam)
{
    PBMPENTRY   pBmp;
    BOOL        bRun = TRUE;

    while(bRun && nOffset && (pBmp = ReadBitmap(nOffset)))
    {
        if (!pBmp->bDeleted)
            bRun = pfnEnumProc(nOffset, pBmp, pParam);

        nOffset = pBmp->FOffsNext;
        FreeBitmap(pBmp);
    }
}

/*++
 *  Function:
 *      FindGroup
 *  Description:
 *      Retrieves a group by ID
 *  Arguments:
 *      szWText - the ID
 *  Return value:
 *      Group location, -1 on error
 --*/
FOFFSET FindGroup(LPWSTR szWText)
{
    GROUPENTRY  Group;
    BOOL        bRun;
    FOFFSET     rv = 0;

    bRun = ReadGroup(0, &Group);

    while(bRun)
    { 
        if (!Group.bDeleted && !wcscmp(Group.WText, szWText))
            break;

        if (!Group.FOffsNext)
            bRun = FALSE;
        else
        {
            rv = Group.FOffsNext;
            bRun = ReadGroup(Group.FOffsNext, &Group);
        }
    }

    if (!bRun)
        rv = -1;

    return rv;
}

/*++
 *  Function:
 *      FindBitmap
 *  Description:
 *      Finds a bitmap by ID and comment
 *  Arguments:
 *      szWText     - ID
 *      szComment   - the comment
 *  Return value:
 *      The location of the bitmap, -1 on error
 --*/
FOFFSET FindBitmap(LPWSTR szWText, char *szComment)
{
    FOFFSET nGrpOffs, nBmpOffs;
    GROUPENTRY  group;
    BMPENTRY    Bitmap;
    FOFFSET rv = -1;
    BOOL    bRun;

    if ((nGrpOffs = FindGroup(szWText)) == -1)
        goto exitpt;

    if (!ReadGroup(nGrpOffs, &group))
        goto exitpt;

    nBmpOffs = group.FOffsBmp;

    bRun = TRUE;
    while(bRun)
    {
        bRun = ReadBitmapHeader(nBmpOffs, &Bitmap);

        if (bRun)
        {
            if (!Bitmap.bDeleted && !strcmp(Bitmap.szComment, szComment))
                break;

            nBmpOffs = Bitmap.FOffsNext;
        }
    }

    if (bRun)
        rv = nBmpOffs;

exitpt:
    return rv;
}

/*++
 *  Function:
 *      CheckSum
 *  Description:
 *      Calculates a check sum for block of memory
 *      Helps for bitmaps comapring
 *  Arguments:
 *      pData   - pointer to the block
 *      nLen    - block size
 *  Return value:
 *      the checksum
 *  Called by:
 *      AddBitMap, Glyph2String
 --*/
UINT
CheckSum(PVOID pData, UINT nLen)
{
    UINT    nChkSum = 0;
    BYTE    *pbBlock = (BYTE *)pData;

    for(;nLen; nLen--, pbBlock++)
        nChkSum += (*pbBlock);

    return nChkSum;
}

/*++
 *  Function:
 *      AddBitmap (Thread dependent)
 *  Description:
 *      Adds a BitMap to the DB
 *  Arguments:
 *      pBitmap - the bitmap
 *      szWText - ID
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      glyphspy.c
 --*/
BOOL AddBitMap(PBMPENTRY pBitmap, LPCWSTR szWText)
{
    BMPENTRY    bmp;
    GROUPENTRY  group;
    INT         strl;
    BOOL        rv = FALSE;
    FOFFSET     lGroupOffs, lBmpOffs;
    GROUPENTRY  grpTemp;
    BMPENTRY    bmpTemp;
    FOFFSET     nOffs;
    PVOID       pData;

    if (!g_hDB || !pBitmap || !pBitmap->pData || !wcslen(szWText))
        goto exitpt;

    memset(&group, 0, sizeof(group));
    memset(&bmp, 0, sizeof(bmp));

    bmp.nDataSize   = pBitmap->nDataSize;
    bmp.bmiSize     = pBitmap->bmiSize;
    bmp.bmpSize     = pBitmap->bmpSize;
    bmp.xSize       = pBitmap->xSize;
    bmp.ySize       = pBitmap->ySize;
    bmp.nChkSum     = CheckSum(pBitmap->pData, pBitmap->nDataSize);

    strcpy(bmp.szComment, pBitmap->szComment);

    strl = wcslen(szWText);
    if (strl > (sizeof(group.WText) - 1)/sizeof(WCHAR))
        strl = (sizeof(group.WText) - 1)/sizeof(WCHAR);
    wcsncpy(group.WText, szWText, strl);
    group.WText[strl] = 0;

    // Create group
    if ((lGroupOffs = FindGroup(group.WText)) == -1) 
    {
        // A new group will be created
        lGroupOffs = _lseek(g_hDB, 0, SEEK_END);
        group.FOffsMe = lGroupOffs;
        if (_write(g_hDB, &group, sizeof(group)) != sizeof(group))
        {
            goto exitpt;
        }
        // Add this group to the list
        if (lGroupOffs)
        {
            nOffs = 0;

            while(ReadGroup(nOffs, &grpTemp) && grpTemp.FOffsNext)
                        nOffs = grpTemp.FOffsNext;

            grpTemp.FOffsNext = lGroupOffs;
            if (!WriteGroup(nOffs, &grpTemp))
                goto exitpt;
        }
    } else {
        if (ReadGroup(lGroupOffs, &group) == -1)
            goto exitpt;
    }

    // Write the bitmap itself
    lBmpOffs = _lseek(g_hDB, 0, SEEK_END);
    bmp.FOffsMe = lBmpOffs;
    if (_write(g_hDB, &bmp, sizeof(bmp)) != sizeof(bmp))
    {
        goto exitpt;
    }
    if (_write(g_hDB, pBitmap->pData, pBitmap->nDataSize) != 
        (long)pBitmap->nDataSize)
    {
        goto exitpt;
    }

    // Add the bitmap to the list
    if (group.FOffsBmp)
    {
        nOffs = group.FOffsBmp;

        // Find end of the list and add
        while(ReadBitmapHeader(nOffs, &bmpTemp) && bmpTemp.FOffsNext)
                        nOffs = bmpTemp.FOffsNext;

        bmpTemp.FOffsNext = lBmpOffs;
        if (!WriteBitmapHeader(nOffs, &bmpTemp))
            goto exitpt;
    } else {
        // No list add to group pointer
        group.FOffsBmp = lBmpOffs;

        if (!WriteGroup(lGroupOffs, &group))
            goto exitpt;
    }

    rv = TRUE;

exitpt:
    return rv;
}

/*++
 *  Ascii version of AddBitMap
 --*/
BOOL AddBitMapA(PBMPENTRY pBitmap, LPCSTR szAText)
{
    WCHAR   szWText[MAX_STRING_LENGTH];
    BOOL    rv = FALSE;
    INT     ccAText = strlen(szAText);

    if (!strlen(szAText) ||
        !MultiByteToWideChar(
        CP_ACP,
        MB_ERR_INVALID_CHARS,
        szAText,
        -1,
        szWText,
        MAX_STRING_LENGTH - 1))
            goto exitpt;

    rv = AddBitMap(pBitmap, szWText);
exitpt:
    return rv;
}

/*++
 *  Function:
 *      DeleteBitmapByPointer (Thread dep)
 *  Description:
 *      Deletes a bitmap identified by pointer
 *  Arguments:
 *      nBmpOffset - the pointer
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      glyphspy.c
 --*/
BOOL DeleteBitmapByPointer(FOFFSET nBmpOffs)
{
    BMPENTRY    Bitmap;
    BOOL        rv = FALSE;

    if (!g_hDB || !nBmpOffs)
        goto exitpt;

    if (!ReadBitmapHeader(nBmpOffs, &Bitmap))
        goto exitpt;

    if (Bitmap.bDeleted)
        goto exitpt;

    Bitmap.bDeleted = TRUE;

    if (!WriteBitmapHeader(nBmpOffs, &Bitmap))
        goto exitpt;

    g_bNeedToPack = TRUE;
    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      DeleteGroupByPointer (Thread dep)
 *  Description:
 *      Deletes group with the same ID by pointer
 *  Arguments:
 *      nGrpOffs    - the pointer
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      glyphspy.c
 --*/
BOOL DeleteGroupByPointer(FOFFSET nGrpOffs)
{
    GROUPENTRY  Group;
    BOOL        rv = FALSE;

    if (!g_hDB)
        goto exitpt;

    if (!ReadGroup(nGrpOffs, &Group))
        goto exitpt;

    if (Group.bDeleted)
        goto exitpt;

    Group.bDeleted = TRUE;

    if (!WriteGroup(nGrpOffs, &Group))
        goto exitpt;

    g_bNeedToPack = TRUE;
    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      DeleteBitmap (Thread dep)
 *  Description:
 *      Deletes a bitmap identified by ID and comment
 *  Arguments:
 *      szWText     - the ID
 *      szComment   - the comment
 *  Return value:
 *      TRUE on success
 --*/
BOOL DeleteBitmap(LPWSTR szWText, char *szComment)
{
    FOFFSET nBmpOffs;
    BOOL    rv = FALSE;
    BMPENTRY    Bitmap;

    if (!g_hDB)
        goto exitpt;

    nBmpOffs = FindBitmap(szWText, szComment);

    if (nBmpOffs == -1)
        goto exitpt;

    if (!ReadBitmapHeader(nBmpOffs, &Bitmap))
        goto exitpt;

    if (Bitmap.bDeleted)
        goto exitpt;

    Bitmap.bDeleted = TRUE;

    if (!WriteBitmapHeader(nBmpOffs, &Bitmap))
        goto exitpt;

    g_bNeedToPack = TRUE;
    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      _PackDB (Thread dep)
 *  Description:
 *      Copies the all database in new file removing
 *      the deleted entrys
 *      If it fails leaves the old file
 *  Called by:
 *      CloseDB
 --*/
void _PackDB(void)
{
    GROUPENTRY  group;
    FOFFSET     lGrpOffs = 0;
    FOFFSET     lBmpOffs;

    if (!g_bNeedToPack)
        goto exitpt;

    g_hTempDB = _open(TEMPDB_NAME, 
                     _O_RDWR|_O_TRUNC|_O_CREAT|_O_BINARY, 
                     _S_IREAD|_S_IWRITE);
    if (g_hTempDB == -1)
        goto exitpt;

    do {
      if (!ReadGroup(lGrpOffs, &group))
          goto exitpt;

      if (!group.bDeleted)
      {
        lBmpOffs = group.FOffsBmp;

        while(lBmpOffs)
        {
            BMPENTRY    Bitmap;

            if (!ReadBitmapHeader(lBmpOffs, &Bitmap))
                goto exitpt;

            if (!Bitmap.bDeleted)
            {
                PBMPENTRY pBmp = ReadBitmap(lBmpOffs);

                if (pBmp)
                {
                    int hSwap;

                    hSwap       = g_hDB;
                    g_hDB       = g_hTempDB;
                    g_hTempDB   = hSwap;

                    AddBitMap(pBmp,
                              group.WText);

                    hSwap       = g_hDB;
                    g_hDB       = g_hTempDB;
                    g_hTempDB   = hSwap;

                    FreeBitmap(pBmp);
                }
            }
            lBmpOffs = Bitmap.FOffsNext;
        }
      }

      lGrpOffs = group.FOffsNext;
    } while (lGrpOffs);

    _close(g_hTempDB);
    _close(g_hDB);
    remove(DB_NAME);
    rename(TEMPDB_NAME, DB_NAME);
    
exitpt:
    ;
}

/*++
 *  Function:
 *      _CollectGroups  (Thread dep)
 *  Description:
 *      Callback function wich collects all groups 
 *      from the database in linked list
 *  Arguments:
 *      nOffs   - pointer to group record in the database
 *      pGroup  - ghe group
 *      ppList  - the list
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      GetGroupList thru EnumerateGroups
 --*/
BOOL _cdecl _CollectGroups(FOFFSET nOffs,
                           PGROUPENTRY pGroup, 
                           PGROUPENTRY *ppList)
{
    BOOL rv = FALSE;
    PGROUPENTRY pNewGrp, pIter, pPrev;

    if (!pGroup)
        goto exitpt;

    pNewGrp = malloc(sizeof(*pNewGrp));

    if (!pNewGrp)
        goto exitpt;

    memcpy(pNewGrp, pGroup, sizeof(*pNewGrp));

    // Add to the end of the queue
    pNewGrp->pNext = NULL;
    pPrev = NULL;
    pIter = *ppList;
    while(pIter)
    {
        pPrev = pIter;
        pIter = pIter->pNext;
    }
    if (pPrev)
        pPrev->pNext = pNewGrp;
    else
        (*ppList) = pNewGrp;

    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      GetGroupList
 *  Description:
 *      Gets all groups from the database
 *  Return value:
 *      linked list
 *  Called by:
 *      InitCache, glyphspy.c
 --*/
PGROUPENTRY GetGroupList(VOID)
{
    PGROUPENTRY pList = NULL;

    EnumerateGroups(_CollectGroups, &pList);

    return pList;
}

/*++
 *  Function:
 *      FreeGroupList
 *  Description:
 *      Frees the list allocated in GetGroupList
 *  Arguments:
 *      pList   - the list
 *  Called by:
 *      DeleteCache, glyphspy.c
 --*/
VOID FreeGroupList(PGROUPENTRY pList)
{
    PGROUPENTRY pTmp, pIter = pList;

    while(pIter)
    {
        pTmp = pIter;
        pIter = pIter->pNext;
        free(pTmp);
    }
}

/*++
 *  Function:
 *      _CollectBitmaps (thread dep)
 *  Description:
 *      collects bitmaps in linked list
 *  Arguments:
 *      nOffs   - pointer in the file
 *      pBitmap - the bitmap
 *      ppList  - the list
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      GetBitmapList thru EnumerateBitmaps
 --*/
BOOL _cdecl _CollectBitmaps(FOFFSET nOffs,PBMPENTRY pBitmap, PBMPENTRY *ppList)
{
    BOOL rv = FALSE;
    PBMPENTRY pNewBmp, pIter, pPrev;

    if (!pBitmap)
        goto exitpt;

    pNewBmp = malloc(sizeof(*pNewBmp));
    if (!pNewBmp)
        goto exitpt;

    memcpy(pNewBmp, pBitmap, sizeof(*pNewBmp));

    if (pNewBmp->nDataSize)
    {
        pNewBmp->pData = malloc(pNewBmp->nDataSize);
        if (!pNewBmp->pData)
            goto exitpt1;

        memcpy(pNewBmp->pData, pBitmap->pData, pNewBmp->nDataSize);
    } else
        pNewBmp->pData = NULL;

    // Add to the end of the queue
    pNewBmp->pNext = NULL;
    pPrev = NULL;
    pIter = *ppList;
    while(pIter)
    {
        pPrev = pIter;
        pIter = pIter->pNext;
    }
    if (pPrev)
        pPrev->pNext = pNewBmp;
    else
        (*ppList) = pNewBmp;

    rv = TRUE;
exitpt:
    return rv;

exitpt1:
    free(pNewBmp);
    return FALSE;
}

/*++
 *  Function:
 *      GetBitmapList (thread dep)
 *  Description:
 *      Gets all bitmaps within a group
 *  Return value:
 *      linked list
 *  Called by:
 *      Glyph2String, BitmapCacheLookup, glyphspy.c
 --*/
PBMPENTRY GetBitmapList(HDC hDC, FOFFSET nOffs)
{
    PBMPENTRY pList = NULL;
    PBMPENTRY pIter;

    EnumerateBitmaps(nOffs, _CollectBitmaps, &pList);

    pIter = pList;
    while(pIter)
    {
      //  Create bitmaps if needed
      if (hDC)
      {
        if (!pIter->bmiSize)
            pIter->hBitmap = 
                CreateBitmap(pIter->xSize, 
                             pIter->ySize, 
                             1, 1,
                             pIter->pData);
        else {
            pIter->hBitmap =
                CreateDIBitmap(hDC,
                               (BITMAPINFOHEADER *)
                               pIter->pData,
                               CBM_INIT,
                               ((BYTE *)(pIter->pData)) + pIter->bmiSize,
                               (BITMAPINFO *)
                               pIter->pData,
                               DIB_PAL_COLORS);

            DeleteDC(hDC);
        }
      } else
        pIter->hBitmap = NULL;

      pIter = pIter->pNext;
    }

    return pList;
}

/*++
 *  Function:
 *      FreeBitmapList
 *  Description:
 *      Deletes resources allocated by GetBitmapList
 *  Arguments:
 *      pList   - the list
 *  Called by:
 *      DeleteCache, glyphspy.c
 --*/
VOID FreeBitmapList(PBMPENTRY pList)
{
    PBMPENTRY pTmp, pIter = pList;

    while(pIter)
    {
        pTmp = pIter;
        pIter = pIter->pNext;

        if (pTmp->hBitmap)
            DeleteObject(pTmp->hBitmap);

        if ( pTmp->pData )
            free( pTmp->pData );

        free(pTmp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\feedback.h ===
/*++
 *  File name:
 *      feedback.h
 *  Contents:
 *      Common definitions for tclient.dll and clxtshar.dll
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#ifndef _FEEDBACK_H
#define _FEEDBACK_H

#define _HWNDOPT        "hSMC="
#define _RECONIDOPT     "ReconID="

#define MAX_VCNAME_LEN  8

/*
 *  Definitions for local execution of smclient and RDP client
 */

#define _TSTNAMEOFCLAS  "_SmClientClass"

#define WM_FB_TEXTOUT       (WM_USER+0) // wPar = ProcId, 
                                        // lPar = Share mem handle 
                                        // to FEEDBACKINFO
#define WM_FB_DISCONNECT    (WM_USER+1) // wPar = uResult, lPar = ProcId
#define WM_FB_ACCEPTME      (WM_USER+2) // wPar = 0,      lPar = ProcId
#define WM_FB_END           (WM_USER+3) // tclient's internal
#define WM_FB_CONNECT       (WM_USER+5) // wPar = hwndMain,   
                                        // lPar = ProcId
#define WM_FB_LOGON         (WM_USER+6) // wPar = session ID
                                        // lPar = ProcId

#ifdef  OS_WIN32

#define WM_FB_BITMAP        WM_FB_GLYPHOUT
#define WM_FB_GLYPHOUT      (WM_USER+4) // wPar = ProcId,
                                        // lPar = (HANDLE)BMPFEEDBACK

typedef struct _FEEDBACKINFO {
    DWORD   dwProcessId;
    DWORD   strsize;
    WCHAR   string[1024];
    WCHAR   align;
} FEEDBACKINFO, *PFEEDBACKINFO;

typedef struct _BMPFEEDBACK {
    LONG_PTR lProcessId;
    UINT    bmpsize;
    UINT    bmiSize;
    UINT    xSize;
    UINT    ySize;
    BITMAPINFO  BitmapInfo;
} BMPFEEDBACK, *PBMPFEEDBACK;
#endif  // OS_WIN32

/*
 *  Definitons for RCLX (remote execution of clx)
 *  both WIN32 and WIN16
 */

#define RCLX_DEFAULT_PORT       12344

#define WM_WSOCK            (WM_USER + 0x20)    // used for winsock 
                                                // notifications

#ifdef  _WIN64
typedef unsigned short  UINT16;
#else   // !_WIN64
#ifdef  OS_WIN32
typedef unsigned int    UINT32;
typedef unsigned short  UINT16;
#endif  // OS_WIN32
#ifdef  OS_WIN16
typedef unsigned long   UINT32;
typedef unsigned int    UINT16;
#endif
#endif  // _WIN64

// Feedback types. Send from clxtshar.dll to tclient.dll
//
enum {FEED_BITMAP,              // bitmap/glyph data
      FEED_TEXTOUT,             // unicode string
      FEED_TEXTOUTA,            // ansi string (unused)
      FEED_CONNECT,             // event connected
      FEED_DISCONNECT,          // event disconnected
      FEED_CLIPBOARD,           // clipboard data (RCLX)
      FEED_LOGON,               // logon event (+ session id)
      FEED_CLIENTINFO,          // client info (RCLX)
      FEED_WILLCALLAGAIN,       // rclx.exe will start a client, which will call
                                // us again
      FEED_DATA                 // response to requested data (RCLX)
} FEEDBACK_TYPE;

typedef struct _RCLXFEEDPROLOG {
    UINT32  FeedType;
    UINT32  HeadSize;
    UINT32  TailSize;
} RCLXFEEDPROLOG, *PRCLXFEEDPROLOG;

typedef struct _RCLXTEXTFEED {
    UINT32  strsize;
} RCLXTEXTFEED, *PRCLXTEXTFEED;

typedef struct _RCLXBITMAPFEED {
    UINT32  bmpsize;
    UINT32  bmisize;
    UINT32  xSize;
    UINT32  ySize;
    BITMAPINFO  BitmapInfo;
} RCLXBITMAPFEED, *PRCLXBITMAPFEED;

typedef struct _RCLXCLIPBOARDFEED {
    UINT32  uiFormat;               // Clipboard is send from the client
    UINT32  nClipBoardSize;         // system to tclient.dll
} RCLXCLIPBOARDFEED, *PRCLXCLIPBOARDFEED;

typedef struct _RCLXCLIENTINFOFEED {
    UINT32  nReconnectAct;
    UINT32  ReconnectID;
    CHAR    szClientInfo[128];    
} RCLXCLIENTINFOFEED, *PRCLXCLIENTINFOFEED;

//Requests. Send from tclient.dll to clxtshar.dll
enum {REQ_MESSAGE,
      REQ_CONNECTINFO,
      REQ_GETCLIPBOARD,
      REQ_SETCLIPBOARD,
      REQ_DATA
} REQUEST_TYPE;

typedef struct _RCLXREQPROLOG {
    UINT32  ReqType;
    UINT32  ReqSize;
} RCLXREQPROLOG, *PRCLXREQPROLOG;

typedef struct _RCLXMSG {
    UINT32  message;
    UINT32  wParam;
    UINT32  lParam;
} RCLXMSG, *PRCLXMSG;

typedef struct _RCLXCONNECTINFO {
    UINT32  YourID;
    UINT32  xResolution;
    UINT32  yResolution;
    UINT32  bLowSpeed;
    UINT32  bPersistentCache;
    CHAR    szHydraServer[32];
} RCLXCONNECTINFO, *PRCLXCONNECTINFO;

typedef struct _RCLXCLIPBOARD {     // Request for retrieve/setting the clipboard
    UINT32  uiFormat;               // from the client system
    BYTE    pNewClipboard[0];       // used in REQ_SETCLIPBOARD, otherwise 0 len
} RCLXCLIPBOARD, *PRCLXCLIPBOARD;

typedef struct _RCLXDATA {
    UINT32  uiType;
    UINT32  uiSize;
    BYTE    Data[0];
} RCLXDATA, *PRCLXDATA;

enum {  // these identify RCLX_DATA
    DATA_BITMAP,
    DATA_VC
};

typedef struct _REQBITMAP {
    UINT32  left, top, right, bottom;
} REQBITMAP, *PREQBITMAP;

#endif  // _FEEDBACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\main.c ===
/*++
 *  File name:
 *      main.c
 *  Contents:
 *      Dll entry point. Call initialization/clean procedures
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 *
 --*/

#include    <windows.h>

/*
 *  External functions
 */
int InitDone(HINSTANCE, int);

/*++
 *  Function:
 *      DllEntry
 *  Description:
 *      Dll entry point
 *  Arguments:
 *      hDllInst    - dll instance
 *      dwReason    - action
 *      fImpLoad    - unused
 *  Return value:
 *      TRUE on success
 *
 --*/
int WINAPI _DllMainCRTStartup(HINSTANCE hDllInst,
                    DWORD   dwReason,
                    LPVOID  fImpLoad)
{
    int rv = TRUE;

    if (dwReason == DLL_PROCESS_ATTACH)
        rv = InitDone(hDllInst, TRUE);
    else  if (dwReason == DLL_PROCESS_DETACH)
        rv = InitDone(hDllInst, FALSE);

    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\gdata.h ===
/*++
 *  File name:
 *      gdata.h
 *  Contents:
 *      Global data definitions
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

extern HWND            g_hWindow;           // Window handle for the 
                                            // feedback thread
extern HINSTANCE       g_hInstance;         // Dll instance
extern PWAIT4STRING    g_pWaitQHead;        // Linked list for waited events
extern PFNPRINTMESSAGE g_pfnPrintMessage;   // Trace function (from smclient)
extern PCONNECTINFO    g_pClientQHead;      // LL of all threads
extern HANDLE  g_hThread;                   // Feedback Thread handle

extern  UINT WAIT4STR_TIMEOUT;              // deafult is 10 min, 
                                            // some events are waited
                                            // 1/4 of that time
                                            // This value can be changed from
                                            // smclient.ini [tclient] 
                                            // timeout=XXX seconds

extern  UINT CONNECT_TIMEOUT;               // Default is 35 seconds
                                            // This value can be changed from
                                            // smclient.ini [tclient]
                                            // contimeout=XXX seconds

extern LPCRITICAL_SECTION  g_lpcsGuardWaitQueue;
                                            // Guards the access to all 
                                            // global variables

extern WCHAR    g_strStartRun[];
extern WCHAR    g_strStartRun_Act[];
extern WCHAR    g_strRunBox[];
extern WCHAR    g_strWinlogon[];
extern WCHAR    g_strWinlogon_Act[];
extern WCHAR    g_strPriorWinlogon[];
extern WCHAR    g_strPriorWinlogon_Act[];
extern WCHAR    g_strNTSecurity[];
extern WCHAR    g_strNTSecurity_Act[];
extern WCHAR    g_strSureLogoff[];
extern WCHAR    g_strStartLogoff[];
extern WCHAR    g_strSureLogoffAct[];
extern WCHAR    g_strLogonErrorMessage[];
extern WCHAR    g_strLogonDisabled[];

extern CHAR     g_strClientCaption[];
extern CHAR     g_strDisconnectDialogBox[];
extern CHAR     g_strYesNoShutdown[];
extern CHAR     g_strClientImg[];

extern INT  g_ConnectionFlags;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\perlsmc.h ===
/*++
 *  File name:
 *      perlsmc.h
 *  Contents:
 *      Definitions needed by tclntpll.xs
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

extern "C" {
    void _stdcall SCInit(void *);
    char * _stdcall SCConnectA (char *lpszServerName, 
                 char *lpszUserName, 
                 char *lpszPassword,
                 char *lpszDomain,
                 int xResolution,
                 int yResolution,
                 void **ppConnectData);

    char * _stdcall SCConnectExA (
                 char *lpszServerName,
                 char *lpszUserName,
                 char *lpszPassword,
                 char *lpszDomain,
                 char *lpszShell,
                 int  xResolution,
                 int  yResolution,
                 int  ConnectionFlags,
                 void **ppConnectData);

    char * _stdcall SCDisconnect (void *pConnectData);
    char * _stdcall SCStartA(void *pConnectData, char *command);
    char * _stdcall SCLogoff(void *pConnectData);
    char * _stdcall SCClipboard(void *pConnectData, int eClipOp, char *lpszFileName);
    char * _stdcall SCSaveClipboard(void *pConnectData, 
                          char *szFormatName, 
                          char *FileName);
    char * _stdcall SCSenddata(void *pConnectData, 
                     unsigned int uiMessage, 
                     unsigned int wParam, 
                     long lParam);
    char * _stdcall SCCheckA(void *pConnectData, char *command, char *param);
    char * _stdcall SCSendtextAsMsgsA(void *pConnectData, char *line);
    char * GetFeedbackString(void *pConnectData, 
                            char *result, 
                            unsigned int max);

    int  _stdcall SCIsDead(void *pConnectData);
    char * _stdcall SCClientTerminate(void *pConnectData);
    void MyBreak(void);

    int  _stdcall SCOpenClipboard(void *);
    int  _stdcall SCCloseClipboard(void);
    int  _stdcall SCGetSessionId(void *);

    char * _stdcall SCSaveClientScreen(void *, int, int, int, int, char *);
};

int  g_bVerbose = 0;

enum MESSAGETYPE
{
    ERROR_MESSAGE,
    ALIVE_MESSAGE,
    WARNING_MESSAGE,
    INFO_MESSAGE
};

void _cdecl LocalPrintMessage(int errlevel, char *format, ...)
{
    char szBuffer[256];
    char *type;
    va_list     arglist;
    int nchr;

    if (g_bVerbose < 2 &&
        errlevel == ALIVE_MESSAGE)
        goto exitpt;

    if (g_bVerbose < 1 &&
        errlevel == INFO_MESSAGE)
        goto exitpt;

    va_start (arglist, format);
    nchr = _vsnprintf (szBuffer, sizeof(szBuffer), format, arglist);
    va_end (arglist);

    switch(errlevel)
    {
    case INFO_MESSAGE: type = "INF"; break;
    case ALIVE_MESSAGE: type = "ALV"; break;
    case WARNING_MESSAGE: type = "WRN"; break;
    case ERROR_MESSAGE: type = "ERR"; break;
    default: type = "UNKNOWN";
    }

    printf("%s:%s", type, szBuffer);
exitpt:
    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\misc.h ===
/*++
 *  File name:
 *      misc.h
 *  Contents:
 *      Help functions from tclient.c
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

VOID    _SetClientRegistry(
    LPCWSTR lpszServerName,
    LPCWSTR lpszShell,
    INT xRes, INT yRes, 
    INT ConnectionFlags
);

VOID    _DeleteClientRegistry(PCONNECTINFO pCI);
BOOL    _CreateFeedbackThread(VOID);
VOID    _DestroyFeedbackThread(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\queues.c ===
/*++
 *  File name:
 *      queues.c
 *  Contents:
 *      Supports the linked lists for the clients
 *      and events
 *      Two linked lists:
 *      g_pClientQHead  - list of all clients running within smclient
 *      g_pWaitQHead    - all events we are waiting for from smclient
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/
#include    <windows.h>
#include    <stdio.h>
#include    <malloc.h>
#include    <process.h>
#include    <string.h>
#include    <stdlib.h>
#include    <ctype.h>

#include    "tclient.h"
#include    "protocol.h"
#include    "gdata.h"
#include    "bmpcache.h"

/*
 *
 *  ClientQ functions
 *
 */

/*++
 *  Function:
 *      _AddToClientQ
 *  Description:
 *      Adds a client on the top of the list
 *  Arguments:
 *      pClient - the client context
 *  Called by:
 *      SCConnect
 --*/
VOID _AddToClientQ(PCONNECTINFO pClient)
{
    EnterCriticalSection(g_lpcsGuardWaitQueue);
    pClient->pNext = g_pClientQHead;
    g_pClientQHead = pClient;
    LeaveCriticalSection(g_lpcsGuardWaitQueue);
}

/*++
 *  Function:
 *      _RemoveFromClientQ
 *  Description:
 *      Removes a client context from the list
 *  Arguments:
 *      pClient - the client context
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      SCDisconnect
 --*/
BOOL _RemoveFromClientQ(PCONNECTINFO pClient)
{
    PCONNECTINFO pIter, pPrev = NULL;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pClientQHead;
    while (pIter && pIter != pClient) {
        pPrev = pIter;
        pIter = pIter->pNext;
    }

    if (pIter) {
        if (!pPrev) g_pClientQHead = pIter->pNext;
        else pPrev->pNext = pIter->pNext;

        pIter->pNext = NULL;
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

/*++
 *  Function:
 *      _SetClientDead
 *  Description:
 *      Marks a client context as dead
 *  Arguments:
 *      dwClientProcessId   -   ID for the client process
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _SetClientDead(LONG_PTR lClientProcessId)
{
    PCONNECTINFO pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pClientQHead;
    while (pIter && pIter->lProcessId != lClientProcessId) 
    {
        pIter = pIter->pNext;
    }    

    if (pIter) pIter->dead = TRUE;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

/*++
 *  Function:
 *      _CheckIsAcceptable
 *  Description:
 *      Checks if we can accept feedback from this RDP client
 *      i.e. if this client is member of the client queue
 *  Arguments:
 *      dwProcessId - clients process Id
 *  Return value:
 *      Pointer to connection context. NULL if not found
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
PCONNECTINFO _CheckIsAcceptable(LONG_PTR lProcessId, BOOL bRClxType)
{
    PCONNECTINFO pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pClientQHead;
    while(pIter && 
          (pIter->lProcessId != lProcessId || pIter->RClxMode != bRClxType))
    {
        pIter = pIter->pNext;
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter);
}

/*++
 *  Function:
 *      _AddStrToClientBuffer
 *  Description:
 *      Add a string to the clients history buffer
 *      When smclient calls Wait4Str it first checks that buffer
 *  Arguments:
 *      str         - the string
 *      dwProcessId - the client process Id
 *  Called by:
 *      _CheckForWaitingWorker
 --*/
VOID _AddStrToClientBuffer(LPCWSTR str, LONG_PTR lProcessId)
{
    PCONNECTINFO pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pClientQHead;
    while(pIter && pIter->lProcessId != lProcessId)
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        int strsize = wcslen(str);
        if (strsize >= MAX_STRING_LENGTH) strsize = MAX_STRING_LENGTH-1;

        wcsncpy( pIter->Feedback[pIter->nFBend],
                str,
                strsize);
        pIter->Feedback[pIter->nFBend][strsize] = 0;

        pIter->nFBend++;
        pIter->nFBend %= FEEDBACK_SIZE;
        if (pIter->nFBsize < FEEDBACK_SIZE)
            pIter->nFBsize++; 

    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

}

/*
 *
 *  WaitQ functions
 *
 */

/*++
 *  Function:
 *      _AddToWaitQNoCheck
 *  Description:
 *      Adds an waiting event to the list with checking in the history list
 *  Arguments:
 *      pCI     - client context
 *      pWait   - the event
 *  Called by:
 *      RegisterChat
 --*/
VOID _AddToWaitQNoCheck(PCONNECTINFO pCI, PWAIT4STRING pWait)
{
    ASSERT(pCI);

    EnterCriticalSection(g_lpcsGuardWaitQueue);
    pWait->pNext = g_pWaitQHead;
    g_pWaitQHead = pWait;
    LeaveCriticalSection(g_lpcsGuardWaitQueue);
}

/*++
 *  Function:
 *      _AddToWaitQueue
 *  Description:
 *      Add an event to the list. If the event is waiting for string(s)
 *      the history buffer is checked first
 *  Arguments:
 *      pCI     - client context
 *      pWait   - the event
 *  Called by:
 *      _WaitSomething
 --*/
VOID _AddToWaitQueue(PCONNECTINFO pCI, PWAIT4STRING pWait)
{
    BOOL bDone = FALSE;
    int i, strn;

    ASSERT(pCI);

    // exit if we are dead
    if (/*!pWait->waitstr[0] && */pCI->dead)
    {
        SetEvent(pWait->evWait);
        goto exitpt;
    }

    EnterCriticalSection(g_lpcsGuardWaitQueue);
// Check if we're already received this feedback
    if (pWait->WaitType == WAIT_STRING)
// look if the string already came
        for(i = 0; !bDone && i < pCI->nFBsize; i++)
        {

            strn = (FEEDBACK_SIZE + pCI->nFBend - i - 1) % FEEDBACK_SIZE;

            if (!pCI->Feedback[strn][0]) continue;
            bDone = (wcsstr(pCI->Feedback[strn], pWait->waitstr) != NULL);
        }
    // In case of waiting multiple strings
    else if (pWait->WaitType == WAIT_MSTRINGS)
    {
        for(i = 0; !bDone && i < pCI->nFBsize; i++)
        {
            WCHAR *wszComp = pWait->waitstr;
            WCHAR *wszLast = pWait->waitstr + pWait->strsize;
            int   idx = 0;

            strn = (FEEDBACK_SIZE + pCI->nFBend - i - 1) % FEEDBACK_SIZE;

            if (!pCI->Feedback[strn][0]) continue;
            while (wszComp < wszLast && *wszComp && !bDone)
            {
                if (wcsstr(pCI->Feedback[strn], wszComp))
                {
                    int i;
                    // Save the string
                    for(i = 0; wszComp[i]; i++)
                        pCI->szWait4MultipleStrResult[i] = (char)wszComp[i];
                    // and the index

                    pCI->szWait4MultipleStrResult[i] = 0;

                    pCI->nWait4MultipleStrResult = idx;
                    bDone = TRUE;
                }
                else
                {
                    // Advance to next string
                     wszComp += wcslen(wszComp) + 1;
                    idx ++;
                }
            }
        }
    }
    else if (pWait->WaitType == WAIT_CLIPBOARD && 
                pWait->pOwner->bRClxClipboardReceived)
    {
        bDone = TRUE;
    }
    else if (pWait->WaitType == WAIT_DATA &&
                pWait->pOwner->pRClxDataChain)
    {
        bDone = TRUE;
    }

    // The string (or anything else) is in the history list
    // Set the event
    if (bDone)
    {
        SetEvent(pWait->evWait);
        pCI->nFBsize = pCI->nFBend = 0;
    }
    pWait->pNext = g_pWaitQHead;
    g_pWaitQHead = pWait;
    LeaveCriticalSection(g_lpcsGuardWaitQueue);
exitpt:
    ;
}

/*++
 *  Function:
 *      _RemoveFromWaitQueue
 *  Description:
 *      Removes an event from the list
 *  Arguments:
 *      pWait   - the event
 *  Return value:
 *      TRUE if the event is found and removed
 *  Called by:
 *      _WaitSomething, _RemoveFromWaitQIndirect
 --*/
BOOL _RemoveFromWaitQueue(PWAIT4STRING pWait)
{   
    PWAIT4STRING pIter, pPrev = NULL;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while (pIter && pIter != pWait) {
        pPrev = pIter;
        pIter = pIter->pNext;
    }

    if (pIter) {
        if (!pPrev) g_pWaitQHead = pIter->pNext;
        else pPrev->pNext = pIter->pNext;

        pIter->pNext = NULL;
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

/*++
 *  Function:
 *      _RemoveFromWaitQIndirect
 *  Description:
 *      Same as _RemoveFromWaitQueue but identifies the event
 *      by client context and waited string
 *  Arguments:
 *      pCI     - the client context
 *      lpszWait4   - the string
 *  Return value:
 *      the event
 *  Called by:
 *      UnregisterChat
 --*/
PWAIT4STRING _RemoveFromWaitQIndirect(PCONNECTINFO pCI, LPCWSTR lpszWait4)
{
    PWAIT4STRING pIter;

    ASSERT(pCI);

    // Search the list
    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while (pIter && 
           (pIter->pOwner != pCI || 
           wcscmp(pIter->waitstr, lpszWait4))
          )
        pIter = pIter->pNext;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    if (pIter)
    {
        _RemoveFromWaitQueue(pIter);
    }

    return pIter;
} 

/*++
 *  Function:
 *      _RetrieveFromWaitQByEvent
 *  Description:
 *      Searches the waiting list by event handler
 *  Arguments:
 *      hEvent  - the handler
 *  Return value:
 *      The event structure
 *  Called by:
 *      _WaitSomething when responds on chat sequence
 --*/
PWAIT4STRING _RetrieveFromWaitQByEvent(HANDLE hEvent)
{
    PWAIT4STRING pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while (pIter &&
           pIter->evWait != hEvent)
        pIter = pIter->pNext;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return pIter;
}

/*++
 *  Function:
 *      _RetrieveFromWaitQByOwner
 *  Description:
 *      Searches the waiting list by owner record
 *  Arguments:
 *      pCI - pointer to the owner context
 *  Return value:
 *      The event structure
 *  Called by:
 *      RClx_MsgReceived
 --*/
PWAIT4STRING 
_RetrieveFromWaitQByOwner(PCONNECTINFO pCI)
{
    PWAIT4STRING pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while (pIter &&
           pIter->pOwner != pCI)
        pIter = pIter->pNext;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return pIter;
}

/*++
 *  Function:
 *      _FlushFromWaitQ
 *  Description:
 *      Flush everithing that we are waiting for from the list
 *      the client is going to DIE
 *  Arguments:
 *      pCI - client context
 *  Called by:
 *      _CloseConnectInfo
 --*/
VOID _FlushFromWaitQ(PCONNECTINFO pCI)
{
    PWAIT4STRING pIter, pPrev, pNext;

    ASSERT(pCI);

    pPrev = NULL;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    do {
        while (pIter && pIter->pOwner != pCI) {
            pPrev = pIter;
            pIter = pIter->pNext;
        }

        if (pIter) {
            if (!pPrev) g_pWaitQHead = pIter->pNext;
            else pPrev->pNext = pIter->pNext;

            pNext = pIter->pNext;
            pIter->pNext = NULL;

            // Important stuff
            if (pIter->evWait)
                CloseHandle(pIter->evWait);

            free(pIter);
            pIter = pNext;
        }
    } while (pIter);

    LeaveCriticalSection(g_lpcsGuardWaitQueue);
}

/*++
 *  Function:
 *      _CheckForWaitingWorker
 *  Description:
 *      Check the received string against the waited events
 *  Arguments:
 *      wszFeed     - the received string
 *      dwProcessId - Id of the sender
 *  Return value:
 *      TRUE if an event is found and signaled
 *  Called by:
 *      _TextOutReceived, _GlyphReceived
 --*/
BOOL _CheckForWaitingWorker(LPCWSTR wszFeed, LONG_PTR lProcessId)
{
    PWAIT4STRING pIter;
    BOOL    bRun;
    CHAR    szBuff[ MAX_STRING_LENGTH ];
    CHAR    *szPBuff;
    DWORD   dwBuffLen;
    LPCWSTR wszPFeed;


    if ( NULL != g_pfnPrintMessage )
    {
        
        wszPFeed = wszFeed;
        while ( *wszPFeed )
        {
            if ( (unsigned short)(*wszPFeed) > 0xff )
                break;

            wszPFeed ++;
        }

        if ( *wszPFeed )
        {
            szBuff[0] = '\\';
            szBuff[1] = 'u';
            szPBuff = szBuff + 2;
            wszPFeed = wszFeed;
            dwBuffLen = MAX_STRING_LENGTH - 3;

            while ( 4 <= dwBuffLen &&
                    0 != *wszPFeed)
            {
                DWORD dwLen;

                if ( dwBuffLen < 4 )
                    break;

                dwLen = _snprintf( szPBuff, dwBuffLen + 1, "%02x",
                                    (BYTE)((*wszPFeed) & 0xff ));
                szPBuff     += dwLen;
                dwBuffLen   -= dwLen;

                dwLen = _snprintf( szPBuff, dwBuffLen + 1, "%02x",
                                    (BYTE)(((*wszPFeed) >> 8) & 0xff ));
                szPBuff     += dwLen;
                dwBuffLen   -= dwLen;

                wszPFeed ++;
            }
            *szPBuff = 0;
            TRACE((ALIVE_MESSAGE, "Received: %s\n", szBuff));
        } else {
            TRACE((ALIVE_MESSAGE, "Received: %S\n", wszFeed));
        }

    }

    _AddStrToClientBuffer(wszFeed, lProcessId);

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;

    bRun = TRUE;
    while(pIter && bRun)
    {
        if (pIter->lProcessId == lProcessId)
        {
            // Check for expected string (one)
            if (pIter->WaitType == WAIT_STRING &&
                wcsstr(wszFeed, pIter->waitstr))
                bRun = FALSE;
            else
            // Check for expected strings (many)
            if (pIter->WaitType == WAIT_MSTRINGS)
            {
                WCHAR *wszComp = pIter->waitstr;
                WCHAR *wszLast = pIter->waitstr + pIter->strsize;
                int   idx = 0;

                while (wszComp < wszLast && *wszComp && bRun)
                {
                    if (wcsstr(wszFeed, wszComp))
                    {
                        int i;
                        PCONNECTINFO pOwner = pIter->pOwner;

                        // Save the string
                        for(i = 0; wszComp[i]; i++)
                        pOwner->szWait4MultipleStrResult[i] = (char)wszComp[i];

                        pOwner->szWait4MultipleStrResult[i] = 0;

                        pOwner->nWait4MultipleStrResult = idx;
                        bRun = FALSE;
                    }
                    else
                    {
                        // Advance to next string
                        wszComp += wcslen(wszComp) + 1;
                        idx ++;
                    }
                }
            }
        }
        // Advance to the next pointer
        if (bRun)
            pIter = pIter->pNext;
    }

    if (pIter)
    {
        SetEvent(pIter->evWait);
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

/*++
 *  Function:
 *      _TextOutReceived
 *  Description:
 *      TextOut order is received from the client, the string is
 *      in shared memory. Unmaps the memory and checks if the
 *      strings is waited by anybody. Also adds the string
 *      to the client history buffer
 *  Arguments:
 *      dwProcessId -   senders Id
 *      hMapF       -   handle to shared memory, which contains the string
 *  Return value:
 *      TRUE if a client is found and signaled
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _TextOutReceived(LONG_PTR lProcessId, HANDLE hMapF)
{
    PFEEDBACKINFO   pView;
    PCONNECTINFO    pIterCl;
    HANDLE  hDupMapF;
    BOOL    rv = FALSE;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIterCl = g_pClientQHead;
    while(pIterCl && pIterCl->lProcessId != lProcessId)
        pIterCl = pIterCl->pNext;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    if (!pIterCl)
        goto exitpt;

    if (!DuplicateHandle(pIterCl->hProcess,
                           hMapF,
                           GetCurrentProcess(),
                           &hDupMapF,
                           FILE_MAP_READ,
                           FALSE,
                           0))
    {
        TRACE((ERROR_MESSAGE, 
               "TEXTOUT:Can't dup file handle, GetLastError = %d\n", 
               GetLastError()));
        goto exitpt;
    }

    pView = MapViewOfFile(hDupMapF,
                          FILE_MAP_READ,
                          0,
                          0,
                          sizeof(*pView));

    if (!pView)
    {
        TRACE((ERROR_MESSAGE, 
               "TEXTOUT:Can't map a view,  GetLastError = %d\n", 
               GetLastError()));
        goto exitpt1;
    }

    rv = _CheckForWaitingWorker(pView->string, lProcessId);

exitpt1:
    UnmapViewOfFile(pView);
    CloseHandle(hDupMapF);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _GlyphReceived
 *  Description:
 *      Same as _TextOutReceived but for GlyphOut order
 *      the glyph is in shared memory. It is converted to
 *      string by calling Glyph2String!bmpcache.c
 *  Arguments:
 *      dwProcessId -   senders Id
 *      hMapF       -   handle to shared memory
 *  Return value:
 *      TRUE if a client is found and signaled
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _GlyphReceived(LONG_PTR lProcessId, HANDLE hMapF)
{
    WCHAR   wszFeed[MAX_STRING_LENGTH];
    BOOL    rv = FALSE;
    PBMPFEEDBACK pView;
    PCONNECTINFO pIterCl;
    HANDLE hDupMapF;
    UINT    nSize;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIterCl = g_pClientQHead;
    while(pIterCl && pIterCl->lProcessId != lProcessId)
        pIterCl = pIterCl->pNext;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    if (!pIterCl)
        goto exitpt;

    if (!DuplicateHandle(  pIterCl->hProcess,
                           hMapF,
                           GetCurrentProcess(),
                           &hDupMapF,
                           FILE_MAP_READ,
                           FALSE,
                           0))
    {
        TRACE((ERROR_MESSAGE, 
               "GLYPH:Can't dup file handle, GetLastError = %d\n", 
               GetLastError()));
        goto exitpt;
    }

    pView = MapViewOfFile(hDupMapF,
                          FILE_MAP_READ,
                          0,
                          0,
                          sizeof(*pView));

    if (!pView)
    {
        TRACE((ERROR_MESSAGE, 
               "GLYPH:Can't map a view,  GetLastError = %d\n", 
               GetLastError()));
        goto exitpt1;
    }

    // Get bitmap size
    nSize = pView->bmpsize;
    if (!nSize)
        goto exitpt1;

    // unmap
    UnmapViewOfFile(pView);

    // remap the whole structure
    pView = MapViewOfFile(hDupMapF,
                          FILE_MAP_READ,
                          0,
                          0,
                          sizeof(*pView) + nSize);

    if (!pView)
    {
        TRACE((ERROR_MESSAGE, 
               "GLYPH:Can't map a view,  GetLastError = %d\n", 
               GetLastError()));
        goto exitpt1;
    }

    if (!Glyph2String(pView, wszFeed, sizeof(wszFeed)/sizeof(WCHAR)))
    {
        goto exitpt1;
    } else {
    }

    rv = _CheckForWaitingWorker(wszFeed, lProcessId);

exitpt1:
    UnmapViewOfFile(pView);
    CloseHandle(hDupMapF);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _CheckForWorkerWaitingDisconnect
 *  Description:
 *      Signals a worker (client thread) wich waits for a disconnect event
 *  Arguments:
 *      dwProcessId -   clients Id
 *  Return value:
 *      TRUE if a client is found and signaled
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _CheckForWorkerWaitingDisconnect(LONG_PTR lProcessId)
{
    PWAIT4STRING pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while(pIter &&
          (pIter->WaitType != WAIT_DISC || 
          pIter->lProcessId != lProcessId))
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        SetEvent(pIter->evWait);
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

/*++
 *  Function:
 *      _CheckForWorkerWaitingConnect
 *  Description:
 *      Signals a worker waiting for a connection
 *  Arguments:
 *      hwndClient  -   clients window handle, this is needed for
 *                      sending messages to the client
 *      dwProcessId -   client Id
 *  Return value:
 *      TRUE if a client is found and signaled
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _CheckForWorkerWaitingConnect(HWND hwndClient, LONG_PTR lProcessId)
{
    PWAIT4STRING pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while(pIter &&
          (pIter->WaitType != WAIT_CONN ||
          pIter->lProcessId != lProcessId))
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        PCONNECTINFO pOwner = pIter->pOwner;

        if (pOwner)
            pOwner->hClient = hwndClient;
        else
            TRACE((WARNING_MESSAGE, "FEED: WAIT4 w/o owner structure"));

        SetEvent(pIter->evWait);
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

/*++
 *  Function:
 *      _CheckForWorkerWaitingConnectAndSetId
 *  Description:
 *      This is intended for RCLX mode. dwProcessId is zero
 *      so this function look for such a client and sets its dwProcessId
 *      Signals a worker waiting for a connection
 *  Arguments:
 *      hwndClient  -   clients window handle, this is needed for
 *                      sending messages to the client
 *      dwProcessId -   client Id
 *  Return value:
 *      connection context, NULL if not found
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
PCONNECTINFO
_CheckForWorkerWaitingConnectAndSetId(HWND hwndClient, LONG_PTR lProcessId)
{
    PWAIT4STRING pIter;
    PCONNECTINFO pOwner = NULL;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while(pIter &&
          (pIter->WaitType != WAIT_CONN ||
          pIter->lProcessId))
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        pOwner = pIter->pOwner;

        if (pOwner)
        {
            ASSERT(pOwner->RClxMode);

            pOwner->hClient = hwndClient;
            pOwner->lProcessId = lProcessId;
            pIter->lProcessId = lProcessId;   // Disable next lookup in
                                                // the same entry
        }
        else
            TRACE((WARNING_MESSAGE, "FEED: WAIT4 w/o owner structure"));

        SetEvent(pIter->evWait);
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pOwner);
}

/*++
 *  Function:
 *      _CheckForWorkerWaitingReconnectAndSetNewId
 *  Description:
 *      This is intended for RCLX mode. When mstsc wants to reconnect
 *      looks for dwLookupId as an ID to reconnect
 *      then sets the new ID
 *      then gets
 *  Arguments:
 *      hwndClient  -   clients window handle, this is needed for
 *                      sending messages to the client
 *      dwLookupId, dwNewId
 *  Return value:
 *      connection context, NULL if not found
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
PCONNECTINFO
_CheckForWorkerWaitingReconnectAndSetNewId(
    HWND hwndClient, 
    DWORD dwLookupId,
    LONG_PTR lNewId)
{
    PWAIT4STRING pIter;
    PCONNECTINFO pOwner = NULL;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while(pIter &&
          (pIter->WaitType != WAIT_CONN ||
           !pIter->pOwner ||
           pIter->pOwner->dwThreadId != dwLookupId ||
           !(pIter->pOwner->bWillCallAgain)))
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        pOwner = pIter->pOwner;

        if (pOwner)
        {
            ASSERT(pOwner->RClxMode);

            pOwner->hClient = hwndClient;
            pOwner->lProcessId = lNewId;
            pIter->lProcessId = lNewId;   // Disable next lookup in
                                            // the same entry
            pOwner->bWillCallAgain = FALSE;
        }
        else
            TRACE((WARNING_MESSAGE, "FEED: WAIT4 w/o owner structure"));

        SetEvent(pIter->evWait);
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pOwner);
}


/*++
 *  Function:
 *      _CancelWaitingWorker
 *  Description:
 *      Releases a worker waiting for any event. 
 *      Eventualy the client is disconnected
 *  Arguments:
 *      dwProcessId - client Id
 *  Return value:
 *      TRUE if a client is found and signaled
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _CancelWaitingWorker(LONG_PTR lProcessId)
{
    PWAIT4STRING pIter;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while(pIter &&
          pIter->lProcessId != lProcessId)
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        SetEvent(pIter->evWait);
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}

/*++
 *  Function:
 *      _CheckForWorkerWaitingClipboard
 *  Description:
 *      Releases a worker waiting for client's clipboard content.
 *  Arguments:
 *      dwProcessId - client Id
 *  Return value:
 *      TRUE if a client is found and signaled
 *  Called by:
 *      _FeedbackWndProc within feedback thread
 --*/
BOOL _CheckForWorkerWaitingClipboard(
    PCONNECTINFO pRClxOwner,
    UINT    uiFormat,
    UINT    nSize,
    PVOID   pClipboard,
    LONG_PTR lProcessId)
{
    PWAIT4STRING pIter = NULL;
    HGLOBAL ghNewClipboard = NULL;
    LPVOID  pNewClipboard = NULL;

    ASSERT(pRClxOwner);

    TRACE((ALIVE_MESSAGE, "Clipboard received, FormatID=%d, Size=%d\n", 
            uiFormat, nSize));

    if (nSize)
    {
        // Copy the clipboard content to new buffer
        ghNewClipboard = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, nSize);
        if (!ghNewClipboard)
        {
            TRACE((ERROR_MESSAGE, "_CheckForWorkerWaitingClipboard: can't allocate %d bytes\n", nSize));
            goto exitpt;
        }

        pNewClipboard = GlobalLock(ghNewClipboard);
        if (!pNewClipboard)
        {
            TRACE((ERROR_MESSAGE, "_CheckForWorkerWaitingClipboard: can't lock global memory\n"));
            goto exitpt;
        }

        memcpy(pNewClipboard, pClipboard, nSize);

        // Unlock the clipboard buffer
        GlobalUnlock(ghNewClipboard);
        pNewClipboard = NULL;

    } else {
        pClipboard = NULL;
    }

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pWaitQHead;
    while(pIter &&
          (pIter->lProcessId != lProcessId ||
           pIter->WaitType != WAIT_CLIPBOARD))
    {
        pIter = pIter->pNext;
    }

    if (pIter)
    {
        PCONNECTINFO pOwner = pIter->pOwner;

        // Put the buffer in the worker's context
        if (pOwner)
        {
            ASSERT(pOwner->RClxMode);
            ASSERT(pOwner == pRClxOwner);

            // pOwner->ghClipboard should be NULL
            ASSERT(pOwner->ghClipboard == NULL);

            pOwner->ghClipboard       = ghNewClipboard;
            pOwner->uiClipboardFormat = uiFormat;
            pOwner->nClipboardSize    = nSize;
        }
        else
            TRACE((WARNING_MESSAGE, "FEED: WAIT4 w/o owner structure"));

        SetEvent(pIter->evWait);
    } else {
        // Can't find anybody waiting, add it to the context owner
        pRClxOwner->ghClipboard       = ghNewClipboard;
        pRClxOwner->uiClipboardFormat = uiFormat;
        pRClxOwner->nClipboardSize    = nSize;
    }
    pRClxOwner->bRClxClipboardReceived = TRUE;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

exitpt:
    if (!pIter)
    // worker not found, clear the allocated buffer
    {
        if (ghNewClipboard)
            GlobalFree(ghNewClipboard);
    }

    return (pIter != NULL);
}

BOOL 
_SetSessionID(LONG_PTR lProcessId, UINT uSessionId)
{
    PCONNECTINFO pIter, pPrev = NULL;

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pIter = g_pClientQHead;
    while (pIter && 
           pIter->lProcessId != lProcessId)
        pIter = pIter->pNext;

    if (pIter)
        pIter->uiSessionId = (uSessionId)?uSessionId:-1;

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    return (pIter != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\queues.h ===
/*++
 *  File name:
 *      queues.h
 *  Contents:
 *      Queue managment functions from queues.c
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

VOID    _AddToWaitQNoCheck(PCONNECTINFO pCI, PWAIT4STRING pWait);
VOID    _AddToWaitQueue(PCONNECTINFO, PWAIT4STRING);
BOOL    _RemoveFromWaitQueue(PWAIT4STRING);
PWAIT4STRING    _RemoveFromWaitQIndirect(PCONNECTINFO, LPCWSTR);
PWAIT4STRING    _RetrieveFromWaitQByEvent(HANDLE);
PWAIT4STRING    _RetrieveFromWaitQByOwner(PCONNECTINFO);
VOID    _FlushFromWaitQ(PCONNECTINFO);
VOID    _AddToClientQ(PCONNECTINFO pClient);
BOOL    _RemoveFromClientQ(PCONNECTINFO pClient);
BOOL    _SetClientDead(LONG_PTR lClientProcessId);
PCONNECTINFO 	_CheckIsAcceptable(LONG_PTR lProcessId, BOOL bRClxType);
BOOL 	_CheckForWaitingWorker(LPCWSTR wszFeed, LONG_PTR lProcessId);
BOOL    _TextOutReceived(LONG_PTR lProcessId, HANDLE hMapF);
BOOL    _GlyphReceived(LONG_PTR lProcessId, HANDLE hMapF);
BOOL 	_CheckForWorkerWaitingDisconnect(LONG_PTR lProcessId);
BOOL    _CheckForWorkerWaitingConnect(HWND hwndClient, LONG_PTR lProcessId);
PCONNECTINFO    
        _CheckForWorkerWaitingConnectAndSetId(HWND hwndClient, 
                                              LONG_PTR lProcessId);
BOOL 	_CancelWaitingWorker(LONG_PTR lProcessId);
BOOL    _CheckForWorkerWaitingClipboard(
    PCONNECTINFO pRClxOwner,
    UINT    uiFormat,
    UINT    nSize,
    PVOID   pClipboard,
    LONG_PTR lProcessId);
PCONNECTINFO
_CheckForWorkerWaitingReconnectAndSetNewId(
    HWND hwndClient,
    DWORD dwLookupId,
    LONG_PTR lNewId);

BOOL    _SetSessionID(LONG_PTR lProcessId, UINT uSessionID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\rclx.c ===
/*++
 *  File name:
 *      rclx.c
 *  Contents:
 *      A module for communicating with clxtshar via TCP/IP
 *      RCLX (Remote CLient eXecution) implemetation
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#include    <windows.h>
#include    <winsock.h>
#include    <malloc.h>
#include    <stdio.h>

#include    "tclient.h"

#define     PROTOCOLAPI __declspec(dllexport)
#include    "protocol.h"

#include    "gdata.h"
#include    "queues.h"
#include    "misc.h"
#include    "bmpcache.h"
#include    "rclx.h"
#include    "extraexp.h"

/*
 *  Globals
 */
u_short g_nPortNumber = RCLX_DEFAULT_PORT;  // Default port to listen
SOCKET  g_hSrvSocket  = INVALID_SOCKET;     // Socket to listen to
PRCLXCONTEXT g_pRClxList = NULL;            // Linked list of all connections
                                            // which havn't receive
                                            // client info

#ifndef SD_RECEIVE
#define SD_RECEIVE      0x00
#define SD_SEND         0x01
#define SD_BOTH         0x02
#endif  // SD_RECEIVE

SOCKET RClx_Listen(u_short  nPortNumber);
VOID RClx_CloseSocket(SOCKET hSocket);
VOID _RClx_RemoveContextFromGlobalQueue(PRCLXCONTEXT pContext);


/*++
 *  Function:
 *      RClx_Init
 *  Description:
 *      Module initialization. Calls WSAStartup, creates a listening
 *      on wich to listen to. Selects FD_ACCEPT as event passed to
 *      the feedback thread/window
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      tclient.c:InitDone
 --*/
BOOL RClx_Init(VOID)
{
    WORD    versionRequested;
    WSADATA wsaData;
    INT     intRC;
    BOOL    rv = FALSE;

    versionRequested = MAKEWORD(1, 1);

    intRC = WSAStartup(versionRequested, &wsaData);

    if (intRC != 0)
    {
        TRACE((ERROR_MESSAGE, 
               "Failed to initialize WinSock rc:%d\n",
               intRC));
        printf("Failed to initialize WinSock rc:%d\n", intRC);
        goto exitpt;
    }

    g_hSrvSocket = RClx_Listen(g_nPortNumber);
    if (g_hSrvSocket == INVALID_SOCKET)
    {
        TRACE((ERROR_MESSAGE, 
               "Can't bind on port: %d\n", 
               g_nPortNumber));
        printf("Can't bind on port: %d\n",
                g_nPortNumber);
        goto exitpt;
    }

    rv = TRUE;
exitpt:
    return rv;
}


/*++
 *  Function:
 *      RClx_Done
 *  Description:
 *      Destruction of the module. Closes the listening socket and
 *      winsocket library
 *  Called by:
 *      tclient.c:InitDone
 --*/
VOID RClx_Done(VOID)
{
    PRCLXCONTEXT pRClxIter;

    // g_pRClxList cleanup
    pRClxIter = g_pRClxList;
    while (pRClxIter)
    {
        RClx_EndRecv(pRClxIter);
        pRClxIter = pRClxIter->pNext;
    }

    if (g_hSrvSocket)
        closesocket(g_hSrvSocket);
    WSACleanup();
}


/*++
 *  Function:
 *      RClx_Listen
 *  Description:
 *      Creates a socket on wich to listen for incoming connections from
 *      clxtshar.dll. Selects the feedback window/thread as a dispatcher
 *      of FD_ACCEPT events, i.e RClx_DispatchWSockEvent will be called
 *      when winsock event occured
 *  Arguments:
 *      nPortNumber - port to listen to
 *  Return value:
 *      INVALID_SOCKET on error, or valid SOCKET of the listening port
 *  Called by:
 *      RClx_Init
 --*/
SOCKET RClx_Listen(u_short  nPortNumber)
{
    struct sockaddr_in sin;
    INT     optval = 1;
    SOCKET  hSocket;

    ASSERT(g_nPortNumber);

    hSocket = socket(AF_INET, SOCK_STREAM, 0);

    if (hSocket == INVALID_SOCKET)
    {
        TRACE((ERROR_MESSAGE, "Can't create socket: %d\n", WSAGetLastError()));
        printf("Can't create socket: %d\n", WSAGetLastError());
        goto exitpt;
    }

    setsockopt(hSocket,                 // Don't linger on socket close
               IPPROTO_TCP, 
               TCP_NODELAY, 
               (const char *)&optval, 
               sizeof(optval));
    setsockopt(hSocket, 
               SOL_SOCKET,  
               SO_DONTLINGER, 
               (const char *)&optval,
               sizeof(optval));

    memset(&sin, 0, sizeof(sin));
    sin.sin_family = PF_INET;
    sin.sin_port = htons(nPortNumber);
    sin.sin_addr.s_addr = INADDR_ANY;

    if (bind(hSocket, (SOCKADDR *)&sin, sizeof(sin)) == SOCKET_ERROR)
    {
        TRACE((ERROR_MESSAGE, "Can't bind: %d\n", WSAGetLastError()));
        printf("Can't bind: %d\n", WSAGetLastError());
        closesocket(hSocket);
        hSocket = INVALID_SOCKET;
        goto exitpt;
    }
    if (listen(hSocket, 5) == SOCKET_ERROR)
    {
        TRACE((ERROR_MESSAGE, "Can't listen: %d\n", WSAGetLastError()));
        printf("Can't listen: %d\n", WSAGetLastError());
        closesocket(hSocket);
        hSocket = INVALID_SOCKET;
        goto exitpt;
    }

    while(!g_hWindow)
    {
        Sleep(500);     // Window is not created yet. Wait !
    }
    if (WSAAsyncSelect(hSocket, g_hWindow, WM_WSOCK, FD_ACCEPT) ==
                       SOCKET_ERROR)
    {
        TRACE((ERROR_MESSAGE, 
               "Can't \"select\" FD_ACCEPT on listening socket: %d\n", 
               WSAGetLastError()));
        printf("Can't \"select\" FD_ACCEPT on listening socket: %d\n",
               WSAGetLastError());
        RClx_CloseSocket(hSocket);
        hSocket = INVALID_SOCKET;
        goto exitpt;
    }

exitpt:
    return hSocket;
}


/*++
 *  Function:
 *      RClx_Accept
 *  Description:
 *      Accepts next connection from g_hSrvSocket
 *  Return value:
 *      INVALID_SOCKET on error, or valid SOCKET of the accepted connection
 *  Called by:
 *      RClx_DispatchWSockEvent upon FD_ACCEPT event
 --*/
SOCKET RClx_Accept(VOID)
{
    struct sockaddr_in sin;
    INT     addrlen;
    SOCKET  hClient;

    ASSERT(g_hSrvSocket != INVALID_SOCKET);

    addrlen = sizeof(sin);

    if ((hClient = accept(g_hSrvSocket, 
                          (struct sockaddr *)&sin, 
                          &addrlen)) == 
         INVALID_SOCKET)
    {
        if (WSAGetLastError() != WSAEWOULDBLOCK)
            TRACE((ERROR_MESSAGE, 
                   "Accept failed: %d\n", 
                   WSAGetLastError()));
        goto exitpt;
    }

exitpt:
    return hClient;
}


/*++
 *  Function:
 *      RClx_StartRecv
 *  Description:
 *      Allocates and initializes context for a connection
 *  Return value:
 *      PRCLXCONTEXT    - pointer to valid RCLX context or NULL on error
 *  Called by:
 *      RClx_DispatchWSockEvent upon FD_ACCEPT event
 --*/
PRCLXCONTEXT RClx_StartRecv(VOID)
{
    PRCLXCONTEXT pContext;

    pContext = malloc(sizeof(*pContext));

    if (!pContext)
        goto exitpt;

    memset(pContext, 0, sizeof(*pContext));

exitpt:
    return pContext;
}

/*++
 *  Function:
 *      RClx_EndRecv
 *  Description:
 *      Frees all resources allocated within an RCLX context
 *      and the context itself.
 *      Becaus the RCLX context is kept in hClient member of CONNECTINFO
 *      structure, the caller of this function have to zero pCI->hClient
 *  Arguments:
 *      pContext    - an RCLX context
 *  Called by:
 *      RClx_DispatchWSockEvent upon FD_ACCEPT event when fail to
 *          find waiting worker or
 *      scfuncs.c:_CloseConnectionInfo
 --*/
VOID RClx_EndRecv(PRCLXCONTEXT pContext)
{

    ASSERT(pContext);

    if (pContext->pHead)
    {
        free(pContext->pHead);
        pContext->pHead = NULL;
    }

    if (pContext->pTail)
    {
        free(pContext->pTail);
        pContext->pTail = NULL;
    }

    if (pContext->hSocket && pContext->hSocket != INVALID_SOCKET)
    {
        RClx_CloseSocket(pContext->hSocket);
    }

    free(pContext);

}


/*++
 *  Function:
 *      RClx_Receive
 *  Description:
 *      RCLXCONTEXT contains a buffer for incoming message
 *      this function trys to receive it all. If the socket blocks
 *      the function exits with OK and next time FD_READ is received will 
 *      be called again. If a whole message is received pContext->bRecvDone
 *      is set to TRUE. This is an indication that message arrived
 *  Arguments:
 *      pContext    - RCLX context
 *  Return value:
 *      TRUE if everithing went OK. FALSE if socket must be closed
 *  Called by:
 *      RClx_DispatchWSockEvent upon FD_READ event
 --*/
BOOL RClx_Receive(PRCLXCONTEXT pContext)
{
    INT  result = 0;
    SOCKET  hSocket;

    ASSERT(pContext);
    hSocket = pContext->hSocket;
    ASSERT(hSocket != INVALID_SOCKET);

    do {
        if (!pContext->bPrologReceived)
        {
        // Receive the prolog
            result = recv(hSocket, 
                          ((BYTE *)&(pContext->Prolog)) +
                          sizeof(pContext->Prolog) - pContext->nBytesToReceive, 
                          pContext->nBytesToReceive,
                          0);
            if (result != SOCKET_ERROR)
            {
                pContext->nBytesToReceive -= result;
                if (!pContext->nBytesToReceive)
                {
                    pContext->bPrologReceived = TRUE;

                    result = 1; // Hack, otherwise the loop can exit

                    pContext->nBytesToReceive = pContext->Prolog.HeadSize;

                    // Check if we have proper buffers allocated
alloc_retry:
                    if (pContext->Prolog.HeadSize)
                      if (!pContext->pHead)
                        pContext->pHead = malloc(pContext->Prolog.HeadSize);

                      else if (pContext->Prolog.HeadSize > 
                            pContext->nHeadAllocated)

                        pContext->pHead = realloc(pContext->pHead,
                                                  pContext->Prolog.HeadSize);

                    if (pContext->Prolog.TailSize)
                      if (!pContext->pTail)
                        pContext->pTail = malloc(pContext->Prolog.TailSize);

                      else if (pContext->Prolog.TailSize >
                            pContext->nTailAllocated)
                       pContext->pTail = realloc(pContext->pTail,
                                                 pContext->Prolog.TailSize);

                    if ((pContext->Prolog.HeadSize && !pContext->pHead) 
                        || 
                        (pContext->Prolog.TailSize && !pContext->pTail))
                    {
                        TRACE((WARNING_MESSAGE, 
                               "Can't (re)allocate memory. Sleep for a minute"));
                        Sleep(60000);
                        goto alloc_retry;
                    } else {
                        pContext->nHeadAllocated = pContext->Prolog.HeadSize;
                        pContext->nTailAllocated = pContext->Prolog.TailSize;
                    }
                }
            }
        } else if (!pContext->bHeadReceived)
        {
        // Receive the message head
            if (pContext->nBytesToReceive)
                result = recv(hSocket,
                          ((BYTE *)pContext->pHead) +
                          pContext->Prolog.HeadSize - pContext->nBytesToReceive,
                          pContext->nBytesToReceive,
                          0);
            else
                result = 0;

            if (result != SOCKET_ERROR)
            {
                pContext->nBytesToReceive -= result;
                if (!pContext->nBytesToReceive)
                {
                    pContext->bHeadReceived   = TRUE;
                    pContext->nBytesToReceive = pContext->Prolog.TailSize;
                    result = 1; // Hack, otherwise the loop can exit
                }
            }
        } else {
        // Receive the message tail (actual info)
            if (pContext->nBytesToReceive)
                result = recv(hSocket,
                          ((BYTE *)pContext->pTail) +
                          pContext->Prolog.TailSize - pContext->nBytesToReceive,
                          pContext->nBytesToReceive,
                          0);
            else
                result = 0;

            if (result != SOCKET_ERROR)
            {
                pContext->nBytesToReceive -= result;
                if (!pContext->nBytesToReceive)
                {
                // Cool, we have the whole message
                    pContext->bRecvDone = TRUE;
                    pContext->bPrologReceived = FALSE;
                    pContext->bHeadReceived = FALSE;
                    pContext->nBytesToReceive = sizeof(pContext->Prolog);
                    result = 1; // Hack, otherwise the loop can exit
                }
            }
        }

    } while (result != 0 && !pContext->bRecvDone &&
             result != SOCKET_ERROR);

// At this point the message is not 100%
// received
// Only pContext->bRecvDone indicates this

    // return FALSE if error is occured

    if (!result)
        return FALSE;       // connection was gracefully closed

    if (result == SOCKET_ERROR)
    {
        if (WSAGetLastError() == WSAEWOULDBLOCK)
            return TRUE;    // the call will block, but ok
        else
            return FALSE;   // other SOCKET_ERROR
    }

    return TRUE;            // it is ok
}

VOID
_RClx_Bitmap(PRCLXCONTEXT pContext)
{
    WCHAR   wszFeed[MAX_STRING_LENGTH];
    PBMPFEEDBACK pBmpFeed;
    PRCLXBITMAPFEED pRClxFeed = pContext->pHead;

    // If BitmapInfo is empty (glyph) it's not sent
    // Hence the HeadSize is smaller
    if (pContext->Prolog.HeadSize > sizeof(*pRClxFeed))
    {
        TRACE((WARNING_MESSAGE, 
               "BitmapOut: Received header is larger than expected\n"));
        ASSERT(0);
        goto exitpt;
    }

    if (pContext->Prolog.TailSize != pRClxFeed->bmpsize)
    {
        TRACE((WARNING_MESSAGE,
               "BitmapOut: Received bits are not equal to expected."
               "Expect:%d, read:%d\n",
                pRClxFeed->bmpsize, pContext->Prolog.TailSize));
        ASSERT(0);
        goto exitpt;
    }

    pBmpFeed = _alloca(sizeof(*pBmpFeed) + pRClxFeed->bmisize + pRClxFeed->bmpsize);
    if (!pBmpFeed)
    {
        TRACE((WARNING_MESSAGE,
               "BitmapOut:alloca failed to allocate 0x%x bytes\n", 
               sizeof(*pBmpFeed) + pRClxFeed->bmpsize));
        goto exitpt;
    }

    pBmpFeed->lProcessId   = pContext->hSocket;
    pBmpFeed->bmpsize       = pRClxFeed->bmpsize;
    pBmpFeed->bmiSize       = pRClxFeed->bmisize;
    pBmpFeed->xSize         = pRClxFeed->xSize;
    pBmpFeed->ySize         = pRClxFeed->ySize;

    // Check and copy bitmapinfo
    if (pBmpFeed->bmiSize > sizeof(pBmpFeed->BitmapInfo))
    {
        TRACE((WARNING_MESSAGE, 
               "BitmapOut:BITMAPINFO is more than expected. Rejecting\n"));
        goto exitpt;
    }
    memcpy(&(pBmpFeed->BitmapInfo), 
           &(pRClxFeed->BitmapInfo), 
           pBmpFeed->bmiSize);

    // Copy the bits after the structure
    memcpy(((BYTE *)(&pBmpFeed->BitmapInfo)) + pBmpFeed->bmiSize, 
           pContext->pTail,
           pContext->Prolog.TailSize);

    // Convert the glyph
    if (!Glyph2String(pBmpFeed, wszFeed, sizeof(wszFeed)/sizeof(WCHAR)))
    {
        goto exitpt;
    }

    _CheckForWaitingWorker(wszFeed, (DWORD)(pContext->hSocket));

exitpt:
    ;

}

/*++
 *  Function:
 *      RClx_MsgReceived
 *  Description:
 *      Dispatches a received message. Converts it in proper internal
 *      format and passes it to some queues.c function to find a waiting
 *      worker
 *      The message is in the RCLX context.
 *  Arguments:
 *      pContext    - RCLX context
 *  Called by:
 *      RClx_DispatchWSockEvent upon FD_READ event
 --*/
VOID RClx_MsgReceived(PRCLXCONTEXT pContext)
{
    UINT32 *puSessionID;

    ASSERT(pContext);
    ASSERT(pContext->pOwner);

    switch(pContext->Prolog.FeedType)
    {
        case FEED_CONNECT:
            _CheckForWorkerWaitingConnect((HWND)pContext, pContext->hSocket);
            break;
        case FEED_LOGON:
            puSessionID = (UINT *)pContext->pHead;

            ASSERT(puSessionID);
            _SetSessionID(pContext->hSocket, *puSessionID);
            break;
        case FEED_DISCONNECT:
            _SetClientDead(pContext->hSocket);
            _CheckForWorkerWaitingDisconnect(pContext->hSocket);
            _CancelWaitingWorker(pContext->hSocket);
            break;
        case FEED_BITMAP:
            _RClx_Bitmap(pContext);
            break;
        case FEED_TEXTOUT:
            //TRACE((WARNING_MESSAGE, "TEXTOUT order is not implemented\n"));
            // pContext->pHead - unused
            _CheckForWaitingWorker(
                (LPCWSTR)(pContext->pTail), 
                (DWORD)(pContext->hSocket));
            break;
        case FEED_TEXTOUTA:
            TRACE((WARNING_MESSAGE, "TEXTOUTA order not implemented\n"));
            break;
        case FEED_CLIPBOARD:
        {
            PRCLXCLIPBOARDFEED pRClxClipFeed = pContext->pHead;

            _CheckForWorkerWaitingClipboard(
                pContext->pOwner,
                pRClxClipFeed->uiFormat,
                pRClxClipFeed->nClipBoardSize,
                pContext->pTail, 
                (DWORD)(pContext->hSocket));
        }
            break;
        case FEED_CLIENTINFO:
            ASSERT(0);  // Shouldn't appear here
            break;
        case FEED_WILLCALLAGAIN:
            TRACE((INFO_MESSAGE, "WILLCALLAGAIN received, disconnecting the client\n"));
            ASSERT(pContext->pOwner);

            EnterCriticalSection(g_lpcsGuardWaitQueue);
            pContext->pOwner->bWillCallAgain = TRUE;
            pContext->pOwner->dead = TRUE;
            _CancelWaitingWorker(pContext->hSocket);
            pContext->pOwner->hClient = NULL;
            LeaveCriticalSection(g_lpcsGuardWaitQueue);

            _RClx_RemoveContextFromGlobalQueue(pContext);
            RClx_EndRecv(pContext);
            break;
        case FEED_DATA:
        {
            PCONNECTINFO pCI;
            PRCLXDATA       pRClxData;
            PRCLXDATACHAIN  pNewEntry;
            PWAIT4STRING    pWait;

            TRACE((ALIVE_MESSAGE, "RClx data arrived\n"));

            pCI = pContext->pOwner;
            ASSERT(pCI);
            pRClxData = (PRCLXDATA)pContext->pHead;
            ASSERT(pRClxData);
            ASSERT(pRClxData->uiSize + sizeof(*pRClxData) == 
                    (pContext->Prolog.HeadSize));

            pWait = _RetrieveFromWaitQByOwner(pCI);

            pNewEntry = malloc(sizeof(*pNewEntry) + pRClxData->uiSize);

            if (!pNewEntry)
            {
                // trash out the received data
                TRACE((WARNING_MESSAGE,
                       "Can't allocate %d bytes for RCLXDATACHAIN\n",
                       pContext->Prolog.HeadSize));
                break;
            }

            pNewEntry->uiOffset = 0;
            pNewEntry->pNext    = NULL;
            memcpy(&pNewEntry->RClxData, 
                   pRClxData, 
                   pContext->Prolog.HeadSize);

            EnterCriticalSection(g_lpcsGuardWaitQueue);
            if (!pCI->pRClxDataChain)
                pCI->pRClxDataChain = pCI->pRClxLastDataChain = pNewEntry;
            else
            {
                ASSERT(pCI->pRClxLastDataChain);
                pCI->pRClxLastDataChain->pNext = pNewEntry;
                pCI->pRClxLastDataChain = pNewEntry;
            }

            // signal the worker
            if (pWait &&
                pWait->WaitType == WAIT_DATA)
                SetEvent(pWait->evWait);
            else
                TRACE((WARNING_MESSAGE, "no event to signal\n"));

            LeaveCriticalSection(g_lpcsGuardWaitQueue);

            break;
        }
        default:
            ASSERT(0);
    }

}


/*++
 *  Function:
 *      RClx_SendBuffer
 *  Description:
 *      Sends a buffer thru socket. The socket must be BLOCKING
 *      so, all the buffer is send after this function exits
 *  Arguments:
 *      hSocket     - the socket
 *      pBuffer     - the buffer
 *      nSize       - buffer size
 *  Return value:
 *      TRUE on success, FALSE if the connection failed
 *  Called by:
 *      RClx_SendMessage, RClx_SendConnectInfo
 --*/
BOOL RClx_SendBuffer(SOCKET hSocket, PVOID pBuffer, UINT nSize)
{
    INT result = 0;
    UINT nBytesToSend = nSize;

    ASSERT(hSocket != INVALID_SOCKET);
    ASSERT(pBuffer);

    if (!nSize)
        goto exitpt;

    do {
        result = send(hSocket, pBuffer, nBytesToSend, 0);

        if (result != SOCKET_ERROR)
        {
            nBytesToSend -= result;
            (BYTE *)pBuffer += result;
        } else
        if (WSAGetLastError() == WSAEWOULDBLOCK)
        {
        // The socket is blocked, wait on select until it's writable
            FD_SET fd;

            FD_ZERO(&fd);
            FD_SET(hSocket, &fd);

            result = select(-1, NULL, &fd, NULL, NULL);
        }
    } while (result != SOCKET_ERROR && nBytesToSend);

exitpt:
    return (result != SOCKET_ERROR);
}


/*++
 *  Function:
 *      RClx_SendMessage
 *  Description:
 *      Sends an window message to the client
 *  Arguments:
 *      pContext    - RCLX context
 *      uiMessage   - message Id
 *      wParam      - word parameter
 *      lParam      - long parameter
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      scfuncs.c:SCSenddata
 --*/
BOOL RClx_SendMessage(PRCLXCONTEXT pContext,
                      UINT uiMessage, 
                      WPARAM wParam, 
                      LPARAM lParam)
{
    RCLXMSG ClxMsg;
    RCLXREQPROLOG ReqProlog;
    SOCKET  hSocket;
    BOOL    rv = TRUE;

    ASSERT(pContext);
    hSocket = pContext->hSocket;
    ASSERT(hSocket != INVALID_SOCKET);

    ReqProlog.ReqType = REQ_MESSAGE;
    ReqProlog.ReqSize = sizeof(ClxMsg);
    ClxMsg.message = uiMessage;
    ClxMsg.wParam  = (UINT32)wParam;
    ClxMsg.lParam  = (UINT32)lParam;

    // Send the request prolog
    rv = RClx_SendBuffer(pContext->hSocket, &ReqProlog, sizeof(ReqProlog));
    if (!rv)
    {
        TRACE((ERROR_MESSAGE, "Can't send: %d\n", WSAGetLastError()));
        goto exitpt;
    }

    // Try to send the whole message
    rv = RClx_SendBuffer(pContext->hSocket, &ClxMsg, sizeof(ClxMsg));
    if (!rv)
    {
        TRACE((ERROR_MESSAGE, "Can't send: %d\n", WSAGetLastError()));
        goto exitpt;
    }

    if (strstr(pContext->pOwner->szClientType, "WIN16") != NULL)
        Sleep(100);  // Don't send very fast to WIN16
exitpt:
    return rv;
}


/*++
 *  Function:
 *      RClx_SendConnectInfo
 *  Description:
 *      Sends the information to the client about Hydra server to connect to
 *      like, server name, resolution etc
 *  Arguments:
 *      pContext    -   RCLX context
 *      xRes, yRes  -   resolution
 *      ConnectionFlags -
 *      -   the "client/hydra server" connection 
 *                      will be compressed
 *      - 
 *                      the bitmaps received by the client will be saved
 *                      on the disc
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      scfuncs.c:SCConnect
 --*/
BOOL RClx_SendConnectInfo(PRCLXCONTEXT pContext,
                          LPCWSTR wszHydraServer,
                          INT xRes,
                          INT yRes,
                          INT ConnectionFlags)
{
    RCLXREQPROLOG ReqProlog;
    SOCKET  hSocket;
    RCLXCONNECTINFO ClxInfo;
    BOOL    rv;

    ASSERT(pContext);
    ASSERT(pContext->pOwner);

    hSocket = pContext->hSocket;
    ASSERT(hSocket != INVALID_SOCKET);

    ReqProlog.ReqType = REQ_CONNECTINFO;
    ReqProlog.ReqSize = sizeof(ClxInfo);

    ClxInfo.YourID = pContext->pOwner->dwThreadId;
    ClxInfo.xResolution = xRes;
    ClxInfo.yResolution = yRes;
    ClxInfo.bLowSpeed   = (ConnectionFlags & TSFLAG_COMPRESSION)?TRUE:FALSE;
    ClxInfo.bPersistentCache = (ConnectionFlags & TSFLAG_BITMAPCACHE)?TRUE:FALSE;
    WideCharToMultiByte(
        CP_ACP,
        0,
        wszHydraServer,
        -1,
        ClxInfo.szHydraServer,
        sizeof(ClxInfo.szHydraServer),
        NULL, NULL);

    // Send the request prolog
    rv = RClx_SendBuffer(pContext->hSocket, &ReqProlog, sizeof(ReqProlog));
    if (!rv)
    {
        TRACE((ERROR_MESSAGE, "Can't send: %d\n", WSAGetLastError()));
        goto exitpt;
    }

    // Try to send the whole message
    rv = RClx_SendBuffer(pContext->hSocket, &ClxInfo, sizeof(ClxInfo));
    if (!rv)
    {
        TRACE((ERROR_MESSAGE, "Can't send: %d\n", WSAGetLastError()));
        goto exitpt;
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      RClx_SendClipboard
 *  Description:
 *      Sends a new clipboard content for the client machine
 *  Arguments:
 *      pContext    -   RCLX context
 *      pClipboard  -   clipboard content
 *      nDataLength -   data length
 *      uiFormat    -   the clipboard format
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      scfuncs.c:SCClipboard
 --*/
BOOL RClx_SendClipboard(
    PRCLXCONTEXT pContext,
    PVOID        pClipboard,
    UINT         nDataLength,
    UINT         uiFormat)
{
    RCLXREQPROLOG   ReqProlog;
    SOCKET          hSocket;
    RCLXCLIPBOARD   SetClipReq;
    BOOL            rv = FALSE;

    ASSERT(pContext);
    ASSERT((pClipboard && nDataLength) || (!pClipboard && !nDataLength));

    hSocket = pContext->hSocket;
    ASSERT(hSocket != INVALID_SOCKET);

    ReqProlog.ReqType = REQ_SETCLIPBOARD;
    ReqProlog.ReqSize = sizeof(SetClipReq) + nDataLength;

    SetClipReq.uiFormat = uiFormat;

    // Send the request prolog
    rv = RClx_SendBuffer(pContext->hSocket, &ReqProlog, sizeof(ReqProlog));
    if (!rv)
    {
        TRACE((ERROR_MESSAGE, "Can't send: %d\n", WSAGetLastError()));
        goto exitpt;
    }

    rv = RClx_SendBuffer(pContext->hSocket, &SetClipReq, sizeof(SetClipReq));
    if (!rv)
    {
        TRACE((ERROR_MESSAGE, "Can't send: %d\n", WSAGetLastError()));
        goto exitpt;
    }

    // Send the data after all (if any)
    if (pClipboard)
    {
        rv = RClx_SendBuffer(pContext->hSocket, pClipboard, nDataLength);
        if (!rv)
        {
            TRACE((ERROR_MESSAGE, "Can't send: %d\n", WSAGetLastError()));
            goto exitpt;
        }
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      RClx_SendClipboardRequest
 *  Description:
 *      Request the clipboard content from the client machine
 *  Arguments:
 *      pContext    -   RCLX context
 *      uiFormat    -   the desired clipboard format
 *  Return value:
 *      TRUE on success
 *  Called by:
 *      scfuncs.c:SCClipboard
 --*/
BOOL RClx_SendClipboardRequest(
    PRCLXCONTEXT pContext,
    UINT         uiFormat)
{
    RCLXREQPROLOG   ReqProlog;
    SOCKET          hSocket;
    RCLXCLIPBOARD   GetClipReq;
    BOOL            rv = FALSE;

    ASSERT(pContext);
    ASSERT(pContext->pOwner);
    hSocket = pContext->hSocket;
    ASSERT(hSocket != INVALID_SOCKET);

    pContext->pOwner->bRClxClipboardReceived = FALSE;

    ReqProlog.ReqType = REQ_GETCLIPBOARD;
    ReqProlog.ReqSize = sizeof(GetClipReq);

    GetClipReq.uiFormat = uiFormat;

    // Send the request prolog
    rv = RClx_SendBuffer(pContext->hSocket, &ReqProlog, sizeof(ReqProlog));
    if (!rv)
    {
        TRACE((ERROR_MESSAGE, "Can't send: %d\n", WSAGetLastError()));
        goto exitpt;
    }

    rv = RClx_SendBuffer(pContext->hSocket, &GetClipReq, sizeof(GetClipReq));
    if (!rv)
    {
        TRACE((ERROR_MESSAGE, "Can't send: %d\n", WSAGetLastError()));
        goto exitpt;
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      RClx_CloseSocket
 *  Description:
 *      Gracefully closes a socket
 *  Arguments:
 *      hSocket     - socket for closing
 *  Called by:
 *      RClx_EndRecv
 *      RClx_DispatchWSockEvent
 *      RClx_Listen
 --*/
VOID RClx_CloseSocket(SOCKET hSocket)
{
    BYTE tBuf[128];
    INT  recvresult;

    ASSERT(hSocket != INVALID_SOCKET);

    WSAAsyncSelect(hSocket, g_hWindow, 0, 0);

    shutdown(hSocket, SD_SEND);
    do {
        recvresult = recv(hSocket, tBuf, sizeof(tBuf), 0);
    } while (recvresult && recvresult != SOCKET_ERROR);

    closesocket(hSocket);
}

//
// search & destroy from g_pRClxList
//
VOID _RClx_RemoveContextFromGlobalQueue(PRCLXCONTEXT pContext)
{
    PRCLXCONTEXT pRClxIter = g_pRClxList;
    PRCLXCONTEXT pRClxPrev = NULL;

    while (pRClxIter && pRClxIter != pContext)
    {
        pRClxPrev = pRClxIter;
        pRClxIter = pRClxIter->pNext;
    }

    if (!pRClxIter)
        goto exitpt;

    if (!pRClxPrev)
        g_pRClxList = pContext->pNext;
    else
        pRClxPrev->pNext = pContext->pNext;

exitpt:
    ;
}

/*+++
 *  Function: 
 *      _AddRClxContextToClientConnection
 *  Description:
 *      FEED_CLIENTINFO is received, now find a proper thread to assign the
 *      RCLX context
 *  Argument:
 *      pRClxCtx    - RCLX context
 *  Called by:
 *      RClx_DispatchWSockEvent
 *
 --*/
VOID
_AddRClxContextToClientConnection(PRCLXCONTEXT pRClxCtx)
{
    PRCLXCLIENTINFOFEED pClntInfo;
    PCONNECTINFO pCI;

    ASSERT(pRClxCtx);
    ASSERT(pRClxCtx->Prolog.FeedType == FEED_CLIENTINFO);

    EnterCriticalSection(g_lpcsGuardWaitQueue);

    pClntInfo = (PRCLXCLIENTINFOFEED)(pRClxCtx->pHead);

    ASSERT(pClntInfo);

    TRACE((ALIVE_MESSAGE, 
           "CLIENTINFO received, recon=%d info: %s\n", 
           pClntInfo->nReconnectAct,
           pClntInfo->szClientInfo));

    // If nReconnectAct is non zero then lookup for thread which waits
    // reconnection
    if (pClntInfo->nReconnectAct)
    {
        ASSERT(pClntInfo->ReconnectID);
        // Identify by dwProcessId
        pCI = _CheckForWorkerWaitingReconnectAndSetNewId(
                    (HWND)pRClxCtx,
                    (DWORD)pClntInfo->ReconnectID,
                    (DWORD)pRClxCtx->hSocket);

        if (!pCI)
        {
            TRACE((WARNING_MESSAGE,
                   "Nobody is waiting for REconnect."
                   " Disconnecting the socket\n"));
            _RClx_RemoveContextFromGlobalQueue(pRClxCtx);
            RClx_EndRecv(pRClxCtx);
        } else {
            _snprintf(pCI->szClientType, sizeof(pCI->szClientType),
                      "%s",
                      pClntInfo->szClientInfo);
            pRClxCtx->pOwner = pCI;
        }
        goto exitpt;
    }

    // Get the first waiting for connect from remote clx
    // accepted socket goes into dwProcessId
    // pRClxCtx goes int hClient member of CONNECTINFO
    // structure. In order to determine the different IDs
    // (one is process Id, and second one is socket)
    // a member bRClxMode is used
    pCI = _CheckForWorkerWaitingConnectAndSetId((HWND)pRClxCtx,
                                                (DWORD)pRClxCtx->hSocket);
    if (!pCI)
    {
        TRACE((WARNING_MESSAGE,
               "Nobody is waiting for connect."
               " Disconnecting the socket\n"));
        _RClx_RemoveContextFromGlobalQueue(pRClxCtx);
        RClx_EndRecv(pRClxCtx);
        goto exitpt;
    } else {
        _snprintf(pCI->szClientType, sizeof(pCI->szClientType),
                  "%s",
                  pClntInfo->szClientInfo);
        pRClxCtx->pOwner = pCI;
    }

exitpt:

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

}

/*++
 *  Function:
 *      RClx_DispatchWSockEvent
 *  Description:
 *      Dispatches winsock events: FD_ACCEPT, FD_READ and FD_CLOSE
 *      The event is passed by the feedback window/thread
 *  Arguments:
 *      hSocket     - the socket for which the event is
 *      lEvent      - actualy lParam of the winsock message
 *                    contains the event and error (if any)
 *  Called by:
 *      tclient.c:_FeedbackWndProc
 --*/
VOID RClx_DispatchWSockEvent(SOCKET hSocket, LPARAM lEvent)
{
    SOCKET hClient;
    PCONNECTINFO    pCI;
    PRCLXCONTEXT    pRClxCtx;

    if (WSAGETSELECTERROR(lEvent))
    {
        TRACE((ERROR_MESSAGE,
               "Select error: %d\n",
               WSAGETSELECTERROR(lEvent)));
        goto perform_close; // On error
                            // behave like the socket is closed
    }

    switch(WSAGETSELECTEVENT(lEvent))
    {
        case FD_ACCEPT:
            // Accept all incoming sockets
            // look in our WaitQ for a free worker waiting connection
            // if there's no free worker disconnect the socket
            // so the remote side knows that connection is unwanted

            ASSERT(hSocket == g_hSrvSocket);
            // Accept all incoming connections
            while ((hClient = RClx_Accept()) != INVALID_SOCKET)
            {

                // Put this socket in Async receive mode
                // The first operation is send, so we well not lose
                // FD_READ message
                if (WSAAsyncSelect(hClient, 
                                   g_hWindow, 
                                   WM_WSOCK, 
                                   FD_READ|FD_CLOSE) == SOCKET_ERROR)
                {
                    TRACE((ERROR_MESSAGE,
                           "Can't \"select\" client socket: %d."
                           "Disconnecting the socket\n",
                           WSAGetLastError()));
                    RClx_CloseSocket(hClient);
                    goto exitpt;
                }

                // Allocate our context
                pRClxCtx = RClx_StartRecv();
                if (!pRClxCtx)
                {
                    TRACE((WARNING_MESSAGE,
                           "Can't allocate memmory. Disconnecting the socket\n"));
                    RClx_CloseSocket(hClient);
                    goto exitpt;
                }
                pRClxCtx->hSocket = hClient;
                pRClxCtx->nBytesToReceive = sizeof(pRClxCtx->Prolog);

                // Add this context to the list of connections which didn't
                // receive their FEED_CLIENTINFO yet
                // we don't need crit sect, 'cause this is single thread op
                pRClxCtx->pNext = g_pRClxList;
                g_pRClxList = pRClxCtx;
                PostMessage(g_hWindow, WM_WSOCK, hClient, FD_READ);
            }

            break;

        case FD_READ:
            // Check first if this comes from RClxList socket
            pRClxCtx = g_pRClxList;
            while (pRClxCtx && pRClxCtx->hSocket != hSocket)
                pRClxCtx = pRClxCtx->pNext;

            if (pRClxCtx)
            {
                RClx_Receive(pRClxCtx);
                if (pRClxCtx->bRecvDone)
                {
                    pRClxCtx->bRecvDone = FALSE;
                    if (pRClxCtx->Prolog.FeedType == FEED_CLIENTINFO)
                    {

                        _RClx_RemoveContextFromGlobalQueue(pRClxCtx);

                        pRClxCtx->pNext = NULL;
                        
                        //
                        // Don't use pRClxCtx past this point
                        // this function could call RClx_EndRecv
                        //
                        _AddRClxContextToClientConnection(pRClxCtx);

                    }
                    break;
                }
            }


            // What if the connection is closed here ?!
            // Solution: use the same critical section as the queue manager
            EnterCriticalSection(g_lpcsGuardWaitQueue);
            pCI = _CheckIsAcceptable((DWORD)hSocket, TRUE);

            if (pCI && pCI->hClient)
            {
                pRClxCtx = (PRCLXCONTEXT)pCI->hClient;

                RClx_Receive(pRClxCtx);
                if (pRClxCtx->bRecvDone)
                {
                    pRClxCtx->bRecvDone = FALSE;
                    RClx_MsgReceived(pRClxCtx);
                }
            }
            LeaveCriticalSection(g_lpcsGuardWaitQueue);

            break;

        case FD_CLOSE:
perform_close:
            // The socket closes, "last call" for the worker
            pCI = _CheckIsAcceptable((DWORD)hSocket, TRUE);

            if (pCI)
            {
                _SetClientDead((DWORD)hSocket);
                _CheckForWorkerWaitingDisconnect((DWORD)hSocket);
                _CancelWaitingWorker((DWORD)hSocket);
            }
            break;
        default:
            ASSERT(0);
    }

exitpt:
    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\scfuncs.c ===
/*++
 *  File name:
 *      scfuncs.c
 *  Contents:
 *      Functions exported to smclient intepreter
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/
#include    <windows.h>
#include    <stdio.h>
#include    <malloc.h>
#include    <process.h>
#include    <string.h>
#include    <stdlib.h>
#include    <ctype.h>
#include    <stdlib.h>
#include    <io.h>
#include    <fcntl.h>
#include    <sys/stat.h>

#include    <winsock.h>

#include    "tclient.h"

#define     PROTOCOLAPI
#include    "protocol.h"

#include    "gdata.h"
#include    "queues.h"
#include    "misc.h"
#include    "rclx.h"
#include    "..\..\bmplib\bmplib.h"

// This structure is used by _FindTopWindow
typedef struct _SEARCHWND {
    TCHAR   *szClassName;       // The class name of searched window,
                                // NULL - ignore
    TCHAR   *szCaption;         // Window caption, NULL - ignore
    LONG_PTR lProcessId;        // Process Id of the owner, 0 - ignore
    HWND    hWnd;               // Found window handle
} SEARCHWND, *PSEARCHWND;

/*
 *  Internal exported functions
 */
LPCSTR  Wait4Str(PCONNECTINFO, LPCWSTR);
LPCSTR  Wait4StrTimeout(PCONNECTINFO, LPCWSTR);
LPCSTR  Wait4MultipleStr(PCONNECTINFO, LPCWSTR);
LPCSTR  Wait4MultipleStrTimeout(PCONNECTINFO, LPCWSTR);
LPCSTR  GetWait4MultipleStrResult(PCONNECTINFO, LPCWSTR);
LPCSTR  GetFeedbackString(PCONNECTINFO, LPSTR result, UINT max);
LPCSTR  Wait4Disconnect(PCONNECTINFO);
LPCSTR  Wait4Connect(PCONNECTINFO);
LPCSTR  RegisterChat(PCONNECTINFO pCI, LPCWSTR lpszParam);
LPCSTR  UnregisterChat(PCONNECTINFO pCI, LPCWSTR lpszParam);
LPCSTR  GetDisconnectReason(PCONNECTINFO pCI);
PROTOCOLAPI
LPCSTR  SMCAPI SCSendtextAsMsgs(PCONNECTINFO, LPCWSTR);
PROTOCOLAPI
LPCSTR  SMCAPI SCSwitchToProcess(PCONNECTINFO pCI, LPCWSTR lpszParam);
PROTOCOLAPI
LPCSTR  SMCAPI SCSetClientTopmost(PCONNECTINFO pCI, LPCWSTR lpszParam);
PROTOCOLAPI
LPCSTR  SMCAPI SCSendMouseClick(PCONNECTINFO pCI, UINT xPos, UINT yPos);
PROTOCOLAPI
LPCSTR  SMCAPI SCGetClientScreen(PCONNECTINFO pCI, INT left, INT top, INT right, INT bottom, UINT  *puiSize, PVOID *ppDIB);
PROTOCOLAPI
LPCSTR  SMCAPI SCSaveClientScreen(PCONNECTINFO pCI, INT left, INT top, INT right, INT bottom, LPCSTR szFileName);

/*
 *  Intenal functions definition
 */
LPCSTR  _Wait4ConnectTimeout(PCONNECTINFO pCI, DWORD dwTimeout);
LPCSTR  _Wait4ClipboardTimeout(PCONNECTINFO pCI, DWORD dwTimeout);
LPCSTR  _SendRClxData(PCONNECTINFO pCI, PRCLXDATA pRClxData);
LPCSTR  _Wait4RClxDataTimeout(PCONNECTINFO pCI, DWORD dwTimeout);
LPCSTR  _Wait4Str(PCONNECTINFO, LPCWSTR, DWORD dwTimeout, WAITTYPE);
LPCSTR  _WaitSomething(PCONNECTINFO pCI, PWAIT4STRING pWait, DWORD dwTimeout);
VOID    _CloseConnectInfo(PCONNECTINFO);
LPCSTR  _Login(PCONNECTINFO, LPCWSTR, LPCWSTR, LPCWSTR);
HWND    _FindTopWindow(LPTSTR, LPTSTR, LONG_PTR);
HWND    _FindWindow(HWND, LPTSTR, LPTSTR);
BOOL    _IsExtendedScanCode(INT scancode);

/*
 *  Clipboard help functions (clputil.c)
 */
VOID
Clp_GetClipboardData(
    UINT format,
    HGLOBAL hClipData,
    INT *pnClipDataSize,
    HGLOBAL *phNewData);

BOOL
Clp_SetClipboardData(
    UINT formatID,
    HGLOBAL hClipData,
    INT nClipDataSize,
    BOOL *pbFreeHandle);

UINT
Clp_GetClipboardFormat(LPCSTR szFormatLookup);

BOOL
Clp_EmptyClipboard(VOID);

BOOL
Clp_CheckEmptyClipboard(VOID);

UINT
_GetKnownClipboardFormatIDByName(LPCSTR szFormatName);

/*++
 *  Function:
 *      SCInit
 *  Description:
 *      Called by smclient after the library is loaded.
 *      Passes trace routine
 *  Arguments:
 *      pInitData   - contains a trace routine
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
VOID
SMCAPI
SCInit(SCINITDATA *pInitData)
{
    g_pfnPrintMessage = pInitData->pfnPrintMessage;
}

/*++
 *  Function:
 *      SCConnectEx
 *  Description:
 *      Called by smclient when connect command is interpreted
 *  Arguments:
 *      lpszServerName  - server to connect to
 *      lpszUserName    - login user name. Empty string means no login
 *      lpszPassword    - login password
 *      lpszDomain      - login domain, empty string means login to a domain
 *                        the same as lpszServerName
 *      xRes, yRes      - clients resolution, 0x0 - default
 *      ConnectFlags    -
 *      - low speed (compression) option
 *      - cache the bitmaps to the disc option
 *      - connection context allocated in this function
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      SCConnect
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCConnectEx(
    LPCWSTR  lpszServerName,
    LPCWSTR  lpszUserName,
    LPCWSTR  lpszPassword,
    LPCWSTR  lpszDomain,
    LPCWSTR  lpszShell,
    IN const int xRes,
    IN const int yRes,
    IN const int ConnectionFlags,
    PCONNECTINFO *ppCI)
{
    HWND hDialog, hClient, hConnect;
    HWND hContainer, hInput, hOutput;
    STARTUPINFO si;
    PROCESS_INFORMATION procinfo;
    LPCSTR rv = NULL;
    int trys;
    CHAR    szCommandLine[MAX_STRING_LENGTH];
    LPCSTR  szDiscon;
    UINT    xxRes, yyRes;

    // Correct the resolution
         if (xRes >= 1600 && yRes >= 1200)  {xxRes = 1600; yyRes = 1200;}
    else if (xRes >= 1280 && yRes >= 1024)  {xxRes = 1280; yyRes = 1024;}
    else if (xRes >= 1024 && yRes >= 768)   {xxRes = 1024; yyRes = 768;}
    else if (xRes >= 800  && yRes >= 600)   {xxRes = 800;  yyRes = 600;}
    else                                    {xxRes = 640;  yyRes = 480;}

    *ppCI = NULL;

    for (trys = 60; trys && !g_hWindow; trys--)
        Sleep(1000);

    if (!g_hWindow)
    {
        TRACE((ERROR_MESSAGE, "Panic !!! Feedback window is not created\n"));
        rv = ERR_WAIT_FAIL_TIMEOUT;
        goto exitpt;
    }

    *ppCI = (PCONNECTINFO)malloc(sizeof(**ppCI));

    if (!*ppCI)
    {
        TRACE((ERROR_MESSAGE,
               "Couldn't allocate %d bytes memory\n",
               sizeof(**ppCI)));
        rv = ERR_ALLOCATING_MEMORY;
        goto exitpt;
    }
    memset(*ppCI, 0, sizeof(**ppCI));

    (*ppCI)->OwnerThreadId = GetCurrentThreadId();

    // Check in what mode the client will be executed
    // if the server name starts with '\'
    // then tclient.dll will wait until some remote client
    // is connected (aka RCLX mode)
    // otherwise start the client on the same machine
    // running tclient.dll (smclient)
    if (*lpszServerName != L'\\')
    {
    // This is local mode, start the RDP client process
        FillMemory(&si, sizeof(si), 0);
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOWMINIMIZED;

        _SetClientRegistry(lpszServerName,
                           lpszShell,
                           xxRes, yyRes,
                           ConnectionFlags);

        _snprintf(szCommandLine, sizeof(szCommandLine),
#ifdef  _WIN64
                  "%s /CLXDLL=CLXTSHAR.DLL /CLXCMDLINE=%s%I64d " REG_FORMAT,
#else   // !_WIN64
                   "%s /CLXDLL=CLXTSHAR.DLL /CLXCMDLINE=%s%d " REG_FORMAT,
#endif  // _WIN64
                   g_strClientImg, _HWNDOPT,
                   g_hWindow, GetCurrentProcessId(), GetCurrentThreadId());

        (*ppCI)->dead = FALSE;

        _AddToClientQ(*ppCI);

        if (!CreateProcessA(NULL,
                          szCommandLine,
                          NULL,             // Security attribute for process
                          NULL,             // Security attribute for thread
                          FALSE,            // Inheritance - no
                          0,                // Creation flags
                          NULL,             // Environment
                          NULL,             // Current dir
                          &si,
                          &procinfo))
        {
            TRACE((ERROR_MESSAGE,
                   "Error creating process (szCmdLine=%s), GetLastError=0x%x\n",
                    szCommandLine, GetLastError()));
            CloseHandle(procinfo.hProcess);
            CloseHandle(procinfo.hThread);
            procinfo.hProcess = procinfo.hProcess = NULL;

            rv = ERR_CREATING_PROCESS;
            goto exiterr;
        }

        (*ppCI)->hProcess       = procinfo.hProcess;
        (*ppCI)->hThread        = procinfo.hThread;
        (*ppCI)->lProcessId    =  procinfo.dwProcessId;
        (*ppCI)->dwThreadId     = procinfo.dwThreadId;

        rv = Wait4Connect(*ppCI);
        if (rv || (*ppCI)->dead)
        {
            (*ppCI)->dead = TRUE;
            TRACE((WARNING_MESSAGE, "Client can't connect\n"));
            rv = ERR_CONNECTING;
            goto exiterr;
        }

        hClient = (*ppCI)->hClient;
        if ( NULL == hClient)
        {
            trys = 120;     // 2 minutes
            do {
                hClient = _FindTopWindow(NAME_MAINCLASS,
                                         NULL,
                                         procinfo.dwProcessId);
                if (!hClient)
                {
                    Sleep(1000);
                    trys --;
                }
            } while(!hClient && trys);

            if (!trys)
            {
                TRACE((WARNING_MESSAGE, "Can't connect"));
                rv = ERR_CONNECTING;
                goto exiterr;
            }
        }

        // Find the clients child windows
        trys = 240;     // 2 min
        do {
            hContainer = _FindWindow(hClient, NULL, NAME_CONTAINERCLASS);
            hInput = _FindWindow(hContainer, NULL, NAME_INPUT);
            hOutput = _FindWindow(hContainer, NULL, NAME_OUTPUT);
            if (!hContainer || !hInput || !hOutput)
            {
                TRACE((INFO_MESSAGE, "Can't get child windows. Retry"));
                Sleep(500);
                trys--;
            }
        } while ((!hContainer || !hInput || !hOutput) && trys);

        if (!trys)
        {
               TRACE((WARNING_MESSAGE, "Can't find child windows"));
                rv = ERR_CONNECTING;
                goto exiterr;
        }

        TRACE((INFO_MESSAGE, "hClient   = 0x%x\n", hClient));
        TRACE((INFO_MESSAGE, "hContainer= 0x%x\n", hContainer));
        TRACE((INFO_MESSAGE, "hInput    = 0x%x\n", hInput));
        TRACE((INFO_MESSAGE, "hOutput   = 0x%x\n", hOutput));


        (*ppCI)->hClient        = hClient;
        (*ppCI)->hContainer     = hContainer;
        (*ppCI)->hInput         = hInput;
        (*ppCI)->hOutput        = hOutput;
    } else {
    // Else what !? This is RCLX mode
    // Go in wait mode and wait until some client is connected
    // remotely
    // set flag in context that this connection works only with remote client

        // find the valid server name
        while (*lpszServerName && (*lpszServerName) == L'\\')
            lpszServerName ++;

        TRACE((INFO_MESSAGE,
               "A thread in RCLX mode. Wait for some client."
               "The target is: %S\n", lpszServerName));

        (*ppCI)->dead = FALSE;
        (*ppCI)->RClxMode = TRUE;
        (*ppCI)->dwThreadId = GetCurrentThreadId();
        _AddToClientQ(*ppCI);

        rv = _Wait4ConnectTimeout(*ppCI, INFINITE);
        if (rv || (*ppCI)->dead)
        {
            (*ppCI)->dead = TRUE;
            TRACE((WARNING_MESSAGE, "Client can't connect to the test controler (us)\n"));
            rv = ERR_CONNECTING;
            goto exiterr;
        } else {
        // dwProcessId contains socket. hClient is pointer to RCLX
        // context structure, aren't they ?
            ASSERT((*ppCI)->lProcessId != INVALID_SOCKET);
            ASSERT((*ppCI)->hClient);

            TRACE((INFO_MESSAGE, "Client received remote connection\n"));
        }

        // Next, send connection info to the remote client
        // like server to connect to, resolution, etc.
        if (!RClx_SendConnectInfo(
                    (PRCLXCONTEXT)((*ppCI)->hClient),
                    lpszServerName,
                    xxRes,
                    yyRes,
                    ConnectionFlags))
        {
            (*ppCI)->dead = TRUE;
            TRACE((WARNING_MESSAGE, "Client can't send connection info\n"));
            rv = ERR_CONNECTING;
            goto exiterr;
        }

        // Now again wait for connect event
        // this time it will be real
        rv = Wait4Connect(*ppCI);
        if ((*ppCI)->bWillCallAgain)
        {
            // if so, now the client is disconnected
            TRACE((INFO_MESSAGE, "Wait for second call\n"));
            (*ppCI)->dead = FALSE;

            rv = Wait4Connect(*ppCI);
            // Wait for second connect
            rv = Wait4Connect(*ppCI);

        }

        if (rv || (*ppCI)->dead)
        {
            (*ppCI)->dead = TRUE;
            TRACE((WARNING_MESSAGE, "Client(mstsc) can't connect to TS\n"));
            rv = ERR_CONNECTING;
            goto exiterr;
        }
    }

    // Save the resolution
    (*ppCI)->xRes = xxRes;
    (*ppCI)->yRes = yyRes;

    // If username is present try to login
    if (wcslen(lpszUserName))
    {
        rv = _Login(*ppCI, lpszUserName, lpszPassword, lpszDomain);
        if (rv)
            goto exiterr;
    }

exitpt:
    return rv;
exiterr:
    if (*ppCI)
    {
        if ((szDiscon = SCDisconnect(*ppCI)))
        {
            TRACE(( WARNING_MESSAGE, "Error disconnecting: %s\n", szDiscon));
        }

        *ppCI = NULL;
    }

    return rv;
}

PROTOCOLAPI
LPCSTR
SMCAPI
SCConnect(
    LPCWSTR  lpszServerName,
    LPCWSTR  lpszUserName,
    LPCWSTR  lpszPassword,
    LPCWSTR  lpszDomain,
    IN const int xRes,
    IN const int yRes,
    PCONNECTINFO *ppCI)
{
    return SCConnectEx(
            lpszServerName,
            lpszUserName,
            lpszPassword,
            lpszDomain,
            NULL,           // Default shell (MS Explorer)
            xRes,
            yRes,
            g_ConnectionFlags, // compression, bmp cache, full screen
            ppCI);

}

/*++
 *  Function:
 *      SCDisconnect
 *  Description:
 *      Called by smclient, when disconnect command is interpreted
 *  Arguments:
 *      pCI -   connection context
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCDisconnect(
    PCONNECTINFO pCI)
{
    LPCSTR  rv = NULL;
    INT     nCloseTime = WAIT4STR_TIMEOUT;
    INT     nCloseTries = 0;
    DWORD   wres;
    HWND hYesNo = NULL;
    HWND hDiscBox = NULL;
    HWND hDialog = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!(pCI->RClxMode))
    {
        // Try to close the client  window
        if (!pCI->hClient)
            pCI->hClient = _FindTopWindow(NAME_MAINCLASS,
                                          NULL,
                                          pCI->lProcessId);

        if (pCI->hClient)
            SendMessage(pCI->hClient, WM_CLOSE, 0, 0);

        do {
            // search for disconnect dialog and close it
            if (!hDialog && !hDiscBox &&
                (hDiscBox =
                 _FindTopWindow(NULL,
                                g_strDisconnectDialogBox,
                                pCI->lProcessId)))
                PostMessage(hDiscBox, WM_CLOSE, 0, 0);

            // If the client asks whether to close or not
            // Answer with 'Yes'

            if (!hYesNo)
                 hYesNo = _FindTopWindow(NULL,
                                g_strYesNoShutdown,
                                pCI->lProcessId);

            if  (hYesNo  &&
                 (nCloseTries % 10) == 1)
                    PostMessage(hYesNo, WM_KEYDOWN, VK_RETURN, 0);
            else if ((nCloseTries % 10) == 5)
            {
                // On every 10 attempts retry to close the client
                if (!pCI->hClient)
                    pCI->hClient = _FindTopWindow(NAME_MAINCLASS,
                                                  NULL,
                                                  pCI->lProcessId);

                if (pCI->hClient)
                PostMessage(pCI->hClient, WM_CLOSE, 0, 0);
            }

            nCloseTries++;
            nCloseTime -= 3000;
        } while (
            (wres = WaitForSingleObject(pCI->hProcess, 3000)) ==
            WAIT_TIMEOUT &&
            nCloseTime > 0
        );

        if (wres == WAIT_TIMEOUT)
        {
            TRACE((WARNING_MESSAGE,
                   "Can't close process. WaitForSingleObject timeouts\n"));
            TRACE((WARNING_MESSAGE,
                   "Process #%d will be killed\n",
                   pCI->lProcessId ));
            if (!TerminateProcess(pCI->hProcess, 1))
            {
                TRACE((WARNING_MESSAGE,
                       "Can't kill process #%p. GetLastError=%d\n",
                       pCI->lProcessId, GetLastError()));
            }
        }

    }

    if (!_RemoveFromClientQ(pCI))
    {
        TRACE(( WARNING_MESSAGE,
                "Couldn't find CONNECTINFO in the queue\n" ));
    }

    _CloseConnectInfo(pCI);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      SCLogoff
 *  Description:
 *      Called by smclient, when logoff command is interpreted
 *  Arguments:
 *      pCI -   connection context
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCLogoff(
    PCONNECTINFO pCI)
{
    LPCSTR  rv = NULL;
    INT     retries = 5;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto disconnectpt;
    }

    do {
        // Send Ctrl+Esc
        SCSenddata(pCI, WM_KEYDOWN, 17, 1900545);
        SCSenddata(pCI, WM_KEYDOWN, 27, 65537);
        SCSenddata(pCI, WM_KEYUP, 27, -1073676287);
        SCSenddata(pCI, WM_KEYUP, 17, -1071841279);
        // Wait for Run... menu
        rv = _Wait4Str(pCI, g_strStartRun, WAIT4STR_TIMEOUT/4, WAIT_STRING);

        if (rv)
            goto next_retry;

        // Send three times Key-Up (scan code 72) and <Enter>
        SCSendtextAsMsgs(pCI, g_strStartLogoff);

        rv = _Wait4Str(pCI,
                   g_strNTSecurity,
                   WAIT4STR_TIMEOUT/4,
                   WAIT_STRING);
next_retry:
        retries --;
    } while (rv && retries);

    if (rv)
        goto disconnectpt;

        for (retries = 5; retries; retries--) {
                SCSendtextAsMsgs(pCI, g_strNTSecurity_Act);

                rv = Wait4Str(pCI, g_strSureLogoff);

                if (!rv) break;
        }

    if (rv)
        goto disconnectpt;

    SCSendtextAsMsgs(pCI, g_strSureLogoffAct);      // Press enter

    rv = Wait4Disconnect(pCI);
    if (rv)
    {
        TRACE((WARNING_MESSAGE, "Can't close the connection\n"));
    }

disconnectpt:
    rv = SCDisconnect(pCI);

exitpt:
    return rv;
}

/*++
 *  Function:
 *      SCStart
 *  Description:
 *      Called by smclient, when start command is interpreted
 *      This functions emulates starting an app from Start->Run menu
 *      on the server side
 *  Arguments:
 *      pCI         - connection context
 *      lpszAppName - command line
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCStart(
    PCONNECTINFO pCI, LPCWSTR lpszAppName)
{
    LPCSTR waitres = NULL;
//    int retries = 5;
//    int retries2 = 5;
    DWORD dwTimeout;
    LPCSTR rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    dwTimeout = 10000; // start the timeout of 10 secs
// Try to start run menu
    do {
// Press Ctrl+Esc
        do {
            TRACE((ALIVE_MESSAGE, "Start: Sending Ctrl+Esc\n"));
            SCSenddata(pCI, WM_KEYDOWN, 17, 1900545);
            SCSenddata(pCI, WM_KEYDOWN, 27, 65537);
            SCSenddata(pCI, WM_KEYUP, 27, -1073676287);
            SCSenddata(pCI, WM_KEYUP, 17, -1071841279);

            // If the last wait was unsuccessfull increase the timeout
            if (waitres)
                dwTimeout += 2000;

            // Wait for Run... menu
            waitres = _Wait4Str(pCI,
                                g_strStartRun,
                                dwTimeout,
                                WAIT_STRING);

            if (waitres)
            {
                TRACE((INFO_MESSAGE, "Start: Start menu didn't appear. Retrying\n"));
            } else {
                TRACE((ALIVE_MESSAGE, "Start: Got the start menu\n"));
            }
        } while (waitres && dwTimeout < WAIT4STR_TIMEOUT);

        if (waitres)
        {
            TRACE((WARNING_MESSAGE, "Start: Start menu didn't appear. Giving up\n"));
            rv = ERR_START_MENU_NOT_APPEARED;
            goto exitpt;
        }

        TRACE((ALIVE_MESSAGE, "Start: Waiting for the \"Run\" box\n"));
// press 'R' for Run...
        SCSendtextAsMsgs(pCI, g_strStartRun_Act);
        waitres = _Wait4Str(pCI,
                            g_strRunBox,
                            dwTimeout,
                            WAIT_STRING);
        if (waitres)
        // No success, press Esc
        {
            TRACE((INFO_MESSAGE, "Start: Can't get the \"Run\" box. Retrying\n"));
            SCSenddata(pCI, WM_KEYDOWN, 27, 65537);
            SCSenddata(pCI, WM_KEYUP, 27, -1073676287);
        }
    } while (waitres && dwTimeout < WAIT4STR_TIMEOUT);

    if (waitres)
    {
        TRACE((WARNING_MESSAGE, "Start: \"Run\" box didn't appear. Giving up\n"));
        rv = ERR_COULDNT_OPEN_PROGRAM;
        goto exitpt;
    }

    TRACE((ALIVE_MESSAGE, "Start: Sending the command line\n"));
    // Now we have the focus on the "Run" box, send the app name
    rv = SCSendtextAsMsgs(pCI, lpszAppName);

// Hit <Enter>
    SCSenddata(pCI, WM_KEYDOWN, 13, 1835009);
    SCSenddata(pCI, WM_KEYUP, 13, -1071906815);

exitpt:
    return rv;
}


// Eventualy, we are going to change the clipboard
// Syncronize this, so no other thread's AV while
// checking the clipboard content
// store 1 for write, 0 for read
static  LONG    g_ClipOpened = 0;

/*++
 *  Function:
 *      SCClipbaord
 *  Description:
 *      Called by smclient, when clipboard command is interpreted
 *      when eClipOp is COPY_TO_CLIPBOARD it copies the lpszFileName to
 *      the clipboard. If eClipOp is PASTE_FROM_CLIPBOARD it
 *      checks the clipboard content against the content of lpszFileName
 *  Arguments:
 *      pCI         - connection context
 *      eClipOp     - clipboard operation. Possible values:
 *                    COPY_TO_CLIPBOARD and PASTE_FROM_CLIPBOARD
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCClipboard(
    PCONNECTINFO pCI, const CLIPBOARDOPS eClipOp, LPCSTR lpszFileName)
{
    LPCSTR  rv = NULL;
    INT     hFile = -1;
    LONG    clplength = 0;
    UINT    uiFormat = 0;
    HGLOBAL ghClipData = NULL;
    HGLOBAL hNewData = NULL;
    PBYTE   pClipData = NULL;
    BOOL    bClipboardOpen = FALSE;
    BOOL    bFreeClipHandle = TRUE;

    LONG    prevOp = 1;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (lpszFileName == NULL || !(*lpszFileName))
    {
        // No filename specified, work like an empty clipboard is requested
        if (eClipOp == COPY_TO_CLIPBOARD)
            if (pCI->RClxMode)
            {
                if (!RClx_SendClipboard((PRCLXCONTEXT)(pCI->hClient),
                        NULL, 0, 0))
                    rv = ERR_COPY_CLIPBOARD;
            } else {
                if (!Clp_EmptyClipboard())
                    rv = ERR_COPY_CLIPBOARD;
            }
        else if (eClipOp == PASTE_FROM_CLIPBOARD)
        {
            if (pCI->RClxMode)
            {
                if (!RClx_SendClipboardRequest((PRCLXCONTEXT)(pCI->hClient), 0))
                {
                    rv = ERR_PASTE_CLIPBOARD;
                    goto exitpt;
                }
                if (_Wait4ClipboardTimeout(pCI, WAIT4STR_TIMEOUT))
                {
                    rv = ERR_PASTE_CLIPBOARD;
                    goto exitpt;
                }

                // We do not expect to receive clipboard data
                // just format ID
                if (!pCI->uiClipboardFormat)
                // if the format is 0, then there's no clipboard
                    rv = NULL;
                else
                    rv = ERR_PASTE_CLIPBOARD_DIFFERENT_SIZE;
            } else {
                if (Clp_CheckEmptyClipboard())
                    rv = NULL;
                else
                    rv = ERR_PASTE_CLIPBOARD_DIFFERENT_SIZE;
            }
        } else {
            TRACE((ERROR_MESSAGE, "SCClipboard: Invalid filename\n"));
            rv = ERR_INVALID_PARAM;
        }
        goto exitpt;
    }

    if (eClipOp == COPY_TO_CLIPBOARD)
    {
        // Open the file for reading
        hFile = _open(lpszFileName, _O_RDONLY|_O_BINARY);
        if (hFile == -1)
        {
            TRACE((ERROR_MESSAGE,
                   "Error opening file: %s. errno=%d\n", lpszFileName, errno));
            rv = ERR_COPY_CLIPBOARD;
            goto exitpt;
        }

        // Get the clipboard length (in the file)
        clplength = _filelength(hFile) - sizeof(uiFormat);
        // Get the format
        if (_read(hFile, &uiFormat, sizeof(uiFormat)) != sizeof(uiFormat))
        {
            TRACE((ERROR_MESSAGE,
                   "Error reading from file. errno=%d\n", errno));
            rv = ERR_COPY_CLIPBOARD;
            goto exitpt;
        }

        ghClipData = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, clplength);
        if (!ghClipData)
        {
            TRACE((ERROR_MESSAGE,
                   "Can't allocate %d bytes\n", clplength));
            rv = ERR_COPY_CLIPBOARD;
            goto exitpt;
        }

        pClipData = GlobalLock(ghClipData);
        if (!pClipData)
        {
            TRACE((ERROR_MESSAGE,
                   "Can't lock handle 0x%x\n", ghClipData));
            rv = ERR_COPY_CLIPBOARD;
            goto exitpt;
        }

        if (_read(hFile, pClipData, clplength) != clplength)
        {
            TRACE((ERROR_MESSAGE,
                   "Error reading from file. errno=%d\n", errno));
            rv = ERR_COPY_CLIPBOARD;
            goto exitpt;
        }

        GlobalUnlock(ghClipData);

        if (pCI->RClxMode)
        // RCLX mode, send the data to the client's machine
        {
            if (!(pClipData = GlobalLock(ghClipData)))
            {
                rv = ERR_COPY_CLIPBOARD;
                goto exitpt;
            }

            if (!RClx_SendClipboard((PRCLXCONTEXT)(pCI->hClient),
                                    pClipData, clplength, uiFormat))
            {
                rv = ERR_COPY_CLIPBOARD;
                goto exitpt;
            }
        } else {
        // Local mode, change the clipboard on this machine
            if ((prevOp = InterlockedExchange(&g_ClipOpened, 1)))
            {
                rv = ERR_CLIPBOARD_LOCKED;
                goto exitpt;
            }

            if (!OpenClipboard(NULL))
            {
                TRACE((ERROR_MESSAGE,
                       "Can't open the clipboard. GetLastError=%d\n",
                       GetLastError()));
                rv = ERR_COPY_CLIPBOARD;
                goto exitpt;
            }

            bClipboardOpen = TRUE;

            // Empty the clipboard, so we'll have only one entry
            EmptyClipboard();

            if (!Clp_SetClipboardData(uiFormat, ghClipData, clplength, &bFreeClipHandle))
            {
                TRACE((ERROR_MESSAGE,
                       "SetClipboardData failed. GetLastError=%d\n",
                       GetLastError()));
                rv = ERR_COPY_CLIPBOARD;
                goto exitpt;
            }
        }

    } else if (eClipOp == PASTE_FROM_CLIPBOARD)
    {
        LONG nClipDataSize;

        // Open the file for reading
        hFile = _open(lpszFileName, _O_RDONLY|_O_BINARY);
        if (hFile == -1)
        {
            TRACE((ERROR_MESSAGE,
                   "Error opening file: %s. errno=%d\n", lpszFileName, errno));
            rv = ERR_PASTE_CLIPBOARD;
            goto exitpt;
        }

        // Get the clipboard length (in the file)
        clplength = _filelength(hFile) - sizeof(uiFormat);
        // Get the format
        if (_read(hFile, &uiFormat, sizeof(uiFormat)) != sizeof(uiFormat))
        {
            TRACE((ERROR_MESSAGE,
                   "Error reading from file. errno=%d\n", errno));
            rv = ERR_PASTE_CLIPBOARD;
            goto exitpt;
        }

        // This piece retrieves the clipboard
        if (pCI->RClxMode)
        // Send request for a clipboard
        {
            if (!RClx_SendClipboardRequest((PRCLXCONTEXT)(pCI->hClient), uiFormat))
            {
                rv = ERR_PASTE_CLIPBOARD;
                goto exitpt;
            }
            if (_Wait4ClipboardTimeout(pCI, WAIT4STR_TIMEOUT))
            {
                rv = ERR_PASTE_CLIPBOARD;
                goto exitpt;
            }

            ghClipData = pCI->ghClipboard;
            // Get the clipboard size
            nClipDataSize = pCI->nClipboardSize;
        } else {
        // retrieve the local clipboard
            if ((prevOp = InterlockedExchange(&g_ClipOpened, 1)))
            {
                rv = ERR_CLIPBOARD_LOCKED;
                goto exitpt;
            }

            if (!OpenClipboard(NULL))
            {
                TRACE((ERROR_MESSAGE,
                       "Can't open the clipboard. GetLastError=%d\n",
                       GetLastError()));
                rv = ERR_PASTE_CLIPBOARD;
                goto exitpt;
            }

            bClipboardOpen = TRUE;

            // Retrieve the data
            ghClipData = GetClipboardData(uiFormat);
            if (ghClipData)
            {
                Clp_GetClipboardData(uiFormat,
                                     ghClipData,
                                     &nClipDataSize,
                                     &hNewData);
                bFreeClipHandle = FALSE;
            }

            if (hNewData)
                ghClipData = hNewData;
        }

        if (!ghClipData)
        {
            TRACE((ERROR_MESSAGE,
                   "Can't get clipboard data (empty clipboard ?). GetLastError=%d\n",
                   GetLastError()));
            rv = ERR_PASTE_CLIPBOARD_EMPTY;
            goto exitpt;
        }

        if (!nClipDataSize)
            TRACE((WARNING_MESSAGE, "Clipboard is empty.\n"));

        pClipData = GlobalLock(ghClipData);
        if (!pClipData)
        {
            TRACE((ERROR_MESSAGE,
                   "Can't lock global mem. GetLastError=%d\n",
                   GetLastError()));
            rv = ERR_PASTE_CLIPBOARD;
            goto exitpt;
        }

        // Check if the client is on Win16 platform
        // and the clipboard is paragraph aligned
        // the file size is just bellow this size
        if (pCI->RClxMode &&
            (strstr(pCI->szClientType, "WIN16") != NULL) &&
            ((nClipDataSize % 16) == 0) &&
            ((nClipDataSize - clplength) < 16) &&
            (nClipDataSize != 0))
        {
            // if so, then cut the clipboard size with the difference
            nClipDataSize = clplength;
        }
        else if (nClipDataSize != clplength)
        {
            TRACE((INFO_MESSAGE, "Different length: file=%d, clipbrd=%d\n",
                    clplength, nClipDataSize));
            rv = ERR_PASTE_CLIPBOARD_DIFFERENT_SIZE;
            goto exitpt;
        }

        // compare the data
        {
            BYTE    pBuff[1024];
            PBYTE   pClp = pClipData;
            UINT    nBytes;
            BOOL    bEqu = TRUE;

            while (bEqu &&
                   (nBytes = _read(hFile, pBuff, sizeof(pBuff))) &&
                   nBytes != -1)
            {
                if (memcmp(pBuff, pClp, nBytes))
                    bEqu = FALSE;

                pClp += nBytes;
            }

            if (!bEqu)
            {
                TRACE((INFO_MESSAGE, "Clipboard and file are not equal\n"));
                rv = ERR_PASTE_CLIPBOARD_NOT_EQUAL;
            }
        }

    } else
        rv = ERR_UNKNOWN_CLIPBOARD_OP;

exitpt:
    // Do the cleanup

    // Release the clipboard handle
    if (pClipData)
        GlobalUnlock(ghClipData);

    // free any clipboard received in RCLX mode
    if (pCI->RClxMode && pCI->ghClipboard)
    {
        GlobalFree(pCI->ghClipboard);
        pCI->ghClipboard = NULL;
    }
    else if (ghClipData && eClipOp == COPY_TO_CLIPBOARD && bFreeClipHandle)
        GlobalFree(ghClipData);

    if (hNewData)
        GlobalFree(hNewData);

    // Close the file
    if (hFile != -1)
        _close(hFile);

    // Close the clipboard
    if (bClipboardOpen)
        CloseClipboard();
    if (!prevOp)
        InterlockedExchange(&g_ClipOpened, 0);

    return rv;
}

/*++
 *  Function:
 *      SCSaveClipboard
 *  Description:
 *      Save the clipboard in file (szFileName) with
 *      format specified in szFormatName
 *  Arguments:
 *      pCI         - connection context
 *      szFormatName- format name
 *      szFileName  - the name of the file to save to
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      !perlext
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSaveClipboard(
    PCONNECTINFO pCI,
    LPCSTR szFormatName,
    LPCSTR szFileName)
{
    LPCSTR  rv = ERR_SAVE_CLIPBOARD;
    BOOL    bClipboardOpen = FALSE;
    UINT    nFormatID = 0;
    HGLOBAL ghClipData = NULL;
    HGLOBAL hNewData = NULL;
    INT     nClipDataSize;
    CHAR    *pClipData = NULL;
    INT     hFile = -1;

    LONG    prevOp = 1;

    // ++++++ First go thru parameter check
    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (szFormatName == NULL || !(*szFormatName))
    {
        TRACE((ERROR_MESSAGE, "SCClipboard: Invalid format name\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    if (szFileName == NULL || !(*szFileName))
    {
        TRACE((ERROR_MESSAGE, "SCClipboard: Invalid filename\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }
    // ------ End of parameter check
    //

    if (pCI->RClxMode)
    {
        nFormatID = _GetKnownClipboardFormatIDByName(szFormatName);
        if (!nFormatID)
        {
            TRACE((ERROR_MESSAGE, "Can't get the clipboard format ID: %s.\n", szFormatName));
            goto exitpt;
        }

        // Send request for a clipboard
        if (!RClx_SendClipboardRequest((PRCLXCONTEXT)(pCI->hClient), nFormatID))
        {
            rv = ERR_PASTE_CLIPBOARD;
            goto exitpt;
        }
        if (_Wait4ClipboardTimeout(pCI, WAIT4STR_TIMEOUT))
        {
            rv = ERR_PASTE_CLIPBOARD;
            goto exitpt;
        }

        ghClipData = pCI->ghClipboard;
        // Get the clipboard size
        nClipDataSize = pCI->nClipboardSize;

        if (!ghClipData || !nClipDataSize)
        {
            TRACE((WARNING_MESSAGE, "Clipboard is empty.\n"));
            goto exitpt;
        }
    } else {
        // local mode
        // Open the clipboard

        if ((prevOp = InterlockedExchange(&g_ClipOpened, 1)))
        {
            rv = ERR_CLIPBOARD_LOCKED;
            goto exitpt;
        }

        if (!OpenClipboard(NULL))
        {
            TRACE((ERROR_MESSAGE, "Can't open the clipboard. GetLastError=%d\n",
                    GetLastError()));
            goto exitpt;
        }

        bClipboardOpen = TRUE;

        nFormatID = Clp_GetClipboardFormat(szFormatName);

        if (!nFormatID)
        {
            TRACE((ERROR_MESSAGE, "Can't get the clipboard format: %s.\n", szFormatName));
            goto exitpt;
        }

        TRACE((INFO_MESSAGE, "Format ID: %d(0x%X)\n", nFormatID, nFormatID));

        // Retrieve the data
        ghClipData = GetClipboardData(nFormatID);
        if (!ghClipData)
        {
            TRACE((ERROR_MESSAGE, "Can't get clipboard data. GetLastError=%d\n", GetLastError()));
            goto exitpt;
        }

        Clp_GetClipboardData(nFormatID, ghClipData, &nClipDataSize, &hNewData);
        if (hNewData)
            ghClipData = hNewData;

        if (!nClipDataSize)
        {
            TRACE((WARNING_MESSAGE, "Clipboard is empty.\n"));
            goto exitpt;
        }
    }

    pClipData = GlobalLock(ghClipData);
    if (!pClipData)
    {
        TRACE((ERROR_MESSAGE, "Can't lock global mem. GetLastError=%d\n", GetLastError()));
        goto exitpt;
    }

    // Open the destination file
    hFile = _open(szFileName,
                  _O_RDWR|_O_CREAT|_O_BINARY|_O_TRUNC,
                  _S_IREAD|_S_IWRITE);
    if (hFile == -1)
    {
        TRACE((ERROR_MESSAGE, "Can't open a file: %s\n", szFileName));
        goto exitpt;
    }

    // First write the format type
    if (_write(hFile, &nFormatID, sizeof(nFormatID)) != sizeof(nFormatID))
    {
        TRACE((ERROR_MESSAGE, "_write failed. errno=%d\n", errno));
        goto exitpt;
    }

    if (_write(hFile, pClipData, nClipDataSize) != (INT)nClipDataSize)
    {
        TRACE((ERROR_MESSAGE, "_write failed. errno=%d\n", errno));
        goto exitpt;
    }

    TRACE((INFO_MESSAGE, "File written successfully. %d bytes written\n", nClipDataSize));

    rv = NULL;
exitpt:
    // Do the cleanup

    // Close the file
    if (hFile != -1)
        _close(hFile);

    // Release the clipboard handle
    if (pClipData)
        GlobalUnlock(ghClipData);

    if (hNewData)
        GlobalFree(hNewData);

    // Close the clipboard
    if (bClipboardOpen)
        CloseClipboard();
    if (!prevOp)
        InterlockedExchange(&g_ClipOpened, 0);

    // free any clipboard received in RCLX mode
    if (pCI && pCI->RClxMode && pCI->ghClipboard)
    {
        GlobalFree(pCI->ghClipboard);
        pCI->ghClipboard = NULL;
    }

    return rv;
}

/*++
 *  Function:
 *      SCSenddata
 *  Description:
 *      Called by smclient, when senddata command is interpreted
 *      Sends an window message to the client
 *  Arguments:
 *      pCI         - connection context
 *      uiMessage   - the massage Id
 *      wParam      - word param of the message
 *      lParam      - long param of the message
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSenddata(
    PCONNECTINFO pCI,
    const UINT uiMessage,
    const WPARAM wParam,
    const LPARAM lParam)
{
    UINT msg = uiMessage;
    LPCSTR  rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

//    TRACE((ALIVE_MESSAGE, "Senddata: uMsg=%x wParam=%x lParam=%x\n",
//        uiMessage, wParam, lParam));

    // Determines whether it will
    // send the message to local window
    // or thru RCLX
    if (!pCI->RClxMode)
    {
// Obsolete, a client registry setting "Allow Background Input" asserts
// that the client will accept the message
//    SetFocus(pCI->hInput);
//    SendMessage(pCI->hInput, WM_SETFOCUS, 0, 0);

        SendMessage(pCI->hInput, msg, wParam, lParam);
    } else {
    // RClxMode
        ASSERT(pCI->lProcessId != INVALID_SOCKET);
        ASSERT(pCI->hClient);

        if (!RClx_SendMessage((PRCLXCONTEXT)(pCI->hClient),
                              msg, wParam, lParam))
        {
            TRACE((WARNING_MESSAGE,
                   "Can't send message thru RCLX\n"));
        }
    }

exitpt:
    return rv;
}

PROTOCOLAPI
LPCSTR
SMCAPI
SCClientTerminate(PCONNECTINFO pCI)
{
    LPCSTR rv = ERR_CLIENTTERMINATE_FAIL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!(pCI->RClxMode))
    {
        if (!TerminateProcess(pCI->hProcess, 1))
        {
            TRACE((WARNING_MESSAGE,
                   "Can't kill process #%p. GetLastError=%d\n",
                   pCI->lProcessId, GetLastError()));
            goto exitpt;
        }
    } else {
        TRACE((WARNING_MESSAGE,
                "ClientTerminate is not supported in RCLX mode yet\n"));
        TRACE((WARNING_MESSAGE, "Using disconnect\n"));
    }

    rv = SCDisconnect(pCI);

exitpt:
    return rv;

}

/*++
 *  Function:
 *      SCGetSessionId
 *  Description:
 *      Called by smclient, returns the session ID. 0 is invalid, not logged on
 *      yet
 *  Arguments:
 *      pCI         - connection context
 *  Return value:
 *      session id, 0 is invlid value, -1 is returned on NT4 clients
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
UINT
SMCAPI
SCGetSessionId(PCONNECTINFO pCI)
{
    UINT    rv = 0;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        goto exitpt;
    }

    if (pCI->dead)
    {
        goto exitpt;
    }

    rv = pCI->uiSessionId;

exitpt:

    return rv;
}

/*++
 *  Function:
 *      SCCheck
 *  Description:
 *      Called by smclient, when check command is interpreted
 *  Arguments:
 *      pCI         - connection context
 *      lpszCommand - command name
 *      lpszParam   - command parameter
 *  Return value:
 *      Error message. NULL on success. Exceptions are GetDisconnectReason and
 *      GetWait4MultipleStrResult
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCCheck(PCONNECTINFO pCI, LPCSTR lpszCommand, LPCWSTR lpszParam)
{
    LPCSTR rv = ERR_INVALID_COMMAND;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (     !_stricmp(lpszCommand, "Wait4Str"))
        rv = Wait4Str(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "Wait4Disconnect"))
        rv = Wait4Disconnect(pCI);
    else if (!_stricmp(lpszCommand, "RegisterChat"))
        rv = RegisterChat(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "UnregisterChat"))
        rv = UnregisterChat(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "GetDisconnectReason"))
        rv = GetDisconnectReason(pCI);
    else if (!_stricmp(lpszCommand, "Wait4StrTimeout"))
        rv = Wait4StrTimeout(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "Wait4MultipleStr"))
        rv = Wait4MultipleStr(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "Wait4MultipleStrTimeout"))
        rv = Wait4MultipleStrTimeout(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "GetWait4MultipleStrResult"))
        rv = GetWait4MultipleStrResult(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "SwitchToProcess"))
        rv = SCSwitchToProcess(pCI, lpszParam);
    /* **New** */
    else if (!_stricmp(lpszCommand, "SetClientTopmost"))
        rv = SCSetClientTopmost(pCI, lpszParam);

exitpt:
    return rv;
}

/*
 *  Extensions and help functions
 */

/*++
 *  Function:
 *      Wait4Disconnect
 *  Description:
 *      Waits until the client is disconnected
 *  Arguments:
 *      pCI -   connection context
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      SCCheck, SCLogoff
 --*/
LPCSTR Wait4Disconnect(PCONNECTINFO pCI)
{
    WAIT4STRING Wait;
    LPCSTR  rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    memset(&Wait, 0, sizeof(Wait));
    Wait.evWait = CreateEvent(NULL,     //security
                             TRUE,     //manual
                             FALSE,    //initial state
                             NULL);    //name

    Wait.lProcessId = pCI->lProcessId;
    Wait.pOwner = pCI;
    Wait.WaitType = WAIT_DISC;

    rv = _WaitSomething(pCI, &Wait, WAIT4STR_TIMEOUT);
    if (!rv)
    {
        TRACE(( INFO_MESSAGE, "Client is disconnected\n"));
    }

    CloseHandle(Wait.evWait);
exitpt:
    return rv;
}

/*++
 *  Function:
 *      Wait4Connect
 *  Description:
 *      Waits until the client is connect
 *  Arguments:
 *      pCI - connection context
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCOnnect
 --*/
LPCSTR Wait4Connect(PCONNECTINFO pCI)
{
    return (_Wait4ConnectTimeout(pCI, CONNECT_TIMEOUT));
}

/*++
 *  Function:
 *      _Wait4ConnectTimeout
 *  Description:
 *      Waits until the client is connect
 *  Arguments:
 *      pCI - connection context
 *      dwTimeout - timeout value
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCConnect
 --*/
LPCSTR _Wait4ConnectTimeout(PCONNECTINFO pCI, DWORD dwTimeout)
{
    WAIT4STRING Wait;
    LPCSTR  rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    memset(&Wait, 0, sizeof(Wait));
    Wait.evWait = CreateEvent(NULL,     //security
                              TRUE,     //manual
                              FALSE,    //initial state
                              NULL);    //name

    Wait.lProcessId = pCI->lProcessId;
    Wait.pOwner = pCI;
    Wait.WaitType = WAIT_CONN;

    rv = _WaitSomething(pCI, &Wait, dwTimeout);
    if (!rv)
    {
        TRACE(( INFO_MESSAGE, "Client is connected\n"));
    }

    CloseHandle(Wait.evWait);
exitpt:
    return rv;
}

/*++
 *  Function:
 *      _Wait4ClipboardTimeout
 *  Description:
 *      Waits until clipboard response is received from RCLX module
 *  Arguments:
 *      pCI - connection context
 *      dwTimeout - timeout value
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCClipboard
 --*/
LPCSTR _Wait4ClipboardTimeout(PCONNECTINFO pCI, DWORD dwTimeout)
{
    WAIT4STRING Wait;
    LPCSTR  rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!(pCI->RClxMode))
    {
        TRACE((WARNING_MESSAGE, "WaitForClipboard: Not in RCLX mode\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    memset(&Wait, 0, sizeof(Wait));
    Wait.evWait = CreateEvent(NULL,     //security
                              TRUE,     //manual
                              FALSE,    //initial state
                              NULL);    //name

    Wait.lProcessId = pCI->lProcessId;
    Wait.pOwner = pCI;
    Wait.WaitType = WAIT_CLIPBOARD;

    rv = _WaitSomething(pCI, &Wait, dwTimeout);
    if (!rv)
    {
        TRACE(( INFO_MESSAGE, "Clipboard received\n"));
    }

    CloseHandle(Wait.evWait);
exitpt:
    return rv;
}

/*++
 *  Function:
 *      GetDisconnectReason
 *  Description:
 *      Retrieves, if possible, the client error box
 *  Arguments:
 *      pCI - connection context
 *  Return value:
 *      The error box message. NULL if not available
 *  Called by:
 *      SCCheck
 --*/
LPCSTR  GetDisconnectReason(PCONNECTINFO pCI)
{
    HWND hDiscBox;
    LPCSTR  rv = NULL;
    HWND hWnd, hwndTop, hwndNext;
    char classname[128];
    char caption[256];

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (strlen(pCI->szDiscReason))
    {
        rv = pCI->szDiscReason;
        goto exitpt;
    }

    hDiscBox = _FindTopWindow(NULL, DISCONNECT_DIALOG_BOX, pCI->lProcessId);

    if (!hDiscBox)
    {
        rv = ERR_NORMAL_EXIT;
        goto exitpt;
    } else {
        TRACE((INFO_MESSAGE, "Found hDiscBox=0x%x", hDiscBox));
    }

    pCI->szDiscReason[0] = 0;
    hWnd = NULL;

    hwndTop = GetWindow(hDiscBox, GW_CHILD);
    if (!hwndTop)
    {
        TRACE((INFO_MESSAGE, "GetWindow failed. hwnd=0x%x\n", hDiscBox));
        goto exitpt;
    }

    hwndNext = hwndTop;
    do {
        hWnd = hwndNext;
        if (!GetClassName(hWnd, classname, sizeof(classname)))
        {
            TRACE((INFO_MESSAGE, "GetClassName failed. hwnd=0x%x\n", hWnd));
            goto nextwindow;
        }
        if (!GetWindowText(hWnd, caption, sizeof(caption)))
        {
            TRACE((INFO_MESSAGE, "GetWindowText failed. hwnd=0x%x\n"));
            goto nextwindow;
        }

        if (!strcmp(classname, STATIC_CLASS) &&
             strlen(classname) <
             sizeof(pCI->szDiscReason) - strlen(pCI->szDiscReason) - 3)
        {
            strcat(pCI->szDiscReason, caption);
            strcat(pCI->szDiscReason, "\n");
        }
nextwindow:
        hwndNext = GetNextWindow(hWnd, GW_HWNDNEXT);
    } while (hWnd && hwndNext != hwndTop);

    rv = (LPCSTR)pCI->szDiscReason;

exitpt:
    return rv;
}

/*++
 *  Function:
 *      Wait4Str
 *  Description:
 *      Waits for a specific string to come from clients feedback
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - waited string
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
LPCSTR Wait4Str(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
    return _Wait4Str(pCI, lpszParam, WAIT4STR_TIMEOUT, WAIT_STRING);
}

/*++
 *  Function:
 *      Wait4StrTimeout
 *  Description:
 *      Waits for a specific string to come from clients feedback
 *      The timeout is different than default and is specified in
 *      lpszParam argument, like:
 *      waited_string<->timeout_value
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - waited string and timeout
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
LPCSTR Wait4StrTimeout(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
    WCHAR waitstr[MAX_STRING_LENGTH];
    WCHAR *sep = wcsstr(lpszParam, CHAT_SEPARATOR);
    DWORD dwTimeout;
    LPCSTR rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (!sep)
    {
        TRACE((WARNING_MESSAGE,
               "Wait4StrTiemout: No timeout value. Default applying\n"));
        rv = Wait4Str(pCI, lpszParam);
    } else {
        LONG_PTR len = sep - lpszParam;

        if (len > sizeof(waitstr) - 1)
            len = sizeof(waitstr) - 1;

        wcsncpy(waitstr, lpszParam, len);
        waitstr[len] = 0;
        sep += wcslen(CHAT_SEPARATOR);
        dwTimeout = _wtoi(sep);

        if (!dwTimeout)
        {
            TRACE((WARNING_MESSAGE,
                   "Wait4StrTiemout: No timeout value(%s). Default applying\n",
                   sep));
            dwTimeout = WAIT4STR_TIMEOUT;
        }

        rv = _Wait4Str(pCI, waitstr, dwTimeout, WAIT_STRING);
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      Wait4MultipleStr
 *  Description:
 *      Same as Wait4Str, but waits for several strings at once
 *      the strings are separated by '|' character
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - waited strings
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
LPCSTR  Wait4MultipleStr(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
     return _Wait4Str(pCI, lpszParam, WAIT4STR_TIMEOUT, WAIT_MSTRINGS);
}

/*++
 *  Function:
 *      Wait4MultipleStrTimeout
 *  Description:
 *      Combination between Wait4StrTimeout and Wait4MultipleStr
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - waited strings and timeout value. Example
 *                  - "string1|string2|...|stringN<->5000"
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
LPCSTR  Wait4MultipleStrTimeout(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
    WCHAR waitstr[MAX_STRING_LENGTH];
    WCHAR  *sep = wcsstr(lpszParam, CHAT_SEPARATOR);
    DWORD dwTimeout;
    LPCSTR rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    pCI->nWait4MultipleStrResult = 0;
    pCI->szWait4MultipleStrResult[0] = 0;

    if (!sep)
    {
        TRACE((WARNING_MESSAGE,
               "Wait4MultipleStrTiemout: No timeout value. Default applying"));
        rv = Wait4MultipleStr(pCI, lpszParam);
    } else {
        LONG_PTR len = sep - lpszParam;

        if (len > sizeof(waitstr) - 1)
            len = sizeof(waitstr) - 1;

        wcsncpy(waitstr, lpszParam, len);
        waitstr[len] = 0;
        sep += wcslen(CHAT_SEPARATOR);
        dwTimeout = _wtoi(sep);

        if (!dwTimeout)
        {
            TRACE((WARNING_MESSAGE,
                   "Wait4StrTiemout: No timeout value. Default applying"));
            dwTimeout = WAIT4STR_TIMEOUT;
        }

        rv = _Wait4Str(pCI, waitstr, dwTimeout, WAIT_MSTRINGS);
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      GetWait4MultipleStrResult
 *  Description:
 *      Retrieves the result from last Wait4MultipleStr call
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - unused
 *  Return value:
 *      The string, NULL on error
 *  Called by:
 *      SCCheck
 --*/
LPCSTR  GetWait4MultipleStrResult(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
    LPCSTR  rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (*pCI->szWait4MultipleStrResult)
        rv = (LPCSTR)pCI->szWait4MultipleStrResult;
    else
        rv = NULL;

exitpt:
    return rv;
}

/*++
 *  Function:
 *      GetFeedbackString
 *  Description:
 *      Pick a string from connection buffer or wait until
 *      something is received
 *  Arguments:
 *      pCI     - connection context
 *      result  - the buffer for received string
 *      max     - the buffer size
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      * * * EXPORTED * * *
 --*/
LPCSTR  GetFeedbackString(PCONNECTINFO pCI, LPSTR result, UINT max)
{
    LPCSTR rv = NULL;
    int nFBpos, nFBsize ;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    // Grab the buffer pointers
    EnterCriticalSection(g_lpcsGuardWaitQueue);
    nFBpos = pCI->nFBend + FEEDBACK_SIZE - pCI->nFBsize;
    nFBsize = pCI->nFBsize;
    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    nFBpos %= FEEDBACK_SIZE;

    if (!max)
        goto exitpt;

    *result = 0;

    if (!nFBsize)
    // Empty buffer, wait for feedback to receive
    {
        rv = _Wait4Str(pCI, L"", WAIT4STR_TIMEOUT, WAIT_STRING);
    }
    if (!rv)
    // Pickup from buffer
    {
        UINT i;

        EnterCriticalSection(g_lpcsGuardWaitQueue);

        // Adjust the buffer pointers
        pCI->nFBsize    =   pCI->nFBend + FEEDBACK_SIZE - nFBpos - 1;
        pCI->nFBsize    %=  FEEDBACK_SIZE;

        // Copy the string but watch out for overflow
        if (max > wcslen(pCI->Feedback[nFBpos]) + 1)
            max = wcslen(pCI->Feedback[nFBpos]);

        for (i = 0; i < max; i++)
            result[i] = (char)(pCI->Feedback[nFBpos][i]);
        result[max] = 0;

        LeaveCriticalSection(g_lpcsGuardWaitQueue);
    }
exitpt:
    return rv;
}

/*++
 *  Function:
 *      _SendRClxData
 *  Description:
 *      Sends request for data to the client
 *  Arguments:
 *      pCI         - connection context
 *      pRClxData   - data to send
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCGetClientScreen
 --*/
LPCSTR
_SendRClxData(PCONNECTINFO pCI, PRCLXDATA pRClxData)
{
    LPCSTR  rv = NULL;
    PRCLXCONTEXT pRClxCtx;
    RCLXREQPROLOG   Request;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!(pCI->RClxMode))
    {
        TRACE((WARNING_MESSAGE, "_SendRClxData: Not in RCLX mode\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    pRClxCtx = (PRCLXCONTEXT)pCI->hClient;
    if (!pRClxCtx || pRClxCtx->hSocket == INVALID_SOCKET)
    {
        TRACE((ERROR_MESSAGE, "Not connected yet, RCLX context is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!pRClxData)
    {
        TRACE((ERROR_MESSAGE, "_SendRClxData: Data block is null\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    Request.ReqType = REQ_DATA;
    Request.ReqSize = pRClxData->uiSize + sizeof(*pRClxData);
    if (!RClx_SendBuffer(pRClxCtx->hSocket, &Request, sizeof(Request)))
    {
        rv = ERR_CLIENT_DISCONNECTED;
        goto exitpt;
    }

    if (!RClx_SendBuffer(pRClxCtx->hSocket, pRClxData, Request.ReqSize))
    {
        rv = ERR_CLIENT_DISCONNECTED;
        goto exitpt;
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _Wait4RClxData
 *  Description:
 *      Waits for data response from RCLX client
 *  Arguments:
 *      pCI         - connection context
 *      dwTimeout   - timeout value
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCGetClientScreen
 --*/
LPCSTR
_Wait4RClxDataTimeout(PCONNECTINFO pCI, DWORD dwTimeout)
{
    WAIT4STRING Wait;
    LPCSTR  rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!(pCI->RClxMode))
    {
        TRACE((WARNING_MESSAGE, "_Wait4RClxData: Not in RCLX mode\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    memset(&Wait, 0, sizeof(Wait));
    Wait.evWait = CreateEvent(NULL,     //security
                              TRUE,     //manual
                              FALSE,    //initial state
                              NULL);    //name

    Wait.lProcessId = pCI->lProcessId;
    Wait.pOwner = pCI;
    Wait.WaitType = WAIT_DATA;

    rv = _WaitSomething(pCI, &Wait, dwTimeout);
    if (!rv)
    {
        TRACE(( INFO_MESSAGE, "RCLX data received\n"));
    }

    CloseHandle(Wait.evWait);
exitpt:
    return rv;
}

/*++
 *  Function:
 *      _Wait4Str
 *  Description:
 *      Waits for string(s) with specified timeout
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - waited string(s)
 *      dwTimeout   - timeout value
 *      WaitType    - WAIT_STRING ot WAIT_MSTRING
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCStart, Wait4Str, Wait4StrTimeout, Wait4MultipleStr
 *      Wait4MultipleStrTimeout, GetFeedbackString
 --*/
LPCSTR _Wait4Str(PCONNECTINFO pCI,
                 LPCWSTR lpszParam,
                 DWORD dwTimeout,
                 WAITTYPE WaitType)
{
    WAIT4STRING Wait;
    int parlen, i;
    LPCSTR rv = NULL;

    ASSERT(pCI);

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    memset(&Wait, 0, sizeof(Wait));

    // Check the parameter
    parlen = wcslen(lpszParam);

    // Copy the string
    if (parlen > sizeof(Wait.waitstr)/sizeof(WCHAR)-1)
        parlen = sizeof(Wait.waitstr)/sizeof(WCHAR)-1;

    wcsncpy(Wait.waitstr, lpszParam, parlen);
    Wait.waitstr[parlen] = 0;
    Wait.strsize = parlen;

    // Convert delimiters to 0s
    if (WaitType == WAIT_MSTRINGS)
    {
        WCHAR *p = Wait.waitstr;

        while((p = wcschr(p, WAIT_STR_DELIMITER)))
        {
            *p = 0;
            p++;
        }
    }

    Wait.evWait = CreateEvent(NULL,     //security
                              TRUE,     //manual
                              FALSE,    //initial state
                              NULL);    //name

    if (!Wait.evWait) {
        TRACE((ERROR_MESSAGE, "Couldn't create event\n"));
        goto exitpt;
    }
    Wait.lProcessId = pCI->lProcessId;
    Wait.pOwner = pCI;
    Wait.WaitType = WaitType;

    TRACE(( INFO_MESSAGE, "Expecting string: %S\n", Wait.waitstr));
    rv = _WaitSomething(pCI, &Wait, dwTimeout);
    TRACE(( INFO_MESSAGE, "String %S received\n", Wait.waitstr));

    if (!rv && pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
    }

    CloseHandle(Wait.evWait);
exitpt:
    return rv;
}

/*++
 *  Function:
 *      _WaitSomething
 *  Description:
 *      Wait for some event: string, connect or disconnect
 *      Meanwhile checks for chat sequences
 *  Arguments:
 *      pCI     -   connection context
 *      pWait   -   the event function waits for
 *      dwTimeout - timeout value
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      Wait4Connect, Wait4Disconnect, _Wait4Str
 --*/
LPCSTR
_WaitSomething(PCONNECTINFO pCI, PWAIT4STRING pWait, DWORD dwTimeout)
{
    BOOL    bDone = FALSE;
    LPCSTR  rv = NULL;
    DWORD   waitres;

    ASSERT(pCI || pWait);

    _AddToWaitQueue(pCI, pWait);
    pCI->evWait4Str = pWait->evWait;

    do {
        if (
            (waitres = WaitForMultipleObjects(
                pCI->nChatNum+1,
                &pCI->evWait4Str,
                FALSE,
                dwTimeout)) <= (pCI->nChatNum + WAIT_OBJECT_0))
        {
            if (waitres == WAIT_OBJECT_0)
            {
                bDone = TRUE;
            } else {
                PWAIT4STRING pNWait;

                ASSERT((unsigned)pCI->nChatNum >= waitres - WAIT_OBJECT_0);

                // Here we must send response messages
                waitres -= WAIT_OBJECT_0 + 1;
                ResetEvent(pCI->aevChatSeq[waitres]);
                pNWait = _RetrieveFromWaitQByEvent(pCI->aevChatSeq[waitres]);

                ASSERT(pNWait);
                ASSERT(wcslen(pNWait->respstr));
                TRACE((INFO_MESSAGE,
                       "Recieved : [%d]%S\n",
                        pNWait->strsize,
                        pNWait->waitstr ));
                SCSendtextAsMsgs(pCI, (LPCWSTR)pNWait->respstr);
            }
        } else {
            if (*(pWait->waitstr))
            {
                TRACE((WARNING_MESSAGE,
                       "Wait for \"%S\" failed: TIMEOUT\n",
                       pWait->waitstr));
            } else {
                TRACE((WARNING_MESSAGE, "Wait failed: TIMEOUT\n"));
            }
            rv = ERR_WAIT_FAIL_TIMEOUT;
            bDone = TRUE;
        }
    } while(!bDone);

    pCI->evWait4Str = NULL;

    _RemoveFromWaitQueue(pWait);

    if (!rv && pCI->dead)
        rv = ERR_CLIENT_IS_DEAD;

    return rv;
}

/*++
 *  Function:
 *      RegisterChat
 *  Description:
 *      This regiters a wait4str <-> sendtext pair
 *      so when we receive a specific string we will send a proper messages
 *      lpszParam is kind of: XXXXXX<->YYYYYY
 *      XXXXX is the waited string, YYYYY is the respond
 *      These command could be nested up to: MAX_WAITING_EVENTS
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - parameter, example:
 *                    "Connect to existing Windows NT session<->\n"
 *                  - hit enter when this string is received
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck, _Login
 --*/
LPCSTR RegisterChat(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
    PWAIT4STRING pWait;
    int parlen, i, resplen;
    LPCSTR rv = NULL;
    LPCWSTR  resp;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!lpszParam)
    {
        TRACE((WARNING_MESSAGE, "Parameter is null\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (pCI->nChatNum >= MAX_WAITING_EVENTS)
    {
        TRACE(( WARNING_MESSAGE, "RegisterChat: too much waiting strings\n" ));
        goto exitpt;
    }

    // Split the parameter
    resp = wcsstr(lpszParam, CHAT_SEPARATOR);
    // Check the strings
    if (!resp)
    {
        TRACE(( WARNING_MESSAGE, "RegisterChat: invalid parameter\n" ));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    parlen = wcslen(lpszParam) - wcslen(resp);
    resp += wcslen(CHAT_SEPARATOR);

    if (!parlen)
    {
        TRACE((WARNING_MESSAGE, "RegisterChat empty parameter\n"));
        goto exitpt;
    }

    resplen = wcslen(resp);
    if (!resplen)
    {
        TRACE((WARNING_MESSAGE, "RegisterChat: empty respond string\n" ));
        goto exitpt;
    }

    // Allocate the WAIT4STRING structure
    pWait = (PWAIT4STRING)malloc(sizeof(*pWait));
    if (!pWait)
    {
        TRACE((WARNING_MESSAGE,
               "RegisterChat: can't allocate %d bytes\n",
               sizeof(*pWait) ));
        goto exitpt;
    }
    memset(pWait, 0, sizeof(*pWait));

    // Copy the waited string
    if (parlen > sizeof(pWait->waitstr)/sizeof(WCHAR)-1)
        parlen = sizeof(pWait->waitstr)/sizeof(WCHAR)-1;

    wcsncpy(pWait->waitstr, lpszParam, parlen);
    pWait->waitstr[parlen] = 0;
    pWait->strsize = parlen;

    // Copy the respond string
    if (resplen > sizeof(pWait->respstr)-1)
        resplen = sizeof(pWait->respstr)-1;

    wcsncpy(pWait->respstr, resp, resplen);
    pWait->respstr[resplen] = 0;
    pWait->respsize = resplen;

    pWait->evWait = CreateEvent(NULL,   //security
                              TRUE,     //manual
                              FALSE,    //initial state
                              NULL);    //name

    if (!pWait->evWait) {
        TRACE((ERROR_MESSAGE, "Couldn't create event\n"));
        free (pWait);
        goto exitpt;
    }
    pWait->lProcessId  = pCI->lProcessId;
    pWait->pOwner       = pCI;
    pWait->WaitType     = WAIT_STRING;

    // _AddToWaitQNoCheck(pCI, pWait);
    _AddToWaitQueue(pCI, pWait);

    // Add to connection info array
    pCI->aevChatSeq[pCI->nChatNum] = pWait->evWait;
    pCI->nChatNum++;

exitpt:
    return rv;
}

// Remove a WAIT4STRING from waiting Q
// Param is the waited string
/*++
 *  Function:
 *      UnregisterChat
 *  Description:
 *      Deallocates and removes from waiting Q everithing
 *      from RegisterChat function
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - waited string
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck, _Login
 --*/
LPCSTR UnregisterChat(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
    PWAIT4STRING    pWait;
    LPCSTR      rv = NULL;
    int         i;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!lpszParam)
    {
        TRACE((WARNING_MESSAGE, "Parameter is null\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    pWait = _RemoveFromWaitQIndirect(pCI, lpszParam);
    if (!pWait)
    {
        TRACE((WARNING_MESSAGE,
               "UnregisterChat: can't find waiting string: %S\n",
               lpszParam ));
        goto exitpt;
    }

    i = 0;
    while (i < pCI->nChatNum && pCI->aevChatSeq[i] != pWait->evWait)
        i++;

    ASSERT(i < pCI->nChatNum);

    memmove(pCI->aevChatSeq+i,
                pCI->aevChatSeq+i+1,
                (pCI->nChatNum-i-1)*sizeof(pCI->aevChatSeq[0]));
    pCI->nChatNum--;

    CloseHandle(pWait->evWait);

    free(pWait);

exitpt:
    return rv;
}

/*
 *  Returns TRUE if the client is dead
 */
PROTOCOLAPI
BOOL
SMCAPI
SCIsDead(PCONNECTINFO pCI)
{
    if (!pCI)
        return TRUE;

    return  pCI->dead;
}

/*++
 *  Function:
 *      _CloseConnectInfo
 *  Description:
 *      Clean all resources for this connection. Close the client
 *  Arguments:
 *      pCI     - connection context
 *  Called by:
 *      SCDisconnect
 --*/
VOID
_CloseConnectInfo(PCONNECTINFO pCI)
{
    PRCLXDATACHAIN pRClxDataChain, pNext;

    ASSERT(pCI);

    _FlushFromWaitQ(pCI);

    // Close All handles
    EnterCriticalSection(g_lpcsGuardWaitQueue);

/*    // not needed, the handle is already closed
    if (pCI->evWait4Str)
    {
        CloseHandle(pCI->evWait4Str);
        pCI->evWait4Str = NULL;
    }
*/

    // Chat events are already closed by FlushFromWaitQ
    // no need to close them

    pCI->nChatNum = 0;

    if (!pCI->RClxMode)
    {
    // The client was local, so we have handles opened
        if (pCI->hProcess)
            CloseHandle(pCI->hProcess);
        if (pCI->hThread);
            CloseHandle(pCI->hThread);

        pCI->hProcess = pCI->hThread =NULL;
    } else {
    // Hmmm, RCLX mode. Then disconnect the socket

        if (pCI->hClient)
            RClx_EndRecv((PRCLXCONTEXT)(pCI->hClient));

        pCI->hClient = NULL;    // Clean the pointer
    }

    // Clear the clipboard handle (if any)
    if (pCI->ghClipboard)
    {
        GlobalFree(pCI->ghClipboard);
        pCI->ghClipboard = NULL;
    }

    // clear any recevied RCLX data
    pRClxDataChain = pCI->pRClxDataChain;
    while(pRClxDataChain)
    {
        pNext = pRClxDataChain->pNext;
        free(pRClxDataChain);
        pRClxDataChain = pNext;
    }

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    if (!pCI->RClxMode)
        _DeleteClientRegistry(pCI);

    free(pCI);
}

/*++
 *  Function:
 *      _Login
 *  Description:
 *      Emulate login procedure
 *  Arguments:
 *      pCI             - connection context
 *      lpszUserName    - user name
 *      lpszPassword    - password
 *      lpszDomain      - domain name
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCConnect
 --*/
LPCSTR _Login(PCONNECTINFO pCI,
              LPCWSTR lpszUserName,
              LPCWSTR lpszPassword,
              LPCWSTR lpszDomain)
{
    LPCSTR waitres;
    LPCSTR rv = NULL;
    WCHAR  szBuff[MAX_STRING_LENGTH];
    INT    nLogonRetrys = 5;
    UINT   nLogonWaitTime;

    ASSERT(pCI);

retry_logon:
    _snwprintf(szBuff, MAX_STRING_LENGTH, L"%s|%s|%s",
            g_strWinlogon, g_strPriorWinlogon, g_strLogonDisabled);

    waitres = Wait4MultipleStr(pCI, szBuff);
    if (!waitres)
    {
        if (pCI->nWait4MultipleStrResult == 1)
        {
            SCSendtextAsMsgs(pCI, g_strPriorWinlogon_Act);
            waitres = Wait4Str(pCI, g_strWinlogon);
        }
        else if (pCI->nWait4MultipleStrResult == 2)
        {
            SCSendtextAsMsgs(pCI, L"\\n");
            waitres = Wait4Str(pCI, g_strWinlogon);
        }
    }

    if (waitres)
    {
        TRACE((WARNING_MESSAGE, "Login failed"));
        rv = waitres;
        goto exitpt;
    }

// Hit Alt+U to go to user name field
    SCSendtextAsMsgs(pCI, g_strWinlogon_Act);

    SCSendtextAsMsgs(pCI, lpszUserName);
// Hit <Tab> key
    Sleep(300);
    SCSendtextAsMsgs(pCI, L"\\t");

    SCSendtextAsMsgs(pCI, lpszPassword);
// Hit <Tab> key
    Sleep(300);
    SCSendtextAsMsgs(pCI, L"\\t");

    SCSendtextAsMsgs(pCI, lpszDomain);
    Sleep(300);

    // Retry logon in case of
    // 1. Winlogon is on background
    // 2. Wrong username/password/domain
    // 3. Other

// Hit <Enter>
    SCSendtextAsMsgs(pCI, L"\\n");

    nLogonWaitTime = 0;
    while (!pCI->dead && !pCI->uiSessionId && nLogonWaitTime < CONNECT_TIMEOUT)
    {
        // Sleep with wait otherwise the chat won't work
        // i.e. this is a hack
        waitres = _Wait4Str(pCI, g_strLogonErrorMessage, 1000, WAIT_STRING);
        if (!waitres)
        // Error message received
        {
            SCSendtextAsMsgs(pCI, L"\\n");
            Sleep(1000);
            break;
        }
        nLogonWaitTime += 1000;
    }

    if (!pCI->dead && !pCI->uiSessionId)
    {
        TRACE((WARNING_MESSAGE, "Logon sequence failed. Retrying (%d)",
                nLogonRetrys));
        if (nLogonRetrys--)
            goto retry_logon;
    }

    if (!pCI->uiSessionId)
    {
    // Send Enter, just in case we are not logged yet
        SCSendtextAsMsgs(pCI, L"\\n");
        rv = ERR_CANTLOGON;
    }

exitpt:
    return rv;
}

WPARAM _GetVirtualKey(INT scancode)
{
    if (scancode == 29)     // L Control
        return VK_CONTROL;
    else if (scancode == 42)     // L Shift
        return VK_SHIFT;
    else if (scancode == 56)     // L Alt
        return VK_MENU;
    else
        return MapVirtualKey(scancode, 3);
}

/*++
 *  Function:
 *      SCSendtextAsMsgs
 *  Description:
 *      Converts a string to WM_KEYUP/KEYDOWN messages
 *      And sends them thru client window
 *  Arguments:
 *      pCI         - connection context
 *      lpszString  - the string to be send
 *                    it can contain the following escape character:
 *  \n - Enter, \t - Tab, \^ - Esc, \& - Alt switch up/down
 *  \XXX - scancode XXX is down, \*XXX - scancode XXX is up
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCLogoff, SCStart, _WaitSomething, _Login
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSendtextAsMsgs(PCONNECTINFO pCI, LPCWSTR lpszString)
{
    LPCSTR  rv = NULL;
    INT     scancode = 0;
    WPARAM  vkKey;
    BOOL    bShiftDown = FALSE;
    BOOL    bAltKey = FALSE;
    BOOL    bCtrlKey = FALSE;
    UINT    uiMsg;
    LPARAM  lParam;

#define _SEND_KEY(_c_, _m_, _v_, _l_)    {/*Sleep(40); */SCSenddata(_c_, _m_, _v_, _l_);}

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!lpszString)
    {
        TRACE((ERROR_MESSAGE, "NULL pointer passed to SCSendtextAsMsgs"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    TRACE(( INFO_MESSAGE, "Sending: \"%S\"\n", lpszString));

    for (;*lpszString; lpszString++)
    {
      if (*lpszString != '\\') {
try_again:
        if ((scancode = OemKeyScan(*lpszString)) == 0xffffffff)
        {
            rv = ERR_INVALID_SCANCODE_IN_XLAT;
            goto exitpt;
        }

    // Check the Shift key state
        if ((scancode & SHIFT_DOWN) && !bShiftDown)
        {
                uiMsg = (bAltKey)?WM_SYSKEYDOWN:WM_KEYDOWN;
                _SEND_KEY(pCI, uiMsg, VK_SHIFT,
                        WM_KEY_LPARAM(1, 0x2A, 0, (bAltKey)?1:0, 0, 0));
                bShiftDown = TRUE;
        }
        else if (!(scancode & SHIFT_DOWN) && bShiftDown)
        {
                uiMsg = (bAltKey)?WM_SYSKEYUP:WM_KEYUP;
                _SEND_KEY(pCI, uiMsg, VK_SHIFT,
                        WM_KEY_LPARAM(1, 0x2A, 0, (bAltKey)?1:0, 1, 1));
                bShiftDown = FALSE;
        }
      } else {
        // Non printable symbols
        lpszString++;
        switch(*lpszString)
        {
        case 'n': scancode = 0x1C; break;   // Enter
        case 't': scancode = 0x0F; break;   // Tab
        case '^': scancode = 0x01; break;   // Esc
        case 'p': Sleep(100);      break;   // Sleep for 0.1 sec
        case 'P': Sleep(1000);     break;   // Sleep for 1 sec
        case 'x': SCSendMouseClick(pCI, pCI->xRes/2, pCI->yRes/2); break;
        case '&':
            // Alt key
            if (bAltKey)
            {
              _SEND_KEY(pCI, WM_KEYUP, VK_MENU,
                WM_KEY_LPARAM(1, 0x38, 0, 0, 1, 1));
            } else {
              _SEND_KEY(pCI, WM_SYSKEYDOWN, VK_MENU,
                WM_KEY_LPARAM(1, 0x38, 0, 1, 0, 0));
            }
            bAltKey = !bAltKey;
            continue;
        case '*':
            lpszString ++;
            if (isdigit(*lpszString))
            {
                INT exten;

                scancode = _wtoi(lpszString);
                TRACE((INFO_MESSAGE, "Scancode: %d UP\n", scancode));

                vkKey = _GetVirtualKey(scancode);

                uiMsg = (!bAltKey || bCtrlKey)?WM_KEYUP:WM_SYSKEYUP;

                if (vkKey == VK_MENU)
                    bAltKey = FALSE;
                else if (vkKey == VK_CONTROL)
                    bCtrlKey = FALSE;
                else if (vkKey == VK_SHIFT)
                    bShiftDown = FALSE;

                exten = (_IsExtendedScanCode(scancode))?1:0;
                lParam = WM_KEY_LPARAM(1, scancode, exten, (bAltKey)?1:0, 1, 1);
                if (uiMsg == WM_KEYUP)
                {
                    TRACE((INFO_MESSAGE, "WM_KEYUP, 0x%x, 0x%x\n", vkKey, lParam));
                } else {
                    TRACE((INFO_MESSAGE, "WM_SYSKEYUP, 0x%x, 0x%x\n", vkKey, lParam));
                }

                _SEND_KEY(pCI, uiMsg, vkKey, lParam);


                while(isdigit(lpszString[1]))
                    lpszString++;
            } else {
                lpszString--;
            }
            continue;
            break;
        case 0: continue;
        default:
            if (isdigit(*lpszString))
            {
                INT exten;

                scancode = _wtoi(lpszString);
                TRACE((INFO_MESSAGE, "Scancode: %d DOWN\n", scancode));
                vkKey = _GetVirtualKey(scancode);

                if (vkKey == VK_MENU)
                    bAltKey = TRUE;
                else if (vkKey == VK_CONTROL)
                    bCtrlKey = TRUE;
                else if (vkKey == VK_SHIFT)
                    bShiftDown = TRUE;

                uiMsg = (!bAltKey || bCtrlKey)?WM_KEYDOWN:WM_SYSKEYDOWN;

                exten = (_IsExtendedScanCode(scancode))?1:0;
                lParam = WM_KEY_LPARAM(1, scancode, exten, (bAltKey)?1:0, 0, 0);

                if (uiMsg == WM_KEYDOWN)
                {
                    TRACE((INFO_MESSAGE, "WM_KEYDOWN, 0x%x, 0x%x\n", vkKey, lParam));
                } else {
                    TRACE((INFO_MESSAGE, "WM_SYSKEYDOWN, 0x%x, 0x%x\n", vkKey, lParam));
                }

                _SEND_KEY(pCI, uiMsg, vkKey, lParam);

                while(isdigit(lpszString[1]))
                    lpszString++;

                continue;
            }
            goto try_again;
      }

    }
    vkKey = MapVirtualKey(scancode, 3);
    // Remove flag fields
        scancode &= 0xff;

        uiMsg = (!bAltKey || bCtrlKey)?WM_KEYDOWN:WM_SYSKEYDOWN;
    // Send the scancode
        _SEND_KEY(pCI, uiMsg, vkKey,
                        WM_KEY_LPARAM(1, scancode, 0, (bAltKey)?1:0, 0, 0));
        uiMsg = (!bAltKey || bCtrlKey)?WM_KEYUP:WM_SYSKEYUP;
        _SEND_KEY(pCI, uiMsg, vkKey,
                        WM_KEY_LPARAM(1, scancode, 0, (bAltKey)?1:0, 1, 1));
    }

    // And Alt key
    if (bAltKey)
        _SEND_KEY(pCI, WM_KEYUP, VK_MENU,
            WM_KEY_LPARAM(1, 0x38, 0, 0, 1, 1));

    // Shift up
    if (bShiftDown)
        _SEND_KEY(pCI, WM_KEYUP, VK_LSHIFT,
            WM_KEY_LPARAM(1, 0x2A, 0, 0, 1, 1));

    // Ctrl key
    if (bCtrlKey)
        _SEND_KEY(pCI, WM_KEYUP, VK_CONTROL,
            WM_KEY_LPARAM(1, 0x1D, 0, 0, 1, 1));
#undef   _SEND_KEY
exitpt:
    return rv;
}

/*++
 *  Function:
 *      SwitchToProcess
 *  Description:
 *      Use Alt+Tab to switch to a particular process that is already running
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - the text in the alt-tab box that uniquely identifies the
 *                    process we should stop at (i.e., end up switching to)
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSwitchToProcess(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
#define ALT_TAB_WAIT_TIMEOUT 1000
#define MAX_APPS             20

    LPCSTR  rv = NULL;
    LPCSTR  waitres = NULL;
    INT     retrys = MAX_APPS;

    WCHAR *wszCurrTask = 0;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }


    // Wait and look for the string, before we do any switching.  This makes
    // sure we don't hit the string even before we hit alt-tab, and then
    // end up switching to the wrong process

    while (_Wait4Str(pCI, lpszParam, ALT_TAB_WAIT_TIMEOUT/5, WAIT_STRING) == 0)
        ;

    // Press alt down
    SCSenddata(pCI, WM_KEYDOWN, 18, 540540929);

    // Now loop through the list of applications (assuming there is one),
    // stopping at our desired app.
    do {
        SCSenddata(pCI, WM_KEYDOWN, 9, 983041);
        SCSenddata(pCI, WM_KEYUP, 9, -1072758783);


        waitres = _Wait4Str(pCI, lpszParam, ALT_TAB_WAIT_TIMEOUT, WAIT_STRING);

        retrys --;
    } while (waitres && retrys);

    SCSenddata(pCI, WM_KEYUP, 18, -1070071807);

    rv = waitres;

exitpt:
    return rv;
}

/*++
 *  Function:
 *      SCSetClientTopmost
 *  Description:
 *      Swithces the focus to this client
 *  Arguments:
 *      pCI     - connection context
 *      lpszParam
 *              - "0" will remote the WS_EX_TOPMOST style
 *              - "non_zero" will set it as topmost window
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSetClientTopmost(
        PCONNECTINFO pCI,
        LPCWSTR     lpszParam
    )
{
    LPCSTR rv = NULL;
    BOOL   bTop = FALSE;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (pCI->RClxMode)
    {
        TRACE((ERROR_MESSAGE, "SetClientOnFocus not supported in RCLX mode\n"));
        rv = ERR_NOTSUPPORTED;
        goto exitpt;
    }

    if (!pCI->hClient)
    {
        TRACE((WARNING_MESSAGE, "Client's window handle is null\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    if (lpszParam)
        bTop = (_wtoi(lpszParam) != 0);
    else
        bTop = 0;

    SetWindowPos(pCI->hClient,
                    (bTop)?HWND_TOPMOST:HWND_NOTOPMOST,
                    0,0,0,0,
                    SWP_NOMOVE | SWP_NOSIZE);

    ShowWindow(pCI->hClient, SW_SHOWNORMAL);

    if (bTop)
    {
        TRACE((INFO_MESSAGE, "Client is SET as topmost window\n"));
    } else {
        TRACE((INFO_MESSAGE, "Client is RESET as topmost window\n"));
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _SendMouseClick
 *  Description:
 *      Sends a messages for a mouse click
 *  Arguments:
 *      pCI     - connection context
 *      xPos    - mouse position
 *      yPos
 *  Return value:
 *      error string if fails, NULL on success
 *  Called by:
 *      * * * EXPORTED * * *
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSendMouseClick(
        PCONNECTINFO pCI,
        UINT xPos,
        UINT yPos)
{
    LPCSTR rv;

    rv = SCSenddata(pCI, WM_LBUTTONDOWN, 0, xPos + (yPos << 16));
    if (!rv)
        SCSenddata(pCI, WM_LBUTTONUP, 0, xPos + (yPos << 16));

    return rv;
}

/*++
 *  Function:
 *      SCSaveClientScreen
 *  Description:
 *      Saves in a file rectangle of the client's receive screen buffer
 *      ( aka shadow bitmap)
 *  Arguments:
 *      pCI     - connection context
 *      left, top, right, bottom - rectangle coordinates
 *                if all == -1 get's the whole screen
 *      szFileName - file to record
 *  Return value:
 *      error string if fails, NULL on success
 *  Called by:
 *      * * * EXPORTED * * *
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSaveClientScreen(
        PCONNECTINFO pCI,
        INT left,
        INT top,
        INT right,
        INT bottom,
        LPCSTR szFileName)
{
    LPCSTR  rv = NULL;
    PVOID   pDIB = NULL;
    UINT    uiSize = 0;

    if (!szFileName)
    {
        TRACE((WARNING_MESSAGE, "SCSaveClientScreen: szFileName is NULL\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    // leave the rest of param checking to SCGetClientScreen
    rv = SCGetClientScreen(pCI, left, top, right, bottom, &uiSize, &pDIB);
    if (rv)
        goto exitpt;

    if (!pDIB || !uiSize)
    {
        TRACE((ERROR_MESSAGE, "SCSaveClientScreen: failed, no data\n"));
        rv = ERR_NODATA;
        goto exitpt;
    }

    if (!SaveDIB(pDIB, szFileName))
    {
        TRACE((ERROR_MESSAGE, "SCSaveClientScreen: save failed\n"));
        rv = ERR_NODATA;
        goto exitpt;
    }

exitpt:

    if (pDIB)
        free(pDIB);

    return rv;
}

/*++
 *  Function:
 *      SCGetClientScreen
 *  Description:
 *      Gets rectangle of the client's receive screen buffer
 *      ( aka shadow bitmap)
 *  Arguments:
 *      pCI     - connection context
 *      left, top, right, bottom - rectangle coordinates
 *                if all == -1 get's the whole screen
 *      ppDIB   - pointer to the received DIB
 *      puiSize - size of allocated data in ppDIB
 *
 *          !!!!! DON'T FORGET to free() THAT MEMORY !!!!!
 *
 *  Return value:
 *      error string if fails, NULL on success
 *  Called by:
 *      SCSaveClientScreen
 *      * * * EXPORTED * * *
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCGetClientScreen(
        PCONNECTINFO pCI,
        INT left,
        INT top,
        INT right,
        INT bottom,
        UINT  *puiSize,
        PVOID *ppDIB)
{
    LPCSTR rv;
    PRCLXDATA  pRClxData;
    PREQBITMAP pReqBitmap;
    PRCLXDATACHAIN pIter, pPrev, pNext;
    PRCLXDATACHAIN pRClxDataChain = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (!pCI->RClxMode)
    {
        TRACE((WARNING_MESSAGE, "SCGetClientScreen is not supported in non-RCLX mode\n"));
        rv = ERR_NOTSUPPORTED;
        goto exitpt;
    }

    if (!ppDIB || !puiSize)
    {
        TRACE((WARNING_MESSAGE, "ppDIB and/or puiSize parameter is NULL\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    // Remove all recieved DATA_BITMAP from the recieve buffer
    EnterCriticalSection(g_lpcsGuardWaitQueue);
    {
        pIter = pCI->pRClxDataChain;
        pPrev = NULL;

        while (pIter)
        {
            pNext = pIter->pNext;

            if (pIter->RClxData.uiType == DATA_BITMAP)
            {
                // dispose this entry
                if (pPrev)
                    pPrev->pNext = pIter->pNext;
                else
                    pCI->pRClxDataChain = pIter->pNext;

                if (!pIter->pNext)
                    pCI->pRClxLastDataChain = pPrev;

                free(pIter);
            } else
                pPrev = pIter;

            pIter = pNext;
        }
    }
    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    pRClxData = alloca(sizeof(*pRClxData) + sizeof(*pReqBitmap));
    pRClxData->uiType = DATA_BITMAP;
    pRClxData->uiSize = sizeof(*pReqBitmap);
    pReqBitmap = (PREQBITMAP)pRClxData->Data;
    pReqBitmap->left   = left;
    pReqBitmap->top    = top;
    pReqBitmap->right  = right;
    pReqBitmap->bottom = bottom;

    TRACE((INFO_MESSAGE, "Getting client's DIB (%d, %d, %d, %d)\n", left, top, right, bottom));
    rv = _SendRClxData(pCI, pRClxData);

    if (rv)
        goto exitpt;

    do {
        rv = _Wait4RClxDataTimeout(pCI, WAIT4STR_TIMEOUT);
            if (rv)
            goto exitpt;

        if (!pCI->pRClxDataChain)
        {
            TRACE((ERROR_MESSAGE, "RClxData is not received\n"));
            rv = ERR_WAIT_FAIL_TIMEOUT;
            goto exitpt;
        }

        EnterCriticalSection(g_lpcsGuardWaitQueue);
        // Get any received DATA_BITMAP
        {
            pIter = pCI->pRClxDataChain;
            pPrev = NULL;

            while (pIter)
            {
                pNext = pIter->pNext;

                if (pIter->RClxData.uiType == DATA_BITMAP)
                {
                    // dispose this entry from the chain
                    if (pPrev)
                        pPrev->pNext = pIter->pNext;
                    else
                        pCI->pRClxDataChain = pIter->pNext;

                    if (!pIter->pNext)
                        pCI->pRClxLastDataChain = pPrev;

                    goto entry_is_found;
                } else
                    pPrev = pIter;

                pIter = pNext;
            }

entry_is_found:
            pRClxDataChain = (pIter && pIter->RClxData.uiType == DATA_BITMAP)?
                                pIter:NULL;
        }
        LeaveCriticalSection(g_lpcsGuardWaitQueue);
    } while (!pRClxDataChain && !pCI->dead);

    if (!pRClxDataChain)
    {
        TRACE((WARNING_MESSAGE, "SCGetClientScreen: client died\n"));
        goto exitpt;
    }

    *ppDIB = malloc(pRClxDataChain->RClxData.uiSize);
    if (!(*ppDIB))
    {
        TRACE((WARNING_MESSAGE, "Can't allocate %d bytes\n",
                pRClxDataChain->RClxData.uiSize));
        rv = ERR_ALLOCATING_MEMORY;
        goto exitpt;
    }

    memcpy(*ppDIB,
            pRClxDataChain->RClxData.Data,
            pRClxDataChain->RClxData.uiSize);
    *puiSize = pRClxDataChain->RClxData.uiSize;

exitpt:

    if (pRClxDataChain)
        free(pRClxDataChain);

    return rv;
}

/*++
 *  Function:
 *      SCSendVCData
 *  Description:
 *      Sends data to a virtual channel
 *  Arguments:
 *      pCI     - connection context
 *      szVCName    - the virtual channel name
 *      pData       - data
 *      uiSize      - data size
 *  Return value:
 *      error string if fails, NULL on success
 *  Called by:
 *      * * * EXPORTED * * *
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSendVCData(
        PCONNECTINFO pCI,
        LPCSTR       szVCName,
        PVOID        pData,
        UINT         uiSize
        )
{
    LPCSTR     rv;
    PRCLXDATA  pRClxData = NULL;
    CHAR       *szName2Send;
    PVOID      pData2Send;
    UINT       uiPacketSize;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (!pCI->RClxMode)
    {
        TRACE((WARNING_MESSAGE, "SCSendVCData is not supported in non-RCLXmode\n"));
        rv = ERR_NOTSUPPORTED;
        goto exitpt;
    }

    if (!pData || !uiSize)
    {
        TRACE((WARNING_MESSAGE, "pData and/or uiSize parameter are NULL\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    if (strlen(szVCName) > MAX_VCNAME_LEN - 1)
    {
        TRACE((WARNING_MESSAGE, "channel name too long\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    uiPacketSize = sizeof(*pRClxData) + MAX_VCNAME_LEN + uiSize;

    pRClxData = malloc(uiPacketSize);
    if (!pRClxData)
    {
        TRACE((ERROR_MESSAGE, "SCSendVCData: can't allocate %d bytes\n",
                uiPacketSize));
        rv = ERR_ALLOCATING_MEMORY;
        goto exitpt;
    }

    pRClxData->uiType = DATA_VC;
    pRClxData->uiSize = uiPacketSize - sizeof(*pRClxData);

    szName2Send = (CHAR *)pRClxData->Data;
    strcpy(szName2Send, szVCName);

    pData2Send  = szName2Send + MAX_VCNAME_LEN;
    memcpy(pData2Send, pData, uiSize);

    rv = _SendRClxData(pCI, pRClxData);

exitpt:
    if (pRClxData)
        free(pRClxData);

    return rv;
}

/*++
 *  Function:
 *      SCRecvVCData
 *  Description:
 *      Receives data from virtual channel
 *  Arguments:
 *      pCI     - connection context
 *      szVCName    - the virtual channel name
 *      ppData      - data pointer
 *
 *          !!!!! DON'T FORGET to free() THAT MEMORY !!!!!
 *
 *      puiSize     - pointer to the data size
 *  Return value:
 *      error string if fails, NULL on success
 *  Called by:
 *      * * * EXPORTED * * *
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCRecvVCData(
        PCONNECTINFO pCI,
        LPCSTR       szVCName,
        PVOID        pData,
        UINT         uiBlockSize,
        UINT         *puiBytesRead
        )
{
    LPCSTR      rv;
    LPSTR       szRecvVCName;
    PVOID       pChanData;
    PRCLXDATACHAIN pIter, pPrev, pNext;
    PRCLXDATACHAIN pRClxDataChain = NULL;
    UINT        uiBytesRead = 0;
    BOOL        bBlockFree = FALSE;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (!pCI->RClxMode)
    {
        TRACE((WARNING_MESSAGE, "SCRecvVCData is not supported in non-RCLXmode\n"));
        rv = ERR_NOTSUPPORTED;
        goto exitpt;
    }

    if (!pData || !uiBlockSize || !puiBytesRead)
    {
        TRACE((WARNING_MESSAGE, "Invalid parameters\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    if (strlen(szVCName) > MAX_VCNAME_LEN - 1)
    {
        TRACE((WARNING_MESSAGE, "channel name too long\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    // Extract data entry from this channel
    do {
        if (!pCI->pRClxDataChain)
        {
            rv = _Wait4RClxDataTimeout(pCI, WAIT4STR_TIMEOUT);
            if (rv)
                goto exitpt;
        }
        EnterCriticalSection(g_lpcsGuardWaitQueue);

        // Search for data from this channel
        {
            pIter = pCI->pRClxDataChain;
            pPrev = NULL;

            while (pIter)
            {
                pNext = pIter->pNext;

                if (pIter->RClxData.uiType == DATA_VC &&
                    !_stricmp(pIter->RClxData.Data, szVCName))
                {

                    if (pIter->RClxData.uiSize - pIter->uiOffset - MAX_VCNAME_LEN <= uiBlockSize)
                    {
                        // will read the whole block
                        // dispose this entry
                        if (pPrev)
                            pPrev->pNext = pIter->pNext;
                        else
                            pCI->pRClxDataChain = pIter->pNext;

                        if (!pIter->pNext)
                            pCI->pRClxLastDataChain = pPrev;

                        bBlockFree = TRUE;
                    }

                    goto entry_is_found;
                } else
                    pPrev = pIter;

                pIter = pNext;
            }
entry_is_found:

            pRClxDataChain = (pIter && pIter->RClxData.uiType == DATA_VC)?
                                pIter:NULL;
        }
        LeaveCriticalSection(g_lpcsGuardWaitQueue);
    } while (!pRClxDataChain && !pCI->dead);


    ASSERT(pRClxDataChain->RClxData.uiType == DATA_VC);

    szRecvVCName = pRClxDataChain->RClxData.Data;
    if (_stricmp(szRecvVCName, szVCName))
    {
        TRACE((ERROR_MESSAGE, "SCRecvVCData: received from different channel: %s\n", szRecvVCName));
        ASSERT(0);
    }

    pChanData = (BYTE *)(pRClxDataChain->RClxData.Data) +
                pRClxDataChain->uiOffset + MAX_VCNAME_LEN;
    uiBytesRead = pRClxDataChain->RClxData.uiSize -
                  pRClxDataChain->uiOffset - MAX_VCNAME_LEN;
    if (uiBytesRead > uiBlockSize)
        uiBytesRead = uiBlockSize;


    memcpy(pData, pChanData, uiBytesRead);

    pRClxDataChain->uiOffset += uiBytesRead;

    rv = NULL;

exitpt:

    if (pRClxDataChain && bBlockFree)
    {
        ASSERT(pRClxDataChain->uiOffset + MAX_VCNAME_LEN == pRClxDataChain->RClxData.uiSize);
        free(pRClxDataChain);
    }

    if (puiBytesRead)
    {
        *puiBytesRead = uiBytesRead;
        TRACE((INFO_MESSAGE, "SCRecvVCData: %d bytes read\n", uiBytesRead));
    }

    return rv;
}

/*++
 *  Function:
 *      _EnumWindowsProc
 *  Description:
 *      Used to find a specific window
 *  Arguments:
 *      hWnd    - current enumerated window handle
 *      lParam  - pointer to SEARCHWND passed from
 *                _FindTopWindow
 *  Return value:
 *      TRUE on success but window is not found
 *      FALSE if the window is found
 *  Called by:
 *      _FindTopWindow thru EnumWindows
 --*/
BOOL CALLBACK _EnumWindowsProc( HWND hWnd, LPARAM lParam )
{
    TCHAR   classname[128];
    TCHAR   caption[128];
    BOOL    rv = TRUE;
    DWORD   dwProcessId;
    LONG_PTR lProcessId;
    PSEARCHWND pSearch = (PSEARCHWND)lParam;

    if (pSearch->szClassName &&
        !GetClassName(hWnd, classname, sizeof(classname)))
    {
        goto exitpt;
    }

    if (pSearch->szCaption && !GetWindowText(hWnd, caption, sizeof(caption)))
    {
        goto exitpt;
    }

    GetWindowThreadProcessId(hWnd, &dwProcessId);
    lProcessId = dwProcessId;
    if (
        (!pSearch->szClassName || !         // Check for classname
#ifdef  UNICODE
        wcscmp
#else
        strcmp
#endif
            (classname, pSearch->szClassName))
    &&
        (!pSearch->szCaption || !
#ifdef  UNICODE
        wcscmp
#else
        strcmp
#endif
            (caption, pSearch->szCaption))
    &&
        lProcessId == pSearch->lProcessId)
    {
        ((PSEARCHWND)lParam)->hWnd = hWnd;
        rv = FALSE;
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _FindTopWindow
 *  Description:
 *      Find specific window by classname and/or caption and/or process Id
 *  Arguments:
 *      classname   - class name to search for, NULL ignore
 *      caption     - caption to search for, NULL ignore
 *      dwProcessId - process Id, 0 ignore
 *  Return value:
 *      window handle found, NULL otherwise
 *  Called by:
 *      SCConnect, SCDisconnect, GetDisconnectResult
 --*/
HWND _FindTopWindow(LPTSTR classname, LPTSTR caption, LONG_PTR lProcessId)
{
    SEARCHWND search;

    search.szClassName = classname;
    search.szCaption = caption;
    search.hWnd = NULL;
    search.lProcessId = lProcessId;

    EnumWindows(_EnumWindowsProc, (LPARAM)&search);

    return search.hWnd;
}

/*++
 *  Function:
 *      _FindWindow
 *  Description:
 *      Find child window by caption and/or classname
 *  Arguments:
 *      hwndParent      - the parent window handle
 *      srchcaption     - caption to search for, NULL - ignore
 *      srchclass       - class name to search for, NULL - ignore
 *  Return value:
 *      window handle found, NULL otherwise
 *  Called by:
 *      SCConnect
 --*/
HWND _FindWindow(HWND hwndParent, LPTSTR srchcaption, LPTSTR srchclass)
{
    HWND hWnd, hwndTop, hwndNext;
    BOOL bFound;
    TCHAR classname[128];
    TCHAR caption[128];

    hWnd = NULL;

    hwndTop = GetWindow(hwndParent, GW_CHILD);
    if (!hwndTop)
    {
        TRACE((INFO_MESSAGE, "GetWindow failed. hwnd=0x%x\n", hwndParent));
        goto exiterr;
    }

    bFound = FALSE;
    hwndNext = hwndTop;
    do {
        hWnd = hwndNext;
        if (srchclass && !GetClassName(hWnd, classname, sizeof(classname)))
        {
            TRACE((INFO_MESSAGE, "GetClassName failed. hwnd=0x%x\n"));
            goto nextwindow;
        }
        if (srchcaption && !GetWindowText(hWnd, caption, sizeof(caption)))
        {
            TRACE((INFO_MESSAGE, "GetWindowText failed. hwnd=0x%x\n"));
            goto nextwindow;
        }

        if (
            (!srchclass || !
#ifdef  UNICODE
            wcscmp
#else
            strcmp
#endif
                (classname, srchclass))
        &&
            (!srchcaption || !
#ifdef  UNICODE
            wcscmp
#else
            strcmp
#endif
                (caption, srchcaption))
        )
            bFound = TRUE;
nextwindow:
        hwndNext = GetNextWindow(hWnd, GW_HWNDNEXT);
    } while (hWnd && hwndNext != hwndTop && !bFound);

    if (!bFound) goto exiterr;

    return hWnd;
exiterr:
    return NULL;
}

BOOL
_IsExtendedScanCode(INT scancode)
{
    static BYTE extscans[] = \
        {28, 29, 53, 55, 56, 71, 72, 73, 75, 77, 79, 80, 81, 82, 83, 87, 88};
    INT idx;

    for (idx = 0; idx < sizeof(extscans); idx++)
    {
        if (scancode == (INT)extscans[idx])
            return TRUE;
    }
    return FALSE;
}

PROTOCOLAPI
BOOL
SMCAPI
SCOpenClipboard(HWND hwnd)
{
    return OpenClipboard(hwnd);
}

PROTOCOLAPI
BOOL
SMCAPI
SCCloseClipboard(VOID)
{
    return CloseClipboard();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\scfuncsa.c ===
/*++
 *  File name:
 *      scfuncsa.c
 *  Contents:
 *      Ascii version of the functions exported by scfuncs.c
 *      Used by the perl extension
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 *
 --*/
#include    <windows.h>
#include    <string.h>
#include    <malloc.h>

#define     PROTOCOLAPI
#include    "protocol.h"
#include    "tclient.h"

/*
 *  External functions definitions
 */
#include    "extraexp.h"

/*
 *  Internal functions definitions
 */
LPWSTR _Ascii2Wide(char *ascii);

/*++
 *  Function:
 *      SCConnectExA
 *  Description:
 *      Ascii version of SCConnectEx. Converts LPSTR params to LPWSTR
 *  Arguments:
 *      same as SCConnect
 *  Return value:
 *      the return value of SCConnect
 *  Called by:
 *      unknown (exported)
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCConnectExA (
                 char *lpszServerName,
                 char *lpszUserName,
                 char *lpszPassword,
                 char *lpszDomain,
                 char *lpszShell,
                 int xResolution,
                 int yResolution,
                 int ConnectinFlags,
                 void **ppConnectData)
{
    LPWSTR  wszServerName, wszUserName, wszPassword, wszDomain;
    LPWSTR  wszShell;
    LPCSTR  rv = NULL;

    wszServerName = _Ascii2Wide(lpszServerName);
    wszUserName   = _Ascii2Wide(lpszUserName);
    wszPassword   = _Ascii2Wide(lpszPassword);
    wszDomain     = _Ascii2Wide(lpszDomain);
    wszShell      = _Ascii2Wide(lpszShell);

    if (wszServerName &&
        wszUserName   &&
        wszPassword   &&
        wszDomain)
        rv = SCConnectEx(wszServerName,
                       wszUserName,
                       wszPassword,
                       wszDomain,
                       wszShell,    // NULL is default shell
                       xResolution,
                       yResolution,
                       ConnectinFlags,
                       ppConnectData);
    else
        rv = ERR_ALLOCATING_MEMORY;

    if (wszServerName)
        free(wszServerName);

    if (wszUserName)
        free(wszUserName);

    if (wszPassword)
        free(wszPassword);

    if (wszDomain)
        free(wszDomain);

    if (wszShell)
        free(wszShell);

    return rv;
}


/*++
 *  Function:
 *      SCConnectA
 *  Description:
 *      Ascii version of SCConnect. Converts LPSTR params to LPWSTR
 *  Arguments:
 *      same as SCConnect
 *  Return value:
 *      the return value of SCConnect
 *  Called by:
 *      !tclntpll.xs
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCConnectA (char *lpszServerName,
                 char *lpszUserName,
                 char *lpszPassword,
                 char *lpszDomain,
                 int xResolution,
                 int yResolution,
                 void **ppConnectData)
{
    LPWSTR  wszServerName, wszUserName, wszPassword, wszDomain;
    LPCSTR  rv = NULL;

    wszServerName = _Ascii2Wide(lpszServerName);
    wszUserName = _Ascii2Wide(lpszUserName);
    wszPassword = _Ascii2Wide(lpszPassword);
    wszDomain   = _Ascii2Wide(lpszDomain);

    if (wszServerName &&
        wszUserName   &&
        wszPassword   &&
        wszDomain)
        rv = SCConnect(wszServerName,
                       wszUserName,
                       wszPassword,
                       wszDomain,
                       xResolution,
                       yResolution,
                       ppConnectData);
    else
        rv = ERR_ALLOCATING_MEMORY;

    if (wszServerName)
        free(wszServerName);

    if (wszUserName)
        free(wszUserName);

    if (wszPassword)
        free(wszPassword);

    if (wszDomain)
        free(wszDomain);

    return rv;
}

/*++
 *  Function:
 *      SCStartA
 *  Description:
 *      Ascii version of SCStart
 *  Arguments:
 *      same as SCStart
 *  Return value:
 *      return value from SCStart
 *  Called by:
 *      !tclntpll.xs
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCStartA(void *pConnectData, char *command)
{
    LPWSTR  wcmd;
    LPCSTR  rv = NULL;

    wcmd = _Ascii2Wide(command);

    if (wcmd)
    {
        rv = SCStart(pConnectData, wcmd);
    } else {
        rv = ERR_ALLOCATING_MEMORY;
    }

    if (wcmd)
        free(wcmd);

    return rv;
}

/*++
 *  Function:
 *      SCCheckA
 *  Description:
 *      Ascii version of SCCheck
 *  Arguments:
 *      same as SCCheck
 *  Return value:
 *      return value from SCCheck
 *  Called by:
 *      !tclntpll.xs
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCCheckA(void *pConnectData, char *command, char *param)
{
    LPWSTR  wparam;
    LPCSTR  rv = NULL;

    wparam = _Ascii2Wide(param);

    if (wparam)
    {
        rv = SCCheck(pConnectData, command, wparam);
    } else {
        rv = ERR_ALLOCATING_MEMORY;
    }

    if (wparam)
        free(wparam);

    return rv;
}

/*++
 *  Function:
 *      SCSendtextAsMsgsA
 *  Description:
 *      Ascii version of SCSendtextAsMsgs
 *  Arguments:
 *      same as SCSendtextAsMsgs
 *  Return value:
 *      return value from SCSendtextAsMsgs
 *  Called by:
 *      !tclntpll.xs
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSendtextAsMsgsA(void *pConnectData, char *line)
{
    LPWSTR  wline;
    LPCSTR  rv = NULL;

    wline = _Ascii2Wide(line);

    if (wline)
        rv = SCSendtextAsMsgs(pConnectData, wline);
    else
        rv = ERR_ALLOCATING_MEMORY;

    if (wline)
        free(wline);

    return rv;
}

/*++
 *  Function:
 *      _Ascii2Wide
 *  Description:
 *      Allocates buffer and converts an ascii string
 *      to unicode
 *  Arguments:
 *      ascii   - the input string
 *  Return value:
 *      pointer to converted string
 *  Called by:
 *      SCConnectA, SCStartA, SCCheckA, SCSendtextAsMsgsA
 --*/
LPWSTR _Ascii2Wide(char *ascii)
{
    LPWSTR  wszWide = NULL;
    int     wsize, ccLen;

    if (!ascii)
        goto exitpt;

    ccLen = strlen(ascii);
    wsize = (ccLen + 1) * sizeof(WCHAR);
    wszWide = malloc(wsize);
    if (wszWide)
        MultiByteToWideChar(
            CP_UTF8,
            0,
            ascii,
            -1,
            wszWide,
            ccLen + 1);

exitpt:
    return wszWide;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\rclx.h ===
/*++
 *  File name:
 *      rclx.h
 *  Contents:
 *      Definitions for RCLX (Remote CLient eXecution) module
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

typedef struct _RCLXCONTEXT {
    SOCKET      hSocket;
    PCONNECTINFO    pOwner;
    BOOL        bPrologReceived;
    BOOL        bHeadReceived;
    BOOL        bRecvDone;
    UINT        nBytesToReceive;
    RCLXFEEDPROLOG  Prolog;
    UINT        nHeadAllocated;
    UINT        nTailAllocated;
    PVOID       pHead;
    PVOID       pTail;
    struct      _RCLXCONTEXT *pNext;
} RCLXCONTEXT, *PRCLXCONTEXT;

BOOL RClx_Init(VOID);
VOID RClx_Done(VOID);

VOID RClx_DispatchWSockEvent(SOCKET hSocket, LPARAM lEvent);

BOOL RClx_SendConnectInfo(PRCLXCONTEXT pContext,
                          LPCWSTR wszHydraServer,
                          INT xRes,
                          INT yRes,
                          INT ConnectionFlags);

BOOL RClx_SendMessage(PRCLXCONTEXT pContext,
                      UINT uiMessage,
                      WPARAM wParam,
                      LPARAM lParam);

BOOL RClx_SendClipboard(
    PRCLXCONTEXT pContext,
    PVOID        pClipboard,
    UINT         nDataLength,
    UINT         uiFormat);

BOOL RClx_SendClipboardRequest(
    PRCLXCONTEXT pContext,
    UINT         uiFormat);

BOOL RClx_SendBuffer(SOCKET hSocket, PVOID pBuffer, UINT nSize);

VOID RClx_EndRecv(PRCLXCONTEXT pContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\tclient.h ===
/*++
 *  File name:
 *      tclient.h
 *  Contents:
 *      Common definitions for tclient.dll
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#ifndef _TCLIENT_H

#define _TCLIENT_H

#ifndef OS_WIN32
#define OS_WIN32
#endif

#include    "feedback.h"
#include    "clntdata.h"

// Error messages
#define ERR_START_MENU_NOT_APPEARED     "Start menu not appeared"
#define ERR_COULDNT_OPEN_PROGRAM        "Couldn't open a program"
#define ERR_INVALID_SCANCODE_IN_XLAT    "Invalid scancode in Xlat table"
#define ERR_WAIT_FAIL_TIMEOUT           "Wait failed: TIMEOUT"
#define ERR_INVALID_PARAM               "Invalid parameter"
#define ERR_NULL_CONNECTINFO            "ConnectInfo structure is NULL"
#define ERR_CLIENT_IS_DEAD              "Client is dead, sorry"
#define ERR_ALLOCATING_MEMORY           "Couldn't allocate memory"
#define ERR_CREATING_PROCESS            "Couldn't start process"
#define ERR_CREATING_THREAD             "Can't create thread"
#define ERR_INVALID_COMMAND             "Check: Invalid command"
#define ERR_ALREADY_DISCONNECTED        "No Info. Disconnect command" \
                                        " was executed"
#define ERR_CONNECTING                  "Can't connect"
#define ERR_CANTLOGON                   "Can't logon"
#define ERR_NORMAL_EXIT                 "Client exit normaly"
#define ERR_UNKNOWN_CLIPBOARD_OP        "Unknown clipboard operation"
#define ERR_COPY_CLIPBOARD              "Error copying to the clipboard"
#define ERR_PASTE_CLIPBOARD             "Error pasting from the clipboard"
#define ERR_PASTE_CLIPBOARD_EMPTY       "The clipboard is empty"
#define ERR_PASTE_CLIPBOARD_DIFFERENT_SIZE "Check clipboard: DIFFERENT SIZE"
#define ERR_PASTE_CLIPBOARD_NOT_EQUAL   "Check clipboard: NOT EQUAL"
#define ERR_SAVE_CLIPBOARD              "Save clipboard FAILED"
#define ERR_CLIPBOARD_LOCKED            "Clipboard is locked for writing " \
                                        "by another thread"
#define ERR_CLIENTTERMINATE_FAIL        "Client termination FAILED"
#define ERR_NOTSUPPORTED                "Call is not supported in this mode"
#define ERR_CLIENT_DISCONNECTED         "Client is disconnected"
#define ERR_NODATA                      "The call failed, data is missing"

// scancode modifier(s)
#define     SHIFT_DOWN 0x10000

// Look for WM_KEYUP or WM_KEYDOWN
#define WM_KEY_LPARAM(repeat, scan, exten, context, prev, trans) \
    (repeat + ((scan & 0xff) << 16) + ((exten & 1) << 24) +\
    ((context & 1) << 29) + ((prev & 1) << 30) + ((trans & 1) << 31))

extern VOID _TClientAssert( LPCTSTR filename, INT line);

#ifndef ASSERT
#define ASSERT(_x_)   if (!(_x_)) _TClientAssert( __FILE__, __LINE__)
#endif  // !ASSERT

#ifndef TRACE
#define TRACE(_x_)  if (g_pfnPrintMessage) {\
                        g_pfnPrintMessage(ALIVE_MESSAGE, "Worker:%d ", GetCurrentThreadId());\
                        g_pfnPrintMessage _x_; }
#endif  // !TRACE

#define REG_FORMAT  "smclient_%X_%X"    
                            // Registry key used to start the client
                            // Sort of: smclient_0xProcId_0xThreadId

#ifdef  OS_WIN16
#define SMCLIENT_INI        "\\smclient.ini"    // Our ini file
#define TCLIENT_INI_SECTION "tclient"           // Our section in ini file
#else
#define SMCLIENT_INI        L"\\smclient.ini"
#define TCLIENT_INI_SECTION L"tclient"
#endif

#define CHAT_SEPARATOR      L"<->"              // Separates wait<->repsonse 
                                                // in chat sequence
#define WAIT_STR_DELIMITER  '|'                 // Deleimiter in Wait for 
                                                // multiple strings

#define MAX_WAITING_EVENTS  16
#define MAX_STRING_LENGTH   128
#define FEEDBACK_SIZE       32

#define WAITINPUTIDLE           180000  // 3 min

typedef struct _RCLXDATACHAIN {
    UINT    uiOffset;
    struct  _RCLXDATACHAIN *pNext;
    RCLXDATA RClxData;
} RCLXDATACHAIN, *PRCLXDATACHAIN;

typedef struct _CONNECTINFO {                   // Connection context
    HWND    hClient;                            // Main HWND of the client
                                                // or in RCLX mode
                                                // context structure
    HWND    hContainer;                         // Client's child windows
    HWND    hInput;
    HWND    hOutput;
    HANDLE  hProcess;                           // Client's process handle
    LONG_PTR lProcessId;                        // Client's process Id
                                                // or in RCLX mode, socket
    HANDLE  hThread;                            // Clients first thread
    DWORD   dwThreadId;                         // --"--
                                                // In RCLX mode this contains
                                                // our ThreadID
    DWORD   OwnerThreadId;                      // thread id of the owner of
                                                // this structure
    BOOL    dead;                               // TRUE if the client is dead
    UINT    xRes;                               // client's resolution
    UINT    yRes;
    BOOL    RClxMode;                           // TRUE if this thread is
                                                // in RCLX mode
                                                // the client is on remote
                                                // machine
    HANDLE  evWait4Str;                         // "Wait for something"
                                                // event handle
    HANDLE  aevChatSeq[MAX_WAITING_EVENTS];     // Event on chat sequences
    INT     nChatNum;                           // Number of chat sequences
    WCHAR   Feedback[FEEDBACK_SIZE][MAX_STRING_LENGTH]; 
                                                // Feedback buffer
    INT     nFBsize, nFBend;                    // Pointer within feedback 
                                                // buffer
    CHAR    szDiscReason[MAX_STRING_LENGTH*2];  // Explains disconnect reason
    CHAR    szWait4MultipleStrResult[MAX_STRING_LENGTH];    
                                                // Result of 
                                                // Wait4MultipleStr:string
    INT     nWait4MultipleStrResult;            // Result of 
                                                // Wait4MultipleStr:ID[0-n]
    HGLOBAL ghClipboard;                        // handle to received clipboard
    UINT    uiClipboardFormat;                  // received clipboard format
    UINT    nClipboardSize;                     // recevied clipboard size
    BOOL    bRClxClipboardReceived;             // Flag the clipbrd is received
    CHAR    szClientType[MAX_STRING_LENGTH];    // in RCLX mode identifys the 
                                                // client machine and platform
    UINT    uiSessionId;
    BOOL    bWillCallAgain;                     // TRUE if FEED_WILLCALLAGAIN
                                                // is received in RCLX mode
    PRCLXDATACHAIN pRClxDataChain;              // data receved from RCLX
    PRCLXDATACHAIN pRClxLastDataChain;          // BITMAPs, Virtual Channels

    struct  _CONNECTINFO *pNext;                // Next structure in the queue
} CONNECTINFO, *PCONNECTINFO;

typedef enum {
    WAIT_STRING,        // Wait for unicode string from the client
    WAIT_DISC,          // Wait for disconnected event
    WAIT_CONN,          // Wait for conneted event
    WAIT_MSTRINGS,      // Wait for multiple strings
    WAIT_CLIPBOARD,     // Wait for clipboard data
    WAIT_DATA           // Wait for data block (RCLX mode responces)
}   WAITTYPE; 
                                                // Different event types
                                                // on which we wait

typedef struct _WAIT4STRING {
    HANDLE          evWait;                     // Wait for event
    PCONNECTINFO    pOwner;                     // Context of the owner
    LONG_PTR        lProcessId;                // Clients ID
    WAITTYPE        WaitType;                   // Event type
    DWORD           strsize;                    // String length (WAIT_STRING, 
                                                // WAIT_MSTRING)
    WCHAR           waitstr[MAX_STRING_LENGTH]; // String we are waiting for
    DWORD           respsize;                   // Length of responf
    WCHAR           respstr[MAX_STRING_LENGTH]; // Respond string 
                                                // (in chat sequences)
    struct _WAIT4STRING *pNext;                 // Next in the queue
} WAIT4STRING, *PWAIT4STRING;


#endif /* _TCLIENT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsreg\misc.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  misc.c                                     **
**                                             **
**  Miscellaneous dialog - TSREG               **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <winuser.h>
#include <commctrl.h>
#include <TCHAR.H>
#include <stdlib.h>
#include "tsreg.h"
#include "resource.h"


//HKEY_CURRENT_USER\Control Panel\Desktop\ForegroundLockTimeout. Set it to zero
TCHAR lpszTimoutPath[] = "Control Panel\\Desktop";
TCHAR lpszTimeoutKey[] = "ForegroundLockTimeout";

HWND g_hwndMiscDlg;
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK Miscellaneous(HWND hDlg, UINT nMsg,
        WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnmhdr;
    static HWND hwndComboOrder;
    static HWND hwndRadioShadowEn, hwndRadioShadowDis;
    static HWND hwndRadioDedicatedEn, hwndRadioDedicatedDis;
	static HWND hwndSliderTimeout, hwndEditTimeout;
	static HWND hwndSliderFrame;
    static TCHAR lpszRegPath[MAX_PATH];

    TCHAR lpszBuffer[6];
    TCHAR lpszMBoxTitle[25];
    TCHAR lpszMBoxError[90];
    int i, nPos;

    LPHELPINFO lphi;


    OSVERSIONINFO osvi;
    static BOOL bIsWindows98orLater;
    static BOOL bIsNT5orLater;
    static int nLockValue;



    //
    // get a pointer to the NMHDR struct for apply button
    //
    lpnmhdr = (LPNMHDR) lParam;

    switch (nMsg) {

        case WM_INITDIALOG:


            LoadString (g_hInst, IDS_REG_PATH,
                lpszRegPath, sizeof (lpszRegPath));
            //
            // get handles
            //
            g_hwndMiscDlg = hDlg;

            hwndComboOrder = GetDlgItem(hDlg, IDC_COMBO_ORDER);
            hwndRadioShadowEn = GetDlgItem(hDlg, IDC_SHADOW_ENABLED);
            hwndRadioShadowDis = GetDlgItem(hDlg, IDC_SHADOW_DISABLED);
            hwndRadioDedicatedEn = GetDlgItem(hDlg, IDC_DEDICATED_ENABLED);
            hwndRadioDedicatedDis = GetDlgItem(hDlg, IDC_DEDICATED_DISABLED);



            //
            // lock timeout stuff ------->

			hwndSliderTimeout = GetDlgItem(hDlg, IDC_SLD_TIMEOUT);
			hwndEditTimeout = GetDlgItem(hDlg, IDC_TXT_TIMEOUT);
			hwndSliderFrame = GetDlgItem(hDlg, IDC_FRAME_TIMEOUT);
            //
            // Find out what operating system is is
            // before doing the lock timeout stuff
            //
            osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            GetVersionEx (&osvi);
            bIsWindows98orLater =
               (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
               ( (osvi.dwMajorVersion > 4) ||
               ( (osvi.dwMajorVersion == 4) && (osvi.dwMinorVersion > 0) ) );


            osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            GetVersionEx (&osvi);
            bIsNT5orLater =
               (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
               ( (osvi.dwMajorVersion > 4) ||
               ( (osvi.dwMajorVersion == 5) ) );


            if ((bIsNT5orLater == TRUE) || (bIsWindows98orLater == TRUE)) {

                //
                // set range on slider
                //
                SendMessage(hwndSliderTimeout, TBM_SETRANGE, TRUE,
                        (LPARAM) MAKELONG(1, 6));


				//
				// get value from registry
				//
				nPos = GetKeyVal(lpszTimoutPath, lpszTimeoutKey);
				
                // Use '<=' here - if there is no reg value for
                // ForegroundWindowLockTimeout, the slider control
                // will read -1.
                if (nPos <= 0) {
                    SendMessage(hwndSliderTimeout,
                            TBM_SETPOS, TRUE, 0);
                    _itot(0, lpszBuffer, 10);
                    SetWindowText(hwndEditTimeout, lpszBuffer);
				} else {
                    SendMessage(hwndSliderTimeout, TBM_SETPOS, TRUE,
                    		((nPos / 100000) + 1));
                    _itot(nPos / 100000, lpszBuffer, 10);
                    SetWindowText(hwndEditTimeout, lpszBuffer);
                }

            } else {

            //
            // disable controls if not NT 5 / Win98 or greater
            //
            EnableWindow(hwndSliderTimeout, FALSE);
            EnableWindow(hwndEditTimeout, FALSE);
            EnableWindow(hwndSliderFrame, FALSE);
            }
            //<------------  end lock timeout stuff
            //_____________________________________________________



            //
            // set radio buttons
            //
            RestoreSettings(hDlg, SHADOWINDEX,
                    IDC_SHADOW_DISABLED, IDC_SHADOW_ENABLED,
                    lpszRegPath);

            RestoreSettings(hDlg, DEDICATEDINDEX,
                    IDC_DEDICATED_ENABLED, IDC_DEDICATED_DISABLED,
                    lpszRegPath);

            // ---------------------------------------
            // fill the combo box list with a range of
            // typical values.
            //
            SendMessage(hwndComboOrder, CB_ADDSTRING, 0,
                    (LPARAM) (LPCTSTR) TEXT("0"));

            for (i = 5; i < 55; i+= 5) {
                _itot(i, lpszBuffer, 10);
                SendMessage(hwndComboOrder, CB_ADDSTRING, 0,
                        (LPARAM) (LPCTSTR) lpszBuffer);
            } // ** end for loop

            for (i = 100; i < 1000; i+= 100) {
                _itot(i, lpszBuffer, 10);
                SendMessage(hwndComboOrder, CB_ADDSTRING, 0,
                        (LPARAM) (LPCTSTR) lpszBuffer);
            } // ** end for loop

            for (i = 1000; i < 10000; i+= 1000) {
                _itot(i, lpszBuffer, 10);
                SendMessage(hwndComboOrder, CB_ADDSTRING, 0,
                        (LPARAM) (LPCTSTR) lpszBuffer);
            } // ** end for loop

            for (i = 10000; i < 70000; i+= 10000) {
                _itot(i, lpszBuffer, 10);
                SendMessage(hwndComboOrder, CB_ADDSTRING, 0,
                        (LPARAM) (LPCTSTR) lpszBuffer);
            } // ** end for loop
            //
            // end filling the combo box dropdown list.
            // ----------------------------------------


            //
            // limit combo box to 5 characters
            //
            SendMessage(hwndComboOrder, CB_LIMITTEXT, 5, 0);

            //
            // set edit box from registry
            //
            if (GetRegKey(ORDERINDEX, lpszRegPath) == 1) {
                g_KeyInfo[ORDERINDEX].CurrentKeyValue =
                        (GetRegKeyValue(ORDERINDEX));

            } else {
                g_KeyInfo[ORDERINDEX].CurrentKeyValue =
                        g_KeyInfo[ORDERINDEX].DefaultKeyValue;
            }

            //
            // write to the edit box
            //
            _itot( g_KeyInfo[ORDERINDEX].CurrentKeyValue, lpszBuffer, 10);
            SetWindowText(hwndComboOrder, lpszBuffer);
            break;

        case WM_NOTIFY:

            switch (lpnmhdr->code) {

                case PSN_HELP:
                    lphi = (LPHELPINFO) lParam;

                    WinHelp(lphi->hItemHandle,
                        g_lpszPath, HELP_CONTENTS, lphi->iCtrlId);
                    break;

                case PSN_APPLY:

                    if (g_KeyInfo[ORDERINDEX].CurrentKeyValue ==
                            g_KeyInfo[ORDERINDEX].DefaultKeyValue) {
                        DeleteRegKey(ORDERINDEX, lpszRegPath);
                    } else {
                        SetRegKey(ORDERINDEX, lpszRegPath);
                    }

                    //
                    // save radio button settings
                    //
                    SaveSettings(hDlg, DEDICATEDINDEX, IDC_DEDICATED_ENABLED,
                            IDC_DEDICATED_DISABLED, lpszRegPath);

                    SaveSettings(hDlg, SHADOWINDEX, IDC_SHADOW_DISABLED,
                            IDC_SHADOW_ENABLED, lpszRegPath);

			        //
			        // Write the lock timeout (milliseconds) to
			        // the registry.
			        //
					SetRegKeyVal(lpszTimoutPath,
								lpszTimeoutKey,
						 		(nLockValue - 1) * 100000);
				 		
                    break;
                }
                break;

        case WM_HELP:

            lphi = (LPHELPINFO) lParam;

            WinHelp(lphi->hItemHandle,
                    g_lpszPath, HELP_CONTEXTPOPUP, lphi->iCtrlId);
            break;

        case WM_COMMAND:

            switch  LOWORD (wParam) {

                case IDC_SHADOW_ENABLED:
                    CheckDlgButton(hDlg, IDC_SHADOW_DISABLED, FALSE);
                    break;
                case IDC_SHADOW_DISABLED:
                    CheckDlgButton(hDlg, IDC_SHADOW_ENABLED, FALSE);
                    break;
                case IDC_DEDICATED_ENABLED:
                    CheckDlgButton(hDlg, IDC_DEDICATED_DISABLED, FALSE);
                    break;
                case IDC_DEDICATED_DISABLED:
                    CheckDlgButton(hDlg, IDC_DEDICATED_ENABLED, FALSE);
                    break;
                case IDC_MISC_BUTTON_RESTORE:
                    CheckDlgButton(hDlg, IDC_SHADOW_ENABLED, TRUE);
                    CheckDlgButton(hDlg, IDC_SHADOW_DISABLED, FALSE);
                    CheckDlgButton(hDlg, IDC_DEDICATED_DISABLED, TRUE);
                    CheckDlgButton(hDlg, IDC_DEDICATED_ENABLED, FALSE);
                    _itot( g_KeyInfo[ORDERINDEX].DefaultKeyValue,
                            lpszBuffer, 10);
                    SetWindowText(hwndComboOrder, lpszBuffer);

                    g_KeyInfo[ORDERINDEX].CurrentKeyValue =
                            g_KeyInfo[ORDERINDEX].DefaultKeyValue;

		            //
		            // Reset the position of the slider control
		            // for the foreground lock timeout.
		            //
                    _itot(LOCK_TIMEOUT / 100000, lpszBuffer, 10);
                    SetWindowText(hwndEditTimeout, lpszBuffer);

	                SendMessage(hwndSliderTimeout, TBM_SETPOS, TRUE,
	                		((LOCK_TIMEOUT / 100000) + 1));
	                nLockValue = (LOCK_TIMEOUT / 100000) + 1;
	

                    break;
            }

            switch  HIWORD (wParam) {

                case CBN_SELCHANGE:

                    g_KeyInfo[ORDERINDEX].CurrentKeyValue = (DWORD)
                            SendMessage(hwndComboOrder, CB_GETCURSEL, 0, 0);
                    SendMessage(hwndComboOrder, CB_GETLBTEXT,
                            g_KeyInfo[ORDERINDEX].CurrentKeyValue,
                            (LPARAM) lpszBuffer);
                    g_KeyInfo[ORDERINDEX].CurrentKeyValue = _ttoi(lpszBuffer);
                    break;

                case CBN_EDITUPDATE:

                    GetWindowText(hwndComboOrder, lpszBuffer, 6);
                    g_KeyInfo[ORDERINDEX].CurrentKeyValue = _ttoi(lpszBuffer);

                    break;

                case CBN_KILLFOCUS:
                    GetWindowText(hwndComboOrder, lpszBuffer, 6);
                    g_KeyInfo[ORDERINDEX].CurrentKeyValue = _ttoi(lpszBuffer);

                    if ( (g_KeyInfo[ORDERINDEX].CurrentKeyValue >
                            MAX_ORDER_DRAW_VAL) ) {

                        //
                        // display error if value is off
                        //
                        LoadString (g_hInst, IDS_MISC_TAB, lpszMBoxTitle,
                                sizeof (lpszMBoxTitle));

                        LoadString (g_hInst, IDS_ODRAW_ERROR, lpszMBoxError,
                                sizeof (lpszMBoxError));

                        MessageBox(hDlg, lpszMBoxError,
                                   lpszMBoxTitle,
                                   MB_OK | MB_ICONEXCLAMATION);

                        _itot(g_KeyInfo[ORDERINDEX].DefaultKeyValue,
                                lpszBuffer, 10);
                        SetWindowText(hwndComboOrder, lpszBuffer);
                        g_KeyInfo[ORDERINDEX].CurrentKeyValue =
                                g_KeyInfo[ORDERINDEX].DefaultKeyValue ;
                    }
                    break;
            }
            break;


        case WM_HSCROLL:

            //
            // get the position of the slider control
            //
            nLockValue = (int) SendMessage(hwndSliderTimeout, TBM_GETPOS, 0,0);
                    _itot(nLockValue - 1, lpszBuffer, 10);
                    SetWindowText(hwndEditTimeout, lpszBuffer);
					
			break;


    }
    return (FALSE);
}

// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\smc\tclient\lib\tclient.c ===
/*++
 *  File name:
 *      tclient.c
 *  Contents:
 *      Initialization code. Global feedback thread
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 *
 --*/
#include    <windows.h>
#include    <stdio.h>
#include    <malloc.h>
#include    <process.h>
#include    <string.h>
#include    <stdlib.h>
#include    <ctype.h>
#include    <direct.h>
#include    <winsock.h>

#include    "tclient.h"
#define     PROTOCOLAPI __declspec(dllexport)
#include    "protocol.h"
#include    "queues.h"
#include    "bmpcache.h"
#include    "rclx.h"
#include    "extraexp.h"

/*
 *  Internal functions definitions
 */
BOOL    _RegisterWindow(VOID);
LRESULT CALLBACK _FeedbackWndProc( HWND , UINT, WPARAM, LPARAM);
BOOL    _CreateFeedbackThread(VOID);
VOID    _DestroyFeedbackThread(VOID);
VOID    _CleanStuff(VOID);
VOID    _ReadINIValues(VOID);

/*
 * Global data
 */
HWND                g_hWindow       = NULL; // Window handle for the feedback thread
HINSTANCE           g_hInstance         = NULL; // Dll instance
PWAIT4STRING    g_pWaitQHead    = NULL; // Linked list for waited events
PFNPRINTMESSAGE g_pfnPrintMessage= NULL;// Trace function (from smclient)
PCONNECTINFO    g_pClientQHead  = NULL; // LL of all threads
HANDLE          g_hThread       = NULL; // Feedback Thread handle
UINT            WAIT4STR_TIMEOUT= 600000;   
                                        // Global timeout value. Default:10 mins
                                        // Optional from smclient.ini, 
                                        // tclient section
                                        // timeout=600 (in seconds)
UINT            CONNECT_TIMEOUT = 35000;
                                        // Connect timeout value
                                        // Default is 35 seconds
                                        // This value can be changed from
                                        // smclient.ini [tclient]
                                        // contimeout=XXX seconds

LPCRITICAL_SECTION      g_lpcsGuardWaitQueue = NULL;
                                        // Guards the access to all 
                                        // global variables

// Some strings we are expecting and response actions
// Those are used in SCConnect, _Logon and SCStart
WCHAR g_strStartRun[MAX_STRING_LENGTH];        // Indicates that start menu is up
WCHAR g_strStartRun_Act[MAX_STRING_LENGTH];    // Chooses "Run..." from start menu
WCHAR g_strRunBox[MAX_STRING_LENGTH];          // Indication for Run... box
WCHAR g_strWinlogon[MAX_STRING_LENGTH];        // Indication that winlogon is up
WCHAR g_strWinlogon_Act[MAX_STRING_LENGTH];    // Action when winlogon appears (chooses username)
WCHAR g_strPriorWinlogon[MAX_STRING_LENGTH];   // Idication before winlogon (for example
                                        // if Options >> appears, i.e domain
                                        // box is hidden
WCHAR g_strPriorWinlogon_Act[MAX_STRING_LENGTH]; // Shows the domain box (Alt+O)
WCHAR g_strNTSecurity[MAX_STRING_LENGTH];      // Indication of NT Security box
WCHAR g_strNTSecurity_Act[MAX_STRING_LENGTH];  // Action on that box (logoff)
WCHAR g_strSureLogoff[MAX_STRING_LENGTH];      // Inidcation of "Are you sure" box
WCHAR g_strSureLogoffAct[MAX_STRING_LENGTH];   // Action on "Are you sure"
WCHAR g_strStartLogoff[MAX_STRING_LENGTH];     // How to invode Windows Security dialog from the start menu
WCHAR g_strLogonErrorMessage[MAX_STRING_LENGTH];
                                               // Caption of an error box 
                                               // which appears while logging in
                                               // responce is <Enter>
                                        // while loging off
WCHAR g_strLogonDisabled[MAX_STRING_LENGTH];
                                               // Caption of the box when 
                                               // logon is disabled

CHAR  g_strClientCaption[MAX_STRING_LENGTH];
CHAR  g_strDisconnectDialogBox[MAX_STRING_LENGTH];
CHAR  g_strYesNoShutdown[MAX_STRING_LENGTH];
CHAR  g_strClientImg[MAX_STRING_LENGTH];

// Low Speed option
// Cache Bitmaps on disc option
// by default, client will not run
// in full screen
INT g_ConnectionFlags = TSFLAG_COMPRESSION|TSFLAG_BITMAPCACHE;

/*++
 *  Function:   
 *      InitDone
 *
 *  Description:    
 *      Initialize/delete global data. Create/destroy
 *      feedback thread
 *
 *  Arguments:
 *      hDllInst - Instance to the DLL
 *      bInit    - TRUE if initialize
 *
 *  Return value:
 *      TRUE if succeeds
 *
 --*/
int InitDone(HINSTANCE hDllInst, int bInit)
{
    int rv = TRUE;

    if (bInit)
    {
        CHAR szMyLibName[_MAX_PATH];

        g_lpcsGuardWaitQueue = malloc(sizeof(*g_lpcsGuardWaitQueue));
        if (!g_lpcsGuardWaitQueue)
        {
            rv = FALSE;
            goto exitpt;
        }

        // Overreference the library
        // The reason for that is beacuse an internal thread is created.
        // When the library trys to unload it can't kill that thread
        // and wait for its handle to get signaled, because
        // the thread itself wants to go to DllEntry and this
        // causes a deadlock. The best solution is to overreference the
        // handle so the library is unload at the end of the process
        if (!GetModuleFileName(hDllInst, szMyLibName, sizeof(szMyLibName)))
        {
            TRACE((ERROR_MESSAGE, "Can't overref the dll. Exit.\n"));
            free(g_lpcsGuardWaitQueue);
            rv = FALSE;
            goto exitpt;
        }

        if (!LoadLibrary(szMyLibName))
        {
            TRACE((ERROR_MESSAGE, "Can't overref the dll. Exit.\n"));
            free(g_lpcsGuardWaitQueue);
            rv = FALSE;
            goto exitpt;
        }

        g_hInstance = hDllInst;
        InitializeCriticalSection(g_lpcsGuardWaitQueue);
        InitCache();
        _ReadINIValues();
        if (_RegisterWindow())              // If failed to register the window,
            _CreateFeedbackThread();        // means the feedback thread will 
                                            // not work
    } else
    {
        if (g_pWaitQHead || g_pClientQHead)
        {
            TRACE((ERROR_MESSAGE, 
                   "The Library unload is unclean. Will try to fix this\n"));
            _CleanStuff();
        }
        _DestroyFeedbackThread();
        DeleteCache();
        if (g_lpcsGuardWaitQueue)
        {
            DeleteCriticalSection(g_lpcsGuardWaitQueue);
            free(g_lpcsGuardWaitQueue);
        }
        g_lpcsGuardWaitQueue = NULL;
        g_hInstance = NULL;
        g_pfnPrintMessage = NULL;
    }
exitpt:
    return rv;
}

/*
 *  Used by perl script to break into the kernel debugger
 */
void MyBreak(void)
{
    TRACE((INFO_MESSAGE, "Break is called\n"));
    DebugBreak();
}

VOID
_ConvertAnsiToUnicode( LPWSTR wszDst, LPWSTR wszSrc )
{
#define _TOHEX(_d_) ((_d_ <= '9' && _d_ >= '0')?_d_ - '0':       \
                     (_d_ <= 'f' && _d_ >= 'a')?_d_ - 'a' + 10:  \
                     (_d_ <= 'F' && _d_ >= 'F')?_d_ - 'A' + 10:0)

    while( wszSrc[0] && wszSrc[1] && wszSrc[2] && wszSrc[3] )
    {
        *wszDst = (_TOHEX(wszSrc[0]) << 4) + _TOHEX(wszSrc[1]) +
                  (((_TOHEX(wszSrc[2]) << 4) + _TOHEX(wszSrc[3])) << 8); 
        wszDst ++;
        wszSrc += 4;
    }
    *wszDst = 0;
#undef  _TOHEX
}

/*
 *
 *  Wrappers for GetPrivateProfileW, on Win95 there's no UNICODE veriosn
 *  of this function
 *
 */
DWORD
_WrpGetPrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD   nSize,
    LPCWSTR lpFileName)
{
    DWORD   rv = 0;
    CHAR    szAppName[MAX_STRING_LENGTH];
    CHAR    szKeyName[MAX_STRING_LENGTH];
    CHAR    szDefault[MAX_STRING_LENGTH];
    CHAR    szReturnedString[MAX_STRING_LENGTH];
    CHAR    szFileName[MAX_STRING_LENGTH];

    rv = GetPrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpDefault,
        lpReturnedString,
        nSize,
        lpFileName);

    if (rv)
        goto exitpt;

// Call the ANSI version
    _snprintf(szAppName, MAX_STRING_LENGTH, "%S", lpAppName);
    _snprintf(szKeyName, MAX_STRING_LENGTH, "%S", lpKeyName);
    _snprintf(szFileName, MAX_STRING_LENGTH, "%S", lpFileName);
    _snprintf(szDefault, MAX_STRING_LENGTH, "%S", lpDefault);

    rv = GetPrivateProfileString(
            szAppName,
            szKeyName,
            szDefault,
            szReturnedString,
            sizeof(szReturnedString),
            szFileName);

    _snwprintf(lpReturnedString, nSize, L"%S", szReturnedString);

exitpt:
    if ( L'\\' == lpReturnedString[0] &&
         L'U'  == towupper(lpReturnedString[1]))
        _ConvertAnsiToUnicode( lpReturnedString, lpReturnedString + 2 );

    return rv;
}

UINT
_WrpGetPrivateProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT   nDefault,
    LPCWSTR lpFileName)
{
    UINT    rv = (UINT)-1;
    CHAR    szAppName[MAX_STRING_LENGTH];
    CHAR    szKeyName[MAX_STRING_LENGTH];
    CHAR    szFileName[MAX_STRING_LENGTH];

    rv = GetPrivateProfileIntW(
        lpAppName,
        lpKeyName,
        nDefault,
        lpFileName);

    if (rv != (UINT)-1 && rv)
        goto exitpt;

// Call the ANSI version
    _snprintf(szAppName, MAX_STRING_LENGTH, "%S", lpAppName);
    _snprintf(szKeyName, MAX_STRING_LENGTH, "%S", lpKeyName);
    _snprintf(szFileName, MAX_STRING_LENGTH, "%S", lpFileName);

    rv = GetPrivateProfileInt(
            szAppName,
            szKeyName,
            nDefault,
            szFileName);

exitpt:
    return rv;
}


/*++
 *  Function:
 *      _ReadINIValues
 *
 *  Description:
 *      Reads smclient.ini, section [tclient], variable "timeout"
 *      This is a global timeout for Wait4Str etc
 *      Also read some other values
 *  Arguments:
 *      none
 *  Return value:
 *      none
 *
 --*/
VOID _ReadINIValues(VOID)
{
    UINT nNew;
    WCHAR szIniFileName[_MAX_PATH];
    WCHAR szBuff[ 4 * MAX_STRING_LENGTH];
    WCHAR szBuffDef[MAX_STRING_LENGTH];
    BOOL  bFlag;

    // Construct INI path
    *szIniFileName = 0;
    if (!_wgetcwd (
        szIniFileName,
        (int)(sizeof(szIniFileName)/sizeof(WCHAR) - wcslen(SMCLIENT_INI) - 1))
    )
    {
        TRACE((ERROR_MESSAGE, "Current directory length too long.\n"));
    }
    wcscat(szIniFileName, SMCLIENT_INI);

    // Get the timeout value
    nNew = _WrpGetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"timeout",
            600,
            szIniFileName);

    if (nNew)
    {
        WAIT4STR_TIMEOUT = nNew * 1000;
        TRACE((INFO_MESSAGE, "New timeout: %d seconds\n", nNew));
    }

    nNew = _WrpGetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"contimeout",
            35,
            szIniFileName);

    if (nNew)
    {
        CONNECT_TIMEOUT = nNew * 1000;
        TRACE((INFO_MESSAGE, "New timeout: %d seconds\n", nNew));
    }

    g_ConnectionFlags = 0;
    bFlag = 
        _WrpGetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"LowSpeed",
            0,
            szIniFileName);
    if (bFlag)
        g_ConnectionFlags |=TSFLAG_COMPRESSION;

    bFlag =
        _WrpGetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"PersistentCache",
            0,
            szIniFileName);
    if (bFlag)
        g_ConnectionFlags |=TSFLAG_BITMAPCACHE;

    bFlag = 
        _WrpGetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"FullScreen",
            0,
            szIniFileName);
    if (bFlag)
        g_ConnectionFlags |=TSFLAG_FULLSCREEN;

    // read the strings
    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"StartRun",
           RUN_MENU,
           g_strStartRun,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"StartLogoff",
           START_LOGOFF,
           g_strStartLogoff,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"StartRunAct",
           RUN_ACT,
           g_strStartRun_Act,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"RunBox",
           RUN_BOX,
           g_strRunBox,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"WinLogon",
           WINLOGON_USERNAME,
           g_strWinlogon,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"WinLogonAct",
           WINLOGON_ACT,
           g_strWinlogon_Act,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"PriorWinLogon",
           PRIOR_WINLOGON,
           g_strPriorWinlogon,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"PriorWinLogonAct",
           PRIOR_WINLOGON_ACT,
           g_strPriorWinlogon_Act,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"NTSecurity",
           WINDOWS_NT_SECURITY,
           g_strNTSecurity,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"NTSecurityAct",
           WINDOWS_NT_SECURITY_ACT,
           g_strNTSecurity_Act,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"SureLogoff",
           ARE_YOU_SURE,
           g_strSureLogoff,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"SureLogoffAct",
           SURE_LOGOFF_ACT,
           g_strSureLogoffAct,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"LogonErrorMessage",
           LOGON_ERROR_MESSAGE,
           g_strLogonErrorMessage,
           MAX_STRING_LENGTH,
           szIniFileName);

    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"LogonDisabled",
           LOGON_DISABLED_MESSAGE,
           g_strLogonDisabled,
           MAX_STRING_LENGTH,
           szIniFileName);

    _snwprintf(szBuffDef, sizeof(szBuffDef), L"%S", CLIENT_CAPTION);
    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"UIClientCaption",
           szBuffDef,
           szBuff,
           MAX_STRING_LENGTH,
           szIniFileName);
    _snprintf(g_strClientCaption, MAX_STRING_LENGTH, "%S", szBuff);

    _snwprintf(szBuffDef, sizeof(szBuffDef), L"%S", DISCONNECT_DIALOG_BOX);
    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"UIDisconnectDialogBox",
           szBuffDef,
           szBuff,
           MAX_STRING_LENGTH,
           szIniFileName);
    _snprintf(g_strDisconnectDialogBox, MAX_STRING_LENGTH, "%S", szBuff);

    _snwprintf(szBuffDef, sizeof(szBuffDef), L"%S", YES_NO_SHUTDOWN);
    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"UIYesNoDisconnect",
           szBuffDef,
           szBuff,
           MAX_STRING_LENGTH,
           szIniFileName);
    _snprintf(g_strYesNoShutdown, MAX_STRING_LENGTH, "%S", szBuff);

    _snwprintf(szBuffDef, sizeof(szBuffDef), L"%S", CLIENT_EXE);
    _WrpGetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"ClientImage",
           szBuffDef,
           szBuff,
           MAX_STRING_LENGTH,
           szIniFileName);
    _snprintf(g_strClientImg, MAX_STRING_LENGTH, "%S", szBuff);
}

/*++
 *  Function:
 *      _FeedbackWndProc
 *  Description:
 *      Window proc wich dispatches messages containing feedback
 *      The messages are usualy sent by RDP clients
 *
 --*/
LRESULT CALLBACK _FeedbackWndProc( HWND hwnd,
                                   UINT uiMessage,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    HANDLE hMapF = NULL;

    switch (uiMessage)
    {
    case WM_FB_TEXTOUT: 
        _TextOutReceived((DWORD)wParam, (HANDLE)lParam);
        break;
    case WM_FB_GLYPHOUT:
        _GlyphReceived((DWORD)wParam, (HANDLE)lParam);
        break;
    case WM_FB_DISCONNECT:
        _SetClientDead(lParam);
        _CheckForWorkerWaitingDisconnect(lParam);
        _CancelWaitingWorker(lParam);
        break;
    case WM_FB_CONNECT:
        _CheckForWorkerWaitingConnect((HWND)wParam, lParam);
        break;
    case WM_FB_LOGON:
        TRACE((INFO_MESSAGE, "LOGON event, session ID=%d\n",
               wParam));
        _SetSessionID(lParam, (UINT)wParam);
        break;
        break;
    case WM_FB_ACCEPTME:
        return (_CheckIsAcceptable(lParam, FALSE) != NULL);
    case WM_WSOCK:          // Windows socket messages
        RClx_DispatchWSockEvent((SOCKET)wParam, lParam);
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd, uiMessage, wParam, lParam);
    }

    return 0;
}

/*++
 *  Function:
 *      _RegisterWindow
 *  Description:
 *      Resgisters window class for the feedback dispatcher
 *  Arguments:
 *      none
 *  Return value:
 *      TRUE on success
 *
 --*/
BOOL _RegisterWindow(VOID)
{
    WNDCLASS    wc;
    BOOL        rv;
    DWORD       dwLastErr;

    memset(&wc, 0, sizeof(wc));

    wc.lpfnWndProc      = _FeedbackWndProc;
    wc.hInstance        = g_hInstance;
    wc.lpszClassName    = _TSTNAMEOFCLAS;

    if (!RegisterClass (&wc) && 
        (dwLastErr = GetLastError()) && 
        dwLastErr != ERROR_CLASS_ALREADY_EXISTS)
    {
        TRACE((ERROR_MESSAGE, 
              "Can't register class. GetLastError=%d\n", 
              GetLastError()));
        goto exitpt;
    }

    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      _GoFeedback
 *  Description:
 *      Main function for the feedback thread. The thread is created for the
 *      lifetime of the DLL
 *  Arguments:
 *      lpParam is unused
 *  Return value:
 *      Thread exit code
 --*/
DWORD WINAPI _GoFeedback(LPVOID lpParam)
{
    MSG         msg;

    g_hWindow = CreateWindow(
                       _TSTNAMEOFCLAS,
                       NULL,         // Window name
                       0,            // dwStyle
                       0,            // x
                       0,            // y
                       0,            // nWidth
                       0,            // nHeight
                       NULL,         // hWndParent
                       NULL,         // hMenu
                       g_hInstance,
                       NULL);        // lpParam

    if (!g_hWindow)
    {
        TRACE((ERROR_MESSAGE, "No feedback window handle"));
        goto exitpt;
    } else {

        if (!RClx_Init())
            TRACE((ERROR_MESSAGE, "Can't initialize RCLX\n"));

        while (GetMessage (&msg, NULL, 0, 0) && msg.message != WM_FB_END)
        {
            DispatchMessage (&msg);
        }

        RClx_Done();
    }

    TRACE((INFO_MESSAGE, "Window/Thread destroyed\n"));
    FreeLibraryAndExitThread(g_hInstance, 0); 
exitpt:
    return 1;
    
}

/*++
 *  Function:
 *      _SetClientRegistry
 *  Description:
 *      Sets the registry prior running RDP client
 *      The format of the key is: smclient_PID_TID
 *      PID is the process ID and TID is the thread ID
 *      This key is deleated after the client disconnects
 *  Arguments:
 *      lpszServerName  - server to which the client will connect
 *      xRes, yRes      - clients resolution
 *      bLowSpeed       - low speed (compression) option
 *      bCacheBitmaps   - cache the bitmaps to the disc option
 *      bFullScreen     - the client will be in full screen mode
 *  Called by:
 *      SCConnect
 --*/
VOID 
_SetClientRegistry(
    LPCWSTR lpszServerName, 
    LPCWSTR lpszShell,
    INT xRes, 
    INT yRes,
    INT ConnectionFlags)
{
    const   CHAR   *pData;
    CHAR    szServer[MAX_STRING_LENGTH];
    register int i;
    LONG    sysrc;
    HKEY    key;
    DWORD   disposition;
    DWORD   dataSize;
    DWORD   ResId;
    CHAR    lpszRegistryEntry[4*MAX_STRING_LENGTH];
    RECT    rcDesktop = {0, 0, 0, 0};
    INT     desktopX, desktopY;

    _snprintf(lpszRegistryEntry, sizeof(lpszRegistryEntry),
              "%s\\" REG_FORMAT, 
               REG_BASE, GetCurrentProcessId(), GetCurrentThreadId());

    // Get desktop size
    GetWindowRect(GetDesktopWindow(), &rcDesktop);
    desktopX = rcDesktop.right;
    desktopY = rcDesktop.bottom;

    // Adjust the resolution
    if (desktopX < xRes || desktopY < yRes)
    {
        xRes = desktopX;
        yRes = desktopY;
    }

    // Convert lpszServerName to proper format

    for (i=0; i < sizeof(szServer)/sizeof(TCHAR)-1 && lpszServerName[i]; i++)
        szServer[i] = (CHAR)lpszServerName[i];

    szServer[i] = 0;
    pData = szServer;
    dataSize = (strlen(pData)+1);

    // Before starting ducati client set registry with server name

    sysrc = RegCreateKeyEx(HKEY_CURRENT_USER,
                           lpszRegistryEntry,
                           0,                   /* reserved             */
                           NULL,                /* class                */
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,                /* security attributes  */
                           &key,
                           &disposition);

    if (sysrc != ERROR_SUCCESS) 
    {
        TRACE((WARNING_MESSAGE, "RegCreateKeyEx failed, sysrc = %d\n", sysrc));
        goto exitpt;
    }

    sysrc = RegSetValueEx(key,
                TEXT("MRU0"),
                0,      // reserved
                REG_SZ,
                (LPBYTE)pData,
                dataSize);

    if (sysrc != ERROR_SUCCESS) 
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    // Set alternative shell (if specified
    if (lpszShell)
    {
        sysrc = RegSetValueEx(key,
                TEXT("Alternate Shell"),
                0,      // reserved
                REG_BINARY,
                (LPBYTE)lpszShell,
                wcslen(lpszShell) * sizeof(*lpszShell));

        if (sysrc != ERROR_SUCCESS)
        {
            TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
        }
    }

    // Set the resolution
         if (xRes >= 1600 && yRes >= 1200)  ResId = 4;
    else if (xRes >= 1280 && yRes >= 1024)  ResId = 3;
    else if (xRes >= 1024 && yRes >= 768)   ResId = 2;
    else if (xRes >= 800  && yRes >= 600)   ResId = 1;
    else                                    ResId = 0; // 640x480

    sysrc = RegSetValueEx(key,
                "Desktop Size ID",
                0,
                REG_DWORD,
                (LPBYTE)&ResId,
                sizeof(ResId));

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    ResId = 1;
    sysrc = RegSetValueEx(key,
                "Auto Connect",
                0,      // reserved
                REG_DWORD,
                (LPBYTE)&ResId,
                sizeof(ResId));

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    ResId = (ConnectionFlags & TSFLAG_BITMAPCACHE)?1:0;
    sysrc = RegSetValueEx(key,
                "BitmapCachePersistEnable",
                0,      // reserved
                REG_DWORD,
                (LPBYTE)&ResId,
                sizeof(ResId));

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    ResId = (ConnectionFlags & TSFLAG_COMPRESSION)?1:0;
    sysrc = RegSetValueEx(key,
                "Compression",
                0,      // reserved
                REG_DWORD,
                (LPBYTE)&ResId,
                sizeof(ResId));

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    if (ConnectionFlags & TSFLAG_FULLSCREEN)
    {
        ResId = 2;
        sysrc = RegSetValueEx(key,
                    "Screen Mode ID",
                    0,      // reserved
                    REG_DWORD,
                    (LPBYTE)&ResId,
                    sizeof(ResId));

        if (sysrc != ERROR_SUCCESS)
        {
            TRACE((WARNING_MESSAGE, 
                   "RegSetValue failed, status = %d\n", sysrc));
        }
    }

    RegCloseKey(key);

    ResId = 1;

    sysrc = RegCreateKeyEx(HKEY_CURRENT_USER,
                           REG_BASE,
                           0,                   /* reserved             */
                           NULL,                /* class                */
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,                /* security attributes  */
                           &key,
                           &disposition);

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegCreateKeyEx failed, sysrc = %d\n", sysrc));
        goto exitpt;
    }

    sysrc = RegSetValueEx(key,
                    ALLOW_BACKGROUND_INPUT,
                    0,
                    REG_DWORD,
                    (LPBYTE)&ResId,
                    sizeof(ResId));

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    RegCloseKey(key);

exitpt:
    ;
}

/*++
 *  Function:
 *      _DeleteClientRegistry
 *  Description:
 *      Deletes the key set by _SetClientRegistry
 *  Called by:
 *      SCDisconnect
 --*/
VOID _DeleteClientRegistry(PCONNECTINFO pCI)
{
    CHAR    lpszRegistryEntry[4*MAX_STRING_LENGTH];
    LONG    sysrc;

    _snprintf(lpszRegistryEntry, sizeof(lpszRegistryEntry),
             "%s\\" REG_FORMAT,
              REG_BASE, GetCurrentProcessId(), pCI->OwnerThreadId);

    sysrc = RegDeleteKey(HKEY_CURRENT_USER, lpszRegistryEntry);
    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegDeleteKey failed, status = %d\n", sysrc));
    }
}

/*++
 *  Function:
 *      _CreateFeedbackThread
 *  Description:
 *      Creates the feedback thread
 *  Called by: 
 *      InitDone
 --*/
BOOL _CreateFeedbackThread(VOID)
{
    BOOL rv = TRUE;
    // Register feedback window class
    WNDCLASS    wc;
    DWORD dwThreadId, dwLastErr;

    g_hThread = (HANDLE)
            _beginthreadex
                (NULL, 
                 0, 
                 (unsigned (__stdcall *)(void*))_GoFeedback, 
                 NULL, 
                 0, 
                 &dwThreadId);

    if (!g_hThread) {
        TRACE((ERROR_MESSAGE, "Couldn't create thread\n"));
        rv = FALSE;
    }
    return rv;
}

/*++
 *  Function:
 *      _DestroyFeedbackThread
 *  Description:
 *      Destroys the thread created by _CreateFeedbackThread
 *  Called by:  
 *      InitDone
 --*/
VOID _DestroyFeedbackThread(VOID)
{

    if (g_hThread)
    {
        DWORD dwWait;
        CHAR  szMyLibName[_MAX_PATH];

        // Closing feedback thread

        PostMessage(g_hWindow, WM_FB_END, 0, 0);
        TRACE((INFO_MESSAGE, "Closing DLL thread\n"));

        // Dedstroy the window
        DestroyWindow(g_hWindow);

        // CloseHandle(g_hThread);
        g_hThread = NULL;
    }
}

/*++
 *  Function:
 *      _CleanStuff
 *  Description:
 *      Cleans the global queues. Closes any resources
 *  Called by:
 *      InitDone
 --*/
VOID _CleanStuff(VOID)
{

    // Thread safe, bacause is executed from DllEntry

    while (g_pClientQHead)
    {
        TRACE((WARNING_MESSAGE, "Cleaning connection info: 0x%x\n", 
               g_pClientQHead));
        SCDisconnect(g_pClientQHead);
    }
#if 0
    if (g_pClientQHead)
    {
        PCONNECTINFO pNext, pIter = g_pClientQHead;
        while (pIter)
        {
            int nEv;
            DWORD wres;

            TRACE((WARNING_MESSAGE, "Cleaning connection info: 0x%x\n", pIter));
            // Clear Events
            if (pIter->evWait4Str)
            {
                CloseHandle(pIter->evWait4Str);
                pIter->evWait4Str = NULL;
            }

            for (nEv = 0; nEv < pIter->nChatNum; nEv ++)
                CloseHandle(pIter->aevChatSeq[nEv]);

            pIter->nChatNum = 0;

            // Clear Processes
            do {
                SendMessage(pIter->hClient, WM_CLOSE, 0, 0);
            } while((wres = WaitForSingleObject(pIter->hProcess, WAIT4STR_TIMEOUT/4) == WAIT_TIMEOUT));

            if (wres == WAIT_TIMEOUT)
            {
                TRACE((WARNING_MESSAGE, 
                       "Can't close process. WaitForSingleObject timeouts\n"));
                TRACE((WARNING_MESSAGE, 
                      "Process #%d will be killed\n", 
                      pIter->dwProcessId ));
                if (!TerminateProcess(pIter->hProcess, 1))
                {
                    TRACE((WARNING_MESSAGE, 
                           "Can't kill process #%d. GetLastError=%d\n", 
                            pIter->dwProcessId, GetLastError()));
                }
            }

            TRACE((WARNING_MESSAGE, "Closing process\n"));

            if (pIter->hProcess)
                CloseHandle(pIter->hProcess);
            if (pIter->hThread)
                CloseHandle(pIter->hThread);

            pIter->hProcess = pIter->hThread = NULL;

            // Free the structures
            pNext = pIter->pNext;
            free(pNext);
            pIter = pNext;
        }
    }

#endif // 0
}

VOID _TClientAssert( LPCTSTR filename, INT line)
{
    TRACE(( ERROR_MESSAGE, "ASSERT %s line: %d\n", filename, line));
    DebugBreak(); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsreg\keyinfo.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  keyinfo.c                                  **
**                                             **
**  registry keys - TSREG                      **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <TCHAR.H>
#include "tsreg.h"

///////////////////////////////////////////////////////////////////////////////

KEY_INFO g_KeyInfo[KEYCOUNT] = {

    { TEXT("Shadow Bitmap Enabled"), 0x0, 0x0 },            //  0
    { TEXT("Dedicated Terminal"), 0x1, 0x1 },               //  1
    { TEXT("BitmapCacheSize"), 0x5dc, 0x5dc },              //  2

    //
    // g_KeyInfo - 3 through 12
    //
    { TEXT("GlyphCacheCell1Size"), 0x4, 0x4 },              //  3
    { TEXT("GlyphCacheCell2Size"), 0x4, 0x4 },              //  4
    { TEXT("GlyphCacheCell3Size"), 0x8, 0x8 },              //  5
    { TEXT("GlyphCacheCell4Size"), 0x8, 0x8 },              //  6
    { TEXT("GlyphCacheCell5Size"), 0x10, 0x10 },            //  7
    { TEXT("GlyphCacheCell6Size"), 0x20, 0x20 },            //  8
    { TEXT("GlyphCacheCell7Size"), 0x40, 0x40 },            //  9
    { TEXT("GlyphCacheCell8Size"), 0x80, 0x80 },            // 10
    { TEXT("GlyphCacheCell9Size"), 0x100, 0x100 },          // 11
    { TEXT("GlyphCacheCell10Size"), 0x200, 0x200 },         // 12
    //
    // g_KeyInfo - 13 through 17
    //
    { TEXT("BitmapCache1Prop"), 0xA, 0xA },                 // 13
    { TEXT("BitmapCache2Prop"), 0x14, 0x14 },               // 14
    { TEXT("BitmapCache3Prop"), 0x46, 0x46 },               // 15
    { TEXT("BitmapCache4Prop"), 0x0, 0x0 },                 // 16
    { TEXT("BitmapCache5Prop"), 0x0, 0x0 },                 // 17
    //
    // g_KeyInfo - 18 through 20
    //
    { TEXT("TextFragmentCellSize"), 0x100, 0x100 },         // 18
    { TEXT("GlyphSupportLevel"), 0x3, 0x3 },                // 19
    { TEXT("Order Draw Threshold"), 0x19, 0x19 },           // 20

    // begin new registry keys 21 - 31 (32 total keys)
    //////////////////////////
    { TEXT("BitmapCacheNumCellCaches"), 0x3, 0x3 },         // 21

    { TEXT("BitmapCache1Persistence"), 0x0, 0x0 },          // 22
    { TEXT("BitmapCache2Persistence"), 0x0, 0x0 },          // 23
    { TEXT("BitmapCache3Persistence"), 0x0, 0x0 },          // 24
    { TEXT("BitmapCache4Persistence"), 0x0, 0x0 },          // 25
    { TEXT("BitmapCache5Persistence"), 0x0, 0x0 }           // 26


};


// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsreg\g_cache.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  g_cache.c                                  **
**                                             **
**  Glyph cache dialog - TSREG                 **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <commctrl.h>
#include <TCHAR.H>
#include <stdlib.h>
#include "tsreg.h"
#include "resource.h"

HWND g_hwndGlyphCacheDlg;

///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK GlyphCache(HWND hDlg, UINT nMsg,
        WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnmhdr;
    static UINT nGlyphBuffer;
    static HWND hwndSlider[NUMBER_OF_SLIDERS];
    static HWND hwndSliderEditBuddy[NUMBER_OF_SLIDERS];
    static HWND hwndComboTextFrag;
    static TCHAR lpszRegPath[MAX_PATH];
    TCHAR lpszBuffer[5];
    HWND hwndCtl;
    int i, nKeyVal;
    int nPos;
    LPHELPINFO lphi;

    //
    // get a pointer to the NMHDR struct for apply button
    //
    lpnmhdr = ((LPNMHDR)lParam);

    switch (nMsg) {

        case WM_VSCROLL:

            hwndCtl = (HWND) (lParam);
            i = (int)GetWindowLongPtr(hwndCtl, GWLP_USERDATA);
            DisplayControlValue(hwndSlider, hwndSliderEditBuddy, i);
            break;

        case WM_INITDIALOG:

            g_hwndGlyphCacheDlg = hDlg;

            LoadString (g_hInst, IDS_REG_PATH,
                lpszRegPath, sizeof (lpszRegPath));

            hwndComboTextFrag = GetDlgItem(hDlg, IDC_CBO_TXT_FRAG);
            InitMiscControls( hDlg, hwndComboTextFrag);

            for (i = 0; i < NUMBER_OF_SLIDERS; i++) {

                //
                // get handles to slider contrls and static edit boxes
                //
                hwndSlider[i] = GetDlgItem(hDlg, (IDC_SLIDER1 + i));
                hwndSliderEditBuddy[i] = GetDlgItem(hDlg, (IDC_STATIC1 + i));

                //
                // save the index of the control
                //
                SetWindowLongPtr(hwndSlider[i], GWLP_USERDATA, i);

                SendMessage(hwndSlider[i], TBM_SETRANGE, FALSE,
                        (LPARAM) MAKELONG(1, 8));

                //
                // get value from registry and check it
                //
                nGlyphBuffer = GetRegKeyValue(i + GLYPHCACHEBASE);
                if ( (nGlyphBuffer) < MIN_GLYPH_CACHE_SIZE ||
                    (nGlyphBuffer > MAX_GLYPH_CACHE_SIZE) ) {

                    nGlyphBuffer =
                            g_KeyInfo[i + GLYPHCACHEBASE].DefaultKeyValue;
                }
                //
                // set the current key value
                //
                g_KeyInfo[i + GLYPHCACHEBASE].CurrentKeyValue =
                        nGlyphBuffer;
                _itot( nGlyphBuffer, (lpszBuffer), 10);
                //
                // display the value in the static edit control
                //
                SetWindowText(hwndSliderEditBuddy[i], lpszBuffer);
                //
                // position the thumb on the slider control
                //
                nGlyphBuffer = g_KeyInfo[i + GLYPHCACHEBASE].CurrentKeyValue;

#ifdef _X86_    // EXECUTE ASSEMBLER CODE ONLY IF X86 PROCESSOR
                // BSF: Bit Scan Forward -
                // Scans the value contained in the EAX regiseter
                // for the first significant (1) bit.
                // This function returns the location of the first
                // significant bit.  The function is used in this
                // application as a base 2 logarythm.  The location
                // of the bit is determined, stored in the nPos
                // variable, and nPos is used to set the slider
                // control. ie. If the register value is 4, nPos
                // is set to 2 (00000100).  10 minus 2 (position 8
                // on the slider control) represents the value 4.
                __asm
                {
                    BSF  EAX, nGlyphBuffer
                    MOV  nPos, EAX
                }
                nPos = 10 - nPos;
                SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, (LPARAM)nPos);

#else

               switch (nGlyphBuffer) {
                   case 4:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 8);
                       break;
                   case 8:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 7);
                       break;
                   case 16:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 6);
                       break;
                   case 32:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 5);
                       break;
                   case 64:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 4);
                       break;
                   case 128:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 3);
                       break;
                   case 256:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 2);
                       break;
                   case 512:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 1);
                       break;
               }
#endif


            } // end for loop
            break;


       case WM_NOTIFY:

            //
            // save settings on OK button
            //
            switch (lpnmhdr->code) {

                case PSN_HELP:
                    lphi = (LPHELPINFO) lParam;

                    WinHelp(lphi->hItemHandle,
                        g_lpszPath, HELP_CONTENTS, lphi->iCtrlId);
                    break;

                case PSN_APPLY:


                    for (i = 0; i < NUMBER_OF_SLIDERS; i++) {
                        if ( (g_KeyInfo[i + GLYPHCACHEBASE].CurrentKeyValue ==
                                g_KeyInfo[i+GLYPHCACHEBASE].DefaultKeyValue) ||
                                (g_KeyInfo[i+GLYPHCACHEBASE].CurrentKeyValue ==
                                 0)) {
                            DeleteRegKey(i + GLYPHCACHEBASE, lpszRegPath);
                        } else {
                            SetRegKey(i + GLYPHCACHEBASE, lpszRegPath);
                        }
                    } // ** end for loop

                    if (g_KeyInfo[GLYPHINDEX].CurrentKeyValue ==
                            g_KeyInfo[GLYPHINDEX].DefaultKeyValue) {
                        DeleteRegKey(GLYPHINDEX, lpszRegPath);
                    } else {
                        SetRegKey(GLYPHINDEX, lpszRegPath);
                    }

                    if (g_KeyInfo[TEXTFRAGINDEX].CurrentKeyValue ==
                            g_KeyInfo[TEXTFRAGINDEX].DefaultKeyValue) {
                        DeleteRegKey(TEXTFRAGINDEX, lpszRegPath);
                    } else {
                        SetRegKey(TEXTFRAGINDEX, lpszRegPath);
                    }
                }
                break;

        case WM_HELP:

            lphi = (LPHELPINFO) lParam;

            WinHelp(lphi->hItemHandle,
                    g_lpszPath, HELP_CONTEXTPOPUP, lphi->iCtrlId);
            break;


        case WM_COMMAND:

            switch  LOWORD (wParam) {

                case IDC_RADIO_NONE:
                    g_KeyInfo[GLYPHINDEX].CurrentKeyValue = NONE;
                    break;

                case IDC_RADIO_PARTIAL:
                    g_KeyInfo[GLYPHINDEX].CurrentKeyValue = PARTIAL;
                    break;

                case IDC_RADIO_FULL:
                    g_KeyInfo[GLYPHINDEX].CurrentKeyValue = FULL;
                    break;

                case IDC_GLYPH_BTN_RESTORE:

                    CheckDlgButton(hDlg, IDC_RADIO_FULL, TRUE);
                    CheckDlgButton(hDlg, IDC_RADIO_PARTIAL, FALSE);
                    CheckDlgButton(hDlg, IDC_RADIO_NONE, FALSE);

                    _itot(g_KeyInfo[TEXTFRAGINDEX].DefaultKeyValue,
                            lpszBuffer, 10);
                    SendMessage(hwndComboTextFrag, CB_SELECTSTRING, -1,
                            (LPARAM)(LPCSTR) lpszBuffer);
                    g_KeyInfo[TEXTFRAGINDEX].CurrentKeyValue =
                    g_KeyInfo[TEXTFRAGINDEX].DefaultKeyValue;

                    g_KeyInfo[GLYPHINDEX].CurrentKeyValue =
                            g_KeyInfo[GLYPHINDEX].DefaultKeyValue;

                    for (i = 0; i < NUMBER_OF_SLIDERS; i++) {

                        g_KeyInfo[i+GLYPHCACHEBASE].CurrentKeyValue =
                                g_KeyInfo[i+GLYPHCACHEBASE].DefaultKeyValue;

                        _itot(g_KeyInfo[i + GLYPHCACHEBASE].DefaultKeyValue,
                                (lpszBuffer), 10);

                        //
                        // display the value in the static edit control
                        //
                        SetWindowText(hwndSliderEditBuddy[i], lpszBuffer);
                        //
                        // position the thumb on the slider control
                        //
                        nGlyphBuffer = g_KeyInfo[i +
                        GLYPHCACHEBASE].DefaultKeyValue;

#ifdef _X86_            // EXECUTE ASSEMBLER CODE ONLY IF X86 PROCESSOR
                        // BSF: Bit Scan Forward -
                        // Scans the value contained in the EAX regiseter
                        // for the first significant (1) bit.
                        // This function returns the location of the first
                        // significant bit.  The function is used in this
                        // application as a base 2 logarythm.  The location
                        // of the bit is determined, stored in the nPos
                        // variable, and nPos is used to set the slider
                        // control. ie. If the register value is 4, nPos
                        // is set to 2 (00000100).  10 minus 2 (position 8
                        // on the slider control) represents the value 4.
                        __asm
                        {
                            BSF  EAX, nGlyphBuffer
                            MOV  nPos, EAX
                        }
                        nPos = 10 - nPos;
                        SendMessage(hwndSlider[i], TBM_SETPOS, TRUE,
                                (LPARAM)nPos);

#else

                       switch (nGlyphBuffer) {
                           case 4:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 8);
                               break;
                           case 8:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 7);
                               break;
                           case 16:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 6);
                               break;
                           case 32:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 5);
                               break;
                           case 64:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 4);
                               break;
                           case 128:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 3);
                               break;
                           case 256:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 2);
                               break;
                           case 512:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 1);
                               break;
               }
#endif

                    }
                    break;
            }

            switch  HIWORD (wParam) {

                case CBN_EDITUPDATE:

                    //
                    // capture typed text
                    //
                    GetWindowText(hwndComboTextFrag, lpszBuffer, 5);
                    nKeyVal = _ttoi(lpszBuffer);
                    g_KeyInfo[TEXTFRAGINDEX].CurrentKeyValue = nKeyVal;
                    break;

                case CBN_KILLFOCUS:

                    //
                    // save value when control looses focus
                    //
                    GetWindowText(hwndComboTextFrag, lpszBuffer, 5);
                    nKeyVal = _ttoi(lpszBuffer);
                    g_KeyInfo[TEXTFRAGINDEX].CurrentKeyValue = nKeyVal;
                    break;
            }
    }
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Returns the integer value related to the coresponding cell.
///////////////////////////////////////////////////////////////////////////////

int GetCellSize(int nPos, int i)
{
    if (nPos >= 1 && nPos <= NUM_SLIDER_STOPS) {
        return g_KeyInfo[i + GLYPHCACHEBASE].CurrentKeyValue =
                       (1 << ((NUM_SLIDER_STOPS + 2) - nPos));
    } else {
        return 0;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  Display the slider control value in it's corresponding static edit box.
///////////////////////////////////////////////////////////////////////////////

void DisplayControlValue(HWND hwndSlider[], HWND hwndSliderEditBuddy[],  int i)

{
    int nPos;
    TCHAR lpszBuffer[5];

    nPos = (int) SendMessage(hwndSlider[i], TBM_GETPOS, 0,0);
    _itot(GetCellSize(nPos, i), lpszBuffer, 10);
    SetWindowText(hwndSliderEditBuddy[i], lpszBuffer);
}

// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsreg\profiles.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  profiles.c                                 **
**                                             **
**  Profiles dialog - TSREG                    **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <commctrl.h>
#include <TCHAR.H>
#include "tsreg.h"
#include "resource.h"

PROFILE_KEY_INFO *g_pkfProfile;
PROFILE_KEY_INFO *g_pkfStart;
HWND g_hwndProfilesDlg;

///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK ProfilePage(HWND hDlg, UINT nMsg,
        WPARAM wParam, LPARAM lParam)
{
    static HWND hwndProfilesCBO;
    static HWND hwndProfilesEdit;
    static HKEY hKey;
    TCHAR lpszClientProfilePath[MAX_PATH];
    TCHAR lpszBuffer[MAXKEYSIZE];
    TCHAR lpszKeyName[MAXKEYSIZE];
    TCHAR lpszConfirm[MAX_MESSAGE_LEN + MAXKEYSIZE];
    TCHAR lpszDeleteCaption[90]; // for message box
    TCHAR lpszDeleteTitle[25]; // for message box
    TCHAR lpszSubKeyPath[MAX_PATH];
    TCHAR lpszText[MAXTEXTSIZE];
    ULONG lpPathLen = MAX_PATH;
    NMHDR *lpnmhdr;
    LPHELPINFO lphi;
    LRESULT i;
    int index;
    BOOL bContinue;

    lpnmhdr = (LPNMHDR) lParam;

    switch (nMsg) {

        case WM_INITDIALOG:

            hwndProfilesCBO = GetDlgItem(hDlg, IDC_CBO_PROFILES);
            hwndProfilesEdit = GetDlgItem(hDlg, IDC_EDIT_PROFILES);
            g_hwndProfilesDlg = hDlg;
            LoadKeyValues();

            LoadString(g_hInst, IDS_DEFAULT, lpszText, MAXTEXTSIZE);

            // display 'Default' in edit cell of combo box
            //
            i = SendMessage(hwndProfilesCBO,
                        CB_FINDSTRING, 0,
                        (LPARAM) lpszText);

            SendMessage(hwndProfilesCBO,
                        CB_SETCURSEL, i, 0);
            break;


        case WM_NOTIFY:

            switch (lpnmhdr->code) {

                case PSN_HELP:
                    lphi = (LPHELPINFO) lParam;

                    WinHelp(lphi->hItemHandle,
                        g_lpszPath, HELP_CONTENTS, lphi->iCtrlId);
                    break;
                }
            break;


        case WM_HELP:

            lphi = (LPHELPINFO) lParam;

            WinHelp(lphi->hItemHandle,
                    g_lpszPath, HELP_CONTEXTPOPUP, lphi->iCtrlId);
            break;

        case WM_COMMAND:

            switch  LOWORD (wParam) {

                case IDC_BTN_LOAD:


                    GetWindowText(hwndProfilesCBO, lpszBuffer, MAXKEYSIZE);

                    // if string is null, exit routine
                    //
                    if (_tcscmp(lpszBuffer, TEXT("")) == 0) {
                        LoadString(g_hInst, IDS_PROFILE_LOAD, lpszText, MAXTEXTSIZE);

                        MessageBox(hDlg, lpszText, NULL, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(hwndProfilesCBO);
                        break;
                    }

                    ReloadKeys(lpszBuffer, hwndProfilesCBO);

                    SetEditCell(lpszBuffer,
                           hwndProfilesCBO);

                    // change window caption
                    ResetTitle(lpszBuffer);


                    LoadString (g_hInst, IDS_PROFILE_LOADED,
                            lpszConfirm, sizeof(lpszConfirm));
                    LoadString (g_hInst, IDS_PROFILE_LOADED2,
                            lpszText, MAXTEXTSIZE);

                    _tcscat(lpszConfirm, lpszBuffer);
                    _tcscat(lpszConfirm, lpszText);

                    MessageBox(hDlg,
                            lpszConfirm,
                            TEXT("Profile Loaded"),
                            MB_OK | MB_ICONEXCLAMATION);

                    break;

                case IDC_BTN_SAVE:

                    DialogBox(g_hInst,
                            MAKEINTRESOURCE(IDD_SAVE_FORM),
                            g_hwndProfilesDlg,
                            SaveDialog);

                    break;

                case IDC_BTN_DELETE:

                    GetWindowText(hwndProfilesCBO, lpszBuffer, MAXKEYSIZE);

                    if (_tcscmp(lpszBuffer, TEXT("")) == 0) {

                        LoadString(g_hInst, IDS_PROFILE_DELETE, lpszText, MAXTEXTSIZE);

                        MessageBox(hDlg, lpszText, NULL, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(hwndProfilesCBO);
                        break;
                    }
                    //
                    // confirm delete
                    //
                    LoadString (g_hInst, IDS_DELETE_TITLE,
                            lpszDeleteTitle,
                            sizeof (lpszDeleteTitle));

                    LoadString (g_hInst, IDS_DELETE_CAPTION,
                            lpszDeleteCaption,
                            sizeof (lpszDeleteCaption));

                    i = MessageBox(hDlg, lpszDeleteCaption,
                                  lpszDeleteTitle,
                                  MB_YESNO | MB_ICONEXCLAMATION);

                    if ( i == IDYES) {

                        LoadString (g_hInst, IDS_PROFILE_PATH,
                                lpszClientProfilePath,
                                sizeof(lpszClientProfilePath));

                        GetWindowText(hwndProfilesCBO,
                                lpszBuffer, MAXKEYSIZE);

                        _tcscpy(lpszSubKeyPath, lpszClientProfilePath);
                        _tcscat(lpszSubKeyPath, TEXT("\\"));
                        _tcscat(lpszSubKeyPath, lpszBuffer);

                        //
                        // delete all subkeys first
                        //
                        index = 0;
                        if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszSubKeyPath, 0,
                                KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {
                            do {
                                if (RegEnumKeyEx(hKey, index, &lpszKeyName[0],
                                        &lpPathLen, NULL, NULL, NULL, NULL) ==
                                        ERROR_SUCCESS) {

                                    if (_tcscmp( lpszKeyName,
                                            TEXT("Default")) != 0) {
                                            RegDeleteKey(hKey,
                                                    &lpszKeyName[0]);
                                    }
                                    bContinue = TRUE;
                                    index++;
                                } else {
                                    bContinue = FALSE;
                                }
                            } while (bContinue == TRUE);
                            RegCloseKey(hKey);
                        }

                        //
                        // delete the parent key
                        //
                        if (_tcscmp( lpszBuffer,
                                TEXT("Default")) == 0) {
                            MessageBox(hDlg,
                                    TEXT("Can not delete default key."),
                                    NULL, MB_OK | MB_ICONEXCLAMATION);

                        } else {

                            if (RegOpenKeyEx(HKEY_CURRENT_USER,
                                        lpszClientProfilePath, 0,
                                        KEY_ALL_ACCESS, &hKey) ==
                                        ERROR_SUCCESS)
                            {

                                RegDeleteKey(hKey, &lpszBuffer[0]);
                                RegCloseKey(hKey);
                            }

                            //
                            // remove key from list box
                            //
                            i = SendMessage(hwndProfilesCBO,
                                        CB_FINDSTRING, 0,
                                        (LPARAM) lpszBuffer);

                            SendMessage(hwndProfilesCBO,
                                        CB_DELETESTRING, i, 0);

                            // reload the data struct with default key
                            ReloadKeys(TEXT("Default"), hwndProfilesCBO);

                            // change window caption
                            ResetTitle(TEXT("Default"));
                            SetEditCell(TEXT("Default"),
                                    hwndProfilesCBO);
                        }

                    } else {

                        SetEditCell(lpszBuffer,
                                hwndProfilesCBO);

                        SetFocus(hwndProfilesEdit);
                    }
                    break;
            }
    }
    return (FALSE);
}


// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsreg\psheet.c ===
/*------------------------------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation                        **
**            All Rights reserved                                   **
**                                                                  **
**  psheet.c                                                        **
**                                                                  **
**  Function for defining and creating the property sheets - TSREG  **
**  07-01-98 a-clindh Created                                       **
**------------------------------------------------------------------*/

#include <windows.h>
#include <commctrl.h> 
#include <TCHAR.H>
#include "tsreg.h"
#include "resource.h"


/////////////////////////////////////////////////////////////////////////////// 

INT_PTR CreatePropertySheet(HWND hwndOwner)
{
    PROPSHEETPAGE psp[PAGECOUNT];
    PROPSHEETHEADER psh;
    TCHAR lpszBuf[MAXKEYSIZE] = TEXT("");


    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags = PSP_PREMATURE | PSP_HASHELP;
    psp[0].hInstance = g_hInst;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_SHADOW);
    psp[0].pszIcon = NULL;
    psp[0].pfnDlgProc = ShadowBitmap;
    psp[0].lParam = 0;

    psp[1].dwSize = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags = PSP_PREMATURE | PSP_HASHELP;
    psp[1].hInstance = g_hInst;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_GLYPH_CACHE_DLG);
    psp[1].pszIcon = NULL;
    psp[1].pfnDlgProc = GlyphCache;
    psp[1].lParam = 0;

    psp[2].dwSize = sizeof(PROPSHEETPAGE);
    psp[2].dwFlags = PSP_PREMATURE | PSP_HASHELP;
    psp[2].hInstance = g_hInst;
    psp[2].pszTemplate = MAKEINTRESOURCE(IDD_MISC);
    psp[2].pszIcon = NULL;
    psp[2].pfnDlgProc = Miscellaneous;
    psp[2].lParam = 0;

    psp[3].dwSize = sizeof(PROPSHEETPAGE);
    psp[3].dwFlags = PSP_PREMATURE | PSP_HASHELP;
    psp[3].hInstance = g_hInst;
    psp[3].pszTemplate = MAKEINTRESOURCE(IDD_PROFILES);
    psp[3].pszIcon = NULL;
    psp[3].pfnDlgProc = ProfilePage;
    psp[3].lParam = 0;


    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = g_hInst;
    psh.pszIcon = MAKEINTRESOURCE(IDI_ICON1);
    LoadString (g_hInst, IDS_WINDOW_TITLE, lpszBuf, sizeof (lpszBuf)); 
    _tcscat(lpszBuf, TEXT("Default"));
    psh.pszCaption = lpszBuf;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    return PropertySheet(&psh);
}

// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsreg\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tsreg.rc
//
#define IDS_BITMAP_CACHE                1
#define IDS_GLYPH_CACHE                 2
#define IDS_PROFILE_PATH                2
#define IDS_MISCELLANEOUS               3
#define IDS_START_ERROR                 3
#define IDS_WINDOW_TITLE                4
#define IDS_REG_PATH                    5
#define IDS_SHADOW_BITMAP               6  // KEYSTART
#define IDS_DEDICTED_TERMINAL           7
#define IDS_BITMAP_CACHE_SIZE           8
#define IDS_GLYPHCELL1                  9
#define IDS_GLYPHCELL2                  10
#define IDS_GLYPHCELL3                  11
#define IDS_GLYPHCELL4                  12
#define IDS_GLYPHCELL5                  13
#define IDS_GLYPHCELL6                  14
#define IDS_GLYPHCELL7                  15
#define IDS_GLYPHCELL8                  16
#define IDS_GLYPHCELL9                  17
#define IDS_GLYPHCELL10                 18
#define IDS_BMPROP1                     19
#define IDS_BMPROP2                     20
#define IDS_BMPROP3                     21
#define IDS_BMPROP4                     22
#define IDS_BMPROP5                     23
#define IDS_TEXTFRAG                    24
#define IDS_GSUPLEVEL                   25
#define IDS_ORDERDRAW                   26
#define IDS_BM_NUM_CACHES               27
#define IDS_BM_C1_PERSIST               28
#define IDS_BM_C2_PERSIST               29
#define IDS_BM_C3_PERSIST               30
#define IDS_BM_C4_PERSIST               31
#define IDS_BM_C5_PERSIST               32
#define IDS_BM_C1_MAX_CEL               33
#define IDS_BM_C2_MAX_CEL               34
#define IDS_BM_C3_MAX_CEL               35
#define IDS_BM_C4_MAX_CEL               36
#define IDS_BM_C5_MAX_CEL               37  // KEYEND
#define IDS_PERCENT_ERROR               39
#define IDS_BMCACHE_ERROR               40
#define IDS_ODRAW_ERROR                 41
#define IDS_MISC_TAB                    42
#define IDS_DELETE_TITLE                43
#define IDS_DELETE_CAPTION              44
#define IDS_PROFILE_LOADED              45
#define IDS_DEFAULT                     46
#define IDS_PROFILE_LOAD                47
#define IDS_PROFILE_DELETE              48
#define IDS_PROFILE_LOADED2             49
#define IDS_KEY_SAVE                    50
#define IDS_PATH_TOO_LONG               51
#define IDD_DEDICATED                   102
#define IDD_PROFILES                    107
#define IDD_GLYPH_CACHE_DLG             111
#define IDD_MISC                        112
#define IDI_ICON1                       115
#define IDI_FOLDER_ICON                 116
#define IDD_SAVE_FORM                   120
#define IDD_SHADOW                      151
#define IDC_DEDICATED_ENABLED           1000
#define IDC_SHADOW_DISABLED             1001
#define IDC_CACHING                     1002
#define IDC_DEDICATED                   1004
#define IDC_SHADOW_ENABLED              1005
#define IDC_DEDICATED_DISABLED          1006
#define IDC_STATIC                      -1
#define IDC_CACHE_SIZE                  1010
#define IDC_COMBO_CACHE_SIZE            1011
#define IDC_CACHE_PROP                  1050

#define IDC_SLD_NO_CACHES               2000
#define IDC_TXT_NO_CACHES               2001

#define IDC_TXT_DST_PROP_1              2002
#define IDC_TXT_DST_PROP_2              2003
#define IDC_TXT_DST_PROP_3              2004
#define IDC_TXT_DST_PROP_4              2005
#define IDC_TXT_DST_PROP_5              2006

#define IDC_SLD_DST_PROP_1              2007
#define IDC_SLD_DST_PROP_2              2008
#define IDC_SLD_DST_PROP_3              2009
#define IDC_SLD_DST_PROP_4              2010
#define IDC_SLD_DST_PROP_5              2011

#define IDC_PERSIST_FRAME               2012

#define IDC_CHK_CSH_1                   2014
#define IDC_CHK_CSH_2                   2015
#define IDC_CHK_CSH_3                   2016
#define IDC_CHK_CSH_4                   2017
#define IDC_CHK_CSH_5                   2018
#define IDC_ACTIVE                      2022

#define IDC_BTN_RESTORE                 1054
#define IDC_RADIO_NONE                  1057
#define IDC_RADIO_PARTIAL               1058
#define IDC_RADIO_FULL                  1059
#define IDC_CBO_TXT_FRAG                1061
#define IDC_FRAME_OD                    1062
#define IDC_COMBO_ORDER                 1064
#define IDC_SLIDER1                     1070
#define IDC_SLIDER2                     1071
#define IDC_SLIDER3                     1072
#define IDC_SLIDER4                     1073
#define IDC_SLIDER5                     1074
#define IDC_SLIDER6                     1075
#define IDC_SLIDER7                     1076
#define IDC_SLIDER8                     1077
#define IDC_SLIDER9                     1078
#define IDC_SLIDER10                    1079
#define IDC_GLYPH_CACHE                 1080
#define IDC_STATIC1                     1083
#define IDC_STATIC2                     1084
#define IDC_STATIC3                     1085
#define IDC_STATIC4                     1086
#define IDC_STATIC5                     1087
#define IDC_STATIC6                     1088
#define IDC_STATIC7                     1089
#define IDC_STATIC8                     1090
#define IDC_STATIC9                     1091
#define IDC_STATIC10                    1092
#define IDC_RESTORE                     1093
#define IDC_CHECK_RESTORE               1094
#define IDC_GLYPH_BTN_RESTORE           1097
#define IDC_MISC_BUTTON_RESTORE         1098
#define IDC_CBO_PROFILES                1102
#define IDC_BTN_LOAD                    1103
#define IDC_BTN_SAVE                    1104
#define IDC_BTN_DELETE                  1105
#define IDC_EDIT_PROFILES               1106
#define IDC_PSAVE                       1107
#define IDC_SAVE_LIST                   1115
#define IDC_EDIT_KEY                    1116


#define IDC_FRAME_TIMEOUT               1117
#define IDC_TXT_TIMEOUT                 1119
#define IDC_SLD_TIMEOUT                 1120


#define IDC_STATIC_CACHE_SIZE           5011

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        121
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1117
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsreg\reg.c ===
/*-----------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation     **
**            All Rights reserved                **
**                                               **
**  reg.c                                        **
**                                               **
**  Functions for reading, writing, and deleting **
**  registry keys - TSREG                        **
**  07-01-98 a-clindh Created                    **
**-----------------------------------------------*/

#include <windows.h>
#include <commctrl.h>
#include <TCHAR.H>
#include <stdlib.h>
#include "tsreg.h"
#include "resource.h"

///////////////////////////////////////////////////////////////////////////////

// Had to have this function in case the user wants to save a profile
// that only has default settings.  This will write a key but the key
// will contain no values.
///////////////////////////////////////////////////////////////////////////////

void WriteBlankKey(TCHAR lpszRegPath[MAX_PATH])
{
    HKEY hKey;
    DWORD dwDisposition;

    RegCreateKeyEx(HKEY_CURRENT_USER, lpszRegPath,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 0, &hKey, &dwDisposition);

    RegCloseKey(hKey);

}

///////////////////////////////////////////////////////////////////////////////
void SetRegKey(int i, TCHAR lpszRegPath[MAX_PATH])
{
    HKEY hKey;
    DWORD dwDisposition;

    RegCreateKeyEx(HKEY_CURRENT_USER, lpszRegPath,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 0, &hKey, &dwDisposition);

    //
    // write the key value to the registry
    //
    if(hKey != NULL) {
    RegSetValueEx(hKey, g_KeyInfo[i].Key, 0, REG_DWORD,
            & (unsigned char) (g_KeyInfo[i].CurrentKeyValue),
            sizeof(DWORD));
    }
    RegCloseKey(hKey);

}

///////////////////////////////////////////////////////////////////////////////

void DeleteRegKey(int i, TCHAR lpszRegPath[MAX_PATH])
{
    HKEY hKey;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszRegPath, 0,
            KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {

        RegDeleteValue(hKey, g_KeyInfo[i].Key);
        RegCloseKey(hKey);
    }
}

///////////////////////////////////////////////////////////////////////////////

// returns 1 if the registry key is there and 0 if it isn't
///////////////////////////////////////////////////////////////////////////////
int GetRegKey(int i, TCHAR lpszRegPath[MAX_PATH])
{
    DWORD *dwKeyValue;
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;

    dwType = REG_SZ;
    dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszRegPath, 0,
                KEY_READ, &hKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hKey, g_KeyInfo[i].Key, 0,
                &dwType, (LPBYTE) &dwKeyValue,
                &dwSize) == ERROR_SUCCESS) {

            RegCloseKey(hKey);
            return 1;
        }
        RegCloseKey(hKey);
    }
    return 0;
}

///////////////////////////////////////////////////////////////////////////////

void SaveSettings(HWND dlghwnd, int i,
        int nCtlID1, int nCtlID2, TCHAR lpszRegPath[MAX_PATH])
{
    do {
        if (IsDlgButtonChecked(dlghwnd, nCtlID1)) {

            SetRegKey(i, lpszRegPath);

        } else {

             if (IsDlgButtonChecked(dlghwnd, nCtlID2)) {

                 DeleteRegKey(i, lpszRegPath);
             }
        }
    dlghwnd = GetNextWindow(dlghwnd, GW_HWNDNEXT);
    } while (dlghwnd != NULL);
}

///////////////////////////////////////////////////////////////////////////////

void RestoreSettings(HWND dlghwnd, int i,
        int nCtlID1, int nCtlID2, TCHAR lpszRegPath[MAX_PATH])
{

    // check settings and enable appropriate radio button.
    if (GetRegKey(i, lpszRegPath) != 0) {

        CheckDlgButton(dlghwnd, nCtlID1, TRUE);
        CheckDlgButton(dlghwnd, nCtlID2, FALSE);

    } else {

        CheckDlgButton(dlghwnd, nCtlID1, FALSE);
        CheckDlgButton(dlghwnd, nCtlID2, TRUE);

    }
}

///////////////////////////////////////////////////////////////////////////////

// pass the index of the key and the function
// returns the value stored in the registry
///////////////////////////////////////////////////////////////////////////////
int GetRegKeyValue(int i)
{
    int nKeyValue;
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;
    TCHAR lpszRegPath[MAX_PATH];

    LoadString (g_hInst, IDS_REG_PATH, lpszRegPath, sizeof (lpszRegPath));

    dwType = REG_SZ;
    dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszRegPath, 0,
                KEY_READ, &hKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hKey, g_KeyInfo[i].Key, 0,
                &dwType, (LPBYTE) &nKeyValue,
                &dwSize) == ERROR_SUCCESS) {

            RegCloseKey(hKey);
            return nKeyValue;
        }
        RegCloseKey(hKey);
    }
    return 0;
}
///////////////////////////////////////////////////////////////////////////////

//  Initialize the controls for the original "misc" sheet.
///////////////////////////////////////////////////////////////////////////////
void InitMiscControls(HWND hDlg, HWND hwndComboBox)
{
    TCHAR szBuffer[4];
    int i, nKeyVal;
    TCHAR lpszRegPath[MAX_PATH];

    LoadString (g_hInst, IDS_REG_PATH, lpszRegPath, sizeof (lpszRegPath));

    //
    // fill the combo box list
    //
    SendMessage(hwndComboBox, CB_ADDSTRING, 0,
            (LPARAM) (LPCTSTR) TEXT("0"));

    for (i = 2; i <= MAXTEXTFRAGSIZE; i*= 2) {
        _itot(i, szBuffer, 10);
        SendMessage(hwndComboBox, CB_ADDSTRING, 0,
                (LPARAM) (LPCTSTR) szBuffer);
    } // ** end for loop

    //
    // limit combo box to 4 characters
    //
    SendMessage(hwndComboBox, CB_LIMITTEXT, 3, 0);

    //
    // get values from registry for text frag combo box
    //
    nKeyVal = GetRegKey(TEXTFRAGINDEX, lpszRegPath); // check for null

    if ( nKeyVal == 1 ) {
        nKeyVal = GetRegKeyValue(TEXTFRAGINDEX);
    } else {
        nKeyVal = g_KeyInfo[TEXTFRAGINDEX].DefaultKeyValue;
    }

    g_KeyInfo[TEXTFRAGINDEX].CurrentKeyValue = nKeyVal;
    _itot( nKeyVal, szBuffer, 10);
    SendMessage(hwndComboBox, CB_SELECTSTRING, -1,
            (LPARAM)(LPCSTR) szBuffer);

    //
    // get values from registry for radio buttons
    //
    nKeyVal = GetRegKey(GLYPHINDEX, lpszRegPath); // check for null

    if ( nKeyVal == 1 ) {
        nKeyVal = GetRegKeyValue(GLYPHINDEX);
        switch (nKeyVal) {

            case 0:
                CheckDlgButton(hDlg, IDC_RADIO_NONE, TRUE);
                break;

            case 1:
                CheckDlgButton(hDlg, IDC_RADIO_PARTIAL, TRUE);
                break;

            case 2:
                CheckDlgButton(hDlg, IDC_RADIO_FULL, TRUE);
                break;
        }
    } else {
        nKeyVal = g_KeyInfo[GLYPHINDEX].DefaultKeyValue;
        CheckDlgButton(hDlg, IDC_RADIO_FULL, TRUE);
    }

    g_KeyInfo[GLYPHINDEX].CurrentKeyValue = nKeyVal;

}

///////////////////////////////////////////////////////////////////////////////

// Needed a special funtion to save settings for the bitmap cache.  The
// combined total must be 100 and can only be checked after all combo
// boxes have been filled.
///////////////////////////////////////////////////////////////////////////////
BOOL SaveBitmapSettings(TCHAR lpszRegPath[MAX_PATH])
{
    static HWND hwndComboCache;
    static HWND hwndSliderNumCaches;
    static HWND hwndSliderDistProp[PERCENT_COMBO_COUNT];
    static HWND hwndPropChkBox[PERCENT_COMBO_COUNT];
    static HWND hwndSliderBuddy[PERCENT_COMBO_COUNT];
    TCHAR lpszBuffer[6];
    int i;

    //
    // get handles for cache size combo box and the
    // number of caches slider
    /////////////////////////////////////////////////////////////////
    hwndSliderNumCaches = GetDlgItem(g_hwndShadowBitmapDlg,
            IDC_SLD_NO_CACHES);

    hwndComboCache = GetDlgItem(g_hwndShadowBitmapDlg,
            IDC_COMBO_CACHE_SIZE);
    //---------------------------------------------------------------

    //
    // save settings for cache size
    /////////////////////////////////////////////////////////////////
    if (g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue ==
                g_KeyInfo[CACHESIZEINDEX].DefaultKeyValue) {
        DeleteRegKey(CACHESIZEINDEX, lpszRegPath);
    } else {
        SetRegKey(CACHESIZEINDEX, lpszRegPath);
    }
    //---------------------------------------------------------------

    //
    // save settings for number of caches
    /////////////////////////////////////////////////////////////////
    if ( g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue ==
            g_KeyInfo[NUM_CELL_CACHES_INDEX].DefaultKeyValue) {
        DeleteRegKey(NUM_CELL_CACHES_INDEX, lpszRegPath);
    } else {
        SetRegKey(NUM_CELL_CACHES_INDEX, lpszRegPath);
    }
    //---------------------------------------------------------------


    for (i = 0; i < PERCENT_COMBO_COUNT; i++) {
        //
        // get handles to sliders, edit, & check boxes
        /////////////////////////////////////////////////////////////
        hwndSliderDistProp[i] = GetDlgItem(g_hwndShadowBitmapDlg,
                    IDC_SLD_DST_PROP_1 + i);

        hwndSliderBuddy[i] = GetDlgItem(g_hwndShadowBitmapDlg,
                    IDC_TXT_DST_PROP_1 + i);

        hwndPropChkBox[i] = GetDlgItem(g_hwndShadowBitmapDlg,
                    IDC_CHK_CSH_1 + i);
        //-----------------------------------------------------------
        GetWindowText(hwndSliderBuddy[i], lpszBuffer, 4);
        g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue =
                _ttoi(lpszBuffer);
        //
        // save settings for cache sizes
        /////////////////////////////////////////////////////////////
        if ( g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue ==
                g_KeyInfo[CACHEPROP1 + i].DefaultKeyValue) {
            DeleteRegKey(CACHEPROP1 + i, lpszRegPath);
        } else {
            SetRegKey(CACHEPROP1 + i, lpszRegPath);
        }
        //-----------------------------------------------------------


        //
        // save settings for persistent caching
        /////////////////////////////////////////////////////////////
        if (IsDlgButtonChecked(g_hwndShadowBitmapDlg, IDC_CHK_CSH_1 + i)) {
            g_KeyInfo[BM_PERSIST_BASE_INDEX + i].CurrentKeyValue = 1;
            SetRegKey(BM_PERSIST_BASE_INDEX + i, lpszRegPath);
        } else {
            g_KeyInfo[BM_PERSIST_BASE_INDEX + i].CurrentKeyValue = 0;
            DeleteRegKey(BM_PERSIST_BASE_INDEX + i, lpszRegPath);
        }
        //-----------------------------------------------------------

    } // ** end for loop

        return TRUE;

}

///////////////////////////////////////////////////////////////////////////////

// reads individual key values for each profile into it's associated
// variable from the regisgry (if there is a value) or assigns the
// element it's default value.
///////////////////////////////////////////////////////////////////////////////
void LoadKeyValues()
{

    TCHAR lpszClientProfilePath[MAX_PATH];
    static HWND hwndProfilesCBO;
    int i, index, nKeyValue;
    TCHAR lpszSubKeyPath[MAX_PATH];
    DWORD dwType;
    DWORD dwSize;
    static HKEY hKey;


    hwndProfilesCBO = GetDlgItem(g_hwndProfilesDlg, IDC_CBO_PROFILES);

    LoadString (g_hInst, IDS_PROFILE_PATH,
        lpszClientProfilePath, sizeof(lpszClientProfilePath));

    // get the key name of each profile
    GetClientProfileNames(lpszClientProfilePath);

    g_pkfProfile = g_pkfStart;
    for (index = 0; index <= g_pkfProfile->Index; index++) {

        // fill combo box existing profile names
        SendMessage(hwndProfilesCBO, CB_ADDSTRING, 0,
                    (LPARAM) g_pkfProfile->KeyInfo->Key);

        _tcscpy(lpszSubKeyPath, lpszClientProfilePath);
        _tcscat(lpszSubKeyPath, TEXT("\\"));
        _tcscat(lpszSubKeyPath, g_pkfProfile->KeyInfo->Key);

        for (i = 0; i < KEYCOUNT; i++) {
            if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszSubKeyPath, 0,
                    KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {

                g_pkfProfile->KeyInfo[i].DefaultKeyValue =
                        g_KeyInfo[i].DefaultKeyValue;

                _tcscpy(g_pkfProfile->KeyInfo[i].KeyPath,
                        lpszSubKeyPath);

                    if (RegQueryValueEx(hKey, g_KeyInfo[i].Key, 0,
                                    &dwType, (LPBYTE) &nKeyValue,
                                    &dwSize) == ERROR_SUCCESS) {
                        g_pkfProfile->KeyInfo[i].CurrentKeyValue =
                                nKeyValue;
                        RegCloseKey(hKey);
                    } else {
                        g_pkfProfile->KeyInfo[i].CurrentKeyValue =
                                g_KeyInfo[i].DefaultKeyValue;
                        RegCloseKey(hKey);
                    }
                    RegCloseKey(hKey);
            }
        }// inner for loop
        g_pkfProfile =  g_pkfProfile->Next;
    }// outer for loop

}

///////////////////////////////////////////////////////////////////////////////

void ReadRecordIn(TCHAR lpszBuffer[])
{
    // adds values from linked list to default data structure.
    int i, index;

    g_pkfProfile = g_pkfStart;
    for (index = 0; index <= g_pkfProfile->Index; index++) {

        if (_tcscmp( lpszBuffer,
                g_pkfProfile->KeyInfo->Key) == 0) {

            for (i = 0; i < KEYCOUNT; i++) {
                g_KeyInfo[i].CurrentKeyValue =
                        g_pkfProfile->KeyInfo[i].
                        CurrentKeyValue;
            }
            break;
        }
        g_pkfProfile = g_pkfProfile->Next;
    }
}

///////////////////////////////////////////////////////////////////////////////

void ReloadKeys(TCHAR lpszBuffer[], HWND hwndProfilesCBO)
{

    int index;

    SendMessage(hwndProfilesCBO, CB_RESETCONTENT, 0, 0);

    // free any allocated memory.
    g_pkfProfile = g_pkfStart;
    for (index = 0; index <= g_pkfProfile->Index; index++) {
        g_pkfProfile = g_pkfStart->Next;
        free(g_pkfProfile);
        g_pkfStart = g_pkfProfile;
    }

    // allocate memory and reload keys.
    LoadKeyValues();

    // read linked list into current key data struct.
    ReadRecordIn(lpszBuffer);

    // adjust the controls accordingly.
    SetControlValues();
}

///////////////////////////////////////////////////////////////////////////////

// change the title of the app to reflect the currently selected profile
///////////////////////////////////////////////////////////////////////////////
void ResetTitle(TCHAR lpszBuffer[])
{
    HWND hWndParent;
    TCHAR lpszCaption[MAXKEYSIZE] = TEXT("");

    // change window caption
    LoadString (g_hInst, IDS_WINDOW_TITLE,
            lpszCaption, sizeof (lpszCaption));
    _tcscat(lpszCaption, lpszBuffer);
    hWndParent = GetParent(g_hwndProfilesDlg);
    SendMessage(hWndParent, WM_SETTEXT, 0,
            (LPARAM) lpszCaption);
}

///////////////////////////////////////////////////////////////////////////////

void SetEditCell(TCHAR lpszBuffer[],
                 HWND hwndProfilesCBO)
{
    LRESULT i;
    //
    // set edit cell text to selected profile string
    //
    i = SendMessage(hwndProfilesCBO,
                CB_FINDSTRING, 0,
                (LPARAM) lpszBuffer);

    SendMessage(hwndProfilesCBO,
                CB_SETCURSEL, i, 0);
}

///////////////////////////////////////////////////////////////////////////////

// Recursive function to allocate memory and read in the values stored
// in the registry.
///////////////////////////////////////////////////////////////////////////////
void GetClientProfileNames(TCHAR lpszClientProfilePath[])
{
    TCHAR lpszKeyName[MAX_PATH];
    ULONG lpPathLen = MAX_PATH;
    static HKEY hKey;
    static int nKeyIndex = 0;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszClientProfilePath, 0,
            KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {

        if (RegEnumKeyEx(hKey, nKeyIndex, &lpszKeyName[0], &lpPathLen,
                NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

            //
            // allocate memory for the first key
            //
            if (nKeyIndex == 0) {
                g_pkfProfile = (PROFILE_KEY_INFO *) malloc
                        (sizeof(PROFILE_KEY_INFO));
                g_pkfStart = g_pkfProfile;
            }

            //
            // Catches failure if malloc fails above
            //
            if(!g_pkfProfile)
            {
                return;
            }

            // save the key name to the data structure
            _tcsncpy(g_pkfProfile->KeyInfo->Key, lpszKeyName,
                     sizeof(g_pkfProfile->KeyInfo->Key)/sizeof(TCHAR));

            // give the data element an index number
            g_pkfProfile->Index = nKeyIndex;

            // allocate memory for the next structure
            g_pkfProfile->Next = (PROFILE_KEY_INFO *) malloc
                    (sizeof(PROFILE_KEY_INFO));

            // increment the pointer to the next element
            g_pkfProfile = g_pkfProfile->Next;

            // close the current registry key
            RegCloseKey(hKey);

            if(!g_pkfProfile)
            {
                return;
            }

            nKeyIndex++;
            GetClientProfileNames(lpszClientProfilePath);
        }
        RegCloseKey(hKey);
    }
    nKeyIndex = 0;
}

///////////////////////////////////////////////////////////////////////////////

// adjust all of the controls in the application to the values stored
// by the profile.
///////////////////////////////////////////////////////////////////////////////
void SetControlValues()
{
    TCHAR lpszBuffer[MAXKEYSIZE];
    HWND hwndComboCache;
    static HWND hwndSliderNumCaches;
    static HWND hwndSliderDistProp[PERCENT_COMBO_COUNT];
    static HWND hwndSliderDistBuddy[PERCENT_COMBO_COUNT];
    static HWND hwndPropChkBox[PERCENT_COMBO_COUNT];
    static HWND hwndSlider[NUMBER_OF_SLIDERS];
    static HWND hwndSliderEditBuddy[NUMBER_OF_SLIDERS];
    static HWND hwndEditNumCaches;
    static HWND hwndComboTextFrag;
    static HWND hwndComboOrder;
    static HWND hwndRadioShadowEn, hwndRadioShadowDis;
    static HWND hwndRadioDedicatedEn, hwndRadioDedicatedDis;
    static TCHAR lpszRegPath[MAX_PATH];
    static UINT nGlyphBuffer;
    int nPos;
    int i;

    LoadString (g_hInst, IDS_REG_PATH, lpszRegPath, sizeof (lpszRegPath));

    // shadow bitmap page *****************************************************

    hwndComboCache = GetDlgItem(g_hwndShadowBitmapDlg,
            IDC_COMBO_CACHE_SIZE);
    hwndSliderNumCaches = GetDlgItem(g_hwndShadowBitmapDlg,
            IDC_SLD_NO_CACHES);
    hwndEditNumCaches = GetDlgItem(g_hwndShadowBitmapDlg,
            IDC_TXT_NO_CACHES);

    for (i = 0; i < PERCENT_COMBO_COUNT; i++) {
        _itot(g_KeyInfo[i + CACHEPROP1].CurrentKeyValue,
                lpszBuffer, 10);

        hwndSliderDistProp[i] = GetDlgItem(g_hwndShadowBitmapDlg,
                IDC_SLD_DST_PROP_1 + i);
        hwndSliderDistBuddy[i] = GetDlgItem(g_hwndShadowBitmapDlg,
                IDC_TXT_DST_PROP_1 + i);

        SetWindowText(hwndSliderDistBuddy[i], lpszBuffer);

        hwndPropChkBox[i] = GetDlgItem(g_hwndShadowBitmapDlg,
                IDC_CHK_CSH_1 + i);
    }

    //
    // enable/disable check boxes and sliders
    //
    EnableControls(g_hwndShadowBitmapDlg, hwndSliderDistProp,
                hwndPropChkBox, hwndSliderDistBuddy,
                hwndEditNumCaches, hwndSliderNumCaches,
                PERCENT_COMBO_COUNT, lpszRegPath);

    _itot(g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue, lpszBuffer, 10);
    SetWindowText(hwndComboCache, lpszBuffer);

    // glyph page *************************************************************

    hwndComboTextFrag = GetDlgItem(g_hwndGlyphCacheDlg, IDC_CBO_TXT_FRAG);

    switch (g_KeyInfo[GLYPHINDEX].CurrentKeyValue) {

        case 0:
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_NONE, TRUE);
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_PARTIAL, FALSE);
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_FULL, FALSE);
            break;

        case 1:
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_NONE, FALSE);
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_PARTIAL, TRUE);
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_FULL, FALSE);
            break;

        case 2:
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_NONE, FALSE);
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_PARTIAL, FALSE);
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_FULL, TRUE);
            break;
    }

    _itot(g_KeyInfo[TEXTFRAGINDEX].CurrentKeyValue, lpszBuffer, 10);
    SendMessage(hwndComboTextFrag, CB_SELECTSTRING, -1,
            (LPARAM)(LPCSTR) lpszBuffer);

    for (i = 0; i < NUMBER_OF_SLIDERS; i++) {

        hwndSlider[i] = GetDlgItem(g_hwndGlyphCacheDlg,
                (IDC_SLIDER1 + i));
        hwndSliderEditBuddy[i] = GetDlgItem(g_hwndGlyphCacheDlg,
                (IDC_STATIC1 + i));

        SetWindowLongPtr(hwndSlider[i], GWLP_USERDATA, i);

        _itot(g_KeyInfo[i + GLYPHCACHEBASE].CurrentKeyValue,
                (lpszBuffer), 10);
        //
        // position the thumb on the slider control
        //
        nGlyphBuffer = g_KeyInfo[i + GLYPHCACHEBASE].CurrentKeyValue;

#ifdef _X86_
        // EXECUTE ASSEMBLER CODE ONLY IF X86 PROCESSOR
        // BSF: Bit Scan Forward -
        // Scans the value contained in the EAX regiseter
        // for the first significant (1) bit.
        // This function returns the location of the first
        // significant bit.  The function is used in this
        // application as a base 2 logarythm.  The location
        // of the bit is determined, stored in the nPos
        // variable, and nPos is used to set the slider
        // control. ie. If the register value is 4, nPos
        // is set to 2 (00000100).  10 minus 2 (position 8
        // on the slider control) represents the value 4.

        __asm
        {
            BSF  EAX, nGlyphBuffer
            MOV  nPos, EAX
        }
        nPos = 10 - nPos;
        SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, (LPARAM)nPos);

#else

       switch (nGlyphBuffer) {
           case 4:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 8);
               break;
           case 8:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 7);
               break;
           case 16:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 6);
               break;
           case 32:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 5);
               break;
           case 64:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 4);
               break;
           case 128:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 3);
               break;
           case 256:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 2);
               break;
           case 512:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 1);
               break;
       }
#endif

    }

    //misc page ***************************************************************

    hwndComboOrder = GetDlgItem(g_hwndMiscDlg, IDC_COMBO_ORDER);
    hwndRadioShadowEn = GetDlgItem(g_hwndMiscDlg, IDC_SHADOW_ENABLED);
    hwndRadioShadowDis = GetDlgItem(g_hwndMiscDlg, IDC_SHADOW_DISABLED);
    hwndRadioDedicatedEn = GetDlgItem(g_hwndMiscDlg, IDC_DEDICATED_ENABLED);
    hwndRadioDedicatedDis = GetDlgItem(g_hwndMiscDlg, IDC_DEDICATED_DISABLED);
    //
    // set radio buttons
    //
    RestoreSettings(g_hwndMiscDlg, SHADOWINDEX,
            IDC_SHADOW_DISABLED, IDC_SHADOW_ENABLED,
            g_pkfProfile->KeyInfo[i].KeyPath);

    RestoreSettings(g_hwndMiscDlg, DEDICATEDINDEX,
            IDC_DEDICATED_ENABLED, IDC_DEDICATED_DISABLED,
            g_pkfProfile->KeyInfo[i].KeyPath);

    _itot( g_KeyInfo[ORDERINDEX].CurrentKeyValue,
    lpszBuffer, 10);
    SetWindowText(hwndComboOrder, lpszBuffer);
}

///////////////////////////////////////////////////////////////////////////////
//
//
// send handles to controls and the integer value for the number of
// enabled combo & check boxes
///////////////////////////////////////////////////////////////////////////////
void EnableControls(HWND hDlg,
            HWND hwndSliderDistProp[],
            HWND hwndPropChkBox[],
            HWND hwndSliderDistBuddy[],
            HWND hwndEditNumCaches,
            HWND hwndSliderNumCaches,
            int nNumCellCaches,
            TCHAR lpszRegPath[])
{

    int i, nPos;
    TCHAR lpszBuffer[6];


    for (i = 0; i < nNumCellCaches; i++) {
        //
        // check/uncheck check boxes for persistent caching
        //
        if (g_KeyInfo[BM_PERSIST_BASE_INDEX + i].CurrentKeyValue == 0)
            CheckDlgButton(hDlg, IDC_CHK_CSH_1 + i, FALSE);
        else
            CheckDlgButton(hDlg, IDC_CHK_CSH_1 + i, TRUE);

        //
        // enable/disable check & slider controls
        //
        if (i < (INT) g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue) {
            EnableWindow(hwndSliderDistProp[i], TRUE);
            EnableWindow(hwndPropChkBox[i], TRUE);
            EnableWindow(hwndSliderDistBuddy[i], TRUE);
            _itot(g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue,
                                        lpszBuffer, 10);
            SetWindowText(hwndSliderDistBuddy[i], lpszBuffer);
            //
            // position the thumb on the slider control
            //
            nPos = g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue;
            SendMessage(hwndSliderDistProp[i], TBM_SETPOS, TRUE,
                    11 - nPos / 10);
            } else {
                EnableWindow(hwndSliderDistProp[i], FALSE);
                EnableWindow(hwndPropChkBox[i], FALSE);
                EnableWindow(hwndSliderDistBuddy[i], FALSE);
                SetWindowText(hwndSliderDistBuddy[i], NULL);
                CheckDlgButton(hDlg, IDC_CHK_CSH_1 + i, FALSE);
                SendMessage(hwndSliderDistProp[i], TBM_SETPOS, TRUE, 11);
            }
    }
    //
    // position the thumb on the slider control (num caches)
    //
    SendMessage(hwndSliderNumCaches, TBM_SETPOS, TRUE,
            g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue + 1);

    _itot( g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue,
            lpszBuffer, 10);
    //
    // display string in edit cell
    //
    SetWindowText(hwndEditNumCaches, lpszBuffer);

}


// end of file
///////////////////////////////////////////////////////////////////////////////
// pass the key name along with the key path and the function
// returns the value stored in the registry
// DWORD values
///////////////////////////////////////////////////////////////////////////////
int GetKeyVal(TCHAR lpszRegPath[MAX_PATH], TCHAR lpszKeyName[MAX_PATH])
{
    int nKeyValue;
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;

    dwType = REG_SZ;
    dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszRegPath, 0,
                KEY_READ, &hKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hKey, lpszKeyName, 0,
                &dwType, (LPBYTE) &nKeyValue,
                &dwSize) == ERROR_SUCCESS) {

            RegCloseKey(hKey);
            return nKeyValue;
        }
        RegCloseKey(hKey);
    }
    return 0;
}
///////////////////////////////////////////////////////////////////////////////

// send path AND key name to set key value - used with foreground window
// lock timeout.
///////////////////////////////////////////////////////////////////////////////
void SetRegKeyVal(TCHAR lpszRegPath[MAX_PATH],
			TCHAR lpszKeyName[MAX_PATH],
	 		int nKeyValue)
{
    HKEY hKey;
    DWORD dwDisposition;

    RegCreateKeyEx(HKEY_CURRENT_USER, lpszRegPath,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 0, &hKey, &dwDisposition);

    //
    // write the key value to the registry
    //
    if(hKey != NULL) {
        RegSetValueEx(hKey, lpszKeyName, 0, REG_DWORD,
                & (unsigned char) (nKeyValue),
                sizeof(DWORD));
        RegCloseKey(hKey);
    }
}

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsreg\save.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  save.c                                     **
**                                             **
**  Save dialog - TSREG                        **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <commctrl.h>
#include <TCHAR.H>
#include <stdlib.h>
#include "tsreg.h"
#include "resource.h"

int SaveKeys(HWND hDlg,
            HWND hwndEditSave,
            HWND hwndProfilesCBO);

BOOL InitListViewItems(HWND hwndSaveList);
BOOL InitListViewImageLists(HWND hwndSaveList);
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK SaveDialog(HWND hDlg, UINT nMsg,
        WPARAM wParam, LPARAM lParam)
{
    TCHAR lpszBuffer[MAXKEYSIZE];
    static HWND hwndProfilesCBO;
    static HWND hwndSaveList;
    static HWND hwndEditSave;
    LPNMLISTVIEW lpnmlv;
    NMHDR *lpnmhdr;

    lpnmlv = (LPNMLISTVIEW) lParam;
    lpnmhdr = ((LPNMHDR)lParam);

    switch (nMsg) {

        case WM_INITDIALOG:

            hwndProfilesCBO = GetDlgItem(g_hwndProfilesDlg, IDC_CBO_PROFILES);
            hwndSaveList = GetDlgItem(hDlg, IDC_SAVE_LIST);
            hwndEditSave = GetDlgItem(hDlg, IDC_EDIT_KEY);
            InitListViewImageLists(hwndSaveList);
            InitListViewItems(hwndSaveList);
            SetFocus(hwndEditSave);
            break;

       case WM_NOTIFY:

            //
            // display text in edit box or save when user
            // clicks or double clicks an icon.
            //
            switch (lpnmlv->hdr.code) {

                case NM_DBLCLK:
                    if (SaveKeys(hDlg, hwndEditSave, hwndProfilesCBO))
                        EndDialog(hDlg, TRUE);
                    break;

                case NM_CLICK:

                    ListView_GetItemText(hwndSaveList,
                            lpnmlv->iItem, 0, lpszBuffer,
                            sizeof(lpszBuffer));		
                    SetWindowText(hwndEditSave, lpszBuffer);
                    break;
            }
            break;

        case WM_COMMAND:

            switch  LOWORD (wParam) {

                case IDOK:
                    if (SaveKeys(hDlg, hwndEditSave, hwndProfilesCBO))
                        EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:

                    EndDialog(hDlg, FALSE);

                    break;
            }
            break;
    }

    return (FALSE);
}

///////////////////////////////////////////////////////////////////////////////

BOOL InitListViewImageLists(HWND hwndSaveList)
{

    HICON hiconItem = NULL;        // icon for list view items
    HIMAGELIST himlSmall = NULL;   // image list for other views

    himlSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
            GetSystemMetrics(SM_CYSMICON), TRUE, 1, 1);

    // Add an icon to the image list.
    hiconItem = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_FOLDER_ICON));
    if(( hiconItem != NULL) && (himlSmall != NULL)) {
        ImageList_AddIcon(himlSmall, hiconItem);
        DeleteObject(hiconItem);

        // Assign the image lists to the list view control.
        ListView_SetImageList(hwndSaveList, himlSmall, LVSIL_SMALL);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////


BOOL InitListViewItems(HWND hwndSaveList)
{
    int i;
    LVITEM lvi;

    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvi.state = 0;
    lvi.stateMask = 0;
    lvi.iImage = 0;

    //
    // Get the key names and add them to the image list
    //
    g_pkfProfile = g_pkfStart;
    for (i = 0; i <= g_pkfProfile->Index; i++) {

        lvi.pszText = g_pkfProfile->KeyInfo->Key;
        lvi.iItem = i;
        lvi.iSubItem = 0;
        ListView_InsertItem(hwndSaveList, &lvi);
        g_pkfProfile = g_pkfProfile->Next;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
int SaveKeys(HWND hDlg,
            HWND hwndEditSave,
            HWND hwndProfilesCBO)
{
    TCHAR lpszClientProfilePath[MAX_PATH] = TEXT("");
    TCHAR lpszSubKeyPath[MAX_PATH];
    TCHAR lpszBuffer[MAXKEYSIZE];
    TCHAR lpszText[MAXTEXTSIZE];
    static HKEY hKey;
    int i;


    GetWindowText(hwndEditSave, lpszBuffer, MAXKEYSIZE);

    // check for null string
    //
    if (_tcscmp(lpszBuffer, TEXT("")) == 0) {

        LoadString(g_hInst, IDS_KEY_SAVE, lpszText, MAXTEXTSIZE);

        MessageBox(hDlg, lpszText, NULL, MB_OK | MB_ICONEXCLAMATION);
        SetFocus(hwndEditSave);
        return 0;
    }

    LoadString (g_hInst, IDS_PROFILE_PATH,
            lpszClientProfilePath,
            sizeof(lpszClientProfilePath));

    _tcscpy(lpszSubKeyPath, lpszClientProfilePath);
    _tcscat(lpszSubKeyPath, TEXT("\\"));
    _tcscat(lpszSubKeyPath, lpszBuffer);
    //
    // only add values to the combo box that aren't already listed
    //
    if (SendMessage(hwndProfilesCBO, CB_FINDSTRING, 0,
        (LPARAM) lpszBuffer) == CB_ERR) {

        SendMessage(hwndProfilesCBO, CB_ADDSTRING, 0,
                (LPARAM) lpszBuffer);
    }
    //
    // change window caption
    //
    ResetTitle(lpszBuffer);
    //
    // save the settings to the registry
    //
    WriteBlankKey(lpszSubKeyPath);//save even if nothing is set

    SaveBitmapSettings(lpszSubKeyPath);

    SaveSettings(g_hwndMiscDlg, DEDICATEDINDEX, IDC_DEDICATED_ENABLED,
            IDC_DEDICATED_DISABLED, lpszSubKeyPath);

    SaveSettings(g_hwndMiscDlg, SHADOWINDEX, IDC_SHADOW_DISABLED,
            IDC_SHADOW_ENABLED, lpszSubKeyPath);

    for (i = 2; i < KEYCOUNT; i++) {

        if (g_KeyInfo[i].CurrentKeyValue != g_KeyInfo[i].DefaultKeyValue)
            SetRegKey(i, lpszSubKeyPath);
        else
            DeleteRegKey(i, lpszSubKeyPath);
    }

    //
    // release memory and re-read key values for all defined
    // profiles
    //
    ReloadKeys(lpszBuffer, hwndProfilesCBO);
    SetEditCell(lpszBuffer,
           hwndProfilesCBO);
	return 1;

}//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsreg\shadow.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  shadow.c                                   **
**                                             **
**  Shadow bitmap dialog - TSREG               **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <commctrl.h>
#include <TCHAR.H>
#include <stdlib.h>
#include "tsreg.h"
#include "resource.h"


HWND g_hwndShadowBitmapDlg;
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK ShadowBitmap(HWND hDlg, UINT nMsg,
        WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnmhdr;
    static HWND hwndComboCacheSize;
    static HWND hwndSliderNumCaches;
    static HWND hwndEditNumCaches;
    static HWND hwndSliderDistProp[PERCENT_COMBO_COUNT];
    static HWND hwndSliderDistBuddy[PERCENT_COMBO_COUNT];
    static HWND hwndPropChkBox[PERCENT_COMBO_COUNT];
    static TCHAR lpszRegPath[MAX_PATH];

    TCHAR lpszBuffer[6];
    TCHAR lpszMBoxTitle[25];
    TCHAR lpszMBoxError[90];
    LPHELPINFO lphi;
    int i, nPos;
    HWND hwndCtl;
    //
    // get a pointer to the NMHDR struct for apply button
    //
    lpnmhdr = (LPNMHDR) lParam;

    switch (nMsg) {

        case WM_NOTIFY:
            //
            // save settings
            //
            switch (lpnmhdr->code) {
                case PSN_KILLACTIVE:
                    SetWindowLongPtr(lpnmhdr->hwndFrom, DWLP_MSGRESULT, FALSE);
                    break;

                case PSN_HELP:
                    lphi = (LPHELPINFO) lParam;
                    WinHelp(lphi->hItemHandle,
                        g_lpszPath, HELP_CONTENTS, lphi->iCtrlId);
                    break;

                case PSN_APPLY:
                    SaveBitmapSettings(lpszRegPath);
                    break;
            }
            break;

        case WM_VSCROLL:

            hwndCtl = (HWND) (lParam);
            i = (int)GetWindowLongPtr(hwndCtl, GWLP_USERDATA);
            nPos = (int) SendMessage(hwndSliderDistProp[i], TBM_GETPOS, 0,0);
            GetWindowText(hwndSliderDistBuddy[i], lpszBuffer, 4);
            //
            // save cache size values to global data struct
            //
            g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue = _ttoi(lpszBuffer);
            //
            // display values in edit controls
            //
            _itot(10 * (11 - nPos), lpszBuffer, 10);
            SetWindowText(hwndSliderDistBuddy[i], lpszBuffer);
            break;

        case WM_HSCROLL:

            nPos = (int) SendMessage(hwndSliderNumCaches, TBM_GETPOS, 0,0);
                    _itot(nPos - 1, lpszBuffer, 10);
                    SetWindowText(hwndEditNumCaches, lpszBuffer);
            //
            // save values to global data struct (number caches)
            //
            g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue = nPos - 1;
            //
            // enable/disable check boxes and sliders
            //
            EnableControls(hDlg, hwndSliderDistProp,
                        hwndPropChkBox, hwndSliderDistBuddy,
                        hwndEditNumCaches, hwndSliderNumCaches,
                        PERCENT_COMBO_COUNT, lpszRegPath);
            break;

        case WM_INITDIALOG:

            LoadString (g_hInst, IDS_REG_PATH,
                lpszRegPath, sizeof (lpszRegPath));
            //
            // get handles
            //
            g_hwndShadowBitmapDlg = hDlg;
            hwndComboCacheSize = GetDlgItem(hDlg, IDC_COMBO_CACHE_SIZE);
            hwndSliderNumCaches = GetDlgItem(hDlg, IDC_SLD_NO_CACHES);
            hwndEditNumCaches = GetDlgItem(hDlg, IDC_TXT_NO_CACHES);
            //
            // set range on slider
            //
            SendMessage(hwndSliderNumCaches, TBM_SETRANGE, TRUE,
                    (LPARAM) MAKELONG(1, 6));

            for (i = 0; i < PERCENT_COMBO_COUNT; i++) {
                hwndSliderDistProp[i] = GetDlgItem(hDlg, IDC_SLD_DST_PROP_1 + i);
                hwndPropChkBox[i] = GetDlgItem(hDlg, IDC_CHK_CSH_1 + i);
                hwndSliderDistBuddy[i] = GetDlgItem(hDlg, IDC_TXT_DST_PROP_1 + i);
                //
                // save the index of the control
                //
                SetWindowLongPtr(hwndSliderDistProp[i], GWLP_USERDATA, i);
                SetWindowLongPtr(hwndSliderDistBuddy[i], GWLP_USERDATA, i);

                SendMessage(hwndSliderDistProp[i], TBM_SETRANGE, TRUE,
                        (LPARAM) MAKELONG(1, 11));

                //
                // get values for persistent caching check boxes
                //
                if (GetRegKey(NUM_CACHE_INDEX + i, lpszRegPath) == 0)
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + i].CurrentKeyValue =
                            g_KeyInfo[BM_PERSIST_BASE_INDEX +
                            i].DefaultKeyValue;
                else
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + i].CurrentKeyValue =
                            GetRegKeyValue(BM_PERSIST_BASE_INDEX + i);

                //
                // get values for sliders
                //
                if (GetRegKey(CACHEPROP1 + i, lpszRegPath) == 0)
                    g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue =
                            g_KeyInfo[CACHEPROP1 + i].DefaultKeyValue;
                else
                    g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue =
                            GetRegKeyValue(CACHEPROP1 + i);

                _itot(g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue,
                        lpszBuffer, 10);
                //
                // display the value in the static edit controls (dist prop.)
                //
                SetWindowText(hwndSliderDistBuddy[i], lpszBuffer);
                //
                // position the thumb on the slider control
                //
                nPos = g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue;
                SendMessage(hwndSliderDistProp[i], TBM_SETPOS, TRUE,
                        11 - nPos / 10);

            } // end for loop **************************************************


            //
            // get value from registry for number of enabled
            // check & slider controls
            //
            if (GetRegKey(NUM_CELL_CACHES_INDEX, lpszRegPath) == 0)
                g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue =
                        g_KeyInfo[NUM_CELL_CACHES_INDEX].DefaultKeyValue;
            else
                g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue =
                        GetRegKeyValue(NUM_CELL_CACHES_INDEX);
            //
            // show number of enabled caches in edit box
            //
            _itot(g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue,
                    lpszBuffer, 10);
            SetWindowText(hwndEditNumCaches, lpszBuffer);
            //
            // position the thumb on the slider control (num caches)
            //
            SendMessage(hwndSliderNumCaches, TBM_SETPOS, TRUE,
                    g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue + 1);
            //
            // enable/disable check boxes and sliders
            //
            EnableControls(hDlg, hwndSliderDistProp,
                        hwndPropChkBox, hwndSliderDistBuddy,
                        hwndEditNumCaches, hwndSliderNumCaches,
                        PERCENT_COMBO_COUNT, lpszRegPath);
            //
            // display text in cache size edit box from registry
            //
            g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                    (GetRegKeyValue(CACHESIZEINDEX));

            if ( (g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue <
                    MIN_BITMAP_CACHE_SIZE) ||
                    (g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue >
                    MAX_BITMAP_CACHE_SIZE)) {

                g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                        g_KeyInfo[CACHESIZEINDEX].DefaultKeyValue;
            }

            _itot( g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue,
                    lpszBuffer, 10);
            SetWindowText(hwndComboCacheSize, lpszBuffer);
            //
            // fill the cache size combo box list
            //
            SendMessage(hwndComboCacheSize, CB_ADDSTRING, 0,
                    (LPARAM) _itot(MIN_BITMAP_CACHE_SIZE, lpszBuffer, 10));

            for (i = CACHE_LIST_STEP_VAL;
                    i <= MAX_BITMAP_CACHE_SIZE;
                    i+= CACHE_LIST_STEP_VAL) {

                _itot(i, lpszBuffer, 10);
                SendMessage(hwndComboCacheSize, CB_ADDSTRING, 0,
                        (LPARAM) (LPCTSTR) lpszBuffer);
            } // ** end for loop

            //
            // limit cache size combo box to 4 characters
            //
            SendMessage(hwndComboCacheSize, CB_LIMITTEXT, 4, 0);
            break;

        case WM_HELP:

            lphi = (LPHELPINFO) lParam;

            WinHelp(lphi->hItemHandle,
                    g_lpszPath, HELP_CONTEXTPOPUP, lphi->iCtrlId);
            break;


        case WM_COMMAND:

        switch  LOWORD (wParam) {

            case IDC_BTN_RESTORE:

                for (i = 0; i < PERCENT_COMBO_COUNT; i++) {
                    _itot(g_KeyInfo[i + CACHEPROP1].DefaultKeyValue,
                            lpszBuffer, 10);
                    SetWindowText(hwndSliderDistProp[i], lpszBuffer);
                    g_KeyInfo[i + CACHEPROP1].CurrentKeyValue =
                            g_KeyInfo[i + CACHEPROP1].DefaultKeyValue;

                    g_KeyInfo[BM_PERSIST_BASE_INDEX + i].CurrentKeyValue =
                            g_KeyInfo[BM_PERSIST_BASE_INDEX +
                            i].DefaultKeyValue;
                }

                _itot(g_KeyInfo[CACHESIZEINDEX].DefaultKeyValue,
                            lpszBuffer, 10);
                SetWindowText(hwndComboCacheSize, lpszBuffer);
                g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                        g_KeyInfo[CACHESIZEINDEX].DefaultKeyValue;

                g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue =
                        g_KeyInfo[NUM_CELL_CACHES_INDEX].DefaultKeyValue;
            //
            // enable/disable check boxes and sliders
            //
            EnableControls(hDlg, hwndSliderDistProp,
                        hwndPropChkBox, hwndSliderDistBuddy,
                        hwndEditNumCaches, hwndSliderNumCaches,
                        PERCENT_COMBO_COUNT, lpszRegPath);
                break;

            case IDC_CHK_CSH_1:
                if(IsDlgButtonChecked(hDlg, IDC_CHK_CSH_1))
                    g_KeyInfo[BM_PERSIST_BASE_INDEX].CurrentKeyValue = 1;
                else
                    g_KeyInfo[BM_PERSIST_BASE_INDEX].CurrentKeyValue =
                        g_KeyInfo[BM_PERSIST_BASE_INDEX].DefaultKeyValue;
                break;
            case IDC_CHK_CSH_2:
                if(IsDlgButtonChecked(hDlg, IDC_CHK_CSH_2))
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 1].CurrentKeyValue = 1;
                else
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 1].CurrentKeyValue =
                        g_KeyInfo[BM_PERSIST_BASE_INDEX + 1].DefaultKeyValue;
                break;
            case IDC_CHK_CSH_3:
                if(IsDlgButtonChecked(hDlg, IDC_CHK_CSH_3))
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 2].CurrentKeyValue = 1;
                else
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 2].CurrentKeyValue =
                        g_KeyInfo[BM_PERSIST_BASE_INDEX + 2].DefaultKeyValue;
                break;
            case IDC_CHK_CSH_4:
                if(IsDlgButtonChecked(hDlg, IDC_CHK_CSH_4))
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 3].CurrentKeyValue = 1;
                else
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 3].CurrentKeyValue =
                        g_KeyInfo[BM_PERSIST_BASE_INDEX + 3].DefaultKeyValue;
                break;
            case IDC_CHK_CSH_5:
                if(IsDlgButtonChecked(hDlg, IDC_CHK_CSH_5))
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 4].CurrentKeyValue = 1;
                else
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 4].CurrentKeyValue =
                        g_KeyInfo[BM_PERSIST_BASE_INDEX + 4].DefaultKeyValue;
                break;
        }


        switch  HIWORD (wParam) {

            case CBN_SELCHANGE:
                //
                // get values for cache size
                //
                g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue = (DWORD)
                        SendMessage(hwndComboCacheSize, CB_GETCURSEL, 0, 0);

                SendMessage(hwndComboCacheSize, CB_GETLBTEXT,
                        g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue,
                        (LPARAM) (LPCSTR) lpszBuffer);
                g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                        _ttoi(lpszBuffer);
                break;


            case CBN_EDITUPDATE:

                GetWindowText(hwndComboCacheSize, lpszBuffer, 5);
                g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                        _ttoi(lpszBuffer);
                break;

            case CBN_KILLFOCUS:
                //
                // only allow values within acceptable range
                //
                GetWindowText(hwndComboCacheSize, lpszBuffer, 5);
                g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                        _ttoi(lpszBuffer);

                if ( (g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue <
                        MIN_BITMAP_CACHE_SIZE) ||
                        (g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue >
                        MAX_BITMAP_CACHE_SIZE) ) {
                    //
                    // display error if cache size is too big
                    //
                    LoadString (g_hInst,
                            IDS_BITMAP_CACHE,
                            lpszMBoxTitle,
                            sizeof (lpszMBoxTitle));

                    LoadString (g_hInst,
                            IDS_BMCACHE_ERROR,
                            lpszMBoxError,
                            sizeof (lpszMBoxError));

                    MessageBox(hDlg, lpszMBoxError,
                               lpszMBoxTitle,
                               MB_OK | MB_ICONEXCLAMATION);

                    _itot(g_KeyInfo[CACHESIZEINDEX].DefaultKeyValue,
                            lpszBuffer, 10);

                    SetWindowText(hwndComboCacheSize, lpszBuffer);

                    g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                            g_KeyInfo[CACHESIZEINDEX].DefaultKeyValue;

                }
                break;
        }
    }
    return FALSE;
}

// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsreg\tsreg.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  tsreg.c                                    **
**                                             **
**  Entry point for TSREG, WinMain.            **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <commctrl.h> 
#include <TCHAR.H>
#include "resource.h"
#include "tsreg.h"

HINSTANCE g_hInst;
TCHAR g_lpszPath[MAX_PATH];
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
        LPSTR lpCmdLine, int nCmdShow)
{
    TCHAR lpszRegPath[MAX_PATH];
    TCHAR lpszBuf[MAX_PATH];
    HKEY hKey;
    INITCOMMONCONTROLSEX  cmctl;
    TCHAR AppBasePath[MAX_PATH];
    int nPathLen;

    /************************************************************************/
    // Grab the app's executable path.
    // Note that the end backslash remains.
    /************************************************************************/
    nPathLen = GetModuleFileName(hInstance,
            AppBasePath, MAX_PATH);
    if (nPathLen > 0) {
        // Strip the module name off the end to leave the executable
        // directory path, by looking for the last backslash.
        nPathLen--;
        while (nPathLen != 0) {
            if (AppBasePath[nPathLen] != _T('\\')) {
                nPathLen--;
                continue;
            }
            nPathLen++;
            break;
        }
    }

    //
    // Check that the path is not too long to contain the base path
    //
    if (nPathLen + MAXKEYSIZE > MAX_PATH) {
        TCHAR lpszText[MAXTEXTSIZE];

        LoadString(hInstance, IDS_PATH_TOO_LONG, lpszText, MAXTEXTSIZE);

        MB(lpszText);
        nPathLen = 0;
    }
    
    AppBasePath[nPathLen] = '\0';

    //
    // Append the name of the help file to the app path and 
    // copy it to the global variable.
    //
    _tcscat(AppBasePath, TEXT("tsreg.hlp"));
    _tcscpy(g_lpszPath, AppBasePath);

    cmctl.dwICC = ICC_TAB_CLASSES | ICC_BAR_CLASSES;
    cmctl.dwSize = sizeof(INITCOMMONCONTROLSEX);
    InitCommonControlsEx(&cmctl);

    //
    // make sure Windows Terminal Server client is installed first.
    //
    LoadString (hInstance, IDS_PROFILE_PATH, lpszRegPath, sizeof (lpszRegPath)); 
    LoadString (hInstance, IDS_START_ERROR, lpszBuf, sizeof (lpszBuf)); 

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszRegPath, 0,
            KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) {

            MessageBox(NULL, lpszBuf,
                       NULL,
                       MB_OK | MB_ICONEXCLAMATION);
        RegCloseKey(hKey);
        return 1;
    }


#ifdef USE_STRING_TABLE
    {
        int i;

        //
        // load string table values into g_KeyInfo data structure
        //
        for (i = KEYSTART; i < (KEYEND + 1); i++) {
                LoadString (hInstance, i, 
                        g_KeyInfo[i - KEYSTART].Key, 
                        sizeof (g_KeyInfo[i - KEYSTART].Key)); 
        }
    }

#endif

    g_hInst = hInstance;
    CreatePropertySheet(NULL);

    return 0;  
                                                 
}

// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsreg\tsreg.h ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  tsreg.h                                    **
**                                             **
**  Project definitions for TSREG.             **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/


// Defines
#define SHADOWINDEX 0
#define DEDICATEDINDEX 1
#define CACHESIZEINDEX 2
#define GLYPHCACHEBASE 3
#define CACHEPROP1 13
#define CACHEPROP2 14
#define CACHEPROP3 15
#define CACHEPROP4 16
#define CACHEPROP5 17
#define NUM_CACHE_INDEX 22
#define TEXTFRAGINDEX 18
#define GLYPHINDEX 19
#define ORDERINDEX 20

#define MAXTEXTFRAGSIZE 256
#define NUMBER_OF_SLIDERS 10
#define MIN_GLYPH_CACHE_SIZE 4
#define MAX_GLYPH_CACHE_SIZE 512
#define MAX_ORDER_DRAW_VAL 65535
#define MIN_ORDER_DRAW_VAL 0
#define MIN_BITMAP_CACHE_SIZE 150
#define MAX_BITMAP_CACHE_SIZE 4500
#define MAX_MESSAGE_LEN 100
#define CACHE_LIST_STEP_VAL 500
#define PERCENT_COMBO_COUNT 5
#define NUM_SLIDER_STOPS 8
#define NUM_CELL_CACHES_INDEX 21
#define BM_PERSIST_BASE_INDEX 22

#define FULL 2
#define PARTIAL 1
#define NONE 0

#define PAGECOUNT 4

#define MAXTEXTSIZE 1024

//
// constants for g_KeyInfo
//
#define KEYSTART 6  // constants for using string table
#define KEYEND 32   // to load key names.

#define KEYCOUNT 27 // total number of keys per profile
#define MAXKEYSIZE 120

// Foreground window lock timeout default value
#define LOCK_TIMEOUT 200000

//
// un-comment if you want to use string table for key names
//
// #define USE_STRING_TABLE 1

/////////////////////////// Quick MessageBox Macro ////////////////////////////
#define DIMOF(Array) (sizeof(Array) / sizeof(Array[0]))
#define MB(s) {                                                      \
        TCHAR szTMP[128];                                            \
        GetModuleFileName(NULL, szTMP, DIMOF(szTMP));                \
        MessageBox(GetActiveWindow(), s, szTMP, MB_OK);              \
}

// Types
typedef struct _KeyInfo
{
    TCHAR Key[MAXKEYSIZE];
    DWORD DefaultKeyValue;
    DWORD CurrentKeyValue;
    TCHAR KeyPath[MAX_PATH];
} KEY_INFO;

typedef struct _ProfileKeyInfo
{
    struct _ProfileKeyInfo *Next;
    KEY_INFO KeyInfo[KEYCOUNT];
    int Index;
} PROFILE_KEY_INFO;


// Externs
extern KEY_INFO g_KeyInfo[KEYCOUNT];
extern HINSTANCE g_hInst;
extern TCHAR g_lpszPath[MAX_PATH];
extern TCHAR g_lpszClientProfilePath[MAX_PATH];

extern HWND g_hwndShadowBitmapDlg;
extern HWND g_hwndGlyphCacheDlg;
extern HWND g_hwndMiscDlg;
extern HWND g_hwndProfilesDlg;


extern PROFILE_KEY_INFO *g_pkfProfile;
extern PROFILE_KEY_INFO *g_pkfStart;

extern TCHAR lpszTimoutPath[MAX_PATH];
extern TCHAR lpszTimeoutKey[MAX_PATH];

// Prototypes
INT_PTR CALLBACK ShadowBitmap(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK GlyphCache(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK Miscellaneous(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ProfilePage(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK SaveDialog(HWND, UINT, WPARAM, LPARAM);

INT_PTR CreatePropertySheet(HWND);
void DeleteRegKey(int, TCHAR lpszRegPath[MAX_PATH]);
void SetRegKey(int, TCHAR lpszRegPath[MAX_PATH]);
void WriteBlankKey(TCHAR lpszRegPath[MAX_PATH]);
int  GetRegKey(int, TCHAR lpszRegPath[MAX_PATH]);
void SaveSettings(HWND, int, int, int, TCHAR lpszRegPath[MAX_PATH]);
void RestoreSettings(HWND, int, int, int, TCHAR lpszRegPath[MAX_PATH]);
BOOL SaveBitmapSettings(TCHAR lpszRegPath[MAX_PATH]);
int GetRegKeyValue(int);
void InitMiscControls(HWND, HWND);
int GetCellSize(int, int);
void GetClientProfileNames(TCHAR lpszClientProfilePath[]);
void SetControlValues();
void LoadKeyValues();
void ReadRecordIn(TCHAR lpszBuffer[]);
void WriteRecordOut(TCHAR lpszBuffer[]);
void ReloadKeys(TCHAR lpszBuffer[], HWND hwndProfilesCBO);
void ResetTitle(TCHAR lpszBuffer[]);
void SetEditCell(TCHAR lpszBuffer[],
                 HWND hwndProfilesCBO);
void DisplayControlValue(HWND hwndSlider[],
            HWND hwndSliderEditBuddy[],  int i);

int GetKeyVal(TCHAR lpszRegPath[MAX_PATH],
			TCHAR lpszKeyName[MAX_PATH]);

void SetRegKeyVal(TCHAR lpszRegPath[MAX_PATH],
			TCHAR lpszKeyName[MAX_PATH],
	 		int nKeyValue);	

void EnableControls(HWND hDlg,
            HWND hwndSliderDistProp[],
            HWND hwndPropChkBox[],
            HWND hwndSliderDistBuddy[],
            HWND hwndEditNumCaches,
            HWND hwndSliderNumCaches,
            int nNumCellCaches,
            TCHAR lpszRegPath[]);

// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsver\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TsVsm.rc
//
#define IDS_STRING1                     1
#define IDS_SPACE                       1
#define IDS_DEFAULT1                    2
#define IDS_DEFAULT2                    3
#define IDS_DEFAULT3                    4
#define IDS_DEFAULT4                    5
#define IDS_MSG_TITLE                   6
#define IDS_REG_KEY_PATH                7
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsver\exe\checkingpage.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    CheckingPage.cpp

Abstract:

    Functions for "Version Checking" page of the wizard.
Author:

    Sergey Kuzin (a-skuzin@microsoft.com) 09-August-1999

Environment:


Revision History:


--*/

#include "tsverui.h"
#include "resource.h"


/*++

Routine Description :

    dialog box procedure for the "Constraints" page.

Arguments :

    IN HWND hwndDlg    - handle to dialog box.
    IN UINT uMsg       - message to be acted upon.
    IN WPARAM wParam   - value specific to wMsg.
    IN LPARAM lParam   - value specific to wMsg.

Return Value :

    TRUE if it processed the message
    FALSE if it did not.

--*/
INT_PTR CALLBACK
CheckingPageProc (
          HWND hwndDlg,
          UINT uMsg,
          WPARAM wParam,
          LPARAM lParam)
{

	//Retrieve the shared user data from GWL_USERDATA

	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			//Get the shared data from PROPSHEETPAGE lParam value
			//and load it into GWL_USERDATA

			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (DWORD_PTR) pdata);

            if (CheckForRegKey(HKEY_LOCAL_MACHINE, szKeyPath, KeyName[DLLNAME]))
            {
                CheckRadioButton(hwndDlg,IDC_ENABLE_CHECKING,IDC_DISABLE_CHECKING,
                    IDC_ENABLE_CHECKING);
            } else {
                CheckRadioButton(hwndDlg,IDC_ENABLE_CHECKING,IDC_DISABLE_CHECKING,
                    IDC_DISABLE_CHECKING);
            }

			break;
		}

	case WM_NOTIFY :
		{
		LPNMHDR lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
			{
			case PSN_SETACTIVE : //Enable the Next button	
                if(pdata->bNoWellcome){
                    PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_NEXT );
                }else{
				    PropSheet_SetWizButtons( GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT );
                }
				break;

			case PSN_WIZNEXT :
				//Handle a Next button click here
                if (IsDlgButtonChecked(hwndDlg, IDC_ENABLE_CHECKING)==BST_CHECKED){

                    pdata->bCheckingEnabled=TRUE;

                } else { // delete all the keys

                   SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_FINISH);
                   pdata->bCheckingEnabled=FALSE;
                   return TRUE;
                }
				break;

			case PSN_RESET :
				//Handle a Cancel button click, if necessary
				break;


			default :
				break;
			}
		}
		break;

	default:
		break;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsver\dll\tsvsm.cpp ===
/*-----------------------------------------------**
**  Copyright (c) 1999 Microsoft Corporation     **
**            All Rights reserved                **
**                                               **
**  tsvsm.cpp                                    **
**                                               **
**  Main for TsVer.dll                           **
**                                               **
**  06-25-99 a-clindh Created                    **
**-----------------------------------------------*/

#include "tsvsm.h"


WINSTATIONCLIENT    ClientData;
int                 g_count;
HINSTANCE           g_hInst;
TCHAR               szWinStaKey[MAX_PATH];
//////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,  // handle to DLL module
    DWORD fdwReason,     // reason for calling function
    LPVOID lpReserved )  // reserved
{

    // Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}

//////////////////////////////////////////////////////////////////////////////
VOID TsVerEventStartup (PWLX_NOTIFICATION_INFO pInfo)
{
    CheckClientVersion();
}

//////////////////////////////////////////////////////////////////////////////
int CheckClientVersion(void)
//VOID CheckClientVersion (PWLX_NOTIFICATION_INFO pInfo)
{
    DWORD               pBytesReturned;
    OSVERSIONINFO       osvi;
    ULONG               *pNumber;
    TCHAR               szNewRegistryString[MAX_LEN];
    TCHAR               tmp[MAX_PATH];

    TCHAR               szConstraints[MAX_LEN];
    UINT i;
    BOOL b1 = FALSE, b2 = FALSE, b3 = FALSE, b4 = FALSE;

    // Get the handle to the dll
    g_hInst = GetModuleHandle(TEXT("tsver"));

    // path to the registry keys
    LoadString (g_hInst, IDS_REG_KEY_PATH, 
         szWinStaKey, sizeof (szWinStaKey));

    // if NO "Constraints" registry key value is there, write one
    if (! CheckForRegKey(HKEY_USERS, szWinStaKey, KeyName[CONSTRAINTS])) 
    {
        // String to allow everyone on.  Only write this if
        // there is no key present.

        // Get the current version
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx (&osvi);
        _tcscpy(szNewRegistryString, TEXT("(0:"));
        _itot(++osvi.dwBuildNumber, tmp, 10);
        _tcscat(szNewRegistryString, tmp);
        _tcscat(szNewRegistryString, TEXT(")"));

        // write the range from 0 to the current build + 1
        szNewRegistryString[_tcslen(szNewRegistryString)] = '\0';
        SetRegKeyString(HKEY_USERS, szNewRegistryString, 
                        szWinStaKey, KeyName[CONSTRAINTS]);
    }

    if (GetSystemMetrics(SM_REMOTESESSION))

    {
        if (WTSQuerySessionInformation(
                            WTS_CURRENT_SERVER_HANDLE,
                            GetCurrentLogonId(),
                            WTSClientBuildNumber,
                            (LPTSTR *)(&pNumber),
                            &pBytesReturned))

        {
        WinStationQueryInformation( 
                        WTS_CURRENT_SERVER_HANDLE,
                        GetCurrentLogonId(),
                        WinStationClient,
                        &ClientData,
                        sizeof(WINSTATIONCLIENT),
                        &pBytesReturned );
                    
        // let me on if:
        // =  Can be more than 1 entry, client build must equal this number.
        // <  Can only be 1 entry.  ANY build less than this number.
        // >  Can only be 1 entry.  ANY build greater than this number.
        // != Can be more than 1 entry, client build can't equal this number.
        // (####:####) Can be more than 1 entry.
        //             If client build is within this range.
        // ;  separator (semicolon)
        // "=419,2054,2070;(9000:9050);(2063:2070)"

            // get the constraints string from the registry
            _tcscpy(szConstraints, GetRegString(HKEY_USERS,
                    szWinStaKey, KeyName[CONSTRAINTS]));
            for (i = 0; i < _tcslen(szConstraints); i++) 
            {
                switch (szConstraints[i])
                {

                    case '=':
                    {
                        g_count = 0;
                        // skip the case where the = sign follows a !
                        if (szConstraints[i-1] != '!')
                            if (ParseNumberFromString(i, 
                                                      szConstraints,
                                                      *pNumber))
                            {
                                b1 = TRUE;
                            } else {
                                b1 = FALSE;
                            }
                    }
                    break;
                    
                    case '<':
                    {
                        g_count = 0;
                        if (LessThan(i, 
                                     szConstraints,
                                     *pNumber))
                            {
                                b2 = TRUE;
                            } else {
                                b2 = FALSE;
                            }
                    }
                    break;
                    
                    case '>':
                    {
                        g_count = 0;
                        if (GreaterThan(i, 
                                        szConstraints,
                                        *pNumber))
                            {
                                b3 = TRUE;
                            } else {
                                b3 = FALSE;
                            }
                    }
                    break;
                    
                    case '!':
                    {
                        g_count = 0;
                        i++; // increment past the = sign
                        if (ParseNumberFromString(i, 
                                                  szConstraints,
                                                  *pNumber))
                        {
                            // if we find this number we can just
                            // kick the user off.
                            KickMeOff(*pNumber);
                            WTSFreeMemory(pNumber);
                            return 0;
                        }
                    }
                    break;
                    
                    case '(':
                    {
                        g_count = 0;
                        if (ParseRangeFromString(i, 
                                                 szConstraints,
                                                 *pNumber))
                            {
                                b4 = TRUE;
                            } else {
                                b4 = FALSE;
                            }
                    }
                    break;
                        
                    default:
                        break;
                }
            }
        }
    }
    // if the user hasn't passed at least one of our constraints
    // then kick them off.
    if (GetSystemMetrics(SM_REMOTESESSION))// so we can run the first time
                                           // to initially write the registry
                                           // keys without getting a warning

        if (!b1 && !b2 && !b3 && !b4) 
            KickMeOff(*pNumber);

    WTSFreeMemory(pNumber);
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
void KickMeOff(ULONG pNumber)
{
    TCHAR  szClientNumber[10];
    TCHAR  szServerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD  pResponse = sizeof(szServerName) / sizeof(TCHAR) - 1;
    TCHAR  pTitle[MAX_LEN];
    TCHAR  pMessage[MAX_LEN];
    TCHAR szStringBuf[MAX_LEN];
    LPTSTR sz;

    LoadString (g_hInst, IDS_MSG_TITLE, 
         pTitle, sizeof (pTitle));

    _itot(pNumber, szClientNumber, 10);
    
    GetComputerName(szServerName, &pResponse);
    
    _tcscpy(pMessage, ClientData.ClientAddress);

    LoadString (g_hInst, IDS_SPACE, 
         szStringBuf, sizeof (szStringBuf));

    _tcscat(pMessage,  szStringBuf);
    _tcscat(pMessage,  ClientData.ClientName);
    _tcscat(pMessage,  szStringBuf);

    // custom message
    if (CheckForRegKey(HKEY_USERS, szWinStaKey,
                       KeyName[USE_MSG]))
    {
        sz = GetRegString(HKEY_USERS, szWinStaKey, KeyName[MSG]);
        if(sz)
        {
            _tcscat(pMessage,  sz);
            sz = GetRegString(HKEY_USERS, szWinStaKey, KeyName[MSG_TITLE]);
            if(sz)
            {
                _tcscpy(pTitle,  sz);
            }
        }
    }
    else
    {
        LoadString (g_hInst, IDS_DEFAULT1, 
             szStringBuf, sizeof (szStringBuf));
        _tcscat(pMessage,  szStringBuf);
        _tcscat(pMessage, szServerName);
        LoadString (g_hInst, IDS_DEFAULT2, 
             szStringBuf, sizeof (szStringBuf));
        _tcscat(pMessage, szStringBuf);
        _tcscat(pMessage, szClientNumber);
        LoadString (g_hInst, IDS_DEFAULT3, 
             szStringBuf, sizeof (szStringBuf));
        _tcscat(pMessage, szStringBuf);
        _tcscat(pMessage, szServerName);
        LoadString (g_hInst, IDS_DEFAULT4, 
             szStringBuf, sizeof (szStringBuf));
        _tcscat(pMessage, szStringBuf);
    }
    WTSSendMessage(
                WTS_CURRENT_SERVER_HANDLE,
                GetCurrentLogonId(),
                pTitle,
                sizeof(pTitle),
                pMessage,
                sizeof(pMessage),
                MB_OK | MB_ICONSTOP,
                30,
                &pResponse,
                TRUE);

    ExitProcess(0);
}

//////////////////////////////////////////////////////////////////////////////
BOOL ParseNumberFromString(UINT i, TCHAR *szConstraints, 
                           ULONG pNumber)
{
    int index;
    TCHAR szNumber[10];


    // parse a number out of the registry string
    index = 0;
    while (szConstraints[i+1] == 32) i++; //strip out any leading spaces
    while (szConstraints[i + 1] >= 48 && 
                szConstraints[i + 1] <= 57)
    {
        szNumber[index] = szConstraints[i + 1];
        i++;
        index++;
    }
    szNumber[index] = '\0';

    if (pNumber == (ULONG)_ttol(szNumber)) g_count++;

    // if there's more than one in the "equal" list,
    // execute the while loop again
    if (szConstraints[i+1] == ',') 
    {
        i++;
        index = 0;
        for (int j = 0; j < 10; j++)
            szNumber[j] = '\0';
        ParseNumberFromString(i, szConstraints, pNumber);
    }

    // return TRUE if the user's build matches one in the registry.
    if (g_count > 0)
    {
        return TRUE;
    } else {
        return FALSE;
    }
}

//////////////////////////////////////////////////////////////////////////////
BOOL ParseRangeFromString(UINT i, TCHAR *szConstraints, 
                           ULONG pNumber)
{
    int index;
    TCHAR szNumber1[10];
    TCHAR szNumber2[10];

    // parse the first number out of the registry string
    index = 0;
    while (szConstraints[i + 1] >= 48 && 
                szConstraints[i + 1] <= 57)
    {
        szNumber1[index] = szConstraints[i + 1];
        i++;
        index++;
    }
    szNumber1[index] = '\0';

    // parse the second number out of the registry string
    i++; // increment past the : symbol
    index = 0;
    while (szConstraints[i+1] >= 48 && 
                szConstraints[i+1] <= 57)
    {
        szNumber2[index] = szConstraints[i+1];
        i++;
        index++;
    }
    szNumber2[index] = '\0';

    if (pNumber >= (ULONG)_ttol(szNumber1) &&
            pNumber <= (ULONG)_ttol(szNumber2)) g_count++;

    // return TRUE if the user's build is within our range.
    if (g_count > 0)
    {
        return TRUE;
    } else {
        return FALSE;
    }
}

//////////////////////////////////////////////////////////////////////////////
BOOL GreaterThan(UINT i, TCHAR *szConstraints, 
                           ULONG pNumber)
{
    int index;
    TCHAR szNumber[10];


    // parse a number out of the registry string
    index = 0;
    while (szConstraints[i + 1] >= 48 && 
                szConstraints[i + 1] <= 57)
    {
        szNumber[index] = szConstraints[i + 1];
        i++;
        index++;
    }
    szNumber[index] = '\0';

    if (pNumber > (ULONG)_ttol(szNumber)) g_count++;

    // return TRUE if the user's build matches one in the registry.
    if (g_count > 0)
    {
        return TRUE;
    } else {
        return FALSE;
    }
}
//////////////////////////////////////////////////////////////////////////////

BOOL LessThan(UINT i, TCHAR *szConstraints, 
                           ULONG pNumber)
{
    int index;
    TCHAR szNumber[10];


    // parse a number out of the registry string
    index = 0;
    while (szConstraints[i + 1] >= 48 && 
                szConstraints[i + 1] <= 57)
    {
        szNumber[index] = szConstraints[i + 1];
        i++;
        index++;
    }
    szNumber[index] = '\0';

    if (pNumber < (ULONG)_ttol(szNumber)) g_count++;

    // return TRUE if the user's build matches one in the registry.
    if (g_count > 0)
    {
        return TRUE;
    } else {
        return FALSE;
    }
}
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsver\dll\reg.cpp ===
/*-----------------------------------------------**
**  Copyright (c) 1999 Microsoft Corporation     **
**            All Rights reserved                **
**                                               **
**  reg.cpp                                      **
**                                               **
**  Functions for reading, writing, and deleting **
**  registry keys                                **
**  07-01-99 a-clindh Created                    **
**-----------------------------------------------*/

/*
void    SetRegKey       (HKEY root, TCHAR *szKeyPath, 
                         TCHAR *szKeyName, BYTE nKeyValue);
void    DeleteRegKey    (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
BOOL    CheckForRegKey  (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
int     GetRegKeyValue  (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
TCHAR * GetRegString    (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
BOOL    SetRegKeyString (HKEY root, TCHAR *szRegString, 
                         TCHAR *szKeyPath, TCHAR *szKeyName);

registry keys used:

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\
Notify\tsver\Asynchronous  REG_DWORD   = 0

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\
Notify\tsver\DllName       REG_SZ      = tsver.dll

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\
Notify\tsver\Impersonate   REG_DWORD   = 0

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\
Notify\tsver\Startup       REG_SZ      = TsVerEventStartup


HKEY_USERS\.DEFAULT\Software\Microsoft\Windows NT\CurrentVersion\TsVer\
Constraints

*/

#include "TsVsm.h"

TCHAR *KeyName[] = {"Constraints", "StartTsVer", "MsgEnabled", "Title", "Message"};
TCHAR sRegistryKeyReturnValue[MAX_LEN];
///////////////////////////////////////////////////////////////////////////////
// Saves a numeric value in the registry
//
// SetRegKey(i, KeyValue);
// i is the index of the KeyName variable
// nKeyValue is the value we want to store.
//
// TCHAR *KeyName[] = {"Constraints"};
// const TCHAR szWinStaKey[] = 
//        {"Software\\Microsoft\\Windows NT\\CurrentVersion\\TsVer"};
///////////////////////////////////////////////////////////////////////////////
void SetRegKey(HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName, BYTE nKeyValue)
{
    HKEY hKey;  
    DWORD dwDisposition;
    
    if (RegCreateKeyEx(root, szKeyPath,
            0, "REG_DWORD", REG_OPTION_NON_VOLATILE, 
            KEY_ALL_ACCESS, 0, &hKey, &dwDisposition)
            == ERROR_SUCCESS) { 
    //
    // write the key value to the registry
    //
    RegSetValueEx(hKey, szKeyName, 0, REG_DWORD,
            &nKeyValue,
            sizeof(DWORD)); 
    RegCloseKey(hKey);
    }

}

//////////////////////////////////////////////////////////////////////////////
// Deletes the specified registry key.
//
//////////////////////////////////////////////////////////////////////////////
void DeleteRegKey(HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName)
{
    HKEY hKey;

    if (RegOpenKeyEx(root, szKeyPath, 0,
            KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    {
        RegDeleteValue(hKey, szKeyName);
        RegCloseKey(hKey);
    }
}

//////////////////////////////////////////////////////////////////////////////
// returns TRUE if the registry key is there and FALSE if it isn't
//
// TCHAR *KeyName[] = {"Constraints"};
// TCHAR szWinStaKey[] = 
//        {"Software\\Microsoft\\Windows NT\\CurrentVersion\\TsVer"};
//////////////////////////////////////////////////////////////////////////////
BOOL CheckForRegKey(HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName)
{
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;

    dwType = REG_SZ;
    dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(root, szKeyPath, 0,
                KEY_READ, &hKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hKey, szKeyName, 0,
                &dwType, NULL,
                &dwSize) == ERROR_SUCCESS) {

            RegCloseKey(hKey);
            return TRUE;
        }
        RegCloseKey(hKey); 
    }
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// pass the index of the KeyName variable and the function
// returns the value stored in the registry
// TCHAR *KeyName[] = {"Constraints"};
//////////////////////////////////////////////////////////////////////////////
int GetRegKeyValue(HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName)
{
    int nKeyValue;
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;

    dwType = REG_SZ;
    dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(root, szKeyPath, 0,
                KEY_READ, &hKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hKey, szKeyName, 0,
                &dwType, (LPBYTE) &nKeyValue,
                &dwSize) == ERROR_SUCCESS) {

            RegCloseKey(hKey);
            return nKeyValue;
        }
        RegCloseKey(hKey);
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// returns a string if it succeeds or NULL if it fails
//
// TCHAR *KeyName[] = {"Constraints"};
// #define CONSTRAINTS     0
// #define MAX_LEN         1024
// TCHAR sRegistryKeyReturnValue[MAX_LEN];
// GetRegString(CONSTRAINTS);
// const TCHAR szWinStaKey[] = 
//        {"Software\\Microsoft\\Windows NT\\CurrentVersion\\TsVer"};
//
//////////////////////////////////////////////////////////////////////////////
TCHAR * GetRegString(HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName)
{
    // sRegistryKeyReturnValue needs to ba a global variable otherwise
    // it will go out of scope when the function returns
    
    HKEY hKey = 0;
    DWORD  dwType = REG_SZ;
    DWORD  dwSize = sizeof(sRegistryKeyReturnValue);

    if (RegOpenKeyEx(root, szKeyPath, 0, 
                     KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey, szKeyName, 0, &dwType, 
                    (LPBYTE) &sRegistryKeyReturnValue, 
                    &dwSize) == ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            return sRegistryKeyReturnValue; 
        }
    }
    return '\0';
}

//////////////////////////////////////////////////////////////////////////////
// returns TRUE if success, returns FAIL otherwise
//
// TCHAR szNewRegistryString[] = "the rain in spain falls, mainly";
// TCHAR *KeyName[] = {"Constraints", "StartTsVer"};
// #define CONSTRAINTS     0
// #define MAX_LEN         1024
// SetRegKeyString(szNewRegistryString, 
//                 szWinStaKey, KeyName[CONSTRAINTS]);
//////////////////////////////////////////////////////////////////////////////
BOOL SetRegKeyString(HKEY root, TCHAR *szRegString, 
                     TCHAR *szKeyPath, TCHAR *szKeyName)
{
    HKEY hKey;  
    DWORD dwDisposition;
    TCHAR lpszKeyType[] = "REG_SZ";


    if (RegCreateKeyEx(root, szKeyPath,
            0, lpszKeyType, REG_OPTION_NON_VOLATILE, 
            KEY_ALL_ACCESS, 0, &hKey, &dwDisposition)
            == ERROR_SUCCESS) { 

        //
        // write the key value to the registry
        //
        RegSetValueEx(hKey, szKeyName, 0, REG_SZ,
                      (BYTE*)szRegString,
                      _tcslen(szRegString)); 

        RegCloseKey(hKey);
        return TRUE;
    } else {
        return FALSE;
    }
}

//////////////////////////////////////////////////////////////////////////////
int CDECL MB(TCHAR *szCaption, TCHAR *szFormat, ...)
{
    TCHAR szBuffer[1024];
    va_list pArgList;

    va_start(pArgList, szFormat);
    _vsntprintf(szBuffer, sizeof(szBuffer) / sizeof(TCHAR),
                szFormat, pArgList);

    va_end(pArgList);
    return MessageBox(NULL, szBuffer, szCaption, MB_OK | MB_ICONSTOP);

}
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsver\dll\tsvsm.h ===
/*-----------------------------------------------**
**  Copyright (c) 1999 Microsoft Corporation     **
**            All Rights reserved                **
**                                               **
**  tsvsm.h                                      **
**                                               **
**                                               **
**                                               **
**  06-25-99 a-clindh Created                    **
**-----------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <TCHAR.h>
#include <Wtsapi32.h>
#include <winuser.h>
#include <winsta.h>
#include <winwlx.h>
#include <utilsub.h>
#include "resource.h"

extern          TCHAR szWinStaKey[];
extern          TCHAR *KeyName[];

#define CONSTRAINTS         0
#define RUNKEY              1
#define USE_MSG             2
#define MSG_TITLE           3
#define MSG                 4


#define MAX_LEN             1024

void    SetRegKey       (HKEY root, TCHAR *szKeyPath, 
                         TCHAR *szKeyName, BYTE nKeyValue);
void    DeleteRegKey    (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
BOOL    CheckForRegKey  (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
int     GetRegKeyValue  (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
TCHAR * GetRegString    (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
BOOL    SetRegKeyString (HKEY root, TCHAR *szRegString, 
                         TCHAR *szKeyPath, TCHAR *szKeyName);

void KickMeOff(ULONG pNumber);


BOOL ParseNumberFromString(UINT i, TCHAR *szConstraints, 
                           ULONG pNumber);
                           
BOOL ParseRangeFromString(UINT i, TCHAR *szConstraints, 
                           ULONG pNumber);

BOOL GreaterThan(UINT i, TCHAR *szConstraints, 
                           ULONG pNumber);

BOOL LessThan(UINT i, TCHAR *szConstraints, 
                           ULONG pNumber);

VOID TsVerEventStartup (PWLX_NOTIFICATION_INFO pInfo);
int CheckClientVersion(void);
int CDECL   MB(TCHAR *szCaption, TCHAR *szFormat, ...);
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsver\exe\messagepage.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    MessagePage.cpp

Abstract:

    Functions for "Message" page of the wizard.
Author:

    Sergey Kuzin (a-skuzin@microsoft.com) 09-August-1999

Environment:


Revision History:


--*/

#include "tsverui.h"
#include "resource.h"

#define MAX_TITLE_LEN 32

void OnNext(HWND hwndDlg, LPSHAREDWIZDATA pdata);

/*++

Routine Description :

    dialog box procedure for the "Message" page.

Arguments :

    IN HWND hwndDlg    - handle to dialog box.
    IN UINT uMsg       - message to be acted upon.
    IN WPARAM wParam   - value specific to wMsg.
    IN LPARAM lParam   - value specific to wMsg.

Return Value :

    TRUE if it processed the message
    FALSE if it did not.

--*/
INT_PTR CALLBACK
MessagePageProc (
      HWND hwndDlg,
      UINT uMsg,
      WPARAM wParam,
      LPARAM lParam)
{

    static HWND hwndFrame=NULL;              //  IDC_STATIC_FRAME
    static HWND hwndStaticTitle=NULL;        //  IDC_STATIC_TITLE
    static HWND hwndEditTitle=NULL;          //  IDC_EDIT_TITLE
    static HWND hwndStaticMsg=NULL;          //  IDC_STATIC_MSG
    static HWND hwndEditMsg=NULL;            //  IDC_EDIT_MSG

    //Retrieve the shared user data from GWL_USERDATA
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			//Get the shared data from PROPSHEETPAGE lParam value
			//and load it into GWL_USERDATA

			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;

			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (DWORD_PTR) pdata);

            //get control handlers

            hwndFrame             = GetDlgItem(hwndDlg, IDC_STATIC_FRAME);
            hwndStaticTitle       = GetDlgItem(hwndDlg, IDC_STATIC_TITLE);
            hwndEditTitle         = GetDlgItem(hwndDlg, IDC_EDIT_TITLE);
            hwndStaticMsg         = GetDlgItem(hwndDlg, IDC_STATIC_MSG);
            hwndEditMsg           = GetDlgItem(hwndDlg, IDC_EDIT_MSG);

            // controls for custom message
            if (CheckForRegKey(HKEY_USERS, szConstraintsKeyPath,KeyName[USE_MSG]))
            {
                EnableWindow(hwndFrame, TRUE);
                EnableWindow(hwndStaticTitle, TRUE);
                EnableWindow(hwndEditTitle, TRUE);
                EnableWindow(hwndStaticMsg, TRUE);
                EnableWindow(hwndEditMsg, TRUE);
                CheckDlgButton(hwndDlg, IDC_ENABLE_MSG, TRUE);
            } else {
                CheckDlgButton(hwndDlg, IDC_ENABLE_MSG, FALSE);
                EnableWindow(hwndFrame, FALSE);
                EnableWindow(hwndStaticTitle, FALSE);
                EnableWindow(hwndEditTitle, FALSE);
                EnableWindow(hwndStaticMsg, FALSE);
                EnableWindow(hwndEditMsg, FALSE);
            }
            LPTSTR szBuf=NULL;
            szBuf=GetRegString(HKEY_USERS, szConstraintsKeyPath, KeyName[MSG]);
            if(szBuf){
                SetWindowText(hwndEditMsg,szBuf);
                delete szBuf;
                szBuf=NULL;
            }
            szBuf=GetRegString(HKEY_USERS, szConstraintsKeyPath, KeyName[MSG_TITLE]);
            if(szBuf){
                SetWindowText(hwndEditTitle,szBuf);
                delete szBuf;
                szBuf=NULL;
            }
			
			break;
		}


	case WM_NOTIFY :
		{
		LPNMHDR lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
			{
			case PSN_SETACTIVE : //Enable the Next button	
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                if(pdata->pszMessageTitle){
                    delete pdata->pszMessageTitle;
                    pdata->pszMessageTitle=NULL;
                }
                if(pdata->pszMessageText){
                    delete pdata->pszMessageText;
                    pdata->pszMessageText=NULL;
                }
				break;

			case PSN_WIZNEXT :
				//Handle a Next button click here
                OnNext(hwndDlg, pdata);
				break;

			case PSN_RESET :
				//Handle a Cancel button click, if necessary
				break;


			default :
				break;
			}
		}
		break;

    case WM_COMMAND:
        switch ( LOWORD(wParam) ) {
            case IDC_ENABLE_MSG:
                if (IsDlgButtonChecked(hwndDlg, IDC_ENABLE_MSG)){

                    EnableWindow(hwndFrame, TRUE);
                    EnableWindow(hwndStaticTitle, TRUE);
                    EnableWindow(hwndEditTitle, TRUE);
                    EnableWindow(hwndStaticMsg, TRUE);
                    EnableWindow(hwndEditMsg, TRUE);
                } else {

                    EnableWindow(hwndFrame, FALSE);
                    EnableWindow(hwndStaticTitle, FALSE);
                    EnableWindow(hwndEditTitle, FALSE);
                    EnableWindow(hwndStaticMsg, FALSE);
                    EnableWindow(hwndEditMsg, FALSE);
                }
                break;

            default:
                break;
        }
        break;

	default:
		break;
	}
	return FALSE;
}

/*++

Routine Description :

    Fills data structure with values from controls.

Arguments :

    IN HWND hwndDlg - Page handle.
    LPSHAREDWIZDATA pdata - pointer to data structure

Return Value :

    none

--*/
void OnNext(HWND hwndDlg, LPSHAREDWIZDATA pdata)
{
    if(IsDlgButtonChecked(hwndDlg, IDC_ENABLE_MSG)==BST_CHECKED){
        pdata->bMessageEnabled=TRUE;
    }else{
        pdata->bMessageEnabled=FALSE;
    }

    TCHAR szBuf[MAX_LEN+1];
    int Size;

    Size=GetDlgItemText(hwndDlg, IDC_EDIT_TITLE, szBuf, MAX_LEN);
    if (Size){
        pdata->pszMessageTitle=new TCHAR[Size+1];
        if (pdata->pszMessageTitle != NULL) {
            _tcscpy(pdata->pszMessageTitle,szBuf);
        }
    }

    Size=GetDlgItemText(hwndDlg, IDC_EDIT_MSG, szBuf, MAX_LEN);
    if (Size){
        pdata->pszMessageText=new TCHAR[Size+1];
        if (pdata->pszMessageText) {
            _tcscpy(pdata->pszMessageText,szBuf);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsver\exe\constraintspage.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ConstraintsPage.cpp

Abstract:

    Functions for "Constraints" page of the wizard.
Author:

    Sergey Kuzin (a-skuzin@microsoft.com) 09-August-1999

Environment:


Revision History:


--*/

#include "tsverui.h"
#include "resource.h"


void AddSelectedItemsToControl(HWND hwndDlg,int iCtrl);
void AddOneSelectedItemToControl(HWND hwndDlg,int iCtrl);
void AddSelectedRangeToControl(HWND hwndDlg);
void AssembleContraints(HWND hwndDlg,LPSHAREDWIZDATA pdata);
void InitConstraintsPage(HWND hwndDlg);
void AddToControl(HWND hwndDlg, int iCtrl,int &i, TCHAR *szConstraints);
void AddOneToControl(HWND hwndDlg, int iCtrl,int &i, TCHAR *szConstraints);
void AddRangeToControl(HWND hwndDlg, int &i, TCHAR *szConstraints);

BOOL CheckSyntax(HWND hwndDlg, WORD wCtrlId);
BOOL CheckRangeSyntax(HWND hwndDlg);
/*++

Routine Description :

    dialog box procedure for the "Constraints" page.

Arguments :

    IN HWND hwndDlg    - handle to dialog box.
    IN UINT uMsg       - message to be acted upon.
    IN WPARAM wParam   - value specific to wMsg.
    IN LPARAM lParam   - value specific to wMsg.

Return Value :

    TRUE if it processed the message
    FALSE if it did not.

--*/
INT_PTR CALLBACK
ConstraintsPageProc (
           HWND hwndDlg,
           UINT uMsg,
           WPARAM wParam,
           LPARAM lParam)
{

	//Retrieve the shared user data from GWL_USERDATA

	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			//Get the shared data from PROPSHEETPAGE lParam value
			//and load it into GWL_USERDATA

			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;

			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (DWORD_PTR) pdata);
			
            InitConstraintsPage(hwndDlg);
			
			break;
		}


	case WM_NOTIFY :
		{
		LPNMHDR lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
			{
			case PSN_SETACTIVE : //Enable the Back and Next buttons
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                if(pdata->pszConstraints){
                    delete pdata->pszConstraints;
                    pdata->pszConstraints=NULL;
                }
				break;

			case PSN_WIZNEXT :
				//Handle a Next button click here
                if(!CheckSyntax(hwndDlg,IDC_ALLOW)||
                    !CheckSyntax(hwndDlg,IDC_DISALLOW)||
                    !CheckSyntax(hwndDlg,IDC_HIGHER)||
                    !CheckSyntax(hwndDlg,IDC_LOWER)||
                    !CheckRangeSyntax(hwndDlg)){
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                }

                AssembleContraints(hwndDlg,pdata);
				break;

			case PSN_RESET :
				//Handle a Cancel button click, if necessary
				break;


			default :
				break;
			}
		}
		break;

    case WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case ID_ALLOW:
            AddSelectedItemsToControl(hwndDlg,IDC_ALLOW);
            break;
        case ID_DISALLOW:
            AddSelectedItemsToControl(hwndDlg,IDC_DISALLOW);
            break;
        case ID_HIGHER:
            AddOneSelectedItemToControl(hwndDlg,IDC_HIGHER);
            break;
        case ID_LOWER:
            AddOneSelectedItemToControl(hwndDlg,IDC_LOWER);
            break;
        case ID_RANGE:
            AddSelectedRangeToControl(hwndDlg);
            break;

        default:
            break;
        }
        break;

	default:
		break;
	}
	return FALSE;
}

/*++

Routine Description :

    Checks validity of entered values

Arguments :

    IN HWND hwndDlg - Page handle.
    IN int wCtrlId - edit box ID.

Return Value :

    FALSE if some invalid values found.

--*/

BOOL
CheckSyntax(
    HWND hwndDlg,
    WORD wCtrlId
    )
{
    HWND hwndCtrl=GetDlgItem(hwndDlg,wCtrlId);

    TCHAR szBuf[MAX_LEN+1];

    TCHAR szTemplate[MAX_LEN-100+1];
    TCHAR szCtrlName[100+1];
    TCHAR szMsg[MAX_LEN+1];
    int size=GetDlgItemText(hwndDlg,wCtrlId,szBuf,MAX_LEN);
    if(!size){
        return TRUE;
    }


    do{
        size--;

        if(!_istdigit(szBuf[size])&&szBuf[size]!=' '){
            switch(wCtrlId){

            case IDC_HIGHER:
            case IDC_LOWER:

                LoadString(g_hInst,IDS_INVALID_VALUE,szTemplate,MAX_LEN-100);
                LoadString(g_hInst,wCtrlId,szCtrlName,100);
                wsprintf(szMsg,szTemplate,szCtrlName);
                MessageBox(hwndDlg,szMsg,NULL,MB_OK);
                return FALSE;

            case IDC_ALLOW:
            case IDC_DISALLOW:

                if(szBuf[size]!=','){

                    LoadString(g_hInst,IDS_INVALID_VALUE,szTemplate,MAX_LEN-100);
                    LoadString(g_hInst,wCtrlId,szCtrlName,100);
                    wsprintf(szMsg,szTemplate,szCtrlName);
                    MessageBox(hwndDlg,szMsg,NULL,MB_OK);
                    return FALSE;
                }else{
                    break;
                }



            default:
                break;
            }
        }
    }while(size);



    return TRUE;
}

/*++

Routine Description :

    Checks validity of entered values
    for IDC_RANGE edit box

Arguments :

    IN HWND hwndDlg - Page handle.

Return Value :

    FALSE if some invalid values found.

--*/
BOOL
CheckRangeSyntax(
    HWND hwndDlg)
{
    HWND hwndCtrl=GetDlgItem(hwndDlg,IDC_RANGE);

    TCHAR szBuf[MAX_LEN+1];

    TCHAR szTemplate[MAX_LEN-100+1];
    TCHAR szCtrlName[100+1];
    TCHAR szMsg[MAX_LEN+1];
    int size=GetDlgItemText(hwndDlg,IDC_RANGE,szBuf,MAX_LEN);
    if(!size){
        return TRUE;
    }

    BOOL bBracket=FALSE;
    BOOL bColon=FALSE;
    BOOL bDigit=FALSE;
    do{
        size--;

        if(!bBracket)//outside of brackets
        {
            if(szBuf[size]!=';' && szBuf[size]!=')' && szBuf[size]!=' '){ //illegal symbol

                LoadString(g_hInst,IDS_INVALID_VALUE,szTemplate,MAX_LEN-100);
                LoadString(g_hInst,IDC_RANGE,szCtrlName,100);
                wsprintf(szMsg,szTemplate,szCtrlName);
                MessageBox(hwndDlg,szMsg,NULL,MB_OK);
                return FALSE;
            }
        } else {//inside of brackets
            if((!_istdigit(szBuf[size]) && szBuf[size]!=':' && szBuf[size]!='(' && szBuf[size]!=' ')|| //illegal symbol
                (szBuf[size]==':' && bColon)||      // two conons inside brackets
                (szBuf[size]=='(' && !bColon)||     // no colons inside brackets
                (szBuf[size]==':' && !bDigit)||     // no number after colon '(123:)'
                (szBuf[size]=='(' && !bDigit)){     // no number after bracket '(:123)'

                LoadString(g_hInst,IDS_INVALID_VALUE,szTemplate,MAX_LEN-100);
                LoadString(g_hInst,IDC_RANGE,szCtrlName,100);
                wsprintf(szMsg,szTemplate,szCtrlName);
                MessageBox(hwndDlg,szMsg,NULL,MB_OK);
                return FALSE;
            }
        }




        if(szBuf[size]==')'){
            bBracket=TRUE;
            bColon=FALSE;
            bDigit=FALSE;
            continue;
        }
        if(szBuf[size]=='('){
            bBracket=FALSE;
            bColon=FALSE;
            bDigit=FALSE;
            continue;
        }
        if(szBuf[size]==':'){
            bColon=TRUE;
            bDigit=FALSE;
            continue;
        }
        if(_istdigit(szBuf[size])){
            bDigit=TRUE;
            continue;
        }

    }while(size);

    return TRUE;
}

/*++

Routine Description :

    Get IDs of selected listbox items

Arguments :

    IN   HWND hwndList    - handle to list box.
    OUT  int **ppItems    - pointer to pointer to array of
                          IDs of selected items

Return Value :

    number of selected items.

--*/
//
int
GetSelectedItems(
         HWND hwndList,
         int **ppItems)
{
    *ppItems=NULL;

    int nItems=(int)SendMessage(hwndList,LB_GETSELCOUNT,(WPARAM)0,(LPARAM)0);
    if(nItems){

        *ppItems=new int[nItems];

        if(*ppItems) {

            SendMessage(hwndList,LB_GETSELITEMS,(WPARAM)nItems,(LPARAM)*ppItems);

        } else {

            return 0;
        }

    }
    return nItems;
}

/*++

Routine Description :

    Adds selected items from list to
    IDC_ALLOW or IDC_DISALLOW edit box

Arguments :

    IN HWND hwndDlg - Page handle.
    IN int iCtrl - edit box ID.

Return Value :

    none

--*/
void
AddSelectedItemsToControl(
           HWND hwndDlg,
           int iCtrl)
{
    static HWND hwndList=NULL;
    if(!hwndList){
        hwndList=GetDlgItem(hwndDlg,IDC_VERSION_LIST);
    }

    int *pItemIDs;
    int nItems=GetSelectedItems(hwndList,&pItemIDs);
    if(nItems){
        _TCHAR szNumber[11];//assume that list contains only numbers
        _TCHAR szCtrlText[MAX_LEN+1];
        for(int i=0;i<nItems;i++){
            SendMessage(hwndList,LB_GETTEXT,(WPARAM)pItemIDs[i],(LPARAM)szNumber);
            GetDlgItemText(hwndDlg,iCtrl,szCtrlText,MAX_LEN);
            if(_tcslen(szCtrlText)<=(MAX_LEN-11)){//10 digits+','
                if(_tcslen(szCtrlText)){
                    _tcscat(szCtrlText,TEXT(","));
                }
                _tcscat(szCtrlText,szNumber);
                SetDlgItemText(hwndDlg,iCtrl,szCtrlText);
            }

        }
        delete pItemIDs;
        //deselect all items
        SendMessage(hwndList,LB_SETSEL,(WPARAM)0,(LPARAM)-1);
    }

}

/*++

Routine Description :

    Adds selected items from list to
    IDC_HIGHER or IDC_LOWER edit box

Arguments :

    IN HWND hwndDlg - Page handle.
    IN int iCtrl - edit box ID.

Return Value :

    none

--*/
void
AddOneSelectedItemToControl(
           HWND hwndDlg,
           int iCtrl)
{
    static HWND hwndList=NULL;
    if(!hwndList){
        hwndList=GetDlgItem(hwndDlg,IDC_VERSION_LIST);
    }

    int *pItemIDs;
    int nItems=GetSelectedItems(hwndList,&pItemIDs);
    if(nItems){
        if(nItems==1){
            TCHAR szNumber[11];//assume that list contains only numbers
            SendMessage(hwndList,LB_GETTEXT,(WPARAM)pItemIDs[0],(LPARAM)szNumber);
            SetDlgItemText(hwndDlg,iCtrl,szNumber);

        }else{
            TCHAR szMsg[256];
            LoadString(g_hInst,IDS_SELECT_ONE,szMsg,255);
            MessageBox(hwndDlg,szMsg,NULL,MB_OK);
        }

        delete pItemIDs;
        //deselect all items
        SendMessage(hwndList,LB_SETSEL,(WPARAM)0,(LPARAM)-1);
    }

}

/*++

Routine Description :

    Adds selected items from list to
    IDC_RANGE edit box

Arguments :

    IN HWND hwndDlg - Page handle.

Return Value :

    none

--*/
void
AddSelectedRangeToControl(
           HWND hwndDlg)
{
    static HWND hwndList=NULL;
    if(!hwndList){
        hwndList=GetDlgItem(hwndDlg,IDC_VERSION_LIST);
    }

    int *pItemIDs;
    int nItems=GetSelectedItems(hwndList,&pItemIDs);
    if(nItems){
        if(nItems==2){
            TCHAR szNumber1[11];//assume that list contains only numbers
            TCHAR szNumber2[11];


            SendMessage(hwndList,LB_GETTEXT,(WPARAM)pItemIDs[0],(LPARAM)szNumber1);
            SendMessage(hwndList,LB_GETTEXT,(WPARAM)pItemIDs[1],(LPARAM)szNumber2);

            TCHAR szRange[24];

            //versions in list are sorted, so Number1<=Number2
            _tcscpy(szRange,TEXT("("));
            _tcscat(szRange,szNumber1);
            _tcscat(szRange,TEXT(":"));
            _tcscat(szRange,szNumber2);
            _tcscat(szRange,TEXT(")"));

            TCHAR szCtrlText[MAX_LEN+1];

            GetDlgItemText(hwndDlg,IDC_RANGE,szCtrlText,MAX_LEN);
            if(_tcslen(szCtrlText)<(MAX_LEN-24)){//23+',' do not count '\0'
                if(_tcslen(szCtrlText)){
                    _tcscat(szCtrlText,TEXT(";"));
                }
                _tcscat(szCtrlText,szRange);
                SetDlgItemText(hwndDlg,IDC_RANGE,szCtrlText);
            }
        }else{
            TCHAR szMsg[256];
            LoadString(g_hInst,IDS_SELECT_TWO,szMsg,255);
            MessageBox(hwndDlg,szMsg,NULL,MB_OK);
        }
        delete pItemIDs;

        //deselect all items
        SendMessage(hwndList,LB_SETSEL,(WPARAM)0,(LPARAM)-1);
    }


}

/*++

Routine Description :

   Initializes controls with values from registry.

Arguments :

    IN HWND hwndDlg - Page handle.

Return Value :

    none

--*/
void
InitConstraintsPage(
           HWND hwndDlg)
{
    //Set string size limits
    HWND hwndAllow=GetDlgItem(hwndDlg,IDC_ALLOW);
    HWND hwndDisallow=GetDlgItem(hwndDlg,IDC_DISALLOW);
    HWND hwndHigher=GetDlgItem(hwndDlg,IDC_HIGHER);
    HWND hwndLower=GetDlgItem(hwndDlg,IDC_LOWER);
    HWND hwndRange=GetDlgItem(hwndDlg,IDC_RANGE);

    SendMessage(hwndAllow,EM_LIMITTEXT,(WPARAM)MAX_LEN,(LPARAM)0);
    SendMessage(hwndDisallow,EM_LIMITTEXT,(WPARAM)MAX_LEN,(LPARAM)0);
    SendMessage(hwndHigher,EM_LIMITTEXT,(WPARAM)10,(LPARAM)0);//max number length
    SendMessage(hwndLower,EM_LIMITTEXT,(WPARAM)10,(LPARAM)0);//max number length
    SendMessage(hwndRange,EM_LIMITTEXT,(WPARAM)MAX_LEN,(LPARAM)0);


    //Fill List of client versions
    //get list from registry
    TCHAR *pBuffer=NULL;
    HWND hwndList=GetDlgItem(hwndDlg,IDC_VERSION_LIST);
    GetRegMultiString(HKEY_USERS, szConstraintsKeyPath, KeyName[VERSIONS], &pBuffer);

    if(pBuffer){

        for(int i=0;pBuffer[i]!=0;i++){
            SendMessage(hwndList,LB_ADDSTRING,(WPARAM)0,(LPARAM)&pBuffer[i]);
            i+=_tcslen(pBuffer+i);
        }
        delete pBuffer;
        pBuffer=NULL;
    }
//#ifdef TEST
    else{
			//Load version numbers from string table.
			TCHAR szTmp[MAX_LEN+1];
			ZeroMemory(szTmp,MAX_LEN+1);
			TCHAR *pszTmp=szTmp;
			LoadString(g_hInst,IDS_CLIENT_VERSIONS,szTmp,MAX_LEN);
			for(int i=0;szTmp[i]!=0;i++)
			{
				if(szTmp[i]==','){
					szTmp[i]=0;
				}
			}
			for(i=0;szTmp[i]!=0;i++){
				SendMessage(hwndList,LB_ADDSTRING,(WPARAM)0,(LPARAM)&szTmp[i]);
				i+=_tcslen(szTmp+i);
			}
			
		
		/*
        TCHAR *pTmp[9]={TEXT("2031"),TEXT("2072"),TEXT("2087"),TEXT("2092"),TEXT("2099"),
            TEXT("1877"),TEXT("9109"),TEXT("9165"),TEXT("9213")};
        for(int i=0;i<9;i++){
            SendMessage(hwndList,LB_ADDSTRING,(WPARAM)0,(LPARAM)pTmp[i]);
        }*/
    }
//#endif TEST

    //--------------------------------------------------------------------------
    //Parse constraint string
    pBuffer=GetRegString(HKEY_USERS, szConstraintsKeyPath, KeyName[CONSTRAINTS]);
    if(pBuffer){
        for (int i = 0; i < (int)_tcslen(pBuffer); i++){
            switch (pBuffer[i])
            {
                case '=':
                    // skip the case where the = sign follows a !
                    if (pBuffer[i-1] != '!'){
                        AddToControl(hwndDlg, IDC_ALLOW,i, pBuffer);
                    }
                    break;

                case '<':
                    AddOneToControl(hwndDlg, IDC_LOWER,i, pBuffer);
                    break;

                case '>':
                    AddOneToControl(hwndDlg, IDC_HIGHER,i, pBuffer);
                    break;

                case '!':
                    i++; // increment past the = sign
                    AddToControl(hwndDlg, IDC_DISALLOW,i, pBuffer);
                    break;

                case '(':
                    AddRangeToControl(hwndDlg, i, pBuffer);
                    break;

                default:
                    break;
            }
        }
        delete pBuffer;
        pBuffer=NULL;
    }
    //--------------------------------------------------------------------------
    //END "Parse constraint string"
}

/*++

Routine Description :
    Adds values from constraint string to
    IDC_ALLOW or IDC_DISALLOW edit box

Arguments :

    IN HWND hwndDlg - Page handle.
    IN int iCtrl - edit box ID.
    IN,OUT int &i - reference to current position in string
    IN TCHAR *szConstraints - constraint string
Return Value :

    none

--*/
void
AddToControl(
        HWND hwndDlg,
        int iCtrl,
        int &i,
        TCHAR *szConstraints)
{
    int index;
    TCHAR szNumber[11];//max 10 digits + '\0'
    TCHAR szItemText[MAX_LEN+1];

    // parse a number out of the registry string
    index = 0;
    i++; //pass '=' or '>' or '<' or ',' symbol

    while ( ( _istdigit(szConstraints[i]) || szConstraints[i] == ' ' ) &&
              index < 10 )
    {
        if(szConstraints[i] != ' '){
            szNumber[index] = szConstraints[i];
            index++;
        }
        i++;

    }
    szNumber[index] = '\0';

    GetDlgItemText(hwndDlg,iCtrl,szItemText,MAX_LEN);
    if(_tcslen(szItemText)<=(MAX_LEN-11)){//10 digits+','
        if(_tcslen(szItemText)){
            _tcscat(szItemText,TEXT(","));
        }
        _tcscat(szItemText,szNumber);
        SetDlgItemText(hwndDlg,iCtrl,szItemText);
    }

    if(szConstraints[i]==','){
        AddToControl(hwndDlg, iCtrl, i, szConstraints);
    }
}

/*++

Routine Description :
    Adds values from constraint string to
    IDC_HIGHER or IDC_LOWER edit box

Arguments :

    IN HWND hwndDlg - Page handle.
    IN int iCtrl - edit box ID.
    IN,OUT int &i - reference to current position in string
    IN TCHAR *szConstraints - constraint string
Return Value :

    none

--*/
void
AddOneToControl(
        HWND hwndDlg,
        int iCtrl,
        int &i,
        TCHAR *szConstraints)
{
    int index;
    TCHAR szNumber[11];//max 10 digits + '\0'

    // parse a number out of the registry string
    index = 0;
    i++; //pass '=' or '>' or '<' or ',' symbol

    while ( ( _istdigit(szConstraints[i]) || szConstraints[i] == ' ' ) &&
              index < 10 )
    {
        if(szConstraints[i] != ' '){
            szNumber[index] = szConstraints[i];
            index++;
        }
        i++;

    }
    szNumber[index] = '\0';

    SetDlgItemText(hwndDlg,iCtrl,szNumber);
}

/*++

Routine Description :
    Adds values from constraint string to
    IDC_RANGE edit box

Arguments :

    IN HWND hwndDlg - Page handle.
    IN,OUT int &i - reference to current position in string
    IN TCHAR *szConstraints - constraint string
Return Value :

    none

--*/
void
AddRangeToControl(
    HWND hwndDlg,
    int &i,
    TCHAR *szConstraints)
{
    int index;
    TCHAR szRange[24];//10+10+'('+':'+')'+'\0'

    index = 0;
    while (szConstraints[i] != ')' && index < 22 ){

        if(szConstraints[i]!=' '){//delete all spaces
            szRange[index] = szConstraints[i];
            index++;
        }
        i++;
    }
    szRange[index]=')';//index max - 22
    index++;
    szRange[index] = '\0';//index max - 23


    TCHAR szItemText[MAX_LEN+1];

    GetDlgItemText(hwndDlg,IDC_RANGE,szItemText,MAX_LEN);
    if(_tcslen(szItemText)<(MAX_LEN-24)){//23+',' do not count '\0'
        if(_tcslen(szItemText)){
            _tcscat(szItemText,TEXT(";"));
        }
        _tcscat(szItemText,szRange);
        SetDlgItemText(hwndDlg,IDC_RANGE,szItemText);
    }

}

/*++

Routine Description :

    Assembles constraint string from values in edit boxes
    and writes it in data structure.

Arguments :

    IN HWND hwndDlg - Page handle.
    LPSHAREDWIZDATA pdata - pointer to data structure

Return Value :

    none

--*/
void AssembleContraints(HWND hwndDlg,LPSHAREDWIZDATA pdata)
{
    TCHAR szAllow[MAX_LEN+1];
    TCHAR szDisallow[MAX_LEN+1];
    TCHAR szHigher[MAX_LEN+1];
    TCHAR szLower[MAX_LEN+1];
    TCHAR szRange[MAX_LEN+1];

    GetDlgItemText(hwndDlg,IDC_ALLOW,szAllow,MAX_LEN);
    GetDlgItemText(hwndDlg,IDC_DISALLOW,szDisallow,MAX_LEN);
    GetDlgItemText(hwndDlg,IDC_HIGHER,szHigher,MAX_LEN);
    GetDlgItemText(hwndDlg,IDC_LOWER,szLower,MAX_LEN);
    GetDlgItemText(hwndDlg,IDC_RANGE,szRange,MAX_LEN);

    int Size=_tcslen(szAllow)+_tcslen(szDisallow)+_tcslen(szHigher)+
        _tcslen(szLower)+_tcslen(szRange)+10;//'='+'!='+'<'+'>'+4*';'+'\0'=10
    pdata->pszConstraints=new TCHAR[Size];
    if(pdata->pszConstraints != NULL) {
        pdata->pszConstraints[0]=0;
    }
    else {
        return;
    }

    if(_tcslen(szAllow)){
        _tcscpy(pdata->pszConstraints,TEXT("="));
        _tcscat(pdata->pszConstraints,szAllow);
    }
    if(_tcslen(szDisallow)){
        if(_tcslen(pdata->pszConstraints)){
            _tcscat(pdata->pszConstraints,TEXT(";!="));
        }else{
            _tcscat(pdata->pszConstraints,TEXT("!="));
        }
        _tcscat(pdata->pszConstraints,szDisallow);
    }
    if(_tcslen(szHigher)){
        if(_tcslen(pdata->pszConstraints)){
            _tcscat(pdata->pszConstraints,TEXT(";>"));
        }else{
            _tcscat(pdata->pszConstraints,TEXT(">"));
        }
        _tcscat(pdata->pszConstraints,szHigher);
    }
    if(_tcslen(szLower)){
        if(_tcslen(pdata->pszConstraints)){
            _tcscat(pdata->pszConstraints,TEXT(";<"));
        }else{
            _tcscat(pdata->pszConstraints,TEXT("<"));
        }
        _tcscat(pdata->pszConstraints,szLower);
    }
    if(_tcslen(szRange)){
        if(_tcslen(pdata->pszConstraints)){
            _tcscat(pdata->pszConstraints,TEXT(";"));
        }
        _tcscat(pdata->pszConstraints,szRange);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsver\exe\reg.cpp ===
/*-----------------------------------------------**
**  Copyright (c) 1999 Microsoft Corporation     **
**            All Rights reserved                **
**                                               **
**  reg.cpp                                      **
**                                               **
**  Functions for reading, writing, and deleting **
**  registry keys                                **
**  07-01-99 a-clindh Created                    **
**  08-04-99 a-skuzin 'GetRegMultiString'        **
**                        function added		 **
**  08-11-99 a-skuzin 'SetRegKey',               **
**                    'SetRegKeyString',         **
** 		              'DeleteRegKey'now return   **
**                      an error value if any,   **
**                  and ERROR_SUCCESS if success.** 
**-----------------------------------------------*/

/*
LONG    SetRegKey       (HKEY root, TCHAR *szKeyPath, 
                         TCHAR *szKeyName, BYTE nKeyValue);
LONG    DeleteRegKey    (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
BOOL    CheckForRegKey  (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
int     GetRegKeyValue  (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
TCHAR * GetRegString    (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
LONG    SetRegKeyString (HKEY root, TCHAR *szRegString, 
                         TCHAR *szKeyPath, TCHAR *szKeyName);

registry keys used:

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\
Notify\tsver\Asynchronous  REG_DWORD   = 0

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\
Notify\tsver\DllName       REG_SZ      = tsver.dll

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\
Notify\tsver\Impersonate   REG_DWORD   = 0

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\
Notify\tsver\Startup       REG_SZ      = TsVerEventStartup


HKEY_USERS\.DEFAULT\Software\Microsoft\Windows NT\CurrentVersion\TsVer\
Constraints

*/

#include "tsverui.h"

TCHAR *KeyName[] = {TEXT("Asynchronous"), TEXT("DllName"), TEXT("Impersonate"), TEXT("Startup"), 
                    TEXT("Constraints"), TEXT("MsgEnabled"), TEXT("Title"), TEXT("Message"),
                    TEXT("ClientVersions"), TEXT("DoNotShowWelcome")};


///////////////////////////////////////////////////////////////////////////////
// Saves a numeric value in the registry
//
// SetRegKey(i, KeyValue);
// i is the index of the KeyName variable
// nKeyValue is the value we want to store.
//
// TCHAR *KeyName[] = {"Constraints"};
// const TCHAR szWinStaKey[] = 
//        {"Software\\Microsoft\\Windows NT\\CurrentVersion\\TsVer"};
///////////////////////////////////////////////////////////////////////////////
LONG SetRegKey(HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName, BYTE nKeyValue)
{
    HKEY hKey;  
    DWORD dwDisposition;
    LONG lResult;
    if ((lResult=RegCreateKeyEx(root, szKeyPath,
            0, TEXT("REG_DWORD"), REG_OPTION_NON_VOLATILE, 
            KEY_ALL_ACCESS, 0, &hKey, &dwDisposition))
            == ERROR_SUCCESS) { 
    //
    // write the key value to the registry
    //
    lResult=RegSetValueEx(hKey, szKeyName, 0, REG_DWORD,
            &nKeyValue,
            sizeof(DWORD)); 
    RegCloseKey(hKey);
    }
	return lResult;
}

//////////////////////////////////////////////////////////////////////////////
// Deletes the specified registry key.
//
//////////////////////////////////////////////////////////////////////////////
LONG DeleteRegKey(HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName)
{
    HKEY hKey;
	LONG lResult;	
    if ((lResult=RegOpenKeyEx(root, szKeyPath, 0,
            KEY_ALL_ACCESS, &hKey)) == ERROR_SUCCESS)
    {
        lResult=RegDeleteValue(hKey, szKeyName);
        RegCloseKey(hKey);
    }
    //if value not found it does not exist already.
    if(lResult==ERROR_FILE_NOT_FOUND)
        lResult=ERROR_SUCCESS;
    return lResult;
}

//////////////////////////////////////////////////////////////////////////////
// returns TRUE if the registry key is there and FALSE if it isn't
//
// TCHAR *KeyName[] = {"Constraints"};
// TCHAR szWinStaKey[] = 
//        {"Software\\Microsoft\\Windows NT\\CurrentVersion\\TsVer"};
//////////////////////////////////////////////////////////////////////////////
BOOL CheckForRegKey(HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName)
{
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;

    dwType = REG_SZ;
    dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(root, szKeyPath, 0,
                KEY_READ, &hKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hKey, szKeyName, 0,
                &dwType, NULL,
                &dwSize) == ERROR_SUCCESS) {

            RegCloseKey(hKey);
            return TRUE;
        }
        RegCloseKey(hKey); 
    }
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// pass the index of the KeyName variable and the function
// returns the value stored in the registry
// TCHAR *KeyName[] = {"Constraints"};
//////////////////////////////////////////////////////////////////////////////
int GetRegKeyValue(HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName)
{
    int nKeyValue;
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;

    dwType = REG_SZ;
    dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(root, szKeyPath, 0,
                KEY_READ, &hKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hKey, szKeyName, 0,
                &dwType, (LPBYTE) &nKeyValue,
                &dwSize) == ERROR_SUCCESS) {

            RegCloseKey(hKey);
            return nKeyValue;
        }
        RegCloseKey(hKey);
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// Allocates and returns a string if it succeeds or NULL if it fails
//
// TCHAR *KeyName[] = {"Constraints"};
// #define CONSTRAINTS     0
// GetRegString(CONSTRAINTS);
// const TCHAR szWinStaKey[] = 
//        {"Software\\Microsoft\\Windows NT\\CurrentVersion\\TsVer"};
//
//////////////////////////////////////////////////////////////////////////////
TCHAR * GetRegString(HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName)
{
    HKEY hKey = 0;
    DWORD  dwType = REG_SZ;
    DWORD  dwSize = 0;
    TCHAR *szValue=NULL;
    if (RegOpenKeyEx(root, szKeyPath, 0, 
                     KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        if(RegQueryValueEx(hKey, szKeyName, 0, &dwType, 
            NULL, &dwSize) == ERROR_SUCCESS){

            szValue=new TCHAR[dwSize/sizeof(TCHAR)];

            if (RegQueryValueEx(hKey, szKeyName, 0, &dwType, 
                (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS){
        
                RegCloseKey(hKey);
                return szValue;
                
            } else {
                delete szValue;
                szValue=NULL;
            }
        }
    }
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////
// returns TRUE if success, returns FAIL otherwise
//
// TCHAR szNewRegistryString[] = "the rain in spain falls, mainly";
// TCHAR *KeyName[] = {"Constraints", "StartTsVer"};
// #define CONSTRAINTS     0
// #define MAX_LEN         1024
// SetRegKeyString(szNewRegistryString, 
//                 szWinStaKey, KeyName[CONSTRAINTS]);
//////////////////////////////////////////////////////////////////////////////
LONG SetRegKeyString(HKEY root, TCHAR *szRegString, 
                     TCHAR *szKeyPath, TCHAR *szKeyName)
{
    HKEY hKey;  
    DWORD dwDisposition;
    TCHAR lpszKeyType[] = TEXT("REG_SZ");
    LONG lResult;

    if ((lResult=RegCreateKeyEx(root, szKeyPath,
            0, lpszKeyType, REG_OPTION_NON_VOLATILE, 
            KEY_ALL_ACCESS, 0, &hKey, &dwDisposition))
            == ERROR_SUCCESS) { 

        //
        // write the key value to the registry
        //
        lResult=RegSetValueEx(hKey, szKeyName, 0, REG_SZ,
                      (BYTE*)szRegString,
                      (_tcslen(szRegString)+1)*sizeof(TCHAR)); 

        RegCloseKey(hKey);
       
    }

    return lResult;
}

//////////////////////////////////////////////////////////////////////////////

/*++
Routine Description:
    Allocates buffer and fills it with data from registry.
Arguments:

Return Value:
    none
--*/
void GetRegMultiString(HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName, TCHAR **ppBuffer)
{
    *ppBuffer=NULL;//if failed (i.e. value does not exist)
        
    HKEY hKey = 0;
    DWORD  dwType = REG_MULTI_SZ;
    DWORD  dwSize = 0;

    if (RegOpenKeyEx(root, szKeyPath, 0, KEY_READ, &hKey) == ERROR_SUCCESS){
        if (RegQueryValueEx(hKey, szKeyName, 0, &dwType, NULL, &dwSize) == ERROR_SUCCESS){

            *ppBuffer=new TCHAR[dwSize/sizeof(TCHAR)];
            if(*ppBuffer != NULL)
            {
                ZeroMemory(*ppBuffer,dwSize);
                RegQueryValueEx(hKey, szKeyName, 0, &dwType, (LPBYTE)*ppBuffer, &dwSize);
            }           
        }

        RegCloseKey(hKey);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsver\exe\startfinish.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ListCtrl.cpp

Abstract:

    Functions for "Welcome" and "Finish" pages of the wizard.
Author:

    Sergey Kuzin (a-skuzin@microsoft.com) 09-August-1999

Environment:


Revision History:


--*/

#include "tsverui.h"
#include "resource.h"


void OnFinish(HWND hwndDlg, LPSHAREDWIZDATA pdata);
void ShowErrorBox(HWND hwndDlg, DWORD dwError);

/*++

Routine Description :

    dialog box procedure for the "Welcome" page.

Arguments :

    IN HWND hwndDlg    - handle to dialog box.
    IN UINT uMsg       - message to be acted upon.
    IN WPARAM wParam   - value specific to wMsg.
    IN LPARAM lParam   - value specific to wMsg.

Return Value :

    TRUE if it processed the message
    FALSE if it did not.

--*/
INT_PTR CALLBACK
StartPageProc (
			HWND hwndDlg,
			UINT uMsg,
			WPARAM wParam,
			LPARAM lParam
			)
{
	//Process messages from the Welcome page

	//Retrieve the shared user data from GWL_USERDATA

	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			//Get the shared data from PROPSHEETPAGE lParam value
			//and load it into GWL_USERDATA

			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;

			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (DWORD_PTR) pdata);
			
			//It's an intro/end page, so get the title font
			//from  the shared data and use it for the title control

			HWND hwndControl = GetDlgItem(hwndDlg, IDC_TITLE);
			SetWindowFont(hwndControl,pdata->hTitleFont, TRUE);
			break;
		}


	case WM_NOTIFY :
		{
		LPNMHDR lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
			{
			case PSN_SETACTIVE : //Enable the Next button	
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
				break;

			case PSN_WIZNEXT :
				//Handle a Next button click here
                if(IsDlgButtonChecked(hwndDlg,IDC_NOWELLCOME)==BST_CHECKED){
                    pdata->bNoWellcome=TRUE;
                }

				break;

			case PSN_RESET :
				//Handle a Cancel button click, if necessary
				break;


			default :
				break;
			}
		}
		break;

	default:
		break;
	}
	return 0;
}


/*++

Routine Description :

    dialog box procedure for the "Finish" page.

Arguments :

    IN HWND hwndDlg    - handle to dialog box.
    IN UINT uMsg       - message to be acted upon.
    IN WPARAM wParam   - value specific to wMsg.
    IN LPARAM lParam   - value specific to wMsg.

Return Value :

    TRUE if it processed the message
    FALSE if it did not.

--*/
INT_PTR CALLBACK FinishPageProc (
						HWND hwndDlg,
						UINT uMsg,
						WPARAM wParam,
						LPARAM lParam
						)
{
	
	//Process messages from the Completion page

	//Retrieve the shared user data from GWL_USERDATA

	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			//Get the shared data from PROPSHEETPAGE lParam value
			//and load it into GWL_USERDATA

			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (DWORD_PTR) pdata);
			
			//It's an intro/end page, so get the title font
			//from  userdata and use it on the title control

			HWND hwndControl = GetDlgItem(hwndDlg, IDC_TITLE);
			SetWindowFont(hwndControl,pdata->hTitleFont, TRUE);
			break;
		}

	case WM_NOTIFY :
		{
		LPNMHDR lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
			{
			case PSN_SETACTIVE : //Enable the correct buttons on for the active page

				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_FINISH);
				break;

			case PSN_WIZBACK :

				 //If the checkbox was checked, jump back
				 //to the first interior page, not the second

				if(!pdata->bCheckingEnabled)
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_VERSION_CHECKING);
					return TRUE;
				}
				break;

			case PSN_WIZFINISH :
				//Handle a Finish button click, if necessary
                OnFinish(hwndDlg,pdata);
				break;

			case PSN_RESET :
				//Handle a Cancel button click, if necessary
				break;

			default :
				break;
			}
		}
	break;

	default:
		break;
	}
	return 0;
}

/*++

Routine Description :

    writes all data into the registry.

Arguments :
    IN HWND hwndDlg    - handle to dialog box.
    IN LPSHAREDWIZDATA pdata - pointer to the data struct.

Return Value :

    none

--*/
void
OnFinish(
         HWND hwndDlg,
         LPSHAREDWIZDATA pdata)
{
    LONG lResult;
    //
    if(pdata->bNoWellcome){
        lResult=SetRegKey(HKEY_USERS, szConstraintsKeyPath,
            KeyName[NOWELLCOME], 1);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }
    }
    //
    if (pdata->bCheckingEnabled){

        lResult=SetRegKey(HKEY_LOCAL_MACHINE, szKeyPath,
            KeyName[ASYNCHRONOUS], 0);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }
        lResult=SetRegKey(HKEY_LOCAL_MACHINE, szKeyPath,
            KeyName[IMPERSONATE], 0);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }
        lResult=SetRegKeyString(HKEY_LOCAL_MACHINE,
            TEXT("tsver.dll"),szKeyPath, KeyName[DLLNAME]);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }
        lResult=SetRegKeyString(HKEY_LOCAL_MACHINE,
            TEXT("TsVerEventStartup"), szKeyPath, KeyName[STARTUP]);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }

    } else { // delete all the keys
        for (int i = 0; i < 4; i++){
            lResult=DeleteRegKey(HKEY_LOCAL_MACHINE, szKeyPath, KeyName[i]);
            if(lResult!=ERROR_SUCCESS){
                ShowErrorBox(hwndDlg,lResult);
                return;
            }
        }
        //do not save other members, they are not valid!
        return;
    }

    //write message
    if (pdata->bMessageEnabled)
    {
        lResult=SetRegKey(HKEY_USERS, szConstraintsKeyPath, KeyName[USE_MSG], 1);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }
    } else {
        lResult=DeleteRegKey(HKEY_USERS, szConstraintsKeyPath, KeyName[USE_MSG]);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }
    }

    // write constraints string
    if (pdata->pszConstraints&&_tcslen(pdata->pszConstraints)){

        lResult=SetRegKeyString(HKEY_USERS, pdata->pszConstraints,
            szConstraintsKeyPath,
            KeyName[CONSTRAINTS]);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }
    } else {
        lResult=DeleteRegKey(HKEY_USERS,
            szConstraintsKeyPath,
            KeyName[CONSTRAINTS]);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }
    }

    // write title string
    if (pdata->pszMessageTitle&&_tcslen(pdata->pszMessageTitle)){

        lResult=SetRegKeyString(HKEY_USERS, pdata->pszMessageTitle,
            szConstraintsKeyPath,
            KeyName[MSG_TITLE]);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }
    } else {
        lResult=DeleteRegKey(HKEY_USERS,
            szConstraintsKeyPath,
             KeyName[MSG_TITLE]);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }
    }

    // write message string
    if (pdata->pszMessageText&&_tcslen(pdata->pszMessageText)){

        lResult=SetRegKeyString(HKEY_USERS, pdata->pszMessageText,
            szConstraintsKeyPath,
            KeyName[MSG]);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }
    } else {
        lResult=DeleteRegKey(HKEY_USERS,
            szConstraintsKeyPath,
            KeyName[MSG]);
        if(lResult!=ERROR_SUCCESS){
            ShowErrorBox(hwndDlg,lResult);
            return;
        }
    }

}


/*++

Routine Description :

    shows MessageBox with error message.

Arguments :
    IN HWND hwndDlg    - handle to dialog box.
    IN DWORD dwError - error code.

Return Value :

    none

--*/
void
ShowErrorBox(
             HWND hwndDlg,
             DWORD dwError)
{

	LPTSTR MsgBuf=NULL;

	DWORD dwFlags=FORMAT_MESSAGE_FROM_SYSTEM|
		FORMAT_MESSAGE_ALLOCATE_BUFFER|
		FORMAT_MESSAGE_IGNORE_INSERTS;

	if(!FormatMessage(
			dwFlags,
			NULL, dwError,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPTSTR)&MsgBuf, 0, NULL )){
		
		    MsgBuf=(LPTSTR)LocalAlloc(LPTR,2*sizeof(TCHAR));
            if(MsgBuf == NULL) {
                return;
            }

            MsgBuf[0]=' ';
	}

    TCHAR szTemplate[256];
    LoadString(g_hInst,IDS_SAVE_ERROR,szTemplate,255);
    LPTSTR szErrorMsg=new TCHAR[_tcslen(MsgBuf)+_tcslen(szTemplate)+1];
    if(szErrorMsg == NULL) {
        return;
    }
    wsprintf(szErrorMsg,szTemplate,MsgBuf);
    MessageBox(hwndDlg,szErrorMsg,NULL,MB_OK|MB_ICONERROR);
    delete szErrorMsg;
    LocalFree(MsgBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\winsta\global.cpp ===
#include "tsvs.h"

// Global Variables:
//////////////////////////////////////////////////////////////////////////////
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];					// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];			// The title bar text

TCHAR       szAppName[] = TEXT("WinSta");
HWND        hWnd;
HWND        g_hListView;
int         g_ColumnOneIndex;
int         g_ColumnTwoIndex;
int         g_ColumnThreeIndex;
int         g_ColumnFourIndex;


TCHAR *     pszColumn  = TEXT("User");
TCHAR *     pszColumn2 = TEXT("Session");
TCHAR *     pszColumn3 = TEXT("Connected From");
TCHAR *     pszColumn4 = TEXT("Status");


TCHAR szMcNames[MAX_STATIONS][MAX_LEN]      = {0};
TCHAR szMcAddress[MAX_STATIONS][MAX_LEN]    = {0};
TCHAR szMcID[MAX_STATIONS][MAX_LEN]         = {0};
TCHAR szBuild   [MAX_STATIONS][MAX_LEN]     = {0};

TCHAR tmp[sizeof(TCHAR) * 50];
TCHAR buf[sizeof(TCHAR) * 50];

TCHAR *DayOfWeek[]  = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
TCHAR *KeyName[]    = {"left", "top", "right", "bottom"};

const TCHAR szWinStaKey[] = 
        {"Software\\Microsoft\\Windows NT\\CurrentVersion\\WinSta"};
        
SYSTEMTIME lpSystemTime;

HANDLE              m_hThread;
FILE                *stream1;

//////////////////////////////////////////////////////////////////////////////

WTS_SESSION_INFO    *ppSessionInfo;
TCHAR               *ppBuffer;
DWORD               pBytesReturned;
DWORD               pCount;

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\winsta\reg.cpp ===
/*-----------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation     **
**            All Rights reserved                **
**                                               **
**  reg.c                                        **
**                                               **
**  Functions for reading, writing, and deleting **
**  registry keys                                **
**  07-01-98 a-clindh Created                    **
**-----------------------------------------------*/
 
#include "tsvs.h"

///////////////////////////////////////////////////////////////////////////////
// i is the index of the KeyName variable in Global.cpp
// nKeyValue is the value we want to store.
///////////////////////////////////////////////////////////////////////////////
void SetRegKey(int i, LONG * nKeyValue)
{
    HKEY hKey;  
    DWORD dwDisposition;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, szWinStaKey,
            0, "REG_DWORD", REG_OPTION_NON_VOLATILE, 
            KEY_ALL_ACCESS, 0, &hKey, &dwDisposition)
            == ERROR_SUCCESS) { 
    //
    // write the key value to the registry
    //
    RegSetValueEx(hKey, KeyName[i], 0, REG_DWORD,
            (const BYTE *)nKeyValue,
            sizeof(DWORD)); 
    RegCloseKey(hKey);
    }

}
///////////////////////////////////////////////////////////////////////////////
// i is the index of the KeyName variable in Global.cpp
///////////////////////////////////////////////////////////////////////////////
void DeleteRegKey(int i)
{
    HKEY hKey;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, szWinStaKey, 0,
            KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {

        RegDeleteValue(hKey, KeyName[i]);
        RegCloseKey(hKey);
    }
}

///////////////////////////////////////////////////////////////////////////////

// returns TRUE if the registry key is there and FALSE if it isn't
///////////////////////////////////////////////////////////////////////////////
BOOL CheckForRegKey(int i)
{
    DWORD *dwKeyValue;
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;

    dwType = REG_SZ;
    dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, szWinStaKey, 0,
                KEY_READ, &hKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hKey, KeyName[i], 0,
                &dwType, (LPBYTE) &dwKeyValue,
                &dwSize) == ERROR_SUCCESS) {

            RegCloseKey(hKey);
            return TRUE;
        }
        RegCloseKey(hKey); 
    }
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// pass the index of the KeyName variable and the function
// returns the value stored in the registry
///////////////////////////////////////////////////////////////////////////////
int GetRegKeyValue(int i)
{
    int nKeyValue;
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;

    dwType = REG_SZ;
    dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, szWinStaKey, 0,
                KEY_READ, &hKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hKey, KeyName[i], 0,
                &dwType, (LPBYTE) &nKeyValue,
                &dwSize) == ERROR_SUCCESS) {

            RegCloseKey(hKey);
            return nKeyValue;
        }
        RegCloseKey(hKey);
    }
    return 0;
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsver\exe\tsverui.h ===
/*-----------------------------------------------**
**  Copyright (c) 1999 Microsoft Corporation     **
**            All Rights reserved                **
**                                               **
**  tsvsm.h                                      **
**                                               **
**                                               **
**                                               **
**  06-25-99 a-clindh Created                    **
**  08-04-99 a-skuzin struct SHAREDWIZDATA added **
**-----------------------------------------------*/

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <TCHAR.h>

#pragma once

extern          TCHAR szKeyPath[];
extern          TCHAR *KeyName[];
extern          TCHAR szConstraintsKeyPath[];
extern          HINSTANCE g_hInst;

#define MAX_LEN         1024

#define ASYNCHRONOUS        0
#define DLLNAME             1
#define IMPERSONATE         2
#define STARTUP             3
#define CONSTRAINTS         4
#define USE_MSG             5
#define MSG_TITLE           6
#define MSG                 7
#define VERSIONS            8
#define NOWELLCOME          9
LONG    SetRegKey       (HKEY root, TCHAR *szKeyPath, 
                         TCHAR *szKeyName, BYTE nKeyValue);
LONG    DeleteRegKey    (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
BOOL    CheckForRegKey  (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
int     GetRegKeyValue  (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
TCHAR * GetRegString    (HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName);
LONG    SetRegKeyString (HKEY root, TCHAR *szRegString, 
                         TCHAR *szKeyPath, TCHAR *szKeyName);
void GetRegMultiString(HKEY root, TCHAR *szKeyPath, TCHAR *szKeyName, TCHAR **ppBuffer);


//////////////////////////////////////////////////////////////////////////////
//struct SHAREDWIZDATA
struct SHAREDWIZDATA
{
    HFONT   hTitleFont;
    BOOL    bNoWellcome;
    BOOL    bCheckingEnabled; 
    TCHAR*  pszConstraints;
    BOOL    bMessageEnabled;    
    TCHAR*  pszMessageTitle;
    TCHAR*  pszMessageText;
    //
    
    SHAREDWIZDATA():hTitleFont(NULL),
        bNoWellcome(FALSE),
        bCheckingEnabled(FALSE),
        pszConstraints(NULL),
        bMessageEnabled(FALSE),
        pszMessageTitle(NULL),
        pszMessageText(NULL)
    {

    }
    //
    ~SHAREDWIZDATA()
    {
        if(hTitleFont)
            DeleteObject(hTitleFont);
        if(pszConstraints)
            delete pszConstraints;
        if(pszMessageTitle)
            delete pszMessageTitle;
        if(pszMessageText)
            delete pszMessageText;
    }

};
typedef SHAREDWIZDATA* LPSHAREDWIZDATA;
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsver\exe\tsverui.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    MessagePage.cpp

Abstract:

    WinMain function of "TsVer.exe".
Author:

    Sergey Kuzin (a-skuzin@microsoft.com) 09-August-1999

Environment:


Revision History:


--*/

#include "tsverui.h"
#include "resource.h"


HINSTANCE g_hInst;


TCHAR szKeyPath[MAX_LEN];
TCHAR szConstraintsKeyPath[MAX_LEN];

INT_PTR CALLBACK StartPageProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK CheckingPageProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ConstraintsPageProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK MessagePageProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FinishPageProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

///////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
#include <crtdbg.h>
#endif _DEBUG


int WINAPI WinMain (HINSTANCE hinstExe, HINSTANCE hinstPrev,
             LPSTR pszCmdLine, int nCmdShow)
{

#ifdef _DEBUG
    //detecting memory leaks
    // Get current flag
    int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
    // Turn on leak-checking bit
    tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
    // Set flag to the new value
    _CrtSetDbgFlag( tmpFlag );
    
#endif _DEBUG

    g_hInst = hinstExe;

    LoadString (g_hInst, IDS_WINLOGON_KEY_PATH,
        szKeyPath, sizeof (szKeyPath)/sizeof(TCHAR));

    LoadString (g_hInst, IDS_CONSTRAINTS_KEY_PATH,
        szConstraintsKeyPath, sizeof (szConstraintsKeyPath)/sizeof(TCHAR));

    SHAREDWIZDATA wizdata;
    ZeroMemory(&wizdata,sizeof(SHAREDWIZDATA));

    PROPSHEETPAGE psp[5];
    ZeroMemory(psp,sizeof(psp));
    psp[0].dwSize=sizeof(PROPSHEETPAGE);
    psp[0].dwFlags= PSP_HIDEHEADER ;
    psp[0].hInstance=hinstExe;
    psp[0].pszTemplate=MAKEINTRESOURCE(IDD_START);
    psp[0].pfnDlgProc=StartPageProc;
    psp[0].pszHeaderTitle=0;
    psp[0].pszHeaderSubTitle=0;
    psp[0].lParam=(LPARAM)&wizdata;


    psp[1].dwSize=sizeof(PROPSHEETPAGE);
    psp[1].dwFlags= PSP_USEHEADERSUBTITLE | PSP_USEHEADERTITLE ;
    psp[1].hInstance=hinstExe;
    psp[1].pszTemplate=MAKEINTRESOURCE(IDD_VERSION_CHECKING);
    psp[1].pfnDlgProc=CheckingPageProc;
    psp[1].pszHeaderTitle=MAKEINTRESOURCE(IDS_VERSION_CHECKING_TITLE);
    psp[1].pszHeaderSubTitle=MAKEINTRESOURCE(IDS_VERSION_CHECKING_SUBTITLE);
    psp[1].lParam=(LPARAM)&wizdata;

    psp[2].dwSize=sizeof(PROPSHEETPAGE);
    psp[2].dwFlags= PSP_USEHEADERSUBTITLE | PSP_USEHEADERTITLE ;
    psp[2].hInstance=hinstExe;
    psp[2].pszTemplate=MAKEINTRESOURCE(IDD_CONSTRAINTS);
    psp[2].pfnDlgProc=ConstraintsPageProc;
    psp[2].pszHeaderTitle=MAKEINTRESOURCE(IDS_CONSTRAINTS_TITLE);
    psp[2].pszHeaderSubTitle=MAKEINTRESOURCE(IDS_CONSTRAINTS_SUBTITLE);
    psp[2].lParam=(LPARAM)&wizdata;

    psp[3].dwSize=sizeof(PROPSHEETPAGE);
    psp[3].dwFlags= PSP_USEHEADERSUBTITLE | PSP_USEHEADERTITLE ;
    psp[3].hInstance=hinstExe;
    psp[3].pszTemplate=MAKEINTRESOURCE(IDD_MESSAGE_EDITOR);
    psp[3].pfnDlgProc=MessagePageProc;
    psp[3].pszHeaderTitle=MAKEINTRESOURCE(IDS_MESSAGE_EDITOR_TITLE);
    psp[3].pszHeaderSubTitle=MAKEINTRESOURCE(IDS_MESSAGE_EDITOR_SUBTITLE);
    psp[3].lParam=(LPARAM)&wizdata;

    psp[4].dwSize=sizeof(PROPSHEETPAGE);
    psp[4].dwFlags= PSP_HIDEHEADER ;
    psp[4].hInstance=hinstExe;
    psp[4].pszTemplate=MAKEINTRESOURCE(IDD_FINISH);
    psp[4].pfnDlgProc=FinishPageProc;
    psp[4].pszHeaderTitle=0;
    psp[4].pszHeaderSubTitle=0;
    psp[4].lParam=(LPARAM)&wizdata;

    PROPSHEETHEADER psh;
    ZeroMemory(&psh,sizeof(psh));
    psh.dwSize=sizeof(PROPSHEETHEADER);
    psh.dwFlags=PSH_WIZARD97 | PSH_HEADER | PSH_PROPSHEETPAGE |
        PSH_WATERMARK;
    psh.hInstance=hinstExe;
    psh.nPages=5;
    //psh.nStartPage=0;
    psh.ppsp=psp;
    psh.pszbmHeader=MAKEINTRESOURCE(IDB_HEADER);
    psh.pszbmWatermark=MAKEINTRESOURCE(IDB_WATERMARK);

    //show or don't show wellcome page
    if (CheckForRegKey(HKEY_USERS, szConstraintsKeyPath, KeyName[NOWELLCOME])){
        wizdata.bNoWellcome=TRUE;
        psh.nStartPage=1;
    }else{
        wizdata.bNoWellcome=FALSE;
        psh.nStartPage=0;
    }

    //Set up the font for the titles on the intro and ending pages

    NONCLIENTMETRICS ncm = {0};
    ncm.cbSize = sizeof(ncm);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    //Create the intro/end title font
    LOGFONT TitleLogFont = ncm.lfMessageFont;
    TitleLogFont.lfWeight = FW_BOLD;
    lstrcpy(TitleLogFont.lfFaceName, TEXT("MS Shell Dlg"));

    HDC hdc = GetDC(NULL); //gets the screen DC
    INT FontSize = 12;
    if(hdc == NULL) {
        return(0);
    }
    TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
    wizdata.hTitleFont = CreateFontIndirect(&TitleLogFont);
    ReleaseDC(NULL, hdc);

    PropertySheet(&psh);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\tsver\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TSVERUI.RC
//
#define IDS_WINLOGON_KEY_PATH           1
#define IDS_CONSTRAINTS_KEY_PATH        2
#define IDS_SELECT_ONE                  3
#define IDS_SELECT_TWO                  4
#define IDS_VERSION_CHECKING_TITLE      5
#define IDS_VERSION_CHECKING_SUBTITLE   6
#define IDS_CONSTRAINTS_TITLE           7
#define IDS_CONSTRAINTS_SUBTITLE        8
#define IDS_MESSAGE_EDITOR_TITLE        9
#define IDS_MESSAGE_EDITOR_SUBTITLE     10
#define IDS_INVALID_VALUE               11
#define IDS_SAVE_ERROR                  12
#define IDS_CLIENT_VERSIONS             13
#define IDD_START                       101
#define IDD_VERSION_CHECKING            102
#define IDD_CONSTRAINTS                 103
#define IDD_MESSAGE_EDITOR              104
#define IDD_FINISH                      105
#define IDD_ADVANCED                    106
#define IDB_HEADER                      110
#define IDB_WATERMARK                   111
#define IDI_ICON_KEY                    112
#define IDC_TITLE                       1001
#define IDC_SHOW_START                  1002
#define IDC_NOWELLCOME                  1002
#define IDC_ENABLE_CHECKING             1004
#define IDC_DISABLE_CHECKING            1005
#define IDC_VERSION_LIST                1005
#define IDC_ALLOW                       1006
#define IDC_DISALLOW                    1007
#define IDC_HIGHER                      1008
#define IDC_LOWER                       1009
#define ID_ALLOW                        1010
#define ID_DISALLOW                     1011
#define ID_HIGHER                       1012
#define ID_LOWER                        1013
#define IDC_EDIT_TITLE                  1015
#define ID_RANGE                        1015
#define IDC_EDIT_MSG                    1016
#define IDC_ENABLE_MSG                  1017
#define IDC_RANGE                       1017
#define IDC_STATIC_FRAME                1018
#define IDC_STATIC_MSG                  1019
#define IDC_STATIC_TITLE                1020
#define IDC_EDIT_CONSTRAINTS            1021
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1032
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\dis\jetrpc-s.c ===
#include <jetrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\winsta\tsvs.h ===
// C RunTime Header Files
#include <windows.h>
#include <commctrl.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <winbase.h>
#include <shellapi.h>
#include <Wtsapi32.h>
#include <winuser.h>
#include <winsta.h>


// Local Header Files
#include "resource.h"


#define MAX_STATIONS 1024

// Foward declarations
//////////////////////////////////////////////////////////////////////////////
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	About(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK    SndMsg(HWND, UINT, WPARAM, LPARAM);
int     CALLBACK    Sort(LPARAM lParam1, LPARAM lParam2, LPARAM lParamColumn);
int     CDECL       MessageBoxPrintf(TCHAR *szCaption, TCHAR *szFormat, ...);

int     FillList(int nMcIndex);
BOOL    MyInitDialog(HWND hwnd);
void    SetRegKey(int i, LONG * nKeyValue);
void    DeleteRegKey(int i);
BOOL    CheckForRegKey(int i);
int     GetRegKeyValue(int i);
void    ShowMyIcon();

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
#define MAX_LEN (MAX_PATH + 1)

#define MAX_LOADSTRING      200
#define COLUMNONEWIDTH      175
#define COLUMNTWOWIDTH      100
#define COLUMNTHREEWIDTH    124
#define COLUMNFOURWIDTH     100

//{"left", "top", "right", "bottom"};
#define LEFT    0
#define TOP     1
#define RIGHT   2
#define BOTTOM  3

#define GREEN   0
#define YELLOW  1
#define RED     2
//#define NONE    3

// Global Variables:
//////////////////////////////////////////////////////////////////////////////
extern HINSTANCE hInst;								// current instance
extern TCHAR szTitle[MAX_LOADSTRING];				// The title bar text
extern TCHAR szWindowClass[MAX_LOADSTRING];			// The title bar text

extern TCHAR        szAppName[];
extern HWND         hWnd;
extern HWND         g_hListView;
extern int          g_ColumnOneIndex;
extern int          g_ColumnTwoIndex;
extern int          g_ColumnThreeIndex;
extern int          g_ColumnFourIndex;

extern TCHAR *      pszColumn;
extern TCHAR *      pszColumn2;
extern TCHAR *      pszColumn3;
extern TCHAR *      pszColumn4;

extern TCHAR szMcNames  [MAX_STATIONS][MAX_LEN];
extern TCHAR szMcAddress[MAX_STATIONS][MAX_LEN];
extern TCHAR szMcID     [MAX_STATIONS][MAX_LEN];
extern TCHAR szBuild   [MAX_STATIONS][MAX_LEN];

extern TCHAR tmp[sizeof(TCHAR) * 50];
extern TCHAR buf[sizeof(TCHAR) * 50];

extern TCHAR *DayOfWeek[];
extern TCHAR *KeyName[];
extern const TCHAR szWinStaKey[];

extern SYSTEMTIME lpSystemTime;


extern HANDLE              m_hThread;
extern FILE                *stream1;
extern HMENU               g_hMenu;
//////////////////////////////////////////////////////////////////////////////
// tray stuff
//////////////////////////////////////////////////////////////////////////////
#define ARRAYSIZE(x) ((sizeof(x) / sizeof(x[0])))
#define PM_QUITTRAYTHREAD   WM_USER
#define PWM_TRAYICON        WM_USER + 1
#define PM_NOTIFYWAITING    WM_USER + 2
#define PWM_ACTIVATE        WM_USER + 3

#define PM_WINSTA           WM_USER + 4
#define PM_REMOVEWINSTA     WM_USER + 5

#define IDM_SYS_SHOW_ALL    WM_USER + 6
#define IDM_SYS_ABOUT       WM_USER + 7

#define FIND_TIMEOUT        5000    // Wait to to 5 seconds for a response

//
// Class to encapsulate all of the info needed to do a tray notification
class CTrayNotification
{
public:

    CTrayNotification()
    {
        //ASSERT(0 && "Someone is using the default constuctor for CTrayNotification");
        ZeroMemory(this, sizeof(*this));
    }

    CTrayNotification(HWND    hWnd,
                      UINT    uCallbackMessage,
                      DWORD   Message,
                      HICON   hIcon,
                      LPTSTR  pszTip)
    {
        m_hWnd              = hWnd;
        m_uCallbackMessage  = uCallbackMessage;
        m_Message           = Message;
        m_hIcon             = hIcon;

        if (pszTip)
            lstrcpyn(m_szTip, pszTip, ARRAYSIZE(m_szTip));
        else
            m_szTip[0] = TEXT('\0');
    }

    HWND    m_hWnd;
    UINT    m_uCallbackMessage;
    DWORD   m_Message;
    HICON   m_hIcon;
    TCHAR   m_szTip[MAX_PATH];
};

extern  CRITICAL_SECTION  g_CSTrayThread;

extern  DWORD             g_idTrayThread;
extern  HANDLE            g_hTrayThread;

extern  HICON             g_TrayIcons[];
extern  UINT              g_cTrayIcons;
extern  const UINT        idTrayIcons[];
extern  NOTIFYICONDATA    NotifyIconData;

extern  DWORD             g_idWinstaThread;
extern  HANDLE            g_hWinstaThread;

BOOL DeliverTrayNotification(CTrayNotification * pNot);
DWORD TrayThreadMessageLoop(LPVOID);

DWORD WinstaThreadMessageLoop(LPVOID);
void GetWinStationInfo(void);


void Tray_NotifyIcon(HWND    hWnd,
                     UINT    uCallbackMessage,
                     DWORD   Message,
                     HICON   hIcon,            
                     LPCTSTR lpTip);

void Tray_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);
void ShowRunningInstance();
HMENU LoadPopupMenu(HINSTANCE hinst, UINT id); 


//////////////////////////////////////////////////////////////////////////////
// TS Session stuff
//////////////////////////////////////////////////////////////////////////////

extern WTS_SESSION_INFO     *ppSessionInfo;
extern TCHAR                *ppBuffer;
extern DWORD                pBytesReturned;
extern DWORD                pCount;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\dis\dis.h ===
/****************************************************************************/
// Directory Integrity Service, header file
//
// Copyright (C) 2000, Microsoft Corporation
/****************************************************************************/

#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <process.h>
#include <sddl.h>

#include <initguid.h>
#include <ole2.h>
#include <objbase.h>
#include <comdef.h>
#include <adoid.h>
#include <adoint.h>

#include <winsta.h>

#include "trace.h"



typedef enum _SERVER_STATUS {
    NotResponding,
    Responding
} SERVER_STATUS;



// Shortcut VARIANT class to handle cleanup on destruction and common code
// inlining.
class CVar : public VARIANT
{
public:
    CVar() { VariantInit(this); }
    CVar(VARTYPE vt, SCODE scode = 0) {
        VariantInit(this);
        this->vt = vt;
        this->scode = scode;
    }
    CVar(VARIANT var) { *this = var; }
    ~CVar() { VariantClear(this); }

    void InitNull() { this->vt = VT_NULL; }
    void InitFromLong(long L) { this->vt = VT_I4; this->lVal = L; }
    void InitNoParam() {
        this->vt = VT_ERROR;
        this->lVal = DISP_E_PARAMNOTFOUND;
    }

    HRESULT InitFromWSTR(PCWSTR WStr) {
        this->bstrVal = SysAllocString(WStr);
        if (this->bstrVal != NULL) {
            this->vt = VT_BSTR;
            return S_OK;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    // Inits from a non-NULL-terminated set of WCHARs.
    HRESULT InitFromWChars(WCHAR *WChars, unsigned Len) {
        this->bstrVal = SysAllocStringLen(WChars, Len);
        if (this->bstrVal != NULL) {
            this->vt = VT_BSTR;
            return S_OK;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    HRESULT InitEmptyBSTR(unsigned Size) {
        this->bstrVal = SysAllocStringLen(L"", Size);
        if (this->bstrVal != NULL) {
            this->vt = VT_BSTR;
            return S_OK;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    HRESULT Clear() { return VariantClear(this); }
};



HRESULT CreateADOStoredProcCommand(
        PWSTR CmdName,
        ADOCommand **ppCommand,
        ADOParameters **ppParameters);

HRESULT AddADOInputStringParam(
        PWSTR Param,
        PWSTR ParamName,
        ADOCommand *pCommand,
        ADOParameters *pParameters,
        BOOL bNullOnNull);

HRESULT GetRowArrayStringField(
        SAFEARRAY *pSA,
        unsigned RowIndex,
        unsigned FieldIndex,
        WCHAR *OutStr,
        unsigned MaxOutStr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\winsta\winfo.cpp ===
#include <string.h>
#include "tsvs.h"
HANDLE              g_hWinstaThread = NULL;
DWORD               g_idWinstaThread;

void GetWinStationInfo(void);
/*/
typedef enum _WTS_CONNECTSTATE_CLASS {
    WTSActive,
    WTSConnected,
    WTSConnectQuery,
    WTSShadow,
    WTSDisconnected,
    WTSIdle,
    WTSListen,
    WTSReset,
    WTSDown,
    WTSInit,
} WTS_CONNECTSTATE_CLASS;
x
#define ACTIVE          0 // "Active"
#define CONNECTED       1 // "Connected"
#define CONNECTQUERY    2 // "Connect Query"
#define SHADOW          3 // "Shadow"
#define DISCONNECTED    4 // "Disconnected"
#define IDLE            5 // "Idle"
#define LISTEN          6 // "Listen"
#define RESET           7 // "Reset"
#define DOWN            8 // "Down"
#define INIT            9 // "Initializing"
/*/

TCHAR * Status[] = 
{
    "Active", "Connected", "Connect Query", "Shadow", "Disconnected", \
    "Idle", "Listen", "Reset", "Down", "Initializing"
};
//////////////////////////////////////////////////////////////////////////////
void GetWinStationInfo(void)
{
    UINT                i;
    WINSTATIONCLIENT    ClientData;
    ULONG               *pNumber;
    TCHAR               szNumber[10];
    int                 nMcIndex;
    int                 *nConnectState;
    DWORD               pEventFlags;
    static BOOL         bInitialized = FALSE;

    nMcIndex = 0;


    if (bInitialized) {
        // wait for someone to log on or off.....
        WTSWaitSystemEvent(
              WTS_CURRENT_SERVER_HANDLE,
              WTS_EVENT_ALL,
              //WTS_EVENT_LOGON | WTS_EVENT_LOGOFF,
              &pEventFlags
        );
        //.......................................
    }
    bInitialized = TRUE;


    // count the sessions after a logon
    if (WTSEnumerateSessions(
                        WTS_CURRENT_SERVER_HANDLE,
                        0,
                        1,
                        &ppSessionInfo,
                        &pCount))
    {
        // loop through the sessions and save their WTSWinStationNames
        for (i = 0; i < pCount; i++) 
        {

            if (WTSQuerySessionInformation(
                                      WTS_CURRENT_SERVER_HANDLE,
                                      ppSessionInfo[i].SessionId,
                                      WTSWinStationName,
                                      &ppBuffer,
                                      &pBytesReturned)) 
            {
                if (GetMenuState(g_hMenu, IDM_SHOW_ALL, 
                        MF_BYCOMMAND) == MF_UNCHECKED)
                {
                    if (_tcslen(ppBuffer) > 7) // don't take console or enpty ID's
                    {
                        _tcscpy(szMcID[nMcIndex], ppBuffer);
                        WTSFreeMemory(ppBuffer);

                        // get domain name
                        if (WTSQuerySessionInformation(
                                            WTS_CURRENT_SERVER_HANDLE,
                                            ppSessionInfo[i].SessionId,
                                            WTSDomainName,
                                            &ppBuffer,
                                            &pBytesReturned))
                        {
                            _tcscpy(szMcNames[nMcIndex], ppBuffer);
                            if (_tcslen(ppBuffer) > 0)
                                _tcscat(szMcNames[nMcIndex], "\\");
                            WTSFreeMemory(ppBuffer);                        }

                        // get user name
                        if (WTSQuerySessionInformation(
                                            WTS_CURRENT_SERVER_HANDLE,
                                            ppSessionInfo[i].SessionId,
                                            WTSUserName,
                                            &ppBuffer,
                                            &pBytesReturned))
                        {
                            _tcscat(szMcNames[nMcIndex], ppBuffer);
                            WTSFreeMemory(ppBuffer);
                        }

                        // get IP address
                        if (WinStationQueryInformation( 
                                            WTS_CURRENT_SERVER_HANDLE,
                                            ppSessionInfo[i].SessionId,
                                            WinStationClient,
                                            &ClientData,
                                            sizeof(WINSTATIONCLIENT),
                                            &pBytesReturned )) 
                        {
                            _tcscpy(szMcAddress[nMcIndex], 
                                            ClientData.ClientAddress);
                        }

                        // get build number
                        /*/
	                    if (WTSQuerySessionInformation(
                                            WTS_CURRENT_SERVER_HANDLE,
                                           ppSessionInfo[i].SessionId,
                                           WTSClientBuildNumber,
                                           (LPTSTR *)(&pNumber),
                                           &pBytesReturned))
                        {
                            _ltot(*pNumber, szNumber, 10);
                            _tcscpy(szBuild[nMcIndex], szNumber);
                            WTSFreeMemory(pNumber);
                        }
                        /*/

                        // get connection state
	                    if (WTSQuerySessionInformation(
                                            WTS_CURRENT_SERVER_HANDLE,
                                           ppSessionInfo[i].SessionId,
                                           WTSConnectState,
                                           (LPTSTR *)(&nConnectState),
                                           &pBytesReturned))
                        {
                            _tcscpy(szBuild[nMcIndex], Status[*nConnectState]);
                            WTSFreeMemory(nConnectState);
                        } else {
                            _tcscpy(szBuild[nMcIndex], _T("Unknown"));                                
                        }
                    nMcIndex++;
                    }
                } else { // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                    _tcscpy(szMcID[nMcIndex], ppBuffer);
                    WTSFreeMemory(ppBuffer);

                    // get domain name
                    if (WTSQuerySessionInformation(
                                        WTS_CURRENT_SERVER_HANDLE,
                                        ppSessionInfo[i].SessionId,
                                        WTSDomainName,
                                        &ppBuffer,
                                        &pBytesReturned))
                    {
                        _tcscpy(szMcNames[nMcIndex], ppBuffer);
                        if (_tcslen(ppBuffer) > 0)
                            _tcscat(szMcNames[nMcIndex], "\\");
                        WTSFreeMemory(ppBuffer);
                    }

                    // get user name
                    if (WTSQuerySessionInformation(
                                        WTS_CURRENT_SERVER_HANDLE,
                                        ppSessionInfo[i].SessionId,
                                        WTSUserName,
                                        &ppBuffer,
                                        &pBytesReturned))
                    {
                        _tcscat(szMcNames[nMcIndex], ppBuffer);
                        WTSFreeMemory(ppBuffer);
                    }

                    // get IP address
                    if (WinStationQueryInformation( 
                                        WTS_CURRENT_SERVER_HANDLE,
                                        ppSessionInfo[i].SessionId,
                                        WinStationClient,
                                        &ClientData,
                                        sizeof(WINSTATIONCLIENT),
                                        &pBytesReturned )) 
                    {
                        _tcscpy(szMcAddress[nMcIndex], 
                                        ClientData.ClientAddress);
                    }
                    // get connection state
	                if (WTSQuerySessionInformation(
                                        WTS_CURRENT_SERVER_HANDLE,
                                       ppSessionInfo[i].SessionId,
                                       WTSConnectState,
                                       (LPTSTR *)(&nConnectState),
                                       &pBytesReturned))
                    {
                        _tcscpy(szBuild[nMcIndex], Status[*nConnectState]);
                        WTSFreeMemory(nConnectState);
                    }
                    nMcIndex++;
                }
            }
        }
    }

    FillList(nMcIndex);
}

//////////////////////////////////////////////////////////////////////////////
DWORD WinstaThreadMessageLoop(LPVOID)
{
    MSG msg;

    while(GetMessage(&msg, NULL, 0, 0))
    {
        switch(msg.message)
        {
            case PM_WINSTA:
            {
                GetWinStationInfo();
                Sleep(1000); // check for logon/off every second
                if (g_idWinstaThread)
                {
                    PostThreadMessage(g_idWinstaThread, PM_WINSTA, 0, 0);
                }
                break;
            }

        }
    }
    
    return 0;
}
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\dis\disutil.cpp ===
/****************************************************************************/
// Directory Integrity Service
//
// Utility functions
//
// Copyright (C) 2000, Microsoft Corporation
/****************************************************************************/

#include "dis.h"



extern ADOConnection *g_pConnection;



/****************************************************************************/
// AddADOInputStringParam
//
// Creates and adds to the given ADOParameters object a WSTR-initialized
// parameter value.
/****************************************************************************/
HRESULT AddADOInputStringParam(
        PWSTR Param,
        PWSTR ParamName,
        ADOCommand *pCommand,
        ADOParameters *pParameters,
        BOOL bNullOnNull)
{
    HRESULT hr;
    CVar varParam;
    BSTR ParamStr;
    ADOParameter *pParam;
    int Len;

    ParamStr = SysAllocString(ParamName);
    if (ParamStr != NULL) {
        // ADO does not seem to like accepting string params that are zero
        // length. So, if the string we have is zero length and bNullOnNull says
        // we can, we send a null VARIANT type, resulting in a null value at
        // the SQL server.
        if (wcslen(Param) > 0 || !bNullOnNull) {
            hr = varParam.InitFromWSTR(Param);
            Len = wcslen(Param);
        }
        else {
            varParam.vt = VT_NULL;
            varParam.bstrVal = NULL;
            Len = -1;
            hr = S_OK;
        }

        if (SUCCEEDED(hr)) {
            hr = pCommand->CreateParameter(ParamStr, adVarWChar, adParamInput,
                    Len, varParam, &pParam);
            if (SUCCEEDED(hr)) {
                hr = pParameters->Append(pParam);
                if (FAILED(hr)) {
                    ERR((TB,"InStrParam: Failed append param %S, hr=0x%X",
                            ParamName, hr));
                }

                // ADO will have its own ref for the param.
                pParam->Release();
            }
            else {
                ERR((TB,"InStrParam: Failed CreateParam %S, hr=0x%X",
                        ParamName, hr));
            }
        }
        else {
            ERR((TB,"InStrParam: Failed alloc variant bstr, "
                    "param %S, hr=0x%X", ParamName, hr));
        }

        SysFreeString(ParamStr);
    }
    else {
        ERR((TB,"InStrParam: Failed alloc paramname"));
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



/****************************************************************************/
// GetRowArrayStringField
//
// Retrieves a WSTR from a specified row and field of the given SafeArray.
// Returns failure if the target field is not a string. MaxOutStr is max
// WCHARs not including NULL.
/****************************************************************************/
HRESULT GetRowArrayStringField(
        SAFEARRAY *pSA,
        unsigned RowIndex,
        unsigned FieldIndex,
        WCHAR *OutStr,
        unsigned MaxOutStr)
{
    HRESULT hr;
    CVar varField;
    long DimIndices[2];

    DimIndices[0] = FieldIndex;
    DimIndices[1] = RowIndex;
    SafeArrayGetElement(pSA, DimIndices, &varField);

    if (varField.vt == VT_BSTR) {
        wcsncpy(OutStr, varField.bstrVal, MaxOutStr);
        hr = S_OK;
    }
    else if (varField.vt == VT_NULL) {
        OutStr[0] = L'\0';
        hr = S_OK;
    }
    else {
        ERR((TB,"GetRowStrField: Row %u Col %u value %d is not a string",
                RowIndex, FieldIndex, varField.vt));
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************************************/
// CreateADOStoredProcCommand
//
// Creates and returns a stored proc ADOCommand, plus a ref to its
// associated Parameters.
/****************************************************************************/
HRESULT CreateADOStoredProcCommand(
        PWSTR CmdName,
        ADOCommand **ppCommand,
        ADOParameters **ppParameters)
{
    HRESULT hr;
    BSTR CmdStr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;

    CmdStr = SysAllocString(CmdName);
    if (CmdStr != NULL) {
        hr = CoCreateInstance(CLSID_CADOCommand, NULL, CLSCTX_INPROC_SERVER,
                IID_IADOCommand25, (LPVOID *)&pCommand);
        if (SUCCEEDED(hr)) {
            // Set the connection.
            hr = pCommand->putref_ActiveConnection(g_pConnection);
            if (SUCCEEDED(hr)) {
                // Set the command text.
                hr = pCommand->put_CommandText(CmdStr);
                if (SUCCEEDED(hr)) {
                    // Set the command type.
                    hr = pCommand->put_CommandType(adCmdStoredProc);
                    if (SUCCEEDED(hr)) {
                        // Get the Parameters pointer from the Command to
                        // allow appending params.
                        hr = pCommand->get_Parameters(&pParameters);
                        if (FAILED(hr)) {
                            ERR((TB,"Failed getParams for command, "
                                    "hr=0x%X", hr));
                            goto PostCreateCommand;
                        }
                    }
                    else {
                        ERR((TB,"Failed set cmdtype for command, hr=0x%X",
                                hr));
                        goto PostCreateCommand;
                    }
                }
                else {
                    ERR((TB,"Failed set cmdtext for command, hr=0x%X", hr));
                    goto PostCreateCommand;
                }
            }
            else {
                ERR((TB,"Command::putref_ActiveConnection hr=0x%X", hr));
                goto PostCreateCommand;
            }
        }
        else {
            ERR((TB,"CoCreate(Command) returned 0x%X", hr));
            goto PostAllocCmdStr;
        }

        SysFreeString(CmdStr);
    }
    else {
        ERR((TB,"Failed to alloc cmd str"));
        hr = E_OUTOFMEMORY;
        goto ExitFunc;
    }

    *ppCommand = pCommand;
    *ppParameters = pParameters;
    return hr;

// Error handling.

PostCreateCommand:
    pCommand->Release();

PostAllocCmdStr:
    SysFreeString(CmdStr);

ExitFunc:
    *ppCommand = NULL;
    *ppParameters = NULL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\winsta\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tsvs.rc
//
#define IDC_MYICON                      2
#define IDD_TSVS_DIALOG                 102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_TSVS                        107
#define IDI_SMALL                       108
#define IDC_TSVS                        109
#define IDR_MAINFRAME                   128
#define IDD_DLG_TSVS                    129
#define IDC_ICON_STOP                   131
#define IDC_ICON_GO                     132
#define IDR_TRAYMENU                    133
#define IDC_ICON_CAUTION                135
#define IDC_ICON_NONE                   136
#define IDI_ICON1                       138
#define IDI_ICON2                       141
#define IDI_ICON3                       142
#define IDR_POP                         149
#define IDD_MSG_DLG                     150
#define IDC_LIST_VIEW                   1001
#define ID_EXIT                         1002
#define IDC_EDIT_TITLE                  1003
#define IDC_EDIT_MSG                    1004
#define IDT_EXIT                        2001
#define IDD_RESTORE                     32771
#define IDD_MINIMIZE                    32772
#define ID_FILE_REFRESH                 32774
#define IDM_SHOW_ALL                    32775
#define IDR_POP_SND_MSG                 32776
#define IDR_POP_MIN                     32777
#define IDR_POP_CLOSE                   32778
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        151
#define _APS_NEXT_COMMAND_VALUE         32779
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\winsta\tray.cpp ===
#include "tsvs.h"

#define             MSG_QUEUE_SIZE  5

CRITICAL_SECTION    g_CSTrayThread;
DWORD               g_idTrayThread;
HANDLE              g_hTrayThread   = NULL;
NOTIFYICONDATA      NotifyIconData;
HMENU               hPopup;

//////////////////////////////////////////////////////////////////////////////

CTrayNotification * g_apQueue[MSG_QUEUE_SIZE] = { NULL };
UINT                g_cQueueSize              = 0;

const UINT idTrayIcons[] =
{
    IDI_ICON1, IDI_ICON2, IDI_ICON3
};

HICON g_TrayIcons[ARRAYSIZE(idTrayIcons)];
UINT  g_cTrayIcons = ARRAYSIZE(idTrayIcons);


//////////////////////////////////////////////////////////////////////////////
BOOL DeliverTrayNotification(CTrayNotification * pNot)
{
    EnterCriticalSection(&g_CSTrayThread);

    // If no worker thread is running, or queue is full, fail
    if (0 == g_idTrayThread || g_cQueueSize == MSG_QUEUE_SIZE)
    {
        LeaveCriticalSection(&g_CSTrayThread);
        return FALSE;
    }

    // Add notification to the queue and post a message to the
    // worker thread
    g_apQueue[g_cQueueSize++] = pNot;
    PostThreadMessage(g_idTrayThread, PM_NOTIFYWAITING, 0, 0);
    
    LeaveCriticalSection(&g_CSTrayThread);

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
DWORD TrayThreadMessageLoop(LPVOID)
{
    MSG msg;

    while(GetMessage(&msg, NULL, 0, 0))
    {
        switch(msg.message)
        {
            case PM_NOTIFYWAITING:
            {
                // Take a message out of the queue
                EnterCriticalSection(&g_CSTrayThread);

                CTrayNotification * pNot = g_apQueue[0];
                for (UINT i = 0; i < g_cQueueSize; i++)
                {
                    g_apQueue[i] = g_apQueue[i+1];
                }
                g_cQueueSize--;

                LeaveCriticalSection(&g_CSTrayThread);

                // Give it to the tray to process.

                Tray_NotifyIcon(pNot->m_hWnd,
                                pNot->m_uCallbackMessage,
                                pNot->m_Message,
                                pNot->m_hIcon,            
                                pNot->m_szTip);

                delete pNot;

                break;
            }

            case PM_QUITTRAYTHREAD:
            {
                // Delete all messages pending

                EnterCriticalSection(&g_CSTrayThread);                

                while (g_cQueueSize)
                {
                    delete g_apQueue[g_cQueueSize - 1];
                    g_cQueueSize--;
                }

                g_idTrayThread = 0;
                LeaveCriticalSection(&g_CSTrayThread);
                DeleteCriticalSection(&g_CSTrayThread);
                ExitThread(0); // chris
                //PostQuitMessage(0);
                break;
            }

            default:
            {

                break;
            }
        }
    }
    
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
void Tray_NotifyIcon(HWND    hWnd,
                     UINT    uCallbackMessage,
                     DWORD   Message,
                     HICON   hIcon,            
                     LPCTSTR lpTip)
{

    NotifyIconData.cbSize           = sizeof(NOTIFYICONDATA);
    NotifyIconData.uID              = uCallbackMessage;
    NotifyIconData.uFlags           = NIF_MESSAGE | NIF_ICON | NIF_TIP;
    NotifyIconData.uCallbackMessage = uCallbackMessage;

    NotifyIconData.hWnd = hWnd;
    NotifyIconData.hIcon = hIcon;

    if (lpTip) 
    {
        lstrcpyn(NotifyIconData.szTip, lpTip, 
                    ARRAYSIZE(NotifyIconData.szTip));
    } 
    else 
    {
        NotifyIconData.szTip[0] = 0;
    }

    Shell_NotifyIcon(Message, &NotifyIconData);
}

//////////////////////////////////////////////////////////////////////////////
void Tray_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam)                     
{

    switch (lParam) 
    {
        case WM_LBUTTONDBLCLK:                                                 
            ShowRunningInstance();
            break;
            
        case WM_RBUTTONDOWN:
        {
            //HMENU hPopup = LoadPopupMenu(hInst, IDR_TRAYMENU);
            hPopup = LoadPopupMenu(hInst, IDR_TRAYMENU);


            // Display the tray icons context menu at 
            // the current cursor location
            if (hPopup)
            {
                POINT pt;
                GetCursorPos(&pt);
                SetForegroundWindow(hWnd);
                TrackPopupMenuEx(hPopup, 0, pt.x, pt.y, hWnd, NULL);
                DestroyMenu(hPopup);
            }
            break;
        }

    }                                                                          
}

//////////////////////////////////////////////////////////////////////////////
void ShowRunningInstance()
{
    OpenIcon(hWnd);
    SetForegroundWindow(hWnd);
    SetWindowPos(hWnd, HWND_NOTOPMOST,
                 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
HMENU LoadPopupMenu(HINSTANCE hinst, UINT id)
{
    HMENU hmenuParent = LoadMenu(hinst, MAKEINTRESOURCE(id));

    if (hmenuParent) 
    {
        HMENU hpopup = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
        return hpopup;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\reskit\winsta\tsvs.cpp ===
#include "tsvs.h"

TCHAR   szTipText[MAX_PATH];
int     iItemCount, count;

int     g_CurrentSortColumn = 0;
BOOL    g_bAscending = FALSE;
HMENU   g_hMenu;
HMENU   hSysMenu;
TCHAR   g_szSelectedSession[MAX_LEN];
//////////////////////////////////////////////////////////////////////////////
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    MSG                     msg;
    HACCEL                  hAccelTable;
    INITCOMMONCONTROLSEX    cmctl;
    LVCOLUMN                lvc;

    cmctl.dwICC = ICC_TAB_CLASSES | ICC_BAR_CLASSES;
    cmctl.dwSize = sizeof(INITCOMMONCONTROLSEX);
    InitCommonControlsEx(&cmctl);


    g_hTrayThread = CreateThread(NULL, 0,
                                 (LPTHREAD_START_ROUTINE)TrayThreadMessageLoop,
                                 NULL, 0, &g_idTrayThread);


    g_hWinstaThread = CreateThread(NULL, 0,
                                   (LPTHREAD_START_ROUTINE)WinstaThreadMessageLoop,
                                   NULL, 0, &g_idWinstaThread);

    // Initialize global strings
    LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadString(hInstance, IDC_TSVS, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    HWND hwndOld = FindWindow(szAppName, szTitle);
    if (hwndOld) {
        // Send the other copy of ourselves a PWM_ACTIVATE message.
        // If that succeeds, and it returns PWM_ACTIVATE back as the
        // return code, it's up and alive and we can exit this instance.
        DWORD dwPid = 0;
        GetWindowThreadProcessId(hwndOld, &dwPid);

        // Chris - Leave this in here.  Might need it when
        // VS gets fixed.
        // AllowSetForegroundWindow(dwPid);


        ULONG_PTR dwResult;
        if (SendMessageTimeout(hwndOld,
                               PWM_ACTIVATE,
                               0, 0,
                               SMTO_ABORTIFHUNG,
                               FIND_TIMEOUT,
                               &dwResult)) {
            return 0;
        }
    }


    // Perform application initialization:
    if (!InitInstance (hInstance, nCmdShow)) {
        return FALSE;
    }

    hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_TSVS);

    lvc.mask = LVCF_TEXT | LVCF_WIDTH;

    lvc.pszText = pszColumn;
    lvc.cchTextMax = sizeof(pszColumn);
    lvc.cx = COLUMNONEWIDTH;
    g_ColumnOneIndex = ListView_InsertColumn(g_hListView, 1, &lvc);

    lvc.pszText = pszColumn2;
    lvc.cchTextMax = sizeof(pszColumn2);
    lvc.cx = COLUMNTWOWIDTH;
    g_ColumnTwoIndex = ListView_InsertColumn(g_hListView, 2, &lvc);

    lvc.pszText = pszColumn3;
    lvc.cchTextMax = sizeof(pszColumn3);
    lvc.cx = COLUMNTHREEWIDTH;
    g_ColumnThreeIndex = ListView_InsertColumn(g_hListView, 3, &lvc);

    lvc.pszText = pszColumn4;
    lvc.cchTextMax = sizeof(pszColumn4);
    lvc.cx = COLUMNFOURWIDTH;
    g_ColumnFourIndex = ListView_InsertColumn(g_hListView, 4, &lvc);

    ListView_SetExtendedListViewStyle(g_hListView,
                                      LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);

    if (g_idWinstaThread) {
        PostThreadMessage(g_idWinstaThread, PM_WINSTA, 0, 0);
    }

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return(int)msg.wParam;
}

//////////////////////////////////////////////////////////////////////////////
ATOM MyRegisterClass(HINSTANCE hInstance)
{

    WNDCLASSEX wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = (WNDPROC)WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = DLGWINDOWEXTRA;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, (LPCTSTR)IDI_TSVS);
    wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_ACTIVEBORDER + 1);
    wcex.lpszMenuName   = MAKEINTRESOURCE(IDC_TSVS);
    wcex.lpszClassName  = szAppName;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, (LPCTSTR)IDI_ICON1);

    return RegisterClassEx(&wcex);
}

//////////////////////////////////////////////////////////////////////////////
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    hInst = hInstance; // Store instance handle in our global variable
    hWnd = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_DLG_TSVS), 0, NULL);
    g_hMenu = GetMenu(hWnd);

    if (!hWnd)
        return FALSE;

    g_hListView = GetDlgItem(hWnd, IDC_LIST_VIEW);


    // variable to save handle to system menu
    hSysMenu = GetSystemMenu(hWnd, FALSE);
    AppendMenu(hSysMenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hSysMenu, MF_STRING, IDM_SYS_SHOW_ALL, TEXT("Show All"));
    AppendMenu(hSysMenu, MF_STRING, IDM_SYS_ABOUT, TEXT("About..."));

    if (CheckForRegKey(LEFT)    == TRUE &&
        CheckForRegKey(TOP)     == TRUE &&
        CheckForRegKey(RIGHT)   == TRUE &&
        CheckForRegKey(BOTTOM)  == TRUE) {
        SetWindowPos(hWnd, HWND_NOTOPMOST,
                     GetRegKeyValue(LEFT),
                     GetRegKeyValue(TOP),
                     (GetRegKeyValue(RIGHT)  +
                      GetSystemMetrics (SM_CXDLGFRAME))
                     - GetRegKeyValue(LEFT),
                     (GetRegKeyValue(BOTTOM) +
                      GetSystemMetrics (SM_CYDLGFRAME))
                     - GetRegKeyValue(TOP),
                     SWP_NOZORDER | SWP_NOACTIVATE);
    }

    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);

    ListView_DeleteAllItems(g_hListView);

    InitializeCriticalSection(&g_CSTrayThread);

    for (UINT i = 0; i < g_cTrayIcons; i++) {
        g_TrayIcons[i] =
        (HICON) LoadImage(hInst,
                          MAKEINTRESOURCE(idTrayIcons[i]),
                          IMAGE_ICON,
                          0, 0,
                          LR_DEFAULTCOLOR);
    }

    CTrayNotification * pNot =
    new CTrayNotification(hWnd,
                          PWM_TRAYICON,
                          NIM_ADD,
                          g_TrayIcons[GREEN],
                          NULL);

    if (pNot) {
        if (FALSE == DeliverTrayNotification(pNot)) {
            delete pNot;
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK WndProc(HWND hWnd, UINT message,
                         WPARAM wParam, LPARAM lParam)
{
    int wmId, wmEvent;
    PAINTSTRUCT ps;
    HDC hdc;
    HMENU hPopMenu;

    switch (message) {
    
    case WM_SYSCOMMAND:
        wmId    = LOWORD(wParam);
        wmEvent = HIWORD(wParam);

        switch (wmId) {
        case IDM_SYS_ABOUT:
            DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
            return 0;

        case IDM_SYS_SHOW_ALL:
            if (GetMenuState(g_hMenu, IDM_SHOW_ALL,
                             MF_BYCOMMAND) == MF_CHECKED) {
                CheckMenuItem(g_hMenu, IDM_SHOW_ALL, MF_UNCHECKED);
                CheckMenuItem(hSysMenu, IDM_SYS_SHOW_ALL, MF_UNCHECKED);
            } else {
                CheckMenuItem(g_hMenu, IDM_SHOW_ALL, MF_CHECKED);
                CheckMenuItem(hSysMenu, IDM_SYS_SHOW_ALL, MF_CHECKED);
            }
            GetWinStationInfo();
            return 0;
        }// end wmId

    case WM_COMMAND:
        wmId    = LOWORD(wParam);
        wmEvent = HIWORD(wParam);

        switch (wmId) {
        case IDM_ABOUT:

            DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
            break;

        case IDR_POP_CLOSE:
        case IDM_EXIT:
            DestroyWindow(hWnd);
            break;

        case IDM_SHOW_ALL:
            if (GetMenuState(g_hMenu, IDM_SHOW_ALL,
                             MF_BYCOMMAND) == MF_CHECKED) {
                CheckMenuItem(g_hMenu, IDM_SHOW_ALL, MF_UNCHECKED);
            } else {
                CheckMenuItem(g_hMenu, IDM_SHOW_ALL, MF_CHECKED);
            }
            GetWinStationInfo();
            break;

        case IDD_RESTORE:
            ShowRunningInstance();
            break;

        case IDR_POP_MIN:
        case IDD_MINIMIZE:
            ShowWindow(hWnd, SW_MINIMIZE);
            break;

        case ID_FILE_REFRESH:
            if (g_idWinstaThread) {
                GetWinStationInfo();
            }
            break;

        case IDR_POP_SND_MSG:
            // make sure a user is selected
            if (g_szSelectedSession[0] != 0 &&
                _tcslen(g_szSelectedSession) > 7)
                DialogBox(hInst, (LPCTSTR)IDD_MSG_DLG,
                          hWnd, (DLGPROC)SndMsg);
            break;

        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
        }
        break;

    case WM_PAINT:
        hdc = BeginPaint(hWnd, &ps);
        RECT rt;
        GetClientRect(hWnd, &rt);
        EndPaint(hWnd, &ps);
        break;

    case WM_NOTIFY:
        {
            switch (((LPNMHDR) lParam)->code) {

            // display a popup menu for sending a message, closing app, etc.
            case NM_RCLICK :
                {
                    LPNMITEMACTIVATE lpnmitem;
                    lpnmitem = (LPNMITEMACTIVATE) lParam;

                    hPopMenu = LoadPopupMenu(hInst, IDR_POP);

                    ZeroMemory(g_szSelectedSession, MAX_LEN);

                    // get the session ID that the user clicked on.
                    ListView_GetItemText(g_hListView, lpnmitem->iItem, 1,
                                         g_szSelectedSession, MAX_LEN);

                    if (g_szSelectedSession[0] != 0 &&
                        _tcslen(g_szSelectedSession) > 7) {
                        EnableMenuItem(hPopMenu,
                                       IDR_POP_SND_MSG, MF_BYCOMMAND | MF_ENABLED);
                    } else {
                        EnableMenuItem(hPopMenu,
                                       IDR_POP_SND_MSG, MF_BYCOMMAND | MF_GRAYED);
                    }

                    if (hPopMenu) {
                        POINT pt;
                        GetCursorPos(&pt);
                        SetForegroundWindow(hWnd);
                        TrackPopupMenuEx(hPopMenu, 0, pt.x, pt.y, hWnd, NULL);
                        DestroyMenu(hPopMenu);
                    }
                    break;

                }

            case NM_DBLCLK :
                {
                    LPNMITEMACTIVATE lpnmitem;
                    lpnmitem = (LPNMITEMACTIVATE) lParam;

                    // get the session ID that the user clicked on.
                    ListView_GetItemText(g_hListView, lpnmitem->iItem, 1,
                                         g_szSelectedSession, MAX_LEN);

                    // make sure a user is selected
                    if (g_szSelectedSession[0] != 0 &&
                        _tcslen(g_szSelectedSession) > 7)
                        DialogBox(hInst, (LPCTSTR)IDD_MSG_DLG,
                                  hWnd, (DLGPROC)SndMsg);
                    break;

                }

            case LVN_COLUMNCLICK:
                {
                    if (g_CurrentSortColumn == ((LPNMLISTVIEW)lParam)->iSubItem)
                        g_bAscending = !g_bAscending;
                    else
                        g_bAscending = TRUE;

                    g_CurrentSortColumn = ((LPNMLISTVIEW)lParam)->iSubItem;

                    if (g_idWinstaThread) GetWinStationInfo();

                    ListView_SortItems(g_hListView, Sort,
                                       ((LPNMLISTVIEW)lParam)->iSubItem);
                }
                break;
            }
        }

    case WM_WINDOWPOSCHANGED:
        {
            WINDOWPOS *lpwp;
            RECT rc, rm;
            lpwp = (LPWINDOWPOS) lParam;

            // resize the list control.
            GetClientRect(hWnd, &rc);
            MoveWindow(
                      g_hListView,        // handle to window
                      0,                  // horizontal position
                      0,                  // vertical position
                      rc.right - rc.left, //width
                      rc.bottom - rc.top, // height
                      TRUE);

            // save window position and size.
            if (! IsIconic(hWnd)) {
                GetWindowRect(hWnd, &rm);
                GetClientRect(hWnd, &rc);
                MapWindowPoints(hWnd, NULL, (LPPOINT)&rc, 2);
                SetRegKey(LEFT,     &rm.left);
                SetRegKey(TOP,      &rm.top);
                SetRegKey(RIGHT,    &rc.right);
                SetRegKey(BOTTOM,   &rc.bottom);
            } else {
                ShowWindow(hWnd, SW_HIDE);
            }
            break;
        }

        // notifications from tray icon
    case PWM_TRAYICON:
        {
            Tray_Notify(hWnd, wParam, lParam);
            break;
        }

        // wake up and be shown
    case PWM_ACTIVATE:
        {
            ShowRunningInstance();
            break;
        }

    case WM_DESTROY:
        {
            TerminateThread(g_hWinstaThread, 0);

            // Remove the tray icon
            CTrayNotification * pNot =
            new CTrayNotification(hWnd,
                                  PWM_TRAYICON,
                                  NIM_DELETE,
                                  NULL,
                                  NULL);
            if (pNot) {
                if (FALSE == DeliverTrayNotification(pNot)) {
                    delete pNot;
                }
            }

            // If there's a tray thread, tell it to exit
            EnterCriticalSection(&g_CSTrayThread);
            if (g_idTrayThread) {
                PostThreadMessage(g_idTrayThread, PM_QUITTRAYTHREAD, 0, 0);
            }
            LeaveCriticalSection(&g_CSTrayThread);

            // Wait around for some period of time for the tray thread to
            // do its cleanup work.  If the wait times out, worst case we
            // orphan the tray icon.
            if (g_hTrayThread) {
#define TRAY_THREAD_WAIT 3000
                WaitForSingleObject(g_hTrayThread, TRAY_THREAD_WAIT);
                CloseHandle(g_hTrayThread);
            }

            PostQuitMessage(0);
            break;
        }

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

// Mesage handler for about box.
//////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
    case WM_INITDIALOG:
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {
            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
        }
        break;
    }
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////

// Mesage handler for send message dialog.
//////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK SndMsg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    int wmId, wmEvent;
    DWORD           pResponse;
    TCHAR           pTitle[MAX_LEN];

    // user name variables
    DWORD   nSize;
    TCHAR   szBuf[MAX_LEN];

    TCHAR           pMessage[MAX_LEN];
    static HWND     hwndEditTitle;
    static HWND     hwndEditMessage;

    PSID            pSID;
    DWORD           dwGroupSIDCount = 0;
    DWORD           cbSID, dwError;
    SID_NAME_USE    snuGroup;
    DWORD           dwDomainSize = MAX_LEN;
    TCHAR           szDomainName[MAX_LEN];
    LPTSTR          pszGroupName[MAX_LEN];

    switch (message) {
    case WM_INITDIALOG:
        {
            hwndEditTitle   = GetDlgItem(hDlg,  IDC_EDIT_TITLE);
            hwndEditMessage = GetDlgItem(hDlg,  IDC_EDIT_MSG);

            // get the user name
            nSize = sizeof(szBuf);
            GetUserName(szBuf,  &nSize);

            cbSID = GetSidLengthRequired (10);
            pSID = ( PSID) malloc ( cbSID);
            if (!pSID) {
                return 0;
            }


            // get the user's domain
            LookupAccountName ( NULL, szBuf, pSID,
                                &cbSID, szDomainName, &dwDomainSize, &snuGroup);
            /*/
            dwError = GetLastError();
            if ( dwError == ERROR_INSUFFICIENT_BUFFER)
            {

            } else {

            }
            /*/
            free(pSID);
            pSID = NULL;

            for (UINT i = 0; i < pCount; i++) {
                // find the correct session ID
                if (! _tcscmp(ppSessionInfo[i].pWinStationName,
                              g_szSelectedSession)) {
                    _tcscpy(pTitle, TEXT("Message from: "));
                    _tcscat(pTitle, szDomainName);
                    _tcscat(pTitle, "\\");
                    _tcscat(pTitle, szBuf);
                    SetWindowText(hwndEditTitle, pTitle);
                }
            }
            return TRUE;
        }

    case WM_COMMAND:
        wmId    = LOWORD(wParam);
        wmEvent = HIWORD(wParam);

        switch (wmId) {
        case IDOK:
            {
                GetWindowText(hwndEditTitle, pTitle, MAX_LEN - 1);
                GetWindowText(hwndEditMessage, pMessage, MAX_LEN - 1);
                for (UINT i = 0; i < pCount; i++) {
                    // find the correct session ID
                    if (! _tcscmp(ppSessionInfo[i].pWinStationName,
                                  g_szSelectedSession))
                        WTSSendMessage(
                                      WTS_CURRENT_SERVER_HANDLE,
                                      ppSessionInfo[i].SessionId,
                                      pTitle,
                                      sizeof(pTitle),
                                      pMessage,
                                      sizeof(pMessage),
                                      MB_OK, // | MB_ICONEXCLAMATION,
                                      30,
                                      &pResponse,
                                      FALSE); // don't wait for a response

                }

                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
        }
    }
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////

int FillList(int nMcIndex)
{
    LVITEM                  lvi;
    LVFINDINFO              lvfi;
    int                     iListViewIndex, i;
    TCHAR                   string[MAX_LEN];
    TCHAR                   tmp[10];

    // initialize tool tip variable
    for (i = 0; i < MAX_PATH; i++) {
        szTipText[i] = 0;
    }

    i = 0;
    iItemCount = ListView_GetItemCount(g_hListView);
    ListView_GetItemText(g_hListView, nMcIndex - 1, 0, string, MAX_LEN);

    ListView_DeleteAllItems(g_hListView);

    // fill the list with the stats for running machines
    while (i < nMcIndex) {

        lvi.mask            = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem           = (int) SendMessage(g_hListView, LVM_GETITEMCOUNT, 0, 0);
        lvi.iSubItem        = 0;
        lvi.pszText         = szMcNames[i];
        lvi.cchTextMax      = sizeof(szMcNames[i]);

        _itot(i, tmp, 10);
        lvi.lParam          = (LPARAM) i; //(TCHAR *)tmp;
        //lvi.lParam          = (LPARAM) (TCHAR *)szMcNames[i];

        lvfi.flags          = LVFI_STRING;
        lvfi.psz            = szMcNames[i];
        lvfi.lParam         = 0;
        lvfi.vkDirection    = 0;

        // get the index of the item, if it's there.
        iListViewIndex = ListView_FindItem(g_hListView, -1, &lvfi);

        // the if statement makes it so you don't get any duplicate names
        // in the list control
        //if (iListViewIndex == -1) {
        int nPos;

        // insert machine name
        nPos = ListView_InsertItem(g_hListView, &lvi);

        // insert time field
        ListView_SetItemText(g_hListView, nPos, g_ColumnTwoIndex, szMcID[i]);

        // insert machine type
        ListView_SetItemText(g_hListView, nPos,
                             g_ColumnThreeIndex, szMcAddress[i]);

        // insert machine type
        ListView_SetItemText(g_hListView, nPos,
                             g_ColumnFourIndex, szBuild[i]);
/*
            // write data to file
            stream1 = fopen("c:\\WinSta.log", "a");

            // write name to file
            fputs(szMcNames[i], stream1);

            // write ID field to file
            for (x = 0; x < (40 - _tcslen(szMcNames[i])); x++) {
                fputs(" ", stream1);
            }
            fputs(szMcID[i], stream1);

            // write address to file
            for (x = 0; x < (20 - _tcslen(szMcAddress[i])); x++) {
                fputs(" ", stream1);
            }
            fputs(szMcAddress[i], stream1);

            fputs("\n", stream1);
            fclose(stream1);
*/
        i++;
    }

    // count the current list elements and determine
    // the icon to display
    iItemCount = ListView_GetItemCount(g_hListView);
    _itot(iItemCount, string, 10);
    _tcscpy(szTipText, string);
    _tcscat(szTipText, " session(s)");
    if (iItemCount == 0) {
        count = GREEN;
        ShowMyIcon();
        return 0;
    }

    if (iItemCount > 0 && iItemCount < 5) {
        count = YELLOW;
        ShowMyIcon();
        return 0;
    }

    if (iItemCount > 5) {
        count = RED;
        ShowMyIcon();
        return 0;
    }

    return 1;
}

//////////////////////////////////////////////////////////////////////////////
int CDECL MessageBoxPrintf(TCHAR *szCaption, TCHAR *szFormat, ...)
{
    TCHAR szBuffer[MAX_STATIONS];
    va_list pArgList;

    va_start(pArgList, szFormat);
    _vsntprintf(szBuffer, sizeof(szBuffer) / sizeof(TCHAR),
                szFormat, pArgList);

    va_end(pArgList);
    return MessageBox(NULL, szBuffer, szCaption, 0);

}
//////////////////////////////////////////////////////////////////////////////
void ShowMyIcon()
{

    CTrayNotification * pNot;

    // change the light back to red if no servers are listed
    switch (count) {
    case GREEN:
        pNot = new CTrayNotification(hWnd,
                                     PWM_TRAYICON,
                                     NIM_MODIFY,
                                     g_TrayIcons[GREEN],
                                     szTipText);
        if (pNot) {
            if (FALSE == DeliverTrayNotification(pNot))
                delete pNot;
        }
        break;


    case YELLOW:
        pNot = new CTrayNotification(hWnd,
                                     PWM_TRAYICON,
                                     NIM_MODIFY,
                                     g_TrayIcons[GREEN],
                                     //g_TrayIcons[YELLOW],
                                     szTipText);
        if (pNot) {
            if (FALSE == DeliverTrayNotification(pNot))
                delete pNot;
        }
        break;

    case RED:
        pNot = new CTrayNotification(hWnd,
                                     PWM_TRAYICON,
                                     NIM_MODIFY,
                                     g_TrayIcons[GREEN],
                                     //g_TrayIcons[RED],
                                     szTipText);
        if (pNot) {
            if (FALSE == DeliverTrayNotification(pNot))
                delete pNot;
        }
        break;
    }
}

//////////////////////////////////////////////////////////////////////////////
int CALLBACK Sort(LPARAM lParam1, LPARAM lParam2, LPARAM lParamColumn)
{
    TCHAR szItemString[MAX_LEN];
    TCHAR szItemString2[MAX_LEN];

    ListView_GetItemText(g_hListView, (INT)lParam1, (INT)lParamColumn,
                         szItemString, MAX_LEN);

    ListView_GetItemText(g_hListView, (INT)lParam2, (INT)lParamColumn,
                         szItemString2, MAX_LEN);

    if (g_bAscending == TRUE)
        return strcmp(szItemString, szItemString2);
    else
        return -1 * strcmp(szItemString, szItemString2);
}
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\inc\tssdshrd.h ===
/****************************************************************************/
// tssdshrd.h
//
// Terminal Server Session Directory Interface header.  Contains constants
// common between tssdjet and SD.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/


// UpdateConfigurationSettings dwSetting values
#define SDCONFIG_SERVER_ADDRESS 1

#define SINGLE_SESSION_FLAG 0x1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\dis\jetrpcfn.cpp ===
/****************************************************************************/
// jetrpcfn.cpp
//
// TS Directory Integrity Service Jet RPC server-side implementations.
//
// Copyright (C) 2000, Microsoft Corporation
/****************************************************************************/

#include "dis.h"
#include "tssdshrd.h"
#include "jetrpc.h"
#include "jetsdis.h"

#pragma warning (push, 4)


/****************************************************************************/
// MIDL_user_allocate
// MIDL_user_free
//
// RPC-required allocation functions.
/****************************************************************************/
void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t Size)
{
    return LocalAlloc(LMEM_FIXED, Size);
}

void __RPC_USER MIDL_user_free(void __RPC_FAR *p)
{
    LocalFree(p);
}


/****************************************************************************/
// OutputAllTables (debug only)
//
// Output all tables to debug output.
/****************************************************************************/
#ifdef DBG
void OutputAllTables()
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    JET_TABLEID clusdirtableid;
    JET_RETRIEVECOLUMN rcSessDir[NUM_SESSDIRCOLUMNS];
    WCHAR UserNameBuf[256];
    WCHAR DomainBuf[127];
    WCHAR ApplicationBuf[256];
    WCHAR ServerNameBuf[128];
    WCHAR ClusterNameBuf[128];
    unsigned count;
    long num_vals[NUM_SESSDIRCOLUMNS];
    char state;
    char SingleSessMode;

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0, 
            &clusdirtableid));
    CALL(JetBeginTransaction(sesid));

    TSDISErrorOut(L"SESSION DIRECTORY\n");
    
    err = JetMove(sesid, sessdirtableid, JET_MoveFirst, 0);

    if (JET_errNoCurrentRecord == err) {
        TSDISErrorOut(L" (empty database)\n");
    }

    while (JET_errNoCurrentRecord != err) {
        // Retrieve all the columns
        memset(&rcSessDir[0], 0, sizeof(JET_RETRIEVECOLUMN) * 
                NUM_SESSDIRCOLUMNS);
        for (count = 0; count < NUM_SESSDIRCOLUMNS; count++) {
            rcSessDir[count].columnid = sesdircolumnid[count];
            rcSessDir[count].pvData = &num_vals[count];
            rcSessDir[count].cbData = sizeof(long);
            rcSessDir[count].itagSequence = 1;
        }
        // fix up pvData, cbData for non-int fields
        rcSessDir[SESSDIR_USERNAME_INTERNAL_INDEX].pvData = UserNameBuf;
        rcSessDir[SESSDIR_USERNAME_INTERNAL_INDEX].cbData = sizeof(UserNameBuf);
        rcSessDir[SESSDIR_DOMAIN_INTERNAL_INDEX].pvData = DomainBuf;
        rcSessDir[SESSDIR_DOMAIN_INTERNAL_INDEX].cbData = sizeof(DomainBuf);
        rcSessDir[SESSDIR_APPTYPE_INTERNAL_INDEX].pvData = ApplicationBuf;
        rcSessDir[SESSDIR_APPTYPE_INTERNAL_INDEX].cbData = 
                sizeof(ApplicationBuf);
        rcSessDir[SESSDIR_STATE_INTERNAL_INDEX].pvData = &state;
        rcSessDir[SESSDIR_STATE_INTERNAL_INDEX].cbData = sizeof(state);

        CALL(JetRetrieveColumns(sesid, sessdirtableid, &rcSessDir[0], 
                NUM_SESSDIRCOLUMNS));

        TSDISErrorOut(L"%8s, %s, %d, %d, %d\n", 
                UserNameBuf, 
                DomainBuf, 
                num_vals[SESSDIR_SERVERID_INTERNAL_INDEX], 
                num_vals[SESSDIR_SESSIONID_INTERNAL_INDEX],
                num_vals[SESSDIR_TSPROTOCOL_INTERNAL_INDEX]);

        TSDISErrorTimeOut(L" %s, ", 
                num_vals[SESSDIR_CTLOW_INTERNAL_INDEX],
                num_vals[SESSDIR_CTHIGH_INTERNAL_INDEX]);

        TSDISErrorTimeOut(L"%s\n",
                num_vals[SESSDIR_DTLOW_INTERNAL_INDEX],
                num_vals[SESSDIR_DTHIGH_INTERNAL_INDEX]);

        TSDISErrorOut(L" %s, %d, %d, %d, %s\n",
                ApplicationBuf ? L"(no application)" : ApplicationBuf, 
                num_vals[SESSDIR_RESWIDTH_INTERNAL_INDEX],
                num_vals[SESSDIR_RESHEIGHT_INTERNAL_INDEX],
                num_vals[SESSDIR_COLORDEPTH_INTERNAL_INDEX],
                state ? L"disconnected" : L"connected");

        err = JetMove(sesid, sessdirtableid, JET_MoveNext, 0);
    }

    // Output Server Directory (we are reusing the rcSessDir structure).
    TSDISErrorOut(L"SERVER DIRECTORY\n");
    
    err = JetMove(sesid, servdirtableid, JET_MoveFirst, 0);
    if (JET_errNoCurrentRecord == err) {
        TSDISErrorOut(L" (empty database)\n");
    }

    while (JET_errNoCurrentRecord != err) {
        // Retrieve all the columns.
        memset(&rcSessDir[0], 0, sizeof(JET_RETRIEVECOLUMN) * 
                NUM_SERVDIRCOLUMNS);
        for (count = 0; count < NUM_SERVDIRCOLUMNS; count++) {
            rcSessDir[count].columnid = servdircolumnid[count];
            rcSessDir[count].pvData = &num_vals[count];
            rcSessDir[count].cbData = sizeof(long);
            rcSessDir[count].itagSequence = 1;
        }
        rcSessDir[SERVDIR_SERVADDR_INTERNAL_INDEX].pvData = ServerNameBuf;
        rcSessDir[SERVDIR_SERVADDR_INTERNAL_INDEX].cbData = 
                sizeof(ServerNameBuf);
        rcSessDir[SERVDIR_SINGLESESS_INTERNAL_INDEX].pvData = &SingleSessMode;
        rcSessDir[SERVDIR_SINGLESESS_INTERNAL_INDEX].cbData = sizeof(SingleSessMode);


        CALL(JetRetrieveColumns(sesid, servdirtableid, &rcSessDir[0],
                NUM_SERVDIRCOLUMNS));

        TSDISErrorOut(L"%d, %s, %d, %d, %d, %d, %s\n", num_vals[
                SERVDIR_SERVID_INTERNAL_INDEX], ServerNameBuf, num_vals[
                SERVDIR_CLUSID_INTERNAL_INDEX], num_vals[
                SERVDIR_AITLOW_INTERNAL_INDEX], num_vals[
                SERVDIR_AITHIGH_INTERNAL_INDEX], num_vals[
                SERVDIR_NUMFAILPINGS_INTERNAL_INDEX], SingleSessMode ? 
                L"single session mode" : L"multi-session mode");

        err = JetMove(sesid, servdirtableid, JET_MoveNext, 0);
   
    }


    // Output Cluster Directory
    TSDISErrorOut(L"CLUSTER DIRECTORY\n");

    err = JetMove(sesid, clusdirtableid, JET_MoveFirst, 0);
    if (JET_errNoCurrentRecord == err) {
        TSDISErrorOut(L" (empty database)\n");
    }

    while (JET_errNoCurrentRecord != err) {
        memset(&rcSessDir[0], 0, sizeof(JET_RETRIEVECOLUMN) * 
                NUM_CLUSDIRCOLUMNS);
        for (count = 0; count < NUM_CLUSDIRCOLUMNS; count++) {
            rcSessDir[count].columnid = clusdircolumnid[count];
            rcSessDir[count].pvData = &num_vals[count];
            rcSessDir[count].cbData = sizeof(long);
            rcSessDir[count].itagSequence = 1;
        }
        rcSessDir[CLUSDIR_CLUSNAME_INTERNAL_INDEX].pvData = ClusterNameBuf;
        rcSessDir[CLUSDIR_CLUSNAME_INTERNAL_INDEX].cbData = 
                sizeof(ClusterNameBuf);
        rcSessDir[CLUSDIR_SINGLESESS_INTERNAL_INDEX].pvData = &SingleSessMode;
        rcSessDir[CLUSDIR_SINGLESESS_INTERNAL_INDEX].cbData = 
                sizeof(SingleSessMode);

        CALL(JetRetrieveColumns(sesid, clusdirtableid, &rcSessDir[0],
                NUM_CLUSDIRCOLUMNS));

        TSDISErrorOut(L"%d, %s, %s\n", num_vals[CLUSDIR_CLUSID_INTERNAL_INDEX],
                ClusterNameBuf, SingleSessMode ? L"single session mode" : 
                L"multi-session mode");

        err = JetMove(sesid, clusdirtableid, JET_MoveNext, 0);
    }

    TSDISErrorOut(L"\n");

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
}
#endif //DBG


typedef DWORD CLIENTINFO;


/****************************************************************************/
// TSSDRpcServerOnline
//
// Called for server-active indications on each cluster TS machine.
/****************************************************************************/
DWORD TSSDRpcServerOnline( 
        handle_t Binding,
        WCHAR __RPC_FAR *ClusterName,
        /* out */ HCLIENTINFO *hCI,
        DWORD SrvOnlineFlags)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID clusdirtableid;
    JET_TABLEID servdirtableid;
    JET_SETCOLUMN scServDir[NUM_SERVDIRCOLUMNS];
    WCHAR *StringBinding = NULL;
    WCHAR *ServerAddress = NULL;
    RPC_BINDING_HANDLE ServerBinding = 0;
    unsigned long cbActual;
    long ClusterID;
    long ServerID = 0;
    long zero = 0;
    char czero = 0;
    // The single session mode of this server.
    char SingleSession = (char) SrvOnlineFlags & SINGLE_SESSION_FLAG;
    char ClusSingleSessionMode;
    unsigned count;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"In ServOnline, ClusterName=%s, SrvOnlineFlags=%u\n", 
            ClusterName, SrvOnlineFlags);


    // Determine client address.
    if (RpcBindingServerFromClient(Binding, &ServerBinding) != RPC_S_OK) {
        TSDISErrorOut(L"ServOn: BindingServerFromClient failed!\n");
        goto HandleError;
    }
    if (RpcBindingToStringBinding(ServerBinding, &StringBinding) != RPC_S_OK) {
        TSDISErrorOut(L"ServOn: BindingToStringBinding failed!\n");
        goto HandleError;
    }
    if (RpcStringBindingParse(StringBinding, NULL, NULL, &ServerAddress, NULL, 
            NULL) != RPC_S_OK) {
        TSDISErrorOut(L"ServOn: StringBindingParse failed!\n");
        goto HandleError;
    }


    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0, 
            &clusdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    // First, delete all entries for this server from the session/server 
    //directories
    CALL(JetBeginTransaction(sesid));

    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServNameIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, ServerAddress, (unsigned)
            (wcslen(ServerAddress) + 1) * sizeof(WCHAR), JET_bitNewKey));
    err = JetSeek(sesid, servdirtableid, JET_bitSeekEQ);
    if (JET_errSuccess == err) {
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_SERVID_INTERNAL_INDEX], &ServerID, sizeof(ServerID), 
                &cbActual, 0, NULL));
        if (TSSDPurgeServer(ServerID) != 0)
            TSDISErrorOut(L"ServOn: PurgeServer %d failed.\n", ServerID);
    } else if (JET_errRecordNotFound != err) {
        CALL(err);
    }
    CALL(JetCommitTransaction(sesid, 0));

    // We have to do the add in a loop, because we have to:
    // 1) Check if the record is there.
    // 2) If it's not, add it.  (The next time through the loop, therefore,
    //    we'll go step 1->3, and we're done.)
    // 3) If it is, retrieve the value of clusterID and break out.
    //
    // There is an additional complication in that someone else may be in the
    // thread simultaneously, doing the same thing.  Therefore, someone might
    // be in step 2 and try to add a new cluster, but fail because someone
    // else added it.  So they have to keep trying, because though the other
    // thread has added it, it may not have committed the change.  To try to
    // keep that to a minimum, we sleep a short time before trying again.
    for ( ; ; ) {
        // Now do the actual add.
        CALL(JetBeginTransaction(sesid));

        // Search for the cluster in the cluster directory.
        CALL(JetSetCurrentIndex(sesid, clusdirtableid, "ClusNameIndex"));
        CALL(JetMakeKey(sesid, clusdirtableid, ClusterName, (unsigned)
                (wcslen(ClusterName) + 1) * sizeof(WCHAR), JET_bitNewKey));
        err = JetSeek(sesid, clusdirtableid, JET_bitSeekEQ);

        // If the cluster does not exist, create it.
        if (JET_errRecordNotFound == err) {
            CALL(JetPrepareUpdate(sesid, clusdirtableid, JET_prepInsert));

            // ClusterName
            CALL(JetSetColumn(sesid, clusdirtableid, clusdircolumnid[
                    CLUSDIR_CLUSNAME_INTERNAL_INDEX], ClusterName, 
                    (unsigned) (wcslen(ClusterName) + 1) * sizeof(WCHAR), 0, 
                    NULL));

            // SingleSessionMode

            // Since this is the only server in the cluster, the single session
            // mode is simply the mode of this server.
            CALL(JetSetColumn(sesid, clusdirtableid, clusdircolumnid[
                    CLUSDIR_SINGLESESS_INTERNAL_INDEX], &SingleSession, 
                    sizeof(SingleSession), 0, NULL));
            
            err = JetUpdate(sesid, clusdirtableid, NULL, 0, &cbActual);

            // If it's a duplicate key, someone else made the key so we should
            // be ok.  Yield the processor and try the query again, next time
            // through the loop.
            if (JET_errKeyDuplicate == err) {
                CALL(JetCommitTransaction(sesid, 0));
                Sleep(100);
            }
            else {
                CALL(err);

                // Now we've succeeded.  Just continue through the loop.
                // The next time through, we will retrieve the autoincrement
                // column we just added and break out.
                CALL(JetCommitTransaction(sesid, 0));
            }

        }
        else {
            CALL(err);

            // If the above check makes it here, we have found the row.
            // Now retrieve the clusid, commit, and break out of the loop.
            CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
                    CLUSDIR_CLUSID_INTERNAL_INDEX], &ClusterID, 
                    sizeof(ClusterID), &cbActual, 0, NULL));

            CALL(JetCommitTransaction(sesid, 0));
            break;
            
        }
    }

    CALL(JetBeginTransaction(sesid));
    
    // Insert the servername, clusterid, 0, 0 into the server directory table
    err = JetMove(sesid, servdirtableid, JET_MoveLast, 0);

    CALL(JetPrepareUpdate(sesid, servdirtableid, JET_prepInsert));

    memset(&scServDir[0], 0, sizeof(JET_SETCOLUMN) * NUM_SERVDIRCOLUMNS);
    
    for (count = 0; count < NUM_SERVDIRCOLUMNS; count++) {
        scServDir[count].columnid = servdircolumnid[count];
        scServDir[count].cbData = 4; // most of them, set the rest individually
        scServDir[count].itagSequence = 1;
    }
    scServDir[SERVDIR_SERVADDR_INTERNAL_INDEX].pvData = ServerAddress;
    scServDir[SERVDIR_SERVADDR_INTERNAL_INDEX].cbData = 
            (unsigned) (wcslen(ServerAddress) + 1) * sizeof(WCHAR);
    scServDir[SERVDIR_CLUSID_INTERNAL_INDEX].pvData = &ClusterID;
    scServDir[SERVDIR_AITLOW_INTERNAL_INDEX].pvData = &zero;
    scServDir[SERVDIR_AITHIGH_INTERNAL_INDEX].pvData = &zero;
    scServDir[SERVDIR_NUMFAILPINGS_INTERNAL_INDEX].pvData = &zero;
    scServDir[SERVDIR_SINGLESESS_INTERNAL_INDEX].pvData = &SingleSession;
    scServDir[SERVDIR_SINGLESESS_INTERNAL_INDEX].cbData = sizeof(SingleSession);

    // Don't set the first column (index 0)--it is autoincrement.
    CALL(JetSetColumns(sesid, servdirtableid, &scServDir[
            SERVDIR_SERVADDR_INTERNAL_INDEX], NUM_SERVDIRCOLUMNS - 1));
    CALL(JetUpdate(sesid, servdirtableid, NULL, 0, &cbActual));

    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServNameIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, ServerAddress, (unsigned)
            (wcslen(ServerAddress) + 1) * sizeof(WCHAR), JET_bitNewKey));
    CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
            SERVDIR_SERVID_INTERNAL_INDEX], &ServerID, sizeof(ServerID), 
            &cbActual, 0, NULL));
    *hCI = ULongToPtr(ServerID);

    // Now that the server is all set up, we have to set the cluster to the
    // correct mode.  If any server in the cluster is in multisession mode, then
    // we stick with multisession.  If they are all single session, though, we
    // turn on single session in this cluster.  We do some database magic
    // to make this work.  We have an index on the ClusterID and the Single
    // Session mode.  We query for this cluster with single session mode 0
    // (i.e., multi-session mode).  If we get any results back, we are multi-
    // session, otherwise we're single session.

    // Set up the key.
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "SingleSessionIndex"));

    CALL(JetMakeKey(sesid, servdirtableid, &ClusterID, sizeof(ClusterID), 
            JET_bitNewKey));
    CALL(JetMakeKey(sesid, servdirtableid, &czero, sizeof(czero), 0));

    err = JetSeek(sesid, servdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange);


    // NOTE REUSE OF SingleSession VARIABLE!  Up there it meant what the flag
    // passed in meant.  Here it means what we determine the cluster's state to
    // be based on our logic.
    if (err == JET_errRecordNotFound) {
        SingleSession = 1;
    }
    else {
        // CALL the error value to make sure it's success
        CALL(err);

        // If we got here then everything is ok.
        SingleSession = 0;
    }

    // Check the cluster to see if it is already in that mode.
    CALL(JetSetCurrentIndex(sesid, clusdirtableid, "ClusIDIndex"));
    CALL(JetMakeKey(sesid, clusdirtableid, (const void *)&ClusterID,
            sizeof(ClusterID), JET_bitNewKey));
    CALL(JetSeek(sesid, clusdirtableid, JET_bitSeekEQ));
    CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
            CLUSDIR_SINGLESESS_INTERNAL_INDEX], &ClusSingleSessionMode, sizeof(
            ClusSingleSessionMode), &cbActual, 0, NULL));

    // If not, change the mode.
    if (SingleSession != ClusSingleSessionMode) {
        CALL(JetPrepareUpdate(sesid, clusdirtableid, JET_prepReplace));
        CALL(JetSetColumn(sesid, clusdirtableid, clusdircolumnid[
                CLUSDIR_SINGLESESS_INTERNAL_INDEX], &SingleSession, 
                sizeof(SingleSession), 0, NULL));
        CALL(JetUpdate(sesid, clusdirtableid, NULL, 0, &cbActual));
    }

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    if (ServerBinding != NULL)
        RpcBindingFree(&ServerBinding);
    if (StringBinding != NULL)
        RpcStringFree(&StringBinding);
    if (ServerAddress != NULL)
        RpcStringFree(&ServerAddress);

    

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    if (ServerBinding != NULL)
        RpcBindingFree(&ServerBinding);
    if (StringBinding != NULL)
        RpcStringFree(&StringBinding);
    if (ServerAddress != NULL)
        RpcStringFree(&ServerAddress);

    // Just in case we got to commit.
    TSSDPurgeServer(ServerID);

    // Close the context handle.
    *hCI = NULL;

    return (DWORD) E_FAIL;
}


/****************************************************************************/
// TSSDRpcServerOffline
//
// Called for server-shutdown indications on each cluster TS machine.
/****************************************************************************/
DWORD TSSDRpcServerOffline(
        handle_t Binding,
        HCLIENTINFO *hCI)
{
    DWORD retval = 0;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"In ServOff, hCI = 0x%x\n", *hCI);
    
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;

    if (pCI != NULL)
        retval = TSSDPurgeServer(*pCI);

    *hCI = NULL;

    return retval;
}


/****************************************************************************/
// TSSDPurgeServer
//
// Delete a server and all its sessions from the session directory.
/****************************************************************************/
DWORD TSSDPurgeServer(
        DWORD ServerID)
{
    JET_SESID sesid = JET_sesidNil;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    JET_DBID dbid;
    JET_ERR err;

    TSDISErrorOut(L"In PurgeServer, ServerID=%d\n", ServerID);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));
    
    // Delete all sessions in session directory that have this serverid
    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "ServerIndex"));
    CALL(JetMakeKey(sesid, sessdirtableid, &ServerID, sizeof(ServerID),
            JET_bitNewKey));
    err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ);

    while (0 == err) {
        CALL(JetDelete(sesid, sessdirtableid));
        CALL(JetMakeKey(sesid, sessdirtableid, &ServerID, sizeof(ServerID),
                JET_bitNewKey));
        err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ);
    }

    // Should be err -1601 -- JET_errRecordNotFound

    // Delete the server in the server directory with this serverid
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerIDIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, &ServerID, sizeof(ServerID),
            JET_bitNewKey));
    err = JetSeek(sesid, servdirtableid, JET_bitSeekEQ);
    if (JET_errSuccess == err)
        CALL(JetDelete(sesid, servdirtableid));

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, sessdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
    return (DWORD) E_FAIL;
}


/****************************************************************************/
// TSSDRpcGetUserDisconnectedSessions
//
// Queries disconnected sessions from the session database.
/****************************************************************************/
DWORD TSSDRpcGetUserDisconnectedSessions(
        handle_t Binding,
        HCLIENTINFO *hCI,
        WCHAR __RPC_FAR *UserName,
        WCHAR __RPC_FAR *Domain,
        /* out */ DWORD __RPC_FAR *pNumSessions,
        /* out */ TSSD_DiscSessInfo __RPC_FAR __RPC_FAR **padsi)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    JET_TABLEID clusdirtableid;
    *pNumSessions = 0;
    unsigned i = 0;
    unsigned j = 0;
    unsigned long cbActual;
    DWORD tempClusterID;
    DWORD CallingServersClusID;
    long ServerID;
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;
    TSSD_DiscSessInfo *adsi = NULL;
    char one = 1;
    char bSingleSession = 0;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"In GetUserDiscSess: ServID = %d, User: %s, "
            L"Domain: %s\n", *pCI, UserName, Domain);


    *padsi = (TSSD_DiscSessInfo *) MIDL_user_allocate(sizeof(TSSD_DiscSessInfo) * 
            TSSD_MaxDisconnectedSessions);

    adsi = *padsi;

    if (adsi == NULL) {
        TSDISErrorOut(L"GetUserDisc: Memory alloc failed!\n");
        goto HandleError;
    }
    
    // Set the pointers to 0 to be safe, and so that we can free uninitialized
    // ones later without AVing.
    for (j = 0; j < TSSD_MaxDisconnectedSessions; j++) {
        adsi[j].ServerAddress = NULL;
        adsi[j].AppType = NULL;
    }
    
    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0,
            &clusdirtableid));

    CALL(JetBeginTransaction(sesid));

    // Verify that the ServerID passed in was OK.
    if (TSSDVerifyServerIDValid(sesid, servdirtableid, PtrToUlong(*hCI)) == FALSE) {
        TSDISErrorOut(L"Invalid ServerID was passed in\n");
        goto HandleError;
    }
    
    // First, get the cluster ID for the server making the query.
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerIDIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, (const void *)pCI, sizeof(DWORD),
            JET_bitNewKey));
    CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
            SERVDIR_CLUSID_INTERNAL_INDEX], &CallingServersClusID, sizeof(
            CallingServersClusID), &cbActual, 0, NULL));

    // Now that we have the cluster id, check to see whether this cluster
    // is in single session mode.
    CALL(JetSetCurrentIndex(sesid, clusdirtableid, "ClusIDIndex"));
    CALL(JetMakeKey(sesid, clusdirtableid, (const void *)&CallingServersClusID,
            sizeof(CallingServersClusID), JET_bitNewKey));
    CALL(JetSeek(sesid, clusdirtableid, JET_bitSeekEQ));
    CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
            CLUSDIR_SINGLESESS_INTERNAL_INDEX], &bSingleSession, sizeof(
            bSingleSession), &cbActual, 0, NULL));

    // Now, get all the disconnected or all sessions for this cluster, depending
    // on the single session mode retrieved above.
    if (bSingleSession == FALSE) {
        CALL(JetSetCurrentIndex(sesid, sessdirtableid, "DiscSessionIndex"));

        CALL(JetMakeKey(sesid, sessdirtableid, UserName, (unsigned)
                (wcslen(UserName) + 1) * sizeof(WCHAR), JET_bitNewKey));
        CALL(JetMakeKey(sesid, sessdirtableid, Domain, (unsigned)
                (wcslen(Domain) + 1) * sizeof(WCHAR), 0));
        CALL(JetMakeKey(sesid, sessdirtableid, &one, sizeof(one), 0));
    }
    else {
        CALL(JetSetCurrentIndex(sesid, sessdirtableid, "AllSessionIndex"));

        CALL(JetMakeKey(sesid, sessdirtableid, UserName, (unsigned)
                (wcslen(UserName) + 1) * sizeof(WCHAR), JET_bitNewKey));
        CALL(JetMakeKey(sesid, sessdirtableid, Domain, (unsigned)
                (wcslen(Domain) + 1) * sizeof(WCHAR), 0));
    }

    err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange);

    while ((i < TSSD_MaxDisconnectedSessions) && (JET_errSuccess == err)) {
        // Remember the initial retrieval does not have cluster id in the 
        // index, so filter by cluster id for each one.

        // Get the ServerID for this record.
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                SESSDIR_SERVERID_INTERNAL_INDEX], &ServerID, sizeof(ServerID), 
                &cbActual, 0, NULL));

        // Get the clusterID
        CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerIDIndex"));
        CALL(JetMakeKey(sesid, servdirtableid, &ServerID, sizeof(ServerID),
                JET_bitNewKey));
        CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_CLUSID_INTERNAL_INDEX], &tempClusterID, 
                sizeof(tempClusterID), &cbActual, 0, NULL));

        // Compare to the passed-in cluster id.
        if (tempClusterID == CallingServersClusID) {
            // Allocate space.
            adsi[i].ServerAddress = (WCHAR *) MIDL_user_allocate(64 * 
                    sizeof(WCHAR));
            adsi[i].AppType = (WCHAR *) MIDL_user_allocate(256 * sizeof(WCHAR));

            if ((adsi[i].ServerAddress == NULL) || (adsi[i].AppType == NULL)) {
                TSDISErrorOut(L"GetUserDisc: Memory alloc failed!\n");
                goto HandleError;
            }
            
            // ServerAddress comes out of the server table
            CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVADDR_INTERNAL_INDEX], adsi[i].ServerAddress, 
                    128, &cbActual, 0, NULL));
            // The rest come out of the session directory
            // Session ID
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_SESSIONID_INTERNAL_INDEX], 
                    &(adsi[i].SessionID), sizeof(DWORD), &cbActual, 0, NULL));
            // TSProtocol
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_TSPROTOCOL_INTERNAL_INDEX], 
                    &(adsi[i].TSProtocol), sizeof(DWORD), &cbActual, 0, NULL));
            // Application Type
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_APPTYPE_INTERNAL_INDEX], 
                    adsi[i].AppType, 512, &cbActual, 0, NULL));
            // ResolutionWidth
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_RESWIDTH_INTERNAL_INDEX], 
                    &(adsi[i].ResolutionWidth), sizeof(DWORD), &cbActual, 0, 
                    NULL));
            // ResolutionHeight
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_RESHEIGHT_INTERNAL_INDEX], 
                    &(adsi[i].ResolutionHeight), sizeof(DWORD), &cbActual, 0, 
                    NULL));
            // Color Depth
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_COLORDEPTH_INTERNAL_INDEX], 
                    &(adsi[i].ColorDepth), sizeof(DWORD), &cbActual, 0, NULL));
            // CreateTimeLow
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_CTLOW_INTERNAL_INDEX], 
                    &(adsi[i].CreateTimeLow), sizeof(DWORD), &cbActual, 0, 
                    NULL));
            // CreateTimeHigh
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_CTHIGH_INTERNAL_INDEX], 
                    &(adsi[i].CreateTimeHigh), sizeof(DWORD), &cbActual, 0, 
                    NULL));
            // DisconnectTimeLow
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_DTLOW_INTERNAL_INDEX], 
                    &(adsi[i].DisconnectTimeLow), sizeof(DWORD), &cbActual, 0, 
                    NULL));
            // DisconnectTimeHigh
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_DTHIGH_INTERNAL_INDEX], 
                    &(adsi[i].DisconnectTimeHigh), sizeof(DWORD), &cbActual, 0,
                    NULL));
            // State
            // This is retrieving a byte that is 0xff or 0x0 into a DWORD
            // pointer.
            CALL(JetRetrieveColumn(sesid, sessdirtableid,
                    sesdircolumnid[SESSDIR_STATE_INTERNAL_INDEX],
                    &(adsi[i].State), sizeof(BYTE), &cbActual, 0,
                    NULL));

            i += 1;
        }

        // Move to the next matching record.
        err = JetMove(sesid, sessdirtableid, JET_MoveNext, 0);
    }

    *pNumSessions = i;
    
    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

#ifdef DBG
    OutputAllTables();
#endif // DBG

    return 0;

HandleError:
    // Deallocate memory.
    for (j = 0; j < TSSD_MaxDisconnectedSessions; j++) {
        MIDL_user_free(adsi[j].ServerAddress);
        MIDL_user_free(adsi[j].AppType);
    }
    
    // Can't really recover.  Just bail out.
    if (sesid != JET_sesidNil) {
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed.
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    // Delete the server and close the context handle.  Their states are bad.
    TSSDPurgeServer(PtrToUlong(*hCI));
    *hCI = NULL;
    
    return (DWORD) E_FAIL;

}


/****************************************************************************/
// TSSDRpcCreateSession
//
// Called on a session logon.
/****************************************************************************/
DWORD TSSDRpcCreateSession( 
        handle_t Binding,
        HCLIENTINFO *hCI,
        WCHAR __RPC_FAR *UserName,
        WCHAR __RPC_FAR *Domain,
        DWORD SessionID,
        DWORD TSProtocol,
        WCHAR __RPC_FAR *AppType,
        DWORD ResolutionWidth,
        DWORD ResolutionHeight,
        DWORD ColorDepth,
        DWORD CreateTimeLow,
        DWORD CreateTimeHigh)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    JET_SETCOLUMN scSessDir[NUM_SESSDIRCOLUMNS];
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;
    unsigned count;
    int zero = 0;
    unsigned long cbActual;
    char state = 0;

    // "unreferenced" parameter (referenced by RPC)
    Binding;


    TSDISErrorOut(L"Inside TSSDRpcCreateSession, ServID=%d, "
            L"UserName=%s, Domain=%s, SessID=%d, TSProt=%d, AppType=%s, "
            L"ResWidth=%d, ResHeight=%d, ColorDepth=%d\n", *pCI, UserName, 
            Domain, SessionID, TSProtocol, AppType, ResolutionWidth,
            ResolutionHeight, ColorDepth);
    TSDISErrorTimeOut(L" CreateTime=%s\n", CreateTimeLow, CreateTimeHigh);

    memset(&scSessDir[0], 0, sizeof(JET_SETCOLUMN) * NUM_SESSDIRCOLUMNS);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));

    // Verify that the ServerID passed in was OK.
    if (TSSDVerifyServerIDValid(sesid, servdirtableid, PtrToUlong(*hCI)) == FALSE) {
        TSDISErrorOut(L"Invalid ServerID was passed in\n");
        goto HandleError;
    }

    err = JetMove(sesid, sessdirtableid, JET_MoveLast, 0);

    CALL(JetPrepareUpdate(sesid, sessdirtableid, JET_prepInsert));

    for (count = 0; count < NUM_SESSDIRCOLUMNS; count++) {
        scSessDir[count].columnid = sesdircolumnid[count];
        scSessDir[count].cbData = 4; // most of them, set the rest individually
        scSessDir[count].itagSequence = 1;
    }
    scSessDir[SESSDIR_USERNAME_INTERNAL_INDEX].cbData = 
            (unsigned) (wcslen(UserName) + 1) * sizeof(WCHAR);
    scSessDir[SESSDIR_DOMAIN_INTERNAL_INDEX].cbData = 
            (unsigned) (wcslen(Domain) + 1) * sizeof(WCHAR);
    scSessDir[SESSDIR_APPTYPE_INTERNAL_INDEX].cbData = 
            (unsigned) (wcslen(AppType) + 1) * sizeof(WCHAR);
    scSessDir[SESSDIR_STATE_INTERNAL_INDEX].cbData = sizeof(char);

    scSessDir[SESSDIR_USERNAME_INTERNAL_INDEX].pvData = UserName;
    scSessDir[SESSDIR_DOMAIN_INTERNAL_INDEX].pvData = Domain;
    scSessDir[SESSDIR_SERVERID_INTERNAL_INDEX].pvData = pCI;
    scSessDir[SESSDIR_SESSIONID_INTERNAL_INDEX].pvData = &SessionID;
    scSessDir[SESSDIR_TSPROTOCOL_INTERNAL_INDEX].pvData = &TSProtocol;
    scSessDir[SESSDIR_CTLOW_INTERNAL_INDEX].pvData = &CreateTimeLow;
    scSessDir[SESSDIR_CTHIGH_INTERNAL_INDEX].pvData = &CreateTimeHigh;
    scSessDir[SESSDIR_DTLOW_INTERNAL_INDEX].pvData = &zero;
    scSessDir[SESSDIR_DTHIGH_INTERNAL_INDEX].pvData = &zero;
    scSessDir[SESSDIR_APPTYPE_INTERNAL_INDEX].pvData = AppType;
    scSessDir[SESSDIR_RESWIDTH_INTERNAL_INDEX].pvData = &ResolutionWidth;
    scSessDir[SESSDIR_RESHEIGHT_INTERNAL_INDEX].pvData = &ResolutionHeight;
    scSessDir[SESSDIR_COLORDEPTH_INTERNAL_INDEX].pvData = &ColorDepth;
    scSessDir[SESSDIR_STATE_INTERNAL_INDEX].pvData = &state;

    CALL(JetSetColumns(sesid, sessdirtableid, scSessDir, NUM_SESSDIRCOLUMNS));
    CALL(JetUpdate(sesid, sessdirtableid, NULL, 0, &cbActual));
    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed.
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    // Delete the server and close the context handle.  Their states are bad.
    TSSDPurgeServer(PtrToUlong(*hCI));
    *hCI = NULL;
    
    return (DWORD) E_FAIL;

}


/****************************************************************************/
// TSSDRpcDeleteSession
//
// Called on a session logoff.
/****************************************************************************/
DWORD TSSDRpcDeleteSession(
        handle_t Binding,
        HCLIENTINFO *hCI, 
        DWORD SessionID)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"In DelSession, ServID=%d, "
            L"SessID=%d\n", *pCI, SessionID);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));

    // Verify that the ServerID passed in was OK.
    if (TSSDVerifyServerIDValid(sesid, servdirtableid, PtrToUlong(*hCI)) == FALSE) {
        TSDISErrorOut(L"Invalid ServerID was passed in\n");
        goto HandleError;
    }

    // Delete all sessions in session directory that have this serverid
    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "primaryIndex"));
    CALL(JetMakeKey(sesid, sessdirtableid, pCI, 
            sizeof(*pCI), JET_bitNewKey));
    CALL(JetMakeKey(sesid, sessdirtableid, &SessionID, sizeof(SessionID),
            0));

    err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ);

    CALL(JetDelete(sesid, sessdirtableid));

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed.
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    // Delete the server and close the context handle.  Their states are bad.
    TSSDPurgeServer(PtrToUlong(*hCI));
    *hCI = NULL;
    
    return (DWORD) E_FAIL;

}


/****************************************************************************/
// TSSDRpcSetSessionDisconnected
//
// Called on a session disconnection.
/****************************************************************************/
DWORD TSSDRpcSetSessionDisconnected( 
        handle_t Binding,
        HCLIENTINFO *hCI,
        DWORD SessionID,
        DWORD DiscTimeLow,
        DWORD DiscTimeHigh)
{
    unsigned long cbActual;
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;
    char one = 1;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"In SetSessDisc, ServID=%d, SessID=%d\n", *pCI, SessionID);
    TSDISErrorTimeOut(L" DiscTime=%s\n", DiscTimeLow, DiscTimeHigh);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));

    // Verify that the ServerID passed in was OK.
    if (TSSDVerifyServerIDValid(sesid, servdirtableid, PtrToUlong(*hCI)) == FALSE) {
        TSDISErrorOut(L"Invalid ServerID was passed in\n");
        goto HandleError;
    }
    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "primaryIndex"));
    
    // find the record with the serverid, sessionid we are looking for
    CALL(JetMakeKey(sesid, sessdirtableid, pCI, sizeof(DWORD), 
            JET_bitNewKey));
    CALL(JetMakeKey(sesid, sessdirtableid, &SessionID, sizeof(DWORD), 0));

    CALL(JetSeek(sesid, sessdirtableid, JET_bitSeekEQ));

    CALL(JetPrepareUpdate(sesid, sessdirtableid, JET_prepReplace));
    CALL(JetSetColumn(sesid, sessdirtableid, sesdircolumnid[
            SESSDIR_STATE_INTERNAL_INDEX], &one, sizeof(one), 0, NULL));
    CALL(JetUpdate(sesid, sessdirtableid, NULL, 0, &cbActual));

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    // Delete the server and close the context handle.  Their states are bad.
    TSSDPurgeServer(PtrToUlong(*hCI));
    *hCI = NULL;

    return (DWORD) E_FAIL;
}


/****************************************************************************/
// TSSDRpcSetSessionReconnected
//
// Called on a session reconnection.
/****************************************************************************/
DWORD TSSDRpcSetSessionReconnected(
        handle_t Binding,
        HCLIENTINFO *hCI,
        DWORD SessionID,
        DWORD TSProtocol,
        DWORD ResWidth,
        DWORD ResHeight,
        DWORD ColorDepth)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;

    char zero = 0;
    unsigned long cbActual;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"In SetSessRec, ServID=%d, SessID=%d, TSProt=%d, "
            L"ResWid=%d, ResHt=%d, ColDepth=%d\n", *pCI, 
            SessionID, TSProtocol, ResWidth, ResHeight,
            ColorDepth);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));
    
    CALL(JetBeginTransaction(sesid));

    // Verify that the ServerID passed in was OK.
    if (TSSDVerifyServerIDValid(sesid, servdirtableid, PtrToUlong(*hCI)) == FALSE) {
        TSDISErrorOut(L"Invalid ServerID was passed in\n");
        goto HandleError;
    }

    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "primaryIndex"));
    
    // Find the record with the serverid, sessionid we are looking for.
    CALL(JetMakeKey(sesid, sessdirtableid, pCI, sizeof(DWORD), 
            JET_bitNewKey));
    CALL(JetMakeKey(sesid, sessdirtableid, &SessionID, sizeof(DWORD), 0));

    CALL(JetSeek(sesid, sessdirtableid, JET_bitSeekEQ));

    CALL(JetPrepareUpdate(sesid, sessdirtableid, JET_prepReplace));
    CALL(JetSetColumn(sesid, sessdirtableid, sesdircolumnid[
            SESSDIR_TSPROTOCOL_INTERNAL_INDEX], &TSProtocol, sizeof(TSProtocol),
            0, NULL));
    CALL(JetSetColumn(sesid, sessdirtableid, sesdircolumnid[
            SESSDIR_RESWIDTH_INTERNAL_INDEX], &ResWidth, sizeof(ResWidth), 
            0, NULL));
    CALL(JetSetColumn(sesid, sessdirtableid, sesdircolumnid[
            SESSDIR_RESHEIGHT_INTERNAL_INDEX], &ResHeight, sizeof(ResHeight), 
            0, NULL));
    CALL(JetSetColumn(sesid, sessdirtableid, sesdircolumnid[
            SESSDIR_COLORDEPTH_INTERNAL_INDEX], &ColorDepth, sizeof(ColorDepth),
            0, NULL));
    CALL(JetSetColumn(sesid, sessdirtableid, sesdircolumnid[
            SESSDIR_STATE_INTERNAL_INDEX], &zero, sizeof(zero), 0, NULL));
    CALL(JetUpdate(sesid, sessdirtableid, NULL, 0, &cbActual));
    
    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed.
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    // Delete the server and close the context handle.  Their states are bad.
    TSSDPurgeServer(PtrToUlong(*hCI));
    *hCI = NULL;

    return (DWORD) E_FAIL;
}


DWORD TSSDRpcSetServerReconnectPending(
        handle_t Binding,
        WCHAR __RPC_FAR *ServerAddress,
        DWORD AlmostTimeLow,
        DWORD AlmostTimeHigh)
{
    // Ignored parameters
    Binding;
    AlmostTimeLow;
    AlmostTimeHigh;
    
    return TSSDSetServerAITInternal(ServerAddress, FALSE, NULL);
}


/****************************************************************************/
// TSSDRpcUpdateConfigurationSetting
//
// Extensible interface to update a configuration setting.
/****************************************************************************/
DWORD TSSDSetServerAddress(HCLIENTINFO *hCI, WCHAR *ServerName)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID servdirtableid;
    unsigned long cbActual;


    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    // Find the server in the server directory
    CALL(JetBeginTransaction(sesid));

    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerIDIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, (const void *)hCI, sizeof(DWORD),
            JET_bitNewKey));
    CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));

    // Prepare to update.
    CALL(JetPrepareUpdate(sesid, servdirtableid, JET_prepReplace));

    // Now set the column to what we want
    CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_SERVADDR_INTERNAL_INDEX], (void *) ServerName, 
                (unsigned) (wcslen(ServerName) + 1) * sizeof(WCHAR), 0, 
                NULL));

    CALL(JetUpdate(sesid, servdirtableid, NULL, 0, &cbActual));


    CALL(JetCommitTransaction(sesid, 0));

    // Clean up.
    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    TSSDPurgeServer(PtrToUlong(*hCI));

    // Close the context handle.
    *hCI = NULL;

    return (DWORD) E_FAIL;
}


/****************************************************************************/
// TSSDRpcUpdateConfigurationSetting
//
// Extensible interface to update a configuration setting.
/****************************************************************************/
DWORD TSSDRpcUpdateConfigurationSetting(
        handle_t Binding,
        HCLIENTINFO *hCI,
        DWORD dwSetting,
        DWORD dwSettingLength,
        BYTE __RPC_FAR *pbValue)
{
    // Unreferenced parameters.
    Binding;
    hCI;
    dwSetting;
    dwSettingLength;
    pbValue;

    if (dwSetting == SDCONFIG_SERVER_ADDRESS) {
        TSDISErrorOut(L"Server is setting its address as %s\n", 
                (WCHAR *) pbValue);
        return TSSDSetServerAddress(hCI, (WCHAR *) pbValue);
    }
    
    return (DWORD) E_NOTIMPL;
}



/****************************************************************************/
// TSSDSetServerAITInternal
//
// Called on a client redirection from one server to another, to let the
// integrity service determine how to ping the redirection target machine.
//
// Args:
//  ServerAddress (in) - the server address to set values for
//  bResetToZero (in) - whether to reset all AIT values to 0
//  FailureCount (in/out) - Pointer to nonzero on entry means increment the 
//   failure count.  Returns the result failure count.
/****************************************************************************/
DWORD TSSDSetServerAITInternal( 
        WCHAR *ServerAddress,
        DWORD bResetToZero,
        DWORD *FailureCount)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID servdirtableid;
    DWORD AITFromServDirLow;
    DWORD AITFromServDirHigh;
    unsigned long cbActual;

    TSDISErrorOut(L"SetServAITInternal: ServAddr=%s, bResetToZero=%d, bIncFail"
            L"=%d\n", ServerAddress, bResetToZero, (FailureCount == NULL) ? 
            0 : *FailureCount);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServNameIndex"));

    CALL(JetMakeKey(sesid, servdirtableid, ServerAddress, (unsigned)
            (wcslen(ServerAddress) + 1) * sizeof(WCHAR), JET_bitNewKey));

    CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));

    // Algorithm for set reconnect pending:
    // 1) If server is not already pending a reconnect,
    // 2) Set the AlmostTimeLow and High to locally computed times (using
    //    the times from the wire is dangerous and requires clocks to be the
    //    same).

    // Retrieve the current values of AlmostInTimeLow and High
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
            SERVDIR_AITLOW_INTERNAL_INDEX], &AITFromServDirLow, 
            sizeof(AITFromServDirLow), &cbActual, 0, NULL));
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
            SERVDIR_AITHIGH_INTERNAL_INDEX], &AITFromServDirHigh, 
            sizeof(AITFromServDirHigh), &cbActual, 0, NULL));


    // If it's time to reset, reset to 0.
    if (bResetToZero != 0) {
        DWORD zero = 0;
        
        CALL(JetPrepareUpdate(sesid, servdirtableid, JET_prepReplace));

        // Set the columns: Low, High, and NumFailedPings.
        CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_AITLOW_INTERNAL_INDEX], &zero, sizeof(zero), 0, NULL));
        CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_AITHIGH_INTERNAL_INDEX], &zero, sizeof(zero), 0, NULL));
        CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_NUMFAILPINGS_INTERNAL_INDEX], &zero, sizeof(zero), 0, 
                NULL));

        CALL(JetUpdate(sesid, servdirtableid, NULL, 0, &cbActual));
    }
    // Otherwise, if the server isn't already pending a reconnect,
    else if ((AITFromServDirLow == 0) && (AITFromServDirHigh == 0)) {
        FILETIME ft;
        SYSTEMTIME st;
        
        // Retrieve the time.
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);

        CALL(JetPrepareUpdate(sesid, servdirtableid, JET_prepReplace));

        // Set the columns.
        CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_AITLOW_INTERNAL_INDEX], &(ft.dwLowDateTime), 
                sizeof(ft.dwLowDateTime), 0, NULL));
        CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_AITHIGH_INTERNAL_INDEX], &(ft.dwHighDateTime), 
                sizeof(ft.dwHighDateTime), 0, NULL));

        CALL(JetUpdate(sesid, servdirtableid, NULL, 0, &cbActual));
    }
    // Else if we were told to increment the failure count
    else if (FailureCount != NULL) {
        if (*FailureCount != 0) {
            DWORD FailureCountFromServDir;

            // Get the current failure count.
            CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_NUMFAILPINGS_INTERNAL_INDEX], 
                    &FailureCountFromServDir, sizeof(FailureCountFromServDir), 
                    &cbActual, 0, NULL));

            // Set return value, also value used for update.
            *FailureCount = FailureCountFromServDir + 1;

            CALL(JetPrepareUpdate(sesid, servdirtableid, JET_prepReplace));
  
            // Set the column.
            CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_NUMFAILPINGS_INTERNAL_INDEX],
                    FailureCount, sizeof(*FailureCount), 0, NULL));
            CALL(JetUpdate(sesid, servdirtableid, NULL, 0, &cbActual));
            
        }
    }

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    return (DWORD) E_FAIL;
}


DWORD TSSDRpcRepopulateAllSessions(
        handle_t Binding,
        HCLIENTINFO *hCI,
        DWORD NumSessions,
        TSSD_RepopInfo rpi[])
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    JET_SETCOLUMN scSessDir[NUM_SESSDIRCOLUMNS];
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;
    unsigned count; // inside each record
    unsigned iCurrSession;
    unsigned long cbActual;
    char State;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"RepopAllSess: ServID = %d, NumSessions = %d, ...\n",
            *pCI, NumSessions);

    memset(&scSessDir[0], 0, sizeof(JET_SETCOLUMN) * NUM_SESSDIRCOLUMNS);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));

    // Verify that the ServerID passed in was OK.
    if (TSSDVerifyServerIDValid(sesid, servdirtableid, PtrToUlong(*hCI)) == FALSE) {
        TSDISErrorOut(L"Invalid ServerID was passed in\n");
        goto HandleError;
    }


    // Set up some constants for all updates.
    for (count = 0; count < NUM_SESSDIRCOLUMNS; count++) {
        scSessDir[count].columnid = sesdircolumnid[count];
        scSessDir[count].cbData = 4; // most of them, set the rest individually
        scSessDir[count].itagSequence = 1;
    }
    scSessDir[SESSDIR_STATE_INTERNAL_INDEX].cbData = sizeof(char);

    // Now do each update in a loop.
    for (iCurrSession = 0; iCurrSession < NumSessions; iCurrSession += 1) {
        err = JetMove(sesid, sessdirtableid, JET_MoveLast, 0);

        CALL(JetPrepareUpdate(sesid, sessdirtableid, JET_prepInsert));

        scSessDir[SESSDIR_USERNAME_INTERNAL_INDEX].cbData = 
                (unsigned) (wcslen(rpi[iCurrSession].UserName) + 1) * 
                sizeof(WCHAR);
        scSessDir[SESSDIR_DOMAIN_INTERNAL_INDEX].cbData =
                (unsigned) (wcslen(rpi[iCurrSession].Domain) + 1) * 
                sizeof(WCHAR);
        scSessDir[SESSDIR_APPTYPE_INTERNAL_INDEX].cbData = 
                (unsigned) (wcslen(rpi[iCurrSession].AppType) + 1) * 
                sizeof(WCHAR);

        scSessDir[SESSDIR_USERNAME_INTERNAL_INDEX].pvData = 
                rpi[iCurrSession].UserName;
        scSessDir[SESSDIR_DOMAIN_INTERNAL_INDEX].pvData = 
                rpi[iCurrSession].Domain;
        scSessDir[SESSDIR_SERVERID_INTERNAL_INDEX].pvData = pCI;
        scSessDir[SESSDIR_SESSIONID_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].SessionID;
        scSessDir[SESSDIR_TSPROTOCOL_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].TSProtocol;
        scSessDir[SESSDIR_CTLOW_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].CreateTimeLow;
        scSessDir[SESSDIR_CTHIGH_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].CreateTimeHigh;
        scSessDir[SESSDIR_DTLOW_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].DisconnectTimeLow;
        scSessDir[SESSDIR_DTHIGH_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].DisconnectTimeHigh;
        scSessDir[SESSDIR_APPTYPE_INTERNAL_INDEX].pvData = 
                rpi[iCurrSession].AppType;
        scSessDir[SESSDIR_RESWIDTH_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].ResolutionWidth;
        scSessDir[SESSDIR_RESHEIGHT_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].ResolutionHeight;
        scSessDir[SESSDIR_COLORDEPTH_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].ColorDepth;

        State = (char) rpi[iCurrSession].State;
        scSessDir[SESSDIR_STATE_INTERNAL_INDEX].pvData = &State;

        CALL(JetSetColumns(sesid, sessdirtableid, scSessDir, 
                NUM_SESSDIRCOLUMNS));
        CALL(JetUpdate(sesid, sessdirtableid, NULL, 0, &cbActual));
    }

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    return (DWORD) E_FAIL;

}


// Called to determine whether a ServerID passed in is valid.  TRUE if valid,
// FALSE otherwise.
// 
// Must be inside a transaction, and sesid and servdirtableid must be ready to 
// go.
BOOL TSSDVerifyServerIDValid(JET_SESID sesid, JET_TABLEID servdirtableid, 
        DWORD ServerID)
{
    JET_ERR err;
    
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerIDIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, (const void *) &ServerID, 
            sizeof(DWORD), JET_bitNewKey));
    // If the ServerID is there, this will succeed, otherwise it will fail and
    // jump to HandleError.
    CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));

    return TRUE;

HandleError:
    return FALSE;
}

// Rundown procedure for when a CLIENTINFO is destroyed as a result of a
// connection loss or client termination.
void HCLIENTINFO_rundown(HCLIENTINFO hCI)
{
    CLIENTINFO CI = PtrToUlong(hCI);

    TSDISErrorOut(L"In HCLIENTINFO_rundown: ServerID=%d\n", CI);

    if (CI != NULL)
        TSSDPurgeServer(CI);
    
    hCI = NULL;
}

#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\dis\jetsdis.h ===
/****************************************************************************/
// Jet-Based Session Directory and Integrity Service, header file
//
// Copyright (C) 2000, Microsoft Corporation
/****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <esent.h>
#include <stdarg.h>
#include <clusapi.h>
#include <resapi.h>
#include <winioctl.h>
#include <basetsd.h>


#define NUM_SESSDIRCOLUMNS 14
#define NUM_SERVDIRCOLUMNS 7
#define NUM_CLUSDIRCOLUMNS 3

#define JETDISMAXSESSIONS 256
#define TSSD_MaxDisconnectedSessions 10

// NOTE: Change these both at the same time.  Also, if you change these,
// change the following two.
#define JETDISDBDIRECTORY ".\\tssesdir\\"
#define JETDISDBDIRECTORYW L".\\tssesdir\\"

// NOTE: Change these both at the same time.
#define JETDBFILENAME ".\\tssesdir\\tssesdir.edb"
#define JETDBFILENAMEW L".\\tssesdir\\tssesdir.edb"


// Auxiliary JET files for deletion when starting clean
#define JETAUXFILENAME1W L".\\tssesdir\\edb.chk"
#define JETAUXFILENAME2W L".\\tssesdir\\edb.log"
#define JETAUXFILENAME3W L".\\tssesdir\\res1.log"
#define JETAUXFILENAME4W L".\\tssesdir\\res2.log"
#define JETAUXFILENAME5W L".\\tssesdir\\tmp.edb"
#define JETAUXFILENAME6W L".\\tssesdir\\edbtmp.log"

// "edbxxxxx.log" (with null terminator) is 13, but we also need the directory
// name.
#define MAX_LOGFILE_LENGTH 256


#define MAX_DEBUG_STRING_LENGTH 256

// "4294967295: " (no null required)
#define MAX_THREADIDSTR_LENGTH 12

#define MAX_DATE_TIME_STRING_LENGTH 64


#define CALL(x) { \
    err = x; \
    if (err != JET_errSuccess) { \
        TSDISErrorOut(L"TSSDIS: Jet error %d, line %d, file %S\n", err, __LINE__, \
                __FILE__); \
        goto HandleError; \
    } \
}


typedef struct _DIRCOLUMNS {
    char *szColumnName;
    JET_COLTYP coltyp;
    int colMaxLen;
} DIRCOLUMNS;


extern const DIRCOLUMNS SessionDirectoryColumns[];
extern const DIRCOLUMNS ServerDirectoryColumns[];
extern const DIRCOLUMNS ClusterDirectoryColumns[];

extern JET_COLUMNID sesdircolumnid[];
extern JET_COLUMNID servdircolumnid[];
extern JET_COLUMNID clusdircolumnid[];

extern JET_INSTANCE g_instance;

#define SESSDIR_USERNAME_INTERNAL_INDEX 0
#define SESSDIR_DOMAIN_INTERNAL_INDEX 1
#define SESSDIR_SERVERID_INTERNAL_INDEX 2
#define SESSDIR_SESSIONID_INTERNAL_INDEX 3
#define SESSDIR_TSPROTOCOL_INTERNAL_INDEX 4
#define SESSDIR_CTLOW_INTERNAL_INDEX 5
#define SESSDIR_CTHIGH_INTERNAL_INDEX 6
#define SESSDIR_DTLOW_INTERNAL_INDEX 7
#define SESSDIR_DTHIGH_INTERNAL_INDEX 8
#define SESSDIR_APPTYPE_INTERNAL_INDEX 9
#define SESSDIR_RESWIDTH_INTERNAL_INDEX 10
#define SESSDIR_RESHEIGHT_INTERNAL_INDEX 11
#define SESSDIR_COLORDEPTH_INTERNAL_INDEX 12
#define SESSDIR_STATE_INTERNAL_INDEX 13

#define SERVDIR_SERVID_INTERNAL_INDEX 0
#define SERVDIR_SERVADDR_INTERNAL_INDEX 1
#define SERVDIR_CLUSID_INTERNAL_INDEX 2
#define SERVDIR_AITLOW_INTERNAL_INDEX 3
#define SERVDIR_AITHIGH_INTERNAL_INDEX 4
#define SERVDIR_NUMFAILPINGS_INTERNAL_INDEX 5
#define SERVDIR_SINGLESESS_INTERNAL_INDEX 6

#define CLUSDIR_CLUSID_INTERNAL_INDEX 0
#define CLUSDIR_CLUSNAME_INTERNAL_INDEX 1
#define CLUSDIR_SINGLESESS_INTERNAL_INDEX 2


void TSDISErrorOut(wchar_t *format_string, ...);
void TSDISErrorTimeOut(wchar_t *format_string, DWORD TimeLow, DWORD TimeHigh);
DWORD TSSDPurgeServer(DWORD ServerID);
BOOL TSSDVerifyServerIDValid(JET_SESID sesid, JET_TABLEID servdirtableid, 
        DWORD ServerID);
DWORD TSSDSetServerAITInternal(WCHAR *ServerAddress, DWORD bResetToZero, DWORD
        *FailureCount);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\dis\trace.c ===
/****************************************************************************/
// trace.c
//
// Tracing code and definitions. See trace.h for other info.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#if DBG || defined(_DEBUG)

#include <windows.h>

#include "trace.h"


struct _ZoneInfo
{
    UINT32 Zone;
    char *Prefix;
} TRC_ZI[] =
{
    { Z_ASSERT, "DIS: !!! ASSERT: " },
    { Z_ERR,    "DIS: *** ERROR: " },
    { Z_WRN,    "DIS: Warning: " },
    { Z_TRC1,   "DIS: " },
    { Z_TRC2,   "DIS: " },
};
int NumTRC_ZIEntries = sizeof(TRC_ZI) / sizeof(struct _ZoneInfo);


// Globals.
UINT32 g_TraceMask = 0xFFFFFFFF;
char TB[1024];
char TB2[1024];


// Main output function.
void TracePrintZ(UINT32 ZoneFlag, char *OutString)
{
    int i;
    char *Prefix = "";

    // Find the zone information in the zone table.
    for (i = 0; i < NumTRC_ZIEntries; i++)
        if (TRC_ZI[i].Zone == ZoneFlag)
            Prefix = TRC_ZI[i].Prefix;

    // Now create the final string.
    wsprintfA(TB2, "%s%s\n", Prefix, OutString);

    // Send to output.
    OutputDebugStringA(TB2);
}



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\inc\tssd.h ===
/****************************************************************************/
// tssd.h
//
// Terminal Server Session Directory Interface main header.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/
#ifndef __TSSD_H
#define __TSSD_H

#include "itssd.h"


// Max number of disconnected sessions allowed from a disc session query.
#define TSSD_MaxDisconnectedSessions 10

// Return value from UI code to signal that TermSrv needs to update
// its info from the registry.

// TS protocol types.
#define TSProtocol_ICA 1
#define TSProtocol_RDP 2


// {0241e043-1cb6-4716-aa50-6a492049c3f3}
DEFINE_GUID(IID_ITSSessionDirectory,
        0x0241e043, 0x1cb6, 0x4716, 0xaa, 0x50, 0x6a, 0x49, 0x20, 0x49, 0xc3, 0xf3);

// {012b47b7-2f06-4154-ad0c-c64bcdf0d512}
DEFINE_GUID(IID_ITSSessionDirectoryEx,
        0x012b47b7, 0x2f06, 0x4154, 0xad, 0x0c, 0xc6, 0x4b, 0xcd, 0xf0, 0xd5, 0x12);

#endif  // __TSSD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\testcli\tssdcli.cpp ===
/****************************************************************************/
// tssdcli.cpp
//
// Terminal Server Session Directory test client code.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#define INITGUID
#include <windows.h>
#include <objbase.h>
#include <stdio.h>

#include <tssd.h>


// Test session data.
const WCHAR *ServerName = L"TSSDTestSvrName";
const WCHAR *TestClusterName = L"TSSDTestClusterName";

const TSSD_CreateSessionInfo TestSessions[] =
{
    { L"FooUser1", L"FooDomain", 1, TSProtocol_RDP, L"", 1024, 768, 8, 0,
            0xFFFF },

};

const FILETIME TestSessionDiscTime[] =
{
    { 0, 0xCCCC },
};


/****************************************************************************/
// Command line main
/****************************************************************************/
int __cdecl main(int argc, char *argv[])
{
    int rc = 1;
    DWORD NumSessions;
    HRESULT hr;
    FILETIME FileTime;
    LONG RegRetVal;
    HKEY hKey;
    DWORD Len;
    DWORD Type;
    ITSSessionDirectory *pTSSD;
    CLSID TSSDCLSID;
    WCHAR CLSIDStr[39];
    WCHAR StoreServerName[64];
    WCHAR ClusterName[64];
    WCHAR OpaqueSettings[256];
    TSSD_CreateSessionInfo CreateInfo;
    TSSD_DisconnectedSessionInfo DiscInfo[10];
    TSSD_ReconnectSessionInfo ReconnInfo;

    printf("TS Session Directory test client\n");

    // Initialize COM
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (SUCCEEDED(hr)) {
        printf("    Initialized COM\n");
    }
    else {
        printf("*** Failed to init COM\n");
        return 1;
    }

    // Get the CLSID of the session directory object to instantiate.
    RegRetVal = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\Terminal Server",
            0, KEY_READ, &hKey);
    if (RegRetVal == ERROR_SUCCESS) {
        CLSIDStr[0] = L'\0';
        Len = sizeof(CLSIDStr);
        RegQueryValueExW(hKey, L"SessionDirectoryCLSID",
                NULL, &Type, (BYTE *)CLSIDStr, &Len);
        if (wcslen(CLSIDStr) == 0 ||
                !SUCCEEDED(CLSIDFromString(CLSIDStr, &TSSDCLSID))) {
            printf("*** SessDir CLSID invalid, idstr=%S\n", CLSIDStr);
            RegCloseKey(hKey);
            goto PostInitCOM;
        }

        RegCloseKey(hKey);
    }
    else {
        printf("*** Failed to open TS key\n");
        goto PostInitCOM;
    }

    // Get the reg settings for the sessdir object. Absence of these settings
    // is not an error.
    StoreServerName[0] = L'\0';
    ClusterName[0] = L'\0';
    OpaqueSettings[0] = L'\0';
    RegRetVal = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\Terminal Server\\ClusterSettings",
            0, KEY_READ, &hKey);
    if (RegRetVal == ERROR_SUCCESS) {
        Len = sizeof(StoreServerName);
        RegRetVal = RegQueryValueExW(hKey, L"SessionDirectoryLocation",
                NULL, &Type, (BYTE *)StoreServerName, &Len);

        Len = sizeof(ClusterName);
        RegRetVal = RegQueryValueExW(hKey, L"SessionDirectoryClusterName",
                NULL, &Type, (BYTE *)ClusterName, &Len);

        // Not an error for the string to be absent or empty.
        Len = sizeof(OpaqueSettings);
        RegRetVal = RegQueryValueExW(hKey, L"SessionDirectoryAdditionalParams",
                NULL, &Type, (BYTE *)OpaqueSettings, &Len);

        RegCloseKey(hKey);
    }

    printf("    Retrieved reg settings:\n");
    printf("        SessionDirectoryLocation: %S\n", StoreServerName);
    printf("        SessionDirectoryClusterName: %S\n", ClusterName);
    printf("        TestClusterName: %S\n", TestClusterName);
    printf("        SessionDirectoryAdditionalParams: %S\n", OpaqueSettings);
    
    // Open the TSSD object.
    hr = CoCreateInstance(TSSDCLSID, NULL, CLSCTX_INPROC_SERVER,
            IID_ITSSessionDirectory, (void **)&pTSSD);
    if (SUCCEEDED (hr)) {
        printf("    Created a TSSD object\n");
    }
    else {
        printf("*** Failed to create a TSSD, hr=0x%X\n", hr);
        goto PostInitCOM;
    }

    // Initialize with a test local server address.
    hr = pTSSD->Initialize((WCHAR *)ServerName, StoreServerName,
            (WCHAR *)TestClusterName, OpaqueSettings);
    if (SUCCEEDED(hr)) {
        printf("    Initialized TSSD, servername=%S\n", ServerName);
    }
    else {
        printf("*** Failed init TSSD, hr=0x%X\n", hr);
        goto PostCreateTSSD;
    }

    // Create one test session.
    CreateInfo = TestSessions[0];
    hr = pTSSD->NotifyCreateLocalSession(&CreateInfo);
    if (SUCCEEDED(hr)) {
        printf("    Created test SessionID %u, uname=%S, domain=%S\n",
                TestSessions[0].SessionID, TestSessions[0].UserName,
                TestSessions[0].Domain);
    }
    else {
        printf("*** Failed create session, hr=0x%X\n", hr);
        goto PostCreateTSSD;
    }

    hr = pTSSD->GetUserDisconnectedSessions((WCHAR *)TestSessions[0].UserName,
            (WCHAR *)TestSessions[0].Domain, &NumSessions, DiscInfo);
    if (SUCCEEDED(hr)) {
        if (NumSessions == 0) {
            printf("    Disc session query returned 0 sessions as expected\n");
        }
        else if (NumSessions > TSSD_MaxDisconnectedSessions) {
            printf("*** Disc session query returned %u sessions, over limit "
                    "of %u\n", NumSessions, TSSD_MaxDisconnectedSessions);
            goto PostCreateTSSD;
        }
        else {
            printf("*** Disc session query returned %u sessions, should be 0\n",
                    NumSessions);
            goto PostCreateTSSD;
        }
    }
    else {
        printf("*** Failed GetDisc, hr=0x%X\n", hr);
        goto PostCreateTSSD;
    }

    FileTime = TestSessionDiscTime[0];
    hr = pTSSD->NotifyDisconnectLocalSession(1, FileTime);
    if (SUCCEEDED(hr)) {
        printf("    Changed test SessionID %u to disconnected\n",
                TestSessions[0].SessionID);
    }
    else {
        printf("*** Failed set test session to disc, hr=0x%X\n", hr);
        goto PostCreateTSSD;
    }

    hr = pTSSD->GetUserDisconnectedSessions((WCHAR *)TestSessions[0].UserName,
            (WCHAR *)TestSessions[0].Domain, &NumSessions, DiscInfo);
    if (SUCCEEDED(hr)) {
        if (NumSessions == 1) {
            printf("    Disc session query returned 1 session as expected\n");

            // Validate the session info returned.
            if (_wcsicmp(DiscInfo[0].ServerAddress, ServerName)) {
                printf("*** Ret ServerAddr %S does not match expected %S\n",
                        DiscInfo[0].ServerAddress, ServerName);
            }
            if (DiscInfo[0].SessionID != TestSessions[0].SessionID) {
                printf("*** Ret SessionID %u does not match expected %u\n",
                        DiscInfo[0].SessionID,
                        TestSessions[0].SessionID);
            }
            if (DiscInfo[0].TSProtocol != TestSessions[0].TSProtocol) {
                printf("*** Ret TSProtocol %u does not match expected %u\n",
                        DiscInfo[0].TSProtocol,
                        TestSessions[0].TSProtocol);
            }
            if (_wcsicmp(DiscInfo[0].ApplicationType,
                    TestSessions[0].ApplicationType)) {
                printf("*** Ret AppType %S does not match expected %S\n",
                        DiscInfo[0].ApplicationType,
                        TestSessions[0].ApplicationType);
            }
            if (DiscInfo[0].ResolutionWidth != TestSessions[0].ResolutionWidth) {
                printf("*** Ret Width %u does not match expected %u\n",
                        DiscInfo[0].ResolutionWidth,
                        TestSessions[0].ResolutionWidth);
            }
            if (DiscInfo[0].ResolutionHeight != TestSessions[0].ResolutionHeight) {
                printf("*** Ret Height %u does not match expected %u\n",
                        DiscInfo[0].ResolutionHeight,
                        TestSessions[0].ResolutionHeight);
            }
            if (DiscInfo[0].ColorDepth != TestSessions[0].ColorDepth) {
                printf("*** Ret ColorDepth %u does not match expected %u\n",
                        DiscInfo[0].ColorDepth,
                        TestSessions[0].ColorDepth);
            }
            if (memcmp(&DiscInfo[0].CreateTime, &TestSessions[0].CreateTime,
                    sizeof(FILETIME))) {
                printf("*** Ret CreateTime %u:%u does not match expected %u:%u\n",
                        DiscInfo[0].CreateTime.dwHighDateTime,
                        DiscInfo[0].CreateTime.dwLowDateTime,
                        TestSessions[0].CreateTime.dwHighDateTime,
                        TestSessions[0].CreateTime.dwLowDateTime);
            }
            if (memcmp(&DiscInfo[0].DisconnectionTime, &TestSessionDiscTime[0],
                    sizeof(FILETIME))) {
                printf("*** Ret DiscTime %X:%X does not match expected %X:%X\n",
                        DiscInfo[0].DisconnectionTime.dwHighDateTime,
                        DiscInfo[0].DisconnectionTime.dwLowDateTime,
                        TestSessionDiscTime[0].dwHighDateTime,
                        TestSessionDiscTime[0].dwLowDateTime);
            }
        }
        else if (NumSessions > TSSD_MaxDisconnectedSessions) {
            printf("*** Disc session query returned %u sessions, over limit "
                    "of %u\n", NumSessions, TSSD_MaxDisconnectedSessions);
            goto PostCreateTSSD;
        }
        else {
            printf("*** Disc session query returned %u sessions, should be 1\n",
                    NumSessions);
            goto PostCreateTSSD;
        }
    }
    else {
        printf("*** Failed GetDisc, hr=0x%X\n", hr);
        goto PostCreateTSSD;
    }

    ReconnInfo.SessionID = TestSessions[0].SessionID;
    ReconnInfo.TSProtocol = TestSessions[0].TSProtocol;
    ReconnInfo.ResolutionWidth = TestSessions[0].ResolutionWidth;
    ReconnInfo.ResolutionHeight = TestSessions[0].ResolutionHeight;
    ReconnInfo.ColorDepth = TestSessions[0].ColorDepth;
    hr = pTSSD->NotifyReconnectLocalSession(&ReconnInfo);
    if (SUCCEEDED(hr)) {
        printf("    Changed test SessionID %u to connected\n",
                TestSessions[0].SessionID);
    }
    else {
        printf("*** Failed set test sessionID %u to conn, hr=0x%X\n",
                TestSessions[0].SessionID, hr);
        goto PostCreateTSSD;
    }

    // Verify again that there are no disconnected sessions.
    hr = pTSSD->GetUserDisconnectedSessions((WCHAR *)TestSessions[0].UserName,
            (WCHAR *)TestSessions[0].Domain, &NumSessions, DiscInfo);
    if (SUCCEEDED(hr)) {
        if (NumSessions == 0) {
            printf("    Disc session query returned 0 sessions as expected\n");
        }
        else if (NumSessions > TSSD_MaxDisconnectedSessions) {
            printf("*** Disc session query returned %u sessions, over limit "
                    "of %u\n", NumSessions, TSSD_MaxDisconnectedSessions);
            goto PostCreateTSSD;
        }
        else {
            printf("*** Disc session query returned %u sessions, should be 0\n",
                    NumSessions);
            goto PostCreateTSSD;
        }
    }
    else {
        printf("*** Failed GetDisc, hr=0x%X\n", hr);
        goto PostCreateTSSD;
    }

    // Success.
    rc = 0;

PostCreateTSSD:
    pTSSD->Release();

PostInitCOM:
    CoUninitialize();

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\dis\tssdis.cpp ===
/****************************************************************************/
// Directory Integrity Service
//
// Copyright (C) 2000, Microsoft Corporation
/****************************************************************************/


#include "dis.h"
#include "jetrpc.h"
#include "jetsdis.h"
#include "sdevent.h"


#pragma warning (push, 4)

#define SERVER_ADDRESS_LENGTH 64
#define NUM_JETRPC_THREADS 10
#define MAX_DRIVE_LETTER_LENGTH 24
// Number of 100-nanosecond periods in 1 second.
#define FILETIME_INTERVAL_TO_SECONDS_MULTIPLIER 10000000

#define DEBUG_LOG_FILENAME L"tssdis.log"

#define MY_STATUS_COMMITMENT_LIMIT          (0xC000012DL)

#define MAX_INSTANCE_MEMORYERR 20


const DIRCOLUMNS SessionDirectoryColumns[NUM_SESSDIRCOLUMNS] = {
    { "UserName", JET_coltypLongText, 512 },
    { "Domain", JET_coltypLongText, 254 },
    { "ServerID", JET_coltypLong, 0 },
    { "SessionID", JET_coltypLong, 0 },
    { "TSProtocol", JET_coltypLong, 0 },
    { "CreateTimeLow", JET_coltypLong, 0 },
    { "CreateTimeHigh", JET_coltypLong, 0 },
    { "DisconnectTimeLow", JET_coltypLong, 0 },
    { "DisconnectTimeHigh", JET_coltypLong, 0 },
    { "ApplicationType", JET_coltypLongText, 512 },
    { "ResolutionWidth", JET_coltypLong, 0 },
    { "ResolutionHeight", JET_coltypLong, 0 },
    { "ColorDepth", JET_coltypLong, 0 },
    { "State", JET_coltypBit, 0 },
};


const DIRCOLUMNS ServerDirectoryColumns[NUM_SERVDIRCOLUMNS] = {
    { "ServerID", JET_coltypLong, 0 },
    { "ServerAddress", JET_coltypLongText, 128 },
    { "ClusterID", JET_coltypLong, 0 },
    { "AlmostInTimeLow", JET_coltypLong, 0 },
    { "AlmostInTimeHigh", JET_coltypLong, 0 },
    { "NumberFailedPings", JET_coltypLong, 0 },
    { "SingleSessionMode", JET_coltypBit, 0 },
};


const DIRCOLUMNS ClusterDirectoryColumns[NUM_CLUSDIRCOLUMNS] = {
    { "ClusterID", JET_coltypLong, 0 },
    { "ClusterName", JET_coltypLongText, 128 },
    { "SingleSessionMode", JET_coltypBit, 0 },
};


JET_COLUMNID sesdircolumnid[NUM_SESSDIRCOLUMNS];
JET_COLUMNID servdircolumnid[NUM_SERVDIRCOLUMNS];
JET_COLUMNID clusdircolumnid[NUM_CLUSDIRCOLUMNS];

JET_INSTANCE g_instance = 0;

ADOConnection *g_pConnection;
HANDLE g_hStopServiceEvent;

SERVICE_STATUS g_DISStatus;
SERVICE_STATUS_HANDLE g_DISStatusHandle;

BOOL g_bDebug = FALSE;


// Registry settings follow
#if 0
DWORD g_bUseSQL = 0;
#endif


enum TraceOutputMode {
    NoTraceOutput,
    DebugPrintOutput,
    StdOutput,
    FileOutput
};

TraceOutputMode g_TraceOutputMode = NoTraceOutput;
HANDLE g_hFileOutput = INVALID_HANDLE_VALUE;

// For debugging purposes, we can set the ping mode to something other than
// WinStationOpenServer using the registry.
enum PingMode {
    NormalMode,
    AlwaysSucceed,
    AlwaysFail
};

PingMode g_PingMode = NormalMode;

ULONGLONG g_TimeServerSilentBeforePing = 60 * FILETIME_INTERVAL_TO_SECONDS_MULTIPLIER;
DWORD DISNumberSecondsBetweenPings = 10;
DWORD g_NumberFailedPingsBeforePurge = 3;


#ifdef DBG
void OutputAllTables();
#endif


void TSDISErrorOut(wchar_t *format_string, ...)
{
    // Immediately bail out if we are in NoTraceOutput mode.
    if (g_TraceOutputMode == NoTraceOutput) {
        return;
    }
    else {
        // Otherwise, do the right thing.
        wchar_t TotalString[MAX_DEBUG_STRING_LENGTH + MAX_THREADIDSTR_LENGTH];
        wchar_t *ThreadIDString = TotalString;
        wchar_t *DebugOutString = NULL;
        va_list args;
        int ThreadStrLength;

        // Get the current thread ID
        ThreadStrLength = _snwprintf(ThreadIDString, MAX_THREADIDSTR_LENGTH, 
                L"%d: ", GetCurrentThreadId());

        // Set the place for the out string to after the string, or after the whole
        // buffer if _snwprintf didn't have enough space.
        if (ThreadStrLength > 0)
            DebugOutString = &TotalString[ThreadStrLength];
        else
            DebugOutString = &TotalString[MAX_THREADIDSTR_LENGTH];
            
        va_start(args, format_string);

        // Create the debug output string.
        _vsnwprintf(DebugOutString, MAX_DEBUG_STRING_LENGTH, format_string, args);
        DebugOutString[MAX_DEBUG_STRING_LENGTH - 1] = '\0';

        // Output to the correct place.
        switch (g_TraceOutputMode) {
            
        case DebugPrintOutput:
            OutputDebugString(TotalString);
            break;

        case StdOutput:
            wprintf(TotalString);
            break;

        case FileOutput:
            {
                char TotalStringA[MAX_DEBUG_STRING_LENGTH + 
                        MAX_THREADIDSTR_LENGTH];
                DWORD dwBytes = 0;

                // Convert to ANSI.
                dwBytes = WideCharToMultiByte(CP_ACP, 0, TotalString, 
                        -1, TotalStringA, MAX_DEBUG_STRING_LENGTH + 
                        MAX_THREADIDSTR_LENGTH, 0, 0);

                // Don't write the terminating NULL (3rd argument)!
                // Ignore return value.
                WriteFile(g_hFileOutput, TotalStringA, dwBytes - 1, 
                        &dwBytes, NULL);
                
                break;
            }
        }

        va_end(args);
    }
}


// TSDISErrorTimeOut
//
// This function is used to output a single FILETIME low, high pair.  The format
// string, given as the first argument, MUST specify a %s format specifier for
// where the date/time should go.
//
// Example:
//  TSDISErrorTimeOut(L"The date and time are %s\n", CurrTimeLow, CurrTimeHigh);
void TSDISErrorTimeOut(wchar_t *format_string, DWORD TimeLow, DWORD TimeHigh)
{
    if (g_TraceOutputMode == NoTraceOutput) {
        return;
    }
    else {
        // We just need to convert the FILETIME we have into a SYSTEMTIME,
        // and then output the SYSTEMTIME using GetDateFormat and GetTimeFormat.
        FILETIME ft;
        SYSTEMTIME st;
        SYSTEMTIME stloc;
        int offset = 0;
        wchar_t DateString[MAX_DATE_TIME_STRING_LENGTH];

        ft.dwLowDateTime = TimeLow;
        ft.dwHighDateTime = TimeHigh;

        if (FileTimeToSystemTime(&ft, &st) != 0) {
            // st is the system time.

            // UTC format?
            if (SystemTimeToTzSpecificLocalTime(NULL, &st, &stloc) != 0) {
                offset = GetDateFormat(LOCALE_SYSTEM_DEFAULT, DATE_SHORTDATE, 
                        &stloc, NULL, DateString, MAX_DATE_TIME_STRING_LENGTH);

                if (offset != 0) {
                    // Turn the terminating NULL into a space.
                    DateString[offset - 1] = ' ';
                    
                    // Write the time after the space.
                    offset = GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &stloc, 
                            NULL, &DateString[offset], 
                            MAX_DATE_TIME_STRING_LENGTH - offset);

                    if (offset != 0) {
                        // Output the string.
                        TSDISErrorOut(format_string, DateString);
                    }
                }
            }
        }
    }
}


// This function is duplicated from \nt\termsrv\winsta\server\sessdir.cpp.
//
// PostSessDirErrorValueEvent
//
// Utility function used to create a system log error event containing one
// hex DWORD error code value.
void PostSessDirErrorValueEvent(unsigned EventCode, DWORD ErrVal)
{
    HANDLE hLog;
    WCHAR hrString[128];
    PWSTR String = NULL;
    static DWORD numInstances = 0;
    //
    //count the numinstances of out of memory error, if this is more than
    //a specified number, we just won't log them
    //
    if( MY_STATUS_COMMITMENT_LIMIT == ErrVal )
    {
        if( numInstances > MAX_INSTANCE_MEMORYERR )
            return;
         //
        //if applicable, tell the user that we won't log any more of the out of memory errors
        //
        if( numInstances >= MAX_INSTANCE_MEMORYERR - 1 ) {
            wsprintfW(hrString, L"0x%X. This type of error will not be logged again to avoid eventlog fillup.", ErrVal);
            String = hrString;
        }
        numInstances++;
    }

    hLog = RegisterEventSource(NULL, L"TermServSessDir");
   if (hLog != NULL) {
        if( NULL == String ) {
            wsprintfW(hrString, L"0x%X", ErrVal);
            String = hrString;
        }
        ReportEvent(hLog, EVENTLOG_ERROR_TYPE, 0, EventCode, NULL, 1, 0,
                (const WCHAR **)&String, NULL);
        DeregisterEventSource(hLog);
    }
}



// DISJetGetServersPendingReconnects
//
// Returns arrays of max length 10 of servers pending reconnects, where the
// reconnect is greater than g_TimeServerSilentBeforePing seconds.
HRESULT STDMETHODCALLTYPE DISJetGetServersPendingReconnects(
        OUT long __RPC_FAR *pNumSessionsReturned,
        OUT WCHAR ServerAddressRows[10][SERVER_ADDRESS_LENGTH],
        OUT DWORD ServerIDs[10])
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID servdirtableid;
    DWORD zero = 0;
    *pNumSessionsReturned = 0;
    unsigned i = 0;
    unsigned long cbActual;
    // These are really FILETIMEs, but we want to do 64-bit math on them,
    // and they're the same structure as FILETIMEs.
    ULARGE_INTEGER ulCurrentTime;
    ULARGE_INTEGER ulAITTime;
        
    //TSDISErrorOut(L"GetPendRec...");
    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    // Get the current file time.
    SYSTEMTIME st;
    
    // Retrieve the time.
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, (FILETIME *) &ulCurrentTime);

    CALL(JetBeginTransaction(sesid));
    
    // Since Jet has no unsigned long type, go through the servers first
    // looking for keys greater than 0, 0, then looking for keys less than 0, 0
    // TODO: Consider how to do this with JET_coltypDateTime or using NULLs
    for (int j = 0; j < 2; j++) {
        CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerAlmostInTimes"));

        CALL(JetMakeKey(sesid, servdirtableid, &zero, sizeof(zero), 
                JET_bitNewKey));
        CALL(JetMakeKey(sesid, servdirtableid, &zero, sizeof(zero), 0));

        if (0 == j)
            err = JetSeek(sesid, servdirtableid, JET_bitSeekGT);
        else
            err = JetSeek(sesid, servdirtableid, JET_bitSeekLT);

        while ((i < TSSD_MaxDisconnectedSessions) && (JET_errSuccess == err)) {

            // Get AlmostInTimeLow, AlmostInTimeHigh (3 + 4) for computation.
            CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_AITLOW_INTERNAL_INDEX], &(ulAITTime.LowPart), 
                    sizeof(ulAITTime.LowPart), &cbActual, 0, NULL));
            CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_AITHIGH_INTERNAL_INDEX], &(ulAITTime.HighPart), 
                    sizeof(ulAITTime.HighPart), &cbActual, 0, NULL));

            // If the difference between the current time and the time the
            // server was stamped is greater than the set 
            // TimeServerSilentBeforePing, then put it in the return array, 
            // else don't.
            if ((ulCurrentTime.QuadPart - ulAITTime.QuadPart) > 
                    g_TimeServerSilentBeforePing) {

                // Get ServerID
                CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                        SERVDIR_SERVID_INTERNAL_INDEX], &ServerIDs[i], 
                        sizeof(ServerIDs[i]), &cbActual, 0, NULL));

                // Get the ServerAddress for this record.
                CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                        SERVDIR_SERVADDR_INTERNAL_INDEX], 
                        &ServerAddressRows[i][0], sizeof(ServerAddressRows[i]),
                        &cbActual, 0, NULL));

                i += 1;
            }

            // Move to the next matching record.
            if (0 == j)
                err = JetMove(sesid, servdirtableid, JET_MoveNext, 0);
            else
                err = JetMove(sesid, servdirtableid, JET_MovePrevious, 0);
        }
    }

    *pNumSessionsReturned = i;
    
    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return S_OK;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
    return E_FAIL;
}


#if 0
HRESULT STDMETHODCALLTYPE DISSQLGetServersPendingReconnects(
        OUT long __RPC_FAR *pNumSessionsReturned, 
        OUT CVar *pVarRows)
{
    long NumRecords = 0;
    HRESULT hr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;
    CVar varFields;
    CVar varStart;

    TRC2((TB,"GetServersWithDisconnectedSessions"));

    ASSERT((pNumSessionsReturned != NULL),(TB,"NULL pNumSess"));

    hr = CreateADOStoredProcCommand(L"SP_TSDISGetServersPendingReconnects",
            &pCommand, &pParameters);
    if (SUCCEEDED(hr)) {
        // Execute the command.
        hr = pCommand->Execute(NULL, NULL, adCmdStoredProc,
                &pResultRecordSet);

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"GetServersWDiscSess: Failed create cmd, hr=0x%X", hr));
    }
        
    // At this point we have a result recordset containing the server rows
    // corresponding to all of the disconnected sessions.
    if (SUCCEEDED(hr)) {
        long State;

        NumRecords = 0;

        hr = pResultRecordSet->get_State(&State);
        if (SUCCEEDED(hr)) {
            if (!(State & adStateClosed)) {
                VARIANT_BOOL VB;

                // If EOF the recordset is empty.
                hr = pResultRecordSet->get_EOF(&VB);
                if (SUCCEEDED(hr)) {
                    if (VB) {
                        TRC1((TB,"GetServersWDiscSess: Result recordset EOF, "
                                "0 rows"));
                        goto PostUnpackResultSet;
                    }
                }
                else {
                    ERR((TB,"GetServersWDiscSess: Failed get_EOF, hr=0x%X", 
                            hr));
                    goto PostUnpackResultSet;
                }
            }
            else {
                ERR((TB,"GetServersWDiscSess: Closed result recordset"));
                goto PostUnpackResultSet;
            }
        }
        else {
            ERR((TB,"GetServersWDiscSess: get_State failed, hr=0x%X", hr));
            goto PostUnpackResultSet;
        }
        
        // Grab the result data into a safearray, starting with the default
        // current row and all fields.
        varStart.InitNoParam();
        varFields.InitNoParam();
        hr = pResultRecordSet->GetRows(adGetRowsRest, varStart,
                varFields, pVarRows);
        if (SUCCEEDED(hr)) {
            hr = SafeArrayGetUBound(pVarRows->parray, 2, &NumRecords);
            if (SUCCEEDED(hr)) {
                // 0-based array bound was returned, num rows is that + 1.
                NumRecords++;

                TRC1((TB,"%d rows retrieved from safearray", NumRecords));
            }
            else {
                ERR((TB,"GetServersWithDisc: Failed safearray getubound, "
                        "hr=0x%X", hr));
                goto PostUnpackResultSet;
            }
        }
        else {
            ERR((TB,"GetServersWDiscSess: Failed to get rows, hr=0x%X", hr));
            goto PostUnpackResultSet;
        }


PostUnpackResultSet:
        pResultRecordSet->Release();
    }
    else {
        ERR((TB,"GetServersWDiscSess: Failed exec, hr=0x%X", hr));
    }

    *pNumSessionsReturned = NumRecords;
    return hr;
}
#endif


/****************************************************************************/
// DISDebugControlHandler
//
// Handle console control events for when service is in debug mode.
/****************************************************************************/
BOOL WINAPI DISDebugControlHandler(DWORD dwCtrlType) {
    switch(dwCtrlType)
    {
    case CTRL_BREAK_EVENT:
    case CTRL_C_EVENT:
        TSDISErrorOut(L"Stopping service\n");

        SetEvent(g_hStopServiceEvent);
        // Should I wait for that to complete?

        return TRUE;
        break;
    }
    return FALSE;
}


/****************************************************************************/
// DISPingServer
//
// Given the IP address of a server, pings it.  Returns TRUE on success, FALSE 
// on failure.
/****************************************************************************/
BOOLEAN DISPingServer(WCHAR *ServerAddress) {
    HANDLE hServer = NULL;
    hServer = WinStationOpenServer(ServerAddress);

    // The only case where we return false is where hServer is NULL and the
    // reason is not ERROR_ACCESS_DENIED.
    if (hServer == NULL) {
        if (GetLastError() != ERROR_ACCESS_DENIED)
            return FALSE;
    }
    else {
        // The hServer is valid, so clean up.
        WinStationCloseServer(hServer);
    }
    return TRUE;
}


/****************************************************************************/
// DISGetServerStatus
//
// Given the IP address of a server, determines its state (Responding or 
// NotResponding).
// 
// Currently implemented as a ping.  See lengthy comment in main for one
// possible future optimization.
/****************************************************************************/
SERVER_STATUS DISGetServerStatus(WCHAR *ServerAddress) {

    switch (g_PingMode) {

    case AlwaysFail:
        return NotResponding;

    case AlwaysSucceed:
        return Responding;

    case NormalMode:
        // NOTE INTENTIONAL FALLTHROUGH.
    default:
        if (DISPingServer(ServerAddress) == TRUE)
            return Responding;
        else
            return NotResponding;

    }

}


#if 0
HRESULT DISSQLInitialize() {
    // Retrieve number of seconds to wait from the registry -- NOT IMPLEMENTED
    HRESULT hr = S_OK;
    BSTR ConnectString = NULL;
    LONG RegRetVal;
    HKEY hKey;
    BSTR ConnectStr = NULL;
    BSTR UserStr = NULL;
    BSTR PwdStr = NULL;

    RegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\DIS"), 0, KEY_READ, &hKey);
    if (RegRetVal == ERROR_SUCCESS) {
        DWORD Type, DataSize;

        // Determine the needed size.
        DataSize = 0;
        RegRetVal = RegQueryValueExW(hKey, L"ConnectString", NULL,
                &Type, NULL, &DataSize);
        DataSize &= ~1;
        if (RegRetVal == ERROR_SUCCESS && Type == REG_SZ) {
            ConnectString = SysAllocStringLen(L"", DataSize /
                    sizeof(WCHAR));
            if (ConnectString != NULL) {
                RegRetVal = RegQueryValueExW(hKey, L"ConnectString",
                        NULL, &Type, (BYTE *)ConnectString,
                        &DataSize);
                if (RegRetVal == ERROR_SUCCESS) {
                    // Hold onto the connect string for use below.
                    TRC1((TB,"Retrieved conn str %S", ConnectString));
                }
                else {
                    ERR((TB,"Final RegQuery failed, err=%u", RegRetVal));
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }
            else {
                ERR((TB,"Failed alloc connect string"));
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        else {
            ERR((TB,"Failed RegQuery - err=%u, DataSize=%u, type=%u",
                    RegRetVal, DataSize, Type));
            hr = E_FAIL;
            goto Cleanup;
        }

        RegCloseKey(hKey);
    }
    else {
        ERR((TB,"RegOpenKeyEx returned err %u", RegRetVal));
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = CoInitialize(NULL);

    // Alloc the BSTRs for the connection.
    ConnectStr = SysAllocString(ConnectString);
    UserStr = SysAllocString(L"");
    PwdStr = SysAllocString(L"");

    if ((ConnectStr == NULL) || (UserStr == NULL) || (PwdStr == NULL)) {
        ERR((TB, "Failed alloc Connect, User, or PwdStr"));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Create an ADO connection instance and connect.
    hr = CoCreateInstance(CLSID_CADOConnection, NULL,
            CLSCTX_INPROC_SERVER, IID_IADOConnection,
            (LPVOID *)&g_pConnection);
    if (SUCCEEDED(hr)) {
        // Do the open.
        hr = g_pConnection->Open(ConnectStr, UserStr, PwdStr,
                adOpenUnspecified);
        if (!SUCCEEDED(hr)) {
            ERR((TB,"Failed open DB, hr=0x%X", hr));
            g_pConnection->Release();
            g_pConnection = NULL;
        }
    }
    else {
        ERR((TB,"CoCreate(ADOConn) returned 0x%X", hr));
    }

Cleanup:

    // SysFreeString(NULL) is ok.
    SysFreeString(ConnectString);
    SysFreeString(ConnectStr);
    SysFreeString(UserStr);
    SysFreeString(PwdStr);

    return hr;
}
#endif


HRESULT DISJetInitialize()
{
    JET_SESID sesid = JET_sesidNil;;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    JET_TABLEID clusdirtableid;
    JET_DBID dbid = JET_dbidNil;

    JET_ERR err = JET_errSuccess;
    JET_TABLECREATE tSess;
    JET_COLUMNCREATE cSess[NUM_SESSDIRCOLUMNS];
    JET_TABLECREATE tServ;
    JET_COLUMNCREATE cServ[NUM_SERVDIRCOLUMNS];
    JET_TABLECREATE tClus;
    JET_COLUMNCREATE cClus[NUM_CLUSDIRCOLUMNS];
    unsigned count;
    DWORD dwError;
    WCHAR filename[MAX_LOGFILE_LENGTH];
    BOOL br;
    SECURITY_ATTRIBUTES SA;

    //
    // This is a string security descriptor.  Look up "Security Descriptor 
    // Definition Language" in MSDN for more details.
    //
    // This one says:
    //
    // D: <we are creating a DACL>
    // (A; <Allow ACE>
    // OICI; <Perform object and container inheritance, i.e., let files and 
    //        directories under this one have these attributes>
    // GA <Generic All Access--Full Control>
    // ;;;SY) <SYSTEM>
    // (A;OICI;GA;;;BA) <same for Builtin Administrators group>
    // (A;OICI;GA;;;CO) <same for creator/owner>
    //
    // We'll use it below to create our directory with the right permissions.

    WCHAR *pwszSD = L"D:(A;OICI;GA;;;SY)(A;OICI;GA;;;BA)(A;OICI;GA;;;CO)";
    
#if 0 // Failover support--before reactivating, check logic versus reading curr directory from registry.
    DWORD dwClusterState;


    // First, determine whether we are running in a cluster.  If so, files
    // will have to go on the shared drive.  If not, files will go in
    // JETDISDBDIRECTORYW.
    dwError = GetNodeClusterState(NULL, &dwClusterState);

    if (dwError != ERROR_SUCCESS) {
        dwClusterState = ClusterStateNotInstalled;
        TSDISErrorOut(L"TSDIS: Unable to get cluster state, err = %d\n", 
                dwError);
    }

    if (dwClusterState == ClusterStateRunning) {
        HCLUSTER hclus;
        HRESOURCE hrSD;
        WCHAR *pszDriveLetter = NULL;
        DWORD cchDriveLetter = MAX_DRIVE_LETTER_LENGTH;

        // Change the current directory to the right place on the shared
        // drive.

        // Open the cluster.
        hclus = OpenCluster(NULL);

        if (hclus == NULL) {
            // TODO: Log event.
            TSDISErrorOut(L"Unable to open cluster, error %d\n", 
                    GetLastError());
            goto HandleError;
        }

        // Open the session directory resource.
        // TODO: Don't want to hardcode this.
        hrSD = OpenClusterResource(hclus, L"DIS");

        if (hrSD == NULL) {
            // TODO: Log event.
            TSDISErrorOut(L"Unable to open cluster resource, error %d\n",
                    GetLastError());
            goto HandleError;
        }

        pszDriveLetter = new WCHAR[cchDriveLetter];

        if (pszDriveLetter == NULL) {
            TSDISErrorOut(L"Failed to allocate memory for drive letter.\n");
            goto HandleError;
        }
        
        // Get the drive we're supposed to use.
        dwError = ResUtilFindDependentDiskResourceDriveLetter(hclus, hrSD,
                pszDriveLetter, &cchDriveLetter);

        if (dwError == ERROR_MORE_DATA) {
            // Wow, big drive letter!
            delete [] pszDriveLetter;
            pszDriveLetter = new WCHAR[cchDriveLetter];

            if (pszDriveLetter == NULL) {
                TSDISErrorOut(L"Failed to allocate memory for drive letter\n");
                goto HandleError;
            }
            
            dwError = ResUtilFindDependentDiskResourceDriveLetter(hclus, hrSD,
                    pszDriveLetter, &cchDriveLetter);
        }

        if (dwError != ERROR_SUCCESS) {
            TSDISErrorOut(L"Could not determine resource drive letter.\n");
            delete [] pszDriveLetter;
            goto HandleError;
        }

        // Switch the working directory to that drive.
        if (SetCurrentDirectory(pszDriveLetter) == FALSE) {
            TSDISErrorOut(L"Could not set current directory to that of "
                    L"shared disk %s.  Error=%d\n", pszDriveLetter, 
                    GetLastError());
            delete [] pszDriveLetter;
            goto HandleError;
        }
        
        delete [] pszDriveLetter;
    } 
    else {
        // This is where file deletion used to go.
    }
#endif // Failover support

    // Create security descriptor for database directory

    SA.nLength = sizeof(SECURITY_ATTRIBUTES);
    SA.bInheritHandle = FALSE;
    br = ConvertStringSecurityDescriptorToSecurityDescriptor(pwszSD, 
            SDDL_REVISION_1, &(SA.lpSecurityDescriptor), NULL);

    if (br == 0) {
        PostSessDirErrorValueEvent(EVENT_COULDNOTSECUREDIR, GetLastError());
        goto HandleError;
    }

    // Create the system32\tssesdir directory.
    if (CreateDirectory(JETDISDBDIRECTORYW, &SA) == 0) {
        if (ERROR_ALREADY_EXISTS != (dwError = GetLastError())) {
            PostSessDirErrorValueEvent(EVENT_COULDNOTCREATEDIR, dwError);
            goto HandleError;
        }
    } else {
        // We created it successfully, so set the directory attributes to not 
        // compress.

        // Obtain a handle to the directory.
        HANDLE hSDDirectory = CreateFile(JETDISDBDIRECTORYW, GENERIC_READ | 
                GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

        if (INVALID_HANDLE_VALUE != hSDDirectory) {
            // We've succeeded opening the directory.

            USHORT CompressionState = COMPRESSION_FORMAT_NONE;
            USHORT OldCompressionState;
            DWORD BytesReturned = 0;

            // Get the current compression state.
            if (DeviceIoControl(hSDDirectory, FSCTL_GET_COMPRESSION,
                    NULL, 0, &OldCompressionState, sizeof(USHORT), 
                    &BytesReturned, NULL) != 0) {

                // If the current compression state is compressed, uncompress.
                if (OldCompressionState != COMPRESSION_FORMAT_NONE) {
                    if (DeviceIoControl(hSDDirectory, FSCTL_SET_COMPRESSION, 
                            &CompressionState, sizeof(USHORT), NULL, 0, 
                            &BytesReturned, NULL) == 0) {
                        // Set compression state failed--this should only be a trace,
                        // it may merely mean that the drive is FAT.
                        TSDISErrorOut(L"TSDIS: Set compression state off failed, "
                                L"lasterr=0x%X\n", GetLastError());
                    } else {
                        PostSessDirErrorValueEvent(EVENT_UNDID_COMPRESSION, 0);
                    }
                }
            }
            
            CloseHandle(hSDDirectory);

        } else {
            // Nonfatal to have an error opening the directory
            TSDISErrorOut(L"TSDIS: Open directory to change compression state "
                    L"failed, lasterr=0x%X\n", GetLastError());
        }

        
    }

    // Delete the database and all other JET files (if present), and start anew.
    (void) DeleteFile(JETDBFILENAMEW);
    (void) DeleteFile(JETAUXFILENAME1W);
    (void) DeleteFile(JETAUXFILENAME2W);
    (void) DeleteFile(JETAUXFILENAME3W);
    (void) DeleteFile(JETAUXFILENAME4W);
    (void) DeleteFile(JETAUXFILENAME5W);
    (void) DeleteFile(JETAUXFILENAME6W);

    // Delete numbered log files.  Jet can create a bunch of log files
    // of the form edb00001.log, edb00002.log, . . ., edb0000a.log,
    // edb0000b.log, . . ., edb0000f.log, edb00010.log, . . .
    for (int i = 1; i < 0xfffff; i++) {
        swprintf(filename, JETDISDBDIRECTORYW L"edb%05X.log", i);

        // If the delete fails for any reason, break out of the loop.
        // Most likely, the failure is because the file does not exist.
        // If it failed for some other reason, 
        if (DeleteFile(filename) == 0) {
            dwError = GetLastError();

            if (dwError == ERROR_FILE_NOT_FOUND) {
                break;
            }
            else {
                PostSessDirErrorValueEvent(EVENT_PROBLEM_DELETING_LOGS, 
                        dwError);
                break;
            }
        }
    }
    
    CALL(JetSetSystemParameter(&g_instance, 0, JET_paramSystemPath, 
            0, JETDISDBDIRECTORY));
    CALL(JetSetSystemParameter(&g_instance, 0, JET_paramTempPath,
            0, JETDISDBDIRECTORY));
    //CALL(JetSetSystemParameter(&g_instance, 0, JET_paramMaxSessions,
    //        JETDISMAXSESSIONS, NULL));
    CALL(JetSetSystemParameter(&g_instance, 0, JET_paramLogFilePath,
            0, JETDISDBDIRECTORY));
    CALL(JetSetSystemParameter(&g_instance, 0, JET_paramCircularLog,
            1, NULL));
    
    CALL(JetInit(&g_instance));
    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    err = JetCreateDatabase(sesid, JETDBFILENAME, "", &dbid, 0);

    if (JET_errDatabaseDuplicate == err) {
        JET_COLUMNDEF jcd;

        err = JetAttachDatabase(sesid, JETDBFILENAME, 0);

        // if we get a wrnDatabaseAttached, then we have recovered.  Otherwise,
        // check the return value as usual.
        if (JET_wrnDatabaseAttached != err) {
            CALL(err);
        }

        // Populate our columnid arrays
        CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

        CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
                &sessdirtableid));
        CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
                &servdirtableid));
        CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0, 
                &clusdirtableid));

        CALL(JetBeginTransaction(sesid));

        for (count = 0; count < NUM_SESSDIRCOLUMNS; count++) {
            CALL(JetGetColumnInfo(sesid, dbid, "SessionDirectory", 
                    SessionDirectoryColumns[count].szColumnName, &jcd, 
                    sizeof(jcd), 0));
            sesdircolumnid[count] = jcd.columnid;
        }
        for (count = 0; count < NUM_SERVDIRCOLUMNS; count++) {
            CALL(JetGetColumnInfo(sesid, dbid, "ServerDirectory",
                    ServerDirectoryColumns[count].szColumnName, &jcd,
                    sizeof(jcd), 0));
            servdircolumnid[count] = jcd.columnid;
        }
        for (count = 0; count < NUM_CLUSDIRCOLUMNS; count++) {
            CALL(JetGetColumnInfo(sesid, dbid, "ClusterDirectory",
                    ClusterDirectoryColumns[count].szColumnName, &jcd,
                    sizeof(jcd), 0));
            clusdircolumnid[count] = jcd.columnid;
        }

        CALL(JetCommitTransaction(sesid, 0));

        goto NormalExit;
    } else {
        CALL(err);
    }

    CALL(JetBeginTransaction(sesid));

    // Set up to create session directory schema
    tSess.cbStruct = sizeof(tSess);
    tSess.szTableName = "SessionDirectory";
    tSess.szTemplateTableName = NULL;
    tSess.ulPages = 0;
    tSess.ulDensity = 100;
    tSess.rgcolumncreate = &cSess[0];
    tSess.cColumns = NUM_SESSDIRCOLUMNS;
    tSess.rgindexcreate = NULL;
    tSess.cIndexes = 0;
    tSess.grbit = JET_bitTableCreateFixedDDL;

    for (count = 0; count < NUM_SESSDIRCOLUMNS; count++) {
        cSess[count].cbStruct = sizeof(JET_COLUMNCREATE);
        cSess[count].szColumnName = SessionDirectoryColumns[count].szColumnName;
        cSess[count].coltyp = SessionDirectoryColumns[count].coltyp;
        cSess[count].cbMax = SessionDirectoryColumns[count].colMaxLen;
        cSess[count].grbit = 0;
        cSess[count].pvDefault = NULL;
        cSess[count].cbDefault = 0;
        cSess[count].cp = 1200;
        cSess[count].columnid = 0;
        cSess[count].err = JET_errSuccess;
    }
    

    // Actually create the session directory table.
    CALL(JetCreateTableColumnIndex(sesid, dbid, &tSess));

    // Store columnids, tableid for later reference.
    for (count = 0; count < NUM_SESSDIRCOLUMNS; count++) {
        sesdircolumnid[count] = cSess[count].columnid;
    }
    sessdirtableid = tSess.tableid;

    // Create server, session index.
    CALL(JetCreateIndex(sesid, sessdirtableid, "primaryIndex", 0, 
            "+ServerID\0+SessionID\0", sizeof("+ServerID\0+SessionID\0"), 
            100));
    // Create index by server for deletion.
    CALL(JetCreateIndex(sesid, sessdirtableid, "ServerIndex", 0,
            "+ServerID\0", sizeof("+ServerID\0"), 100));
    // Create index for disconnected session retrieval.
    CALL(JetCreateIndex(sesid, sessdirtableid, "DiscSessionIndex", 0,
            "+UserName\0+Domain\0+State\0", 
            sizeof("+UserName\0+Domain\0+State\0"), 100));
    // Create index for all session retrieval.
    CALL(JetCreateIndex(sesid, sessdirtableid, "AllSessionIndex", 0,
            "+UserName\0+Domain\0",
            sizeof("+UserName\0+Domain\0"), 100));

    // Create server directory.
    tServ.cbStruct = sizeof(tServ);
    tServ.szTableName = "ServerDirectory";
    tServ.szTemplateTableName = NULL;
    tServ.ulPages = 0;
    tServ.ulDensity = 100;
    tServ.rgcolumncreate = &cServ[0];
    tServ.cColumns = NUM_SERVDIRCOLUMNS;
    tServ.rgindexcreate = NULL;
    tServ.cIndexes = 0;
    tServ.grbit = JET_bitTableCreateFixedDDL;

    for (count = 0; count < NUM_SERVDIRCOLUMNS; count++) {
        cServ[count].cbStruct = sizeof(JET_COLUMNCREATE);
        cServ[count].szColumnName = ServerDirectoryColumns[count].szColumnName;
        cServ[count].coltyp = ServerDirectoryColumns[count].coltyp;
        cServ[count].cbMax = ServerDirectoryColumns[count].colMaxLen;
        cServ[count].grbit = 0;
        cServ[count].pvDefault = NULL;
        cServ[count].cbDefault = 0;
        cServ[count].cp = 1200;
        cServ[count].columnid = 0;
        cServ[count].err = JET_errSuccess;
    }
    // Set the autoincrement column to autoincrement
    cServ[0].grbit |= JET_bitColumnAutoincrement;

    CALL(JetCreateTableColumnIndex(sesid, dbid, &tServ));

    for (count = 0; count < NUM_SERVDIRCOLUMNS; count++) {
        servdircolumnid[count] = cServ[count].columnid;
    }
    servdirtableid = tServ.tableid;

    // Create Server Name index.
    CALL(JetCreateIndex(sesid, servdirtableid, "ServNameIndex", 0,
            "+ServerAddress\0", sizeof("+ServerAddress\0"), 100));
    // Create Server ID index.
    CALL(JetCreateIndex(sesid, servdirtableid, "ServerIDIndex", 0,
            "+ServerID\0", sizeof("+ServerID\0"), 100));
    // Create Pending Reconnect index.
    CALL(JetCreateIndex(sesid, servdirtableid, "ServerAlmostInTimes", 0,
            "+AlmostInTimeLow\0+AlmostInTimeHigh\0", 
            sizeof("+AlmostInTimeLow\0+AlmostInTimeHigh\0"), 100));
    // Create the single session index.
    CALL(JetCreateIndex(sesid, servdirtableid, "SingleSessionIndex", 0,
            "+ClusterID\0+SingleSessionMode\0", 
            sizeof("+ClusterID\0+SingleSessionMode\0"), 100));
            
    // Create cluster directory.
    tClus.cbStruct = sizeof(tClus);
    tClus.szTableName = "ClusterDirectory";
    tClus.szTemplateTableName = NULL;
    tClus.ulPages = 0;
    tClus.ulDensity = 100;
    tClus.rgcolumncreate = &cClus[0];
    tClus.cColumns = NUM_CLUSDIRCOLUMNS;
    tClus.rgindexcreate = NULL;
    tClus.cIndexes = 0;
    tClus.grbit = JET_bitTableCreateFixedDDL;

    for (count = 0; count < NUM_CLUSDIRCOLUMNS; count++) {
        cClus[count].cbStruct = sizeof(JET_COLUMNCREATE);
        cClus[count].szColumnName = ClusterDirectoryColumns[count].szColumnName;
        cClus[count].coltyp = ClusterDirectoryColumns[count].coltyp;
        cClus[count].cbMax = ClusterDirectoryColumns[count].colMaxLen;
        cClus[count].grbit = 0;
        cClus[count].pvDefault = NULL;
        cClus[count].cbDefault = 0;
        cClus[count].cp = 1200;
        cClus[count].columnid = 0;
        cClus[count].err = JET_errSuccess;
    }
    // Set the autoincrement column to autoincrement
    cClus[0].grbit |= JET_bitColumnAutoincrement;

    CALL(JetCreateTableColumnIndex(sesid, dbid, &tClus));

    for (count = 0; count < NUM_CLUSDIRCOLUMNS; count++) {
        clusdircolumnid[count] = cClus[count].columnid;
    }
    clusdirtableid = tClus.tableid;

    // Create Cluster Name index.
    CALL(JetCreateIndex(sesid, clusdirtableid, "ClusNameIndex", 
            JET_bitIndexUnique, "+ClusterName\0", sizeof("+ClusterName\0"), 
            100));
    // Create cluster ID index.
    CALL(JetCreateIndex(sesid, clusdirtableid, "ClusIDIndex", 0,
            "+ClusterID\0", sizeof("+ClusterID\0"), 100));


    CALL(JetCommitTransaction(sesid, 0));

    // Tables were opened with exclusive access from CreateTableColumnIndex.
    // Close them now.
NormalExit:
    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    LocalFree(SA.lpSecurityDescriptor);
    SA.lpSecurityDescriptor = NULL;

#ifdef DBG
    OutputAllTables();
#endif // DBG

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    LocalFree(SA.lpSecurityDescriptor);
    SA.lpSecurityDescriptor = NULL;

    PostSessDirErrorValueEvent(EVENT_JET_COULDNT_INIT, err);

    exit(1);
}


/****************************************************************************/
// DISCleanupGlobals
//
// Common cleanup code for SQL and Jet code paths.
/****************************************************************************/
void DISCleanupGlobals()
{
    if (g_hStopServiceEvent != NULL) {
        CloseHandle(g_hStopServiceEvent);
        g_hStopServiceEvent = NULL;
    }

    if (g_hFileOutput != INVALID_HANDLE_VALUE) {
        if (CloseHandle(g_hFileOutput) == 0) {
            ERR((TB, "CloseHandle on output file failed: lasterr=0x%X", 
                    GetLastError()));
        }
        g_hFileOutput = INVALID_HANDLE_VALUE;
    }
}


#if 0
/****************************************************************************/
// DISCallSPForServer
//
// Generic function to call a stored procedure that takes a ServerAddress as an
// argument.
/****************************************************************************/
void DISCallSPForServer(WCHAR *StoredProcName, WCHAR *ServerAddress) {
    HRESULT hr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;


    hr = CreateADOStoredProcCommand(StoredProcName, &pCommand, &pParameters);

    if (SUCCEEDED(hr)) {
        hr = AddADOInputStringParam(ServerAddress, L"ServerAddress", 
                pCommand, pParameters, FALSE);
        if (SUCCEEDED(hr)) {
            // Execute the command.
            hr = pCommand->Execute(NULL, NULL, adCmdStoredProc, 
                    &pResultRecordSet);
            if (SUCCEEDED(hr)) {
                pResultRecordSet->Release();
            } else {
                ERR((TB, "DISCallSPForServer: Failed Execute, hr = 0x%X", 
                        hr));
            }
        }
        else {
            ERR((TB,"DISCallSPForServer: Failed add parameter, hr=0x%X", hr));
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"DISCallSPForServer: Failed create cmd, hr=0x%X", hr));
    }
}
#endif


/****************************************************************************/
// DISJetHandleDeadServer
//
// When a server is not responding, this function call sends the command to the
// Jet database to remove all entries pertaining to that server.
/****************************************************************************/
void DISJetHandleDeadServer(WCHAR *ServerAddress, DWORD ServerID) {
    // FailureCount is initially set to 1, TRUE, to tell SetServerAITInternal
    // to increment the failure count and return the resultant count.
    DWORD FailureCount = 1;

    TSSDSetServerAITInternal(ServerAddress, FALSE, &FailureCount);

    TSDISErrorOut(L"Server %s (%d) not responding (Failure Count: %d).\n",
            ServerAddress, ServerID, FailureCount);

    if (FailureCount >= g_NumberFailedPingsBeforePurge)
        TSSDPurgeServer(ServerID);
}


// TODO: Possible optimization: pass in ServerID
void DISJetSetServerPingSuccessful(WCHAR *ServerAddress) {
    TSSDSetServerAITInternal(ServerAddress, TRUE, NULL);
}


#if 0
/****************************************************************************/
// DISSQLHandleDeadServer
//
// When a server is not responding, this function call sends the command to the
// database to execute SP_TSDISServerNotResponding.
/****************************************************************************/
void DISSQLHandleDeadServer(WCHAR *ServerAddress) {
    DISCallSPForServer(L"SP_TSDISServerNotResponding", ServerAddress);
}


void DISSQLSetServerPingSuccessful(WCHAR *ServerAddress) {
    DISCallSPForServer(L"SP_TSDISSetServerPingSuccessful", ServerAddress);
}
#endif


VOID DISCtrlHandler(DWORD opcode) {

    switch(opcode)
    {
    //case SERVICE_CONTROL_PAUSE:
        // pause
    //    g_DISStatus.dwCurrentState = SERVICE_PAUSED;
    //    break;

    //case SERVICE_CONTROL_CONTINUE:
        // continue
    //    g_DISStatus.dwCurrentState = SERVICE_RUNNING;
    //    break;

    case SERVICE_CONTROL_STOP:
        //stop
        g_DISStatus.dwWin32ExitCode = 0;
        g_DISStatus.dwCurrentState = SERVICE_STOP_PENDING;
        g_DISStatus.dwCheckPoint = 0;
        g_DISStatus.dwWaitHint = 0;

        if (!SetServiceStatus(g_DISStatusHandle, &g_DISStatus)) {
            ERR((TB, "SetServiceStatus failed"));
        }

        // Here is where to actually stop the service
        SetEvent(g_hStopServiceEvent);
        // Should I wait for that to complete?

        g_DISStatus.dwCurrentState = SERVICE_STOPPED;

        if (!SetServiceStatus(g_DISStatusHandle, &g_DISStatus)) {
            ERR((TB, "SetServiceStatus failed"));
        }

        return;

    case SERVICE_CONTROL_INTERROGATE:
        // fall through to return current status
        break;

    default:
        ERR((TB, "Unrecognized opcode to DISCtrlHandler - 0x%08x", opcode));
    }

    // send current status
    if (!SetServiceStatus(g_DISStatusHandle, &g_DISStatus)) {
        ERR((TB, "SetServiceStatus failed"));
    }
}


void DISDirectoryIntegrityLoop() {
    CVar varRows;
    WCHAR *ServerAddress;
#if 0
    WCHAR ServerAddressBuf[SERVER_ADDRESS_LENGTH];
#endif
    WCHAR ServerAddressRows[10][SERVER_ADDRESS_LENGTH];
    DWORD ServerIDs[10];
    long NumSessionsReturned;
#if 0
    HRESULT hr = S_OK;
#endif
    SERVER_STATUS ServerStatus;
    DWORD EventStatus;

#if 0
    ServerAddress = ServerAddressBuf; // In SQL case, we need a static buffer
#endif

#if 0
    TSDISErrorOut(L"%s active\n", g_bUseSQL ? L"Directory Integrity Service" : 
            L"Session Directory");
#endif

    TSDISErrorOut(L"Session Directory Active\n");
            
    // Loop forever
    for ( ; ; ) {
        // Retrieve set of servers that have disconnected sessions pending
        // reconnects
#if 0
        if (g_bUseSQL == FALSE)
#endif
            DISJetGetServersPendingReconnects(&NumSessionsReturned,
                    ServerAddressRows, ServerIDs);
#if 0
        else
            DISSQLGetServersPendingReconnects(&NumSessionsReturned, 
                    &varRows);
#endif

        // For each server,
        for (DWORD i = 0; i < (unsigned)NumSessionsReturned; i++) {
#if 0
            if (g_bUseSQL == FALSE)
#endif

            ServerAddress = ServerAddressRows[i];

#if 0
            else
                hr = GetRowArrayStringField(varRows.parray, i, 0,
                        ServerAddress, sizeof(ServerAddressBuf) /
                        sizeof(WCHAR) - 1);

            if (FAILED(hr)) {
                ERR((TB,"DISDirectoryIntegrityLoop: Row %u returned hr=0x%X",
                        i, hr));
            }
#endif

            ServerStatus = DISGetServerStatus(ServerAddress);

            // if the server does not respond, handle dead server.
            // The function we call will do the right thing, which may be
            // to purge immediately, or may be to simply increment a failure
            // count.
            if (ServerStatus == NotResponding) {
#if 0
                if (FALSE == g_bUseSQL)
#endif
                DISJetHandleDeadServer(ServerAddress, ServerIDs[i]);
#if 0
                else
                    DISSQLHandleDeadServer(ServerAddress);
#endif

#ifdef DBG
                OutputAllTables();
#endif // DBG
            } 
            // else stop pinging
            else if (ServerStatus == Responding) {
#if 0
                if (FALSE == g_bUseSQL)
#endif
                    DISJetSetServerPingSuccessful(ServerAddress);
#if 0
                else
                    DISSQLSetServerPingSuccessful(ServerAddress);
#endif
            }
            else {
                ERR((TB, "DISDirectoryIntegrityLoop: ServerStatus enum has bad "
                        "value %d", ServerStatus));
            }
        }

        // Wait DISNumberSecondsBetweenPings
        EventStatus = WaitForSingleObjectEx(g_hStopServiceEvent, 
                DISNumberSecondsBetweenPings * 1000, FALSE);
        if (EventStatus == WAIT_TIMEOUT) {
            // do normal stuff
            continue;
        } else if (EventStatus == WAIT_OBJECT_0) {
            // the event was signaled -- clean up
            break;
        } else if (EventStatus == -1) {
            // there is an error
        } else {
            // weird output from that function
        }
    }
}
    

#if 0
/****************************************************************************/
// DISSQLStart
//
// Service main entry point for when the service is configured to verify
// SQL tables.
/****************************************************************************/
VOID DISSQLStart(DWORD argc, LPTSTR *argv) {
    HRESULT hr = S_OK;

    // unreferenced parameters
    argv;
    argc;
    
    g_DISStatus.dwServiceType = SERVICE_WIN32;
    g_DISStatus.dwCurrentState = SERVICE_START_PENDING;
    g_DISStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    g_DISStatus.dwWin32ExitCode = 0;
    g_DISStatus.dwServiceSpecificExitCode = 0;
    g_DISStatus.dwCheckPoint = 0;
    g_DISStatus.dwWaitHint = 0;
    g_DISStatusHandle = RegisterServiceCtrlHandler(
            _T("Directory Integrity Service"), DISCtrlHandler);
    if (g_DISStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        ERR((TB, "DISSQLStart: RegisterServiceCtrlHandler failed"));
        goto ExitFunc;
    }

    // Initialization code goes here
    hr = DISSQLInitialize();
    if (FAILED(hr)) {
        ERR((TB, "DISSQLStart: DISSQLInitialize failed"));
        goto PostRegisterService;
    }

    g_DISStatus.dwCurrentState = SERVICE_RUNNING;
    g_DISStatus.dwCheckPoint = 1;
    if (!SetServiceStatus(g_DISStatusHandle, &g_DISStatus)) {
        ERR((TB, "DISSQLStart: SetServiceHandler failed"));
        goto PostRegisterService;
    }

    DISDirectoryIntegrityLoop();

PostRegisterService:
    g_DISStatus.dwCurrentState = SERVICE_STOPPED;
    g_DISStatus.dwCheckPoint = 2;
    SetServiceStatus(g_DISStatusHandle, &g_DISStatus);

ExitFunc:
    DISCleanupGlobals();
}
#endif


/****************************************************************************/
// DISJetStart
//
// Service main entry point for when the service is configured to act as
// an RPC server and use Jet for all session directory transactions.
/****************************************************************************/
VOID DISJetStart(DWORD argc, LPTSTR *argv) {
    RPC_STATUS Status;
    RPC_BINDING_VECTOR *pBindingVector = 0;
    RPC_POLICY rpcpol = {sizeof(rpcpol), 0, 0};


    // unreferenced parameters
    argv;
    argc;


    g_DISStatus.dwServiceType = SERVICE_WIN32;
    g_DISStatus.dwCurrentState = SERVICE_START_PENDING;
    g_DISStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    g_DISStatus.dwWin32ExitCode = 0;
    g_DISStatus.dwServiceSpecificExitCode = 0;
    g_DISStatus.dwCheckPoint = 0;
    g_DISStatus.dwWaitHint = 0;

    if (g_bDebug == FALSE) {
        g_DISStatusHandle = RegisterServiceCtrlHandler(
                _T("Directory Integrity Service"), DISCtrlHandler);

        if (g_DISStatusHandle == (SERVICE_STATUS_HANDLE)0) {
            ERR((TB, "DISJetStart: RegisterServiceCtrlHandler failed"));
            goto ExitFunc;
        }
    }

    // Init the RPC server interface.
    // Register the named pipe. This uses NT domain authentication.

    /*
    Status = RpcServerUseProtseqEp(
            L"ncacn_np",  // Protocol Sequence
            NUM_JETRPC_THREADS,  // Maximum calls at one time
            L"\\pipe\\TSSD_Jet_RPC_Service",  // Endpoint
            NULL);  // Security
    */

    Status = RpcServerUseProtseqEx(L"ncacn_ip_tcp", 3, 0, &rpcpol);
    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d RpcUseProtseqEp on ncacn_ip_tcp", 
                Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_INIT_USEPROTSEQ, Status);
        goto PostRegisterService;
    }

    // Register our interface handle (found in jetrpc.h).
    Status = RpcServerRegisterIf(TSSDJetRPC_ServerIfHandle, NULL, NULL);
    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d RegIf", Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_INIT_REGISTERIF, Status);
        goto PostRegisterService;
    }

    Status = RpcServerInqBindings(&pBindingVector);

    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d InqBindings", Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_INIT_INQBINDINGS, Status);
        goto PostRegisterService;
    }

    Status = RpcEpRegister(TSSDJetRPC_ServerIfHandle, pBindingVector, 0, 0);
    // TODO: Probably need to unregister, maybe delete some binding vector.

    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d EpReg", Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_INIT_EPREGISTER, Status);
        goto PostRegisterService;
    }

    Status = RpcServerRegisterAuthInfo(0, RPC_C_AUTHN_WINNT, 0, 0);

    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d RegAuthInfo", Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_INIT_REGAUTHINFO, Status);
        goto PostRegisterService;
    }

    // Now initialize the JET database
    DISJetInitialize();

    // Now do the RPC listen to service calls
    Status = RpcServerListen(1, NUM_JETRPC_THREADS, TRUE);
    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d ServerListen", Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_LISTEN, Status);
        goto PostRegisterService;
    }

    // We are now up.
    g_DISStatus.dwCurrentState = SERVICE_RUNNING;
    g_DISStatus.dwCheckPoint = 1;
    if (g_bDebug == FALSE)
        SetServiceStatus(g_DISStatusHandle, &g_DISStatus);

    // Now we have the RPC server running, we can just wait for the
    // service-stop event to be fired to let us know we need to exit.
    // We do this inside the Directory Integrity Loop.
    DISDirectoryIntegrityLoop();

    // Time to clean up.
    // Kill the RPC listener.
    RpcServerUnregisterIf(TSSDJetRPC_ServerIfHandle, NULL, NULL);

PostRegisterService:
    g_DISStatus.dwCurrentState = SERVICE_STOPPED;
    g_DISStatus.dwCheckPoint = 2;
    if (g_bDebug == FALSE)
        SetServiceStatus(g_DISStatusHandle, &g_DISStatus);

ExitFunc:
    DISCleanupGlobals();
}


/****************************************************************************/
// DISInstallService
//
// Used to install the service, returns 0 on success, nonzero otherwise.
/****************************************************************************/
int DISInstallService() {
    WCHAR wzModulePathname[MAX_PATH];
    SC_HANDLE hSCM = NULL, hService = NULL;

    if (0 != GetModuleFileNameW(NULL, wzModulePathname, MAX_PATH)) {
        hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
        if (hSCM != NULL) {
            hService = CreateServiceW(hSCM, L"Directory Integrity Service",
                    L"Directory Integrity Service", 0, 
                    SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START,
                    SERVICE_ERROR_NORMAL, wzModulePathname, NULL, NULL, NULL,
                    NULL, NULL);
            if (hService != NULL) {
                CloseServiceHandle(hService);
                CloseServiceHandle(hSCM);
            } else {
                ERR((TB, "CreateService failed, error = 0x%X", GetLastError()));
                CloseServiceHandle(hSCM);
                return -1;
            }
        } else {
            ERR((TB, "OpenSCManager failed, error = 0x%X", GetLastError()));
            return -1;
        }
    } else {
        ERR((TB, "GetModuleFileNameW failed, error = 0x%X", GetLastError()));
        return -1;
    }

    return 0;
}


/****************************************************************************/
// DISRemoveService()
//
// Used to remove the service, returns 0 on success, nonzero otherwise.
/****************************************************************************/
int DISRemoveService() {
    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if (hSCM != NULL) {
        // Open this service for DELETE access
        SC_HANDLE hService = OpenServiceW(hSCM, L"Directory Integrity Service",
                DELETE);
        if (hService != NULL) {
            // Remove this service from the SCM's database.
            DeleteService(hService);
            CloseServiceHandle(hService);
            CloseServiceHandle(hSCM);
            return 0;
        } else {
            ERR((TB, "Failure opening service for delete, error = 0x%X", 
                    GetLastError()));
        }
        CloseServiceHandle(hService);
    } else {
        ERR((TB, "Failure opening SC Manager, error = 0x%X", GetLastError()));
    }

    return -1;
}


// Reads a DWORD value out of the registry.
//
// In:
//  hKey - an open HKEY
//  RegValName - the name of the registry value
//  pValue - pointer to the value.  The value will be set to the registry value
//    if the registry operation is a success, else it will remain untouched.
//
// Out:
//  0 if success, nonzero otherwise
int ReadRegVal(HKEY hKey, WCHAR *RegValName, DWORD *pValue)
{
    DWORD RegRetVal;
    DWORD Type, Temp, Size;

    Size = sizeof(Temp);
    RegRetVal = RegQueryValueExW(hKey, RegValName, NULL, &Type,
            (BYTE *)&Temp, &Size);
    if (RegRetVal == ERROR_SUCCESS) {
        *pValue = Temp;
        return 0;
    }
    else {
        TRC1((TB, "TSSDIS: Failed RegQuery for %S - "
                "err=%u, DataSize=%u, type=%u\n",
                RegValName, RegRetVal, Size, Type));
        return -1;
    }

}


// Reads a Unicode text value out of the registry.
//
// hKey (IN) - an open HKEY
// RegValName (IN) - the name of the registry value
// pText (IN/OUT) - pointer to the buffer to which to write.
// cbData (IN) - size of buffer IN BYTES
//
// returns 0 if success, nonzero otherwise.
int ReadRegTextVal(HKEY hKey, WCHAR *RegValName, WCHAR *pText, DWORD cbData)
{
    DWORD RegRetVal;
    DWORD Type, Size;

    Size = cbData;

    RegRetVal = RegQueryValueExW(hKey, RegValName, NULL, &Type,
            (BYTE *)pText, &Size);

    if (RegRetVal == ERROR_SUCCESS) {
        return 0;
    }
    else {
        TRC1((TB, "TSSDIS: Failed RegQuery for %S - err=%u, DataSize=%u, "
                "type=%u\n", RegValName, RegRetVal, Size, Type));
        return -1;
    }
}


// Reads configuration from the registry and sets global variables.
void ReadConfigAndSetGlobals()
{
    DWORD RegRetVal;
    HKEY hKey;
    DWORD Temp;
    WCHAR WorkingDirectory[MAX_PATH];

    // Open the service settings regkey and grab the UseJet flag.
    // Absence of the key or the setting means no jet.
#if 0
    g_bUseSQL = FALSE;
#endif
    RegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\TermServSessDir", 0, KEY_READ, &hKey);
    if (RegRetVal == ERROR_SUCCESS) {

        // With each of these calls, an error is non-fatal.
#if 0
        // Query UseSQL value.
        ReadRegVal(hKey, L"UseSQL", &g_bUseSQL);
#endif

        // Query PingMode value.  Note this is an enum so sending the variable
        // in directly is illegal.
        if (ReadRegVal(hKey, L"PingMode", &Temp) == 0) {

            // Make sure this is a legal value for the enum.
            if (Temp > AlwaysFail)
                Temp = NormalMode;

            g_PingMode = (PingMode) Temp;
        }

        // Query TraceOutputMode value.  As above, enum means don't set it
        // directly.
        if (ReadRegVal(hKey, L"TraceOutputMode", &Temp) == 0) {

            // Make sure this is a legal value for the enum.
            if (Temp > FileOutput)
                Temp = NoTraceOutput;

            g_TraceOutputMode = (TraceOutputMode) Temp;

        }

        // Query NumberFailedPingsBeforePurge.
        ReadRegVal(hKey, L"NumberFailedPingsBeforePurge", 
                &g_NumberFailedPingsBeforePurge);

        // Query TimeBetweenPings.
        ReadRegVal(hKey, L"TimeBetweenPings", &DISNumberSecondsBetweenPings);

        // Query TimeServerSilentBeforePing.
        if (ReadRegVal(hKey, L"TimeServerSilentBeforePing", &Temp) == 0) {
            g_TimeServerSilentBeforePing = (ULONGLONG) Temp * 
                    FILETIME_INTERVAL_TO_SECONDS_MULTIPLIER;
        }

        // Query Working Directory
        if (ReadRegTextVal(hKey, L"WorkingDirectory", WorkingDirectory, 
                sizeof(WorkingDirectory)) == 0) {
            if (SetCurrentDirectory(WorkingDirectory) == 0) {
                DWORD Err;

                Err = GetLastError();
                PostSessDirErrorValueEvent(EVENT_PROBLEM_SETTING_WORKDIR, Err);
                ERR((TB, "TERMSRV: Unable to set directory to value read from "
                        "registry.  LastErr=0x%X", Err));
            }
        }
        
        RegCloseKey(hKey);

        // Now, if in file output mode, open the file.
        if (g_TraceOutputMode == FileOutput) {
            g_hFileOutput = CreateFile(DEBUG_LOG_FILENAME, GENERIC_WRITE,
                    FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                    NULL);

            if (g_hFileOutput == INVALID_HANDLE_VALUE) {
                ERR((TB, "Could not open debug log file, lasterror=0x%X", 
                        GetLastError()));
                g_TraceOutputMode = NoTraceOutput;
            } 
            else {
                DWORD dwRetVal = 0;
                // Set the insertion point to the end of the file and output 
                // something.
                dwRetVal = SetFilePointer(g_hFileOutput, 0, NULL, FILE_END);

                if (dwRetVal == INVALID_SET_FILE_POINTER) {
                    ERR((TB, "Could not set to end of file, lasterror=0x%X",
                            GetLastError()));
                    g_TraceOutputMode = NoTraceOutput;
                }
                else {
                    DWORD dwBytesWritten = 0;
                    char *pszIntro = "\n\nNEW INSTANCE\n";
                    
                    if (WriteFile(g_hFileOutput, pszIntro, 
                            (DWORD) strlen(pszIntro), &dwBytesWritten, 
                            NULL) == 0) {
                        ERR((TB, "WriteFile failed, lasterr=0x%X", 
                                GetLastError()));
                    }
                }
            }
        }

    }
    else {
        WRN((TB,"TERMSRV: Unable to open settings key in HKLM, "
                "lasterr=0x%X", GetLastError()));
    }
}


int __cdecl main() {
    int nArgc;
    WCHAR **ppArgv = (WCHAR **) CommandLineToArgvW(GetCommandLineW(), &nArgc);
    BOOL fStartService = (nArgc < 2);
    int i;
    HANDLE hMutex;

    if ((fStartService == FALSE) && (ppArgv == NULL)) {
        PostSessDirErrorValueEvent(EVENT_NO_COMMANDLINE, GetLastError());
        return -1;
    }

    // Only allow one session directory at a time.  System will close the
    // handle automatically when the process terminates.
    hMutex = CreateMutex(NULL, FALSE, 
            _T("Global\\Windows Terminal Server Session Directory"));

    if (hMutex == NULL) {
        // Handle creation failed, not because it already existed.
        PostSessDirErrorValueEvent(EVENT_PROBLEM_CREATING_MUTEX, 
                GetLastError());
        return -1;
    }
    
    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        // Already a session directory out there.
        PostSessDirErrorValueEvent(EVENT_TWO_SESSDIRS, 0);
        return -1;
    }


    SERVICE_TABLE_ENTRY DispatchTable[] =
    {
        { _T("Directory Integrity Service"), DISJetStart },  // Default to the
                                                             // Jet version.
        { NULL, NULL }
    };

    for (i = 1; i < nArgc; i++) {
        if ((ppArgv[i][0] == '-') || (ppArgv[i][0] == '/')) {
            if (wcscmp(&ppArgv[i][1], L"install") == 0) {
                if (DISInstallService()) {
                    ERR((TB, "Could not install service"));
                }
            }
            if (wcscmp(&ppArgv[i][1], L"remove") == 0) {
                if (DISRemoveService()) {
                    ERR((TB, "Could not remove service"));
                }
            }
            if (wcscmp(&ppArgv[i][1], L"debug") == 0) {
                TSDISErrorOut(L"Debugging Jet-based Session Directory\n");

                g_hStopServiceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

                g_bDebug = TRUE;

                // Log to stdout by default in this mode, but can be
                // overridden by the registry.
                g_TraceOutputMode = StdOutput;
                
                ReadConfigAndSetGlobals();

                SetConsoleCtrlHandler(DISDebugControlHandler, TRUE);

                DISJetStart(nArgc, ppArgv);
            }
        }
    }

    HeapFree(GetProcessHeap(), 0, (PVOID) ppArgv);

    if (fStartService) {
        // Stop event - signals for the ServiceMain thread to exit.
        g_hStopServiceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        ReadConfigAndSetGlobals();

#if 0
        if (g_bUseSQL) {
            // Switch from the default to the SQL service start.
            DispatchTable[0].lpServiceProc = DISSQLStart;
        }
#endif

        if (!StartServiceCtrlDispatcher(DispatchTable)) {
#ifdef DBG
            DWORD dw = GetLastError();
#endif // DBG
            ERR((TB, "Could not start service control dispatcher, error 0x%X",
                    dw));
        }
    }

    return 0;
}

#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdjet\jetrpc-c.c ===
#include <jetrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdjet\factory.h ===
/****************************************************************************/
// factory.h
//
// TSLI class factory definition.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/
#ifndef __FACTORY_H
#define __FACTORY_H


class CClassFactory : public IClassFactory
{
protected:
    long m_RefCount;

public:
    CClassFactory() : m_RefCount(0) {}

    // Standard COM methods
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory COM interfaces
    STDMETHODIMP CreateInstance(IUnknown *, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};



#endif  // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\testcli2\tssdcli.cpp ===
// tssdjetharness.cpp : Defines the entry point for the console application.
//

#include <windows.h>
#include <stdio.h>
#include <initguid.h>
#include "itssd.h"
#include "itssd_i.c"
#include "tssdshrd.h"

DEFINE_GUID(CLSID_TSSDJET,
        0x005a9c68, 0xe216, 0x4b27, 0x8f, 0x59, 0xb3, 0x36, 0x82, 0x9b, 0x38, 
        0x68);

#define TSSD_MaxDisconnectedSessions 10
#define SESSDIR_MACHINE_NAME L"trevorfodev"

ITSSessionDirectory *pTSSD;


// STATUS_UNSUCCESSFUL or STATUS_SUCCESS
DWORD RepopSessDir() {
    printf("RepopSessDir called.\n");
    return pTSSD->Repopulate(0, NULL);
}


HRESULT ConnectUser(WCHAR *UserName, WCHAR *Domain, DWORD SessionID, 
        DWORD TSProtocol, WCHAR *Application, DWORD HRes, DWORD VRes, 
        DWORD ColorDepth, DWORD LowTime, DWORD HighTime)
{
    TSSD_CreateSessionInfo ts;
    
    wcscpy(ts.UserName, UserName);
    wcscpy(ts.Domain, Domain);
    ts.SessionID = SessionID;
    ts.TSProtocol = TSProtocol;
    wcscpy(ts.ApplicationType, Application);
    ts.ResolutionWidth = HRes;
    ts.ResolutionHeight = VRes;
    ts.ColorDepth = ColorDepth;
    ts.CreateTime.dwLowDateTime = LowTime;
    ts.CreateTime.dwHighDateTime = HighTime;
    
    return pTSSD->NotifyCreateLocalSession(&ts);
}


void checkerr(wchar_t *Component, HRESULT hr)
{
    if (SUCCEEDED(hr))
        printf("%S successful.\n", Component);
    else
        printf("FAIL: %S failed, err=%u\n", Component, hr);

}


void RunMainProcess()
{
    DWORD numSessionsReturned;
    TSSD_DisconnectedSessionInfo SessionBuf[TSSD_MaxDisconnectedSessions];
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    HANDLE MainSignalEvent;
    HANDLE ASignalEvent;
    HRESULT hr;
    DWORD dr;
    BOOL br;

    // This is for us to signal Process 'A'.
    MainSignalEvent = CreateEvent(NULL, FALSE, FALSE, L"MainSignalEvent");

    if (MainSignalEvent == NULL) {
        printf("Problem %u creating MainSignalEvent.\n", GetLastError());
        exit(1);
    }

    // This is for process A to signal us.
    ASignalEvent = CreateEvent(NULL, FALSE, FALSE, L"ASignalEvent");

    if (ASignalEvent == NULL) {
        printf("Problem %u creating ASignalEvent.\n", GetLastError());
        exit(1);
    }
    
    printf("Now initializing...");

    hr = pTSSD->Initialize(L"WRONGIP", SESSDIR_MACHINE_NAME, L"Cluster1", 
            L"OpaqueSettings", 0, RepopSessDir);

    checkerr(L"Initialization", hr);

    printf("Sleeping for 5 sec. to make sure connect happens.\n");

    printf("Should see a RepopSessDir right here.\n");

    Sleep(5000);

    hr = ConnectUser(L"trevorfo", L"NTDEV", 0, 1, L"Desktop", 640, 480, 24, 22, 
            33);

    checkerr(L"ConnectUser", hr);

    // Verify there are no disconnected sessions for the user.
    hr = pTSSD->GetUserDisconnectedSessions(L"trevorfo", L"NTDEV", 
            &numSessionsReturned, SessionBuf);

    if (SUCCEEDED(hr)) {
        if (numSessionsReturned == 0)
            printf("GetUserDisconnectedSessions succeeded and returned 0 "
                    "users\n");
        else
            printf("FAIL: GetUserDisconnectedSessions returned %d users"
                    " (should be 0)\n", numSessionsReturned);
    }
    else {
        printf("FAIL: GetUserDisconnectedSessions failed, hr=%u\n", hr);
    }


    // Hand off to process 2.
    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);

    wchar_t CommandLine[] = L"tssdcli A";
    
    //br = CreateProcess(NULL, CommandLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
    br = TRUE;
    
    if (br == FALSE) {
        printf("CreateProcess failed.\n");
        exit(1);
    }

    printf("About to hand off to process A.\n");

    br = SetEvent(MainSignalEvent);

    if (br == FALSE) {
        printf("SetEvent failed.\n");
        exit(1);
    }

    // He's gonna signal me when he's in single session mode, then I am going
    // to switch to single session mode and see if I can get the "disconnected"
    // session.
    dr = WaitForSingleObject(ASignalEvent, INFINITE);

    if (dr != WAIT_OBJECT_0) {
        printf("Wait failed.\n");
        exit(1);
    }

    printf("Main: Updating\n");
    hr = pTSSD->Update(L"WRONGIP", SESSDIR_MACHINE_NAME, L"Cluster1", 
            L"OpaqueSettings", SINGLE_SESSION_FLAG);
    
    checkerr(L"Update", hr);

    printf("Sleeping for 5 sec\n");
    Sleep(5000);

    // Verify it returns a disconnected session for the user.
    hr = pTSSD->GetUserDisconnectedSessions(L"trevorfo", L"NTDEV", 
            &numSessionsReturned, SessionBuf);

    if (SUCCEEDED(hr)) {
        if (numSessionsReturned == 1)
            printf("GetUserDisconnectedSessions succeeded and returned 1 "
                    "users\n");
        else
            printf("FAIL: GetUserDisconnectedSessions returned %d users"
                    " (should be 1)\n", numSessionsReturned);
    }
    else {
        printf("FAIL: GetUserDisconnectedSessions failed, hr=%u\n", hr);
    }

    Sleep(60000);
    
}


void RunProcessA()
{
    HANDLE MainSignalEvent;
    HANDLE ASignalEvent;
    DWORD numSessionsReturned;
    HRESULT hr;
    BOOL br;
    DWORD dr;
    TSSD_DisconnectedSessionInfo SessionBuf[TSSD_MaxDisconnectedSessions];

    // This is the main process to signal us.
    MainSignalEvent = CreateEvent(NULL, FALSE, FALSE, L"MainSignalEvent");

    if (MainSignalEvent == NULL) {
        printf("Problem %u creating MainSignalEvent.\n", GetLastError());
        exit(1);
    }

    // This is for us to process the main proces.
    ASignalEvent = CreateEvent(NULL, FALSE, FALSE, L"ASignalEvent");

    if (ASignalEvent == NULL) {
        printf("Problem %u creating ASignalEvent.\n", GetLastError());
        exit(1);
    }

    printf("This is process A.\n");

    printf("About to connect in single session mode and call GetDisconnectedSessions, which should fail.\n");

    hr = pTSSD->Initialize(L"PROCESSA", SESSDIR_MACHINE_NAME, L"Cluster1", 
            L"OpaqueSettings", SINGLE_SESSION_FLAG, RepopSessDir);

    // Wait to be signaled.
    dr = WaitForSingleObject(MainSignalEvent, INFINITE);
       if (dr != WAIT_OBJECT_0) {
        printf("Wait failed.\n");
        exit(1);
    }


    checkerr(L"Initialize", hr);

    printf("Break in here.\n");
    Sleep(10000);

    // Verify there are no disconnected sessions for the user.
    hr = pTSSD->GetUserDisconnectedSessions(L"trevorfo", L"NTDEV", 
            &numSessionsReturned, SessionBuf);

    if (SUCCEEDED(hr)) {
        if (numSessionsReturned == 0)
            printf("GetUserDisconnectedSessions succeeded and returned 0 "
                    "users\n");
        else
            printf("FAIL: GetUserDisconnectedSessions returned %d users"
                    " (should be 0)\n", numSessionsReturned);
    }
    else {
        printf("FAIL: GetUserDisconnectedSessions failed, hr=%u\n", hr);
    }

    printf("Switching to multisession to verify still no disconnected sessions.\n");

    // Switch to multisession and check disconnected sessions again.
    hr = pTSSD->Update(L"PROCESSA", SESSDIR_MACHINE_NAME, L"Cluster1",
            L"OpaqueSettings", 0);

    checkerr(L"Update", hr);

    // Wait for the update to go through.
    printf("Should get a repopulate here...sleeping for 15 sec.\n");
    Sleep(15000);
    
    // Verify there are no disconnected sessions for the user.
    hr = pTSSD->GetUserDisconnectedSessions(L"trevorfo", L"NTDEV", 
            &numSessionsReturned, SessionBuf);

    if (SUCCEEDED(hr)) {
        if (numSessionsReturned == 0)
            printf("GetUserDisconnectedSessions succeeded and returned 0 "
                    "users\n");
        else
            printf("FAIL: GetUserDisconnectedSessions returned %d users"
                    " (should be 0)\n", numSessionsReturned);
    }
    else {
        printf("FAIL: GetUserDisconnectedSessions failed, hr=%u\n", hr);
    }

    
    // Switch back to single session and check the disconnected sessions.
    hr = pTSSD->Update(L"PROCESSA", SESSDIR_MACHINE_NAME, L"Cluster1",
            L"OpaqueSettings", SINGLE_SESSION_FLAG);

    checkerr(L"Update", hr);

    printf("Waiting for Repop.\n");
    
    Sleep(5000);
    
    // Verify there are no disconnected sessions for the user.
    hr = pTSSD->GetUserDisconnectedSessions(L"trevorfo", L"NTDEV", 
            &numSessionsReturned, SessionBuf);

    if (SUCCEEDED(hr)) {
        if (numSessionsReturned == 0)
            printf("GetUserDisconnectedSessions succeeded and returned 0 "
                    "users\n");
        else
            printf("FAIL: GetUserDisconnectedSessions returned %d users"
                    " (should be 0)\n", numSessionsReturned);
    }
    else {
        printf("FAIL: GetUserDisconnectedSessions failed, hr=%u\n", hr);
    }

    // Log in a user (we don't repopulate in this test currently)
    hr = ConnectUser(L"trevorfo", L"NTDEV", 3, 1, L"Desktop", 640, 480, 24, 22, 
            33);

    checkerr(L"ConnectUser", hr);


    // OK, switch back to the other process.
    br = SetEvent(ASignalEvent);

    if (br == FALSE) {
        printf("SetEvent failed.\n");
        exit(1);
    }

    // Sleep 100000
    Sleep(100000);
}

int __cdecl main(int argc, char* argv[])
{
    HRESULT hr;
    
    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    hr = CoCreateInstance(CLSID_TSSDJET, NULL, CLSCTX_INPROC_SERVER,
            IID_ITSSessionDirectory, (void **)&pTSSD);

    checkerr(L"CoCreateInstance", hr);

    if (argc == 2) {
        if (*argv[1] == 'A') {
            // We are process 'A'.
            RunProcessA();
        }
    }
    else {
        // We are ttsshe main process.
        RunMainProcess();
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdjet\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sds.rc
//
#define IDD_DIALOG_SDS                  101
#define IDC_CHECK_ENABLE                1000
#define IDC_EDIT_SERVERNAME             1001
#define IDC_EDIT_CLUSTERNAME            1002
#define IDS_DISABLE                     1004
#define IDS_ENABLE                      1005
#define IDS_ATTRIBUTE_NAME              1006
#define IDS_PROPERTIES                  1007
#define IDS_DESCRIP_ENABLE              1008
#define IDS_ERROR_SDIRLOC               1009
#define IDS_DESCRIP_PROPS               1010
#define IDC_EDIT_ACCOUNTNAME            1011
#define IDC_EDIT_PASSWORD               1012
#define IDC_STATIC_STORENAME            1013
#define IDC_STATIC_CLUSTERNAME          1014
#define IDS_ERROR_TITLE                 1017
#define IDS_ERROR_TEXT                  1018
#define IDS_ERROR_TEXT2                 1019
#define IDS_ERROR_TEXT3                 1020
#define IDS_HELPFILE                    1021
#define IDS_ERROR_SDIREMPTY             1022
#define IDC_CHECK_EXPOSEIP              1023
#define IDM_MENU_ENABLE                 2000
#define IDM_MENU_PROPS                  2001
#define IDC_WARNING_ICON                2002
#define IDI_SMALLWARN                   2003
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1021
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdjet\factory.cpp ===
/****************************************************************************/
// factory.cpp
//
// TS Session Directory class factory code.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>

#include <ole2.h>
#include <objbase.h>
#include <comutil.h>
#include <comdef.h>
#include <adoid.h>
#include <adoint.h>

#include "tssdjet.h"
#include "factory.h"
#include "trace.h"


extern long g_lObjects;
extern long g_lLocks;


/****************************************************************************/
// CClassFactory::QueryInterface
//
// Standard COM IUnknown interface function.
// Handles interface queries for the class factory only.
/****************************************************************************/
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IUnknown) {
        *ppv = (LPVOID)(IUnknown *)this;
    }
    else if(riid == IID_IClassFactory) {
        *ppv = (LPVOID)(IClassFactory *)this;
    }
    else {
        TRC2((TB,"ClassFactory: Unknown interface"));
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


/****************************************************************************/
// CClassFactory::AddRef
//
// Standard COM IUnknown function.
/****************************************************************************/
STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_RefCount);
}


/****************************************************************************/
// CClassFactory::Release
//
// Standard COM IUnknown function.
/****************************************************************************/
STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    long Refs = InterlockedDecrement(&m_RefCount);
    if (Refs == 0)
        delete this;

    return Refs;
}


/****************************************************************************/
// CClassFactory::CreateInstance
//
// IClassFactory creator function.
/****************************************************************************/
STDMETHODIMP CClassFactory::CreateInstance(
        IN IUnknown *pUnknownOuter,
        IN REFIID iid,
        OUT LPVOID *ppv)
{
    HRESULT hr;
    CTSSessionDirectory *pTSSDI = NULL;

    *ppv = NULL;

    TRC2((TB,"ClassFactory::CreateInstance"));

    // We do not support aggregation
    if (pUnknownOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    // Create the provider object
    pTSSDI = new CTSSessionDirectory;
    if (pTSSDI != NULL) {
        // Retrieve the requested interface.
        hr = pTSSDI->QueryInterface(iid, ppv);
        if (!FAILED(hr)) {
            return S_OK;
        }
        else {
            delete pTSSDI;
            return hr;
        }
    }
    else {
        return E_OUTOFMEMORY;
    }
}


/****************************************************************************/
// CClassFactory::LockServer
//
// IClassFactory lock function.
/****************************************************************************/
STDMETHODIMP CClassFactory::LockServer(IN BOOL bLock)
{
    if (bLock)
        InterlockedIncrement(&g_lLocks);
    else
        InterlockedDecrement(&g_lLocks);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdjet\server.cpp ===
/****************************************************************************/
// server.cpp
//
// General COM in-proc server framework code. TSSD-specific code is
// designated by CLSID SPECIFIC comments.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <tchar.h>

#define INITGUID
#include <ole2.h>
#include <objbase.h>
#include <comutil.h>
#include <comdef.h>
#include <adoid.h>
#include <adoint.h>
#include <initguid.h>

#include "factory.h"
#include "trace.h"


/****************************************************************************/
// CLSID SPECIFIC section
//
// Provider-specific includes, unique CLSID, other info.
/****************************************************************************/

// For new components, this is the only area that needs to be modified in this
// file. Include any appropriate header files, a unique CLSID and update 
// the macros.

#include "tssd.h"

// {005a9c68-e216-4b27-8f59-b336829b3868}
DEFINE_GUID(CLSID_TSSDJET,
        0x005a9c68, 0xe216, 0x4b27, 0x8f, 0x59, 0xb3, 0x36, 0x82, 0x9b, 0x38, 0x68);

// {ec98d957-48ad-436d-90be-bc291f42709c}
DEFINE_GUID(CLSID_TSSDJETEX,
        0xec98d957, 0x48ad, 0x436d, 0x90, 0xbe, 0xbc, 0x29, 0x1f, 0x42, 0x70, 0x9c);


#define IMPLEMENTED_CLSID       CLSID_TSSDJET
#define IMPLEMENTED_CLSIDEX     CLSID_TSSDJETEX

#define SERVER_REGISTRY_COMMENT L"Terminal Server Session Directory Interface"
#define CPP_CLASS_NAME          CTSSessionDirectory
#define INTERFACE_CAST          (ITSSessionDirectory *)

/****************************************************************************/
// End CLSID SPECIFIC section
/****************************************************************************/


HINSTANCE g_hInstance;
long g_lLocks = 0;
long g_lObjects = 0;


/****************************************************************************/
// DllMain
//
// Standard DLL entry point. Returns FALSE on failure.
/****************************************************************************/
BOOL WINAPI DllMain(
        HINSTANCE hInstDLL,
        DWORD dwReason,
        LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hInstDLL;
        DisableThreadLibraryCalls(hInstDLL);
    }

    return TRUE;
}


/****************************************************************************/
// DllGetClassObject
//
// Standard OLE In-Process Server entry point to return an class factory
// instance.
//***************************************************************************
STDAPI DllGetClassObject(
        REFCLSID rclsid,
        REFIID riid,
        LPVOID *ppv)
{
    CClassFactory *pClassFactory;
    HRESULT hr;

    TRC2((TB,"DllGetClassObject"));

    // Verify the caller is asking for our type of object
    if (rclsid == IMPLEMENTED_CLSID || rclsid == IMPLEMENTED_CLSIDEX) { 
        // Create the class factory.
        pClassFactory = new CClassFactory;
        if (pClassFactory != NULL) {
            hr = pClassFactory->QueryInterface(riid, ppv);
            if (FAILED(hr)) {
                ERR((TB,"DllGetClassObject: GUID not found"));
                delete pClassFactory;
            }
        }
        else {
            ERR((TB,"DllGetClassObject: Failed alloc class factory"));
            hr = E_OUTOFMEMORY;
        }
    }
    else {
        ERR((TB,"DllGetClassObject: Failed alloc class factory"));
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}


/****************************************************************************/
// DllCanUnloadNow
//
// Standard COM entry point for COM server shutdown request. Allows shutdown
// only if no outstanding objects or locks are present.
/****************************************************************************/
STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;

    if (g_lLocks == 0 && g_lObjects == 0)
        hr = S_OK;
    else
        hr = S_FALSE;

    return hr;
}


/****************************************************************************/
// DllRegisterServer
//
// Standard COM entry point for registering the server.
/****************************************************************************/
HRESULT RegisterCLSID(CLSID  clsid)
{
    HRESULT hr = E_FAIL;
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];
    wchar_t Path[1024];

    // Get the DLL's filename
    GetModuleFileNameW(g_hInstance, Path, 1024);

    TRC2((TB,"RegisterCLSID: %S", KeyPath));

    // Convert CLSID to string.
    if( SUCCEEDED( StringFromCLSID(clsid, &pGuidStr) ) )
    {  
        swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

        // Place it in registry.
        // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
        //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 :
        //        <no_name> : "path to DLL"
        //        ThreadingModel : "both"
        HKEY hKey;
        LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
        if (lRes == 0) {
            wchar_t *pName = SERVER_REGISTRY_COMMENT;
            RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *)pName,
                    wcslen(pName) * 2 + 2);
    
            HKEY hSubkey;
            lRes = RegCreateKeyW(hKey, L"InprocServer32", &hSubkey);
    
            RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path,
                    wcslen(Path) * 2 + 2);
            RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ,
                    (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);
    
            RegCloseKey(hSubkey);
            RegCloseKey(hKey);
        }
        else {
            TRC2((TB,"RegisterCLSID: Failed to Create key: %x", lRes));
        }
    
        CoTaskMemFree(pGuidStr);
    
        hr = HRESULT_FROM_WIN32( lRes );
    }
    else {
        TRC2((TB,"RegisterCLSID failed"));
    }

    return hr;
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr = E_FAIL;
    
    hr = RegisterCLSID(IMPLEMENTED_CLSID);
    hr = RegisterCLSID(IMPLEMENTED_CLSIDEX);
    
    return hr;    
}


/****************************************************************************/
// DllUnregisterServer
//
// Standard COM entry point for unregistering the server.
/****************************************************************************/
HRESULT UnregisterCLSID(REFCLSID rclsid)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];
    HRESULT hr = E_FAIL;

    if( SUCCEEDED( StringFromCLSID(rclsid, &pGuidStr) ) )
    {
        swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

        // Delete InProcServer32 subkey.
        LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
        if (!lRes) {
            RegDeleteKeyW(hKey, L"InprocServer32");
            RegCloseKey(hKey);

            // Delete CLSID GUID key.
            lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
            if (!lRes) {
                RegDeleteKeyW(hKey, pGuidStr);
                RegCloseKey(hKey);
            }
        }
        
        CoTaskMemFree(pGuidStr);

        hr = HRESULT_FROM_WIN32( lRes );
    }

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];
    HRESULT hr = E_FAIL;

    hr = UnregisterCLSID(IMPLEMENTED_CLSID);
    hr = UnregisterCLSID(IMPLEMENTED_CLSIDEX);
    
    return hr;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdsql\factory.h ===
/****************************************************************************/
// factory.h
//
// TSLI class factory definition.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/
#ifndef __FACTORY_H
#define __FACTORY_H


class CClassFactory : public IClassFactory
{
protected:
    long m_RefCount;

public:
    CClassFactory() : m_RefCount(0) {}

    // Standard COM methods
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory COM interfaces
    STDMETHODIMP CreateInstance(IUnknown *, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};



#endif  // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdjet\trace.h ===
/****************************************************************************/
// trace.h
//
// Tracing definitions. See trace.c for other information.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif


#if DBG || defined(_DEBUG)

#include <stdio.h>


// Zones. Up to 32 zones can be defined, these are predefined for general use.
#define Z_ASSERT 0x01
#define Z_ERR    0x02
#define Z_WRN    0x04
#define Z_TRC1   0x08
#define Z_TRC2   0x10

// Defined in msmcs.c.
extern char TB[1024];
extern UINT32 g_TraceMask;
void TracePrintZ(UINT32, char *);

// Error, warning, trace level 1, and trace level 2 definitions.
#define ERR(X) TRCZ(Z_ERR, X)
#define WRN(X) TRCZ(Z_WRN, X)
#define TRC1(X) TRCZ(Z_TRC1, X)
#define TRC2(X) TRCZ(Z_TRC2, X)
#define ASSERT(COND, X) \
{  \
    if (!(COND)) { \
        TRCZ(Z_ASSERT, X); \
        DebugBreak(); \
    }  \
}

#define TRCZ(Z, X) \
{ \
    if (g_TraceMask & (Z)) { \
        sprintf X; \
        TracePrintZ((Z), TB); \
    } \
}


#else  // DBG

#define ERR(X)
#define WRN(X)
#define TRC1(X)
#define TRC2(X)
#define ASSERT(COND, X)

#endif  // DBG



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdjet\synch.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    synch.c

Abstract:

    This module contains routines for shared reader/writer locks for Session 
    Directory.  These reader/writer locks can starve writers, so the assumption
    is that there is not a lot of constant reading activity.

Author:

    Trevor Foucher (trevorfo) 01-Feb-2001

Environment:
    User mode.

Revision History:

    01-Feb-2001 trevorfo
        Created

--*/


#include "synch.h"


#if DBG
NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
        TRUE)
#else
#define ASSERT( exp )         ((void) 0)
#endif



BOOL
InitializeSharedResource(
    IN OUT PSHAREDRESOURCE psr
    )

/*++

Routine Description:

    This routine initializes a shared resource object.  Call FreeSharedResource
    to free.

Arguments:

    psr - Pointer to SHAREDRESOURCE to initialize.  Must point to a valid block
          of memory, and the psr->Valid field must be FALSE.

Return Value:

    TRUE if the function succeeds, FALSE if it fails.

--*/
{
    BOOL brr = FALSE;
    BOOL bwr = FALSE;
    BOOL retval = FALSE;

    ASSERT(!IsBadReadPtr(psr, sizeof(psr)));
    ASSERT(psr->Valid == FALSE);
    
    // Initialize Reader Mutex, Writer Mutex.
    __try {

        // Initialize the critical section to preallocate the event
        // and spin 4096 times on each try (since we don't spend very
        // long in our critical section).
        brr = InitializeCriticalSectionAndSpinCount(&psr->ReaderMutex, 
                0x80001000);
        bwr = InitializeCriticalSectionAndSpinCount(&psr->WriterMutex,
                0x80001000);

    }
    __finally {

        if (brr && bwr) {
            retval = TRUE;
            psr->Valid = TRUE;
        }
        else {
            if (brr)
                DeleteCriticalSection(&psr->ReaderMutex);
            if (bwr)
                DeleteCriticalSection(&psr->WriterMutex);

            psr->Valid = FALSE;
        }
    }

    // Initialize Readers
    psr->Readers = 0;

    return retval;
}


VOID
AcquireResourceShared(
    IN PSHAREDRESOURCE psr
    )
/*++

Routine Description:

    This routine acquires a resource for shared access.
    
Arguments:

    psr - Pointer to SHAREDRESOURCE which has been initialized.

Return Value:

    None.

--*/
{
    ASSERT(psr->Valid);
    
    EnterCriticalSection(&psr->ReaderMutex);

    psr->Readers += 1;

    if (psr->Readers == 1)
        EnterCriticalSection(&psr->WriterMutex);

    LeaveCriticalSection(&psr->ReaderMutex);
}


VOID
ReleaseResourceShared(
    IN PSHAREDRESOURCE psr
    )
/*++

Routine Description:

    This routine releases a resource's shared access.
    
Arguments:

    psr - Pointer to SHAREDRESOURCE which has been initialized and which has
          shared (read) access.

Return Value:

    None.

--*/
{
    ASSERT(psr->Valid);

    EnterCriticalSection(&psr->ReaderMutex);

    ASSERT(psr->Readers != 0);

    psr->Readers -= 1;

    if (psr->Readers == 0)
        LeaveCriticalSection(&psr->WriterMutex);

    LeaveCriticalSection(&psr->ReaderMutex);
}


VOID
AcquireResourceExclusive(
    IN PSHAREDRESOURCE psr
    )
/*++

Routine Description:
    This routine acquires a resource for exclusive (write) access.

Arguments:

    psr - Pointer to SHAREDRESOURCE which has been initialized.

Return Value:

    None.

--*/
{
    ASSERT(psr->Valid);

    EnterCriticalSection(&psr->WriterMutex);

    ASSERT(psr->Readers == 0);
}


VOID
ReleaseResourceExclusive(
    IN PSHAREDRESOURCE psr
    )
/*++

Routine Description:
    This routine releases a resource for which we have exclusive (write) access.

Arguments:

    psr - Pointer to SHAREDRESOURCE which has been initialized and which has
          write access.

Return Value:

    None.

--*/
{
    ASSERT(psr->Valid);
    ASSERT(psr->Readers == 0);

    LeaveCriticalSection(&psr->WriterMutex);
}


VOID
FreeSharedResource(
    IN OUT PSHAREDRESOURCE psr
    )
/*++

Routine Description:

    This routine frees resources taken up by a shared resource object allocated
    by InitializeSharedResource.  It does not free the memory.
    
Arguments:

    psr - Pointer to SHAREDRESOURCE whose resources should be freed.

Return Value:

    None.

--*/
{
    ASSERT(psr->Valid);
    ASSERT(psr->Readers == 0);

    DeleteCriticalSection(&psr->ReaderMutex);
    DeleteCriticalSection(&psr->WriterMutex);
    
    psr->Readers = 0;
    psr->Valid = FALSE;
}


BOOL
VerifyNoSharedAccess(
    IN PSHAREDRESOURCE psr
    )
/*++

Routine Description:

    This routine verifies that the critical section does not currently have any
    shared accessors.

Arugments:

    psr - Pointer to SHAREDRESOURCE to verify.

Return Value:

    TRUE - if there are no shared accessors.
    FALSE - if there are shared accessors.

--*/
{
    ASSERT(psr->Valid);
    
    return (psr->Readers == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdjet\tssdjet.h ===
/****************************************************************************/
// tssdjet.h
//
// Terminal Server Session Directory Interface Jet RPC provider header.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/
#ifndef __TSSDJET_H
#define __TSSDJET_H

#include <tchar.h>

#include "tssd.h"
#include "tssdshrd.h"
#include "srvsetex.h"
#include "jetrpc.h"
#include "synch.h"


/****************************************************************************/
// Defines
/****************************************************************************/


/****************************************************************************/
// Types
/****************************************************************************/

// CTSSessionDirectory
//
// C++ class instantiation of ITSSessionDirectory.
class CTSSessionDirectory : public ITSSessionDirectory, 
        public IExtendServerSettings, public ITSSessionDirectoryEx
{
private:
    long m_RefCount;

    BOOL m_bConnected;
    HCLIENTINFO m_hCI;
    RPC_BINDING_HANDLE m_hRPCBinding;
    WCHAR m_StoreServerName[64];
    WCHAR m_LocalServerAddress[64];
    WCHAR m_ClusterName[64];

    // Flags passed in from Termsrv
    DWORD m_Flags;

    // Private data for UI menus
    BOOL m_fEnabled;

    // Autorecovery variables
    //
    // Events
    // * m_hSDServerDown - Event that is signalled to awaken recovery thread,
    // which wakes up, polls the session directory until it comes back up,
    // and then refreshes the database.
    // * m_hTerminateRecovery - Recovery thread, when it enters waits, can be
    // terminated by the use of this event
    //
    // Thread Information
    // * m_hRecoveryThread - Handle to the recovery thread.
    // * m_RecoveryTid - Thread identifier for recovery thread.
    //
    // Boolean
    // * m_bSDIsUp - If this is on then we think the session directory is up.
    // * m_sr - Protects m_SDIsUp.
    //
    // DWORD
    // * m_RecoveryTimeout - time in ms between attempts to reestablish
    // connection with the session directory.
    //
    // Function pointer
    // * m_repopfn - pointer to the repopulation function in termsrv to call
    // when we want an update.

    HANDLE m_hSDServerDown;
    HANDLE m_hTerminateRecovery;
    uintptr_t m_hRecoveryThread;

    unsigned m_RecoveryTid;

    // m_sr protects SDIsUp flag
    SHAREDRESOURCE m_sr;
    volatile LONG m_SDIsUp;

    // Flag for whether shared reader/writer lock init succeeded.  If it doesn't
    // succeed, we can't do anything.
    BOOL m_LockInitializationSuccessful;

    DWORD m_RecoveryTimeout;

    DWORD (*m_repopfn)();

    // Autorecovery thread
    unsigned static __stdcall RecoveryThread(void *);
    VOID RecoveryThreadEx();

    // Helper functions
    DWORD RequestSessDirUpdate();
    DWORD ReestablishSessionDirectoryConnection();
    void Terminate();
    void StartupSD();
    void NotifySDServerDown();
    boolean EnterSDRpc();
    void LeaveSDRpc();
    void DisableSDRpcs();
    void EnableSDRpcs();


public:
    CTSSessionDirectory();
    ~CTSSessionDirectory();

    // Standard COM methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, void **);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // ITSSessionDirectory COM interface
    HRESULT STDMETHODCALLTYPE Initialize(LPWSTR, LPWSTR, LPWSTR, LPWSTR, 
            DWORD, DWORD (*)());
    HRESULT STDMETHODCALLTYPE Update(LPWSTR, LPWSTR, LPWSTR, LPWSTR, DWORD);
    HRESULT STDMETHODCALLTYPE GetUserDisconnectedSessions(LPWSTR, LPWSTR,
            DWORD __RPC_FAR *, TSSD_DisconnectedSessionInfo __RPC_FAR
            [TSSD_MaxDisconnectedSessions]);
    HRESULT STDMETHODCALLTYPE NotifyCreateLocalSession(
            TSSD_CreateSessionInfo __RPC_FAR *);
    HRESULT STDMETHODCALLTYPE NotifyDestroyLocalSession(DWORD);
    HRESULT STDMETHODCALLTYPE NotifyDisconnectLocalSession(DWORD, FILETIME);

    HRESULT STDMETHODCALLTYPE NotifyReconnectLocalSession(
            TSSD_ReconnectSessionInfo __RPC_FAR *);
    HRESULT STDMETHODCALLTYPE NotifyReconnectPending(WCHAR *);
    HRESULT STDMETHODCALLTYPE Repopulate(DWORD, TSSD_RepopulateSessionInfo *);
    HRESULT STDMETHODCALLTYPE GetLoadBalanceInfo(LPWSTR, BSTR*);

    // IExtendServerSettings COM interface
    STDMETHOD(GetAttributeName)(WCHAR *);
    STDMETHOD(GetDisplayableValueName)(WCHAR *);
    STDMETHOD(InvokeUI)(HWND,PDWORD);
    STDMETHOD(GetMenuItems)(int *, PMENUEXTENSION *);
    STDMETHOD(ExecMenuCmd)(UINT, HWND, PDWORD);
    STDMETHOD(OnHelp)(int *);

    BOOL CTSSessionDirectory::CheckSessionDirectorySetting(WCHAR *Setting);
    BOOL IsSessionDirectoryEnabled();
    BOOL CTSSessionDirectory::IsSessionDirectoryExposeServerIPEnabled();
    DWORD SetSessionDirectoryState(WCHAR *, BOOL);
    DWORD SetSessionDirectoryEnabledState(BOOL);
    DWORD SetSessionDirectoryExposeIPState(BOOL);
    void ErrorMessage(HWND hwnd , UINT res , DWORD);
    
public:
    TCHAR m_tchProvider[64];
    TCHAR m_tchDataSource[64];
    TCHAR m_tchUserId[64];
    TCHAR m_tchPassword[64];
};



#endif // __TSSDJET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdjet\synch.h ===
/******************************************************************************/
// synch.h
//
// Terminal Server Session Directory shared reader/writer header.
//
// Copyright (C) 2001 Microsoft Corporation
/******************************************************************************/

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _SHAREDRESOURCE {
    CRITICAL_SECTION ReaderMutex;
    CRITICAL_SECTION WriterMutex;

    DWORD Readers;
    BOOL Valid;
} SHAREDRESOURCE, *PSHAREDRESOURCE;


BOOL
InitializeSharedResource(
    IN OUT PSHAREDRESOURCE psr
    );

VOID
AcquireResourceShared(
    IN PSHAREDRESOURCE psr
    );

VOID
ReleaseResourceShared(
    IN PSHAREDRESOURCE psr
    );

VOID
AcquireResourceExclusive(
    IN PSHAREDRESOURCE psr
    );

VOID
ReleaseResourceExclusive(
    IN PSHAREDRESOURCE psr
    );

VOID
FreeSharedResource(
    IN OUT PSHAREDRESOURCE psr
    );

BOOL
VerifyNoSharedAccess(
    IN PSHAREDRESOURCE psr
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdsql\factory.cpp ===
/****************************************************************************/
// factory.cpp
//
// TS Session Directory class factory code.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>

#include <ole2.h>
#include <objbase.h>
#include <comutil.h>
#include <comdef.h>
#include <adoid.h>
#include <adoint.h>

#include "tssdsql.h"
#include "factory.h"
#include "trace.h"


extern long g_lObjects;
extern long g_lLocks;


/****************************************************************************/
// CClassFactory::QueryInterface
//
// Standard COM IUnknown interface function.
// Handles interface queries for the class factory only.
/****************************************************************************/
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IUnknown) {
        *ppv = (LPVOID)(IUnknown *)this;
    }
    else if(riid == IID_IClassFactory) {
        *ppv = (LPVOID)(IClassFactory *)this;
    }
    else {
        TRC2((TB,"ClassFactory: Unknown interface"));
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


/****************************************************************************/
// CClassFactory::AddRef
//
// Standard COM IUnknown function.
/****************************************************************************/
STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_RefCount);
}


/****************************************************************************/
// CClassFactory::Release
//
// Standard COM IUnknown function.
/****************************************************************************/
STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    long Refs = InterlockedDecrement(&m_RefCount);
    if (Refs == 0)
        delete this;

    return Refs;
}


/****************************************************************************/
// CClassFactory::CreateInstance
//
// IClassFactory creator function.
/****************************************************************************/
STDMETHODIMP CClassFactory::CreateInstance(
        IN IUnknown *pUnknownOuter,
        IN REFIID iid,
        OUT LPVOID *ppv)
{
    HRESULT hr;
    CTSSessionDirectory *pTSSDI = NULL;

    *ppv = NULL;

    TRC2((TB,"ClassFactory::CreateInstance"));

    // We do not support aggregation
    if (pUnknownOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    // Create the provider object
    pTSSDI = new CTSSessionDirectory;
    if (pTSSDI != NULL) {
        // Retrieve the requested interface.
        hr = pTSSDI->QueryInterface(iid, ppv);
        if (!FAILED(hr)) {
            return S_OK;
        }
        else {
            delete pTSSDI;
            return hr;
        }
    }
    else {
        return E_OUTOFMEMORY;
    }
}


/****************************************************************************/
// CClassFactory::LockServer
//
// IClassFactory lock function.
/****************************************************************************/
STDMETHODIMP CClassFactory::LockServer(IN BOOL bLock)
{
    if (bLock)
        InterlockedIncrement(&g_lLocks);
    else
        InterlockedDecrement(&g_lLocks);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdsql\trace.h ===
/****************************************************************************/
// trace.h
//
// Tracing definitions. See trace.c for other information.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif


#if DBG || defined(_DEBUG)

#include <stdio.h>


// Zones. Up to 32 zones can be defined, these are predefined for general use.
#define Z_ASSERT 0x01
#define Z_ERR    0x02
#define Z_WRN    0x04
#define Z_TRC1   0x08
#define Z_TRC2   0x10

// Defined in msmcs.c.
extern char TB[1024];
extern UINT32 g_TraceMask;
void TracePrintZ(UINT32, char *);

// Error, warning, trace level 1, and trace level 2 definitions.
#define ERR(X) TRCZ(Z_ERR, X)
#define WRN(X) TRCZ(Z_WRN, X)
#define TRC1(X) TRCZ(Z_TRC1, X)
#define TRC2(X) TRCZ(Z_TRC2, X)
#define ASSERT(COND, X) \
{  \
    if (!(COND)) { \
        TRCZ(Z_ASSERT, X); \
        DebugBreak(); \
    }  \
}

#define TRCZ(Z, X) \
{ \
    if (g_TraceMask & (Z)) { \
        sprintf X; \
        TracePrintZ((Z), TB); \
    } \
}


#else  // DBG

#define ERR(X)
#define WRN(X)
#define TRC1(X)
#define TRC2(X)
#define ASSERT(COND, X)

#endif  // DBG



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdjet\trace.c ===
/****************************************************************************/
// trace.c
//
// Tracing code and definitions. See trace.h for other info.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#if DBG || defined(_DEBUG)

#include <windows.h>

#include "trace.h"


struct _ZoneInfo
{
    UINT32 Zone;
    char *Prefix;
} TRC_ZI[] =
{
    { Z_ASSERT, "TSSDJET: !!! ASSERT: " },
    { Z_ERR,    "TSSDJET: *** ERROR: " },
    { Z_WRN,    "TSSDJET: Warning: " },
    { Z_TRC1,   "TSSDJET: " },
    { Z_TRC2,   "TSSDJET: " },
};
int NumTRC_ZIEntries = sizeof(TRC_ZI) / sizeof(struct _ZoneInfo);


// Globals.
UINT32 g_TraceMask = 0xFFFFFFFF;
char TB[1024];
char TB2[1024];


// Main output function.
void TracePrintZ(UINT32 ZoneFlag, char *OutString)
{
    int i;
    char *Prefix = "";

    // Find the zone information in the zone table.
    for (i = 0; i < NumTRC_ZIEntries; i++)
        if (TRC_ZI[i].Zone == ZoneFlag)
            Prefix = TRC_ZI[i].Prefix;

    // Now create the final string.
    wsprintfA(TB2, "%s%s\n", Prefix, OutString);

    // Send to output.
    OutputDebugStringA(TB2);
}



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdjet\tssdjet.cpp ===
/****************************************************************************/
// tssdjet.cpp
//
// Terminal Server Session Directory Jet RPC component code.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <process.h>

#include <ole2.h>
#include <objbase.h>
#include <comdef.h>
#include <winsta.h>
#include <regapi.h>
#include <winsock2.h>

#include "tssdjet.h"
#include "trace.h"
#include "resource.h"

#pragma warning (push, 4)

/****************************************************************************/
// Defines
/****************************************************************************/
#define REQUEST_UPDATE 1
#define DONT_REQUEST_UPDATE 0


/****************************************************************************/
// Prototypes
/****************************************************************************/
INT_PTR CALLBACK CustomUIDlg(HWND, UINT, WPARAM, LPARAM);


/****************************************************************************/
// Globals
/****************************************************************************/
extern HINSTANCE g_hInstance;

// The COM object counter (declared in server.cpp)
extern long g_lObjects;

// RPC binding string components - RPC over named pipes.
const WCHAR *g_RPCUUID = L"aa177641-fc9b-41bd-80ff-f964a701596f"; 
                                                    // From jetrpc.idl
const WCHAR *g_RPCOptions = L"Security=Impersonation Dynamic False";
const WCHAR *g_RPCProtocolSequence = L"ncacn_ip_tcp";   // RPC over TCP/IP
const WCHAR *g_RPCRemoteEndpoint = L"\\pipe\\TSSD_Jet_RPC_Service";


/****************************************************************************/
// Static RPC Exception Filter structure and function, based on 
// I_RpcExceptionFilter in \nt\com\rpc\runtime\mtrt\clntapip.cxx.
/****************************************************************************/

// windows.h includes windef.h includes winnt.h, which defines some exceptions
// but not others.  ntstatus.h contains the two extra we want, 
// STATUS_POSSIBLE_DEADLOCK and STATUS_INSTRUCTION_MISALIGNMENT, but it would
// be very difficult to get the right #includes in without a lot of trouble.

#define STATUS_POSSIBLE_DEADLOCK         0xC0000194L
#define STATUS_INSTRUCTION_MISALIGNMENT  0xC00000AAL

const ULONG FatalExceptions[] = 
{
    STATUS_ACCESS_VIOLATION,
    STATUS_POSSIBLE_DEADLOCK,
    STATUS_INSTRUCTION_MISALIGNMENT,
    STATUS_DATATYPE_MISALIGNMENT,
    STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_ILLEGAL_INSTRUCTION,
    STATUS_BREAKPOINT,
    STATUS_STACK_OVERFLOW
};

const int FATAL_EXCEPTIONS_ARRAY_SIZE = sizeof(FatalExceptions) / 
        sizeof(FatalExceptions[0]);

static int TSSDRpcExceptionFilter (unsigned long ExceptionCode)
{
    int i;

    for (i = 0; i < FATAL_EXCEPTIONS_ARRAY_SIZE; i++) {
        if (ExceptionCode == FatalExceptions[i])
            return EXCEPTION_CONTINUE_SEARCH;
        }

    return EXCEPTION_EXECUTE_HANDLER;
}


/****************************************************************************/
// MIDL_user_allocate
// MIDL_user_free
//
// RPC-required allocation functions.
/****************************************************************************/
void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t Size)
{
    return LocalAlloc(LMEM_FIXED, Size);
}

void __RPC_USER MIDL_user_free(void __RPC_FAR *p)
{
    LocalFree(p);
}


/****************************************************************************/
// CTSSessionDirectory::CTSSessionDirectory
// CTSSessionDirectory::~CTSSessionDirectory
//
// Constructor and destructor
/****************************************************************************/
CTSSessionDirectory::CTSSessionDirectory() :
        m_RefCount(0), m_hRPCBinding(NULL), m_hSDServerDown(NULL), 
        m_hTerminateRecovery(NULL), m_hRecoveryThread(NULL), m_RecoveryTid(0),
        m_LockInitializationSuccessful(FALSE), m_SDIsUp(FALSE), m_Flags(0)
{
    InterlockedIncrement(&g_lObjects);

    m_StoreServerName[0] = L'\0';
    m_LocalServerAddress[0] = L'\0';
    m_ClusterName[0] = L'\0';

    m_fEnabled = 0;
    m_tchProvider[0] = 0;
    m_tchDataSource[0] = 0;
    m_tchUserId[0] = 0;
    m_tchPassword[0] = 0;

    m_sr.Valid = FALSE;

    // Recovery timeout should be configurable, but currently is not.
    // Time is in ms.
    m_RecoveryTimeout = 15000;

    if (InitializeSharedResource(&m_sr)) {
        m_LockInitializationSuccessful = TRUE;
    }
    else {
        ERR((TB, "Constructor: Failed to initialize shared resource"));
    }

}

CTSSessionDirectory::~CTSSessionDirectory()
{
    // Clean up.
    if (m_LockInitializationSuccessful)
        Terminate();

    if (m_sr.Valid)
        FreeSharedResource(&m_sr);
    
    // Decrement the global COM object counter.
    InterlockedDecrement(&g_lObjects);
}


/****************************************************************************/
// CTSSessionDirectory::QueryInterface
//
// Standard COM IUnknown function.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::QueryInterface(
        REFIID riid,
        void **ppv)
{
    if (riid == IID_IUnknown) {
        *ppv = (LPVOID)(IUnknown *)(ITSSessionDirectory *)this;
    }
    else if (riid == IID_ITSSessionDirectory) {
        *ppv = (LPVOID)(ITSSessionDirectory *)this;
    }
    else if (riid == IID_IExtendServerSettings) {
        *ppv = (LPVOID)(IExtendServerSettings *)this;
    }
    else if (riid == IID_ITSSessionDirectoryEx) {
        *ppv = (LPVOID)(ITSSessionDirectoryEx *)this;
    }
    else {
        ERR((TB,"QI: Unknown interface"));
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


/****************************************************************************/
// CTSSessionDirectory::AddRef
//
// Standard COM IUnknown function.
/****************************************************************************/
ULONG STDMETHODCALLTYPE CTSSessionDirectory::AddRef()
{
    return InterlockedIncrement(&m_RefCount);
}


/****************************************************************************/
// CTSSessionDirectory::Release
//
// Standard COM IUnknown function.
/****************************************************************************/
ULONG STDMETHODCALLTYPE CTSSessionDirectory::Release()
{
    long lRef = InterlockedDecrement(&m_RefCount);

    if (lRef == 0)
        delete this;
    return lRef;
}


/****************************************************************************/
// CTSSessionDirectory::Initialize
//
// ITSSessionDirectory function. Called soon after object instantiation to
// initialize the directory. LocalServerAddress provides a text representation
// of the local server's load balance IP address. This information should be
// used as the server IP address in the session directory for client
// redirection by other pool servers to this server. SessionDirectoryLocation,
// SessionDirectoryClusterName, and SessionDirectoryAdditionalParams are 
// generic reg entries known to TermSrv which cover config info across any type
// of session directory implementation. The contents of these strings are 
// designed to be parsed by the session directory providers.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::Initialize(
        LPWSTR LocalServerAddress,
        LPWSTR StoreServerName,
        LPWSTR ClusterName,
        LPWSTR OpaqueSettings,
        DWORD Flags,
        DWORD (*repopfn)())
{
    HRESULT hr;
    WCHAR *pBindingString = NULL;

    // Unreferenced parameter
    OpaqueSettings;

    if (m_LockInitializationSuccessful == FALSE) {
        hr = E_OUTOFMEMORY;
        goto ExitFunc;
    }

    ASSERT((LocalServerAddress != NULL),(TB,"Init: LocalServerAddr null!"));
    ASSERT((StoreServerName != NULL),(TB,"Init: StoreServerName null!"));
    ASSERT((ClusterName != NULL),(TB,"Init: ClusterName null!"));
    ASSERT((repopfn != NULL),(TB,"Init: repopfn null!"));

    // Don't allow blank session directory server name.
    if (StoreServerName[0] == '\0') {
        hr = E_INVALIDARG;
        goto ExitFunc;
    }

    // Copy off the server address, store server, and cluster name for later
    // use.
    wcsncpy(m_StoreServerName, StoreServerName,
            sizeof(m_StoreServerName) / sizeof(WCHAR) - 1);
    m_StoreServerName[sizeof(m_StoreServerName) / sizeof(WCHAR) - 1] = L'\0';
    wcsncpy(m_LocalServerAddress, LocalServerAddress,
            sizeof(m_LocalServerAddress) / sizeof(WCHAR) - 1);
    m_LocalServerAddress[sizeof(m_LocalServerAddress) / sizeof(WCHAR) - 1] =
            L'\0';
    wcsncpy(m_ClusterName, ClusterName,
            sizeof(m_ClusterName) / sizeof(WCHAR) - 1);
    m_ClusterName[sizeof(m_ClusterName) / sizeof(WCHAR) - 1] = L'\0';
    m_Flags = Flags;
    m_repopfn = repopfn;

    TRC1((TB,"Initialize: Svr addr=%S, StoreSvrName=%S, ClusterName=%S, "
            "OpaqueSettings=%S, repopfn = %p",
            m_LocalServerAddress, m_StoreServerName, m_ClusterName,
            OpaqueSettings, repopfn));

    // Connect to the Jet RPC server according to the server name provided.
    // We first create an RPC binding handle from a composed binding string.
    hr = RpcStringBindingCompose(/*(WCHAR *)g_RPCUUID,*/
            0,
            (WCHAR *)g_RPCProtocolSequence, m_StoreServerName,
            /*(WCHAR *)g_RPCRemoteEndpoint, */
            0,
            NULL, &pBindingString);

    if (hr == RPC_S_OK) {
        // Generate the RPC binding from the canonical RPC binding string.
        hr = RpcBindingFromStringBinding(pBindingString, &m_hRPCBinding);
        
        if (hr == RPC_S_OK) {
            hr = RpcBindingSetAuthInfo(m_hRPCBinding, 0, 
                    RPC_C_AUTHN_LEVEL_NONE, RPC_C_AUTHN_WINNT, 0, 0);
            if (hr != RPC_S_OK) {
                ERR((TB,"Init: Error %d in RpcBindingSetAuthInfo", hr));
                goto ExitFunc;
            }
        } else {
            ERR((TB,"Init: Error %d in RpcBindingFromStringBinding\n", hr));
            m_hRPCBinding = NULL;
            goto ExitFunc;
        }
    }
    else {
        ERR((TB,"Init: Error %d in RpcStringBindingCompose\n", hr));
        pBindingString = NULL;
        goto ExitFunc;
    }

    // Initialize recovery infrastructure
    // Initialize should not be called more than once.

    ASSERT((m_hSDServerDown == NULL),(TB, "Init: m_hSDServDown non-NULL!"));
    ASSERT((m_hRecoveryThread == NULL),(TB, "Init: m_hSDRecoveryThread "
            "non-NULL!"));
    ASSERT((m_hTerminateRecovery == NULL), (TB, "Init: m_hTerminateRecovery "
            "non-NULL!"));


    // Initially unsignaled
    m_hSDServerDown = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_hSDServerDown == NULL) {
        ERR((TB, "Init: Failed to create event necessary for SD init, err = "
                "%d", GetLastError()));
        hr = E_FAIL;
        goto ExitFunc;
    }

    // Initially unsignaled, auto-reset.
    m_hTerminateRecovery = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hTerminateRecovery == NULL) {
        ERR((TB, "Init: Failed to create event necessary for SD init, err = "
            "%d", GetLastError()));
        hr = E_FAIL;
        goto ExitFunc;
    }

    m_hRecoveryThread = _beginthreadex(NULL, 0, RecoveryThread, (void *) this, 
            0, &m_RecoveryTid);
    if (m_hRecoveryThread == NULL) {
        ERR((TB, "Init: Failed to create recovery thread, errno = %d", errno));
        hr = E_FAIL;
        goto ExitFunc;
    }

    // Start up the session directory (by faking server down).
    StartupSD();
    
ExitFunc:
    if (pBindingString != NULL)
        RpcStringFree(&pBindingString);

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::Update
//
// ITSSessionDirectory function. Called whenever configuration settings change
// on the terminal server.  See Initialize for a description of the first four
// arguments, the fifth, Result, is a flag of whether to request a refresh of
// every session that should be in the session directory for this server after
// this call completes.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::Update(
        LPWSTR LocalServerAddress,
        LPWSTR StoreServerName,
        LPWSTR ClusterName,
        LPWSTR OpaqueSettings,
        DWORD Flags)
{
    HRESULT hr = S_OK;

    ASSERT((LocalServerAddress != NULL),(TB,"Update: LocalServerAddr null!"));
    ASSERT((StoreServerName != NULL),(TB,"Update: StoreServerName null!"));
    ASSERT((ClusterName != NULL),(TB,"Update: ClusterName null!"));
    ASSERT((OpaqueSettings != NULL),(TB,"Update: OpaqueSettings null!"));

    // For update, we do not care about either LocalServerAddress or 
    // OpaqueSettings.  If the StoreServerName or ClusterName has changed, we
    // Terminate and then reinitialize.
    if ((_wcsnicmp(StoreServerName, m_StoreServerName, 64) != 0) 
            || (_wcsnicmp(ClusterName, m_ClusterName, 64) != 0)
            || (Flags != m_Flags)) {

        // Terminate current connection.
        Terminate();
        
        // Initialize new connection.
        hr = Initialize(LocalServerAddress, StoreServerName, ClusterName, 
                OpaqueSettings, Flags, m_repopfn);

    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::GetUserDisconnectedSessions
//
// Called to perform a query against the session directory, to provide the
// list of disconnected sessions for the provided username and domain.
// Returns zero or more TSSD_DisconnectedSessionInfo blocks in SessionBuf.
// *pNumSessionsReturned receives the number of blocks.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::GetUserDisconnectedSessions(
        LPWSTR UserName,
        LPWSTR Domain,
        DWORD __RPC_FAR *pNumSessionsReturned,
        TSSD_DisconnectedSessionInfo __RPC_FAR SessionBuf[
            TSSD_MaxDisconnectedSessions])
{
    DWORD NumSessions = 0;
    HRESULT hr;
    unsigned i;
    unsigned long RpcException;
    TSSD_DiscSessInfo *adsi = NULL;
    
    TRC2((TB,"GetUserDisconnectedSessions"));

    ASSERT((pNumSessionsReturned != NULL),(TB,"NULL pNumSess"));
    ASSERT((SessionBuf != NULL),(TB,"NULL SessionBuf"));


    // Make the RPC call.
    if (EnterSDRpc()) {
    
        RpcTryExcept {
            hr = TSSDRpcGetUserDisconnectedSessions(m_hRPCBinding, &m_hCI, 
                    UserName, Domain, &NumSessions, &adsi);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"GetUserDisc: RPC Exception %d\n", RpcException));

            // In case RPC messed with us.
            m_hCI = NULL;
            NumSessions = 0;
            adsi = NULL;

            hr = E_FAIL;
        }
        RpcEndExcept

        if (SUCCEEDED(hr)) {
            TRC1((TB,"GetUserDisc: RPC call returned %u records", NumSessions));

            // Loop through and fill out the session records.
            for (i = 0; i < NumSessions; i++) {
                // ServerAddress
                wcsncpy(SessionBuf[i].ServerAddress, adsi[i].ServerAddress,
                        sizeof(SessionBuf[i].ServerAddress) / 
                        sizeof(WCHAR) - 1);
                SessionBuf[i].ServerAddress[sizeof(
                        SessionBuf[i].ServerAddress) / 
                        sizeof(WCHAR) - 1] = L'\0';

                // SessionId, TSProtocol
                SessionBuf[i].SessionID = adsi[i].SessionID;
                SessionBuf[i].TSProtocol = adsi[i].TSProtocol;

                // ApplicationType
                wcsncpy(SessionBuf[i].ApplicationType, adsi[i].AppType,
                        sizeof(SessionBuf[i].ApplicationType) / 
                        sizeof(WCHAR) - 1);
                SessionBuf[i].ApplicationType[sizeof(SessionBuf[i].
                        ApplicationType) / sizeof(WCHAR) - 1] = L'\0';

                // Resolutionwidth, ResolutionHeight, ColorDepth, CreateTime,
                // DisconnectionTime.
                SessionBuf[i].ResolutionWidth = adsi[i].ResolutionWidth;
                SessionBuf[i].ResolutionHeight = adsi[i].ResolutionHeight;
                SessionBuf[i].ColorDepth = adsi[i].ColorDepth;
                SessionBuf[i].CreateTime.dwLowDateTime = adsi[i].CreateTimeLow;
                SessionBuf[i].CreateTime.dwHighDateTime = 
                        adsi[i].CreateTimeHigh;
                SessionBuf[i].DisconnectionTime.dwLowDateTime = 
                        adsi[i].DisconnectTimeLow;
                SessionBuf[i].DisconnectionTime.dwHighDateTime = 
                        adsi[i].DisconnectTimeHigh;

                // Free the memory allocated by the server.
                MIDL_user_free(adsi[i].ServerAddress);
                MIDL_user_free(adsi[i].AppType);
            }
        }
        else {
            ERR((TB,"GetUserDisc: Failed RPC call, hr=0x%X", hr));
            NotifySDServerDown();
        }

        LeaveSDRpc();
    }
    else {
        ERR((TB,"GetUserDisc: Session Directory is unreachable"));
        hr = E_FAIL;
    }

    MIDL_user_free(adsi);

    *pNumSessionsReturned = NumSessions;
    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyCreateLocalSession
//
// ITSSessionDirectory function. Called when a session is created to add the
// session to the session directory. Note that other interface functions
// access the session directory by either the username/domain or the
// session ID; the directory schema should take this into account for
// performance optimization.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyCreateLocalSession(
        TSSD_CreateSessionInfo __RPC_FAR *pCreateInfo)
{
    HRESULT hr;
    unsigned long RpcException;

    TRC2((TB,"NotifyCreateLocalSession, SessID=%u", pCreateInfo->SessionID));

    ASSERT((pCreateInfo != NULL),(TB,"NotifyCreate: NULL CreateInfo"));

    // Make the RPC call.
    if (EnterSDRpc()) {

        // Make the RPC call.
        RpcTryExcept {
            // Make the call.
            hr = TSSDRpcCreateSession(m_hRPCBinding, &m_hCI, 
                    pCreateInfo->UserName,
                    pCreateInfo->Domain, pCreateInfo->SessionID,
                    pCreateInfo->TSProtocol, pCreateInfo->ApplicationType,
                    pCreateInfo->ResolutionWidth, pCreateInfo->ResolutionHeight,
                    pCreateInfo->ColorDepth, 
                    pCreateInfo->CreateTime.dwLowDateTime,
                    pCreateInfo->CreateTime.dwHighDateTime);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"NotifyCreate: RPC Exception %d\n", RpcException));
            hr = E_FAIL;
        }
        RpcEndExcept

        if (FAILED(hr)) {
            ERR((TB,"NotifyCreate: Failed RPC call, hr=0x%X", hr));
            NotifySDServerDown();
        }

        LeaveSDRpc();
    }
    else {
        ERR((TB,"NotifyCreate: Session directory is unreachable"));
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyDestroyLocalSession
//
// ITSSessionDirectory function. Removes a session from the session database.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyDestroyLocalSession(
        DWORD SessionID)
{
    HRESULT hr;
    unsigned long RpcException;

    TRC2((TB,"NotifyDestroyLocalSession, SessionID=%u", SessionID));

    // Make the RPC call.
    if (EnterSDRpc()) {

        RpcTryExcept {
            // Make the call.
            hr = TSSDRpcDeleteSession(m_hRPCBinding, &m_hCI, SessionID);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"NotifyDestroy: RPC Exception %d\n", RpcException));
            hr = E_FAIL;
        }
        RpcEndExcept

        if (FAILED(hr)) {
            ERR((TB,"NotifyDestroy: Failed RPC call, hr=0x%X", hr));
            NotifySDServerDown();
        }

        LeaveSDRpc();
    }
    else {
        ERR((TB,"NotifyDestroy: Session directory is unreachable"));
        hr = E_FAIL;
    }


    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyDisconnectLocalSession
//
// ITSSessionDirectory function. Changes the state of an existing session to
// disconnected. The provided time should be returned in disconnected session
// queries performed by any machine in the server pool.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyDisconnectLocalSession(
        DWORD SessionID,
        FILETIME DiscTime)
{
    HRESULT hr;
    unsigned long RpcException;

    TRC2((TB,"NotifyDisconnectLocalSession, SessionID=%u", SessionID));

    // Make the RPC call.
    if (EnterSDRpc()) {

        RpcTryExcept {
            // Make the call.
            hr = TSSDRpcSetSessionDisconnected(m_hRPCBinding, &m_hCI, SessionID,
                    DiscTime.dwLowDateTime, DiscTime.dwHighDateTime);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"NotifyDisc: RPC Exception %d\n", RpcException));
            hr = E_FAIL;
        }
        RpcEndExcept

        if (FAILED(hr)) {
            ERR((TB,"NotifyDisc: RPC call failed, hr=0x%X", hr));
            NotifySDServerDown();
        }

        LeaveSDRpc();
    }
    else {
        ERR((TB,"NotifyDisc: Session directory is unreachable"));
        hr = E_FAIL;
    }


    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyReconnectLocalSession
//
// ITSSessionDirectory function. Changes the state of an existing session
// from disconnected to connected.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyReconnectLocalSession(
        TSSD_ReconnectSessionInfo __RPC_FAR *pReconnInfo)
{
    HRESULT hr;
    unsigned long RpcException;

    TRC2((TB,"NotifyReconnectLocalSession, SessionID=%u",
            pReconnInfo->SessionID));

    // Make the RPC call.
    if (EnterSDRpc()) {

        RpcTryExcept {
            // Make the call.
            hr = TSSDRpcSetSessionReconnected(m_hRPCBinding, &m_hCI, 
                    pReconnInfo->SessionID, pReconnInfo->TSProtocol, 
                    pReconnInfo->ResolutionWidth, pReconnInfo->ResolutionHeight,
                    pReconnInfo->ColorDepth);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"NotifyReconn: RPC Exception %d\n", RpcException));
            hr = E_FAIL;
        }
        RpcEndExcept

        if (FAILED(hr)) {
            ERR((TB,"NotifyReconn: RPC call failed, hr=0x%X", hr));
            NotifySDServerDown();
        }

        LeaveSDRpc();
    }
    else {
        ERR((TB,"NotifyReconn: Session directory is unreachable"));
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyReconnectPending
//
// ITSSessionDirectory function. Informs session directory that a reconnect
// is pending soon because of a revectoring.  Used by DIS to determine
// when a server might have gone down.  (DIS is the Directory Integrity
// Service, which runs on the machine with the session directory.)
//
// This is a two-phase procedure--we first check the fields, and then we
// add the timestamp only if there is no outstanding timestamp already (i.e., 
// the two Almost-In-Time fields are 0).  This prevents constant revectoring
// from updating the timestamp fields, which would prevent the DIS from 
// figuring out that a server is down.
//
// These two steps are done in the stored procedure to make the operation
// atomic.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyReconnectPending(
        WCHAR *ServerName)
{
    HRESULT hr;
    unsigned long RpcException;
    FILETIME ft;
    SYSTEMTIME st;
    
    TRC2((TB,"NotifyReconnectPending"));

    ASSERT((ServerName != NULL),(TB,"NotifyReconnectPending: NULL ServerName"));

    // Get the current system time.
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    // Make the RPC call.
    if (EnterSDRpc()) {

        RpcTryExcept {
            // Make the call.
            hr = TSSDRpcSetServerReconnectPending(m_hRPCBinding, ServerName, 
                    ft.dwLowDateTime, ft.dwHighDateTime);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"NotifyReconnPending: RPC Exception %d\n", RpcException));
            hr = E_FAIL;
        }
        RpcEndExcept

        if (FAILED(hr)) {
            ERR((TB,"NotifyReconnPending: RPC call failed, hr=0x%X", hr));
            NotifySDServerDown();
        }

        LeaveSDRpc();
    }
    else {
        ERR((TB,"NotifyReconnPending: Session directory is unreachable"));
        hr = E_FAIL;
    }

    return hr;
}

/****************************************************************************/
// CTSSessionDirectory::Repopulate
//
// This function is called by the recovery thread, and repopulates the session
// directory with all sessions.
//
// Arguments: WinStationCount - # of winstations to repopulate
//   rsi - array of TSSD_RepopulateSessionInfo structs.
//
// Return value: HRESULT
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::Repopulate(DWORD WinStationCount,
        TSSD_RepopulateSessionInfo *rsi)
{
    HRESULT hr = S_OK;
    unsigned long RpcException;

    ASSERT(((rsi != NULL) || (WinStationCount == 0)),(TB,"Repopulate: NULL "
            "rsi!"));

    RpcTryExcept {
        hr = TSSDRpcRepopulateAllSessions(m_hRPCBinding, &m_hCI, 
                WinStationCount, (TSSD_RepopInfo *) rsi);
                
        if (FAILED(hr)) {
            ERR((TB, "Repop: RPC call failed, hr = 0x%X", hr));
        }
    }
    RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
        RpcException = RpcExceptionCode();
        ERR((TB, "Repop: RPC Exception %d\n", RpcException));
        hr = E_FAIL;
    }
    RpcEndExcept

    return hr;

}



/****************************************************************************/
// Plug-in UI interface for TSCC
/****************************************************************************/


/****************************************************************************/
// describes the name of this entry in server settings
/****************************************************************************/
STDMETHODIMP CTSSessionDirectory::GetAttributeName(
        /* out */ WCHAR *pwszAttribName)
{
    TCHAR szAN[256];

    ASSERT((pwszAttribName != NULL),(TB,"NULL attrib ptr"));
    LoadString(g_hInstance, IDS_ATTRIBUTE_NAME, szAN, sizeof(szAN) / 
            sizeof(TCHAR));
    lstrcpy(pwszAttribName, szAN);
    return S_OK;
}


/****************************************************************************/
// for this component the attribute value indicates whether it is enabled
/****************************************************************************/
STDMETHODIMP CTSSessionDirectory::GetDisplayableValueName(
        /* out */WCHAR *pwszAttribValueName)
{
    TCHAR szAvn[256];    

    ASSERT((pwszAttribValueName != NULL),(TB,"NULL attrib ptr"));

	POLICY_TS_MACHINE gpolicy;
    RegGetMachinePolicy(&gpolicy);        

    if (gpolicy.fPolicySessionDirectoryActive)
		m_fEnabled = gpolicy.SessionDirectoryActive;
	else
		m_fEnabled = IsSessionDirectoryEnabled();
    
	if (m_fEnabled)
    {
        LoadString(g_hInstance, IDS_ENABLE, szAvn, sizeof(szAvn) / 
                sizeof(TCHAR));
    }
    else
    {
        LoadString(g_hInstance, IDS_DISABLE, szAvn, sizeof(szAvn) / 
                sizeof(TCHAR));
    }
    lstrcpy(pwszAttribValueName, szAvn);    
    return S_OK;
}


/****************************************************************************/
// Provides custom UI
/****************************************************************************/
STDMETHODIMP CTSSessionDirectory::InvokeUI(/* in */ HWND hParent, /*out*/ 
        PDWORD pdwStatus)
{
    WSADATA wsaData;

    if (WSAStartup(0x202, &wsaData) == 0)
    {
        INT_PTR iRet = DialogBoxParam(g_hInstance,
            MAKEINTRESOURCE(IDD_DIALOG_SDS),
            hParent,
            (DLGPROC)CustomUIDlg,
            (LPARAM)this
           );

        // TRC1((TB,"DialogBox returned 0x%x", iRet));
        // TRC1((TB,"Extended error = %lx", GetLastError()));
        *pdwStatus = (DWORD)iRet;
        WSACleanup();
    }
    else
    {
        *pdwStatus = WSAGetLastError();
        TRC1((TB,"WSAStartup failed with 0x%x", *pdwStatus));
        ErrorMessage(hParent, IDS_ERROR_TEXT3, *pdwStatus);
        return E_FAIL;
    }
    return S_OK;
}


/****************************************************************************/
// Custom menu items -- must be freed by LocalFree
// this is called everytime the user right clicks the listitem
// so you can alter the settings (i.e. enable to disable and vice versa)
/****************************************************************************/
STDMETHODIMP CTSSessionDirectory::GetMenuItems(
        /* out */ int *pcbItems,
        /* out */ PMENUEXTENSION *pMex)
{
    ASSERT((pcbItems != NULL),(TB,"NULL items ptr"));

    *pcbItems = 2;
    *pMex = (PMENUEXTENSION)LocalAlloc(LMEM_FIXED, *pcbItems * 
            sizeof(MENUEXTENSION));
    if (*pMex != NULL)
    {
        LoadString(g_hInstance, IDS_PROPERTIES,  (*pMex)[0].MenuItemName,
                sizeof((*pMex)[0].MenuItemName) / sizeof(WCHAR));
        LoadString(g_hInstance, IDS_DESCRIP_PROPS, (*pMex)[0].StatusBarText,
                sizeof((*pMex)[0].StatusBarText) / sizeof(WCHAR));

        // menu items id -- this id will be passed back to you in ExecMenuCmd
        (*pMex)[0].cmd = IDM_MENU_PROPS;

        // load string to display enable or disable
        if (m_fEnabled)
        {
            LoadString(g_hInstance, IDS_DISABLE, (*pMex)[1].MenuItemName,
                    sizeof((*pMex)[1].MenuItemName) / sizeof(WCHAR));
        }
        else
        {
            LoadString(g_hInstance, IDS_ENABLE, (*pMex)[1].MenuItemName,
                    sizeof((*pMex)[1].MenuItemName) / sizeof(WCHAR));
        }  
        // acquire the description text for menu item
        LoadString(g_hInstance, IDS_DESCRIP_ENABLE, (*pMex)[1].StatusBarText,
                sizeof((*pMex)[1].StatusBarText) / sizeof(WCHAR));

        // menu items id -- this id will be passed back to you in ExecMenuCmd
        (*pMex)[1].cmd = IDM_MENU_ENABLE;

        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


/****************************************************************************/
// When the user selects a menu item the cmd id is passed to this component.
// the provider (which is us)
/****************************************************************************/
STDMETHODIMP CTSSessionDirectory::ExecMenuCmd(
        /* in */ UINT cmd,
        /* in */ HWND hParent,
        /* out*/ PDWORD pdwStatus)
{
    WSADATA wsaData;

    switch (cmd) {
        case IDM_MENU_ENABLE:
            
            m_fEnabled = m_fEnabled ? 0 : 1;
            
            TRC1((TB,"%ws was selected", m_fEnabled ? L"Disable" : L"Enable"));
            
            if (SetSessionDirectoryEnabledState(m_fEnabled) == ERROR_SUCCESS)
            {            
                *pdwStatus = UPDATE_TERMSRV_SESSDIR;
            }            
            break;
        case IDM_MENU_PROPS:
            
            if (WSAStartup(0x202, &wsaData) == 0)
            {
                INT_PTR iRet = DialogBoxParam(g_hInstance,
                    MAKEINTRESOURCE(IDD_DIALOG_SDS),
                    hParent,
                    (DLGPROC)CustomUIDlg,
                    (LPARAM)this);
                *pdwStatus = (DWORD)iRet;

                WSACleanup();
            }
            else
            {
                *pdwStatus = WSAGetLastError();
                TRC1((TB,"WSAStartup failed with 0x%x", *pdwStatus));        
                ErrorMessage(hParent, IDS_ERROR_TEXT3, *pdwStatus);
                return E_FAIL;
            }
    }
    return S_OK;
}


/****************************************************************************/
// Tscc provides a default help menu item,  when selected this method is called
// if we want tscc to handle (or provide) help return any value other than zero
// for those u can't follow logic return zero if you're handling help.
/****************************************************************************/
STDMETHODIMP CTSSessionDirectory::OnHelp(/* out */ int *piRet)
{
    ASSERT((piRet != NULL),(TB,"NULL ret ptr"));
    *piRet = 0;
    return S_OK;
}


/****************************************************************************/
// CheckSessionDirectorySetting returns a bool
/****************************************************************************/
BOOL CTSSessionDirectory::CheckSessionDirectorySetting(WCHAR *Setting)
{
    LONG lRet;
    HKEY hKey;
    DWORD dwEnabled = 0;
    DWORD dwSize = sizeof(DWORD);

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         REG_CONTROL_TSERVER,
                         0,
                         KEY_READ,
                         &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        lRet = RegQueryValueEx(hKey,
                                Setting,
                                NULL,
                                NULL,
                                (LPBYTE)&dwEnabled,
                                &dwSize);
        RegCloseKey(hKey);
    }
    return (BOOL)dwEnabled;
}


/****************************************************************************/
// IsSessionDirectoryEnabled returns a bool
/****************************************************************************/
BOOL CTSSessionDirectory::IsSessionDirectoryEnabled()
{
    return CheckSessionDirectorySetting(REG_TS_SESSDIRACTIVE);
}


/****************************************************************************/
// IsSessionDirectoryEnabled returns a bool
/****************************************************************************/
BOOL CTSSessionDirectory::IsSessionDirectoryExposeServerIPEnabled()
{
    return CheckSessionDirectorySetting(REG_TS_SESSDIR_EXPOSE_SERVER_ADDR);
}


/****************************************************************************/
// SetSessionDirectoryState - sets "Setting" regkey to bVal
/****************************************************************************/
DWORD CTSSessionDirectory::SetSessionDirectoryState(WCHAR *Setting, BOOL bVal)
{
    LONG lRet;
    HKEY hKey;
    DWORD dwSize = sizeof(DWORD);
    
    lRet = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_TSERVER,
                        0,
                        KEY_WRITE,
                        &hKey);
    if (lRet == ERROR_SUCCESS)
    {   
        lRet = RegSetValueEx(hKey,
                              Setting,
                              0,
                              REG_DWORD,
                              (LPBYTE)&bVal,
                              dwSize);
        RegCloseKey(hKey);
    }
    else
    {
        ErrorMessage(NULL, IDS_ERROR_TEXT3, (DWORD)lRet);
    }
    return (DWORD)lRet;
}


/****************************************************************************/
// SetSessionDirectoryEnabledState - sets SessionDirectoryActive regkey to bVal
/****************************************************************************/
DWORD CTSSessionDirectory::SetSessionDirectoryEnabledState(BOOL bVal)
{
    return SetSessionDirectoryState(REG_TS_SESSDIRACTIVE, bVal);
}


/****************************************************************************/
// SetSessionDirectoryExposeIPState - sets SessionDirectoryExposeServerIP 
// regkey to bVal
/****************************************************************************/
DWORD CTSSessionDirectory::SetSessionDirectoryExposeIPState(BOOL bVal)
{
    return SetSessionDirectoryState(REG_TS_SESSDIR_EXPOSE_SERVER_ADDR, bVal);
}


/****************************************************************************/
// ErrorMessage --
/****************************************************************************/
void CTSSessionDirectory::ErrorMessage(HWND hwnd, UINT res, DWORD dwStatus)
{
    TCHAR tchTitle[64];
    TCHAR tchText[64];
    TCHAR tchErrorMessage[256];
    LPTSTR pBuffer = NULL;
    
    // report error
    ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,                                   //ignored
            (DWORD)dwStatus,                        //message ID
            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),  //message language
            (LPTSTR)&pBuffer,                       //address of buffer pointer
            0,                                      //minimum buffer size
            NULL);  
    
    LoadString(g_hInstance, IDS_ERROR_TITLE, tchTitle, sizeof(tchTitle) / 
            sizeof(TCHAR));
    LoadString(g_hInstance, res, tchText, sizeof(tchText) / sizeof(TCHAR));
    wsprintf(tchErrorMessage, tchText, pBuffer);
    ::MessageBox(hwnd, tchErrorMessage, tchTitle, MB_OK | MB_ICONINFORMATION);
}


/****************************************************************************/
// CTSSessionDirectory::RecoveryThread
//
// Static helper function.  The SDPtr passed in is a pointer to this for
// when _beginthreadex is called during init.  RecoveryThread simply calls
// the real recovery function, which is RecoveryThreadEx.
/****************************************************************************/
unsigned __stdcall CTSSessionDirectory::RecoveryThread(void *SDPtr) {

    ((CTSSessionDirectory *)SDPtr)->RecoveryThreadEx();

    return 0;
}


/****************************************************************************/
// CTSSessionDirectory::RecoveryThreadEx
//
// Recovery thread for tssdjet recovery.  Sits around and waits for the
// server to go down.  When the server fails, it wakes up, sets a variable
// indicating that the server is unreachable, and then tries to reestablish
// a connection with the server.  Meanwhile, further calls to the session
// directory simply fail without delay.
//
// When the session directory finally comes back up, the recovery thread
// temporarily halts session directory updates while repopulating the database.
// If all goes well, it cleans up and goes back to sleep.  If all doesn't go
// well, it tries again.
//
// The recovery thread terminates if it fails a wait, or if m_hTerminateRecovery
// is set.
/****************************************************************************/
VOID CTSSessionDirectory::RecoveryThreadEx()
{
    DWORD err;
    BOOL bErr;
    CONST HANDLE lpHandles[] = { m_hSDServerDown, m_hTerminateRecovery };
    
    for ( ; ; ) {
        // Wait forever until there is a problem with the session directory,
        // or until we are told to shut down.
        err = WaitForMultipleObjects(2, lpHandles, FALSE, INFINITE);

        switch (err) {
            case WAIT_OBJECT_0: // m_hSDServerDown
                // SD Server Down--go through recovery.
                break;
            case WAIT_OBJECT_0 + 1: // m_hTerminateRecovery
                // We're quitting.
                return;
            default:
                // This is unexpected.  Assert on checked builds.  On free,
                // just return.
                ASSERT(((err == WAIT_OBJECT_0) || (err == WAIT_OBJECT_0 + 1)),
                        (TB, "RecoveryThreadEx: Unexpected value from Wait!"));
                return;
        }

        // Wait for all pending SD Rpcs to complete, and make all further
        // EnterSDRpc's return FALSE until we're back up.  Note that if there
        // is a failure in recovery that this can be called more than once.
        DisableSDRpcs();

        // This function loops and tries to reestablish a connection with the
        // session directory.  When it thinks it has one, it returns.
        // If it returns nonzero, though, that means it was terminated or
        // an error occurred in the wait, so terminate recovery.
        if (ReestablishSessionDirectoryConnection() != 0)
            return;

        // Now we have (theoretically) a session directory connection.
        // Update the session directory.  Nonzero on failure.
        err = RequestSessDirUpdate();

        if (err != 0) {
            // Keep trying, so serverdown event stays signaled.
            continue;
        }

        // Everything is good now.  Clean up and wait for the next failure.
        bErr = ResetEvent(m_hSDServerDown);
        EnableSDRpcs();
    }
}


/****************************************************************************/
// StartupSD
//
// Initiates a connection by signaling to the recovery thread that the server
// is down.
/****************************************************************************/
void CTSSessionDirectory::StartupSD()
{
    if (SetEvent(m_hSDServerDown) == FALSE) {
        ERR((TB, "StartupSD: SetEvent failed.  GetLastError=%d",
                GetLastError()));
    }
}


/****************************************************************************/
// NotifySDServerDown
//
// Tells the recovery thread that the server is down.
/****************************************************************************/
void CTSSessionDirectory::NotifySDServerDown()
{
    if (SetEvent(m_hSDServerDown) == FALSE) {
        ERR((TB, "NotifySDServerDown: SetEvent failed.  GetLastError=%d",
                GetLastError()));
    }
}


/****************************************************************************/
// EnterSDRpc
//
// This function returns whether it is OK to make an RPC right now.  It handles
// not letting anyone make an RPC call if RPCs are disabled, and also, if anyone
// is able to make an RPC, it ensures they will be able to do so until they call
// LeaveSDRpc.
//
// Return value:
//  true - if OK to make RPC call, in which case you must call LeaveSDRpc when
//   you are done.
//  false - if not OK.  You must not call LeaveSDRpc.
//  
/****************************************************************************/
boolean CTSSessionDirectory::EnterSDRpc()
{
    AcquireResourceShared(&m_sr);

    if (m_SDIsUp) {
        return TRUE;
    }
    else {
        ReleaseResourceShared(&m_sr);
        return FALSE;
    }
    
}


/****************************************************************************/
// LeaveSDRpc
//
// If you were able to EnterSDRpc (i.e., it returned true), you must call this 
// function when you are done with your Rpc call no matter what happened.
/****************************************************************************/
void CTSSessionDirectory::LeaveSDRpc()
{
    ReleaseResourceShared(&m_sr);
}


/****************************************************************************/
// DisableSDRpcs
//
// Prevent new EnterSDRpcs from returning true, and then wait for all pending
// EnterSDRpcs to be matched by their LeaveSDRpc's.
/****************************************************************************/
void CTSSessionDirectory::DisableSDRpcs()
{

    //
    // First, set the flag that the SD is up to FALSE, preventing further Rpcs.
    // Then, we grab the resource exclusive and release it right afterwards--
    // this forces us to wait until all RPCs we're already in have completed.
    //

    (void) InterlockedExchange(&m_SDIsUp, FALSE);

    AcquireResourceExclusive(&m_sr);
    ReleaseResourceExclusive(&m_sr);
}


/****************************************************************************/
// EnableSDRpcs
//
// Enable EnterSDRpcs to return true once again.
/****************************************************************************/
void CTSSessionDirectory::EnableSDRpcs()
{
    ASSERT((VerifyNoSharedAccess(&m_sr)),(TB,"EnableSDRpcs called but "
            "shouldn't be when there are shared readers."));

    (void) InterlockedExchange(&m_SDIsUp, TRUE);
}



/****************************************************************************/
// RequestSessDirUpdate
//
// Requests that termsrv update the session directory using the batchupdate
// interface.
//
// This function needs to know whether the update succeeded and return 0 on
// success, nonzero on failure.
/****************************************************************************/
DWORD CTSSessionDirectory::RequestSessDirUpdate()
{
    return (*m_repopfn)();
}


/****************************************************************************/
// ReestablishSessionDirectoryConnection
//
// This function loops and tries to reestablish a connection with the
// session directory.  When it has one, it returns.
//
// Return value: 0 if normal exit, nonzero if terminated by TerminateRecovery
// event.
/****************************************************************************/
DWORD CTSSessionDirectory::ReestablishSessionDirectoryConnection()
{
    HRESULT hr;
    unsigned long RpcException;
    DWORD err;

    
    for ( ; ; ) {
        // Execute ServerOnline.
        RpcTryExcept {
            hr = TSSDRpcServerOnline(m_hRPCBinding, m_ClusterName, &m_hCI, 
                    m_Flags);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            m_hCI = NULL;
            RpcException = RpcExceptionCode();
            hr = E_FAIL;
        }
        RpcEndExcept
            
        if (SUCCEEDED(hr)) {
            RpcTryExcept {
                hr = TSSDRpcUpdateConfigurationSetting(m_hRPCBinding, &m_hCI, 
                        SDCONFIG_SERVER_ADDRESS, 
                        (DWORD) (wcslen(m_LocalServerAddress) + 1) * 
                        sizeof(WCHAR), (PBYTE) m_LocalServerAddress);
            }
            RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
                m_hCI = NULL;
                RpcException = RpcExceptionCode();
                hr = E_FAIL;
            }
            RpcEndExcept

            if (SUCCEEDED(hr))
                return 0;
        }

        err = WaitForSingleObject(m_hTerminateRecovery, m_RecoveryTimeout);
        if (err != WAIT_TIMEOUT) {
            // It was not a timeout, it better be our terminate recovery event.
            ASSERT((err == WAIT_OBJECT_0),(TB, "ReestSessDirConn: Unexpected "
                    "value returned from wait"));

            // If it was not our event, we want to keep going through
            // this loop so this thread does not terminate.
            if (err == WAIT_OBJECT_0)
                return 1;
        }
    }

}


/****************************************************************************/
// CTSSessionDirectory::Terminate
//
// Helper function called by the destructor and by Update when switching to
// another server.  Frees RPC binding, events, and recovery thread.
/****************************************************************************/
void CTSSessionDirectory::Terminate()
{
    HRESULT rc = S_OK;
    unsigned long RpcException;
    BOOL ConnectionMaybeUp;

    // Terminate recovery.
    if (m_hRecoveryThread != NULL) {
        SetEvent(m_hTerminateRecovery);
        WaitForSingleObject((HANDLE) m_hRecoveryThread, INFINITE);
        m_hRecoveryThread = NULL;
    }

    ConnectionMaybeUp = EnterSDRpc();
    if (ConnectionMaybeUp)
        LeaveSDRpc();

    // Wait for current Rpcs to complete (if any), disable new ones.
    DisableSDRpcs();

    // If we think there is a connection, disconnect it.
    if (ConnectionMaybeUp) {
        RpcTryExcept {
            rc = TSSDRpcServerOffline(m_hRPCBinding, &m_hCI);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"Term: RPC Exception %d\n", RpcException));
            rc = E_FAIL;
        }
        RpcEndExcept

        if (FAILED(rc)) {
            ERR((TB,"Term: SvrOffline failed, lasterr=0x%X", GetLastError()));
        }
    }


    // Clean up.
    if (m_hRPCBinding != NULL) {
        RpcBindingFree(&m_hRPCBinding);
        m_hRPCBinding = NULL;
    }

    if (m_hSDServerDown != NULL) {
        CloseHandle(m_hSDServerDown);
        m_hSDServerDown = NULL;
    }
    
    if (m_hTerminateRecovery != NULL) {
        CloseHandle(m_hTerminateRecovery);
        m_hTerminateRecovery = NULL;
    }

    if (m_sr.Valid == TRUE) {
        
        // We clean up only in the destructor, because we may initialize again.
        // On check builds verify that no one is currently accessing.

        ASSERT((VerifyNoSharedAccess(&m_sr)), (TB, "Terminate: Shared readers"
                " exist!"));
    }

}


/****************************************************************************/
// CTSSessionDirectory::GetLoadBalanceInfo
//
// Based on the server address, generate load balance info to send to the client
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::GetLoadBalanceInfo(
        LPWSTR ServerAddress, 
        BSTR* LBInfo)        
{
    HRESULT hr = S_OK;
    
    // This is for test only
    //WCHAR lbInfo[MAX_PATH];
    //wcscpy(lbInfo, L"load balance info");

    *LBInfo = NULL;
    
    TRC2((TB,"GetLoadBalanceInfo"));

    if (ServerAddress) {
        //
        // "Cookie: msts=4294967295.65535.0000" + CR + LF + NULL, on 8-byte
        // boundary is 40 bytes.
        //
        // The format of the cookie for F5 is, for an IP of 1.2.3.4
        // using port 3389, Cookie: msts=67305985.15629.0000 + CR + LF + NULL.
        //
        #define TEMPLATE_STRING_LENGTH 40
        #define SERVER_ADDRESS_LENGTH 64
        
        char CookieTemplate[TEMPLATE_STRING_LENGTH];
        char AnsiServerAddress[SERVER_ADDRESS_LENGTH];
        
        unsigned long NumericalServerAddr = 0;
        int retval;

        // Compute integer for the server address.
        // First, get ServerAddress as an ANSI string.
        retval = WideCharToMultiByte(CP_ACP, 0, ServerAddress, -1, 
                AnsiServerAddress, SERVER_ADDRESS_LENGTH, NULL, NULL);

        if (retval == 0) {
            TRC2((TB, "GetLoadBalanceInfo WideCharToMB failed %d", 
                    GetLastError()));
            return E_INVALIDARG;
        }

        // Now, use inet_addr to turn into an unsigned long.
        NumericalServerAddr = inet_addr(AnsiServerAddress);

        if (NumericalServerAddr == INADDR_NONE) {
            TRC2((TB, "GetLoadBalanceInfo inet_addr failed"));
            return E_INVALIDARG;
        }

        // Compute the total cookie string.  0x3d0d is 3389 in correct byte
        // order.  We need to change this to whatever the port number has been
        // configured to.
        sprintf(CookieTemplate, "Cookie: msts=%u.%u.0000\r\n",
                NumericalServerAddr, 0x3d0d);

        // Generate returned BSTR.
        *LBInfo = SysAllocStringByteLen((LPCSTR)CookieTemplate, 
                (UINT) strlen(CookieTemplate));
        
        if (*LBInfo) {
            TRC2((TB,"GetLoadBalanceInfo: okay"));
            hr = S_OK;
        }
        else {
            TRC2((TB,"GetLoadBalanceInfo: failed"));
            hr = E_OUTOFMEMORY;
        }
    }
    else {
        TRC2((TB,"GetLoadBalanceInfo: failed"));
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************************************/
// IsServerNameValid
//
// This function tries to ping the server name to determine if its a valid 
// entry
//
// Return value: FALSE if we cannot ping.
// event.
/****************************************************************************/
BOOL IsServerNameValid(wchar_t * pwszName)
{
    HCURSOR hCursor = NULL;
    long inaddr;
    char szAnsiServerName[256];
    struct hostent *hostp = NULL;
    BOOL bRet;
    if (pwszName == NULL || pwszName[0] == '\0')
    {
        bRet = FALSE;
    }   
    else
    {
        hCursor = SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
        // some winsock apis does accept wides.
        WideCharToMultiByte(CP_ACP,
            0,
            pwszName,
            -1,
            szAnsiServerName, 
            sizeof(szAnsiServerName),
            NULL, 
            NULL);
        // check ip format return true do a dns lookup.
        if ((inaddr = inet_addr(szAnsiServerName)) == INADDR_NONE)
        {
            hostp = gethostbyname(szAnsiServerName);
            if (hostp != NULL)
            {
                bRet = TRUE;
            }
            else
            {
                // Neither dotted, not name.
                bRet = FALSE;
            }
        }
        else
        {
            // Is dotted.
            bRet = TRUE;        
        }

        SetCursor(hCursor);

    }
    return bRet;
}



BOOL OnHelp(HWND hwnd, LPHELPINFO lphi)
{
    UNREFERENCED_PARAMETER(hwnd);

    TCHAR tchHelpFile[MAX_PATH];

    //
    // For the information to winhelp api
    //

    if (IsBadReadPtr(lphi, sizeof(HELPINFO)))
    {
        return FALSE;
    }

    if (lphi->iCtrlId <= -1)
    {
        return FALSE;
    }

    LoadString(g_hInstance, IDS_HELPFILE, tchHelpFile, 
                sizeof (tchHelpFile) / sizeof(TCHAR));

    ULONG_PTR rgdw[2];

    rgdw[0] = (ULONG_PTR)lphi->iCtrlId;

    rgdw[1] = (ULONG_PTR)lphi->dwContextId;

    WinHelp((HWND) lphi->hItemHandle, tchHelpFile, HELP_WM_HELP, 
            (ULONG_PTR) &rgdw);
    
    return TRUE;
}

/****************************************************************************/
// Custom UI msg handler dealt with here
/****************************************************************************/
INT_PTR CALLBACK CustomUIDlg(HWND hwnd, UINT umsg, WPARAM wp, LPARAM lp)
{
    static BOOL s_fServerNameChanged;
    static BOOL s_fClusterNameChanged;
    static BOOL s_fPreviousButtonState;
    static BOOL s_fPreviousExposeIPState;
    
    CTSSessionDirectory *pCTssd;
    
    POLICY_TS_MACHINE gpolicy;
    
    switch(umsg)
    {
    case WM_INITDIALOG:
        {
            BOOL bEnable = FALSE;
            BOOL bExposeIP = FALSE;
            
            pCTssd = (CTSSessionDirectory *)lp;
            
            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pCTssd);
            
            SendMessage(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME),
                EM_LIMITTEXT,
                (WPARAM)64,
                0);
            SendMessage(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME),
                EM_LIMITTEXT,
                (WPARAM)64,
                0);
            SendMessage(GetDlgItem(hwnd, IDC_EDIT_ACCOUNTNAME),
                EM_LIMITTEXT,
                (WPARAM)64,
                0);
            SendMessage(GetDlgItem(hwnd, IDC_EDIT_PASSWORD),
                EM_LIMITTEXT,
                (WPARAM)64,
                0);
            
            HICON hIcon;
            
            hIcon = (HICON)LoadImage(
                g_hInstance,
                MAKEINTRESOURCE(IDI_SMALLWARN),
                IMAGE_ICON,
                0,
                0,
                0);
            // TRC1((TB, "CustomUIDlg - LoadImage returned 0x%p",hIcon));
            SendMessage(
                GetDlgItem(hwnd, IDC_WARNING_ICON),
                STM_SETICON,
                (WPARAM)hIcon,
                (LPARAM)0
               );
            
            LONG lRet;
            HKEY hKey;
            DWORD cbData = 256;
            TCHAR szString[256];    
            
            RegGetMachinePolicy(&gpolicy);        
            
            lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                REG_TS_CLUSTERSETTINGS,
                0,
                KEY_READ | KEY_WRITE, 
                &hKey);
            if (lRet == ERROR_SUCCESS)
            {               
                lRet = RegQueryValueEx(hKey,
                    REG_TS_CLUSTER_STORESERVERNAME,
                    NULL, 
                    NULL,
                    (LPBYTE)szString, 
                    &cbData);
                if (lRet == ERROR_SUCCESS)
                {
                    SetWindowText(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), 
                            szString);
                }
                
                cbData = 256;
                
                lRet = RegQueryValueEx(hKey,
                    REG_TS_CLUSTER_CLUSTERNAME,
                    NULL,
                    NULL,
                    (LPBYTE)szString,
                    &cbData);           
                if (lRet == ERROR_SUCCESS)
                {
                    SetWindowText(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), 
                            szString);
                }
                RegCloseKey(hKey);
            }
            else
            {
                if (pCTssd != NULL)
                {
                    pCTssd->ErrorMessage(hwnd, IDS_ERROR_TEXT, (DWORD)lRet);
                }
                EndDialog(hwnd, lRet);                
            }        
            
            
            if (gpolicy.fPolicySessionDirectoryActive)
            {
                bEnable = gpolicy.SessionDirectoryActive;
                EnableWindow(GetDlgItem(hwnd, IDC_CHECK_ENABLE), FALSE);
            }
            else
            {
                if (pCTssd != NULL)
                    bEnable = pCTssd->IsSessionDirectoryEnabled();
            }
            
            s_fPreviousButtonState = bEnable;
            CheckDlgButton(hwnd, IDC_CHECK_ENABLE, bEnable);

            if (gpolicy.fPolicySessionDirectoryLocation)
            {                    
                SetWindowText(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), 
                        gpolicy.SessionDirectoryLocation);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_STORENAME), FALSE);
            }                
            else
            {
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_STORENAME), bEnable);
            }
            
            if (gpolicy.fPolicySessionDirectoryClusterName != 0)
            {                    
                SetWindowText(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), 
                        gpolicy.SessionDirectoryClusterName);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_CLUSTERNAME),FALSE);
            }
            else
            {
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_CLUSTERNAME),bEnable);
            }

            if (gpolicy.fPolicySessionDirectoryExposeServerIP != 0)
            {
                CheckDlgButton(hwnd, IDC_CHECK_EXPOSEIP, TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_CHECK_EXPOSEIP), FALSE);
                s_fPreviousExposeIPState = TRUE;
            }
            else
            {
                if (pCTssd != NULL)
                {
                    bExposeIP = 
                            pCTssd->IsSessionDirectoryExposeServerIPEnabled();
                }
                CheckDlgButton(hwnd, IDC_CHECK_EXPOSEIP, bExposeIP ? 
                        BST_CHECKED : BST_UNCHECKED);
                EnableWindow(GetDlgItem(hwnd, IDC_CHECK_EXPOSEIP), bEnable);

                s_fPreviousExposeIPState = bExposeIP;
            }

            s_fServerNameChanged = FALSE;
            s_fClusterNameChanged = FALSE;
        }
        break;
    
        case WM_HELP:
            OnHelp(hwnd, (LPHELPINFO)lp);
            break;
        
        case WM_COMMAND:
            if (LOWORD(wp) == IDCANCEL)
            {                
                EndDialog(hwnd, 0);
            }
            else if (LOWORD(wp) == IDOK)
            {
                BOOL bEnabled;
                BOOL bExposeIP;
                DWORD dwRetStatus = 0;
                
                pCTssd = (CTSSessionDirectory *) GetWindowLongPtr(hwnd, 
                        DWLP_USER);
                
                bEnabled = (IsDlgButtonChecked(hwnd, IDC_CHECK_ENABLE) == 
                        BST_CHECKED);
                bExposeIP = (IsDlgButtonChecked(hwnd, IDC_CHECK_EXPOSEIP) ==
                        BST_CHECKED);
                
                if (bEnabled != s_fPreviousButtonState)
                {
                    DWORD dwStatus;
                    
                    dwStatus = pCTssd->SetSessionDirectoryEnabledState(
                            bEnabled);
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        return 0;
                    }
                    dwRetStatus = UPDATE_TERMSRV_SESSDIR;
                }
                if (bExposeIP != s_fPreviousExposeIPState)
                {
                    DWORD dwStatus;

                    dwStatus = pCTssd->SetSessionDirectoryExposeIPState(
                            bExposeIP);
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        return 0;
                    }
                    dwRetStatus = UPDATE_TERMSRV_SESSDIR;
                }    
                if (s_fServerNameChanged || s_fClusterNameChanged)
                {
                    HKEY hKey;
                    LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        REG_TS_CLUSTERSETTINGS,
                        0,
                        KEY_READ | KEY_WRITE, 
                        &hKey);
                    
                    if (lRet == ERROR_SUCCESS)
                    {
                        TCHAR szName[64];
                        
                        if (s_fServerNameChanged)
                        {
                            if (GetWindowText(GetDlgItem(hwnd, 
                                    IDC_EDIT_SERVERNAME), szName, 
                                    sizeof(szName) / sizeof(TCHAR)) != 0)
                            {
                                if (!IsServerNameValid(szName))
                                {
                                    int nRet;
                                    TCHAR szError[256];
                                    TCHAR szTitle[80];
                                    
                                    TRC1((TB,"Server name was not valid"));
                                    LoadString(g_hInstance,
                                        IDS_ERROR_SDIRLOC,
                                        szError,
                                        sizeof(szError)/sizeof(TCHAR));
                                    
                                    LoadString(g_hInstance,
                                        IDS_ERROR_TITLE,
                                        szTitle,
                                        sizeof(szTitle)/sizeof(TCHAR));
                                    
                                    nRet = MessageBox(hwnd, szError, szTitle, 
                                            MB_YESNO | MB_ICONWARNING);
                                    if (nRet == IDNO)
                                    {
                                        SetFocus(GetDlgItem(hwnd, 
                                                IDC_EDIT_SERVERNAME));
                                        return 0;
                                    }
                                }                                
                            }
                            else {
                                // Blank name not allowed if session directory
                                // is enabled.  This code will not be run if the
                                // checkbox is disabled because when it is
                                // disabled the static flags get set to 
                                // disabled.
                                TCHAR szError[256];
                                TCHAR szTitle[80];

                                LoadString(g_hInstance, IDS_ERROR_TITLE,
                                        szTitle, sizeof(szTitle) / 
                                        sizeof(TCHAR));
                                LoadString(g_hInstance, IDS_ERROR_SDIREMPTY,
                                        szError, sizeof(szError) / 
                                        sizeof(TCHAR));

                                MessageBox(hwnd, szError, szTitle, 
                                        MB_OK | MB_ICONWARNING);

                                SetFocus(GetDlgItem(hwnd, 
                                        IDC_EDIT_SERVERNAME));

                                return 0;
                            }
                            RegSetValueEx(hKey,
                                REG_TS_CLUSTER_STORESERVERNAME,
                                0,
                                REG_SZ,
                                (CONST LPBYTE) szName,
                                sizeof(szName) - sizeof(TCHAR));
                        }
                        if (s_fClusterNameChanged)
                        {
                            
                            GetWindowText(GetDlgItem(hwnd, 
                                IDC_EDIT_CLUSTERNAME), szName, 
                                sizeof(szName) / sizeof(TCHAR));
                            RegSetValueEx(hKey,
                                REG_TS_CLUSTER_CLUSTERNAME,
                                0,
                                REG_SZ,
                                (CONST LPBYTE) szName,
                                sizeof(szName) - sizeof(TCHAR));
                        }
                        RegCloseKey(hKey);
                    }
                    else
                    {
                        pCTssd->ErrorMessage(hwnd, IDS_ERROR_TEXT2, 
                                (DWORD) lRet);
                        return 0;
                    }
                    dwRetStatus = UPDATE_TERMSRV_SESSDIR;
                }                
                EndDialog(hwnd, dwRetStatus);
            }
            else
            {
                switch(HIWORD(wp))
                {            
                case EN_CHANGE:
                    if (LOWORD(wp) == IDC_EDIT_SERVERNAME)
                    {
                        s_fServerNameChanged = TRUE;
                    }
                    else if (LOWORD(wp) == IDC_EDIT_CLUSTERNAME)
                    {
                        s_fClusterNameChanged = TRUE;
                    }
                    break;
                case BN_CLICKED:
                    if (LOWORD(wp) == IDC_CHECK_ENABLE)
                    {
                        BOOL bEnable;
                        
                        bEnable = (IsDlgButtonChecked(hwnd, IDC_CHECK_ENABLE) ==
                                BST_CHECKED ? TRUE : FALSE);
                        // set flags 
                        s_fServerNameChanged = bEnable;
                        s_fClusterNameChanged = bEnable;
                        
				        RegGetMachinePolicy(&gpolicy);        
	
						if (gpolicy.fPolicySessionDirectoryLocation)
						{                    
							EnableWindow(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), FALSE);
							EnableWindow(GetDlgItem(hwnd, IDC_STATIC_STORENAME), FALSE);
						}                
						else
						{
							EnableWindow(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), bEnable);
							EnableWindow(GetDlgItem(hwnd, IDC_STATIC_STORENAME), bEnable);
						}
            
						if (gpolicy.fPolicySessionDirectoryClusterName)
						{                    
							EnableWindow(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), FALSE);
							EnableWindow(GetDlgItem(hwnd, IDC_STATIC_CLUSTERNAME),FALSE);
						}
						else
						{
							EnableWindow(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), bEnable);
							EnableWindow(GetDlgItem(hwnd, IDC_STATIC_CLUSTERNAME),bEnable);
						}

                        EnableWindow(GetDlgItem(hwnd, IDC_CHECK_EXPOSEIP),
                                bEnable);
                        
                    }
                    break;
                }
            }   
            break;
    }
    return 0;
}


#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdsql\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sds.rc
//
#define IDD_DIALOG_SDS                  101
#define IDC_CHECK_ENABLE                1000
#define IDC_EDIT_SERVERNAME             1001
#define IDC_EDIT_CLUSTERNAME            1002
#define IDS_DISABLE                     1004
#define IDS_ENABLE                      1005
#define IDS_ATTRIBUTE_NAME              1006
#define IDS_PROPERTIES                  1007
#define IDS_DESCRIP_ENABLE              1008
#define IDS_DESCRIP_PROPS               1010
#define IDC_EDIT_ACCOUNTNAME            1011
#define IDC_EDIT_PASSWORD               1012
#define IDC_STATIC_SQLNAME              1013
#define IDC_STATIC_CLUSTERNAME          1014
#define IDC_STATIC_SQLACCOUNT           1015
#define IDC_STATIC_SQLPWD               1016
#define IDS_ERROR_TITLE                 1017
#define IDS_ERROR_TEXT                  1018
#define IDS_ERROR_TEXT2                 1019
#define IDS_ERROR_TEXT3                 1020
#define IDM_MENU_ENABLE                 2000
#define IDM_MENU_PROPS                  2001
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1021
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\comp\tscomprc.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ftcomprc.h

Abstract:

    Resource ids definitions for tscomp.rc

Author:

    Makarand Patwardhan (cristiat)  6-July-2000

Notes:

Revision History:

--*/

#define TSCOMP_STR_ABORT_DESCRIPTION 1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdsql\tssdsql.cpp ===
/****************************************************************************/
// tssdsql.cpp
//
// Terminal Server Session Directory Interface common component code.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <process.h>

#include <ole2.h>
#include <objbase.h>
#include <comdef.h>
#include <adoid.h>
#include <adoint.h>
#include <regapi.h>
#include "tssdsql.h"
#include "trace.h"
#include "resource.h"


/****************************************************************************/
// Types
/****************************************************************************/

// Shortcut VARIANT class to handle cleanup on destruction and common code
// inlining.
class CVar : public VARIANT
{
public:
    CVar() { VariantInit(this); }
    CVar(VARTYPE vt, SCODE scode = 0) {
        VariantInit(this);
        this->vt = vt;
        this->scode = scode;
    }
    CVar(VARIANT var) { *this = var; }
    ~CVar() { VariantClear(this); }

    void InitNull() { this->vt = VT_NULL; }
    void InitFromLong(long L) { this->vt = VT_I4; this->lVal = L; }
    void InitNoParam() {
        this->vt = VT_ERROR;
        this->lVal = DISP_E_PARAMNOTFOUND;
    }

    HRESULT InitFromWSTR(PCWSTR WStr) {
        this->bstrVal = SysAllocString(WStr);
        if (this->bstrVal != NULL) {
            this->vt = VT_BSTR;
            return S_OK;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    // Inits from a non-NULL-terminated set of WCHARs.
    HRESULT InitFromWChars(WCHAR *WChars, unsigned Len) {
        this->bstrVal = SysAllocStringLen(WChars, Len);
        if (this->bstrVal != NULL) {
            this->vt = VT_BSTR;
            return S_OK;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    HRESULT InitEmptyBSTR(unsigned Size) {
        this->bstrVal = SysAllocStringLen(L"", Size);
        if (this->bstrVal != NULL) {
            this->vt = VT_BSTR;
            return S_OK;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    HRESULT Clear() { return VariantClear(this); }
};


/****************************************************************************/
// Prototypes
/****************************************************************************/
INT_PTR CALLBACK CustomUIDlg(HWND, UINT, WPARAM, LPARAM);
void FindSqlValue(LPTSTR, LPTSTR, LPTSTR);
LPTSTR ModifySqlValue( LPTSTR * , LPTSTR , LPTSTR );
LPTSTR FindField( LPTSTR pszString , LPTSTR pszKeyName );
VOID strtrim( TCHAR **pszStr);

/****************************************************************************/
// Globals
/****************************************************************************/
extern HINSTANCE g_hInstance;

// The COM object counter (declared in server.cpp)
extern long g_lObjects;


/****************************************************************************/
// CTSSessionDirectory::CTSSessionDirectory
// CTSSessionDirectory::~CTSSessionDirectory
//
// Constructor and destructor
/****************************************************************************/
CTSSessionDirectory::CTSSessionDirectory() :
        m_RefCount(0), m_pConnection(NULL)
{
    InterlockedIncrement(&g_lObjects);

    m_LocalServerAddress[0] = L'\0';
    m_DBConnectStr = NULL;
    m_DBPwdStr = NULL;
    m_DBUserStr = NULL;
    m_fEnabled = 0;

    m_pszOpaqueString = NULL;
    
}

CTSSessionDirectory::~CTSSessionDirectory()
{
    HRESULT hr;

    // If the database connection exists, release it.
    if (m_pConnection != NULL) {
        hr = ExecServerOffline();
        if (FAILED(hr)) {
            ERR((TB,"Destr: ExecSvrOffline failed, hr=0x%X", hr));
        }
        hr = m_pConnection->Close();
        if (FAILED(hr)) {
            ERR((TB,"pConn->Close() failed, hr=0x%X", hr));
        }
        m_pConnection->Release();
        m_pConnection = NULL;
    }

    // Decrement the global COM object counter
    InterlockedDecrement(&g_lObjects);

    if (m_DBConnectStr != NULL)
        SysFreeString(m_DBConnectStr);
    if (m_DBPwdStr != NULL)
        SysFreeString(m_DBPwdStr);
    if (m_DBUserStr != NULL)
        SysFreeString(m_DBUserStr);
}


/****************************************************************************/
// CTSSessionDirectory::QueryInterface
//
// Standard COM IUnknown function.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::QueryInterface(
        REFIID riid,
        void **ppv)
{
    if (riid == IID_IUnknown) {
        *ppv = (LPVOID)(IUnknown *)(ITSSessionDirectory *)this;
    }
    else if (riid == IID_ITSSessionDirectory) {
        *ppv = (LPVOID)(ITSSessionDirectory *)this;
    }
    else if (riid == IID_IExtendServerSettings) {
        *ppv = (LPVOID)(IExtendServerSettings *)this;
    }
    else {
        ERR((TB,"QI: Unknown interface"));
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


/****************************************************************************/
// CTSSessionDirectory::AddRef
//
// Standard COM IUnknown function.
/****************************************************************************/
ULONG STDMETHODCALLTYPE CTSSessionDirectory::AddRef()
{
    return InterlockedIncrement(&m_RefCount);
}


/****************************************************************************/
// CTSSessionDirectory::Release
//
// Standard COM IUnknown function.
/****************************************************************************/
ULONG STDMETHODCALLTYPE CTSSessionDirectory::Release()
{
    long lRef = InterlockedDecrement(&m_RefCount);

    if (lRef == 0)
        delete this;
    return lRef;
}


/****************************************************************************/
// CTSSessionDirectory::Initialize
//
// ITSSessionDirectory function. Called soon after object instantiation to
// intiialize the directory. LocalServerAddress provides a text representation
// of the local server's load balance IP address. This information should be
// used as the server IP address in the session directory for client
// redirection by other pool servers to this server. StoreServerName,
// ClusterName, and OpaqueSettings are generic reg entries known to TermSrv
// which cover config info across any type of session directory
// implementation. The contents of these strings are designed to be parsed
// by the session directory providers.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::Initialize(
        LPWSTR LocalServerAddress,
        LPWSTR StoreServerName,
        LPWSTR ClusterName,
        LPWSTR OpaqueSettings,
        DWORD Flags,
        DWORD (*repopfn)())
{
    HRESULT hr = S_OK;
    unsigned Len;
    WCHAR *pSearch;
    WCHAR ConnectString[384];

    ASSERT((LocalServerAddress != NULL),(TB,"Init: LocalServerAddr null!"));
    ASSERT((StoreServerName != NULL),(TB,"Init: StoreServerName null!"));
    ASSERT((ClusterName != NULL),(TB,"Init: ClusterName null!"));
    ASSERT((OpaqueSettings != NULL),(TB,"Init: OpaqueSettings null!"));

    // Copy off the server address and cluster name for later use.
    wcsncpy(m_LocalServerAddress, LocalServerAddress,
            sizeof(m_LocalServerAddress) / sizeof(WCHAR) - 1);
    m_LocalServerAddress[sizeof(m_LocalServerAddress) / sizeof(WCHAR) - 1] =
            L'\0';
    wcsncpy(m_ClusterName, ClusterName,
            sizeof(m_ClusterName) / sizeof(WCHAR) - 1);
    m_ClusterName[sizeof(m_ClusterName) / sizeof(WCHAR) - 1] = L'\0';

    // Create the SQL connect string using the OpaqueSettings string
    // (which should contain some of the conn str including SQL security
    // username and password, sub-table names, provider type, etc.).
    // We add onto the end a semicolon (if not already present) and the
    // data source (from StoreServerName), if the "data source" substring
    // is not already in the connect string.
    pSearch = OpaqueSettings;
    while (*pSearch != L'\0') {
        if (*pSearch == L'D' || *pSearch == L'd') {
            if (!_wcsnicmp(pSearch, L"data source", wcslen(L"data source"))) {
                // Transfer the OpaqueSettings string as a whole to become
                // the connect str.
                wcscpy(ConnectString, OpaqueSettings);
                goto PostConnStrSetup;
            }
        }
        pSearch++;
    }

    Len = wcslen(OpaqueSettings);
    if (Len == 0 || OpaqueSettings[Len - 1] == L';')
        wsprintfW(ConnectString, L"%sData Source=%s", OpaqueSettings,
                StoreServerName);
    else
        wsprintfW(ConnectString, L"%s;Data Source=%s", OpaqueSettings,
                StoreServerName);

PostConnStrSetup:
    TRC1((TB,"Initialize: Svr addr=%S, StoreSvrName=%S, ClusterName=%S, "
            "OpaqueSettings=%S, final connstr=%S",
            m_LocalServerAddress, StoreServerName, m_ClusterName,
            OpaqueSettings, ConnectString));

    // Alloc the BSTRs for the connection strings.
    m_DBConnectStr = SysAllocString(ConnectString);
    if (m_DBConnectStr != NULL) {
        m_DBUserStr = SysAllocString(L"");
        if (m_DBUserStr != NULL) {
            m_DBPwdStr = SysAllocString(L"");
            if (m_DBPwdStr == NULL) {
                ERR((TB,"Failed alloc bstr for pwdstr"));
                goto ExitFunc;
            }
        }
        else {
            ERR((TB,"Failed alloc bstr for userstr"));
            goto ExitFunc;
        }
    }
    else {
        ERR((TB,"Failed alloc bstr for connstr"));
        goto ExitFunc;
    }

    // Create an ADO connection instance and connect.
    hr = CoCreateInstance(CLSID_CADOConnection, NULL,
            CLSCTX_INPROC_SERVER, IID_IADOConnection,
            (LPVOID *)&m_pConnection);
    if (SUCCEEDED(hr)) {
        // Set the connection timeout to only 8 seconds. Standard is 15
        // but we don't want to be holding up TermSrv's initialization.
        m_pConnection->put_ConnectionTimeout(8);

        // Do the open.
        hr = OpenConnection();
        if (SUCCEEDED(hr)) {
            // Signal the server is online.
            hr = ExecServerOnline();
        }
        else {
            m_pConnection->Release();
            m_pConnection = NULL;
        }
    }
    else {
        ERR((TB,"CoCreate(ADOConn) returned 0x%X", hr));
    }

ExitFunc:
    return hr;
}


HRESULT STDMETHODCALLTYPE CTSSessionDirectory::Update(
        LPWSTR LocalServerAddress,
        LPWSTR StoreServerName,
        LPWSTR ClusterName,
        LPWSTR OpaqueSettings,
        DWORD Flags)
{
    return E_NOTIMPL;
}


/****************************************************************************/
// CTSSessionDirectory::OpenConnection
//
// Opens the connection to the SQL server based on the pre-existing
// connect string and allocated connection. This is called at init time,
// plus whenever the database connection times out and gets closed, but is
// still required 
/****************************************************************************/
HRESULT CTSSessionDirectory::OpenConnection()
{
    HRESULT hr;

    ASSERT((m_pConnection != NULL),(TB,"OpenConn: NULL pconn"));
    ASSERT((m_DBConnectStr != NULL),(TB,"OpenConn: NULL connstr"));
    ASSERT((m_DBUserStr != NULL),(TB,"OpenConn: NULL userstr"));
    ASSERT((m_DBPwdStr != NULL),(TB,"OpenConn: NULL pwdstr"));

    hr = m_pConnection->Open(m_DBConnectStr, m_DBUserStr, m_DBPwdStr,
            adOpenUnspecified);
    if (FAILED(hr)) {
        ERR((TB,"OpenConn: Failed open DB, connstring=%S, hr=0x%X",
                m_DBConnectStr, hr));
    }

    return hr;
}


/****************************************************************************/
// GetRowArrayStringField
//
// Retrieves a WSTR from a specified row and field of the given SafeArray.
// Returns failure if the target field is not a string. MaxOutStr is max
// WCHARs not including NULL.
/****************************************************************************/
HRESULT GetRowArrayStringField(
        SAFEARRAY *pSA,
        unsigned RowIndex,
        unsigned FieldIndex,
        WCHAR *OutStr,
        unsigned MaxOutStr)
{
    HRESULT hr;
    CVar varField;
    long DimIndices[2];

    DimIndices[0] = FieldIndex;
    DimIndices[1] = RowIndex;
    SafeArrayGetElement(pSA, DimIndices, &varField);

    if (varField.vt == VT_BSTR) {
        wcsncpy(OutStr, varField.bstrVal, MaxOutStr);
        hr = S_OK;
    }
    else if (varField.vt == VT_NULL) {
        OutStr[0] = L'\0';
        hr = S_OK;
    }
    else {
        ERR((TB,"GetRowStrField: Row %u Col %u value %d is not a string",
                RowIndex, FieldIndex, varField.vt));
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************************************/
// GetRowArrayDWORDField
//
// Retrieves a DWORD from a specified row and field of the given SafeArray.
// Returns failure if the target field is not a 4-byte integer.
/****************************************************************************/
HRESULT GetRowArrayDWORDField(
        SAFEARRAY *pSA,
        unsigned RowIndex,
        unsigned FieldIndex,
        DWORD *pOutValue)
{
    HRESULT hr;
    CVar varField;
    long DimIndices[2];

    DimIndices[0] = FieldIndex;
    DimIndices[1] = RowIndex;
    SafeArrayGetElement(pSA, DimIndices, &varField);

    if (varField.vt == VT_I4) {
        *pOutValue = (DWORD)varField.lVal;
        hr = S_OK;
    }
    else if (varField.vt == VT_NULL) {
        *pOutValue = 0;
        hr = S_OK;
    }
    else {
        ERR((TB,"GetRowDWField: Row %u Col %u value %d is not a VT_I4",
                RowIndex, FieldIndex, varField.vt));
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::GetUserDisconnectedSessions
//
// Called to perform a query against the session directory, to provide the
// list of disconnected sessions for the provided username and domain.
// Returns zero or more TSSD_DisconnectedSessionInfo blocks in SessionBuf.
// *pNumSessionsReturned receives the number of blocks.
/****************************************************************************/
#define NumOutputFields 11

HRESULT STDMETHODCALLTYPE CTSSessionDirectory::GetUserDisconnectedSessions(
        LPWSTR UserName,
        LPWSTR Domain,
        DWORD __RPC_FAR *pNumSessionsReturned,
        TSSD_DisconnectedSessionInfo __RPC_FAR SessionBuf[
            TSSD_MaxDisconnectedSessions])
{
    DWORD NumSessions = 0;
    long State;
    long NumRecords;
    HRESULT hr;
    unsigned i, j;
    unsigned NumFailed;
    TSSD_DisconnectedSessionInfo *pInfo;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;
    ADOFields *pFields;
    CVar varRows;
    CVar varFields;
    CVar varStart;
    HRESULT hrFields[NumOutputFields];

    TRC2((TB,"GetUserDisconnectedSessions"));

    ASSERT((pNumSessionsReturned != NULL),(TB,"NULL pNumSess"));
    ASSERT((SessionBuf != NULL),(TB,"NULL SessionBuf"));

    hr = CreateADOStoredProcCommand(L"SP_TSSDGetUserDisconnectedSessions",
            &pCommand, &pParameters);
    if (SUCCEEDED(hr)) {
        hr = AddADOInputStringParam(UserName, L"UserName", pCommand,
                pParameters, FALSE);
        if (SUCCEEDED(hr)) {
            hr = AddADOInputStringParam(Domain, L"Domain", pCommand,
                    pParameters, FALSE);
            if (SUCCEEDED(hr)) {
                hr = AddADOInputDWORDParam(m_ClusterID, L"ClusterID",
                        pCommand, pParameters);
                if (SUCCEEDED(hr)) {
                    // Execute the command.
                    hr = pCommand->Execute(NULL, NULL, adCmdStoredProc,
                            &pResultRecordSet);
                    if (FAILED(hr)) {
                        // If we've not used the connection for awhile, it
                        // might have been disconnected and the connection
                        // object will be invalid. Attempt a reopen then
                        // reissue the command.
                        TRC2((TB,"GetUserDisc: Failed cmd, hr=0x%X, retrying",
                                hr));
                        m_pConnection->Close();
                        hr = OpenConnection();
                        if (SUCCEEDED(hr)) {
                            hr = pCommand->Execute(NULL, NULL,
                                    adCmdStoredProc, &pResultRecordSet);
                            if (FAILED(hr)) {
                                ERR((TB,"GetUserDisc: Failed cmd, hr=0x%X",
                                        hr));
                            }
                        }
                        else {
                            ERR((TB,"GetUserDisc: Failed reopen conn, hr=0x%X",
                                    hr));
                        }
                    }
                }
                else {
                    ERR((TB,"GetUserDisc: Failed add cluster, hr=0x%X", hr));
                }
            }
            else {
                ERR((TB,"GetUserDisc: Failed add sessid, hr=0x%X", hr));
            }
        }
        else {
            ERR((TB,"GetUserDisc: Failed add svraddr, hr=0x%X", hr));
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"GetUserDisc: Failed create cmd, hr=0x%X", hr));
    }
        
    // At this point we have a result recordset containing the server rows
    // corresponding to all of the disconnected sessions.
    if (SUCCEEDED(hr)) {
        long State;

        NumSessions = 0;

        hr = pResultRecordSet->get_State(&State);
        if (SUCCEEDED(hr)) {
            if (!(State & adStateClosed)) {
                VARIANT_BOOL VB;

                // If EOF the recordset is empty.
                hr = pResultRecordSet->get_EOF(&VB);
                if (SUCCEEDED(hr)) {
                    if (VB) {
                        TRC1((TB,"GetUserDisc: Result recordset EOF, 0 rows"));
                        goto PostUnpackResultSet;
                    }
                }
                else {
                    ERR((TB,"GetUserDisc: Failed get_EOF, hr=0x%X", hr));
                    goto PostUnpackResultSet;
                }
            }
            else {
                ERR((TB,"GetUserDisc: Closed result recordset"));
                goto PostUnpackResultSet;
            }
        }
        else {
            ERR((TB,"GetUserDisc: get_State failed, hr=0x%X", hr));
            goto PostUnpackResultSet;
        }

        // Grab the result data into a safearray, starting with the default
        // current row and all fields.
        varStart.InitNoParam();
        varFields.InitNoParam();
        hr = pResultRecordSet->GetRows(TSSD_MaxDisconnectedSessions, varStart,
                varFields, &varRows);
        if (SUCCEEDED(hr)) {
            NumRecords = 0;
            hr = SafeArrayGetUBound(varRows.parray, 2, &NumRecords);
            if (SUCCEEDED(hr)) {
                // 0-based array bound was returned, num rows is that + 1.
                NumRecords++;
                ASSERT((NumRecords <= TSSD_MaxDisconnectedSessions),
                        (TB,"GetUserDisc: NumRecords %u greater than expected %u",
                        NumRecords, TSSD_MaxDisconnectedSessions));

                TRC1((TB,"%d rows retrieved from safearray", NumRecords));
            }
            else {
                ERR((TB,"GetUserDisc: Failed safearray getubound, hr=0x%X", hr));
                goto PostUnpackResultSet;
            }
        }
        else {
            ERR((TB,"GetUserDisc: Failed to get rows, hr=0x%X", hr));
            goto PostUnpackResultSet;
        }

        // Loop through and get the contents of each row, translating into
        // the output DiscSession structs.
        pInfo = SessionBuf;
        for (i = 0; i < (unsigned)NumRecords; i++) {
            // Stack up the hr's for each field before checking them all.
            hrFields[0] = GetRowArrayStringField(varRows.parray, i, 0,
                    pInfo->ServerAddress, sizeof(pInfo->ServerAddress) /
                    sizeof(TCHAR) - 1);
            hrFields[1] = GetRowArrayDWORDField(varRows.parray, i, 1,
                    &pInfo->SessionID);
            hrFields[2] = GetRowArrayDWORDField(varRows.parray, i, 2,
                    &pInfo->TSProtocol);
            hrFields[3] = GetRowArrayStringField(varRows.parray, i, 7,
                    pInfo->ApplicationType, sizeof(pInfo->ApplicationType) /
                    sizeof(TCHAR) - 1);
            hrFields[4] = GetRowArrayDWORDField(varRows.parray, i, 8,
                    &pInfo->ResolutionWidth);
            hrFields[5] = GetRowArrayDWORDField(varRows.parray, i, 9,
                    &pInfo->ResolutionHeight);
            hrFields[6] = GetRowArrayDWORDField(varRows.parray, i, 10,
                    &pInfo->ColorDepth);
            hrFields[7] = GetRowArrayDWORDField(varRows.parray, i, 3,
                    &pInfo->CreateTime.dwLowDateTime);
            hrFields[8] = GetRowArrayDWORDField(varRows.parray, i, 4,
                    &pInfo->CreateTime.dwHighDateTime);
            hrFields[9] = GetRowArrayDWORDField(varRows.parray, i, 5,
                    &pInfo->DisconnectionTime.dwLowDateTime);
            hrFields[10] = GetRowArrayDWORDField(varRows.parray, i, 6,
                    &pInfo->DisconnectionTime.dwHighDateTime);

            NumFailed = 0;
            for (j = 0; j < NumOutputFields; j++) {
                if (SUCCEEDED(hrFields[j])) {
                    continue;
                }
                else {
                    ERR((TB,"GetUserDisc: Row %u field %u returned hr=0x%X",
                            i, j, hrFields[j]));
                    NumFailed++;
                }
            }
            if (!NumFailed) {
                NumSessions++;
                pInfo++;
            }
        }


PostUnpackResultSet:
        pResultRecordSet->Release();
    }
    else {
        ERR((TB,"GetUserDisc: Failed exec, hr=0x%X", hr));
    }

    *pNumSessionsReturned = NumSessions;
    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyCreateLocalSession
//
// ITSSessionDirectory function. Called when a session is created to add the
// session to the session directory. Note that other interface functions
// access the session directory by either the username/domain or the
// session ID; the directory schema should take this into account for
// performance optimization.
/****************************************************************************/
#define NumCreateParams 11

HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyCreateLocalSession(
        TSSD_CreateSessionInfo __RPC_FAR *pCreateInfo)
{
    unsigned i, NumFailed;
    HRESULT hr;
    HRESULT hrParam[NumCreateParams];
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;

    TRC2((TB,"NotifyCreateLocalSession, SessID=%u", pCreateInfo->SessionID));

    ASSERT((pCreateInfo != NULL),(TB,"NotifyCreate: NULL CreateInfo"));

    hr = CreateADOStoredProcCommand(L"SP_TSSDCreateSession", &pCommand,
            &pParameters);
    if (SUCCEEDED(hr)) {
        // Create and add the params in one fell swoop. We'll check all
        // of the return values in a batch later.
        hrParam[0] = AddADOInputStringParam(pCreateInfo->UserName,
                L"UserName", pCommand, pParameters, FALSE);
        hrParam[1] = AddADOInputStringParam(pCreateInfo->Domain,
                L"Domain", pCommand, pParameters, FALSE);
        hrParam[2] = AddADOInputDWORDParam(m_ServerID,
                L"ServerID", pCommand, pParameters);
        hrParam[3] = AddADOInputDWORDParam(pCreateInfo->SessionID,
                L"SessionID", pCommand, pParameters);
        hrParam[4] = AddADOInputDWORDParam(pCreateInfo->TSProtocol,
                L"TSProtocol", pCommand, pParameters);
        hrParam[5] = AddADOInputStringParam(pCreateInfo->ApplicationType,
                L"AppType", pCommand, pParameters);
        hrParam[6] = AddADOInputDWORDParam(pCreateInfo->ResolutionWidth,
                L"ResolutionWidth", pCommand, pParameters);
        hrParam[7] = AddADOInputDWORDParam(pCreateInfo->ResolutionHeight,
                L"ResolutionHeight", pCommand, pParameters);
        hrParam[8] = AddADOInputDWORDParam(pCreateInfo->ColorDepth,
                L"ColorDepth", pCommand, pParameters);
        hrParam[9] = AddADOInputDWORDParam(pCreateInfo->CreateTime.dwLowDateTime,
                L"CreateTimeLow", pCommand, pParameters);
        hrParam[10] = AddADOInputDWORDParam(pCreateInfo->CreateTime.dwHighDateTime,
                L"CreateTimeHigh", pCommand, pParameters);

        NumFailed = 0;
        for (i = 0; i < NumCreateParams; i++) {
            if (SUCCEEDED(hrParam[i])) {
                continue;
            }
            else {
                ERR((TB,"NotifyCreate: Failed param create %u", i));
                NumFailed++;
                hr = hrParam[i];
            }
        }
        if (NumFailed == 0) {
            // Execute the command.
            hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                    adExecuteNoRecords, &pResultRecordSet);
            if (FAILED(hr)) {
                // If we've not used the connection for awhile, it might
                // have been disconnected and the connection object will
                // be invalid. Attempt a reopen then reissue the command.
                TRC2((TB,"NotifyCreate: Failed cmd, hr=0x%X, retrying",
                        hr));
                m_pConnection->Close();
                hr = OpenConnection();
                if (SUCCEEDED(hr)) {
                    hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                            adExecuteNoRecords, &pResultRecordSet);
                    if (FAILED(hr)) {
                        ERR((TB,"NotifyCreate: Failed exec, hr=0x%X", hr));
                    }
                }
                else {
                    ERR((TB,"NotifyCreate: Failed reopen conn, hr=0x%X",
                            hr));
                }
            }
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"NotifyCreate: Failed create cmd, hr=0x%X", hr));
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyDestroyLocalSession
//
// ITSSessionDirectory function. Removes a session from the session database.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyDestroyLocalSession(
        DWORD SessionID)
{
    HRESULT hr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;

    TRC2((TB,"NotifyDestroyLocalSession, SessionID=%u", SessionID));

    hr = CreateADOStoredProcCommand(L"SP_TSSDDeleteSession", &pCommand,
            &pParameters);
    if (SUCCEEDED(hr)) {
        hr = AddADOInputDWORDParam(m_ServerID, L"ServerID",
                pCommand, pParameters);
        if (SUCCEEDED(hr)) {
            hr = AddADOInputDWORDParam(SessionID, L"SessionID", pCommand,
                    pParameters);
            if (SUCCEEDED(hr)) {
                // Execute the command.
                hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                        adExecuteNoRecords, &pResultRecordSet);
                if (FAILED(hr)) {
                    // If we've not used the connection for awhile, it might
                    // have been disconnected and the connection object will
                    // be invalid. Attempt a reopen then reissue the command.
                    TRC2((TB,"NotifyDestroy: Failed cmd, hr=0x%X, retrying",
                            hr));
                    m_pConnection->Close();
                    hr = OpenConnection();
                    if (SUCCEEDED(hr)) {
                        hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                                adExecuteNoRecords, &pResultRecordSet);
                        if (FAILED(hr)) {
                            ERR((TB,"NotifyDestroy: Failed exec, hr=0x%X", hr));
                        }
                    }
                    else {
                        ERR((TB,"NotifyDestroy: Failed reopen conn, hr=0x%X",
                                hr));
                    }
                }
            }
            else {
                ERR((TB,"NotifyDestroy: Failed add sessid, hr=0x%X", hr));
            }
        }
        else {
            ERR((TB,"NotifyDestroy: Failed add svraddr, hr=0x%X", hr));
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"NotifyDestroy: Failed create cmd, hr=0x%X", hr));
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyDisconnectLocalSession
//
// ITSSessionDirectory function. Changes the state of an existing session to
// disconnected. The provided time should be returned in disconnected session
// queries performed by any machine in the server pool.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyDisconnectLocalSession(
        DWORD SessionID,
        FILETIME DiscTime)
{
    HRESULT hr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;

    TRC2((TB,"NotifyDisconnectLocalSession, SessionID=%u", SessionID));

    hr = CreateADOStoredProcCommand(L"SP_TSSDSetSessionDisconnected",
            &pCommand, &pParameters);
    if (SUCCEEDED(hr)) {
        hr = AddADOInputDWORDParam(m_ServerID, L"ServerID",
                pCommand, pParameters);
        if (SUCCEEDED(hr)) {
            hr = AddADOInputDWORDParam(SessionID, L"SessionID", pCommand,
                    pParameters);
            if (SUCCEEDED(hr)) {
                hr = AddADOInputDWORDParam(DiscTime.dwLowDateTime,
                        L"DiscTimeLow", pCommand, pParameters);
                if (SUCCEEDED(hr)) {
                    hr = AddADOInputDWORDParam(DiscTime.dwHighDateTime,
                            L"DiscTimeHigh", pCommand, pParameters);
                    if (SUCCEEDED(hr)) {
                        // Execute the command.
                        hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                                adExecuteNoRecords, &pResultRecordSet);
                        if (FAILED(hr)) {
                            // If we've not used the connection for awhile, it
                            // might have been disconnected and the connection
                            // object will be invalid. Attempt a reopen then
                            // reissue the command.
                            TRC2((TB,"NotifyDisc: Failed cmd, hr=0x%X, "
                                    "retrying", hr));
                            m_pConnection->Close();
                            hr = OpenConnection();
                            if (SUCCEEDED(hr)) {
                                hr = pCommand->Execute(NULL, NULL,
                                        adCmdStoredProc | adExecuteNoRecords,
                                        &pResultRecordSet);
                                if (FAILED(hr)) {
                                    ERR((TB,"NotifyDisc: Failed exec, hr=0x%X",
                                            hr));
                                }
                            }
                            else {
                                ERR((TB,"NotifyDisc: Failed reopen conn, "
                                        "hr=0x%X", hr));
                            }
                        }
                    }
                    else {
                        ERR((TB,"NotifyDisconn: Failed add disctimehigh, "
                                "hr=0x%X", hr));
                    }
                }
                else {
                    ERR((TB,"NotifyDisconn: Failed add disctimelow, hr=0x%X",
                            hr));
                }
            }
            else {
                ERR((TB,"NotifyDisconn: Failed add sessid, hr=0x%X", hr));
            }
        }
        else {
            ERR((TB,"NotifyDisconn: Failed add svraddr, hr=0x%X", hr));
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"NotifyDisconn: Failed create cmd, hr=0x%X", hr));
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyReconnectLocalSession
//
// ITSSessionDirectory function. Changes the state of an existing session
// from disconnected to connected.
/****************************************************************************/
#define NumReconnParams 6

HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyReconnectLocalSession(
        TSSD_ReconnectSessionInfo __RPC_FAR *pReconnInfo)
{
    HRESULT hr;
    HRESULT hrParam[NumReconnParams];
    unsigned i, NumFailed;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;

    TRC2((TB,"NotifyReconnectLocalSession, SessionID=%u",
            pReconnInfo->SessionID));

    hr = CreateADOStoredProcCommand(L"SP_TSSDSetSessionReconnected",
            &pCommand, &pParameters);
    if (SUCCEEDED(hr)) {
        // Add the 5 parameters.
        hrParam[0] = AddADOInputDWORDParam(m_ServerID,
                L"ServerID", pCommand, pParameters);
        hrParam[1] = AddADOInputDWORDParam(pReconnInfo->SessionID,
                L"SessionID", pCommand, pParameters);
        hrParam[2] = AddADOInputDWORDParam(pReconnInfo->TSProtocol,
                L"TSProtocol", pCommand, pParameters);
        hrParam[3] = AddADOInputDWORDParam(pReconnInfo->ResolutionWidth,
                L"ResWidth", pCommand, pParameters);
        hrParam[4] = AddADOInputDWORDParam(pReconnInfo->ResolutionHeight,
                L"ResHeight", pCommand, pParameters);
        hrParam[5] = AddADOInputDWORDParam(pReconnInfo->ColorDepth,
                L"ColorDepth", pCommand, pParameters);
                
        NumFailed = 0;
        for (i = 0; i < NumReconnParams; i++) {
            if (SUCCEEDED(hrParam[i])) {
                continue;
            }
            else {
                ERR((TB,"NotifyReconn: Failed param create %u", i));
                NumFailed++;
                hr = hrParam[i];
            }
        }
        if (NumFailed == 0) {
            // Execute the command.
            hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                    adExecuteNoRecords, &pResultRecordSet);
            if (FAILED(hr)) {
                // If we've not used the connection for awhile, it might
                // have been disconnected and the connection object will
                // be in a bad state. Close, reopen, and reissue the
                // command.
                TRC2((TB,"NotifyReconn: Failed exec, hr=0x%X, retrying",
                        hr));
                m_pConnection->Close();
                hr = OpenConnection();
                if (SUCCEEDED(hr)) {
                    hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                            adExecuteNoRecords, &pResultRecordSet);
                    if (FAILED(hr)) {
                        ERR((TB,"NotifyReconn: Failed exec, hr=0x%X", hr));
                    }
                }
                else {
                    ERR((TB,"NotifyReconn: Failed reopen conn, hr=0x%X",
                            hr));
                }
            }
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"NotifyReconn: Failed create cmd, hr=0x%X", hr));
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyReconnectPending
//
// ITSSessionDirectory function. Informs session directory that a reconnect
// is pending soon because of a revectoring.  Used by DIS to determine
// when a server might have gone down.  (DIS is the Directory Integrity
// Service, which runs on the machine with the session directory.)
//
// This is a two-phase procedure--we first check the fields, and then we
// add the timestamp only if there is no outstanding timestamp already (i.e., 
// the two Almost-In-Time fields are 0).  This prevents constant revectoring
// from updating the timestamp fields, which would prevent the DIS from 
// figuring out that a server is down.
//
// These two steps are done in the stored procedure to make the operation
// atomic.
/****************************************************************************/
#define NumReconPendParams 3

HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyReconnectPending(
        WCHAR *ServerName)
{
    HRESULT hr;
    HRESULT hrParam[NumReconPendParams];
    unsigned NumFailed, i;

    FILETIME ft;
    SYSTEMTIME st;
    
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;

    TRC2((TB,"NotifyReconnectPending"));

    ASSERT((ServerName != NULL),(TB,"NotifyReconnectPending: NULL ServerName"));

    // Get the current system time.
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    // Call the stored procedure, which will update the fields if they are 0.
    hr = CreateADOStoredProcCommand(L"SP_TSSDSetServerReconnectPending",
            &pCommand, &pParameters);
    if (SUCCEEDED(hr)) {
        // Add the 3 parameters.
        hrParam[0] = AddADOInputStringParam(ServerName,
                L"ServerAddress", pCommand, pParameters, FALSE);
        hrParam[1] = AddADOInputDWORDParam(ft.dwLowDateTime,
                L"AlmostTimeLow", pCommand, pParameters);
        hrParam[2] = AddADOInputDWORDParam(ft.dwHighDateTime,
                L"AlmostTimeHigh", pCommand, pParameters);

        NumFailed = 0;
        for (i = 0; i < NumReconPendParams; i++) {
            if (SUCCEEDED(hrParam[i])) {
                continue;
            }
            else {
                ERR((TB,"NotifyReconPending: Failed param create %u", i));
                NumFailed++;
                hr = hrParam[i];
            }
        }
        if (NumFailed == 0) {
            // Execute the command.
            hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                    adExecuteNoRecords, &pResultRecordSet);
            if (FAILED(hr)) {
                // If we've not used the connection for awhile, it might
                // have been disconnected and the connection object will
                // be in a bad state. Close, reopen, and reissue the
                // command.
                TRC2((TB,"NotifyReconPending: Failed exec, hr=0x%X, retrying",
                        hr));
                m_pConnection->Close();
                hr = OpenConnection();
                if (SUCCEEDED(hr)) {
                    hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                            adExecuteNoRecords, &pResultRecordSet);
                    if (FAILED(hr)) {
                        ERR((TB,"NotifyReconPending: Failed exec, hr=0x%X", hr));
                    }
                }
                else {
                    ERR((TB,"NotifyReconPending: Failed reopen conn, hr=0x%X",
                            hr));
                }
            }
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"NotifyReconnectPending: Failed create cmd, hr=0x%X", hr));
    }


    return hr;
}


HRESULT STDMETHODCALLTYPE CTSSessionDirectory::Repopulate(
        DWORD WinStationCount, 
        TSSD_RepopulateSessionInfo *rsi)
{
    return E_NOTIMPL;
}


/****************************************************************************/
// CreateADOStoredProcCommand
//
// Creates and returns a stored proc ADOCommand, plus a ref to its
// associated Parameters.
/****************************************************************************/
HRESULT CTSSessionDirectory::CreateADOStoredProcCommand(
        PWSTR CmdName,
        ADOCommand **ppCommand,
        ADOParameters **ppParameters)
{
    HRESULT hr;
    BSTR CmdStr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;

    CmdStr = SysAllocString(CmdName);
    if (CmdStr != NULL) {
        hr = CoCreateInstance(CLSID_CADOCommand, NULL, CLSCTX_INPROC_SERVER,
                IID_IADOCommand25, (LPVOID *)&pCommand);
        if (SUCCEEDED(hr)) {
            // Set the connection.
            hr = pCommand->putref_ActiveConnection(m_pConnection);
            if (SUCCEEDED(hr)) {
                // Set the command text.
                hr = pCommand->put_CommandText(CmdStr);
                if (SUCCEEDED(hr)) {
                    // Set the command type.
                    hr = pCommand->put_CommandType(adCmdStoredProc);
                    if (SUCCEEDED(hr)) {
                        // Get the Parameters pointer from the Command to
                        // allow appending params.
                        hr = pCommand->get_Parameters(&pParameters);
                        if (FAILED(hr)) {
                            ERR((TB,"Failed getParams for command, "
                                    "hr=0x%X", hr));
                            goto PostCreateCommand;
                        }
                    }
                    else {
                        ERR((TB,"Failed set cmdtype for command, hr=0x%X",
                                hr));
                        goto PostCreateCommand;
                    }
                }
                else {
                    ERR((TB,"Failed set cmdtext for command, hr=0x%X", hr));
                    goto PostCreateCommand;
                }
            }
            else {
                ERR((TB,"Command::putref_ActiveConnection hr=0x%X", hr));
                goto PostCreateCommand;
            }
        }
        else {
            ERR((TB,"CoCreate(Command) returned 0x%X", hr));
            goto PostAllocCmdStr;
        }

        SysFreeString(CmdStr);
    }
    else {
        ERR((TB,"Failed to alloc cmd str"));
        hr = E_OUTOFMEMORY;
        goto ExitFunc;
    }

    *ppCommand = pCommand;
    *ppParameters = pParameters;
    return hr;

// Error handling.

PostCreateCommand:
    pCommand->Release();

PostAllocCmdStr:
    SysFreeString(CmdStr);

ExitFunc:
    *ppCommand = NULL;
    *ppParameters = NULL;
    return hr;
}


/****************************************************************************/
// AddADOInputDWORDParam
//
// Creates and adds to the given ADOParameters object a DWORD-initialized
// parameter value.
/****************************************************************************/
HRESULT CTSSessionDirectory::AddADOInputDWORDParam(
        DWORD Param,
        PWSTR ParamName,
        ADOCommand *pCommand,
        ADOParameters *pParameters)
{
    HRESULT hr;
    CVar varParam;
    BSTR ParamStr;
    ADOParameter *pParam;

    ParamStr = SysAllocString(ParamName);
    if (ParamStr != NULL) {
        varParam.vt = VT_I4;
        varParam.lVal = Param;
        hr = pCommand->CreateParameter(ParamStr, adInteger, adParamInput, -1,
                varParam, &pParam);
        if (SUCCEEDED(hr)) {
            hr = pParameters->Append(pParam);
            if (FAILED(hr)) {
                ERR((TB,"InDWParam: Failed append param %S, hr=0x%X",
                        ParamName, hr));
            }

            // ADO will have its own ref for the param.
            pParam->Release();
        }
        else {
            ERR((TB,"InDWParam: Failed CreateParam %S, hr=0x%X",
                    ParamName, hr));
        }

        SysFreeString(ParamStr);
    }
    else {
        ERR((TB,"InDWParam: Failed alloc paramname"));
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/****************************************************************************/
// AddADOInputStringParam
//
// Creates and adds to the given ADOParameters object a WSTR-initialized
// parameter value.
/****************************************************************************/
HRESULT CTSSessionDirectory::AddADOInputStringParam(
        PWSTR Param,
        PWSTR ParamName,
        ADOCommand *pCommand,
        ADOParameters *pParameters,
        BOOL bNullOnNull)
{
    HRESULT hr;
    CVar varParam;
    BSTR ParamStr;
    ADOParameter *pParam;
    int Len;

    ParamStr = SysAllocString(ParamName);
    if (ParamStr != NULL) {
        // ADO does not seem to like accepting string params that are zero
        // length. So, if the string we have is zero length and bNullOnNull says
        // we can, we send a null VARIANT type, resulting in a null value at
        // the SQL server.
        if (wcslen(Param) > 0 || !bNullOnNull) {
            hr = varParam.InitFromWSTR(Param);
            Len = wcslen(Param);
        }
        else {
            varParam.vt = VT_NULL;
            varParam.bstrVal = NULL;
            Len = -1;
            hr = S_OK;
        }

        if (SUCCEEDED(hr)) {
            hr = pCommand->CreateParameter(ParamStr, adVarWChar, adParamInput,
                    Len, varParam, &pParam);
            if (SUCCEEDED(hr)) {
                hr = pParameters->Append(pParam);
                if (FAILED(hr)) {
                    ERR((TB,"InStrParam: Failed append param %S, hr=0x%X",
                            ParamName, hr));
                }

                // ADO will have its own ref for the param.
                pParam->Release();
            }
            else {
                ERR((TB,"InStrParam: Failed CreateParam %S, hr=0x%X",
                        ParamName, hr));
            }
        }
        else {
            ERR((TB,"InStrParam: Failed alloc variant bstr, "
                    "param %S, hr=0x%X", ParamName, hr));
        }

        SysFreeString(ParamStr);
    }
    else {
        ERR((TB,"InStrParam: Failed alloc paramname"));
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::ExecServerOnline
//
// Encapsulates creation and execution of the SP_TSSDServerOnline
// stored procedure on the server. Assumes that m_ClusterName is already set.
/****************************************************************************/
HRESULT CTSSessionDirectory::ExecServerOnline()
{
    HRESULT hr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;
    CVar varRows;
    CVar varFields;
    CVar varStart;
    long NumRecords;

    if (m_pConnection != NULL) {
        // Create the command.
        hr = CreateADOStoredProcCommand(L"SP_TSSDServerOnline", &pCommand,
                &pParameters);
        if (SUCCEEDED(hr)) {
            // Server name param.
            hr = AddADOInputStringParam(m_LocalServerAddress,
                    L"ServerAddress", pCommand, pParameters, FALSE);
            if (SUCCEEDED(hr)) {
                // Cluster name param.
                hr = AddADOInputStringParam(m_ClusterName,
                        L"ClusterName", pCommand, pParameters, TRUE);
                if (SUCCEEDED(hr)) {
                    // Execute the command.
                    hr = pCommand->Execute(NULL, NULL, adCmdStoredProc,
                            &pResultRecordSet);
                    if (SUCCEEDED(hr)) {
                        TRC2((TB,"ExecOn: Success"));
                    }
                    else {
                        ERR((TB,"Failed exec ServerOnline, hr=0x%X", hr));
                    }
                }
                else {
                    ERR((TB,"ExecOn: Failed adding ClusterName, hr=0x%X", hr));
                }
            }
            else {
                ERR((TB,"ExecOn: Failed adding ServerAddress, hr=0x%X",
                        hr));
            }

            pParameters->Release();
            pCommand->Release();
        }
        else {
            ERR((TB,"ExecOn: Failed create command, hr=0x%X", hr));
        }
    }
    else {
        ERR((TB,"ExecOn: Connection invalid"));
        hr = E_FAIL;
    }

    // Parse out the ServerID and ClusterID from the result recordset.
    if (SUCCEEDED(hr)) {
        long State;

        hr = pResultRecordSet->get_State(&State);
        if (SUCCEEDED(hr)) {
            if (!(State & adStateClosed)) {
                VARIANT_BOOL VB;

                // If EOF the recordset is empty.
                hr = pResultRecordSet->get_EOF(&VB);
                if (SUCCEEDED(hr)) {
                    if (VB) {
                        TRC1((TB,"ExecOnline: Result recordset EOF"));
                        hr = E_FAIL;
                        goto PostUnpackResultSet;
                    }
                }
                else {
                    ERR((TB,"GetUserDisc: Failed get_EOF, hr=0x%X", hr));
                    goto PostUnpackResultSet;
                }
            }
            else {
                ERR((TB,"GetUserDisc: Closed result recordset"));
                hr = E_FAIL;
                goto PostUnpackResultSet;
            }
        }
        else {
            ERR((TB,"GetUserDisc: get_State failed, hr=0x%X", hr));
            goto PostUnpackResultSet;
        }

        // Grab the result data into a safearray, starting with the default
        // current row and all fields.
        varStart.InitNoParam();
        varFields.InitNoParam();
        hr = pResultRecordSet->GetRows(1, varStart, varFields, &varRows);
        if (SUCCEEDED(hr)) {
            NumRecords = 0;
            hr = SafeArrayGetUBound(varRows.parray, 2, &NumRecords);
            if (SUCCEEDED(hr)) {
                // 0-based array bound was returned, num rows is that + 1.
                NumRecords++;
                ASSERT((NumRecords == 1),
                        (TB,"ExecOnline: NumRecords %u != expected %u",
                        NumRecords, 1));

                TRC1((TB,"%d rows retrieved from safearray", NumRecords));
            }
            else {
                ERR((TB,"ExecOnline: Failed safearray getubound, hr=0x%X", hr));
                goto PostUnpackResultSet;
            }
        }
        else {
            ERR((TB,"ExecOnline: Failed to get rows, hr=0x%X", hr));
            goto PostUnpackResultSet;
        }

        // Get the fields.
        hr = GetRowArrayDWORDField(varRows.parray, 0, 0, &m_ServerID);
        if (SUCCEEDED(hr)) {
            hr = GetRowArrayDWORDField(varRows.parray, 0, 1, &m_ClusterID);
            if (FAILED(hr)) {
                ERR((TB,"ExecOnline: Failed retrieve ClusterID, hr=0x%X", hr));
            }
        }
        else {
            ERR((TB,"ExecOnline: Failed retrieve ServerID, hr=0x%X", hr));
        }

PostUnpackResultSet:
        pResultRecordSet->Release();
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::ExecServerOffline
//
// Encapsulates creation and execution of the SP_TSSDServerOffline
// stored procedure on the server.
/****************************************************************************/
HRESULT CTSSessionDirectory::ExecServerOffline()
{
    HRESULT hr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;

    if (m_pConnection != NULL) {
        // Create the command.
        hr = CreateADOStoredProcCommand(L"SP_TSSDServerOffline", &pCommand,
                &pParameters);
        if (SUCCEEDED(hr)) {
            // On an offline request, we need fast turn-around since we're
            // likely being called when the system is going down. Set the
            // timeout value for the command to 2 seconds.
            pCommand->put_CommandTimeout(2);

            hr = AddADOInputDWORDParam(m_ServerID,
                    L"ServerID", pCommand, pParameters);
            if (SUCCEEDED(hr)) {
                // Execute the command.
                hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                        adExecuteNoRecords, &pResultRecordSet);
                if (SUCCEEDED(hr)) {
                    TRC2((TB,"ExecOff: Success"));
                }
                else {
                    ERR((TB,"Failed exec ServerOffline, hr=0x%X", hr));
                }
            }
            else {
                ERR((TB,"ExecOnOff: Failed adding ServerAddress, hr=0x%X",
                        hr));
            }

            pParameters->Release();
            pCommand->Release();
        }
        else {
            ERR((TB,"ExecOff: Failed create command, hr=0x%X", hr));
        }
    }
    else {
        ERR((TB,"ExecOff: Connection invalid"));
        hr = E_FAIL;
    }

    return hr;
}


/* ------------------------------------------------------------------------
   Plug-in UI interface for TSCC
   ------------------------------------------------------------------------*/


/* -------------------------------------------------------------------------------
 * describes the name of this entry in server settins
 * -------------------------------------------------------------------------------
 */
STDMETHODIMP CTSSessionDirectory::GetAttributeName(/* out */ WCHAR *pwszAttribName)
{
    TCHAR szAN[256];

    ASSERT((pwszAttribName != NULL),(TB,"NULL attrib ptr"));
    LoadString(g_hInstance, IDS_ATTRIBUTE_NAME, szAN, sizeof(szAN) / sizeof(TCHAR));
    lstrcpy(pwszAttribName, szAN);
    return S_OK;
}


/* -------------------------------------------------------------------------------
 * for this component the attribute value would indicate if its enabled or not
 * -------------------------------------------------------------------------------
 */
STDMETHODIMP CTSSessionDirectory::GetDisplayableValueName(
        /* out */WCHAR *pwszAttribValueName)
{
    TCHAR szAvn[256];    

    ASSERT((pwszAttribValueName != NULL),(TB,"NULL attrib ptr"));

    m_fEnabled = IsSessionDirectoryEnabled();
    if (m_fEnabled)
        LoadString(g_hInstance, IDS_ENABLE, szAvn, sizeof(szAvn) / sizeof(TCHAR));
    else
        LoadString(g_hInstance, IDS_DISABLE, szAvn, sizeof(szAvn) / sizeof(TCHAR));

    lstrcpy(pwszAttribValueName, szAvn);

    return S_OK;
}


/* -------------------------------------------------------------------------------
 * Custom UI provided here
 * pdwStatus informs Terminal Service Config to update termsrv
 * -------------------------------------------------------------------------------
 */
STDMETHODIMP CTSSessionDirectory::InvokeUI( /* in */ HWND hParent , /* out */ PDWORD pdwStatus )
{
    INT_PTR iRet = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_DIALOG_SDS),
            hParent, (DLGPROC)CustomUIDlg, (LPARAM)this);

    TRC1((TB,"DialogBox returned 0x%x", iRet));

    *pdwStatus = ( DWORD )iRet;

    return S_OK;
}


/* -------------------------------------------------------------------------------
 * Custom menu items -- must be freed by LocalFree
 * this is called everytime the user right clicks the listitem
 * so you can alter the settings ( i.e. enable to disable and vice versa )
 * -------------------------------------------------------------------------------
 */
STDMETHODIMP CTSSessionDirectory::GetMenuItems(
        /* out */ int *pcbItems,
        /* out */ PMENUEXTENSION *pMex)
{
    ASSERT((pcbItems != NULL),(TB,"NULL items ptr"));

    *pcbItems = 2;

    *pMex = ( PMENUEXTENSION )LocalAlloc( LMEM_FIXED, *pcbItems * sizeof( MENUEXTENSION ) );

    if( *pMex != NULL )
    {
        // display enable or disable
        if( m_fEnabled )
        {
            LoadString(g_hInstance, IDS_DISABLE, (*pMex)[0].MenuItemName,
                    sizeof((*pMex)[0].MenuItemName) / sizeof(WCHAR));
        }
        else
        {
            LoadString(g_hInstance, IDS_ENABLE, (*pMex)[0].MenuItemName,
                    sizeof((*pMex)[0].MenuItemName) / sizeof(WCHAR));
        }
        
        LoadString(g_hInstance, IDS_DESCRIP_ENABLE, (*pMex)[0].StatusBarText,
                sizeof((*pMex)[0].StatusBarText) / sizeof(WCHAR));

        // menu items id -- this id will be passed back to u in ExecMenuCmd

        (*pMex)[0].cmd = IDM_MENU_ENABLE;

        LoadString(g_hInstance, IDS_PROPERTIES,  (*pMex)[1].MenuItemName,
                sizeof((*pMex)[1].MenuItemName) / sizeof(WCHAR));

        LoadString(g_hInstance, IDS_DESCRIP_PROPS, (*pMex)[1].StatusBarText,
                sizeof((*pMex)[1].StatusBarText) / sizeof(WCHAR));

        // menu items id -- this id will be passed back to u in ExecMenuCmd
        (*pMex)[1].cmd = IDM_MENU_PROPS;

        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


/* -------------------------------------------------------------------------------
 * When the user selects a menu item the cmd id is passed to this component.
 * the provider ( which is us )
 * -------------------------------------------------------------------------------
 */
STDMETHODIMP CTSSessionDirectory::ExecMenuCmd(
        /* in */ UINT cmd,
        /* in */ HWND hParent ,
        /* out*/ PDWORD pdwStatus )
{
    switch (cmd) {
        case IDM_MENU_ENABLE:
            m_fEnabled = m_fEnabled ? 0 : 1;
            TRC1((TB,"%ws was selected", m_fEnabled ? L"Disable" : L"Enable"));
            if( SetSessionDirectoryState( m_fEnabled ) == ERROR_SUCCESS )
            {
                *pdwStatus = UPDATE_TERMSRV_SESSDIR;
            }
            break;

        case IDM_MENU_PROPS:
            INT_PTR iRet = DialogBoxParam(g_hInstance,
                    MAKEINTRESOURCE(IDD_DIALOG_SDS),
                    hParent,
                    (DLGPROC)CustomUIDlg,
                    (LPARAM)this);

            *pdwStatus = ( DWORD )iRet;
    }

    return S_OK;
}


/* -------------------------------------------------------------------------------
 * Tscc provides a default help menu item,  when selected this method is called
 * if we want tscc to handle ( or provide ) help return any value other than zero
 * for those u can't follow logic return zero if you're handling help.
 * -------------------------------------------------------------------------------
 */
STDMETHODIMP CTSSessionDirectory::OnHelp( /* out */ int *piRet)
{
    ASSERT((piRet != NULL),(TB,"NULL ret ptr"));
    *piRet = 0;
    return S_OK;
}


/* -------------------------------------------------------------------------------
 * IsSessionDirectoryEnabled returns a bool
 * -------------------------------------------------------------------------------
 */
BOOL CTSSessionDirectory::IsSessionDirectoryEnabled()
{
    LONG lRet;
    HKEY hKey;
    DWORD dwEnabled = 0;
    DWORD dwSize = sizeof(DWORD);
    
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            REG_CONTROL_TSERVER,
            0,
            KEY_READ,
            &hKey);

    if (lRet == ERROR_SUCCESS)
    {
        lRet = RegQueryValueEx( hKey ,
                                REG_TS_SESSDIRACTIVE,
                                NULL ,
                                NULL ,
                                ( LPBYTE )&dwEnabled ,
                                &dwSize );

        RegCloseKey( hKey );
    }  

    return ( BOOL )dwEnabled;
}


/* -------------------------------------------------------------------------------
 * SetSessionDirectoryState - sets SessionDirectoryActive regkey to bVal
 * -------------------------------------------------------------------------------
 */
DWORD CTSSessionDirectory::SetSessionDirectoryState( BOOL bVal )
{
    LONG lRet;
    HKEY hKey;
    DWORD dwSize = sizeof( DWORD );
    
    lRet = RegOpenKeyEx( 
                        HKEY_LOCAL_MACHINE ,
                        REG_CONTROL_TSERVER ,
                        0,
                        KEY_WRITE,
                        &hKey );
    if (lRet == ERROR_SUCCESS)
    {
        lRet = RegSetValueEx( hKey ,
                              REG_TS_SESSDIRACTIVE,
                              0,
                              REG_DWORD ,
                              ( LPBYTE )&bVal ,
                              dwSize );
        
        RegCloseKey( hKey );
    } 
    else
    {
        ErrorMessage( NULL , IDS_ERROR_TEXT3 , ( DWORD )lRet );
    }

    return ( DWORD )lRet;
}


/* -------------------------------------------------------------------------------
 * ErrorMessage --
 * -------------------------------------------------------------------------------
 */
void CTSSessionDirectory::ErrorMessage( HWND hwnd , UINT res , DWORD dwStatus )
{
    TCHAR tchTitle[ 64 ];
    TCHAR tchText[ 64 ];
    TCHAR tchErrorMessage[ 256 ];
    LPTSTR pBuffer = NULL;
    
    // report error
    ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,                                         //ignored
            ( DWORD )dwStatus,                            //message ID
            MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),  //message language
            (LPTSTR)&pBuffer,                             //address of buffer pointer
            0,                                            //minimum buffer size
            NULL);  
    
    LoadString(g_hInstance, IDS_ERROR_TITLE, tchTitle, sizeof(tchTitle) / sizeof(TCHAR));
    LoadString(g_hInstance, res, tchText, sizeof(tchText) / sizeof(TCHAR));
    wsprintf( tchErrorMessage , tchText , pBuffer );
    ::MessageBox(hwnd, tchErrorMessage, tchTitle, MB_OK | MB_ICONINFORMATION);
}


/* -------------------------------------------------------------------------------
 * Custom UI msg handler dealt with here
 * -------------------------------------------------------------------------------
 */
INT_PTR CALLBACK CustomUIDlg(HWND hwnd, UINT umsg, WPARAM wp, LPARAM lp)
{
    static BOOL s_fServerNameChanged;
    static BOOL s_fClusterNameChanged;
    static BOOL s_fOpaqueStringChanged;
    static BOOL s_fPreviousButtonState;

    CTSSessionDirectory *pCTssd;

    switch (umsg)
    {
        case WM_INITDIALOG:
        {
            pCTssd = ( CTSSessionDirectory * )lp;

            SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pCTssd );

            SendMessage( GetDlgItem( hwnd , IDC_EDIT_SERVERNAME ) ,
                    EM_LIMITTEXT ,
                    ( WPARAM )64 ,
                    0 );
            SendMessage( GetDlgItem( hwnd , IDC_EDIT_CLUSTERNAME ) ,
                    EM_LIMITTEXT ,
                    ( WPARAM )64 ,
                    0 );
            SendMessage( GetDlgItem( hwnd , IDC_EDIT_ACCOUNTNAME ) ,
                    EM_LIMITTEXT ,
                    ( WPARAM )64 ,
                    0 );
            SendMessage( GetDlgItem( hwnd , IDC_EDIT_PASSWORD ) ,
                    EM_LIMITTEXT ,
                    ( WPARAM )64 ,
                    0 );
                 
            LONG lRet;
            HKEY hKey;
            
            TCHAR szString[ 256 ];
            DWORD cbData = sizeof( szString );

            lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                    REG_TS_CLUSTERSETTINGS ,
                    0,
                    KEY_READ | KEY_WRITE , 
                    &hKey );
            if( lRet == ERROR_SUCCESS )
            {
                lRet = RegQueryValueEx(hKey ,
                        REG_TS_CLUSTER_STORESERVERNAME,
                        NULL , 
                        NULL ,
                        ( LPBYTE )szString , 
                        &cbData );
                if( lRet == ERROR_SUCCESS )
                {
                    SetWindowText( GetDlgItem( hwnd , IDC_EDIT_SERVERNAME ) , szString );
                }
            
                cbData = sizeof( szString );

                lRet = RegQueryValueEx(hKey,
                        REG_TS_CLUSTER_CLUSTERNAME,
                        NULL,
                        NULL,
                        (LPBYTE)szString,
                        &cbData);           
                if( lRet == ERROR_SUCCESS )
                {
                    SetWindowText(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), szString);
                }

                cbData = 0;                

                lRet = RegQueryValueEx( hKey ,
                        REG_TS_CLUSTER_OPAQUESETTINGS,
                        NULL , 
                        NULL ,
                        (LPBYTE)NULL,
                        &cbData);

                if( lRet == ERROR_SUCCESS )
                {
                    pCTssd->m_pszOpaqueString =  ( LPTSTR )LocalAlloc( LMEM_FIXED , cbData );

                    if( pCTssd->m_pszOpaqueString != NULL )
                    {
                        lRet = RegQueryValueEx( hKey ,
                            REG_TS_CLUSTER_OPAQUESETTINGS,
                            NULL , 
                            NULL ,
                            (LPBYTE)pCTssd->m_pszOpaqueString ,
                            &cbData );
                    }
                    else
                    {
                        lRet = ERROR_OUTOFMEMORY;
                    }
                }                    

                if( lRet == ERROR_SUCCESS )
                {
                    // jump to user_id
                    TCHAR tchUserId[64] = { 0 };
                    TCHAR tchPassword[64] = { 0 };

                    LPTSTR pszUserId = tchUserId;
                    LPTSTR pszPassword = tchPassword;
                    
                    FindSqlValue( pCTssd->m_pszOpaqueString , TEXT("User Id"), pszUserId );
                    
                    strtrim( &pszUserId );                    

                    FindSqlValue( pCTssd->m_pszOpaqueString , TEXT("Password"), pszPassword );

                    strtrim( &pszPassword );                    
                     
                    SetWindowText( GetDlgItem( hwnd , IDC_EDIT_ACCOUNTNAME ) , pszUserId );
                    SetWindowText( GetDlgItem( hwnd , IDC_EDIT_PASSWORD ) , pszPassword );
                } 

                RegCloseKey(hKey);
            }
            else
            {
                if( pCTssd != NULL )
                {
                    pCTssd->ErrorMessage( hwnd , IDS_ERROR_TEXT , ( DWORD )lRet );
                }
                
                EndDialog(hwnd, lRet);                
            }

            if( pCTssd != NULL )
            {
                BOOL bEnable;
                
                bEnable = pCTssd->IsSessionDirectoryEnabled();

                CheckDlgButton( hwnd , IDC_CHECK_ENABLE , bEnable ? BST_CHECKED : BST_UNCHECKED );
                
                s_fPreviousButtonState = bEnable;

                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_ACCOUNTNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_PASSWORD), bEnable);      
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_SQLNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_CLUSTERNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_SQLACCOUNT), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_SQLPWD), bEnable);
            }

            s_fServerNameChanged = FALSE;
            s_fClusterNameChanged = FALSE;
            s_fOpaqueStringChanged = FALSE;    
        }

        break;

                            
        case WM_COMMAND:
            if( LOWORD( wp ) == IDCANCEL )
            {
                pCTssd = ( CTSSessionDirectory * )GetWindowLongPtr( hwnd , DWLP_USER );

                if( pCTssd->m_pszOpaqueString != NULL )
                {
                    LocalFree( pCTssd->m_pszOpaqueString );
                }

                EndDialog(hwnd , 0);
            }
            else if( LOWORD( wp ) == IDOK )
            {
                BOOL bEnabled;

                DWORD dwRetStatus = 0;

                pCTssd = ( CTSSessionDirectory * )GetWindowLongPtr(hwnd, DWLP_USER);
                bEnabled = IsDlgButtonChecked( hwnd , IDC_CHECK_ENABLE ) == BST_CHECKED;

                if( bEnabled != s_fPreviousButtonState )
                {
                    DWORD dwStatus;

                    TRC1((TB,"EnableButtonChanged"));
                    dwStatus = pCTssd->SetSessionDirectoryState( bEnabled );
                    if( dwStatus != ERROR_SUCCESS )
                    {
                        return 0;
                    }

                    dwRetStatus = UPDATE_TERMSRV_SESSDIR;
                }

                if( s_fServerNameChanged || s_fClusterNameChanged || s_fOpaqueStringChanged )
                {
                    HKEY hKey;

                    LONG lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                            REG_TS_CLUSTERSETTINGS ,
                            0,
                            KEY_READ | KEY_WRITE , 
                            &hKey );
                    
                    if( lRet == ERROR_SUCCESS )
                    {
                        TCHAR szName[ 64 ];

                        if( s_fServerNameChanged )
                        {
                            TRC1((TB,"SQLServerNameChanged" )) ;
                    
                            GetWindowText( GetDlgItem( hwnd , IDC_EDIT_SERVERNAME ) , szName , sizeof( szName ) / sizeof( TCHAR )  );

                            RegSetValueEx( hKey ,
                                REG_TS_CLUSTER_STORESERVERNAME,
                                0,
                                REG_SZ,
                                ( CONST LPBYTE )szName ,
                                sizeof( szName ) );
                        }

                        if( s_fClusterNameChanged )
                        {
                            TRC1((TB,"ClusterNameChanged"));
                    
                            GetWindowText( GetDlgItem( hwnd , IDC_EDIT_CLUSTERNAME ) , szName , sizeof( szName ) / sizeof( TCHAR )  );

                            RegSetValueEx( hKey ,
                                REG_TS_CLUSTER_CLUSTERNAME,
                                0,
                                REG_SZ,
                                ( CONST LPBYTE )szName ,
                                sizeof( szName ) );
                        }
                        if( s_fOpaqueStringChanged )
                        {
                            TRC1((TB,"OpaqueStringChanged" )) ;  
                            
                            LPTSTR pszNewOpaqueString = NULL;

                            LPTSTR pszName = NULL;
                                                        
                            GetWindowText( GetDlgItem( hwnd , IDC_EDIT_ACCOUNTNAME ) , szName , sizeof( szName ) / sizeof( TCHAR )  );

                            pszName = szName;

                            strtrim( &pszName );

                            ModifySqlValue( &pCTssd->m_pszOpaqueString , L"User Id" , pszName );

                            GetWindowText( GetDlgItem( hwnd , IDC_EDIT_PASSWORD ) , szName , sizeof( szName ) / sizeof( TCHAR )  );

                            pszName = szName;

                            strtrim( &pszName );

                            if( ModifySqlValue( &pCTssd->m_pszOpaqueString , L"Password" , pszName ) != NULL )
                            {
                                RegSetValueEx( hKey ,
                                        REG_TS_CLUSTER_OPAQUESETTINGS,
                                        0,
                                        REG_SZ,
                                        ( CONST LPBYTE )pCTssd->m_pszOpaqueString ,
                                        lstrlen( pCTssd->m_pszOpaqueString ) * sizeof( TCHAR ) );
                            }
                        }

                        RegCloseKey(hKey);

                        dwRetStatus = UPDATE_TERMSRV_SESSDIR;
                    }
                    else
                    {
                        pCTssd->ErrorMessage(hwnd , IDS_ERROR_TEXT2 , (DWORD)lRet);
                        return 0;
                    }
                }

                if( pCTssd->m_pszOpaqueString != NULL )
                {
                    LocalFree( pCTssd->m_pszOpaqueString );
                }

                EndDialog( hwnd , ( INT_PTR )dwRetStatus );
            }
            else 
            {
                switch (HIWORD(wp)) 
                {            
                    case EN_CHANGE:
                        if( LOWORD( wp ) == IDC_EDIT_SERVERNAME )
                        {
                            s_fServerNameChanged = TRUE;
                        }
                        else if( LOWORD( wp ) == IDC_EDIT_CLUSTERNAME )
                        {
                            s_fClusterNameChanged = TRUE;
                        }
                        else if( LOWORD( wp ) == IDC_EDIT_ACCOUNTNAME || LOWORD( wp ) == IDC_EDIT_PASSWORD )
                        {
                            s_fOpaqueStringChanged = TRUE;
                        }                
                        break;

                    case BN_CLICKED:
                        if( LOWORD( wp ) == IDC_CHECK_ENABLE)
                        {
                            BOOL bEnable;

                            if( IsDlgButtonChecked( hwnd , IDC_CHECK_ENABLE ) == BST_CHECKED )
                            {
                                // enabled all controls
                                bEnable = TRUE;
                            }
                            else
                            {
                                // disable all controls
                                bEnable = FALSE;                       
                            }
                            
                            // set flags 
                            s_fServerNameChanged = bEnable;
                            s_fClusterNameChanged = bEnable;
                            s_fOpaqueStringChanged = bEnable;

                            EnableWindow( GetDlgItem( hwnd , IDC_EDIT_SERVERNAME ) , bEnable );
                            EnableWindow( GetDlgItem( hwnd , IDC_EDIT_CLUSTERNAME ) , bEnable );
                            EnableWindow( GetDlgItem( hwnd , IDC_EDIT_ACCOUNTNAME ) , bEnable );
                            EnableWindow( GetDlgItem( hwnd , IDC_EDIT_PASSWORD ) , bEnable );      
                            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_SQLNAME ) , bEnable );
                            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_CLUSTERNAME ) , bEnable ); 
                            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_SQLACCOUNT ) , bEnable ); 
                            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_SQLPWD ) , bEnable ); 

                        }
                        break;
                }
            }        

            break;
    }

    return 0;
}

/********************************************************************************************
 [in ] lpString is the buffer containing the OpaqueSettings
 [in ] lpKeyName is the field name within the OpaqueSettings string
 [out] pszValue is a buffer that will contain the field name value

 Ret: None
 *******************************************************************************************/
void FindSqlValue(LPTSTR lpString, LPTSTR lpKeyName, LPTSTR pszValue)
{    
    int i;

    LPTSTR lpszStart = lpString;
    LPTSTR lpszTemp;

    UINT nKeyName;

    if( lpString != NULL && lpKeyName != NULL )
    {
        // find field name

        lpString = FindField( lpString , lpKeyName );

        if( *lpString != 0 )
        {
            i = 0;

            while( *lpString != 0 && *lpString != ( TCHAR )';' )
            {
                pszValue[i] = *lpString;
                i++;
                lpString++;            
            }

            pszValue[ i ] = 0;
        }
    }
}
        
/********************************************************************************************

 [in/out ] lpszOpaqueSettings is the buffer containing the OpaqueSettings
 [in ] lpKeyName is the field name within the OpaqueSettings string
 [in ] lpszNewValue contains the value that will replace the original value in the field

 Ret: A new OpaqueSetting string is constructed and must be freed with LocalFree

********************************************************************************************/
LPTSTR ModifySqlValue( LPTSTR* lppszOpaqueSettings , LPTSTR lpszKeyName , LPTSTR lpszNewValue )
{
    LPTSTR szEndPos       = NULL;
    LPTSTR szSecondPos    = NULL;
    LPTSTR pszNewSettings = NULL;
    LPTSTR lpszOpaqueSettings = *lppszOpaqueSettings;
    LPTSTR pszTempSettings = lpszOpaqueSettings;    
    UINT cbSize = 0;
    
    //a ) find value
    //b ) set pos2 after ';'
    //c ) set endpos1 after '='  to null
    //d ) create a buffer the length of first string + value + ; + second string
    //e ) strcpy first string + value + ; + second string
    //f ) return buffer

    if( lpszKeyName != NULL && lpszOpaqueSettings != NULL  )
    {
        
        szEndPos = FindField( lpszOpaqueSettings , lpszKeyName );

        if( *szEndPos != 0 )
        {            
            lpszOpaqueSettings = szEndPos;

            while( *lpszOpaqueSettings != 0 ) 
            {
                if( *lpszOpaqueSettings == ( TCHAR )';' )
                {
                    szSecondPos = lpszOpaqueSettings + 1;

                    break;
                }

                lpszOpaqueSettings++;
            }                   

            *szEndPos = 0;

            cbSize = lstrlen( pszTempSettings );

            cbSize += lstrlen( lpszNewValue );

            cbSize += 2; // for the semicolon and null

            if( szSecondPos != NULL && *szSecondPos != 0 )
            {
                cbSize += lstrlen( szSecondPos );
            }

            pszNewSettings = ( LPTSTR )LocalAlloc( LMEM_FIXED , cbSize * sizeof( TCHAR ) );

            if( pszNewSettings != NULL )
            {
                lstrcpy( pszNewSettings , pszTempSettings );

                lstrcat( pszNewSettings , lpszNewValue );

                lstrcat( pszNewSettings , TEXT( ";" ) );

                if( szSecondPos != NULL )
                {
                    lstrcat( pszNewSettings , szSecondPos );
                }

                LocalFree( pszTempSettings );

                *lppszOpaqueSettings = pszNewSettings;                                    
            }                    

        }
        else
        {
            // we're here because either the field name didnot exist or is unattainable
            // so we're slapping the field name and value at the end.

            cbSize = lstrlen( pszTempSettings );

            // add the size of the keyname and = and ;
            cbSize += lstrlen( lpszKeyName ) + 2;

            // add the new value
            cbSize += lstrlen( lpszNewValue ) + 1;

            pszNewSettings = ( LPTSTR )LocalAlloc( LMEM_FIXED , cbSize * sizeof( TCHAR ) );

            if( pszNewSettings != NULL )
            {
                lstrcpy( pszNewSettings , pszTempSettings );
                lstrcat( pszNewSettings , lpszKeyName );
                lstrcat( pszNewSettings , TEXT( "=" ) );
                lstrcat( pszNewSettings , lpszNewValue );
                lstrcat( pszNewSettings , TEXT( ";" ) );

                LocalFree( pszTempSettings );

                *lppszOpaqueSettings = pszNewSettings;                    
            }

        }
    }

    return pszNewSettings;
}

/********************************************************************************************
 FindField -- greps the OpaqueString passed in
   pszString and searches for field name in pszKeyName

  [ in ] pszString - OpaqueString
  [ in ] pszKeyName - field name

  ret: the position of the field value ( after the " = " )

 *******************************************************************************************/
LPTSTR FindField( LPTSTR pszString , LPTSTR pszKeyName )
{
    LPTSTR lpszStart = pszString;
    LPTSTR lpszTemp;
    LPTSTR lpszFieldName;

    UINT nKeyName;

    // find field name

    nKeyName = lstrlen( pszKeyName );

    while( *pszString != 0 )
    {
        while( *pszString != 0 && *pszString != ( TCHAR )'=' )
        {            
            pszString++;
        }

        // ok move backwards to check for name
        if( *pszString != 0 )
        {
            lpszTemp = pszString - 1;            

            while(  lpszStart <= lpszTemp )
            {               

                if( IsCharAlphaNumeric( *lpszTemp ) )
                {
                    break;
                }

                lpszTemp--;
            }

            lpszFieldName = ( lpszTemp - nKeyName + 1 );            

            if( lpszStart <= lpszFieldName && _tcsncicmp( lpszFieldName , pszKeyName , nKeyName ) == 0 )
            {
                // found the name skip '='                
                pszString++;
                break;
            }
        }

        pszString++;
    }

    return pszString;
}

/*********************************************************************************************
 * borrowed from Ting Cai (tingcai) with slight modifications
 * net\upnp\ssdp\common\ssdpparser\parser.cpp
 *
 ********************************************************************************************/    
VOID strtrim( TCHAR **pszStr)
{

    TCHAR *end;
    TCHAR *begin;

    begin = *pszStr;
    end = begin + lstrlen( *pszStr ) - 1;

    while (*begin == ( TCHAR )' ' || *begin == ( TCHAR )'\t')
    {
        begin++;
    }

    *pszStr = begin;

    while (*end == ( TCHAR )' ' || *end == ( TCHAR )'\t')
    {
        end--;
    }

    *(end+1) = '\0';    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdsql\trace.c ===
/****************************************************************************/
// trace.c
//
// Tracing code and definitions. See trace.h for other info.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#if DBG || defined(_DEBUG)

#include <windows.h>

#include "trace.h"


struct _ZoneInfo
{
    UINT32 Zone;
    char *Prefix;
} TRC_ZI[] =
{
    { Z_ASSERT, "TSSDSQL: !!! ASSERT: " },
    { Z_ERR,    "TSSDSQL: *** ERROR: " },
    { Z_WRN,    "TSSDSQL: Warning: " },
    { Z_TRC1,   "TSSDSQL: " },
    { Z_TRC2,   "TSSDSQL: " },
};
int NumTRC_ZIEntries = sizeof(TRC_ZI) / sizeof(struct _ZoneInfo);


// Globals.
UINT32 g_TraceMask = 0xFFFFFFFF;
char TB[1024];
char TB2[1024];


// Main output function.
void TracePrintZ(UINT32 ZoneFlag, char *OutString)
{
    int i;
    char *Prefix = "";

    // Find the zone information in the zone table.
    for (i = 0; i < NumTRC_ZIEntries; i++)
        if (TRC_ZI[i].Zone == ZoneFlag)
            Prefix = TRC_ZI[i].Prefix;

    // Now create the final string.
    wsprintfA(TB2, "%s%s\n", Prefix, OutString);

    // Send to output.
    OutputDebugStringA(TB2);
}



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdsql\server.cpp ===
/****************************************************************************/
// server.cpp
//
// General COM in-proc server framework code. TSSDI-specific code is
// designated by CLSID SPECIFIC comments.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <tchar.h>

#define INITGUID
#include <ole2.h>
#include <objbase.h>
#include <comutil.h>
#include <comdef.h>
#include <adoid.h>
#include <adoint.h>
#include <initguid.h>
#include <regapi.h>
#include "factory.h"
#include "trace.h"


/****************************************************************************/
// CLSID SPECIFIC section
//
// Provider-specific includes, unique CLSID, other info.
/****************************************************************************/

// For new components, this is the only area that needs to be modified in this
// file. Include any appropriate header files, a unique CLSID and update 
// the macros.

#include "tssd.h"

// {943e9311-c6a6-42cf-a591-e7ce8bb1de8d}
DEFINE_GUID(CLSID_TSSDSQL,
        0x943e9311, 0xc6a6, 0x42cf, 0xA5, 0x91, 0xe7, 0xce, 0x8b, 0xb1, 0xde, 0x8d);


#define IMPLEMENTED_CLSID       CLSID_TSSDSQL
#define SERVER_REGISTRY_COMMENT L"Terminal Server Session Directory Interface"
#define CPP_CLASS_NAME          CTSSessionDirectory
#define INTERFACE_CAST          (ITSSessionDirectory *)

/****************************************************************************/
// End CLSID SPECIFIC section
/****************************************************************************/


HINSTANCE g_hInstance;
long g_lLocks = 0;
long g_lObjects = 0;


/****************************************************************************/
// DllMain
//
// Standard DLL entry point. Returns FALSE on failure.
/****************************************************************************/
BOOL WINAPI DllMain(
        HINSTANCE hInstDLL,
        DWORD dwReason,
        LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hInstDLL;
        DisableThreadLibraryCalls(hInstDLL);
    }

    return TRUE;
}


/****************************************************************************/
// DllGetClassObject
//
// Standard OLE In-Process Server entry point to return an class factory
// instance.
//***************************************************************************
STDAPI DllGetClassObject(
        REFCLSID rclsid,
        REFIID riid,
        LPVOID *ppv)
{
    CClassFactory *pClassFactory;
    HRESULT hr;

    TRC2((TB,"DllGetClassObject"));

    // Verify the caller is asking for our type of object
    if (rclsid == IMPLEMENTED_CLSID) { 
        // Create the class factory.
        pClassFactory = new CClassFactory;
        if (pClassFactory != NULL) {
            hr = pClassFactory->QueryInterface(riid, ppv);
            if (FAILED(hr)) {
                ERR((TB,"DllGetClassObject: GUID not found"));
                delete pClassFactory;
            }
        }
        else {
            ERR((TB,"DllGetClassObject: Failed alloc class factory"));
            hr = E_OUTOFMEMORY;
        }
    }
    else {
        ERR((TB,"DllGetClassObject: Failed alloc class factory"));
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}


/****************************************************************************/
// DllCanUnloadNow
//
// Standard COM entry point for COM server shutdown request. Allows shutdown
// only if no outstanding objects or locks are present.
/****************************************************************************/
STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;

    if (g_lLocks == 0 && g_lObjects == 0)
        hr = S_OK;
    else
        hr = S_FALSE;

    return hr;
}


/****************************************************************************/
// DllRegisterServer
//
// Standard COM entry point for registering the server.
/****************************************************************************/
STDAPI DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];
    HRESULT hr = E_FAIL;

    // Get the DLL's filename
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    if( SUCCEEDED( StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr ) ) )
    {
        swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

        // Place it in registry.
        // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
        //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 :
        //        <no_name> : "path to DLL"
        //        ThreadingModel : "both"
        HKEY hKey;
        LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
        if (lRes == 0)
        {
            wchar_t *pName = SERVER_REGISTRY_COMMENT;
            RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *)pName,
                    wcslen(pName) * 2 + 2);

            HKEY hSubkey;
            lRes = RegCreateKeyW(hKey, L"InprocServer32", &hSubkey);

            RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path,
                    wcslen(Path) * 2 + 2);
            RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ,
                    (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

            RegCloseKey(hSubkey);
            RegCloseKey(hKey);            
            hr = S_OK;
        }

        CoTaskMemFree(pGuidStr);

        hr = HRESULT_FROM_WIN32( lRes );
    }

    return hr;  
}


/****************************************************************************/
// DllUnregisterServer
//
// Standard COM entry point for unregistering the server.
/****************************************************************************/
STDAPI DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];
    HRESULT hr = E_FAIL;

    if( SUCCEEDED( StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr) ) )
    {
        swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

        // Delete InProcServer32 subkey.
        LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
        if (!lRes) {
            RegDeleteKeyW(hKey, L"InprocServer32");
            RegCloseKey(hKey);

            // Delete CLSID GUID key.
            lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
            if (!lRes) {
                RegDeleteKeyW(hKey, pGuidStr);
                RegCloseKey(hKey);
            }
        }
        
        CoTaskMemFree(pGuidStr);

        hr = HRESULT_FROM_WIN32( lRes );
    }

    return hr;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\conmsg\conmsg.h ===
#if !defined(AFX_POWERMSG_H__38FB9C26_C63A_49DD_8BFA_743222A9DD44__INCLUDED_)
#define AFX_POWERMSG_H__38FB9C26_C63A_49DD_8BFA_743222A9DD44__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_POWERMSG_H__38FB9C26_C63A_49DD_8BFA_743222A9DD44__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\conmsg\conmsg.cpp ===
// ConMsg.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "resource.h"
#include "stdio.h"
#include "tchar.h"
#include "wtsapi32.h"
#include "winsta.h"

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];								// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];								// The title bar text

// Foward declarations of functions included in this code module:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE /* hPrevInstance*/,
                     LPSTR     /* lpCmdLine */,
                     int       nCmdShow)
{
 	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_POWERMSG, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// Perform application initialization:
	if (!InitInstance (hInstance, nCmdShow)) 
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_POWERMSG);

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return msg.wParam;
}



//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX);

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_POWERMSG);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= (LPCSTR)IDC_POWERMSG;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
	
   HWND hWnd;

   hInst = hInstance; // Store instance handle in our global variable

   hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);


   if (!hWnd)
   {
      return FALSE;
   }


   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

//   if (!SetTimer(hWnd, 23, 1500, NULL))
//		MessageBox(NULL, _T("Failed"), _T("Failed"), MB_OK);


   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	static HWND hChildWnd;
	LRESULT lResult;
	TCHAR szString[512];
	int iCount;
	static int iState = 0;
	DWORD dwSessionId; 
//	int iVal;
//	HWND hWnd2;

	switch (message)
	{
	case WM_CREATE:
		 lResult = DefWindowProc(hWnd, message, wParam, lParam);
  		 RECT rt;
		 GetClientRect(hWnd, &rt);
		 hChildWnd = CreateWindow("LISTBOX", szTitle, WS_CHILD | WS_VISIBLE,
					0, 0, rt.right - rt.left, rt.bottom - rt.top, hWnd, NULL, hInst, NULL);

		 srand( 25 );
 	   if (!SetTimer(hWnd, 23, 1500, NULL))
			MessageBox(NULL, _T("Failed"), _T("Failed"), MB_OK);


		 
		 return lResult;
		 break;

/*
	case WM_TIMER:
		   SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("Got Timer")));
//		   hWnd2 = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
//			   CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInst, NULL);
//		   ShowWindow(hWnd2, SW_SHOWDEFAULT);
//		   UpdateWindow(hWnd2);



		   iVal = rand() % 3;
		   switch (iVal)
		   {
		   case 0:
				PostMessage(hWnd, WM_COMMAND, ID_FILE_REGISTERALLSESSIONS, 0);
					break;
		   case 1:
				PostMessage(hWnd, WM_COMMAND, ID_FILE_REGISTERFORTHISSESSION, 0);
					break;
		   case 2:
				PostMessage(hWnd, WM_COMMAND, ID_FILE_UNREGISTER, 0);
					break;
		   }
		   break;
		
*/

	case WM_POWERBROADCAST:
		{
			switch (wParam)
			{
				case PBT_APMBATTERYLOW:
					SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("PBT_APMBATTERYLOW")));
					break;
				case PBT_APMOEMEVENT:
					SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("PBT_APMOEMEVENT")));
					break;
				case PBT_APMPOWERSTATUSCHANGE:
					SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("PBT_APMPOWERSTATUSCHANGE")));
					break;
				case PBT_APMQUERYSUSPEND:
					SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("PBT_APMQUERYSUSPEND")));
					break;
				case PBT_APMQUERYSUSPENDFAILED:
					SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("PBT_APMQUERYSUSPENDFAILED")));
					break;
				case PBT_APMRESUMEAUTOMATIC:
					SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("PBT_APMRESUMEAUTOMATIC")));
					break;
				case PBT_APMRESUMECRITICAL:
					SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("PBT_APMRESUMECRITICAL")));
					break;
				case PBT_APMRESUMESUSPEND:
					SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("PBT_APMRESUMESUSPEND")));
					break;
				case PBT_APMSUSPEND:
					SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("PBT_APMSUSPEND")));
					break;
			}
		}
		break;

		case WM_COMMAND:
			wmId    = LOWORD(wParam);
			wmEvent = HIWORD(wParam);
			// Parse the menu selections:
			switch (wmId)
			{
                case ID_FILE_REGISTERALLSESSIONS:
					OutputDebugString(TEXT("* ConMsg:calling WTSRegisterSessionNotification\n"));
                    if (WTSRegisterSessionNotification(hWnd, NOTIFY_FOR_ALL_SESSIONS))
					{
						iState = 2;
					}
					else
					{
						SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("ERROR:Registering for all sessions **failed**.")));
					}

					OutputDebugString(TEXT("* ConMsg:done with WTSRegisterSessionNotification\n"));
                    break;

                case ID_FILE_REGISTERFORTHISSESSION:
					OutputDebugString(TEXT("* ConMsg:calling WTSRegisterSessionNotification\n"));
					if (WTSRegisterSessionNotification(hWnd, NOTIFY_FOR_THIS_SESSION))
					{
						iState = 1;
					}
					else
					{
						SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("ERROR:Registered for this session **failed**.")));
					}

					OutputDebugString(TEXT("* ConMsg:done with WTSRegisterSessionNotification\n"));
                    break;

                case ID_FILE_UNREGISTER:
					OutputDebugString(TEXT("* ConMsg:calling WTSUnRegisterSessionNotification\n"));
                    if (WTSUnRegisterSessionNotification(hWnd))
					{
						iState = 0;
					}
					else
					{
						SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(_T("UNRegistered for this sessions **failed**.")));
					}
					OutputDebugString(TEXT("* ConMsg:done with WTSUnRegisterConsoleNotification\n"));
                    break;

				case ID_FILE_CLEANLOG:
					iCount = SendMessage(hChildWnd, LB_GETCOUNT , 0, 0);
					while (iCount != LB_ERR && iCount > 0)
					{
						SendMessage(hChildWnd, LB_DELETESTRING , 0, 0);
						iCount = SendMessage(hChildWnd, LB_GETCOUNT , 0, 0);
					}
					break;


				case IDM_EXIT:
				   DestroyWindow(hWnd);
				   iState = 3;
				   break;

                case IDM_GET_SESSIONSTATE:
                {
                    BOOL bLockedState;
                    DWORD ReturnLength;
                    if (!WinStationQueryInformation( SERVERNAME_CURRENT,
                                    LOGONID_CURRENT,
                                    WinStationLockedState,
                                    (PVOID)&bLockedState,
                                    sizeof(bLockedState),
                                    &ReturnLength))
                    {
                        _stprintf(szString, _T("WinStationQueryInformationfailed, LastError = %d"), GetLastError());
                        SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(szString));
                    }
                    else
                    {
                        _stprintf(szString, _T("WinStationQueryInformation Succeeded"));
                        SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(szString));
                        _stprintf(szString, _T("    LockedState = %s"), bLockedState ? _T("On") : _T("Off"));
                        SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(szString));
                    }

                }
                break;

                case IDM_SET_WELCOME_ON:
                {
                    BOOL bWelcomeOn = 1;
                    if (!WinStationSetInformation( SERVERNAME_CURRENT,
                                          LOGONID_CURRENT,
                                          WinStationLockedState,
                                          &bWelcomeOn, sizeof(bWelcomeOn)))

                    {

                        _stprintf(szString, _T("WinStationSetInformation failed, LastError = %d"), GetLastError());
                        SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(szString));
                    }
                    else
                    {
                        _stprintf(szString, _T("WinStationSetInformation succeeded"));
                        SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(szString));
                    }

                }
                break;

                case IDM_SET_WELCOME_OFF:
                {
                    BOOL bWelcomeOff = 0;
                    if (!WinStationSetInformation( SERVERNAME_CURRENT,
                                          LOGONID_CURRENT,
                                          WinStationLockedState,
                                          &bWelcomeOff, sizeof(bWelcomeOff)))

                    {

                        _stprintf(szString, _T("WinStationSetInformation failed, LastError = %d"), GetLastError());
                        SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(szString));
                    }
                    else
                    {
                        _stprintf(szString, _T("WinStationSetInformation succeeded"));
                        SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(szString));
                    }
                }

            break;

				default:
				   return DefWindowProc(hWnd, message, wParam, lParam);
			}

			switch (iState)
			{
			case 0:
					_tcscpy(szString, _T("UNRegistered for this sessions."));
					break;
			case 1:
					_tcscpy(szString, _T("Registered for this sessions."));
					break;

			case 2:
					_tcscpy(szString, _T("Registered for all sessions."));
					break;

			case 3:
			default:
				iState = 3;
			}

			if (iState != 3)
			{
				SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(szString));
			}

			break;

		case WM_DESTROY:
			PostQuitMessage(0);
			break;


		case WM_WTSSESSION_CHANGE:
			DWORD GetSessionId(LPARAM lParam);
			dwSessionId = GetSessionId(lParam);

            switch (wParam)
            {
                case WTS_CONSOLE_CONNECT:
				_stprintf(szString, _T("WTS_CONSOLE_CONNECT, Session Affected was %d"), dwSessionId);
                break;

                case WTS_CONSOLE_DISCONNECT:
				_stprintf(szString, _T("WTS_CONSOLE_DISCONNECT, Session Affected was %d"), dwSessionId);
                break;

                case WTS_REMOTE_CONNECT:
				_stprintf(szString, _T("WTS_REMOTE_CONNECT, Session Affected was %d"), dwSessionId);
                break;

                case WTS_REMOTE_DISCONNECT:
				_stprintf(szString, _T("WTS_REMOTE_DISCONNECT, Session Affected was %d"), dwSessionId);
                break;

                case WTS_SESSION_LOGON:
				_stprintf(szString, _T("WTS_SESSION_LOGON, Session Affected was %d"), dwSessionId);
                break;

                case WTS_SESSION_LOGOFF:
				_stprintf(szString, _T("WTS_SESSION_LOGOFF, Session Affected was %d"), dwSessionId);
                break;

                case WTS_SESSION_LOCK:
				_stprintf(szString, _T("WTS_SESSION_LOCK, Session Affected was %d"), dwSessionId);
                break;

                case WTS_SESSION_UNLOCK:
				_stprintf(szString, _T("WTS_SESSION_UNLOCK, Session Affected was %d"), dwSessionId);
                break;

                default:
				_stprintf(szString, _T("Unknown Notification Code!!!!, Session Affected was %d"), dwSessionId);

                break;

            }
			SendMessage(hChildWnd, LB_ADDSTRING, 0, LPARAM(szString));
            break;


		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}

// Mesage handler for about box.
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM /* lParam */)
{
	switch (message)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}

DWORD GetSessionId(LPARAM lParam)
{
	return lParam;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\sessdir\tssdsql\tssdsql.h ===
/****************************************************************************/
// tssdsql.h
//
// Terminal Server Session Directory Interface SQL provider header.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/
#ifndef __TSSDSQL_H
#define __TSSDSQL_H

#include <tchar.h>

#include "tssd.h"
#include "srvsetex.h"


/****************************************************************************/
// Defines
/****************************************************************************/

/****************************************************************************/
// Types
/****************************************************************************/

// CTSSessionDirectory
//
// C++ class instantiation of ITSSessionDirectory.
class CTSSessionDirectory : public ITSSessionDirectory , public IExtendServerSettings
{
    long m_RefCount;
    BSTR m_DBConnectStr;
    BSTR m_DBPwdStr;
    BSTR m_DBUserStr;

    ADOConnection *m_pConnection;
    DWORD m_ServerID;
    DWORD m_ClusterID;

    WCHAR m_LocalServerAddress[64];
    WCHAR m_ClusterName[64];

    // Private data for UI menus

    // WCHAR m_szDisableEnable[ 64 ];
    BOOL m_fEnabled;

    // Private utility functions.
    HRESULT AddADOInputDWORDParam(DWORD, PWSTR, ADOCommand *, ADOParameters *);
    HRESULT AddADOInputStringParam(PWSTR, PWSTR, ADOCommand *,
            ADOParameters *, BOOL = TRUE);
    HRESULT CreateADOStoredProcCommand(PWSTR, ADOCommand **, ADOParameters **);

    HRESULT ExecServerOnline();
    HRESULT ExecServerOffline();

    HRESULT OpenConnection();

public:
    CTSSessionDirectory();
    ~CTSSessionDirectory();

    // Standard COM methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, void **);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // ITSSessionDirectory COM interface
    HRESULT STDMETHODCALLTYPE Initialize(LPWSTR, LPWSTR, LPWSTR, LPWSTR,
            DWORD, DWORD (*)());
    HRESULT STDMETHODCALLTYPE Update(LPWSTR, LPWSTR, LPWSTR, LPWSTR, DWORD);
    HRESULT STDMETHODCALLTYPE GetUserDisconnectedSessions(LPWSTR, LPWSTR,
            DWORD __RPC_FAR *, TSSD_DisconnectedSessionInfo __RPC_FAR
            [TSSD_MaxDisconnectedSessions]);
    HRESULT STDMETHODCALLTYPE NotifyCreateLocalSession(
            TSSD_CreateSessionInfo __RPC_FAR *);
    HRESULT STDMETHODCALLTYPE NotifyDestroyLocalSession(DWORD);
    HRESULT STDMETHODCALLTYPE NotifyDisconnectLocalSession(DWORD, FILETIME);

    HRESULT STDMETHODCALLTYPE NotifyReconnectLocalSession(
            TSSD_ReconnectSessionInfo __RPC_FAR *);
    HRESULT STDMETHODCALLTYPE NotifyReconnectPending(WCHAR *);
    HRESULT STDMETHODCALLTYPE Repopulate(DWORD, TSSD_RepopulateSessionInfo *);


    // IExtendServerSettings COM interface
    STDMETHOD( GetAttributeName )( /* out */ WCHAR * pwszAttribName );
    STDMETHOD( GetDisplayableValueName )( /* out */WCHAR * pwszAttribValueName );
    STDMETHOD( InvokeUI )( /* in */ HWND hParent , /* out */ PDWORD pdwStatus );
    STDMETHOD( GetMenuItems )( /* out */ int * pcbItems , /* out */ PMENUEXTENSION *pMex );
    STDMETHOD( ExecMenuCmd )( /* in */ UINT cmd , /* in */ HWND hParent , /* out */ PDWORD pdwStatus );
    STDMETHOD( OnHelp )( /* out */ int *piRet );

    BOOL IsSessionDirectoryEnabled( );
    DWORD SetSessionDirectoryState( BOOL );
    void ErrorMessage( HWND hwnd , UINT res , DWORD );
    
public:

    LPTSTR m_pszOpaqueString;

};



#endif // __TSSDSQL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\comp\tscomp.cpp ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    tscomp.cpp

Abstract:

    This compatibility dll is used by winnt32.exe in order to decide
    whether the user need to be warned about Terminal Server installation on system and it
    impending removal

Author:

    Makarand Patwardhan (MakarP)  28-Sept-2000

Environment:

    compatibility dll for winnt32.exe

Notes:

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <comp.h>

#include "registry.h"
#include "tscomprc.h"


HINSTANCE	g_hinst;

// compatibility text and html for w2k upgrades.
TCHAR       TSCOMP_ERROR_HTML_FILE_5[]        = _T("compdata\\tscomp5.htm");
TCHAR       TSCOMP_ERROR_TEXT_FILE_5[]        = _T("compdata\\tscomp5.txt");

// compatibility text and html for ts4 upgrades.
TCHAR       TSCOMP_ERROR_HTML_FILE_4[]        = _T("compdata\\tscomp4.htm");
TCHAR       TSCOMP_ERROR_TEXT_FILE_4[]        = _T("compdata\\tscomp4.txt");

LPCTSTR     TS_ENABLED_VALUE                = _T("TSEnabled");
LPCTSTR     TS_APPCMP_VALUE                 = _T("TSAppCompat");
LPCTSTR     REG_CONTROL_TS_KEY              = _T("System\\CurrentControlSet\\Control\\Terminal Server");
LPCTSTR     REG_PRODUCT_VER_KEY             = _T("ProductVersion");

extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE   hInstance,
    DWORD       dwReasonForCall,
    LPVOID      lpReserved
    )
{
    BOOL    status = TRUE;
    
    switch( dwReasonForCall )
    {
    case DLL_PROCESS_ATTACH:
        g_hinst = hInstance;
	    DisableThreadLibraryCalls(hInstance);
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return status;
}


BOOL IsAppServerInstalled (BOOL *pbIsTS4)
{
    ASSERT(pbIsTS4);
    *pbIsTS4 = FALSE;


	CRegistry oRegTermsrv;
    DWORD dwError;
	if (ERROR_SUCCESS == oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY, KEY_READ))
    {
        DWORD cbVersion = 0;
        LPTSTR szVersion = NULL;

        //
        //	Determine if this is a TS 4.0 upgrade.
        //
        dwError = oRegTermsrv.ReadRegString(REG_PRODUCT_VER_KEY, &szVersion, &cbVersion);
        if (ERROR_SUCCESS == dwError)
        {
        	if ((_tcsicmp(szVersion, _T("5.1")) == 0) || (_tcsicmp(szVersion, _T("5.0")) == 0))
        	{
                DWORD dwValue;
                //
                // this is 50+ TS, now lets check if TS is enabled,
                //
                if (ERROR_SUCCESS == oRegTermsrv.ReadRegDWord(TS_ENABLED_VALUE, &dwValue) && dwValue == 1)
                {
                    //
                    // ts was enabled, check the ts mode.
                    //
                    if (ERROR_SUCCESS == oRegTermsrv.ReadRegDWord(TS_APPCMP_VALUE, &dwValue))
                    {
                        //
                        // for appserver mode we have this value 1.
                        //
                        return (dwValue == 1);
                    }
                    else
                    {
                        //
                        // failed to read mode key, this should not happen.
                        //
                        ASSERT(FALSE);

                        // lets us say that is not in AppServer mode.
                        return FALSE;
                    }
                }
                else
                {
                    //
                    // ts was not enabled, or we failed to get TSEnabled state.
                    // either way lets us say that is not in AppServer mode.
                    //
                    return FALSE;

                }

        	}
        	else if ((_tcsicmp(szVersion, _T("4.0")) == 0) || (_tcsicmp(szVersion, _T("2.10")) == 0))
        	{
                //
                // this is TS40 or similar upgrade,
                // it has only app server mode then.
                *pbIsTS4 = TRUE;
        		return TRUE;
        	}
        	else
        	{
                //
                // ummm, Cant determine the TS mode. this should not happen,
                //
                ASSERT(FALSE);

                //
                // could this be older thatn ts4 version?
                //
                *pbIsTS4 = TRUE;
                return TRUE;
        	}
        }
        else
        {
            //
            // ummm, Cant determine the TS mode. this should not happen,
            //
            ASSERT(FALSE);

            // lets us say that is not in AppServer mode.
        	return FALSE;
        }
    }
    else
    {
        // this is an upgrade from Non TS system
        return FALSE;
    }
}


BOOL WINAPI
TSCompatibilityCheck(
    IN PCOMPAIBILITYCALLBACK    CompatibilityCallback,
    IN LPVOID                   Context
    )

/*++

Routine Description:

    This routine is called by winnt32.exe in order to decide whether
    the user should be warn before upgrade because of Terminal Server
    in a Windows 2000 system or later.

Arguments:

    CompatibilityCallback   - Supplies the winnt32 callback

    Context                 - Supplies the compatibility context

Return Value:

    FALSE   if the installation can continue
    TRUE    if the user need to be warned

--*/

{
    // BUGBUG : does it work for ts4, test it.
    COMPATIBILITY_ENTRY ce;
    TCHAR description[100];


    BOOL bIsTS4 = FALSE;
    if (!IsAppServerInstalled(&bIsTS4))
    {
        // upgrade can go ahead.
        return FALSE;

    }

    //
    // otherwise warn about imminent switch to remote admin mode.
    //

    if (!LoadString(g_hinst, TSCOMP_STR_ABORT_DESCRIPTION, description, 100)) {
        description[0] = 0;
    }

    ZeroMemory((PVOID) &ce, sizeof(COMPATIBILITY_ENTRY));
    ce.Description = description;

    if (bIsTS4)
    {
        ce.HtmlName = TSCOMP_ERROR_HTML_FILE_4;
        ce.TextName = TSCOMP_ERROR_TEXT_FILE_4;
    }
    else
    {
        ce.HtmlName = TSCOMP_ERROR_HTML_FILE_5;
        ce.TextName = TSCOMP_ERROR_TEXT_FILE_5;
    }

    ce.RegKeyName = NULL;
    ce.RegValName = NULL;
    ce.RegValDataSize = 0;
    ce.RegValData = NULL;
    ce.SaveValue = NULL;
    ce.Flags = 0;
    CompatibilityCallback(&ce, Context);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\conmsg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// Local Header Files

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\conmsg\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	PowerMsg.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\conmsg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by conmsg.rc
//
#define IDC_MYICON                      2
#define IDD_POWERMSG_DIALOG             102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_POWERMSG                    107
#define IDI_SMALL                       108
#define IDC_POWERMSG                    109
#define IDR_MAINFRAME                   128
#define ID_FILE_REGISTERFORTHISSESSION  32771
#define ID_FILE_REGISTERALLSESSIONS     32772
#define ID_FILE_UNREGISTER              32773
#define ID_FILE_CLEANLOG                32774

#define IDM_GET_SESSIONSTATE            32775
#define IDM_SET_WELCOME_ON              32776
#define IDM_SET_WELCOME_OFF             32777
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32775
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\acl.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *  Acl.h
 *
 *  Routine to add the TERMINAL_SERVER_RID to any object.
 *
 *  Breen Hagan - 5/4/99
 */

#ifndef __TSOC_ACL_H__
#define __TSOC_ACL_H__

//
//  Includes
//

#include <aclapi.h>

//
//  Function Prototypes
//

BOOL
AddTerminalServerUserToSD(
    PSECURITY_DESCRIPTOR *ppSd,
    DWORD  NewAccess,
    PACL   *ppDacl
    );

#ifdef LATERMUCHLATER
BOOL
AddTerminalServerUserToObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    DWORD NewAccess
    );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\acl.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation


/*************************************************************************
*
* acl.c
*
* Generic routines to manage ACL's
*
* Author:  John Richardson 04/25/97
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "stdafx.h"
/*
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
*/

#include <windows.h>
#include <rpc.h>
#include <stdio.h>
#include <process.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>

#undef DBG
#define DBG 1
#define DBGTRACE 1

#define DbgPrint(x)
#if DBG
//ULONG
//DbgPrint(
//    PCH Format,
//    ...
//    );

#define DBGPRINT(x) DbgPrint(x)
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*
 * Forward references
 */
BOOL
xxxLookupAccountName(
    PWCHAR pSystemName,
    PWCHAR pAccountName,
    PSID   *ppSid
    );

BOOL
SelfRelativeToAbsoluteSD(
    PSECURITY_DESCRIPTOR SecurityDescriptorIn,
    PSECURITY_DESCRIPTOR *SecurityDescriptorOut,
    PULONG ReturnedLength
    );


/*****************************************************************************
 *
 *  AddTerminalServerUserToSD
 *
 *   Add the given user for the given domain to the security descriptor.
 *   The callers security descriptor may be re-allocated.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/
BOOL
AddTerminalServerUserToSD(
    PSECURITY_DESCRIPTOR *ppSd,
    DWORD  NewAccess,
    PACL   *ppDacl
    )
{
    ULONG i;
    BOOL Result;
    BOOL DaclPresent;
    BOOL DaclDefaulted;
    DWORD Length;
    DWORD NewAclLength;
    PACE_HEADER OldAce;
    PACE_HEADER NewAce;
    ACL_SIZE_INFORMATION AclInfo;
    PSID pSid = NULL;
    PACL Dacl = NULL;
    PACL NewDacl = NULL;
    PACL NewAceDacl = NULL;
    PSECURITY_DESCRIPTOR NewSD = NULL;
    PSECURITY_DESCRIPTOR OldSD = NULL;
    SID_IDENTIFIER_AUTHORITY SepNtAuthority = SECURITY_NT_AUTHORITY;

    OldSD = *ppSd;

    pSid = LocalAlloc(LMEM_FIXED, 1024);
    if (!pSid || !InitializeSid(pSid, &SepNtAuthority, 1))
    {
        return( FALSE );
    };

    *(GetSidSubAuthority(pSid, 0 )) = SECURITY_TERMINAL_SERVER_RID;


    /*
     * Convert SecurityDescriptor to absolute format. It generates
     * a new SecurityDescriptor for its output which we must free.
     */
    Result = SelfRelativeToAbsoluteSD( OldSD, &NewSD, NULL );
    if ( !Result ) {
        LOGMESSAGE1(_T("Could not convert to AbsoluteSD %d\n"),GetLastError());
        LocalFree( pSid );
        return( FALSE );
    }

    // Must get DACL pointer again from new (absolute) SD
    Result = GetSecurityDescriptorDacl(
                 NewSD,
                 &DaclPresent,
                 &Dacl,
                 &DaclDefaulted
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Could not get Dacl %d\n"),GetLastError());
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    //
    // If no DACL, no need to add the user since no DACL
    // means all accesss
    //
    if( !DaclPresent ) {
        LOGMESSAGE2(_T("SD has no DACL, Present %d, Defaulted %d\n"),DaclPresent,DaclDefaulted);
        LocalFree( pSid );
        LocalFree( NewSD );
        return( TRUE );
    }

    //
    // Code can return DaclPresent, but a NULL which means
    // a NULL Dacl is present. This allows all access to the object.
    //
    if( Dacl == NULL ) {
        LOGMESSAGE2(_T("SD has NULL DACL, Present %d, Defaulted %d\n"),DaclPresent,DaclDefaulted);
        LocalFree( pSid );
        LocalFree( NewSD );
        return( TRUE );
    }

    // Get the current ACL's size
    Result = GetAclInformation(
                 Dacl,
                 &AclInfo,
                 sizeof(AclInfo),
                 AclSizeInformation
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Error GetAclInformation %d\n"),GetLastError());
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    //
    // Create a new ACL to put the new access allowed ACE on
    // to get the right structures and sizes.
    //
    NewAclLength = sizeof(ACL) +
                   sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) +
                   GetLengthSid( pSid );

    NewAceDacl = (PACL) LocalAlloc( LMEM_FIXED, NewAclLength );
    if ( NewAceDacl == NULL ) {
        LOGMESSAGE1(_T("Error LocalAlloc %d bytes\n"),NewAclLength);
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Result = InitializeAcl( NewAceDacl, NewAclLength, ACL_REVISION );
    if( !Result ) {
        LOGMESSAGE1(_T("Error Initializing Acl %d\n"),GetLastError());
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Result = AddAccessAllowedAce(
                 NewAceDacl,
                 ACL_REVISION,
                 NewAccess,
                 pSid
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Error adding Ace %d\n"),GetLastError());
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    LOGMESSAGE1(_T("Added 0x%x Access to ACL\n"),NewAccess);

    Result = GetAce( NewAceDacl, 0, (void **)&NewAce );
    if( !Result ) {
        LOGMESSAGE1(_T("Error getting Ace %d\n"),GetLastError());
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    /* add CONTAINER_INHERIT_ACE TO AceFlags */
    NewAce->AceFlags |= CONTAINER_INHERIT_ACE;


    /*
     * Allocate new DACL and copy existing ACE list
     */
    Length = AclInfo.AclBytesInUse + NewAce->AceSize;
    NewDacl = (PACL) LocalAlloc( LMEM_FIXED, Length );
    if( NewDacl == NULL ) {
        LOGMESSAGE1(_T("Error LocalAlloc %d bytes\n"),Length);
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Result = InitializeAcl( NewDacl, Length, ACL_REVISION );
    if( !Result ) {
        LOGMESSAGE1(_T("Error Initializing Acl %d\n"),GetLastError());
        LocalFree( NewDacl );
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    /*
     * Insert new ACE at the front of the DACL
     */
    Result = AddAce( NewDacl, ACL_REVISION, 0, NewAce, NewAce->AceSize );
    if( !Result ) {
        LOGMESSAGE1(_T("Error Adding New Ace to Acl %d\n"),GetLastError());
        LocalFree( NewDacl );
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    /*
     * Now put the ACE's on the old Dacl to the new Dacl
     */
    for ( i = 0; i < AclInfo.AceCount; i++ ) {

        Result = GetAce( Dacl, i, (void **) &OldAce );
        if( !Result ) {
            LOGMESSAGE1(_T("Error getting old Ace from Acl %d\n"),GetLastError());
            LocalFree( NewDacl );
            LocalFree( NewAceDacl );
            LocalFree( pSid );
            LocalFree( NewSD );
            return( FALSE );
        }

        Result = AddAce( NewDacl, ACL_REVISION, i+1, OldAce, OldAce->AceSize );
        if( !Result ) {
            LOGMESSAGE1(_T("Error setting old Ace to Acl %d\n"),GetLastError());
            LocalFree( NewDacl );
            LocalFree( NewAceDacl );
            LocalFree( pSid );
            LocalFree( NewSD );
            return( FALSE );
        }
    }

    /*
     * Set new DACL for Security Descriptor
     */
    Result = SetSecurityDescriptorDacl(
                 NewSD,
                 TRUE,
                 NewDacl,
                 FALSE
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Error setting New Dacl to SD %d\n"),GetLastError());
        LocalFree( NewDacl );
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    // the DACL must be passed back so that it can be saved to the registry using the new
    // GetNamedSecurityInfo() func.
    *ppDacl = Dacl = NewDacl;


    // Release the callers old security descriptor
//    LocalFree( OldSD );


    // There was a bug in W2K such that keys created under our install hive had the 
    // incorrect DACL headers which caused the DACL to be basically open to all users
    // for full control.
    // The prolem was due to the wrong SD->Control flag which was NT4 style though ACLs
    // were in NT5 style
    SetSecurityDescriptorControl(NewSD,
                        SE_DACL_AUTO_INHERIT_REQ|SE_DACL_AUTO_INHERITED,
                        SE_DACL_AUTO_INHERIT_REQ|SE_DACL_AUTO_INHERITED);

    *ppSd = NewSD;

    // The new SD is in absolute format, so don't free the SID.
//  LocalFree( pSid );

    return( TRUE );
}

/*****************************************************************************
 *
 *  AddUserToSD
 *
 *   Add the given user for the given domain to the security descriptor.
 *   The callers security descriptor may be re-allocated.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
AddUserToSD(
    PSECURITY_DESCRIPTOR *ppSd,
    PWCHAR pAccount,
    PWCHAR pDomain,
    DWORD  NewAccess
    )
{
    ULONG i;
    BOOL Result;
    BOOL DaclPresent;
    BOOL DaclDefaulted;
    DWORD Length;
//    NET_API_STATUS Status;
    DWORD /*NewAceLength,*/ NewAclLength;
    PACE_HEADER OldAce;
    PACE_HEADER NewAce;
    ACL_SIZE_INFORMATION AclInfo;
    PWCHAR pDC = NULL;
    PSID pSid = NULL;
    PACL Dacl = NULL;
    PACL NewDacl = NULL;
    PACL NewAceDacl = NULL;
    PSECURITY_DESCRIPTOR NewSD = NULL;
    PSECURITY_DESCRIPTOR OldSD = NULL;

    OldSD = *ppSd;
/*
    // Get our domain controller
    Status = NetGetAnyDCName(
                 NULL,    // Local computer
                 pDomain,
                 (LPBYTE*)&pDC
                 );
    if( Status != NERR_Success ) {
        LOGMESSAGE2(_T("SUSERVER: Could not get domain controller %d for domain %ws\n"),Status,pDomain);
        return( FALSE );
    }
*/
    // Get Users SID
    Result  = xxxLookupAccountName(
                  pDomain,
                  pAccount,
                  &pSid
                  );
    if( !Result ) {
        LOGMESSAGE2(_T("SUSERVER: Could not get users SID %d, %ws\n"),GetLastError(),pAccount);
        NetApiBufferFree( pDC );
        return( FALSE );
    }

    NetApiBufferFree( pDC );

    /*
     * Convert SecurityDescriptor to absolute format. It generates
     * a new SecurityDescriptor for its output which we must free.
     */
    Result = SelfRelativeToAbsoluteSD( OldSD, &NewSD, NULL );
    if ( !Result ) {
        LOGMESSAGE1(_T("Could not convert to AbsoluteSD %d\n"),GetLastError());
        LocalFree( pSid );
        return( FALSE );
    }

    // Must get DACL pointer again from new (absolute) SD
    Result = GetSecurityDescriptorDacl(
                 NewSD,
                 &DaclPresent,
                 &Dacl,
                 &DaclDefaulted
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Could not get Dacl %d\n"),GetLastError());
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    //
    // If no DACL, no need to add the user since no DACL
    // means all accesss
    //
    if( !DaclPresent ) {
        LOGMESSAGE2(_T("SD has no DACL, Present %d, Defaulted %d\n"),DaclPresent,DaclDefaulted);
        LocalFree( pSid );
        LocalFree( NewSD );
        return( TRUE );
    }

    //
    // Code can return DaclPresent, but a NULL which means
    // a NULL Dacl is present. This allows all access to the object.
    //
    if( Dacl == NULL ) {
        LOGMESSAGE2(_T("SD has NULL DACL, Present %d, Defaulted %d\n"),DaclPresent,DaclDefaulted);
        LocalFree( pSid );
        LocalFree( NewSD );
        return( TRUE );
    }

    // Get the current ACL's size
    Result = GetAclInformation(
                 Dacl,
                 &AclInfo,
                 sizeof(AclInfo),
                 AclSizeInformation
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Error GetAclInformation %d\n"),GetLastError());
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    //
    // Create a new ACL to put the new access allowed ACE on
    // to get the right structures and sizes.
    //
    NewAclLength = sizeof(ACL) +
                   sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) +
                   GetLengthSid( pSid );

    NewAceDacl = (PACL) LocalAlloc( LMEM_FIXED, NewAclLength );
    if ( NewAceDacl == NULL ) {
        LOGMESSAGE1(_T("Error LocalAlloc %d bytes\n"),NewAclLength);
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Result = InitializeAcl( NewAceDacl, NewAclLength, ACL_REVISION );
    if( !Result ) {
        LOGMESSAGE1(_T("Error Initializing Acl %d\n"),GetLastError());
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Result = AddAccessAllowedAce(
                 NewAceDacl,
                 ACL_REVISION,
                 NewAccess,
                 pSid
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Error adding Ace %d\n"),GetLastError());
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    LOGMESSAGE1(_T("Added 0x%x Access to ACL\n"),NewAccess);

    Result = GetAce( NewAceDacl, 0, (void **)&NewAce );
    if( !Result ) {
        LOGMESSAGE1(_T("Error getting Ace %d\n"),GetLastError());
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    /* add CONTAINER_INHERIT_ACE TO AceFlags */
    NewAce->AceFlags |= CONTAINER_INHERIT_ACE;


    /*
     * Allocate new DACL and copy existing ACE list
     */
    Length = AclInfo.AclBytesInUse + NewAce->AceSize;
    NewDacl = (PACL) LocalAlloc( LMEM_FIXED, Length );
    if( NewDacl == NULL ) {
        LOGMESSAGE1(_T("Error LocalAlloc %d bytes\n"),Length);
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Result = InitializeAcl( NewDacl, Length, ACL_REVISION );
    if( !Result ) {
        LOGMESSAGE1(_T("Error Initializing Acl %d\n"),GetLastError());
        LocalFree( NewDacl );
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    /*
     * Insert new ACE at the front of the DACL
     */
    Result = AddAce( NewDacl, ACL_REVISION, 0, NewAce, NewAce->AceSize );
    if( !Result ) {
        LOGMESSAGE1(_T("Error Adding New Ace to Acl %d\n"),GetLastError());
        LocalFree( NewDacl );
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    /*
     * Now put the ACE's on the old Dacl to the new Dacl
     */
    for ( i = 0; i < AclInfo.AceCount; i++ ) {

        Result = GetAce( Dacl, i, (void **) &OldAce );
        if( !Result ) {
            LOGMESSAGE1(_T("Error getting old Ace from Acl %d\n"),GetLastError());
            LocalFree( NewDacl );
            LocalFree( NewAceDacl );
            LocalFree( pSid );
            LocalFree( NewSD );
            return( FALSE );
        }

        Result = AddAce( NewDacl, ACL_REVISION, i+1, OldAce, OldAce->AceSize );
        if( !Result ) {
            LOGMESSAGE1(_T("Error setting old Ace to Acl %d\n"),GetLastError());
            LocalFree( NewDacl );
            LocalFree( NewAceDacl );
            LocalFree( pSid );
            LocalFree( NewSD );
            return( FALSE );
        }
    }

    /*
     * Set new DACL for Security Descriptor
     */
    Result = SetSecurityDescriptorDacl(
                 NewSD,
                 TRUE,
                 NewDacl,
                 FALSE
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Error setting New Dacl to SD %d\n"),GetLastError());
        LocalFree( NewDacl );
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Dacl = NewDacl;

    // Release the callers old security descriptor
//    LocalFree( OldSD );

    *ppSd = NewSD;

    // The new SD is in absolute format, so don't free the SID.
//  LocalFree( pSid );

    return( TRUE );
}

/*******************************************************************************
 *
 * SelfRelativeToAbsoluteSD
 *
 *   Convert a Security Descriptor from self-relative format to absolute.
 *
 *  ENTRY:
 *    SecurityDescriptorIn (input)
 *      Pointer to self-relative SD to convert
 *    SecurityDescriptorIn (output)
 *      Pointer to location to return absolute SD
 *    ReturnLength (output)
 *      Pointer to location to return length of absolute SD
 *
 *  EXIT:
 *
 ******************************************************************************/

BOOL
SelfRelativeToAbsoluteSD(
    PSECURITY_DESCRIPTOR SecurityDescriptorIn,
    PSECURITY_DESCRIPTOR *SecurityDescriptorOut,
    PULONG ReturnedLength
    )
{
    BOOL Result;
    PACL pDacl, pSacl;
    PSID pOwner, pGroup;
    PSECURITY_DESCRIPTOR pSD;
    ULONG SdSize, DaclSize, SaclSize, OwnerSize, GroupSize;

    /*
     * Determine buffer size needed to convert self-relative SD to absolute.
     * We use try-except here since if the input security descriptor value
     * is sufficiently messed up, it is possible for this call to trap.
     */
	SdSize = DaclSize = SaclSize = OwnerSize = GroupSize = 0;

    __try {
        
        Result = MakeAbsoluteSD(
                     SecurityDescriptorIn,
                     NULL, &SdSize,
                     NULL, &DaclSize,
                     NULL, &SaclSize,
                     NULL, &OwnerSize,
                     NULL, &GroupSize
                     );

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        Result = FALSE;
    }

    if ( Result || (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ) {
        LOGMESSAGE1(_T("SUSERVER: SelfRelativeToAbsoluteSD, Error %d\n"),GetLastError());
        return( FALSE );
    }

    /*
     * Allocate memory for the absolute SD and setup various pointers
     */
    pSD = LocalAlloc( LMEM_FIXED, SdSize + DaclSize + SaclSize + OwnerSize + GroupSize );
    if ( pSD == NULL )
        return( FALSE );

    pDacl = (PACL)((PCHAR)pSD + SdSize);
    pSacl = (PACL)((PCHAR)pDacl + DaclSize);
    pOwner = (PSID)((PCHAR)pSacl + SaclSize);
    pGroup = (PSID)((PCHAR)pOwner + OwnerSize);

    /*
     * Now convert self-relative SD to absolute format.
     * We use try-except here since if the input security descriptor value
     * is sufficiently messed up, it is possible for this call to trap.
     */
    __try {
        Result = MakeAbsoluteSD(
                     SecurityDescriptorIn,
                     pSD, &SdSize,
                     pDacl, &DaclSize,
                     pSacl, &SaclSize,
                     pOwner, &OwnerSize,
                     pGroup, &GroupSize
                     );

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        Result = FALSE;
    }

    if ( !Result ) {
        LOGMESSAGE1(_T("SUSERVER: SelfRelativeToAbsoluteSD, Error %d\n"),GetLastError());
        LocalFree( pSD );
        return( FALSE );
    }

    *SecurityDescriptorOut = pSD;

    if ( ReturnedLength )
        *ReturnedLength = SdSize + DaclSize + SaclSize + OwnerSize + GroupSize;

    return( TRUE );
}

/*****************************************************************************
 *
 *  xxxLookupAccountName
 *
 *   Wrapper to lookup the SID for a given account name
 *
 *   Returns a pointer to the SID in newly allocated memory
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
xxxLookupAccountName(
    PWCHAR pSystemName,
    PWCHAR pAccountName,
    PSID   *ppSid
    )
{
    BOOL  rc;
    DWORD Size, DomainSize, Error;
    SID_NAME_USE Type;
    PWCHAR pDomain = NULL;
    PSID pSid = NULL;
    WCHAR Buf;

    Size = 0;
    DomainSize = 0;

    rc = LookupAccountNameW(
             pSystemName,
             pAccountName,
             &Buf,    // pSid
             &Size,
             &Buf,    // pDomain
             &DomainSize,
             &Type
             );

    if( rc ) {
        return( FALSE );
    }
    else {
        Error = GetLastError();
        if( Error != ERROR_INSUFFICIENT_BUFFER ) {
            return( FALSE );
        }

        pSid = LocalAlloc( LMEM_FIXED, Size );
        if( pSid == NULL ) {
            return( FALSE );            
        }

        pDomain = (WCHAR *)LocalAlloc( LMEM_FIXED, DomainSize*sizeof(WCHAR) );
        if( pDomain == NULL ) {
            LocalFree( pSid );
            return( FALSE );            
        }

        rc = LookupAccountNameW(
                 pSystemName,
                 pAccountName,
                 pSid,
                 &Size,
                 pDomain,
                 &DomainSize,
                 &Type
                 );

        if( !rc ) {
            LocalFree( pSid );
            LocalFree( pDomain );
            return( FALSE );
        }

        *ppSid = pSid;

        LocalFree( pDomain );
        return( TRUE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\cocpage.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *  COCPage.h
 *
 *  A base class for an optional component wizard page.
 */

#ifndef __TSOC_COCPAGE_H__
#define __TSOC_COCPAGE_H__

#include "stdafx.h"

class COCPageData
{
    friend class COCPage;

	public:

    //
    //  Constructor.
    //

		COCPageData		();

    //
    //  Standard functions.
    //

	BOOL WasPageActivated ();

	protected:
    
	BOOL m_fPageActivated;

};

class COCPage : public PROPSHEETPAGE
{
	public:

    //
    //  Constructor and destructor.
    //

	COCPage (IN COCPageData  *pPageData);

	~COCPage ();

    //
    //  Standard functions.
    //

	BOOL Initialize ();

	// most of the messages are handled by base class.
	// if you override this function, you might want to rerount the message to base class
	// for handling common messages.
	 virtual BOOL OnNotify (IN HWND hDlgWnd, IN WPARAM   wParam, IN LPARAM   lParam);

    //
    //  Callback functions.
    //

	static UINT CALLBACK PropSheetPageProc (IN HWND hWnd, IN UINT uMsg, IN LPPROPSHEETPAGE  pPsp);
	static INT_PTR CALLBACK PropertyPageDlgProc (IN HWND hDlgWnd, IN UINT uMsg, IN WPARAM wParam, IN LPARAM lParam);

protected:
    COCPageData*    m_pPageData;
    HWND            m_hDlgWnd;

	virtual BOOL	ApplyChanges();
	virtual BOOL    CanShow () = 0;

	virtual COCPageData* GetPageData () const;
	virtual UINT GetPageID () = 0;
	virtual UINT GetHeaderTitleResource () = 0;
	virtual UINT GetHeaderSubTitleResource () = 0;
	virtual VOID OnActivation ();
	virtual BOOL OnCommand (IN HWND hDlgWnd, IN WPARAM wParam, IN LPARAM lParam);
	virtual VOID OnDeactivation ();
	virtual BOOL OnInitDialog (IN HWND hDlgWnd, IN WPARAM wParam, IN LPARAM lParam);
	VOID SetDlgWnd (IN HWND hDlgWnd);
	virtual BOOL VerifyChanges ();
};

#endif // __TSOC_COCPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\cocpage.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *  COCPage.cpp
 *
 *  A base class for an optional component wizard page.
 */

#include "stdafx.h"
#include "COCPage.h"

/*
 *  Class COCPageData
 */

COCPageData::COCPageData ()
{
    m_fPageActivated = FALSE;
}

BOOL COCPageData::WasPageActivated ()
{
    return(m_fPageActivated);
}

COCPageData* COCPage::GetPageData () const
{
    return(m_pPageData);
}


/*
 *  Class COCPage
 */

COCPage::COCPage (IN COCPageData  *pPageData)
{
    ASSERT(pPageData);

    m_hDlgWnd = NULL;
    m_pPageData = pPageData;
}

COCPage::~COCPage ()
{
}

BOOL COCPage::Initialize ()
{
    dwFlags         = PSP_USECALLBACK;
    dwSize          = sizeof(PROPSHEETPAGE);
    hInstance       = GetInstance();
    lParam          = (LPARAM)this;
    pfnCallback     = PropSheetPageProc;
    pfnDlgProc      = PropertyPageDlgProc;
    pszTemplate     = MAKEINTRESOURCE(GetPageID());

    pszHeaderTitle = MAKEINTRESOURCE(GetHeaderTitleResource());
    if (pszHeaderTitle != NULL) 
	{
        dwFlags |= PSP_USEHEADERTITLE;
    }

    pszHeaderSubTitle = MAKEINTRESOURCE(GetHeaderSubTitleResource());
    if (pszHeaderSubTitle != NULL) 
	{
        dwFlags |= PSP_USEHEADERSUBTITLE;
    }

    return(pszTemplate != NULL ? TRUE : FALSE);
}

BOOL COCPage::OnNotify (IN HWND hDlgWnd, IN WPARAM /* wParam */, IN LPARAM lParam)
{
    BOOL fApplied;
    NMHDR *pnmh = (LPNMHDR) lParam;

    switch(pnmh->code) 
	{
    case PSN_SETACTIVE:
        GetPageData()->m_fPageActivated = CanShow();
        SetWindowLongPtr(hDlgWnd, DWLP_MSGRESULT, GetPageData()->m_fPageActivated ? 0 : -1);
        PropSheet_SetWizButtons(GetParent(hDlgWnd), PSWIZB_NEXT | PSWIZB_BACK);
        
		if (GetPageData()->m_fPageActivated) 
		{
            GetHelperRoutines().ShowHideWizardPage(GetHelperRoutines().OcManagerContext,
                                        TRUE);
            OnActivation ();
        }

		break;

    case PSN_WIZNEXT:
        fApplied = ApplyChanges();
        SetWindowLongPtr(hDlgWnd, DWLP_MSGRESULT, fApplied ? 0 : -1);
        break;

    case PSN_WIZBACK:
        OnDeactivation();
        SetWindowLongPtr(hDlgWnd, DWLP_MSGRESULT, 0);
        break;

    default:
        return(FALSE);

    }

    return(TRUE);
}

UINT CALLBACK COCPage::PropSheetPageProc (IN HWND /* hWnd */, IN UINT uMsg, IN LPPROPSHEETPAGE  pPsp)
{
    COCPage* pThis;

    ASSERT(pPsp != NULL);

    pThis = reinterpret_cast<COCPage*>(pPsp->lParam);
    ASSERT(pThis != NULL);

    switch(uMsg) 
	{
    case PSPCB_RELEASE:
        delete pThis;
    }

    return(1);
}

INT_PTR CALLBACK COCPage::PropertyPageDlgProc (IN HWND hDlgWnd, IN UINT uMsg, IN WPARAM wParam, IN LPARAM lParam)
{
    COCPage*    pDlg;

    if (uMsg == WM_INITDIALOG) 
	{
        pDlg = reinterpret_cast<COCPage*>(LPPROPSHEETPAGE(lParam)->lParam);
    } 
	else 
	{
        pDlg = reinterpret_cast<COCPage*>(GetWindowLongPtr(hDlgWnd, DWLP_USER));
    }

    if (pDlg == NULL) 
	{
        return(0);
    }

    switch(uMsg) 
	{
    case WM_INITDIALOG:
        pDlg->SetDlgWnd(hDlgWnd);
        SetWindowLongPtr(hDlgWnd, DWLP_USER, (LONG_PTR)pDlg);
        return(pDlg->OnInitDialog(hDlgWnd, wParam, lParam));

    case WM_NOTIFY:
        return(pDlg->OnNotify(hDlgWnd, wParam, lParam));

    case WM_COMMAND:
        return(pDlg->OnCommand(hDlgWnd, wParam, lParam));
    }

    return(0);
}


VOID COCPage::OnActivation ()
{
}

BOOL COCPage::OnCommand (IN HWND /* hDlgWnd */, IN WPARAM /* wParam */, IN LPARAM /* lParam */)
{
    return(TRUE);
}

VOID COCPage::OnDeactivation ()
{
}

BOOL COCPage::OnInitDialog(IN HWND /* hDlgWnd */, IN WPARAM /* wParam */, IN LPARAM /* lParam */ )
{
    return(TRUE);
}

BOOL COCPage::ApplyChanges ()
{
    return(TRUE);
}

VOID COCPage::SetDlgWnd (IN HWND hDlgWnd)
{
    m_hDlgWnd = hDlgWnd;
}

BOOL COCPage::VerifyChanges ()
{
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\conv.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    conv.h

Abstract:

    UNICODE / ASCII conversion macros

Author:

    Hakki T. Bostanci (hakkib) 5-Aug-1998

Revision History:

--*/

#ifndef USES_CONVERSION

// USES_CONVERSION must be defined in every function that uses the
// conversion macros

#define USES_CONVERSION int __nLength; PCWSTR __pUnicode; PCSTR __pAscii

//////////////////////////////////////////////////////////////////////////
//
// W2A
//
// Routine Description:
//   Converts a UNICODE string to ASCII. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          UNICODE string
//
// Return Value:
//   the converted ASCII string
//

#define W2A(pStr)								                \
												                \
	((__pUnicode = pStr) == 0 ? (PSTR) 0 : (	                \
												                \
	__nLength = WideCharToMultiByte(				            \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		0,										                \
		0,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pAscii = (PCSTR) _alloca(__nLength * sizeof(CHAR)),       \
												                \
	WideCharToMultiByte(						                \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		(PSTR) __pAscii,						                \
		__nLength,								                \
		0,										                \
		0										                \
	),											                \
												                \
	(PSTR) __pAscii))							                \


//////////////////////////////////////////////////////////////////////////
//
// A2W
//
// Routine Description:
//   Converts an ASCII string to UNICODE. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          ASCII string
//
// Return Value:
//   the converted UNICODE string
//

#define A2W(pStr)								                \
												                \
	((__pAscii = pStr) == 0 ? (PWSTR) 0 : (					    \
												                \
	__nLength = MultiByteToWideChar(				            \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pUnicode = (PCWSTR) _alloca(__nLength * sizeof(WCHAR)),	\
												                \
	MultiByteToWideChar(						                \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		(PWSTR) __pUnicode,							            \
		__nLength									            \
	),											                \
												                \
	(PWSTR) __pUnicode))							            \

//////////////////////////////////////////////////////////////////////////
//
// T2A, A2T, T2W, W2T
//
// Routine Description:
//   These macros expand to the corresponding correct form according to the
//   #definition of UNICODE. 
//
//   We use the cryptic form (__nLength, __pAscii, __pUnicode, pStr) to avoid 
//   the compiler warning "symbol defined but not used" due to the variables 
//   defined in USES_CONVERSION macro.
//

#ifdef UNICODE
	#define T2A(pStr) W2A(pStr)
	#define A2T(pStr) A2W(pStr)
	#define T2W(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define W2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2DA(pStr) W2A(pStr)
	#define A2DT(pStr) A2W(pStr)
	#define T2DW(pStr) _wcsdupa(pStr)
	#define W2DT(pStr) _wcsdupa(pStr)
#else //UNICODE
	#define T2A(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define A2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2W(pStr) A2W(pStr)
	#define W2T(pStr) W2A(pStr)
	#define T2DA(pStr) _strdupa(pStr)
	#define A2DT(pStr) _strdupa(pStr)
	#define T2DW(pStr) A2W(pStr)
	#define W2DT(pStr) W2A(pStr)
#endif //UNICODE


//////////////////////////////////////////////////////////////////////////
//
// _tcsdupa
//
// Routine Description:
//   Duplicates a string to a buffer allocated off the stack using _alloca
//
// Arguments:
//	 pStr          input string
//
// Return Value:
//   duplicated string
//

#define _wcsdupa(pStr)                                                  \
                                                                        \
    (__pAscii, (__pUnicode = pStr) == 0 ? (PWSTR) 0 : (                 \
                                                                        \
    __nLength = wcslen(__pUnicode) + 1,                                 \
                                                                        \
    wcscpy((PWSTR) _alloca(__nLength * sizeof(WCHAR)), __pUnicode)))    \


#define _strdupa(pStr)                                                  \
                                                                        \
    (__pUnicode, (__pAscii = pStr) == 0 ? (PSTR) 0 : (                  \
                                                                        \
    __nLength = strlen(__pAscii) + 1,                                   \
                                                                        \
    strcpy((PSTR) _alloca(__nLength * sizeof(CHAR)), __pAscii)))        \


#ifdef UNICODE 
#define _tcsdupa _wcsdupa
#else
#define _tcsdupa _strdupa
#endif


#endif //USES_CONVERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\constants.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// constants.cpp
#include "stdafx.h"

#ifndef __TSOC_CONSTANTS_H__
#define __TSOC_CONSTANTS_H__

extern LPCTSTR     TERMINAL_SERVER_THIS_VERSION;
extern LPCTSTR     TERMINAL_SERVER_NO_VERSION;

extern LPCTSTR     PRODUCT_SUITE_KEY;
extern LPCTSTR     SYSTEM_RDPWD_KEY;
extern LPCTSTR     TS_LANATABLE_KEY;
extern LPCTSTR     TS_VIDEO_KEY;
extern LPCTSTR     PRODUCT_SUITE_VALUE;
extern LPCTSTR     TS_PRODUCT_SUITE_STRING;
extern LPCTSTR     TS_ENABLED_VALUE;
extern LPCTSTR     TS_APPCMP_VALUE;

extern LPCTSTR     LOGFILE;
extern LPCTSTR     MODULENAME;

extern LPCTSTR     BASE_COMPONENT_NAME;
extern LPCTSTR     APPSRV_COMPONENT_NAME;

extern LPCTSTR      REMOTE_ADMIN_SERVER_X86;
extern LPCTSTR      APPSERVER_SERVER_X86;
extern LPCTSTR      TSDISABLED_SERVER_X86;
extern LPCTSTR      PERSONALTS_SERVER_X86;


extern LPCTSTR      REMOTE_ADMIN_SERVER_IA64;
extern LPCTSTR      APPSERVER_SERVER_IA64;
extern LPCTSTR      TSDISABLED_SERVER_IA64;
extern LPCTSTR      PERSONALTS_SERVER_IA64;

extern LPCTSTR     UPGRADE_FROM_40_SERVER_X86;
extern LPCTSTR     UPGRADE_FROM_50_SERVER_X86;
extern LPCTSTR     UPGRADE_FROM_50_SERVER_X86;
extern LPCTSTR     FRESH_INSTALL_SERVER_X86;
extern LPCTSTR     UPGRADE_FROM_51_SERVER_X86;

extern LPCTSTR     UPGRADE_FROM_40_SERVER_IA64;
extern LPCTSTR     UPGRADE_FROM_50_SERVER_IA64;
extern LPCTSTR     UPGRADE_FROM_50_SERVER_IA64;
extern LPCTSTR     FRESH_INSTALL_SERVER_IA64;
extern LPCTSTR     UPGRADE_FROM_51_SERVER_IA64;

extern LPCTSTR      REMOTE_ADMIN_PRO_X86;
extern LPCTSTR      APPSERVER_PRO_X86;
extern LPCTSTR      TSDISABLED_PRO_X86;
extern LPCTSTR      PERSONALTS_PRO_X86;

extern LPCTSTR      REMOTE_ADMIN_PRO_IA64;
extern LPCTSTR      APPSERVER_PRO_IA64;
extern LPCTSTR      TSDISABLED_PRO_IA64;
extern LPCTSTR      PERSONALTS_PRO_IA64;

// extern LPCTSTR     TOGGLE_ON_SECTION_PRO;
// extern LPCTSTR     TOGGLE_OFF_SECTION_PRO;

extern LPCTSTR     UPGRADE_FROM_40_PRO_X86;
extern LPCTSTR     UPGRADE_FROM_50_PRO_X86;
extern LPCTSTR     UPGRADE_FROM_51_PRO_X86;
extern LPCTSTR     FRESH_INSTALL_PRO_X86;

extern LPCTSTR     UPGRADE_FROM_40_PRO_IA64;
extern LPCTSTR     UPGRADE_FROM_50_PRO_IA64;
extern LPCTSTR     UPGRADE_FROM_51_PRO_IA64;
extern LPCTSTR     FRESH_INSTALL_PRO_IA64;


// extern LPCTSTR     SECURITY_APPSRV_SECTION;
// extern LPCTSTR     SECURITY_REMADM_SECTION;
// extern LPCTSTR     SECURITY_PRO_SECTION;


extern LPCTSTR     TSCLIENTS_INSTALL_SECTION_SERVER;
extern LPCTSTR     TSCLIENTS_UNINSTALL_SECTION_SERVER;

extern LPCTSTR     TSCLIENTS_INSTALL_SECTION_PRO;
extern LPCTSTR     TSCLIENTS_UNINSTALL_SECTION_PRO;

extern LPCTSTR     TSCLIENT_DIRECTORY;

extern LPCTSTR     TS_EVENT_SOURCE;

#define            TS_UNATTEND_SECTION          BASE_COMPONENT_NAME
extern LPCTSTR     TS_UNATTEND_APPSRVKEY;
extern LPCTSTR     TS_UNATTEND_PERMKEY;

extern LPCTSTR     TERMSRV_PACK_4_KEY;
extern LPCTSTR     TERMSRV_PACK_5_KEY;
extern LPCTSTR     TERMSRV_PACK_6_KEY;
extern LPCTSTR     TERMSRV_PACK_7_KEY;
extern LPCTSTR     TERMSRV_PACK_8_KEY;
extern LPCTSTR     SOFTWARE_UNINSTALL_KEY;

extern LPCTSTR     DENY_CONN_VALUE;
extern LPCTSTR     TS_ALLOW_CON_ENTRY;
extern LPCTSTR     TS_ALLOW_CON_ENTRY_2;
extern LPCTSTR     TS_LICENSING_MODE;

extern LPCTSTR     SVCHOSST_KEY;
extern LPCTSTR     NETSVCS_VAL;
extern LPCTSTR     TERMSERVICE;
extern LPCTSTR     TERMSVCS_VAL;
extern LPCTSTR     TERMSVCS_PARMS;
extern LPCTSTR     TERMSVCS_STACK;
extern LPCTSTR     SVCHOSST_TERMSRV_KEY;
extern LPCTSTR     TERMSERVICE_MULTISZ;


//
//  REGAPI.H creates a wide and an ansi version, instead of #ifdef'ing as
//  necessary.
//

#ifdef UNICODE
#define REG_CHGUSR_OPTION_KEY   CHANGEUSER_OPTION_REG_NAME
#define REG_CONTROL_TS_KEY      REG_CONTROL_TSERVER
#define REG_PRODUCT_VER_KEY     REG_CITRIX_PRODUCTVERSION
#define REG_SECURITY_VALUE      REG_SECURITY
#define REG_WINSTATION_KEY      WINSTATION_REG_NAME
#else
#define REG_CHGUSR_OPTION_KEY   CHANGEUSER_OPTION_REG_NAME_A
#define REG_CONTROL_TS_KEY      REG_CONTROL_TSERVER_A
#define REG_PRODUCT_VER_KEY     REG_CITRIX_PRODUCTVERSION_A
#define REG_SECURITY_VALUE      REG_SECURITY_A
#define REG_WINSTATION_KEY      WINSTATION_REG_NAME_A
#endif

#define REG_CONTROL_TS_LICENSING_KEY    TEXT("System\\CurrentControlSet\\Control\\Terminal Server\\Licensing Core")

#define REG_LICENSING_MODE_AC_ON        TEXT("PolicyAcOn")
#define REG_LICENSING_MODE_AC_OFF       TEXT("PolicyAcOff")


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\constants.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// constants.cpp
#include "stdafx.h"

LPCTSTR     TERMINAL_SERVER_THIS_VERSION    = _T("5.1");
LPCTSTR     TERMINAL_SERVER_NO_VERSION      = _T("0.0");

#ifdef UNICODE
LPCTSTR     PRODUCT_SUITE_KEY               = REG_CONTROL L"\\ProductOptions";
LPCTSTR     SYSTEM_RDPWD_KEY                = WD_REG_NAME L"\\rdpwd";
LPCTSTR     TS_LANATABLE_KEY                = REG_CONTROL_TSERVER L"\\LanaTable";
#else
LPCTSTR     PRODUCT_SUITE_KEY               = REG_CONTROL_A "\\ProductOptions";
LPCTSTR     SYSTEM_RDPWD_KEY                = WD_REG_NAME_A "\\rdpwd";
LPCTSTR     TS_LANATABLE_KEY                = REG_CONTROL_TSERVER_A "\\LanaTable";
#endif

LPCTSTR     TS_VIDEO_KEY                    = _T("VIDEO");
LPCTSTR     PRODUCT_SUITE_VALUE             = _T("ProductSuite");
LPCTSTR     TS_PRODUCT_SUITE_STRING         = _T("Terminal Server");
LPCTSTR     TS_ENABLED_VALUE                = _T("TSEnabled");
LPCTSTR     TS_APPCMP_VALUE                 = _T("TSAppCompat");

LPCTSTR     LOGFILE                         = _T("%SystemRoot%\\tsoc.log");
LPCTSTR     MODULENAME                      = _T("tsoc.dll");

LPCTSTR     BASE_COMPONENT_NAME             = _T("TerminalServices");
LPCTSTR     APPSRV_COMPONENT_NAME           = _T("TerminalServer");

LPCTSTR		REMOTE_ADMIN_SERVER_X86         = _T("RemoteAdmin.srv.x86");
LPCTSTR		APPSERVER_SERVER_X86            = _T("AppServer.srv.x86");
LPCTSTR		TSDISABLED_SERVER_X86           = _T("DisabledTS.srv.x86");
LPCTSTR		PERSONALTS_SERVER_X86           = _T("PersonalTS.srv.x86");

LPCTSTR		REMOTE_ADMIN_SERVER_IA64        = _T("RemoteAdmin.srv.ia64");
LPCTSTR		APPSERVER_SERVER_IA64           = _T("AppServer.srv.ia64");
LPCTSTR		TSDISABLED_SERVER_IA64          = _T("DisabledTS.srv.ia64");
LPCTSTR		PERSONALTS_SERVER_IA64          = _T("PersonalTS.srv.ia64");

LPCTSTR     UPGRADE_FROM_40_SERVER_X86      = _T("UpgradeFrom40Section.server.x86");
LPCTSTR     UPGRADE_FROM_50_SERVER_X86      = _T("UpgradeFrom50Section.server.x86");
LPCTSTR     UPGRADE_FROM_51_SERVER_X86      = _T("UpgradeFrom51Section.server.x86");
LPCTSTR     FRESH_INSTALL_SERVER_X86        = _T("FreshInstallSection.server.x86");

LPCTSTR     UPGRADE_FROM_40_SERVER_IA64     = _T("UpgradeFrom40Section.server.ia64");
LPCTSTR     UPGRADE_FROM_50_SERVER_IA64     = _T("UpgradeFrom50Section.server.ia64");
LPCTSTR     UPGRADE_FROM_51_SERVER_IA64     = _T("UpgradeFrom51Section.server.ia64");
LPCTSTR     FRESH_INSTALL_SERVER_IA64       = _T("FreshInstallSection.server.ia64");

LPCTSTR		REMOTE_ADMIN_PRO_X86            = _T("RemoteAdmin.pro.x86");
LPCTSTR		APPSERVER_PRO_X86               = _T("AppServer.pro.x86");
LPCTSTR		TSDISABLED_PRO_X86              = _T("DisabledTS.pro.x86");
LPCTSTR		PERSONALTS_PRO_X86              = _T("PersonalTS.pro.x86");

LPCTSTR		REMOTE_ADMIN_PRO_IA64           = _T("RemoteAdmin.pro.ia64");
LPCTSTR		APPSERVER_PRO_IA64              = _T("AppServer.pro.ia64");
LPCTSTR		TSDISABLED_PRO_IA64             = _T("DisabledTS.pro.ia64");
LPCTSTR		PERSONALTS_PRO_IA64             = _T("PersonalTS.pro.ia64");

LPCTSTR     UPGRADE_FROM_40_PRO_X86                 = _T("UpgradeFrom40Section.pro.x86");
LPCTSTR     UPGRADE_FROM_50_PRO_X86                 = _T("UpgradeFrom50Section.pro.x86");
LPCTSTR     UPGRADE_FROM_51_PRO_X86                 = _T("UpgradeFrom51Section.pro.x86");
LPCTSTR     FRESH_INSTALL_PRO_X86                   = _T("FreshInstallSection.pro.x86");

LPCTSTR     UPGRADE_FROM_40_PRO_IA64        = _T("UpgradeFrom40Section.pro.ia64");
LPCTSTR     UPGRADE_FROM_50_PRO_IA64        = _T("UpgradeFrom50Section.pro.ia64");
LPCTSTR     UPGRADE_FROM_51_PRO_IA64        = _T("UpgradeFrom51Section.pro.ia64");
LPCTSTR     FRESH_INSTALL_PRO_IA64          = _T("FreshInstallSection.pro.ia64");


// LPCTSTR     SECURITY_APPSRV_SECTION         = _T("TerminalServices.AppSrvDefaultSecurity");
// LPCTSTR     SECURITY_REMADM_SECTION         = _T("TerminalServices.RemAdmDefaultSecurity");
// LPCTSTR     SECURITY_PRO_SECTION            = _T("TerminalServices.ProDefaultSecurity");


LPCTSTR     TSCLIENTS_INSTALL_SECTION_SERVER       = _T("TSClientInstallSection.server");
LPCTSTR     TSCLIENTS_UNINSTALL_SECTION_SERVER     = _T("TSClientUninstallSection.server");

LPCTSTR     TSCLIENTS_INSTALL_SECTION_PRO   = _T("TSClientInstallSection.pro");
LPCTSTR     TSCLIENTS_UNINSTALL_SECTION_PRO = _T("TSClientUninstallSection.pro");

LPCTSTR     TS_UNATTEND_APPSRVKEY           = _T("TerminalServer");
LPCTSTR     TS_UNATTEND_PERMKEY             = _T("PermissionsSetting");
LPCTSTR     TSCLIENT_DIRECTORY              = _T("%SystemRoot%\\system32\\clients\\tsclient");

LPCTSTR     TS_EVENT_SOURCE                 = _T("TermService");

LPCTSTR     TERMSRV_PACK_4_KEY              = _T("Windows NT Terminal Server 4.0 Service Pack 4");
LPCTSTR     TERMSRV_PACK_5_KEY              = _T("Windows NT Terminal Server 4.0 Service Pack 5");
LPCTSTR     TERMSRV_PACK_6_KEY              = _T("Windows NT Terminal Server 4.0 Service Pack 6");
LPCTSTR     TERMSRV_PACK_7_KEY              = _T("Windows NT Terminal Server 4.0 Service Pack 7");
LPCTSTR     TERMSRV_PACK_8_KEY              = _T("Windows NT Terminal Server 4.0 Service Pack 8");

LPCTSTR     SOFTWARE_UNINSTALL_KEY          = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall");
LPCTSTR	    DENY_CONN_VALUE                 = _T("fDenyTSConnections");
LPCTSTR	    TS_ALLOW_CON_ENTRY              = _T("AllowConnections");
LPCTSTR	    TS_ALLOW_CON_ENTRY_2            = _T("AllowConnection");
LPCTSTR	    TS_LICENSING_MODE               = _T("LicensingMode");

LPCTSTR     SVCHOSST_KEY                    = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost");
LPCTSTR     TERMSVCS_VAL                    = _T("termsvcs");
LPCTSTR     NETSVCS_VAL                     = _T("netsvcs");
LPCTSTR     TERMSERVICE                     = _T("TermService");
LPCTSTR     TERMSERVICE_MULTISZ             = _T("TermService\0");
LPCTSTR     TERMSVCS_PARMS                  = _T("CoInitializeSecurityParam");
LPCTSTR     TERMSVCS_STACK                  = _T("DefaultRpcStackSize");
LPCTSTR     SVCHOSST_TERMSRV_KEY            = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost\\termsvcs");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\hydraoc.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Module Name:
 *
 *      hydraoc.h
 *
 *  Abstract:
 *
 *      Common Header file for the HydraOC Component.
 *      HydraOc Component is an optional component which installs Termainal Server (Hydra)
 *
 *  Author:
 *
 *
 *  Environment:
 *
 *    User Mode
 */

#ifndef _HYDRAOC_H_
#define _HYDRAOC_H_


#include "state.h"

DWORD IsStringInMultiString         (HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, BOOL *pbFound);
DWORD RemoveStringFromMultiString   (HKEY hkey, LPCTSTR szSuitekey, LPCTSTR szSuitevalue, LPCTSTR szAppend);
DWORD AppendStringToMultiString     (HKEY hkey, LPCTSTR szSuitekey, LPCTSTR szSuitevalue, LPCTSTR szAppend);
DWORD GetStringValue                (HINF hinf, LPCTSTR  section, LPCTSTR key,  LPTSTR outputbuffer, DWORD dwSize);
DWORD GetSectionToBeProcessed       (HINF hInf, LPTSTR section, LPCTSTR SubcomponentId);
BOOL  DoesHydraKeysExists           ();
BOOL  DisableNonRDPWinstations      ();
BOOL  UpgradeRdpWinstations         ();
BOOL  IsMetaFrameWinstation         (CRegistry *pRegWinstation);
BOOL  IsConsoleWinStation           (CRegistry *pRegWinstation);
BOOL  IsRdpWinStation               (CRegistry *pRegWinstation);
BOOL  UpdateRDPWinstation           (CRegistry *pRegWinstation);
BOOL  DisableWinStation             (CRegistry *pRegWinstation);
void TickGauge (DWORD  dwTickCount);
void TickComplete();

BOOL DisableInternetConnector ();

const int   S_SIZE                          = 256;
const int   MAX_PRODUCT_SUITE_SIZE          = 256;
const int   MAX_VERSION_STRING              = 256;
const UINT  COMPONENT_VERSION               = OCMANAGER_VERSION;

const UINT  REGSVR_ADDREMOVE                = 1;
const UINT  REGSVR_PROGRAM                  = 2;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\logmsg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// LogMsg.cpp: implementation of the LogMsg class.
//
//////////////////////////////////////////////////////////////////////

#define _LOGMESSAGE_CPP_

#include "stdafx.h"
#include "LogMsg.h"


DWORD TCharStringToAnsiString(const TCHAR *tsz ,char *asz);


// maks_todo: is there any standard file to be used for  logs.
//////////////////////////////////////////////////////////////////////
// constants
//////////////////////////////////////////////////////////////////////
const UINT        LOG_ENTRY_SIZE             = 1024;
const UINT        STAMP_SIZE                 = 1024;
LPCTSTR           UNINITIALIZED              = _T("uninitialized");


//////////////////////////////////////////////////////////////////////
// globals.
////////////////////////////////////////////////////////////////////////
LogMsg thelog(26);  // used by LOGMESSAGE macros.


//////////////////////////////////////////////////////////////////////
// Construction / destruction
////////////////////////////////////////////////////////////////////////
LogMsg::LogMsg(int value)
{
    m_temp = value;
    _tcscpy(m_szLogFile, UNINITIALIZED);
}

LogMsg::~LogMsg()
{
    LOGMESSAGE0(_T("********Terminating Log"));
}

/*--------------------------------------------------------------------------------------------------------
* DWORD LogMsg::Init(LPCTSTR szLogFile, LPCTSTR szLogModule)
* creates/opens the szLogFile for logging messages.
* must be called befour using the Log Function.
* -------------------------------------------------------------------------------------------------------*/
DWORD LogMsg::Init(LPCTSTR szLogFile, LPCTSTR szLogModule)
{
    USES_CONVERSION;
    ASSERT(szLogFile);
    ASSERT(szLogModule);

    // dont call this function twice.
    // maks_todo:why is the constructor not getting called?
    // maks_todo:enable this assert.
    //ASSERT(_tcscmp(m_szLogFile, UNINITIALIZED) == 0);

    ASSERT(_tcslen(szLogFile) < MAX_PATH);
    ASSERT(_tcslen(szLogModule) < MAX_PATH);

    _tcscpy(m_szLogFile, szLogFile);
    _tcscpy(m_szLogModule, szLogModule);


    // open the log file
    HANDLE hfile = CreateFile(m_szLogFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        hfile = CreateFile(m_szLogFile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {

        // lets prepare for writing to the file.
        SetFilePointer(hfile, 0, NULL, FILE_END);
        DWORD  bytes;

        // get the current time/date stamp.
        TCHAR   time[STAMP_SIZE];
        TCHAR   date[STAMP_SIZE];
        TCHAR   output_unicode[LOG_ENTRY_SIZE];

        _tstrdate(date);
        _tstrtime(time);


        _stprintf(output_unicode, _T("\r\n\r\n*******Initializing Message Log:%s %s %s\r\n"), m_szLogModule, date, time);
        ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);


        // TCharStringToAnsiString(output_unicode, output);

        WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);


        // now write some more info about the version etc.
        OSVERSIONINFO OsV;
        OsV.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&OsV)== 0)
        {
            // get version failed.
            _stprintf(output_unicode, _T("GetVersionEx failed, ErrrorCode = %lu\r\n"), GetLastError());

            ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);

            WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);

        }
        else
        {
            //
            // ok we have the version info, write it out
            //

            _stprintf(output_unicode, _T("*******Version:Major=%lu, Minor=%lu, Build=%lu, PlatForm=%lu, CSDVer=%s, %s\r\n\r\n"),
                OsV.dwMajorVersion,
                OsV.dwMinorVersion,
                OsV.dwBuildNumber,
                OsV.dwPlatformId,
                OsV.szCSDVersion,
#ifdef DBG
                _T("Checked")
#else
                _T("Free")
#endif
                );

            ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);

            WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);
        }

        CloseHandle(hfile);
    }

    return GetLastError();
}


/*--------------------------------------------------------------------------------------------------------
* void log(TCHAR *fmt, ...)
* writes message to the log file. (LOGFILE)
* -------------------------------------------------------------------------------------------------------*/
DWORD LogMsg::Log(LPCTSTR file, int line, TCHAR *fmt, ...)
{

    USES_CONVERSION;
    ASSERT(file);
    ASSERT(fmt);
    ASSERT(_tcscmp(m_szLogFile, UNINITIALIZED) != 0);

     // write down file and line info into the buffer..
    TCHAR   fileline_unicode[LOG_ENTRY_SIZE];

    // file is actually full path to the file.
    ASSERT(_tcschr(file, '\\'));

    // we want to print only file name not full path
    UINT uiFileLen = _tcslen(file);
    while (uiFileLen && *(file + uiFileLen - 1) != '\\')
    {
        uiFileLen--;
    }
    ASSERT(uiFileLen);

    _stprintf(fileline_unicode, _T("%s(%d)"), (file+uiFileLen), line);



    // create the output string
    TCHAR  output_unicode[LOG_ENTRY_SIZE];
    va_list vaList;
    va_start(vaList, fmt);
    _vstprintf(output_unicode, fmt, vaList);
    va_end(vaList);

    ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);


    // open the log file
    HANDLE hfile = CreateFile(m_szLogFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);

        DWORD  bytes;
        const LPCSTR CRLF = "\r\n";
        WriteFile(hfile, T2A(fileline_unicode), _tcslen(fileline_unicode), &bytes, NULL);
        WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);
        WriteFile(hfile, CRLF, strlen(CRLF) * sizeof(char), &bytes, NULL);

        CloseHandle(hfile);
    }

    return GetLastError();
}

/*--------------------------------------------------------------------------------------------------------
* TCharStringToAnsiString(const TCHAR *tsz ,char *asz)
* converts the given TCHAR * to char *
* -------------------------------------------------------------------------------------------------------*/

DWORD TCharStringToAnsiString(const TCHAR *tsz ,char *asz)
{

    ASSERT(tsz && asz);

#ifdef UNICODE
    DWORD count;

    count = WideCharToMultiByte(CP_ACP,
                                0,
                                tsz,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!count || count > STAMP_SIZE)
        return count;

    return WideCharToMultiByte(CP_ACP,
                               0,
                               tsz,
                               -1,
                               asz,
                               count,
                               NULL,
                               NULL);
#else
    _tcscpy(asz, tsz);
    return _tcslen(asz);
#endif
}



// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\logmsg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// LogMsg.h: interface for the LogMsg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_)
#define AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_
#define _LOGMESSAGE_INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class LogMsg
{

    

private:

    TCHAR m_szLogFile[MAX_PATH];
    TCHAR m_szLogModule[MAX_PATH];
    int m_temp;

public:
	
    
                LogMsg          (int value);
	virtual     ~LogMsg         ();

    DWORD       Init            (LPCTSTR szLogFile, LPCTSTR szLogModule);
    DWORD       Log             (LPCTSTR file, int line, TCHAR *fmt, ...);

 //   static LogMsg GetLogObject();

};

// instantiated in LogMsg.cpp.
#ifndef _LOGMESSAGE_CPP_

extern LogMsg thelog;

#endif

// maks_todo : how to make sure that we get compiler error if we use macro with fewer parameters when we should have used macro with more parameters ?
// for example : LOGERROR1(_T("Show Two Values %s, %s"), firstvalue, secondvalue) how to catch this error during compilation ?
#define LOGMESSAGEINIT(logfile, module)                 thelog.Init(logfile, module)
#define LOGMESSAGE0(msg)                                thelog.Log(_T(__FILE__), __LINE__, msg)
#define LOGMESSAGE1(msg, arg1)                          thelog.Log(_T(__FILE__), __LINE__, msg, arg1)
#define LOGMESSAGE2(msg, arg1, arg2)                    thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2)
#define LOGMESSAGE3(msg, arg1, arg2, arg3)              thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3)
#define LOGMESSAGE4(msg, arg1, arg2, arg3, arg4)        thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3, arg4)
#define LOGMESSAGE5(msg, arg1, arg2, arg3, arg4, arg5)  thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3, arg4, arg5)

#endif // !defined(AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\pages.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// pages.cpp
#include "stdafx.h"

#include "hydraoc.h"
#include "pages.h"


const WARNING_STRING_LENGTH = 1024;

LPCTSTR GetUninstallKey()   {return _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall");}

//
//  ModePage Class
//

AppSrvWarningPage::AppSrvWarningPage (COCPageData* pPageData) : COCPage(pPageData)
{
}

BOOL AppSrvWarningPage ::CanShow ()
{
    return (!StateObject.IsUnattended() && StateObject.IsAppServerSelected() && !StateObject.WasItAppServer());
}

BOOL AppSrvWarningPage::OnInitDialog (HWND /* hwndDlg */, WPARAM /* wParam */, LPARAM /* lParam */)
{
    HICON hIcon;

    hIcon = (HICON)LoadImage(
        GetInstance(),
        MAKEINTRESOURCE(IDI_SMALLWARN),
        IMAGE_ICON,
        0,
        0,
        0
        );
    ASSERT(hIcon != NULL);

    SendMessage(
        GetDlgItem(m_hDlgWnd, IDC_WARNING_ICON),
        STM_SETICON,
        (WPARAM)hIcon,
        (LPARAM)0
        );

    TCHAR szWarningString[WARNING_STRING_LENGTH];
    UINT uiWarningId = StateObject.IsFreshInstall() ? IDS_STRING_TSINSTALL_CLEAN : IDS_STRING_TSINSTALL_ARP;
    if (LoadString( GetInstance(), uiWarningId, szWarningString, WARNING_STRING_LENGTH ))
    {
        SetDlgItemText(m_hDlgWnd, IDC_WARNING_MSG, szWarningString);
    }

    return(TRUE);
}


UINT AppSrvWarningPage::GetHeaderTitleResource ()
{
    return IDS_STRING_APPSRV_WARN_TITLE;
}

UINT AppSrvWarningPage::GetHeaderSubTitleResource () 
{
    return IDS_STRING_APPSRV_WARN_SUBTITLE;
}


AppSrvUninstallpage::AppSrvUninstallpage (COCPageData* pPageData) : COCPage(pPageData)
{
}

BOOL AppSrvUninstallpage ::CanShow ()
{
    return ( StateObject.IsStandAlone() && !StateObject.IsUnattended() && !StateObject.IsAppServerSelected() && StateObject.WasItAppServer());
}

BOOL AppSrvUninstallpage::OnInitDialog (HWND /* hwndDlg */, WPARAM /* wParam */, LPARAM /* lParam */)
{
    HICON hIcon;

    hIcon = (HICON)LoadImage(
        GetInstance(),
        MAKEINTRESOURCE(IDI_SMALLWARN),
        IMAGE_ICON,
        0,
        0,
        0
        );
    ASSERT(hIcon != NULL);

    SendMessage(
        GetDlgItem(m_hDlgWnd, IDC_WARNING_ICON),
        STM_SETICON,
        (WPARAM)hIcon,
        (LPARAM)0
        );


    TCHAR szWarningString[WARNING_STRING_LENGTH];
    if (LoadString( GetInstance(), IDS_STRING_TSREMOVE, szWarningString, WARNING_STRING_LENGTH ))
    {
        SetDlgItemText(m_hDlgWnd, IDC_WARNING_MSG, szWarningString);
    }

    return(TRUE);
}


UINT AppSrvUninstallpage::GetHeaderTitleResource ()
{
    return IDS_STRING_APPSRV_UNINSTALL_WARN_TITLE;
}

UINT AppSrvUninstallpage::GetHeaderSubTitleResource () 
{
    return IDS_STRING_APPSRV_UNINSTALL_WARN_SUBTITLE;
}

//
//  DefSecPageData Class
//

DefSecPageData::DefSecPageData() : COCPageData()
{
    m_cArray = 0;
    m_pWinStationArray = NULL;
}

DefSecPageData::~DefSecPageData()
{
    CleanArray();
}

VOID DefSecPageData::CleanArray()
{
    if (m_pWinStationArray != NULL) 
	{
        for (UINT i = 0; i < m_cArray; i++) 
		{
            if (m_pWinStationArray[i] != NULL) 
			{
                LocalFree(m_pWinStationArray[i]);
            }
        }

        LocalFree(m_pWinStationArray);
        m_pWinStationArray = NULL;
    }

    m_cArray = 0;
}


BOOL DefSecPageData::AlocateWinstationsArray (UINT uiWinstationCount)
{
	if (m_pWinStationArray != NULL) 
	{
		CleanArray();
	}

	ASSERT(m_pWinStationArray == NULL);

	if (uiWinstationCount > 0)
	{

		m_pWinStationArray = (LPTSTR*)LocalAlloc(LPTR, uiWinstationCount * sizeof(LPTSTR));

		if (NULL == m_pWinStationArray)
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL DefSecPageData::AddWinstation (LPCTSTR pStr)
{
	ASSERT(NULL != m_pWinStationArray);
	ASSERT(pStr);

    LPTSTR pWinStation = (LPTSTR)LocalAlloc(LPTR, (_tcslen(pStr) + 1) * sizeof(TCHAR));

    if (pWinStation == NULL) 
	{
		return FALSE;
    } 
    
	_tcscpy(pWinStation, pStr);
	
    m_pWinStationArray[m_cArray] = pWinStation;
    m_cArray++;

	return TRUE;
}

//
//  DefaultSecurityPage Class
//

DefaultSecurityPage::DefaultSecurityPage(COCPageData* pPageData) : COCPage(pPageData)
{
    m_cWinStations = 0;
    m_hListView = NULL;
}

BOOL DefaultSecurityPage::CanShow ()
{
    return ((m_cWinStations > 0) && StateObject.IsTSEnableSelected() && StateObject.WasItAppServer() != StateObject.IsAppServerSelected() && !StateObject.IsUnattended());
}

BOOL DefaultSecurityPage::OnInitDialog (HWND /* hwndDlg */, WPARAM /* wParam */, LPARAM /* lParam */)
{
    LVCOLUMN lvColumn;
    RECT rc;

    m_hListView = GetDlgItem(m_hDlgWnd, IDC_SECURITY_LISTVIEW);
    ListView_SetExtendedListViewStyleEx(m_hListView, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES);

    GetClientRect(m_hListView , &rc);
    lvColumn.mask = LVCF_FMT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.cx = rc.right - rc.left - GetSystemMetrics(SM_CXHSCROLL) - 2;

    ListView_InsertColumn(m_hListView, 0, &lvColumn);
    PopulateWinStationList();

    return(TRUE);
}

VOID DefaultSecurityPage::OnActivation ()
{
	ASSERT(CanShow());
    if (StateObject.IsAppServerSelected()) 
	{
        ShowWindow(GetDlgItem(m_hDlgWnd, IDC_SECURITY_DEFAULT_1), SW_HIDE);
        ShowWindow(GetDlgItem(m_hDlgWnd, IDC_SECURITY_DEFAULT_2), SW_SHOW);
    } 
	else 
	{
        ShowWindow(GetDlgItem(m_hDlgWnd, IDC_SECURITY_DEFAULT_1), SW_SHOW);
        ShowWindow(GetDlgItem(m_hDlgWnd, IDC_SECURITY_DEFAULT_2), SW_HIDE);
    }

}

VOID DefaultSecurityPage::OnDeactivation ()
{
	GetPageData()->CleanArray();
}

BOOL DefaultSecurityPage::ApplyChanges ()
{

    //
    //  If this page has been processed, then the back button on a succeeding page
    //  is pressed and this page is returned to the screen, empty out the old
    //  information.
    //

	ASSERT(CanShow());
    if (m_cWinStations != 0) 
	{
        LOGMESSAGE1(_T("%d WinStations to verify."), m_cWinStations);

        //
        //  Allocate an array big enough to hold all items, even if some are not checked.
        //  If the allocation fails, set the array size to zero, and continue as if there
        //  is no error.
        //
		if (!GetPageData()->AlocateWinstationsArray(m_cWinStations))
		{
            LOGMESSAGE0(_T("Error: Out of Memory creating WinStation list."));
            return(TRUE);
        }

        for (UINT i = 0; i < m_cWinStations; i++) 
		{
            if (ListView_GetCheckState(m_hListView, i)) 
			{
                TCHAR  pStr[S_SIZE];

                LOGMESSAGE1(_T("Item %d checked"), i);

                ListView_GetItemText(m_hListView, i, 0, pStr, S_SIZE);
				if (!GetPageData()->AddWinstation (pStr))
				{
					LOGMESSAGE1(_T("Error: Out of Memory creating %s entry."), pStr);
				}
            } 
			else 
			{
                LOGMESSAGE1(_T("Item %d unchecked"), i);
            }
        }
    } 
	else 
	{
        LOGMESSAGE0(_T("No WinStations to verify."));
    }

    LOGMESSAGE0(_T("Default Security change-list made.\r\n\r\n"));

    return(TRUE);
}

UINT DefaultSecurityPage::GetHeaderTitleResource ()
{
    return IDS_STRING_SEC_PAGE_HEADER_TITLE;
}

UINT DefaultSecurityPage::GetHeaderSubTitleResource ()
{
    return IDS_STRING_SEC_PAGE_HEADER_SUBTITLE;
}

DefSecPageData* DefaultSecurityPage::GetPageData()
{
    return(static_cast <DefSecPageData *> (COCPage::GetPageData()));
}

BOOL DefaultSecurityPage::PopulateWinStationList ()
{
    DWORD dwRet;
    ULONG cbWinStationName, cEntries, iWinStation;
    WINSTATIONNAME WinStationName;

    cbWinStationName = sizeof(WINSTATIONNAME);
    cEntries = 1;
    iWinStation = 0;
    m_cWinStations = 0;

    GetPageData()->CleanArray();

    LOGMESSAGE0(_T("Populating WinStation list."));

    while ((dwRet = RegWinStationEnumerate(
                        SERVERNAME_CURRENT,
                        &iWinStation,
                        &cEntries,
                        WinStationName,
                        &cbWinStationName)) == ERROR_SUCCESS)
    {
        LVITEM lvItem;
        ULONG cbSecDescLen = 0;

        //
        //  Skip the console winstation.
        //

        if (_tcsicmp(WinStationName, _T("Console")) == 0) 
		{
            LOGMESSAGE0(_T("Skipping Console winstation."));
            continue;
        }

        LOGMESSAGE1(_T("Checking %s for custom security."), WinStationName);

        //
        //  Check for custom security.
        //

        dwRet = RegWinStationQuerySecurity(
                    SERVERNAME_CURRENT,
                    WinStationName,
                    NULL,
                    0,
                    &cbSecDescLen
                    );
        if (dwRet == ERROR_INSUFFICIENT_BUFFER) 
		{

            //
            //  Insufficient buffer means the winstation has custom security.
            //  cbSecDescLen must be greater than zero.
            //

            ASSERT(cbSecDescLen > 0);
            dwRet = ERROR_SUCCESS;
            LOGMESSAGE1(_T("%s has custom security."), WinStationName);

			//
			//  The current winstation has custom security. Add it to the list.
			//

			lvItem.mask = LVIF_TEXT;
			lvItem.pszText = WinStationName;
			lvItem.iItem = m_cWinStations;
			lvItem.iSubItem = 0;

			ListView_InsertItem(m_hListView, &lvItem);
			ListView_SetCheckState(m_hListView, m_cWinStations, TRUE);

			m_cWinStations++;

        } 
		else 
		{
            LOGMESSAGE2(_T("%s does not have custom security: %ld"), WinStationName, dwRet);
        }
    }

    LOGMESSAGE0(_T("WinStation list populated.\r\n\r\n"));

    return(dwRet == ERROR_SUCCESS);
}


//
//  PermPage Class
//

PermPage::PermPage(COCPageData* pPageData) : COCPage(pPageData)
{
//  Link window registration is required if we are going to use any
// "Link WIndow" controls in our resources
//	if (!LinkWindow_RegisterClass())
//	{
//		LOGMESSAGE0(_T("ERROR:Failed to Register Link Window class"));
//	}
}

BOOL PermPage::CanShow()
{
    return(!StateObject.IsUnattended() && StateObject.IsAppServerSelected() && !StateObject.WasItAppServer() && StateObject.IsServer());
}

BOOL PermPage::OnInitDialog(HWND /* hwndDlg */, WPARAM /* wParam */, LPARAM /* lParam */)
{
    HICON hIcon;

    hIcon = (HICON)LoadImage(
        GetInstance(),
        MAKEINTRESOURCE(IDI_SMALLWARN),
        IMAGE_ICON,
        0,
        0,
        0
        );
    ASSERT(hIcon != NULL);

    SendMessage(
        GetDlgItem(m_hDlgWnd, IDC_WARNING_ICON),
        STM_SETICON,
        (WPARAM)hIcon,
        (LPARAM)0
        );

    return(TRUE);
}

VOID PermPage::OnActivation()
{
	ASSERT(CanShow());

    CheckRadioButton(
        m_hDlgWnd,
        IDC_RADIO_WIN2KPERM,
        IDC_RADIO_TS4PERM,
        StateObject.CurrentPermMode() == PERM_TS4 ? IDC_RADIO_TS4PERM : IDC_RADIO_WIN2KPERM
        );
}


BOOL PermPage::ApplyChanges()
{
	ASSERT(CanShow());
    if (IsDlgButtonChecked(m_hDlgWnd, IDC_RADIO_TS4PERM) == BST_CHECKED)
	{
		StateObject.SetCurrentPermMode (PERM_TS4);
    } 
	else
	{
		StateObject.SetCurrentPermMode (PERM_WIN2K);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\hydraoc.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      hydraoc.cpp
*
*  Abstract:
*
*      This file implements the optional component HydraOc for Terminal Server Installations.
*
*
*  Author:
*
*      Makarand Patwardhan  - March 6, 1998
*
*  Environment:
*
*    User Mode
* -------------------------------------------------------------------------------------------------------*/

#include "stdafx.h"
#include "hydraoc.h"
#include "pages.h"
#include "subtoggle.h"
#include "subcore.h"
#include "ocmanage.h"


#define INITGUID // must be before iadmw.h

#include "iadmw.h"      // Interface header
#include "iiscnfg.h"    // MD_ & IIS_MD_ defines

#define REASONABLE_TIMEOUT 1000

#define TRANS_ADD        0
#define TRANS_DEL        1
#define TRANS_PRINT_PATH 2
#define STRING_TS_WEBCLIENT_INSTALL _T("TSWebClient.Install")
#define STRING_TS_WEBCLIENT_UNINSTALL _T("TSWebClient.UnInstall")
#define STRING_TS_WEBCLIENT _T("TSWebClient")
#define STRING_TS_WEBCLIENT_DIR _T("\\web\\tsweb")

/*--------------------------------------------------------------------------------------------------------
* declarations.
* -------------------------------------------------------------------------------------------------------*/

//
// component manager message handlers.
//
DWORD OnPreinitialize               ();
DWORD OnInitComponent               (PSETUP_INIT_COMPONENT psc);
DWORD OnExtraRoutines               (PEXTRA_ROUTINES pExtraRoutines);
DWORD OnSetLanguage                 ();
DWORD OnQueryImage                  ();
DWORD OnSetupRequestPages           (WizardPagesType ePageType, SETUP_REQUEST_PAGES *pRequestPages);
DWORD OnQuerySelStateChange         (LPCTSTR SubcomponentId, UINT SelectionState,  LONG Flag);
DWORD OnCalcDiskSpace               (LPCTSTR SubcomponentId, DWORD addComponent, HDSKSPC dspace);
DWORD OnQueueFileOps                (LPCTSTR SubcomponentId, HSPFILEQ queue);
DWORD OnNotificationFromQueue       ();
DWORD OnQueryStepCount              (LPCTSTR SubComponentId);
DWORD OnCompleteInstallation        (LPCTSTR SubcomponentId);
DWORD OnCleanup                     ();
DWORD OnQueryState                  (LPCTSTR SubComponentId, UINT whichstate);
DWORD OnNeedMedia                   ();
DWORD OnAboutToCommitQueue          (LPCTSTR SubcomponentId);
DWORD OnQuerySkipPage               ();
DWORD OnWizardCreated               ();
DWORD_PTR WebClientSetup                (LPCTSTR, LPCTSTR, UINT, UINT_PTR, PVOID);

//                                     
// private utility functions.      
//                                    
BOOL  OpenMetabaseAndDoStuff(WCHAR *wszVDir, WCHAR *wszDir, int iTrans);
BOOL  GetVdirPhysicalPath(IMSAdminBase *pIMSAdminBase,WCHAR * wszVDir,WCHAR *wszStringPathToFill);
BOOL  AddVirtualDir(IMSAdminBase *pIMSAdminBase, WCHAR *wszVDir, WCHAR *wszDir);
BOOL  RemoveVirtualDir(IMSAdminBase *pIMSAdminBase, WCHAR *wszVDir);
INT   CheckifServiceExist(LPCTSTR lpServiceName);

/*--------------------------------------------------------------------------------------------------------
* defines
* -------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------
* constants
-------------------------------------------------------------------------------------------------------*/


//
// global variables and functions to access them.
//

SubCompToggle       *gpSubCompToggle    = NULL;
SubCompCoreTS       *gpSubCompCoreTS    = NULL;
COCPageData         *gpAppSrvUninstallPageData   = NULL;
DefSecPageData      *gpSecPageData      = NULL;
COCPageData         *gpPermPageData     = NULL;
COCPageData         *gpAppPageData		= NULL;


/*--------------------------------------------------------------------------------------------------------
* LPCTSTR GetOCFunctionName(UINT uiFunction)
* utility function for logging the oc messages.
* returns oc manager function name from funciton id.
* returns _T("Unknown Function") if its unknown.
* -------------------------------------------------------------------------------------------------------*/
LPCTSTR GetOCFunctionName(UINT uiFunction)
{
    struct
    {
        UINT  msg;
        TCHAR *desc;
    } gMsgs[] =
    {
        {OC_PREINITIALIZE,          TEXT("OC_PREINITIALIZE")},
        {OC_INIT_COMPONENT,         TEXT("OC_INIT_COMPONENT")},
        {OC_SET_LANGUAGE,           TEXT("OC_SET_LANGUAGE")},
        {OC_QUERY_IMAGE,            TEXT("OC_QUERY_IMAGE")},
        {OC_REQUEST_PAGES,          TEXT("OC_REQUEST_PAGES")},
        {OC_QUERY_CHANGE_SEL_STATE, TEXT("OC_QUERY_CHANGE_SEL_STATE")},
        {OC_CALC_DISK_SPACE,        TEXT("OC_CALC_DISK_SPACE")},
        {OC_QUEUE_FILE_OPS,         TEXT("OC_QUEUE_FILE_OPS")},
        {OC_NOTIFICATION_FROM_QUEUE,TEXT("OC_NOTIFICATION_FROM_QUEUE")},
        {OC_QUERY_STEP_COUNT,       TEXT("OC_QUERY_STEP_COUNT")},
        {OC_COMPLETE_INSTALLATION,  TEXT("OC_COMPLETE_INSTALLATION")},
        {OC_CLEANUP,                TEXT("OC_CLEANUP")},
        {OC_QUERY_STATE,            TEXT("OC_QUERY_STATE")},
        {OC_NEED_MEDIA,             TEXT("OC_NEED_MEDIA")},
        {OC_ABOUT_TO_COMMIT_QUEUE,  TEXT("OC_ABOUT_TO_COMMIT_QUEUE")},
        {OC_QUERY_SKIP_PAGE,        TEXT("OC_QUERY_SKIP_PAGE")},
        {OC_WIZARD_CREATED,         TEXT("OC_WIZARD_CREATED")},
        {OC_EXTRA_ROUTINES,         TEXT("OC_EXTRA_ROUTINES")}
    };
    
    for (int i = 0; i < sizeof(gMsgs) / sizeof(gMsgs[0]); i++)
    {
        if (gMsgs[i].msg == uiFunction)
            return gMsgs[i].desc;
    }
    
    return _T("Unknown Function");
}

/*--------------------------------------------------------------------------------------------------------
* called by CRT when _DllMainCRTStartup is the DLL entry point
* -------------------------------------------------------------------------------------------------------*/

BOOL WINAPI DllMain(IN HINSTANCE hinstance, IN DWORD reason, IN LPVOID    /*reserved*/    )
{
    SetInstance( hinstance );
    
    switch(reason)
    {
    case DLL_PROCESS_ATTACH:
        TCHAR szLogFile[MAX_PATH];
        ExpandEnvironmentStrings(LOGFILE, szLogFile, MAX_PATH);
        LOGMESSAGEINIT(szLogFile, MODULENAME);
        break;
        
    case DLL_THREAD_ATTACH:
    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
        break;
    }
    
    return(TRUE); // for successful process_attach
}


/*--------------------------------------------------------------------------------------------------------
*  This is our export function which will be called by OC Manager
* -------------------------------------------------------------------------------------------------------*/
DWORD_PTR HydraOc(
                  IN     LPCTSTR ComponentId,
                  IN     LPCTSTR SubcomponentId,
                  IN     UINT    Function,
                  IN     UINT_PTR  Param1,
                  IN OUT PVOID   Param2
                  )
{
    // we use this variable to track if we receive OnCompleteInstallation or not.
    // there is a problem with ocm which aborts all the components if any of them
    // does something wrong with file queue.
    static BOOL sbGotCompleteMessage = FALSE;
    
    LOGMESSAGE1(_T("Entering %s"), GetOCFunctionName(Function));
    LOGMESSAGE2(_T("Component=%s, SubComponent=%s"), ComponentId, SubcomponentId);
    
    DWORD_PTR rc;
    
    if (SubcomponentId &&  _tcsicmp(SubcomponentId,  _T("tswebClient")) == 0)
    {
        rc = WebClientSetup(ComponentId, SubcomponentId, Function, Param1,   Param2);
        LOGMESSAGE2(_T("%s Done. Returning %lu\r\n\r\n"), GetOCFunctionName(Function), rc);
        return rc;
    }
    
    // since we are supporting only one component.
    ASSERT(_tcsicmp(APPSRV_COMPONENT_NAME,  ComponentId) == 0);
    
    
    switch(Function)
    {
    case OC_PREINITIALIZE:
        rc = OnPreinitialize();
        break;
        
    case OC_INIT_COMPONENT:
        rc = OnInitComponent((PSETUP_INIT_COMPONENT)Param2);
        break;
        
    case OC_EXTRA_ROUTINES:
        rc = OnExtraRoutines((PEXTRA_ROUTINES)Param2);
        break;
        
    case OC_SET_LANGUAGE:
        rc = OnSetLanguage();
        break;
        
    case OC_QUERY_IMAGE:
        rc = OnQueryImage();
        break;
        
    case OC_REQUEST_PAGES:
        rc = OnSetupRequestPages(WizardPagesType(Param1),  PSETUP_REQUEST_PAGES (Param2));
        break;
        
    case OC_QUERY_CHANGE_SEL_STATE:
        rc = OnQuerySelStateChange(SubcomponentId, (UINT)Param1, LONG(ULONG_PTR(Param2)));
        break;
        
    case OC_CALC_DISK_SPACE:
        rc = OnCalcDiskSpace(SubcomponentId, (DWORD)Param1, Param2);
        break;
        
    case OC_QUEUE_FILE_OPS:
        rc = OnQueueFileOps(SubcomponentId, (HSPFILEQ)Param2);
        break;
        
    case OC_NOTIFICATION_FROM_QUEUE:
        rc = OnNotificationFromQueue();
        break;
        
    case OC_QUERY_STEP_COUNT:
        rc = OnQueryStepCount(SubcomponentId);
        break;
        
    case OC_COMPLETE_INSTALLATION:
        sbGotCompleteMessage = TRUE;
        
        rc = OnCompleteInstallation(SubcomponentId);
        break;
        
    case OC_CLEANUP:
        rc = OnCleanup();
        
        if (!sbGotCompleteMessage)
        {
            if (StateObject.IsStandAlone())
            {
                LOGMESSAGE0(_T("Error:StandAlone:TSOC Did not get OC_COMPLETE_INSTALLATION."));
            }
            else
            {
                LOGMESSAGE0(_T("Error:TSOC Did not get OC_COMPLETE_INSTALLATION."));
            }
        }
        break;
        
    case OC_QUERY_STATE:
        rc = OnQueryState(SubcomponentId, (UINT)Param1);
        break;
        
    case OC_NEED_MEDIA:
        rc = OnNeedMedia();
        break;
        
    case OC_ABOUT_TO_COMMIT_QUEUE:
        rc = OnAboutToCommitQueue(SubcomponentId);
        break;
        
    case OC_QUERY_SKIP_PAGE:
        rc = OnQuerySkipPage();
        break;
        
    case OC_WIZARD_CREATED:
        rc = OnWizardCreated();
        break;
        
    default:
        rc = 0; // it means we do not recognize this command.
        break;
    }
    
    LOGMESSAGE2(_T("%s Done. Returning %lu\r\n\r\n"), GetOCFunctionName(Function), rc);
    return rc;
}

/*--------------------------------------------------------------------------------------------------------
* OC Manager message handlers
* -------------------------------------------------------------------------------------------------------*/

DWORD OnPreinitialize(VOID)
{
#ifdef ANSI
    return OCFLAG_ANSI;
#else
    return OCFLAG_UNICODE;
#endif
    
}

/*--------------------------------------------------------------------------------------------------------
* OnInitComponent()
*
* handler for OC_INIT_COMPONENT
* -------------------------------------------------------------------------------------------------------*/

DWORD OnInitComponent(PSETUP_INIT_COMPONENT psc)
{
    ASSERT(psc);
    
    //
    // let the ocmanager know our version
    //
    
    psc->ComponentVersion = COMPONENT_VERSION;
    
    //
    // Is this component written for newer version than the oc manager ?
    //
    
    if (COMPONENT_VERSION  > psc->OCManagerVersion)
    {
        LOGMESSAGE2(_T("ERROR:OnInitComponent: COMPONENT_VERSION(%x) > psc->OCManagerVersion(%x)"), COMPONENT_VERSION, psc->OCManagerVersion);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }
    
    if (!StateObject.Initialize(psc))
    {
        return ERROR_CANCELLED; // due to ERROR_OUTOFMEMORY;
    }
    
    // if its standalone (!guimode) setup, We must have  Hydra in product suite by now.
    // ASSERT( StateObject.IsGuiModeSetup() || DoesHydraKeysExists() );
    
    
    
    //
    // now create our subcomponents
    //
    gpSubCompToggle = new SubCompToggle;
    gpSubCompCoreTS = new SubCompCoreTS;
    
    if (!gpSubCompToggle || !gpSubCompCoreTS)
        return ERROR_CANCELLED;
    
    //
    // if initialization of any of the sub component fails
    // fail the setup
    //
    
    if (!gpSubCompToggle->Initialize() ||
        !gpSubCompCoreTS->Initialize())
        
        return ERROR_CANCELLED;
    
    
    return NO_ERROR;
}

DWORD
OnExtraRoutines(
                PEXTRA_ROUTINES pExtraRoutines
                )
{
    ASSERT(pExtraRoutines);
    
    return(SetExtraRoutines(pExtraRoutines) ? ERROR_SUCCESS : ERROR_CANCELLED);
}

/*--------------------------------------------------------------------------------------------------------
* OnCalcDiskSpace()
*
* handler for OC_ON_CALC_DISK_SPACE
* -------------------------------------------------------------------------------------------------------*/

DWORD OnCalcDiskSpace(
                      LPCTSTR /* SubcomponentId */,
                      DWORD addComponent,
                      HDSKSPC dspace
                      )
{
    return gpSubCompCoreTS->OnCalcDiskSpace(addComponent, dspace);
}

/*--------------------------------------------------------------------------------------------------------
* OnQueueFileOps()
*
* handler for OC_QUEUE_FILE_OPS
* -------------------------------------------------------------------------------------------------------*/

DWORD OnQueueFileOps(LPCTSTR SubcomponentId, HSPFILEQ queue)
{
    if (SubcomponentId == NULL)
    {
        return gpSubCompCoreTS->OnQueueFiles( queue );
    }
    else if (_tcsicmp(SubcomponentId, APPSRV_COMPONENT_NAME) == 0)
    {
        return gpSubCompToggle->OnQueueFiles( queue );
    }
    else
    {
        ASSERT(FALSE);
        LOGMESSAGE1(_T("ERROR, Got a OnQueueFileOps with unknown SubComp(%s)"), SubcomponentId);
        return 0;
    }
    
}


/*--------------------------------------------------------------------------------------------------------
* OnCompleteInstallation
*
* handler for OC_COMPLETE_INSTALLATION
* -------------------------------------------------------------------------------------------------------*/

DWORD OnCompleteInstallation(LPCTSTR SubcomponentId)
{
    static BOOL sbStateUpdated = FALSE;
    
    if (!sbStateUpdated)
    {
        StateObject.UpdateState();
        sbStateUpdated = TRUE;
    }
    
    if (SubcomponentId == NULL)
    {
        return gpSubCompCoreTS->OnCompleteInstall();
    }
    else if (_tcsicmp(SubcomponentId, APPSRV_COMPONENT_NAME) == 0)
    {
        return gpSubCompToggle->OnCompleteInstall();
    }
    else
    {
        ASSERT(FALSE);
        LOGMESSAGE1(_T("ERROR, Got a Complete Installation with unknown SubComp(%s)"), SubcomponentId);
        return 0;
    }
}


/*--------------------------------------------------------------------------------------------------------
* OnSetLanguage()
*
* handler for OC_SET_LANGUAGE
* -------------------------------------------------------------------------------------------------------*/

DWORD OnSetLanguage()
{
    return false;
}

/*--------------------------------------------------------------------------------------------------------
* OnSetLanguage()
*
* handler for OC_SET_LANGUAGE
* -------------------------------------------------------------------------------------------------------*/

DWORD OnQueryImage()
{
    return NULL;
}

/*--------------------------------------------------------------------------------------------------------
* OnSetupRequestPages
*
* Prepares wizard pages and returns them to the OC Manager
* -------------------------------------------------------------------------------------------------------*/

DWORD OnSetupRequestPages (WizardPagesType ePageType, SETUP_REQUEST_PAGES *pRequestPages)
{
    if (ePageType == WizPagesEarly)
    {
        ASSERT(pRequestPages);
        const UINT uiPages = 4;
        
        // if we are provided sufficient space for our pages
        if (pRequestPages->MaxPages >= uiPages )
        {
            //
            //  Pages will be deleted in PSPCB_RELEASE in OCPage::PropSheetPageProc
            //
            
            gpAppPageData = new COCPageData;
            AppSrvWarningPage *pAppSrvWarnPage = new AppSrvWarningPage(gpAppPageData);
            
            gpSecPageData = new DefSecPageData;
            DefaultSecurityPage *pSecPage = new DefaultSecurityPage(gpSecPageData);
            
            gpPermPageData = new COCPageData;
            PermPage *pPermPage = new PermPage(gpPermPageData);
            
            gpAppSrvUninstallPageData = new COCPageData;
            AppSrvUninstallpage *pAppSrvUninstallPage = new  AppSrvUninstallpage(gpAppSrvUninstallPageData);
            
            if (pAppSrvWarnPage && pAppSrvWarnPage->Initialize() &&
                pSecPage     && pSecPage->Initialize()    &&
                pPermPage    && pPermPage->Initialize()   &&
                pAppSrvUninstallPage && pAppSrvUninstallPage->Initialize()
                )
            {
                ASSERT(pRequestPages->Pages);
                pRequestPages->Pages[0] = CreatePropertySheetPage((PROPSHEETPAGE *) pAppSrvWarnPage);
                pRequestPages->Pages[1] = CreatePropertySheetPage((PROPSHEETPAGE *) pSecPage);
                pRequestPages->Pages[2] = CreatePropertySheetPage((PROPSHEETPAGE *) pPermPage);
                pRequestPages->Pages[3] = CreatePropertySheetPage((PROPSHEETPAGE *) pAppSrvUninstallPage);
                
                ASSERT(pRequestPages->Pages[0]);
                ASSERT(pRequestPages->Pages[1]);
                ASSERT(pRequestPages->Pages[2]);
                ASSERT(pRequestPages->Pages[3]);
            }
            else
            {
                //
                // failed to allocate memory
                //
                
                if (gpAppPageData)
                    delete gpAppPageData;
                
                gpAppPageData = NULL;
                
                
                if (pAppSrvWarnPage)
                    delete pAppSrvWarnPage;
                
                pAppSrvWarnPage = NULL;
                
                if (gpSecPageData)
                    delete gpSecPageData;
                
                gpSecPageData = NULL;
                
                if (pSecPage)
                    delete pSecPage;
                
                pSecPage = NULL;
                
                if (gpPermPageData)
                    delete gpPermPageData;
                
                gpPermPageData = NULL;
                
                if (pPermPage)
                    delete pPermPage;
                
                pPermPage =NULL;
                
                if (gpAppSrvUninstallPageData)
                    delete gpAppSrvUninstallPageData;
                
                gpAppSrvUninstallPageData = NULL;
                
                if (pAppSrvUninstallPage)
                    delete pAppSrvUninstallPage;
                
                pAppSrvUninstallPage = NULL;
                
                SetLastError(ERROR_OUTOFMEMORY);
                return DWORD(-1);
            }
        }
        
        return uiPages;
    }
    
    return 0;
    
}

/*--------------------------------------------------------------------------------------------------------
* OnWizardCreated()
* -------------------------------------------------------------------------------------------------------*/

DWORD OnWizardCreated()
{
    return NO_ERROR;
}

/*--------------------------------------------------------------------------------------------------------
* OnQuerySkipPage()
*
* don't let the user deselect the sam component
* -------------------------------------------------------------------------------------------------------*/

DWORD OnQuerySkipPage()
{
    return false;
}

/*--------------------------------------------------------------------------------------------------------
* OnQuerySelStateChange(LPCTSTR SubcomponentId, UINT SelectionState,  LONG Flag);
*
* informs that user has changed the state of the component/subcomponent and asks approval
* -------------------------------------------------------------------------------------------------------*/

DWORD OnQuerySelStateChange(LPCTSTR SubcomponentId, UINT SelectionState,  LONG Flag)
{
    BOOL bNewState = SelectionState;
    BOOL bDirectSelection = Flag & OCQ_ACTUAL_SELECTION;
    LOGMESSAGE3(_T("OnQuerySelStateChange for %s, NewState = %d, DirectSelect = %s"), SubcomponentId, SelectionState, bDirectSelection ? _T("True") : _T("False"));
    
    return gpSubCompToggle->OnQuerySelStateChange(bNewState, bDirectSelection);
}

/*--------------------------------------------------------------------------------------------------------
* OnCleanup()
*
* handler for OC_CLEANUP
* -------------------------------------------------------------------------------------------------------*/

DWORD OnCleanup()
{
    
    if (gpAppPageData)
        delete gpAppPageData;
    
    if (gpSecPageData)
        delete gpSecPageData;
    
    if (gpPermPageData)
        delete gpPermPageData;
    
    if (gpAppSrvUninstallPageData)
        delete gpAppSrvUninstallPageData;
    
    if (gpSubCompToggle)
        delete gpSubCompToggle;
    
    if (gpSubCompCoreTS)
        delete gpSubCompCoreTS;
    
    // DestroySetupData();
    DestroyExtraRoutines();
    
    return NO_ERROR;
}

/*--------------------------------------------------------------------------------------------------------
* OnQueryState()
*
* handler for OC_QUERY_STATE
* -------------------------------------------------------------------------------------------------------*/

DWORD OnQueryState(LPCTSTR SubComponentId, UINT whichstate)
{
    ASSERT(OCSELSTATETYPE_ORIGINAL == whichstate ||
        OCSELSTATETYPE_CURRENT == whichstate ||
        OCSELSTATETYPE_FINAL == whichstate);
    
    TCHAR szState[256];
    
    switch (whichstate)
    {
    case OCSELSTATETYPE_ORIGINAL:
        _tcscpy(szState, _T("Original"));
        break;
    case OCSELSTATETYPE_CURRENT:
        _tcscpy(szState, _T("Current"));
        break;
    case OCSELSTATETYPE_FINAL:
        _tcscpy(szState, _T("Final"));
        break;
    default:
        ASSERT(FALSE);
        return ERROR_BAD_ARGUMENTS;
    }
    
    DWORD dwReturn = gpSubCompToggle->OnQueryState(whichstate);
    
    TCHAR szReturn[] = _T("SubcompUseOcManagerUknownState");
    switch (dwReturn)
    {
    case SubcompOn:
        _tcscpy(szReturn, _T("SubcompOn"));
        break;
    case SubcompUseOcManagerDefault:
        _tcscpy(szReturn, _T("SubcompUseOcManagerDefault"));
        break;
    case SubcompOff:
        _tcscpy(szReturn, _T("SubcompOff"));
        break;
    default:
        ASSERT(FALSE);
    }
    
    LOGMESSAGE3(_T("Query State Asked For %s, %s. Returning %s"), SubComponentId, szState, szReturn);
    
    return dwReturn;
}





/*--------------------------------------------------------------------------------------------------------
* OnNotificationFromQueue()
*
* handler for OC_NOTIFICATION_FROM_QUEUE
*
* NOTE: although this notification is defined,
* it is currently unimplemented in oc manager
* -------------------------------------------------------------------------------------------------------*/

DWORD OnNotificationFromQueue()
{
    return NO_ERROR;
}

/*--------------------------------------------------------------------------------------------------------
* OnQueryStepCount
*
* handler for OC_QUERY_STEP_COUNT
* -------------------------------------------------------------------------------------------------------*/

DWORD OnQueryStepCount(LPCTSTR /* SubcomponentId */)
{
    //
    // now return the ticks for the component
    //
    return gpSubCompCoreTS->OnQueryStepCount() + gpSubCompToggle->OnQueryStepCount();
    
}

/*--------------------------------------------------------------------------------------------------------
* OnNeedMedia()
*
* handler for OC_NEED_MEDIA
* -------------------------------------------------------------------------------------------------------*/

DWORD OnNeedMedia()
{
    return false;
}

/*--------------------------------------------------------------------------------------------------------
* OnAboutToCommitQueue()
*
* handler for OC_ABOUT_TO_COMMIT_QUEUE
* -------------------------------------------------------------------------------------------------------*/

DWORD OnAboutToCommitQueue(LPCTSTR /* SubcomponentId */)
{
    return NO_ERROR;
}


/*--------------------------------------------------------------------------------------------------------
* BOOL DoesHydraKeysExists()
*
* checks if Teminal server string exists in the product suite key.
* -------------------------------------------------------------------------------------------------------*/

BOOL DoesHydraKeysExists()
{
    BOOL bStringExists = FALSE;
    DWORD dw = IsStringInMultiString(
        HKEY_LOCAL_MACHINE,
        PRODUCT_SUITE_KEY,
        PRODUCT_SUITE_VALUE,
        TS_PRODUCT_SUITE_STRING,
        &bStringExists);
    
    return (dw == ERROR_SUCCESS) && bStringExists;
}



/*--------------------------------------------------------------------------------------------------------
* DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, BOOL *pbFound)
* checks if parameter string exists in given multistring.
* returns error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, BOOL *pbFound)
{
    ASSERT(szkey && *szkey);
    ASSERT(szvalue && *szvalue);
    ASSERT(szCheckForString&& *szCheckForString);
    ASSERT(*szkey != '\\');
    ASSERT(pbFound);
    
    // not yet found.
    *pbFound = FALSE;
    
    CRegistry reg;
    DWORD dwError = reg.OpenKey(hkey, szkey, KEY_READ);  // open up the required key.
    if (dwError == NO_ERROR)
    {
        LPTSTR szSuiteValue;
        DWORD dwSize;
        dwError = reg.ReadRegMultiString(szvalue, &szSuiteValue, &dwSize);
        if (dwError == NO_ERROR)
        {
            LPCTSTR pTemp = szSuiteValue;
            while(_tcslen(pTemp) > 0 )
            {
                if (_tcscmp(pTemp, szCheckForString) == 0)
                {
                    *pbFound = TRUE;
                    break;
                }
                
                pTemp += _tcslen(pTemp) + 1; // point to the next string within the multistring.
                if ( DWORD(pTemp - szSuiteValue) > (dwSize / sizeof(TCHAR)))
                    break; // temporary pointer passes the size of the szSuiteValue something is wrong with szSuiteValue.
            }
        }
    }
    
    return dwError;
    
}

/*--------------------------------------------------------------------------------------------------------
* DWORD AppendStringToMultiString(HKEY hkey, LPCTSTR szSuitekey, LPCTSTR szSuitevalue, LPCTSTR szAppend)
* appends given string to the given multi_sz value
* the given key / value must exist.
* returns error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD AppendStringToMultiString(HKEY hkey, LPCTSTR szSuitekey, LPCTSTR szSuitevalue, LPCTSTR szAppend)
{
    ASSERT(szSuitekey && *szSuitekey);
    ASSERT(szSuitevalue && *szSuitevalue);
    ASSERT(szAppend && *szAppend);
    ASSERT(*szSuitekey != '\\');
    
    CRegistry reg;
    // open the registry key.
    DWORD dwResult = reg.OpenKey(hkey, szSuitekey, KEY_READ | KEY_WRITE);
    if (dwResult == ERROR_SUCCESS)
    {
        DWORD dwSize = 0;
        LPTSTR strOriginalString = 0;
        
        // read our multi string
        dwResult = reg.ReadRegMultiString(szSuitevalue, &strOriginalString, &dwSize);
        
        if (dwResult == ERROR_SUCCESS)
        {
            // now calculate the Memory required for appending the string.
            // as dwOldSize is in bytes and we are using TCHARs
            DWORD dwMemReq = dwSize + ((_tcslen(szAppend) + 2)  * sizeof(TCHAR) / sizeof(BYTE));
            
            // NOTE: if dwSize is >= 1 we just require
            // dwSize + ((_tcslen(szAppend) + 1)  * sizeof(TCHAR) / sizeof(BYTE));
            // But in case its 0 we provide space for an additional terminating null
            
            LPTSTR szProductSuite = (LPTSTR ) new BYTE [dwMemReq];
            
            if (!szProductSuite)
            {
                return ERROR_OUTOFMEMORY;
            }
            
            CopyMemory(szProductSuite, strOriginalString, dwSize);
            
            // convert the size into TCHARs
            dwSize = dwSize * sizeof(BYTE) / sizeof(TCHAR);
            
            if (dwSize <= 2)
            {
                // there are no strings out there.
                _tcscpy(szProductSuite, szAppend);
                
                // new size including terminating null in tchar
                dwSize = _tcslen(szAppend) + 2;
            }
            else
            {
                // there are strings in its. so append our string before the terminating null.
                //  for example for this string "A\0B\0\0" dwSize == 5 and we are doing tcscat at "A\0B\0\0" + 4
                _tcscpy(szProductSuite + dwSize - 1, szAppend);
                
                // new size including terminating null in tchar
                dwSize += _tcslen(szAppend) + 1;
            }
            
            // now append a final terminating null character.
            *(szProductSuite + dwSize-1) = NULL;
            
            // reconvert size into bytes.
            dwSize *= sizeof(TCHAR) / sizeof(BYTE);
            
            // and finally write the final string.
            dwResult = reg.WriteRegMultiString(szSuitevalue, szProductSuite, dwSize);
            
            delete [] szProductSuite;
            
        }
    }
    
    return dwResult;
}


/*--------------------------------------------------------------------------------------------------------
* BOOL GetStringValue(HINF hinf, LPCTSTR  section, LPCTSTR key,  LPTSTR outputbuffer, DWORD dwSize)
* returns the given string value under given section.
* returns success
* -------------------------------------------------------------------------------------------------------*/
DWORD GetStringValue(HINF hinf, LPCTSTR  section, LPCTSTR key,  LPTSTR outputbuffer, DWORD dwSize)
{
    INFCONTEXT          context;
    
    BOOL rc = SetupFindFirstLine(
        hinf,
        section,
        key,
        &context
        );
    if (rc)
    {
        rc = SetupGetStringField(
            &context,
            1,
            outputbuffer,
            dwSize,
            &dwSize
            );
    }
    
    if (!rc)
        return GetLastError();
    else
        return ERROR_SUCCESS;
}



DWORD_PTR WebClientSetup(LPCTSTR ComponentId,
                         LPCTSTR SubcomponentId,
                         UINT    Function,
                         UINT_PTR  Param1,
                         PVOID   Param2)
{
    DWORD_PTR rc;
    BOOL bCurrentState, bOriginalState;
    static fTSWebWasActualSelected = FALSE;
    
    LOGMESSAGE1(_T("Entering %s"), _T("WebClient Setup"));
    
    switch(Function)
    {
    case OC_INIT_COMPONENT:
        return NO_ERROR;
        
    case OC_QUERY_STATE:
        return SubcompUseOcManagerDefault;
        break;
        
    case OC_SET_LANGUAGE:
        return FALSE;
        
    case OC_QUERY_IMAGE:
        rc = (DWORD_PTR)LoadImage(GetInstance(), MAKEINTRESOURCE(IDB_WEBCLIENT), IMAGE_BITMAP,
            0, 0, LR_DEFAULTCOLOR);
        LOGMESSAGE1(_T("Bitmap is: %d"), rc);
        return rc;
        
    case OC_QUERY_CHANGE_SEL_STATE:
        {
            BOOL rc = TRUE;
            BOOL fActualSelection = (BOOL)((INT_PTR)Param2 & OCQ_ACTUAL_SELECTION);
            BOOL fProposedState = (BOOL)Param1;

            //
            // Allow an direct selection or
            // allow indirect selection if it's unselect
            //
            if (fActualSelection || !fProposedState) {
                fTSWebWasActualSelected = fProposedState;
                return TRUE;
            }

            //
            // parent was selected: default is do not install subcomponent
            // 
            if (!fTSWebWasActualSelected) {
                return FALSE;
            } 
            //
            // we can be here if subcomponent was actually selected but 
            // OCM calls us for such event twice: when the component is actually
            // selected and then when it changes state of the parent.
            // So, in this case accept changes, but reset the flag.
            // We need to reset the flag for the scenario: select some 
            // subcomponents, return to the parent, unselect the parent and then
            // select parent again. In such case we have to put default again.
            //
            fTSWebWasActualSelected = FALSE;
            return rc;
            
        }
        break;
        
    case OC_CALC_DISK_SPACE:
        //rc = OnCalcDiskSpace(SubcomponentId, (DWORD)Param1, Param2);
        
        //_tcscpy(section, SubcomponentId);
        
        if ((DWORD)Param1)
        {
            rc = SetupAddInstallSectionToDiskSpaceList((HDSKSPC)Param2, GetComponentInfHandle(), NULL, 
                STRING_TS_WEBCLIENT_INSTALL, 0, 0);
        }
        else
        {
            rc = SetupRemoveInstallSectionFromDiskSpaceList((HDSKSPC)Param2, GetComponentInfHandle(), NULL, 
                STRING_TS_WEBCLIENT_INSTALL, 0, 0);
        }
        
        LOGMESSAGE1(_T("Query Disk Space return: %d"), rc);
        
        if (!rc)
            rc = GetLastError();
        else
            rc = NO_ERROR;
        break;
        
    case OC_QUEUE_FILE_OPS:
        rc = NO_ERROR;
        bOriginalState = GetHelperRoutines().QuerySelectionState(GetHelperRoutines().OcManagerContext, 
            STRING_TS_WEBCLIENT, OCSELSTATETYPE_ORIGINAL);
        bCurrentState = GetHelperRoutines().QuerySelectionState(GetHelperRoutines().OcManagerContext, 
            STRING_TS_WEBCLIENT, OCSELSTATETYPE_CURRENT);
        
        LOGMESSAGE2(_T("Original=%d, Current=%d"), bOriginalState, bCurrentState);
        
        if(bCurrentState)   {
            // Only copy files if it's machine upgrade or
            //  the component is not previously installed
            if (!StateObject.IsStandAlone() || !bOriginalState) {
                if (!SetupInstallFilesFromInfSection(GetComponentInfHandle(), NULL, (HSPFILEQ)Param2,
                    STRING_TS_WEBCLIENT_INSTALL, NULL, 0)) {
                    rc = GetLastError();
                    LOGMESSAGE2(_T("ERROR:OnQueueFileOps::SetupInstallFilesFromInfSection <%s> failed.GetLastError() = <%ul)"), SubcomponentId, rc);
                }
            }
            
            LOGMESSAGE1(_T("Copy files return: %d"), rc);
        }
        else    {
            if (!bOriginalState) {
                // Not installed before, do nothing
                return NO_ERROR;
            }
            if (!SetupInstallFilesFromInfSection(GetComponentInfHandle(), NULL, (HSPFILEQ)Param2,
                STRING_TS_WEBCLIENT_UNINSTALL, NULL, 0))
            {
                rc = GetLastError();
                LOGMESSAGE2(_T("ERROR:OnQueueFileOps::SetupInstallFilesFromInfSection <%s> failed.GetLastError() = <%ul)"), SubcomponentId, rc);
            }
            
            LOGMESSAGE1(_T("Remove files return: %d"), rc);
        }
        break;

        
    case OC_COMPLETE_INSTALLATION:
        bOriginalState = GetHelperRoutines().QuerySelectionState(GetHelperRoutines().OcManagerContext, _T("TSWebClient"), OCSELSTATETYPE_ORIGINAL);
        bCurrentState = GetHelperRoutines().QuerySelectionState(GetHelperRoutines().OcManagerContext, _T("TSWebClient"), OCSELSTATETYPE_CURRENT);
        LOGMESSAGE2(_T("Orinal=%d, Current=%d"), bOriginalState, bCurrentState);
        
        if(bOriginalState==bCurrentState) //state does not change
            return NO_ERROR;
        
        int iTrans;   //mark removing or adding tsweb dir
        int nLength;
        
        iTrans = 0;
        WCHAR wszVDirName[MAX_PATH];
        WCHAR wszDirPath[MAX_PATH];
        TCHAR szDirPath[MAX_PATH];
        TCHAR szVDirName[MAX_PATH];
        
        if (GetWindowsDirectory(szDirPath, MAX_PATH) == 0) {
            rc = GetLastError();
            return rc;
        }
        
        nLength = _tcsclen(szDirPath);
        if(_T('\\')==szDirPath[nLength-1])
            szDirPath[nLength-1]=_T('\0');
        _tcscat(szDirPath, STRING_TS_WEBCLIENT_DIR);
        
        if (LoadString(GetInstance(), IDS_STRING_TSWEBCLIENT_VIRTUALPATH, szVDirName, MAX_PATH) == 0)   {
            LOGMESSAGE0(_T("Can't load string  IDS_STRING_TSWEBCLIENT_VIRTUALPATH"));
            rc = GetLastError();;
        }
        
        LOGMESSAGE2(_T("Dir Path is: %s, Virtual Name is: %s"), szDirPath, szVDirName);
        
        if(bCurrentState)  //enable IIS directory
            iTrans = TRANS_ADD;
        else
            iTrans = TRANS_DEL;
        
#ifndef _UNICODE 
        MultiByteToWideChar(CP_ACP, 0, szDirPath, -1, (LPWSTR) wszDirPath, MAX_PATH);
        MultiByteToWideChar(CP_ACP, 0, szVDirName, -1, (LPWSTR) wszVDirName, MAX_PATH);
#else
        _tcscpy(wszDirPath, szDirPath);
        _tcscpy(wszVDirName, szVDirName);
#endif
        
        rc = OpenMetabaseAndDoStuff(wszVDirName, wszDirPath, iTrans)?0:1;
        
        LOGMESSAGE1(_T("Websetup complete, return is: %d"), rc);
        return rc;
    default:
        rc = NO_ERROR; // it means we do not recognize this command.
        break;
    }
    return rc;
}


BOOL
OpenMetabaseAndDoStuff(
                       WCHAR * wszVDir,
                       WCHAR * wszDir,
                       int iTrans)
{
    BOOL fRet = FALSE;
    HRESULT hr;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer
    WCHAR wszPrintString[MAX_PATH + MAX_PATH];
    
    // Make sure that IISADMIN service exists
    if (CheckifServiceExist(_T("IISADMIN")) != 0) 
    {
        LOGMESSAGE0(_T("IISADMIN service does not exist"));
        // We have to return TRUE here if IIS service does not exist
        return TRUE;
    }
    
    if( FAILED (hr = CoInitializeEx( NULL, COINIT_MULTITHREADED )) ||
        FAILED (hr = ::CoCreateInstance(CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void **)&pIMSAdminBase)))  
    {
        LOGMESSAGE1(_T("CoCreateInstance failed with error code %u"), hr);
        return FALSE;
    }
    
    switch (iTrans) {
    case TRANS_DEL:
        if(RemoveVirtualDir( pIMSAdminBase, wszVDir)) {
            
            hr = pIMSAdminBase->SaveData();
            
            if( SUCCEEDED( hr )) {
                fRet = TRUE;
            }
        }
        
        break;
    case TRANS_ADD:
        if(AddVirtualDir( pIMSAdminBase, wszVDir, wszDir)) {
            
            hr = pIMSAdminBase->SaveData();
            
            if( SUCCEEDED( hr )) {
                fRet = TRUE;
            }
        }
        break;
    default:
        break;
    }
    
    if (pIMSAdminBase) {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }
    
    CoUninitialize();
    return fRet;
}


BOOL
GetVdirPhysicalPath(
                    IMSAdminBase *pIMSAdminBase,
                    WCHAR * wszVDir,
                    WCHAR *wszStringPathToFill)
{
    HRESULT hr;
    BOOL fRet = FALSE;
    METADATA_HANDLE hMetabase = NULL;   // handle to metabase
    METADATA_RECORD mr;
    WCHAR  szTmpData[MAX_PATH];
    DWORD  dwMDRequiredDataLen;
    
    // open key to ROOT on website #1 (default)
    hr = pIMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
        L"/LM/W3SVC/1",
        METADATA_PERMISSION_READ,
        REASONABLE_TIMEOUT,
        &hMetabase);
    if( FAILED( hr )) {
        return FALSE;
    }
    
    // Get the physical path for the WWWROOT
    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = sizeof( szTmpData );
    mr.pbMDData       = reinterpret_cast<unsigned char *>(szTmpData);
    
    //if nothing specified get the root.
    if (_wcsicmp(wszVDir, L"") == 0) {
        WCHAR wszTempDir[MAX_PATH];
        swprintf(wszTempDir,L"/ROOT/%s", wszVDir);
        hr = pIMSAdminBase->GetData( hMetabase, wszTempDir, &mr, &dwMDRequiredDataLen );
    } else {
        hr = pIMSAdminBase->GetData( hMetabase, L"/ROOT", &mr, &dwMDRequiredDataLen );
    }
    pIMSAdminBase->CloseKey( hMetabase );
    
    if( SUCCEEDED( hr )) {
        wcscpy(wszStringPathToFill,szTmpData);
        fRet = TRUE;
    }
    
    pIMSAdminBase->CloseKey( hMetabase );
    return fRet;
}



BOOL
AddVirtualDir(
              IMSAdminBase *pIMSAdminBase,
              WCHAR * wszVDir,
              WCHAR * wszDir)
{
    HRESULT hr;
    BOOL    fRet = FALSE;
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    WCHAR   szTempPath[MAX_PATH];
    DWORD   dwMDRequiredDataLen = 0;
    DWORD   dwAccessPerm = 0;
    METADATA_RECORD mr;
    
    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
        L"/LM/W3SVC/1/ROOT",
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        REASONABLE_TIMEOUT,
        &hMetabase );
    
    // Create the key if it does not exist.
    if( FAILED( hr )) {
        return FALSE;
    }
    
    fRet = TRUE;
    
    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = sizeof( szTempPath );
    mr.pbMDData       = reinterpret_cast<unsigned char *>(szTempPath);
    
    // see if MD_VR_PATH exists.
    hr = pIMSAdminBase->GetData( hMetabase, wszVDir, &mr, &dwMDRequiredDataLen );
    
    if( FAILED( hr )) {
        
        fRet = FALSE;
        if( hr == MD_ERROR_DATA_NOT_FOUND ||
            HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND ) {
            
            // Write both the key and the values if GetData() failed with any of the two errors.
            
            pIMSAdminBase->AddKey( hMetabase, wszVDir );
            
            mr.dwMDIdentifier = MD_VR_PATH;
            mr.dwMDAttributes = METADATA_INHERIT;
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = STRING_METADATA;
            mr.dwMDDataLen    = (wcslen(wszDir) + 1) * sizeof(WCHAR);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(wszDir);
            
            // Write MD_VR_PATH value
            hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
            fRet = SUCCEEDED( hr );
            
            // Set the default authentication method
            if( fRet ) {
                
                DWORD dwAuthorization = MD_AUTH_ANONYMOUS;     // NTLM only.
                
                mr.dwMDIdentifier = MD_AUTHORIZATION;
                mr.dwMDAttributes = METADATA_INHERIT;   // need to inherit so that all subdirs are also protected.
                mr.dwMDUserType   = IIS_MD_UT_FILE;
                mr.dwMDDataType   = DWORD_METADATA;
                mr.dwMDDataLen    = sizeof(DWORD);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAuthorization);
                
                // Write MD_AUTHORIZATION value
                hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
                fRet = SUCCEEDED( hr );
            }
        }
    }
    
    // In the following, do the stuff that we always want to do to the virtual dir, regardless of Admin's setting.
    
    if( fRet ) {
        
        dwAccessPerm = MD_ACCESS_READ | MD_ACCESS_SCRIPT;
        
        mr.dwMDIdentifier = MD_ACCESS_PERM;
        mr.dwMDAttributes = METADATA_INHERIT;    // Make it inheritable so all subdirectories will have the same rights.
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = DWORD_METADATA;
        mr.dwMDDataLen    = sizeof(DWORD);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAccessPerm);
        
        // Write MD_ACCESS_PERM value
        hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
        fRet = SUCCEEDED( hr );
    }
    
    if( fRet ) {
        
        PWCHAR  szDefLoadFile = L"Default.htm,Default.asp";
        
        mr.dwMDIdentifier = MD_DEFAULT_LOAD_FILE;
        mr.dwMDAttributes = 0;   // no need for inheritence
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = (wcslen(szDefLoadFile) + 1) * sizeof(WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szDefLoadFile);
        
        // Write MD_DEFAULT_LOAD_FILE value
        hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
        fRet = SUCCEEDED( hr );
    }
    
    if( fRet ) {
        
        PWCHAR  szKeyType = IIS_CLASS_WEB_VDIR_W;
        
        mr.dwMDIdentifier = MD_KEY_TYPE;
        mr.dwMDAttributes = 0;   // no need for inheritence
        mr.dwMDUserType   = IIS_MD_UT_SERVER;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = (wcslen(szKeyType) + 1) * sizeof(WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szKeyType);
        
        // Write MD_DEFAULT_LOAD_FILE value
        hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
        fRet = SUCCEEDED( hr );
    }
    
    pIMSAdminBase->CloseKey( hMetabase );
    
    return fRet;
}


BOOL
RemoveVirtualDir(
                 IMSAdminBase *pIMSAdminBase,
                 WCHAR * wszVDir)
{
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    HRESULT hr;
    
    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
        L"/LM/W3SVC/1/ROOT",
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        REASONABLE_TIMEOUT,
        &hMetabase );
    
    if( FAILED( hr )) {
        return FALSE; 
    }
    
    // We don't check the return value since the key may already 
    // not exist and we could get an error for that reason.
    pIMSAdminBase->DeleteKey( hMetabase, wszVDir );
    
    pIMSAdminBase->CloseKey( hMetabase );    
    
    return TRUE;
}

//Check if the service "lpServiceName" exist or not
// if exist, return 0
// if not,  return error code
INT CheckifServiceExist(LPCTSTR lpServiceName)
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    
    if ((hScManager = OpenSCManager(NULL, NULL, GENERIC_ALL)) == NULL 
        || (hService = OpenService(hScManager, lpServiceName, GENERIC_ALL)) == NULL)
    {
        err = GetLastError();
    }
    
    if (hService) 
        CloseServiceHandle(hService);
    if (hScManager) 
        CloseServiceHandle(hScManager);
    return (err);
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\pages.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// pages.h

#ifndef __pages_h__
#define __pages_h__

#include "stdafx.h"
#include "cocpage.h"

class AppSrvWarningPage : public COCPage
{
    public:
    AppSrvWarningPage           (COCPageData* pPageData);

    UINT GetPageID              ()  {return IDD_PROPPAGE_TERMINAL_SERVER_APPSRV_WARN;}
    BOOL CanShow                () ;
    UINT GetHeaderTitleResource () ;
    UINT GetHeaderSubTitleResource () ;
	BOOL OnInitDialog           (HWND hwndDlg, WPARAM /* wParam */, LPARAM /* lParam */);

};

class AppSrvUninstallpage : public COCPage
{
    public:
    AppSrvUninstallpage           (COCPageData* pPageData);

    UINT GetPageID              ()  {return IDD_PROPPAGE_TERMINAL_SERVER_APPSRV_WARN;}
    BOOL CanShow                () ;
    UINT GetHeaderTitleResource () ;
    UINT GetHeaderSubTitleResource () ;
	BOOL OnInitDialog           (HWND hwndDlg, WPARAM /* wParam */, LPARAM /* lParam */);

};

class DefSecPageData: public COCPageData
{
    public:
    DefSecPageData              ();
    ~DefSecPageData             ();

    LPTSTR* GetWinStationArray  ()  {return m_pWinStationArray;}
    UINT    GetWinStationCount  ()  {return m_cArray;}
	BOOL	AlocateWinstationsArray  (UINT uiWinstationCount);
	BOOL	AddWinstation		(LPCTSTR pStr);
	VOID    CleanArray          ();

    private:
    UINT    m_cArray;
    LPTSTR* m_pWinStationArray;


};

class DefaultSecurityPage : public COCPage
{
    public:
    DefaultSecurityPage         (COCPageData* pPageData);

    UINT GetPageID              ()  {return IDD_PROPPAGE_TERMINAL_SERVER_SEC;}
    BOOL CanShow                ();
    BOOL OnInitDialog           (HWND hwndDlg, WPARAM /* wParam */, LPARAM /* lParam */);
    UINT GetHeaderTitleResource ();
    UINT GetHeaderSubTitleResource () ;
    BOOL ApplyChanges           ();
    VOID OnActivation           ();
	VOID OnDeactivation			();

    private:
    HWND m_hListView;
    UINT m_cWinStations;

    BOOL PopulateWinStationList ();
    DefSecPageData* GetPageData();

};

/*
class PermPageData: public COCPageData
{

    public:
    PermPageData();
    ~PermPageData();

    EPermMode GetPermissionMode() {return m_ePermMode;}

    private:
    EPermMode m_ePermMode;
};
*/
class PermPage: public COCPage
{
    public:
    PermPage(COCPageData* pPageData);

    UINT GetPageID() {return IDD_PROPPAGE_TERMINAL_SERVER_PERM;}
    BOOL CanShow();
    BOOL OnInitDialog(HWND hwndDlg, WPARAM /* wParam */, LPARAM /* lParam */);
    VOID OnActivation();
    UINT GetHeaderTitleResource() {return IDS_STRING_PERM_PAGE_HEADER_TITLE;}
    UINT GetHeaderSubTitleResource() {return IDS_STRING_PERM_PAGE_HEADER_SUBTITLE;}
    BOOL ApplyChanges();

    // private:
    // PermPageData* GetPageData();
};


#endif // __pages_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\rdpdrstp.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    rdpdrstp

Abstract:

    This module implements Terminal Server RDPDR device redirector
    setup functions in C for user-mode NT.

Environment:

    User mode

Author:

    Tadb

--*/

// Toggle stand-alone testing.
//#define UNITTEST      1


#include "stdafx.h"


#ifdef UNITTEST
#include <windows.h>
#include <tchar.h>
#include <time.h>
#include <stdio.h>
#include <setupapi.h>
#include <prsht.h>
#include "objbase.h"        // for CoInitialize()
#endif

#include <devguid.h>
#include <cfgmgr32.h>
#include <winspool.h>
#include <rdpdrstp.h>
#include "newdev.h"

#define SIZECHARS(x)        (sizeof((x))/sizeof(*x))

//#define USBMON_DLL   TEXT("USBMON.DLL")
//#define USB_MON_NAME TEXT("USB Monitor")

#ifndef UNITTEST
#include "logmsg.h"
#endif

#ifdef UNITTEST
#define LOGMESSAGE1(arg1, arg2) ;
#define LOGMESSAGE0(arg1) ;
#endif


////////////////////////////////////////////////////////////
//
//  Internal Types
//

typedef BOOL (InstallDevInstFuncType)(
                    HWND hwndParent, LPCWSTR DeviceInstanceId,
                    BOOL UpdateDriver,
                    PDWORD pReboot,
                    BOOL silentInstall
                    );

BOOL RDPDRINST_GUIModeSetupInstall(
    IN  HWND    hwndParent,
    IN  WCHAR   *pPNPID,
    IN  TCHAR   *pDeviceID
    )
/*++

Routine Description:

    This is the single entry point for RDPDR (Terminal Server Device Redirector)
    GUI-mode setup install routine.

    It currently simply creates and installs a dev node for RDPDR to interact with
    PnP.

Arguments:

    hwndParent    Handle to parent window for GUI required by this function.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
{
    HDEVINFO            devInfoSet;
    SP_DEVINFO_DATA     deviceInfoData;
    TCHAR               className[MAX_CLASS_NAME_LEN];
    WCHAR               pnpID[256];
    DWORD               len;
    WCHAR               devInstanceID[MAX_PATH];
    InstallDevInstFuncType  *pInstallDevInst;
    HINSTANCE               hndl = NULL;
    //MONITOR_INFO_2 mi;

    //mi.pDLLName     =   USBMON_DLL;
    //mi.pEnvironment =   NULL;
    //mi.pName        =   USB_MON_NAME;


    // Add the USB port monitor
    //if (!AddMonitor(NULL, 2, (PBYTE)&mi)) {
    //    if (GetLastError() != ERROR_PRINT_MONITOR_ALREADY_INSTALLED) {
    //        LOGMESSAGE1(_T("AddMonitor failed.  Error code:  %ld."), GetLastError());
    //        return FALSE;
    //    }
    //}

    //
    //  Create the device info list.
    //
    devInfoSet = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_SYSTEM, hwndParent);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        LOGMESSAGE1(_T("Error creating device info list.  Error code:  %ld."),
                    GetLastError());
        return FALSE;
    }

    //
    //  Get the "official" system class name.
    //
    ZeroMemory(&deviceInfoData, sizeof(SP_DEVINFO_DATA));
    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if (!SetupDiClassNameFromGuid(&GUID_DEVCLASS_SYSTEM,
                                  className,
                                  sizeof(className)/sizeof(TCHAR),
                                  NULL
                                  ))
    {
        LOGMESSAGE1(_T("Error fetching system class name.  Error code:  %ld."),
                    GetLastError());
        return FALSE;
    }

    //
    //  Create the dev node.
    //
    if (!SetupDiCreateDeviceInfo(devInfoSet,
                             pDeviceID,
                             &GUID_DEVCLASS_SYSTEM,
                             NULL,
                             hwndParent,
                             0L,   // No flags.
                             &deviceInfoData
                             ))
    {
        // If it already exists, then we are done ... because this was an
        // upgrade.
        if (GetLastError() == ERROR_DEVINST_ALREADY_EXISTS)
        {
            SetupDiDestroyDeviceInfoList(devInfoSet);
            return TRUE;
        }
        else {
            LOGMESSAGE1(_T("Error creating device node.  Error code:  %ld."),
                        GetLastError());
            SetupDiDestroyDeviceInfoList(devInfoSet);
            return FALSE;
        }
    }
    else if (!SetupDiSetSelectedDevice(devInfoSet, &deviceInfoData)) {
        LOGMESSAGE1(_T("Error selecting device node.  Error code:  %ld."),
                    GetLastError());
        goto WhackTheDevNodeAndReturnError;
    }

    //
    //  Add the RDPDR PnP ID.
    //

    // Create the PnP ID string.
    wcscpy(pnpID, pPNPID);
    len = wcslen(pnpID);

    // This is a multi_sz string, so we need to terminate with an extra null.
    pnpID[len+1] = 0;

    // Add it to the registry entry for the dev node.
    if (!SetupDiSetDeviceRegistryProperty(
                            devInfoSet, &deviceInfoData,
                            SPDRP_HARDWAREID, (CONST BYTE *)pnpID,
                            (len + 2) * sizeof(WCHAR))) {
        LOGMESSAGE1(_T("Error setting device registry property.  Error code:  %ld."),
                    GetLastError());
        goto WhackTheDevNodeAndReturnError;
    }

    //
    //  Register the, as of yet, phantom dev node with PnP to turn it into a real
    //  dev node.
    //
    if (!SetupDiRegisterDeviceInfo(devInfoSet, &deviceInfoData, 0, NULL,
                                NULL, NULL)) {
        LOGMESSAGE1(_T("Error registering device node with PnP.  Error code:  %ld."),
                    GetLastError());
        goto WhackTheDevNodeAndReturnError;
    }

    //
    //  Get the device instance ID.
    //
    if (!SetupDiGetDeviceInstanceIdW(devInfoSet, &deviceInfoData, devInstanceID,
        SIZECHARS(devInstanceID), NULL)) {
        LOGMESSAGE1(_T("Error getting the device instance id.  Error code:  %ld."),
                    GetLastError());
        goto WhackTheDevNodeAndReturnError;
    }

    //
    //  Use newdev.dll to install RDPDR as the driver for this new dev node.
    //
    hndl = LoadLibrary(TEXT("newdev.dll"));
    if (hndl == NULL) {
        LOGMESSAGE1(_T("Error loading newdev.dll.  Error code:  %ld."),
                    GetLastError());
        goto WhackTheDevNodeAndReturnError;
    }

    pInstallDevInst = (InstallDevInstFuncType *)GetProcAddress(hndl, "InstallDevInstEx");
    if (pInstallDevInst == NULL) {
        LOGMESSAGE1(_T("Error fetching InstallDevInst func.  Error code:  %ld."),
                    GetLastError());
        goto WhackTheDevNodeAndReturnError;
    }

    if ((*pInstallDevInst)(hwndParent, devInstanceID, FALSE, NULL, TRUE)) {
        // Clean up and return success!
        SetupDiDestroyDeviceInfoList(devInfoSet);
        FreeLibrary(hndl);
        return TRUE;
    }
    else {
        LOGMESSAGE1(_T("Error in newdev install.  Error code:  %ld."),
            GetLastError());
    }

    //
    //  Whack the dev node and return failure.
    //
WhackTheDevNodeAndReturnError:
    SetupDiCallClassInstaller(DIF_REMOVE, devInfoSet, &deviceInfoData);
    SetupDiDestroyDeviceInfoList(devInfoSet);
    if (hndl != NULL) {
        FreeLibrary(hndl);
    }

    return FALSE;
}

BOOL RDPDRINST_GUIModeSetupUninstall(HWND hwndParent, WCHAR *pPNPID, GUID *pGuid)
/*++

Routine Description:

    This is the single entry point for RDPDR (Terminal Server Device Redirector)
    GUI-mode setup uninstall routine.

    It currently simply remove the dev node created so that RDPDR can interact
    with PnP.

Arguments:

    hwndParent    Handle to parent window for GUI required by this function.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
{
    HDEVINFO            devInfoSet;
    SP_DEVINFO_DATA     deviceInfoData;
    DWORD               iLoop;
    BOOL                bMoreDevices;
    WCHAR               pnpID[256];
    BOOL                result;



    //
    //  Get the set of all devices with the RDPDR PnP ID.
    //
    devInfoSet = SetupDiGetClassDevs(pGuid, NULL, hwndParent,
                                   DIGCF_PRESENT);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        LOGMESSAGE1(_T("Error getting RDPDR devices from PnP.  Error code:  %ld."),
                    GetLastError());
        return FALSE;
    }

    // Assume that we will be successful.
    result = TRUE;

    // Get the first device.
    iLoop=0;
    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, iLoop, &deviceInfoData);

    // Get the details for all matching device interfaces.
    while (bMoreDevices)
    {
        // Get the PnP ID for the device.
        if (!SetupDiGetDeviceRegistryProperty(devInfoSet, &deviceInfoData,
                                SPDRP_HARDWAREID, NULL, (BYTE *)pnpID,
                                sizeof(pnpID), NULL)) {
            LOGMESSAGE1(_T("Error fetching PnP ID in RDPDR device node remove.  Error code:  %ld."),
                        GetLastError());
        }
        // If the current device matches RDPDR, then remove it.
        else if (!wcscmp(pnpID, pPNPID))
        {
            if (!SetupDiCallClassInstaller(DIF_REMOVE, devInfoSet, &deviceInfoData)) {
                // If we failed here, set the return status to indicate failure, but
                // don't give up on any other RDPDR dev nodes.
                LOGMESSAGE1(_T("Error removing RDPDR device node.  Error code:  %ld."),
                            GetLastError());
                result = FALSE;
            }
        }

        // Get the next one device interface.
        bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, ++iLoop, &deviceInfoData);
    }

    // Release the device info list.
    SetupDiDestroyDeviceInfoList(devInfoSet);

    return result;
}


ULONG RDPDRINST_DetectInstall()
/*++

Routine Description:

    Return the number of RDPDR.SYS devices found.

Arguments:

    NA

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
{
    HDEVINFO            devInfoSet;
    SP_DEVINFO_DATA     deviceInfoData;
    DWORD               iLoop;
    BOOL                bMoreDevices;
    ULONG               count;
    TCHAR               pnpID[256];


    GUID *pGuid=(GUID *)&GUID_DEVCLASS_SYSTEM;

    //
    //  Get the set of all devices with the RDPDR PnP ID.
    //
    devInfoSet = SetupDiGetClassDevs(pGuid, NULL, NULL,
                                   DIGCF_PRESENT);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        LOGMESSAGE1(_T("ERRORgetting RDPDRINST_DetectInstall:RDPDR devices from PnP.  Error code:  %ld."),
                GetLastError());
        return 0;
    }

    // Get the first device.
    iLoop=0;
    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, iLoop, &deviceInfoData);

    // Get the details for all matching device interfaces.
    count = 0;
    while (bMoreDevices)
    {
        // Get the PnP ID for the device.
        if (!SetupDiGetDeviceRegistryProperty(devInfoSet, &deviceInfoData,
                                SPDRP_HARDWAREID, NULL, (BYTE *)pnpID,
                                sizeof(pnpID), NULL)) {
            LOGMESSAGE1(_T("ERROR:fetching PnP ID in RDPDR device node remove.  Error code:  %ld."),
                        GetLastError());
        }

        // If the current device matches the RDPDR PNP ID
        if (!_tcscmp(pnpID, TRDPDRPNPID)) {
            count++;
        }

        // Get the next one device interface.
        bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, ++iLoop, &deviceInfoData);
    }

    // Release the device info list.
    SetupDiDestroyDeviceInfoList(devInfoSet);

    return count;
}

BOOL IsRDPDrInstalled ()
{
    ULONG ulReturn;
    LOGMESSAGE0(_T("Entered IsRDPDrInstalled"));
    
    ulReturn = RDPDRINST_DetectInstall();
    
    LOGMESSAGE1(_T("Returning IsRDPDrInstalled (ulReturn = %d)"), ulReturn);
    
    return 0 != ulReturn;
}

//
//      Unit-Test
//
#ifdef UNITTEST
void __cdecl main()
{
    RDPDRINST_GUIModeSetupInstall(NULL);
    RDPDRINST_GUIModeSetupUninstall(NULL);
}
#endif

#ifdef TSOC_CONSOLE_SHADOWING


//
// Need to instantiate the device class GUIDs so we can use the "Net" class
// GUID below...
//
/*
DWORD
InstallRootEnumeratedDevice(
    IN  HWND   hwndParent,
    IN  PCTSTR DeviceName,
    IN  PCTSTR HardwareIdList,
    IN  PCTSTR FullInfPath,
    OUT PBOOL  RebootRequired  OPTIONAL
    )
*/
/*++
    Routine Description:
    This routine creates and installs a new, root-enumerated devnode
    representing a network adapter.

    Arguments:
    hwndParent - Supplies the window handle to be used as the parent of any
    UI that is generated as a result of this device's installation.
    DeviceName - Supplies the full name of the devnode to be created (e.g.,
    "Root\VMWARE\0000"). Note that if this devnode already exists, the API
    will fail.

    HardwareIdList - Supplies a multi-sz list containing one or more hardware
    IDs to be associated with the device. These are necessary in order to
    match up with an INF driver node when we go to do the device
    installation.

    FullInfPath - Supplies the full path to the INF to be used when installing
    this device.

    RebootRequired - Optionally, supplies the address of a boolean that is set,
    upon successful return, to indicate whether or not a reboot is required
    to bring the newly-installed device on-line.
    Return Value:
    If the function succeeds, the return value is NO_ERROR.
    If the function fails, the return value is a Win32 error code indicating
    the cause of the failure.

--*/
/*
{
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD HardwareIdListSize, CurIdSize;
    PCTSTR p;
    DWORD Err;

    //
    // Create the container for the to-be-created device information element.
    //

    DeviceInfoSet = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_DISPLAY, hwndParent);

    if (DeviceInfoSet == INVALID_HANDLE_VALUE)
    {
        LOGMESSAGE1(_T("SetupDiCreateDeviceInfoList  failed. LastError = %ld"), GetLastError());
        return GetLastError();
    }

    //
    // Now create the element.
    //
    // ** Note that if the desire is to always have a unique devnode be created
    // (i.e., have an auto-generated name), then the caller would need to pass
    // in just the device part of the name (i.e., just the middle part of
    // "Root\<DeviceId>\<UniqueInstanceId>"). In that case, we'd need to pass
    // the DICD_GENERATE_ID flag in the next-to-last argument of the call below.
    //

    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if (!SetupDiCreateDeviceInfo(DeviceInfoSet,
                                DeviceName,
                                &GUID_DEVCLASS_DISPLAY,
                                NULL,
                                hwndParent,
                                0,
                                &DeviceInfoData))
    {

        LOGMESSAGE1(_T("SetupDiCreateDeviceInfo  failed. LastError = %ld"), GetLastError());


        Err = GetLastError();
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        return Err;
    }

    //
    // Now compute the size of the hardware ID list we're going to associate
    // with the device.
    //

    HardwareIdListSize = 1; // initialize to 1 for extra null terminating char
    for(p = HardwareIdList; *p; p += CurIdSize)
    {
        CurIdSize = lstrlen(p) + 1;
        HardwareIdListSize += CurIdSize;
    }

    //
    // (Need size in bytes, not characters, for call below.)
    //

    HardwareIdListSize *= sizeof(TCHAR);

    //
    // Store the hardware ID list to the device's HardwareID property.
    //

    if (!SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                         &DeviceInfoData,
                                         SPDRP_HARDWAREID,
                                         (LPBYTE)HardwareIdList,
                                         HardwareIdListSize))
    {

        LOGMESSAGE1(_T("SetupDiSetDeviceRegistryProperty  failed. LastError = %ld"), GetLastError());
        Err = GetLastError();
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        return Err;
    }

    //
    // OK, now we can register our device information element. This transforms
    // the element from a mere registry presence into an actual devnode in the
    // PnP hardware tree.
    //

    if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
                                  DeviceInfoSet,
                                  &DeviceInfoData))
    {

        LOGMESSAGE1(_T("SetupDiCallClassInstaller  failed. LastError = %ld"), GetLastError());
        Err = GetLastError();
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        return Err;
    }

    //
    // OK, the device information element has now been registered. From here
    // on, if we encounter any failure we'll also need to explicitly remove
    // this device from the system before bailing.
    //
    //
    // Now we're ready to install the device. (We need to initialize the
    // caller-supplied "RebootRequired" buffer to zero, because the call below
    // simply ORs in reboot-needed flags, as it performs device installations
    // that require reboot.)
    //

    if(RebootRequired)
    {
        *RebootRequired = FALSE;
    }

    if (!UpdateDriverForPlugAndPlayDevices(hwndParent,
                                          HardwareIdList, // use the first ID
                                          FullInfPath,
                                          INSTALLFLAG_FORCE,
                                          RebootRequired))
    {
        Err = GetLastError();
        LOGMESSAGE1(_T("UpdateDriverForPlugAndPlayDevices  failed. LastError = %ld"), GetLastError());

        if(Err == NO_ERROR)
        {
            //
            // The only time we should get NO_ERROR here is when
            // UpdateDriverForPlugAndPlayDevices didn't find anything to do.
            // That should never be the case here. However, since something
            // obviously went awry, go ahead and force some error, so the
            // caller knows things didn't work out.
            //

            Err = ERROR_NO_SUCH_DEVINST;
        }

        SetupDiCallClassInstaller(DIF_REMOVE,
                                  DeviceInfoSet,
                                  &DeviceInfoData
                                 );

        SetupDiDestroyDeviceInfoList(DeviceInfoSet);

        return Err;
    }

    //
    // We're done! We successfully installed the device.
    //

    SetupDiDestroyDeviceInfoList(DeviceInfoSet);

    return NO_ERROR;
}
*/

#endif//  TSOC_CONSOLE_SHADOWING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\privs.cpp ===
//+-------------------------------------------------------------------------
//
//  
//  Copyright (C) Microsoft
//
//  File:       securd.cpp
//
//  History:    30-March-2000    a-skuzin   Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"

//
// #include <windows.h>
// #include <ntsecapi.h>
//

#ifndef NT_SUCCESS

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#endif

NTSTATUS ChangePrivilegeOnAccount(IN BOOL addPrivilage, IN LPWSTR wszServer, IN LPWSTR wszPrivilegeName, IN PSID pSid);
// NTSTATUS OpenPolicy(IN LPWSTR wszServer,IN DWORD DesiredAccess,OUT PLSA_HANDLE pPolicyHandle );
void InitLsaString(OUT PLSA_UNICODE_STRING LsaString,IN LPWSTR String);
BOOL SetPrivilegeInAccessToken(LPCTSTR PrivilegeName,DWORD dwAttributes) ;


/*****************************************************************************
 *
 *  GrantRemotePrivilegeToEveryone
 *
 *   Grants "SeRemoteInteractiveLogonRight" privilege to "Everyone SID"
 *
 * ENTRY:
 *  BOOL    addPrivilage    - if TRUE, we are adding privilege, else, we are remving privilage
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *           
 *          
 *
 ****************************************************************************/
DWORD 
GrantRemotePrivilegeToEveryone( BOOL addPrivilege)
{
	USES_CONVERSION;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID pWorldSid;

    if(!AllocateAndInitializeSid( &WorldSidAuthority, 1,
                                   SECURITY_WORLD_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &pWorldSid ))
    {
        return GetLastError();
    }
    
    NTSTATUS Status = ChangePrivilegeOnAccount(addPrivilege, NULL, T2W(SE_REMOTE_INTERACTIVE_LOGON_NAME),pWorldSid);

    FreeSid(pWorldSid);

    return (DWORD)LsaNtStatusToWinError(Status);
}

/*****************************************************************************
 *
 *  ChangePrivilegeOnAccount
 *
 *   Grants or Remove privelege represented by wszPrivilegeName to account represented by  pSid
 *
 * ENTRY:
 *      BOOL    addPrivilage     - If TRUE, we are adding privilage, else, we are removing privilage
 *      LPCWSTR wszServer        - name of the server on which the privilege is being set
 *      LPCWSTR wszPrivilegeName - name of the privilege
 *      PSID pSid                - pointer to hte SID of the user (or group)
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: NTSTATUS code of an error if failure
 *           
 *          
 *
 ****************************************************************************/
NTSTATUS 
ChangePrivilegeOnAccount(
        IN BOOL   addPrivilege,       // add or remove
        IN LPWSTR wszServer,
        IN LPWSTR wszPrivilegeName,
        IN PSID pSid)
{
    NTSTATUS Status;
    LSA_HANDLE PolicyHandle = NULL;

    Status = OpenPolicy(wszServer,POLICY_WRITE|POLICY_LOOKUP_NAMES,&PolicyHandle);

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }
    
    
    LSA_UNICODE_STRING PrivilegeString;
    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, wszPrivilegeName);
    //
    // grant  the privilege
    //

    if ( addPrivilege) 
    {
        Status=LsaAddAccountRights(
                    PolicyHandle,       // open policy handle
                    pSid,               // target SID
                    &PrivilegeString,   // privileges
                    1                   // privilege count
                    );
    }
    else
    {
        Status=LsaRemoveAccountRights(
            PolicyHandle,       // open policy handle
            pSid,               // target SID
            FALSE,              // we are NOT removing all rights 
            &PrivilegeString,   // privileges
            1                   // privilege count
            );
    }

    LsaClose(PolicyHandle);

    return Status;
}

#if 0
/*****************************************************************************
 *
 *  OpenPolicy
 *
 *   Opens LSA policy
 *
 * ENTRY:
 *      IN LPWSTR wszServer
 *      IN DWORD DesiredAccess 
 *      OUT PLSA_HANDLE pPolicyHandle
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: NTSTATUS code of an error if failure
 *           
 *          
 *
 ****************************************************************************/
NTSTATUS  
OpenPolicy(
        IN LPWSTR wszServer,
        IN DWORD DesiredAccess, 
        OUT PLSA_HANDLE pPolicyHandle ) 
{ 
    LSA_OBJECT_ATTRIBUTES ObjectAttributes; 
    LSA_UNICODE_STRING ServerString; 
    // 
    // Always initialize the object attributes to all zeroes. 
    // 
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes)); 
    // 
    // Make a LSA_UNICODE_STRING out of the LPWSTR passed in 
    // 
    InitLsaString(&ServerString, wszServer); 
    // 
    // Attempt to open the policy. 
    // 
    return LsaOpenPolicy( 
                &ServerString, 
                &ObjectAttributes, 
                DesiredAccess, 
                pPolicyHandle); 
}


/*****************************************************************************
 *
 *  InitLsaString
 *
 *   Makes a LSA_UNICODE_STRING out of the LPWSTR passed in
 *
 * ENTRY:
 *      OUT PLSA_UNICODE_STRING LsaString
 *      IN LPWSTR String
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  NONE
 *           
 *          
 *
 ****************************************************************************/
void 
InitLsaString(
        OUT PLSA_UNICODE_STRING LsaString,
        IN LPWSTR String)
{
    DWORD StringLength;

    if (String == NULL) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
} 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\registry.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      Registry.cpp
*
*  Abstract:
*
*      Registry.cpp: implementation of the CRegistry class.
*      This class helps with registry by allocating memory by itself
*      As a result caller must copy the pointer returned by Get functions
*      immediately.
*
*
*
*  Author:
*
*      Makarand Patwardhan  - April 9, 1997
*
* -------------------------------------------------------------------------------------------------------*/

#include "stdafx.h"
#include "Registry.h"


/*--------------------------------------------------------------------------------------------------------
* Constructor
* -------------------------------------------------------------------------------------------------------*/
CRegistry::CRegistry()
{
    m_pMemBlock = NULL;
    m_hKey = NULL;
    m_iEnumIndex = -1;
    m_iEnumValueIndex = -1;

#ifdef DBG
    m_dwSizeDebugOnly = 0;
#endif
}


CRegistry::CRegistry(HKEY hKey)
{
    m_pMemBlock = NULL;
    m_hKey = hKey;
    m_iEnumIndex = -1;
    m_iEnumValueIndex = -1;
}

/*--------------------------------------------------------------------------------------------------------
* Destructor
* -------------------------------------------------------------------------------------------------------*/
CRegistry::~CRegistry()
{
    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
    Release();
}

/*--------------------------------------------------------------------------------------------------------
* void Allocate (DWORD dwSize)
* This private function is used for allocating the memory for
* reading registry
* returns the pointer to memory allocated.
* -------------------------------------------------------------------------------------------------------*/
void *CRegistry::Allocate (DWORD dwSize)
{
    if (m_pMemBlock)
        Release();

    m_pMemBlock = new BYTE[dwSize];

#ifdef DBG
    // remember the size of the block to be allocated.
    m_dwSizeDebugOnly = dwSize;
#endif

    return m_pMemBlock;
}

/*--------------------------------------------------------------------------------------------------------
* void Release ()
* This private function is used for releasing internal memory block
* -------------------------------------------------------------------------------------------------------*/
void CRegistry::Release ()
{
    if (m_pMemBlock)
    {

#ifdef DBG
        // fistly fill up the block we allocated previously with garbage.
        // so that if anybody is using this block, it is more lilely to
        // catch the bug.
        FillMemory(m_pMemBlock, m_dwSizeDebugOnly, 'c');
        m_dwSizeDebugOnly = 0;

#endif

        delete [] m_pMemBlock;
    }
    
    m_pMemBlock = 0;
}


///*--------------------------------------------------------------------------------------------------------
//* DWORD CRegistry::CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, DWORD *pDisposition /*= NULL*/, LPSECURITY_ATTRIBUTES lpSecAttr /* = NULL */)
//* opens/creates the key specified. before attempting any operation on any key/value. this function
//* must be called.
//* hKey - hive
//* lpSubKey - Path of the key in the format _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server")
//* access - access desired. like REG_READ, REG_WRITE..
//* RETURNS error code.
//* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, DWORD *pDisposition /*= NULL*/, LPSECURITY_ATTRIBUTES lpSecAttr /* = NULL */)
{
    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    // security descriptor should be null or it should be a valid one.
    ASSERT(!lpSecAttr || IsValidSecurityDescriptor(lpSecAttr->lpSecurityDescriptor));

    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    DWORD dwDisposition;
    LONG lResult = RegCreateKeyEx(
                    hKey,               // handle of an open key
                    lpSubKey,           // address of subkey name
                    0,                  // reserved
                    NULL,               // address of class string
                    REG_OPTION_NON_VOLATILE ,  // special options flag
                    access,             // desired security access
                    lpSecAttr,          // address of key security structure
                    &m_hKey,            // address of buffer for opened handle
                    &dwDisposition      // address of disposition value buffer
                    );

    if (lResult != ERROR_SUCCESS)
    {
        m_hKey = NULL;
    }

    if (pDisposition)
        *pDisposition = dwDisposition;

    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access) ()
* opens the key specified. before attempting any operation on any key/value. this function
* must be called.
* hKey - hive
* lpSubKey - Path of the key in the format _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server")
* access - access desired. like REG_READ, REG_WRITE..
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/ )
{
    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    LONG lResult = RegOpenKeyEx(
        hKey,                       // handle of open key
        lpSubKey,                   // address of name of subkey to open
        0 ,                         // reserved
        access,                     // security access mask
        &m_hKey                     // address of handle of open key
        );

    if (lResult != ERROR_SUCCESS)
    {
        m_hKey = NULL;
    }

    return lResult;
}

DWORD CRegistry::DeleteValue (LPCTSTR lpValue)
{
    ASSERT(lpValue);
    ASSERT(m_hKey);
    return RegDeleteValue(m_hKey, lpValue);

}
DWORD CRegistry::RecurseDeleteKey (LPCTSTR lpSubKey)
{
    ASSERT(lpSubKey);
    ASSERT(m_hKey);

    CRegistry reg;
    DWORD dwError = reg.OpenKey(m_hKey, lpSubKey);
    if (dwError != ERROR_SUCCESS)
        return dwError;


    LPTSTR lpChildKey;
    DWORD  dwSize;

    // we needn't/shouldn't use GetNextSubKey in this here
    // as we are deleting the key during the loop.
    while (ERROR_SUCCESS == reg.GetFirstSubKey(&lpChildKey, &dwSize))
    {
        VERIFY(reg.RecurseDeleteKey(lpChildKey) == ERROR_SUCCESS);
    }

    return RegDeleteKey(m_hKey, lpSubKey);

}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadReg(LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype)
* Reads the registry used internally.
* LPCTSTR lpValue - value to be read.
* LPBYTE *lppbyte - address of the lpbyte at which to place the output buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* dword datatype - datatype you are expecting.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadReg(LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype)
{
    ASSERT(lpValue);
    ASSERT(lppbyte);
    ASSERT(pdw);
    ASSERT(m_hKey != NULL);
    *pdw = 0;

    DWORD dwType;
    DWORD lResult = RegQueryValueEx(
        m_hKey,             // handle of key to query
        lpValue,            // address of name of value to query
        0,                  // reserved
        &dwType,            // address of buffer for value type
        0,                  // address of data buffer 
        pdw                 // address of data buffer size 
        );

    if (lResult == ERROR_SUCCESS)
    {
        ASSERT(dwType == dwDatatype || dwType == REG_EXPAND_SZ);

        if (0 == Allocate(*pdw))
            return ERROR_OUTOFMEMORY;

        lResult = RegQueryValueEx(
            m_hKey,                 // handle of key to query
            lpValue,                // address of name of value to query
            0,                      // reserved
            &dwType,                // address of buffer for value type
            m_pMemBlock,            // address of data buffer 
            pdw                     // address of data buffer size 
            ); 

        ASSERT (ERROR_MORE_DATA != lResult);
    
        if (lResult == ERROR_SUCCESS)
            *lppbyte = m_pMemBlock;
    }

    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
* Reads A string (REG_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
{
    return ReadReg(lpValue, (LPBYTE *)lppStr, pdw, REG_SZ);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegDWord(LPCTSTR lpValue, DWORD *pdw)
* Reads A string (REG_SZ) from the registry
* LPCTSTR lpValue value to be read.
* DWORD  *pdw  - address of dword in which the read dword returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegDWord(LPCTSTR lpValue, DWORD *pdw)
{
    ASSERT(pdw);

    DWORD dwSize;
    LPBYTE pByte;
    DWORD dwReturn = ReadReg(lpValue, &pByte, &dwSize, REG_DWORD);
    ASSERT(dwReturn != ERROR_SUCCESS || dwSize == sizeof(DWORD));

    if (dwReturn == ERROR_SUCCESS)
        *pdw = * LPDWORD(pByte);

    return dwReturn;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegMultiString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
* Reads A string (REG_MULTI_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegMultiString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
{
    return ReadReg(lpValue, (LPBYTE *)lppStr, pdw, REG_MULTI_SZ);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegBinary(LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw)
* Reads A string (REG_MULTI_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPBYTE *lppByte - address of LPBYTE in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it.
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegBinary(LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw)
{
    return ReadReg(lpValue, lppByte, pdw, REG_BINARY);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetFirstSubKey(LPTSTR *lppStr, DWORD *pdw)
* Reads a first subkey for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it.
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetFirstSubKey(LPTSTR *lppStr, DWORD *pdw)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    m_iEnumIndex = 0;

    return GetNextSubKey(lppStr, pdw);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetNextSubKey(LPTSTR *lppStr, DWORD *pdw
* Reads the next subkey for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy
* the buffer to immediately. caller must not use this buffer except for copying it.
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetNextSubKey(LPTSTR *lppStr, DWORD *pdw)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(m_hKey != NULL);
    ASSERT(m_iEnumIndex >= 0); // must call GetFirstSubKey first.

    *pdw = 1024;
    if (0 == Allocate(*pdw * sizeof(TCHAR)))
        return ERROR_NOT_ENOUGH_MEMORY;

    LONG lResult = RegEnumKeyEx(
        m_hKey,                     // handle of key to enumerate
        m_iEnumIndex,               // index of subkey to enumerate
        (LPTSTR)m_pMemBlock,        // address of buffer for subkey name
        pdw,                        // address for size of subkey buffer
        0,                          // reserved
        NULL,                       // address of buffer for class string
        NULL,                       // address for size of class buffer
        NULL                        // address for time key last written to
        );

    (*pdw)++;    // since null is not included in the size.
    if (ERROR_NO_MORE_ITEMS == lResult)
        return lResult;

    m_iEnumIndex++;

    if (lResult == ERROR_SUCCESS)
        *lppStr = (LPTSTR)m_pMemBlock;

    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetFirstValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
* Reads a first value for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* DWORD *pDataType - datatype of the value is returned in this one.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetFirstValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(pDataType);

    m_iEnumValueIndex = 0;
    return GetNextValue(lppStr, pdw, pDataType);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetNextValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
* Reads a next value for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy
* the buffer to immediately. caller must not use this buffer except for copying it.
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* DWORD *pDataType - datatype of the value is returned in this one.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetNextValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(pDataType);
    ASSERT(m_hKey != NULL);
    ASSERT(m_iEnumValueIndex >= 0); // must call GetFirstSubKey first.

    *pdw = 1024;
    if (0 == Allocate(*pdw * sizeof(TCHAR)))
        return ERROR_NOT_ENOUGH_MEMORY;

    LONG lResult = RegEnumValue(
        m_hKey,                     // handle of key to query
        m_iEnumValueIndex,          // index of value to query
        (LPTSTR)m_pMemBlock,        // address of buffer for value string
        pdw,                        // address for size of value buffer
        0,                          // reserved
        pDataType,                  // address of buffer for type code
        NULL,                       // address of buffer for value data    maks_todo : use this
        NULL                        // address for size of data buffer
        );

    (*pdw)++;    // since null is not included in the size.

    if (ERROR_NO_MORE_ITEMS == lResult)
        return lResult;


    m_iEnumValueIndex++;
    if (lResult == ERROR_SUCCESS)
        *lppStr = (LPTSTR)m_pMemBlock;
    
    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegString(LPCTSTR lpValueName, LPCTSTR lpStr)
* writes REG_SZ value into the registry
* LPCTSTR lpValueName - value name to be written to
* LPCTSTR lpStr - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegString(LPCTSTR lpValueName, LPCTSTR lpStr)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

    DWORD dwSize = (_tcslen(lpStr) + 1) * sizeof(TCHAR) / sizeof(BYTE);
    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for
        lpValueName,            // address of value to set
        0,                      // Reserved
        REG_SZ,                 // flag for value type
        (LPBYTE)lpStr,          // address of value data
        dwSize                  // size of value data
        );
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegExpString(LPCTSTR lpValueName, LPCTSTR lpStr)
* writes REG_EXPAND_SZ value into the registry
* LPCTSTR lpValueName - value name to be written to
* LPCTSTR lpStr - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegExpString(LPCTSTR lpValueName, LPCTSTR lpStr)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

    DWORD dwSize = (_tcslen(lpStr) + 1) * sizeof(TCHAR) / sizeof(BYTE);
    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for
        lpValueName,            // address of value to set
        0,                      // Reserved
        REG_EXPAND_SZ,                 // flag for value type
        (LPBYTE)lpStr,          // address of value data
        dwSize                  // size of value data
        );
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegMultiString(LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize)
* writes REG_MULTI_SZ value into the registry 
* LPCTSTR lpValueName - value name to be written to
* LPCTSTR lpStr - data to be written 
* DWORD   dwSize - size of data.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegMultiString(LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

#ifdef DBG
    
    // lets make sure that the given size is right.
    LPCTSTR lpTemp = lpStr;
    DWORD rightsize = 0;
    while (_tcslen(lpTemp) > 0)
    {
        rightsize  += _tcslen(lpTemp) + 1;
        lpTemp += _tcslen(lpTemp) + 1;
    }

    ASSERT(*lpTemp == 0);           // final NULL.
    rightsize++;                    // account for final terminating null

    rightsize *= sizeof(TCHAR) / sizeof(BYTE); // size must be in bytes.

    ASSERT(dwSize == rightsize);
    
#endif

    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_MULTI_SZ,           // flag for value type
        (LPBYTE)lpStr,          // address of value data 
        dwSize                  // size of value data 
        ); 
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegBinary (LPCTSTR lpValueName, LPBYTE lpData, DWORD dwSize)
* writes REG_BINARY value into the registry 
* LPCTSTR lpValueName - value name to be written to
* LPBYTE lpData - data to be written 
* DWORD   dwSize - size of data.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegBinary (LPCTSTR lpValueName, LPBYTE lpData, DWORD dwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpData);
	ASSERT(dwSize > 0);

    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_BINARY,           // flag for value type
        lpData,          // address of value data 
        dwSize                  // size of value data 
        ); 
}



/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegDWord(LPCTSTR lpValueName, DWORD dwValue)
* writes REG_DWORD value into the registry 
* LPCTSTR lpValueName - value name to be written to 
* LPCTSTR dwValue - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegDWord(LPCTSTR lpValueName, DWORD dwValue)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);

    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved
        REG_DWORD,              // flag for value type
        (LPBYTE)&dwValue,       // address of value data 
        sizeof(dwValue)         // size of value data 
        );
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ExistInMultiString  (LPCTSTR lpValueName, LPCTSTR lpStr, BOOL *pbExists)
* checks if given null terminated string exists in a multi_sz value
* LPCTSTR lpValueName - value name to be checked
* LPCTSTR lpCheckForStr - the value to be checked for 
* BOOL *pbExists - return. TRUE if exits.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
/*
DWORD CRegistry::ExistInMultiString  (LPCTSTR  lpValueName, LPCTSTR lpCheckForStr, BOOL *pbExists)
{
	ASSERT(m_hKey != NULL);     // call setkey before calling this function.
	ASSERT(lpValueName);
	ASSERT(lpCheckForStr);
	ASSERT(*lpCheckForStr);
	ASSERT(pbExists);




	DWORD dwError = ERROR_SUCCESS;
	*pbExists = FALSE;

    LPTSTR szValue;
	DWORD dwSize;
	dwError = ReadRegMultiString(lpValueName, &szValue, dwSize);
	if (ERROR_SUCCESS == dwError)
	{
        LPCTSTR pTemp = szValue;
        while(_tcslen(pTemp) > 0 )
        {
            if (_tcscmp(pTemp, lpCheckForStr) == 0)
            {
                *pbExists = TRUE;
                break;
            }

            pTemp += _tcslen(pTemp) + 1; // point to the next string within the multistring.
            if ( DWORD(pTemp - szSuiteValue) > (dwSize / sizeof(TCHAR)))
                break; // temporary pointer passes the size of the szSuiteValue something is wrong with szSuiteValue.
		}
	}

	return dwError;


    ASSERT(FALSE);
	return ERROR_CALL_NOT_IMPLEMENTED;

}
*/

/*--------------------------------------------------------------------------------------------------------
* DWORD AppendToMultiString (LPCTSTR lpValueName, LPCTSTR lpStr)
* appends given string to a multistring value
* LPCTSTR lpValueName - value name to be appended to
* LPCTSTR lpStr - the value to be appended
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::AppendToMultiString (LPCTSTR lpValueName, LPCTSTR lpStr)
{
	ASSERT(m_hKey != NULL);     // call setkey before calling this function.
	ASSERT(lpValueName);
	ASSERT(lpStr);
	ASSERT(*lpStr);

	return ERROR_CALL_NOT_IMPLEMENTED;

}

// copy the buffer immediately
DWORD CRegistry::GetSecurity(PSECURITY_DESCRIPTOR *ppSec, SECURITY_INFORMATION SecurityInformation, DWORD *pdwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(ppSec);
    ASSERT(pdwSize);
    DWORD dwError;

    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    *pdwSize = 0;   // we just want to get the right size during the first call.

    dwError = RegGetKeySecurity(
        m_hKey,                  // open handle of key to set
        SecurityInformation,     // descriptor contents
        &pSecurityDescriptor,    // address of descriptor for key
        pdwSize                  // address of size of buffer and descriptor
        );

    // this call can not succeed. as we have set the size = 0
    ASSERT(dwError != ERROR_SUCCESS);

    if (dwError != ERROR_INSUFFICIENT_BUFFER)
    {
        // something else has went wronng.
        // return the error code
        return dwError;
    }

    ASSERT(*pdwSize != 0);

    // now we have got the right size, allocate it.
    if (0 == Allocate(*pdwSize))
        return ERROR_OUTOFMEMORY;

    dwError = RegGetKeySecurity(
        m_hKey,                  // open handle of key to set
        SecurityInformation,     // descriptor contents
        m_pMemBlock,             // address of descriptor for key
        pdwSize                  // address of size of buffer and descriptor
        );

    ASSERT(dwError != ERROR_INSUFFICIENT_BUFFER);

    if (dwError == ERROR_SUCCESS)
        *ppSec = m_pMemBlock;

    return dwError;
           
}

DWORD CRegistry::SetSecurity(PSECURITY_DESCRIPTOR pSec, SECURITY_INFORMATION SecurityInformation)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    return RegSetKeySecurity(
        m_hKey,                 // open handle of key to set
        SecurityInformation,    // descriptor contents
        pSec                    // address of descriptor for key
        );
}


// this function will fail miserably if the source and destination overlap.
DWORD CRegistry::CopyTree(CRegistry &regSrc)
{
    DWORD dwSize;
    LPTSTR szKey;
    LPTSTR szValue;
	DWORD dwError;

    if (ERROR_SUCCESS == (dwError = regSrc.GetFirstSubKey(&szKey, &dwSize)))
    {
		
        do
        {
            CRegistry regSrcKey;
            CRegistry regDstKey;
            if (ERROR_SUCCESS == (dwError = regSrcKey.OpenKey(regSrc, szKey)))
			{
				
                if (ERROR_SUCCESS == (dwError = regDstKey.CreateKey(m_hKey, szKey)))
				{
					regDstKey.CopyTree(regSrcKey);
				}
				else
				{
					LOGMESSAGE2(_T("Failed to create dest key <%s>, LastError = %d"), szKey, dwError);

				}
			}
			else
			{
				LOGMESSAGE2(_T("Failed to open src key <%s>, LastError = %d"), szKey, dwError);
			}

        }
        while (ERROR_SUCCESS == (dwError = regSrc.GetNextSubKey(&szKey, &dwSize)));

    }

    //
    // now copy values.
    //


    DWORD dwDataType;
    if (ERROR_SUCCESS == (dwError = regSrc.GetFirstValue(&szValue, &dwSize, &dwDataType)))
    {
        do
        {
            TCHAR *szValueName = new TCHAR[dwSize];
			if (!szValueName)
				break;

            _tcscpy(szValueName, szValue);

            LPBYTE pData;
            if (ERROR_SUCCESS == (dwError = regSrc.ReadReg(szValueName, &pData, &dwSize, dwDataType)))
            {
                dwError = RegSetValueEx(
                    m_hKey,                 // handle of key to set value for
                    szValueName,            // address of value to set
                    0,                      // Reserved
                    dwDataType,             // flag for value type
                    pData,                  // address of value data
                    dwSize                  // size of value data
                    );

				if (dwError != ERROR_SUCCESS)
				{
					LOGMESSAGE2(_T("Error Setting <%s>, Error = %d"), szValueName, dwError);
				}
            }
			else
			{
				LOGMESSAGE2(_T("Failed to Reading Value <%s>, Error = %d"), szValueName, dwError);
			}
        }
        while (ERROR_SUCCESS == regSrc.GetNextValue(&szValue, &dwSize, &dwDataType));

    }

    return TRUE;

}
#ifdef _Maks_AutoTest_

//
// make sure that CRegistry does not support
// Copy constructor & assignment operator
//
void TestRegistry (CRegistry reg)
{
    CRegistry reg2 = reg;   // should get error for copy constructor
    CRegistry reg3(reg);     // should get error for copy constructor
    CRegistry reg4;
    reg4 = reg;             // should get error for = operator.
    TestRegistry(reg);       // should get error for copy construtor
}

#endif // _Maks_AutoTest_

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\registry.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      Registry.h
*
*  Abstract:
*
*      declaration of a simple registry class CRegistry.
*
*
*
*  Author:
*
*      Makarand Patwardhan  - April 9, 1997
*
* -------------------------------------------------------------------------------------------------------*/

#if !defined(AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_)
#define AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include <winreg.h>


class CRegistry
{
private:

    LPBYTE      m_pMemBlock;
    HKEY        m_hKey;
    int         m_iEnumIndex;
    int         m_iEnumValueIndex;

    DWORD       ReadReg             (LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype);
    void *      Allocate            (DWORD dwSize);



    //
    // This class is not designed to allow copy constructors, = assignments,
    // therefore we should ensure that copy ctor, assignment operator are not
    // generated by compiler. we do that by declaring these functions private
    // and not implementing them. This will ensure that these functions are
    // not generated by compilers, and caller will get error if he tries to
    // use them.
    //

                CRegistry           (const CRegistry &reg);     // copy ctor
  CRegistry &   operator=           (const CRegistry &reg);     // = oprerator



#ifdef DBG
    DWORD       m_dwSizeDebugOnly;
#endif

public:
                CRegistry           ();
                CRegistry           (HKEY hKey);

    virtual     ~CRegistry          ();

    void        Release             ();

    operator    HKEY                ()    {return m_hKey;}


    DWORD       OpenKey             (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS);
    DWORD       CreateKey           (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS, DWORD *pDisposition = NULL, LPSECURITY_ATTRIBUTES lpSecAttr  = NULL );

    DWORD       DeleteValue         (LPCTSTR lpValue);
    DWORD       RecurseDeleteKey    (LPCTSTR lpSubKey);
    DWORD       CopyTree            (CRegistry &regSrc);

    DWORD       ReadRegString       (LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw);
    DWORD       ReadRegDWord        (LPCTSTR lpValue, DWORD *pdw);
    DWORD       ReadRegMultiString  (LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw);
    DWORD       ReadRegBinary       (LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw);

    DWORD       WriteRegString      (LPCTSTR lpValueName, LPCTSTR lpStr);
    DWORD       WriteRegExpString      (LPCTSTR lpValueName, LPCTSTR lpStr);
    DWORD       WriteRegDWord       (LPCTSTR lpValueName, DWORD dwValue);
    DWORD       WriteRegMultiString (LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize);
	DWORD		WriteRegBinary		(LPCTSTR lpValueName, LPBYTE lpData, DWORD dwSize);
	DWORD		ExistInMultiString  (LPCTSTR lpValueName, LPCTSTR lpCheckForStr, BOOL *pbExists);
	DWORD		AppendToMultiString (LPCTSTR lpValueName, LPCTSTR lpStr);


    DWORD       GetFirstSubKey      (LPTSTR *lppStr, DWORD *pdw);
    DWORD       GetNextSubKey       (LPTSTR *lppStr, DWORD *pdw);

    DWORD       GetFirstValue       (LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType);
    DWORD       GetNextValue        (LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType);

    DWORD       GetSecurity         (PSECURITY_DESCRIPTOR *ppSec, SECURITY_INFORMATION SecurityInformation, DWORD *pdwSize);
    DWORD       SetSecurity         (PSECURITY_DESCRIPTOR pSec, SECURITY_INFORMATION SecurityInformation);

};

#endif // !defined(AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_)

//EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hydraoc.rc
//
#define IDS_STRING_SEC_PAGE_HEADER_TITLE 9
#define IDS_STRING_SEC_PAGE_HEADER_SUBTITLE 10
#define IDS_STRING_TSUSR_ACCOUNT_COMMENT 11
#define IDS_STRING_MESSAGE_BOX_TITLE    12
#define IDS_STRING_PROGRESS_CONFIGURING 13
#define IDS_STRING_PROGRESS_CORE_TS     14
#define IDS_STRING_PROGRESS_ENABLING    15
#define IDS_STRING_PROGRESS_DISABLING   16
#define IDS_STRING_WILL_BE_UNINSTALLED  17
#define IDS_STRING_MAY_NOT_WORK_PROPERLY 18
#define IDS_LISTVIEW_COLUMN_1_HEADER    19
#define IDS_LISTVIEW_COLUMN_2_HEADER    20
#define IDS_STRING_CSC_OFF              21
#define IDS_STRING_GENERIC_LANA_WARNING 22
#define IDS_STRING_PERM_PAGE_HEADER_TITLE 23
#define IDS_STRING_PERM_PAGE_HEADER_SUBTITLE 24
#define IDS_STRING_CLUSTERING_ISON      25
#define IDS_STRING_APPSRV_WARN_TITLE    26
#define IDS_STRING_APPSRV_WARN_SUBTITLE 27
#define IDS_STRING_TERMINAL_SERVER_UNINSTALLED 28
#define IDS_STRING_TSWEBCLIENT_VIRTUALPATH 29

#define IDD_PROPPAGE_TERMINAL_SERVER_TOGGLEON 107
#define IDD_PROPPAGE_TERMINAL_SERVER_TOGGLEOFF 108
#define IDD_PROPPAGE_TERMINAL_SERVER_SEC 110
#define IDD_PROPPAGE_TERMINAL_SERVER_APPSERVER 111
#define IDD_PROPPAGE_TERMINAL_SERVER_PERM 112
#define IDD_PROPPAGE_TERMINAL_SERVER_APPSRV_WARN 113
#define IDD_PROPPAGE_TERMINAL_SERVER_APPSRV_UNINSTALL_WARN 114
#define IDS_STRING_APPSRV_UNINSTALL_WARN_TITLE 114
#define IDS_STRING_APPSRV_UNINSTALL_WARN_SUBTITLE 115
#define IDS_STRING_TSINSTALL_ARP        117
#define IDS_STRING_TSINSTALL_CLEAN      118
#define IDS_STRING_TSREMOVE             119
#define IDC_LIST_APPS_TOGGLE_ON         1001
#define IDC_LIST_APPS_TOGGLE_OFF        1002
#define IDC_RADIO_REMADM                1003
#define IDC_RADIO_APPSRV                1004
#define IDC_CONFIG_1                    1005
#define IDC_CONFIG_2                    1006
#define IDC_MANAGED_APPS_LISTVIEW       1006
#define IDC_NOTE_1                      1007
#define IDC_NOTE_2                      1008
#define IDC_WARNING_MSG                 1008
#define IDC_APPSRV_BLURB                1009
#define IDC_SECURITY_LISTVIEW           1010
#define IDC_SECURITY_DEFAULT_1          1011
#define IDC_SECURITY_DEFAULT_2          1012
#define IDC_RADIO_WIN2KPERM             1013
#define IDC_RADIO_TS4PERM               1014
#define IDC_WARNING_ICON                1015
#define IDI_SMALLWARN                   10000
#define IDB_WEBCLIENT                   10002
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\rdpdrstp.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    rdpdrstp

Abstract:

    This module implements Terminal Server RDPDR device redirector
    setup functions in C for user-mode NT.

Environment:

    User mode

Author:

    Tadb

--*/

#ifndef _RDPDRSTP_
#define _RDPDRSTP_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

////////////////////////////////////////////////////////////
//
//  Internal Defines
//

#define TRDPDRPNPID     TEXT("ROOT\\RDPDR")
#define RDPDRPNPID      L"ROOT\\RDPDR"
#define RDPDRDEVICEID   TEXT("Root\\RDPDR\\0000")



#ifdef TSOC_CONSOLE_SHADOWING

#define RDPMOUPNPID     L"ROOT\\RDP_MOU"
#define RDPMOUDEVICEID  TEXT("Root\\RDP_MOU\\0000")
#define RDPKBDPNPID     L"ROOT\\RDP_KBD"
#define RDPKBDDEVICEID  TEXT("Root\\RDP_KBD\\0000")

/*
const TCHAR szRDPCDDInfFile[]    = _T("%windir%\\inf\\rdpcdd.inf");
const TCHAR szRDPCDDHardwareID[] = _T("ROOT\\DISPLAY");             // should match with the inf entry.
const TCHAR szRDPCDDDeviceName[] = _T("ROOT\\DISPLAY\\0000");
*/

/*++

Routine Description:

    This is the single entry point for RDPDR (Terminal Server Device Redirector)
    GUI-mode setup install routine.

    It currently simply creates and installs a dev node for RDPDR to interact with
    PnP.

Arguments:

    hwndParent    Handle to parent window for GUI required by this function.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
/*
DWORD
InstallRootEnumeratedDevice(
    IN  HWND   hwndParent,
    IN  PCTSTR DeviceName,
    IN  PCTSTR HardwareIdList,
    IN  PCTSTR FullInfPath,
    OUT PBOOL  RebootRequired  OPTIONAL
    );
*/
#endif // TSOC_CONSOLE_SHADOWING

BOOL RDPDRINST_GUIModeSetupInstall(
    IN  HWND    hwndParent,
    IN  WCHAR   *pPNPID,
    IN  TCHAR   *pDeviceID
    );


/*++

Routine Description:

    This is the single entry point for RDPDR (Terminal Server Device Redirector)
    GUI-mode setup uninstall routine.

    It currently simply remove the dev node created so that RDPDR can interact
    with PnP.

Arguments:

    hwndParent    Handle to parent window for GUI required by this function.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
BOOL RDPDRINST_GUIModeSetupUninstall(HWND hwndParent, WCHAR *pPNPID, GUID *pGuid);
BOOL IsRDPDrInstalled ();

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // RDPDRSTP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\rights.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      rights.cpp
*
*  Abstract:
*
*      This file contains code to grant rights to objects.
*
*
*  Author:
*
*      Makarand Patwardhan  - March 6, 1998
*
*  Environment:
*
*    User Mode
* -------------------------------------------------------------------------------------------------------*/

#include "stdafx.h"
#include <ntsecapi.h>

#include "rights.h"

#define SIZE_SID            1024
#define SIZE_REF_DOMAIN     256

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L)
#define STATUS_OBJECT_NAME_NOT_FOUND    ((NTSTATUS)0xC0000034L)
#define STATUS_INVALID_SID              ((NTSTATUS)0xC0000078L)
#endif





void        InitLsaString(PLSA_UNICODE_STRING LsaString, LPWSTR String);
NTSTATUS    OpenPolicy(LPWSTR ServerName, DWORD DesiredAccess, PLSA_HANDLE PolicyHandle);


// returns 0 on success.
// returns last error.
DWORD GetAccountSID(LPWSTR wMachineName, LPWSTR wAccountName, PSID pSid, DWORD dwSidSize)
{
    ASSERT(wAccountName);
    ASSERT(pSid);
    ASSERT(dwSidSize > 0);

    DWORD dwRefDomainSize = SIZE_REF_DOMAIN;
    LPWSTR szRefDomain = (LPWSTR) new WCHAR[dwRefDomainSize];
    SID_NAME_USE SidNameUse;


    LookupAccountNameW(
        wMachineName,          // address of string for system name
        wAccountName,          // address of string for account name
        pSid,                   // address of security identifier
        &dwSidSize,             // address of size of security identifier
        szRefDomain,            // address of string for referenced domain
        &dwRefDomainSize,       // address of size of domain string
        &SidNameUse             // address of SID-type indicator
        );

    delete [] szRefDomain;
    return GetLastError();
}

DWORD GrantRights(LPWSTR lpMachineName, LPWSTR lpAccountName, LPWSTR lpRightsString, BOOL bAdd)
{
    DWORD dwSidSize = SIZE_SID;
    PSID pSid = new BYTE[dwSidSize];

    DWORD dwError = GetAccountSID(lpMachineName, lpAccountName, pSid, dwSidSize);
    if (dwError != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("LookupAccountNameW failed with %lu"), dwError);
    }
    else
    {
        ASSERT(IsValidSid(pSid));
        LSA_HANDLE PolicyHandle;

        // open the policy on the said machine.
        dwError = OpenPolicy(
            lpMachineName,
            POLICY_ALL_ACCESS,
            &PolicyHandle
            );

        if(dwError != STATUS_SUCCESS)
        {
            LOGMESSAGE1(_T("LookupAccountNameW failed with %lu"), dwError);
            return dwError;
        }

        LSA_UNICODE_STRING lsaString;
        InitLsaString(&lsaString, lpRightsString);
        if (bAdd)
        {
            dwError = LsaAddAccountRights(
                PolicyHandle,
                pSid,
                &lsaString,
                1
                );
        }
        else
        {
            dwError = LsaRemoveAccountRights(
                PolicyHandle,
                pSid,
                FALSE,
                &lsaString,
                1
                );
        }

        if(dwError != STATUS_SUCCESS)
        {
            LOGMESSAGE1(_T("LsaAddAccountRights/LsaRemoveAccountRights  failed with %lu"), dwError);
            return dwError;
        }

        LsaClose(PolicyHandle);
    }

    delete [] pSid;
    return dwError;
}


NTSTATUS OpenPolicy(LPWSTR ServerName, DWORD DesiredAccess, PLSA_HANDLE PolicyHandle)
{

    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;

    //
    // Always initialize the object attributes to all zeroes
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if(ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);

        Server = &ServerString;
    }

    //
    // Attempt to open the policy
    //
    return LsaOpenPolicy(Server, &ObjectAttributes, DesiredAccess, PolicyHandle);
}


void InitLsaString( PLSA_UNICODE_STRING LsaString, LPWSTR String)
{
    if(String == NULL)
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;

        return;
    }

    DWORD StringLength = lstrlenW(String);

    LsaString->Buffer = String;
    LsaString->Length = (USHORT) (StringLength * sizeof(WCHAR));
    LsaString->MaximumLength = (USHORT) ((StringLength + 1) * sizeof(WCHAR));
}

DWORD AddPermissions(LPWSTR wMachineName, LPWSTR wAccountName, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD AccessMask)
{

    ASSERT( wMachineName );
    ASSERT( wAccountName );
    ASSERT( pSecurityDescriptor );
    ASSERT( IsValidSecurityDescriptor(pSecurityDescriptor) );


    DWORD dwSidSize = SIZE_SID;
    PSID pSid = new BYTE[dwSidSize];
    BOOL bResult = FALSE;
    BOOL bAllocatedpDacl = FALSE;

    DWORD dwError = GetAccountSID(wMachineName, wAccountName, pSid, dwSidSize);
    if (dwError != ERROR_SUCCESS)
    {
        delete [] pSid;
        LOGMESSAGE0(_T("GetAccountSID failed."));
        return dwError;
    }

    BOOL bDaclPresent;
    PACL pDacl = NULL;
    BOOL bDaclDefaulted;

    if (!GetSecurityDescriptorDacl(
        pSecurityDescriptor,                 // address of security descriptor
        &bDaclPresent,                       // address of flag for presence of disc. ACL
        &pDacl,                              // address of pointer to ACL
        &bDaclDefaulted                       // address of flag for default disc. ACL
        ))
    {
        dwError = GetLastError();
        delete [] pSid;
        LOGMESSAGE0(_T("GetSecurityDescriptorDacl failed."));
        return dwError;
    }

    {
        if (bDaclPresent)
        {
            // there already exists a acl and we have a valid pDacl;

        }
        else
        {
            // there was no dacl present, so lets initialize new one ourselves.
            bAllocatedpDacl = TRUE;
            pDacl = (PACL) new BYTE [1024];
            bResult = InitializeAcl(
                pDacl,            // address of access-control list
                1024,             // size of access-control list
                ACL_REVISION      // revision level of access-control list
                );

            if (!bResult)
            {
                LOGMESSAGE0(_T("InitializeAcl failed."));
            }

        }

        if (bResult || bDaclPresent)
        {

            if (AddAccessAllowedAce(
                pDacl,            // pointer to access-control list
                ACL_REVISION,     // ACL revision level
                AccessMask,       // access mask
                pSid              // pointer to security identifier
                ))
            {

                if (SetSecurityDescriptorDacl(
                    pSecurityDescriptor,   // address of security descriptor
                    TRUE,                  // flag for presence of discretionary ACL
                    pDacl,                 // address of discretionary ACL
                    FALSE                  // flag for default discretionary ACL
                    ))
                {

                }
                else
                {
                    LOGMESSAGE0(_T("SetSecurityDescriptorDacl failed."));
                }

            }
            else
            {
                LOGMESSAGE0(_T("AddAccessAllowedAce failed."));
            }

        } // bResult || bDaclPresent

    } // GetSecurityDescriptorDacl

    if (bAllocatedpDacl)
        delete [] pDacl;


    dwError = GetLastError();
    if (dwError != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("LastError = %d"), dwError);
    }


    delete [] pSid;
    return dwError;

}


// AdjustTokenPrivileges
// TOKEN_ADJUST_PRIVILEGES
// LsaAddAccountRights
// #define SE_INTERACTIVE_LOGON_NAME       TEXT("SeInteractiveLogonRight")
/*
Article ID: Q145697
Article ID: Q136867
NTSTATUS
NTAPI
LsaOpenPolicy(
    IN PLSA_UNICODE_STRING SystemName OPTIONAL,
    IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle
    );
NTSTATUS
NTAPI
LsaAddAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN PLSA_UNICODE_STRING UserRights,
    IN ULONG CountOfRights
    );

// PRIVILEGE_SET 
// AdjustTokenPrivileges
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\securd.cpp ===
//+-------------------------------------------------------------------------
//
//  
//  Copyright (C) Microsoft
//
//  File:       securd.cpp
//
//  History:    30-March-2000    a-skuzin   Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include <winsta.h>
#include <regapi.h>

#include "secupgrd.h"
#include "state.h"

// from winnt.h
#define MAXDWORD    0xffffffff  

//Global variables
BYTE g_DefaultSD[] = {  0x01,0x00,0x14,0x80,0x88,0x00,0x00,0x00,0x94,0x00,
                        0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x00,0x00,0x00,
                        0x02,0x00,0x74,0x00,0x05,0x00,0x00,0x00,0x00,0x00,
                        0x18,0x00,0xBF,0x03,0x0F,0x00,0x01,0x02,0x00,0x00,
                        0x00,0x00,0x00,0x05,0x20,0x00,0x00,0x00,0x20,0x02,
                        0x00,0x00,0x00,0x00,0x14,0x00,0xBF,0x03,0x0F,0x00,
                        0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x12,0x00,
                        0x00,0x00,0x00,0x00,0x18,0x00,0xA1,0x01,0x00,0x00,
                        0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x05,0x20,0x00,
                        0x00,0x00,0x2B,0x02,0x00,0x00,0x00,0x00,0x14,0x00,
                        0x81,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,
                        0x00,0x05,0x13,0x00,0x00,0x00,0x00,0x00,0x14,0x00,
                        0x81,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,
                        0x00,0x05,0x14,0x00,0x00,0x00,0x01,0x01,0x00,0x00,
                        0x00,0x00,0x00,0x05,0x12,0x00,0x00,0x00,0x01,0x01,
                        0x00,0x00,0x00,0x00,0x00,0x05,0x12,0x00,0x00,0x00 };

BYTE g_ConsoleSD[] = {  0x01,0x00,0x14,0x80,0x70,0x00,0x00,0x00,0x7C,0x00,
                        0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x00,0x00,0x00,
                        0x02,0x00,0x5C,0x00,0x04,0x00,0x00,0x00,0x00,0x00,
                        0x18,0x00,0xBF,0x03,0x0F,0x00,0x01,0x02,0x00,0x00,
                        0x00,0x00,0x00,0x05,0x20,0x00,0x00,0x00,0x20,0x02,
                        0x00,0x00,0x00,0x00,0x14,0x00,0x81,0x00,0x00,0x00,
                        0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x13,0x00,
                        0x00,0x00,0x00,0x00,0x14,0x00,0x81,0x00,0x00,0x00,
                        0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x14,0x00,
                        0x00,0x00,0x00,0x00,0x14,0x00,0xBF,0x03,0x0F,0x00,
                        0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x12,0x00,
                        0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,
                        0x12,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,
                        0x00,0x05,0x12,0x00,0x00,0x00 };

DWORD AreThereAnyCustomSecurityDescriptors( BOOL &any )
{
    HKEY hKey;
    DWORD err;

    err=RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		REG_WINSTATION_KEY,
		0,
		KEY_READ,
		&hKey
		);

	if( err!=ERROR_SUCCESS )
	{
        LOGMESSAGE1(_T("Could not open TS key %d"),err);
		return err;
	}

    CDefaultSD DefaultSD;
    CDefaultSD ConsoleSD;
    //Load default SD from the registry, since we need to compare to this
    err = DefaultSD.Init(hKey,DefaultRDPSD);   
    
    if( err!=ERROR_SUCCESS )
    {
        RegCloseKey(hKey);
        return err;
    }

    //Load default console SD from the registry, since we need to compare to this
    err = ConsoleSD.Init(hKey,DefaultConsoleSD);   
    
    if( err!=ERROR_SUCCESS )
    {
        RegCloseKey(hKey);
        return err;
    }

    CNameAndSDList NameSDList;
    DWORD dwTotalWinStations = 0;
    DWORD dwDefaultWinStations = 0;

    err=EnumWinStationSecurityDescriptors( hKey, &NameSDList);
    if(err == ERROR_SUCCESS)
    {
        dwTotalWinStations = NameSDList.size();

        if(dwTotalWinStations)
        {
            CNameAndSDList::iterator it;
            
            for(it=NameSDList.begin();it!=NameSDList.end(); it++)
            {
                if((*it).IsDefaultOrEmpty(&DefaultSD,&ConsoleSD))
                {
                    dwDefaultWinStations++;
                }
            }

            //If all descriptors are default
            if(dwDefaultWinStations == dwTotalWinStations)
            {
                any = FALSE;
            }
            else
            {
                any = TRUE;
            }
        }
    }
    
    RegCloseKey(hKey);
    return err;
}

/*****************************************************************************
 *
 *  SetupWorker
 *
 * ENTRY:
 *  IN const TSState &State
 *  
 *  
 * NOTES:
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *
 ****************************************************************************/
DWORD
SetupWorker(
        IN const TSState &State )
{
    DWORD Result;
    const BOOL bStandAlone = State.IsStandAlone();
    const BOOL bClean = State.IsTSFreshInstall();
    const BOOL bAppServer = State.IsItAppServer();
    const BOOL bServer = State.IsServer();

    LOGMESSAGE4(_T("SetupWorker( %d, %d, %d, %d )"), bClean, bStandAlone, bServer, bAppServer );

    if (!bStandAlone) // we are in GUI-setup mode
    {  
        // clean install of OS or OS upgrade

        Result = SetupWorkerNotStandAlone( bClean, bServer,bAppServer );         
    }
    else
    {
        // we are being called from Add/Remove Programs, which means, we are
        // switching modes

        BOOL    anyCustomSDs;

        Result = AreThereAnyCustomSecurityDescriptors( anyCustomSDs ) ;

        LOGMESSAGE1(_T("AreThereAnyCustomSecurityDescriptors = %d"),  anyCustomSDs );

        if ( Result == ERROR_SUCCESS ) 
        {

            if (!anyCustomSDs )  
            {
                // make sure we don't have a left-over privilage on the EveryoneSID
                Result = GrantRemotePrivilegeToEveryone( FALSE );
            }

            if (bAppServer) 
            {
                // copy the content of the Local\Users into the RDU-group if and only
                // if there are no custom security dscriptors.
    
                if (!anyCustomSDs ) // there are no custom security descriptors
                {
                    Result = CopyUsersGroupToRDUsersGroup();  
                }

            }
            else
            {
                // we are switching to Remote-Admin mode, secure machine by
                // removing the content of the RDU-Group
                Result = RemoveAllFromRDUsersGroup();     
            }
        }
        else
        {
            LOGMESSAGE1(_T("AreThereAnyCustomSecurityDescriptors() returned : %d"),Result );
        }

    }

    return Result; 
}



/*****************************************************************************
 *
 *  SetupWorkerNoStandAlone
 *      This will be called when machine is being upgraded or fresh OS is being installed.
 *      It is NOT called if switching modes (AS <->RA )
 *
 * ENTRY:
 *  none
 *  
 *  
 * NOTES:
 *  IN BOOL bClean 
 *  IN BOOL bServer
 *  IN BOOL bAppServer
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *
 ****************************************************************************/
DWORD SetupWorkerNotStandAlone( 
    IN BOOL bClean,
    IN BOOL bServer,
    IN BOOL bAppServer)
{
    HKEY hKey;
    DWORD err;

    err=RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		REG_WINSTATION_KEY,
		0,
		KEY_READ|KEY_WRITE,
		&hKey
		);
	if( err!=ERROR_SUCCESS )
	{
        LOGMESSAGE1(_T("Could not open TS key %d"),err);
		return err;
	}

    if(bClean)
    {
        if(bAppServer)
        {
            err = CopyUsersGroupToRDUsersGroup();

            LOGMESSAGE1(_T("CopyUsersGroupToRDUsersGroup() returned : %d"),err);

            if(err != ERROR_SUCCESS)
            {
                RegCloseKey(hKey);
                return err;
            }

        }

    }
    else
    {
        err = GrantRemoteUsersAccessToWinstations(hKey,bServer,bAppServer);

        LOGMESSAGE1(_T("GrantRemoteUsersAccessToWinstations() returned : %d"),err);

        if(err != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            return err;
        }
    }

    err = SetNewDefaultSecurity(hKey);

    LOGMESSAGE1(_T("SetNewDefaultSecurity() returned : %d"),err);

    err = SetNewConsoleSecurity(hKey,bServer);
        
    LOGMESSAGE1(_T("SetNewConsoleSecurity() returned : %d"),err);

    RegCloseKey(hKey);

    return err;
}

/*****************************************************************************
 *
 *  GrantRemoteUsersAccessToWinstations
 *
 *   if all winstations have default SD - copies all members from "Users" to
 *   "Remote Desktop Users", then deletes all winstation's security descriptors; 
 *   otherwise grants "Everyone" with "SeRemoteInteractiveLogonRight" privilege 
 *   and then adds "Remote Desktop Users" to each winstation's security descriptor
 *
 * ENTRY:
 *  IN HKEY hKey - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *  IN BOOL bAppServer 
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *
 ****************************************************************************/
DWORD 
GrantRemoteUsersAccessToWinstations(
        IN HKEY hKey,
        IN BOOL bServer,
        IN BOOL bAppServer)
{
    DWORD err;
    
    CDefaultSD DefaultSD;
    CDefaultSD ConsoleSD;

    //Load default SD from the registry
    err = DefaultSD.Init(hKey,DefaultRDPSD);   
    
    if( err!=ERROR_SUCCESS )
    {
        //Default SD may not be present if TS was
        //never enabled.
        if(err == ERROR_FILE_NOT_FOUND)
        {
            err = ERROR_SUCCESS;
            //Copy all members of "Users" group to 
            //"Remote Desktop Users" group.
            //And we are done
            if(bAppServer)
            {
                err = CopyUsersGroupToRDUsersGroup();
            }

        }
        return err;
    }
    
    //Load default console SD from the registry
    err = ConsoleSD.Init(hKey,DefaultConsoleSD);   
    
    if( err!=ERROR_SUCCESS )
    {
        return err;
    }

    BOOL bDefaultSDHasRemoteUsers;

    err = DefaultSD.DoesDefaultSDHaveRemoteUsers(&bDefaultSDHasRemoteUsers);
    
    if( err!=ERROR_SUCCESS )
    {
        return err;
    }
    else
    {
        //in this case assume that system already has been upgraded before.
        if(bDefaultSDHasRemoteUsers)
        {
            return ERROR_SUCCESS;
        }
    }

    CNameAndSDList NameSDList;
    DWORD dwTotalWinStations = 0;
    DWORD dwDefaultWinStations = 0;

    err=EnumWinStationSecurityDescriptors( hKey, &NameSDList);
    if(err == ERROR_SUCCESS)
    {
        dwTotalWinStations = NameSDList.size();

        if(dwTotalWinStations)
        {
            CNameAndSDList::iterator it;
            
            for(it=NameSDList.begin();it!=NameSDList.end(); it++)
            {
                if((*it).IsDefaultOrEmpty(&DefaultSD,&ConsoleSD))
                {
                    dwDefaultWinStations++;
                }
            }

            //If all descriptors are default
            if(dwDefaultWinStations == dwTotalWinStations)
            {
                //Copy all members of "Users" group to 
                //"Remote Desktop Users" group.
                if(bAppServer)
                {
                    err = CopyUsersGroupToRDUsersGroup();
                }
                //remove all ald default SDs (because we will have
                //different default SD
                for(it=NameSDList.begin();it!=NameSDList.end(); it++)
                {
                    if((*it).m_pSD)
                    {
                        //in case of error, continue with other winstations
                        //but return first error.
                        if(!err)
                        {
                            err = RemoveWinstationSecurity( hKey, (*it).m_pName );   
                        }
                        else
                        {
                            RemoveWinstationSecurity( hKey, (*it).m_pName );  
                        }
                    }
                }
                
            }
            else
            {
                //Grant "SeRemoteInteractiveLogonRight" privilege to "Everyone"
                err = GrantRemotePrivilegeToEveryone( TRUE );
 
                //Add "Remote Desktop Users" group to WinStation's DS.
                //Add also "LocalService" and "NetworkService".
                //NOTE: (*it).m_pSD is being changed during each call
                //to AddLocalAndNetworkServiceToWinstationSD or 
                //AddRemoteUsersToWinstationSD
                for(it=NameSDList.begin();it!=NameSDList.end(); it++)
                {
                    //On server - skip console
                    if(bServer && (*it).IsConsole())
                    {
                        //if SD is not NULL add "LocalService" and "NetworkService" to it
                        if((*it).m_pSD)
                        {
                            if(!err)
                            {
                                err = AddLocalAndNetworkServiceToWinstationSD( hKey, &(*it) );   
                            }
                            else
                            {
                                AddLocalAndNetworkServiceToWinstationSD( hKey, &(*it) );  
                            }
                        }
                        continue;
                    }

                    //if SD is not NULL add RDU to it
                    if((*it).m_pSD)
                    {
                        //in case of error, continue with other winstations
                        //but return first error.
                        if(!err)
                        {
                            err = AddRemoteUsersToWinstationSD( hKey, &(*it) );   
                        }
                        else
                        {
                            AddRemoteUsersToWinstationSD( hKey, &(*it) );  
                        }
                        
                        //add "LocalService" and "NetworkService" to SD
                        if(!err)
                        {
                            err = AddLocalAndNetworkServiceToWinstationSD( hKey, &(*it) );   
                        }
                        else
                        {
                            AddLocalAndNetworkServiceToWinstationSD( hKey, &(*it) );  
                        }
                    }
                   
                }
                
            }
        }
    }
 
    return err;
}

/*****************************************************************************
 *
 *  AddRemoteUserToWinstationSD
 *
 *   Grants "user access" permissions to a winstation to "REMOTE DESKTOP USERS"
 *
 * ENTRY:
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN CNameAndSD *pNameSD  - name and security descriptor of a winstation
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *           
 *          
 *
 ****************************************************************************/
DWORD 
AddRemoteUsersToWinstationSD(
        IN HKEY hKeyParent,
        IN CNameAndSD *pNameSD)
{
    //
    DWORD err = ERROR_SUCCESS;

    PACL pDacl = NULL;

    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID pRUSid=NULL;
    
    if( !AllocateAndInitializeSid( &sia, 2,
              SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS, 
              0, 0, 0, 0, 0, 0,&pRUSid ) )
    {
        return GetLastError();
    }

    
    
    //get dacl
    err = GetDacl(pNameSD->m_pSD, &pDacl );

    if( err == ERROR_SUCCESS ) {
        
        
        if(!pDacl) 
        {
            //It shuold never be in our case 
            //so we return error here
            FreeSid(pRUSid);
            return ERROR_INVALID_PARAMETER;
        }
        
        //let's add it
        err = AddUserToDacl( hKeyParent, pDacl, pRUSid, WINSTATION_USER_ACCESS, pNameSD ); 

    }
    
    FreeSid(pRUSid);
    return err;
}

/*****************************************************************************
 *
 *  AddLocalAndNetworkServiceToWinstationSD
 *
 *   Grants WINSTATION_QUERY | WINSTATION_MSG permissions to 
 *   a winstation to LocalService and NetworkService accounts
 *
 * ENTRY:
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN CNameAndSD *pNameSD  - name and security descriptor of a winstation
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *           
 *          
 *
 ****************************************************************************/
DWORD 
AddLocalAndNetworkServiceToWinstationSD(
        IN HKEY hKeyParent,
        IN CNameAndSD *pNameSD)
{
    //
    DWORD err = ERROR_SUCCESS;
    PACL pDacl = NULL;
    
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID pLSSid=NULL;
    PSID pNSSid=NULL;
    

    if( !AllocateAndInitializeSid( &sia, 1,
              SECURITY_LOCAL_SERVICE_RID,
              0, 0, 0, 0, 0, 0, 0,&pLSSid ) )
    {
        return GetLastError();
    }
    
    
    
    if( !AllocateAndInitializeSid( &sia, 1,
              SECURITY_NETWORK_SERVICE_RID,
              0, 0, 0, 0, 0, 0, 0,&pNSSid ) )
    {
        FreeSid(pLSSid);
        return GetLastError();
    }
    
    
    //get dacl
    err = GetDacl(pNameSD->m_pSD, &pDacl );

    if( err == ERROR_SUCCESS ) {
        
        
        if(!pDacl) 
        {
            //It shuold never be in our case 
            //so we return error here
            FreeSid(pLSSid);
            FreeSid(pNSSid);
            return ERROR_INVALID_PARAMETER;
        }
        
        //let's add it
        err = AddUserToDacl( hKeyParent, pDacl, pLSSid, 
            WINSTATION_QUERY | WINSTATION_MSG, pNameSD ); 
        if(err == ERROR_SUCCESS)
        {
            //SD has been changed. It makes pDacl invalid.
            //So we need to get it again
            err = GetDacl(pNameSD->m_pSD, &pDacl );
            
            ASSERT(pDacl);

            if(err == ERROR_SUCCESS)
            {
                err = AddUserToDacl( hKeyParent, pDacl, pNSSid, 
                    WINSTATION_QUERY | WINSTATION_MSG, pNameSD );
            }
        }

    }
    
    FreeSid(pLSSid);
    FreeSid(pNSSid);
    return err;
}

/*****************************************************************************
 *
 *  AddUserToDacl
 *
 *   Grants 
 *   WINSTATION_USER_ACCESS
 *   permissions to a winstation to user, defined by SID
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN PACL pOldACL:   pointer to prewvious DACL of the key
 *   IN PSID pSid:      pointer to SID of user to grant permissions to
 *   IN DWORD dwAccessMask: access flags for this SID
 *   IN CNameAndSD *pNameSD  - name and security descriptor of a winstation
 * NOTES:
 *
 * EXIT:
 *  Returns: error code if cannot grant permissions; ERROR_SUCCESS otherwise.
 *
 ****************************************************************************/

DWORD 
AddUserToDacl(
        IN HKEY hKeyParent,
        IN PACL pOldACL, 
        IN PSID pSid,
        IN DWORD dwAccessMask,
        IN CNameAndSD *pNameSD)
{
    //See if this user is already in the DACL.
    //In this case don't add the user
    //search ACL for "REMOTE USERS"  SID
    ACL_SIZE_INFORMATION asiAclSize; 
	DWORD dwBufLength=sizeof(asiAclSize);
    ACCESS_ALLOWED_ACE *paaAllowedAce; 
    DWORD dwAcl_i;
    
    ASSERT(pOldACL);

    if (GetAclInformation(pOldACL, 
                (LPVOID)&asiAclSize, 
                (DWORD)dwBufLength, 
                (ACL_INFORMATION_CLASS)AclSizeInformation)) 
    { 
    
        for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount; dwAcl_i++) 
        { 

            if(GetAce( pOldACL, dwAcl_i, (LPVOID *)&paaAllowedAce)) 
            {

                if(EqualSid((PSID)&(paaAllowedAce->SidStart),pSid)) 
                {
                    //some permission already exist, we don't need to 
                    //do anything (even if it is a different permission!)
                    return ERROR_SUCCESS;
                }
            }
        }
    }

    DWORD err=ERROR_SUCCESS;
    PACL pNewACL;
    ACCESS_ALLOWED_ACE *pNewACE;

    //calculate space needed for 1 additional ACE
    WORD wSidSize=(WORD)GetLengthSid( pSid);
    WORD wAceSize=(sizeof(ACCESS_ALLOWED_ACE)+wSidSize-sizeof( DWORD ));
    
	pNewACL=(PACL)LocalAlloc(LPTR,pOldACL->AclSize+wAceSize);
    if(!pNewACL) 
    {
        return GetLastError();
    }
    //copy old ACL to new ACL
    memcpy(pNewACL,pOldACL,pOldACL->AclSize);
    //correct size
    pNewACL->AclSize+=wAceSize;
	
    //prepare new ACE
    //----------------------------------------------------------
    pNewACE=(ACCESS_ALLOWED_ACE*)LocalAlloc(LPTR,wAceSize);
    if(!pNewACE) 
    {
        LocalFree(pNewACL);
        return GetLastError();
    }

    pNewACE->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pNewACE->Header.AceFlags = 0;
    pNewACE->Header.AceSize = wAceSize;
    pNewACE->Mask = dwAccessMask;
    CopySid( wSidSize, (PSID) &(pNewACE->SidStart), pSid);
    
    //append new ACE to the ACL
     if(!AddAce(pNewACL,pNewACL->AclRevision,MAXDWORD,pNewACE,wAceSize)) 
    {
        err=GetLastError();
    }
    else
    {
        //create new security descriptor
        SECURITY_DESCRIPTOR NewAbsSD;
        if(InitializeSecurityDescriptor(&NewAbsSD, SECURITY_DESCRIPTOR_REVISION) && 
            SetSecurityDescriptorDacl(&NewAbsSD,TRUE,pNewACL,FALSE) ) 
        {

            //---------------------------------------------------------
            //Copy all other stuff from the old SD to the new SD
            SECURITY_DESCRIPTOR_CONTROL sdc;
            DWORD dwRevision;
            if(GetSecurityDescriptorControl(pNameSD->m_pSD,&sdc,&dwRevision))
            {
                //Clear SE_SELF_RELATIVE flag
                sdc &=~SE_SELF_RELATIVE;

                SetSecurityDescriptorControl(&NewAbsSD,sdc,sdc);
            }
            
            PSID pSid = NULL;
            BOOL bDefaulted;
            if(GetSecurityDescriptorOwner(pNameSD->m_pSD,&pSid,&bDefaulted) && pSid)
            {
                SetSecurityDescriptorOwner(&NewAbsSD,pSid,bDefaulted);                
            }
            
            pSid = NULL;
            if(GetSecurityDescriptorGroup(pNameSD->m_pSD,&pSid,&bDefaulted) && pSid)
            {
                SetSecurityDescriptorGroup(&NewAbsSD,pSid,bDefaulted);                
            }
            
            PACL pSacl = NULL;
            BOOL bSaclPresent;
            if(GetSecurityDescriptorSacl(pNameSD->m_pSD,&bSaclPresent,&pSacl,&bDefaulted))
            {
                SetSecurityDescriptorSacl(&NewAbsSD,bSaclPresent,pSacl,bDefaulted);
            }
            //---------------------------------------------------------

            DWORD dwSDLen = GetSecurityDescriptorLength( &NewAbsSD ); 
            PSECURITY_DESCRIPTOR pSD;

            pSD = ( PSECURITY_DESCRIPTOR )LocalAlloc(LPTR,dwSDLen);
            
            if(pSD)
            {
                if(MakeSelfRelativeSD( &NewAbsSD , pSD , &dwSDLen ))
                {
                    err = SetWinStationSecurity(hKeyParent, pNameSD->m_pName, pSD );
                    if(err == ERROR_SUCCESS)
                    {
                        pNameSD->SetSD(pSD);
                    }
                }
                else
                {
                     err=GetLastError();
                }
            }
            else
            {
                err=GetLastError();
            }
        }
        else
        {
            err=GetLastError();
        }
      
    }
    
    LocalFree(pNewACE);
    LocalFree(pNewACL);
    return err;    
}

/*****************************************************************************
 *
 *  GetDacl
 *
 *   Gets security descriptor DACL.
 *
 * ENTRY:
 *  
 *  IN PSECURITY_DESCRIPTOR *pSD: pointer to SD
 *  OUT PACL *ppDacl:  pointer to pointer to DACL inside SD
 *  
 * NOTES:
 *      Do not try to free DACL!
 *
 * EXIT:
 *  Returns: error code if cannot get DACL; ERROR_SUCCESS otherwise.
 *
 ****************************************************************************/

DWORD 
GetDacl(
        IN PSECURITY_DESCRIPTOR pSD, 
        OUT PACL *ppDacl)
{
	
    BOOL bDaclPresent;
    BOOL bDaclDefaulted;
    
    *ppDacl=NULL;
 
    if(GetSecurityDescriptorDacl(pSD,&bDaclPresent,ppDacl,&bDaclDefaulted)) {
        if(!bDaclPresent){
            *ppDacl=NULL;
        }
    } else {
        return GetLastError();
    }
    
    return ERROR_SUCCESS;
} 

/*****************************************************************************
 *
 *  GetSacl
 *
 *   Gets security descriptor SACL.
 *
 * ENTRY:
 *  
 *  IN PSECURITY_DESCRIPTOR *pSD: pointer to SD
 *  OUT PACL *ppSacl:  pointer to pointer to SACL inside SD
 *  
 * NOTES:
 *      Do not try to free SACL!
 *
 * EXIT:
 *  Returns: error code if cannot get SACL; ERROR_SUCCESS otherwise.
 *
 ****************************************************************************/

DWORD 
GetSacl(
        IN PSECURITY_DESCRIPTOR pSD, 
        OUT PACL *ppSacl)
{
	
    BOOL bSaclPresent;
    BOOL bSaclDefaulted;
    
    *ppSacl=NULL;
 
    if(GetSecurityDescriptorSacl(pSD,&bSaclPresent,ppSacl,&bSaclDefaulted)) {
        if(!bSaclPresent){
            *ppSacl=NULL;
        }
    } else {
        return GetLastError();
    }
    
    return ERROR_SUCCESS;
}

/*****************************************************************************
 *
 *  EnumWinStationSecurityDescriptors
 *
 *   Enumerates winstations and gets their security descriptors
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   OUT CNameAndSDList  - name and security descriptor of a winstation
 * NOTES:
 *      Call LocalFree function to free SD, do not try to free DACL!
 *
 * EXIT:
 *  Returns: error code or ERROR_SUCCESS
 *
 ****************************************************************************/
DWORD 
EnumWinStationSecurityDescriptors(
        IN  HKEY hKeyParent,
        OUT CNameAndSDList *pNameSDList)
{
    DWORD err;
    
	DWORD dwIndex;
	TCHAR wszTmpName[MAX_PATH+1];
	DWORD cbTmpName=MAX_PATH;
	FILETIME ftLastWriteTime;
    
	for(dwIndex=0;;dwIndex++)
	{
		cbTmpName=MAX_PATH;
		err=RegEnumKeyEx(
					hKeyParent, 	// handle of key to enumerate
					dwIndex, 	// index of subkey to enumerate
					wszTmpName, 	// address of buffer for subkey name
					&cbTmpName,  // address for size of subkey buffer
					NULL, // reserved
					NULL, // address of buffer for class string
					NULL, // address for size of class buffer
					&ftLastWriteTime // address for time key last written to
					);
		if((err!=ERROR_SUCCESS)&&
			(err!=ERROR_MORE_DATA)&&
			 (err!=ERROR_NO_MORE_ITEMS))
		{
			return err;
		}
		if(err==ERROR_NO_MORE_ITEMS)
			break;

		else
		{
            CNameAndSD Entry(wszTmpName);
            err = GetWinStationSecurity(hKeyParent, Entry.m_pName, 
                _T("Security"), &(Entry.m_pSD));

            if( err == ERROR_SUCCESS || err == ERROR_FILE_NOT_FOUND )
            {
                pNameSDList->push_back(Entry);
            }

        }
	}

    return ERROR_SUCCESS;
}


/*****************************************************************************
 *
 *  GetWinStationSecurity
 *
 *   Returns WinStation's security descriptor.
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN  PWINSTATIONNAMEW pWSName  - name  of a winstation 
 *                        if pWSName is NULL - function returns default SD
 *   OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor - pointer to pointer to SD
 *
 * NOTES:
 *      Call LocalFree function to free SD!
 *
 * EXIT:
 *  Returns: error code or ERROR_SUCCESS 
 *
 ****************************************************************************/
DWORD 
GetWinStationSecurity( 
        IN  HKEY hKeyParent,
        IN  PWINSTATIONNAME pWSName,
        IN  LPCTSTR szValueName,  
        OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor)
{

    DWORD SDLength = 0;
    DWORD ValueType =0;
    HKEY hKey = NULL;
    DWORD err;

    *ppSecurityDescriptor = NULL;
    
    if(pWSName)
    {
        err = RegOpenKeyEx(hKeyParent, pWSName, 0,KEY_READ, &hKey );
    }
    else
    {
        //If pWSName - get defauilt SD
        hKey = hKeyParent;
        err = ERROR_SUCCESS;
    }

    if(err == ERROR_SUCCESS)
    {
        err = RegQueryValueEx( hKey, szValueName, NULL, &ValueType,NULL, &SDLength );
        if(err == ERROR_SUCCESS )
        {
            //Return error if not correct data type
            if (ValueType == REG_BINARY)
            {
 
                //Allocate a buffer to read the Security info and read it
                // ACLUI uses LocalFree
            
                *ppSecurityDescriptor = ( PSECURITY_DESCRIPTOR )LocalAlloc( LMEM_FIXED , SDLength );

                if ( *ppSecurityDescriptor )
                {
 
                    err = RegQueryValueEx( hKey, szValueName, NULL, &ValueType,
                                (BYTE *) *ppSecurityDescriptor, &SDLength );
                    if(err == ERROR_SUCCESS )
                    {
                        //Check for a valid SD before returning.
                        if(! IsValidSecurityDescriptor( *ppSecurityDescriptor ) )
                        {
                            LocalFree(*ppSecurityDescriptor);
                            *ppSecurityDescriptor = NULL;
                            err = ERROR_INVALID_DATA;
                        }
                    }
                    else
                    {
                        LocalFree(*ppSecurityDescriptor);
                        *ppSecurityDescriptor = NULL;
                    }
                }
                else
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else
            {
                err = ERROR_INVALID_DATA;
            }
        }
        
        if(hKey != hKeyParent)
        {
            RegCloseKey(hKey);
        }
    }
    
    return err;

}  // GetWinStationSecurity

/*****************************************************************************
 *
 *  SetWinStationSecurity
 *
 *   Writes winstation security descriptor to the registry
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN PWINSTATIONNAMEW pWSName  - name of a winstation
 *   IN PSECURITY_DESCRIPTOR pSecurityDescriptor - pointer to SD
 *  
 * NOTES:
 *      Call LocalFree function to free SD, do not try to free DACL!
 *
 * EXIT:
 *  Returns: 0: if success
 *           Error code: otherwise
 *
 ****************************************************************************/

DWORD 
SetWinStationSecurity( 
        IN  HKEY hKeyParent,
        IN  PWINSTATIONNAME pWSName,
        IN  PSECURITY_DESCRIPTOR pSecurityDescriptor )
{

    HKEY hKey = NULL;
    DWORD err;

    err = RegOpenKeyEx(hKeyParent, pWSName, 0,KEY_WRITE, &hKey );
    if(err == ERROR_SUCCESS)
    {
        err = RegSetValueEx(hKey, _T("Security"),0,REG_BINARY,(LPBYTE)pSecurityDescriptor,
                    GetSecurityDescriptorLength(pSecurityDescriptor));

        RegCloseKey(hKey);
    }
    
    return err;

}  // SetWinStationSecurity


/*****************************************************************************
 *
 *  RemoveWinStationSecurity
 *
 *   Removes winstation's security descriptor from the registry
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN PWINSTATIONNAMEW pWSName  - name of a winstation
 *  
 * NOTES:
 *      
 *
 * EXIT:
 *  Returns: 0: if success
 *           Error code: otherwise
 *
 ****************************************************************************/
DWORD
RemoveWinstationSecurity( 
        IN  HKEY hKeyParent,
        IN  PWINSTATIONNAME pWSName)
{
    HKEY hKey = NULL;
    DWORD err;

    err = RegOpenKeyEx(hKeyParent, pWSName, 0,KEY_WRITE, &hKey );
    if(err == ERROR_SUCCESS)
    {
        err = RegDeleteValue(hKey, _T("Security"));

        RegCloseKey(hKey);
    }
    
    return err;
}

/*****************************************************************************
 *
 *  SetNewDefaultSecurity
 *
 *   Sets new default security descriptor
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *  
 * NOTES:
 *      
 *
 * EXIT:
 *  Returns: 0: if success
 *           Error code: otherwise
 *
 ****************************************************************************/
DWORD
SetNewDefaultSecurity( 
        IN  HKEY hKey)
{
    //
    DWORD err;
    err = RegSetValueEx(hKey, _T("DefaultSecurity"), 0, REG_BINARY, 
        (LPBYTE)g_DefaultSD, sizeof(g_DefaultSD));

    return err;
}

/*****************************************************************************
 *
 *  SetNewConsoleSecurity
 *
 *   Sets new console security descriptor
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN BOOL bServer
 * NOTES:
 *      
 *
 * EXIT:
 *  Returns: 0: if success
 *           Error code: otherwise
 *
 ****************************************************************************/
DWORD
SetNewConsoleSecurity( 
        IN  HKEY hKeyParent,
        IN BOOL bServer)
{
    //
    DWORD err;
    
    //Set default console security
    if(bServer)
    {
        err = RegSetValueEx(hKeyParent, _T("ConsoleSecurity"), 0, REG_BINARY, 
            (LPBYTE)g_ConsoleSD, sizeof(g_ConsoleSD));
    }
    else
    { 
        // on Professional it's the same as "DefaultSecurity"
        err = RegSetValueEx(hKeyParent, _T("ConsoleSecurity"), 0, REG_BINARY, 
            (LPBYTE)g_DefaultSD, sizeof(g_DefaultSD));
    }

    return err;
}

/*****************************************************************************
 *
 *  CDefaultSD::DoesDefaultSDHaveRemoteUsers
 *
 *   Checks if defauilt SD has "Remote Desktop Users" SID. 
 *
 * ENTRY:
 *   OUT LPBOOL pbHas - TRUE if defauilt SD has "Remote Desktop Users" SID. 
 *  
 * NOTES:
 *  
 * EXIT:
 *  Returns: 0: if success
 *           Error code: otherwise
 *
 ****************************************************************************/
DWORD 
CDefaultSD::DoesDefaultSDHaveRemoteUsers(
        OUT LPBOOL pbHas)
{
    *pbHas = FALSE;
    //
    DWORD err = ERROR_SUCCESS;
    
    PACL pDacl = NULL;

    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID pRUSid=NULL;
    
    if( !AllocateAndInitializeSid( &sia, 2,
              SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS, 
              0, 0, 0, 0, 0, 0,&pRUSid ) )
    {
        return GetLastError();
    }

    
    
    //get dacl
    err = GetDacl(m_pSD, &pDacl );

    if( err == ERROR_SUCCESS ) {
        //search ACL for "REMOTE USERS"  SID
        ACL_SIZE_INFORMATION asiAclSize; 
	    DWORD dwBufLength=sizeof(asiAclSize);
        ACCESS_ALLOWED_ACE *paaAllowedAce; 
        DWORD dwAcl_i;
        
        if(!pDacl) 
        {
            //It shuold never be in our case 
            //so we return error here
            FreeSid(pRUSid);
            return ERROR_INVALID_PARAMETER;
        }
        else
        //DACL present
        {

            if (GetAclInformation(pDacl, 
	            (LPVOID)&asiAclSize, 
	            (DWORD)dwBufLength, 
	            (ACL_INFORMATION_CLASS)AclSizeInformation)) 
            { 
	        
                for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount; dwAcl_i++) 
                { 

		            if(GetAce( pDacl, dwAcl_i, (LPVOID *)&paaAllowedAce)) 
                    {

                        if(EqualSid((PSID)&(paaAllowedAce->SidStart),pRUSid)) 
                        {
                            //permission already exist, we don't need to 
                            //do anything

                            *pbHas = TRUE;
		                }
                    }
                }
            }
        }
        
    }
    
    FreeSid(pRUSid);
    return err;
}

//*************************************************************
//
//  LookupSid()
//
//  Purpose:   Given SID allocates and returns string containing 
//             name of the user in format DOMAINNAME\USERNAME
//
//  Parameters: IN PSID pSid
//              OUT LPWSTR ppName 
//              OUT SID_NAME_USE *peUse   
//
//  Return:     TRUE if success, FALSE otherwise
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              10/23/00    skuzin     Created
//
//*************************************************************
BOOL
LookupSid(
    IN PSID pSid, 
    OUT LPWSTR *ppName,
    OUT SID_NAME_USE *peUse)
{
    LPWSTR szName = NULL;
    DWORD cName = 0;
    LPWSTR szDomainName = NULL;
    DWORD cDomainName = 0;
    
    *ppName = NULL;
    
    if(!LookupAccountSidW(NULL,pSid,
        szName,&cName,
        szDomainName,&cDomainName,
        peUse) && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        //cName and cDomainName include terminating 0
        *ppName = (LPWSTR)LocalAlloc(LPTR,(cName+cDomainName)*sizeof(WCHAR));

        if(*ppName)
        {
            szDomainName = *ppName;
            szName = &(*ppName)[cDomainName];

            if(LookupAccountSidW(NULL,pSid,
                    szName,&cName,
                    szDomainName,&cDomainName,
                    peUse))
            {
                //user name now in format DOMAINNAME\0USERNAME
                //let's replace '\0' with  '\\'
                //now cName and cDomainName do not include terminating 0
                //very confusing
                if(cDomainName)
                {
                    (*ppName)[cDomainName] = L'\\';
                }
                return TRUE;
            }
            else
            {
                LocalFree(*ppName);
                *ppName = NULL;
            }

        }

    }

    return FALSE;
}

//*************************************************************
//
//  IsLocal()
//
//  Purpose:    
//
//  Parameters: wszDomainandname   -  domain\user
//              determines whether the user is local or not
//              if local - cuts out domain name 
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************
BOOL 
IsLocal(
        IN LPWSTR wszLocalCompName,
        IN OUT LPWSTR wszDomainandname)
{

    LPWSTR wszTmp = wcschr(wszDomainandname,L'\\');

    if(!wszTmp)
    {
        return TRUE;
    }

    if(!_wcsnicmp(wszDomainandname, wszLocalCompName,wcslen(wszLocalCompName) ))
    {
        //get rid of useless domain name
        wcscpy(wszDomainandname,wszTmp+1);
        return TRUE;
    }

    return FALSE;

}

//*************************************************************
//
//  GetAbsoluteSD()
//
//  Purpose:   Converts self-relative SD to absolute SD
//             returns pointers to SACL DACL Owner and Group 
//             of the absolute SD.
//
//  Parameters:
//             IN PSECURITY_DESCRIPTOR pSelfRelativeSD
//             OUT PSECURITY_DESCRIPTOR *ppAbsoluteSD
//             OUT PACL *ppDacl
//             OUT PACL *ppSacl
//             OUT PSID *ppOwner
//             OUT PSID *ppPrimaryGroup 
//
//  Return:  error code if fails, ERROR_SUCCESS otherwise
//
//  Comments: caller needs to free 
//            every returned pointer using LocalFree function.
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************
DWORD
GetAbsoluteSD(
        IN PSECURITY_DESCRIPTOR pSelfRelativeSD,
        OUT PSECURITY_DESCRIPTOR *ppAbsoluteSD,
        OUT PACL *ppDacl,
        OUT PACL *ppSacl,
        OUT PSID *ppOwner,
        OUT PSID *ppPrimaryGroup)
{
    DWORD dwAbsoluteSDSize = 0;           // absolute SD size
    DWORD dwDaclSize = 0;                 // size of DACL
    DWORD dwSaclSize = 0;                 // size of SACL
    DWORD dwOwnerSize = 0;                // size of owner SID
    DWORD dwPrimaryGroupSize = 0;         // size of group SID

    *ppAbsoluteSD = NULL;
    *ppDacl = NULL;
    *ppSacl = NULL;
    *ppOwner = NULL;
    *ppPrimaryGroup = NULL;

    MakeAbsoluteSD(
              pSelfRelativeSD, // self-relative SD
              NULL,     // absolute SD
              &dwAbsoluteSDSize,           // absolute SD size
              NULL,                           // DACL
              &dwDaclSize,                 // size of DACL
              NULL,                           // SACL
              &dwSaclSize,                 // size of SACL
              NULL,                          // owner SID
              &dwOwnerSize,                // size of owner SID
              NULL,                   // primary-group SID
              &dwPrimaryGroupSize          // size of group SID
            );
    try
    {
        if(dwAbsoluteSDSize)
        {
            *ppAbsoluteSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR,dwAbsoluteSDSize);
            if(!(*ppAbsoluteSD))
            {
                throw GetLastError();
            }
        }
        if(dwDaclSize)
        {
            *ppDacl = (PACL)LocalAlloc(LPTR,dwDaclSize);
            if(!(*ppDacl))
            {
                throw GetLastError();
            }
        }
        if(dwSaclSize)
        {
            *ppSacl = (PACL)LocalAlloc(LPTR,dwSaclSize);
            if(!(*ppSacl))
            {
                throw GetLastError();
            }
        }
        if(dwOwnerSize)
        {
            *ppOwner = (PSID)LocalAlloc(LPTR,dwOwnerSize);
            if(!(*ppOwner))
            {
                throw GetLastError();
            }
        }
        if(dwPrimaryGroupSize)
        {
            *ppPrimaryGroup = (PSID)LocalAlloc(LPTR,dwPrimaryGroupSize);
            if(!(*ppPrimaryGroup))
            {
                throw GetLastError();
            }
        }

        if(!MakeAbsoluteSD(
                  pSelfRelativeSD, // self-relative SD
                  *ppAbsoluteSD,     // absolute SD
                  &dwAbsoluteSDSize,           // absolute SD size
                  *ppDacl,                           // DACL
                  &dwDaclSize,                 // size of DACL
                  *ppSacl,                           // SACL
                  &dwSaclSize,                 // size of SACL
                  *ppOwner,                          // owner SID
                  &dwOwnerSize,                // size of owner SID
                  *ppPrimaryGroup,                   // primary-group SID
                  &dwPrimaryGroupSize          // size of group SID
                ))
        {
            throw GetLastError();
        }

    }
    catch(DWORD ret)
    {
        if(*ppAbsoluteSD)
        {
            LocalFree(*ppAbsoluteSD);
            *ppAbsoluteSD = NULL;
        }
        if(*ppDacl)
        {
            LocalFree(*ppDacl);
            *ppDacl = NULL;
        }
        if(*ppSacl)
        {
            LocalFree(*ppSacl);
            *ppSacl = NULL;
        }
        if(*ppOwner)
        {
            LocalFree(*ppOwner);
            *ppOwner = NULL;
        }
        if(*ppPrimaryGroup)
        {
            LocalFree(*ppPrimaryGroup);
            *ppPrimaryGroup = NULL;
        }

        return ret;
    }

    return ERROR_SUCCESS;
}

//*************************************************************
//
//  GetAbsoluteSD()
//
//  Purpose:   Converts absolute SD to self-relative SD
//             returns pointer to self-relative SD.
//
//  Parameters:
//             IN  PSECURITY_DESCRIPTOR pAbsoluteSD,
//             OUT PSECURITY_DESCRIPTOR *ppSelfRelativeSD
//
//  Return:   error code if fails, ERROR_SUCCESS otherwise
//
//  Comments: caller needs to free 
//            returned pointer using LocalFree function.
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************
DWORD
GetSelfRelativeSD(
  IN  PSECURITY_DESCRIPTOR pAbsoluteSD,
  OUT PSECURITY_DESCRIPTOR *ppSelfRelativeSD)
{
    DWORD dwBufferLength = 0;

    *ppSelfRelativeSD = NULL;

    MakeSelfRelativeSD(pAbsoluteSD, NULL, &dwBufferLength);
    
    if(dwBufferLength)
    {
        *ppSelfRelativeSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR,dwBufferLength);

        if(*ppSelfRelativeSD)
        {
            if(!MakeSelfRelativeSD(pAbsoluteSD, *ppSelfRelativeSD, &dwBufferLength))
            {
                DWORD dwResult = GetLastError();
                LocalFree(*ppSelfRelativeSD);
                return dwResult;
            }
        }

    }
    else
    {
        return GetLastError();
    }
    
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\state.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
*
*  State.cpp
*
*  Routines to gather various state information.
*
*/

//
//	Includes
//


#define _STATE_CPP_

#include "stdafx.h"
#include "hydraoc.h"


// local functions
BOOL ReadStringFromAnsewerFile (LPTSTR *szValue);
BOOL ReadIntFromAnswerFile(LPCTSTR szSection, LPCTSTR szKey, int *piValue);

BOOL GetAllowConnectionFromAnswerFile (BOOL *pbAllowConnection);
BOOL GetPermissionsSettingsFromUnAttendedFile (EPermMode *pPermMode );
BOOL GetAppModeFromAnswerFile (BOOL *pbEnableAppCompat);


// global state object.
TSState StateObject;

//
// OC State Function Definitions
//

BOOL DoesTSAppCompatKeyExist( VOID )
{
    return TRUE;
}

BOOL ReadIntFromAnswerFile(LPCTSTR szSection, LPCTSTR szKey, int *piValue)
{
    ASSERT(szSection);
    ASSERT(szKey);
    ASSERT(piValue);
    
    HINF hInf = GetUnAttendedInfHandle();
    if (hInf)
    {
        INFCONTEXT InfContext;
        if (SetupFindFirstLine( hInf, szSection, szKey, &InfContext))
        {
            return SetupGetIntField( &InfContext, 1, piValue );
        }
    }
    
    return FALSE;
}


BOOL ReadStringFromAnsewerFile (LPCTSTR szSection, LPCTSTR szKey, LPTSTR szValue, DWORD dwBufferSize)
{
    ASSERT(szSection);
    ASSERT(szKey);
    ASSERT(szValue);
    ASSERT(dwBufferSize > 0);
    
    HINF hInf = GetUnAttendedInfHandle();
    
    if (hInf)
    {
        INFCONTEXT InfContext;
        if (SetupFindFirstLine(hInf, szSection, szKey, &InfContext))
        {
            return SetupGetStringField (&InfContext, 1, szValue, dwBufferSize, NULL);
        }
    }
    
    return FALSE;
}

BOOL GetAllowConnectionFromAnswerFile (BOOL *pbAllowConnection)
{
    ASSERT(pbAllowConnection);
    int iValue;
    if (ReadIntFromAnswerFile(TS_UNATTEND_SECTION, TS_ALLOW_CON_ENTRY, &iValue))
    {
        LOGMESSAGE2(_T("Found %s in unattended, Value = %d"), TS_ALLOW_CON_ENTRY, iValue);
        if (iValue == 1)
        {
            *pbAllowConnection = TRUE;
        }
        else if (iValue == 0)
        {
            *pbAllowConnection = FALSE;
        }
        else
        {
            LOGMESSAGE2(_T("ERROR, Invalid value for %s (%d)in answer file. Ignoring..."), TS_ALLOW_CON_ENTRY, iValue);
            return FALSE;
        }
        
        return TRUE;
    }
    else
    {
        //
        // if we did not find TS_ALLOW_CON_ENTRY in answer file, then look for TS_ALLOW_CON_ENTRY_2
        if (ReadIntFromAnswerFile(TS_UNATTEND_SECTION, TS_ALLOW_CON_ENTRY_2, &iValue))
        {
            LOGMESSAGE2(_T("Found %s in unattended, Value = %d"), TS_ALLOW_CON_ENTRY_2, iValue);
            if (iValue == 1)
            {
                *pbAllowConnection = TRUE;
            }
            else if (iValue == 0)
            {
                *pbAllowConnection = FALSE;
            }
            else
            {
                LOGMESSAGE2(_T("ERROR, Invalid value for %s (%d)in answer file. Ignoring..."), TS_ALLOW_CON_ENTRY_2, iValue);
                return FALSE;
            }
            
            return TRUE;
        }
        
    }
    
    LOGMESSAGE0(_T("answer file entry for allowconnection not found"));
    
    return FALSE;
}

BOOL GetAppModeFromAnswerFile  (BOOL *pbEnableAppCompat)
{
    ASSERT(pbEnableAppCompat);
    
    TCHAR szBuffer[256];
    if (ReadStringFromAnsewerFile(_T("Components"), APPSRV_COMPONENT_NAME, szBuffer, 256))
    {
        ASSERT(szBuffer);
        if (0 == _tcsicmp(_T("on"), szBuffer))
        {
            *pbEnableAppCompat = TRUE;
        }
        else if (0 == _tcsicmp(_T("off"), szBuffer))
        {
            *pbEnableAppCompat = FALSE;
        }
        else
        {
            LOGMESSAGE2(_T("ERROR, Invalid value for %s (%s) in answer file. Ignoring..."), APPSRV_COMPONENT_NAME, szBuffer);
            return FALSE;
        }
        
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}

ETSLicensingMode GetLicensingModeFromAnswerFile()
{
	TCHAR szBuffer[256];

	if (ReadStringFromAnsewerFile(TS_UNATTEND_SECTION, TS_LICENSING_MODE, szBuffer, 256))
	{
		if (0 == _tcsicmp(_T("perseat"), szBuffer))
		{
			return eLicPerSeat;
		}
		else if (0 == _tcsicmp(_T("persession"), szBuffer))
		{
			return eLicPerSession;
		}
		else if (0 == _tcsicmp(_T("pts"), szBuffer))
		{
			return eLicPTS;
		}
		else if (0 == _tcsicmp(_T("remoteadmin"), szBuffer))
		{
			return eLicRemoteAdmin;
		}
		else if (0 == _tcsicmp(_T("internetconnector"), szBuffer))
		{
			return eLicInternetConnector;
		}
		else
		{
			LOGMESSAGE2(_T("ERROR, Invalid value for %s (%s) in answer file. Ignoring..."), TS_UNATTEND_SECTION, szBuffer);
			return eLicUnset;
		}
    }
    else
    {
        return eLicUnset;
    }

}

BOOL GetPermissionsSettingsFromUnAttendedFile( EPermMode *pPermMode )
{
    ASSERT(pPermMode);
    
    int iValue;	
    if (ReadIntFromAnswerFile(TS_UNATTEND_SECTION, TS_UNATTEND_PERMKEY, &iValue))
    {
        if (iValue == PERM_TS4)
        {
            *pPermMode = PERM_TS4;
        }
        else if (iValue == PERM_WIN2K)
        {
            *pPermMode = PERM_WIN2K;
        }
        else
        {
            LOGMESSAGE2(_T("ERROR, Invalid value for %s (%d) in answer file, ignoring..."), TS_UNATTEND_PERMKEY, iValue);
            return FALSE;
        }
        
        return TRUE;
    }
    
    return FALSE;
}


DWORD SetTSVersion (LPCTSTR pszVersion)
{
    CRegistry pReg;
    DWORD dwRet;
    
    dwRet = pReg.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
    if (dwRet == ERROR_SUCCESS)
    {
        dwRet = pReg.WriteRegString(REG_PRODUCT_VER_KEY, pszVersion);
    }
    
    return(dwRet);
}

BOOL WasTSInstalled (VOID)
{
    return (StateObject.GetInstalltype() != eFreshInstallTS);
}

PSETUP_INIT_COMPONENT GetSetupData ()
{
    ASSERT(StateObject.GetSetupData());
    return(StateObject.GetSetupData());
}


ETSInstallType TSState::GetInstalltype () const
{
    return m_eInstallType;
}

ETSMode TSState::OriginalTSMode () const
{
    return m_eOriginalTSMode;
}

ETSMode TSState::CurrentTSMode () const
{
    return m_eCurrentTSMode;
}

ETSLicensingMode TSState::NewLicMode () const
{
	return m_eNewLicMode;
}

EPermMode TSState::OriginalPermMode () const
{
    return m_eOriginalPermMode;
}

EPermMode TSState::CurrentPermMode () const
{
    return m_eCurrentPermMode;
}

BOOL TSState::IsFreshInstall () const
{
    return !IsStandAlone() && !IsUpgrade();
}

BOOL TSState::IsTSFreshInstall () const
{
    return m_eInstallType == eFreshInstallTS;
}

BOOL TSState::IsUpgradeFrom40TS () const
{
    return m_eInstallType == eUpgradeFrom40TS;
}

BOOL TSState::IsUpgradeFrom50TS () const
{
    return m_eInstallType == eUpgradeFrom50TS;
}

BOOL TSState::IsUpgradeFrom51TS () const
{
    return m_eInstallType == eUpgradeFrom51TS;
}


BOOL TSState::IsUnattended () const
{
    return (GetSetupData()->SetupData.OperationFlags & SETUPOP_BATCH) ? TRUE : FALSE;
}

BOOL TSState::IsStandAlone () const
{
    return (GetSetupData()->SetupData.OperationFlags & SETUPOP_STANDALONE) ? TRUE : FALSE;
}

BOOL TSState::IsGuiModeSetup () const
{
    return !IsStandAlone();
}

BOOL TSState::IsWorkstation () const
{
    return m_osVersion.wProductType == VER_NT_WORKSTATION;
}

BOOL TSState::IsPersonal () const
{
    return m_osVersion.wSuiteMask & VER_SUITE_PERSONAL;
}

BOOL TSState::IsProfessional() const
{
    return IsWorkstation() && !IsPersonal();
}

BOOL TSState::IsServer () const
{
    return !IsWorkstation();
}

BOOL TSState::IsAdvServerOrHigher () const
{
    return IsServer () && ((m_osVersion.wSuiteMask & VER_SUITE_ENTERPRISE) || (m_osVersion.wSuiteMask & VER_SUITE_DATACENTER));
}

BOOL TSState::IsSBS() const
{
    return IsServer () && (m_osVersion.wSuiteMask & VER_SUITE_SMALLBUSINESS);
}

BOOL TSState::CanInstallAppServer () const
{
    return IsAdvServerOrHigher () || IsSBS ();
}

BOOL TSState::WasTSInstalled () const
{
    return !IsTSFreshInstall();
}

BOOL TSState::WasTSEnabled () const
{
    return this->WasTSInstalled() && m_eOriginalTSMode != eTSDisabled;
}

BOOL TSState::IsUpgrade () const
{
    return (GetSetupData()->SetupData.OperationFlags & (SETUPOP_NTUPGRADE |
        SETUPOP_WIN95UPGRADE |
        SETUPOP_WIN31UPGRADE)) ? TRUE : FALSE;
}

BOOL TSState::WasItAppServer () const
{
    return eAppServer == OriginalTSMode();
}

BOOL TSState::WasItRemoteAdmin () const
{
    return eRemoteAdmin == OriginalTSMode();
}

BOOL TSState::IsItAppServer () const
{
    //
    // if its app server, we must have app server selected.
    //
    ASSERT((eAppServer != CurrentTSMode()) || IsAppServerSelected());
    
    //
    // if you cannot select app server,it cannot be app server.
    //
    ASSERT((eAppServer != CurrentTSMode()) || CanInstallAppServer());
    return eAppServer == CurrentTSMode();
}


//
// this returns the app server selection state.
//
BOOL TSState::IsAppServerSelected () const
{
    return(
        GetHelperRoutines().QuerySelectionState(
        GetHelperRoutines().OcManagerContext,
        APPSRV_COMPONENT_NAME,
        OCSELSTATETYPE_CURRENT
        )
        );
}
BOOL TSState::IsItRemoteAdmin () const
{
    // if its RA we must not have app server selected.
    ASSERT((eRemoteAdmin != CurrentTSMode()) || !IsAppServerSelected());
    return eRemoteAdmin == CurrentTSMode();
}

BOOL TSState::IsAppSrvModeSwitch () const
{
    ASSERT(m_bNewStateValid); // you cannot ask if this is mode switch only in after completeinstall
    return WasItAppServer() != IsItAppServer();
}
BOOL TSState::IsTSModeChanging () const
{
    return CurrentTSMode() != OriginalTSMode();
}

BOOL TSState::HasChanged () const
{
    return ((CurrentTSMode() != OriginalTSMode()) ||
        (CurrentPermMode() != OriginalPermMode()));
}

BOOL TSState::IsTSEnableSelected  () const
{
    //
    // For whistler we dont disable TS ever. OS is always TS Enabled.
    // But for some reason if we want to privide TS Off facility. This function
    // Should return accordingly.
    //
    return TRUE;
}

void TSState::SetCurrentConnAllowed (BOOL bAllowed)
{
    // we must not allow connections for personal.
    ASSERT(!bAllowed || !IsPersonal());
    m_bCurrentConnAllowed = bAllowed;
}

BOOL TSState::GetCurrentConnAllowed () const
{
    return m_bCurrentConnAllowed;
}

BOOL TSState::GetOrigConnAllowed () const
{
    return m_bOrigConnAllowed;
}


TSState::TSState ()
{
    m_gpInitComponentData = NULL;
    m_bNewStateValid = FALSE;
}

TSState::~TSState ()
{
    if (m_gpInitComponentData)
        LocalFree (m_gpInitComponentData);
    
}

const PSETUP_INIT_COMPONENT TSState::GetSetupData () const
{
    ASSERT(m_gpInitComponentData);
    return m_gpInitComponentData;
}

BOOL TSState::SetSetupData (PSETUP_INIT_COMPONENT pSetupData)
{
    m_gpInitComponentData = (PSETUP_INIT_COMPONENT)LocalAlloc(LPTR, sizeof(SETUP_INIT_COMPONENT));
    
    if (m_gpInitComponentData == NULL)
    {
        return(FALSE);
    }
    
    CopyMemory(m_gpInitComponentData, pSetupData, sizeof(SETUP_INIT_COMPONENT));
    
    return(TRUE);
}

BOOL TSState::GetNTType ()
{
    
    ZeroMemory(&m_osVersion, sizeof(OSVERSIONINFOEX));
    m_osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (GetVersionEx((LPOSVERSIONINFO )&m_osVersion))
    {
        return TRUE;
        
    }
    else
    {
        LOGMESSAGE1(_T("GetVersionEx failed, Error = %d"), GetLastError());
        return FALSE;
    }
}

BOOL TSState::Initialize (PSETUP_INIT_COMPONENT pSetupData)
{
    
    ASSERT(pSetupData);
    
    if ( !SetSetupData(pSetupData))
    {
        return FALSE;
    }
    
    //
    // This is a necessary step.
    //
    
    if (GetComponentInfHandle())
        SetupOpenAppendInfFile(NULL, GetComponentInfHandle(), NULL);
    
    //
    // now populate our state variables.
    // first check if its a professional or server installation.
    //
    
    VERIFY( GetNTType() );
    
    m_eInstallType = ReadInstallType();
    
    // Set Original TS Mode.
    switch (m_eInstallType)
    {
    case eFreshInstallTS:
        m_eOriginalTSMode = eTSDisabled;
        break;
        
    case eUpgradeFrom40TS:
        m_eOriginalTSMode = eAppServer;
        break;
        
    case eUpgradeFrom50TS:
    case eUpgradeFrom51TS:
    case eStandAloneSetup:
        m_eOriginalTSMode = ReadTSMode ();
        break;
        
    default:
        ASSERT(FALSE);
        m_eOriginalTSMode = eTSDisabled;
        
    }
    
    // Set Original Permission Modes.
    if (m_eOriginalTSMode == eAppServer)
    {
        m_eOriginalPermMode = ReadPermMode();
    }
    else
    {
        m_eOriginalPermMode = PERM_WIN2K;
    }
    
    //
    // Set Original Connection Allowed Status.
    //
    if (m_eInstallType == eFreshInstallTS)
    {
        m_bOrigConnAllowed = FALSE;
    }
    else
    {
        m_bOrigConnAllowed = AreConnectionsAllowed();
    }
    
    
    //
    // now lets pick default values for the new installation.
    //
    if (m_eInstallType == eFreshInstallTS)
    {
        if (IsWorkstation())
        {
            SetCurrentTSMode (ePersonalTS);
            SetCurrentConnAllowed (FALSE);
        }
        else
        {
            SetCurrentTSMode (eRemoteAdmin);
            SetCurrentConnAllowed (TRUE);
        }
    }
    else
    {
        if (m_eOriginalTSMode == eTSDisabled)
        {
            //
            // for whistler we have TS always on.
            // so if ts was disabled perviously, set it to on after upgrade.
            // just disallow connections for such upgrades.
            //
            SetCurrentPermMode (PERM_WIN2K);
            SetCurrentTSMode (IsWorkstation() ? ePersonalTS : eRemoteAdmin);
            SetCurrentConnAllowed (FALSE);
        }
        else if (m_eOriginalTSMode == eAppServer && !CanInstallAppServer())
        {
            //
            // this is upgrade from an app server machine to whistler server.
            // we must downgrade this. since whistler server does not support app server anymore
            // app server is supported on adv server or higher.
            //
            SetCurrentPermMode (PERM_WIN2K);
            SetCurrentTSMode (eRemoteAdmin);
            SetCurrentConnAllowed (m_bOrigConnAllowed);
            LOGMESSAGE0(_T("WARNING:Your Terminal Server is uninstalled since its not supported in Server product. Terminal Server is supported only on Advanced Server or Datacenter products"));
            // LogErrorToSetupLog(OcErrLevWarning, IDS_STRING_TERMINAL_SERVER_UNINSTALLED);
        }
        else
        {
            
            //
            // for all other upgrade cases, retain the original values.
            //
            SetCurrentTSMode (m_eOriginalTSMode);
            SetCurrentPermMode (m_eOriginalPermMode);
            if (!IsPersonal())
            {
                SetCurrentConnAllowed (m_bOrigConnAllowed);
            }
            else
            {
                SetCurrentConnAllowed (FALSE);
            }
        }
    }
    
    //
    // Lets see if we are given the unattended file, to overwrite our new state
    //
    if (StateObject.IsUnattended())
    {
        ASSERT(eTSDisabled != CurrentTSMode());
        BOOL bAppServerMode;
        if (GetAppModeFromAnswerFile(&bAppServerMode))
        {
            LOGMESSAGE1(_T("Mode Setting is %s in answer file"), bAppServerMode ? _T("AppServer") : _T("RemoteAdmin"));
            if (!CanInstallAppServer())
            {
                // we support TS mode selection only on the adv server or data center.
                LOGMESSAGE0(_T("WARNING:Your unattended terminal server mode setting, can not be respected on this installation."));
                
                if (IsWorkstation())
                {
                    SetCurrentTSMode (ePersonalTS);
                }
                else
                {
                    ASSERT(IsServer());
                    SetCurrentTSMode (eRemoteAdmin);
                }
            }
            else
            {
                if (bAppServerMode)
                {
                    SetCurrentTSMode (eAppServer);
                }
                else
                {
                    SetCurrentTSMode (eRemoteAdmin);
                }
            }
        }
        
        EPermMode ePermMode;
        if (GetPermissionsSettingsFromUnAttendedFile(&ePermMode))
        {
            if (ePermMode == PERM_TS4)
            {
                if (m_eCurrentTSMode != eAppServer)
                {
                    LOGMESSAGE0(_T("WARNING:Your unattended setting:TS4 perm mode is inconsistent, can't be respected on professional or remote admin mode."));
                }
                else
                {
                    SetCurrentPermMode (PERM_TS4);
                }
            }
            else
            {
                SetCurrentPermMode (PERM_WIN2K);
            }
        }
        
        // Read Connection Allowed Settings.
        BOOL bAllowConnections;
        if (!IsPersonal() && GetAllowConnectionFromAnswerFile (&bAllowConnections))
        {
            SetCurrentConnAllowed (bAllowConnections);
        }
        
        // Read licensing mode
        ETSLicensingMode eLicMode;

        if (eLicUnset != (eLicMode = GetLicensingModeFromAnswerFile()))
        {
            if (!CanInstallAppServer() || ((eLicMode != eLicPerSeat) && (eLicMode != eLicPerSession)))
            {
                LOGMESSAGE0(_T("WARNING:Your unattended setting:licensing mode is inconsistent, can't be respected."));

                eLicMode = eLicUnset;
            }
        }
        SetNewLicMode(eLicMode);

    } // StateObject.IsUnattended()
    
    LogState();
    ASSERT( this->Assert () );
    return TRUE;
}

void TSState::UpdateState ()
{
    m_bNewStateValid = TRUE;
    if (IsAppServerSelected())
    {
        SetCurrentTSMode(eAppServer);
    }
    else
    {
        if (IsWorkstation())
        {
            SetCurrentTSMode(ePersonalTS);
        }
        else
        {
            SetCurrentTSMode(eRemoteAdmin);
        }
    }
    
    ASSERT(StateObject.Assert());
}

void TSState::SetCurrentTSMode (ETSMode eNewMode)
{
    //
    // we no more have ts disabled mode.
    //
    ASSERT(eNewMode != eTSDisabled);
    
    // 
    // On server machine you cannot have Personal TS.
    //
    ASSERT(IsServer() || eNewMode == ePersonalTS);
    
    // you can have app server only on advance server or higher.
    ASSERT(CanInstallAppServer() || eNewMode != eAppServer);
    
    m_eCurrentTSMode = eNewMode;
    
    if (eNewMode != eAppServer)
    {
        SetCurrentPermMode (PERM_WIN2K);
    }
}

void TSState::SetNewLicMode (ETSLicensingMode eNewMode)
{
	//
	// we no more have IC mode.
	//
	ASSERT(eNewMode != eLicInternetConnector);

	m_eNewLicMode = eNewMode;
}

void TSState::SetCurrentPermMode (EPermMode eNewMode)
{
    //
    // if you want to set perm mode to PERM_TS4, you must first set AppServer Mode.
    //
    // ASSERT(eNewMode != PERM_TS4 || CurrentTSMode() == eAppServer);
    
    m_eCurrentPermMode = eNewMode;
}

ETSInstallType TSState::ReadInstallType () const
{
    DWORD dwError;
    CRegistry oRegTermsrv;
    if ( IsUpgrade() )
    {
        dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
        if (ERROR_SUCCESS == dwError)
        {
            //
            // TS was installed originally
            //
            DWORD cbVersion = 0;
            LPTSTR szVersion = NULL;
            
            //
            //	Determine if this is a TS 4.0 upgrade.
            //
            dwError = oRegTermsrv.ReadRegString(REG_PRODUCT_VER_KEY, &szVersion, &cbVersion);
            if (ERROR_SUCCESS == dwError)
            {
                if ((_tcsicmp(szVersion, _T("5.1")) == 0))
                {
                    return eUpgradeFrom51TS;
                }
                else if ((_tcsicmp(szVersion, _T("5.0")) == 0))
                {
                    return eUpgradeFrom50TS;
                }
                else if ((_tcsicmp(szVersion, _T("4.0")) == 0) || (_tcsicmp(szVersion, _T("2.10")) == 0))
                {
                    return eUpgradeFrom40TS;
                }
                else
                {
                    LOGMESSAGE1(_T("Error, dont recognize previous TS version (%s)"), szVersion);
                    return eFreshInstallTS;
                }
            }
            else
            {
                LOGMESSAGE1(_T("Error, Failed to retrive previous TS version, Errorcode = %d"), dwError);
                return eFreshInstallTS;
            }
        }
        else
        {
            LOGMESSAGE1(_T("Could not Open TermSrv Registry, Must be Fresh TS install. Errorcode = %d"), dwError);
            return eFreshInstallTS;
        }
    }
    else
    {
        
        if (IsStandAlone())
        {
            return eStandAloneSetup;
        }
        else
        {
            //
            // this is fresh install.
            //
            return eFreshInstallTS;
        }
        
    }
}

ETSMode TSState::ReadTSMode () const
{
    DWORD dwError;
    CRegistry oRegTermsrv;
    
    dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
    if (ERROR_SUCCESS == dwError)
    {
        DWORD dwValue = 0;
        dwError = oRegTermsrv.ReadRegDWord(TS_ENABLED_VALUE, &dwValue);
        if (ERROR_SUCCESS == dwError)
        {
            if (dwValue == 1)
            {
                //
                // ts was enabled, now find out the mode.
                //
                if (oRegTermsrv.ReadRegDWord(TS_APPCMP_VALUE, &dwValue) == ERROR_SUCCESS)
                {
                    if (dwValue == 1)
                    {
                        ASSERT(IsServer());
                        return eAppServer;
                    }
                    else
                    {
                        if (IsWorkstation())
                        {
                            return ePersonalTS;
                        }
                        else
                        {
                            return eRemoteAdmin;
                        }
                    }
                }
                else
                {
                    LOGMESSAGE0(_T("Error, TSMode registry is missing...Is it Beta version of W2k ?"));
                    return eAppServer;
                }
            }
            else
            {
                return eTSDisabled;
            }
        }
        else
        {
            LOGMESSAGE0(_T("Error, Failed to retrive previous TS enabled state, Is it TS40 Box??."));
            return eTSDisabled;
        }
    }
    else
    {
        LOGMESSAGE1(_T("Error Opening TermSrv Registry, ErrorCode = %d"), dwError);
        return eTSDisabled;
        
    }
}

BOOL TSState::AreConnectionsAllowed () const
{
    DWORD dwError;
    CRegistry oRegTermsrv;
    
    dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
    if (ERROR_SUCCESS == dwError)
    {
        DWORD dwDenyConnect;
        dwError = oRegTermsrv.ReadRegDWord(DENY_CONN_VALUE, &dwDenyConnect);
        if (ERROR_SUCCESS == dwError)
        {
            return !dwDenyConnect;
        }
    }
    
    //
    // could not read registry, this means connections were allowed.
    //
    return TRUE;
}

EPermMode TSState::ReadPermMode () const
{
    DWORD dwError;
    CRegistry oRegTermsrv;
    
    dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
    if (ERROR_SUCCESS == dwError)
    {
        DWORD dwPerm;
        dwError = oRegTermsrv.ReadRegDWord(_T("TSUserEnabled"), &dwPerm);
        if (ERROR_SUCCESS == dwError)
        {
            switch(dwPerm)
            {
            case PERM_TS4:
            case PERM_WIN2K:
                return	(EPermMode)dwPerm;
                break;
                
            default:
                LOGMESSAGE1(_T("ERROR:Unrecognized, Permission value %d"), dwPerm);
                return	PERM_TS4;
                break;
            }
        }
        else
        {
            LOGMESSAGE1(_T("Warning Failed to read Permissions registry, Is it 40 TS / Beta 2000 upgrade > "), dwError);
            return PERM_TS4;
        }
        
    }
    else
    {
        LOGMESSAGE1(_T("Error Opening TermSrv Registry, Errorcode = %d"), dwError);
        return PERM_WIN2K;
        
    }
}

BOOL TSState::LogState () const
{
    static BOOL sbLoggedOnce = FALSE;
    
    if (!sbLoggedOnce)
    {
        LOGMESSAGE0(_T("Setup Parameters ****************************"));
        LOGMESSAGE1(_T("We are running on %s"), 	StateObject.IsWorkstation()		? _T("Wks")  : _T("Srv"));
        LOGMESSAGE1(_T("Is this adv server %s"), 	StateObject.IsAdvServerOrHigher()? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("Is this Personal (Home Edition) %s"), 	StateObject.IsPersonal()? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("Is this SBS server %s"), 	StateObject.IsSBS()				? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("IsStandAloneSetup = %s"),	StateObject.IsStandAlone()		? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("IsFreshInstall = %s"),		StateObject.IsFreshInstall()	? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("IsTSFreshInstall = %s"),	StateObject.IsTSFreshInstall()	? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("IsUnattendSetup = %s"), 	StateObject.IsUnattended()		? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("IsUpgradeFromTS40 = %s"),	StateObject.IsUpgradeFrom40TS() ? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("IsUpgradeFromNT50 = %s"),	StateObject.IsUpgradeFrom50TS() ? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("IsUpgradeFromNT51 = %s"),	StateObject.IsUpgradeFrom51TS() ? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("IsUnattended = %s"),		StateObject.IsUnattended()		? _T("Yes")  : _T("No"));
        
        LOGMESSAGE0(_T("Original State ******************************"));
        LOGMESSAGE1(_T("WasTSInstalled = %s"),		StateObject.WasTSInstalled()	? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("WasTSEnabled = %s"),		StateObject.WasTSEnabled()		? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("OriginalPermMode = %s"),	StateObject.OriginalPermMode() == PERM_TS4 ? _T("TS4") : _T("WIN2K"));
        
        
        
        ETSMode eOriginalTSMode = StateObject.OriginalTSMode();
        switch (eOriginalTSMode)
        {
        case eRemoteAdmin:
            LOGMESSAGE1(_T("Original TS Mode = %s"),  _T("Remote Admin"));
            break;
        case eAppServer:
            LOGMESSAGE1(_T("Original TS Mode = %s"),  _T("App Server"));
            break;
        case eTSDisabled:
            LOGMESSAGE1(_T("Original TS Mode = %s"),  _T("TS Disabled"));
            break;
        case ePersonalTS:
            LOGMESSAGE1(_T("Original TS Mode = %s"),  _T("Personal TS"));
            break;
        default:
            LOGMESSAGE1(_T("Original TS Mode = %s"),  _T("Unknown"));
        }
        
        sbLoggedOnce = TRUE;
    }
    
    
    LOGMESSAGE0(_T("Current State   ******************************"));
    
    ETSMode eCurrentMode = StateObject.CurrentTSMode();
    switch (eCurrentMode)
    {
    case eRemoteAdmin:
        LOGMESSAGE1(_T("New TS Mode = %s"),  _T("Remote Admin"));
        break;
    case eAppServer:
        LOGMESSAGE1(_T("New TS Mode = %s"),  _T("App Server"));
        break;
    case eTSDisabled:
        LOGMESSAGE1(_T("New TS Mode = %s"),  _T("TS Disabled"));
        break;
    case ePersonalTS:
        LOGMESSAGE1(_T("New TS Mode = %s"),  _T("Personal TS"));
        break;
    default:
        LOGMESSAGE1(_T("New TS Mode = %s"),  _T("Unknown"));
    }
    
    EPermMode ePermMode = StateObject.CurrentPermMode();
    switch (ePermMode)
    {
    case PERM_WIN2K:
        LOGMESSAGE1(_T("New Permissions Mode = %s"),  _T("PERM_WIN2K"));
        break;
    case PERM_TS4:
        LOGMESSAGE1(_T("New Permissions Mode = %s"),  _T("PERM_TS4"));
        break;
    default:
        LOGMESSAGE1(_T("New Permissions Mode = %s"),  _T("Unknown"));
    }
    
    LOGMESSAGE1(_T("New Connections Allowed = %s"), StateObject.GetCurrentConnAllowed() ? _T("True") : _T("False"));
    
    return TRUE;
    
}

BOOL TSState::IsX86 () const
{
    SYSTEM_INFO sysInfo;
    ZeroMemory(&sysInfo, sizeof(sysInfo));
    GetSystemInfo(&sysInfo);
    
    return sysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL;
}


BOOL TSState::Assert () const
{
    
    // its assert !!
    ASSERT(IsCheckedBuild());
    
    // on professional there is no remote admin
    ASSERT(IsServer() || !WasItRemoteAdmin());
    
    // on professional there is no app server.
    ASSERT(IsServer() || !WasItAppServer());
    
    // if original perm was TS4 compatible, it must have been app server.
    ASSERT((OriginalPermMode() != PERM_TS4) || WasItAppServer());
    
    // make sure standalone is consistant.
    ASSERT(IsStandAlone() ==  (GetInstalltype() == eStandAloneSetup));
    
    if (m_bNewStateValid)
    {
        // we no more have disable ts state.
        ASSERT(CurrentTSMode() != eTSDisabled);
        
        // AppServer mode is available only for adv server, datacenter
        ASSERT(CanInstallAppServer() || !IsItAppServer());
        
        // we cannot be in RA mode for Professional.
        ASSERT(IsServer() || !IsItRemoteAdmin());
        
        // if permissions mode is TS4 compatible, it must be appserver 
        ASSERT((CurrentPermMode() != PERM_TS4) || IsItAppServer());
        
        // we should never allwe connections on Personal
        ASSERT(!IsPersonal() || !GetCurrentConnAllowed ());
        
    }
    
    return TRUE;
}
BOOL TSState::IsCheckedBuild () const
{
#ifdef DBG
    return TRUE;
#else
    return FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\secupgrd.h ===
#include <tchar.h>
#include <list>
#include <Sddl.h>
#include <aclapi.h>

using namespace std;


class CDefaultSD;
class CNameAndSD;

typedef list<CNameAndSD> CNameAndSDList;

class TSState;

//from privs.cpp
DWORD GrantRemotePrivilegeToEveryone( IN BOOL addPrivilage );  // add or remove
//from securd.cpp
DWORD SetupWorker(IN const TSState &State);
//from users.cpp
DWORD CopyUsersGroupToRDUsersGroup();
DWORD RemoveAllFromRDUsersGroup();
DWORD CopyUsersGroupToRDUsersGroup();

//
DWORD 
GetDacl(
        IN PSECURITY_DESCRIPTOR pSD, 
        OUT PACL *ppDacl);

DWORD 
GetSacl(
        IN PSECURITY_DESCRIPTOR pSD, 
        OUT PACL *ppSacl);

DWORD 
EnumWinStationSecurityDescriptors(
        IN  HKEY hKeyParent,
        OUT CNameAndSDList *pNameSDList);

DWORD 
GetWinStationSecurity( 
        IN  HKEY hKeyParent,
        IN  PWINSTATIONNAME pWSName,
        IN  LPCTSTR szValueName,
        OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor );

DWORD 
SetWinStationSecurity( 
        IN  HKEY hKeyParent,
        IN  PWINSTATIONNAME pWSName,
        IN  PSECURITY_DESCRIPTOR pSecurityDescriptor );

DWORD 
AddRemoteUsersToWinstationSD(
        IN HKEY hKeyParent,
        IN CNameAndSD *pNameSD);

DWORD 
AddLocalAndNetworkServiceToWinstationSD(
        IN HKEY hKeyParent,
        IN CNameAndSD *pNameSD);
           
DWORD 
AddUserToDacl(
        IN HKEY hKeyParent,
        IN PACL pOldACL, 
        IN PSID pSid,
        IN DWORD dwAccessMask,
        IN CNameAndSD *pNameSD);

DWORD
RemoveWinstationSecurity( 
        IN  HKEY hKeyParent,
        IN  PWINSTATIONNAME pWSName);

DWORD
SetNewDefaultSecurity( 
        IN  HKEY hKey);

DWORD
SetNewConsoleSecurity( 
        IN  HKEY hKeyParent,
        IN BOOL bServer);

DWORD 
SetupWorkerNotStandAlone( 
    IN BOOL bClean,
    IN BOOL bServer,
    IN BOOL bAppServer );

DWORD 
GrantRemoteUsersAccessToWinstations(
        IN HKEY hKey,
        IN BOOL bServer,
        IN BOOL bAppServer);

BOOL
LookupSid(
        IN PSID pSid, 
        OUT LPWSTR *ppName,
        OUT SID_NAME_USE *peUse);

BOOL 
IsLocal(
        IN LPWSTR wszLocalCompName,
        IN OUT LPWSTR wszDomainandname);

DWORD
GetAbsoluteSD(
        IN PSECURITY_DESCRIPTOR pSelfRelativeSD,
        OUT PSECURITY_DESCRIPTOR *ppAbsoluteSD,
        OUT PACL *ppDacl,
        OUT PACL *ppSacl,
        OUT PSID *ppOwner,
        OUT PSID *ppPrimaryGroup);

DWORD
GetSelfRelativeSD(
  PSECURITY_DESCRIPTOR pAbsoluteSD,
  PSECURITY_DESCRIPTOR *ppSelfRelativeSD);

enum DefaultSDType {
    DefaultRDPSD = 0,
    DefaultConsoleSD
};


/*++ class CDefaultSD

Class Description:

    Represents the the default security descriptor 
    in binary (self relative) form

Revision History:

    06-June-2000    a-skuzin   Created
--*/
class CDefaultSD
{
private:
    PSECURITY_DESCRIPTOR    m_pSD;
    DWORD                   m_dwSDSize;
public:
    
    CDefaultSD() : m_pSD(NULL), m_dwSDSize(0)
    {
    }
    
    ~CDefaultSD()
    {
        if(m_pSD)
        {
            LocalFree(m_pSD);
        }
    }

    //read default SD from the registry
    DWORD Init(HKEY hKey, DefaultSDType Type)
    {
        DWORD err;

        if(Type == DefaultConsoleSD)
        {
            err = GetWinStationSecurity(hKey,NULL,_T("ConsoleSecurity"),&m_pSD);

            if(err == ERROR_FILE_NOT_FOUND)
            {
                //No "ConsoleSecurity" value means that 
                //"DefaultSecurity" value is used as a 
                //default SD for the console.
                err = GetWinStationSecurity(hKey,NULL,_T("DefaultSecurity"),&m_pSD);
            }
        }
        else
        {
            err = GetWinStationSecurity(hKey,NULL,_T("DefaultSecurity"),&m_pSD);
        }

        if(err == ERROR_SUCCESS)
        {
            m_dwSDSize = GetSecurityDescriptorLength(m_pSD);
        }

        return err;
    }

    // Must be a self-relative type of security descr, since after all, it is comming from 
    // the registry
    BOOL IsEqual(const PSECURITY_DESCRIPTOR pSD) const
    {
        return ((m_dwSDSize == GetSecurityDescriptorLength(pSD)) &&
                            !memcmp(pSD,m_pSD,m_dwSDSize));
    }

    // Must be a self-relative type of security descr, since after all, it is comming from 
    // the registry
    DWORD CopySD(PSECURITY_DESCRIPTOR *ppSD) const
    {
        *ppSD = ( PSECURITY_DESCRIPTOR )LocalAlloc( LMEM_FIXED , m_dwSDSize );

        if( *ppSD )
        {
            memcpy(*ppSD,m_pSD,m_dwSDSize);
            return ERROR_SUCCESS;
        }
        else
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DWORD DoesDefaultSDHaveRemoteUsers(OUT LPBOOL pbHas);
};

/*++ class CNameAndSD

Class Description:

    Represents the the name of a winstation along with its 
    security descriptor

Revision History:

    30-March-2000    a-skuzin   Created
--*/
class CNameAndSD
{
public:
    PWINSTATIONNAME      m_pName;
    PSECURITY_DESCRIPTOR m_pSD;

    CNameAndSD() : 
        m_pName(NULL), m_pSD(NULL)
    {
    }
    
    CNameAndSD(LPCTSTR szName) : 
        m_pName(NULL), m_pSD(NULL)
    {
        if(szName)
        {
            m_pName = (PWINSTATIONNAME)LocalAlloc(LPTR,(_tcslen(szName)+1)*sizeof(TCHAR));
            if(m_pName)
            {
                _tcscpy(m_pName,szName);
            }
        }
    }
    
    CNameAndSD(const CNameAndSD &ns) : 
        m_pName(NULL), m_pSD(NULL)
    {
        *this=ns;
    }
    
    ~CNameAndSD()
    {
        if(m_pSD)
        {
            LocalFree(m_pSD);
        }
        if(m_pName)
        {
            LocalFree(m_pName);
        }
    }

    void operator=(const CNameAndSD &ns)
    {
        if(m_pSD)
        {
            LocalFree(m_pSD);
            m_pSD = NULL;
        }
        if(m_pName)
        {
            LocalFree(m_pName);
            m_pName = NULL;
        }

        if(ns.m_pName)
        {
            m_pName = (PWINSTATIONNAME)LocalAlloc(LPTR,(_tcslen(ns.m_pName)+1)*sizeof(TCHAR));
            if(m_pName)
            {
                _tcscpy(m_pName,ns.m_pName);
            }
        }

        if(ns.m_pSD)
        {
            DWORD dwSize = GetSecurityDescriptorLength(ns.m_pSD);

            m_pSD = (PWINSTATIONNAME)LocalAlloc(LPTR,GetSecurityDescriptorLength(ns.m_pSD));
            if(m_pSD)
            {
                memcpy(m_pSD,ns.m_pSD,dwSize);
            }
        }

    }
    
    BOOL IsDefaultOrEmpty(const CDefaultSD *pds, //Default RDP SD
                          const CDefaultSD *pcs) const //Default console SD
    {
        if(!m_pSD)
        {
            return TRUE;
        }
        else
        {
            if(IsConsole())
            {
                ASSERT(pcs);
                return pcs->IsEqual(m_pSD);
            }
            else
            {
                ASSERT(pds);
                return pds->IsEqual(m_pSD);
            }
        }
    }
    
    // Inilialize the security descriptor of this object to be the one being passed into it.
    DWORD SetDefault(const CDefaultSD &ds)
    {
        if (m_pSD) 
        {
            LocalFree(m_pSD);
            m_pSD = NULL;
        }
        return ds.CopySD(&m_pSD);
    }

    BOOL IsConsole() const
    {
        if(m_pName && !(_tcsicmp(m_pName,_T("Console"))))
        {
            return TRUE;        
        }

        return FALSE;
    }
    
    void SetSD(PSECURITY_DESCRIPTOR pSD)
    {
        if (m_pSD) 
        {
            LocalFree(m_pSD);
            m_pSD = NULL;
        }
        m_pSD = pSD;
    }
};

/*++ class CNameSID

Class Description:

    Represents the the name of a user or a group 
    along with it's SID

Revision History:

    09-March-2001    skuzin   Created
--*/
class CNameSID
{
private:
    LPWSTR m_wszName;
    PSID   m_pSID;
    LPWSTR m_wszSID;
public:

    CNameSID() : 
        m_pSID(NULL), m_wszName(NULL), m_wszSID(NULL)
    {
    }
    
    CNameSID(LPCWSTR wszName, PSID   pSID) : 
        m_pSID(NULL), m_wszName(NULL), m_wszSID(NULL)
    {
        if(wszName)
        {
            m_wszName = (LPWSTR)LocalAlloc(LPTR,(wcslen(wszName)+1)*sizeof(WCHAR));
            if(m_wszName)
            {
                wcscpy(m_wszName,wszName);
            }
        }

        if(pSID)
        {
            DWORD dwSidLength = GetLengthSid(pSID);
            m_pSID = (PSID)LocalAlloc(LPTR,dwSidLength);
            if(m_pSID)
            {
                CopySid(dwSidLength,m_pSID,pSID);
            }
        }
    }
    
    CNameSID(const CNameSID &ns) : 
        m_pSID(NULL), m_wszName(NULL), m_wszSID(NULL)
    {
        *this=ns;
    }
    
    ~CNameSID()
    {
        if(m_pSID)
        {
            LocalFree(m_pSID);
            m_pSID = NULL;
        }
        if(m_wszName)
        {
            LocalFree(m_wszName);
            m_wszName = NULL;
        }
        if(m_wszSID)
        {
            LocalFree(m_wszSID);
            m_wszSID = NULL;
        }
    }

    void operator=(const CNameSID &ns)
    {
        if(m_pSID)
        {
            LocalFree(m_pSID);
            m_pSID = NULL;
        }
        if(m_wszName)
        {
            LocalFree(m_wszName);
            m_wszName = NULL;
        }
        if(m_wszSID)
        {
            LocalFree(m_wszSID);
            m_wszSID = NULL;
        }

        if(ns.m_wszName)
        {
            m_wszName = (LPWSTR)LocalAlloc(LPTR,(wcslen(ns.m_wszName)+1)*sizeof(WCHAR));
            if(m_wszName)
            {
                wcscpy(m_wszName,ns.m_wszName);
            }
        }

        if(ns.m_pSID)
        {
            DWORD dwSidLength = GetLengthSid(ns.m_pSID);
            m_pSID = (PSID)LocalAlloc(LPTR,dwSidLength);
            if(m_pSID)
            {
                CopySid(dwSidLength,m_pSID,ns.m_pSID);
            }
        }

        if(ns.m_wszSID)
        {
            m_wszSID = (LPWSTR)LocalAlloc(LPTR,(wcslen(ns.m_wszSID)+1)*sizeof(WCHAR));
            if(m_wszSID)
            {
                wcscpy(m_wszSID,ns.m_wszSID);
            }
        }

    }
    
    LPCWSTR GetName()
    {
        return m_wszName;
    }

    const PSID GetSID()
    {
        if(!m_pSID && m_wszSID)
        {
            ConvertStringSidToSidW(m_wszSID,&m_pSID);
        }

        return m_pSID;
    }

    LPCWSTR GetTextSID()
    {
        if(!m_wszSID && m_pSID)
        {
            ConvertSidToStringSidW(m_pSID,&m_wszSID);
        }

        return m_wszSID;
    }
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\stdafx.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Module Name:
 *
 *      hydraoc.h
 *
 *  Abstract:
 *
 *      Common Header file for the HydraOC Component.
 *      HydraOc Component is an optional component which installs Termainal Server (Hydra)
 *
 *  Author:
 *
 *
 *  Environment:
 *
 *    User Mode
 */

#ifndef _stdafx_h_
#define _stdafx_h_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <devguid.h>
#include <initguid.h>
#include <objbase.h>
#include <tchar.h>
#include <time.h>
#include <lm.h>
#include <lmaccess.h>
#include <stdio.h>
#include <setupapi.h>
#include <prsht.h>
#include <loadperf.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commdlg.h>
#include <ocmanage.h>
#include <winsta.h>
#include <regapi.h>
#include <ntsecapi.h>
#include <malloc.h>
#include <appmgmt.h>
#include <msi.h>


#include "conv.h"
#include "constants.h"
#include "resource.h"
#include "Registry.h"
#include "logmsg.h"
#include "util.h"
#include "icaevent.h"

#define AssertFalse() ASSERT(FALSE)

#define VERIFY(x)  RTL_VERIFY(x)
//;

#endif // _stdafx_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\sources.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

!IF 0

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Makarand Patwardhan (makarp)

!ENDIF

TERMSRV_ROOT = ..\..\..

INCLUDES= \
    ..; \
    $(TERMSRV_ROOT)\winsta\server\$(O); \
    $(TERMSRV_ROOT)\common\license\inc; \
    $(TERMSRV_ROOT)\newclient\inc; \
    $(BASE_INC_PATH); \

TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLDEF=..\hydraoc.def
DLLBASE=0x2000000
DLLENTRY=_DllMainCRTStartup
USE_MSVCRT=1
USE_STL=1
USE_NATIVE_EH=1

PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_SOURCEFILE = ..\stdafx.cpp
PRECOMPILED_CXX = 1

C_DEFINES=$(C_DEFINES) -DTSOC_CONSOLE_SHADOWING
!ifdef TERMSRV_PROC
C_DEFINES=$(C_DEFINES) -DTERMSRV_PROC
!endif

SOURCES=            \
  ..\hydraoc.rc     \
  ..\acl.cpp        \
  ..\cocpage.cpp    \
  ..\constants.cpp  \
  ..\hydraoc.cpp    \
  ..\LogMsg.cpp     \
  ..\pages.cpp      \
  ..\rdpdrstp.cpp   \
  ..\registry.cpp   \
  ..\state.cpp      \
  ..\subcomp.cpp    \
  ..\subcore.cpp    \
  ..\subtoggle.cpp  \
  ..\util.cpp       \
  ..\privs.cpp      \
  ..\users.cpp      \
  ..\securd.cpp     \
  ..\sysprep.cpp


TARGETLIBS= \
         $(TERMSRV_LIB_PATH)\regapi.lib     \
         $(SDK_LIB_PATH)\user32.lib         \
         $(DS_LIB_PATH)\rsa32.lib   \
         $(DS_LIB_PATH)\randlib.lib \
         $(TERMSRV_ROOT)\lib\$(O)\tssec.lib \
         $(TERMSRV_ROOT)\lib\$(O)\cryptlib.lib \
         $(SDK_LIB_PATH)\kernel32.lib       \
         $(SDK_LIB_PATH)\advapi32.lib       \
         $(SDK_LIB_PATH)\comctl32.lib       \
         $(SDK_LIB_PATH)\ole32.lib          \
         $(SDK_LIB_PATH)\setupapi.lib       \
         $(SDK_LIB_PATH)\netapi32.lib       \
         $(SDK_LIB_PATH)\winspool.lib       \
         $(SDK_LIB_PATH)\uuid.lib           \
         $(DDK_LIB_PATH)\newdev.lib         \
         $(SDK_LIB_PATH)\loadperf.lib       \
         $(SDK_LIB_PATH)\winsta.lib         \
         $(SHELL_LIB_PATH)\shell32p.lib \
         $(SDK_LIB_PATH)\Shlwapi.lib        \
         $(SDK_LIB_PATH)\msi.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\rights.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// rights.h

DWORD GrantRights(LPWSTR lpMachineName, LPWSTR lpAccountName, LPWSTR lpRightsString, BOOL bAdd);

// Eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\state.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
*
*  State.h
*
*  Routines to gather various state information.
*
*/

#ifndef __TSOC_STATE_H__
#define __TSOC_STATE_H__


//
//  Type Definitions
//

typedef enum {
    PERM_WIN2K = 0,
        PERM_TS4 = 1
} EPermMode;

//
//  OC State Function Prototypes
//


DWORD SetTSVersion (LPCTSTR pszVersion);
PSETUP_INIT_COMPONENT GetSetupData(VOID);


enum ETSInstallType
{
        eFreshInstallTS,     // it could be an upgrade, but from non TS machine.
        eUpgradeFrom40TS,
        eUpgradeFrom50TS,
        eUpgradeFrom51TS,
        eStandAloneSetup
};

enum ETSMode
{
    eTSDisabled,
        eRemoteAdmin,
        eAppServer,
        ePersonalTS
};

    // This must be in the same order as IDs in lscore
    enum ETSLicensingMode
    {
        eLicPTS,
        eLicRemoteAdmin,
        eLicPerSeat,
        eLicInternetConnector,  // not supported in Whistler
        eLicPerSession,
        eLicUnset
    };

class TSState
{
    
public:
    
    
    TSState             ();
    virtual            ~TSState             ();
    
    BOOL                Initialize          (PSETUP_INIT_COMPONENT pSetupData);
    
    const PSETUP_INIT_COMPONENT GetSetupData() const;
    
    
    ETSInstallType      GetInstalltype      () const;
    
    ETSMode             OriginalTSMode      () const;
    ETSMode             CurrentTSMode       () const;
    
    EPermMode           OriginalPermMode    () const;
    EPermMode           CurrentPermMode     () const;

    ETSLicensingMode    NewLicMode          () const;

    BOOL                IsUpgrade           () const;
    BOOL                IsFreshInstall      () const;
    BOOL                IsTSFreshInstall    () const;
    BOOL                IsUpgradeFrom40TS   () const;
    BOOL                IsUpgradeFrom50TS   () const;
    BOOL                IsUpgradeFrom51TS   () const;
    BOOL                IsUnattended        () const;
    BOOL                IsGuiModeSetup      () const;
    BOOL                IsStandAlone        () const;
    BOOL                IsWorkstation       () const;
    BOOL                IsServer            () const;
    BOOL                IsSBS               () const;
    BOOL                CanInstallAppServer () const;
    BOOL                IsAdvServerOrHigher () const;
    BOOL                IsPersonal          () const;
    BOOL                IsProfessional      () const;
    BOOL                IsX86               () const;
    BOOL                IsCheckedBuild      () const;
    
    BOOL                WasTSInstalled      () const;
    BOOL                WasTSEnabled        () const;
    BOOL                WasItAppServer      () const;
    BOOL                WasItRemoteAdmin    () const;
    
    BOOL                IsAppSrvModeSwitch  () const;
    BOOL                IsTSModeChanging    () const;
    BOOL                IsItAppServer       () const;
    BOOL                IsAppServerSelected () const;
    BOOL                IsItRemoteAdmin     () const;
    BOOL                HasChanged          () const;
    BOOL                IsTSEnableSelected  () const;
    
    
    void                SetCurrentTSMode    (ETSMode eNewMode);
    void                SetCurrentPermMode  (EPermMode eNewMode);
    void                SetNewLicMode       (ETSLicensingMode eNewMode);
    void                UpdateState         ();
    
    BOOL                Assert () const;
    BOOL                LogState () const;
    
    BOOL                GetCurrentConnAllowed () const;
    BOOL                GetOrigConnAllowed   () const;
    
private:
    
    ETSInstallType      m_eInstallType;
    
    ETSMode             m_eOriginalTSMode;
    ETSMode             m_eCurrentTSMode;
    
    EPermMode           m_eOriginalPermMode;
    EPermMode           m_eCurrentPermMode;
    
    BOOL                m_bCurrentConnAllowed;
    BOOL                m_bOrigConnAllowed;
    
    BOOL                m_bNewStateValid;
    
    ETSLicensingMode    m_eNewLicMode;

    PSETUP_INIT_COMPONENT m_gpInitComponentData;
    OSVERSIONINFOEX     m_osVersion;
    
    
    BOOL                GetNTType           ();
    BOOL                SetSetupData        (PSETUP_INIT_COMPONENT pSetupData);
    
    
    ETSInstallType      ReadInstallType     () const;
    ETSMode             ReadTSMode          () const;
    EPermMode           ReadPermMode        () const;
    BOOL                AreConnectionsAllowed () const;
    void                SetCurrentConnAllowed (BOOL bAllowed);
};





extern TSState  StateObject;


#endif // __TSOC_STATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\subcore.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

//
// SubCore.h
// subcomponent enable terminal services.
//

#ifndef _SubCore_h_
#define _SubCore_h_

#include "subcomp.h" // defines OCMSubComp


class SubCompCoreTS : public OCMSubComp
{
    public:

    DWORD   GetStepCount                () const;
    LPCTSTR GetSubCompID                () const;
    DWORD   OnQueryState                (UINT uiWhichState);
    LPCTSTR GetSectionToBeProcessed     (ESections eSection) const;
    BOOL    BeforeCompleteInstall       ();
    BOOL    AfterCompleteInstall        ();
    DWORD   OnQuerySelStateChange       (BOOL bNewState, BOOL bDirectSelection) const;

        DWORD LoadOrUnloadPerf           ();
    BOOL SetupConsoleShadow          ();
    void AddRDPNP(LPTSTR szOldValue, LPTSTR szNewValue);
    void RemoveRDPNP(LPTSTR szOldValue, LPTSTR szNewValue);
    BOOL AddRemoveRDPNP              ();
    BOOL InstallUninstallRdpDr       ();
    BOOL HandleHotkey                ();
        BOOL UpdateMMDefaults                    ();
        BOOL AddTermSrvToNetSVCS                 ();
        BOOL AddRemoveTSProductSuite     ();
        BOOL UpgradeRdpWinstations               ();
        BOOL DoHydraRegistrySecurityChanges ();
        BOOL DisableInternetConnector    ();
        BOOL ResetTermServGracePeriod    ();
        BOOL RemoveTSServicePackEntry    ();
        BOOL RemoveMetaframeFromUserinit ();
        BOOL UninstallTSClient                   ();
        BOOL WriteDenyConnectionRegistry ();


        BOOL BackUpRestoreConnections    (BOOL bBackup);
        BOOL  IsConsoleShadowInstalled   ();
        void SetConsoleShadowInstalled   (BOOL bInstalled);
        BOOL IsTermSrvInNetSVCS                  ();
        BOOL DisableWinStation                   (CRegistry *pRegWinstation);
        BOOL DoesLanaTableExist                  ();
        void VerifyLanAdapters                   (CRegistry *pRegWinstation, LPTSTR pszWinstation);
        BOOL UpdateRDPWinstation                 (CRegistry *pRegWinstation);
        BOOL IsRdpWinStation                     (CRegistry *pRegWinstation);
        BOOL IsConsoleWinStation                 (CRegistry *pRegWinstation);
        BOOL IsMetaFrameWinstation               (CRegistry *pRegWinstation);
private:
    DWORD UnloadPerf();
};
#endif // _SubCore_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\subcomp.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// subcomp.cpp
// implementation a default sub component

#include "stdafx.h"
#include "subcomp.h"


OCMSubComp::OCMSubComp ()
{
    m_lTicks = 0;
}

BOOL OCMSubComp::Initialize ()
{

    return TRUE;
}

BOOL OCMSubComp::GetCurrentSubCompState () const
{
    return GetHelperRoutines().QuerySelectionState(
        GetHelperRoutines().OcManagerContext,
        GetSubCompID(),
        OCSELSTATETYPE_CURRENT);
}

BOOL OCMSubComp::GetOriginalSubCompState () const
{
    return GetHelperRoutines().QuerySelectionState(
        GetHelperRoutines().OcManagerContext,
        GetSubCompID(),
        OCSELSTATETYPE_ORIGINAL);
}

BOOL OCMSubComp::HasStateChanged () const
{
    //
    // returns true if current selection state is different from previous.
    //
    return GetCurrentSubCompState() != GetOriginalSubCompState();

}

//
// this functions ticks the gauge for the specified count
// keep traks of the count reported to the OC_QUERY_STEP_COUNT
//
void OCMSubComp::Tick (DWORD  dwTickCount /* = 1 */)
{
    if (m_lTicks > 0)
    {
        m_lTicks -= dwTickCount;
        while(dwTickCount--)
            GetHelperRoutines().TickGauge( GetHelperRoutines().OcManagerContext );

    }
    else
    {
        m_lTicks = 0;
    }
}

//
// completes the remaining ticks.
//
void OCMSubComp::TickComplete ()
{
    ASSERT(m_lTicks >= 0);
    while (m_lTicks--)
        GetHelperRoutines().TickGauge( GetHelperRoutines().OcManagerContext );
}

DWORD OCMSubComp::OnQueryStepCount()
{
    m_lTicks = GetStepCount() + 2;
    return m_lTicks;
}

DWORD OCMSubComp::GetStepCount () const
{
    return 0;
}


DWORD OCMSubComp::OnQueryState ( UINT uiWhichState ) const
{
	LOGMESSAGE1(_T("In OCMSubComp::OnQueryState  for %s"), GetSubCompID());

    ASSERT(OCSELSTATETYPE_ORIGINAL == uiWhichState ||
           OCSELSTATETYPE_CURRENT == uiWhichState ||
           OCSELSTATETYPE_FINAL == uiWhichState );

    return SubcompUseOcManagerDefault;

}

DWORD OCMSubComp::OnQuerySelStateChange (BOOL /* bNewState */, BOOL /* bDirectSelection */) const
{
    return TRUE;
}

DWORD OCMSubComp::LookupTargetSection(LPTSTR szTargetSection, DWORD dwSize, LPCTSTR lookupSection)
{
    DWORD dwError = GetStringValue(GetComponentInfHandle(), GetSubCompID(), lookupSection, szTargetSection, dwSize);
    if (dwError == ERROR_SUCCESS)
    {
        LOGMESSAGE2(_T("sectionname = <%s>, actual section = <%s>"), lookupSection, szTargetSection);
    }
    else
    {
        AssertFalse();
        LOGMESSAGE1(_T("ERROR:GetSectionToBeProcess:GetStringValue failed GetLastError() = %lu"), dwError);
    }

    return dwError;
}

DWORD OCMSubComp::GetTargetSection(LPTSTR szTargetSection, DWORD dwSize, ESections eSectionType, BOOL *pbNoSection)
{
    ASSERT(szTargetSection);
    ASSERT(pbNoSection);

    //
    // get section to be processed
    //
    LPCTSTR szSection = GetSectionToBeProcessed( eSectionType );

    if (szSection == NULL)
    {
        *pbNoSection = TRUE;
        return NO_ERROR;
    }
    else
    {
        //
        // there is a section to be processed.
        //
        *pbNoSection = FALSE;
    }


    //
    // look for the target section
    //
    return LookupTargetSection(szTargetSection, dwSize, szSection);

}

DWORD OCMSubComp::OnCalcDiskSpace ( DWORD addComponent, HDSKSPC dspace )
{
	LOGMESSAGE1(_T("In OCMSubComp::OnCalcDiskSpace for %s"), GetSubCompID());

    TCHAR TargetSection[S_SIZE];
    BOOL bNoSection = FALSE;

    DWORD rc = GetTargetSection(TargetSection, S_SIZE, kDiskSpaceAddSection, &bNoSection);

    //
    // if there is no section to be processed. just return success.
    //
    if (bNoSection)
    {
        return NO_ERROR;
    }

    if (rc == NO_ERROR)
    {
        if (addComponent)
        {
            LOGMESSAGE1(_T("Calculating disk space for add section =  %s"), TargetSection);
            rc = SetupAddInstallSectionToDiskSpaceList(
                dspace,
                GetComponentInfHandle(),
                NULL,
                TargetSection,
                0,
                0);
        }
        else
        {
            LOGMESSAGE1(_T("Calculating disk space for remove section =  %s"), TargetSection);
            rc = SetupRemoveInstallSectionFromDiskSpaceList(
                dspace,
                GetComponentInfHandle(),
                NULL,
                TargetSection,
                0,
                0);
        }

        if (!rc)
            rc = GetLastError();
        else
            rc = NO_ERROR;

    }

    return rc;
}

DWORD OCMSubComp::OnQueueFiles ( HSPFILEQ queue )
{
	LOGMESSAGE1(_T("In OCMSubComp::OnQueueFiles for %s"), GetSubCompID());

    TCHAR TargetSection[S_SIZE];
    BOOL bNoSection = FALSE;
    DWORD rc = GetTargetSection(TargetSection, S_SIZE, kFileSection, &bNoSection);

    //
    // if there is no section to be processed. just return success.
    //
    if (bNoSection)
    {
        return NO_ERROR;
    }


    if (rc == NO_ERROR)
    {
        LOGMESSAGE1(_T("Queuing Files from Section = %s"), TargetSection);
        if (!SetupInstallFilesFromInfSection(
            GetComponentInfHandle(),
            NULL,
            queue,
            TargetSection,
            NULL,
            0  // this should eliminate the warning about overwriting newer file.
            ))
        {
            rc = GetLastError();
            LOGMESSAGE2(_T("ERROR:OnQueueFileOps::SetupInstallFilesFromInfSection <%s> failed.GetLastError() = <%ul)"), TargetSection, rc);
        }
        else
        {
            return NO_ERROR;
        }

    }

    return rc;
}

DWORD OCMSubComp::OnCompleteInstall ()
{
	LOGMESSAGE1(_T("In OCMSubComp::OnCompleteInstall for %s"), GetSubCompID());
    if (!BeforeCompleteInstall ())
    {
        LOGMESSAGE0(_T("ERROR:BeforeCompleteInstall failed!"));
    }

    TCHAR TargetSection[S_SIZE];
    BOOL bNoSection = FALSE;
    DWORD dwError = GetTargetSection(TargetSection, S_SIZE, kRegistrySection, &bNoSection);

    //
    // if there is no section to be processed. just go ahead.
    //
    if (!bNoSection)
    {
        LOGMESSAGE1(_T("Setting up Registry/Links/RegSvrs from section =  %s"), TargetSection);
        dwError = SetupInstallFromInfSection(
            NULL,                                // hwndOwner
            GetComponentInfHandle(),             // inf handle
            TargetSection,                       //
            SPINST_ALL & ~SPINST_FILES,          // operation flags
            NULL,                                // relative key root
            NULL,                                // source root path
            0,                                   // copy flags
            NULL,                                // callback routine
            NULL,                                // callback routine context
            NULL,                                // device info set
            NULL                                 // device info struct
            );

        if (dwError == 0)
            LOGMESSAGE1(_T("ERROR:while installating section <%lu>"), GetLastError());
    }

    Tick();

    if (!AfterCompleteInstall ())
    {
        LOGMESSAGE0(_T("ERROR:AfterCompleteInstall failed!"));
    }

    TickComplete();
    return NO_ERROR;
}

BOOL OCMSubComp::BeforeCompleteInstall  ()
{
    return TRUE;
}

BOOL OCMSubComp::AfterCompleteInstall   ()
{
    return TRUE;
}

DWORD OCMSubComp::OnAboutToCommitQueue  ()
{
    return NO_ERROR;
}

void
OCMSubComp::SetupRunOnce( HINF hInf, LPCTSTR SectionName )
{
    INFCONTEXT  sic;
    TCHAR CommandLine[ RUNONCE_CMDBUFSIZE ];
    BOOL b;
    STARTUPINFO startupinfo;
    PROCESS_INFORMATION process_information;
    DWORD dwErr;

    if (!SetupFindFirstLine( hInf, SectionName, NULL , &sic))
    {
        LOGMESSAGE1(_T("WARNING: nothing in %s to be processed."), SectionName);
    }
    else
    {
        do  {
            if (!SetupGetStringField(&sic, 1, CommandLine, RUNONCE_CMDBUFSIZE, NULL))
            {
                LOGMESSAGE1(_T("WARNING: No command to be processed."), SectionName);
                break;
            }

            LOGMESSAGE1(_T("RunOnce: spawning process %s"), CommandLine);


            ZeroMemory( &startupinfo, sizeof(startupinfo) );
            startupinfo.cb = sizeof(startupinfo);
            startupinfo.dwFlags = STARTF_USESHOWWINDOW;
            startupinfo.wShowWindow = SW_HIDE | SW_SHOWMINNOACTIVE;

            b = CreateProcess( NULL,
                               CommandLine,
                               NULL,
                               NULL,
                               FALSE,
                               CREATE_DEFAULT_ERROR_MODE,
                               NULL,
                               NULL,
                               &startupinfo,
                               &process_information );
            if ( !b )
            {
                LOGMESSAGE1(_T("ERROR: failed to spawn %s process."), CommandLine);
                continue;
            }

            dwErr = WaitForSingleObject( process_information.hProcess, RUNONCE_DEFAULTWAIT );
            if ( dwErr != NO_ERROR )
            {
                LOGMESSAGE1(_T("ERROR: process %s failed to complete in time."), CommandLine);

                // Don't terminate process, just go on to next one.
            }
            else
            {
                LOGMESSAGE1(_T("INFO: process %s completed successfully."), CommandLine);
            }

            CloseHandle( process_information.hProcess );
            CloseHandle( process_information.hThread );
        } while ( SetupFindNextLine( &sic, &sic ) );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\subcomp.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

//
// subcomp.h
// defines a subcomponent class
//

#ifndef _subcomp_h_
#define _subcomp_h_

#include "hydraoc.h"

#define RUNONCE_SECTION_KEYWORD     _T("RunOnce.Setup")
#define RUNONCE_DEFAULTWAIT         5 * 60 * 1000 // 5 mins default wait for process to complete.
#define RUNONCE_CMDBUFSIZE          512

class OCMSubComp
{
    private:
    LONG m_lTicks;

    public:
    enum ESections
    {
        kFileSection,
        kRegistrySection,
        kDiskSpaceAddSection
    };

    OCMSubComp ();

    void    Tick (DWORD  dwTickCount  =  1);
    void    TickComplete ();

    BOOL    HasStateChanged() const;
    BOOL    GetCurrentSubCompState () const;
    BOOL    GetOriginalSubCompState () const;
    DWORD   LookupTargetSection (LPTSTR szTargetSection, DWORD dwSize, LPCTSTR lookupSection);
    DWORD   GetTargetSection (LPTSTR szTargetSection, DWORD dwSize, ESections eSectionType, BOOL *pbNoSection);

    virtual LPCTSTR GetSubCompID    () const = 0;
    virtual LPCTSTR GetSectionToBeProcessed (ESections) const = 0;


    //
    // default implementaion is provided for all these
    //
    virtual BOOL Initialize ();
    virtual BOOL BeforeCompleteInstall  ();
    virtual BOOL AfterCompleteInstall   ();

    virtual DWORD GetStepCount          () const;

    virtual DWORD OnQuerySelStateChange (BOOL bNewState, BOOL bDirectSelection) const;
    virtual DWORD OnQueryState          (UINT uiWhichState) const;
    virtual DWORD OnCalcDiskSpace       (DWORD addComponent, HDSKSPC dspace);
    virtual DWORD OnQueueFiles          (HSPFILEQ queue);
    virtual DWORD OnCompleteInstall     ();
    virtual DWORD OnAboutToCommitQueue  ();

    // implemented by this class.
    DWORD OnQueryStepCount              ();

    virtual VOID SetupRunOnce( HINF inf, LPCTSTR SectionName );


};

#endif // _subcomp_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\subtoggle.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
*
*  SubToggle
*
*  A subcomponent class to toggle Terminal Services.
*
*/

#ifndef __TSOC__SUBTOGGLE_H__
#define __TSOC__SUBTOGGLE_H__

//
//  Includes
//

#include "subcomp.h"

//
//  Class Definition
//

class SubCompToggle : public OCMSubComp
{
public:
    
    virtual BOOL    BeforeCompleteInstall   ();
    virtual DWORD   GetStepCount            () const;
    virtual DWORD   OnQueryState            (UINT uiWhichState) const;
    virtual DWORD   OnQuerySelStateChange   (BOOL bNewState, BOOL bDirectSelection) const;
    
    BOOL    AfterCompleteInstall    ();
    
    LPCTSTR GetSectionToBeProcessed (ESections eSection) const;
    
    LPCTSTR GetSubCompID            () const;
    
    BOOL  ModifyWallPaperPolicy      ();
    BOOL  ModifyNFA                  ();
    BOOL  ApplyDefaultSecurity       ();
    BOOL  ApplyModeRegistry          ();
    BOOL  SetPermissionsMode         ();
    BOOL  ResetWinstationSecurity    ();
    BOOL  ApplySection               (LPCTSTR szSection);
    BOOL  ModifyAppPriority          ();
    BOOL  InformLicensingOfModeChange();
    BOOL  WriteLicensingMode         ();
    //BOOL  UpdateMMDefaults           ();
};

#endif // _SubToggle_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\subcore.cpp ===
//
//Copyright (c) 1998 - 1999 Microsoft Corporation
//

//
// SubCore.cpp
// subcomponent Core terminal server implementation.
//

#include "stdafx.h"
#include "SubCore.h"
#include "acl.h"
#include "rdpdrstp.h"

BOOL UpdateAudioCodecs (BOOL bIsProfessional);


LPCTSTR SubCompCoreTS::GetSubCompID () const
{
    return BASE_COMPONENT_NAME;
}

DWORD SubCompCoreTS::GetStepCount () const
{
    return 18;
}

DWORD SubCompCoreTS::OnQueryState ( UINT /* uiWhichState */)
{
    AssertFalse(); // since this is our internal component.
    
    return SubcompUseOcManagerDefault;
}

DWORD SubCompCoreTS::OnQuerySelStateChange (BOOL /*bNewState*/, BOOL /*bDirectSelection*/) const
{
    // we are not a real sub comp.
    ASSERT(FALSE);
    return TRUE;
}


LPCTSTR SubCompCoreTS::GetSectionToBeProcessed (ESections /* eSection */) const
{
    LPCTSTR sectionname = NULL;
    if (StateObject.IsGuiModeSetup())   // core installation is only for gui-mode.
    {
        
        ETSInstallType eInstallType =  StateObject.GetInstalltype();
        
        switch (eInstallType)
        {
        case eFreshInstallTS:
            if (StateObject.IsX86())
            {
                sectionname = StateObject.IsWorkstation() ? FRESH_INSTALL_PRO_X86 : FRESH_INSTALL_SERVER_X86;
            }
            else
            {
                sectionname = StateObject.IsWorkstation() ? FRESH_INSTALL_PRO_IA64 : FRESH_INSTALL_SERVER_IA64;
            }
            
            break;
        case eUpgradeFrom40TS:
            ASSERT(StateObject.IsServer());
            if (StateObject.IsX86())
            {
                sectionname = UPGRADE_FROM_40_SERVER_X86;
            }
            else
            {
                ASSERT(FALSE); // we did not have ts4 on ia64
                sectionname = UPGRADE_FROM_40_SERVER_IA64;
            }
            break;
            
        case eUpgradeFrom50TS:
            //
            // we dont really have a upgrade from 50 case for Professional, But to support old 51 (pre 2220) builds)
            // of pro which think that they are 50, we need to check for professional here.
            //
            if (StateObject.IsX86())
            {
                sectionname = StateObject.IsWorkstation() ? UPGRADE_FROM_51_PRO_X86 : UPGRADE_FROM_50_SERVER_X86;
            }
            else
            {
                sectionname = StateObject.IsWorkstation() ? UPGRADE_FROM_51_PRO_IA64 : UPGRADE_FROM_50_SERVER_IA64;
            }
            break;
            
        case eUpgradeFrom51TS:
            if (StateObject.IsX86())
            {
                sectionname = StateObject.IsWorkstation() ? UPGRADE_FROM_51_PRO_X86 : UPGRADE_FROM_51_SERVER_X86;
            }
            else
            {
                sectionname = StateObject.IsWorkstation() ? UPGRADE_FROM_51_PRO_IA64 : UPGRADE_FROM_51_SERVER_IA64;
            }
            break;
            
        case eStandAloneSetup:
            ASSERT(FALSE);
            sectionname = NULL;
            break;
            
        default:
            ASSERT(FALSE);
            if (StateObject.IsX86())
            {
                sectionname = StateObject.IsWorkstation() ? FRESH_INSTALL_PRO_X86 : FRESH_INSTALL_SERVER_X86;
            }
            else
            {
                sectionname = StateObject.IsWorkstation() ? FRESH_INSTALL_PRO_IA64 : FRESH_INSTALL_SERVER_IA64;
            }
            
        }
    }
    
    return sectionname;
}

BOOL SubCompCoreTS::BeforeCompleteInstall  ()
{
    return(TRUE);
}

BOOL SubCompCoreTS::AfterCompleteInstall  ()
{
    //
    // This is core TS subcomponent.
    // It has nothing to do with standalone seutp.
    // so if we are in standalone setup. just return.
    //
    
    //
    // Deny Connections registry
    //

    WriteDenyConnectionRegistry ();
    Tick();
    
    if (!StateObject.IsGuiModeSetup())
    {
        return TRUE;
    }
    
    
    SetProgressText(IDS_STRING_PROGRESS_CORE_TS);
    
    //
    // add ts product suite to registry.
    //
    AddRemoveTSProductSuite();
    Tick();
    
    
#ifndef TERMSRV_PROC
    //
    // add termsrv to netsvcs group.
    //
    AddTermSrvToNetSVCS ();
    Tick();
#endif
    
    //
    // apply hydra security to registry.
    //
    DoHydraRegistrySecurityChanges();
    Tick();
    
    
    //
    // Audio Redirection
    //
    UpdateAudioCodecs( StateObject.IsWorkstation() );
    Tick();
    
    //
    // Client Drive Mappings.
    //
    AddRemoveRDPNP();
    Tick();
    
    
    //
    // Hot key for Local Language change.
    //
    // We dont need to do this.
    //    HandleHotkey ();
    //    Tick();
    
    //
    // Printer Redirection.
    //
    InstallUninstallRdpDr ();
    Tick();
    
    
#ifdef TSOC_CONSOLE_SHADOWING
    //
    // Console Shadowing.
    //
    SetupConsoleShadow();
    Tick();
#endif // TSOC_CONSOLE_SHADOWING
    
    //
    // Performance monitors for TS. BUGBUG - check with ErikMa - do they work when TS is not started ?
    //
    LoadOrUnloadPerf();
    Tick();
    
    
    //
    // we have different session pool, view defaults for mm on pro
    //
    UpdateMMDefaults ();
    Tick();
    
    //
    //  If this were a real subcomponent, one that the OC manager knew
    //  about and handled, the following call would be to
    //  GetOriginalSubCompState().
    //
    
    if (StateObject.WasTSInstalled())
    {
        UpgradeRdpWinstations();
        Tick();
        
        //
        // This no longer exists in Whistler
        //
        DisableInternetConnector();
        Tick();
        
        if (StateObject.IsUpgradeFrom40TS())
        {
            //
            // this is upgrade from TS4
            // we want to remove service pack key in uninstall. this is to
            // ensure that service pack do not appear in Add/Remove Programs
            // and in our incompatible applications list.
            //
            RemoveTSServicePackEntry();
            Tick();
            
            //
            // There are some metaframe components in user init,
            // we need to remove thouse as we upgrade ts40
            //
            RemoveMetaframeFromUserinit ();
            Tick();
            
        }
        
        //
        // we need to reset Win2000 ts grace period for licenses on upgrades
        // Whistler uses a different location, so this won't affect RTM to
        // RTM upgrades
        //
        ResetTermServGracePeriod();
        Tick();
    }
    
    // some new code to uninstall TSClient.
    if (!UninstallTSClient())
    {
        LOGMESSAGE0(_T("ERROR: Could not uninstall tsclient."));
    }
    
    
    Tick();
    
    return TRUE;
}

BOOL SubCompCoreTS::IsTermSrvInNetSVCS ()
{
    BOOL bStringExists = FALSE;
    DWORD dw = IsStringInMultiString(
        HKEY_LOCAL_MACHINE,
        SVCHOSST_KEY,
        NETSVCS_VAL,
        TERMSERVICE,
        &bStringExists);
    
    return (dw == ERROR_SUCCESS) && bStringExists;
}

BOOL SubCompCoreTS::AddTermSrvToNetSVCS ()
{
    DWORD dw = NO_ERROR;
    if (StateObject.IsWorkstation())
    {
        //
        // for workstations, we want to share process with netsvcs group
        //
        if (!IsTermSrvInNetSVCS())
        {
            dw = AppendStringToMultiString(
                HKEY_LOCAL_MACHINE,
                SVCHOSST_KEY,
                NETSVCS_VAL,
                TERMSERVICE
                );
            
            if (dw != NO_ERROR)
            {
                LOGMESSAGE1(_T("Error, appending TermService to netsvcs, Errorcode = %u"), dw);
            }
        }
    }
    
    //
    // for servers we want to have our own svchost for termsrv.
    // lets create the necessary entries for pro as well, so that for debugging termsrv it'll be easier to switch to own svchost.
    //
    {
        //
        // for servers we want to have our own svchost process.
        //
        CRegistry oReg;
        dw = oReg.OpenKey(HKEY_LOCAL_MACHINE, SVCHOSST_KEY);
        if (ERROR_SUCCESS == dw)
        {
            dw = oReg.WriteRegMultiString(TERMSVCS_VAL, TERMSERVICE_MULTISZ, (_tcslen(TERMSERVICE) + 2) * sizeof(TCHAR));
            if (ERROR_SUCCESS == dw)
            {
                // add CoInitializeSecurityParam, so that CoInitialize gets called in main thread for this svc group.
                CRegistry termsvcKey;
                dw = termsvcKey.CreateKey(HKEY_LOCAL_MACHINE, SVCHOSST_TERMSRV_KEY );
                if (ERROR_SUCCESS == dw)
                {
                    dw = termsvcKey.WriteRegDWord(TERMSVCS_PARMS, 1);
                    if (ERROR_SUCCESS != dw)
                    {
                        LOGMESSAGE1(_T("Failed to write termsvc coinit params, Error = %d"), dw);
                    }
                    dw = termsvcKey.WriteRegDWord(TERMSVCS_STACK, 8);
                    if (ERROR_SUCCESS != dw)
                    {
                        LOGMESSAGE1(_T("Failed to write termsvc stack params, Error = %d"), dw);
                    }
                    
                }
                else
                {
                    LOGMESSAGE1(_T("Error, Failed to create svchost\termsrv key, Error = %d"), dw);
                }
            }
            else
            {
                LOGMESSAGE1(_T("Error, Writing termsrv value, Error = %d"), dw);
            }
        }
        else
        {
            LOGMESSAGE1(_T("Error, Opening Svchost key, Error = %d"), dw);
        }
        
    }
    
    return dw == NO_ERROR;
}
/*--------------------------------------------------------------------------------------------------------
* DWORD AddRemoveTSProductSuite (BOOL bAddRemove)
* does the necessary changes for installing hydra specific registry keys which are not done from inf.
* parameter state decides if key is to be added or removed.
* returns success
* -------------------------------------------------------------------------------------------------------*/
BOOL SubCompCoreTS::AddRemoveTSProductSuite ()
{
    
    //
    // add product suite key only for servers.
    // This is required only for TS4 compatibility.
    // TS4 applications detect if machine is terminal server using this key.
    //
    
    DWORD dw = NO_ERROR;
    if (StateObject.IsServer())
    {
        // installing/upgrading.
        if (!DoesHydraKeysExists())
        {
            ASSERT(FALSE == StateObject.WasTSInstalled());
            // now read the original data in this product suite value.
            dw = AppendStringToMultiString(
                HKEY_LOCAL_MACHINE,
                PRODUCT_SUITE_KEY,
                PRODUCT_SUITE_VALUE,
                TS_PRODUCT_SUITE_STRING
                );
            
            if (dw != NO_ERROR)
                LOGMESSAGE1(_T("ERROR:DoHydraRegistryChanges : Error Appending String = <%lu>"), dw);
        }
        
    }
    
    dw = SetTSVersion(TERMINAL_SERVER_THIS_VERSION);
    if (ERROR_SUCCESS != dw)
    {
        LOGMESSAGE1(_T("ERROR, Setting TS version, ErrorCode = %u "), dw);
    }
    
    return dw == NO_ERROR;
}


BOOL SubCompCoreTS::DisableWinStation (CRegistry *pRegWinstation)
{
    ASSERT(pRegWinstation);
    
#ifdef DBG
    // the value must be there already.
    DWORD dwValue;
    ASSERT(ERROR_SUCCESS == pRegWinstation->ReadRegDWord(_T("fEnableWinStation"), &dwValue));
#endif
    
    VERIFY(ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fEnableWinStation"), 0));
    
    return TRUE;
}

BOOL SubCompCoreTS::DoesLanaTableExist ()
{
    static fValueDetermined = FALSE;
    static fRet;
    
    if (fValueDetermined)
    {
        return(fRet);
    }
    else
    {
        CRegistry Reg;
        fRet = Reg.OpenKey(HKEY_LOCAL_MACHINE, TS_LANATABLE_KEY) == ERROR_SUCCESS;
        fValueDetermined = TRUE;
        
        LOGMESSAGE1(_T("DoesLanaTableExist: %s"), fRet ? _T("Yes") : _T("No"));
        return(fRet);
    }
}

void SubCompCoreTS::VerifyLanAdapters (CRegistry *pRegWinstation, LPTSTR pszWinstation)
{
    DWORD dwLana = 0;
    static BOOL fErrorLogged = FALSE;
    
    LOGMESSAGE1(_T("Verifying lan adapters for %s"), pszWinstation);
    
    if (DoesLanaTableExist())
    {
        LOGMESSAGE0(_T("OK: GuidTable already exists."));
        return;
    }
    
    if (pRegWinstation->ReadRegDWord(_T("LanAdapter"), &dwLana) == ERROR_SUCCESS)
    {
        if (dwLana == 0)
        {
            LOGMESSAGE0(_T("OK: using all adapters"));
        }
        else
        {
            LPTSTR lpStrings[1] = { NULL };
            
            LOGMESSAGE0(_T("ERROR: using custom bindings"));
            LOGMESSAGE1(_T("%s will be disabled and bindings reset"), pszWinstation);
            
            VERIFY(ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("LanAdapter"), (DWORD)-1));
            VERIFY(ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fEnableWinStation"), 0));
            
            //
            //  Log error to setuperr.txt once. Log error to eventlog
            //  each time.
            //
            
            if (!fErrorLogged)
            {
                fErrorLogged = TRUE;
                LogErrorToSetupLog(OcErrLevWarning, IDS_STRING_GENERIC_LANA_WARNING);
            }
            
            lpStrings[0] = pszWinstation;
            LogErrorToEventLog(
                EVENTLOG_WARNING_TYPE,
                CATEGORY_NOTIFY_EVENTS,
                EVENT_WINSTA_DISABLED_DUE_TO_LANA,
                1,
                0,
                (LPCTSTR *)lpStrings,
                NULL
                );
        }
    }
    else
    {
        LOGMESSAGE0(_T("OK: No LanAdapter value"));
    }
}

BOOL SubCompCoreTS::UpdateRDPWinstation (CRegistry *pRegWinstation)
{
    //
    //  These entries will be modified on upgrades.
    //
    
    ASSERT(pRegWinstation);
    
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fDisableClip"), 0) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fDisableCpm"), 0) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fDisableLPT"), 0) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fInheritAutoClient"), 1) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fAutoClientLpts"), 1) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fForceClientLptDef"), 1) );
    
    
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegString(_T("WdName"), _T("Microsoft RDP 5.1")));
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("WdFlag"), 0x36) );
    
    // per JoyC updated for RDPWD, RDP-TCP winstations.
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fDisableCcm"), 0x0) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fDisableCdm"), 0x0) );
    
    //  enable audio redirection for Professional, disable for server
    //
    if ( StateObject.IsWorkstation() )
    {
        VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fDisableCam"), 0x0 ));
    }
    
    
    // Per AraBern, updated for RDPWD, RDP-TCP winstations.
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("ColorDepth"), StateObject.IsWorkstation() ? 0x3 : 0x1) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fInheritColorDepth"), 0x1) );
    
    
    return TRUE;
}

BOOL SubCompCoreTS::IsRdpWinStation(CRegistry *pRegWinstation)
{
    ASSERT(pRegWinstation);
    
    
    DWORD dwWdFlag;
    if (ERROR_SUCCESS == pRegWinstation->ReadRegDWord(_T("WdFlag"), &dwWdFlag))
    {
        
        
#ifdef DBG
        // if this is an RDP winstation,
        // we must have Microsoft in the WdName string
        if (WDF_TSHARE & dwWdFlag)
        {
            LPTSTR strWdName;
            DWORD dwSize;
            if (ERROR_SUCCESS == pRegWinstation->ReadRegString(_T("WdName"), &strWdName, &dwSize))
            {
                ASSERT(_tcsstr(strWdName,_T("Microsoft")) && _tcsstr(strWdName, _T("RDP")));
            }
            else
            {
                //
                // we failed to read strWdName.
                // it shouldn't have happened.
                ASSERT(FALSE);
            }
            
        }
#endif
        
        return WDF_TSHARE & dwWdFlag;
        
    }
    else
    {
        //
        // we failed to read WdFlag, it should not have happened.
        //
        LOGMESSAGE0(_T("ERROR, Failed to read WdFlag for winstation"));
        ASSERT(FALSE);
        return FALSE;
    }
    
    
}

BOOL SubCompCoreTS::IsConsoleWinStation(CRegistry *pRegWinstation)
{
    ASSERT(pRegWinstation);
    
    LPTSTR strWdName;
    DWORD dwSize;
    if (ERROR_SUCCESS == pRegWinstation->ReadRegString(_T("WdName"), &strWdName, &dwSize))
    {
        // if the value wdname contains the string "Console"
        // this is console winstation subkey
        
        LOGMESSAGE1(_T("WdName for this winstation = %s"), strWdName);
        
#ifdef DBG
        // if this is console winstation
        if (_tcsicmp(strWdName,_T("Console")) == 0)
        {
            // then it cannot be either RDP or MetaFrame winstation
            ASSERT(!IsMetaFrameWinstation(pRegWinstation) && !IsRdpWinStation(pRegWinstation));
        }
#endif
        
        return _tcsicmp(strWdName,_T("Console")) == 0;
        
    }
    else
    {
        LOGMESSAGE0(_T("ERROR, Failed to read Wdname for winstation"));
        ASSERT(FALSE);
        return FALSE;
    }
    
}

// returns true if this is non-rdp and non-console winstation subkey.
BOOL SubCompCoreTS::IsMetaFrameWinstation(CRegistry *pRegWinstation)
{
    ASSERT(pRegWinstation);
    
    DWORD dwWdFlag;
    if (ERROR_SUCCESS == pRegWinstation->ReadRegDWord(_T("WdFlag"), &dwWdFlag))
    {
        return WDF_ICA & dwWdFlag;
    }
    else
    {
        //
        // we could not read WdFlag value.
        //
        LOGMESSAGE0(_T("ERROR, Failed to read WdFlag for winstation"));
        ASSERT(FALSE);
        return TRUE;
    }
    
}


BOOL SubCompCoreTS::UpgradeRdpWinstations ()
{
    // we need to upgrade RDP capabilities for RDPWD and existing RDP winstations.
    // see also #240925
    
    // also if during upgrades we found any non-rdp winstations
    // we must disable them as they are not compatible with NT5.
    // #240905
    
    CRegistry reg;
    if (ERROR_SUCCESS == reg.OpenKey(HKEY_LOCAL_MACHINE, REG_WINSTATION_KEY))
    {
        
        LPTSTR lpStr = NULL;
        DWORD dwSize = 0;
        
        if (ERROR_SUCCESS == reg.GetFirstSubKey(&lpStr, &dwSize))
        {
            do
            {
                
                ASSERT(lpStr);
                ASSERT(dwSize > 0);
                
                // check if the current key is on rdp winstation
                CRegistry regSubKey;
                if ( ERROR_SUCCESS == regSubKey.OpenKey(reg, lpStr) )
                {
                    
                    if (IsRdpWinStation(&regSubKey))
                    {
                        LOGMESSAGE1(_T("Updating Winstation - %s"), lpStr);
                        UpdateRDPWinstation(&regSubKey);
                        VerifyLanAdapters(&regSubKey, lpStr);
                    }
                    else if (IsMetaFrameWinstation(&regSubKey))
                    {
                        LOGMESSAGE1(_T("Disabling winstaion - %s"), lpStr);
                        DisableWinStation(&regSubKey);
                        VerifyLanAdapters(&regSubKey, lpStr);
                    }
                    else
                    {
                        LOGMESSAGE1(_T("Found a Console Winstation - %s"), lpStr);
                        // this must be console winstation
                        // do nothing for this.
                    }
                    
                }
                else
                {
                    AssertFalse();
                    LOGMESSAGE1(_T("ERROR:Failed to Open Winstation Key %s"), lpStr);
                }
                
            }
            while (ERROR_SUCCESS == reg.GetNextSubKey(&lpStr, &dwSize ));
            
        }
        else
        {
            // since this is upgrade we must find key under Winstations.
            AssertFalse();
            return FALSE;
        }
    }
    else
    {
        AssertFalse();
        return FALSE;
    }
    
    // we need to upgrade Wds\rdpwd as well.
    if ( ERROR_SUCCESS == reg.OpenKey(HKEY_LOCAL_MACHINE, SYSTEM_RDPWD_KEY))
    {
        //
        // this is not really a winstation.
        // but this call will upgrade the required entries.
        //
        UpdateRDPWinstation(&reg);
    }
    else
    {
        AssertFalse();
        return FALSE;
    }
    
    return TRUE;
}

/*--------------------------------------------------------------------------------------------------------
* BOOL DoHydraRegistrySecurityChanges ()
* does the necessary security changes for installing hydra
* that is Adds/remove LogOnLocall rights to EveryOne group.
* returns success
* Parameter decides if hydra is getting enabled or disabled.
* -------------------------------------------------------------------------------------------------------*/
BOOL SubCompCoreTS::DoHydraRegistrySecurityChanges ()
{
    BOOL bAddRemove = StateObject.IsTSEnableSelected();
    DWORD dwError = NO_ERROR;
    if (bAddRemove)
    {
        CRegistry reg;
        dwError = reg.OpenKey(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Software"));
        VERIFY(ERROR_SUCCESS == dwError);
        
        PSECURITY_DESCRIPTOR pSecDec, pSecDecNew;
        DWORD dwSize;
        dwError = reg.GetSecurity(&pSecDec, DACL_SECURITY_INFORMATION, &dwSize);
        
        if (dwError != ERROR_SUCCESS)
        {
            LOGMESSAGE1(_T("ERROR:GetSecurity failed with %u"), dwError);
        }
        else
        {
            ASSERT(pSecDec);
            ASSERT(IsValidSecurityDescriptor(pSecDec));
            pSecDecNew = pSecDec;
            
            PACL    pNewDacl = NULL;
            
            if (!AddTerminalServerUserToSD(&pSecDecNew, GENERIC_WRITE, &pNewDacl ))
            {
                LOGMESSAGE1(_T("ERROR:AddUserToSD failed with %u"), GetLastError());
            }
            else
            {
                // due to a bug in RegSetKeySecurity(), existing children of this key
                // will not get the new SID, hence, we must use MARTA calls intead.
                dwError  = SetNamedSecurityInfo(
                    _T("Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Software"),
                    SE_REGISTRY_KEY,
                    DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pNewDacl,
                    NULL);
                
                if (dwError != ERROR_SUCCESS)
                {
                    LOGMESSAGE1(_T("ERROR:SetNamedSecurityInfo failed with %u"), dwError);
                }
            }
            
            // if new sec desciptor been allocated
            if (pSecDecNew != pSecDec)
                LocalFree(pSecDecNew);
        }
        
    }
    else
    {
        ASSERT(FALSE);
    }
    
    return dwError == NO_ERROR;
}


#define INTERNET_CONNECTOR_LICENSE_STORE    L"INET_LICENSE_STORE_2_60e55c11-a780-11d2-b1a0-00c04fa30cc4"
#define INTERNET_CONNECTOR_LSERVER_STORE    L"INET_LSERVER_STORE_2_341D3DAB-BD58-11d2-B130-00C04FB16103"
#define INTERNET_CONNECTOR_LSERVER_STORE2   L"INET_LSERVER_STORE_3_341D3DAB-BD58-11d2-B130-00C04FB16103"

#define HYDRA_SERVER_PARAM                  _T("SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters")
#define HS_PARAM_INTERNET_CONNECTOR_FLAG    _T("fInternetConnector")

BOOL SubCompCoreTS::DisableInternetConnector ()
{
    
    LOGMESSAGE0(_T("DisableInternetConnector"));
    
    // Wipe out the secret keys in LSA, regarding to Internet Connector
    DWORD dwStatus = StoreSecretKey(INTERNET_CONNECTOR_LICENSE_STORE,(PBYTE) NULL,0);
    if (dwStatus == ERROR_SUCCESS)
    {
        LOGMESSAGE0(_T("StoreSecretKey succeeded for INTERNET_CONNECTOR_LICENSE_STORE"));
        
    }
    else
    {
        LOGMESSAGE1(_T("StoreSecretKey(INTERNET_CONNECTOR_LICENSE_STORE) failed. Reason %ld"),dwStatus);
        
    }
    
    
    dwStatus = StoreSecretKey(INTERNET_CONNECTOR_LSERVER_STORE,(PBYTE) NULL,0);
    if (dwStatus == ERROR_SUCCESS)
    {
        LOGMESSAGE0(_T("StoreSecretKey succeeded for INTERNET_CONNECTOR_LSERVER_STORE"));
    }
    else
    {
        LOGMESSAGE1(_T("StoreSecretKey(INTERNET_CONNECTOR_LSERVER_STORE) failed. Reason %ld"),dwStatus);
    }
    
    
    dwStatus = StoreSecretKey(INTERNET_CONNECTOR_LSERVER_STORE2,(PBYTE) NULL,0);
    if (dwStatus == ERROR_SUCCESS)
    {
        LOGMESSAGE0(_T("StoreSecretKey succeeded for INTERNET_CONNECTOR_LSERVER_STORE2"));
    }
    else
    {
        LOGMESSAGE1(_T("StoreSecretKey(INTERNET_CONNECTOR_LSERVER_STORE2) failed. Reason %ld"),dwStatus);
    }
    
    NET_API_STATUS dwNtStatus = NetUserDel(NULL,L"TsInternetUser");
    
    if (dwNtStatus == NERR_Success)
    {
        LOGMESSAGE0(_T("NetUserDel succeeded for TsInternetUser"));
    }
    else
    {
        LOGMESSAGE1(_T("NetUserDel(TsInternetUser) failed. Reason %ld"),dwNtStatus);
    }
    
    return FALSE;
}


#define LICENSING_TIME_BOMB_5_0 L"TIMEBOMB_832cc540-3244-11d2-b416-00c04fa30cc4"
#define RTMLICENSING_TIME_BOMB_5_0 L"RTMTSTB_832cc540-3244-11d2-b416-00c04fa30cc4"

BOOL SubCompCoreTS::ResetTermServGracePeriod ()
{
    
    //
    // Wipe out the secret keys in LSA for the Win2000 grace period
    //
    
    LOGMESSAGE0(_T("Calling StoreSecretKey"));
	
    StoreSecretKey(LICENSING_TIME_BOMB_5_0,(PBYTE) NULL,0);
	
	StoreSecretKey(RTMLICENSING_TIME_BOMB_5_0,(PBYTE) NULL,0);
	
    return TRUE;
    
}

BOOL SubCompCoreTS::RemoveTSServicePackEntry ()
{
    LOGMESSAGE0(_T("will delete terminal service pack uninstall keys."));
    
    CRegistry regUninstallKey;
    if (ERROR_SUCCESS != regUninstallKey.OpenKey(HKEY_LOCAL_MACHINE, SOFTWARE_UNINSTALL_KEY))
    {
        return(TRUE);
    }
    
    BOOL bReturn = TRUE;
    DWORD dwError;
    
    
    //
    // now try to delete various service pack key.
    // if the key does not exist its NOT an error. It means service pack was not installed at all.
    //
    
    dwError = RegDeleteKey(regUninstallKey, TERMSRV_PACK_4_KEY);
    if ((ERROR_SUCCESS != dwError) && (ERROR_FILE_NOT_FOUND != dwError))
    {
        bReturn = FALSE;
        LOGMESSAGE2(_T("Error deleting subkey %s (%d)"), TERMSRV_PACK_4_KEY, dwError);
    }
    
    dwError = RegDeleteKey(regUninstallKey, TERMSRV_PACK_5_KEY);
    if ((ERROR_SUCCESS != dwError) && (ERROR_FILE_NOT_FOUND != dwError))
    {
        bReturn = FALSE;
        LOGMESSAGE2(_T("Error deleting subkey %s (%d)"), TERMSRV_PACK_5_KEY, dwError);
    }
    
    dwError = RegDeleteKey(regUninstallKey, TERMSRV_PACK_6_KEY);
    if ((ERROR_SUCCESS != dwError) && (ERROR_FILE_NOT_FOUND != dwError))
    {
        bReturn = FALSE;
        LOGMESSAGE2(_T("Error deleting subkey %s (%d)"), TERMSRV_PACK_6_KEY, dwError);
    }
    
    dwError = RegDeleteKey(regUninstallKey, TERMSRV_PACK_7_KEY);
    if ((ERROR_SUCCESS != dwError) && (ERROR_FILE_NOT_FOUND != dwError))
    {
        bReturn = FALSE;
        LOGMESSAGE2(_T("Error deleting subkey %s (%d)"), TERMSRV_PACK_7_KEY, dwError);
    }
    
    dwError = RegDeleteKey(regUninstallKey, TERMSRV_PACK_8_KEY);
    if ((ERROR_SUCCESS != dwError) && (ERROR_FILE_NOT_FOUND != dwError))
    {
        bReturn = FALSE;
        LOGMESSAGE2(_T("Error deleting subkey %s (%d)"), TERMSRV_PACK_8_KEY, dwError);
    }
    
    return bReturn;
    
}


//
// #386628: we need remove metaframe executables - txlogon.exe and wfshell.exe from userinit key on TS40 upgrades,
// as these apps are broken after upgrade. // what about any other app that are appending value to userinit ? :
// BradG suggested, that we should just wack the reigsty to contain just userinit.
//

BOOL SubCompCoreTS::RemoveMetaframeFromUserinit ()
{
    ASSERT( StateObject.IsUpgradeFrom40TS() );
    
    CRegistry reg;
    const TCHAR szUserInitKey[] = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
    const TCHAR szUserInitValue[] = _T("Userinit");
    const TCHAR szData[] = _T("userinit");
    
    if (ERROR_SUCCESS == reg.OpenKey(HKEY_LOCAL_MACHINE, szUserInitKey))
    {
        return (ERROR_SUCCESS == reg.WriteRegString(szUserInitValue, szData));
    }
    else
    {
        LOGMESSAGE0(_T("ERROR:Failed to open userinit key"));
    }
    
    return FALSE;
}


BOOL SubCompCoreTS::BackUpRestoreConnections (BOOL bBackup)
{
    
    LPCTSTR SOFTWARE_MSFT = _T("Software\\Microsoft");
    LPCTSTR TS_CLIENT     = _T("Terminal Server Client");
    LPCTSTR TS_CLIENT_TMP = _T("Terminal Server Client.temp");
    
    CRegistry regAllUsers(HKEY_USERS);
    
    
    //
    // now enumerate through all the uses and Copy settings to new key.
    //
    
    DWORD dwSize;
    LPTSTR szUser = NULL;
    if (ERROR_SUCCESS == regAllUsers.GetFirstSubKey(&szUser, &dwSize))
    {
        
        do
        {
            
            ASSERT(szUser);
            
            TCHAR szSrcKey[512];
            TCHAR szDstKey[512];
            
            
            _tcscpy(szSrcKey, szUser);
            _tcscat(szSrcKey, _T("\\"));
            _tcscat(szSrcKey, SOFTWARE_MSFT);
            _tcscat(szSrcKey, _T("\\"));
            
            _tcscpy(szDstKey, szSrcKey);
            
            
            if (bBackup)
            {
                // we are backing up from TS_CLIENT to TS_CLIENT_TEMP
                _tcscat(szSrcKey, TS_CLIENT);
                _tcscat(szDstKey, TS_CLIENT_TMP);
                
            }
            else
            {
                // we are restoring TS_CLIENT from TS_CLIENT_TMP
                _tcscat(szSrcKey, TS_CLIENT_TMP);
                _tcscat(szDstKey, TS_CLIENT);
                
            }
            
            CRegistry regSrc;
            CRegistry regDst;
            DWORD dwError;
            
            if (ERROR_SUCCESS == (dwError = regSrc.OpenKey(HKEY_USERS, szSrcKey)))
            {
                if (ERROR_SUCCESS == (dwError = regDst.CreateKey(HKEY_USERS, szDstKey)))
                {
                    regDst.CopyTree(regSrc);
                    
                    if (!bBackup)
                    {
                        //
                        // if we are restoring, delete the temp tree we created, during backup.
                        //
                        CRegistry regSM;
                        TCHAR szTempKey[512];
                        _tcscpy(szTempKey, szUser);
                        _tcscat(szTempKey, _T("\\"));
                        _tcscat(szTempKey, SOFTWARE_MSFT);
                        
                        dwError = regSM.OpenKey(HKEY_USERS, szTempKey);
                        if (ERROR_SUCCESS  == dwError)
                        {
                            dwError = regSM.RecurseDeleteKey(TS_CLIENT_TMP);
                            if (ERROR_SUCCESS != dwError)
                            {
                                LOGMESSAGE2(_T("Failed to recurse delete <%s>, LastError = %d"), _T("Terminal Server Client.Temp"), dwError);
                                
                            }
                            
                        }
                        else
                        {
                            LOGMESSAGE2(_T("Failed to open <%s> key for deleting, LastError = %d"), szTempKey, dwError);
                        }
                    }
                    
                }
                else
                {
                    LOGMESSAGE2(_T("Failed to CreateKey <%s>, Error = %d"), szDstKey, dwError);
                }
            }
            else
            {
                //
                // if error is file not found, then its nor a real error.
                // It just means that the Client key was not there for this user.
                // If its anything but ERROR_FILE_NOT_FOUND we want to know about it.
                //
                if (dwError != ERROR_FILE_NOT_FOUND)
                {
                    LOGMESSAGE2(_T("Failed to openKey <%s>, Error = %d"), szSrcKey, dwError);
                }
            }
            
            
        }
        while (ERROR_SUCCESS == regAllUsers.GetNextSubKey(&szUser, &dwSize));
        
    }
    else
    {
        LOGMESSAGE0(_T("Error reading users hive"));
        return FALSE;
    }
    
    return TRUE;
}

BOOL ExecuteProgram(LPTSTR szUninstallProg)
{
    PROCESS_INFORMATION pinfo;
    STARTUPINFO sinfo;
    
    ZeroMemory(&sinfo, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    
    ASSERT(szUninstallProg);
    if (CreateProcess(
        NULL,                             // name of executable module
        szUninstallProg,                  // command line string
        NULL,                             // SD
        NULL,                             // SD
        FALSE,                            // handle inheritance option
        CREATE_NEW_PROCESS_GROUP,         // creation flags
        NULL,                             // new environment block
        NULL,                             // current directory name
        &sinfo,                             // startup information
        &pinfo                            // process information
        ))
    {
        
        DWORD dwReason = WaitForSingleObject(pinfo.hProcess, 15 * 1000);
        if (WAIT_OBJECT_0 == dwReason)
        {
            DWORD dwExitCode;
            if (GetExitCodeProcess(pinfo.hProcess, &dwExitCode))
            {
                LOGMESSAGE1(_T("Uninstall exited with code = %d"), dwExitCode);
            }
            else
            {
                LOGMESSAGE1(_T("ERROR, GetExitCodeProcess failed, LastError = %d"), GetLastError());
                return FALSE;
            }
        }
        else
        {
            if (WAIT_ABANDONED == dwReason)
            {
                LOGMESSAGE0(_T("ERROR, wait object was wrong!"));
                
            }
            else
            {
                // WAIT_TIMEOUT
                LOGMESSAGE0(_T("ERROR, timed out waiting!"));
                
            }
            
            return FALSE;
            
        }
        
        
    }
    else
    {
        LOGMESSAGE1(_T("ERROR CreateProcess failed, Lasterror was %d"), GetLastError());
        return FALSE;
    }
    
    
    return TRUE;
}


BOOL SubCompCoreTS::UninstallTSClient ()
{
    LPCTSTR SOFTWARE_MSFT = _T("Software\\Microsoft");
    LPCTSTR RUNONCE = _T("Windows\\CurrentVersion\\RunOnce");
    LPCTSTR TSC_UNINSTALL = _T("tscuninstall");
    LPCTSTR TSC_UNINSTALL_CMD = _T("%systemroot%\\system32\\tscupgrd.exe");
    
    CRegistry regAllUsers(HKEY_USERS);
    
    //
    // now enumerate through all the uses and Copy settings to new key.
    //
    
    DWORD dwSize;
    LPTSTR szUser = NULL;
    if (ERROR_SUCCESS == regAllUsers.GetFirstSubKey(&szUser, &dwSize))
    {
        do
        {
            ASSERT(szUser);
            
            TCHAR szSrcKey[512];
            
            _tcscpy(szSrcKey, szUser);
            _tcscat(szSrcKey, _T("\\"));
            _tcscat(szSrcKey, SOFTWARE_MSFT);
            _tcscat(szSrcKey, _T("\\"));
            _tcscat(szSrcKey, RUNONCE);
            
            CRegistry regSrc;
            DWORD dwError;
            
            if (ERROR_SUCCESS == (dwError = regSrc.OpenKey(HKEY_USERS, szSrcKey)))
            {
                
                if (ERROR_SUCCESS == regSrc.WriteRegExpString(TSC_UNINSTALL, TSC_UNINSTALL_CMD)) {
                    
                    LOGMESSAGE1(_T("Write TSC uninstall reg value to user %s"), szSrcKey);
                    
                }
                else {
                    
                    LOGMESSAGE1(_T("ERROR write TSC uninstall reg value, Lasterror was %d"), GetLastError());
                }
            }
            else {
                
                LOGMESSAGE1(_T("ERROR open user runonce key, Lasterror was %d"), GetLastError());
            }
            
        } while (ERROR_SUCCESS == regAllUsers.GetNextSubKey(&szUser, &dwSize));
    }
    else {
        
        LOGMESSAGE1(_T("ERROR open user hive"), GetLastError());
    }
    
    return TRUE;
}


BOOL SubCompCoreTS::WriteDenyConnectionRegistry ()
{
    //
    // we need to write this value only for fresh installs, or if its changed.
    //
    DWORD dwError;
    CRegistry oRegTermsrv;
    
    dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
    if (ERROR_SUCCESS == dwError)
    {
        DWORD dwDenyConnect = StateObject.GetCurrentConnAllowed() ? 0 : 1;
        LOGMESSAGE1(_T("Writing dwDenyConnect = %d"), dwDenyConnect);
        
        dwError = oRegTermsrv.WriteRegDWord(DENY_CONN_VALUE, dwDenyConnect);
        
        if (ERROR_SUCCESS == dwError)
        {
            return TRUE;
        }
        else
        {
            LOGMESSAGE2(_T("Error (%d), Writing, %s Value"), dwError, DENY_CONN_VALUE);
            return FALSE;
        }
    }
    else
    {
        LOGMESSAGE2(_T("Error (%d), Opening , %s key"), dwError, REG_CONTROL_TS_KEY);
        return FALSE;
    }
    
}

LPCTSTR SERVICES_TERMDD_KEY = _T("SYSTEM\\CurrentControlSet\\Services\\TermDD");

void SubCompCoreTS::SetConsoleShadowInstalled (BOOL bInstalled)
{
    // ; HKLM, "SYSTEM\CurrentControlSet\Services\TermDD", "PortDriverEnable", 0x00010001, 0x1
    
    CRegistry Reg;
    if (ERROR_SUCCESS == Reg.CreateKey(HKEY_LOCAL_MACHINE, SERVICES_TERMDD_KEY))
    {
        if (ERROR_SUCCESS != Reg.WriteRegDWord(_T("PortDriverEnable"), bInstalled ? 1 : 0))
        {
            LOGMESSAGE0(_T("ERROR, Failed to write to PortDriverEnable"));
        }
        
    }
    else
    {
        LOGMESSAGE1(_T("ERROR, Failed to Create/Open %s"), SERVICES_TERMDD_KEY);
        
    }
    
}

BOOL SubCompCoreTS::IsConsoleShadowInstalled ()
{
    // ; HKLM, "SYSTEM\CurrentControlSet\Services\TermDD", "PortDriverEnable", 0x00010001, 0x1
    
    CRegistry Reg;
    
    if (ERROR_SUCCESS == Reg.OpenKey(HKEY_LOCAL_MACHINE, SERVICES_TERMDD_KEY))
    {
        DWORD dwPortDriverEnable;
        if (ERROR_SUCCESS == Reg.ReadRegDWord(_T("PortDriverEnable"), &dwPortDriverEnable))
        {
            return (dwPortDriverEnable == 1);
        }
        else
        {
            LOGMESSAGE0(_T("Failed to read from PortDriverEnable, Maybe Console Shadow is not installed yet."));
            
        }
        
    }
    else
    {
        LOGMESSAGE1(_T("ERROR, Failed to Open %s"), SERVICES_TERMDD_KEY);
        
    }
    
    return FALSE;
}

#ifdef TSOC_CONSOLE_SHADOWING
BOOL SubCompCoreTS::SetupConsoleShadow ()
{
    if (IsConsoleShadowInstalled () == StateObject.IsTSEnableSelected())
    {
        return TRUE;
    }
    
    if (StateObject.IsTSEnableSelected())
    {
        LOGMESSAGE0(_T("Installing RDP Keyboard/Mouse drivers!"));
        
        //
        // this code is new to install Mouse Device for console shadowing.
        //
        
        if (!RDPDRINST_GUIModeSetupInstall(NULL, RDPMOUPNPID, RDPMOUDEVICEID))
        {
            LOGMESSAGE0(_T("ERROR:Could not create mouse devnode"));
        }
        
        
        //
        // this code is new to install Kbd Device for console shadowing.
        //
        
        if (!RDPDRINST_GUIModeSetupInstall(NULL, RDPKBDPNPID, RDPKBDDEVICEID))
        {
            LOGMESSAGE0(_T("ERROR:Could not create kbd devnode"));
        }
        
        //
        // this code is new to install RDPCDD chained driver
        //
        
        
        /*
        TCHAR szInfFile[MAX_PATH];
        ExpandEnvironmentStrings(szRDPCDDInfFile, szInfFile, MAX_PATH);
        LOGMESSAGE1(_T("Inf file for RDPCDD is %s"), szInfFile);
        
          BOOL bRebootRequired = TRUE;
          
            if (NO_ERROR != InstallRootEnumeratedDevice( NULL, szRDPCDDDeviceName, szRDPCDDHardwareID, szInfFile, &bRebootRequired))
            {
            LOGMESSAGE0(_T("InstallRootEnumeratedDevice failed"));
            }
        */
        
    }
    else
    {
        GUID *pGuid=(GUID *)&GUID_DEVCLASS_SYSTEM;
        if (!RDPDRINST_GUIModeSetupUninstall(NULL, RDPMOUPNPID, pGuid))
        {
            LOGMESSAGE0(_T("ERROR:RDPDRINST_GUIModeSetupUninstall failed for RDP Mouse device"));
        }
        
        pGuid=(GUID *)&GUID_DEVCLASS_SYSTEM;
        if (!RDPDRINST_GUIModeSetupUninstall(NULL, RDPKBDPNPID, pGuid))
        {
            LOGMESSAGE0(_T("ERROR:RDPDRINST_GUIModeSetupUninstall failed for RDP KBD device"));
        }
        
        /*
        pGuid=(GUID *)&GUID_DEVCLASS_DISPLAY;
        if (!RDPDRINST_GUIModeSetupUninstall(NULL, (WCHAR *)T2W(szRDPCDDHardwareID), pGuid)) {
        LOGMESSAGE0(_T("ERROR:RDPDRINST_GUIModeSetupUninstall failed for Chained Display device"));
        }
        */
        
        CRegistry Reg;
        
        if (ERROR_SUCCESS == Reg.OpenKey(HKEY_LOCAL_MACHINE, SERVICES_TERMDD_KEY))
        {
            if (ERROR_SUCCESS != Reg.WriteRegDWord(_T("Start"), 4))
            {
                LOGMESSAGE0(_T("ERROR, Failed to write to TermDD\\Start"));
            }
        }
        else
        {
            LOGMESSAGE1(_T("ERROR, Failed to Open %s"), SERVICES_TERMDD_KEY);
            
        }
    }
    
    SetConsoleShadowInstalled( StateObject.IsTSEnableSelected() );
    
    return( TRUE );
}


#endif // TSOC_CONSOLE_SHADOWING

DWORD SubCompCoreTS::LoadOrUnloadPerf ()
{
    BOOL bLoad = StateObject.IsTSEnableSelected();
    LPCTSTR TERMSRV_SERVICE_PATH = _T("SYSTEM\\CurrentControlSet\\Services\\TermService");
    LPCTSTR TERMSRV_PERF_NAME = _T("Performance");
    LPCTSTR TERMSRV_PERF_COUNTERS = _T("SYSTEM\\CurrentControlSet\\Services\\TermService\\Performance");
    LPCTSTR TERMSRV_PERF_COUNTERS_FIRST_COUNTER = _T("First Counter");
    LPCTSTR TERMSRV_PERF_COUNTERS_LAST_COUNTER = _T("Last Counter");
    LPCTSTR TERMSRV_PERF_COUNTERS_FIRST_HELP = _T("First Help");
    LPCTSTR TERMSRV_PERF_COUNTERS_LAST_HELP = _T("Last Help");
    LPCTSTR TERMSRV_PERF_COUNTERS_LIBRARY = _T("Library");
    LPCTSTR TERMSRV_PERF_COUNTERS_LIBRARY_VALUE = _T("perfts.dll");
    LPCTSTR TERMSRV_PERF_CLOSE = _T("Close");
    LPCTSTR TERMSRV_PERF_CLOSE_VALUE = _T("CloseTSObject");
    LPCTSTR TERMSRV_PERF_COLLECT_TIMEOUT = _T("Collect Timeout");
    const DWORD TERMSRV_PERF_COLLECT_TIMEOUT_VALUE = 1000;
    LPCTSTR TERMSRV_PERF_COLLECT = _T("Collect");
    LPCTSTR TERMSRV_PERF_COLLECT_VALUE = _T("CollectTSObjectData");
    LPCTSTR TERMSRV_PERF_OPEN_TIMEOUT = _T("Open Timeout");
    const DWORD TERMSRV_PERF_OPEN_TIMEOUT_VALUE = 1000;
    LPCTSTR TERMSRV_PERF_OPEN = _T("Open");
    LPCTSTR TERMSRV_PERF_OPEN_VALUE = _T("OpenTSObject");
    
    TCHAR PerfArg[MAX_PATH + 10];
    CRegistry reg;
    DWORD RetVal;
    
    LOGMESSAGE1(_T("Entered LoadOrUnloadPerfCounters, load=%u"), bLoad);
    
    if (bLoad)
    {
        //
        // As a first step to installing, first clean out any existing
        // entries by unloading the counters
        //
        LOGMESSAGE0(_T("Unloading counters before install"));
        UnloadPerf();

        RetVal = reg.CreateKey(HKEY_LOCAL_MACHINE, TERMSRV_PERF_COUNTERS);
        if (RetVal == ERROR_SUCCESS)
        {
            
            TCHAR SystemDir[MAX_PATH];
            
            // On load we create and populate the entire Performance key.
            // This key must not be present when we are unloaded because
            // the WMI provider enumerates service performance DLLs
            // according to the presence of the Perf key. If it is present
            // but not fully filled in then an error log is generated.
            if (GetSystemDirectory(SystemDir, MAX_PATH))
            {
                // Just in case they are present, delete the counter number
                // entries to make sure we regenerate them correctly below.
                reg.DeleteValue(TERMSRV_PERF_COUNTERS_FIRST_COUNTER);
                reg.DeleteValue(TERMSRV_PERF_COUNTERS_LAST_COUNTER);
                reg.DeleteValue(TERMSRV_PERF_COUNTERS_FIRST_HELP);
                reg.DeleteValue(TERMSRV_PERF_COUNTERS_LAST_HELP);
                
                // Generate the static values.
                reg.WriteRegString(TERMSRV_PERF_CLOSE, TERMSRV_PERF_CLOSE_VALUE);
                reg.WriteRegDWord(TERMSRV_PERF_COLLECT_TIMEOUT, TERMSRV_PERF_COLLECT_TIMEOUT_VALUE);
                reg.WriteRegString(TERMSRV_PERF_COLLECT, TERMSRV_PERF_COLLECT_VALUE);
                reg.WriteRegDWord(TERMSRV_PERF_OPEN_TIMEOUT, TERMSRV_PERF_OPEN_TIMEOUT_VALUE);
                reg.WriteRegString(TERMSRV_PERF_OPEN, TERMSRV_PERF_OPEN_VALUE);
                reg.WriteRegString(TERMSRV_PERF_COUNTERS_LIBRARY, TERMSRV_PERF_COUNTERS_LIBRARY_VALUE);
                
                _stprintf(PerfArg, _T("%s %s\\%s"), _T("lodctr"), SystemDir, _T("tslabels.ini"));
                LOGMESSAGE1(_T("Arg is %s"), PerfArg);
                return DWORD(LoadPerfCounterTextStrings(PerfArg, FALSE));
            }
            else
            {
                unsigned LastErr = GetLastError();
                
                LOGMESSAGE1(_T("GetSystemDirectory Failure is %ld"), LastErr);
                return LastErr;
            }
        }
        else
        {
            LOGMESSAGE1(_T("Perf regkey create failure, err=%ld"), RetVal);
            return RetVal;
        }
    }
    else
    {
        return UnloadPerf();
    }
}

//
// Unload perf ctrs
//
DWORD SubCompCoreTS::UnloadPerf()
{
    TCHAR PerfArg[MAX_PATH + 10];
    CRegistry reg;
    DWORD RetVal;

    LPCTSTR TERMSRV_SERVICE_PATH = _T("SYSTEM\\CurrentControlSet\\Services\\TermService");
    LPCTSTR TERMSRV_PERF_NAME = _T("Performance");

    // On unload, first unload the counters we should have in the system.
    _stprintf(PerfArg, _T("%s %s"), _T("unlodctr"), _T("TermService"));
    LOGMESSAGE1(_T("Arg is %s"), PerfArg);
    UnloadPerfCounterTextStrings(PerfArg, FALSE);

    // Delete the entire Performance key and all its descendants. We have
    // to first open the ancestor key (TermService).
    RetVal = reg.OpenKey(HKEY_LOCAL_MACHINE, TERMSRV_SERVICE_PATH);
    if (RetVal == ERROR_SUCCESS)
    {
        RetVal = reg.RecurseDeleteKey(TERMSRV_PERF_NAME);
        if (RetVal != ERROR_SUCCESS)
        {
            LOGMESSAGE1(_T("ERROR deleting Performance key: %ld"), RetVal);
        }
    }
    else
    {
        LOGMESSAGE1(_T("Err opening Performance key, err=%ld"), RetVal);
    }

    return RetVal;
}


void SubCompCoreTS::AddRDPNP(LPTSTR szOldValue, LPTSTR szNewValue)
{
    TCHAR RDPNP_ENTRY[]  = _T("RDPNP");
    const TCHAR SZ_SEP[] = _T(" \t");
    
    //
    // We are adding our rdpnp entry to the beginning of the list
    //
    // we dont want to add comma if original value is empty.
    //
    if (_tcslen(szOldValue) != 0 && _tcstok(szOldValue, SZ_SEP))
    {
        _tcscpy(szNewValue, RDPNP_ENTRY);
        _tcscat(szNewValue, _T(","));
        _tcscat(szNewValue, szOldValue);
    }
    else {
        _tcscpy(szNewValue, RDPNP_ENTRY);
    }                   
    
}

void SubCompCoreTS::RemoveRDPNP(LPTSTR szOldValue, LPTSTR szNewValue)
{
    TCHAR RDPNP_ENTRY[]  = _T("RDPNP");
    
    //
    // this is little complicated,
    // we need to remove RDPNP from , seperated list.
    //
    // so lets get tokens.
    //
    
    
    TCHAR *szToken = NULL;
    const TCHAR SZ_SEP[] = _T(",");
    
    _tcscpy(szNewValue, _T(""));
    
    szToken = _tcstok(szOldValue, SZ_SEP);
    
    BOOL bFirstPass = TRUE;
    while (szToken)
    {
        // if the token is RDPNP, skip it.
        if (_tcsstr(szToken, RDPNP_ENTRY) == 0)
        {
            if (!bFirstPass)
            {
                _tcscat(szNewValue, _T(","));
            }
            
            _tcscat(szNewValue, szToken);
            
            bFirstPass = FALSE;
            
        }
        
        szToken = _tcstok(NULL, SZ_SEP);
        
    }
}

BOOL SubCompCoreTS::AddRemoveRDPNP ()
{
    // HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\NetworkProvider\Order
    
    BOOL bAdd = StateObject.IsTSEnableSelected();
    TCHAR NEWORK_PROVIDER_ORDER_KEY[] = _T("SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order");
    TCHAR PROVIDER_ORDER_VALUE[]      = _T("ProviderOrder");
    TCHAR RDPNP_ENTRY[]               = _T("RDPNP");
    
    CRegistry regNetOrder;
    if (ERROR_SUCCESS == regNetOrder.OpenKey(HKEY_LOCAL_MACHINE, NEWORK_PROVIDER_ORDER_KEY))
    {
        LPTSTR szOldValue;
        DWORD dwSize;
        if (ERROR_SUCCESS == regNetOrder.ReadRegString(PROVIDER_ORDER_VALUE, &szOldValue, &dwSize))
        {
            //
            // now we want to add or remove RDPNP_ENTRY depending on we are enabled or disabled.
            //
            
            BOOL bRdpNpExists = (_tcsstr(szOldValue, RDPNP_ENTRY) != NULL);
            
            if (bAdd == bRdpNpExists)
            {
                TCHAR szNewValue[256];
                
                //
                // already exists.
                //
                LOGMESSAGE0(_T("AddRemoveRDPNP, no change required."));
                
                //
                // Need to move to the right location
                // 
                RemoveRDPNP(szOldValue, szNewValue); 
                _tcscpy(szOldValue, szNewValue);
                AddRDPNP(szOldValue, szNewValue);           
                
                if (ERROR_SUCCESS != regNetOrder.WriteRegString(PROVIDER_ORDER_VALUE, szNewValue))
                {
                    
                    LOGMESSAGE2(_T("ERROR, Writing %s to %s"), szNewValue, PROVIDER_ORDER_VALUE);
                    
                }
            }
            else
            {
                TCHAR szNewValue[256];
                
                if (bAdd)
                {
                    //
                    // We are adding our rdpnp entry to the beginning of the list
                    //
                    
                    AddRDPNP(szOldValue, szNewValue);
                }
                else
                {
                    //
                    // this is little complicated,
                    // we need to remove RDPNP from , seperated list.
                    //
                    
                    RemoveRDPNP(szOldValue, szNewValue);                    
                }
                
                if (ERROR_SUCCESS != regNetOrder.WriteRegString(PROVIDER_ORDER_VALUE, szNewValue))
                {
                    
                    LOGMESSAGE2(_T("ERROR, Writing %s to %s"), szNewValue, PROVIDER_ORDER_VALUE);
                    
                }
                
            }
            
        }
        else
        {
            LOGMESSAGE1(_T("ERROR, Reading %s"), PROVIDER_ORDER_VALUE);
            return FALSE;
            
        }
    }
    else
    {
        LOGMESSAGE1(_T("ERROR, Opening %s"), NEWORK_PROVIDER_ORDER_KEY);
        return FALSE;
    }
    
    return TRUE;
}



BOOL SubCompCoreTS::UpdateMMDefaults ()
{
    LPCTSTR MM_REG_KEY = _T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management");
    LPCTSTR SESSION_VIEW_SIZE_VALUE = _T("SessionViewSize");
    LPCTSTR SESSION_POOL_SIZE_VALUE = _T("SessionPoolSize");
    
    const DWORD dwViewSizeforPTS = 48;
    const DWORD dwPoolSizeforPTS = 4;
    
    if (StateObject.IsWorkstation() && StateObject.IsX86())
    {
        CRegistry  regMM;
        if (ERROR_SUCCESS == regMM.OpenKey(HKEY_LOCAL_MACHINE, MM_REG_KEY))
        {
            if (StateObject.IsTSEnableSelected() && !StateObject.IsCheckedBuild())
            {
                if ((ERROR_SUCCESS != regMM.WriteRegDWord(SESSION_VIEW_SIZE_VALUE, dwViewSizeforPTS)) ||
                    (ERROR_SUCCESS != regMM.WriteRegDWord(SESSION_POOL_SIZE_VALUE, dwPoolSizeforPTS)))
                {
                    LOGMESSAGE0(_T("ERROR, Failed to write MM Defaults for PTS"));
                    return FALSE;
                }
                else
                {
                    LOGMESSAGE0(_T("Wrote MM Defaults for PTS"));
                }
            }
            else
            {
                //
                //  For checked builds we dont want to keep defaults
                //
                regMM.DeleteValue(SESSION_VIEW_SIZE_VALUE);
                regMM.DeleteValue(SESSION_POOL_SIZE_VALUE);
            }
        }
        else
        {
            LOGMESSAGE0(_T("ERROR, Failed to open mm Key"));
            return FALSE;
        }
    }
    
    return TRUE;
}


BOOL SubCompCoreTS::InstallUninstallRdpDr ()
{
    //
    //  This code shouldn't run on Personal.  Device redirection isn't 
    //  supported for Personal.
    //
    if (StateObject.IsPersonal()) {
        return TRUE;
    }
    
    //
    //  Installing RDPDR over itself is bad. Hence, only (un)install on
    //  a state change or an upgrade from TS40, but don't do unnecessary
    //  uninstalls. These are when coming from TS40, but using an unattended
    //  file to turn TS off. Therefore, RDPDR installation is the XOR of
    //  HasStateChanged() and IsUpgradeFromTS40().
    //
    
    // if state has changed.
    if (StateObject.IsUpgradeFrom40TS() || (StateObject.WasTSEnabled() != StateObject.IsTSEnableSelected()) 
        || !IsRDPDrInstalled() ) // last case checks for Personal -> Pro upgrades, we want to instsall rdpdr in those cases.
    {
        if (StateObject.IsTSEnableSelected())
        {
            LOGMESSAGE0(_T("Installing RDPDR"));
            if (!RDPDRINST_GUIModeSetupInstall(NULL, RDPDRPNPID, RDPDRDEVICEID))
            {
                LOGMESSAGE0(_T("ERROR:RDPDRINST_GUIModeSetupInstall failed"));
            }
        }
        else
        {
            LOGMESSAGE0(_T("Uninstalling RDPDR"));
            GUID *pGuid=(GUID *)&GUID_DEVCLASS_SYSTEM;
            if (!RDPDRINST_GUIModeSetupUninstall(NULL, RDPDRPNPID, pGuid))
            {
                LOGMESSAGE0(_T("ERROR:RDPDRINST_GUIModeSetupUninstall failed"));
            }
        }
    }
    
    return TRUE;
}

BOOL SubCompCoreTS::HandleHotkey ()
{
    if (StateObject.IsTSEnableSelected())
    {
        CRegistry pRegToggle;
        
        //
        // Install Hotkey if not exist key value in HKU/.Default/Keyboard Layout/Toggle!Hotkey
        //
#define REG_TOGGLE_KEY   _T(".Default\\Keyboard Layout\\Toggle")
#define REG_HOT_KEY      _T("Hotkey")
#define DEFAULT_HOT_KEY  _T("1")
        DWORD dwRet;
        
        dwRet = pRegToggle.CreateKey(HKEY_USERS, REG_TOGGLE_KEY);
        if (dwRet == ERROR_SUCCESS)
        {
            LPTSTR pszHotkey;
            DWORD  cbSize;
            
            dwRet = pRegToggle.ReadRegString(REG_HOT_KEY, &pszHotkey, &cbSize);
            if (dwRet != ERROR_SUCCESS)
            {
                dwRet = pRegToggle.WriteRegString(REG_HOT_KEY, DEFAULT_HOT_KEY);
                if (dwRet != ERROR_SUCCESS)
                {
                    LOGMESSAGE2(_T("ERROR:CRegistry::WriteRegString (%s=%s)"), REG_HOT_KEY, DEFAULT_HOT_KEY);
                }
            }
        }
        else
        {
            LOGMESSAGE1(_T("ERROR:CRegistry::CreateKey (%s)"), REG_TOGGLE_KEY);
        }
    }
    
    return TRUE;
}

/*
*  UpdateAudioCodecs - populates all audio codecs for RDP session
*/
#define DRIVERS32 _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32")
#define RDPDRV    ( DRIVERS32 _T("\\Terminal Server\\RDP") )

BOOL UpdateAudioCodecs (BOOL bIsProfessional)
{
    BOOL    rv = TRUE;
    LPTSTR  szBuff;
    DWORD   status;
    CRegistry regKey;
    CRegistry regDestKey;
    DWORD   size;
    CRegistry   regTemp;
    
    //
    //  copy keys from
    //  HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Drivers32
    //      wavemapper
    //      midimapper
    //      EnableMP3Codec (Professional only)
    //
    status = regKey.OpenKey(
        HKEY_LOCAL_MACHINE,
        DRIVERS32
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    
    status = regTemp.OpenKey(
        HKEY_LOCAL_MACHINE,
        DRIVERS32
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    //
    //  Create the destination
    //
    status = regDestKey.CreateKey(
        HKEY_LOCAL_MACHINE,
        RDPDRV
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    //
    //  query for wavemapper
    //
    status = regKey.ReadRegString(
        _T("wavemapper"),
        &szBuff,
        &size
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    status = regDestKey.WriteRegString(
        _T("wavemapper"),
        szBuff
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    if ( bIsProfessional )
    {
        status = regDestKey.WriteRegDWord(
            _T("EnableMP3Codec"),
            1
            );
        
        if ( ERROR_SUCCESS != status )
            goto exitpt;
    }
    
    //
    //  query for midimapper
    //
    status = regKey.ReadRegString(
        _T("midimapper"),
        &szBuff,
        &size
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    status = regDestKey.WriteRegString(
        _T("midimapper"),
        szBuff
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    
    rv = TRUE;
    
exitpt:
    
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\sysprep.cpp ===
#include "stdafx.h"
#include "hydraoc.h"
#include "subcomp.h"
#include "secupgrd.h"
#include "lscsp.h"
#include <SHlWapi.h>
#include "reglic.h"
#include "cryptkey.h"

#define MSLICENSING_REG_KEY             _T("SOFTWARE\\Microsoft\\MSLicensing")

typedef DWORD (*PSETENTRIESINACL)(
  ULONG cCountOfExplicitEntries,           // number of entries
  PEXPLICIT_ACCESS pListOfExplicitEntries, // buffer
  PACL OldAcl,                             // original ACL
  PACL *NewAcl                             // new ACL
);


BOOL
AddACLToObjectSecurityDescriptor(
                                HANDLE hObject,
                                SE_OBJECT_TYPE ObjectType                                
                                 )
{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID pAdminSid = NULL;
    PSID pSystemSid = NULL;
    PSID pPowerUsersSid = NULL;
    PSID pCreatorSid = NULL;
    PSID pUsersSid = NULL;
    PACL pNewDACL;

    DWORD                       dwError;
    BOOL                        bSuccess;

    DWORD                       i;

    PALLOCATEANDINITIALIZESID_FN pAllocateAndInitializeSid = NULL;
    PSETENTRIESINACL            pSetEntriesInAcl = NULL;
    HMODULE                     pAdvApi32 = NULL;
    PFREESID_FN                 pFreeSid = NULL;

    PSETSECURITYINFO_FN pSetSecurityInfo;

    pAdvApi32 = LoadLibrary(ADVAPI_32_DLL);
    if (!pAdvApi32) {
        return(FALSE);
    }

    pAllocateAndInitializeSid = (PALLOCATEANDINITIALIZESID_FN)
                                   GetProcAddress(pAdvApi32,
                                                  ALLOCATE_AND_INITITIALIZE_SID);
    if (pAllocateAndInitializeSid == NULL)
    {
        goto ErrorCleanup;
    }

#ifdef UNICODE
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclW" ));
#else
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclA" ));
#endif

    if (!pSetEntriesInAcl) {
        FreeLibrary( pAdvApi32 );
        return(FALSE);
    }

    EXPLICIT_ACCESS             ExplicitAccess[5];
    //
    // Create SIDs - Admins and System
    //

    bSuccess = pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pAdminSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     1,
                                                     SECURITY_LOCAL_SYSTEM_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pSystemSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_POWER_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pPowerUsersSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &CreatorAuthority,
                                                     1,
                                                     SECURITY_CREATOR_OWNER_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pCreatorSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid(&NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pUsersSid);

    if (bSuccess) {

        //
        // Initialize Access structures describing the ACEs we want:
        //  System Full Control
        //  Admins Full Control
        //
        // We'll take advantage of the fact that the unlocked private keys is
        // the same as the device parameters key and they are a superset of the
        // locked private keys.
        //
        // When we create the DACL for the private key we'll specify a subset of
        // the ExplicitAccess array.
        //
        for (i = 0; i < 5; i++) {
            ExplicitAccess[i].grfAccessMode = SET_ACCESS;
            ExplicitAccess[i].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;            
            ExplicitAccess[i].Trustee.pMultipleTrustee = NULL;
            ExplicitAccess[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            ExplicitAccess[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ExplicitAccess[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        }
        ExplicitAccess[0].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[0].Trustee.ptstrName = (LPTSTR)pAdminSid;

        ExplicitAccess[1].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[1].Trustee.ptstrName = (LPTSTR)pSystemSid;

        ExplicitAccess[2].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[2].Trustee.ptstrName = (LPTSTR)pCreatorSid;

        ExplicitAccess[3].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE;
        ExplicitAccess[3].Trustee.ptstrName = (LPTSTR)pPowerUsersSid;

        ExplicitAccess[4].grfAccessPermissions = GENERIC_READ;
        ExplicitAccess[4].Trustee.ptstrName = (LPTSTR)pUsersSid;

        dwError = (DWORD)pSetEntriesInAcl( 5,
                                           ExplicitAccess,
                                           NULL,
                                           &pNewDACL );        
        
        pSetSecurityInfo = (PSETSECURITYINFO_FN)GetProcAddress(pAdvApi32,SET_SECURITY_INFO);
        
        if (pSetSecurityInfo == NULL)
        {
            OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc SetSecurityInfo"));
            goto ErrorCleanup;
        }

        dwError = pSetSecurityInfo(
                    hObject,
                    ObjectType,
                    DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pNewDACL,
                    NULL
                    );
        
    }
ErrorCleanup:

    pFreeSid = (PFREESID_FN)
            GetProcAddress(pAdvApi32,
                           FREE_SID);

    if(pAdminSid)
        pFreeSid(pAdminSid);
    if(pSystemSid)
        pFreeSid(pSystemSid);
    if(pPowerUsersSid)
        pFreeSid(pPowerUsersSid);
    if(pCreatorSid)
        pFreeSid(pCreatorSid);
    if(pUsersSid)
        pFreeSid(pUsersSid);
    if(pNewDACL)
        LocalFree(pNewDACL);


    if(pAdvApi32)
        FreeLibrary( pAdvApi32 );

    return bSuccess;
}


BOOL
AddACLToStoreObjectSecurityDescriptor(
                                HANDLE hObject,
                                SE_OBJECT_TYPE ObjectType
                                 )
{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID pAdminSid = NULL;
    PSID pSystemSid = NULL;
    PSID pPowerUsersSid = NULL;
    PSID pCreatorSid = NULL;
    PSID pUsersSid = NULL;
    PACL pNewDACL;

    DWORD                       dwError;
    BOOL                        bSuccess;

    DWORD                       i;

    PALLOCATEANDINITIALIZESID_FN pAllocateAndInitializeSid = NULL;
    PSETENTRIESINACL            pSetEntriesInAcl = NULL;    
    HMODULE                     pAdvApi32 = NULL;
    PFREESID_FN                 pFreeSid = NULL;
    PSETSECURITYINFO_FN pSetSecurityInfo;
    EXPLICIT_ACCESS             ExplicitAccess[6];

    pAdvApi32 = LoadLibrary(ADVAPI_32_DLL);
    if (!pAdvApi32) {
        return(FALSE);
    }

    pAllocateAndInitializeSid = (PALLOCATEANDINITIALIZESID_FN)
                                   GetProcAddress(pAdvApi32,
                                                  ALLOCATE_AND_INITITIALIZE_SID);
    if (pAllocateAndInitializeSid == NULL)
    {
        goto ErrorCleanup;
    }

#ifdef UNICODE
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclW" ));
#else
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclA" ));
#endif

    if (!pSetEntriesInAcl) {
        FreeLibrary( pAdvApi32 );
        return(FALSE);
    }
    
    //
    // Create SIDs - Admins and System
    //

    bSuccess = pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pAdminSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     1,
                                                     SECURITY_LOCAL_SYSTEM_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pSystemSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_POWER_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pPowerUsersSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &CreatorAuthority,
                                                     1,
                                                     SECURITY_CREATOR_OWNER_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pCreatorSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid(&NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pUsersSid);

    if (bSuccess) {

        //
        // Initialize Access structures describing the ACEs we want:
        //  System Full Control
        //  Admins Full Control
        //
        // We'll take advantage of the fact that the unlocked private keys is
        // the same as the device parameters key and they are a superset of the
        // locked private keys.
        //
        // When we create the DACL for the private key we'll specify a subset of
        // the ExplicitAccess array.
        //
        for (i = 0; i < 6; i++) {
            ExplicitAccess[i].grfAccessMode = SET_ACCESS;              
            ExplicitAccess[i].Trustee.pMultipleTrustee = NULL;
            ExplicitAccess[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            ExplicitAccess[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ExplicitAccess[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        }
        ExplicitAccess[0].grfAccessPermissions = KEY_ALL_ACCESS; 
        ExplicitAccess[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[0].Trustee.ptstrName = (LPTSTR)pAdminSid;

        ExplicitAccess[1].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[1].Trustee.ptstrName = (LPTSTR)pSystemSid;

        ExplicitAccess[2].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[2].Trustee.ptstrName = (LPTSTR)pCreatorSid;

        ExplicitAccess[3].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE;
        ExplicitAccess[3].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[3].Trustee.ptstrName = (LPTSTR)pPowerUsersSid;

        ExplicitAccess[4].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE| KEY_CREATE_SUB_KEY |KEY_SET_VALUE;
        ExplicitAccess[4].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[4].Trustee.ptstrName = (LPTSTR)pUsersSid;

        ExplicitAccess[5].grfAccessPermissions = DELETE;
        ExplicitAccess[5].grfInheritance = INHERIT_ONLY_ACE | SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[5].Trustee.ptstrName = (LPTSTR)pUsersSid;

        dwError = (DWORD)pSetEntriesInAcl( 6,
                                           ExplicitAccess,
                                           NULL,
                                           &pNewDACL );
        
        pSetSecurityInfo = (PSETSECURITYINFO_FN)GetProcAddress(pAdvApi32,SET_SECURITY_INFO);
        
        if (pSetSecurityInfo == NULL)
        {
            OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc SetSecurityInfo"));
            goto ErrorCleanup;
        }

        dwError = pSetSecurityInfo(
                    hObject,
                    ObjectType,
                    DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pNewDACL,
                    NULL
                    );
        
    }
ErrorCleanup:

    pFreeSid = (PFREESID_FN)
            GetProcAddress(pAdvApi32,
                           FREE_SID);

    if(pAdminSid)
        pFreeSid(pAdminSid);
    if(pSystemSid)
        pFreeSid(pSystemSid);
    if(pPowerUsersSid)
        pFreeSid(pPowerUsersSid);
    if(pCreatorSid)
        pFreeSid(pCreatorSid);
    if(pUsersSid)
        pFreeSid(pUsersSid);
    if(pNewDACL)
        LocalFree(pNewDACL);


    if(pAdvApi32)
        FreeLibrary( pAdvApi32 );

    return bSuccess;
}


BOOL CreateRegAddAcl(VOID)
{
    BOOL fRet = FALSE;
    DWORD dwDisposition, dwError = NO_ERROR;
    HKEY hKey = NULL, hKeyStore = NULL;

    dwError = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    MSLICENSING_REG_KEY,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisposition
                    );

    if (dwError != ERROR_SUCCESS) {
        return FALSE;
    }

    fRet = AddACLToObjectSecurityDescriptor(
                hKey,
                SE_REGISTRY_KEY
                );

    if (!fRet) {
        goto cleanup;
    }

    dwError = RegCreateKeyEx(
                    hKey,
                    MSLICENSING_STORE_SUBKEY,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKeyStore,
                    &dwDisposition
                    );

    if (dwError != ERROR_SUCCESS) {
        fRet = FALSE;
        goto cleanup;
    }

    fRet = AddACLToStoreObjectSecurityDescriptor(
                hKeyStore,
                SE_REGISTRY_KEY
                );

cleanup:
    if (NULL != hKey)
    {
        RegCloseKey( hKey );
    }

    if (NULL != hKeyStore)
    {
        RegCloseKey( hKeyStore );
    }

    return fRet;
}

BOOL
CreateAndWriteHWID(VOID)
{    
    BOOL fRet = FALSE;
    DWORD dwDisposition, dwError = NO_ERROR;
    HKEY hKey = NULL;
    HWID hwid;

    // Write HWID to registry

    dwError = RegCreateKeyEx(
                             HKEY_LOCAL_MACHINE,
                             MSLICENSING_HWID_KEY,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKey,
                             &dwDisposition
                             );

    if (dwError != ERROR_SUCCESS) {
        goto cleanup;
    }

    // generate HWID

    if (LICENSE_STATUS_OK == GenerateClientHWID(&hwid))
    {

        dwError = RegSetValueEx(hKey,
                                MSLICENSING_HWID_VALUE,
                                0,
                                REG_BINARY,
                                (LPBYTE)&hwid,
                                sizeof(HWID));
        
        if (dwError != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    fRet = TRUE;
    

cleanup:
    if (NULL != hKey)
    {
        RegCloseKey( hKey );
    }

    return fRet;
}


BOOL SetupMSLicensingKey()
{
    OSVERSIONINFOA OsVer;
    memset(&OsVer, 0x0, sizeof(OSVERSIONINFOA));
    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    GetVersionExA(&OsVer);

    if (VER_PLATFORM_WIN32_NT == OsVer.dwPlatformId)  //It should be Windows NT
    {
        if(CreateRegAddAcl())
        {
            // generate and write the HWID
            if (CreateAndWriteHWID())
            {
                return TRUE;
            }          
        }
    }
    return FALSE;
}



LPCTSTR pszSysPrepBackupCmd[] = { _T("sessmgr.exe -unregserver") };
DWORD numSysPrepBackupCmd = sizeof(pszSysPrepBackupCmd) / sizeof(pszSysPrepBackupCmd[0]);

LPCTSTR pszSysPrepRestoreCmd[] = { _T("sessmgr.exe -service") };
DWORD numSysPrepRestoreCmd = sizeof(pszSysPrepRestoreCmd) / sizeof(pszSysPrepRestoreCmd[0]);

class CNameSIDList : public list<CNameSID>
{
public:
    BOOL Save(HKEY hKey);
    BOOL LoadAndDelete(HKEY hKey);
    BOOL Find(PSID pSid, LPCWSTR *pwszName);
    void AddIfNotExist(CNameSID &NameSID);
};

DWORD
BackupTSCustomSercurity();

DWORD
RestoreTSCustomSercurity();

DWORD 
GetLocalSIDs(
        IN PSECURITY_DESCRIPTOR pSD, 
        IN OUT CNameSIDList &NameSIDList);

DWORD 
RenewLocalSIDs(
        IN OUT PSECURITY_DESCRIPTOR &pSD, 
        IN OUT CNameSIDList &NameSIDList);

DWORD
ResetTSPublicPrivateKeys();

BOOL 
CNameSIDList::Save(HKEY hKey)
{
    BOOL bResult = FALSE;
    CNameSIDList::iterator it;
    //
    //calc the size of the buffer we need
    //
    DWORD dwBufSize = 0;
    LPCWSTR wszTmp1,wszTmp2;
    for(it=begin();it!=end(); it++)
    {
        wszTmp1 = (*it).GetName();
        wszTmp2 = (*it).GetTextSID();
        if(wszTmp1 && wszTmp2)
        {
            dwBufSize += (wcslen(wszTmp1)+wcslen(wszTmp2)+2)*sizeof(WCHAR); 
        }
    }
    //
    //for second terminating 0.
    //
    dwBufSize += sizeof(WCHAR);
    //
    //Allocate buffer (this will also zeroinit it).
    //
    LPWSTR wszBuf = (LPWSTR)LocalAlloc(LPTR,dwBufSize);
    DWORD dwPos = 0;
    if(wszBuf)
    {
        //
        //Fill buffer with data
        //
        for(it=begin();it!=end(); it++)
        {
            wszTmp1 = (*it).GetName();
            wszTmp2 = (*it).GetTextSID();
            if(wszTmp1 && wszTmp2)
            {
                wcscpy(wszBuf+dwPos,wszTmp1);
                dwPos += wcslen(wszTmp1)+1; 
                wcscpy(wszBuf+dwPos,wszTmp2);
                dwPos += wcslen(wszTmp2)+1; 
            }
        }
        //
        //Save data in the registry
        //
        if(dwPos && RegSetValueExW(hKey,L"BackupSids",0,REG_MULTI_SZ,
                (CONST BYTE *)wszBuf,dwBufSize)==ERROR_SUCCESS)
        {
            bResult = TRUE;
        }

        LocalFree(wszBuf);
    }
    

    return bResult;
}

BOOL 
CNameSIDList::LoadAndDelete(HKEY hKey)
{
    BOOL bResult = FALSE;
    DWORD err;
    DWORD ValueSize = 0;
    DWORD ValueType = 0;
    
    err = RegQueryValueExW( hKey, L"BackupSids", NULL, &ValueType, NULL, &ValueSize );

    if(err == ERROR_SUCCESS && ValueType == REG_MULTI_SZ && ValueSize)
    {

        LPWSTR wszBuf = (LPWSTR)LocalAlloc(LPTR,ValueSize);

        if ( wszBuf )
        {

            err = RegQueryValueExW( hKey, L"BackupSids", NULL, &ValueType,
                        (BYTE *) wszBuf, &ValueSize );
            
            RegDeleteValueW(hKey,L"BackupSids");

            if(err == ERROR_SUCCESS )
            {
                LPCWSTR wszTmp1,wszTmp2;
                DWORD dwPos = 0,dwMaxPos = ValueSize/sizeof(WCHAR);
                while(dwPos < dwMaxPos)
                {
                    wszTmp1 = wszBuf + dwPos;
                    dwPos += wcslen(wszTmp1) + 1;
                    wszTmp2 = wszBuf + dwPos;
                    dwPos += wcslen(wszTmp2) + 1;
                    
                    PSID pSid;
                    if(ConvertStringSidToSidW(wszTmp2,&pSid))
                    {
                        CNameSID NameSID(wszTmp1,pSid);
                        push_back(NameSID);
                        LocalFree(pSid);
                    }
                }
                
                bResult = TRUE;
            }
            
            LocalFree(wszBuf);
        }

    }

    return bResult;
}

BOOL 
CNameSIDList::Find(PSID pSid, LPCWSTR *pwszName)
{
    *pwszName = NULL;

    CNameSIDList::iterator it;
    
    for(it=begin();it!=end(); it++)
    {
        if(EqualSid(pSid,(*it).GetSID()))
        {
            *pwszName = (*it).GetName();
            return TRUE;
        }
    }
    
    return FALSE;
}

void 
CNameSIDList::AddIfNotExist(CNameSID &NameSID)
{
    LPCWSTR wszName;
    if(!Find(NameSID.GetSID(),&wszName))
    {
        push_back(NameSID);
    }
}

VOID
RunSysPrepCommands( LPCTSTR pszCmds )
{
    STARTUPINFO startupinfo;
    PROCESS_INFORMATION process_information;
    BOOL bSuccess;
    DWORD dwErr;
    TCHAR pszCommand[ MAX_PATH * 2 + 1];


    try {
        //
        // CreateProcessW() will fail if lpCommandLine is a const string 
        // AV if it is actually point to LPCTSTR.
        //
        lstrcpy( pszCommand, pszCmds );

        ZeroMemory( &startupinfo, sizeof(startupinfo) );
        startupinfo.cb = sizeof(startupinfo);
        startupinfo.dwFlags = STARTF_USESHOWWINDOW;
        startupinfo.wShowWindow = SW_HIDE | SW_SHOWMINNOACTIVE;

        LOGMESSAGE1(_T("Running command %s."), pszCmds);
	    	
        bSuccess = CreateProcess( NULL,
                               pszCommand,
                               NULL,
                               NULL,
                               FALSE,
                               CREATE_DEFAULT_ERROR_MODE,
                               NULL,
                               NULL,
                               &startupinfo,
                               &process_information );
        if ( !bSuccess )
        {
            LOGMESSAGE1(_T("ERROR: failed to spawn %s process."), pszCommand);
        }
        else
        {
            dwErr = WaitForSingleObject( process_information.hProcess, RUNONCE_DEFAULTWAIT );
            if ( dwErr != NO_ERROR )
            {
                LOGMESSAGE1(_T("ERROR: process %s failed to complete in time."), pszCommand);
            }
            else
            {
                LOGMESSAGE1(_T("INFO: process %s completed successfully."), pszCommand);
            }

            CloseHandle( process_information.hProcess );
            CloseHandle( process_information.hThread );
        }
    }
    catch(...) {
        LOGMESSAGE0(_T("Command caused exception.") );
    }

    return;
}


__declspec( dllexport )
VOID
SysPrepBackup( void )
{
    DWORD dwIndex;
    TCHAR szLogFile[MAX_PATH + 1];

    ZeroMemory(szLogFile, sizeof(szLogFile));

    ExpandEnvironmentStrings(LOGFILE, szLogFile, MAX_PATH);
    LOGMESSAGEINIT(szLogFile, MODULENAME);

    LOGMESSAGE0( _T("Entering SysPrepBackup") );

    for(dwIndex = 0; dwIndex < numSysPrepBackupCmd; dwIndex++ )
    {
        RunSysPrepCommands( pszSysPrepBackupCmd[dwIndex] );
    }
    
    DWORD err = BackupTSCustomSercurity();
    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: BackupTSCustomSercurity() FAILED: %d"),err );
    }

    LOGMESSAGE0( _T("SysPrepBackup completed") );
}

__declspec( dllexport )
VOID
SysPrepRestore( void )
{
    DWORD dwIndex;
    TCHAR szLogFile[MAX_PATH + 1];
    
    ZeroMemory( szLogFile, sizeof(szLogFile) );

    ExpandEnvironmentStrings(LOGFILE, szLogFile, MAX_PATH);

    LOGMESSAGEINIT(szLogFile, MODULENAME);

    LOGMESSAGE0( _T("Entering SysPrepRestore") );

    for(dwIndex = 0; dwIndex < numSysPrepRestoreCmd; dwIndex++ )
    {
        RunSysPrepCommands( pszSysPrepRestoreCmd[dwIndex] );
    }
    
    DWORD err = RestoreTSCustomSercurity();
    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: RestoreTSCustomSercurity() FAILED: %d"),err );
    }

    err = ResetTSPublicPrivateKeys();
    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: ResetTSPublicPrivateKeys() FAILED: %d"),err );
    }
	//
    // This can be done at SysPrep time instead of SysRestore time; however, sysprep
    // might support back out sysprep so we delay deleting licensing key at restore time,
    // also, to keep it consistent with ResetTSPublicPrivateKey().
    //
    err = SHDeleteKey( HKEY_LOCAL_MACHINE, MSLICENSING_REG_KEY );

    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: Deleting MSLicensing key FAILED: %d"),err );
    }
    
    err = SetupMSLicensingKey();

    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: SetupMSLicensingKey() FAILED: %d"),err );
    }
    LOGMESSAGE0( _T("SysPrepRestore completed") );
}

//*************************************************************
//
//  BackupTSCustomSercurity()
//
//  Purpose:    Creates a list of all local SIDs and 
//              corresponding names included in WinStation's 
//              security descriptors, and saves it 
//              in the registry.
//
//  Parameters: NONE
//
//  Return:     error code if fails, ERROR_SUCCESS otherwise   
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************
DWORD
BackupTSCustomSercurity()
{
    HKEY hKey;
    DWORD err;
    //
    //Open "SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations" key
    //
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations"), 
        0,KEY_READ|KEY_WRITE, &hKey );
    
    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: BackupTSCustomSercurity - RegOpenKeyEx FAILED: %d"),err );
        return err;
    }
    
    
    CNameAndSDList NameSDList; //List of security descriptors
    CNameSIDList NameSIDList;  //List of local SIDs

    err=EnumWinStationSecurityDescriptors( hKey, &NameSDList);

    if(err == ERROR_SUCCESS)
    {
        CNameAndSDList::iterator it;
            
        for(it=NameSDList.begin();it!=NameSDList.end(); it++)
        {
            //
            //If SD was not customized in most cases it is NULL
            //
            if((*it).m_pSD)
            {
                err = GetLocalSIDs((*it).m_pSD, NameSIDList);

                if(err != ERROR_SUCCESS)
                {
                    LOGMESSAGE2(_T("ERROR: GetLocalSIDs for  %s FAILED: %d"), (*it).m_pName, err );
                    break;
                }
            }
        }
        
        if(err == ERROR_SUCCESS)
        {
            if(!NameSIDList.Save(hKey))
            {
                LOGMESSAGE0(_T("ERROR: BackupTSCustomSercurity - NameSIDList.Save FAILED"));
                err = ERROR_FILE_NOT_FOUND;
            }
        }
    }
    else
    {
        LOGMESSAGE1(_T("ERROR: RestoreTSCustomSercurity - ")
            _T("EnumWinStationSecurityDescriptors FAILED: %d"),err );
    }
    
    RegCloseKey(hKey);

    return err;
}

//*************************************************************
//
//  RestoreTSCustomSercurity()
//
//  Purpose:    Gets a list of local SIDs and corresponding names 
//              (saved by BackupTSCustomSercurity)
//              from the registry and updates all WinStation's 
//              security descriptors with new SID for each  
//              local account.
//
//  Parameters: NONE
//
//  Return:     error code if fails, ERROR_SUCCESS otherwise
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************
DWORD
RestoreTSCustomSercurity()
{
    HKEY hKey;
    DWORD err;
    //
    //Open "SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations" key
    //
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations"), 
        0,KEY_READ|KEY_WRITE, &hKey );
    
    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: RestoreTSCustomSercurity - RegOpenKeyEx FAILED: %d"),err );
        return err;
    }
    
    
    CNameAndSDList NameSDList; //List of security descriptors
    CNameSIDList NameSIDList;  //List of local SIDs
    
    //Now load
    if(!NameSIDList.LoadAndDelete(hKey))
    {
        LOGMESSAGE0(_T("ERROR: RestoreTSCustomSercurity - NameSIDList.LoadAndDelete FAILED"));
        RegCloseKey(hKey);
        return ERROR_FILE_NOT_FOUND;
    }

    err=EnumWinStationSecurityDescriptors( hKey, &NameSDList);
    
    if(err == ERROR_SUCCESS)
    {
        CNameAndSDList::iterator it;
            
        for(it=NameSDList.begin();it!=NameSDList.end(); it++)
        {
            //
            //If SD was not customized in most cases it is NULL
            //
            if((*it).m_pSD)
            {
                err = RenewLocalSIDs((*it).m_pSD, NameSIDList);

                if(err == ERROR_SUCCESS)
                {
                    err = SetWinStationSecurity( hKey, (*it).m_pName, (*it).m_pSD );

                    if(err !=ERROR_SUCCESS)
                    {
                        LOGMESSAGE2(_T("ERROR: SetWinStationSecurity for  %s FAILED: %d"),
                            (*it).m_pName, err );
                        break;
                    }
                }
                else
                {
                    LOGMESSAGE2(_T("ERROR: RenewLocalSIDs for  %s FAILED: %d"), 
                        (*it).m_pName, err );
                    break;
                }
            }
        }
        
    }
    else
    {
        LOGMESSAGE1(_T("ERROR: RestoreTSCustomSercurity - ")
            _T("EnumWinStationSecurityDescriptors FAILED: %d"),err );
    }
    
    RegCloseKey(hKey);

    return err;
}

//*************************************************************
//
//  GetLocalSIDs()
//
//  Purpose:    Gets local SIDs from a security descriptor 
//              and puts them in the list
//
//  Parameters: 
//              IN PSECURITY_DESCRIPTOR pSD, 
//              IN OUT CNameSIDList &NameSIDList
//
//  Return:     error code if fails, ERROR_SUCCESS otherwise
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************
DWORD 
GetLocalSIDs(
        IN PSECURITY_DESCRIPTOR pSD, 
        IN OUT CNameSIDList &NameSIDList)
{
    PACL pDacl;
    PACL pSacl;
    DWORD dwResult;
    
    DWORD cEntries = 0;
    
    dwResult = GetDacl(pSD,&pDacl);

    if(dwResult != ERROR_SUCCESS)
    {
        return dwResult;
    }
    
    dwResult = GetSacl(pSD,&pSacl);

    if(dwResult != ERROR_SUCCESS)
    {
        return dwResult;
    }
    
    DWORD dwCompNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    
    if(!GetComputerNameW(wszComputerName, &dwCompNameSize))
    {
        return GetLastError();
    }


    ACL_SIZE_INFORMATION asiAclSize; 
    DWORD dwBufLength=sizeof(asiAclSize);
    ACCESS_ALLOWED_ACE *pAllowedAce; 
    SYSTEM_AUDIT_ACE *pSystemAce;
    DWORD dwAcl_i;
    LPWSTR wszName;
    SID_NAME_USE eUse;

    if(pDacl)
    {
        if (GetAclInformation(pDacl, 
                (LPVOID)&asiAclSize, 
                (DWORD)dwBufLength, 
                (ACL_INFORMATION_CLASS)AclSizeInformation)) 
        { 
            for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount; dwAcl_i++) 
            { 
                
                if(GetAce( pDacl, dwAcl_i, (LPVOID *)&pAllowedAce)) 
                {
                    if(LookupSid((PSID)&(pAllowedAce->SidStart),&wszName,&eUse))
                    {
                        if(IsLocal(wszComputerName, wszName))
                        {
                            NameSIDList.AddIfNotExist(CNameSID(wszName,
                                (PSID)&(pAllowedAce->SidStart)));
                        }

                        LocalFree(wszName);
                    }
                        
                }
            }
        }
    }
    
    if(pSacl)
    {
        if (GetAclInformation(pSacl, 
                (LPVOID)&asiAclSize, 
                (DWORD)dwBufLength, 
                (ACL_INFORMATION_CLASS)AclSizeInformation)) 
        { 
            for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount; dwAcl_i++) 
            { 
                
                if(GetAce( pSacl, dwAcl_i, (LPVOID *)&pSystemAce)) 
                {
                    if(LookupSid((PSID)&(pSystemAce->SidStart),&wszName,&eUse))
                    {
                        if(IsLocal(wszComputerName, wszName))
                        {
                            NameSIDList.AddIfNotExist(CNameSID(wszName,
                                (PSID)&(pSystemAce->SidStart)));
                        }

                        LocalFree(wszName);
                    }
                        
                }
            }
        }
    }

    return ERROR_SUCCESS;
}


//*************************************************************
//
//  RenewLocalSIDs()
//
//  Purpose:    Replaces all the local SIDs in a security 
//              descriptor with the new ones.
//
//  Parameters: 
//              IN OUT PSECURITY_DESCRIPTOR &pSD, 
//              IN OUT CNameSIDList &NameSIDList
//
//  Return:     error code if fails, ERROR_SUCCESS otherwise
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************

DWORD 
RenewLocalSIDs(
        IN OUT PSECURITY_DESCRIPTOR &pSD, 
        IN OUT CNameSIDList &NameSIDList)
{
    PSECURITY_DESCRIPTOR pAbsoluteSD = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    PSID pOwner = NULL;
    PSID pPrimaryGroup = NULL;
    DWORD dwResult;
    
    dwResult = GetAbsoluteSD(
                    pSD,
                    &pAbsoluteSD,
                    &pDacl,
                    &pSacl,
                    &pOwner,
                    &pPrimaryGroup);

    if(dwResult != ERROR_SUCCESS)
    {
        return dwResult;
    }

    ULONG cEntries;
    PEXPLICIT_ACCESS_W pListOfEntries;
    LPCWSTR wszName;
    PACL pNewDacl = NULL, pNewSacl = NULL;

    __try
    {
        if(pDacl)
        {
            dwResult = GetExplicitEntriesFromAclW(pDacl, &cEntries, &pListOfEntries);

            if(dwResult != ERROR_SUCCESS)
            {
                return dwResult;
            }

            for(ULONG i=0;i<cEntries;i++)
            {
                if(pListOfEntries[i].Trustee.TrusteeForm == TRUSTEE_IS_SID &&
                    NameSIDList.Find((PSID)pListOfEntries[i].Trustee.ptstrName, &wszName))
                {
                    pListOfEntries[i].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
                    pListOfEntries[i].Trustee.ptstrName = const_cast<LPWSTR>(wszName);
                }
            }

            dwResult = SetEntriesInAclW(cEntries,pListOfEntries,NULL,&pNewDacl);
            
            LocalFree(pListOfEntries);

            if(dwResult != ERROR_SUCCESS)
            {
                return dwResult;
            }

            if(!SetSecurityDescriptorDacl(pAbsoluteSD,TRUE,pNewDacl,FALSE))
            {
                return GetLastError();
            }
        }
    
        if(pSacl)
        {
            dwResult = GetExplicitEntriesFromAclW(pSacl, &cEntries, &pListOfEntries);

            if(dwResult != ERROR_SUCCESS)
            {
                return dwResult;
            }

            for(ULONG i=0;i<cEntries;i++)
            {
                if(pListOfEntries[i].Trustee.TrusteeForm == TRUSTEE_IS_SID &&
                    NameSIDList.Find((PSID)pListOfEntries[i].Trustee.ptstrName, &wszName))
                {
                    pListOfEntries[i].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
                    pListOfEntries[i].Trustee.ptstrName = const_cast<LPWSTR>(wszName);
                }
            }

            dwResult = SetEntriesInAclW(cEntries,pListOfEntries,NULL,&pNewSacl);
            
            LocalFree(pListOfEntries);

            if(dwResult != ERROR_SUCCESS)
            {
                return dwResult;
            }

            if(!SetSecurityDescriptorSacl(pAbsoluteSD,TRUE,pNewSacl,FALSE))
            {
                return GetLastError();
            }
        }
        
        PSECURITY_DESCRIPTOR pTmpSD;

        dwResult = GetSelfRelativeSD(pAbsoluteSD,&pTmpSD);

        if(dwResult != ERROR_SUCCESS)
        {
            return dwResult;
        }

        LocalFree(pSD);
        pSD = pTmpSD;

    }
    __finally
    {
        if(pAbsoluteSD)
        {
            LocalFree(pAbsoluteSD);
        }
        if(pDacl)
        {
            LocalFree(pDacl);
        }
        if(pSacl)
        {
            LocalFree(pSacl);
        }
        if(pOwner)
        {
            LocalFree(pOwner);
        }
        if(pPrimaryGroup)
        {
            LocalFree(pPrimaryGroup);
        }
        if(pNewDacl)
        {
            LocalFree(pNewDacl);
        }
        if(pNewSacl)
        {
            LocalFree(pNewSacl);
        }

    }

    return ERROR_SUCCESS;
}


//*************************************************************
//
//  ResetTSPublicPrivateKeys()
//
//  Purpose:    Deletes keys from LSA secret, so that sysprep'd
//              machines don't share the same keys
//
//  Parameters: NONE
//
//  Return:     error code if fails, ERROR_SUCCESS otherwise   
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              06/12/01    robleit    Created
//
//*************************************************************
DWORD
ResetTSPublicPrivateKeys()
{
    LSA_HANDLE
        PolicyHandle;
    UNICODE_STRING
        SecretKeyName;
    DWORD
        Status;

    LOGMESSAGE0(_T("INFO: Starting ResetTSPublicPrivateKeys.") );

    Status = OpenPolicy( NULL, POLICY_CREATE_SECRET, &PolicyHandle );

    if( ERROR_SUCCESS != Status )
    {
        return LsaNtStatusToWinError(Status);
    }

    SecretKeyName.Buffer = PRIVATE_KEY_NAME;
    SecretKeyName.Length = sizeof(PRIVATE_KEY_NAME) - sizeof(WCHAR);
    SecretKeyName.MaximumLength = sizeof(PRIVATE_KEY_NAME) ;

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                NULL
                );

    if (Status != STATUS_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: ResetTSPublicPrivateKeys() FAILED to delete private key: %d"),Status );
    }

    SecretKeyName.Buffer = X509_CERT_PRIVATE_KEY_NAME;
    SecretKeyName.Length = sizeof(X509_CERT_PRIVATE_KEY_NAME) - sizeof(WCHAR);
    SecretKeyName.MaximumLength = sizeof(X509_CERT_PRIVATE_KEY_NAME);

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                NULL
                );

    if (Status != STATUS_SUCCESS)
    {
        LOGMESSAGE1(_T("WARNING: ResetTSPublicPrivateKeys() FAILED to delete X509 private key: %d"),Status );
    }

    SecretKeyName.Buffer = X509_CERT_PUBLIC_KEY_NAME;
    SecretKeyName.Length = sizeof(X509_CERT_PUBLIC_KEY_NAME) - sizeof(WCHAR);
    SecretKeyName.MaximumLength = sizeof(X509_CERT_PUBLIC_KEY_NAME);

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                NULL
                );

    if (Status != STATUS_SUCCESS)
    {
        LOGMESSAGE1(_T("WARNING: ResetTSPublicPrivateKeys() FAILED to delete X509 public key: %d"),Status );
    }

    LsaClose( PolicyHandle );

    Status = LsaNtStatusToWinError( Status );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inc\conv.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    conv.h

Abstract:

    UNICODE / ASCII conversion macros

Author:

    Hakki T. Bostanci (hakkib) 5-Aug-1998

Revision History:

--*/

#ifndef USES_CONVERSION

// USES_CONVERSION must be defined in every function that uses the
// conversion macros

#define USES_CONVERSION int __nLength; PCWSTR __pUnicode; PCSTR __pAscii

//////////////////////////////////////////////////////////////////////////
//
// W2A
//
// Routine Description:
//   Converts a UNICODE string to ASCII. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          UNICODE string
//
// Return Value:
//   the converted ASCII string
//

#define W2A(pStr)								                \
												                \
	((__pUnicode = pStr) == 0 ? (PSTR) 0 : (	                \
												                \
	__nLength = WideCharToMultiByte(				            \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		0,										                \
		0,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pAscii = (PCSTR) _alloca(__nLength * sizeof(CHAR)),       \
												                \
	WideCharToMultiByte(						                \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		(PSTR) __pAscii,						                \
		__nLength,								                \
		0,										                \
		0										                \
	),											                \
												                \
	(PSTR) __pAscii))							                \


//////////////////////////////////////////////////////////////////////////
//
// A2W
//
// Routine Description:
//   Converts an ASCII string to UNICODE. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          ASCII string
//
// Return Value:
//   the converted UNICODE string
//

#define A2W(pStr)								                \
												                \
	((__pAscii = pStr) == 0 ? (PWSTR) 0 : (					    \
												                \
	__nLength = MultiByteToWideChar(				            \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pUnicode = (PCWSTR) _alloca(__nLength * sizeof(WCHAR)),	\
												                \
	MultiByteToWideChar(						                \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		(PWSTR) __pUnicode,							            \
		__nLength									            \
	),											                \
												                \
	(PWSTR) __pUnicode))							            \

//////////////////////////////////////////////////////////////////////////
//
// T2A, A2T, T2W, W2T
//
// Routine Description:
//   These macros expand to the corresponding correct form according to the
//   #definition of UNICODE. 
//
//   We use the cryptic form (__nLength, __pAscii, __pUnicode, pStr) to avoid 
//   the compiler warning "symbol defined but not used" due to the variables 
//   defined in USES_CONVERSION macro.
//

#ifdef UNICODE
	#define T2A(pStr) W2A(pStr)
	#define A2T(pStr) A2W(pStr)
	#define T2W(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define W2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2DA(pStr) W2A(pStr)
	#define A2DT(pStr) A2W(pStr)
	#define T2DW(pStr) _wcsdupa(pStr)
	#define W2DT(pStr) _wcsdupa(pStr)
#else //UNICODE
	#define T2A(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define A2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2W(pStr) A2W(pStr)
	#define W2T(pStr) W2A(pStr)
	#define T2DA(pStr) _strdupa(pStr)
	#define A2DT(pStr) _strdupa(pStr)
	#define T2DW(pStr) A2W(pStr)
	#define W2DT(pStr) W2A(pStr)
#endif //UNICODE


//////////////////////////////////////////////////////////////////////////
//
// _tcsdupa
//
// Routine Description:
//   Duplicates a string to a buffer allocated off the stack using _alloca
//
// Arguments:
//	 pStr          input string
//
// Return Value:
//   duplicated string
//

#define _wcsdupa(pStr)                                                  \
                                                                        \
    (__pAscii, (__pUnicode = pStr) == 0 ? (PWSTR) 0 : (                 \
                                                                        \
    __nLength = wcslen(__pUnicode) + 1,                                 \
                                                                        \
    wcscpy((PWSTR) _alloca(__nLength * sizeof(WCHAR)), __pUnicode)))    \


#define _strdupa(pStr)                                                  \
                                                                        \
    (__pUnicode, (__pAscii = pStr) == 0 ? (PSTR) 0 : (                  \
                                                                        \
    __nLength = strlen(__pAscii) + 1,                                   \
                                                                        \
    strcpy((PSTR) _alloca(__nLength * sizeof(CHAR)), __pAscii)))        \


#ifdef UNICODE 
#define _tcsdupa _wcsdupa
#else
#define _tcsdupa _strdupa
#endif


#endif //USES_CONVERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\subtoggle.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

//
// SubToggle.cpp
// subcomponent enable terminal server implementation.
//

#include "stdafx.h"
#include "SubToggle.h"
#include "hydraoc.h"
#include "pages.h"
#include "secupgrd.h"

#include "gpedit.h"

// {0F6B957D-509E-11d1-A7CC-0000F87571E3}
DEFINE_GUID(CLSID_PolicySnapInMachine,0xf6b957d, 0x509e, 0x11d1, 0xa7, 0xcc, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);



// #define REGISTRY_EXTENSION_GUID  { 0x35378EAC, 0x683F, 0x11D2, 0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2 }
DEFINE_GUID(CLSID_RegistryEntensionGuid, 0x35378EAC, 0x683F, 0x11D2, 0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2);


GUID guidRegistryEntension = REGISTRY_EXTENSION_GUID;
GUID guidPolicyMachineSnapin = CLSID_PolicySnapInMachine;




//
//  Globals
//
extern DefSecPageData *gpSecPageData;



DWORD SubCompToggle::GetStepCount () const
{
    return 4;
}

DWORD SubCompToggle::OnQueryState ( UINT uiWhichState ) const
{
    DWORD dwReturn = SubcompUseOcManagerDefault;
    
    switch(uiWhichState)
    {
    case OCSELSTATETYPE_FINAL:
        dwReturn = StateObject.IsItAppServer() ? SubcompOn : SubcompOff;
        break;
        
    case OCSELSTATETYPE_ORIGINAL:
        //
        // thought originally the comp was on, we want to unselect it for server sku.
        //
        if (StateObject.CanInstallAppServer())
        {
            dwReturn = StateObject.WasItAppServer() ? SubcompOn : SubcompOff;
        }
        else
        {
            if (StateObject.WasItAppServer())
            {
                LogErrorToSetupLog(OcErrLevWarning, IDS_STRING_TERMINAL_SERVER_UNINSTALLED);
            }
            dwReturn = SubcompOff;
        }
        break;
        
    case OCSELSTATETYPE_CURRENT:
        //
        // our state object knows best about the current state for unattended and fresh install cases.
        //
        if (StateObject.IsTSFreshInstall() || StateObject.IsUnattended())
        {
            if (StateObject.CurrentTSMode() == eAppServer)
            {
                dwReturn = SubcompOn;
            }
            else
            {
                dwReturn =  SubcompOff;
            }
        }
        else
        {
            dwReturn = SubcompUseOcManagerDefault;
        }
        break;
        
    default:
        AssertFalse();
        break;
    }
    
    return dwReturn;
    
}

DWORD SubCompToggle::OnQuerySelStateChange (BOOL bNewState, BOOL bDirectSelection) const
{
    if (bNewState)
    {
        //
        // this component is available only for adv server or highter. so dont let it be selected for 
        // any other sku. 
        //
        return StateObject.CanInstallAppServer();
    }
    
    return TRUE;
}

LPCTSTR SubCompToggle::GetSectionToBeProcessed (ESections eSection) const
{
    //
    //  If the state hasn't changed in stand alone setup, don't do anything.
    //  Note that an permission settings will be handled later.
    //
    
    if ((StateObject.CurrentTSMode() == StateObject.OriginalTSMode()) && 
        StateObject.IsStandAlone()) 
    {
        return(NULL);
    }
    
    //
    //  There are no files to install.
    //
    if ((eSection == kFileSection) || (eSection == kDiskSpaceAddSection))
    {
        return(NULL);
    }


    ETSMode eMode = StateObject.CurrentTSMode();
    if (StateObject.IsX86())
    {
        switch (eMode)
        {
        case eRemoteAdmin:
                return StateObject.IsWorkstation() ? REMOTE_ADMIN_PRO_X86 : REMOTE_ADMIN_SERVER_X86;
                break;
        case eAppServer:
                return StateObject.IsWorkstation() ? APPSERVER_PRO_X86 : APPSERVER_SERVER_X86;
                break;
        case ePersonalTS:
                return StateObject.IsWorkstation() ? PERSONALTS_PRO_X86 : PERSONALTS_SERVER_X86;
                break;
        case eTSDisabled:
        default:
                ASSERT(FALSE);
                return NULL;
        }
    }
    else
    {
        switch (eMode)
        {
        case eRemoteAdmin:
                return StateObject.IsWorkstation() ? REMOTE_ADMIN_PRO_IA64 : REMOTE_ADMIN_SERVER_IA64;
                break;
        case eAppServer:
                return StateObject.IsWorkstation() ? APPSERVER_PRO_IA64 : APPSERVER_SERVER_IA64;
                break;
        case ePersonalTS:
                return StateObject.IsWorkstation() ? PERSONALTS_PRO_IA64 : PERSONALTS_SERVER_IA64;
                break;
        case eTSDisabled:
        default:
                ASSERT(FALSE);
                return NULL;
        }
    }

}

BOOL SubCompToggle::BeforeCompleteInstall  ()
{
    if (StateObject.IsItAppServer() != StateObject.WasItAppServer())
    {
        SetProgressText(StateObject.IsItAppServer() ? IDS_STRING_PROGRESS_ENABLING : IDS_STRING_PROGRESS_DISABLING);
    }
    
    return TRUE;
}


LPCTSTR SubCompToggle::GetSubCompID () const
{
    return (APPSRV_COMPONENT_NAME);
}

BOOL SubCompToggle::AfterCompleteInstall ()
{
    
    LOGMESSAGE0(_T("Entering AfterCompleteInstall"));
    ASSERT(StateObject.Assert());
    StateObject.LogState();
    
    WriteLicensingMode();
    Tick();

    SetPermissionsMode ();
    Tick();
    
    //
    // this need to be done even if there is no state change, as we want to do this on upgrades as well.
    //
    if (StateObject.IsStandAlone() && !StateObject.IsAppSrvModeSwitch())
    {
        //
        // nothing has changed. dont bother to do any of the next steps.
        //
        return TRUE;
    }

    // UpdateMMDefaults();
    
    ResetWinstationSecurity ();
    Tick();
    
    ModifyWallPaperPolicy();
    Tick();
    
    ModifyAppPriority();
    
    
    // this really belongs in subcore, but since we want to it after ResetWinstationSecurity is called we are calling it here.
    //
    // we have modified winstation security mechanism for whistler.
    // Call this routine, which takes care of upgrades as well as clean installs.
    //
    LOGMESSAGE0(_T("Will Call SetupWorker now."));
    DWORD dwError = SetupWorker(StateObject);
    LOGMESSAGE0(_T("Done with SetupWorker."));
    
    if (dwError != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR :SetupWorker failed. ErrorCode = %d"), dwError);
    }
    
    if( StateObject.IsGuiModeSetup() )
    {
        // WARNING : this must be done after SetupWorker()
        SetupRunOnce( GetComponentInfHandle(), RUNONCE_SECTION_KEYWORD );
    }
    
    //
    //  We need a reboot if we toggled TS through AR/P.
    //
    
    if ( StateObject.IsStandAlone() && StateObject.IsAppSrvModeSwitch())
    {
        SetReboot();

        //
        // If we're changing into or out of app-compatibility mode, inform
        // the licensing system, because we're about to reboot
        //
        InformLicensingOfModeChange();
        Tick();
    }
    
    ASSERT(StateObject.Assert());
    StateObject.LogState();

    return(TRUE);
}

BOOL SubCompToggle::WriteLicensingMode ()
{
	//
	// we need to write this value only if it's set in answer file
	//
    if (StateObject.IsItAppServer() && (StateObject.NewLicMode() != eLicUnset))
    {
        DWORD dwError;
        CRegistry oRegTermsrv;
	
        dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
        if (ERROR_SUCCESS == dwError)
        {
            DWORD dwMode = StateObject.NewLicMode();

            TCHAR *tszValueName = StateObject.IsItAppServer() ? REG_LICENSING_MODE_AC_ON : REG_LICENSING_MODE_AC_OFF;

            LOGMESSAGE2(_T("Writing %s = %d"), tszValueName, dwMode);
            
            dwError = oRegTermsrv.WriteRegDWord(tszValueName, dwMode);

            if (ERROR_SUCCESS == dwError)
            {
                return TRUE;
            }
            else
            {
                LOGMESSAGE2(_T("Error (%d), Writing, %s Value"), dwError, tszValueName);
                return FALSE;
            }
        }
        else
        {
            LOGMESSAGE2(_T("Error (%d), Opening , %s key"), dwError, REG_CONTROL_TS_LICENSING_KEY);
            return FALSE;
        }
	}
    else
    {
        return TRUE;
    }
}


BOOL SubCompToggle::ApplySection (LPCTSTR szSection)
{
    
    DWORD dwError;
    
    LOGMESSAGE1(_T("Setting up Registry from section =  %s"), szSection);
    dwError = SetupInstallFromInfSection(
        NULL,                                // hwndOwner
        GetComponentInfHandle(),             // inf handle
        szSection,                          //
        SPINST_REGISTRY,                     // operation flags
        NULL,                                // relative key root
        NULL,                                // source root path
        0,                                   // copy flags
        NULL,                                // callback routine
        NULL,                                // callback routine context
        NULL,                                // device info set
        NULL                                 // device info struct
        );
    
    if (dwError == 0)
    {
        LOGMESSAGE1(_T("ERROR:while installating section <%lu>"), GetLastError());
    }
    
    return (dwError != 0);
}


BOOL SubCompToggle::ResetWinstationSecurity ()
{
    //
    //  If the TS mode is changing, reset winstation securities.
    //
    
    DWORD dwError;
    if (StateObject.IsAppSrvModeSwitch() && gpSecPageData->GetWinStationCount() > 0)
    {
        CRegistry pReg;
        CRegistry pSubKey;
        LPTSTR* pWinStationArray = gpSecPageData->GetWinStationArray();
        UINT cArray = gpSecPageData->GetWinStationCount();
        
        LOGMESSAGE1(_T("%d WinStations to reset."), cArray);
        
        //
        //  Open the WinStations key. At this point, this key must exist.
        //
        
        VERIFY(pReg.OpenKey(HKEY_LOCAL_MACHINE, REG_WINSTATION_KEY) == ERROR_SUCCESS);
        
        if (cArray != 0)
        {
            ASSERT(pWinStationArray != NULL);
            
            for (UINT i = 0; i < cArray; i++)
            {
                LOGMESSAGE1(_T("Resetting %s."), pWinStationArray[i]);
                
                dwError = pSubKey.OpenKey(pReg, pWinStationArray[i]);
                if (dwError == ERROR_SUCCESS)
                {
                    LOGMESSAGE2(_T("Delete registry value %s\\%s"), pWinStationArray[i], REG_SECURITY_VALUE);
                    
                    dwError = pSubKey.DeleteValue(REG_SECURITY_VALUE);
                    if (dwError == ERROR_SUCCESS)
                    {
                        LOGMESSAGE0(_T("Registry value deleted."));
                    }
                    else
                    {
                        LOGMESSAGE1(_T("Error deleting value: %ld"), dwError);
                    }
                }
                else
                {
                    LOGMESSAGE2(_T("Couldn't open key %s: %ld"), pWinStationArray[i], dwError);
                }
            }
        }
    }
    
    return TRUE;
    
}

BOOL SubCompToggle::InformLicensingOfModeChange ()
{
    BOOL fRet;

    ASSERT(StateObject.IsTSModeChanging());

    //
    // RPC into licensing to tell it we're going to reboot
    //

    HANDLE hServer = ServerLicensingOpen(NULL);

    if (NULL == hServer)
    {
        LOGMESSAGE1(_T("ERROR: InformLicensingOfModeChange calling ServerLicensingOpen <%lu>"), GetLastError());

        return FALSE;
    }

    fRet = ServerLicensingDeactivateCurrentPolicy(
                                                  hServer
                                                  );
    if (!fRet)
    {
        LOGMESSAGE1(_T("ERROR: InformLicensingOfModeChange calling ServerLicensingDeactivateCurrentPolicy <%lu>"), GetLastError());
    }

    ServerLicensingClose(hServer);


    return fRet;
}

BOOL SubCompToggle::SetPermissionsMode ()
{
    //
    //  If TS is toggling on, set the security key based on the choices
    //  made through the wizard page. This must be done even if TS was
    //  already enabled, as the permissions mode can be changed by the
    //  unattended file.
    //
    
    CRegistry reg;
    EPermMode ePermMode = StateObject.CurrentPermMode();
    
    VERIFY(reg.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY) == ERROR_SUCCESS);
    // BUGBUG should be
    // return (ERROR_SUCCESS == reg.WriteRegDWord( _T("TSUserEnabled"), StateObject.IsItAppServer() ? (DWORD)ePermMode : (DWORD)PERM_WIN2K));
    return (ERROR_SUCCESS == reg.WriteRegDWord( _T("TSUserEnabled"), StateObject.IsTSEnableSelected() ? (DWORD)ePermMode : (DWORD)PERM_TS4));
    
}


BOOL RegisterDll(LPCTSTR szDll)
{
    USES_CONVERSION;
    HMODULE hMod = LoadLibrary(szDll);
    HRESULT hResult = E_FAIL;
    
    if (hMod)
    {
        FARPROC pfRegSrv = GetProcAddress(hMod, "DllRegisterServer");
        if (pfRegSrv)
        {
            __try
            {
                hResult = (HRESULT)pfRegSrv();
                if (hResult != S_OK)
                {
                    LOGMESSAGE2(_T("ERROR, DllRegister Server in %s failed, hResult = %x"), szDll, hResult);
                }
            }
            __except( 1 )
            {
                hResult = E_FAIL;
                LOGMESSAGE2(_T("ERROR, Exception hit Registrering  of %s failed, Exception = %x"), szDll, GetExceptionCode());
            }
            
        }
        else
        {
            LOGMESSAGE1(_T("ERROR, Failed to Get proc for DllregisterServer for %s"), szDll);
        }
        
        FreeLibrary(hMod);
    }
    else
    {
        LOGMESSAGE2(_T("ERROR, Failed to Load library %s, lastError = %d"), szDll, GetLastError());
    }
    
    return hResult == S_OK;
}


BOOL SubCompToggle::ModifyWallPaperPolicy ()
{
    USES_CONVERSION;
    BOOL bRet = FALSE;
    
    //
    // policy must be applied when we change modes.
    // also for fresh installs/upgrades of app server.
    //
    if (StateObject.IsAppSrvModeSwitch() || (StateObject.IsGuiModeSetup() && StateObject.IsItAppServer()))
    {
        LOGMESSAGE0(_T("Will apply/change policies now..."));
        if (StateObject.IsGuiModeSetup())
        {
            //
            // in case of Gui mode setup
            // the group policy object may not be registered yet.
            // so lets register it ourselves.
            //
            
            TCHAR szGPEditFile[MAX_PATH];
            GetSystemDirectory(szGPEditFile, MAX_PATH);
            _tcscat(szGPEditFile, _T("\\gpedit.dll"));
            if (!RegisterDll(szGPEditFile))
            {
                LOGMESSAGE1(_T("Error, failed to register dll - %s."), szGPEditFile);
            }
            
        }
        
        OleInitialize(NULL);
        IGroupPolicyObject *pIGroupPolicyObject = NULL;
        HRESULT hResult = CoCreateInstance(
            CLSID_GroupPolicyObject,        //Class identifier (CLSID) of the object
            NULL,                           //Pointer to controlling IUnknown
            CLSCTX_ALL,                     //Context for running executable code
            IID_IGroupPolicyObject,         //Reference to the identifier of the interface
            (void **)&pIGroupPolicyObject   //Address of output variable that receives  the interface pointer requested in riid
            );
        if (SUCCEEDED(hResult))
        {
            ASSERT(pIGroupPolicyObject);
            
            hResult = pIGroupPolicyObject->OpenLocalMachineGPO(GPO_OPEN_LOAD_REGISTRY);
            if (SUCCEEDED(hResult))
            {
                HKEY hMachinePolicyKey = NULL;
                hResult = pIGroupPolicyObject->GetRegistryKey(GPO_SECTION_MACHINE, &hMachinePolicyKey);
                if (SUCCEEDED(hResult))
                {
                    ASSERT(hMachinePolicyKey);
                    
                    const LPCTSTR szNoActiveDesktop_key     = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer");
                    const LPCTSTR szNoActiveDesktop_val     = _T("NoActiveDesktop");
                    const DWORD   szNoActiveDesktop_dat     = 1;
                    
                    const LPCTSTR szNoFileAssoc_key         = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer");
                    const LPCTSTR szNoFileAssoc_val         = _T("NoFileAssociate");
                    const DWORD   szNoFileAssoc_dat         = 1;

                    CRegistry regMachinePolicy;

                    if (ERROR_SUCCESS == regMachinePolicy.CreateKey(hMachinePolicyKey, szNoActiveDesktop_key))
                    {
                        if (StateObject.IsItAppServer())
                        {
                            if (ERROR_SUCCESS != regMachinePolicy.WriteRegDWord(szNoActiveDesktop_val, szNoActiveDesktop_dat))
                            {
                                LOGMESSAGE1(_T("ERROR, Failed to Write %s policy"), szNoActiveDesktop_val);
                            }
                        }
                        else
                        {
                            if (ERROR_SUCCESS != regMachinePolicy.DeleteValue(szNoActiveDesktop_val))
                            {
                                LOGMESSAGE1(_T("Failed to delete %s policy"), szNoActiveDesktop_val);
                            }
                        }
                    }
                    
                    if (ERROR_SUCCESS == regMachinePolicy.CreateKey(hMachinePolicyKey, szNoFileAssoc_key))
                    {
                        if (StateObject.IsItAppServer())
                        {
                            if (ERROR_SUCCESS != regMachinePolicy.WriteRegDWord(szNoFileAssoc_val, szNoFileAssoc_dat))
                            {
                                LOGMESSAGE1(_T("ERROR, Failed to Write %s policy"), szNoFileAssoc_val);
                            }
                        }
                        else
                        {
                            if (ERROR_SUCCESS != regMachinePolicy.DeleteValue(szNoFileAssoc_val))
                            {
                                LOGMESSAGE1(_T("Failed to delete %s policy"), szNoFileAssoc_val);
                            }
                        }
                    }
                    
                    pIGroupPolicyObject->Save(TRUE, TRUE, &guidRegistryEntension, &guidPolicyMachineSnapin);
                    RegCloseKey(hMachinePolicyKey);
                    bRet = TRUE;
                    
                }
                else
                {
                    LOGMESSAGE1(_T("ERROR, Failed to GetRegistryKey...hResult = %x"), hResult);
                }
            }
            else
            {
                LOGMESSAGE1(_T("ERROR, Failed to OpenLocalMachineGPO...hResult = %x"), hResult);
            }
            
            pIGroupPolicyObject->Release();
            
        }
        else
        {
            LOGMESSAGE1(_T("ERROR, Failed to get the interface IID_IGroupPolicyObject...hResult = %x"), hResult);
            
        }
        
        LOGMESSAGE0(_T("Done with Policy changes!"));
    }
    
    return bRet;
}


BOOL SubCompToggle::ModifyAppPriority()
{
    if (StateObject.IsAppSrvModeSwitch())
    {
        DWORD dwSrvPrioity = StateObject.IsItAppServer() ? 0x26 : 0x18;
        
        LPCTSTR PRIORITY_KEY = _T("SYSTEM\\CurrentControlSet\\Control\\PriorityControl");
        
        CRegistry oReg;
        if (ERROR_SUCCESS == oReg.OpenKey(HKEY_LOCAL_MACHINE, PRIORITY_KEY))
        {
            if (ERROR_SUCCESS != oReg.WriteRegDWord(_T("Win32PrioritySeparation"), dwSrvPrioity))
            {
                LOGMESSAGE0(_T("Error, Failed to update Win32PrioritySeparation"));
                return FALSE;
            }
            
            return TRUE;
        }
        else
        {
            LOGMESSAGE1(_T("Errror, Failed to open %s key"), PRIORITY_KEY);
            return FALSE;
        }
        
    }
    
    return TRUE;
}

/*
BOOL SubCompToggle::UpdateMMDefaults ()
{
    LPCTSTR MM_REG_KEY = _T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management");
    LPCTSTR SESSION_VIEW_SIZE_VALUE = _T("SessionViewSize");
    LPCTSTR SESSION_POOL_SIZE_VALUE = _T("SessionPoolSize");
    
    const DWORD dwViewSizeforPTS = 48;
    const DWORD dwPoolSizeforPTS = 4;
    const DWORD dwPoolSizeforRA = 48;
    // const DWORD dwPoolSizeforAS = 16;
    
    ASSERT(StateObject.IsTSEnableSelected());

    if (!StateObject.IsX86())
    {
        // these setting apply only for x86
        return TRUE;
    }

    CRegistry  regMM;
    if (ERROR_SUCCESS != regMM.OpenKey(HKEY_LOCAL_MACHINE, MM_REG_KEY))
    {
        LOGMESSAGE0(_T("ERROR, Failed to open mm Key"));
        return FALSE;
    }
        
    if (StateObject.IsWorkstation())
    {
        if ((ERROR_SUCCESS != regMM.WriteRegDWord(SESSION_VIEW_SIZE_VALUE, dwViewSizeforPTS)) ||
            (ERROR_SUCCESS != regMM.WriteRegDWord(SESSION_POOL_SIZE_VALUE, dwPoolSizeforPTS)))
        {
            LOGMESSAGE0(_T("ERROR, Failed to write MM Defaults for PTS"));
            return FALSE;
        }
        else
        {
            LOGMESSAGE0(_T("Wrote MM Defaults for PTS"));
        }
    }
    else
    {
        if (StateObject.IsItAppServer())
        {
            // for app server mode, mm sets the right defaults.
            // so just delete these value.
            regMM.DeleteValue(SESSION_VIEW_SIZE_VALUE);
            regMM.DeleteValue(SESSION_POOL_SIZE_VALUE);
            
            LOGMESSAGE0(_T("deleted MM defaults for AS"));
        }
        else
        {
            if (ERROR_SUCCESS != regMM.WriteRegDWord(SESSION_POOL_SIZE_VALUE, dwPoolSizeforRA))
            {
                LOGMESSAGE0(_T("ERROR, Failed to write MM Defaults for RA"));
                return FALSE;
            }
            else
            {
                LOGMESSAGE0(_T("Wrote MM Defaults for RA"));
            }
        }
    }
    
    return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\util.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Util.h
 *
 *  Utility routines.
 *
 */

#ifndef __TSOC_UTIL_H__
#define __TSOC_UTIL_H__

//
//  Includes
//

#include "stdafx.h"

//
//  Function prototypes
//

VOID
DestroyExtraRoutines(
    VOID
    );

VOID
DestroySetupData(
    VOID
    );

BOOL
DoMessageBox(
    UINT uiMsg
    );

HINF
GetComponentInfHandle(
    VOID
    );

OCMANAGER_ROUTINES
GetHelperRoutines(
    VOID
    );

HINSTANCE
GetInstance(
    VOID
    );

PSETUP_INIT_COMPONENT
GetSetupData(
    VOID
    );

HINF
GetUnAttendedInfHandle(
    VOID
    );

VOID
LogErrorToEventLog(
    WORD wType,
    WORD wCategory,
    DWORD dwEventId,
    WORD wNumStrings,
    DWORD dwDataSize,
    LPCTSTR *lpStrings,
    LPVOID lpRawData
    );

VOID
LogErrorToSetupLog(
    OcErrorLevel ErrorLevel,
    UINT uiMsg,
    ...
    );

VOID
SetInstance(
    HINSTANCE hInstance
    );

VOID
SetProgressText(
    UINT uiMsg
    );

BOOL
SetReboot(
    VOID
    );

BOOL
SetExtraRoutines(
    PEXTRA_ROUTINES pExtraRoutines
    );

BOOL
SetSetupData(
    PSETUP_INIT_COMPONENT pSetupData
    );

BOOL Delnode( IN LPCTSTR  Directory );

DWORD StoreSecretKey(PWCHAR  pwszKeyName, BYTE *  pbKey, DWORD   cbKey );

DWORD OpenPolicy(LPWSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle );

void InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String );

#endif // __TSOC_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inc\logmsg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// LogMsg.h: interface for the LogMsg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_)
#define AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_
#define _LOGMESSAGE_INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class LogMsg
{



private:

	enum {
		LOG_INITIALIZED = 25
		};

    TCHAR m_szLogFile[MAX_PATH];
    TCHAR m_szLogModule[MAX_PATH];
	int m_iIsInitialized;

public:
	
    
                LogMsg          (int value);
	virtual     ~LogMsg         ();

	BOOL		IsInitialized	();

    DWORD       Init            (LPCTSTR szLogFile, LPCTSTR szLogModule);
    DWORD       Log             (LPCTSTR file, int line, TCHAR *fmt, ...);

 //   static LogMsg GetLogObject();

};

// instantiated in LogMsg.cpp.
#ifndef _LOGMESSAGE_CPP_

extern LogMsg thelog;

#endif

// maks_todo : how to make sure that we get compiler error if we use macro with fewer parameters when we should have used macro with more parameters ?
// for example : LOGERROR1(_T("Show Two Values %s, %s"), firstvalue, secondvalue) how to catch this error during compilation ?
#define LOGMESSAGEINIT(logfile, module)                 thelog.Init(logfile, module)
#define LOGMESSAGE0(msg)                                thelog.Log(_T(__FILE__), __LINE__, msg)
#define LOGMESSAGE1(msg, arg1)                          thelog.Log(_T(__FILE__), __LINE__, msg, arg1)
#define LOGMESSAGE2(msg, arg1, arg2)                    thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2)
#define LOGMESSAGE3(msg, arg1, arg2, arg3)              thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3)
#define LOGMESSAGE4(msg, arg1, arg2, arg3, arg4)        thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3, arg4)
#define LOGMESSAGE5(msg, arg1, arg2, arg3, arg4, arg5)  thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3, arg4, arg5)

#endif // !defined(AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\users.cpp ===
#include "stdafx.h"

// #include <windows.h>
#include <lm.h>
#include <dsrole.h>

NET_API_STATUS GetDomainUsersSid(OUT PSID *ppSid);
DWORD GetWellKnownName(IN DWORD dwRID, OUT WCHAR **pszName);

/*****************************************************************************
 *
 *  RemoveAllFromRDUsersGroup
 *
 *   Removes all entries from "Remote Desktop Users" group
 *
 * ENTRY:
 *  none
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *
 *          
 *
 ****************************************************************************/
DWORD
RemoveAllFromRDUsersGroup()
{
    NET_API_STATUS Result,Result1;

    //Get "Remote Desktop Users" group name.
    //It may be different in different languages
    WCHAR *szRemoteGroupName = NULL;
    Result = GetWellKnownName(DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS, &szRemoteGroupName);
    if(Result == NERR_Success)
    {
        //Copy members of "Users" group to "Remote Desktop Users" group
        PLOCALGROUP_MEMBERS_INFO_0 plmi0 = NULL;
        DWORD entriesread = 0;
        DWORD totalentries = 0;
        DWORD_PTR resumehandle = 0;

        do
        {
            Result = NetLocalGroupGetMembers(NULL,szRemoteGroupName,0,(LPBYTE *)&plmi0,
                            1000,&entriesread,
                            &totalentries,&resumehandle);

            if((Result == NERR_Success || Result == ERROR_MORE_DATA) &&
                entriesread)
            {
                for(DWORD i=0;i<entriesread;i++)
                {
                    //We have to add users one by one because of the stupid behaviour 
                    //of this function, not allowing to add users if some of them are already
                    //members of the group.
                    Result1 = NetLocalGroupDelMembers(NULL,szRemoteGroupName,0,(LPBYTE)&plmi0[i],1);
                    if(Result1 != ERROR_SUCCESS && Result1 != ERROR_MEMBER_IN_ALIAS)
                    {
                        LOGMESSAGE1(_T("NetLocalGroupDelMembers failed %d\n"),Result1);
                        break;
                    }
                }
                NetApiBufferFree(plmi0);
                if(Result1 != ERROR_SUCCESS && Result1 != ERROR_MEMBER_IN_ALIAS)
                {
                    Result = Result1;
                    break;
                }
            }

        }while (Result == ERROR_MORE_DATA);

        delete szRemoteGroupName;
    }
    else
    {
        LOGMESSAGE1(_T("GetWellKnownName(DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS) failed %d\n"),Result);
    }
    
    return Result;
}

/*****************************************************************************
 *
 *  CopyUsersGroupToRDUsersGroup
 *
 *   Copies all members of "Users" group to "Remote Desktop Users" group
 *
 * ENTRY:
 *  none
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *           
 *          
 *
 ****************************************************************************/
DWORD 
CopyUsersGroupToRDUsersGroup()
{
    NET_API_STATUS Result,Result1;

    //Get real name of "Users" group
    //It may be different in different languages
    WCHAR *szUsersName = NULL;
    Result = GetWellKnownName(DOMAIN_ALIAS_RID_USERS, &szUsersName);
    if(Result != NERR_Success)
    {
        LOGMESSAGE1(_T("GetWellKnownName(DOMAIN_ALIAS_RID_USERS) failed %d\n"),Result);
        return Result;
    }
    
    //Get "Remote Desktop Users" group name.
    //It may be different in different languages
    WCHAR *szRemoteGroupName = NULL;
    Result = GetWellKnownName(DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS, &szRemoteGroupName);
    if(Result == NERR_Success)
    {
        //Copy members of "Users" group to "Remote Desktop Users" group
        PLOCALGROUP_MEMBERS_INFO_0 plmi0 = NULL;
        DWORD entriesread = 0;
        DWORD totalentries = 0;
        DWORD_PTR resumehandle = 0;

        do
        {
            Result = NetLocalGroupGetMembers(NULL,szUsersName,0,(LPBYTE *)&plmi0,
                            1000,&entriesread,
                            &totalentries,&resumehandle);

            if((Result == NERR_Success || Result == ERROR_MORE_DATA) &&
                entriesread)
            {
                for(DWORD i=0;i<entriesread;i++)
                {
                    //We have to add users one by one because of the stupid behaviour 
                    //of this function, not allowing to add users if some of them are already
                    //members of the group.
                    Result1 = NetLocalGroupAddMembers(NULL,szRemoteGroupName,0,(LPBYTE)&plmi0[i],1);
                    if(Result1 != ERROR_SUCCESS && Result1 != ERROR_MEMBER_IN_ALIAS)
                    {
                        LOGMESSAGE1(_T("NetLocalGroupAddMembers failed %d\n"),Result1);
                        break;
                    }
                }
                NetApiBufferFree(plmi0);
                if(Result1 != ERROR_SUCCESS && Result1 != ERROR_MEMBER_IN_ALIAS)
                {
                    Result = Result1;
                    break;
                }
            }

        }while (Result == ERROR_MORE_DATA);

        
        delete szRemoteGroupName;
    }
    else
    {
        LOGMESSAGE1(_T("GetWellKnownName(DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS) failed %d\n"),Result);
    }
    
    delete szUsersName;
    return Result;
}

/*****************************************************************************
 *
 *  GetWellKnownName
 *
 *   Returns a real name of any well-known account
 *
 * ENTRY:
 *    IN DWORD dwRID
 *    OUT WCHAR **pszName
 *  
 *  
 * NOTES:
 *   To free returned buffer use "delete" operator.
 *  
 * EXIT:
 *  Returns: NERR_Success if success, error code if failure
 *           
 *          
 *
 ****************************************************************************/
DWORD
GetWellKnownName( 
        IN DWORD dwRID,
        OUT WCHAR **pszName)
{
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID pSid=NULL;
    
    if( !AllocateAndInitializeSid( &sia, 2,
              SECURITY_BUILTIN_DOMAIN_RID,
              dwRID, 
              0, 0, 0, 0, 0, 0,&pSid ) )
    {
        return GetLastError();
    }

    //Lookup name
    WCHAR *szDomainName = NULL;

    DWORD cName = MAX_PATH;
    DWORD cDomainName = MAX_PATH;
    SID_NAME_USE eUse;
    
    DWORD Result = NERR_Success;

    for(int i=0; i<2; i++)
    {
        Result = NERR_Success;

        *pszName = new WCHAR[cName];

        if(!(*pszName))
        {
            Result = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        szDomainName = new WCHAR[cDomainName];
        
        if(!szDomainName)
        {
            delete *pszName;
            *pszName = NULL;
            Result = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if(!LookupAccountSidW(NULL,pSid,
            *pszName,&cName,
            szDomainName,&cDomainName,
            &eUse))
        {
            delete *pszName;
            delete szDomainName;
            *pszName = NULL;
            szDomainName = NULL;

            Result = GetLastError();

            if(Result == ERROR_INSUFFICIENT_BUFFER)
            {
                continue;
            }
            else
            {
                break;
            }
        }
        
        break;
    }
    
    if(szDomainName)
    {
        delete szDomainName;
    }

    FreeSid(pSid);
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\vermak.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/////////////////////////////////////////////////////////////////////////////
// VERSION INFO
#include <ntverp.h>


#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Terminal Server Optional Component Setup"
#define VER_INTERNALNAME_STR        "tsoc"
#define VER_ORIGINALFILENAME_STR    "tsoc.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inc\registry.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      Registry.h
*
*  Abstract:
*
*      declaration of a simple registry class CRegistry.
*
*
*
*  Author:
*
*      Makarand Patwardhan  - April 9, 1997
*
* -------------------------------------------------------------------------------------------------------*/

#if !defined(AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_)
#define AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include <winreg.h>


class CRegistry
{
private:

    LPBYTE      m_pMemBlock;
    HKEY        m_hKey;
    int         m_iEnumIndex;
    int         m_iEnumValueIndex;

    DWORD       ReadReg             (LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype);
    void *      Allocate            (DWORD dwSize);



    //
    // This class is not designed to allow copy constructors, = assignments,
    // therefore we should ensure that copy ctor, assignment operator are not
    // generated by compiler. we do that by declaring these functions private
    // and not implementing them. This will ensure that these functions are
    // not generated by compilers, and caller will get error if he tries to
    // use them.
    //

                CRegistry           (const CRegistry &reg);     // copy ctor
  CRegistry &   operator=           (const CRegistry &reg);     // = oprerator



#ifdef DBG
    DWORD       m_dwSizeDebugOnly;
#endif

public:
                CRegistry           ();
                CRegistry           (HKEY hKey);

    virtual     ~CRegistry          ();

    void        Release             ();

    operator    HKEY                ()    {return m_hKey;}


    DWORD       OpenKey             (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS, LPCTSTR lpMachineName = NULL);
    DWORD       CreateKey           (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS, DWORD *pDisposition = NULL, LPSECURITY_ATTRIBUTES lpSecAttr  = NULL );

    DWORD       DeleteValue         (LPCTSTR lpValue);
    DWORD       RecurseDeleteKey    (LPCTSTR lpSubKey);
    DWORD       CopyTree            (CRegistry &regSrc);

    DWORD       ReadRegString       (LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw);
    DWORD       ReadRegDWord        (LPCTSTR lpValue, DWORD *pdw);
    DWORD       ReadRegMultiString  (LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw);
    DWORD       ReadRegBinary       (LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw);

    DWORD       WriteRegString      (LPCTSTR lpValueName, LPCTSTR lpStr);
    DWORD       WriteRegExString    (LPCTSTR lpValueName, LPCTSTR lpStr);
    DWORD       WriteRegDWord       (LPCTSTR lpValueName, DWORD dwValue);
    DWORD       WriteRegMultiString (LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize);
	DWORD		WriteRegBinary		(LPCTSTR lpValueName, LPBYTE lpData, DWORD dwSize);
	DWORD		ExistInMultiString  (LPCTSTR lpValueName, LPCTSTR lpCheckForStr, BOOL *pbExists);
	DWORD		AppendToMultiString (LPCTSTR lpValueName, LPCTSTR lpStr);


    DWORD       GetFirstSubKey      (LPTSTR *lppStr, DWORD *pdw);
    DWORD       GetNextSubKey       (LPTSTR *lppStr, DWORD *pdw);

    DWORD       GetFirstValue       (LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType);
    DWORD       GetNextValue        (LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType);

    DWORD       GetSecurity         (PSECURITY_DESCRIPTOR *ppSec, SECURITY_INFORMATION SecurityInformation, DWORD *pdwSize);
    DWORD       SetSecurity         (PSECURITY_DESCRIPTOR pSec, SECURITY_INFORMATION SecurityInformation);

};

#endif // !defined(AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_)

//EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\dll\util.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Util.cpp
 *
 *  Utility routines.
 *
 */

//
//  Includes
//

#include "stdafx.h"
#include "hydraoc.h"


//
//  Globals
//

HINSTANCE               ghInstance          = NULL;
PEXTRA_ROUTINES         gpExtraRoutines     = NULL;
// PSETUP_INIT_COMPONENT   gpInitComponentData = NULL;

//
//  Function Definitions
//

VOID
DestroyExtraRoutines(
    VOID
    )
{
    if (gpExtraRoutines != NULL) {
        LocalFree(gpExtraRoutines);
    }
}


BOOL
DoMessageBox(
    UINT uiMsg
    )
{
    TCHAR strMsg[1024];
    TCHAR strTitle[1024];

    ASSERT(!StateObject.IsUnattended());

    if ((LoadString(GetInstance(), IDS_STRING_MESSAGE_BOX_TITLE, strTitle, 1024) != 0) &&
        (LoadString(GetInstance(), uiMsg, strMsg, 1024) != 0))
    {
        MessageBox(
            GetHelperRoutines().QueryWizardDialogHandle(GetHelperRoutines().OcManagerContext),
            strMsg,
            strTitle,
            MB_OK
            );

        return(TRUE);
    }

    return(FALSE);
}

HINF
GetComponentInfHandle(
    VOID
    )
{
    if (INVALID_HANDLE_VALUE == GetSetupData()->ComponentInfHandle) {
        return(NULL);
    } else {
        return(GetSetupData()->ComponentInfHandle);
    }
}

EXTRA_ROUTINES
GetExtraRoutines(
    VOID
    )
{
    return(*gpExtraRoutines);
}

OCMANAGER_ROUTINES
GetHelperRoutines(
    VOID
    )
{
    return(GetSetupData()->HelperRoutines);
}

HINSTANCE
GetInstance(
    VOID
    )
{
    ASSERT(ghInstance);
    return(ghInstance);
}


HINF
GetUnAttendedInfHandle(
    VOID
    )
{
    ASSERT(StateObject.IsUnattended());
    return(GetHelperRoutines().GetInfHandle(INFINDEX_UNATTENDED,GetHelperRoutines().OcManagerContext));
}

VOID
LogErrorToEventLog(
    WORD wType,
    WORD wCategory,
    DWORD dwEventId,
    WORD wNumStrings,
    DWORD dwDataSize,
    LPCTSTR *lpStrings,
    LPVOID lpRawData
    )
{
    HANDLE hEventLog;

    hEventLog = RegisterEventSource(NULL, TS_EVENT_SOURCE);
    if (hEventLog != NULL) {
        if (!ReportEvent(
                hEventLog,
                wType,
                wCategory,
                dwEventId,
                NULL,
                wNumStrings,
                dwDataSize,
                lpStrings,
                lpRawData
                )) {
            LOGMESSAGE1(_T("ReportEvent failed %ld"), GetLastError());
        }

        DeregisterEventSource(hEventLog);
    } else {
        LOGMESSAGE1(_T("RegisterEventSource failed %ld"), GetLastError());
        return;
    }
}

VOID
LogErrorToSetupLog(
    OcErrorLevel ErrorLevel,
    UINT uiMsg,
    ...
    )
{
    TCHAR szFormat[1024];
    TCHAR szOutput[1024];

    if (LoadString(GetInstance(), uiMsg, szFormat, 1024) != 0) {
        va_list vaList;

        va_start(vaList, uiMsg);
        _vstprintf(szOutput, szFormat, vaList);
        va_end(vaList);

        GetExtraRoutines().LogError(
            GetHelperRoutines().OcManagerContext,
            ErrorLevel,
            szOutput
            );
    }
}

VOID
SetInstance(
    HINSTANCE hInstance
    )
{
    ghInstance = hInstance;
}

VOID
SetProgressText(
    UINT uiMsg
    )
{
    TCHAR strMsg[1024];

    if (LoadString(GetInstance(), uiMsg, strMsg, 1024) != 0) {
        GetHelperRoutines().SetProgressText(GetHelperRoutines().OcManagerContext, strMsg);
    }
}

BOOL
SetReboot(
    VOID
    )
{
    return(GetHelperRoutines().SetReboot(GetHelperRoutines().OcManagerContext, 0));
}

BOOL
SetExtraRoutines(
    PEXTRA_ROUTINES pExtraRoutines
    )
{
    if (pExtraRoutines->size != sizeof(EXTRA_ROUTINES)) {
        LOGMESSAGE0(_T("WARNING: Extra Routines are a different size than expected!"));
    }

    gpExtraRoutines = (PEXTRA_ROUTINES)LocalAlloc(LPTR, pExtraRoutines->size);
    if (gpExtraRoutines == NULL) {
        return(FALSE);
    }

    CopyMemory(gpExtraRoutines, pExtraRoutines, pExtraRoutines->size);

    return(TRUE);
}


BOOL Delnode( IN LPCTSTR  Directory )
{
    TCHAR           szDirectory[MAX_PATH + 1];
    TCHAR           szPattern[MAX_PATH + 1];
    WIN32_FIND_DATA FindData;
    HANDLE          FindHandle;

    LOGMESSAGE0(_T("Delnode: Entered"));

    //
    //  Delete each file in the given directory, then remove the directory
    //  itself. If any directories are encountered along the way recurse to
    //  delete them as they are encountered.
    //
    //  Start by forming the search pattern, which is <currentdir>\*.
    //

    ExpandEnvironmentStrings(Directory, szDirectory, MAX_PATH);
    LOGMESSAGE1(_T("Delnode: Deleting %s"), szDirectory);

    _tcscpy(szPattern, szDirectory);
    _tcscat(szPattern, _T("\\"));
    _tcscat(szPattern, _T("*"));

    //
    // Start the search.
    //

    FindHandle = FindFirstFile(szPattern, &FindData);
    if(FindHandle != INVALID_HANDLE_VALUE)
    {

        do
        {

            //
            // Form the full name of the file or directory we just found.
            //

            _tcscpy(szPattern, szDirectory);
            _tcscat(szPattern, _T("\\"));
            _tcscat(szPattern, FindData.cFileName);

            //
            // Remove read-only atttribute if it's there.
            //

            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                SetFileAttributes(szPattern, FILE_ATTRIBUTE_NORMAL);
            }

            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //

                if ((_tcsicmp(FindData.cFileName,_T("."))) &&
                    (_tcsicmp(FindData.cFileName,_T(".."))))
                {
                    if (!Delnode(szPattern))
                    {
                        LOGMESSAGE1(_T("DelNode failed on %s"), szPattern);
                    }
                }

            }
            else
            {

                //
                // The current match is not a directory -- so delete it.
                //

                if (!DeleteFile(szPattern))
                {
                    LOGMESSAGE2(_T("Delnode: %s not deleted: %d"), szPattern, GetLastError());
                }
            }

        }
        while(FindNextFile(FindHandle, &FindData));

        FindClose(FindHandle);
    }

    //
    // Remove the directory we just emptied out. Ignore errors.
    //

    if (!RemoveDirectory(szDirectory))
    {
        LOGMESSAGE2(_T("Failed to remove the directory %s (%d)"), szDirectory, GetLastError());
        return FALSE;
    }

    return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Function:	StoreSecretKey
//
//  Synopsis:	stores a key in the LSA
//
//  Arguments:	[pwszKeyName] -- the license server
//				[pbKey]     -- the product id to add license on
//				[cbKey]	  -- the key pack type to add the license to
//
//  Returns:	returns a WinError code
//
//  History:    September 17, 1998 - created [hueiwang]
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD StoreSecretKey(PWCHAR  pwszKeyName, BYTE *  pbKey, DWORD   cbKey )
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    DWORD Status;

    if( ( NULL == pwszKeyName ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString( &SecretKeyName, pwszKeyName );

    SecretData.Buffer = ( LPWSTR )pbKey;
    SecretData.Length = ( USHORT )cbKey;
    SecretData.MaximumLength = ( USHORT )cbKey;

    Status = OpenPolicy( NULL, POLICY_CREATE_SECRET, &PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }


    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                pbKey ? &SecretData : NULL
                );

    LsaClose(PolicyHandle);

    return LsaNtStatusToWinError(Status);
}

//+--------------------------------------------------------------------------
//
//  Function:	OpenPolicy
//
//  Synopsis:	opens a policy of the LSA component
//
//  Arguments:	[ServerName]     -- server
//				[DesiredAccess]  --
//				[PociyHandle]	 --
//
//  Returns:	returns nt error code
//
//  History:    September 17, 1998 - created [hueiwang]
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD OpenPolicy(LPWSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //

    ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if( NULL != ServerName )
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //

        InitLsaString( &ServerString, ServerName );
        Server = &ServerString;

    }
    else
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //

    return( LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle ) );
}


//+--------------------------------------------------------------------------
//
//  Function:	InitLsaString
//
//  Synopsis:	initializes LSA string
//
//  Arguments:	[LsaString] --
//				[String]    --
//
//  Returns:	void
//
//  History:    September 17, 1998 - created [hueiwang]
//
//  Notes:
//
//---------------------------------------------------------------------------
void InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String )
{
    DWORD StringLength;

    if( NULL == String )
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW( String );
    LsaString->Buffer = String;
    LsaString->Length = ( USHORT ) (StringLength * sizeof( WCHAR ));
    LsaString->MaximumLength=( USHORT ) (( StringLength + 1 ) * sizeof( WCHAR ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\sources.inc ===
# Copyright (c) 1998 - 1999 Microsoft Corporation
#
# This file is designed to be included from 2 levels below
# (ie, daytona\srv, daytona\wks, cairo\srv, or cairo\wks).
#

MAJORCOMP=setup
MINORCOMP=infs

TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=notarget

C_DEFINES=$(C_DEFINES) -DTSOC_CONSOLE_SHADOWING
!ifdef TERMSRV_PROC
C_DEFINES=$(C_DEFINES) -DTERMSRV_PROC
!endif

!ifdef _PER_SKU_
C_DEFINES=$(C_DEFINES) -D_PER_SKU_
!endif

!ifdef _PRO_SKU_
C_DEFINES=$(C_DEFINES) -D_PRO_SKU_
!endif

!ifdef _SRV_SKU_
C_DEFINES=$(C_DEFINES) -D_SRV_SKU_
!endif

!ifdef _ADS_SKU_
C_DEFINES=$(C_DEFINES) -D_ADS_SKU_
!endif

!ifdef _DTC_SKU_
C_DEFINES=$(C_DEFINES) -D_DTC_SKU_
!endif



#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=

#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
NTTARGETFILE0=make_infs

NO_BROWSER_FILE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\makefile.inc ===
# Copyright (c) 1998 - 1999 Microsoft Corporation
#
# For daytona, this file is designed to be included from 3 levels below
# ie, dayona\$(LANGUAGE)inf\srv, or daytona\$(LANGUAGE)inf\wks
#
# Note: NEC98 builds go through this file twice, the second time
# with "ALT_PROJECT"=="NEC_98".  These latter produce a subset
# of binaries which are only used on NEC98 machines.
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=..\..\..\$(LANGUAGE)
_INX=..\..\..
_INF=obj\$(TARGET_DIRECTORY)

!ifdef _PER_SKU_
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b perinf)
!endif

!ifdef _PRO_SKU_
TSBINPLACE_CMD=$(BINPLACE_CMD)
!endif

!ifdef _SRV_SKU_
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf)
!endif

!ifdef _ADS_SKU_
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b entinf)
!endif

!ifdef _DTC_SKU_
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b dtcinf)
!endif


make_infs:$(_INF)\tsoc.inf

$(_INF)\tsoc.inf: $(_INX)\tsoc.inx $(_LNG)\tsoc.txt
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$(_INX)\$(@B).inx > $(O)\$(@B).tmp
$(CPPXX: =
)
<<NOKEEP
    copy $(O)\$(@B).tmp+$(_LNG)\$(@B).txt $@
    $(TSBINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\arainf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\arainf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\arainf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\arainf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\brinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\arainf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\brinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\brinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\chsinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\chsinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\chsinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\brinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\brinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\chsinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\chsinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\chtinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\chtinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\chtinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\chtinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\csinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\csinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\chtinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\csinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\dainf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\dainf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\csinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\csinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\dainf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\dainf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\elinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\dainf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\elinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\elinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\elinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\elinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\esinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\esinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\esinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\esinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\esinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\fiinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\fiinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\fiinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\fiinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\frinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\fiinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\frinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\frinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\frinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\gerinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\gerinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\gerinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\frinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\gerinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\gerinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\hebinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\hebinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\hebinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\hebinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\hebinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\huinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\huinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\huinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\huinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\huinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\itinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\itinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\itinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\itinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\jpninf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\itinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\jpninf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\jpninf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\jpninf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\jpninf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\korinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\korinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\korinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\korinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\nlinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\korinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\nlinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\nlinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\nlinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\nlinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\noinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\noinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\noinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\noinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\plinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\plinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\plinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\noinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\plinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\plinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\psuinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\psuinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\psuinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\ptinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\ptinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\psuinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\psuinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\ptinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\ptinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\ptinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\ruinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\ruinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\ruinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\ruinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\svinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\svinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\svinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\svinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\ruinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\svinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\trinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\trinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\trinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\trinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\trinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\tstinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\tstinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\tstinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\tstinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\usainf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\tstinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\usainf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\usainf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\usainf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\inf\daytona\usainf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\ists\ists.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

#include <windows.h>
#include <stdio.h>

void main(void)
{
//    DWORD dwError;
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    BOOL bTsPresent = VerifyVersionInfo(
        &osVersionInfo,
        VER_SUITENAME,
        dwlConditionMask
        );

    printf("VerifyVersionInfo says TerminalServices is %s", bTsPresent ? "ON" : "OFF");

}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\isinstallmode\isinst.c ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

#include <windows.h>
#include <winbase.h>

typedef BOOLEAN (*PFnTERMSRVAPPINSTALLMODE) (VOID);
typedef BOOLEAN (*PFnCTXGETINIMAPPING) (VOID);

BOOL IsTrmSrvInstallMode()
{
    BOOLEAN                     bReturn = FALSE;
    BOOL                        bReturn2 = FALSE;
    HINSTANCE                   hKernel = NULL;
    PFnTERMSRVAPPINSTALLMODE    pfnTermsrvAppInstallMode = NULL;
    PFnCTXGETINIMAPPING         pfnCtxGetIniMapping = NULL;

    hKernel = GetModuleHandleA("kernel32.dll");
    if (hKernel)
    {
        // Try to get the NT5 API first...
        pfnTermsrvAppInstallMode = (PFnTERMSRVAPPINSTALLMODE)GetProcAddress( hKernel, "TermsrvAppInstallMode");
        if ( pfnTermsrvAppInstallMode )
        {
            bReturn = pfnTermsrvAppInstallMode();
        }
        else
        {
            // No NT5 API ==> try the NT40-WTSRV API.
            // NOTE: Remember this API's output is reverse of the above API
            pfnCtxGetIniMapping = (PFnCTXGETINIMAPPING)GetProcAddress(hKernel,"CtxGetIniMapping");
            if (pfnCtxGetIniMapping)
            {
                bReturn = !pfnCtxGetIniMapping();

            }
        }
    }

    return bReturn;
}

int WINAPI WinMain(
  HINSTANCE  hInstance,      // handle to current instance
  HINSTANCE  hPrevInstance,  // handle to previous instance
  LPSTR      lpCmdLine,      // pointer to command line
  int        nCmdShow       // show state of window);
  )
{
    BOOL bIsInstallMode;

    UNREFERENCED_PARAMETER (hInstance);
    UNREFERENCED_PARAMETER (hPrevInstance);
    UNREFERENCED_PARAMETER (lpCmdLine);
    UNREFERENCED_PARAMETER (nCmdShow);

    bIsInstallMode = IsTrmSrvInstallMode();

    if (bIsInstallMode)
        MessageBoxA( NULL, "TS Install Mode.", "Status", MB_OK );
    else
        MessageBoxA( NULL, "TS Execute Mode.", "Status", MB_OK );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\service\logmsg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// LogMsg.h: interface for the LogMsg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_)
#define AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_
#define _LOGMESSAGE_INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class LogMsg
{

    

private:

    TCHAR m_szLogFile[MAX_PATH];
    TCHAR m_szLogModule[MAX_PATH];
    int m_temp;

public:
	
    
                LogMsg          (int value);
	virtual     ~LogMsg         ();

    DWORD       Init            (LPCTSTR szLogFile, LPCTSTR szLogModule);
    DWORD       Log             (LPCTSTR file, int line, TCHAR *fmt, ...);

 //   static LogMsg GetLogObject();

};

// instantiated in LogMsg.cpp.
#ifndef _LOGMESSAGE_CPP_

extern LogMsg thelog;

#endif

// maks_todo : how to make sure that we get compiler error if we use macro with fewer parameters when we should have used macro with more parameters ?
// for example : LOGERROR1(_T("Show Two Values %s, %s"), firstvalue, secondvalue) how to catch this error during compilation ?
#define LOGMESSAGEINIT(logfile, module)                 thelog.Init(logfile, module)
#define LOGMESSAGE0(msg)                                thelog.Log(_T(__FILE__), __LINE__, msg)
#define LOGMESSAGE1(msg, arg1)                          thelog.Log(_T(__FILE__), __LINE__, msg, arg1)
#define LOGMESSAGE2(msg, arg1, arg2)                    thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2)
#define LOGMESSAGE3(msg, arg1, arg2, arg3)              thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3)
#define LOGMESSAGE4(msg, arg1, arg2, arg3, arg4)        thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3, arg4)
#define LOGMESSAGE5(msg, arg1, arg2, arg3, arg4, arg5)  thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3, arg4, arg5)

#endif // !defined(AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\lib\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

!ENDIF

TERMSRV_ROOT = ..\..\..
INCLUDES= \
    $(TERMSRV_ROOT)\setup\inc; \
    $(BASE_INC_PATH); \

TARGETPATH=$(TERMSRV_ROOT)\setup\lib\$(_OBJ_DIR)
TARGETTYPE=LIBRARY

SOURCES= \
    registry.cpp \
    logmsg.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\ists\ists.c ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

#include <windows.h>
#include <winbase.h>

/* -------------------------------------------------------------
   Note that the ValidateProductSuite() and IsTerminalServices()
   APIs use ANSI versions of functions in order to maintain
   compatibility with Win9X platforms.
   ------------------------------------------------------------- */

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(P)          (P)
#endif

#define OLD_VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))

BOOL ValidateProductSuite (LPSTR SuiteName)
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPSTR ProductSuite = NULL;
    LPSTR p;

    Rslt = RegOpenKeyA(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\ProductOptions",
        &hKey
        );

    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueExA( hKey, "ProductSuite", NULL, &Type, NULL, &Size );
    if (Rslt != ERROR_SUCCESS || !Size)
        goto exit;

    ProductSuite = (LPSTR) LocalAlloc( LPTR, Size );
    if (!ProductSuite)
        goto exit;

    Rslt = RegQueryValueExA( hKey, "ProductSuite", NULL, &Type,
        (LPBYTE) ProductSuite, &Size );
     if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    p = ProductSuite;
    while (*p)
    {
        if (lstrcmpA( p, SuiteName ) == 0)
        {
            rVal = TRUE;
            break;
        }
        p += (lstrlenA( p ) + 1);
    }

exit:
    if (ProductSuite)
        LocalFree( ProductSuite );

    if (hKey)
        RegCloseKey( hKey );

    return rVal;
}


BOOL IsTerminalServicesEnabled( VOID )
{
    BOOL    bResult = FALSE;
    DWORD   dwVersion;
    OSVERSIONINFOEXA osVersionInfo;
    DWORDLONG dwlConditionMask = 0;
    HMODULE hmodK32 = NULL;
    typedef ULONGLONG (*PFnVerSetConditionMask) ( ULONGLONG, ULONG, UCHAR );
    typedef BOOL      (*PFnVerifyVersionInfoA) (POSVERSIONINFOEXA, DWORD, DWORDLONG);
    PFnVerSetConditionMask pfnVerSetConditionMask;
    PFnVerifyVersionInfoA pfnVerifyVersionInfoA;


    dwVersion = GetVersion();

    /* are we running NT ? */
    if (!(dwVersion & 0x80000000))
    {
        // Is it NT 50 or greater ?
        if (LOBYTE(LOWORD(dwVersion)) > 4)
        {
            /* In NT5 we need to use the Product Suite APIs
             Don't static link because it won't load on non-NT5 systems */

            hmodK32 = GetModuleHandleA( "KERNEL32.DLL" );
            if (hmodK32)
            {
                pfnVerSetConditionMask = (PFnVerSetConditionMask )GetProcAddress( hmodK32, "VerSetConditionMask");

                if (pfnVerSetConditionMask)
                {
                    /* get the condition mask. */
                    dwlConditionMask = (*pfnVerSetConditionMask)(dwlConditionMask, VER_SUITENAME, VER_AND);

                    pfnVerifyVersionInfoA = (PFnVerifyVersionInfoA)GetProcAddress( hmodK32, "VerifyVersionInfoA") ;

                    if (pfnVerifyVersionInfoA != NULL)
                    {

                        ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));
                        osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
                        osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;
                        bResult = (*pfnVerifyVersionInfoA)(
                                          &osVersionInfo,
                                          VER_SUITENAME,
                                          dwlConditionMask);
                    }
                }
            }
        }
        else
        {
            /* This is NT 40 */
            bResult = ValidateProductSuite( "Terminal Server" );
        }
    }

    return bResult;
}


int WINAPI WinMain(
  HINSTANCE  hInstance,
  HINSTANCE  hPrevInstance,
  LPSTR      lpCmdLine,
  int        nCmdShow
  )
{
    BOOL bIsTerminalServer;

    UNREFERENCED_PARAMETER (hInstance);
    UNREFERENCED_PARAMETER (hPrevInstance);
    UNREFERENCED_PARAMETER (lpCmdLine);
    UNREFERENCED_PARAMETER (nCmdShow);

    bIsTerminalServer = IsTerminalServicesEnabled();

    if (bIsTerminalServer)
        MessageBoxA( NULL, "Terminal Services is running.", "Status", MB_OK );
    else
        MessageBoxA( NULL, "Not a Terminal Services box.", "Status", MB_OK );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\lib\logmsg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// LogMsg.cpp: implementation of the LogMsg class.
//
//////////////////////////////////////////////////////////////////////

#define _LOGMESSAGE_CPP_

#include "stdafx.h"
#include "LogMsg.h"


DWORD TCharStringToAnsiString(const TCHAR *tsz ,char *asz);


// maks_todo: is there any standard file to be used for  logs.
//////////////////////////////////////////////////////////////////////
// constants
//////////////////////////////////////////////////////////////////////
const UINT        LOG_ENTRY_SIZE             = 1024;
const UINT        STAMP_SIZE                 = 1024;
LPCTSTR           UNINITIALIZED              = _T("uninitialized");


//////////////////////////////////////////////////////////////////////
// globals.
////////////////////////////////////////////////////////////////////////
LogMsg thelog(26);  // used by LOGMESSAGE macros.


//////////////////////////////////////////////////////////////////////
// Construction / destruction
////////////////////////////////////////////////////////////////////////
LogMsg::LogMsg(int value)
{
    m_iIsInitialized = 0;
    _tcscpy(m_szLogFile, UNINITIALIZED);
}

LogMsg::~LogMsg()
{
	if (IsInitialized())
		LOGMESSAGE0(_T("********Terminating Log"));
}

/*--------------------------------------------------------------------------------------------------------
* DWORD LogMsg::Init(LPCTSTR szLogFile, LPCTSTR szLogModule)
* creates/opens the szLogFile for logging messages.
* must be called befour using the Log Function.
* -------------------------------------------------------------------------------------------------------*/
DWORD LogMsg::Init(LPCTSTR szLogFile, LPCTSTR szLogModule)
{

    USES_CONVERSION;
    ASSERT(szLogFile);
    ASSERT(szLogModule);
	ASSERT(!IsInitialized());

    // dont call this function twice.
    // maks_todo:why is the constructor not getting called?
    // maks_todo:enable this assert.
    ASSERT(_tcscmp(m_szLogFile, UNINITIALIZED) == 0);

    ASSERT(_tcslen(szLogFile) < MAX_PATH);
    ASSERT(_tcslen(szLogModule) < MAX_PATH);

    _tcscpy(m_szLogFile, szLogFile);
    _tcscpy(m_szLogModule, szLogModule);


    // open the log file
    HANDLE hfile = CreateFile(m_szLogFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        hfile = CreateFile(m_szLogFile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {

        // lets prepare for writing to the file.
        SetFilePointer(hfile, 0, NULL, FILE_END);
        DWORD  bytes;

        // get the current time/date stamp.
        TCHAR   time[STAMP_SIZE];
        TCHAR   date[STAMP_SIZE];
        TCHAR   output_unicode[LOG_ENTRY_SIZE];

        _tstrdate(date);
        _tstrtime(time);


        _stprintf(output_unicode, _T("\r\n\r\n*******Initializing Message Log:%s %s %s\r\n"), m_szLogModule, date, time);
        ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);


        // TCharStringToAnsiString(output_unicode, output);

        WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);


        // now write some more info about the version etc.
        OSVERSIONINFO OsV;
        OsV.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&OsV)== 0)
        {
            // get version failed.
            _stprintf(output_unicode, _T("GetVersionEx failed, ErrrorCode = %lu\r\n"), GetLastError());

            ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);

            WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);

        }
        else
        {
            //
            // ok we have the version info, write it out
            //

            _stprintf(output_unicode, _T("*******Version:Major=%lu, Minor=%lu, Build=%lu, PlatForm=%lu, CSDVer=%s, %s\r\n\r\n"),
                OsV.dwMajorVersion,
                OsV.dwMinorVersion,
                OsV.dwBuildNumber,
                OsV.dwPlatformId,
                OsV.szCSDVersion,
#ifdef DBG
                _T("Checked")
#else
                _T("Free")
#endif
                );

            ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);

            WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);
        }

        CloseHandle(hfile);
		m_iIsInitialized = LOG_INITIALIZED;
    }

    return GetLastError();
}

BOOL LogMsg::IsInitialized	()
{
	return m_iIsInitialized == LOG_INITIALIZED;
}

/*--------------------------------------------------------------------------------------------------------
* void log(TCHAR *fmt, ...)
* writes message to the log file. (LOGFILE)
* -------------------------------------------------------------------------------------------------------*/
DWORD LogMsg::Log(LPCTSTR file, int line, TCHAR *fmt, ...)
{

	ASSERT(IsInitialized());
    USES_CONVERSION;
    ASSERT(file);
    ASSERT(fmt);
    ASSERT(_tcscmp(m_szLogFile, UNINITIALIZED) != 0);

     // write down file and line info into the buffer..
    TCHAR   fileline_unicode[LOG_ENTRY_SIZE];

    // file is actually full path to the file.
    ASSERT(_tcschr(file, '\\'));

    // we want to print only file name not full path
    UINT uiFileLen = _tcslen(file);
    while (uiFileLen && *(file + uiFileLen - 1) != '\\')
    {
        uiFileLen--;
    }
    ASSERT(uiFileLen);

    _stprintf(fileline_unicode, _T("%s(%d)"), (file+uiFileLen), line);



    // create the output string
    TCHAR  output_unicode[LOG_ENTRY_SIZE];
    va_list vaList;
    va_start(vaList, fmt);
    _vstprintf(output_unicode, fmt, vaList);
    va_end(vaList);

    ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);


    // open the log file
    HANDLE hfile = CreateFile(m_szLogFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);

        DWORD  bytes;
        const LPCSTR CRLF = "\r\n";
        WriteFile(hfile, T2A(fileline_unicode), _tcslen(fileline_unicode), &bytes, NULL);
        WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);
        WriteFile(hfile, CRLF, strlen(CRLF) * sizeof(char), &bytes, NULL);

        CloseHandle(hfile);
    }

    return GetLastError();
}

/*--------------------------------------------------------------------------------------------------------
* TCharStringToAnsiString(const TCHAR *tsz ,char *asz)
* converts the given TCHAR * to char *
* -------------------------------------------------------------------------------------------------------*/

DWORD TCharStringToAnsiString(const TCHAR *tsz ,char *asz)
{

    ASSERT(tsz && asz);

#ifdef UNICODE
    DWORD count;

    count = WideCharToMultiByte(CP_ACP,
                                0,
                                tsz,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!count || count > STAMP_SIZE)
        return count;

    return WideCharToMultiByte(CP_ACP,
                               0,
                               tsz,
                               -1,
                               asz,
                               count,
                               NULL,
                               NULL);
#else
    _tcscpy(asz, tsz);
    return _tcslen(asz);
#endif
}



// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\lib\stdafx.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Module Name:
 *
 *      stdafx.h
 *
 *  Abstract:
 *
 *      Common Header file for the my library components
 *
 *  Author:
 *
 *
 *  Environment:
 *
 *    User Mode
 */

#ifndef _stdafx_h_
#define _stdafx_h_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <malloc.h>

#include "conv.h"

#define AssertFalse() ASSERT(FALSE)
#ifdef DBG
#define VERIFY(x) ASSERT(x)
#else
#define VERIFY(x)  (x)
#endif


#endif // _stdafx_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\lib\registry.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      Registry.cpp
*
*  Abstract:
*
*      Registry.cpp: implementation of the CRegistry class.
*      This class helps with registry by allocating memory by itself
*      As a result caller must copy the pointer returned by Get functions
*      immediately.
*
*
*
*  Author:
*
*      Makarand Patwardhan  - April 9, 1997
*
* -------------------------------------------------------------------------------------------------------*/

#include "stdafx.h"
#include "Registry.h"


/*--------------------------------------------------------------------------------------------------------
* Constructor
* -------------------------------------------------------------------------------------------------------*/
CRegistry::CRegistry()
{
    m_pMemBlock = NULL;
    m_hKey = NULL;
    m_iEnumIndex = -1;
    m_iEnumValueIndex = -1;

#ifdef DBG
    m_dwSizeDebugOnly = 0;
#endif
}


CRegistry::CRegistry(HKEY hKey)
{
    m_pMemBlock = NULL;
    m_hKey = hKey;
    m_iEnumIndex = -1;
    m_iEnumValueIndex = -1;
}

/*--------------------------------------------------------------------------------------------------------
* Destructor
* -------------------------------------------------------------------------------------------------------*/
CRegistry::~CRegistry()
{
    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
    Release();
}

/*--------------------------------------------------------------------------------------------------------
* void Allocate (DWORD dwSize)
* This private function is used for allocating the memory for
* reading registry
* returns the pointer to memory allocated.
* -------------------------------------------------------------------------------------------------------*/
void *CRegistry::Allocate (DWORD dwSize)
{
    if (m_pMemBlock)
        Release();

    m_pMemBlock = new BYTE[dwSize];

#ifdef DBG
    // remember the size of the block to be allocated.
    m_dwSizeDebugOnly = dwSize;
#endif

    return m_pMemBlock;
}

/*--------------------------------------------------------------------------------------------------------
* void Release ()
* This private function is used for releasing internal memory block
* -------------------------------------------------------------------------------------------------------*/
void CRegistry::Release ()
{
    if (m_pMemBlock)
    {

#ifdef DBG
        // fistly fill up the block we allocated previously with garbage.
        // so that if anybody is using this block, it is more lilely to
        // catch the bug.
        FillMemory(m_pMemBlock, m_dwSizeDebugOnly, 'c');
        m_dwSizeDebugOnly = 0;

#endif

        delete [] m_pMemBlock;
    }
    
    m_pMemBlock = 0;
}


///*--------------------------------------------------------------------------------------------------------
//* DWORD CRegistry::CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, DWORD *pDisposition /*= NULL*/, LPSECURITY_ATTRIBUTES lpSecAttr /* = NULL */)
//* opens/creates the key specified. before attempting any operation on any key/value. this function
//* must be called.
//* hKey - hive
//* lpSubKey - Path of the key in the format _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server")
//* access - access desired. like REG_READ, REG_WRITE..
//* RETURNS error code.
//* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, DWORD *pDisposition /*= NULL*/, LPSECURITY_ATTRIBUTES lpSecAttr /* = NULL */)
{
    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    // security descriptor should be null or it should be a valid one.
    ASSERT(!lpSecAttr || IsValidSecurityDescriptor(lpSecAttr->lpSecurityDescriptor));

    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    DWORD dwDisposition;
    LONG lResult = RegCreateKeyEx(
                    hKey,               // handle of an open key
                    lpSubKey,           // address of subkey name
                    0,                  // reserved
                    NULL,               // address of class string
                    REG_OPTION_NON_VOLATILE ,  // special options flag
                    access,             // desired security access
                    lpSecAttr,          // address of key security structure
                    &m_hKey,            // address of buffer for opened handle
                    &dwDisposition      // address of disposition value buffer
                    );

    if (lResult != ERROR_SUCCESS)
    {
        m_hKey = NULL;
    }

    if (pDisposition)
        *pDisposition = dwDisposition;

    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access) ()
* opens the key specified. before attempting any operation on any key/value. this function
* must be called.
* hKey - hive
* lpSubKey - Path of the key in the format _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server")
* access - access desired. like REG_READ, REG_WRITE..
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, LPCTSTR lpMachineName /* = NULL */)
{
	LONG lResult;
    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');
	LPTSTR szCompName = NULL;
    

	if (lpMachineName)
	{
		// if remote name is specified, hkey must be one of following.
		ASSERT(hKey == HKEY_LOCAL_MACHINE || hKey == HKEY_USERS || hKey == HKEY_PERFORMANCE_DATA);

		szCompName = new TCHAR[_tcslen(lpMachineName) + 3];
		if (!szCompName)
			return ERROR_OUTOFMEMORY;

		_tcscpy(szCompName, _T(""));
		if (*lpMachineName != '\\')
		{
			ASSERT(*(lpMachineName + 1) != '\\');
			_tcscpy(szCompName, _T("\\\\"));
		}
		
		_tcscat(szCompName, lpMachineName);

		// now connect to the remote computer.
		lResult = RegConnectRegistry (szCompName, hKey, &hKey);
		if (ERROR_SUCCESS != lResult)
		{
			delete [] szCompName;
			return lResult;
		}
	}

	if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    lResult = RegOpenKeyEx(
        hKey,                       // handle of open key
        lpSubKey,                   // address of name of subkey to open
        0 ,                         // reserved
        access,                     // security access mask
        &m_hKey                     // address of handle of open key
        );

    if (lResult != ERROR_SUCCESS)
    {
        m_hKey = NULL;
    }

	// if we opened remote registry.. lets close the top level key
	if (szCompName)
	{
		RegCloseKey(hKey);
		delete [] szCompName;
	}

    return lResult;
}

DWORD CRegistry::DeleteValue (LPCTSTR lpValue)
{
    ASSERT(lpValue);
    ASSERT(m_hKey);
    return RegDeleteValue(m_hKey, lpValue);

}
DWORD CRegistry::RecurseDeleteKey (LPCTSTR lpSubKey)
{
    ASSERT(lpSubKey);
    ASSERT(m_hKey);

    CRegistry reg;
    DWORD dwError = reg.OpenKey(m_hKey, lpSubKey);
    if (dwError != ERROR_SUCCESS)
        return dwError;


    LPTSTR lpChildKey;
    DWORD  dwSize;

    // we needn't/shouldn't use GetNextSubKey in this here
    // as we are deleting the key during the loop.
    while (ERROR_SUCCESS == reg.GetFirstSubKey(&lpChildKey, &dwSize))
    {
        VERIFY(reg.RecurseDeleteKey(lpChildKey) == ERROR_SUCCESS);
    }

    return RegDeleteKey(m_hKey, lpSubKey);

}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadReg(LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype)
* Reads the registry used internally.
* LPCTSTR lpValue - value to be read.
* LPBYTE *lppbyte - address of the lpbyte at which to place the output buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* dword datatype - datatype you are expecting.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadReg(LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype)
{
    ASSERT(lpValue);
    ASSERT(lppbyte);
    ASSERT(pdw);
    ASSERT(m_hKey != NULL);
    *pdw = 0;

    DWORD dwType;
    DWORD lResult = RegQueryValueEx(
        m_hKey,             // handle of key to query
        lpValue,            // address of name of value to query
        0,                  // reserved
        &dwType,            // address of buffer for value type
        0,                  // address of data buffer 
        pdw                 // address of data buffer size 
        );

    if (lResult == ERROR_SUCCESS)
    {
        ASSERT(dwType == dwDatatype || dwType == REG_EXPAND_SZ);

        if (0 == Allocate(*pdw))
            return ERROR_OUTOFMEMORY;

        lResult = RegQueryValueEx(
            m_hKey,                 // handle of key to query
            lpValue,                // address of name of value to query
            0,                      // reserved
            &dwType,                // address of buffer for value type
            m_pMemBlock,            // address of data buffer 
            pdw                     // address of data buffer size 
            ); 

        ASSERT (ERROR_MORE_DATA != lResult);
    
        if (lResult == ERROR_SUCCESS)
            *lppbyte = m_pMemBlock;
    }

    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
* Reads A string (REG_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
{
    return ReadReg(lpValue, (LPBYTE *)lppStr, pdw, REG_SZ);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegDWord(LPCTSTR lpValue, DWORD *pdw)
* Reads A string (REG_SZ) from the registry
* LPCTSTR lpValue value to be read.
* DWORD  *pdw  - address of dword in which the read dword returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegDWord(LPCTSTR lpValue, DWORD *pdw)
{
    ASSERT(pdw);

    DWORD dwSize;
    LPBYTE pByte;
    DWORD dwReturn = ReadReg(lpValue, &pByte, &dwSize, REG_DWORD);
    ASSERT(dwReturn != ERROR_SUCCESS || dwSize == sizeof(DWORD));

    if (dwReturn == ERROR_SUCCESS)
        *pdw = * LPDWORD(pByte);

    return dwReturn;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegMultiString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
* Reads A string (REG_MULTI_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegMultiString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
{
    return ReadReg(lpValue, (LPBYTE *)lppStr, pdw, REG_MULTI_SZ);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegBinary(LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw)
* Reads A string (REG_MULTI_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPBYTE *lppByte - address of LPBYTE in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it.
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegBinary(LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw)
{
    return ReadReg(lpValue, lppByte, pdw, REG_BINARY);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetFirstSubKey(LPTSTR *lppStr, DWORD *pdw)
* Reads a first subkey for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it.
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetFirstSubKey(LPTSTR *lppStr, DWORD *pdw)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    m_iEnumIndex = 0;

    return GetNextSubKey(lppStr, pdw);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetNextSubKey(LPTSTR *lppStr, DWORD *pdw
* Reads the next subkey for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy
* the buffer to immediately. caller must not use this buffer except for copying it.
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetNextSubKey(LPTSTR *lppStr, DWORD *pdw)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(m_hKey != NULL);
    ASSERT(m_iEnumIndex >= 0); // must call GetFirstSubKey first.

    *pdw = 1024;
    if (0 == Allocate(*pdw * sizeof(TCHAR)))
        return ERROR_NOT_ENOUGH_MEMORY;

    LONG lResult = RegEnumKeyEx(
        m_hKey,                     // handle of key to enumerate
        m_iEnumIndex,               // index of subkey to enumerate
        (LPTSTR)m_pMemBlock,        // address of buffer for subkey name
        pdw,                        // address for size of subkey buffer
        0,                          // reserved
        NULL,                       // address of buffer for class string
        NULL,                       // address for size of class buffer
        NULL                        // address for time key last written to
        );

    (*pdw)++;    // since null is not included in the size.
    if (ERROR_NO_MORE_ITEMS == lResult)
        return lResult;

    m_iEnumIndex++;

    if (lResult == ERROR_SUCCESS)
        *lppStr = (LPTSTR)m_pMemBlock;

    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetFirstValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
* Reads a first value for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* DWORD *pDataType - datatype of the value is returned in this one.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetFirstValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(pDataType);

    m_iEnumValueIndex = 0;
    return GetNextValue(lppStr, pdw, pDataType);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetNextValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
* Reads a next value for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy
* the buffer to immediately. caller must not use this buffer except for copying it.
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* DWORD *pDataType - datatype of the value is returned in this one.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetNextValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(pDataType);
    ASSERT(m_hKey != NULL);
    ASSERT(m_iEnumValueIndex >= 0); // must call GetFirstSubKey first.

    *pdw = 1024;
    if (0 == Allocate(*pdw * sizeof(TCHAR)))
        return ERROR_NOT_ENOUGH_MEMORY;

    LONG lResult = RegEnumValue(
        m_hKey,                     // handle of key to query
        m_iEnumValueIndex,          // index of value to query
        (LPTSTR)m_pMemBlock,        // address of buffer for value string
        pdw,                        // address for size of value buffer
        0,                          // reserved
        pDataType,                  // address of buffer for type code
        NULL,                       // address of buffer for value data    maks_todo : use this
        NULL                        // address for size of data buffer
        );

    (*pdw)++;    // since null is not included in the size.

    if (ERROR_NO_MORE_ITEMS == lResult)
        return lResult;


    m_iEnumValueIndex++;
    if (lResult == ERROR_SUCCESS)
        *lppStr = (LPTSTR)m_pMemBlock;
    
    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegString(LPCTSTR lpValueName, LPCTSTR lpStr)
* writes REG_SZ value into the registry
* LPCTSTR lpValueName - value name to be written to
* LPCTSTR lpStr - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegString(LPCTSTR lpValueName, LPCTSTR lpStr)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

    DWORD dwSize = (_tcslen(lpStr) + 1) * sizeof(TCHAR) / sizeof(BYTE);
    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for
        lpValueName,            // address of value to set
        0,                      // Reserved
        REG_SZ,                 // flag for value type
        (LPBYTE)lpStr,          // address of value data
        dwSize                  // size of value data
        );
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegMultiString(LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize)
* writes REG_MULTI_SZ value into the registry 
* LPCTSTR lpValueName - value name to be written to
* LPCTSTR lpStr - data to be written 
* DWORD   dwSize - size of data.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegMultiString(LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

#ifdef DBG
    
    // lets make sure that the given size is right.
    LPCTSTR lpTemp = lpStr;
    DWORD rightsize = 0;
    while (_tcslen(lpTemp) > 0)
    {
        rightsize  += _tcslen(lpTemp) + 1;
        lpTemp += _tcslen(lpTemp) + 1;
    }

    ASSERT(*lpTemp == 0);           // final NULL.
    rightsize++;                    // account for final terminating null

    rightsize *= sizeof(TCHAR) / sizeof(BYTE); // size must be in bytes.

    ASSERT(dwSize == rightsize);
    
#endif

    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_MULTI_SZ,           // flag for value type
        (LPBYTE)lpStr,          // address of value data 
        dwSize                  // size of value data 
        ); 
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegBinary (LPCTSTR lpValueName, LPBYTE lpData, DWORD dwSize)
* writes REG_BINARY value into the registry 
* LPCTSTR lpValueName - value name to be written to
* LPBYTE lpData - data to be written 
* DWORD   dwSize - size of data.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegBinary (LPCTSTR lpValueName, LPBYTE lpData, DWORD dwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpData);
	ASSERT(dwSize > 0);

    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_BINARY,           // flag for value type
        lpData,          // address of value data 
        dwSize                  // size of value data 
        ); 
}



/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegDWord(LPCTSTR lpValueName, DWORD dwValue)
* writes REG_DWORD value into the registry 
* LPCTSTR lpValueName - value name to be written to 
* LPCTSTR dwValue - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegDWord(LPCTSTR lpValueName, DWORD dwValue)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);

    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved
        REG_DWORD,              // flag for value type
        (LPBYTE)&dwValue,       // address of value data 
        sizeof(dwValue)         // size of value data 
        );
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ExistInMultiString  (LPCTSTR lpValueName, LPCTSTR lpStr, BOOL *pbExists)
* checks if given null terminated string exists in a multi_sz value
* LPCTSTR lpValueName - value name to be checked
* LPCTSTR lpCheckForStr - the value to be checked for 
* BOOL *pbExists - return. TRUE if exits.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
/*
DWORD CRegistry::ExistInMultiString  (LPCTSTR  lpValueName, LPCTSTR lpCheckForStr, BOOL *pbExists)
{
	ASSERT(m_hKey != NULL);     // call setkey before calling this function.
	ASSERT(lpValueName);
	ASSERT(lpCheckForStr);
	ASSERT(*lpCheckForStr);
	ASSERT(pbExists);




	DWORD dwError = ERROR_SUCCESS;
	*pbExists = FALSE;

    LPTSTR szValue;
	DWORD dwSize;
	dwError = ReadRegMultiString(lpValueName, &szValue, dwSize);
	if (ERROR_SUCCESS == dwError)
	{
        LPCTSTR pTemp = szValue;
        while(_tcslen(pTemp) > 0 )
        {
            if (_tcscmp(pTemp, lpCheckForStr) == 0)
            {
                *pbExists = TRUE;
                break;
            }

            pTemp += _tcslen(pTemp) + 1; // point to the next string within the multistring.
            if ( DWORD(pTemp - szSuiteValue) > (dwSize / sizeof(TCHAR)))
                break; // temporary pointer passes the size of the szSuiteValue something is wrong with szSuiteValue.
		}
	}

	return dwError;


    ASSERT(FALSE);
	return ERROR_CALL_NOT_IMPLEMENTED;

}
*/

/*--------------------------------------------------------------------------------------------------------
* DWORD AppendToMultiString (LPCTSTR lpValueName, LPCTSTR lpStr)
* appends given string to a multistring value
* LPCTSTR lpValueName - value name to be appended to
* LPCTSTR lpStr - the value to be appended
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::AppendToMultiString (LPCTSTR lpValueName, LPCTSTR lpStr)
{
	ASSERT(m_hKey != NULL);     // call setkey before calling this function.
	ASSERT(lpValueName);
	ASSERT(lpStr);
	ASSERT(*lpStr);

	return ERROR_CALL_NOT_IMPLEMENTED;

}

// copy the buffer immediately
DWORD CRegistry::GetSecurity(PSECURITY_DESCRIPTOR *ppSec, SECURITY_INFORMATION SecurityInformation, DWORD *pdwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(ppSec);
    ASSERT(pdwSize);
    DWORD dwError;

    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    *pdwSize = 0;   // we just want to get the right size during the first call.

    dwError = RegGetKeySecurity(
        m_hKey,                  // open handle of key to set
        SecurityInformation,     // descriptor contents
        &pSecurityDescriptor,    // address of descriptor for key
        pdwSize                  // address of size of buffer and descriptor
        );

    // this call can not succeed. as we have set the size = 0
    ASSERT(dwError != ERROR_SUCCESS);

    if (dwError != ERROR_INSUFFICIENT_BUFFER)
    {
        // something else has went wronng.
        // return the error code
        return dwError;
    }

    ASSERT(*pdwSize != 0);

    // now we have got the right size, allocate it.
    if (0 == Allocate(*pdwSize))
        return ERROR_OUTOFMEMORY;

    dwError = RegGetKeySecurity(
        m_hKey,                  // open handle of key to set
        SecurityInformation,     // descriptor contents
        m_pMemBlock,             // address of descriptor for key
        pdwSize                  // address of size of buffer and descriptor
        );

    ASSERT(dwError != ERROR_INSUFFICIENT_BUFFER);

    if (dwError == ERROR_SUCCESS)
        *ppSec = m_pMemBlock;

    return dwError;
           
}

DWORD CRegistry::SetSecurity(PSECURITY_DESCRIPTOR pSec, SECURITY_INFORMATION SecurityInformation)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    return RegSetKeySecurity(
        m_hKey,                 // open handle of key to set
        SecurityInformation,    // descriptor contents
        pSec                    // address of descriptor for key
        );
}


// this function will fail miserably if the source and destination overlap.
DWORD CRegistry::CopyTree(CRegistry &regSrc)
{
    DWORD dwSize;
    LPTSTR szKey;
    LPTSTR szValue;
	DWORD dwError;

    if (ERROR_SUCCESS == (dwError = regSrc.GetFirstSubKey(&szKey, &dwSize)))
    {
		
        do
        {
            CRegistry regSrcKey;
            CRegistry regDstKey;
            if (ERROR_SUCCESS == (dwError = regSrcKey.OpenKey(regSrc, szKey)))
			{
				
                if (ERROR_SUCCESS == (dwError = regDstKey.CreateKey(m_hKey, szKey)))
				{
					regDstKey.CopyTree(regSrcKey);
				}
			}
        }
        while (ERROR_SUCCESS == (dwError = regSrc.GetNextSubKey(&szKey, &dwSize)));

    }

    //
    // now copy values.
    //


    DWORD dwDataType;
    if (ERROR_SUCCESS == (dwError = regSrc.GetFirstValue(&szValue, &dwSize, &dwDataType)))
    {
        do
        {
            TCHAR *szValueName = new TCHAR[dwSize];
			if (!szValueName)
				break;

            _tcscpy(szValueName, szValue);

            LPBYTE pData;
            if (ERROR_SUCCESS == (dwError = regSrc.ReadReg(szValueName, &pData, &dwSize, dwDataType)))
            {
                dwError = RegSetValueEx(
                    m_hKey,                 // handle of key to set value for
                    szValueName,            // address of value to set
                    0,                      // Reserved
                    dwDataType,             // flag for value type
                    pData,                  // address of value data
                    dwSize                  // size of value data
                    );

            }
        }
        while (ERROR_SUCCESS == regSrc.GetNextValue(&szValue, &dwSize, &dwDataType));

    }

    return TRUE;

}

DWORD CRegistry::WriteRegExString(LPCTSTR lpValueName, LPCTSTR lpStr)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

    DWORD dwSize = (_tcslen(lpStr) + 1) * sizeof(TCHAR) / sizeof(BYTE);
    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for
        lpValueName,            // address of value to set
        0,                      // Reserved
        REG_EXPAND_SZ,          // flag for value type
        (LPBYTE)lpStr,          // address of value data
        dwSize                  // size of value data
        );

}

#ifdef _Maks_AutoTest_

//
// make sure that CRegistry does not support
// Copy constructor & assignment operator
//
void TestRegistry (CRegistry reg)
{
    CRegistry reg2 = reg;   // should get error for copy constructor
    CRegistry reg3(reg);     // should get error for copy constructor
    CRegistry reg4;
    reg4 = reg;             // should get error for = operator.
    TestRegistry(reg);       // should get error for copy construtor
}

#endif // _Maks_AutoTest_

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\service\logmsg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// LogMsg.cpp: implementation of the LogMsg class.
//
//////////////////////////////////////////////////////////////////////

#define _LOGMESSAGE_CPP_

// #include "stdafx.h"
#include <windows.h>
#include <tchar.h>
#include "..\dll\conv.h"
#include "stdio.h"
#include "time.h"
#include "LogMsg.h"
#include "assert.h"

#define ASSERT(cond) assert(cond)
// ;


DWORD TCharStringToAnsiString(const TCHAR *tsz ,char *asz);


// maks_todo: is there any standard file to be used for  logs.
//////////////////////////////////////////////////////////////////////
// constants
//////////////////////////////////////////////////////////////////////
const UINT        LOG_ENTRY_SIZE             = 1024;
const UINT        STAMP_SIZE                 = 1024;
LPCTSTR           UNINITIALIZED              = _T("uninitialized");


//////////////////////////////////////////////////////////////////////
// globals.
////////////////////////////////////////////////////////////////////////
LogMsg thelog(26);  // used by LOGMESSAGE macros.


//////////////////////////////////////////////////////////////////////
// Construction / destruction
////////////////////////////////////////////////////////////////////////
LogMsg::LogMsg(int value)
{
    m_temp = value;
    _tcscpy(m_szLogFile, UNINITIALIZED);
}

LogMsg::~LogMsg()
{
    LOGMESSAGE0(_T("********Terminating Log"));
}

/*--------------------------------------------------------------------------------------------------------
* DWORD LogMsg::Init(LPCTSTR szLogFile, LPCTSTR szLogModule)
* creates/opens the szLogFile for logging messages.
* must be called befour using the Log Function.
* -------------------------------------------------------------------------------------------------------*/
DWORD LogMsg::Init(LPCTSTR szLogFile, LPCTSTR szLogModule)
{
    USES_CONVERSION;
    ASSERT(szLogFile);
    ASSERT(szLogModule);

    // dont call this function twice.
    // maks_todo:why the hell is the constructor not getting called?
    // maks_todo:enable this assert.
    //ASSERT(_tcscmp(m_szLogFile, UNINITIALIZED) == 0);

    ASSERT(_tcslen(szLogFile) < MAX_PATH);
    ASSERT(_tcslen(szLogModule) < MAX_PATH);

    _tcscpy(m_szLogFile, szLogFile);
    _tcscpy(m_szLogModule, szLogModule);


    // open the log file
    HANDLE hfile = CreateFile(m_szLogFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        hfile = CreateFile(m_szLogFile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {

        // lets prepare for writing to the file.
        SetFilePointer(hfile, 0, NULL, FILE_END);
        DWORD  bytes;

        // get the current time/date stamp.
        TCHAR   time[STAMP_SIZE];
        TCHAR   date[STAMP_SIZE];
        TCHAR   output_unicode[LOG_ENTRY_SIZE];

        _tstrdate(date);
        _tstrtime(time);


        _stprintf(output_unicode, _T("\r\n\r\n*******Initializing Message Log:%s %s %s\r\n"), m_szLogModule, date, time);
        ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);


        // TCharStringToAnsiString(output_unicode, output);

        WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);


        // now write some more info about the version etc.
        OSVERSIONINFO OsV;
        OsV.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&OsV)== 0)
        {
            // get version failed.
            _stprintf(output_unicode, _T("GetVersionEx failed, ErrrorCode = %lu\r\n"), GetLastError());

            ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);

            WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);

        }
        else
        {
            //
            // ok we have the version info, write it out
            //

            _stprintf(output_unicode, _T("*******Version:Major=%lu, Minor=%lu, Build=%lu, PlatForm=%lu, CSDVer=%s, %s\r\n\r\n"),
                OsV.dwMajorVersion,
                OsV.dwMinorVersion,
                OsV.dwBuildNumber,
                OsV.dwPlatformId,
                OsV.szCSDVersion,
#ifdef DBG
                _T("Checked")
#else
                _T("Free")
#endif
                );

            ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);

            WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);
        }

        CloseHandle(hfile);
    }

    return GetLastError();
}


/*--------------------------------------------------------------------------------------------------------
* void log(TCHAR *fmt, ...)
* writes message to the log file. (LOGFILE)
* -------------------------------------------------------------------------------------------------------*/
DWORD LogMsg::Log(LPCTSTR file, int line, TCHAR *fmt, ...)
{

    USES_CONVERSION;
    ASSERT(file);
    ASSERT(fmt);
    ASSERT(_tcscmp(m_szLogFile, UNINITIALIZED) != 0);

     // write down file and line info into the buffer..
    TCHAR   fileline_unicode[LOG_ENTRY_SIZE];

    // file is actually full path to the file.
    ASSERT(_tcschr(file, '\\'));

    // we want to print only file name not full path
    UINT uiFileLen = _tcslen(file);
    while (uiFileLen && *(file + uiFileLen - 1) != '\\')
    {
        uiFileLen--;
    }
    ASSERT(uiFileLen);

    _stprintf(fileline_unicode, _T("%s(%d)"), (file+uiFileLen), line);



    // create the output string
    TCHAR  output_unicode[LOG_ENTRY_SIZE];
    va_list vaList;
    va_start(vaList, fmt);
    _vstprintf(output_unicode, fmt, vaList);
    va_end(vaList);

    ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);


    // open the log file
    HANDLE hfile = CreateFile(m_szLogFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);

        DWORD  bytes;
        const LPCSTR CRLF = "\r\n";
        WriteFile(hfile, T2A(fileline_unicode), _tcslen(fileline_unicode), &bytes, NULL);
        WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);
        WriteFile(hfile, CRLF, strlen(CRLF) * sizeof(char), &bytes, NULL);

        CloseHandle(hfile);
    }

    return GetLastError();
}

/*--------------------------------------------------------------------------------------------------------
* TCharStringToAnsiString(const TCHAR *tsz ,char *asz)
* converts the given TCHAR * to char *
* -------------------------------------------------------------------------------------------------------*/

DWORD TCharStringToAnsiString(const TCHAR *tsz ,char *asz)
{

    ASSERT(tsz && asz);

#ifdef UNICODE
    DWORD count;

    count = WideCharToMultiByte(CP_ACP,
                                0,
                                tsz,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!count || count > STAMP_SIZE)
        return count;

    return WideCharToMultiByte(CP_ACP,
                               0,
                               tsz,
                               -1,
                               asz,
                               count,
                               NULL,
                               NULL);
#else
    _tcscpy(asz, tsz);
    return _tcslen(asz);
#endif
}



// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( TSDiag )
EXTERN_PROXY_FILE( tsdiag )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( TSDiag ),
  REFERENCE_PROXY_FILE( tsdiag ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\nttype\nttype.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation



#include <windows.h>
#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>


int
#if !defined(_MIPS_) && !defined(_ALPHA_) && !defined(_PPC_)
_cdecl
#endif
main( int /* argc */, char ** /* argv */)
{

    OSVERSIONINFOEX osVersion;

    ZeroMemory(&osVersion, sizeof(OSVERSIONINFOEX));
    osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);



    if (GetVersionEx((LPOSVERSIONINFO )&osVersion))
    {


        cout << "Prodcut Type:" << endl;

        if (osVersion.wProductType == VER_NT_WORKSTATION)
        {
            cout << "VER_NT_WORKSTATION" << endl;

        }

        if (osVersion.wProductType == VER_NT_DOMAIN_CONTROLLER)
        {
            cout << "VER_NT_DOMAIN_CONTROLLER" << endl;

        }

        if (osVersion.wProductType == VER_NT_SERVER)
        {
            cout << "VER_NT_SERVER" << endl;

        }


        cout << "Suite:" << endl;
        if (osVersion.wSuiteMask & VER_SERVER_NT)
        {
            cout << "VER_SERVER_NT" << endl;

        }
        if (osVersion.wSuiteMask & VER_WORKSTATION_NT)
        {
            cout << "VER_WORKSTATION_NT" << endl;

        }
        if (osVersion.wSuiteMask & VER_SUITE_SMALLBUSINESS)
        {
            cout << "VER_SUITE_SMALLBUSINESS" << endl;

        }
        if (osVersion.wSuiteMask & VER_SUITE_ENTERPRISE)
        {
            cout << "VER_SUITE_ENTERPRISE" << endl;

        }
        if (osVersion.wSuiteMask & VER_SUITE_BACKOFFICE)
        {
            cout << "VER_SUITE_BACKOFFICE" << endl;

        }
        if (osVersion.wSuiteMask & VER_SUITE_COMMUNICATIONS)
        {
            cout << "VER_SUITE_COMMUNICATIONS" << endl;

        }
        if (osVersion.wSuiteMask & VER_SUITE_TERMINAL)
        {
            cout << "VER_SUITE_TERMINAL" << endl;

        }
        if (osVersion.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED)
        {
            cout << "VER_SUITE_SMALLBUSINESS_RESTRICTED" << endl;

        }
        if (osVersion.wSuiteMask & VER_SUITE_EMBEDDEDNT)
        {
            cout << "VER_SUITE_EMBEDDEDNT" << endl;

        }
        if (osVersion.wSuiteMask & VER_SUITE_DATACENTER)
        {
            cout << "VER_SUITE_DATACENTER" << endl;

        }
        if (osVersion.wSuiteMask & VER_SUITE_SINGLEUSERTS)
        {
            cout << "VER_SUITE_SINGLEUSERTS" << endl;

        }
        if (osVersion.wSuiteMask & VER_SUITE_PERSONAL)
        {
            cout << "VER_SUITE_PERSONAL" << endl;

        }
    }
    else
    {
        cout << "GetVersionEx failed, LastError = " << GetLastError() << endl;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\dlldatax.c ===
// wrapper for dlldata.c

#pragma warning( disable : 4206 )

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "TSDiag_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__60AB0CA8_CB88_4D79_90FA_1A1775D53249__INCLUDED_)
#define AFX_DLLDATAX_H__60AB0CA8_CB88_4D79_90FA_1A1775D53249__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__60AB0CA8_CB88_4D79_90FA_1A1775D53249__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\drdetect.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    drdetect

Abstract:

    Detect whether RDPDR was properly installed.

Environment:

    User mode

Author:

    Tadb

--*/

#include "stdafx.h"
#include <setupapi.h>

////////////////////////////////////////////////////////////
//
//  Internal Defines
//

#define RDPDRPNPID      _T("ROOT\\RDPDR")
#define RDPDRDEVICEID   TEXT("Root\\RDPDR\\0000")

const GUID GUID_DEVCLASS_SYSTEM =
{ 0x4d36e97dL, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } };


ULONG RDPDRINST_DetectInstall()
/*++

Routine Description:

    Return the number of RDPDR.SYS devices found.

Arguments:

    NA

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
{
    HDEVINFO            devInfoSet;
    SP_DEVINFO_DATA     deviceInfoData;
    DWORD               iLoop;
    BOOL                bMoreDevices;
    ULONG               count;
    TCHAR               pnpID[256];


    GUID *pGuid=(GUID *)&GUID_DEVCLASS_SYSTEM;

    //
    //  Get the set of all devices with the RDPDR PnP ID.
    //
    devInfoSet = SetupDiGetClassDevs(pGuid, NULL, NULL,
                                   DIGCF_PRESENT);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "Error getting RDPDR devices from PnP.  Error code:  %ld.",
                GetLastError());
        return 0;
    }

    // Get the first device.
    iLoop=0;
    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, iLoop, &deviceInfoData);

    // Get the details for all matching device interfaces.
    count = 0;
    while (bMoreDevices)
    {
        // Get the PnP ID for the device.
        if (!SetupDiGetDeviceRegistryProperty(devInfoSet, &deviceInfoData,
                                SPDRP_HARDWAREID, NULL, (BYTE *)pnpID,
                                sizeof(pnpID), NULL)) {
            fprintf(stderr, "Error fetching PnP ID in RDPDR device node remove.  Error code:  %ld.",
                        GetLastError());
        }

        // If the current device matches the RDPDR PNP ID
        if (!_tcscmp(pnpID, RDPDRPNPID)) {
            count++;
        }

        // Get the next one device interface.
        bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, ++iLoop, &deviceInfoData);
    }

    // Release the device info list.
    SetupDiDestroyDeviceInfoList(devInfoSet);

    return count;
}


//
//      Unit-Test
//
//void __cdecl main()
//{
//    ULONG count;
//    count = RDPDRINST_DetectInstall();
//    printf("Found %ld instance(s) of RDPDR.SYS.\n", count);
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\service\service.cpp ===
#include <nt.h>
#include <ntrtl.h>   // DbgPrint prototype
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winsvc.h>
#include <winsvcp.h>

#include <winuser.h>
#include <dbt.h>

#include <crtdbg.h>

#include <wtsapi32.h>
#include <tchar.h>

#include <logmsg.h>
//
// Definitions
//

#define MAKARP_LOG0(string)             \
        (VOID) DbgPrint(string);        \
        LOGMESSAGE0(string);

#define MAKARP_LOG1(string, var)        \
        (VOID) DbgPrint(string, var);    \
        LOGMESSAGE1(string, var);


#define MAKARP_LOG2(string, var1, var2) \
        (VOID) DbgPrint(string, var1, var2); \
            LOGMESSAGE2(string, var1, var2);


#define LOG0(string)                    \

#define LOG1(string, var)               \

#define LOG2(string, var1, var2)        \


//
// Test fix for bug #106110
//
// #define     FLOOD_PIPE
//

//
// Test fix for bug #120359
//
static const GUID GUID_NDIS_LAN_CLASS =
    {0xad498944,0x762f,0x11d0,{0x8d,0xcb,0x00,0xc0,0x4f,0xc3,0x35,0x8c}};


//
// Globals
//
SERVICE_STATUS          ssService;
SERVICE_STATUS_HANDLE   hssService;
HANDLE                  g_hEvent;


BOOL IsUserLoggedOn(DWORD dwSessionId)
{
    LPTSTR pBuffer = NULL;
    DWORD dwBytesReturned;

    if (WTSQuerySessionInformation(
          WTS_CURRENT_SERVER_HANDLE,
          dwSessionId,
          WTSUserName,
          &pBuffer,
          &dwBytesReturned
          ))
    {
        if (pBuffer)
        {
            MAKARP_LOG1("Logged on user is %s\n", pBuffer);
        }
        else
        {
            MAKARP_LOG0("Logged on user is NULL\n");
        }


    }
    else
    {
        MAKARP_LOG0("WTSQuerySessionInformation failed\n");
    }

    return TRUE;

}

void PrintNotification(DWORD dwEventType, PWTSSESSION_NOTIFICATION pConsoleNotification)
{
    TCHAR szString[1024];
    DWORD dwBytesReturned;
    LPTSTR pBuffer = NULL;
    int i = 0;


    i += sprintf(szString + i, "------------* Start Received console switch notification *-----------\n");

    switch (dwEventType)
    {
    case WTS_CONSOLE_CONNECT:
        i += sprintf(szString + i, "Event = WTS_CONSOLE_CONNECT\n");
        break;

    case WTS_CONSOLE_DISCONNECT:
        i += sprintf(szString + i, "Event = WTS_CONSOLE_DISCONNECT\n");
        break;

    case WTS_REMOTE_CONNECT:
        i += sprintf(szString + i, "Event = WTS_REMOTE_CONNECT\n");
        break;

    case WTS_REMOTE_DISCONNECT:
        i += sprintf(szString + i, "Event = WTS_REMOTE_DISCONNECT\n");
        break;

    case WTS_SESSION_LOGON:
        i += sprintf(szString + i, "Event = WTS_SESSION_LOGON\n");
        break;

    case WTS_SESSION_LOGOFF:
        i += sprintf(szString + i, "Event = WTS_SESSION_LOGOFF\n");
        break;


    default:
        ASSERT(WTS_CONSOLE_DISCONNECT == dwEventType); // ASSERT(FALSE);
        i += sprintf(szString + i, "Event = UNKNOWN\n");
        break;

    }

    if (WTSQuerySessionInformation(
          WTS_CURRENT_SERVER_HANDLE,
          pConsoleNotification->dwSessionId,
          WTSUserName,
          &pBuffer,
          &dwBytesReturned
          ))
    {
        if (pBuffer)
        {
            i += sprintf(szString + i, "Logged on user is %s\n", pBuffer);
        }
        else
        {
            i += sprintf(szString + i, "Logged on user is NULL\n");
        }


    }
    else
    {
        i += sprintf(szString + i, "WTSQuerySessionInformation failed\n");
    }

    WTSFreeMemory(pBuffer);

    i += sprintf(szString + i, "Size = %ld\n", pConsoleNotification->cbSize);
    i += sprintf(szString + i, "Session = %ld\n", pConsoleNotification->dwSessionId);
    i += sprintf(szString + i, "------------* End Received console switch notification *-----------\n");

    MAKARP_LOG1("%s", szString);
}


VOID WINAPI
ServiceStart(
    DWORD /*argc */,
    LPTSTR * /*argv*/
    );

DWORD WINAPI
ServiceCtrlHandler(
    DWORD   Opcode,
    DWORD   dwEventType,
    PVOID   EventData,
    PVOID   /*pData*/ )
{

    PWTSSESSION_NOTIFICATION pConsoleNotification;
    switch(Opcode)
    {
        case SERVICE_CONTROL_SESSIONCHANGE:
            pConsoleNotification = (PWTSSESSION_NOTIFICATION) EventData;
            PrintNotification(dwEventType, pConsoleNotification);
            break;

        case SERVICE_CONTROL_PAUSE:
            ssService.dwCurrentState = SERVICE_PAUSED;
            LOG0("Service paused\n");
            break;

        case SERVICE_CONTROL_CONTINUE:
            ssService.dwCurrentState = SERVICE_RUNNING;
            LOG0("Service continuing\n");
            break;

        case SERVICE_CONTROL_SHUTDOWN:
            LOG0("Shutdown command received\n");

            //
            // Fall through to STOP case
            //

        case SERVICE_CONTROL_STOP:
            ssService.dwWin32ExitCode = 0;
            ssService.dwCurrentState  = SERVICE_STOP_PENDING;
            ssService.dwCheckPoint    = 0;
            ssService.dwWaitHint      = 0;
            break;

        case SERVICE_CONTROL_INTERROGATE:
            LOG0("Service interrogated\n");
            break;

        case 251:
        {
            DWORD  dwError;
            DWORD  dwTest = 0xabcdefab;

            //
            // Try a bad address
            //
            dwError = I_ScSendTSMessage(SERVICE_CONTROL_SESSIONCHANGE,
                                        0,
                                        0,
                                        NULL);

            LOG1("I_ScSendTSMessage with NULL pointer returned %d\n", dwError);


            //
            // Try a bad control
            //
            dwError = I_ScSendTSMessage(SERVICE_CONTROL_STOP,
                                        0,
                                        sizeof(DWORD),
                                        (LPBYTE) &dwTest);

            LOG1("I_ScSendTSMessage for SERVICE_CONTROL_STOP returned %d\n", dwError);

            //
            // Now try for real
            //
            dwError = I_ScSendTSMessage(SERVICE_CONTROL_SESSIONCHANGE,
                                        0,
                                        sizeof(DWORD),
                                        (LPBYTE) &dwTest);

            LOG1("I_ScSendTSMessage (real call) returned %d\n", dwError);

            break;
        }

        case 252:
        {
            DEV_BROADCAST_DEVICEINTERFACE dbdPnpFilter;

            //
            // Test fix for bug #120359
            //
            ssService.dwCurrentState = SERVICE_STOPPED;

            //
            // Eventlog's SERVICE_STATUS_HANDLE when I checked
            //
            if (!SetServiceStatus((SERVICE_STATUS_HANDLE)0x96df8, &ssService))
            {
                LOG1("Fix works -- SetServiceStatus error %ld\n", GetLastError());
            }
            else
            {
                LOG0("ERROR -- SetServiceStatus call succeeded!\n");
            }

            //
            // Eventlog's LPSERVICE_RECORD when I checked
            //
            if (!SetServiceStatus((SERVICE_STATUS_HANDLE)0x4844e8, &ssService))
            {
                LOG1("Fix works -- SetServiceStatus error %ld\n", GetLastError());
            }
            else
            {
                LOG0("ERROR -- SetServiceStatus call succeeded!\n");
            }

            //
            // SERVICE_STATUS_HANDLE again
            //

            ZeroMemory (&dbdPnpFilter, sizeof(dbdPnpFilter));
            dbdPnpFilter.dbcc_size         = sizeof(dbdPnpFilter);
            dbdPnpFilter.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
            dbdPnpFilter.dbcc_classguid    = GUID_NDIS_LAN_CLASS;

            if (!RegisterDeviceNotification((SERVICE_STATUS_HANDLE)0x96df8,
                                            &dbdPnpFilter,
                                            DEVICE_NOTIFY_SERVICE_HANDLE))
            {
                LOG1("Fix works -- RegisterDeviceNotification error %ld\n", GetLastError());
            }
            else
            {
                LOG0("ERROR -- RegisterDeviceNotification call succeeded!\n");
            }

            ssService.dwCurrentState = SERVICE_RUNNING;
            break;
        }

        case 253:
        {
            //
            // Test fix for bug #36395.  Make sure that we inherited the
            // environment block of the user, not the system.  NOTE this
            // assumes the service is running in an account AND the
            // variable we're looking for is in the user's environment.
            //

            CHAR    cTemp[1];
            /*DWORD   dwCount = */ GetEnvironmentVariable("User_specific_variable",
                                                     cTemp,
                                                     sizeof(cTemp));

            LOG1("GetEnvironmentVariable on User_specific_variable %ws\n",
                 (dwCount == 0 ? L"FAILED!" : L"succeeded"));

            break;
        }

        case 254:
        {
            //
            // Test client-side API for #120359 fix
            //
            WCHAR                  wszServiceName[256 + 1];
            DWORD                  dwError;

            dwError = I_ScPnPGetServiceName(hssService, wszServiceName, 256);

            if (dwError == NO_ERROR)
            {
                LOG0("I_ScPnPGetServiceName succeeded for valid handle\n");
                LOG1("ServiceName is %ws\n", wszServiceName);
            }
            else
            {
                LOG0("I_ScPnPGetServiceName failed for valid handle!\n");
                LOG1("Error was %d\n", dwError);
            }

            dwError = I_ScPnPGetServiceName(NULL, wszServiceName, 256);

            if (dwError == NO_ERROR)
            {
                LOG0("I_ScPnPGetServiceName succeeded for NULL handle!\n");
                LOG1("ServiceName is %ws\n", wszServiceName);
            }
            else
            {
                LOG0("I_ScPnPGetServiceName failed for NULL handle!\n");
                LOG1("Error was %d\n", dwError);
            }

            break;
        }

        case 255:

            //
            // Print controls to the debugger
            //
            LOG0("Controls supported:\n");
            LOG0("\t251:\tTry calling I_ScSendTSMessage\n");
            LOG0("\t252:\tTry calling SetServiceStatus with a bogus status handle\n");
            LOG0("\t253:\tCheck service environment for %%User_specific_variable%%\n");
            LOG0("\t254:\tTest I_ScPnPGetServiceName on valid and invalid handles\n");
            break;

        default:
            LOG1("Unrecognized opcode %ld\n", Opcode);
    }

    if (!SetServiceStatus(hssService, &ssService))
    {
        LOG1("SetServiceStatus error %ld\n", GetLastError());
    }

    if (Opcode == SERVICE_CONTROL_STOP || Opcode == SERVICE_CONTROL_SHUTDOWN)
    {
        SetEvent(g_hEvent);
    }

    return NO_ERROR;
}


VOID WINAPI
ServiceStart(
    DWORD  /*argc */,
    LPTSTR * /*argv*/
    )
{

    LOGMESSAGEINIT(_T("c:\\temp\\consrv.log"), _T("consrv"));
    g_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (g_hEvent == NULL)
    {
        LOG1("CreateEvent error = %d\n", GetLastError());
        return;
    }

    ssService.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    ssService.dwCurrentState            = SERVICE_START_PENDING;
    ssService.dwControlsAccepted        = SERVICE_ACCEPT_STOP |
                                            SERVICE_ACCEPT_SHUTDOWN |
                                            SERVICE_ACCEPT_POWEREVENT |
                                            SERVICE_ACCEPT_SESSIONCHANGE;
    ssService.dwWin32ExitCode           = 0;
    ssService.dwServiceSpecificExitCode = 0;
    ssService.dwCheckPoint              = 0;
    ssService.dwWaitHint                = 0;

    hssService = RegisterServiceCtrlHandlerEx(TEXT("simservice"),
                                              ServiceCtrlHandler,
                                              (LPVOID) 0xdeadbeef);

    if (hssService == (SERVICE_STATUS_HANDLE)0)
    {
        LOG1("RegisterServiceCtrlHandler failed %d\n", GetLastError());
        return;
    }

    //
    // Initialization complete - report running status.
    //
    ssService.dwCurrentState       = SERVICE_RUNNING;
    ssService.dwCheckPoint         = 0;
    ssService.dwWaitHint           = 0;

    LOG0("Initialized and running\n");
    LOG1("PID is %d\n", GetCurrentProcessId());
    LOG1("TID is %d\n", GetCurrentThreadId());

    if (!SetServiceStatus (hssService, &ssService))
    {
        LOG1("SetServiceStatus error %ld\n", GetLastError());
    }

    WaitForSingleObject(g_hEvent, INFINITE);

    ssService.dwCurrentState       = SERVICE_STOPPED;
    ssService.dwCheckPoint         = 0;
    ssService.dwWaitHint           = 0;

    if (!SetServiceStatus (hssService, &ssService))
    {
        LOG1("SetServiceStatus error %ld\n", GetLastError());
    }

    LOG0("Returning the Main Thread\n");

    return;
}


int __cdecl main( int argc, char *argv[])
{
    if (argc == 2 && _stricmp(argv[1], "install") == 0)
    {
        SC_HANDLE hSCMgr = OpenSCManager (NULL, NULL, SC_MANAGER_CREATE_SERVICE);
        if (hSCMgr)
        {
            SC_HANDLE hService = CreateService(
              hSCMgr,                       // handle to SCM database
              "ConSrvName",                 // name of service to start
              "ConSrvDisplayName",          // display name
              SERVICE_ALL_ACCESS,           // type of access to service
              SERVICE_WIN32_OWN_PROCESS,    // type of service
              SERVICE_DEMAND_START,         // when to start service
              SERVICE_ERROR_IGNORE,         // severity of service failure
              "d:\\winnt\\system32\\consrv.exe",         // name of binary file
              NULL,                         // name of load ordering group
              NULL,                         // tag identifier
              NULL,                         // array of dependency names
              NULL,                         // account name
              NULL                          // account password
            );

            if (hService)
            {
                MAKARP_LOG0("Service Installed Ok.\n");
            }
            else
            {
                MAKARP_LOG1("CreateService failed, error = %ld", GetLastError());
            }

        }
        else
        {
            MAKARP_LOG1("OpenSCManager failed, error %ld\n", GetLastError());

        }


    }
    else
    {
        SERVICE_TABLE_ENTRY   DispatchTable[] =
        {
            { TEXT("simservice"),     ServiceStart    },
            { NULL,                   NULL            }
        };

    #ifdef  FLOOD_PIPE

        LOG1("Service PID is %d\n", GetCurrentProcessId());
        LOG0("Sleeping for 20 seconds\n");

        Sleep(20000);

    #endif  // FLOOD_PIPE

        if (!StartServiceCtrlDispatcher(DispatchTable))
        {
            LOG1("StartServiceCtrlDispatcher error = %d\n", GetLastError());
        }

        return 0;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\event.cpp ===
#include "stdafx.h"
// #include "winbase.h"

#define MAX_INSERT_STRS     5

TCHAR *aszTSEventSources[] = { _T("TermService"), _T("TermDD"), _T("TermServDevices") };

bool ExtractEvents();
bool ExtractAllTSEvents()
{
    cout << endl;
    return ExtractEvents ();
}

bool ExtractEvents ()
{
    USES_CONVERSION;
    bool bFoundEvents = false;



    HANDLE hEventLog = OpenEventLog(NULL, _T("System"));
    if (hEventLog)
    {

        const DWORD dwBytesToRead =  1024*10;

        char *pBuff = new char[dwBytesToRead];
        if (pBuff)
        {
            DWORD dwBytesRead, dwBytesNeeded;

            while (ReadEventLog(hEventLog,
                        EVENTLOG_BACKWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                        0,
                        PVOID(pBuff),
                        dwBytesToRead,
                        &dwBytesRead,
                        &dwBytesNeeded))
            {
                if (dwBytesRead == 0)
                    break;

                for (PEVENTLOGRECORD pEventLogRecord = ( PEVENTLOGRECORD ) pBuff;
                    PCHAR(pEventLogRecord) + pEventLogRecord->Length < pBuff + dwBytesRead;
                    pEventLogRecord = (EVENTLOGRECORD *)(PCHAR(pEventLogRecord) + pEventLogRecord->Length)
                    )
                {
                    LPCTSTR szSource = LPCTSTR(PBYTE(pEventLogRecord) + sizeof(EVENTLOGRECORD));


                    //
                    // check if event source is among interesting ones.
                    //

                    LPCTSTR szEventSource = NULL;
                    for (int i = 0; i < (sizeof(aszTSEventSources) / sizeof(aszTSEventSources[0])); i++)
                    {
                        if (_tcsicmp(szSource, aszTSEventSources[i]) == 0)
                            szEventSource = aszTSEventSources[i];
                    }

                    if (!szEventSource)
                        continue;


                    //
                    // prepare the array of insert strings for FormatMessage - the
                    // insert strings are in the log entry.
                    //
                    char *aInsertStrings[MAX_INSERT_STRS];

                    char *p = (char *) ((LPBYTE) pEventLogRecord + pEventLogRecord->StringOffset);
                    for (i = 0; i < pEventLogRecord->NumStrings && i < MAX_INSERT_STRS; i++)
                    {
                        aInsertStrings[i] = p;
                        p += strlen(p) + 1;     // point to next string
                    }



                    //
                    // Get the binaries to look message in from registry.
                    //

                    TCHAR szSourceKey[1024];
                    _tcscpy(szSourceKey, _T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\"));
                    _tcscat(szSourceKey, szEventSource);

                    CRegistry oReg;
                    TCHAR szSourcePath[MAX_PATH];

                    if (oReg.OpenKey(HKEY_LOCAL_MACHINE, szSourceKey, KEY_READ) == ERROR_SUCCESS)
                    {
                        LPTSTR str;
                        DWORD dwSize;
                        if (ERROR_SUCCESS == oReg.ReadRegString(_T("EventMessageFile"), &str, &dwSize))
                        {

                            ExpandEnvironmentStrings(str, szSourcePath, MAX_PATH);
                        }
                        else
                        {
                            cout << "       Error Reading Registry (" << T2A(szSourceKey) << ")/(EventMessageFiles)" << endl;
                            continue;
                        }

                    }
                    else
                    {
                        cout << "       Error Reading Registry (" << T2A(szSourceKey) << endl;
                        continue;
                    }

                    //
                    // Binary String in registry could contain multipal binaries seperated by ;
                    //

                    TCHAR *szModule;
                    szModule = _tcstok(szSourcePath, _T(";"));

                    //
                    // for each binary found
                    //

                    DWORD dwBytesTransfered = 0;
                    do
                    {
                        HINSTANCE hModule = LoadLibrary(szModule);

                        TCHAR szMessage[1024];
                        dwBytesTransfered = FormatMessage(
                                            FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                            hModule,
                                            pEventLogRecord->EventID,
                                            0,
                                            szMessage,
                                            1024,
					    (va_list *)aInsertStrings);

                        if (dwBytesTransfered)
                        {
                            bFoundEvents = true;
                            TCHAR szTimeString[512];
                            _tcsftime(szTimeString, 512, _T("%c"), localtime( (const time_t *)&pEventLogRecord->TimeGenerated ));
                            cout <<  "       " << T2A(szTimeString) << ": ( " << T2A(szEventSource) << " ) : " << T2A(szMessage);
                        }
                        else
                        {
                            cout << "       FormatMessage Failed. lasterror = " << GetLastError() << endl;
                        }

                        szModule = _tcstok(NULL, _T(";"));

                    }
                    while (!dwBytesTransfered && szModule);

                }


            }

        }

    }
    else
    {
        cout << "       Failed to Open Event log." << endl;
        return false;
    }

    return bFoundEvents;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\ping.cpp ===
// ping.cpp
#include "stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <snmp.h>
#include <winsock2.h>

#include "llinfo.h"
//#include "tcpcmd.h"
#include "ipexport.h"
#include "icmpapi.h"
//#include "nlstxt.h"
#include "Icmpapi.h"

#include "tstst.h"
#include "testdata.h"

unsigned long get_pingee(char *ahstr, char **hstr, int *was_inaddr, int dnsreq)
{
    struct hostent *hostp = NULL;
    long            inaddr;

    if ( strcmp( ahstr, "255.255.255.255" ) == 0 ) {
        return(0L);
    }

    if ((inaddr = inet_addr(ahstr)) == -1L) {
        hostp = gethostbyname(ahstr);
        if (hostp) {
            /*
             * If we find a host entry, set up the internet address
             */
            inaddr = *(long *)hostp->h_addr;
            *was_inaddr = 0;
        } else {
            // Neither dotted, not name.
            return(0L);
        }

    } else {
        // Is dotted.
        *was_inaddr = 1;
        if (dnsreq == 1) {
            hostp = gethostbyaddr((char *)&inaddr,sizeof(inaddr),AF_INET);
        }
    }

    *hstr = hostp ? hostp->h_name : (char *)NULL;
    return(inaddr);
}

bool CanPing ()
{
	if (!CTSTestData::GetMachineName())
		return true;

	USES_CONVERSION;
	const Timeout = 4000L;

	WSADATA WsaData;
    if (WSAStartup( 0x0101, &WsaData)) 
	{
		return false;
    }

	HANDLE  IcmpHandle;
	IcmpHandle = IcmpCreateFile();
	if (IcmpHandle == INVALID_HANDLE_VALUE)
	{
		return false;
	}
	
	char    *hostname = NULL;
	int     was_inaddr;
	int     dnsreq = 0;
	IPAddr  address = 0;
	address = get_pingee(T2A(CTSTestData::GetMachineName()), &hostname, &was_inaddr, dnsreq);
	if ( !address || (address == INADDR_NONE) ) 
	{
		return false;
	}

	const SendSize = 32;
	const RecvSize = 0x2000 - 8;
	char *SendBuffer = (char *)LocalAlloc(LMEM_FIXED, SendSize);
	char *RcvBuffer = (char *)LocalAlloc(LMEM_FIXED, RecvSize);
	if (!RcvBuffer || !SendBuffer)
	{
		if (RcvBuffer)
			LocalFree(RcvBuffer);

		if (SendBuffer)
			LocalFree(SendBuffer);

		return false;
	}
	
	IP_OPTION_INFORMATION SendOpts;
    SendOpts.OptionsData = NULL;
    SendOpts.OptionsSize = 0;
    SendOpts.Ttl = 128;
    SendOpts.Tos = 0;
    SendOpts.Flags = 0;

    if (IcmpSendEcho2(IcmpHandle,
                     0,
                     NULL,
                     NULL,
                     address,
                     SendBuffer,
                     (unsigned short) SendSize,
                     &SendOpts,
                     RcvBuffer,
                     RecvSize,
                     Timeout) == 0) 
	{
		return false;
	}

	IcmpCloseHandle(IcmpHandle);
	LocalFree(SendBuffer);
	LocalFree(RcvBuffer);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\stdafx.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\stdafx.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Module Name:
 *
 *      hydraoc.h
 *
 *  Abstract:
 *
 *      Common Header file for the HydraOC Component.
 *      HydraOc Component is an optional component which installs Termainal Server (Hydra)
 *
 *  Author:
 *
 *
 *  Environment:
 *
 *    User Mode
 */

#ifndef _stdafx_h_
#define _stdafx_h_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <devguid.h>
#include <initguid.h>
#include <objbase.h>
#include <tchar.h>
#include <time.h>
#include <stdio.h>
#include <setupapi.h>
#include <prsht.h>
#include <loadperf.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commdlg.h>
#include <lm.h>
#include <lmerr.h>
#include <lmserver.h>
#include <iostream.h>
#include <fstream.h>
#include <stdlib.h>
#include <string.h>
#include <clusapi.h>        // for GetNodeClusterState
#include <malloc.h>
#include <stddef.h>
#include <wincrypt.h>
#include <imagehlp.h>


#include <coguid.h>
#pragma message ("*** Including comdef.h ")
#include <comdef.h>
#pragma message ("*** Including atlbase.h ")
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#pragma message ("*** Including atlcom.h ")

#include <atlcom.h>
#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>


#include "Registry.h"       // CRegistry
#include "logmsg.h"


#define AssertFalse() ASSERT(FALSE)
#define VERIFY(x)     RTL_VERIFY(x)
#pragma message ("*** done with stdaf.h ")

#endif // _stdafx_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tsdiag.rc
//
#define IDS_PROJNAME                    100
			
#define IDS_MACHINENAME					101
#define IDS_MACHINENAME_FAILED					201
#define IDS_DOMAINNAME					102
#define IDS_DOMAINNAME_FAILED					202
#define IDS_IP_ADDRESS					103
#define IDS_IP_ADDRESS_FAILED					203
#define IDS_PRODUCTTYPE					104
#define IDS_PRODUCTTYPE_FAILED					204
#define IDS_PRODUCTSUITE				105
#define IDS_PRODUCTSUITE_FAILED				205
#define IDS_TSVERSION					106
#define IDS_TSVERSION_FAILED					206
#define IDS_ISSERVER					107
#define IDS_ISSERVER_FAILED					207
#define IDS_CLIENT_VERSION				108
#define IDS_CLIENT_VERSION_FAILED				208
#define IDS_SESSION_USERNAME			109
#define IDS_SESSION_USERNAME_FAILED			209
#define IDS_IS_TSOCLOG_PRESENT			110
#define IDS_IS_TSOCLOG_PRESENT_FAILED			210
#define IDS_DID_SETUP_FINISH			111
#define IDS_DID_SETUP_FINISH_FAILED			211
#define IDS_CLUSTERING_INSTALLED		112
#define IDS_CLUSTERING_INSTALLED_FAILED		212
#define IDS_IS_TSPRODUCT				113
#define IDS_IS_TSPRODUCT_FAILED				213
#define IDS_DID_OCM_INSTALL_TS			114
#define IDS_DID_OCM_INSTALL_TS_FAILED			214
#define IDS_IS_TS_ENABLED				115
#define IDS_IS_TS_ENABLED_FAILED				215
#define IDS_IS_KERNEL_TSENABLED			116
#define IDS_IS_KERNEL_TSENABLED_FAILED			216
#define IDS_IS_TSREGISTRY_OK			117
#define IDS_IS_TSREGISTRY_OK_FAILED			217
#define IDS_WINSTATIONS_OK				118
#define IDS_WINSTATIONS_OK_FAILED				218
#define IDS_IS_TERMSRV_RUNNING			119
#define IDS_IS_TERMSRV_RUNNING_FAILED			219
#define IDS_IS_TS_STARTBIT_OK			120
#define IDS_IS_TS_STARTBIT_OK_FAILED			220
#define IDS_IS_TS_IN_SYSTEM_CONTEXT		121
#define IDS_IS_TS_IN_SYSTEM_CONTEXT_FAILED		221
#define IDS_IS_LISTNER_PRESENT			122
#define IDS_IS_LISTNER_PRESENT_FAILED			222
#define IDS_REMOTE_CONNECTION_GP		123
#define IDS_REMOTE_CONNECTION_GP_FAILED		223
#define IDS_REMOTE_CONNECTION_LOCAL		124
#define IDS_REMOTE_CONNECTION_LOCAL_FAILED		224
#define IDS_RDPDR_INSTALLED				125
#define IDS_RDPDR_INSTALLED_FAILED				225
#define IDS_RDPNP_INSTALLED				126
#define IDS_RDPNP_INSTALLED_FAILED				226
#define IDS_MULTIPAL_CONNECTION_ALLOWED	127
#define IDS_MULTIPAL_CONNECTION_ALLOWED_FAILED	227
#define IDS_LOGON_UI					128
#define IDS_LOGON_UI_FAILED					228
#define IDS_TS_MODE						129
#define IDS_TS_MODE_FAILED						229
#define IDS_IS_MODE_REGISTRYOK			130
#define IDS_IS_MODE_REGISTRYOK_FAILED			230
#define IDS_PERM_MODE					131
#define IDS_PERM_MODE_FAILED					231
#define IDS_STACK_BINARIES_SIGNED		132
#define IDS_STACK_BINARIES_SIGNED_FAILED		232
#define IDS_ENCRYPTION_LEVEL			133
#define IDS_ENCRYPTION_LEVEL_FAILED			233
#define IDS_IS_BETA_SYSTEM				134
#define IDS_IS_BETA_SYSTEM_FAILED				234
#define IDS_GRACE_PERIOD_OK				135
#define IDS_GRACE_PERIOD_OK_FAILED				235
#define IDS_CLIENT_SUPPORT_AUDIO		136
#define IDS_CLIENT_SUPPORT_AUDIO_FAILED		236
#define IDS_CLIENT_SUPPORT_PRINTER		137
#define IDS_CLIENT_SUPPORT_PRINTER_FAILED		237
#define IDS_CLIENT_SUPPORT_FILE			138
#define IDS_CLIENT_SUPPORT_FILE_FAILED			238
#define IDS_CLIENT_SUPPORT_CLIPBOARD	139
#define IDS_CLIENT_SUPPORT_CLIPBOARD_FAILED	239
#define IDS_TERMSRV_CONFIG_PRINTER		140
#define IDS_TERMSRV_CONFIG_PRINTER_FAILED		240
#define IDS_TERMSRV_CONFIG_AUDIO		141
#define IDS_TERMSRV_CONFIG_AUDIO_FAILED		241
#define IDS_TERMSRV_CONFIG_COM			142
#define IDS_TERMSRV_CONFIG_COM_FAILED			242
#define IDS_TERMSRV_CONFIG_CLIPBOARD	143
#define IDS_TERMSRV_CONFIG_CLIPBOARD_FAILED	243
#define IDS_TERMSRV_CONFIG_FILE			145
#define IDS_TERMSRV_CONFIG_FILE_FAILED			245
#define IDS_TERMSRV_CONFIG_LPT			146
#define IDS_TERMSRV_CONFIG_LPT_FAILED			246
#define IDS_REMOTELOGON_ENABLED			147
#define IDS_REMOTELOGON_ENABLED_FAILED			148

#define IDS_TERMSRV_CLIENT_AUDIO_ENABLED        149
#define IDS_TERMSRV_CLIENT_AUDIO_ENABLED_FAILED 150
#define IDS_TERMSRV_CLIENT_AUDIO_SETTINGS       151
#define IDS_TERMSRV_CLIENT_AUDIO_SETTINGS_FAILED 152

#define IDR_TSDIAGNOSIS                 101
#define IDD_DIALOG1                     501

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\suite.h ===
// Suite.h: interface for the CSuite class.
//
//////////////////////////////////////////////////////////////////////
#include "test.h"

#if !defined(AFX_SUITE_H__F1A2E086_3DAE_4F83_ABEA_BF59D1571439__INCLUDED_)
#define AFX_SUITE_H__F1A2E086_3DAE_4F83_ABEA_BF59D1571439__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class ATL_NO_VTABLE CSuite : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CTest, &CLSID_TSDiagnosis>,
	public IDispatchImpl<ITestSuite, &IID_ITestSuite, &LIBID_TSDIAGLib>

{
public:
	CSuite();
	virtual ~CSuite();

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSuite)
	COM_INTERFACE_ENTRY(ITestSuite)
	COM_INTERFACE_ENTRY2(IDispatch, ITest)
END_COM_MAP()

// ITestSuite
public:
		STDMETHOD(get_Name)(/*[out, retval]*/ BSTR  *pVal);
		STDMETHOD(get_Description)(/*[out, retval]*/ BSTR  *pVal);
		STDMETHOD(get_IsApplicable)(/*[out, retval]*/ BOOL *pVal);
		STDMETHOD(get_WhyNotApplicable)(/*[out, retval]*/ BSTR  *pVal);
		
		STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
		STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *pVal);
		STDMETHOD(get_Item)(/*[in]*/ VARIANT Index, /*[out, retval]*/ VARIANT *pVal);

		void SetSuiteIndex (DWORD dwSuite);

private:
	
	DWORD m_dwSuiteIndex;
	void SetInvalidSuiteIndex() {m_dwSuiteIndex = 0xffffffff;};
	bool IsValid() const		{return m_dwSuiteIndex != 0xffffffff;};
	bool GetTest(const VARIANT &Index, DWORD dwSuiteIndex, PTVerificationTest *ppTest);

	
};

#endif // !defined(AFX_SUITE_H__F1A2E086_3DAE_4F83_ABEA_BF59D1571439__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\suites.h ===
// Suites.h: interface for the CSuites class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SUITES_H__50063540_1265_4B9D_AB5E_579294044F0B__INCLUDED_)
#define AFX_SUITES_H__50063540_1265_4B9D_AB5E_579294044F0B__INCLUDED_

#include "resource.h"       // main symbols
#include "testdata.h"		// for CTSTestData 


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class ATL_NO_VTABLE CSuites : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CTest, &CLSID_TSDiagnosis>,
	public IDispatchImpl<ITestSuites, &IID_ITestSuites, &LIBID_TSDIAGLib>

{
public:
	CSuites();
	virtual ~CSuites();


DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSuites)
	COM_INTERFACE_ENTRY(ITestSuites)
	COM_INTERFACE_ENTRY2(IDispatch, ITestSuites)
END_COM_MAP()

// ITestSuites
public:
		STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
		STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *pVal);
		STDMETHOD(get_Item)(/*[in]*/ VARIANT Index, /*[out, retval]*/ VARIANT *pVal);

private:

	static bool SuiteIndexFromVarient(const VARIANT &pIndex, DWORD *pdwIndex);
	// our data and private functions, declared here.
};

#endif // !defined(AFX_SUITES_H__50063540_1265_4B9D_AB5E_579294044F0B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\suite.cpp ===
// Suite.cpp: implementation of the CSuite class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TSDiag.h"

#include "Suite.h"

#include "testdata.h"
#include "test.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////



CSuite::CSuite()
{
	SetInvalidSuiteIndex();
}

CSuite::~CSuite()
{

}


void CSuite::SetSuiteIndex (DWORD dwSuite)
{
	ASSERT(GlobalTestData.GetSuiteCount() > dwSuite);
	m_dwSuiteIndex = dwSuite;
}

STDMETHODIMP CSuite::get_Name(BSTR  *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	bstr_t bstr = GlobalTestData.GetSuiteName(m_dwSuiteIndex);
	*pVal = bstr.copy();
	return S_OK;
}

STDMETHODIMP CSuite::get_Description(BSTR  *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}
	
	bstr_t bstr = GlobalTestData.GetSuiteName(m_dwSuiteIndex);
	*pVal = bstr.copy();

	return E_NOTIMPL;
}

STDMETHODIMP CSuite::get_IsApplicable(BOOL *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	*pVal = GlobalTestData.CanExecuteSuite(m_dwSuiteIndex);
	return S_OK;
}

STDMETHODIMP CSuite::get_WhyNotApplicable(BSTR  *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	if (GlobalTestData.CanExecuteSuite(m_dwSuiteIndex))
	{
		return CO_E_NOTCONSTRUCTED;
	}

	bstr_t bstr = GlobalTestData.GetSuiteErrorText(m_dwSuiteIndex);
	*pVal = bstr.copy();

	return S_OK;
}

STDMETHODIMP CSuite::get_Count(long *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	*pVal = GlobalTestData.GetTestCount(m_dwSuiteIndex);

	return S_OK;
}

STDMETHODIMP CSuite::get__NewEnum(LPUNKNOWN *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	return E_NOTIMPL;
}

STDMETHODIMP CSuite::get_Item(VARIANT Index, VARIANT *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	CComObject<CTest> *pTest;
	
	HRESULT hr = CComObject<CTest>::CreateInstance(&pTest);
	if (FAILED(hr))
	{
		return hr;
	}

	PTVerificationTest ptheTest;
	if (!GetTest(Index, m_dwSuiteIndex, &ptheTest))
	{
		return E_INVALIDARG;
	}
	
	// initialize test object;
	pTest->SetTest(ptheTest);
	IDispatch* pDisp = NULL;

	hr = pTest->QueryInterface(&pDisp);
	if (SUCCEEDED(hr))
	{
		pVal->vt = VT_DISPATCH;
		pVal->pdispVal = pDisp;

		// if we need to initialize our Suites object, it should be done here.
	}
	else
	{
		delete pTest;
	}

	return hr;
}


bool CSuite::GetTest(const VARIANT &Index, DWORD dwSuiteIndex, PTVerificationTest *ppTest)
{
	ASSERT(	IsValid() );

	ASSERT(ppTest);
	ASSERT(dwSuiteIndex < GlobalTestData.GetSuiteCount());
	
	*ppTest = NULL;
	

	switch(Index.vt)
	{
	case VT_I4 :
	case VT_UI2:
	case VT_UINT:
	case VT_INT:
	case VT_I2:
		{
			if ((Index.iVal >= 0) && (DWORD(Index.iVal) < GlobalTestData.GetTestCount(dwSuiteIndex)))
			{
				*ppTest = GlobalTestData.GetTest(dwSuiteIndex, Index.iVal);
				return true;
			}
			else 
			{
				return false;
			}
		}
		break;

	case VT_BSTR :
		{
			if (!Index.bstrVal)
			{
				return false;
			}
			else
			{
				for (DWORD dw = 0; dw < GlobalTestData.GetTestCount(dwSuiteIndex); dw++)
				{
					USES_CONVERSION;
					CComBSTR bstr;
					VERIFY(bstr.LoadString(GlobalTestData.GetTest(dwSuiteIndex, dw)->uiName));
					if (_tcscmp(bstr, Index.bstrVal) == 0)
					{
						// ok we got the index
						*ppTest = GlobalTestData.GetTest(dwSuiteIndex, dw);
						return true;
					}
				}
				
				return false;
			}
		}
		break;

	default:
		return false;
		break;
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\test.cpp ===
// Test.cpp: implementation of the CTest class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TSDiag.h"
#include "Test.h"

//#include "tstst.h"
#include "testdata.h"



//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTest::CTest() : m_pTest(0), m_bTestRun(false)
{

}

CTest::~CTest()
{

}

STDMETHODIMP CTest::get_Name (BSTR  *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	CComBSTR bstr;
	bstr.LoadString(m_pTest->uiName);
	*pVal = bstr.Copy();
	return S_OK;
}

STDMETHODIMP CTest::get_Description (BSTR  *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}
	
//	bstr_t bstr = m_pTest->szTestName;
//	*pVal = bstr.copy();
	return E_NOTIMPL;
}

STDMETHODIMP CTest::get_IsApplicable (BOOL *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}
	
	if (m_pTest->pfnNeedRunTest)
	{
		*pVal = (*m_pTest->pfnNeedRunTest)();
	}
	else
	{
		*pVal = true;
	}

	return S_OK;
}

STDMETHODIMP CTest::get_WhyNotApplicable (BSTR  *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	bstr_t bstr = m_pTest->TestDetails;
	*pVal = bstr.copy();

	return S_OK;
}

STDMETHODIMP CTest::Execute ()
{
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	if (m_pTest->pfnNeedRunTest && !(*m_pTest->pfnNeedRunTest)())
	{
		return ERROR_INVALID_PARAMETER;
	}

	char szOutput[512];
	
	ostrstream oTestResult(szOutput, 512);
	ZeroMemory(oTestResult.str(), 512);
	
	m_eResult = (*m_pTest->pfnTestFunc)(oTestResult);
	m_bstrResult  = oTestResult.str();
	m_bTestRun = true;

	return S_OK;
}

STDMETHODIMP CTest::get_Result (long *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	if (!m_bTestRun)
	{
		return CO_E_NOTCONSTRUCTED;
	}

	*pVal = m_eResult;
	return S_OK;
}

STDMETHODIMP CTest::get_ResultString (BSTR *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}
	
	if (!m_bTestRun)
	{
		return CO_E_NOTCONSTRUCTED;
	}

	*pVal = m_bstrResult.copy();

	return S_OK;
}

STDMETHODIMP CTest::get_ResultDetails (BSTR *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}
	
	if (!m_bTestRun)
	{
		return CO_E_NOTCONSTRUCTED;
	}

	UINT uiDetailsResource = m_pTest->uiTestDetailsLocal;
	if (!IsItLocalMachine() && m_pTest->uiTestDetailsRemote != 0)
	{
		uiDetailsResource = m_pTest->uiTestDetailsRemote;
	}

	CComBSTR bstr;
	bstr.LoadString(uiDetailsResource);
	*pVal = bstr.Copy();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\suites.cpp ===
// Suites.cpp: implementation of the CSuites class.
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "TSDiag.h"
#include "Suites.h"

#include "suite.h"
#include "testdata.h"



//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSuites::CSuites()
{

}

CSuites::~CSuites()
{

}


STDMETHODIMP CSuites::get_Count(long *pVal)
{
	if (!pVal)
		return E_POINTER;

	*pVal = GlobalTestData.GetSuiteCount();
	return S_OK;
}

STDMETHODIMP CSuites::get__NewEnum(LPUNKNOWN *pVal)
{
	if (!pVal)
		return E_POINTER;

	return E_NOTIMPL;
}

STDMETHODIMP CSuites::get_Item(VARIANT Index, VARIANT *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}


	// BUGBUG find right index value.
	DWORD dwIndex;
	if (!SuiteIndexFromVarient(Index, &dwIndex ))
	{
		return E_INVALIDARG;
	}

	ASSERT(dwIndex < GlobalTestData.GetSuiteCount());

	CComObject<CSuite> *pSuite;
	HRESULT hr = CComObject<CSuite>::CreateInstance(&pSuite);
	if (FAILED(hr))
		return hr;

	// if we need to initialize our Suite object, it should be done here.
	pSuite->SetSuiteIndex(dwIndex);
	
	IDispatch* pDisp = NULL;

	hr = pSuite->QueryInterface(&pDisp);
	if (SUCCEEDED(hr))
	{
		VariantInit(pVal);
		pVal->vt = VT_DISPATCH;
		pVal->pdispVal = pDisp;

	}
	else
	{
		delete pSuite;
	}

	return hr;
	
}

bool CSuites::SuiteIndexFromVarient(const VARIANT &Index, DWORD *pdwIndex)
{
	ASSERT(pdwIndex);
	*pdwIndex = 0xffffffff;

	switch(Index.vt)
	{
	case VT_I4:
	case VT_UI2:
	case VT_UINT:
	case VT_INT:
	case VT_I2:
		{
			if ((Index.iVal >= 0) && (DWORD(Index.iVal) < GlobalTestData.GetSuiteCount()))
			{
				*pdwIndex = Index.iVal;
				return true;
			}
			else 
			{
				return false;
			}
		}
		break;

	case VT_BSTR :
		{
			if (!Index.bstrVal)
			{
				return false;
			}
			else
			{
				for (DWORD dw = 0; dw < GlobalTestData.GetSuiteCount(); dw++)
				{
					if (_tcscmp(GlobalTestData.GetSuiteName(dw), Index.bstrVal) == 0)
					{
						// ok we got the index
						*pdwIndex = dw;
						return true;
					}
				}
				
				return false;
			}
		}
		break;

	default:
		return false;
		break;
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\test.h ===
// Test.h: interface for the CTest class.
//
//////////////////////////////////////////////////////////////////////


#if !defined(AFX_TEST_H__3761055A_21CF_4689_908F_1758001D332D__INCLUDED_)
#define AFX_TEST_H__3761055A_21CF_4689_908F_1758001D332D__INCLUDED_

//#import "F:\nt\termsrv\setup\tsdiag\dll\obj\i386\tsdiag.dll" raw_interfaces_only, raw_native_types, no_namespace, named_guids 
//#import "tsdiag.tlb" raw_interfaces_only, raw_native_types, no_namespace, named_guids 
#include "resource.h"       // main symbols
#include "testdata.h"		// for CTSTestData 
#include "tstst.h"


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class ATL_NO_VTABLE CTest : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CTest, &CLSID_TSDiagnosis>,
	public IDispatchImpl<ITest, &IID_ITest, &LIBID_TSDIAGLib>
{
public:
	CTest();
	virtual ~CTest();


DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTest)
	COM_INTERFACE_ENTRY(ITest)
	COM_INTERFACE_ENTRY2(IDispatch, ITest)
END_COM_MAP()

// ITest
public:
		STDMETHOD(get_Name)(/*[out, retval]*/ BSTR  *pVal);
		STDMETHOD(get_Description)(/*[out, retval]*/ BSTR  *pVal);
		STDMETHOD(get_IsApplicable)(/*[out, retval]*/ BOOL *pVal);
		STDMETHOD(get_WhyNotApplicable)(/*[out, retval]*/ BSTR  *pVal);
		STDMETHOD(Execute)();
		STDMETHOD(get_Result)(/*[out, retval]*/ long *pVal);
		STDMETHOD(get_ResultString)(/*[out, retval]*/ BSTR *pVal);
		STDMETHOD(get_ResultDetails)(/*[out, retval]*/ BSTR *pVal);

		void SetTest(PTVerificationTest ptheTest) { m_pTest = ptheTest;}

private:

	bool m_bTestRun;
	EResult m_eResult;
	bstr_t m_bstrResult;
	bstr_t m_bDetails;
	PTVerificationTest m_pTest;
	bool IsValid() const { return m_pTest != NULL;};
};

#endif // !defined(AFX_TEST_H__3761055A_21CF_4689_908F_1758001D332D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\testdata.h ===
#ifndef __testdata_h__
#define __testdata_h__

#include "tst.h"

class CTSTestData :public CTestData
{

private:
	

public:
	
	CTSTestData();
	~CTSTestData();

	virtual bool				CanExecuteSuite (DWORD dwSuite) const;
	virtual LPCTSTR				GetSuiteErrorText (DWORD dwSuite) const;
	virtual DWORD 				GetSuiteCount	() const;
	virtual LPCTSTR				GetSuiteName	(DWORD dwSuite) const;
	virtual DWORD				GetTestCount    (DWORD dwSuite) const;
	virtual PTVerificationTest	GetTest			(DWORD dwSuite, DWORD iTestNumber) const;
	
	static BOOL					SetMachineName	(LPCTSTR lpMachineName);
	static LPCTSTR			    GetMachineName  ();
	static LPCTSTR				GetMachineNamePath  ();

	static LPTSTR m_lpMachineName;

};


#ifndef ____InsideTestData____
extern 
#endif 

CTSTestData GlobalTestData;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\timebomb.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include "license.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "secstore.h"

#define LICENSING_TIME_BOMB L"TIMEBOMB_832cc540-3244-11d2-b416-00c04fa30cc4"
#define RTMLICENSING_TIME_BOMB L"RTMTSTB_832cc540-3244-11d2-b416-00c04fa30cc4"

#define LICENSING_TIME_BOMB_5_0 L"TIMEBOMB_832cc540-3244-11d2-b416-00c04fa30cc4"
#define RTMLICENSING_TIME_BOMB_5_0 L"RTMTSTB_832cc540-3244-11d2-b416-00c04fa30cc4"

// L$ means only readable from the local machine

#define BETA_LICENSING_TIME_BOMB_5_1 L"L$BETA3TIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define RTM_LICENSING_TIME_BOMB_5_1 L"L$RTMTIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define BETA_LICENSING_TIME_BOMB_LATEST_VERSION BETA_LICENSING_TIME_BOMB_5_1

#define RTM_LICENSING_TIME_BOMB_LATEST_VERSION RTM_LICENSING_TIME_BOMB_5_1

#define X509_CERT_PRIVATE_KEY_NAME \
    L"L$HYDRAENCKEY_dd2d98db-2316-11d2-b414-00c04fa30cc4"

///////////////////////////////////////////////////////////////////

typedef BOOL
(* TLSISBETANTSERVER)();

BOOL FIsBetaSystem ()
{
    HMODULE hmodTlsAPI = LoadLibrary( _T("mstlsapi.dll") );

    if (hmodTlsAPI)
    {
        TLSISBETANTSERVER pfnTLSIsBetaNTServer;
        BOOL fBeta = FALSE;
        
        pfnTLSIsBetaNTServer = (TLSISBETANTSERVER) GetProcAddress(hmodTlsAPI,"TLSIsBetaNTServer");

        if (NULL != pfnTLSIsBetaNTServer)
        {
            fBeta = pfnTLSIsBetaNTServer();
        }

        FreeLibrary(hmodTlsAPI);

        return fBeta;
    }
    else
    {
        return FALSE;
    }
}

bool IsBetaSystem ()
{
    return (FIsBetaSystem() != 0);
}

bool HasLicenceGracePeriodExpired ()
{
    DWORD status;
    DWORD  cbByte;
    PBYTE  pbByte = NULL;
    LPWSTR szTimeBombKey;
    FILETIME timebomb;
    FILETIME filetimeCurrent;
    DWORD dwVersion;


    dwVersion = GetVersion();

    if ((dwVersion & 0x80000000)
        || (LOBYTE(LOWORD(dwVersion)) <= 4))
    {
        cout << endl << "       Pre-Windows 2000.  No grace period";
        return false;
    }
    else if ((LOBYTE(LOWORD(dwVersion)) == 5)
             && (HIBYTE(LOWORD(dwVersion)) == 0))
    {
        // Windows 2000

        if (FIsBetaSystem())
            szTimeBombKey = LICENSING_TIME_BOMB_5_0;
        else
            szTimeBombKey = RTMLICENSING_TIME_BOMB_5_0;
    }
    else if ((LOBYTE(LOWORD(dwVersion)) == 5)
             && (HIBYTE(LOWORD(dwVersion)) == 1))
    {
        // Whistler

        if (FIsBetaSystem())
            szTimeBombKey = BETA_LICENSING_TIME_BOMB_5_1;
        else
            szTimeBombKey = RTM_LICENSING_TIME_BOMB_5_1;
    }
    else
    {
        cout << endl << "       Unknown OS.  Assume no grace period";
        return false;
    }

    status = RetrieveKey(
                         szTimeBombKey,
                         &pbByte,
                         &cbByte
                         );


    if(status == ERROR_SUCCESS && pbByte)
    {
        timebomb = *(FILETIME *)pbByte;


        GetSystemTimeAsFileTime(&filetimeCurrent);

        // yes license has expired if filetimeCurrent >= timebomb
        return (CompareFileTime(&timebomb, &filetimeCurrent) < 1);

    }
    else
    {
        // It hasn't been set yet, so we're not expired

        return false;
    }
}

static gdwCount = 0;
static TCHAR gLicenseServers[1024];

BOOL ServerEnumCallBack(
    IN TLS_HANDLE hHandle,
    IN LPCTSTR pszServerName,
    IN HANDLE /* dwUserData */)
{
    USES_CONVERSION;

    if (hHandle)
    {
		_tcscat(gLicenseServers, pszServerName);
        cout << endl << "       Found #" << ++gdwCount << ":"<< T2A(pszServerName);
    }


    return 0;
}

typedef HANDLE
(* TLSCONNECTTOANYLSSERVER)(  
    DWORD dwTimeOut
);

typedef DWORD 
(* ENUMERATETLSSERVERNEW)(  
    TLSENUMERATECALLBACK fCallBack, 
    HANDLE dwUserData,
    DWORD dwTimeOut,
    BOOL fRegOnly
);


typedef DWORD 
(* ENUMERATETLSSERVEROLD)(  
    LPCTSTR szDomain,
    LPCTSTR szScope, 
    DWORD dwPlatformType, 
    TLSENUMERATECALLBACK fCallBack, 
    HANDLE dwUserData,
    DWORD dwTimeOut,
    BOOL fRegOnly
);

bool EnumerateLicenseServers ()
{
    HMODULE hmodTlsAPI = LoadLibrary( _T("mstlsapi.dll") );

    if (hmodTlsAPI)
    {
        DWORD dwResult;
		_tcscat(gLicenseServers, _T(""));

        // load TLSShutdown to see if we have the new APIs
        if (NULL == GetProcAddress(hmodTlsAPI,"TLSShutdown"))
        {
            ENUMERATETLSSERVEROLD pfnEnumerateTlsServer;

            pfnEnumerateTlsServer = (ENUMERATETLSSERVEROLD) GetProcAddress(hmodTlsAPI,"EnumerateTlsServer");

            if (NULL != pfnEnumerateTlsServer)
            {

                dwResult = pfnEnumerateTlsServer(
                            NULL,
                            NULL,
                            LSKEYPACKPLATFORMTYPE_UNKNOWN,
                            ServerEnumCallBack,
                            0,
                            0,
                            FALSE);
            }
            else
            {
                cout << endl << "       Failed to GetProcAddress,ErrorCode = " << GetLastError() << endl;

                return false;
            }
        }
        else
        {
            if (NULL != GetProcAddress(hmodTlsAPI,"TLSGetSupportFlags"))
            {
                // Use newer discovery function

                TLSCONNECTTOANYLSSERVER pfnTLSConnectToAnyLsServer;
                TLS_HANDLE hServer;

                pfnTLSConnectToAnyLsServer = (TLSCONNECTTOANYLSSERVER) GetProcAddress(hmodTlsAPI,"TLSConnectToAnyLsServer");

                if (NULL != pfnTLSConnectToAnyLsServer)
                {
                    hServer = pfnTLSConnectToAnyLsServer(INFINITE);

                    if (NULL != hServer)
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    cout << endl << "       Failed to GetProcAddress TLSConnectToAnyLsServer,ErrorCode = " << GetLastError() << endl;
                    
                    return FALSE;
                }
            }
            else
            {
                ENUMERATETLSSERVERNEW pfnEnumerateTlsServer;
        
                pfnEnumerateTlsServer = (ENUMERATETLSSERVERNEW) GetProcAddress(hmodTlsAPI,"EnumerateTlsServer");

                if (NULL != pfnEnumerateTlsServer)
                {
                    dwResult = pfnEnumerateTlsServer(
                                                     ServerEnumCallBack,
                                                     0,
                                                     0,
                                                     FALSE);
                }
                else
                {
                    cout << endl << "       Failed to GetProcAddress,ErrorCode = " << GetLastError() << endl;

                    return false;
                }
            }
        }
        
        FreeLibrary(hmodTlsAPI);
        
        if (dwResult != NO_ERROR)
            cout << endl << "       Failed to EnumerateTlsServer,ErrorCode = " << dwResult << endl;


        if (gdwCount > 0)
            cout << endl;

        return gdwCount > 0;

    }
    else
    {
        cout << endl << "       Failed to load mstlsapi.dll,ErrorCode = " << GetLastError() << endl;

        return false;
    }

}

TCHAR *GetLicenseServers ()
{	
	if (EnumerateLicenseServers ())
		return gLicenseServers;
	else
		return TEXT("Failed");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\tscert.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

#include "stdafx.h"

#define MemAlloc malloc // for certfy.inc
#define MemFree free

#include "../../tscert/inc/pubblob.h"    // needed by certvfy.inc
#include "../../tscert/inc/certvfy.inc"  // VerifyFile()


bool FileExists (char *pszFullNameAndPath); // from tstst.cpp

bool CheckifBinaryisSigned(TCHAR *szFile)
{
    USES_CONVERSION;
    TCHAR szFullFile[MAX_PATH +1];
    RTL_CRITICAL_SECTION VfyLock;

    if (ExpandEnvironmentStrings(szFile, szFullFile, MAX_PATH))
    {
        if (FileExists(T2A(szFullFile)))
        {
            RtlInitializeCriticalSection( &VfyLock );

            if ( VerifyFile( T2W(szFullFile), &VfyLock ) )
            {
                return true;
            }
        }

    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\tsdgns.cpp ===
// tsdgns.cpp : Implementation of CTSDiagnosis
#include "stdafx.h"
#include "TSDiag.h"
#include "tsdgns.h"

#include "testdata.h"
#include "suites.h"


static int iTSDiag = 0;
CTSDiagnosis::CTSDiagnosis()
{
	m_dwSuite = 0;
	iTSDiag++;
	TCHAR szString[256];
	_stprintf(szString, _T("iTSDiag = %d\n"), iTSDiag);
	OutputDebugString(szString);

}


CTSDiagnosis::~CTSDiagnosis()
{
	iTSDiag--;
	TCHAR szString[256];
	_stprintf(szString, _T("iTSDiag = %d\n"), iTSDiag);
	OutputDebugString(szString);
}

DWORD CTSDiagnosis::GetTotalTestCount ()
{
	return GlobalTestData.GetTestCount(m_dwSuite);

}
STDMETHODIMP CTSDiagnosis::get_TestCount(long *pVal)
{
	// TODO: Add your implementation code here
	*pVal = GetTotalTestCount ();
	return ERROR_SUCCESS;
}

STDMETHODIMP CTSDiagnosis::get_TestDescription(int i, BSTR * pVal)
{
	
	// TODO: Add your implementation code here
	if (i >= (int)GetTotalTestCount ())
	{
		return ERROR_INVALID_PARAMETER;
	}

	if (!pVal)
	{
		return ERROR_INVALID_PARAMETER;
	}

	return E_NOTIMPL;


	return ERROR_SUCCESS;
}

STDMETHODIMP CTSDiagnosis::get_TestApplicable(int i, BOOL *pbApplicable)
{
	if (i >= (int)GetTotalTestCount ())
	{
		return ERROR_INVALID_PARAMETER;
	}

	if (!pbApplicable)
	{
		return ERROR_INVALID_PARAMETER;
	}
	
	PTVerificationTest pTest = GlobalTestData.GetTest(m_dwSuite, i);
	if (pTest->pfnNeedRunTest && !(*(pTest->pfnNeedRunTest))())
	{
		*pbApplicable = FALSE;
	}
	else
	{
		*pbApplicable = TRUE;
	}

	return ERROR_SUCCESS;
}

STDMETHODIMP CTSDiagnosis::RunTest(int i)
{
	USES_CONVERSION;

	if (i >= (int)GetTotalTestCount ())
	{
		return ERROR_INVALID_PARAMETER;
	}

	PTVerificationTest pTest = GlobalTestData.GetTest(m_dwSuite, i);

	if (pTest->pfnNeedRunTest && !(*(pTest->pfnNeedRunTest))())
	{
		return ERROR_INVALID_PARAMETER;
	}

	ASSERT (pTest->pfnTestFunc);

	char szOutput[512];
	
	ostrstream oTestResult(szOutput, 512);
	ZeroMemory(oTestResult.str(), 512);
	m_lTestResult = (*(pTest->pfnTestFunc))(oTestResult);
	//oTestResult << "\0";

	m_bstrTestResultString  = oTestResult.str();
	
	return S_OK;
}

STDMETHODIMP CTSDiagnosis::get_TestResultString(BSTR *pVal)
{
	if (!pVal)
	{
		return ERROR_INVALID_PARAMETER;
	}
	*pVal = m_bstrTestResultString.copy();
	return S_OK;
}

STDMETHODIMP CTSDiagnosis::get_TestResult(long *pVal)
{
	if (!pVal)
	{
		return ERROR_INVALID_PARAMETER;
	}

	*pVal = m_lTestResult;
	return S_OK;
}


STDMETHODIMP CTSDiagnosis::put_TestType(VARIANT newVal)
{
	switch(newVal.vt)
	{
		case VT_I4 :
		case VT_UI2:
		case VT_UINT:
		case VT_INT:
		{
			if (DWORD(newVal.iVal) >= GlobalTestData.GetSuiteCount())
			{
				return E_INVALIDARG; 
			}
			else
			{
				m_dwSuite = newVal.iVal;
			}
		}
		break;

		case VT_BSTR :
		{
			if (!newVal.bstrVal)
			{
				return E_INVALIDARG;
			}
			else
			{
				_bstr_t bstrGroupName = newVal.bstrVal;

				for (DWORD i = 0; i < GlobalTestData.GetSuiteCount(); i++)
				{
					if (0 == _tcscmp(bstrGroupName, GlobalTestData.GetSuiteName(i)) )
					{
						m_dwSuite = i;
					}
				}

				if (i ==  GlobalTestData.GetSuiteCount())
				{
					return E_INVALIDARG;
				}
			}
		}
		break;

		default:
			return E_INVALIDARG;
			break;
	}

	return S_OK;

}


STDMETHODIMP CTSDiagnosis::get_TestDetails(int i, BSTR *pVal)
{
	// TODO: Add your implementation code here
	if (i >= (int)GetTotalTestCount ())
	{
		return ERROR_INVALID_PARAMETER;
	}

	if (!pVal)
	{
		return ERROR_INVALID_PARAMETER;
	}

	bstr_t bstrTestDetails;

	PTVerificationTest pTest = GlobalTestData.GetTest(m_dwSuite, i);
	bstrTestDetails = pTest->TestDetails;
	*pVal = bstrTestDetails.copy();

	return ERROR_SUCCESS;
}


STDMETHODIMP CTSDiagnosis::ExecuteIt(BSTR strCommand)
{

    ASSERT(strCommand);
	HINSTANCE hInst = ShellExecute(NULL, _T("open"), strCommand, NULL, NULL, SW_SHOW );
	if (32 > PtrToLong(hInst))
	{

		PROCESS_INFORMATION pinfo;
		STARTUPINFO sinfo;

		ZeroMemory(&sinfo, sizeof(sinfo));
		sinfo.cb = sizeof(sinfo);

		if (CreateProcess(
			NULL,                             // name of executable module
			strCommand,						  // command line string
			NULL,                             // SD
			NULL,                             // SD
			FALSE,                            // handle inheritance option
			CREATE_NEW_PROCESS_GROUP,         // creation flags
			NULL,                             // new environment block
			NULL,                             // current directory name
			&sinfo,                             // startup information
			&pinfo                            // process information
			))
		{
			// MessageBox(NULL, _T("Executed fine"), _T("TSDIAG"), MB_OK);
		}
		else
		{
			MessageBox(NULL, _T("Failed to Execute"), _T("TSDIAG"), MB_OK);
		}
	}

	return S_OK;
}
STDMETHODIMP CTSDiagnosis::put_RemoteMachineName(BSTR newVal)
{
	if (!GlobalTestData.SetMachineName(newVal))
		return E_OUTOFMEMORY;

	return S_OK;
}

STDMETHODIMP CTSDiagnosis::get_SuiteApplicable (DWORD dwSuite, BOOL * pVal)
{
	if (!pVal)
	{
		return ERROR_INVALID_PARAMETER;
	}

	if (dwSuite >= GlobalTestData.GetSuiteCount())
	{
		return ERROR_INVALID_PARAMETER;
	}
	
	*pVal = GlobalTestData.CanExecuteSuite(dwSuite);
	return S_OK;

}

STDMETHODIMP CTSDiagnosis::get_SuiteErrorText (DWORD dwSuite, BSTR  * pVal)
{
	if (!pVal)
	{
		return ERROR_INVALID_PARAMETER;
	}

	if (dwSuite >= GlobalTestData.GetSuiteCount())
	{
		return ERROR_INVALID_PARAMETER;
	}

	bstr_t bstrSuiteError;
	bstrSuiteError = GlobalTestData.GetSuiteErrorText(dwSuite);
	*pVal =  bstrSuiteError.copy();
	
	return S_OK;
}

STDMETHODIMP CTSDiagnosis::ExecuteCommand (BSTR strCommand)
{
    ASSERT(strCommand);
	HINSTANCE hInst = ShellExecute(NULL, _T("open"), strCommand, NULL, NULL, SW_SHOW );
	if (32 > PtrToLong(hInst))
	{

		PROCESS_INFORMATION pinfo;
		STARTUPINFO sinfo;

		ZeroMemory(&sinfo, sizeof(sinfo));
		sinfo.cb = sizeof(sinfo);

		if (CreateProcess(
			NULL,                             // name of executable module
			strCommand,						  // command line string
			NULL,                             // SD
			NULL,                             // SD
			FALSE,                            // handle inheritance option
			CREATE_NEW_PROCESS_GROUP,         // creation flags
			NULL,                             // new environment block
			NULL,                             // current directory name
			&sinfo,                             // startup information
			&pinfo                            // process information
			))
		{
			// MessageBox(NULL, _T("Executed fine"), _T("TSDIAG"), MB_OK);
		}
		else
		{
			MessageBox(NULL, _T("Failed to Execute"), _T("TSDIAG"), MB_OK);
		}
	}

	return S_OK;
}
STDMETHODIMP CTSDiagnosis::put_MachineName (BSTR newVal)
{
	if (!GlobalTestData.SetMachineName(newVal))
	{
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CTSDiagnosis::get_Suites (VARIANT * pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}

	CComObject<CSuites> *pSuites;
	
	HRESULT hr = CComObject<CSuites>::CreateInstance(&pSuites);
	if (FAILED(hr))
		return hr;

	// if we need to initialize our Suites object, it should be done here.
	
	IDispatch* pDisp = NULL;

	hr = pSuites->QueryInterface(&pDisp);
	if (SUCCEEDED(hr))
	{
		pVal->vt = VT_DISPATCH;
		pVal->pdispVal = pDisp;

		// if we need to initialize our Suites object, it should be done here.
	}
	else
	{
		delete pSuites;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\tst.h ===
//
// This file defines basic test structures
// this should not contain any ts specific things.
//

#ifndef ___TST_H___
#define ___TST_H___


enum EResult 
{
	eFailed = 0,
	ePassed = 1,
	eUnknown= 2,
	eFailedToExecute = 4
};

typedef bool	(PFN_SUITE_FUNC)();
typedef TCHAR * (PFN_SuiteErrorReason)(void);
typedef bool	(PFN_BOOL)(void);
typedef EResult (PFN_TEST_FUNC)(ostrstream &);


typedef struct _TVerificationTest
{
	UINT				uiName;
    //char szTestName[256];                   // descriptive name of the test
    PFN_BOOL            *pfnNeedRunTest;     // pointer to function that will be called to decide if the test need run, test is run if NULL.
	PFN_TEST_FUNC		*pfnTestFunc;
	DWORD				SuiteMask;
	UINT				uiTestDetailsLocal;
	UINT				uiTestDetailsRemote;
	char TestDetails[2048];

} TVerificationTest, *PTVerificationTest;


typedef struct _TTestSuite
{
	LPCTSTR					szSuiteName;
	PFN_SUITE_FUNC *		pfnCanRunSuite;
	PFN_SuiteErrorReason *  pfnSuiteErrorReason;				
	DWORD					dwTestCount;
	int	*					aiTests;

} TTestSuite, *PTTestSuite;




// to implement your test suites, derive from this class.
class CTestData 
{
	public:
		CTestData() {};
		virtual ~CTestData() {};


	virtual DWORD 				GetSuiteCount	() const = 0;
	virtual LPCTSTR				GetSuiteName	(DWORD dwSuite) const = 0 ;
	virtual DWORD				GetTestCount    (DWORD dwSuite) const = 0 ;
	virtual PTVerificationTest	GetTest			(DWORD dwSuite, DWORD iTestNumber) const = 0 ;
};


DWORD						GetTotalTestCount ();
PTVerificationTest			GetTest (DWORD dwTestIndex);

#endif // ___TST_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\tsdiag.cpp ===
// TSDiag.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for TSDiag.idl by adding the following 
//      files to the Outputs.
//          TSDiag_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f TSDiagps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TSDiag.h"
#include "dlldatax.h"

#include "TSDiag_i.c"
#include "tsdgns.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;



BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TSDiagnosis, CTSDiagnosis)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TSDIAGLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
     return _Module.RegisterServer(TRUE);

}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\tstst.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation



#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "stdafx.h"
#include <dsrole.h>
#include <wtsapi32.h>
#include "winsta.h"
#include "tstst.h"
#include "testdata.h"
#include <rdpsndp.h>
#include <rdpstrm.h>
//
// global utilities and veraibles.
//
bool CheckifBinaryisSigned        (TCHAR *szFile);  // from tscert.cpp
bool EnumerateLicenseServers      ();               // from timebomb.cpp
bool HasLicenceGracePeriodExpired ();               // from timebomb.cpp
bool ExtractAllTSEvents();
TCHAR *GetLicenseServers ();
bool ValidateProductSuite (LPSTR SuiteName);
bool IsTerminalServicesEnabled ( VOID );
DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, bool *pbFound);
bool DoesHydraKeysExists ();
bool IsItRemoteMachine ();


bool IsTermDDStartBitSet ();
bool GetTSOCLogFileName (char *strFileName, UINT uiSize);
bool FileExists (char *pszFullNameAndPath);
bool IsRemoteAdminMode ();
bool CheckModePermissions(DWORD *pdwSecurtyMode);
bool IsFile128Bit(LPTSTR szFile, bool *pb128Bit);
ULONG RDPDRINST_DetectInstall();    // defined in drdetect.cpp
bool IsBetaSystem();
bool CheckModeRegistry (bool bAppCompat, ostrstream &ResultStream);
bool GetWinstationConfiguration (WINSTATIONCONFIG **ppInfo);

bool CanPing (); // comes from ping.cpp

const SERVER_INFO_101 *GetServerInfo()
{
	ASSERT(IsItRemoteMachine());

    // for local machines, we will get GetMachineName() as null,
    if (CTSTestData::GetMachineName())
    {
    	USES_CONVERSION;
    	static SERVER_INFO_101 ServerInfo;
    	LPBYTE Buffer;
    	static bool bGotOnce = false;
    	if (!bGotOnce)
    	{
    		TCHAR szMachineName[256];
    		_tcscpy(szMachineName, CTSTestData::GetMachineName());
    		if (NERR_Success == NetServerGetInfo(
    			T2W(szMachineName),
    			102,
    			&Buffer
    			))
    		{
    			bGotOnce = true;
    			CopyMemory(&ServerInfo, Buffer, sizeof(SERVER_INFO_101));
    			return &ServerInfo;
    		}
    		else
    		{
    			return NULL;
    		}
    	}
    	else
    	{
    		return &ServerInfo;
    	}
    }

    return NULL;
}

const OSVERSIONINFOEX *GetOSVersionInfo()
{
	ASSERT(!IsItRemoteMachine());
    static OSVERSIONINFOEX gOsVersion;
    static bool bGotOnce = false;
    if (!bGotOnce)
    {
        ZeroMemory(&gOsVersion, sizeof(OSVERSIONINFOEX));
        gOsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        GetVersionEx( (LPOSVERSIONINFO ) &gOsVersion);
        bGotOnce = true;
    }

    return &gOsVersion;
}



// #include <strstream>
#include "winsock2.h"


// ostringstream sz

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(P)          (P)
#endif

#define OLD_VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))


TCHAR *aszStack[] = {
//  _T("noexport\%SystemRoot%\\system32\\drivers\\rdpwdd.sys"),
    _T("%SystemRoot%\\system32\\drivers\\termdd.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdasync.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdipx.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdnetb.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdpipe.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdspx.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdtcp.sys"),
    _T("%SystemRoot%\\system32\\drivers\\rdpwd.sys"),
    _T("%SystemRoot%\\system32\\rdpdd.dll"),
    _T("%SystemRoot%\\system32\\rdpwsx.dll")
};


TCHAR *GetTSVersion()
{
	static TCHAR Version[256] = TEXT("");

	if (_tcslen(Version) != 0)
		return Version;

	CRegistry oRegTermsrv;
	DWORD cbVersion = 0;
	LPTSTR szVersion = NULL;

	if ((ERROR_SUCCESS == oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName())) &&
		(ERROR_SUCCESS == oRegTermsrv.ReadRegString(_T("ProductVersion"), &szVersion, &cbVersion)))
	{
		_tcscpy(Version, szVersion);
		return Version;
	}

	return _T("Error finding Version.");
}

EResult GetTSVersion (ostrstream &ResultStream)
{
	USES_CONVERSION;
	ResultStream << T2A(GetTSVersion());
	return ePassed;
}

bool IsIt50TS()
{
	return (0 == _tcsicmp(GetTSVersion(), _T("5.0")));
}

bool IsIt51TS()
{
	return (0 == _tcsicmp(GetTSVersion(), _T("5.1")));
}


bool DoIhaveRPCPermissions ()
{
	HANDLE hServer = WTS_CURRENT_SERVER_HANDLE;
	if (CTSTestData::GetMachineName())
	{
		TCHAR szMachineName[256];
		_tcscpy(szMachineName, CTSTestData::GetMachineName());
		hServer = WTSOpenServer (szMachineName);
	}

	LPTSTR buffer;
	DWORD dwBytesReturned;
	if (WTSQuerySessionInformation(
			hServer,
			65536,
			WTSInitialProgram,
			&buffer,
			&dwBytesReturned))
	{
		WTSFreeMemory(buffer);
		return true;
	}

	if (CTSTestData::GetMachineName())
		WTSCloseServer(hServer);

	return false;
}


bool DoIHaveEnufPermissions ()
{
	char szOutput[512];
	ostrstream oTestResult(szOutput, 512);
	ZeroMemory(oTestResult.str(), 512);


	if (!DoIhaveRPCPermissions())
	{
		return false;
	}

	CRegistry oRegTermsrv;
	return ERROR_SUCCESS == oRegTermsrv.OpenKey(
								HKEY_LOCAL_MACHINE, 
								_T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), 
								KEY_READ, 
								CTSTestData::GetMachineName()
								);
}

bool IsUserRemoteAdmin ()
{
	if (IsItRemoteMachine())
	{
		USES_CONVERSION;
		TCHAR strNTFilename[256];
		if (CTSTestData::GetMachineNamePath())
		{
			_tcscpy(strNTFilename, CTSTestData::GetMachineNamePath());
			_tcscat(strNTFilename, _T("\\admin$\\system32\\ntoskrnl.exe"));
		}

        HANDLE hFile = CreateFile(strNTFilename, 0, FILE_SHARE_READ,
					              NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		
		if (hFile != INVALID_HANDLE_VALUE)
		{
			CloseHandle(hFile);
			return true;
		}

		return false;
	}
	else
	{
		// we dont require admin priviledges if running on local machine
		return true;
	}
}

EResult HasLicenceGracePeriodExpired (ostrstream &ResultStream)
{
    if (HasLicenceGracePeriodExpired())
	{
		ResultStream << "Its expired";
		return eFailed;
	}
	else
	{
		ResultStream << "No, its not expired.";
		return ePassed;
	}
}

EResult Check_StackBinSigatures (ostrstream &ResultStream)
{

	USES_CONVERSION;
    bool bRet = true;

    LPTSTR aStackBins[] =
    {
        _T("%SystemRoot%\\system32\\drivers\\termdd.sys"),
        _T("%SystemRoot%\\system32\\drivers\\tdpipe.sys"),
        _T("%SystemRoot%\\system32\\drivers\\tdtcp.sys"),
        _T("%SystemRoot%\\system32\\drivers\\rdpwd.sys"),
        _T("%SystemRoot%\\system32\\rdpdd.dll"),
        _T("%SystemRoot%\\system32\\rdpwsx.dll")
    };

    for (int i = 0; i < sizeof(aStackBins)/sizeof(aStackBins[0]); i++)
    {
        if (!CheckifBinaryisSigned(aStackBins[i]))
        {
            ResultStream << "Invalid Signature for:" << T2A(aStackBins[i]) << ",";
            bRet = false;
        }

    }

	if (bRet)
	{
		ResultStream << "Passed";
		return ePassed;
	}
	else
	{
		return eFailed;
	}
}

EResult IsRdpDrInstalledProperly (ostrstream &ResultStream)
{
	//
	// we cannot do this test for remote machine.
	//
	ASSERT(IsItLocalMachine());
    if (RDPDRINST_DetectInstall())
	{
		ResultStream << "Passed";
		return ePassed;
	}
	else
	{
		ResultStream << "Failed";
		return eFailed;

	}
}

EResult GetModePermissions (ostrstream &ResultStream)
{
    CRegistry reg;
    DWORD dwSecurityMode;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName()))
    {
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSUserEnabled"), &dwSecurityMode))
        {
            if (dwSecurityMode == 0)
            {
                ResultStream <<  "Its W2k Compatible";
				return ePassed;
            }
            else if (dwSecurityMode == 1)
            {
                ResultStream <<  "Its TS4 Compatible";
				return ePassed;
            }
            else
            {
                ResultStream << "SYSTEM\\CurrentControlSet\\Control\\Terminal Server/TSUserEnabled has wrong value" << dwSecurityMode << "!";
                return eFailedToExecute;
            }
        }
		else
		{
            ResultStream << "failed to read TSUserEnabled";
            return eFailedToExecute;
		}
    }
	else
	{
        ResultStream << "failed to read SYSTEM\\CurrentControlSet\\Control\\Terminal Server";
        return eFailedToExecute;
	}

}

bool CheckModePermissions (DWORD *pdwSecurtyMode)
{
//    PERM_WIN2K = 0,
//    PERM_TS4 = 1

    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName()))
    {
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSUserEnabled"), pdwSecurtyMode))
        {
            return (*pdwSecurtyMode== 0) || (*pdwSecurtyMode== 1);
        }
    }

    return false;
}

EResult GetCypherStrenthOnRdpwd (ostrstream &ResultStream)
{
   
	bool bFile128bit;
	TCHAR strFileName[256];
	
	if (CTSTestData::GetMachineName())
	{
		_tcscpy(strFileName, CTSTestData::GetMachineNamePath());
		_tcscat(strFileName, _T("\\admin$\\system32\\drivers\\rdpwd.sys"));
	}
	else
	{
		_tcscpy(strFileName, _T("%SystemRoot%\\system32\\drivers\\rdpwd.sys"));
	}

    if ( IsFile128Bit(strFileName, &bFile128bit) )
    {
        ResultStream << (bFile128bit ? "128 Bit" : "56 Bit");
		return ePassed;
    }
    else
    {
		ResultStream << "Failed to get cypher strength on rdpwd.sys, You may not have sufficient permissions.";
        return eFailedToExecute;
    }

}


bool IsFile128Bit(LPTSTR szFile, bool *pb128Bit)
{
    USES_CONVERSION;
    DWORD dwHandle;

    TCHAR szFullFile[MAX_PATH +1];

    bool bSuccess = false;

    if (ExpandEnvironmentStrings(szFile, szFullFile, MAX_PATH))
    {
        if (FileExists(T2A(szFullFile)))
        {
            DWORD dwSize = GetFileVersionInfoSize(szFullFile, &dwHandle);
            if (dwSize > 0)
            {
                BYTE *pbData = new BYTE[dwSize];
                if (pbData)
                {
                    if (GetFileVersionInfo(szFullFile, 0, dwSize, pbData))
                    {
                        TCHAR *szFileDescription;
                        UINT uiLen = 0;
                        if (VerQueryValue(pbData, _T("\\StringFileInfo\\040904B0\\FileDescription"), (LPVOID *)&szFileDescription, &uiLen))
                        {
                            if (_tcsstr(szFileDescription, _T("Not for Export")))
                            {
                                *pb128Bit = true;
                                bSuccess = true;

                            }
                            else if (_tcsstr(szFileDescription, _T("Export Version")))
                            {
                                *pb128Bit = false;
                                bSuccess = true;
                            }
                        }
                    }

                    delete [] pbData;

                }

            }
        }
    }

    return bSuccess;
}



bool ValidateProductSuite (LPSTR SuiteName)
{
    bool rVal = false;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPSTR ProductSuite = NULL;
    LPSTR p;

    Rslt = RegOpenKeyA(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\ProductOptions",
        &hKey
        );

    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueExA( hKey, "ProductSuite", NULL, &Type, NULL, &Size );
    if (Rslt != ERROR_SUCCESS || !Size)
        goto exit;

    ProductSuite = (LPSTR) LocalAlloc( LPTR, Size );
    if (!ProductSuite)
        goto exit;

    Rslt = RegQueryValueExA( hKey, "ProductSuite", NULL, &Type,
        (LPBYTE) ProductSuite, &Size );
     if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    p = ProductSuite;
    while (*p)
    {
        if (lstrcmpA( p, SuiteName ) == 0)
        {
            rVal = true;
            break;
        }
        p += (lstrlenA( p ) + 1);
    }

exit:
    if (ProductSuite)
        LocalFree( ProductSuite );

    if (hKey)
        RegCloseKey( hKey );

    return rVal;
}


bool IsTerminalServicesEnabled( VOID )
{
    bool bResult = false;
    DWORD   dwVersion;
    OSVERSIONINFOEXA osVersionInfo;
    DWORDLONG dwlConditionMask = 0;
    HMODULE hmodK32 = NULL;
    typedef ULONGLONG (*PFnVerSetConditionMask) ( ULONGLONG, ULONG, UCHAR );
    typedef BOOL      (*PFnVerifyVersionInfoA) (POSVERSIONINFOEXA, DWORD, DWORDLONG);
    PFnVerSetConditionMask pfnVerSetConditionMask;
    PFnVerifyVersionInfoA pfnVerifyVersionInfoA;


    dwVersion = GetVersion();

    /* are we running NT ? */
    if (!(dwVersion & 0x80000000))
    {
        // Is it NT 50 or greater ?
        if (LOBYTE(LOWORD(dwVersion)) > 4)
        {
            /* In NT5 we need to use the Product Suite APIs
             Don't static link because it won't load on non-NT5 systems */

            hmodK32 = GetModuleHandleA( "KERNEL32.DLL" );
            if (hmodK32)
            {
                pfnVerSetConditionMask = (PFnVerSetConditionMask )GetProcAddress( hmodK32, "VerSetConditionMask");

                if (pfnVerSetConditionMask)
                {
                    /* get the condition mask. */
                    dwlConditionMask = (*pfnVerSetConditionMask)(dwlConditionMask, VER_SUITENAME, VER_AND);

                    pfnVerifyVersionInfoA = (PFnVerifyVersionInfoA)GetProcAddress( hmodK32, "VerifyVersionInfoA") ;

                    if (pfnVerifyVersionInfoA != NULL)
                    {

                        ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));
                        osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
                        osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;
                        bResult = (*pfnVerifyVersionInfoA)(
                                          &osVersionInfo,
                                          VER_SUITENAME,
                                          dwlConditionMask) != 0;
                    }
                }
            }
        }
        else
        {
            /* This is NT 40 */
            bResult = ValidateProductSuite( "Terminal Server" );
        }
    }

    return bResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, bool *pbFound)
* checks if parameter string exists in given multistring.
* returns error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, bool *pbFound)
{
    ASSERT(szkey && *szkey);
    ASSERT(szvalue && *szvalue);
    ASSERT(szCheckForString&& *szCheckForString);
    ASSERT(*szkey != '\\');
    ASSERT(pbFound);

    // not yet found.
    *pbFound = false;

    CRegistry reg;
    DWORD dwError = reg.OpenKey(hkey, szkey, KEY_READ, CTSTestData::GetMachineName());  // open up the required key.
    if (dwError == NO_ERROR)
    {
        LPTSTR szSuiteValue;
        DWORD dwSize;
        dwError = reg.ReadRegMultiString(szvalue, &szSuiteValue, &dwSize);
        if (dwError == NO_ERROR)
        {
            LPCTSTR pTemp = szSuiteValue;
            while(_tcslen(pTemp) > 0 )
            {
                if (_tcscmp(pTemp, szCheckForString) == 0)
                {
                    *pbFound = true;
                    break;
                }

                pTemp += _tcslen(pTemp) + 1; // point to the next string within the multistring.
                if ( DWORD(pTemp - szSuiteValue) > (dwSize / sizeof(TCHAR)))
                    break; // temporary pointer passes the size of the szSuiteValue something is wrong with szSuiteValue.
            }
        }
    }

    return dwError;

}


bool DoesHydraKeysExists()
{
    bool bStringExists = false;
    DWORD dw = IsStringInMultiString(
        HKEY_LOCAL_MACHINE,
        _T("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
        _T("ProductSuite"),
        _T("Terminal Server"),
        &bStringExists);

    return (dw == ERROR_SUCCESS) && bStringExists;
}





/*
TCHAR *IsItAppServer ()
{
    return ((GetOSVersionInfo()->wSuiteMask & VER_SUITE_TERMINAL) &&
           !(GetOSVersionInfo()->wSuiteMask & VER_SUITE_SINGLEUSERTS)) ? _T("Yes") : _T("No");
}
*/
bool IsItPTS( VOID )
{
    return ( 0 != (GetOSVersionInfo()->wSuiteMask & VER_SUITE_SINGLEUSERTS));
}

bool IsItRemoteMachine ()
{
	return CTSTestData::GetMachineName() != NULL;
}

bool AreWeInsideSession ()
{
	return GetSystemMetrics(SM_REMOTESESSION) != 0;
}

bool IsItLocalMachine ()
{
	return !IsItRemoteMachine ();
}

bool IsItLocalServer ()
{
	return IsItServer () && IsItLocalMachine ();
}

bool IsItServer ()
{
	if (IsItRemoteMachine())
	{
		const SERVER_INFO_101 *pServerInfo;
		pServerInfo = GetServerInfo();
		if (pServerInfo)
		{
			return ( (pServerInfo->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
					 (pServerInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) ||
					 (pServerInfo->sv101_type & SV_TYPE_SERVER_NT));
		}
		else
		{

			return true; // we could not determine if its server or not, Lets say its server.
		}

	}
	else
	{
		return GetOSVersionInfo()->wProductType != VER_NT_WORKSTATION;
	}

	
}

bool IsAudioEnabled()
{
    USES_CONVERSION;
    WINSTATIONCONFIG  *pWSInfo = NULL;

    if ( !AreWeInsideSession() )
        return FALSE;

    if (GetWinstationConfiguration(&pWSInfo))
    {
        return !(pWSInfo->User.fDisableCam);
    }

    return FALSE;
}

bool IsItRemoteConsole( VOID )
{
    return ( AreWeInsideSession() && (NtCurrentPeb()->SessionId == 0 || IsItPTS()) );
}

EResult IsItServer (ostrstream &ResultStream)
{
	ResultStream << (IsItServer ()) ? "Its a workstation" : "Its a server";
	return (IsItServer()) ? ePassed : eFailed;
}

EResult GetProductType (ostrstream &ResultStream)
{
	ASSERT(IsItLocalMachine());
    BYTE wProductType = GetOSVersionInfo()->wProductType;
    if (wProductType == VER_NT_WORKSTATION)
    {
		ResultStream << "VER_NT_WORKSTATION";
    }

    if (wProductType == VER_NT_DOMAIN_CONTROLLER)
    {
		ResultStream << "VER_NT_DOMAIN_CONTROLLER ";
    }

    if (wProductType == VER_NT_SERVER)
    {
		ResultStream << "VER_NT_SERVER ";
    }

    return ePassed;
}


EResult GetProductSuite (ostrstream &ResultStream)
{
	ASSERT(IsItLocalMachine());
    WORD wProductSuite = GetOSVersionInfo()->wSuiteMask;
    
	if (wProductSuite & VER_SERVER_NT)
    {
        ResultStream << "VER_SERVER_NT ";
    }
    if (wProductSuite & VER_WORKSTATION_NT)
    {
        ResultStream << "VER_WORKSTATION_NT ";
    }
    if (wProductSuite & VER_SUITE_SMALLBUSINESS)
    {
        ResultStream << "VER_SUITE_SMALLBUSINESS ";
    }
    if (wProductSuite & VER_SUITE_ENTERPRISE)
    {
        ResultStream << "VER_SUITE_ENTERPRISE ";
    }
    if (wProductSuite & VER_SUITE_BACKOFFICE)
    {
        ResultStream << "VER_SUITE_BACKOFFICE ";
    }
    if (wProductSuite & VER_SUITE_COMMUNICATIONS)
    {
        ResultStream << "VER_SUITE_COMMUNICATIONS ";
    }
    if (wProductSuite & VER_SUITE_TERMINAL)
    {
        ResultStream << "VER_SUITE_TERMINAL ";
    }
    if (wProductSuite & VER_SUITE_SMALLBUSINESS_RESTRICTED)
    {
        ResultStream << "VER_SUITE_SMALLBUSINESS_RESTRICTED ";
    }
    if (wProductSuite & VER_SUITE_EMBEDDEDNT)
    {
        ResultStream << "VER_SUITE_EMBEDDEDNT ";
    }
    if (wProductSuite & VER_SUITE_DATACENTER)
    {
        ResultStream << "VER_SUITE_DATACENTER ";
    }
    if (wProductSuite & VER_SUITE_SINGLEUSERTS)
    {
        ResultStream << "VER_SUITE_SINGLEUSERTS ";
    }
    if (wProductSuite & VER_SUITE_PERSONAL)
    {
        ResultStream << "VER_SUITE_PERSONAL ";
    }
    return ePassed;
}

/*
TCHAR *IsServer ()
{
    return IsItServer() ? _T("Its a Server") : _T("Its a WorkStation");
}
*/



EResult IsKernelTSEnable (ostrstream &ResultStream)
{
	ASSERT(IsItLocalMachine());
    if (IsTerminalServicesEnabled())
	{
		ResultStream << "Yes.";
		return ePassed;
	}
	else
	{
		ResultStream << "No.";
		return eFailed;
	}
}

bool TSEnabled ()
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwTSEnabled = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSEnabled"), &dwTSEnabled))
        {
            return dwTSEnabled == 1;
        }
    }

    return false;
}

EResult TSEnabled (ostrstream &ResultStream)
{
    if (TSEnabled())
	{
		ResultStream << "Yes.";
		return ePassed;
	}
	else
	{
		ResultStream << "No.";
		return eFailed;
	}
}

EResult DoesProductSuiteContainTS (ostrstream &ResultStream)
{
    if (DoesHydraKeysExists())
	{
		ResultStream << "Yes.";
		return ePassed;
	}
	else
	{
		ResultStream << "No.";
		return eFailed;
	}
}

EResult IsTerminalServerRegistryOk (ostrstream &ResultStream)
{
    CRegistry reg1;
    CRegistry reg2;
    CRegistry reg3;

    if (
    (ERROR_SUCCESS == reg1.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName())) &&
    (ERROR_SUCCESS == reg2.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations"), KEY_READ, CTSTestData::GetMachineName())) &&
    (ERROR_SUCCESS == reg3.OpenKey(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName())))
	{
		ResultStream << "Yes.";
		return ePassed;
	}
	else
	{
		ResultStream << "No.";
		return eFailed;
	}
}

EResult GetWinstationList (ostrstream &ResultStream)
{
	USES_CONVERSION;
    CRegistry reg2;
    
	bool bFoundNonConsoleWinstation = false;

    if (ERROR_SUCCESS == reg2.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations"), KEY_READ, CTSTestData::GetMachineName()))
    {
        LPTSTR szWinstation;
        DWORD dwSize;
		bool bFirst = true;

        if (ERROR_SUCCESS == reg2.GetFirstSubKey(&szWinstation, &dwSize))
        {
            do
            {
                if (0 != _tcsicmp(szWinstation, _T("Console")))
                {
                    bFoundNonConsoleWinstation = true;
                }

                if (!bFirst)
                {
					ResultStream << ", ";
                }

				ResultStream << T2A(szWinstation);
                bFirst = false;
            }
            while (ERROR_SUCCESS == reg2.GetNextSubKey(&szWinstation, &dwSize));
        }
    }
	else
	{
		ResultStream << "Failed to open winstations registry";
		return eFailed;
	}

    if (!bFoundNonConsoleWinstation)
    {
        // ResultStream << "Error, Only Console Winstation found";
		return eFailed;
    }
	else
	{
		return ePassed;
	}
}

EResult IsTerminalServiceStartBitSet (ostrstream &ResultStream)
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermService"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwTermServStartBit = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("Start"), &dwTermServStartBit))
        {
            switch (dwTermServStartBit)
            {
                case 2:
                ResultStream << "AutoStart";
                break;

                case 3:
                ResultStream << "Manual Start";
                break;

                case 4:
                ResultStream << "Error, Disabled";
                break;

                default:
                ResultStream << "ERROR:Wrong value for startbit";
            }

			if (IsIt50TS())
			{
				if (2 == dwTermServStartBit)
					return ePassed;
				else
					return eFailed;
			}
			else
			{
				if (IsIt51TS())
				{
					if (3 == dwTermServStartBit)
						return ePassed;
					else
						return eFailed;
				}

				ResultStream << "what version of its is it ?";
				return eFailedToExecute;
			}
        }
		else
		{
			ResultStream << "Failed to read startbit";
			return eFailedToExecute;
		}
    }
	else
	{
		ResultStream << "Failed to read startbit";
		return eFailedToExecute;
	}
}

bool IsTermDDStartBitSet ()
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermDD"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwTermDDStartBit = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("Start"), &dwTermDDStartBit))
        {
            return dwTermDDStartBit == 2;
        }
    }

    return false;
}

EResult IsGroupPolicyOk (ostrstream &ResultStream)
{
	CRegistry reg;
	if (ERROR_SUCCESS == reg.OpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services"), KEY_READ, CTSTestData::GetMachineName()))
	{
		DWORD dwDenyConnections;
		if (ERROR_SUCCESS == reg.ReadRegDWord(_T("fDenyTSConnections"), &dwDenyConnections))
		{
			if (dwDenyConnections == 0)
			{
				ResultStream << "Passed";
				return ePassed;
			}
			else
			{
				ResultStream << "Group Policy does not allow connections";
				return eFailed;
			}
		}
	}

	ResultStream << "Passed,Policy does not exist";
	return ePassed;

}

/*
bool AreEffectiveConnectionAllowed ()
{
    HMODULE hmodRegAPI = LoadLibrary( _T("RegApi.dll") );

    if (hmodRegAPI)
    {
        typedef BOOLEAN (*PFDenyConnectionPolicy) ();
        PFDenyConnectionPolicy pfnDenyConnectionPolicy;

        pfnDenyConnectionPolicy = (PFDenyConnectionPolicy) GetProcAddress( hmodRegAPI, "RegDenyTSConnectionsPolicy");
        if (pfnDenyConnectionPolicy)
        {
              return (*pfnDenyConnectionPolicy)() ? false : true;

        }
        else
        {
            szMoreInfo << "Failed to get proc RegDenyTSConnectionsPolicy" << endl;
            return false;
        }
    }
    else
    {
       szMoreInfo << "Failed to Load regapi.dll" << endl;
       return false;
    }


}
*/

EResult AreConnectionsAllowed(ostrstream &ResultStream)
{
	DWORD dwError;
	CRegistry oRegTermsrv;

	dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName());
	if (ERROR_SUCCESS == dwError)
	{
		DWORD dwDenyConnect;
		dwError = oRegTermsrv.ReadRegDWord(_T("fDenyTSConnections"), &dwDenyConnect);
		if (ERROR_SUCCESS == dwError)
		{
			if (dwDenyConnect == 1)
			{
				ResultStream << "Failed, Connections are denied";
				return eFailed;
			}
			else
			{
				ResultStream << "Passed, Connections are allowed";
				return ePassed;
			}
		}
		else
		{
			ResultStream << "failed to read value";
			return eFailedToExecute;
		}

	}
	else
	{
		ResultStream << "failed to open key";
		return eFailedToExecute;
	}
}

bool GetTSOCLogFileName(char *strFileName, UINT uiSize)
{

	USES_CONVERSION;
	if (CTSTestData::GetMachineName())
	{
		strcpy(strFileName, T2A(CTSTestData::GetMachineNamePath()));
		strcat(strFileName, "\\admin$");
	}
	else
	{
		if (!GetSystemWindowsDirectoryA(strFileName, uiSize))
			return false;
	}

    strcat(strFileName, "\\tsoc.log");
    ASSERT(strlen(strFileName) < uiSize);
    return true;
}

char *IncompleteMessage = "Error:TSOC Did not get OC_COMPLETE_INSTALLATION.";
EResult DidTsOCgetCompleteInstallationMessage (ostrstream &ResultStream)
{
    if (!IsTSOClogPresent())
    {
        ResultStream << "Failed because tsoc.log does not exist." << endl;
        return eFailedToExecute;
    }

    char strTSOCLog[256];
    GetTSOCLogFileName(strTSOCLog, 256);

	ifstream ifSrc(strTSOCLog);
	if(!ifSrc)
    {
        ResultStream << "Failed to open tsoc.log file." << endl;
        return eFailedToExecute;
    }


    char tempSrc[256];
	while(!ifSrc.eof())
	{
		ifSrc.getline(tempSrc, 256);
        if (strstr(tempSrc, IncompleteMessage))
        {
			ResultStream << "Failed";
            return eFailed;
        }
	}

	ResultStream << "Passed";
    return ePassed;
}

bool FileExists(char *pszFullNameAndPath)
{
    ASSERT(pszFullNameAndPath);

    if (pszFullNameAndPath && pszFullNameAndPath[0])
    {
        HANDLE hFile = CreateFileA(pszFullNameAndPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
					              NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	    if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
            return true;
        }
    }

    return false;
}


bool IsTSOClogPresent ()
{
    char strTSOCLog[256];
    GetTSOCLogFileName(strTSOCLog, 256);
    return FileExists(strTSOCLog);
}

EResult IsTSOClogPresent (ostrstream &ResultStream)
{
	if (IsTSOClogPresent ())
	{
		ResultStream << "Passed";
		return ePassed;
	}
	else
	{
		ResultStream << "Failed";
		return eFailed;
	}

}

EResult DidOCMInstallTSEnable(ostrstream &ResultStream)
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\SubComponents"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwTSEnabled = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("tsenable"), &dwTSEnabled))
        {
            if (dwTSEnabled == 1)
			{
				ResultStream << "Passed";
				return ePassed;
			}
			else
			{
				ResultStream << "Failed";
				return eFailed;
			}
        }
		else
		{
			ResultStream << "Failed to open Value";
			return eFailed;
		}
    }
	else
	{
		ResultStream << "Failed to open key";
		return eFailedToExecute;
	}

}


EResult IsClusteringInstalled  (ostrstream &ResultStream)
{
    DWORD dwClusterState;
    if (ERROR_SUCCESS == GetNodeClusterState(NULL, &dwClusterState))
    {
        if (dwClusterState != ClusterStateNotInstalled)
        {
			ResultStream <<  "***Failed. Clustering is installed.";
            return eFailed;
		}

    }

	ResultStream <<  "Passed.";
    return ePassed;
}


EResult GetTSMode  (ostrstream &ResultStream)
{
	if (!IsItServer() && !IsRemoteAdminMode())
	{
			ResultStream << "ERROR:The machine is in app server Mode for Professional";
			return eFailed;
	}
	else
	{
		ResultStream << (IsRemoteAdminMode() ?  "Remote Admin" : "Application Server");
		return ePassed;
	}
}

bool IsRemoteAdminMode ()
{
    // HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server","TSAppCompat",0x00010001,0x0
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwAppCompat = 1;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSAppCompat"), &dwAppCompat))
        {
            return dwAppCompat == 0;
        }
        else
        {
            // if the registry TSAppCompat does not exist it means we are in app server mode.
            return false;
        }
    }

    // this return is bogus.
    return true;

}

EResult VerifyModeRegistry (ostrstream &ResultStream)
{
    if (CheckModeRegistry(!IsRemoteAdminMode(), ResultStream))
	{
		ResultStream << "Passed";
		return ePassed;
	}
	else
	{
		ResultStream << "Failed";
		return eFailed;
	}
}

bool CheckModeRegistry (bool bAppCompat, ostrstream &ResultStream)
{
    USES_CONVERSION;
    bool bOk = true;

    CRegistry reg;

    if (IsItServer())
    {
        CRegistry reg1;
        if ( ERROR_SUCCESS == reg1.OpenKey( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), KEY_READ, CTSTestData::GetMachineName()))
        {
            LPTSTR str;
            DWORD dwSize;
            if (ERROR_SUCCESS == reg1.ReadRegString(_T("AppSetup"), &str, &dwSize))
            {
                if (bAppCompat)
                {
                    if (_tcsicmp(str, _T("UsrLogon.Cmd")) != 0)
                    {
                        bOk = false;
                        ResultStream << "ERROR: Wrong value (" << T2A(str) << ") for AppSetup, contact makarp/breenh" << endl;
                    }

                }
                else
                {
                    if (_tcslen(str) != 0)
                    {
                        bOk = false;
                        ResultStream << "ERROR: Wrong value (" << T2A(str) << ") for AppSetup, contact makarp/breenh" << endl;

                    }

                }

            }
            else
            {
                ResultStream << "ERROR reading appsetup registry" << endl;
                bOk = false;
            }

        }
        else
        {
            ResultStream << "ERROR:reading SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon" << endl;
            bOk = false;
        }

    }


    // check registry value
    // for appcompat mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\PriorityControl","Win32PrioritySeparation", 0x00010001,0x26
    // and for remote admin mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\PriorityControl","Win32PrioritySeparation", 0x00010001,0x18

    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\PriorityControl"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwPriority;
        if (ERROR_SUCCESS == reg.ReadRegDWord(_T("Win32PrioritySeparation"), &dwPriority))
        {
            if (bAppCompat)
            {
                if (0x26 != dwPriority)
                {
                    bOk = false;
                    ResultStream << "ERROR: Wrong Win32PrioritySeparation (" << dwPriority << ")" << endl;
                }

            }
            else if (IsItServer())
            {
                if (0x18 != dwPriority)
                {
                    bOk = false;
                    ResultStream << "ERROR: Wrong Win32PrioritySeparation (" << dwPriority << ")" << endl;
                }

            }
        }
        else
        {
            bOk = false;
            ResultStream << "ERROR:Reading Win32PrioritySeparation registry" << endl;

        }

    }
    else
    {
        bOk = false;
        ResultStream << "ERROR:Reading PriorityControl registry" << endl;
    }


    // check registry value
    // for appcompat mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server","IdleWinStationPoolCount",0x00010001,0x2
    // and for remote admin mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server","IdleWinStationPoolCount",0x00010001,0x0


    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwIdleWinstations;
        if (ERROR_SUCCESS == reg.ReadRegDWord(_T("IdleWinStationPoolCount"), &dwIdleWinstations))
        {
            if (bAppCompat)
            {
                if (0x2 != dwIdleWinstations)
                {
                    bOk = false;
                    ResultStream << "ERROR: Wrong IdleWinStationPoolCount (" << dwIdleWinstations << ")" << endl;
                }

            }
            else
            {
                if (0 != dwIdleWinstations)
                {
                    bOk = false;
                    ResultStream << "ERROR: Wrong IdleWinStationPoolCount (" << dwIdleWinstations << ")" << endl;
                }

            }

        }
    