wStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_AttachControl_Proxy( 
    IAxWinHostWindow __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkControl,
    /* [in] */ HWND hWnd);


void __RPC_STUB IAxWinHostWindow_AttachControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_QueryControl_Proxy( 
    IAxWinHostWindow __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IAxWinHostWindow_QueryControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_SetExternalDispatch_Proxy( 
    IAxWinHostWindow __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pDisp);


void __RPC_STUB IAxWinHostWindow_SetExternalDispatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_SetExternalUIHandler_Proxy( 
    IAxWinHostWindow __RPC_FAR * This,
    /* [in] */ IDocHostUIHandlerDispatch __RPC_FAR *pDisp);


void __RPC_STUB IAxWinHostWindow_SetExternalUIHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAxWinHostWindow_INTERFACE_DEFINED__ */


#ifndef __IAxWinAmbientDispatch_INTERFACE_DEFINED__
#define __IAxWinAmbientDispatch_INTERFACE_DEFINED__

/* interface IAxWinAmbientDispatch */
/* [unique][helpstring][uuid][dual][object] */ 


EXTERN_C const IID IID_IAxWinAmbientDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6EA2051-048A-11d1-82B9-00C04FB9942E")
    IAxWinAmbientDispatch : public IDispatch
    {
    public:
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowWindowlessActivation( 
            /* [in] */ VARIANT_BOOL bCanWindowlessActivate) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowWindowlessActivation( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanWindowlessActivate) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR clrBackground) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclrBackground) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
            /* [in] */ OLE_COLOR clrForeground) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclrForeground) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LocaleID( 
            /* [in] */ LCID lcidLocaleID) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocaleID( 
            /* [retval][out] */ LCID __RPC_FAR *plcidLocaleID) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_UserMode( 
            /* [in] */ VARIANT_BOOL bUserMode) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UserMode( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbUserMode) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DisplayAsDefault( 
            /* [in] */ VARIANT_BOOL bDisplayAsDefault) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayAsDefault( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbDisplayAsDefault) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Font( 
            /* [in] */ IFontDisp __RPC_FAR *pFont) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *pFont) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MessageReflect( 
            /* [in] */ VARIANT_BOOL bMsgReflect) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MessageReflect( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbMsgReflect) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowGrabHandles( 
            VARIANT_BOOL __RPC_FAR *pbShowGrabHandles) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowHatching( 
            VARIANT_BOOL __RPC_FAR *pbShowHatching) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DocHostFlags( 
            /* [in] */ DWORD dwDocHostFlags) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DocHostFlags( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwDocHostFlags) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DocHostDoubleClickFlags( 
            /* [in] */ DWORD dwDocHostDoubleClickFlags) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DocHostDoubleClickFlags( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwDocHostDoubleClickFlags) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowContextMenu( 
            /* [in] */ VARIANT_BOOL bAllowContextMenu) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowContextMenu( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbAllowContextMenu) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowShowUI( 
            /* [in] */ VARIANT_BOOL bAllowShowUI) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowShowUI( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbAllowShowUI) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_OptionKeyPath( 
            /* [in] */ BSTR bstrOptionKeyPath) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OptionKeyPath( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOptionKeyPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAxWinAmbientDispatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAxWinAmbientDispatch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAxWinAmbientDispatch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllowWindowlessActivation )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bCanWindowlessActivate);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowWindowlessActivation )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanWindowlessActivate);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackColor )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ OLE_COLOR clrBackground);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackColor )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclrBackground);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ForeColor )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ OLE_COLOR clrForeground);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ForeColor )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclrForeground);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocaleID )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ LCID lcidLocaleID);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocaleID )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ LCID __RPC_FAR *plcidLocaleID);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserMode )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bUserMode);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UserMode )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbUserMode);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplayAsDefault )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bDisplayAsDefault);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayAsDefault )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbDisplayAsDefault);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Font )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ IFontDisp __RPC_FAR *pFont);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Font )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *pFont);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MessageReflect )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bMsgReflect);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MessageReflect )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbMsgReflect);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowGrabHandles )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            VARIANT_BOOL __RPC_FAR *pbShowGrabHandles);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowHatching )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            VARIANT_BOOL __RPC_FAR *pbShowHatching);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DocHostFlags )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ DWORD dwDocHostFlags);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocHostFlags )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwDocHostFlags);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DocHostDoubleClickFlags )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ DWORD dwDocHostDoubleClickFlags);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocHostDoubleClickFlags )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwDocHostDoubleClickFlags);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllowContextMenu )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bAllowContextMenu);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowContextMenu )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbAllowContextMenu);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllowShowUI )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bAllowShowUI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowShowUI )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbAllowShowUI);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OptionKeyPath )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [in] */ BSTR bstrOptionKeyPath);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OptionKeyPath )( 
            IAxWinAmbientDispatch __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOptionKeyPath);
        
        END_INTERFACE
    } IAxWinAmbientDispatchVtbl;

    interface IAxWinAmbientDispatch
    {
        CONST_VTBL struct IAxWinAmbientDispatchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAxWinAmbientDispatch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinAmbientDispatch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAxWinAmbientDispatch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAxWinAmbientDispatch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAxWinAmbientDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAxWinAmbientDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAxWinAmbientDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAxWinAmbientDispatch_put_AllowWindowlessActivation(This,bCanWindowlessActivate)	\
    (This)->lpVtbl -> put_AllowWindowlessActivation(This,bCanWindowlessActivate)

#define IAxWinAmbientDispatch_get_AllowWindowlessActivation(This,pbCanWindowlessActivate)	\
    (This)->lpVtbl -> get_AllowWindowlessActivation(This,pbCanWindowlessActivate)

#define IAxWinAmbientDispatch_put_BackColor(This,clrBackground)	\
    (This)->lpVtbl -> put_BackColor(This,clrBackground)

#define IAxWinAmbientDispatch_get_BackColor(This,pclrBackground)	\
    (This)->lpVtbl -> get_BackColor(This,pclrBackground)

#define IAxWinAmbientDispatch_put_ForeColor(This,clrForeground)	\
    (This)->lpVtbl -> put_ForeColor(This,clrForeground)

#define IAxWinAmbientDispatch_get_ForeColor(This,pclrForeground)	\
    (This)->lpVtbl -> get_ForeColor(This,pclrForeground)

#define IAxWinAmbientDispatch_put_LocaleID(This,lcidLocaleID)	\
    (This)->lpVtbl -> put_LocaleID(This,lcidLocaleID)

#define IAxWinAmbientDispatch_get_LocaleID(This,plcidLocaleID)	\
    (This)->lpVtbl -> get_LocaleID(This,plcidLocaleID)

#define IAxWinAmbientDispatch_put_UserMode(This,bUserMode)	\
    (This)->lpVtbl -> put_UserMode(This,bUserMode)

#define IAxWinAmbientDispatch_get_UserMode(This,pbUserMode)	\
    (This)->lpVtbl -> get_UserMode(This,pbUserMode)

#define IAxWinAmbientDispatch_put_DisplayAsDefault(This,bDisplayAsDefault)	\
    (This)->lpVtbl -> put_DisplayAsDefault(This,bDisplayAsDefault)

#define IAxWinAmbientDispatch_get_DisplayAsDefault(This,pbDisplayAsDefault)	\
    (This)->lpVtbl -> get_DisplayAsDefault(This,pbDisplayAsDefault)

#define IAxWinAmbientDispatch_put_Font(This,pFont)	\
    (This)->lpVtbl -> put_Font(This,pFont)

#define IAxWinAmbientDispatch_get_Font(This,pFont)	\
    (This)->lpVtbl -> get_Font(This,pFont)

#define IAxWinAmbientDispatch_put_MessageReflect(This,bMsgReflect)	\
    (This)->lpVtbl -> put_MessageReflect(This,bMsgReflect)

#define IAxWinAmbientDispatch_get_MessageReflect(This,pbMsgReflect)	\
    (This)->lpVtbl -> get_MessageReflect(This,pbMsgReflect)

#define IAxWinAmbientDispatch_get_ShowGrabHandles(This,pbShowGrabHandles)	\
    (This)->lpVtbl -> get_ShowGrabHandles(This,pbShowGrabHandles)

#define IAxWinAmbientDispatch_get_ShowHatching(This,pbShowHatching)	\
    (This)->lpVtbl -> get_ShowHatching(This,pbShowHatching)

#define IAxWinAmbientDispatch_put_DocHostFlags(This,dwDocHostFlags)	\
    (This)->lpVtbl -> put_DocHostFlags(This,dwDocHostFlags)

#define IAxWinAmbientDispatch_get_DocHostFlags(This,pdwDocHostFlags)	\
    (This)->lpVtbl -> get_DocHostFlags(This,pdwDocHostFlags)

#define IAxWinAmbientDispatch_put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)	\
    (This)->lpVtbl -> put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatch_get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)	\
    (This)->lpVtbl -> get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatch_put_AllowContextMenu(This,bAllowContextMenu)	\
    (This)->lpVtbl -> put_AllowContextMenu(This,bAllowContextMenu)

#define IAxWinAmbientDispatch_get_AllowContextMenu(This,pbAllowContextMenu)	\
    (This)->lpVtbl -> get_AllowContextMenu(This,pbAllowContextMenu)

#define IAxWinAmbientDispatch_put_AllowShowUI(This,bAllowShowUI)	\
    (This)->lpVtbl -> put_AllowShowUI(This,bAllowShowUI)

#define IAxWinAmbientDispatch_get_AllowShowUI(This,pbAllowShowUI)	\
    (This)->lpVtbl -> get_AllowShowUI(This,pbAllowShowUI)

#define IAxWinAmbientDispatch_put_OptionKeyPath(This,bstrOptionKeyPath)	\
    (This)->lpVtbl -> put_OptionKeyPath(This,bstrOptionKeyPath)

#define IAxWinAmbientDispatch_get_OptionKeyPath(This,pbstrOptionKeyPath)	\
    (This)->lpVtbl -> get_OptionKeyPath(This,pbstrOptionKeyPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowWindowlessActivation_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bCanWindowlessActivate);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowWindowlessActivation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowWindowlessActivation_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanWindowlessActivate);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowWindowlessActivation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_BackColor_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ OLE_COLOR clrBackground);


void __RPC_STUB IAxWinAmbientDispatch_put_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_BackColor_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pclrBackground);


void __RPC_STUB IAxWinAmbientDispatch_get_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_ForeColor_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ OLE_COLOR clrForeground);


void __RPC_STUB IAxWinAmbientDispatch_put_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ForeColor_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pclrForeground);


void __RPC_STUB IAxWinAmbientDispatch_get_ForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_LocaleID_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ LCID lcidLocaleID);


void __RPC_STUB IAxWinAmbientDispatch_put_LocaleID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_LocaleID_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ LCID __RPC_FAR *plcidLocaleID);


void __RPC_STUB IAxWinAmbientDispatch_get_LocaleID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_UserMode_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bUserMode);


void __RPC_STUB IAxWinAmbientDispatch_put_UserMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_UserMode_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbUserMode);


void __RPC_STUB IAxWinAmbientDispatch_get_UserMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DisplayAsDefault_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bDisplayAsDefault);


void __RPC_STUB IAxWinAmbientDispatch_put_DisplayAsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DisplayAsDefault_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbDisplayAsDefault);


void __RPC_STUB IAxWinAmbientDispatch_get_DisplayAsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_Font_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ IFontDisp __RPC_FAR *pFont);


void __RPC_STUB IAxWinAmbientDispatch_put_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_Font_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *pFont);


void __RPC_STUB IAxWinAmbientDispatch_get_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_MessageReflect_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bMsgReflect);


void __RPC_STUB IAxWinAmbientDispatch_put_MessageReflect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_MessageReflect_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbMsgReflect);


void __RPC_STUB IAxWinAmbientDispatch_get_MessageReflect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ShowGrabHandles_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    VARIANT_BOOL __RPC_FAR *pbShowGrabHandles);


void __RPC_STUB IAxWinAmbientDispatch_get_ShowGrabHandles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ShowHatching_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    VARIANT_BOOL __RPC_FAR *pbShowHatching);


void __RPC_STUB IAxWinAmbientDispatch_get_ShowHatching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DocHostFlags_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ DWORD dwDocHostFlags);


void __RPC_STUB IAxWinAmbientDispatch_put_DocHostFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DocHostFlags_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwDocHostFlags);


void __RPC_STUB IAxWinAmbientDispatch_get_DocHostFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DocHostDoubleClickFlags_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ DWORD dwDocHostDoubleClickFlags);


void __RPC_STUB IAxWinAmbientDispatch_put_DocHostDoubleClickFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DocHostDoubleClickFlags_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwDocHostDoubleClickFlags);


void __RPC_STUB IAxWinAmbientDispatch_get_DocHostDoubleClickFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowContextMenu_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bAllowContextMenu);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowContextMenu_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbAllowContextMenu);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowShowUI_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bAllowShowUI);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowShowUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowShowUI_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbAllowShowUI);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowShowUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_OptionKeyPath_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [in] */ BSTR bstrOptionKeyPath);


void __RPC_STUB IAxWinAmbientDispatch_put_OptionKeyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_OptionKeyPath_Proxy( 
    IAxWinAmbientDispatch __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrOptionKeyPath);


void __RPC_STUB IAxWinAmbientDispatch_get_OptionKeyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAxWinAmbientDispatch_INTERFACE_DEFINED__ */


#ifndef __IInternalConnection_INTERFACE_DEFINED__
#define __IInternalConnection_INTERFACE_DEFINED__

/* interface IInternalConnection */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IInternalConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72AD0770-6A9F-11d1-BCEC-0060088F444E")
    IInternalConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddConnection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseConnection( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternalConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInternalConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInternalConnection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInternalConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddConnection )( 
            IInternalConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseConnection )( 
            IInternalConnection __RPC_FAR * This);
        
        END_INTERFACE
    } IInternalConnectionVtbl;

    interface IInternalConnection
    {
        CONST_VTBL struct IInternalConnectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternalConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternalConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInternalConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInternalConnection_AddConnection(This)	\
    (This)->lpVtbl -> AddConnection(This)

#define IInternalConnection_ReleaseConnection(This)	\
    (This)->lpVtbl -> ReleaseConnection(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInternalConnection_AddConnection_Proxy( 
    IInternalConnection __RPC_FAR * This);


void __RPC_STUB IInternalConnection_AddConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternalConnection_ReleaseConnection_Proxy( 
    IInternalConnection __RPC_FAR * This);


void __RPC_STUB IInternalConnection_ReleaseConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInternalConnection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_atliface_0236 */
/* [local] */ 

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

ATLAPI_(INT_PTR) AtlAxDialogBoxW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
ATLAPI_(INT_PTR) AtlAxDialogBoxA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
#ifdef UNICODE
#define AtlAxDialogBox AtlAxDialogBoxW
#else
#define AtlAxDialogBox AtlAxDialogBoxA
#endif

ATLAPI_(HWND) AtlAxCreateDialogW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
ATLAPI_(HWND) AtlAxCreateDialogA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
#ifdef UNICODE
#define AtlAxCreateDialog AtlAxCreateDialogW
#else
#define AtlAxCreateDialog AtlAxCreateDialogA
#endif

ATLAPI AtlAxCreateControl(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer);
ATLAPI AtlAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, 
		REFIID iidSink=IID_NULL, IUnknown* punkSink=NULL);
ATLAPI AtlAxAttachControl(IUnknown* pControl, HWND hWnd, IUnknown** ppUnkContainer);
ATLAPI_(BOOL) AtlAxWinInit();

ATLAPI AtlAxGetHost(HWND h, IUnknown** pp);
ATLAPI AtlAxGetControl(HWND h, IUnknown** pp);

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif //_ATL_DLL_IMPL


extern RPC_IF_HANDLE __MIDL_itf_atliface_0236_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_atliface_0236_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\atl30\regobj.h ===
// RegObj.h : Declaration of the CRegObject

/////////////////////////////////////////////////////////////////////////////
// register

class ATL_NO_VTABLE CDLLRegObject : public CRegObject, public CComObjectRoot,
					  public CComCoClass<CDLLRegObject, &CLSID_Registrar>
{
public:
	CDLLRegObject() {}
	~CDLLRegObject(){CRegObject::ClearReplacements();}

BEGIN_COM_MAP(CDLLRegObject)
	COM_INTERFACE_ENTRY(IRegistrar)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CDLLRegObject)
	HRESULT FinalConstruct()
	{
		return CComObjectRoot::FinalConstruct();
	}
	void FinalRelease()
	{
		CComObjectRoot::FinalRelease();
	}
//we can't use the component because that's what we're registering
//we don't want to do the static registry because we'd have extra code
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		CComObject<CDLLRegObject>* p;
		CComObject<CDLLRegObject>::CreateInstance(&p);
		CComPtr<IRegistrar> pR;
		p->QueryInterface(IID_IRegistrar, (void**)&pR);
		return AtlModuleUpdateRegistryFromResourceD(&_Module,
			(LPCOLESTR)MAKEINTRESOURCE(IDR_Registrar), bRegister, NULL, pR);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\atl30\regobj.cpp ===
// RegObj.cpp : Implementation of CregisterApp and DLL registration.

#include "stdafx.h"
#include "resource.h"       // main symbols
#include "RegObj.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\atl30\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by atl.rc
//
#define IDS_REGISTRAR_DESC              1
#define IDS_NOT_IN_MAP                  2
#define IDS_UNEXPECTED_EOS              3
#define IDS_VALUE_SET_FAILED            4
#define IDS_RECURSE_DELETE_FAILED       5
#define IDS_EXPECTING_EQUAL             6
#define IDS_CREATE_KEY_FAILED           7
#define IDS_DELETE_KEY_FAILED           8
#define IDS_OPEN_KEY_FAILED             9
#define IDS_CLOSE_KEY_FAILED            10
#define IDS_UNABLE_TO_COERCE            11
#define IDS_BAD_HKEY                    12
#define IDS_MISSING_OPENKEY_TOKEN       13
#define IDS_CONVERT_FAILED              14
#define IDS_TYPE_NOT_SUPPORTED          15
#define IDS_COULD_NOT_CONCAT            16
#define IDS_COMPOUND_KEY                17
#define IDS_INVALID_MAPKEY              18
#define IDS_UNSUPPORTED_VT              19
#define IDS_VALUE_GET_FAILED            20
#define IDS_VALUE_TOO_LARGE             21
#define IDS_MISSING_VALUE_DELIMETER     22
#define IDS_DATA_NOT_BYTE_ALIGNED       23
#define IDS_PROJNAME                    100
#define IDR_Registrar                   101
#define IDS_STRING101                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1029
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\cdonts\cdonts.c ===
#include "windows.h"

STDAPI
DllCanUnloadNow (
    void
    )

{
    return 0;
}

STDAPI
DllGetClassObject (
    IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID FAR* ppv
    )

{
    return 0;
}

STDAPI
DllRegisterServer (
    void
    )

{
    return 0;
}

STDAPI
DllUnregisterServer (
    void
    )

{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\atl30\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#define _WIN32_WINNT 0x0501
#define _ATL_FREE_THREADED
#define _CONVERSION_USES_THREAD_LOCALE
#define _ATL_DLL_IMPL
//#define _ATL_DEBUG_QI

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <statreg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\atl30\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\cdosys\cdosys.c ===
#include "windows.h"

STDAPI
DllCanUnloadNow (
    void
    )

{
    return 0;
}

STDAPI
DllGetClassObject (
    IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID FAR* ppv
    )

{
    return 0;
}

STDAPI
DllRegisterServer (
    void
    )

{
    return 0;
}

STDAPI
DllUnregisterServer (
    void
    )

{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\atlamd64\amd64\atlamd64.asm ===
title   "Atl30 Stubs"
;++
;
; Copyright (c) 2001  Microsoft Corporation
;
; Module Name:
;
;   atl30asm.asm
;
; Abstract:
;
;   This module implements the atlcom.h call thunk helper and the atlbase.h
;   query interface implementation thunks for the AMD64 platform.
;
; Author:
;
;   David N. Cutler 18-Feb-2001
;
; Environment:
;
;   Any mode.
;
;-

include ksamd64.inc

        subttl  "Call Thunk Helper"
;++
;
; VOID
; CComStdCallThunkHelper (
;    PVOID pThunk
;    ...
;    )
;
; Routine Description:
;
;   This function forwards a call through a com call thunk.
;
; Arguments:
;
;   This (rcx) - Supplies a pointer to the thunk data.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY CComStdCallThunkHelper, _TEXT$00

        mov     rax, rcx                ; copy pThunk address
        mov     rcx, 8[rax]             ; get address of pThunk->pThis
        jmp     qword ptr 16[rax]       ; jump to pThunk->pfn

        LEAF_END CComStdCallThunkHelper, _TEXT$00

        subttl  "Query Interface Thunk Functions"
;++
;
; VOID
;  _QIThunk<nnn>(
;    IN IUnknown *This,
;    ...
;    )
;
; Routine Description:
;
;   This function forwards a call through a query interface thunk.
;
; Arguments:
;
;   This (rcx) - Supplies a pointer to the interface.
;
; Return Value:
;
;   None.
;
;--

;
; Define macro to generate forwarder functions.
;

IMPL_THUNK macro Method

        LEAF_ENTRY _QIThunk_f&Method, _TEXT$00

        mov     rcx, 8[rax]             ; get object address
        mov     rax, [rcx]              ; get vtable address
        jmp     qword ptr (&Method * 8)[rax] ; transfer to method

        LEAF_END _QIThunk_f&Method, _TEXT$00

        endm

;
; Generate forwarder functions.
;

;index = 3

;        rept    (1023 - 3 + 1)

;        IMPL_THUNK %index

;index = index + 1

;        endm

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\dskimage\identify.h ===
//
// IDENTIFY data
//

#pragma pack (push,1)
typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumCylinders;                    // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumHeads;                        // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT NumSectorsPerTrack;              // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    UCHAR  SerialNumber[20];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    UCHAR  FirmwareRevision[8];             // 2E  23-26
    UCHAR  ModelNumber[40];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:3;        // 6A  53
    USHORT Reserved3:13;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[11];                   //     69-79
    USHORT MajorRevision;                   //     80
    USHORT MinorRevision;                   //     81
    USHORT Reserved6[6];                    //     82-87
    USHORT UltraDMASupport : 8;             //     88
    USHORT UltraDMAActive  : 8;             //
    USHORT Reserved7[37];                   //     89-125
    USHORT LastLun:3;                       //     126
    USHORT Reserved8:13;
    USHORT MediaStatusNotification:2;       //     127
    USHORT Reserved9:6;
    USHORT DeviceWriteProtect:1;
    USHORT Reserved10:7;
    USHORT Reserved11[128];                  //     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\corpol\corpol.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    corpol.c

Abstract:

   This module implements stub functions for shell32 interfaces.

Author:

    David N. Cutler (davec) 1-Mar-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"

#define STUBFUNC(x)     \
int                     \
x(                      \
    void                \
    )                   \
{                       \
    return 0;           \
}

STUBFUNC(CORLockDownProvider)
STUBFUNC(CORPolicyProvider)
STUBFUNC(DllCanUnloadNow)
STUBFUNC(DllRegisterServer)
STUBFUNC(DllUnregisterServer)
STUBFUNC(GetUnsignedPermissions)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\dskimage\dskimage.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <ntddvol.h>
#include <ntdddisk.h>
#include "identify.h"

#define SECTOR_SIZE 512
#define SECTOR_MASK (SECTOR_SIZE - 1)

#define MAX_NUM_CHS_ADDRESSABLE_SECTORS 16514064

//
// Perform the copy using 8 outstanding I/Os of 128k each
//

#define COPYBUF_SIZE (128 * 1024)
#define COPYBUF_COUNT 8

//
// A failed assert will abort the process
//

#define assert(x) if (!(x)) { printf("Assert failed: %s\n", #x); exit(-1); }

typedef struct _COPYBUF {
    OVERLAPPED Overlapped;
    ULONG State;
    ULONG Bytes;
    PVOID Buffer;
} COPYBUF, *PCOPYBUF;

//
// Three possible states for a copybuf
//

#define CB_FREE  0x0
#define CB_READ  0x1
#define CB_WRITE 0x2

//
// CUSTOM_IDENTIFY_DATA consists of an IDENTIFY_DATA structure,
// along with three fields in which to pass along the "BIOS" disk
// geometry to the SIMICS simulator.
//

#pragma pack(push,1)

typedef union _CUSTOM_IDENTIFY_DATA {
    IDENTIFY_DATA IdentifyData;
    struct {
        USHORT Reserved[128];
        ULONG  Cylinders;
        USHORT Heads;
        USHORT SectorsPerTrack;
    } BiosData;
} CUSTOM_IDENTIFY_DATA, *PCUSTOM_IDENTIFY_DATA;

#pragma pack(pop)

BOOLEAN
DisplayDiskGeometry(
    IN HANDLE handle
    );

VOID
DoWrite (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG64 Offset,
    IN PCOPYBUF CopyBuf
    );

BOOLEAN
GetIdentifyData(
               IN HANDLE Handle,
               OUT PIDENTIFY_DATA IdentifyData
               );

BOOLEAN
GetVolumeInfo (
    IN PCHAR DrivePath,
    OUT PULONG DriveNumber,
    OUT PULONG PartitionNumber,
    OUT PULONG64 StartingOffset,
    OUT PULONG64 ExtentLength
    );

VOID
InitializeCopyBuffers (
    VOID
    );

VOID
MassageIdentifyData(
    VOID
    );

VOID
ProcessCompletedCopy (
    PCOPYBUF CopyBuf
    );

BOOL
ScanCopyBuffers (
    VOID
    );

VOID
StartRead (
    IN OUT PCOPYBUF CopyBuf
    );

VOID
StartWrite (
    IN OUT PCOPYBUF CopyBuf
    );

//
// Global data declarations follow
//

COPYBUF CopyBufArray[COPYBUF_COUNT];

//
//  Identifies the PhysicalDrive.
//

INT gDeviceNumber;

//
// Identifies the position of the drive on the controller
// ie. master == 0, slave == 1.
//

UCHAR gDriveNumber = 1;

HANDLE DriveHandle;
HANDLE FileHandle;

//
// CopyOffset is the byte offset between data on the source disk image and
// corresponding data in the output file.  This is used to account for the
// sector-sized prefix in the output file.
//

ULONG CopyOffset;

ULONG64 CurrentOffset;
ULONG64 DriveSize;
ULONG64 MaxSize;
UCHAR PercentComplete;
ULONG OutstandingIo;

IDENTIFY_DATA IdentifyData;
DISK_GEOMETRY DiskGeometry;

//
// Array of event handles, one per copy buffer
//

HANDLE IoEvents[COPYBUF_COUNT];

int
_cdecl main (
            int argc,
            char *argv[]
            )
{
 
    char deviceBuffer[20];
    PCHAR outputFileName;
    PCHAR drive;
    BOOLEAN result;
    ULONG64 volumeOffset;
    ULONG64 volumeSize;
    ULONG partitionNumber;
    DWORD waitResult;
    PCOPYBUF copyBuf;
    ULONG i;
 
    //
    // Must be invoked with two arguments
    // 
 
    if (argc != 3) {
        fprintf(stderr,
                "Usage: %s <drive:> <OutputFile>\n",
                argv[0]);
        exit(1);
    }
 
    InitializeCopyBuffers();
 
    //
    // Extract both arguments
    // 
 
    drive = argv[1];
    outputFileName = argv[2];
 
    result = GetVolumeInfo(drive,
                           &gDeviceNumber,
                           &partitionNumber,
                           &volumeOffset,
                           &volumeSize);
 
    if (result == FALSE) {
        exit(1);
    }
 
    //
    // Calculate how many sectors need to be in the image
    //
 
    MaxSize = (volumeOffset + volumeSize + SECTOR_MASK) / SECTOR_SIZE;
 
    sprintf(deviceBuffer,"\\\\.\\PhysicalDrive%d",
            gDeviceNumber);
 
    //
    // Open the physical source drive.
    //
 
    DriveHandle = CreateFile(deviceBuffer,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL |
                                 FILE_FLAG_NO_BUFFERING |
                                 FILE_FLAG_OVERLAPPED,
                             NULL);
 
    if (INVALID_HANDLE_VALUE == DriveHandle){
        printf("Couldn't open: %s. Drive may not exist. ",
               deviceBuffer);
        return -1;
    }
 
    //
    // Retrieve and display the BIOS disk geometry
    //
 
    result = DisplayDiskGeometry( DriveHandle );
    if (result == FALSE) {
        printf("Could not retrieve disk geometry\n");
        exit(1);
    }
 
    //
    // Reteive the identify data, if possible.  If the data could not be
    // retrieved, MassageIdentifyData() will attempt to fabricate the relevant
    // portions based on the BIOS disk geometry retrieved previously.
    //
 
    GetIdentifyData( DriveHandle,
                     &IdentifyData );
    MassageIdentifyData();
 
    DriveSize = IdentifyData.UserAddressableSectors * (ULONGLONG)512;
    if (MaxSize == 0) {
        MaxSize = DriveSize;
    } else {
        MaxSize *= 512;
    }
    printf("Drive size %dMB\n",(ULONG)(DriveSize / (1024 * 1024)));
    printf("Image size %dMB\n",(ULONG)(MaxSize / (1024 * 1024)));
 
    //
    // Open the output file
    //
 
    FileHandle = CreateFile(outputFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL |
                                FILE_FLAG_NO_BUFFERING |
                                FILE_FLAG_OVERLAPPED,
                            NULL);
    if (FileHandle == INVALID_HANDLE_VALUE) {
        printf("Could not create %s\n", outputFileName);
        return -1;
    }
 
    //
    // Write the identify data
    //
 
    CopyOffset = 0;
    CurrentOffset = 0;
 
    DoWrite(&IdentifyData,
            sizeof(IDENTIFY_DATA),
            0,
            &CopyBufArray[0]);
 
 
    //
    // Kick off reads on all of the remaining copy buffers
    //
 
    CopyOffset = sizeof(IDENTIFY_DATA);
    for (i = 1; i < COPYBUF_COUNT; i++) {
        StartRead(&CopyBufArray[i]);
    }

    //
    // Loop, processing completed I/O as appropriate.  When all
    // outstanding io has completed, the copy is complete.
    // 
 
    do {
 
        waitResult = WaitForMultipleObjects( COPYBUF_COUNT,
                                             IoEvents,
                                             FALSE,
                                             INFINITE );

        waitResult -= WAIT_OBJECT_0;
        assert(waitResult < COPYBUF_COUNT);
 
        copyBuf = &CopyBufArray[waitResult];
        ProcessCompletedCopy(copyBuf);

    } while (OutstandingIo > 0);

    //
    // The copy is finished.
    // 

    printf("%s created\n", outputFileName);
 
    CloseHandle(DriveHandle);
    CloseHandle(FileHandle);
 
    return 0;
}


VOID
InitializeCopyBuffers (
    VOID
    )
{
    ULONG bytes;
    PCOPYBUF copyBuf;
    PCOPYBUF copyBufEnd;
    ULONG i;
    HANDLE event;

    PCHAR copyBuffer;

    //
    // Make a single, sector-aligned allocation to contain all of the copy
    // buffers
    //

    bytes = COPYBUF_SIZE * COPYBUF_COUNT + SECTOR_MASK;
    copyBuffer = malloc(bytes);
    if (copyBuffer == NULL) {
        printf("Out of memory\n");
        exit(-1);
    }

    copyBuffer =
        (PCHAR)(((ULONG_PTR)copyBuffer + SECTOR_MASK) & ~SECTOR_MASK);

    //
    // Walk the copyBuf array, initializing each to point to it's portion of
    // the copy buffer
    // 

    copyBuf = CopyBufArray;

    for (i = 0; i < COPYBUF_COUNT; i++) {

        copyBuf->State = CB_FREE;
        copyBuf->Buffer = copyBuffer;

        event = CreateEvent( NULL,
                             FALSE,
                             FALSE,
                             NULL );
        assert(event != NULL);
        copyBuf->Overlapped.hEvent = event;
        IoEvents[i] = event;

        copyBuffer += COPYBUF_SIZE;
        copyBuf++;
    }
}

BOOLEAN
GetVolumeInfo (
    IN PCHAR DrivePath,
    OUT PULONG DriveNumber,
    OUT PULONG PartitionNumber,
    OUT PULONG64 StartingOffset,
    OUT PULONG64 ExtentLength
    )
{
    char deviceBuffer[20];
    HANDLE volumeHandle;
    BOOL result;
    STORAGE_DEVICE_NUMBER deviceNumber;
    PARTITION_INFORMATION partitionInformation;
    ULONG bytesReturned;

    //
    // Determine which physical drive contains the specified partition by
    //
    // - Opening the volume
    //
    // - Sending IOCTL_STORAGE_GET_DEVICE_NUMBER to retrieve the device and
    //   partition number
    //
    // - Sending IOCTL_DISK_GET_PARTITION_INFO to retrieve the starting
    //   offset and length of the volume
    //
    // - Closing the volume
    //

    sprintf(deviceBuffer, "\\\\.\\%s", DrivePath);

    volumeHandle = CreateFile(deviceBuffer,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL |
                                  FILE_FLAG_NO_BUFFERING |
                                  FILE_FLAG_OVERLAPPED,
                              NULL);

    if (volumeHandle == INVALID_HANDLE_VALUE) {
        printf("Error %d opening %s\n", GetLastError(), deviceBuffer);
        return FALSE;
    }

    result = DeviceIoControl(volumeHandle,
                             IOCTL_STORAGE_GET_DEVICE_NUMBER,
                             NULL,
                             0,
                             &deviceNumber,
                             sizeof(deviceNumber),
                             &bytesReturned,
                             NULL);
    if (result == FALSE) {

        printf("Could not get device number for %s\n", deviceBuffer);
        CloseHandle(volumeHandle);
        return FALSE;
    }

    if (deviceNumber.DeviceType != FILE_DEVICE_DISK) {
        printf("%s is not a disk\n",deviceBuffer);
        CloseHandle(volumeHandle);
        return FALSE;
    }

    bytesReturned = 0;
    result = DeviceIoControl(volumeHandle,
                             IOCTL_DISK_GET_PARTITION_INFO,
                             NULL,
                             0,
                             &partitionInformation,
                             sizeof(partitionInformation),
                             &bytesReturned,
                             NULL);
    CloseHandle(volumeHandle);
    if (result == FALSE) {
        printf("Error %d retrieving partition information for %s\n",
               GetLastError(),
               deviceBuffer);
        return FALSE;
    }

    //
    // All of the information was successfully retrieved.  Fill in the
    // output parameters and return.
    //  

    *DriveNumber = deviceNumber.DeviceNumber;
    *PartitionNumber = deviceNumber.PartitionNumber;
    *StartingOffset = partitionInformation.StartingOffset.QuadPart;
    *ExtentLength = partitionInformation.PartitionLength.QuadPart;

    return TRUE;
}

BOOLEAN
GetIdentifyData(
               IN HANDLE Handle,
               OUT PIDENTIFY_DATA IdentifyData
               )
{

    SENDCMDINPARAMS inputParams;
    PSENDCMDOUTPARAMS outputParams;
    PIDENTIFY_DATA    identifyData;
    ULONG bytesReturned;
    ULONG bufSize;
 
    ZeroMemory(&inputParams, sizeof(SENDCMDINPARAMS));
 
    bufSize = sizeof(SENDCMDOUTPARAMS) - 1 + IDENTIFY_BUFFER_SIZE;
    bufSize *= 2;
 
    outputParams = (PSENDCMDOUTPARAMS) malloc(bufSize);
    if (!outputParams) {
        printf("Out of memory\n");
        return FALSE;
    }
 
    ZeroMemory(outputParams, bufSize);
 
    //
    // Build register structure to send SMART command.
    //
 
    inputParams.irDriveRegs.bFeaturesReg     = 0;
    inputParams.irDriveRegs.bSectorCountReg  = 1;
    inputParams.irDriveRegs.bSectorNumberReg = 1;
    inputParams.irDriveRegs.bCylLowReg       = 0;
    inputParams.irDriveRegs.bCylHighReg      = 0;
    inputParams.irDriveRegs.bDriveHeadReg    = 0xA0 | ((gDriveNumber & 1) << 4);
    inputParams.irDriveRegs.bCommandReg      = ID_CMD; 
 
    bytesReturned = 0;
 
    if (!DeviceIoControl (Handle,
                          SMART_RCV_DRIVE_DATA,
                          &inputParams,
                          sizeof(SENDCMDINPARAMS) - 1,
                          outputParams,
                          bufSize,
                          &bytesReturned,
                          NULL)) {
        printf("IDE_IDENTIFY failed with 0x%x, %d bytes returned\n",
               GetLastError(),
               bytesReturned);
        
        printf("WARNING: This image file will work with the SIMICS simulator\n"
               "         but not simnow.\n");
        
        memset(IdentifyData, 0, sizeof(IDENTIFY_DATA));
        free(outputParams);
        return FALSE;
    }
 
    identifyData = (PIDENTIFY_DATA)outputParams->bBuffer;
    *IdentifyData = *identifyData;
 
    free(outputParams);
    return TRUE;
}

VOID
MassageIdentifyData(
    VOID
    )

/*++

Routine Description:

    This routine sets the bios CHS geometry in the IdentifyData structure
    in a place previously agreed upon with Simics.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PCUSTOM_IDENTIFY_DATA custom;
    ULONG sectorCount;

    USHORT ideCylinders;
    USHORT ideHeads;
    USHORT ideSectorsPerTrack;

    C_ASSERT(FIELD_OFFSET(IDENTIFY_DATA,NumCylinders)/2 == 1);
    C_ASSERT(FIELD_OFFSET(IDENTIFY_DATA,NumHeads)/2 == 3);
    C_ASSERT(FIELD_OFFSET(IDENTIFY_DATA,NumSectorsPerTrack)/2 == 6);
    C_ASSERT(FIELD_OFFSET(IDENTIFY_DATA,CurrentSectorCapacity)/2 == 57);

    //
    // Set the BIOS disk geometry in the new fields that are passed
    // along to the SIMICS simulator.
    // 

    custom = (PCUSTOM_IDENTIFY_DATA)&IdentifyData;
    custom->BiosData.Cylinders = DiskGeometry.Cylinders.LowPart;
    custom->BiosData.Heads = (USHORT)DiskGeometry.TracksPerCylinder;
    custom->BiosData.SectorsPerTrack = (USHORT)DiskGeometry.SectorsPerTrack;

    if (IdentifyData.NumCylinders == 0) {

        //
        // The IDENTIFY_DATA ioctl failed (SMART isn't supported), so parts
        // of the IDE geometry must be fabricated, including:
        //
        // - NumCylinders
        // - NumHeads
        // - NumSectorsPerTrack
        // - CurrentSectorCapacity
        // - UserAddressableSectors
        //

        sectorCount = DiskGeometry.Cylinders.LowPart *
                      DiskGeometry.TracksPerCylinder *
                      DiskGeometry.SectorsPerTrack;
    
        if (sectorCount > MAX_NUM_CHS_ADDRESSABLE_SECTORS) {

            IdentifyData.NumCylinders = 16383;
            IdentifyData.NumHeads = 16;
            IdentifyData.NumSectorsPerTrack = 63;

        } else {

            IdentifyData.NumSectorsPerTrack =
                (USHORT)DiskGeometry.SectorsPerTrack;
                
            IdentifyData.NumHeads = 16;

            IdentifyData.NumCylinders = (USHORT)
                (sectorCount / (IdentifyData.NumSectorsPerTrack *
                               IdentifyData.NumHeads));
        }

        IdentifyData.CurrentSectorCapacity = sectorCount;
        IdentifyData.UserAddressableSectors = sectorCount;
    }

    printf("IDE disk geometry:\n"
           "  Cyls    %d\n"
           "  Heads   %d\n"
           "  Sct/Trk %d\n\n"
           "BIOS disk geometry:\n"
           "  Cyls    %d\n"
           "  Heads   %d\n"
           "  Sct/Trk %d\n",

           IdentifyData.NumCylinders,
           IdentifyData.NumHeads,
           IdentifyData.NumSectorsPerTrack,

           custom->BiosData.Cylinders,
           custom->BiosData.Heads,
           custom->BiosData.SectorsPerTrack);
}


VOID
DoWrite (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG64 Offset,
    IN PCOPYBUF CopyBuf
    )
{
    LARGE_INTEGER offset;
    BOOL result;

    offset.QuadPart = Offset;

    CopyBuf->Overlapped.Offset = offset.HighPart;
    CopyBuf->Overlapped.OffsetHigh = offset.LowPart;
    CopyBuf->State = CB_READ;

    memcpy(CopyBuf->Buffer,Buffer,Length);
    CopyBuf->Bytes = Length;

    StartWrite(CopyBuf);
}

VOID
StartWrite (
    IN OUT PCOPYBUF CopyBuf
    )
{
    LARGE_INTEGER offset;
    BOOL result;
    ULONG error;

    CopyBuf->State = CB_WRITE;

    //
    // Adjust the offset
    //

    offset.LowPart = CopyBuf->Overlapped.Offset;
    offset.HighPart = CopyBuf->Overlapped.OffsetHigh;
    offset.QuadPart += CopyOffset;
    CopyBuf->Overlapped.Offset = offset.LowPart;
    CopyBuf->Overlapped.OffsetHigh = offset.HighPart;

    result = WriteFile( FileHandle,
                        CopyBuf->Buffer,
                        CopyBuf->Bytes,
                        NULL,
                        &CopyBuf->Overlapped );
    if (result == FALSE) {
        error = GetLastError();
        if (error != ERROR_IO_PENDING &&
            error != ERROR_IO_INCOMPLETE) {

            printf("Error %d returned from write\n",error);
            exit(-1);
        }
    }

    OutstandingIo += 1;
}

VOID
StartRead (
    IN OUT PCOPYBUF CopyBuf
    )
{
    LARGE_INTEGER offset;
    BOOL result;
    ULONG64 length;
    ULONG error;

    if (CurrentOffset == MaxSize) {
        return;
    }

    length = MaxSize - CurrentOffset;
    if (length > COPYBUF_SIZE) {
        length = COPYBUF_SIZE;
    }

    CopyBuf->State = CB_READ;

    offset.QuadPart = CurrentOffset;
    CurrentOffset += length;

    CopyBuf->Overlapped.Offset = offset.LowPart;
    CopyBuf->Overlapped.OffsetHigh = offset.HighPart;

    result = ReadFile( DriveHandle,
                       CopyBuf->Buffer,
                       (ULONG)length,
                       NULL,
                       &CopyBuf->Overlapped );

    if (result == FALSE) {
        error = GetLastError();
        if (error != ERROR_IO_PENDING &&
            error != ERROR_IO_INCOMPLETE) {

            printf("Error %d returned from read\n",error);
            exit(-1);
        }
    }

    OutstandingIo += 1;
}

BOOLEAN
DisplayDiskGeometry(
    IN HANDLE handle
    )
{
    BOOL result;
    ULONG bytesReturned;

    result = DeviceIoControl(handle,
                             IOCTL_DISK_GET_DRIVE_GEOMETRY,
                             NULL,
                             0,
                             &DiskGeometry,
                             sizeof(DiskGeometry),
                             &bytesReturned,
                             NULL);
    if (result == FALSE) {
        return FALSE;
    }

    printf("%I64d Cylinders %d Heads %d Sectors/Track\n",
            DiskGeometry.Cylinders.QuadPart,
            DiskGeometry.TracksPerCylinder,
            DiskGeometry.SectorsPerTrack);

    return TRUE;
}

VOID
ProcessCompletedCopy (
    PCOPYBUF CopyBuf
    )
{
    UCHAR percent;
    HANDLE handle;
    BOOL result;

    //
    // Decrement the outstanding Io count.  Successfully starting another
    // read or write will increment it again.
    //

    OutstandingIo -= 1;

    //
    // We have found a buffer with either a read or a write in progress.
    // Retrieve the number of bytes transferred.
    // 

    if (CopyBuf->State == CB_READ) {
        handle = DriveHandle;
    } else {
        handle = FileHandle;
    }

    result = GetOverlappedResult( handle,
                                  &CopyBuf->Overlapped,
                                  &CopyBuf->Bytes,
                                  FALSE );
    assert(result != FALSE);

    if (CopyBuf->State == CB_READ) {

        //
        // This buffer contains data read from the drive, kick off a write
        // to the output file.
        //

        StartWrite(CopyBuf);

    } else {

        //
        // This buffer represents data that has been written to the drive.
        // Use it to start another read.
        //

        percent = (UCHAR)((CurrentOffset * 100) / MaxSize);
        if (percent != PercentComplete) {
            printf("%d%%\r",percent);
            PercentComplete = percent;
        }

        StartRead(CopyBuf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hh\funcs.h ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

// *********************** Assertion Definitions ************************** //

// Get rid of any previously defined versions

#undef ASSERT
#undef VERIFY

#ifndef THIS_FILE
#define THIS_FILE __FILE__
#endif

// *********************** Function Prototypes **************************** //

PCSTR GetStringResource(int idString);

// *********************** Debug/Internal Functions ********************** //

#ifdef INTERNAL

void AssertErrorReport(PCSTR pszExpression, UINT line, LPCSTR pszFile);

// IASSERT is available in INTERNAL retail builds

#define IASSERT(exp) \
	{ \
		((exp) ? (void) 0 : \
			AssertErrorReport(#exp, __LINE__, THIS_FILE)); \
	}

#define IASSERT_COMMENT(exp, pszComment) \
	{ \
		((exp) ? (void) 0 : \
			AssertErrorReport(pszComment, __LINE__, THIS_FILE)); \
	}

#else

#define IASSERT(exp)
#define IASSERT_COMMENT(exp, pszComment)

#endif

#ifdef _DEBUG

#define ASSERT(exp) \
	{ \
		((exp) ? (void) 0 : \
			AssertErrorReport(#exp, __LINE__, THIS_FILE)); \
	}

#define ASSERT_COMMENT(exp, pszComment) \
	{ \
		((exp) ? (void) 0 : \
			AssertErrorReport(pszComment, __LINE__, THIS_FILE)); \
	}

#define FAIL(pszComment) AssertErrorReport(pszComment, __LINE__, THIS_FILE);

#define VERIFY(exp) 	ASSERT(exp)
#define VERIFY_RESULT(exp1, exp2)	ASSERT((exp1) == (exp2))
#define DEBUG_ReportOleError doReportOleError
void doReportOleError(HRESULT hres);
#define DBWIN(psz) { OutputDebugString(psz); OutputDebugString("\n"); }

#define CHECK_POINTER(val) if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) return E_POINTER

int 		MsgBox(int idString, UINT nType = MB_OK);
int 		MsgBox(PCSTR pszMsg, UINT nType = MB_OK);

#else // non-debugging version

#define ASSERT(exp)
#define ASSERT_COMMENT(exp, pszComment)
#define VERIFY(exp) ((void)(exp))
#define VERIFY_RESULT(exp1, exp2) ((void)(exp))
#define DEBUG_ReportOleError(hres)
#define DBWIN(psz)
#define FAIL(pszComment)
#define CHECK_POINTER(val)

#define THIS_FILE  __FILE__

#endif

#define ZERO_STRUCTURE(foo) ClearMemory(&foo, sizeof(foo))
#define ClearMemory(p, cb) memset(p, 0, cb)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hh\header.h ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#define NOATOM
#define NOCOMM
#define NODEFERWINDOWPOS
#define NODRIVERS
#define NOEXTDEVMODEPROPSHEET
#define NOIME
#define NOKANJI
#define NOLOGERROR
#define NOMCX
#define NOPROFILER
#define NOSCALABLEFONT
#define NOSERVICE
#define NOSOUND

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#define WINVER 0x0400

#ifndef STRICT
#define STRICT
#endif

#ifndef FASTCALL
#define FASTCALL __fastcall
#endif

#ifndef STDCALL
#define STDCALL __stdcall
#endif

#ifndef INLINE
#define INLINE __inline 		// Remove for profiling
#endif

//////////////////////////////////// Includes ///////////////////////////////

#include <windows.h>
#include <ole2.h>	// to get HRESULT

#include "funcs.h"
#include "..\hhctrl\shared.h"
#include "..\hhctrl\lcmem.h"
#include "..\hhctrl\cstr.h"

/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
#define STATIC		// because icecap doesn't believe in static functions
#else
#define STATIC static
#endif

extern BOOL 		g_fHhaLoaded;  // TRUE if hha.dll has been loaded
extern BOOL 		g_fTriedHHA;   // TRUE if we already tried to load hha.dll
extern HINSTANCE	g_hinst;

#define HINST_THIS g_hinst
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\expsrv\expsrv.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    expsrv.c

Abstract:

   This module implements stub functions for shell32 interfaces.

Author:

    David N. Cutler (davec) 11-Jun-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"

#define STUBFUNC(x)     \
int                     \
x(                      \
    void                \
    )                   \
{                       \
    return 0;           \
}

STUBFUNC(BASIC_CLASS_AddRef)
STUBFUNC(BASIC_CLASS_GetIDsOfNames)
STUBFUNC(BASIC_CLASS_Invoke)
STUBFUNC(BASIC_CLASS_QueryInterface)
STUBFUNC(BASIC_CLASS_Release)
STUBFUNC(BASIC_DISPINTERFACE_GetTICount)
STUBFUNC(BASIC_DISPINTERFACE_GetTypeInfo)
STUBFUNC(CopyRecord)
STUBFUNC(CreateIExprSrvObj)
STUBFUNC(DllFunctionCall)
STUBFUNC(EVENT_SINK2_AddRef)
STUBFUNC(EVENT_SINK2_Release)
STUBFUNC(EVENT_SINK_AddRef)
STUBFUNC(EVENT_SINK_GetIDsOfNames)
STUBFUNC(EVENT_SINK_Invoke)
STUBFUNC(EVENT_SINK_QueryInterface)
STUBFUNC(EVENT_SINK_Release)
STUBFUNC(EbCreateContext)
STUBFUNC(EbDestroyContext)
STUBFUNC(EbGetErrorInfo)
STUBFUNC(EbGetHandleOfExecutingProject)
STUBFUNC(EbGetObjConnectionCounts)
STUBFUNC(EbGetVBAObject)
STUBFUNC(EbIsProjectOnStack)
STUBFUNC(EbLibraryLoad)
STUBFUNC(EbLibraryUnload)
STUBFUNC(EbLoadRunTime)
STUBFUNC(EbResetProject)
STUBFUNC(EbResetProjectNormal)
STUBFUNC(EbSetContextWorkerThread)
STUBFUNC(GetMem1)
STUBFUNC(GetMem2)
STUBFUNC(GetMem4)
STUBFUNC(GetMem8)
STUBFUNC(GetMemEvent)
STUBFUNC(GetMemNewObj)
STUBFUNC(GetMemObj)
STUBFUNC(GetMemR4)
STUBFUNC(GetMemR8)
STUBFUNC(GetMemStr)
STUBFUNC(GetMemVar)
STUBFUNC(IID_IVbaHost)
STUBFUNC(PpExSPCur)
STUBFUNC(ProcEntry)
STUBFUNC(PutMem1)
STUBFUNC(PutMem2)
STUBFUNC(PutMem4)
STUBFUNC(PutMem8)
STUBFUNC(PutMemEvent)
STUBFUNC(PutMemNewObj)
STUBFUNC(PutMemObj)
STUBFUNC(PutMemR4)
STUBFUNC(PutMemR8)
STUBFUNC(PutMemStr)
STUBFUNC(PutMemVar)
STUBFUNC(SetMemEvent)
STUBFUNC(SetMemNewObj)
STUBFUNC(SetMemObj)
STUBFUNC(SetMemVar)
STUBFUNC(TPPExSP)
STUBFUNC(TipCreateInstanceEx)
STUBFUNC(TipCreateInstanceProject2)
STUBFUNC(TipGetAddressOfPredeclaredInstance)
STUBFUNC(TipInvokeMethod)
STUBFUNC(TipInvokeMethod2)
STUBFUNC(TipSetOption)
STUBFUNC(TipUnloadInstance)
STUBFUNC(TipUnloadProject)
STUBFUNC(VarPtr)
STUBFUNC(Zombie_AddRef)
STUBFUNC(Zombie_GetIDsOfNames)
STUBFUNC(Zombie_GetTypeInfo)
STUBFUNC(Zombie_GetTypeInfoCount)
STUBFUNC(Zombie_Invoke)
STUBFUNC(Zombie_QueryInterface)
STUBFUNC(Zombie_Release)
STUBFUNC(__vbaAryConstruct)
STUBFUNC(__vbaAryConstruct2)
STUBFUNC(__vbaAryCopy)
STUBFUNC(__vbaAryDestruct)
STUBFUNC(__vbaAryLock)
STUBFUNC(__vbaAryMove)
STUBFUNC(__vbaAryRebase1Var)
STUBFUNC(__vbaAryRecCopy)
STUBFUNC(__vbaAryRecMove)
STUBFUNC(__vbaAryUnlock)
STUBFUNC(__vbaAryVar)
STUBFUNC(__vbaAryVarVarg)
STUBFUNC(__vbaBoolErrVar)
STUBFUNC(__vbaBoolStr)
STUBFUNC(__vbaBoolVar)
STUBFUNC(__vbaBoolVarNull)
STUBFUNC(__vbaCVarAryUdt)
STUBFUNC(__vbaCastObj)
STUBFUNC(__vbaCastObjVar)
STUBFUNC(__vbaCheckType)
STUBFUNC(__vbaCheckTypeVar)
STUBFUNC(__vbaChkstk)
STUBFUNC(__vbaCopyBytes)
STUBFUNC(__vbaCopyBytesZero)
STUBFUNC(__vbaCyAbs)
STUBFUNC(__vbaCyAdd)
STUBFUNC(__vbaCyErrVar)
STUBFUNC(__vbaCyFix)
STUBFUNC(__vbaCyForInit)
STUBFUNC(__vbaCyForNext)
STUBFUNC(__vbaCyI2)
STUBFUNC(__vbaCyI4)
STUBFUNC(__vbaCyInt)
STUBFUNC(__vbaCyMul)
STUBFUNC(__vbaCyMulI2)
STUBFUNC(__vbaCySgn)
STUBFUNC(__vbaCyStr)
STUBFUNC(__vbaCySub)
STUBFUNC(__vbaCyUI1)
STUBFUNC(__vbaCyVar)
STUBFUNC(__vbaDateR4)
STUBFUNC(__vbaDateR8)
STUBFUNC(__vbaDateStr)
STUBFUNC(__vbaDateVar)
STUBFUNC(__vbaDerefAry)
STUBFUNC(__vbaDerefAry1)
STUBFUNC(__vbaEnd)
STUBFUNC(__vbaErase)
STUBFUNC(__vbaEraseKeepData)
STUBFUNC(__vbaEraseNoPop)
STUBFUNC(__vbaError)
STUBFUNC(__vbaErrorOverflow)
STUBFUNC(__vbaExceptHandler)
STUBFUNC(__vbaExitEachAry)
STUBFUNC(__vbaExitEachColl)
STUBFUNC(__vbaExitEachVar)
STUBFUNC(__vbaExitProc)
STUBFUNC(__vbaFPException)
STUBFUNC(__vbaFailedFriend)
STUBFUNC(__vbaFileClose)
STUBFUNC(__vbaFileCloseAll)
STUBFUNC(__vbaFileLock)
STUBFUNC(__vbaFileOpen)
STUBFUNC(__vbaFileSeek)
STUBFUNC(__vbaFixstrConstruct)
STUBFUNC(__vbaForEachAry)
STUBFUNC(__vbaForEachCollAd)
STUBFUNC(__vbaForEachCollObj)
STUBFUNC(__vbaForEachCollVar)
STUBFUNC(__vbaForEachVar)
STUBFUNC(__vbaFpCDblR4)
STUBFUNC(__vbaFpCDblR8)
STUBFUNC(__vbaFpCSngR4)
STUBFUNC(__vbaFpCSngR8)
STUBFUNC(__vbaFpCmpCy)
STUBFUNC(__vbaFpCy)
STUBFUNC(__vbaFpI2)
STUBFUNC(__vbaFpI4)
STUBFUNC(__vbaFpR4)
STUBFUNC(__vbaFpR8)
STUBFUNC(__vbaFpUI1)
STUBFUNC(__vbaFreeObj)
STUBFUNC(__vbaFreeObjList)
STUBFUNC(__vbaFreeStr)
STUBFUNC(__vbaFreeStrList)
STUBFUNC(__vbaFreeVar)
STUBFUNC(__vbaFreeVarList)
STUBFUNC(__vbaFreeVarg)
STUBFUNC(__vbaGenerateBoundsError)
STUBFUNC(__vbaGet3)
STUBFUNC(__vbaGet4)
STUBFUNC(__vbaGetFxStr3)
STUBFUNC(__vbaGetFxStr4)
STUBFUNC(__vbaGetOwner3)
STUBFUNC(__vbaGetOwner4)
STUBFUNC(__vbaGetSeh)
STUBFUNC(__vbaGosub)
STUBFUNC(__vbaGosubFree)
STUBFUNC(__vbaGosubReturn)
STUBFUNC(__vbaHresultCheck)
STUBFUNC(__vbaHresultCheckNonvirt)
STUBFUNC(__vbaHresultCheckObj)
STUBFUNC(__vbaI2Abs)
STUBFUNC(__vbaI2Cy)
STUBFUNC(__vbaI2ErrVar)
STUBFUNC(__vbaI2ForNextCheck)
STUBFUNC(__vbaI2I4)
STUBFUNC(__vbaI2Sgn)
STUBFUNC(__vbaI2Str)
STUBFUNC(__vbaI2Var)
STUBFUNC(__vbaI4Abs)
STUBFUNC(__vbaI4Cy)
STUBFUNC(__vbaI4ErrVar)
STUBFUNC(__vbaI4ForNextCheck)
STUBFUNC(__vbaI4Sgn)
STUBFUNC(__vbaI4Str)
STUBFUNC(__vbaI4Var)
STUBFUNC(__vbaInStr)
STUBFUNC(__vbaInStrB)
STUBFUNC(__vbaInStrVar)
STUBFUNC(__vbaInStrVarB)
STUBFUNC(__vbaInputFile)
STUBFUNC(__vbaLateIdCall)
STUBFUNC(__vbaLateIdCallLd)
STUBFUNC(__vbaLateIdCallSt)
STUBFUNC(__vbaLateIdNamedCall)
STUBFUNC(__vbaLateIdNamedCallLd)
STUBFUNC(__vbaLateIdNamedCallSt)
STUBFUNC(__vbaLateIdNamedStAd)
STUBFUNC(__vbaLateIdSt)
STUBFUNC(__vbaLateIdStAd)
STUBFUNC(__vbaLateMemCall)
STUBFUNC(__vbaLateMemCallLd)
STUBFUNC(__vbaLateMemCallSt)
STUBFUNC(__vbaLateMemNamedCall)
STUBFUNC(__vbaLateMemNamedCallLd)
STUBFUNC(__vbaLateMemNamedCallSt)
STUBFUNC(__vbaLateMemNamedStAd)
STUBFUNC(__vbaLateMemSt)
STUBFUNC(__vbaLateMemStAd)
STUBFUNC(__vbaLbound)
STUBFUNC(__vbaLdZeroAry)
STUBFUNC(__vbaLenBstr)
STUBFUNC(__vbaLenBstrB)
STUBFUNC(__vbaLenVar)
STUBFUNC(__vbaLenVarB)
STUBFUNC(__vbaLineInputStr)
STUBFUNC(__vbaLineInputVar)
STUBFUNC(__vbaLsetFixstr)
STUBFUNC(__vbaLsetFixstrFree)
STUBFUNC(__vbaMidStmtBstr)
STUBFUNC(__vbaMidStmtBstrB)
STUBFUNC(__vbaMidStmtVar)
STUBFUNC(__vbaMidStmtVarB)
STUBFUNC(__vbaNameFile)
STUBFUNC(__vbaNew)
STUBFUNC(__vbaNew2)
STUBFUNC(__vbaNextEachAry)
STUBFUNC(__vbaNextEachCollAd)
STUBFUNC(__vbaNextEachCollObj)
STUBFUNC(__vbaNextEachCollVar)
STUBFUNC(__vbaNextEachVar)
STUBFUNC(__vbaObjAddref)
STUBFUNC(__vbaObjIs)
STUBFUNC(__vbaObjSet)
STUBFUNC(__vbaObjSetAddref)
STUBFUNC(__vbaObjVar)
STUBFUNC(__vbaOnError)
STUBFUNC(__vbaOnGoCheck)
STUBFUNC(__vbaPowerR8)
STUBFUNC(__vbaPrintFile)
STUBFUNC(__vbaPrintObj)
STUBFUNC(__vbaPut3)
STUBFUNC(__vbaPut4)
STUBFUNC(__vbaPutFxStr3)
STUBFUNC(__vbaPutFxStr4)
STUBFUNC(__vbaPutOwner3)
STUBFUNC(__vbaPutOwner4)
STUBFUNC(__vbaR4Cy)
STUBFUNC(__vbaR4ErrVar)
STUBFUNC(__vbaR4Fix)
STUBFUNC(__vbaR4ForNextCheck)
STUBFUNC(__vbaR4Int)
STUBFUNC(__vbaR4Sgn)
STUBFUNC(__vbaR4Str)
STUBFUNC(__vbaR4Var)
STUBFUNC(__vbaR8Cy)
STUBFUNC(__vbaR8ErrVar)
STUBFUNC(__vbaR8Fix)
STUBFUNC(__vbaR8FixI2)
STUBFUNC(__vbaR8FixI4)
STUBFUNC(__vbaR8ForNextCheck)
STUBFUNC(__vbaR8Int)
STUBFUNC(__vbaR8IntI2)
STUBFUNC(__vbaR8IntI4)
STUBFUNC(__vbaR8Sgn)
STUBFUNC(__vbaR8Str)
STUBFUNC(__vbaR8Var)
STUBFUNC(__vbaRaiseEvent)
STUBFUNC(__vbaRecAnsiToUni)
STUBFUNC(__vbaRecAssign)
STUBFUNC(__vbaRecDestruct)
STUBFUNC(__vbaRecDestructAnsi)
STUBFUNC(__vbaRecUniToAnsi)
STUBFUNC(__vbaRedim)
STUBFUNC(__vbaRedimPreserve)
STUBFUNC(__vbaRedimPreserveVar)
STUBFUNC(__vbaRedimPreserveVar2)
STUBFUNC(__vbaRedimVar)
STUBFUNC(__vbaRedimVar2)
STUBFUNC(__vbaRefVarAry)
STUBFUNC(__vbaResume)
STUBFUNC(__vbaRsetFixstr)
STUBFUNC(__vbaRsetFixstrFree)
STUBFUNC(__vbaSetSeh)
STUBFUNC(__vbaSetSystemError)
STUBFUNC(__vbaStopExe)
STUBFUNC(__vbaStr2Vec)
STUBFUNC(__vbaStrAryToAnsi)
STUBFUNC(__vbaStrAryToUnicode)
STUBFUNC(__vbaStrBool)
STUBFUNC(__vbaStrCat)
STUBFUNC(__vbaStrCmp)
STUBFUNC(__vbaStrComp)
STUBFUNC(__vbaStrCompVar)
STUBFUNC(__vbaStrCopy)
STUBFUNC(__vbaStrCy)
STUBFUNC(__vbaStrDate)
STUBFUNC(__vbaStrErrVarCopy)
STUBFUNC(__vbaStrFixstr)
STUBFUNC(__vbaStrI2)
STUBFUNC(__vbaStrI4)
STUBFUNC(__vbaStrLike)
STUBFUNC(__vbaStrMove)
STUBFUNC(__vbaStrR4)
STUBFUNC(__vbaStrR8)
STUBFUNC(__vbaStrTextCmp)
STUBFUNC(__vbaStrTextLike)
STUBFUNC(__vbaStrToAnsi)
STUBFUNC(__vbaStrToUnicode)
STUBFUNC(__vbaStrUI1)
STUBFUNC(__vbaStrVarCopy)
STUBFUNC(__vbaStrVarMove)
STUBFUNC(__vbaStrVarVal)
STUBFUNC(__vbaUI1Cy)
STUBFUNC(__vbaUI1ErrVar)
STUBFUNC(__vbaUI1I2)
STUBFUNC(__vbaUI1I4)
STUBFUNC(__vbaUI1Sgn)
STUBFUNC(__vbaUI1Str)
STUBFUNC(__vbaUI1Var)
STUBFUNC(__vbaUbound)
STUBFUNC(__vbaUdtVar)
STUBFUNC(__vbaUnkVar)
STUBFUNC(__vbaVar2Vec)
STUBFUNC(__vbaVarAbs)
STUBFUNC(__vbaVarAdd)
STUBFUNC(__vbaVarAnd)
STUBFUNC(__vbaVarCat)
STUBFUNC(__vbaVarCmpEq)
STUBFUNC(__vbaVarCmpGe)
STUBFUNC(__vbaVarCmpGt)
STUBFUNC(__vbaVarCmpLe)
STUBFUNC(__vbaVarCmpLt)
STUBFUNC(__vbaVarCmpNe)
STUBFUNC(__vbaVarCopy)
STUBFUNC(__vbaVarDateVar)
STUBFUNC(__vbaVarDiv)
STUBFUNC(__vbaVarDup)
STUBFUNC(__vbaVarEqv)
STUBFUNC(__vbaVarErrI4)
STUBFUNC(__vbaVarFix)
STUBFUNC(__vbaVarForInit)
STUBFUNC(__vbaVarForNext)
STUBFUNC(__vbaVarIdiv)
STUBFUNC(__vbaVarImp)
STUBFUNC(__vbaVarIndexLoad)
STUBFUNC(__vbaVarIndexLoadRef)
STUBFUNC(__vbaVarIndexLoadRefLock)
STUBFUNC(__vbaVarIndexStore)
STUBFUNC(__vbaVarIndexStoreObj)
STUBFUNC(__vbaVarInt)
STUBFUNC(__vbaVarLateMemCallLd)
STUBFUNC(__vbaVarLateMemCallLdRf)
STUBFUNC(__vbaVarLateMemCallSt)
STUBFUNC(__vbaVarLateMemSt)
STUBFUNC(__vbaVarLateMemStAd)
STUBFUNC(__vbaVarLike)
STUBFUNC(__vbaVarLikeVar)
STUBFUNC(__vbaVarMod)
STUBFUNC(__vbaVarMove)
STUBFUNC(__vbaVarMul)
STUBFUNC(__vbaVarNeg)
STUBFUNC(__vbaVarNot)
STUBFUNC(__vbaVarOr)
STUBFUNC(__vbaVarPow)
STUBFUNC(__vbaVarSetObj)
STUBFUNC(__vbaVarSetObjAddref)
STUBFUNC(__vbaVarSetUnk)
STUBFUNC(__vbaVarSetUnkAddref)
STUBFUNC(__vbaVarSetVar)
STUBFUNC(__vbaVarSetVarAddref)
STUBFUNC(__vbaVarSub)
STUBFUNC(__vbaVarTextCmpEq)
STUBFUNC(__vbaVarTextCmpGe)
STUBFUNC(__vbaVarTextCmpGt)
STUBFUNC(__vbaVarTextCmpLe)
STUBFUNC(__vbaVarTextCmpLt)
STUBFUNC(__vbaVarTextCmpNe)
STUBFUNC(__vbaVarTextLike)
STUBFUNC(__vbaVarTextLikeVar)
STUBFUNC(__vbaVarTextTstEq)
STUBFUNC(__vbaVarTextTstGe)
STUBFUNC(__vbaVarTextTstGt)
STUBFUNC(__vbaVarTextTstLe)
STUBFUNC(__vbaVarTextTstLt)
STUBFUNC(__vbaVarTextTstNe)
STUBFUNC(__vbaVarTstEq)
STUBFUNC(__vbaVarTstGe)
STUBFUNC(__vbaVarTstGt)
STUBFUNC(__vbaVarTstLe)
STUBFUNC(__vbaVarTstLt)
STUBFUNC(__vbaVarTstNe)
STUBFUNC(__vbaVarVargNofree)
STUBFUNC(__vbaVarXor)
STUBFUNC(__vbaVarZero)
STUBFUNC(__vbaVargObj)
STUBFUNC(__vbaVargObjAddref)
STUBFUNC(__vbaVargParmRef)
STUBFUNC(__vbaVargUnk)
STUBFUNC(__vbaVargUnkAddref)
STUBFUNC(__vbaVargVar)
STUBFUNC(__vbaVargVarCopy)
STUBFUNC(__vbaVargVarMove)
STUBFUNC(__vbaVargVarRef)
STUBFUNC(__vbaVerifyVarObj)
STUBFUNC(__vbaWriteFile)
STUBFUNC(g_hFSMt)
STUBFUNC(g_pFS)
STUBFUNC(rtBoolFromErrVar)
STUBFUNC(rtBstrFromErrVar)
STUBFUNC(rtCyFromErrVar)
STUBFUNC(rtDecFromVar)
STUBFUNC(rtI2FromErrVar)
STUBFUNC(rtI4FromErrVar)
STUBFUNC(rtR4FromErrVar)
STUBFUNC(rtR8FromErrVar)
STUBFUNC(rtUI1FromErrVar)
STUBFUNC(rtcAbsVar)
STUBFUNC(rtcAnsiValueBstr)
STUBFUNC(rtcAppActivate)
STUBFUNC(rtcAppleScript)
STUBFUNC(rtcArray)
STUBFUNC(rtcAtn)
STUBFUNC(rtcBeep)
STUBFUNC(rtcBstrFromAnsi)
STUBFUNC(rtcBstrFromByte)
STUBFUNC(rtcBstrFromChar)
STUBFUNC(rtcBstrFromError)
STUBFUNC(rtcBstrFromFormatVar)
STUBFUNC(rtcByteValueBstr)
STUBFUNC(rtcCVErrFromVar)
STUBFUNC(rtcCallByName)
STUBFUNC(rtcChangeDir)
STUBFUNC(rtcChangeDrive)
STUBFUNC(rtcCharValueBstr)
STUBFUNC(rtcChoose)
STUBFUNC(rtcCommandBstr)
STUBFUNC(rtcCommandVar)
STUBFUNC(rtcCompareBstr)
STUBFUNC(rtcCos)
STUBFUNC(rtcCreateObject)
STUBFUNC(rtcCreateObject2)
STUBFUNC(rtcCurrentDir)
STUBFUNC(rtcCurrentDirBstr)
STUBFUNC(rtcDDB)
STUBFUNC(rtcDateAdd)
STUBFUNC(rtcDateDiff)
STUBFUNC(rtcDateFromVar)
STUBFUNC(rtcDatePart)
STUBFUNC(rtcDeleteSetting)
STUBFUNC(rtcDir)
STUBFUNC(rtcDoEvents)
STUBFUNC(rtcEndOfFile)
STUBFUNC(rtcEnvironBstr)
STUBFUNC(rtcEnvironVar)
STUBFUNC(rtcErrObj)
STUBFUNC(rtcExp)
STUBFUNC(rtcFV)
STUBFUNC(rtcFileAttributes)
STUBFUNC(rtcFileCopy)
STUBFUNC(rtcFileDateTime)
STUBFUNC(rtcFileLen)
STUBFUNC(rtcFileLength)
STUBFUNC(rtcFileLocation)
STUBFUNC(rtcFileReset)
STUBFUNC(rtcFileSeek)
STUBFUNC(rtcFileWidth)
STUBFUNC(rtcFilter)
STUBFUNC(rtcFixVar)
STUBFUNC(rtcFormatCurrency)
STUBFUNC(rtcFormatDateTime)
STUBFUNC(rtcFormatNumber)
STUBFUNC(rtcFormatPercent)
STUBFUNC(rtcFreeFile)
STUBFUNC(rtcGetAllSettings)
STUBFUNC(rtcGetCurrentCalendar)
STUBFUNC(rtcGetDateBstr)
STUBFUNC(rtcGetDateValue)
STUBFUNC(rtcGetDateVar)
STUBFUNC(rtcGetDayOfMonth)
STUBFUNC(rtcGetDayOfWeek)
STUBFUNC(rtcGetErl)
STUBFUNC(rtcGetFileAttr)
STUBFUNC(rtcGetHostLCID)
STUBFUNC(rtcGetHourOfDay)
STUBFUNC(rtcGetMinuteOfHour)
STUBFUNC(rtcGetMonthOfYear)
STUBFUNC(rtcGetObject)
STUBFUNC(rtcGetPresentDate)
STUBFUNC(rtcGetSecondOfMinute)
STUBFUNC(rtcGetSetting)
STUBFUNC(rtcGetTimeBstr)
STUBFUNC(rtcGetTimeValue)
STUBFUNC(rtcGetTimeVar)
STUBFUNC(rtcGetTimer)
STUBFUNC(rtcGetYear)
STUBFUNC(rtcHexBstrFromVar)
STUBFUNC(rtcHexVarFromVar)
STUBFUNC(rtcIMEStatus)
STUBFUNC(rtcIPMT)
STUBFUNC(rtcIRR)
STUBFUNC(rtcImmediateIf)
STUBFUNC(rtcInStr)
STUBFUNC(rtcInStrChar)
STUBFUNC(rtcInStrRev)
STUBFUNC(rtcInputBox)
STUBFUNC(rtcInputCharCount)
STUBFUNC(rtcInputCharCountVar)
STUBFUNC(rtcInputCount)
STUBFUNC(rtcInputCountVar)
STUBFUNC(rtcIntVar)
STUBFUNC(rtcIsArray)
STUBFUNC(rtcIsDate)
STUBFUNC(rtcIsEmpty)
STUBFUNC(rtcIsError)
STUBFUNC(rtcIsMissing)
STUBFUNC(rtcIsNull)
STUBFUNC(rtcIsNumeric)
STUBFUNC(rtcIsObject)
STUBFUNC(rtcJoin)
STUBFUNC(rtcKillFiles)
STUBFUNC(rtcLeftBstr)
STUBFUNC(rtcLeftCharBstr)
STUBFUNC(rtcLeftCharVar)
STUBFUNC(rtcLeftTrimBstr)
STUBFUNC(rtcLeftTrimVar)
STUBFUNC(rtcLeftVar)
STUBFUNC(rtcLenCharVar)
STUBFUNC(rtcLenVar)
STUBFUNC(rtcLog)
STUBFUNC(rtcLowerCaseBstr)
STUBFUNC(rtcLowerCaseVar)
STUBFUNC(rtcMIRR)
STUBFUNC(rtcMacId)
STUBFUNC(rtcMakeDir)
STUBFUNC(rtcMidBstr)
STUBFUNC(rtcMidCharBstr)
STUBFUNC(rtcMidCharVar)
STUBFUNC(rtcMidVar)
STUBFUNC(rtcMonthName)
STUBFUNC(rtcMsgBox)
STUBFUNC(rtcNPV)
STUBFUNC(rtcNPer)
STUBFUNC(rtcOctBstrFromVar)
STUBFUNC(rtcOctVarFromVar)
STUBFUNC(rtcPMT)
STUBFUNC(rtcPPMT)
STUBFUNC(rtcPV)
STUBFUNC(rtcPackDate)
STUBFUNC(rtcPackTime)
STUBFUNC(rtcPartition)
STUBFUNC(rtcQBColor)
STUBFUNC(rtcR8ValFromBstr)
STUBFUNC(rtcRandomNext)
STUBFUNC(rtcRandomize)
STUBFUNC(rtcRate)
STUBFUNC(rtcRemoveDir)
STUBFUNC(rtcReplace)
STUBFUNC(rtcRgb)
STUBFUNC(rtcRightBstr)
STUBFUNC(rtcRightCharBstr)
STUBFUNC(rtcRightCharVar)
STUBFUNC(rtcRightTrimBstr)
STUBFUNC(rtcRightTrimVar)
STUBFUNC(rtcRightVar)
STUBFUNC(rtcRound)
STUBFUNC(rtcSLN)
STUBFUNC(rtcSYD)
STUBFUNC(rtcSaveSetting)
STUBFUNC(rtcSendKeys)
STUBFUNC(rtcSetCurrentCalendar)
STUBFUNC(rtcSetDateBstr)
STUBFUNC(rtcSetDateVar)
STUBFUNC(rtcSetFileAttr)
STUBFUNC(rtcSetTimeBstr)
STUBFUNC(rtcSetTimeVar)
STUBFUNC(rtcSgnVar)
STUBFUNC(rtcShell)
STUBFUNC(rtcSin)
STUBFUNC(rtcSpaceBstr)
STUBFUNC(rtcSpaceVar)
STUBFUNC(rtcSplit)
STUBFUNC(rtcSqr)
STUBFUNC(rtcStrConvVar)
STUBFUNC(rtcStrConvVar2)
STUBFUNC(rtcStrFromVar)
STUBFUNC(rtcStrReverse)
STUBFUNC(rtcStringBstr)
STUBFUNC(rtcStringVar)
STUBFUNC(rtcSwitch)
STUBFUNC(rtcTan)
STUBFUNC(rtcTrimBstr)
STUBFUNC(rtcTrimVar)
STUBFUNC(rtcTypeName)
STUBFUNC(rtcUpperCaseBstr)
STUBFUNC(rtcUpperCaseVar)
STUBFUNC(rtcVarBstrFromAnsi)
STUBFUNC(rtcVarBstrFromByte)
STUBFUNC(rtcVarBstrFromChar)
STUBFUNC(rtcVarDateFromVar)
STUBFUNC(rtcVarFromError)
STUBFUNC(rtcVarFromFormatVar)
STUBFUNC(rtcVarFromVar)
STUBFUNC(rtcVarStrFromVar)
STUBFUNC(rtcVarType)
STUBFUNC(rtcWeekdayName)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\delayimp\delayimp.c ===
//
// DelayImp.c
//
//  define structures and prototypes necessary for delay loading of imports
//

#include "windows.h"

typedef IMAGE_THUNK_DATA *          PImgThunkData;
typedef const IMAGE_THUNK_DATA *    PCImgThunkData;
typedef DWORD                       RVA;

typedef struct ImgDelayDescrV2 {
    DWORD           grAttrs;        // attributes
    RVA             rvaDLLName;     // RVA to dll name
    RVA             rvaHmod;        // RVA of module handle
    RVA             rvaIAT;         // RVA of the IAT
    RVA             rvaINT;         // RVA of the INT
    RVA             rvaBoundIAT;    // RVA of the optional bound IAT
    RVA             rvaUnloadIAT;   // RVA of optional copy of original IAT
    DWORD           dwTimeStamp;    // 0 if not bound,
                                    // O.W. date/time stamp of DLL bound to (Old BIND)
    } ImgDelayDescrV2, * PImgDelayDescrV2;

typedef ImgDelayDescrV2  ImgDelayDescr;
typedef PImgDelayDescrV2 PImgDelayDescr;

typedef const ImgDelayDescr *   PCImgDelayDescr;

enum DLAttr {                   // Delay Load Attributes
    dlattrRva = 0x1,                // RVAs are used instead of pointers
    };

//
// Delay load import hook notifications
//
enum {
    dliStartProcessing,             // used to bypass or note helper only
    dliNotePreLoadLibrary,          // called just before LoadLibrary, can
                                    //  override w/ new HMODULE return val
    dliNotePreGetProcAddress,       // called just before GetProcAddress, can
                                    //  override w/ new FARPROC return value
    dliFailLoadLib,                 // failed to load library, fix it by
                                    //  returning a valid HMODULE
    dliFailGetProc,                 // failed to get proc address, fix it by
                                    //  returning a valid FARPROC
    dliNoteEndProcessing,           // called after all processing is done, no
                                    //  no bypass possible at this point except
                                    //  by longjmp()/throw()/RaiseException.
    };

typedef struct DelayLoadProc {
    BOOL                fImportByName;
    union {
        LPCSTR          szProcName;
        DWORD           dwOrdinal;
        };
    } DelayLoadProc;

typedef struct DelayLoadInfo {
    DWORD               cb;         // size of structure
    PCImgDelayDescr     pidd;       // raw form of data (everything is there)
    FARPROC *           ppfn;       // points to address of function to load
    LPCSTR              szDll;      // name of dll
    DelayLoadProc       dlp;        // name or ordinal of procedure
    HMODULE             hmodCur;    // the hInstance of the library we have loaded
    FARPROC             pfnCur;     // the actual function that will be called
    DWORD               dwLastError;// error received (if an error notification)
    } DelayLoadInfo, * PDelayLoadInfo;

typedef FARPROC (WINAPI *PfnDliHook)(
    unsigned        dliNotify,
    PDelayLoadInfo  pdli
    );

IMAGE_DOS_HEADER __ImageBase;

//
// Unload support
//

BOOL
WINAPI
__FUnloadDelayLoadedDLL2 (
    LPCSTR szDll
    )

{
    return FALSE;
}

// structure definitions for the list of unload records
typedef struct UnloadInfo * PUnloadInfo;
typedef struct UnloadInfo {
    PUnloadInfo     puiNext;
    PCImgDelayDescr pidd;
    } UnloadInfo;

// the default delay load helper places the unloadinfo records in the list
// headed by the following pointer.

PUnloadInfo __puiHead;

//
// Hook pointers
//

// The "notify hook" gets called for every call to the
// delay load helper.  This allows a user to hook every call and
// skip the delay load helper entirely.
//
// dliNotify == {
//  dliStartProcessing |
//  dliPreLoadLibrary  |
//  dliPreGetProc |
//  dliNoteEndProcessing}
//  on this call.
//

PfnDliHook   __pfnDliNotifyHook;

PfnDliHook   __pfnDliNotifyHook2;

PfnDliHook   __pfnDliFailureHook;

PfnDliHook   __pfnDliFailureHook2;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hh\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hh.RC
//
#define IDICON_HH                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hh\strtable.h ===
// DO NOT CHANGE THIS VALUE! hha.dll expects this string resource

#define IDS_VERSION 					0xD000
#define IDICO_HH	100

#define IDS_DEFAULT_CAPTION 		1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hh\verdef.h ===
#ifdef HHCTRL
#define IDS_VERSION_STRING		"HTML Help Control Version 4.74.9120"
#endif

#define VERSION 			"4.74.9120"
#define VER_PRODUCTVERSION_STR		"4.74.9120\0"
#define VER_PRODUCTVERSION		4,74,9120,0
#define VER_PRODUCTVERSION_DW		(0x04740000 | 9120)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\animate.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  ANIMATE.CPP
//
/*
    This class is responsible for the animations in the busy dialogs such as the 
    merge index dialog.

    REVIEW: Could we use the commctrl animation control instead?

*/

// needed for those pesky pre-compiled headers
#include "header.h"

#include <windows.h>

#include "animate.h"                  // Animate class

#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

static const char txtAnimateClassName[] = "Help_Animation";
static const WCHAR wtxtAnimateClassName[] = L"Help_Animation";

typedef struct {
        int left;
        int top;
        int cx;
        int cy;
} WRECT;

void STDCALL GetWindowWRect(HWND hwnd, WRECT* prc)
{
  ASSERT(IsValidWindow(hwnd));
  GetWindowRect(hwnd, (PRECT) prc);

  // Convert right and bottom into width and height
  prc->cx -= prc->left;
  prc->cy -= prc->top;
}

const int CX_DRAWAREA = 40;
const int CY_DRAWAREA = 40;

const int CX_BOOK = 36;
const int CY_BOOK = 36;
const int C_BOOKS = 5;
const int X_BOOK = 0;
const int Y_BOOK = (CY_DRAWAREA - CY_BOOK);

const int CX_PEN = 15;
const int CY_PEN = 20;
const int C_PENS = 3;
const int X_PEN = 18;
const int Y_PEN = 2;

const int CX_STROKE = 1;
const int CY_STROKE = 2;

const int C_HORZ_STROKES = 10;
const int C_VERT_STROKES = 4;
const int C_PEN_STROKES = (C_HORZ_STROKES * C_VERT_STROKES);

const int C_PAUSE_FRAMES = 0;
const int C_FRAMES = (C_PEN_STROKES + C_BOOKS + C_PAUSE_FRAMES);

const int ANIMATE_INCREMENTS = 100;

const COLORREF clrPenA = RGB(128, 128, 128);
const COLORREF clrPenB = RGB(128, 0, 128);

const int MAX_CNT_LINE = 1024;
const int VPAD = 62;
const int HPAD = 30;

static VOID _fastcall PointFromStroke(int xStroke, int yStroke, POINT* lppt);

#define SafeDeleteDC( hDC ) if( hDC ) { DeleteDC( hDC ); hDC = NULL; }
#define SafeDeleteObject( hObj ) if( hObj ) { DeleteObject( hObj ); hObj = NULL; }

LRESULT CALLBACK StatusWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  // remove escape keys
#if 0
  MSG msg2;
  if( PeekMessage( &msg2, hwnd, 0, 0, PM_NOREMOVE ) ) {
    if( msg2.message == WM_KEYDOWN || msg2.message == WM_KEYUP ) {
      if( msg2.wParam == VK_ESCAPE ) {
        PeekMessage( &msg2, hwnd, 0, 0, PM_REMOVE );
      }
    }
  }
#endif
  if(g_bWinNT5)
     return DefWindowProcW(hwnd, msg, wParam, lParam);
  else
     return DefWindowProc(hwnd, msg, wParam, lParam);
}

class Animate
{
public:
        Animate();
        ~Animate(void);
        void STDCALL NextFrame(void);
        void SetPosition(int x, int y) { m_xPos = x; m_yPos = y; };
        BOOL STDCALL CreateStatusWindow(HWND hwndParent, int idTitle);
        HWND m_hWndParent;
        HWND m_hWnd;

protected:
        HBITMAP m_hBmpTemp;
        HDC     m_hDCBmp;
        HBITMAP m_hBmpIml;
        int     m_iFrame;
        int     m_xPos;
        int     m_yPos;
        DWORD   m_oldTickCount;
        DWORD   m_originalTickCount;
        BOOL    m_fShown;
};

static Animate* g_pAnimationWindow = NULL;

BOOL STDCALL StartAnimation(int idTitle, HWND hWnd )
{
        ASSERT(!g_pAnimationWindow);
        if( g_pAnimationWindow )
          return FALSE;
        g_pAnimationWindow = new Animate();
        if( !hWnd )
          if( !(hWnd = GetActiveWindow()) )
            hWnd = GetDesktopWindow();
        if (!g_pAnimationWindow->CreateStatusWindow( hWnd, idTitle)) {
                delete g_pAnimationWindow;
                g_pAnimationWindow = NULL;
                return FALSE;
        }
        return TRUE;
}

void STDCALL NextAnimation(void)
{
        if (g_pAnimationWindow)
                g_pAnimationWindow->NextFrame();
}

void STDCALL StopAnimation(void)
{
        if (g_pAnimationWindow)
                delete g_pAnimationWindow;
        g_pAnimationWindow = NULL;
}

BOOL STDCALL Animate::CreateStatusWindow(HWND hWndParent, int idTitle)
{
        int width;

        WORD lang = PRIMARYLANGID(_Module.m_Language.GetUiLanguage());

        if(g_bWinNT5)
        {
            WNDCLASSW wc;

            SIZE sSize;

            ZeroMemory(&wc, sizeof(wc));

            // Register Main window class

            wc.hInstance = _Module.GetModuleInstance();
            wc.style = CS_BYTEALIGNWINDOW | CS_CLASSDC;
            wc.lpfnWndProc = StatusWndProc;
            wc.lpszClassName = wtxtAnimateClassName;
            wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
            wc.hIcon = LoadIcon(_Module.GetResourceInstance(), "Icon!HTMLHelp");

            if (!RegisterClassW(&wc))
                    return FALSE;

            WRECT rc;
            m_hWndParent = hWndParent;
            GetWindowWRect(m_hWndParent, &rc);

            const WCHAR *psz = GetStringResourceW(idTitle);
            int len = wcslen(psz);
            HDC hdc = GetDC(hWndParent);
            GetTextExtentPoint32W(hdc, psz, len, (LPSIZE)&sSize);
            ReleaseDC(m_hWndParent, hdc);

	        width = sSize.cx;
	
			if(lang == LANG_JAPANESE || lang == LANG_CHINESE || lang == LANG_KOREAN)
				width+=100;

            if (width < CX_BOOK)
                    width = CX_BOOK;
            if ( 0 /*!fIsThisNewShell4*/ )
                    width += HPAD;

#ifdef BIDI
            m_hWnd = CreateWindowExW(WS_EX_WINDOWEDGE | /* WS_EX_TOPMOST | */
                            (fForceLtr ? 0 : WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR),
                    wtxtAnimateClassName, psz, WS_POPUP | WS_BORDER | WS_CAPTION,
                    rc.left + rc.cx / 2 - width / 2,
                    rc.top + rc.cy / 2 - CY_BOOK / 2 + HPAD,
                    width + GetSystemMetrics(SM_CXBORDER) * 2 + 2,
                    CY_BOOK + GetSystemMetrics(SM_CYBORDER) * 2 + VPAD +
                            GetSystemMetrics(SM_CYCAPTION),
                            (IsWindowVisible(m_hWndParent)) ? m_hWndParent : NULL,
                    NULL, hInsNow, NULL);
#else
            m_hWnd = CreateWindowExW(WS_EX_WINDOWEDGE /* | WS_EX_TOPMOST*/,
                    wtxtAnimateClassName, psz, WS_POPUP | WS_BORDER | WS_CAPTION,
                    rc.left + rc.cx / 2 - width / 2,
                    rc.top + rc.cy / 2 - CY_BOOK / 2 + HPAD,
                    width + GetSystemMetrics(SM_CXBORDER) * 2 + 2,
                    CY_BOOK + GetSystemMetrics(SM_CYBORDER) * 2 + VPAD +
                            GetSystemMetrics(SM_CYCAPTION),
                            (IsWindowVisible(m_hWndParent)) ? m_hWndParent : NULL,
                    NULL, _Module.GetModuleInstance(), NULL);
#endif
        }
        else
        {
			WNDCLASS wc;
			SIZE sSize;

			ZeroMemory(&wc, sizeof(wc));

			// Register Main window class

			wc.hInstance = _Module.GetModuleInstance();
			wc.style = CS_BYTEALIGNWINDOW | CS_CLASSDC;
			wc.lpfnWndProc = StatusWndProc;
			wc.lpszClassName = (LPCSTR) txtAnimateClassName;
			wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
			wc.hIcon = LoadIcon(_Module.GetResourceInstance(), "Icon!HTMLHelp");

			if (!RegisterClass(&wc))
					return FALSE;

			WRECT rc;
			m_hWndParent = hWndParent;
			GetWindowWRect(m_hWndParent, &rc);

			HDC hdc = GetDC(m_hWndParent);
			PSTR psz = (PSTR) GetStringResource(idTitle);
			GetTextExtentPoint32(hdc, psz, (int)strlen(psz), (LPSIZE)&sSize);
			width = sSize.cx;
			
			if(lang == LANG_JAPANESE || lang == LANG_CHINESE || lang == LANG_KOREAN)
				width+=100;
			
			if (width < CX_BOOK)
					width = CX_BOOK;
			if ( 0 /*!fIsThisNewShell4*/ )
					width += HPAD;
			ReleaseDC(m_hWndParent, hdc);

#ifdef BIDI
			m_hWnd = CreateWindowEx(WS_EX_WINDOWEDGE | /* WS_EX_TOPMOST | */
							(fForceLtr ? 0 : WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR),
					(LPCSTR) txtAnimateClassName, psz, WS_POPUP | WS_BORDER | WS_CAPTION,
					rc.left + rc.cx / 2 - width / 2,
					rc.top + rc.cy / 2 - CY_BOOK / 2 + HPAD,
					width + GetSystemMetrics(SM_CXBORDER) * 2 + 2,
					CY_BOOK + GetSystemMetrics(SM_CYBORDER) * 2 + VPAD +
							GetSystemMetrics(SM_CYCAPTION),
							(IsWindowVisible(m_hWndParent)) ? m_hWndParent : NULL,
					NULL, hInsNow, NULL);
#else
			m_hWnd = CreateWindowEx(WS_EX_WINDOWEDGE /* | WS_EX_TOPMOST*/,
					(LPCSTR) txtAnimateClassName, psz, WS_POPUP | WS_BORDER | WS_CAPTION,
					rc.left + rc.cx / 2 - width / 2,
					rc.top + rc.cy / 2 - CY_BOOK / 2 + HPAD,
					width + GetSystemMetrics(SM_CXBORDER) * 2 + 2,
					CY_BOOK + GetSystemMetrics(SM_CYBORDER) * 2 + VPAD +
							GetSystemMetrics(SM_CYCAPTION),
							(IsWindowVisible(m_hWndParent)) ? m_hWndParent : NULL,
					NULL, _Module.GetModuleInstance(), NULL);
#endif
		}
        ASSERT(m_hWnd);
        SetPosition((width - CX_BOOK) / 2, VPAD / 4);

        EnableWindow( m_hWndParent, FALSE );

        if (!m_hWnd) {
                UnregisterClass((LPCSTR)txtAnimateClassName, _Module.GetModuleInstance());
                return FALSE;
        }

        m_fShown = FALSE;
        return TRUE;
}

///////////////////////////// ANIMATE CLASS ///////////////////////////////

Animate::Animate()
{
  m_hDCBmp = NULL;
  m_hWnd = NULL;
  m_originalTickCount = GetTickCount();
  m_hWndParent = NULL;
  m_hBmpTemp = NULL;
  m_hBmpIml = NULL;
}

Animate::~Animate(void)
{
  SafeDeleteDC( m_hDCBmp )
  SafeDeleteObject( m_hBmpTemp );
  SafeDeleteObject( m_hBmpIml );

  EnableWindow( m_hWndParent, TRUE );

  if (m_hWnd) {
    DestroyWindow(m_hWnd);
    m_hWnd = NULL;
    UnregisterClass((LPCSTR) txtAnimateClassName, _Module.GetModuleInstance());
  }
}

/***************************************************************************

        FUNCTION:       AnimFrame

        PURPOSE:        Displays one frame of the "build index" animation
                                in the specified device context.

        PARAMETERS:
                hdc
                x
                y

        RETURNS:

        COMMENTS:

        MODIFICATION DATES:
                04-Nov-1993 [niklasb]

***************************************************************************/

void PASCAL Animate::NextFrame(void)
{
        DWORD curTickCount = GetTickCount();
        if (curTickCount - m_oldTickCount < ANIMATE_INCREMENTS)
                return;
        m_oldTickCount = curTickCount;

        // Delay showing the window for one second. If we get done before then,
        // then there's no need to have gone to all the trouble.

        if (!m_fShown) {
                if (curTickCount - m_originalTickCount < 1000)
                        return;

                HBITMAP hbmBooks = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDBMP_BOOK));
                HBITMAP hbmPens = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDBMP_PENS));
                HDC hdcTemp = CreateCompatibleDC(NULL);
                m_hDCBmp = CreateCompatibleDC(NULL);

                HBITMAP hbmpOldBook = NULL;
                m_hBmpTemp = NULL;
                if (m_hDCBmp) {
                        hbmpOldBook = (HBITMAP)SelectObject(m_hDCBmp, hbmBooks);
                        m_hBmpTemp = CreateCompatibleBitmap(m_hDCBmp, CX_DRAWAREA, CY_DRAWAREA);
                }

                if (!hbmBooks || !hbmPens || !m_hBmpTemp || !m_hDCBmp || !hdcTemp) {
                        if (hbmpOldBook)
                                SelectObject(m_hDCBmp, hbmpOldBook);
                        SafeDeleteObject( hbmpOldBook );
                        SafeDeleteObject( hbmBooks );
                        SafeDeleteObject( hbmPens );
                        SafeDeleteDC( hdcTemp );
                        return;
                }

                m_hBmpIml = CreateCompatibleBitmap(m_hDCBmp, CX_DRAWAREA * C_FRAMES, CY_DRAWAREA);

                HBITMAP hbmpOldTemp = (HBITMAP) SelectObject(hdcTemp, m_hBmpTemp);
                HBITMAP hbmpOldBmp =  (HBITMAP) SelectObject(m_hDCBmp, hbmBooks);

                // Create the frames in which the pen scribbles on the open book.

                m_iFrame = 0;
                for (int y = 0; y < C_VERT_STROKES; y++) {
                        for (int x = 0; x < C_HORZ_STROKES; x++) {

                                // Show the book on a white background.

                                PatBlt(hdcTemp, 0, 0, CX_DRAWAREA, CY_DRAWAREA, WHITENESS);
                                SelectObject(m_hDCBmp, hbmBooks);

                                BitBlt(hdcTemp, X_BOOK, Y_BOOK, CX_BOOK, CY_BOOK, m_hDCBmp,
                                                (C_BOOKS - 1) * CX_BOOK, 0, SRCCOPY);

                                // Add in the scribbled "text".

                                POINT pt;
                                for (int yDraw = 0; yDraw < y; yDraw++) {
                                        for (int xDraw = 0; xDraw < C_HORZ_STROKES; xDraw++) {
                                                PointFromStroke(xDraw, yDraw, &pt);
                                                SetPixel(hdcTemp, pt.x, pt.y + CY_PEN - 1,
                                                        (xDraw & 1) ? clrPenA : clrPenB);
                                        }
                                }
                                for (int xDraw = 0; xDraw <= x; xDraw++) {
                                        PointFromStroke(xDraw, y, &pt);
                                        SetPixel(hdcTemp, pt.x, pt.y + CY_PEN - 1,
                                                        (xDraw & 1) ? clrPenA : clrPenB);
                                }

                                // Add in the pen using the SRCAND operation.

                                SelectObject(m_hDCBmp, hbmPens);
                                BitBlt(hdcTemp, pt.x, pt.y, CX_PEN, CY_PEN, m_hDCBmp,
                                                (m_iFrame & 1) ? CX_PEN : (m_iFrame & 2) * CX_PEN, 0, SRCAND);

                                SelectObject(m_hDCBmp, m_hBmpIml);
                                BitBlt(m_hDCBmp, m_iFrame * CX_DRAWAREA, 0, CX_DRAWAREA, CY_DRAWAREA,
                                        hdcTemp, 0, 0, SRCCOPY);

                                m_iFrame++;
                        }
                }

                // Blast a white background into the temporary bitmap, and
                // select the books bitmap.

                PatBlt(hdcTemp, 0, 0, CX_DRAWAREA, CY_DRAWAREA, WHITENESS);

                // Add the frames for the page turning (from the books bitmap).

                for (int iBook = 0; iBook < C_BOOKS; iBook++) {
                        SelectObject(m_hDCBmp, hbmBooks);
                        BitBlt(hdcTemp, X_BOOK, Y_BOOK, CX_BOOK, CY_BOOK,
                                        m_hDCBmp, iBook * CX_BOOK, 0, SRCCOPY);
                        SelectObject(m_hDCBmp, m_hBmpIml);
                        BitBlt(m_hDCBmp, m_iFrame * CX_DRAWAREA, 0, CX_DRAWAREA, CY_DRAWAREA,
                                hdcTemp, 0, 0, SRCCOPY);
                        m_iFrame++;
                }

                SelectObject(hdcTemp, hbmpOldTemp);

                m_iFrame = 0;

                if (hbmpOldBook)
                        SelectObject(m_hDCBmp, hbmpOldBook);
                SafeDeleteObject(hbmpOldBook);
                SafeDeleteObject(hbmBooks);
                SafeDeleteObject(hbmPens);
                SafeDeleteDC( hdcTemp );

                m_fShown = TRUE;
                ShowWindow(m_hWnd, SW_NORMAL);

        }

        ASSERT(IsValidWindow(m_hWnd));
        HDC hdc = GetDC(m_hWnd);
        HBITMAP hbmpOld = (HBITMAP) SelectObject(m_hDCBmp, m_hBmpIml);
        BitBlt(hdc, m_xPos, m_yPos, CX_DRAWAREA, CY_DRAWAREA, m_hDCBmp,
                m_iFrame * CX_DRAWAREA, 0, SRCCOPY);
        SelectObject(m_hDCBmp, hbmpOld);

        ReleaseDC(m_hWnd, hdc);

        // Next time draw the next frame.

        if (++m_iFrame > C_FRAMES) {
                m_iFrame = 0;
        }
}

static VOID FASTCALL PointFromStroke(int xStroke, int yStroke, POINT* lppt)
{
        int cx = (C_HORZ_STROKES / 2) - xStroke;

        lppt->x = X_PEN + xStroke * CX_STROKE;
        lppt->y = Y_PEN + yStroke * CY_STROKE + cx * cx / 10;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\adsearch.cpp ===
///////////////////////////////////////////////////////////
//
//
// AdSearch.cpp - Implementation of the Advanced Search UI
//
// This source file implements the Advanced Search Navigation
// pane class.

///////////////////////////////////////////////////////////
//
// Include section
//
#include "header.h"

#include "strtable.h" // These headers were copied from search.cpp. Are they all needed?
#include "system.h"
#include "hhctrl.h"
#include "resource.h"
#include "secwin.h"
#include "htmlhelp.h"
#include "cpaldc.h"
#include "fts.h"
#include "TCHAR.h"
#include "parserhh.h"
#include "collect.h"
#include "hhtypes.h"
#include "toc.h"
#include "cctlww.h"
// CFTSListView
#include "listview.h"

// Subsets dialog
#include "csubset.h"

// Our header file.
#include "adsearch.h"

// Get rid of warnings when loading the following.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
//OBM_

// Common Control Macros
#include <windowsx.h>

///////////////////////////////////////////////////////////
//
//                  Constants
//
const char c_PersistFolder[] = "AdvSearchUI\\Keywords"; // Holds keyword list.
const char c_PropertiesFolder[] = "AdvSearchUI\\Properties"; //Holds the properties of the dialog
const wchar_t c_KeywordSeparator[] = L"\n";
const int c_KeywordSeparatatorLength = (sizeof(c_KeywordSeparator)/sizeof(c_KeywordSeparator[0]));

const int c_ListViewColumnPadding = 10;
const int c_MaxKeywordsInCombo = 20;
const int c_MaxKeywordLength    = 250;
const int c_MaxPersistKeywordBufferSize = c_MaxKeywordsInCombo*(c_MaxKeywordLength + c_KeywordSeparatatorLength)+1 /*Ending NULL*/;

#ifdef __SUBSETS__
// The following contants are the item data for the predefined subsets.
const DWORD c_SubSetEntire      =   0xffffffff;
const DWORD c_SubSetPrevious    =   0xfffffffe;
const DWORD c_SubSetCurrent     =   0xfffffffd;
#endif

// Valid State Properties --- These values are persisted in the Properties folder
enum
{
    StateProp_MatchSimilar      = 0x00000001,
    StateProp_TitlesOnly        = 0x00000002,
    StateProp_PrevSearch        = 0x00000004
};

///////////////////////////////////////////////////////////
//
// Static Member functions
//

WNDPROC CAdvancedSearchNavPane::s_lpfnlListViewWndProc = NULL;
WNDPROC CAdvancedSearchNavPane::s_lpfnlKeywordComboEditProc = NULL;
WNDPROC CAdvancedSearchNavPane::s_lpfnlKeywordComboProc = NULL;
WNDPROC CAdvancedSearchNavPane::s_lpfnlGenericBtnProc = NULL;
WNDPROC CAdvancedSearchNavPane::s_lpfnlGenericKeyboardProc = NULL;
#ifdef __SUBSETS__
WNDPROC CAdvancedSearchNavPane::s_lpfnlSubsetsComboProc = NULL;
#endif

///////////////////////////////////////////////////////////
//
// Non-Member helper functions.
//
// Convert a rect from screen to client.
void ScreenRectToClientRect(HWND hWnd, /*in/out*/ RECT* prect);
BOOL WINAPI EnumListViewFont(HWND hwnd, LPARAM lval);

///////////////////////////////////////////////////////////
//
//                  Construction
//
///////////////////////////////////////////////////////////
//
// CAdvancedSearchNavPane();
//
CAdvancedSearchNavPane::CAdvancedSearchNavPane(CHHWinType* pWinType)
:   m_hWnd(NULL),
    m_hfont(NULL),
    m_padding(2),    // padding to put around the window
    m_hbmConj(NULL),
    m_plistview(NULL),
    m_hKeywordComboEdit(NULL),
    m_dwKeywordComboEditLastSel(0),
    m_pWinType(pWinType)
{
    ASSERT(pWinType);
    m_pTitleCollection = pWinType->m_phmData->m_pTitleCollection;
    ASSERT(m_pTitleCollection);

    m_NavTabPos = pWinType->tabpos;
}

///////////////////////////////////////////////////////////
//
//  ~CAdvancedSearchNavPane
//
CAdvancedSearchNavPane::~CAdvancedSearchNavPane()
{
    //--- Persist Keywords in combo
    SaveKeywordCombo();

    //--- CleanUp
   if (m_hfont)
    {
        ::DeleteObject(m_hfont);
    }

    if (m_hbmConj)
    {
        ::DeleteObject(m_hbmConj);
    }

    if (m_hWnd)
    {
        ::DestroyWindow(m_hWnd);
    }

    if(m_plistview)
    {
        if (m_plistview->m_pResults != NULL)
        {
            // Free the results list
            //
            m_pTitleCollection->m_pFullTextSearch->FreeResults(m_plistview->m_pResults);
        }
        delete m_plistview;
    }

    //Don't free m_pTitleCollection
}

///////////////////////////////////////////////////////////
//
//              INavUI Interface functions.
//
///////////////////////////////////////////////////////////
//
// Create
//
BOOL
CAdvancedSearchNavPane::Create(HWND hwndParent)
{
    bool bReturn = false;

    if (m_hWnd)
    {
        return true;
    }

    // ---Create the dialog.
    bool bUnicode = true;
    m_hWnd = CreateDialogParamW(
                        _Module.GetResourceInstance(),
                        MAKEINTRESOURCEW(IDPAGE_TAB_ADVANCED_SEARCH),
                        hwndParent,
                        s_DialogProc,
                        reinterpret_cast<LPARAM>(this)); // Pass over the this pointer.
    if (!m_hWnd)
    {
        bUnicode = false;
        m_hWnd = CreateDialogParamA(
                        _Module.GetResourceInstance(),
                        MAKEINTRESOURCEA(IDPAGE_TAB_ADVANCED_SEARCH),
                        hwndParent,
                        s_DialogProc,
                        reinterpret_cast<LPARAM>(this)); // Pass over the this pointer.
    }
    ASSERT(m_hWnd);

    //--- Initialize the DlgItem Array.
    InitDlgItemArray();

    //--- Initialize the bitmap button.
    m_hbmConj = ::LoadBitmap(NULL, MAKEINTRESOURCE(OBM_MNARROW));
    ASSERT(m_hbmConj);
    // Set the bitmap.
    ::SendMessage(m_aDlgItems[c_ConjunctionBtn].m_hWnd,
        BM_SETIMAGE,
        IMAGE_BITMAP,
        reinterpret_cast<LONG_PTR>(m_hbmConj));

    // Get the size of the bitmap.
    BITMAP bm;
    GetObject(m_hbmConj, sizeof(BITMAP), &bm);

    // Get the width of a 3-d border.
    int cxEdge = GetSystemMetrics(SM_CXEDGE);
    int cyEdge = GetSystemMetrics(SM_CYEDGE);

    // Set the new size.
    SetWindowPos(   m_aDlgItems[c_ConjunctionBtn].m_hWnd, NULL,
                    0,0, //Don't change position.
                    bm.bmWidth+cxEdge, bm.bmHeight+cyEdge, // Change width and height.
                    SWP_NOCOPYBITS | SWP_NOMOVE | SWP_NOZORDER);

    //--- Initialize the results list
    W_EnableUnicode(m_aDlgItems[c_ResultsList].m_hWnd, W_ListView);
//    W_ListView_SetExtendedListViewStyle(m_aDlgItems[c_ResultsList].m_hWnd, LVS_EX_FULLROWSELECT);
    W_ListView_SetExtendedListViewStyle(m_aDlgItems[c_ResultsList].m_hWnd, LVS_EX_FULLROWSELECT | g_RTL_Style);
    // Create the listview object which will manage the list for us.
    m_plistview = new CFTSListView(m_pTitleCollection, m_aDlgItems[c_ResultsList].m_hWnd, true);
    // Sub-class the list view
    if (s_lpfnlListViewWndProc == NULL)
    {
        s_lpfnlListViewWndProc = W_GetWndProc(m_aDlgItems[c_ResultsList].m_hWnd, bUnicode);
    }
    W_SubClassWindow(m_aDlgItems[c_ResultsList].m_hWnd, reinterpret_cast<LONG_PTR>(s_ListViewProc), bUnicode);
    SETTHIS(m_aDlgItems[c_ResultsList].m_hWnd);

#ifdef __SUBSETS__
    //--- Initalize the Search In combo box.
    int index = ComboBox_AddString(m_aDlgItems[c_SubsetsCombo].m_hWnd, GetStringResource(IDS_ADVSEARCH_SEARCHIN_PREVIOUS));
    ComboBox_SetItemData(m_aDlgItems[c_SubsetsCombo].m_hWnd, index, c_SubSetPrevious);
    //--- Add other pre-defined or user defined subsets. <mc>
    UpdateSSCombo(true);
#endif

    //--- Initialize the Keyword combo box.
    // Limit the amount of text which can be typed in.
    int iret = ComboBox_LimitText(m_aDlgItems[c_KeywordCombo].m_hWnd,c_MaxKeywordLength-1);

    // Subclass the keyword combo so that we can process the keys
    if (s_lpfnlKeywordComboProc == NULL)
    {
        s_lpfnlKeywordComboProc  = W_GetWndProc(m_aDlgItems[c_KeywordCombo].m_hWnd, bUnicode);
    }
    W_SubClassWindow(m_aDlgItems[c_KeywordCombo].m_hWnd, reinterpret_cast<LONG_PTR>(s_KeywordComboProc), bUnicode);
    SETTHIS(m_aDlgItems[c_KeywordCombo].m_hWnd);

    // Subclass the keyword combo edit ctrl so that we can keep the current selection around.
    // The edit control is the child of the combobox with the id 1001.
    m_hKeywordComboEdit = ::GetDlgItem(m_aDlgItems[c_KeywordCombo].m_hWnd,1001);
    if (s_lpfnlKeywordComboEditProc == NULL)
    {
        s_lpfnlKeywordComboEditProc  = W_GetWndProc(m_hKeywordComboEdit, bUnicode);
    }
    W_SubClassWindow(m_hKeywordComboEdit, reinterpret_cast<LONG_PTR>(s_KeywordComboEditProc), bUnicode);
    SETTHIS(m_hKeywordComboEdit);

    // font for the combo/EC...
    SendMessage(m_hKeywordComboEdit, WM_SETFONT, (WPARAM) GetFont(), FALSE);
    
    if(g_fBiDi)
	{
	    SetWindowLong(m_hKeywordComboEdit, GWL_STYLE,
            GetWindowLong(m_hKeywordComboEdit, GWL_STYLE) & ~(ES_LEFT));        

	    SetWindowLong(m_hKeywordComboEdit, GWL_STYLE,
            GetWindowLong(m_hKeywordComboEdit, GWL_STYLE) | ES_RIGHT);        

        SetWindowLong(m_hKeywordComboEdit, GWL_EXSTYLE,
            GetWindowLong(m_hKeywordComboEdit, GWL_EXSTYLE) |  g_RTL_Style);
	}
   else
   {
        SetWindowLong(m_hKeywordComboEdit, GWL_EXSTYLE,
            GetWindowLong(m_hKeywordComboEdit, GWL_EXSTYLE) & ~(WS_EX_RTLREADING | WS_EX_RIGHT));
        SetWindowLong(m_hKeywordComboEdit, GWL_STYLE,
            GetWindowLong(m_hKeywordComboEdit, GWL_STYLE) & ~(ES_RIGHT));        
    }    


    //--- Subclass all of the buttons

    // Start with the StartSearch button;
    if (s_lpfnlGenericBtnProc == NULL)
    {
        s_lpfnlGenericBtnProc = W_GetWndProc(m_aDlgItems[c_SearchBtn].m_hWnd, bUnicode);
    }
    W_SubClassWindow(m_aDlgItems[c_SearchBtn].m_hWnd, reinterpret_cast<LONG_PTR>(s_GenericBtnProc), bUnicode);
    SETTHIS(m_aDlgItems[c_SearchBtn].m_hWnd);

    // Bitmap btn
    W_SubClassWindow(m_aDlgItems[c_ConjunctionBtn].m_hWnd, reinterpret_cast<LONG_PTR>(s_GenericBtnProc), bUnicode);
    SETTHIS(m_aDlgItems[c_ConjunctionBtn].m_hWnd);

    // c_DisplayBtn
    W_SubClassWindow(m_aDlgItems[c_DisplayBtn].m_hWnd, reinterpret_cast<LONG_PTR>(s_GenericBtnProc), bUnicode);
    SETTHIS(m_aDlgItems[c_DisplayBtn].m_hWnd);

#ifdef __SUBSETS__
    // c_SubsetsBtn
    W_SubClassWindow(m_aDlgItems[c_SubsetsBtn].m_hWnd, reinterpret_cast<LONG_PTR>(s_GenericBtnProc), bUnicode);
    SETTHIS(m_aDlgItems[c_SubsetsBtn].m_hWnd);
#endif

    //--- Subclass all of the check boxes for generic keyboard handling.

    //--- Init Similar Words Checkbox.
    // Turn on the checkbox
    Button_SetCheck(m_aDlgItems[c_SimilarCheck].m_hWnd, true);
    // Subclass c_SimilarCheck
    if (NULL == s_lpfnlGenericKeyboardProc)
    {
        s_lpfnlGenericKeyboardProc  = W_GetWndProc(m_aDlgItems[c_SimilarCheck].m_hWnd, bUnicode);
    }
    W_SubClassWindow(m_aDlgItems[c_SimilarCheck].m_hWnd, reinterpret_cast<LONG_PTR>(s_GenericKeyboardProc), bUnicode);
    SETTHIS(m_aDlgItems[c_SimilarCheck].m_hWnd);

    // Subclass c_TitlesOnlyCheck
    W_SubClassWindow(m_aDlgItems[c_TitlesOnlyCheck].m_hWnd, reinterpret_cast<LONG_PTR>(s_GenericKeyboardProc), bUnicode);
    SETTHIS(m_aDlgItems[c_TitlesOnlyCheck].m_hWnd);

#ifndef __SUBSETS__
    // Subclass c_TitlesOnlyCheck
    W_SubClassWindow(m_aDlgItems[c_PreviousCheck].m_hWnd, reinterpret_cast<LONG_PTR>(s_GenericKeyboardProc), bUnicode);
    SETTHIS(m_aDlgItems[c_PreviousCheck].m_hWnd);

#else //__SUBSETS__
    //--- Subclass the edit control part of c_SubsetsCombo
    // The edit control is the child of the combobox with the id 1001.
    if (NULL == s_lpfnlSubsetsComboProc)
    {
        s_lpfnlSubsetsComboProc = W_GetWndProc(m_aDlgItems[c_SubsetsCombo].m_hWnd, bUnicode);
    }

    W_SubClassWindow(m_aDlgItems[c_SubsetsCombo].m_hWnd, reinterpret_cast<LONG_PTR>(s_SubsetsComboProc), bUnicode);
    SETTHIS(m_aDlgItems[c_SubsetsCombo].m_hWnd);
#endif

    //--- Set the font. This will fix some dbcs issues.
    for (int i = 0; i < c_NumDlgItems; i++)
    {
        if ( m_aDlgItems[i].m_id != IDC_ADVSRC_KEYWORD_COMBO )
           SendMessage(m_aDlgItems[i].m_hWnd, WM_SETFONT, (WPARAM) _Resource.GetUIFont(), FALSE);
    }

    // Now set the font for the part of the UI that will come from the CHM file.
    SendMessage(m_plistview->m_hwndListView, WM_SETFONT, (WPARAM) GetAccessableContentFont(), FALSE);

    // Make sure the list header uses a normal font
    EnumChildWindows(m_plistview->m_hwndListView, (WNDENUMPROC) EnumListViewFont, 0);

    //--- Fill the combobox with persisted data.
    LoadKeywordCombo();

    //TODO: Fix
    return true;
}

BOOL WINAPI EnumListViewFont(HWND hwnd, LPARAM lParam)
{
    char szClass[MAX_PATH];
    VERIFY(GetClassName(hwnd, szClass, sizeof(szClass)));

    if (IsSamePrefix(szClass, "SysHeader32"))
        SendMessage(hwnd, WM_SETFONT, (WPARAM) _Resource.GetUIFont(), FALSE);

    return TRUE;
}

///////////////////////////////////////////////////////////
//
// OnCommand
//
LRESULT
CAdvancedSearchNavPane::OnCommand(HWND hwnd, UINT id, UINT NotifyCode, LPARAM lParam)
{
    switch(NotifyCode)
    {
    case BN_CLICKED:
        switch(id)
        {
        case IDC_ADVSRC_SEARCH_BTN:
            OnStartSearch();
            break;
        case IDC_ADVSRC_DISPLAY_BTN:
            OnDisplayTopic();
            break;
#ifdef __SUBSETS__
        case IDC_ADVSRC_SUBSET_BTN:
            OnDefineSubsets();
            break;
#endif
        case IDC_ADVSRC_CONJUNCTIONS_BTN:
            OnConjunctions();
            break;
        default:
            return 0;
        }
        return 1;

    case CBN_EDITCHANGE:
        if (id == IDC_ADVSRC_KEYWORD_COMBO)
        {
            // Text in keyword combo has changed. dis/enable Start Search Button.
            EnableDlgItem(c_SearchBtn, W_HasText(reinterpret_cast<HWND>(lParam)) ? true : false);
            return 1;
        }
        break;

    case CBN_SELENDOK:
        if (id == IDC_ADVSRC_KEYWORD_COMBO)
        {
            EnableDlgItem(c_SearchBtn, TRUE);
            return 1;
        }
        break;
    }
    return 0;
}

///////////////////////////////////////////////////////////
//
// ResizeWindow
//
void
CAdvancedSearchNavPane::ResizeWindow()
{
    ASSERT(::IsValidWindow(m_hWnd));

    // Resize to fit the client area of the parent.
    HWND hwndParent = ::GetParent(m_hWnd);
    ASSERT(::IsValidWindow(hwndParent));


    //--- Get the size of the window
    RECT rcParent;
    GetParentSize(&rcParent, hwndParent, m_padding, m_NavTabPos);

    //--- Move and size the dialog box itself.
    ::SetWindowPos( m_hWnd, NULL, rcParent.left, rcParent.top,
                    rcParent.right-rcParent.left,
                    rcParent.bottom-rcParent.top,
                    SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOREDRAW);

    //---Fix the painting bugs. However, this is a little on the flashy side.
    ::InvalidateRect(m_hWnd, NULL, TRUE);

    RECT rcDlg;
    ::GetClientRect(m_hWnd, &rcDlg);

    //--- Now position each control within this space.

    for (int i = 0; i < c_NumDlgItems; i++)
    {
        // Get Current Settings.
        int X = m_aDlgItems[i].m_rectCur.left;
        int Y = m_aDlgItems[i].m_rectCur.top;
        int CX = m_aDlgItems[i].m_rectCur.right - m_aDlgItems[i].m_rectCur.left;
        int CY = m_aDlgItems[i].m_rectCur.bottom - m_aDlgItems[i].m_rectCur.top;

        bool bChanged = false;
        //--- RIGHT JUSTIFICATION
        if (m_aDlgItems[i].m_JustifyH == Justify::Right)
        {
            int NewX = rcDlg.right-m_aDlgItems[i].m_iOffsetH; // subtract the offset
            int MinX = m_aDlgItems[i].m_rectMin.left;
            if (NewX < MinX)
            {
                NewX = MinX;  // Don't go below min.
            }

            if (X != NewX)
            {
                X = NewX; // Update the current setting.
                bChanged = true;
            }
        }

        //--- LEFT JUSTIFICATION
        if (m_aDlgItems[i].m_JustifyH == Justify::Left)
        {
            int MinX = m_aDlgItems[i].m_rectMin.left;
            int NewX = rcDlg.left;

            if (NewX < MinX)
            {
                NewX = MinX;  // Don't go below min.
            }

            if (X != NewX)
            {
                X = NewX; // Update the current setting.
                bChanged = true;
            }
        }

        //--- BOTTOM JUSTIFICATION
        if (m_aDlgItems[i].m_JustifyV == Justify::Bottom)
        {
            int NewY = rcDlg.bottom - m_aDlgItems[i].m_iOffsetV;
            int MinY = m_aDlgItems[i].m_rectMin.top;
            if (NewY < MinY)
            {
                NewY = MinY;
            }

            if (Y != NewY)
            {
                Y = NewY; // Update Setting.
                bChanged = true;
            }
        }

        //--- HORIZONTAL GROWING
        if (m_aDlgItems[i].m_bGrowH)
        {
            int MaxCX = m_aDlgItems[i].m_rectMax.right - m_aDlgItems[i].m_rectMax.left;
            int MinCX = m_aDlgItems[i].m_rectMin.right - m_aDlgItems[i].m_rectMin.left;
            int MinCY = m_aDlgItems[i].m_rectMin.bottom - m_aDlgItems[i].m_rectMin.top;
            int NewRight = rcDlg.right - m_aDlgItems[i].m_iPadH;
            int NewCX = NewRight - m_aDlgItems[i].m_rectMin.left;
            if (NewCX < MinCX)
            {
                NewCX = MinCX;
            }
            else if ((!m_aDlgItems[i].m_bIgnoreMax) && NewCX > MaxCX)
            {
                NewCX = MaxCX;
            }

            if (CX != NewCX)
            {
                CX =  NewCX; // Update Current;
                bChanged = true;
            }
        }

        //--- VERTICAL GROWING
        if (m_aDlgItems[i].m_bGrowV)
        {
            int MaxCY = m_aDlgItems[i].m_rectMax.bottom - m_aDlgItems[i].m_rectMax.top;
            int MinCY = m_aDlgItems[i].m_rectMin.bottom - m_aDlgItems[i].m_rectMin.top;
            int MinCX = m_aDlgItems[i].m_rectMin.right - m_aDlgItems[i].m_rectMin.left;
            int NewBottom = rcDlg.bottom - m_aDlgItems[i].m_iPadV;
            int NewCY = NewBottom - m_aDlgItems[i].m_rectMin.top;
            if (NewCY < MinCY)
            {
                NewCY = MinCY;
            }
            else if ((!m_aDlgItems[i].m_bIgnoreMax) && NewCY > MaxCY)
            {
                NewCY = MaxCY;
            }

            if (CY != NewCY)
            {
                CY = NewCY;
                bChanged = true;
            }
        }

        if (bChanged)
        {
            m_aDlgItems[i].m_rectCur.left = X;
            m_aDlgItems[i].m_rectCur.top = Y;
            m_aDlgItems[i].m_rectCur.right = X + CX;
            m_aDlgItems[i].m_rectCur.bottom = Y + CY;

            ::SetWindowPos(m_aDlgItems[i].m_hWnd, NULL,
                           X, Y, CX, CY,
                           SWP_NOZORDER | SWP_NOOWNERZORDER /*| SWP_NOREDRAW*/);

            // If we have to change the size of the results list, lets change the size of the columns.
            if (i == c_ResultsList)
            {
                m_plistview->SizeColumns();
            }

        }
    }


}


///////////////////////////////////////////////////////////
//
// HideWindow
//
void
CAdvancedSearchNavPane::HideWindow()
{
    if (::IsValidWindow(m_hWnd))
    {
        ::ShowWindow(m_hWnd, SW_HIDE);
    }
}


///////////////////////////////////////////////////////////
//
// ShowWindow
//
void
CAdvancedSearchNavPane::ShowWindow()
{
    if (::IsValidWindow(m_hWnd))
    {
        // Turn the dialog items on/off
        ShowDlgItemsEnabledState();

        // Show the dialog window.
        ::ShowWindow(m_hWnd, SW_SHOW);

        ::SetFocus(m_aDlgItems[c_KeywordCombo].m_hWnd);
    }
}


///////////////////////////////////////////////////////////
//
// SetPadding
//
void
CAdvancedSearchNavPane::SetPadding(int pad)
{
    m_padding = pad;
}


///////////////////////////////////////////////////////////
//
// SetTabPos
//
void
CAdvancedSearchNavPane::SetTabPos(int tabpos)
{
    m_NavTabPos = tabpos;
}



///////////////////////////////////////////////////////////
//
// SetDefaultFocus --- Set focus to the most expected control, usually edit combo.
//
void
CAdvancedSearchNavPane::SetDefaultFocus()
{
    if (::IsValidWindow(m_aDlgItems[c_KeywordCombo].m_hWnd))
    {
        ::SetFocus(m_aDlgItems[c_KeywordCombo].m_hWnd);
    }
}

///////////////////////////////////////////////////////////
//
// ProcessMenuChar --- Process accelerator keys.
//
bool
CAdvancedSearchNavPane::ProcessMenuChar(HWND hwndParent, int ch)
{
    return ::ProcessMenuChar(this, hwndParent, m_aDlgItems, c_NumDlgItems, ch);
}

///////////////////////////////////////////////////////////
//
// OnNotify --- Process WM_NOTIFY messages. Used by embedded Tree and List view controls.
//
LRESULT
CAdvancedSearchNavPane::OnNotify(HWND hwnd, WPARAM idCtrl, LPARAM lParam)
{

    switch(idCtrl)
    {
    case IDC_ADVSRC_RESULTS_LIST:
        if (m_plistview && ::IsValidWindow(m_aDlgItems[c_ResultsList].m_hWnd))
        {
            return m_plistview->ListViewMsg(m_aDlgItems[c_ResultsList].m_hWnd, (NM_LISTVIEW*) lParam);
        }
        break;
    case IDC_ADVSRC_KEYWORD_COMBO:
        break;
    default:
        //return DefDlgProc(m_hWnd, WM_NOTIFY, idCtrl, lParam);
        return 0;
    }

    return 0;
}

///////////////////////////////////////////////////////////
//
// OnDrawItem --- Process WM_DRAWITEM messages.
//
void
CAdvancedSearchNavPane::OnDrawItem(UINT id, LPDRAWITEMSTRUCT pdis)
{
}

///////////////////////////////////////////////////////////
//
// Seed --- Seed the nav ui with a search term or keyword.
//
void
CAdvancedSearchNavPane::Seed(LPCSTR pszSeed)
{
}


///////////////////////////////////////////////////////////
//
//              Helper Functions.
//
///////////////////////////////////////////////////////////
//
// InitDlgItemArray
//
void
CAdvancedSearchNavPane::InitDlgItemArray()
{
    RECT rectCurrent;
    RECT rectDlg;
    ::GetClientRect(m_hWnd, &rectDlg);
    //--- Setup the dlg array for each control.

    //--- Conj menu button
    int i = c_ConjunctionBtn;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_ADVSRC_CONJUNCTIONS_BTN);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_CONJUNCTIONS_BTN;
    m_aDlgItems[i].m_accelkey = 0;              // No accelerator.

    m_aDlgItems[i].m_Type = ItemInfo::Button;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV =;            // Distance from our justification point.
    if(g_bArabicUi)
   {
        m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left
        m_aDlgItems[i].m_iOffsetH = rectCurrent.left - rectDlg.left;
   }
   else
   {
        m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left 
        m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
   }
    //m_aDlgItems[i].m_iPadH =;               // Right Horizontal Padding.
    //m_aDlgItems[i].m_iPadV =;               // Bottom Vertical Padding.

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax;        // Max size.

    //--- Search Term Combo
    i = c_KeywordCombo;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_ADVSRC_KEYWORD_COMBO);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd , &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_KEYWORD_COMBO;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_hWnd, IDC_ADVSRC_KEYWORD_STATIC);

    m_aDlgItems[i].m_Type = ItemInfo::Generic;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = TRUE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV =;            // Distance from our justification point.

    if(g_bBiDiUi)
   {
        m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left
        m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
        m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
      
   }
   else
   {
        m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left
        //m_aDlgItems[i].m_iOffsetH;
        m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
   }
    //m_aDlgItems[i].m_iPadV =;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax;        // Max size.

    //--- Start Search Button
    i = c_SearchBtn;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_ADVSRC_SEARCH_BTN);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_SEARCH_BTN;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_aDlgItems[i].m_hWnd);

    m_aDlgItems[i].m_Type = ItemInfo::Button;
    m_aDlgItems[i].m_bIgnoreEnabled = FALSE;
    m_aDlgItems[i].m_bEnabled = FALSE;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV =;            // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
  //  m_aDlgItems[i].m_iPadH = rectDlg.right = rectCurrent.right;
    //m_aDlgItems[i].m_iPadV =;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax;        // Max size.

    //--- Display Topics Button
    i = c_DisplayBtn;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_ADVSRC_DISPLAY_BTN);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_DISPLAY_BTN;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_aDlgItems[i].m_hWnd);

    m_aDlgItems[i].m_Type = ItemInfo::Button;
    m_aDlgItems[i].m_bIgnoreEnabled = FALSE;
    m_aDlgItems[i].m_bEnabled   = FALSE;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV =;            // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
//    m_aDlgItems[i].m_iPadH = 0;
    //m_aDlgItems[i].m_iPadV =;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax;        // Max size.


    //--- Found Static Text
    i = c_FoundStatic;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_ADVSRC_FOUND_STATIC);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd , &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_FOUND_STATIC;
    m_aDlgItems[i].m_accelkey = 0;

    m_aDlgItems[i].m_Type = ItemInfo::Generic;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV =;            // Distance from our justification point.

//    if(g_bBiDiUi)
// {
//        m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left
//        m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.right;
// }
// else
// {
    m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
// }
    //aDlgItems[i].m_iPadH
    //m_aDlgItems[i].m_iPadV =;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax;        // Max size.

    //--- Results List
    i= c_ResultsList;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_ADVSRC_RESULTS_LIST);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_RESULTS_LIST;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_hWnd, IDC_ADVSRC_STATIC_SELECT); // Associated static ctrl

    m_aDlgItems[i].m_Type = ItemInfo::Generic;
    m_aDlgItems[i].m_bIgnoreEnabled = FALSE;
    m_aDlgItems[i].m_bEnabled = FALSE;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = TRUE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = TRUE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV =;            // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left
    //m_aDlgItems[i].m_iOffsetH;
    m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
    m_aDlgItems[i].m_iPadV = rectDlg.bottom - rectCurrent.bottom;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax;        // Max size.

#ifdef __SUBSETS__
    //--- Search In Static Text
    i = c_SearchInStatic;
    m_aDlgItems[i].m_hWnd= ::GetDlgItem(m_hWnd, IDC_ADVSRC_SEARCHIN_STATIC);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_SEARCHIN_STATIC;
    m_aDlgItems[i].m_accelkey = 0;

    m_aDlgItems[i].m_Type = ItemInfo::Generic;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Bottom;        // Do we stick to the top or the bottom.
    m_aDlgItems[i].m_iOffsetV = rectDlg.bottom - rectCurrent.top; // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left
    //m_aDlgItems[i].m_iOffsetH;
    //m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
    //m_aDlgItems[i].m_iPadV =;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax;        // Max size.

    //--- Search In Combo
    i = c_SubsetsCombo;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_ADVSRC_SUBSET_COMBO);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd , &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_SUBSET_COMBO;
    m_aDlgItems[i].m_accelkey = GetAcceleratorKey(m_hWnd, IDC_ADVSRC_SEARCHIN_STATIC); // Associated static ctrl

    m_aDlgItems[i].m_Type = ItemInfo::Generic;
    m_aDlgItems[i].m_bIgnoreEnabled = true;
    m_aDlgItems[i].m_bEnabled = false;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = TRUE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Bottom;        // Do we stick to the top or the bottom.
    m_aDlgItems[i].m_iOffsetV = rectDlg.bottom - rectCurrent.top; // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    //m_aDlgItems[i].m_iOffsetH;
    m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
    //m_aDlgItems[i].m_iPadV =;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax;        // Max size.


    //--- Define Subset Button
    i = c_SubsetsBtn;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_ADVSRC_SUBSET_BTN);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_SUBSET_BTN;
    m_aDlgItems[i].m_accelkey = GetAcceleratorKey(m_aDlgItems[i].m_hWnd);

    m_aDlgItems[i].m_Type = ItemInfo::Button;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE; //TODO: Implement this control
    m_aDlgItems[i].m_bEnabled = false;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Bottom;        // Do we stick to the top or the bottom.
    m_aDlgItems[i].m_iOffsetV = rectDlg.bottom - rectCurrent.top; // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    m_aDlgItems[i].m_iOffsetH =rectDlg.right - rectCurrent.left;
    //m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
    //m_aDlgItems[i].m_iPadV =;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax;        // Max size.

#else
    //--- IDC_ADVSRC_PREVIOUS_CHECK
    i =     c_PreviousCheck;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_ADVSRC_PREVIOUS_CHECK);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_PREVIOUS_CHECK;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_aDlgItems[i].m_hWnd);

    m_aDlgItems[i].m_Type = ItemInfo::CheckBox;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Bottom;        // Do we stick to the top or the bottom.
    m_aDlgItems[i].m_iOffsetV = rectDlg.bottom - rectCurrent.top; // Distance from our justification point.

    if(g_bBiDiUi)
   {
        m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left; // Maintain same distance. If someone to the right grows we are broken.
        m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
   }
   else
        m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left     
    //m_aDlgItems[i].m_iOffsetH;
    //m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
    //m_aDlgItems[i].m_iPadV =;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax;        // Max size.

#endif
    //--- IDC_ADVSRC_SIMILAR_CHECK
    i = c_SimilarCheck;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_ADVSRC_SIMILAR_CHECK);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_SIMILAR_CHECK;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_aDlgItems[i].m_hWnd);

    m_aDlgItems[i].m_Type = ItemInfo::CheckBox;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Bottom;        // Do we stick to the top or the bottom.
    m_aDlgItems[i].m_iOffsetV = rectDlg.bottom - rectCurrent.top; // Distance from our justification point.

    if(g_bBiDiUi)
   {
        m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left; // Maintain same distance. If someone to the right grows we are broken.
        m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
   }
   else
        m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left

    //m_aDlgItems[i].m_iOffsetH;
    //m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
    //m_aDlgItems[i].m_iPadV =;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax;        // Max size.

    //--- IDC_OPTIONS_CHECK_TITLESONLY
    i = c_TitlesOnlyCheck;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_ADVSRC_TITLESONLY_CHECK);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd , &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_TITLESONLY_CHECK;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_aDlgItems[i].m_hWnd);

    m_aDlgItems[i].m_Type = ItemInfo::CheckBox;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Bottom;        // Do we stick to the top or the bottom.
    m_aDlgItems[i].m_iOffsetV = rectDlg.bottom - rectCurrent.top; // Distance from our justification point.

    if(g_bBiDiUi)
   {
        m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left; // Maintain same distance. If someone to the right grows we are broken.
        m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    }
   else
        m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left

    //m_aDlgItems[i].m_iOffsetH;
    //m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
    //m_aDlgItems[i].m_iPadV =;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax;        // Max size.


    //--- Type in words static text
    i = c_TypeInWordsStatic;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_ADVSRC_KEYWORD_STATIC);
    ::GetWindowRect(m_aDlgItems[i].m_hWnd , &rectCurrent); // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_ADVSRC_KEYWORD_STATIC;
    m_aDlgItems[i].m_accelkey = 0;

    m_aDlgItems[i].m_Type = ItemInfo::Generic;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.

    if(g_bBiDiUi)
    {

        m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
        m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
    }
    else
    {
        m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left
        m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.right;
    }
    //aDlgItems[i].m_iPadH
    //m_aDlgItems[i].m_iPadV =;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;





    
}


///////////////////////////////////////////////////////////
//
// SetEnabledState
//
void
CAdvancedSearchNavPane::ShowDlgItemsEnabledState()
{
    // Enable/Disable all the controls
    for (int i = 0; i < c_NumDlgItems; i++)
    {
        if (!m_aDlgItems[i].m_bIgnoreEnabled && ::IsValidWindow(m_aDlgItems[i].m_hWnd))
        {
            EnableWindow(m_aDlgItems[i].m_hWnd, m_aDlgItems[i].m_bEnabled);
        }
    }
}


///////////////////////////////////////////////////////////
//
// EnableDlgItem
//
void
CAdvancedSearchNavPane::EnableDlgItem(DlgItemInfoIndex index, bool bEnable)
{
    ASSERT(index >= 0 && index < c_NumDlgItems);

    if (!m_aDlgItems[index].m_bIgnoreEnabled)
    {
        // Are we enabled or not?
        m_aDlgItems[index].m_bEnabled = bEnable;

        // Do it for real.
        if (::IsValidWindow(m_aDlgItems[index].m_hWnd))
        {
            EnableWindow(m_aDlgItems[index].m_hWnd, bEnable);
        }
    }

}

///////////////////////////////////////////////////////////
//
// AddKeywordToCombo
//
void
CAdvancedSearchNavPane::AddKeywordToCombo(PCWSTR sz)
{
    PWSTR  pszQuery = NULL;
    PCWSTR psz = sz;
    if (psz == NULL)
    {
        int lenQuery = W_GetTextLengthExact(m_aDlgItems[c_KeywordCombo].m_hWnd);
        if (lenQuery <=0)
        {
            return;
        }
        pszQuery = new WCHAR [++lenQuery];
        W_GetWindowText(m_aDlgItems[c_KeywordCombo].m_hWnd, pszQuery, lenQuery);
        psz = pszQuery;
    }

    if (CB_ERR == W_ComboBox_FindStringExact(m_aDlgItems[c_KeywordCombo].m_hWnd, -1, psz))
    {
        // Not in listbox, so add it to the begining.
        W_ComboBox_InsertString(m_aDlgItems[c_KeywordCombo].m_hWnd, 0, psz);

        // Limit the number of entries.
        int lastindex = ComboBox_GetCount(m_aDlgItems[c_KeywordCombo].m_hWnd);
        if ( lastindex > c_MaxKeywordsInCombo)
        {
            // remove the last one.
            ComboBox_DeleteString(m_aDlgItems[c_KeywordCombo].m_hWnd, lastindex-1 );
        }
    }

    if (pszQuery)
    {
        delete [] pszQuery;
    }
}


///////////////////////////////////////////////////////////
//
// SaveKeywordCombo --- Persists the keyword combo to the storage
//
void
CAdvancedSearchNavPane::SaveKeywordCombo()
{
    // TODO: Implement an IsDirty flag, so that we only save when we need to.

    // Are there any keywords to save?
    int count = ComboBox_GetCount(m_aDlgItems[c_KeywordCombo].m_hWnd);
    if (count > 0 && count != CB_ERR)
    {
        ASSERT(count <= c_MaxKeywordsInCombo);

        WCHAR buffer[c_MaxPersistKeywordBufferSize];
        int bufferlength = W_ComboBox_GetListText(m_aDlgItems[c_KeywordCombo].m_hWnd, buffer, c_MaxPersistKeywordBufferSize);
        ASSERT(bufferlength > 0 );
        if (bufferlength > 0)
        {
            // Save it
            CState* pstate = m_pTitleCollection->GetState();
            if (SUCCEEDED(pstate->Open(c_PersistFolder, STGM_WRITE)))
            {
                pstate->Write(&buffer, (bufferlength+1)*sizeof(WCHAR)); // Include the null terminating char.
                pstate->Close();
            }
        }
    }

    //
    //--- Save UI state.
    //

    // Before we can save, we need to get the state.
    DWORD curstate = 0;

    ASSERT(IsWindow(m_aDlgItems[c_TitlesOnlyCheck].m_hWnd));
    if (Button_GetCheck(m_aDlgItems[c_TitlesOnlyCheck].m_hWnd) == BST_CHECKED)
    {
        curstate |= StateProp_TitlesOnly;
    }

    if (Button_GetCheck(m_aDlgItems[c_SimilarCheck].m_hWnd) == BST_CHECKED)
    {
        curstate |= StateProp_MatchSimilar;
    }

    if (Button_GetCheck(m_aDlgItems[c_PreviousCheck].m_hWnd) == BST_CHECKED)
    {
        curstate |= StateProp_PrevSearch;
    }


    // Now save the state.
    CState* pstate = m_pTitleCollection->GetState();
    if (SUCCEEDED(pstate->Open(c_PropertiesFolder, STGM_WRITE)))
    {
        pstate->Write(&curstate, sizeof(curstate));
        pstate->Close();
    }
}

///////////////////////////////////////////////////////////
//
// LoadKeywordCombo --- Loads the keyword combo from the storage
//
void
CAdvancedSearchNavPane::LoadKeywordCombo()
{
    CState* pstate = m_pTitleCollection->GetState();
    if (SUCCEEDED(pstate->Open(c_PersistFolder, STGM_READ)))
    {
        WCHAR buffer[c_MaxPersistKeywordBufferSize];

        // Read in the persisted data.
        DWORD cbRead;
        pstate->Read(buffer, c_MaxPersistKeywordBufferSize, &cbRead);
        pstate->Close();

        if (cbRead > 0)
        {
            int count = W_ComboBox_SetListText(m_aDlgItems[c_KeywordCombo].m_hWnd, buffer, c_MaxKeywordsInCombo);
            if (count > 0)
            {
                ComboBox_SetCurSel(m_aDlgItems[c_KeywordCombo].m_hWnd, 0);
                EnableDlgItem(c_SearchBtn, true);
            }
        }
    }

    //
    //--- Load UI state.
    //

    // Read in the dword state value
    CState* pstate2 = m_pTitleCollection->GetState(); // Don't trust CState cleanup. So use a new var.
    if (SUCCEEDED(pstate2->Open(c_PropertiesFolder, STGM_READ)))
    {
        DWORD curstate = NULL;
        DWORD cbRead = NULL;
        pstate2->Read(&curstate, sizeof(curstate), &cbRead);
        pstate2->Close();
        if (cbRead == sizeof(curstate))
        {
            // Make the UI match the persisted state.
            // Searching Titles Only?
            ASSERT(IsWindow(m_aDlgItems[c_TitlesOnlyCheck].m_hWnd));
            DWORD check = NULL;
            if (curstate & StateProp_TitlesOnly)
            {
                check = BST_CHECKED;
            }
            else
            {
                check = BST_UNCHECKED;
            }
            Button_SetCheck(m_aDlgItems[c_TitlesOnlyCheck].m_hWnd, check);

            // Matching similar words?
            if (curstate & StateProp_MatchSimilar)
            {
                check = BST_CHECKED;
            }
            else
            {
                check = BST_UNCHECKED;
            }
            Button_SetCheck(m_aDlgItems[c_SimilarCheck].m_hWnd, check);

            check = BST_UNCHECKED;
            Button_SetCheck(m_aDlgItems[c_PreviousCheck].m_hWnd, check);

        }
    }
}

///////////////////////////////////////////////////////////
//
//                  Message Handlers
//
///////////////////////////////////////////////////////////
//
// OnStartSearch
//
void
CAdvancedSearchNavPane::OnStartSearch()
{
    //---Get the word from the edit control.
    int lenQuery = W_GetTextLengthExact(m_aDlgItems[c_KeywordCombo].m_hWnd);
    if (lenQuery <=0)
    {
        return;
    }
    PWSTR pszQuery = new WCHAR [++lenQuery];
    W_GetWindowText(m_aDlgItems[c_KeywordCombo].m_hWnd, pszQuery, lenQuery);

    //--- Disable controls
    // Disable Display Topic Command
    EnableDlgItem(c_DisplayBtn, false);
    // Disable results list
    EnableDlgItem(c_ResultsList, false);

    //---Set up the flags.
    DWORD flags = 0;

    //FTS_SIMILARITY????
    // Does the user want to search titles only?
    if (Button_GetCheck(m_aDlgItems[c_TitlesOnlyCheck].m_hWnd))
    {
        flags |= FTS_TITLE_ONLY;
    }

    if (Button_GetCheck(m_aDlgItems[c_SimilarCheck].m_hWnd))
    {
        flags |= FTS_ENABLE_STEMMING;
    }

#ifndef __SUBSETS__
    //--- Check the previous results checkbox.
    if (Button_GetCheck(m_aDlgItems[c_PreviousCheck].m_hWnd))
    {
        flags |= FTS_SEARCH_PREVIOUS;
    }

#else //__SUBSETS__
    //--- Get the subset.
    CSubSet* pS = NULL;
    int iCurSel = ComboBox_GetCurSel(m_aDlgItems[c_SubsetsCombo].m_hWnd);
    DWORD which = ComboBox_GetItemData(m_aDlgItems[c_SubsetsCombo].m_hWnd, iCurSel);
    if (which == c_SubSetPrevious)
    {
        flags |= FTS_SEARCH_PREVIOUS;
    }
    else
       pS = (CSubSet*)which;
#endif

    //--- Execute the search!
    int ResultCount = 0;
    CHourGlass HourGlass;
    SEARCH_RESULT *pTempResults;
#ifdef __SUBSETS__
    HRESULT hr = m_pTitleCollection->m_pFullTextSearch->ComplexQuery(
                                pszQuery,
                                flags,
                                &ResultCount,
                                &pTempResults, pS);
#else
        HRESULT hr = m_pTitleCollection->m_pFullTextSearch->ComplexQuery(
                                pszQuery,
                                flags,
                                &ResultCount,
                                &pTempResults, NULL);
#endif

    //--- Check the results
    bool bContinue = true;
    if (FAILED(hr))
    {
        bContinue = false;
        if (hr == FTS_NO_INDEX)
            MsgBox(IDS_NO_FTS_DATA);
        else if (hr == FTS_NOT_INITIALIZED)
            MsgBox(IDS_BAD_ITIRCL);
      else if (hr == FTS_INVALID_SYNTAX)
        {
          MsgBox(IDS_INCORRECT_SYNTAX);
            // re-enable results list
            EnableDlgItem(c_ResultsList, true);
        }
/*
        else if (hr == FTS_SKIP_TITLE)
            bContinue = true;
        else if (hr == FTS_SKIP_VOLUME)
            bContinue = true;
        else if (hr == FTS_SKIP_ALL)
            bContinue = true;
*/
        else if (hr == FTS_CANCELED)
        {
            EnableDlgItem(c_ResultsList, true);
        }
        else
            MsgBox(IDS_SEARCH_FAILURE);
    }


    if (bContinue )
    {
        // Make sure that we have results.
        if (!ResultCount)
        {
            // Nothing fun to play with.
            MsgBox(IDS_NO_TOPICS_FOUND);
            bContinue = FALSE;
            // re-enable results list
            EnableDlgItem(c_ResultsList, true);
        }
        else
        {
            if(g_bWinNT5)
            {
                //--- Reset the previous listview.
                //    DOUGO: This change is to leave the previous results intact when the new query fails
                //
                // Display the results number:
                WCHAR wszNewText[128];

                // insert &LRM control character to get mixed layout correct under bidi
                //
                if(g_bBiDiUi)
                    wsprintfW(wszNewText,L"%s%c%d", GetStringResourceW(IDS_ADVSEARCH_FOUND), 0x200E, ResultCount);
                else        
                    wsprintfW(wszNewText,L"%s%d", GetStringResourceW(IDS_ADVSEARCH_FOUND), ResultCount);
                 SetWindowTextW(m_aDlgItems[c_FoundStatic].m_hWnd,wszNewText);
			}
			else
			{
				//--- Reset the previous listview.
				//    DOUGO: This change is to leave the previous results intact when the new query fails
				//
				// Display the results number:
				char szNewText[128];

				// insert &LRM control character to get mixed layout correct under bidi
				//
				if(g_bBiDiUi)
					wsprintf(szNewText,"%s%c%d", GetStringResource(IDS_ADVSEARCH_FOUND), 0xFD, ResultCount);
				else        
					wsprintf(szNewText,"%s%d", GetStringResource(IDS_ADVSEARCH_FOUND), ResultCount);
				Static_SetText(m_aDlgItems[c_FoundStatic].m_hWnd,szNewText);
			}

            m_plistview->ResetQuery();
            m_plistview->SetResults(ResultCount, pTempResults);

        }
    }

    // Do we continue?
    if( bContinue )
    {
        // Enable Display Topic Command
        EnableDlgItem(c_DisplayBtn, true);
        // Enable results list
        EnableDlgItem(c_ResultsList, true);

        // Add the results.
        m_plistview->AddItems();

        //--- If the word isn't already in the list control. Put it in the list control.
        AddKeywordToCombo(pszQuery);
    }
    else
    {
        // We are done.
        SetFocus(m_aDlgItems[c_KeywordCombo].m_hWnd);
    }

    // Cleanup
    delete [] pszQuery;
}

///////////////////////////////////////////////////////////
//
// OnDisplayTopic
//
void
CAdvancedSearchNavPane::OnDisplayTopic()
{
    if( (m_plistview->m_pResults != NULL) && (m_plistview->m_ItemNumber!= -1))
    {
        DWORD dwtemp = m_plistview->m_pResults[m_plistview->m_ItemNumber].dwTopicNumber;
        CExTitle* pTitle = m_plistview->m_pResults[m_plistview->m_ItemNumber].pTitle;

        if ( pTitle )
        {
            char szURL[MAX_URL];
            if ((pTitle->GetTopicURL(dwtemp, szURL, sizeof(szURL)) == S_OK))
            {
                    ChangeHtmlTopic(szURL, GetParent(m_plistview->m_hwndListView), 1);
            }
        }
    }
}

///////////////////////////////////////////////////////////
//
// OnConjunctions
//
void
CAdvancedSearchNavPane::OnConjunctions()
{
    const int NumMenus = 4;
    // Create menu
    HMENU hConjMenu = ::CreatePopupMenu();

    // Get the strings
    CStr MenuText[NumMenus];
    MenuText[0] = GetStringResource(IDS_ADVSEARCH_CONJ_AND);
    MenuText[1] = GetStringResource(IDS_ADVSEARCH_CONJ_OR);
    MenuText[2] = GetStringResource(IDS_ADVSEARCH_CONJ_NEAR);
    MenuText[3] = GetStringResource(IDS_ADVSEARCH_CONJ_NOT);

    // Add the menu items.
    for (int i = 0; i < NumMenus; i++)
    {
        ::HxAppendMenu(hConjMenu, MF_STRING, i+1, MenuText[i]);
    }

    // Get the button rect in screen coordinates for the exclusion area.
    RECT rcExclude;
    ::GetWindowRect(m_aDlgItems[c_ConjunctionBtn].m_hWnd, &rcExclude);

    TPMPARAMS tpm;
    tpm.cbSize = sizeof(tpm);
    tpm.rcExclude = rcExclude;

    // Track the menu.
    int iCommand = TrackPopupMenuEx(  hConjMenu,
                                TPM_LEFTALIGN | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RETURNCMD,
                                rcExclude.right, // Place at upper right of button.
                                rcExclude.top,
                                m_hWnd,
                                &tpm);

    // Act on command
    if (iCommand > 0)
    {
//TODO:[paulde] Unicode-ize -- veeery carefully. Think about GetEditSel coords
//  in MBCS text and how to map to WCHAR coords.
        char text[256];
        int iSelectionIndex; // Where to put the caret when we are done.

        //---Get the word from the edit control.
        char* pszQuery = NULL;
        int len = ComboBox_GetTextLength(m_aDlgItems[c_KeywordCombo].m_hWnd);
        if (len <= 0)
        {
            // No text in edit control. Just put our text into the control.
            ComboBox_SetText(m_aDlgItems[c_KeywordCombo].m_hWnd, MenuText[iCommand-1]);

            // Get length of selection.
            iSelectionIndex = (int)strlen(MenuText[iCommand-1]);
        }
        else
        {
            // There is text in the edit control. Replace the selection.

            // Get the existing text
            pszQuery = new char[len+1];
            ComboBox_GetText(m_aDlgItems[c_KeywordCombo].m_hWnd, pszQuery, len+1);


            // Find out what is selected.
            int end = HIWORD(m_dwKeywordComboEditLastSel);
            int start = LOWORD(m_dwKeywordComboEditLastSel);

			char *pszTemp = pszQuery;
			int char_start = 0, count = 0;

			// The above start/end values are in character offsets which 
			// do not correspond to byte offsets when we have DBCS chars.
			//
			// find out the start value in bytes:
			//
			while(*pszTemp && count < start)
			{
				char_start++;
				char_start+=IsDBCSLeadByte(*pszTemp);
				pszTemp = CharNext(pszTemp);
				++count;
			}

			int char_end = 0;

			// do the same thing to compute the end offset in bytes
			//
			pszTemp = pszQuery;
			count = 0;
			while(*pszTemp && count < end)
			{
				char_end++;
				char_end+=IsDBCSLeadByte(*pszTemp);
				pszTemp = CharNext(pszTemp);
				++count;
			}
			
			// set buffer to all zeros. So we can just concat.
            _strnset(text,'\0',sizeof(text));

            if (start > 0)
            {
                // Copy the first part of the string.
                strncat(text, pszQuery, char_start); // doesn't add null.
            }
            // Insert the conjunction surrounded by spaces.
            strcat(text, " ");
            strcat(text, MenuText[iCommand-1]);
            strcat(text, " ");

            iSelectionIndex = (int)strlen(text);

            if (end>=0)
            {
                //Copy the last part of the string.
                strcat(text,&pszQuery[char_end]);
            }

            // Set the text.
            ComboBox_SetText(m_aDlgItems[c_KeywordCombo].m_hWnd, text);

            // Cleanup
            if (pszQuery)
            {
                delete [] pszQuery;
            }
        }
        // Set focus to the control.
        SetFocus(m_aDlgItems[c_KeywordCombo].m_hWnd);

        // Put the cursor at the end of the text just added.
        ComboBox_SetEditSel(m_aDlgItems[c_KeywordCombo].m_hWnd, iSelectionIndex, iSelectionIndex);
    }


}

///////////////////////////////////////////////////////////
//
// OnDefineSubsets
//
void
CAdvancedSearchNavPane::OnDefineSubsets()
{
#ifdef __SUBSETS__
   CSubSet* pS;
   int index;

   if (! m_pTitleCollection->m_phmData->m_pInfoType )
   {
      m_pTitleCollection->m_phmData->m_pInfoType = new CInfoType();
      m_pTitleCollection->m_phmData->m_pInfoType->CopyTo( m_pTitleCollection->m_phmData );
   }
   if ( ChooseInformationTypes(m_pTitleCollection->m_phmData->m_pInfoType, NULL, m_hWnd, NULL, m_pWinType) )
   {
      pS = m_pTitleCollection->m_pSubSets->m_cur_Set;
      if ( pS && pS->m_cszSubSetName.psz )
      {
         if ( ComboBox_SelectString(m_aDlgItems[c_SubsetsCombo].m_hWnd, -1, pS->m_cszSubSetName.psz) == CB_ERR )
         {
            index = ComboBox_AddString(m_aDlgItems[c_SubsetsCombo].m_hWnd, pS->m_cszSubSetName.psz);
            ComboBox_SetItemData(m_aDlgItems[c_SubsetsCombo].m_hWnd, index, pS);
            ComboBox_SetCurSel(m_aDlgItems[c_KeywordCombo].m_hWnd, index );
         }
      }
   }
#endif
}

//////////////////////////////////////////////////////////////////////////
//
// UpdateSSCombo
//
void
CAdvancedSearchNavPane::UpdateSSCombo(bool bInitialize)
{
#ifdef __SUBSETS__
   if (m_pTitleCollection && m_pTitleCollection->m_pSubSets)
   {
        CSubSets* pSS = m_pTitleCollection->m_pSubSets;

        int max = pSS->HowManySubSets();
        for (int n = 0; n < max; n++ )
        {
            CSubSet* pS = pSS->GetSubSet(n);
            if (pS)
            {
                // If we are initializing, add them all. If we are updating, only add the ones we don't have.
                if ( bInitialize || ComboBox_FindStringExact(m_aDlgItems[c_SubsetsCombo].m_hWnd, -1, pS->m_cszSubSetName.psz) == CB_ERR )
                {
                    int index = ComboBox_AddString(m_aDlgItems[c_SubsetsCombo].m_hWnd, pS->m_cszSubSetName.psz);
                    ComboBox_SetItemData(m_aDlgItems[c_SubsetsCombo].m_hWnd, index, pS);
                }
            }
        }

        //--- Set the selected line.
        int bItemSelected = CB_ERR;

        // Try setting it to the current subset.
        if (max > 0 && pSS->m_FTS && pSS->m_FTS->m_cszSubSetName.psz )
          bItemSelected = ComboBox_SelectString(m_aDlgItems[c_SubsetsCombo].m_hWnd, -1, pSS->m_FTS->m_cszSubSetName); //BUGBUG: m_cszSubSetName this is non-sense!

        // Try explictly setting it to Entire Collection.
        if (bItemSelected == CB_ERR)
        {
          bItemSelected = ComboBox_SelectString(m_aDlgItems[c_SubsetsCombo].m_hWnd, -1, GetStringResource(IDS_ADVSEARCH_SEARCHIN_ENTIRE));
        }

        // Okay, now just set it to the first one!.
        if (bItemSelected == CB_ERR)
        {
            ComboBox_SetCurSel(m_aDlgItems[c_KeywordCombo].m_hWnd, 0);
        }
    }
#endif
}

///////////////////////////////////////////////////////////
//
// OnTab - Handles pressing of the tab key.
//
void
CAdvancedSearchNavPane::OnTab(HWND hwndReceivedTab, DlgItemInfoIndex /*index*/)
{
    //if (index == c_NumDlgItems) --- caller doesn't know the index.
    ASSERT(::IsValidWindow(hwndReceivedTab));

    //--- Is the shift key down?
    BOOL bPrevious = (GetKeyState(VK_SHIFT) < 0);
#if 0
    //---Are we the first or last control?
    if ((bPrevious && hwndReceivedTab == m_hKeywordComboEdit/*m_aDlgItems[c_KeywordCombo].m_hWnd*/) || // The c_KeywordCombo control is the first control, so shift tab goes to the topic window.
        (!bPrevious && hwndReceivedTab == m_aDlgItems[c_TitlesOnlyCheck].m_hWnd)) // The c_TitlesOnlyCheck is the last control, so tab goes to the topic window.
    {

        PostMessage(m_pWinType->GetHwnd(), WMP_HH_TAB_KEY, 0, 0);
    }
    else
#endif
    {
        //--- Move to the next control .
        // Get the next tab item.
        HWND hWndNext = GetNextDlgTabItem(m_hWnd, hwndReceivedTab, bPrevious);
        // Set focus to it.
        ::SetFocus(hWndNext);
    }
}

///////////////////////////////////////////////////////////
//
// OnArrow
//
void
CAdvancedSearchNavPane::OnArrow(HWND hwndReceivedTab, DlgItemInfoIndex /*index*/, INT_PTR key)
{
    //if (index == c_NumDlgItems) --- caller doesn't know the index.

    ASSERT(::IsValidWindow(hwndReceivedTab));

    BOOL bPrevious = FALSE;
    if (key == VK_LEFT || key == VK_UP)
    {
        bPrevious = TRUE;
    }

    // Get the next tab item.
    HWND hWndNext = GetNextDlgGroupItem(m_hWnd, hwndReceivedTab, bPrevious);
    // Set focus to it.
    ::SetFocus(hWndNext);
}

///////////////////////////////////////////////////////////
//
// OnReturn - Default handling of the return key.
//
bool
CAdvancedSearchNavPane::OnReturn(HWND hwndReceivedTab, DlgItemInfoIndex /*index*/)
{
    //if (index == c_NumDlgItems) --- caller doesn't know the index.

    // Do the default button action.
    // Always do a search topic, if its enabled.
    if (::IsWindowEnabled(m_aDlgItems[c_SearchBtn].m_hWnd))
    {
        OnStartSearch();
        return true;
    }
    else
    {
        return false;
    }

}
///////////////////////////////////////////////////////////
//
//              Callback Functions.
//
///////////////////////////////////////////////////////////
//
// Static DialogProc
//
INT_PTR CALLBACK
CAdvancedSearchNavPane::s_DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Call member function dialog proc.
    if (msg == WM_INITDIALOG)
    {
        // The lParam is the this pointer for this dialog box.
        // Save it in the window userdata section.
        ::SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
    }

    // Get the this pointer and call the non-static callback function.
    CAdvancedSearchNavPane* p = GETTHIS(CAdvancedSearchNavPane, hwnd);
    if (p)
    {
        return p->DialogProc(hwnd, msg, wParam, lParam);
    }
    else
    {
        return FALSE;
    }
}

///////////////////////////////////////////////////////////
//
// ListViewProc
//
LRESULT WINAPI
CAdvancedSearchNavPane::s_ListViewProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
            // A return means that we want to display the currently selected topic.
            GETTHIS(CAdvancedSearchNavPane, hwnd)->OnDisplayTopic();
            return 0;
        case VK_TAB:
            GETTHIS(CAdvancedSearchNavPane, hwnd)->OnTab(hwnd, c_ResultsList);
            break;
        }
        break;
    }
    return W_DelegateWindowProc(s_lpfnlListViewWndProc, hwnd, msg, wParam, lParam);
}

///////////////////////////////////////////////////////////
//
//  KeywordComboEditProc - Subclassed the Edit Control in the Keyword Combo Box
// The original reason for doing this was to save the selection location.
//
LRESULT WINAPI
CAdvancedSearchNavPane::s_KeywordComboEditProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CAdvancedSearchNavPane* pThis;
    switch (msg)
    {
    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
            pThis = GETTHIS(CAdvancedSearchNavPane, hwnd);
            if (pThis->OnReturn(hwnd, c_KeywordCombo))
            {
                pThis->AddKeywordToCombo();
                return 0;
            }
            break;
        case VK_TAB:
            GETTHIS(CAdvancedSearchNavPane, hwnd)->OnTab(hwnd,c_KeywordCombo);
            return 0;
        }
        break;

    case WM_CHAR:
        if (wParam == VK_TAB) // The virt code is the same as the tab character.
        {
            // Not handling this message was causing a beep.
            return 0;
        }
        break;

/*  There is no point in handling this message, because it never gets sent.
    it is sent by IsDialogMessage which never gets called...
    case WM_GETDLGCODE:
        return DLGC_WANTTAB;
*/

    case WM_KILLFOCUS:
        // Save the selection so that we can use it to insert the conjunctions.
        GETTHIS(CAdvancedSearchNavPane, hwnd)->m_dwKeywordComboEditLastSel = Edit_GetSel(hwnd);
        break;
    }
    return W_DelegateWindowProc(s_lpfnlKeywordComboEditProc, hwnd, msg, wParam, lParam);
}

///////////////////////////////////////////////////////////
//
// KeywordComboProc -
// We handle the keyboard.
//
LRESULT WINAPI
CAdvancedSearchNavPane::s_KeywordComboProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
/* We don't process any messages here.
    switch (msg)
    {

        case WM_KEYDOWN:
            if (wParam == VK_TAB)
                return 0;
            break;

    case WM_GETDLGCODE:
        return DLGC_WANTTAB;

    }
*/
    return W_DelegateWindowProc(s_lpfnlKeywordComboProc, hwnd, msg, wParam, lParam);
}


///////////////////////////////////////////////////////////
//
//  s_SubsetsComboEditProc - Subclassed the Edit Control in the Subset Combo Box
//
#ifdef __SUBSETS__
LRESULT WINAPI
CAdvancedSearchNavPane::s_SubsetsComboProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
            if (GETTHIS(CAdvancedSearchNavPane, hwnd)->OnReturn(hwnd, c_SubsetsCombo))
                return 0;
            break;
        case VK_TAB:
            GETTHIS(CAdvancedSearchNavPane, hwnd)->OnTab(hwnd,c_SubsetsCombo);
            return 0;
        }
    }
    return W_DelegateWindowProc(s_lpfnlSubsetsComboProc, hwnd, msg, wParam, lParam);
}
#endif
///////////////////////////////////////////////////////////
//
// Generic keyboard handling for all btns.
//
LRESULT WINAPI
CAdvancedSearchNavPane::s_GenericBtnProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CAdvancedSearchNavPane* pThis;
    switch (msg)
    {
    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
            pThis = GETTHIS(CAdvancedSearchNavPane, hwnd);
            return pThis->OnCommand(pThis->m_hWnd, ::GetDlgCtrlID(hwnd), BN_CLICKED, lParam);

        case VK_TAB:
            GETTHIS(CAdvancedSearchNavPane, hwnd)->OnTab(hwnd,c_NumDlgItems);
            return 0;

        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            GETTHIS(CAdvancedSearchNavPane, hwnd)->OnArrow(hwnd,c_NumDlgItems, wParam);
            return 0;
        }
    }
    return W_DelegateWindowProc(s_lpfnlGenericBtnProc, hwnd, msg, wParam, lParam);
}

///////////////////////////////////////////////////////////
//
// Generic keyboard handling for other controls which aren't handled elsewhere.
//
LRESULT WINAPI
CAdvancedSearchNavPane::s_GenericKeyboardProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
            if (GETTHIS(CAdvancedSearchNavPane, hwnd)->OnReturn(hwnd, c_NumDlgItems))
                return 0;
            break;

        case VK_TAB:
            GETTHIS(CAdvancedSearchNavPane, hwnd)->OnTab(hwnd, c_NumDlgItems);
            return 0;

        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            GETTHIS(CAdvancedSearchNavPane, hwnd)->OnArrow(hwnd, c_NumDlgItems, wParam);
            return 0;
        }
        break;
    }
    return W_DelegateWindowProc(s_lpfnlGenericKeyboardProc, hwnd, msg, wParam, lParam);
}

///////////////////////////////////////////////////////////
//
// DialogProc
//
INT_PTR
CAdvancedSearchNavPane::DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
    case WM_COMMAND: return OnCommand(hwnd, LOWORD(wParam), HIWORD(wParam), lParam);
    case WM_NOTIFY : return OnNotify(hwnd, wParam, lParam);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hh\init.c ===
#define NOATOM
#define NOCOMM
#define NODEFERWINDOWPOS
#define NODRIVERS
#define NOEXTDEVMODEPROPSHEET
#define NOIME
#define NOKANJI
#define NOMDI
#define NOLOGERROR
#define NOMCX
#define NOPROFILER
#define NOSCALABLEFONT
#define NOSERVICE
#define NOSOUND
#define NOWINDOWSX
#define NOENHMETAFILE

// Ignore header files that have to be read that we don't want.

#define _WINNETWK_
//#define _WINREG_
#define _WINCON_
#define VER_H
//#define _OLE2_H_

//#define WIN32_LEAN_AND_MEAN

#include <windows.h>

int __cdecl _purecall(void)
{
    return -1;
}

typedef void (__cdecl *_PVFV)(void);

#if defined(_M_IX86)
int __cdecl atexit(_PVFV func)
{
    return -1;
}
#endif

#pragma data_seg(".text", "CODE")
static const char txtHHCtrl[] = "hhctrl.ocx";
static const char txtDoWinMain[] = "doWinMain";
static const CLSID CLSID_HHCtrl = {0xadb880a6,0xd8ff,0x11cf,{0x93,0x77,0x00,0xaa,0x00,0x3b,0x7a,0x11}};
static const char txtStringGuid[] = "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}";
static const char txtInProc[] = "CLSID\\%s\\InprocServer32";
#pragma data_seg()

//=--------------------------------------------------------------------------=
// StringFromGuidA
//=--------------------------------------------------------------------------=
// returns an ANSI string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPSTR                - [in/out]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
int StringFromGuidA( CLSID riid, LPSTR pszBuf )
{
  return wsprintf( (char*) pszBuf,
    txtStringGuid,
    riid.Data1, riid.Data2, riid.Data3,
    riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3],
    riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);
}

#define GUID_STR_LEN  40

//=--------------------------------------------------------------------------=
// GetRegisteredLocation
//=--------------------------------------------------------------------------=
// Returns the registered location of an inproc server given the CLSID
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
//
// Parameters:
//    REFCLSID     - [in] CLSID of the object
//    LPTSTR       - [in/out] Pathname
//
// Output:
//    BOOL         - FALSE means couldn't find it

BOOL GetRegisteredLocation( CLSID riid, LPTSTR pszPathname )
{
  BOOL bReturn = FALSE;
  HKEY hKey = NULL;
  char szGuidStr[GUID_STR_LEN];
  char szScratch[MAX_PATH];

  if( !StringFromGuidA( riid, szGuidStr ) )
    return FALSE;

  wsprintf( szScratch, txtInProc, szGuidStr );
  if( RegOpenKeyEx( HKEY_CLASSES_ROOT, szScratch, 0, KEY_READ, &hKey ) == ERROR_SUCCESS ) {
    DWORD dwSize = MAX_PATH;
    if( RegQueryValueEx( hKey, "", 0, 0, szScratch, &dwSize ) == ERROR_SUCCESS ) {
      lstrcpy( pszPathname, szScratch );
      bReturn = TRUE;
    }
  }

  if( hKey )
    RegCloseKey( hKey );

  return bReturn;
}

FARPROC pDoWinMain;
int doWinMain(HINSTANCE hinstApp, LPSTR lpszCmdLine);

int WINAPI WinMain(HINSTANCE hinstCur, HINSTANCE hinstPrev, LPSTR lpszCmdLine,
    int iCmdShow)
{
    TCHAR szHHCtrl[MAX_PATH];
    HMODULE hmodHHCtrl;

    // if we have a registered location for hhctrl.ocx then use it
    // otherwise load the one on the path
    if( !GetRegisteredLocation( CLSID_HHCtrl, szHHCtrl ) )
      lstrcpy( szHHCtrl, txtHHCtrl );

    hmodHHCtrl = (HMODULE) LoadLibrary( szHHCtrl );
    if( !hmodHHCtrl )
      hmodHHCtrl = (HMODULE) LoadLibrary( txtHHCtrl );
      
    if( hmodHHCtrl ) {
      if( pDoWinMain = GetProcAddress( hmodHHCtrl, txtDoWinMain ) ) {
        int iReturn = (int)pDoWinMain(hinstCur, lpszCmdLine);
        FreeLibrary( hmodHHCtrl );
        return iReturn;
      }
    }
    return -1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\aboutbox.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.H"
#include "resource.h"
#include "hhctrl.h"

// Code used to display an authored Version or About dialog box

BOOL CALLBACK AboutBoxDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);

void CHtmlHelpControl::doAboutBox()
{
	DialogBoxParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDDLG_ABOUTBOX),
		m_hwnd, (DLGPROC) AboutBoxDlgProc, (LPARAM) m_ptblItems);
}

/***************************************************************************

	FUNCTION:	AboutBoxDlgProc

	PURPOSE:	Display an "About" box with up to 3 authored lines

	COMMENTS:
		The first string in g_ptblItems is the title, the next 3 strings are
		text for each of the static controls. If the string isn't supplied,
		the the control is hidden.

		Note that we don't deal with trunctaion, wrapping, etc. It's up
		to the help author to be sure the lines aren't too long (not an issue
		if the control is authored with HtmlHelp Workshop).

	MODIFICATION DATES:
		02-Jul-1997 [ralphw]

***************************************************************************/

BOOL CALLBACK AboutBoxDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
		case WM_INITDIALOG:
			{
				CTable* ptblItems = (CTable*) lParam;

				ASSERT(ptblItems && ptblItems->CountStrings());
				if (ptblItems->CountStrings())
					SetWindowText(hdlg, ptblItems->GetPointer(1));

				for (int id = IDC_LINE1; id <= IDC_LINE3; id++) {

					// -2 because CTable is 1-based, and we skip over the title

					if (id - IDC_LINE1 > ptblItems->CountStrings() - 2)
						break;

					 SetWindowText(GetDlgItem(hdlg, id),
						ptblItems->GetPointer((id - IDC_LINE1) + 2));
				}

				// Hide any unused controls

				while (id <= IDC_LINE3)
					ShowWindow(GetDlgItem(hdlg, id++), SW_HIDE);

				return FALSE;
			}

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
				EndDialog(hdlg, FALSE);
			break;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\animate.h ===
BOOL STDCALL StartAnimation(int idTitle, HWND hWnd = NULL);
void STDCALL NextAnimation(void);
void STDCALL StopAnimation(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\atlinc.h ===
// ATLINC.H:  Common includes used primarily for ATL

#ifndef __ATLINC_H__
#define __ATLINC_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_FREE_THREADED
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
#include "module.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CHtmlHelpModule _Module;
#include <atlcom.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\adsearch.h ===
#ifndef _ADSEARCH_H__
#define _ADSEARCH_H__
///////////////////////////////////////////////////////////
//
//
// AdSearch.h - Advanced Search UI
//
// This header file defines the Advanced Search Navigation
// pane class.

#include "navui.h"

// Other nav pane related structures.
#include "navpane.h"

///////////////////////////////////////////////////////////
//
// Subset Dialog Removal
//
#define _SUBSETS__


///////////////////////////////////////////////////////////
//
// Forwards
//
class CFTSListView;

///////////////////////////////////////////////////////////
//
// Constants
//
typedef enum DlgItemInfoIndex
{
    c_KeywordCombo,
    c_ConjunctionBtn,
    c_SearchBtn,
    c_DisplayBtn,
    c_FoundStatic,
    c_ResultsList,
#ifdef __SUBSETS__
    c_SearchInStatic,
    c_SubsetsCombo,
    c_SubsetsBtn,
#else
    c_PreviousCheck,
#endif
    c_SimilarCheck,
    c_TitlesOnlyCheck,
    c_TypeInWordsStatic,
    c_NumDlgItems
};

///////////////////////////////////////////////////////////
//
// CAdvancedSearchNavPane
//
class CAdvancedSearchNavPane : public INavUI
{
public:
    //---Construction
    CAdvancedSearchNavPane(CHHWinType* pWinType);
    virtual ~CAdvancedSearchNavPane() ;

public:
    //--- INavUI Interface functions.
      virtual BOOL Create(HWND hwndParent);
   virtual LRESULT OnCommand(HWND hwnd, UINT id, UINT uNotifiyCode, LPARAM lParam);
   virtual void ResizeWindow();
   virtual void HideWindow() ;
   virtual void ShowWindow() ;
      virtual void SetPadding(int pad) ;
   virtual void SetTabPos(int tabpos) ;

    // Set focus to the most expected control, usually edit combo.
    virtual void SetDefaultFocus() ;
    // Process accelerator keys.
    virtual bool ProcessMenuChar(HWND hwndParent, int ch) ;
    // Process WM_NOTIFY messages. Used by embedded Tree and List view controls.
    virtual LRESULT  OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam) ;
    // Process WM_DRAWITEM messages.
    virtual void OnDrawItem(UINT id, LPDRAWITEMSTRUCT pdis) ;
    // Seed the nav ui with a search term or keyword.
    virtual void Seed(LPCSTR pszSeed) ;

    void OnVKListNotify(NMHDR* pNMHdr) {/*Not Implemented*/}

public:
    // Called from code that may add or delete subsets so that we can update our list accordingly.
    void    UpdateSSCombo(bool bInitialize = false);

private:
    //--- Helper Functions.
    void    SetFont (HFONT hfont) { m_hfont = hfont; }
    void    InitDlgItemArray() ;
    void    ShowDlgItemsEnabledState() ;
    void    EnableDlgItem(DlgItemInfoIndex index, bool bEnabled) ;
    void    AddKeywordToCombo(PCWSTR sz = NULL) ;
    void    SaveKeywordCombo() ;
    void    LoadKeywordCombo() ;

protected:
    //--- Message Handler Functions
    void    OnStartSearch() ;
    void    OnDisplayTopic() ;
    void    OnDefineSubsets() ;
    void    OnConjunctions() ;
    void    OnTab(HWND hwndReceivedTab, DlgItemInfoIndex index) ;
    void    OnArrow(HWND hwndReceivedTab, DlgItemInfoIndex index, INT_PTR key) ;
    bool    OnReturn(HWND hwndReceivedTab, DlgItemInfoIndex /*index*/);

    HFONT GetFont() { return m_pWinType->GetContentFont(); }
    HFONT GetAccessableContentFont() { return m_pWinType->GetAccessableContentFont(); }

private:
    //--- Callbacks
    static INT_PTR  CALLBACK s_DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) ;
    INT_PTR DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) ;
    static LRESULT WINAPI s_ListViewProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT WINAPI s_KeywordComboProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT WINAPI s_KeywordComboEditProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#ifdef __SUBSETS__
    static LRESULT WINAPI s_SubsetsComboProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#endif

    // shared by all btns.
    static LRESULT WINAPI s_GenericBtnProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // shared by other ctrls to handle keyboard
    static LRESULT WINAPI s_GenericKeyboardProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

protected:
    //--- Statics
    static WNDPROC s_lpfnlListViewWndProc;
    static WNDPROC s_lpfnlKeywordComboProc ;
    static WNDPROC s_lpfnlKeywordComboEditProc ;
#ifdef __SUBSETS__
    static WNDPROC s_lpfnlSubsetsComboProc ;
#endif
    static WNDPROC s_lpfnlGenericBtnProc ; // Shared by all btns.
    static WNDPROC s_lpfnlGenericKeyboardProc ; // Shared by ctrls which don't use one of the other procs.

private:
    //--- Member Functions.
   HWND     m_hWnd;
   HFONT    m_hfont;    // author-specified font to use for child windows
   int      m_padding;
   int      m_NavTabPos;   // location of parent tabs

    // Members supporting the Conj button.
    HBITMAP     m_hbmConj ;      // Bitmap

    // Array of dlgitems
    CDlgItemInfo m_aDlgItems[c_NumDlgItems] ;

    // Pointer to the TitleCollection on which we will search.
    CExCollection* m_pTitleCollection;

    // class to manage the list view control
    CFTSListView    *m_plistview;

    // Handle to the edit control of the keyword combobox
    HWND m_hKeywordComboEdit ;

    // Cache for the last selection in the combobox
    DWORD m_dwKeywordComboEditLastSel ;

    // Holds a pointer to the wintype so we can send the WMP_HH_TAB_KEY message to it.
    CHHWinType* m_pWinType;
};

#endif //_ADSEARCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\atlimpl.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_H__
	#error atlimpl.cpp requires atlbase.h to be included first
#endif

extern "C" const IID IID_IRegistrar = {0x44EC053B,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
#ifndef _ATL_DLL_IMPL
extern "C" const CLSID CLSID_Registrar = {0x44EC053A,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
#endif

#include <atlconv.cpp>
#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>
#endif

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

// used in thread pooling
UINT CComApartment::ATL_CREATE_OBJECT = 0;

#ifdef __ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
// AtlReportError

HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, const IID& iid,
	HRESULT hRes, HINSTANCE hInst)
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), 0, NULL, iid, hRes, hInst);
}

HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), dwHelpID,
		lpszHelpFile, iid, hRes, hInst);
}

#ifndef OLE2ANSI
HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	DWORD dwHelpID, LPCSTR lpszHelpFile, const IID& iid, HRESULT hRes)
{
	_ASSERTE(lpszDesc != NULL);
	USES_CONVERSION;
	return AtlSetErrorInfo(clsid, A2COLE(lpszDesc), dwHelpID, A2CW(lpszHelpFile),
		iid, hRes, NULL);
}

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	_ASSERTE(lpszDesc != NULL);
	USES_CONVERSION;
	return AtlSetErrorInfo(clsid, A2COLE(lpszDesc), 0, NULL, iid, hRes, NULL);
}
#endif

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	return AtlSetErrorInfo(clsid, lpszDesc, 0, NULL, iid, hRes, NULL);
}

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes)
{
	return AtlSetErrorInfo(clsid, lpszDesc, dwHelpID, lpszHelpFile, iid, hRes, NULL);
}

#endif //__ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

CComBSTR& CComBSTR::operator=(const CComBSTR& src)
{
	if (m_str != src.m_str)
	{
		if (m_str)
			::SysFreeString(m_str);
		m_str = src.Copy();
	}
	return *this;
}

CComBSTR& CComBSTR::operator=(LPCOLESTR pSrc)
{
	::SysFreeString(m_str);
	m_str = ::SysAllocString(pSrc);
	return *this;
}

void CComBSTR::Append(LPCOLESTR lpsz, int nLen)
{
	int n1 = Length();
	BSTR b = SysAllocStringLen(NULL, n1+nLen);
	memcpy(b, m_str, n1*sizeof(OLECHAR));
	memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
	b[n1+nLen] = NULL;
	SysFreeString(m_str);
	m_str = b;
}

#ifndef OLE2ANSI
void CComBSTR::Append(LPCSTR lpsz)
{
	USES_CONVERSION;
	LPCOLESTR lpo = A2COLE(lpsz);
	Append(lpo, ocslen(lpo));
}

CComBSTR::CComBSTR(LPCSTR pSrc)
{
	USES_CONVERSION;
	m_str = ::SysAllocString(A2COLE(pSrc));
}

CComBSTR::CComBSTR(int nSize, LPCSTR sz)
{
	USES_CONVERSION;
	m_str = ::SysAllocStringLen(A2COLE(sz), nSize);
}

CComBSTR& CComBSTR::operator=(LPCSTR pSrc)
{
	USES_CONVERSION;
	::SysFreeString(m_str);
	m_str = ::SysAllocString(A2COLE(pSrc));
	return *this;
}
#endif

HRESULT CComBSTR::ReadFromStream(IStream* pStream)
{
	_ASSERTE(pStream != NULL);
	_ASSERTE(m_str == NULL); // should be empty
	ULONG cb;
	ULONG cbStrLen;
	HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), &cb);
	if (FAILED(hr))
		return hr;
	if (cbStrLen != 0)
	{
		//subtract size for terminating NULL which we wrote out
		//since SysAllocStringByteLen overallocates for the NULL
		m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
		if (m_str == NULL)
			hr = E_OUTOFMEMORY;
		else
			hr = pStream->Read((void*) m_str, cbStrLen, &cb);
	}
	return hr;
}

HRESULT CComBSTR::WriteToStream(IStream* pStream)
{
	_ASSERTE(pStream != NULL);
	ULONG cb;
	ULONG cbStrLen = m_str ? SysStringByteLen(m_str)+sizeof(OLECHAR) : 0;
	HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
	if (FAILED(hr))
		return hr;
	return cbStrLen ? pStream->Write((void*) m_str, cbStrLen, &cb) : S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CComVariant

CComVariant& CComVariant::operator=(BSTR bstrSrc)
{
	InternalClear();
	vt = VT_BSTR;
	bstrVal = ::SysAllocString(bstrSrc);
	if (bstrVal == NULL && bstrSrc != NULL)
	{
		vt = VT_ERROR;
		scode = E_OUTOFMEMORY;
	}
	return *this;
}

CComVariant& CComVariant::operator=(LPCOLESTR lpszSrc)
{
	InternalClear();
	vt = VT_BSTR;
	bstrVal = ::SysAllocString(lpszSrc);

	if (bstrVal == NULL && lpszSrc != NULL)
	{
		vt = VT_ERROR;
		scode = E_OUTOFMEMORY;
	}
	return *this;
}

#ifndef OLE2ANSI
CComVariant& CComVariant::operator=(LPCSTR lpszSrc)
{
	USES_CONVERSION;
	InternalClear();
	vt = VT_BSTR;
	bstrVal = ::SysAllocString(A2COLE(lpszSrc));

	if (bstrVal == NULL && lpszSrc != NULL)
	{
		vt = VT_ERROR;
		scode = E_OUTOFMEMORY;
	}
	return *this;
}
#endif

#if _MSC_VER>1020
CComVariant& CComVariant::operator=(bool bSrc)
{
	if (vt != VT_BOOL)
	{
		InternalClear();
		vt = VT_BOOL;
	}
#pragma warning(disable: 4310) // cast truncates constant value
	boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return *this;
}
#endif

CComVariant& CComVariant::operator=(int nSrc)
{
	if (vt != VT_I4)
	{
		InternalClear();
		vt = VT_I4;
	}
	lVal = nSrc;

	return *this;
}

CComVariant& CComVariant::operator=(BYTE nSrc)
{
	if (vt != VT_UI1)
	{
		InternalClear();
		vt = VT_UI1;
	}
	bVal = nSrc;
	return *this;
}

CComVariant& CComVariant::operator=(short nSrc)
{
	if (vt != VT_I2)
	{
		InternalClear();
		vt = VT_I2;
	}
	iVal = nSrc;
	return *this;
}

CComVariant& CComVariant::operator=(long nSrc)
{
	if (vt != VT_I4)
	{
		InternalClear();
		vt = VT_I4;
	}
	lVal = nSrc;
	return *this;
}

CComVariant& CComVariant::operator=(float fltSrc)
{
	if (vt != VT_R4)
	{
		InternalClear();
		vt = VT_R4;
	}
	fltVal = fltSrc;
	return *this;
}

CComVariant& CComVariant::operator=(double dblSrc)
{
	if (vt != VT_R8)
	{
		InternalClear();
		vt = VT_R8;
	}
	dblVal = dblSrc;
	return *this;
}

CComVariant& CComVariant::operator=(CY cySrc)
{
	if (vt != VT_CY)
	{
		InternalClear();
		vt = VT_CY;
	}
	cyVal.Hi = cySrc.Hi;
	cyVal.Lo = cySrc.Lo;
	return *this;
}

CComVariant& CComVariant::operator=(IDispatch* pSrc)
{
	InternalClear();
	vt = VT_DISPATCH;
	pdispVal = pSrc;
	// Need to AddRef as VariantClear will Release
	if (pdispVal != NULL)
		pdispVal->AddRef();
	return *this;
}

CComVariant& CComVariant::operator=(IUnknown* pSrc)
{
	InternalClear();
	vt = VT_UNKNOWN;
	punkVal = pSrc;

	// Need to AddRef as VariantClear will Release
	if (punkVal != NULL)
		punkVal->AddRef();
	return *this;
}

#if _MSC_VER>1020
bool CComVariant::operator==(const VARIANT& varSrc)
{
	if (this == &varSrc)
		return true;

	// Variants not equal if types don't match
	if (vt != varSrc.vt)
		return false;

	// Check type specific values
	switch (vt)
	{
		case VT_EMPTY:
		case VT_NULL:
			return true;

		case VT_BOOL:
			return boolVal == varSrc.boolVal;

		case VT_UI1:
			return bVal == varSrc.bVal;

		case VT_I2:
			return iVal == varSrc.iVal;

		case VT_I4:
			return lVal == varSrc.lVal;

		case VT_R4:
			return fltVal == varSrc.fltVal;

		case VT_R8:
			return dblVal == varSrc.dblVal;

		case VT_BSTR:
			return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
					(::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

		case VT_ERROR:
			return scode == varSrc.scode;

		case VT_DISPATCH:
			return pdispVal == varSrc.pdispVal;

		case VT_UNKNOWN:
			return punkVal == varSrc.punkVal;

		default:
			_ASSERTE(false);
			// fall through
	}

	return false;
}
#else
BOOL CComVariant::operator==(const VARIANT& varSrc)
{
	if (this == &varSrc)
		return TRUE;

	// Variants not equal if types don't match
	if (vt != varSrc.vt)
		return FALSE;

	// Check type specific values
	switch (vt)
	{
		case VT_EMPTY:
		case VT_NULL:
			return TRUE;

		case VT_BOOL:
			return boolVal == varSrc.boolVal;

		case VT_UI1:
			return bVal == varSrc.bVal;

		case VT_I2:
			return iVal == varSrc.iVal;

		case VT_I4:
			return lVal == varSrc.lVal;

		case VT_R4:
			return fltVal == varSrc.fltVal;

		case VT_R8:
			return dblVal == varSrc.dblVal;

		case VT_BSTR:
			return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
					(::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

		case VT_ERROR:
			return scode == varSrc.scode;

		case VT_DISPATCH:
			return pdispVal == varSrc.pdispVal;

		case VT_UNKNOWN:
			return punkVal == varSrc.punkVal;

		default:
			_ASSERTE(FALSE);
			// fall through
	}

	return FALSE;
}
#endif

HRESULT CComVariant::Attach(VARIANT* pSrc)
{
	// Clear out the variant
	HRESULT hr = Clear();
	if (!FAILED(hr))
	{
		// Copy the contents and give control to CComVariant
		memcpy(this, pSrc, sizeof(VARIANT));
		VariantInit(pSrc);
		hr = S_OK;
	}
	return hr;
}

HRESULT CComVariant::Detach(VARIANT* pDest)
{
	// Clear out the variant
	HRESULT hr = ::VariantClear(pDest);
	if (!FAILED(hr))
	{
		// Copy the contents and remove control from CComVariant
		memcpy(pDest, this, sizeof(VARIANT));
		vt = VT_EMPTY;
		hr = S_OK;
	}
	return hr;
}

HRESULT CComVariant::ChangeType(VARTYPE vtNew, const VARIANT* pSrc)
{
	VARIANT* pVar = const_cast<VARIANT*>(pSrc);
	// Convert in place if pSrc is NULL
	if (pVar == NULL)
		pVar = this;
	// Do nothing if doing in place convert and vts not different
	return ::VariantChangeType(this, pVar, 0, vtNew);
}

HRESULT CComVariant::InternalClear()
{
	HRESULT hr = Clear();
	_ASSERTE(SUCCEEDED(hr));
	if (FAILED(hr))
	{
		vt = VT_ERROR;
		scode = hr;
	}
	return hr;
}

void CComVariant::InternalCopy(const VARIANT* pSrc)
{
	HRESULT hr = Copy(pSrc);
	if (FAILED(hr))
	{
		vt = VT_ERROR;
		scode = hr;
	}
}


HRESULT CComVariant::WriteToStream(IStream* pStream)
{
	HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);
	if (FAILED(hr))
		return hr;

	int cbWrite = 0;
	switch (vt)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			CComPtr<IPersistStream> spStream;
			if (punkVal != NULL)
			{
				hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
				if (FAILED(hr))
					return hr;
			}
			if (spStream != NULL)
				return OleSaveToStream(spStream, pStream);
			else
				return WriteClassStm(pStream, CLSID_NULL);
		}
	case VT_UI1:
	case VT_I1:
		cbWrite = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbWrite = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbWrite = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbWrite = sizeof(double);
		break;
	default:
		break;
	}
	if (cbWrite != 0)
		return pStream->Write((void*) &bVal, cbWrite, NULL);

	CComBSTR bstrWrite;
	CComVariant varBSTR;
	if (vt != VT_BSTR)
	{
		hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);
		if (FAILED(hr))
			return hr;
		bstrWrite = varBSTR.bstrVal;
	}
	else
		bstrWrite = bstrVal;

	return bstrWrite.WriteToStream(pStream);
}

HRESULT CComVariant::ReadFromStream(IStream* pStream)
{
	_ASSERTE(pStream != NULL);
	HRESULT hr;
	hr = VariantClear(this);
	if (FAILED(hr))
		return hr;
	VARTYPE vtRead;
	hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
	if (FAILED(hr))
		return hr;

	vt = vtRead;
	int cbRead = 0;
	switch (vtRead)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			punkVal = NULL;
			hr = OleLoadFromStream(pStream, 
				(vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch, 
				(void**)&punkVal);
			if (hr == REGDB_E_CLASSNOTREG)
				hr = S_OK;
			return S_OK;
		}
	case VT_UI1:
	case VT_I1:
		cbRead = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbRead = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbRead = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbRead = sizeof(double);
		break;
	default:
		break;
	}
	if (cbRead != 0)
		return pStream->Read((void*) &bVal, cbRead, NULL);
	CComBSTR bstrRead;

	hr = bstrRead.ReadFromStream(pStream);
	if (FAILED(hr))
		return hr;
	vt = VT_BSTR;
	bstrVal = bstrRead.Detach();
	if (vtRead != VT_BSTR)
		hr = ChangeType(vtRead);
	return hr;
}

#ifdef __ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
// CComTypeInfoHolder

void CComTypeInfoHolder::AddRef()
{
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	m_dwRef++;
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

void CComTypeInfoHolder::Release()
{
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	if (--m_dwRef == 0)
	{
		if (m_pInfo != NULL)
			m_pInfo->Release();
		m_pInfo = NULL;
	}
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

HRESULT CComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
	//If this assert occurs then most likely didn't initialize properly
	_ASSERTE(m_plibid != NULL && m_pguid != NULL);
	_ASSERTE(ppInfo != NULL);
	*ppInfo = NULL;

	HRESULT hRes = E_FAIL;
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib;
		hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
		if (SUCCEEDED(hRes))
		{
			ITypeInfo* pTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &pTypeInfo);
			if (SUCCEEDED(hRes))
				m_pInfo = pTypeInfo;
			pTypeLib->Release();
		}
	}
	*ppInfo = m_pInfo;
	if (m_pInfo != NULL)
	{
		m_pInfo->AddRef();
		hRes = S_OK;
	}
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
	return hRes;
}

HRESULT CComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/, LCID lcid,
	ITypeInfo** pptinfo)
{
	HRESULT hRes = E_POINTER;
	if (pptinfo != NULL)
		hRes = GetTI(lcid, pptinfo);
	return hRes;
}

HRESULT CComTypeInfoHolder::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
	UINT cNames, LCID lcid, DISPID* rgdispid)
{
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		hRes = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
		pInfo->Release();
	}
	return hRes;
}

HRESULT CComTypeInfoHolder::Invoke(IDispatch* p, DISPID dispidMember, REFIID /*riid*/,
	LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
	EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
	SetErrorInfo(0, NULL);
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		hRes = pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		pInfo->Release();
	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// QI implementation

#ifdef _ATL_DEBUG_QI
HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr)
{
	USES_CONVERSION;
	CRegKey key;
	TCHAR szName[100];
	DWORD dwType,dw = sizeof(szName);

	LPOLESTR pszGUID = NULL;
	StringFromCLSID(iid, &pszGUID);
	OutputDebugString(pszClassName);
	OutputDebugString(_T(" - "));

	// Attempt to find it in the interfaces section
	key.Open(HKEY_CLASSES_ROOT, _T("Interface"));
	if (key.Open(key, OLE2T(pszGUID)) == S_OK)
	{
		*szName = 0;
		RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
		OutputDebugString(szName);
		goto cleanup;
	}
	// Attempt to find it in the clsid section
	key.Open(HKEY_CLASSES_ROOT, _T("CLSID"));
	if (key.Open(key, OLE2T(pszGUID)) == S_OK)
	{
		*szName = 0;
		RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
		OutputDebugString(_T("(CLSID\?\?\?) "));
		OutputDebugString(szName);
		goto cleanup;
	}
	OutputDebugString(OLE2T(pszGUID));
cleanup:
	if (hr != S_OK)
		OutputDebugString(_T(" - failed"));
	OutputDebugString(_T("\n"));
	CoTaskMemFree(pszGUID);
	return hr;
}
#endif

HRESULT WINAPI CComObjectRootBase::_Break(void* /* pv */, REFIID iid, void** /* ppvObject */, DWORD_PTR /* dw */)
{
	iid;
	_ATLDUMPIID(iid, _T("Break due to QI for interface "), S_OK);
#ifdef _DEBUG
	DebugBreak();
#endif
	return S_FALSE;
}

HRESULT WINAPI CComObjectRootBase::_NoInterface(void* /* pv */, REFIID /* iid */, void** /* ppvObject */, DWORD_PTR /* dw */)
{
	return E_NOINTERFACE;
}

HRESULT WINAPI CComObjectRootBase::_Creator(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
{
	_ATL_CREATORDATA* pcd = (_ATL_CREATORDATA*)dw;
	return pcd->pFunc(pv, iid, ppvObject);
}

HRESULT WINAPI CComObjectRootBase::_Delegate(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
{
	HRESULT hRes = E_NOINTERFACE;
	IUnknown* p = *(IUnknown**)((DWORD_PTR)pv + dw);
	if (p != NULL)
		hRes = p->QueryInterface(iid, ppvObject);
	return hRes;
}

HRESULT WINAPI CComObjectRootBase::_Chain(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
{
	_ATL_CHAINDATA* pcd = (_ATL_CHAINDATA*)dw;
	void* p = (void*)((DWORD_PTR)pv + pcd->dwOffset);
	return InternalQueryInterface(p, pcd->pFunc(), iid, ppvObject);
}

HRESULT WINAPI CComObjectRootBase::_Cache(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
{
	HRESULT hRes = E_NOINTERFACE;
	_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)dw;
	IUnknown** pp = (IUnknown**)((DWORD_PTR)pv + pcd->dwOffsetVar);
	if (*pp == NULL)
		hRes = pcd->pFunc(pv, IID_IUnknown, (void**)pp);
	if (*pp != NULL)
		hRes = (*pp)->QueryInterface(iid, ppvObject);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// CComClassFactory

STDMETHODIMP CComClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
	REFIID riid, void** ppvObj)
{
	_ASSERTE(m_pfnCreateInstance != NULL);
	HRESULT hRes = E_POINTER;
	if (ppvObj != NULL)
	{
		*ppvObj = NULL;
		// can't ask for anything other than IUnknown when aggregating
		_ASSERTE((pUnkOuter == NULL) || InlineIsEqualUnknown(riid));
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			hRes = CLASS_E_NOAGGREGATION;
		else
			hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
	}
	return hRes;
}

STDMETHODIMP CComClassFactory::LockServer(BOOL fLock)
{
	if (fLock)
		_Module.Lock();
	else
		_Module.Unlock();
	return S_OK;
}

STDMETHODIMP CComClassFactory2Base::LockServer(BOOL fLock)
{
	if (fLock)
		_Module.Lock();
	else
		_Module.Unlock();
	return S_OK;
}

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

DWORD CComDynamicUnkArray::Add(IUnknown* pUnk)
{
   ULONG iIndex;
	IUnknown** pp = NULL;
	if (m_nSize == 0) // no connections
	{
		m_pUnk = pUnk;
		m_nSize = 1;
		return 1;
	}
	else if (m_nSize == 1)
	{
		//create array
		pp = (IUnknown**)malloc(sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
		if (pp == NULL)
			return 0;
		memset(pp, 0, sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
		*pp = m_pUnk;
		m_ppUnk = pp;
		m_nSize = _DEFAULT_VECTORLENGTH;
	}
	for (pp = begin();pp<end();pp++)
	{
		if (*pp == NULL)
		{
			*pp = pUnk;
            iIndex = ULONG((pp-begin()));
			return iIndex+1;
		}
	}
	int nAlloc = m_nSize*2;
	pp = (IUnknown**)realloc(m_ppUnk, sizeof(IUnknown*)*nAlloc);
	if (pp == NULL)
		return 0;
	m_ppUnk = pp;
	memset(&m_ppUnk[m_nSize], 0, sizeof(IUnknown*)*m_nSize);
	m_ppUnk[m_nSize] = pUnk;
   iIndex = m_nSize;
	m_nSize = nAlloc;
	return iIndex+1;
}

BOOL CComDynamicUnkArray::Remove(DWORD dwCookie)
{
   ULONG iIndex;
	if (dwCookie == NULL)
		return FALSE;
	if (m_nSize == 0)
		return FALSE;
   iIndex = dwCookie-1;
   if (iIndex >= (ULONG)m_nSize)
   {
      return FALSE;
   }
	if (m_nSize == 1)
	{
		m_nSize = 0;
		return TRUE;
	}
   begin()[iIndex] = NULL;
   return TRUE;
}

#endif //!_ATL_NO_CONNECTION_POINTS

#endif //__ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
// Object Registry Support

static HRESULT WINAPI AtlRegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
	CRegKey keyProgID;
	LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID);
	if (lRes == ERROR_SUCCESS)
	{
		keyProgID.SetValue(lpszUserDesc);
		keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
		return S_OK;
	}
	return HRESULT_FROM_WIN32(lRes);
}

void CComModule::AddCreateWndData(_AtlCreateWndData* pData, void* pObject)
{
	pData->m_pThis = pObject;
	pData->m_dwThreadID = ::GetCurrentThreadId();
	::EnterCriticalSection(&m_csWindowCreate);
	pData->m_pNext = m_pCreateWndList;
	m_pCreateWndList = pData;
	::LeaveCriticalSection(&m_csWindowCreate);
}

void* CComModule::ExtractCreateWndData()
{
	::EnterCriticalSection(&m_csWindowCreate);
	_AtlCreateWndData* pEntry = m_pCreateWndList;
	if(pEntry == NULL)
	{
		::LeaveCriticalSection(&m_csWindowCreate);
		return NULL;
	}

	DWORD dwThreadID = ::GetCurrentThreadId();
	_AtlCreateWndData* pPrev = NULL;
	while(pEntry != NULL)
	{
		if(pEntry->m_dwThreadID == dwThreadID)
		{
			if(pPrev == NULL)
				m_pCreateWndList = pEntry->m_pNext;
			else
				pPrev->m_pNext = pEntry->m_pNext;
			::LeaveCriticalSection(&m_csWindowCreate);
			return pEntry->m_pThis;
		}
		pPrev = pEntry;
		pEntry = pEntry->m_pNext;
	}

	::LeaveCriticalSection(&m_csWindowCreate);
	return NULL;
}

#ifdef _ATL_STATIC_REGISTRY
// Statically linking to Registry Ponent
HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	USES_CONVERSION;
	CRegObject ro;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
	LPOLESTR pszModule = T2OLE(szModule);
	ro.AddReplacement(OLESTR("Module"), pszModule);
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			_ASSERTE(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	LPCOLESTR szType = OLESTR("REGISTRY");
	return (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
			ro.ResourceUnregister(pszModule, nResID, szType);
}

HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	USES_CONVERSION;
	CRegObject ro;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
	LPOLESTR pszModule = T2OLE(szModule);
	ro.AddReplacement(OLESTR("Module"), pszModule);
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			_ASSERTE(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	LPCOLESTR szType = OLESTR("REGISTRY");
	LPCOLESTR pszRes = T2COLE(lpszRes);
	return (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :
			ro.ResourceUnregisterSz(pszModule, pszRes, szType);
}
#endif // _ATL_STATIC_REGISTRY

HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister)
{
	if (bRegister)
	{
		return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID,
			dwFlags);
	}
	else
		return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags)
{
	static const TCHAR szProgID[] = _T("ProgID");
	static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
	static const TCHAR szLS32[] = _T("LocalServer32");
	static const TCHAR szIPS32[] = _T("InprocServer32");
	static const TCHAR szThreadingModel[] = _T("ThreadingModel");
	static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
	static const TCHAR szApartment[] = _T("Apartment");
	static const TCHAR szBoth[] = _T("both");
	USES_CONVERSION;
	HRESULT hRes = S_OK;
	TCHAR szDesc[256];
	LoadString(m_hInst, nDescID, szDesc, 256);
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(m_hInst, szModule, _MAX_PATH);

	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);

	hRes = AtlRegisterProgID(lpsz, lpszProgID, szDesc);
	if (hRes == S_OK)
		hRes = AtlRegisterProgID(lpsz, lpszVerIndProgID, szDesc);
	LONG lRes = ERROR_SUCCESS;
	if (hRes == S_OK)
	{
		CRegKey key;
		LONG lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"));
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpsz);
			if (lRes == ERROR_SUCCESS)
			{
				key.SetValue(szDesc);
				key.SetKeyValue(szProgID, lpszProgID);
				key.SetKeyValue(szVIProgID, lpszVerIndProgID);

				if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
					key.SetKeyValue(szLS32, szModule);
				else
				{
					key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule);
					LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
						(dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
					if (lpszModel != NULL)
						key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
				}
			}
		}
	}
	CoTaskMemFree(lpOleStr);
	if (lRes != ERROR_SUCCESS)
		hRes = HRESULT_FROM_WIN32(lRes);
	return hRes;
}

HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID)
{
	USES_CONVERSION;
	CRegKey key;

	key.Attach(HKEY_CLASSES_ROOT);
	if (lpszProgID != NULL && lstrcmpi(lpszProgID, _T("")))
		key.RecurseDeleteKey(lpszProgID);
	if (lpszVerIndProgID != NULL && lstrcmpi(lpszVerIndProgID, _T("")))
		key.RecurseDeleteKey(lpszVerIndProgID);
	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);
	if (key.Open(key, _T("CLSID")) == ERROR_SUCCESS)
		key.RecurseDeleteKey(lpsz);
	CoTaskMemFree(lpOleStr);
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRegKey

LONG CRegKey::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	_ASSERTE(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	_ASSERTE(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		_ASSERTE(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	DWORD dwType = NULL;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	return lRes;
}

LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
	_ASSERTE(pdwCount != NULL);
	DWORD dwType = NULL;
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)szValue, pdwCount);
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
			 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
	return lRes;
}

LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(m_hKey, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
	_ASSERTE(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		(BYTE * const)&dwValue, sizeof(DWORD));
}

HRESULT CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	_ASSERTE(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
//specified key has subkeys
LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
	CRegKey key;
	LONG lRes = key.Open(m_hKey, lpszKey);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}

#ifdef __ATLCOM_H__
#ifndef _ATL_NO_SECURITY

CSecurityDescriptor::CSecurityDescriptor()
{
	m_pSD = NULL;
	m_pOwner = NULL;
	m_pGroup = NULL;
	m_pDACL = NULL;
	m_pSACL= NULL;
}

CSecurityDescriptor::~CSecurityDescriptor()
{
	if (m_pSD)
		delete m_pSD;
	if (m_pOwner)
		free(m_pOwner);
	if (m_pGroup)
		free(m_pGroup);
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSACL)
		free(m_pSACL);
}

HRESULT CSecurityDescriptor::Initialize()
{
	if (m_pSD)
	{
		delete m_pSD;
		m_pSD = NULL;
	}
	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}
	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}
	if (m_pDACL)
	{
		free(m_pDACL);
		m_pDACL = NULL;
	}
	if (m_pSACL)
	{
		free(m_pSACL);
		m_pSACL = NULL;
	}

	ATLTRY(m_pSD = new SECURITY_DESCRIPTOR);
	if (!m_pSD)
		return E_OUTOFMEMORY;
	if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		delete m_pSD;
		m_pSD = NULL;
		_ASSERTE(FALSE);
		return hr;
	}
	// Set the DACL to allow EVERYONE
	SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE);
	return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
	PSID pUserSid;
	PSID pGroupSid;
	HRESULT hr;

	Initialize();
	hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (FAILED(hr))
		return hr;
	hr = SetOwner(pUserSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	hr = SetGroup(pGroupSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
	PSID pUserSid;
	PSID pGroupSid;
	HRESULT hr;

	Initialize();
	hr = GetThreadSids(&pUserSid, &pGroupSid);
	if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
		hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (FAILED(hr))
		return hr;
	hr = SetOwner(pUserSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	hr = SetGroup(pGroupSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	return S_OK;
}

HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
	_ASSERTE(m_pSD);

	// Mark the SD as having no owner
	if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}

	// If they asked for no owner don't do the copy
	if (pOwnerSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pOwnerSid);

	m_pOwner = (PSID) malloc(dwSize);
	if (!m_pOwner)
	{
		// Insufficient memory to allocate Sid
		_ASSERTE(FALSE);
		return E_OUTOFMEMORY;
	}
	if (!CopySid(dwSize, m_pOwner, pOwnerSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	_ASSERTE(IsValidSid(m_pOwner));

	if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
	_ASSERTE(m_pSD);

	// Mark the SD as having no Group
	if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}

	// If they asked for no Group don't do the copy
	if (pGroupSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pGroupSid);

	m_pGroup = (PSID) malloc(dwSize);
	if (!m_pGroup)
	{
		// Insufficient memory to allocate Sid
		_ASSERTE(FALSE);
		return E_OUTOFMEMORY;
	}
	if (!CopySid(dwSize, m_pGroup, pGroupSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	_ASSERTE(IsValidSid(m_pGroup));

	if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
	HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
	if (!bRes)
	{
		// Couldn't open process token
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	return hr;
}

HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
	if (!bRes)
	{
		// Couldn't open thread token
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	return hr;
}


HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
	DWORD dwSize;
	HRESULT hr;
	PTOKEN_USER ptkUser = NULL;
	PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;

	if (ppUserSid)
	{
		// Get length required for TokenUser by specifying buffer length of 0
		GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			_ASSERTE(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkUser = (TOKEN_USER*) malloc(dwSize);
		if (!ptkUser)
		{
			// Insufficient memory to allocate TOKEN_USER
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkUser->User.Sid);

		PSID pSid = (PSID) malloc(dwSize);
		if (!pSid)
		{
			// Insufficient memory to allocate Sid
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		_ASSERTE(IsValidSid(pSid));
		*ppUserSid = pSid;
		free(ptkUser);
	}
	if (ppGroupSid)
	{
		// Get length required for TokenPrimaryGroup by specifying buffer length of 0
		GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			_ASSERTE(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
		if (!ptkGroup)
		{
			// Insufficient memory to allocate TOKEN_USER
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

		PSID pSid = (PSID) malloc(dwSize);
		if (!pSid)
		{
			// Insufficient memory to allocate Sid
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		_ASSERTE(IsValidSid(pSid));

		*ppGroupSid = pSid;
		free(ptkGroup);
	}

	return S_OK;

failed:
	if (ptkUser)
		free(ptkUser);
	if (ptkGroup)
		free (ptkGroup);
	return hr;
}


HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
	HANDLE tkHandle;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
	{
		TOKEN_USER *tkUser;
		DWORD tkSize;
		DWORD sidLength;

		// Call to get size information for alloc
		GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
		tkUser = (TOKEN_USER *) malloc(tkSize);

		// Now make the real call
		if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
		{
			sidLength = GetLengthSid(tkUser->User.Sid);
			*ppSid = (PSID) malloc(sidLength);

			memcpy(*ppSid, tkUser->User.Sid, sidLength);
			CloseHandle(tkHandle);

			free(tkUser);
			return S_OK;
		}
		else
		{
			free(tkUser);
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}
	return HRESULT_FROM_WIN32(GetLastError());
}


HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
	HRESULT hr;
	LPTSTR pszRefDomain = NULL;
	DWORD dwDomainSize = 0;
	DWORD dwSidSize = 0;
	SID_NAME_USE snu;

	// Call to get size info for alloc
	LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	ATLTRY(pszRefDomain = new TCHAR[dwDomainSize]);
	if (pszRefDomain == NULL)
		return E_OUTOFMEMORY;

	*ppSid = (PSID) malloc(dwSidSize);
	if (*ppSid != NULL)
	{
		if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
		{
			free(*ppSid);
			*ppSid = NULL;
			delete[] pszRefDomain;
			return HRESULT_FROM_WIN32(GetLastError());
		}
		delete[] pszRefDomain;
		return S_OK;
	}
	delete[] pszRefDomain;
	return E_OUTOFMEMORY;
}


HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
	PACL    pDACL = NULL;
	PACL    pSACL = NULL;
	BOOL    bDACLPresent, bSACLPresent;
	BOOL    bDefaulted;
	PACL    m_pDACL = NULL;
	ACCESS_ALLOWED_ACE* pACE;
	HRESULT hr;
	PSID    pUserSid;
	PSID    pGroupSid;

	hr = Initialize();
	if(FAILED(hr))
		return hr;

	// get the existing DACL.
	if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
		goto failed;

	if (bDACLPresent)
	{
		if (pDACL)
		{
			// allocate new DACL.
			m_pDACL = (PACL) malloc(pDACL->AclSize);
			if (!m_pDACL)
				goto failed;

			// initialize the DACL
			if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pDACL->AceCount; i++)
			{
				if (!GetAce(pDACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pDACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pDACL))
				goto failed;
		}

		// set the DACL
		if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
			goto failed;
	}

	// get the existing SACL.
	if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
		goto failed;

	if (bSACLPresent)
	{
		if (pSACL)
		{
			// allocate new SACL.
			m_pSACL = (PACL) malloc(pSACL->AclSize);
			if (!m_pSACL)
				goto failed;

			// initialize the SACL
			if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pSACL->AceCount; i++)
			{
				if (!GetAce(pSACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pSACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pSACL))
				goto failed;
		}

		// set the SACL
		if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
			goto failed;
	}

	if (!GetSecurityDescriptorOwner(m_pSD, &pUserSid, &bDefaulted))
		goto failed;

	if (FAILED(SetOwner(pUserSid, bDefaulted)))
		goto failed;

	if (!GetSecurityDescriptorGroup(m_pSD, &pGroupSid, &bDefaulted))
		goto failed;

	if (FAILED(SetGroup(pGroupSid, bDefaulted)))
		goto failed;

	if (!IsValidSecurityDescriptor(m_pSD))
		goto failed;

	return hr;

failed:
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSD)
		free(m_pSD);
	return E_UNEXPECTED;
}

HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
	HRESULT hr;
	DWORD dwSize = 0;
	PSECURITY_DESCRIPTOR pSD = NULL;

	GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);

	if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		free(pSD);
		return hr;
	}

	hr = Attach(pSD);
	free(pSD);
	return hr;
}


HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	LPVOID pAce;
	ACE_HEADER *aceHeader;

	if (pSrc == NULL)
		return S_OK;

	if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		return HRESULT_FROM_WIN32(GetLastError());

	// Copy all of the ACEs to the new ACL
	for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pSrc, i, &pAce))
			return HRESULT_FROM_WIN32(GetLastError());

		aceHeader = (ACE_HEADER *) pAce;

		if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
			return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PSID principalSID;
	PACL oldACL, newACL;

	oldACL = *ppAcl;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

	ATLTRY(newACL = (PACL) new BYTE[aclSize]);

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
	{
		free(principalSID);
		return returnValue;
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PSID principalSID;
	PACL oldACL, newACL;

	oldACL = *ppAcl;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

	ATLTRY(newACL = (PACL) new BYTE[aclSize]);

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
	{
		free(principalSID);
		return returnValue;
	}

	if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	ULONG i;
	LPVOID ace;
	ACCESS_ALLOWED_ACE *accessAllowedAce;
	ACCESS_DENIED_ACE *accessDeniedAce;
	SYSTEM_AUDIT_ACE *systemAuditAce;
	PSID principalSID;
	DWORD returnValue;
	ACE_HEADER *aceHeader;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	for (i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pAcl, i, &ace))
		{
			free(principalSID);
			return HRESULT_FROM_WIN32(GetLastError());
		}

		aceHeader = (ACE_HEADER *) ace;

		if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
		{
			accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
		{
			accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
		{
			systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		}
	}
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
	HRESULT hr;
	TOKEN_PRIVILEGES tpPrevious;
	TOKEN_PRIVILEGES tp;
	DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
	LUID luid;

	// if no token specified open process token
	if (hToken == 0)
	{
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			return hr;
		}
	}

	if (!LookupPrivilegeValue(NULL, privilege, &luid ))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = 0;

	if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	tpPrevious.PrivilegeCount = 1;
	tpPrevious.Privileges[0].Luid = luid;

	if (bEnable)
		tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
	else
		tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

	if (!AdjustTokenPrivileges(hToken, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}
	return S_OK;
}

#endif //_ATL_NO_SECURITY
#endif //__ATLCOM_H__

#ifdef _DEBUG

void _cdecl AtlTrace(LPCTSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = _vstprintf(szBuffer, lpszFormat, args);
	_ASSERTE(nBuf < sizeof(szBuffer));

	OutputDebugString(szBuffer);
	va_end(args);
}
#endif

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

///////////////////////////////////////////////////////////////////////////////
//All Global stuff goes below this line
///////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Minimize CRT
// Specify DllMain as EntryPoint
// Turn off exception handling
// Define _ATL_MIN_CRT

#ifdef _ATL_MIN_CRT
/////////////////////////////////////////////////////////////////////////////
// Startup Code

#if defined(_WINDLL) || defined(_USRDLL)

// Declare DllMain
extern "C" BOOL WINAPI DllMain(HANDLE hDllHandle, DWORD dwReason, LPVOID lpReserved);

extern "C" BOOL WINAPI _DllMainCRTStartup(HANDLE hDllHandle, DWORD dwReason, LPVOID lpReserved)
{
	return DllMain(hDllHandle, dwReason, lpReserved);
}

#else

// wWinMain is not defined in winbase.h.
extern "C" int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd);

#define SPACECHAR   _T(' ')
#define DQUOTECHAR  _T('\"')


#ifdef _UNICODE
extern "C" void wWinMainCRTStartup()
#else // _UNICODE
extern "C" void WinMainCRTStartup()
#endif // _UNICODE
{
	LPTSTR lpszCommandLine = ::GetCommandLine();
	if(lpszCommandLine == NULL)
		::ExitProcess((UINT)-1);

	// Skip past program name (first token in command line).
	// Check for and handle quoted program name.
	if(*lpszCommandLine == DQUOTECHAR)
	{
		// Scan, and skip over, subsequent characters until
		// another double-quote or a null is encountered.
		do
		{
			lpszCommandLine = ::CharNext(lpszCommandLine);
		}
		while((*lpszCommandLine != DQUOTECHAR) && (*lpszCommandLine != _T('\0')));

		// If we stopped on a double-quote (usual case), skip over it.
		if(*lpszCommandLine == DQUOTECHAR)
			lpszCommandLine = ::CharNext(lpszCommandLine);
	}
	else
	{
		while(*lpszCommandLine > SPACECHAR)
			lpszCommandLine = ::CharNext(lpszCommandLine);
	}

	// Skip past any white space preceeding the second token.
	while(*lpszCommandLine && (*lpszCommandLine <= SPACECHAR))
		lpszCommandLine = ::CharNext(lpszCommandLine);

	STARTUPINFO StartupInfo;
	StartupInfo.dwFlags = 0;
	::GetStartupInfo(&StartupInfo);

	int nRet = _tWinMain(::GetModuleHandle(NULL), NULL, lpszCommandLine,
		(StartupInfo.dwFlags & STARTF_USESHOWWINDOW) ?
		StartupInfo.wShowWindow : SW_SHOWDEFAULT);

	::ExitProcess((UINT)nRet);
}

#endif // defined(_WINDLL) | defined(_USRDLL)

/////////////////////////////////////////////////////////////////////////////
// Heap Allocation

#ifndef _DEBUG

#ifndef _MERGE_PROXYSTUB
//rpcproxy.h does the same thing as this
int __cdecl _purecall()
{
#ifdef _DEBUG
	DebugBreak();
#endif
	return 0;
}
#endif

#if !defined(_M_ALPHA) && !defined(_M_PPC)
//RISC always initializes floating point and always defines _fltused
extern "C" const int _fltused = 0;
#endif

void* __cdecl malloc(size_t n)
{
	if (_Module.m_hHeap == NULL)
	{
		_Module.m_hHeap = HeapCreate(0, 0, 0);
		if (_Module.m_hHeap == NULL)
			return NULL;
	}
	_ASSERTE(_Module.m_hHeap != NULL);

#ifdef _MALLOC_ZEROINIT
	return HeapAlloc(_Module.m_hHeap, HEAP_ZERO_MEMORY, n);
#else
	return HeapAlloc(_Module.m_hHeap, 0, n);
#endif
}

void* __cdecl calloc(size_t n, size_t s)
{
	return malloc(n * s);
}

void* __cdecl realloc(void* p, size_t n)
{
	_ASSERTE(_Module.m_hHeap != NULL);
#ifdef _MALLOC_ZEROINIT
	return (p == NULL) ? malloc(n) : HeapReAlloc(_Module.m_hHeap, HEAP_ZERO_MEMORY, p, n);
#else
	return (p == NULL) ? malloc(n) : HeapReAlloc(_Module.m_hHeap, 0, p, n);
#endif
}

void __cdecl free(void* p)
{
	_ASSERTE(_Module.m_hHeap != NULL);
	HeapFree(_Module.m_hHeap, 0, p);
}

void* __cdecl operator new(size_t n)
{
	return malloc(n);
}

void __cdecl operator delete(void* p)
{
	free(p);
}

#endif  //_DEBUG

#endif //_ATL_MIN_CRT

#ifndef _ATL_DLL

#ifndef ATL_NO_NAMESPACE
#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
	_ASSERTE(lpszPathName != NULL);

	// always capture the complete file name including extension (if present)
	LPCOLESTR lpszTemp = lpszPathName;
	for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
	{
		LPCOLESTR lp = CharNextO(lpsz);
		// remember last directory/drive separator
		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
			lpszTemp = lp;
		lpsz = lp;
	}

	return lpszTemp-lpszPathName;
}

/////////////////////////////////////////////////////////////////////////////
// QI support

ATLAPI AtlInternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
	_ASSERTE(pThis != NULL);
	// First entry in the com map should be a simple map entry
	_ASSERTE(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
	if (ppvObject == NULL)
		return E_POINTER;
	*ppvObject = NULL;
	if (InlineIsEqualUnknown(iid)) // use first interface
	{
			IUnknown* pUnk = (IUnknown*)((int)pThis+pEntries->dw);
			pUnk->AddRef();
			*ppvObject = pUnk;
			return S_OK;
	}
	while (pEntries->pFunc != NULL)
	{
		BOOL bBlind = (pEntries->piid == NULL);
		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
		{
			if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset
			{
				_ASSERTE(!bBlind);
				IUnknown* pUnk = (IUnknown*)((int)pThis+pEntries->dw);
				pUnk->AddRef();
				*ppvObject = pUnk;
				return S_OK;
			}
			else //actual function call
			{
				HRESULT hRes = pEntries->pFunc(pThis,
					iid, ppvObject, pEntries->dw);
				if (hRes == S_OK || (!bBlind && FAILED(hRes)))
					return hRes;
			}
		}
		pEntries++;
	}
	return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	*pp = NULL;
	if (lp != NULL)
		lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

ATLAPI AtlFreeMarshalStream(IStream* pStream)
{
	if (pStream != NULL)
	{
		CoReleaseMarshalData(pStream);
		pStream->Release();
	}
	return S_OK;
}

ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream)
{
	HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
	if (SUCCEEDED(hRes))
	{
		hRes = CoMarshalInterface(*ppStream, iid,
			pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
		if (FAILED(hRes))
		{
			(*ppStream)->Release();
			*ppStream = NULL;
		}
	}
	return hRes;
}

ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk)
{
	*ppUnk = NULL;
	HRESULT hRes = E_INVALIDARG;
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
	}
	return hRes;
}

ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent)
{
	DWORD dwRet;
	MSG msg;

	while(1)
	{
		dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT);

		if (dwRet == WAIT_OBJECT_0)
			return TRUE;    // The event was signaled

		if (dwRet != WAIT_OBJECT_0 + 1)
			break;          // Something else happened

		// There is one or more window message available. Dispatch them
		while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
				return TRUE; // Event is now signaled.
		}
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Advise(pUnk, pdw);
	return hRes;
}

ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Unadvise(dw);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
	USES_CONVERSION;
	TCHAR szDesc[1024];
	szDesc[0] = NULL;
	// For a valid HRESULT the id should be in the range [0x0200, 0xffff]
	if (HIWORD(lpszDesc) == 0) //id
	{
		UINT nID = LOWORD((DWORD)lpszDesc);
		_ASSERTE((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
		if (LoadString(hInst, nID, szDesc, 1024) == 0)
		{
			_ASSERTE(FALSE);
			lstrcpy(szDesc, _T("Unknown Error"));
		}
		lpszDesc = T2OLE(szDesc);
		if (hRes == 0)
			hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
	}

	CComPtr<ICreateErrorInfo> pICEI;
	if (SUCCEEDED(CreateErrorInfo(&pICEI)))
	{
		CComPtr<IErrorInfo> pErrorInfo;
		pICEI->SetGUID(iid);
		LPOLESTR lpsz;
		ProgIDFromCLSID(clsid, &lpsz);
		if (lpsz != NULL)
			pICEI->SetSource(lpsz);
		if (dwHelpID != 0 && lpszHelpFile != NULL)
		{
			pICEI->SetHelpContext(dwHelpID);
			pICEI->SetHelpFile(const_cast<LPOLESTR>(lpszHelpFile));
		}
		CoTaskMemFree(lpsz);
		pICEI->SetDescription((LPOLESTR)lpszDesc);
		if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
			SetErrorInfo(0, pErrorInfo);
	}
//#ifdef _DEBUG
//  USES_CONVERSION;
//  ATLTRACE(_T("AtlReportError: Description=\"%s\" returning %x\n"), OLE2CT(lpszDesc), hRes);
//#endif
	return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Module

//Although these functions are big, they are only used once in a module
//so we should make them inline.

ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	if (pM->cbSize < sizeof(_ATL_MODULE))
		return E_INVALIDARG;
	pM->m_pObjMap = p;
	pM->m_hInst = pM->m_hInstTypeLib = pM->m_hInstResource = h;
	pM->m_nLockCnt=0L;
	pM->m_hHeap = NULL;
	InitializeCriticalSection(&pM->m_csTypeInfoHolder);
	InitializeCriticalSection(&pM->m_csWindowCreate);
	InitializeCriticalSection(&pM->m_csObjMap);
	return S_OK;
}

ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	_ASSERTE(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RegisterClassObject(dwClsContext, dwFlags);
		pEntry++;
	}
	return hRes;
}

ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	_ASSERTE(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RevokeClassObject();
		pEntry++;
	}
	return hRes;
}

ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	_ASSERTE(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	if (ppv == NULL)
		return E_POINTER;
	while (pEntry->pclsid != NULL)
	{
		if (InlineIsEqualGUID(rclsid, *pEntry->pclsid))
		{
			if (pEntry->pCF == NULL)
			{
				EnterCriticalSection(&pM->m_csObjMap);
				if (pEntry->pCF == NULL)
					hRes = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
				LeaveCriticalSection(&pM->m_csObjMap);
			}
			if (pEntry->pCF != NULL)
				hRes = pEntry->pCF->QueryInterface(riid, ppv);
			break;
		}
		pEntry++;
	}
	if (*ppv == NULL && hRes == S_OK)
		hRes = CLASS_E_CLASSNOTAVAILABLE;
	return hRes;
}

ATLAPI AtlModuleTerm(_ATL_MODULE* pM)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	_ASSERTE(pM->m_hInst != NULL);
	if (pM->m_pObjMap != NULL)
	{
		_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pCF != NULL)
				pEntry->pCF->Release();
			pEntry->pCF = NULL;
			pEntry++;
		}
	}
	DeleteCriticalSection(&pM->m_csTypeInfoHolder);
	DeleteCriticalSection(&pM->m_csWindowCreate);
	DeleteCriticalSection(&pM->m_csObjMap);
	if (pM->m_hHeap != NULL)
		HeapDestroy(pM->m_hHeap);
	return S_OK;
}

ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	_ASSERTE(pM->m_hInst != NULL);
	_ASSERTE(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	for (;pEntry->pclsid != NULL; pEntry++)
	{
		if (pCLSID == NULL)
		{
			if (pEntry->pfnGetObjectDescription() != NULL)
				continue;
		}
		else
		{
			if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
				continue;
		}
		hRes = pEntry->pfnUpdateRegistry(TRUE);
		if (FAILED(hRes))
			break;
	}
	if (SUCCEEDED(hRes) && bRegTypeLib)
		hRes = AtlModuleRegisterTypeLib(pM, 0);
	return hRes;
}

ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID)
{
	_ASSERTE(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	_ASSERTE(pM->m_hInst != NULL);
	_ASSERTE(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	for (;pEntry->pclsid != NULL; pEntry++)
	{
		if (pCLSID == NULL)
		{
			if (pEntry->pfnGetObjectDescription() != NULL)
				continue;
		}
		else
		{
			if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
				continue;
		}
		pEntry->pfnUpdateRegistry(FALSE); //unregister
	}
	return S_OK;
}

ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE* pM, LPCOLESTR lpszRes,
	BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg)
{
	USES_CONVERSION;
	_ASSERTE(pM != NULL);
	HRESULT hRes = S_OK;
	CComPtr<IRegistrar> p;
	if (pReg != NULL)
		p = pReg;
	else
	{
		hRes = CoCreateInstance(CLSID_Registrar, NULL,
			CLSCTX_INPROC_SERVER, IID_IRegistrar, (void**)&p);
	}
	if (SUCCEEDED(hRes))
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(pM->m_hInst, szModule, _MAX_PATH);
		p->AddReplacement(OLESTR("Module"), T2OLE(szModule));

		if (NULL != pMapEntries)
		{
			while (NULL != pMapEntries->szKey)
			{
				_ASSERTE(NULL != pMapEntries->szData);
				p->AddReplacement((LPOLESTR)pMapEntries->szKey, (LPOLESTR)pMapEntries->szData);
				pMapEntries++;
			}
		}
		LPCOLESTR szType = OLESTR("REGISTRY");
		GetModuleFileName(pM->m_hInstResource, szModule, _MAX_PATH);
		LPOLESTR pszModule = T2OLE(szModule);
		if (HIWORD(lpszRes)==0)
		{
			if (bRegister)
				hRes = p->ResourceRegister(pszModule, ((UINT)LOWORD((DWORD)lpszRes)), szType);
			else
				hRes = p->ResourceUnregister(pszModule, ((UINT)LOWORD((DWORD)lpszRes)), szType);
		}
		else
		{
			if (bRegister)
				hRes = p->ResourceRegisterSz(pszModule, lpszRes, szType);
			else
				hRes = p->ResourceUnregisterSz(pszModule, lpszRes, szType);
		}

	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
	_ASSERTE(pM != NULL);
	USES_CONVERSION;
	_ASSERTE(pM->m_hInstTypeLib != NULL);
	TCHAR szModule[_MAX_PATH+10];
	OLECHAR szDir[_MAX_PATH];
	GetModuleFileName(pM->m_hInstTypeLib, szModule, _MAX_PATH);
	if (lpszIndex != NULL)
		lstrcat(szModule, OLE2CT(lpszIndex));
	ITypeLib* pTypeLib;
	LPOLESTR lpszModule = T2OLE(szModule);
	HRESULT hr = LoadTypeLib(lpszModule, &pTypeLib);
	if (!SUCCEEDED(hr))
	{
		// typelib not in module, try <module>.tlb instead
		LPTSTR lpszExt = NULL;
		LPTSTR lpsz;
		for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz))
		{
			if (*lpsz == _T('.'))
				lpszExt = lpsz;
		}
		if (lpszExt == NULL)
			lpszExt = lpsz;
		lstrcpy(lpszExt, _T(".tlb"));
		lpszModule = T2OLE(szModule);
		hr = LoadTypeLib(lpszModule, &pTypeLib);
	}
	if (SUCCEEDED(hr))
	{
		ocscpy(szDir, lpszModule);
		szDir[AtlGetDirLen(szDir)] = 0;
		hr = ::RegisterTypeLib(pTypeLib, lpszModule, szDir);
	}
	if (pTypeLib != NULL)
		pTypeLib->Release();
	return hr;
}

#ifndef ATL_NO_NAMESPACE
#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif
#endif

#endif //!_ATL_DLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\autocont.h ===
// Copyright (C) 1996 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CONTENT_AUTOMATION_H__
#define __CONTENT_AUTOMATION_H__

#include <stddef.h>
#include "unknown.h"
#include "contain.h"

//=--------------------------------------------------------------------------=
// AUTOMATIONOBJECTINFO
//=--------------------------------------------------------------------------=
// for each automation object type you wish to expose to the programmer/user
// that is not a control, you must fill out one of these structures.  if the
// object isn't CoCreatable, then the first four fields should be empty.
// otherwise, they should be filled in with the appropriate information.
// use the macro DEFINE_AUTOMATIONOBJECT to both declare and define your object.
// make sure you have an entry in the global table of objects, g_ObjectInfo
// in the main .Cpp file for your InProc server.
//
typedef struct {

   UNKNOWNOBJECTINFO unknowninfo;             // fill in with 0's if we're not CoCreatable
   long      lVersion;                  // Version number of Object.  ONLY USE IF YOU'RE CoCreatable!
   const IID   *riid;                      // object's type
   LPCSTR       pszHelpFile;               // the helpfile for this automation object.
   ITypeInfo   *pTypeInfo;                 // typeinfo for this object
   UINT      cTypeInfo;                 // number of refs to the type info

} AUTOMATIONOBJECTINFO;

#define PPTYPEINFOOFOBJECT(index)      &((((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo))
#define CTYPEINFOOFOBJECT(index)    ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->cTypeInfo
#define INTERFACEOFOBJECT(index)    *(((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->riid)
#define VERSIONOFOBJECT(index)         ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->lVersion
#define DO_GUIDS_MATCH(riid1, riid2) ((riid1.Data1 == riid2.Data1) && (riid1 == riid2))

//=--------------------------------------------------------------------------=
// these things are used to set up our objects in our global object table
//
#define OI_UNKNOWN       0
#define OI_AUTOMATION    1
#define OI_CONTROL       2
#define OI_PROPERTYPAGE  3
#define OI_BOGUS      0xffff
#define EMPTYOBJECT        { OI_BOGUS, NULL }

class CAutomateContent : public CUnknownObject, public IDispatch
{
private:
   int m_cRef;
   class CContainer * m_pOuter;
   IDispatch * m_pIDispatch;
   BOOL m_bFirstTime;

public:
   CAutomateContent(CContainer *);
   virtual ~CAutomateContent();

   //Gotta have an IUnknown for delegation.
   STDMETHODIMP QueryInterface(REFIID, LPVOID *);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   // pass through IDispatch functions to the internal interface

   STDMETHOD(GetTypeInfoCount)(UINT*);
   STDMETHOD(GetTypeInfo)(UINT, LCID, LPTYPEINFO*);
   STDMETHOD(GetIDsOfNames)(REFIID, LPOLESTR*, UINT, LCID, DISPID*);
   STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS*, LPVARIANT,
                 LPEXCEPINFO, UINT*);

   void LookupKeyword(LPCSTR cs);
   void OnCommandStateChange(long Command, BOOL Enable);
   void OnDownloadBegin();
   void OnDownloadComplete();
    void OnDocumentComplete();
      void OnPropertyChange(LPCTSTR szProperty);
   void OnQuit(BOOL* Cancel);
   void OnStatusTextChange(LPCTSTR bstrText);
   void OnWindowActivated();
   void OnTitleChange(LPCTSTR bstrTitle);

   // void OnProgressChange(long Progress, long ProgressMax);
   void OnBeforeNavigate(LPCTSTR URL, long Flags, LPCTSTR TargetFrameName, VARIANT* PostData, LPCTSTR Headers, BOOL* Cancel);
   void OnNavigateComplete(LPCTSTR URL);

   int   m_ObjectType;
   BOOL  m_fLoadedTypeInfo;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\autoobj.h ===
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _AUTOOBJ_H_
#define _AUTOOBJ_H_
#include "Unknown.H"

//=--------------------------------------------------------------------------=
// the constants in this header file uniquely identify your automation objects.
// make sure that for each object you have in the g_ObjectInfo table, you have
// a constant in this header file.
//
#include "LocalSrv.H"

//=--------------------------------------------------------------------------=
// AUTOMATIONOBJECTINFO
//=--------------------------------------------------------------------------=
// for each automation object type you wish to expose to the programmer/user
// that is not a control, you must fill out one of these structures.  if the
// object isn't CoCreatable, then the first four fields should be empty.
// otherwise, they should be filled in with the appropriate information.
// use the macro DEFINE_AUTOMATIONOBJECT to both declare and define your object.
// make sure you have an entry in the global table of objects, g_ObjectInfo
// in the main .Cpp file for your InProc server.

#ifndef NDEF_AUTOMATIONOBJECTINFO

typedef struct {
	UNKNOWNOBJECTINFO unknowninfo;				 // fill in with 0's if we're not CoCreatable
	long		 lVersion;						 // Version number of Object.  ONLY USE IF YOU'RE CoCreatable!
	const IID	*riid;							 // object's type
	LPCSTR		 pszHelpFile;					 // the helpfile for this automation object.
	ITypeInfo	*pTypeInfo; 					 // typeinfo for this object
	UINT		 cTypeInfo; 					 // number of refs to the type info
} AUTOMATIONOBJECTINFO;

#endif

// macros to manipulate the AUTOMATIONOBJECTINFO in the global table table.

#define VERSIONOFOBJECT(index)		   ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->lVersion
#define INTERFACEOFOBJECT(index)	   *(((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->riid)
#define PPTYPEINFOOFOBJECT(index)	   &((((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo))
#define PTYPEINFOOFOBJECT(index)	   ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo
#define CTYPEINFOOFOBJECT(index)	   ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->cTypeInfo
#define HELPFILEOFOBJECT(index) 	   ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszHelpFile

#ifndef INITOBJECTS

#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
extern AUTOMATIONOBJECTINFO name##Object \

#else
#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
	AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, fn }, ver, riid, pszh, NULL, 0} \

#endif // INITOBJECTS

//=--------------------------------------------------------------------------=
// Standard Dispatch and SupportErrorInfo
//=--------------------------------------------------------------------------=
// all objects should declare these in their class definitions so that they
// get standard implementations of IDispatch and ISupportErrorInfo.
//
#define DECLARE_STANDARD_DISPATCH() \
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { \
		return CAutomationObject::GetTypeInfoCount(pctinfo); \
	} \
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **ppTypeInfoOut) { \
		return CAutomationObject::GetTypeInfo(itinfo, lcid, ppTypeInfoOut); \
	} \
	STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cnames, LCID lcid, DISPID *rgdispid) { \
		return CAutomationObject::GetIDsOfNames(riid, rgszNames, cnames, lcid, rgdispid); \
	} \
	STDMETHOD(Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) { \
		return CAutomationObject::Invoke(dispid, riid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr); \
	} \


#define DECLARE_STANDARD_SUPPORTERRORINFO() \
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid) { \
		return CAutomationObject::InterfaceSupportsErrorInfo(riid); \
	} \


//=--------------------------------------------------------------------------=
// CAutomationObject
//=--------------------------------------------------------------------------=
// global class that all automation objects can inherit from to give them a
// bunch of implementation for free, namely IDispatch and ISupportsErrorInfo

class CAutomationObject : public CUnknownObject {

public:
	// aggreation query interface support

	virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

	// IDispatch methods

	STDMETHOD(GetTypeInfoCount)(UINT *);
	STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo **);
	STDMETHOD(GetIDsOfNames)(REFIID, OLECHAR **, UINT, LCID, DISPID *);
	STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

	//	ISupportErrorInfo methods

	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID);

	CAutomationObject(IUnknown *, int , void *);
	virtual ~CAutomationObject();

	// callable functions -- things that most people will find useful.

	HRESULT Exception(HRESULT hr, WORD idException, DWORD dwHelpContextID);

protected:
	// member variables that derived objects might need to get at information in the
	// global object table

	int   m_ObjectType;

private:

	BOOL  m_fLoadedTypeInfo;
};

#endif // _AUTOOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\bookmark.cpp ===
///////////////////////////////////////////////////////////
//
//
// AdSearch.cpp - Implementation of the Advanced Search UI
//
// This source file implements the Advanced Search Navigation
// pane class.

///////////////////////////////////////////////////////////
//
// Include section
//
#include "header.h"

#include "strtable.h" // These headers were copied from search.cpp. Are they all needed?
#include "system.h"
#include "hhctrl.h"
#include "resource.h"
#include "secwin.h"
#include "htmlhelp.h"
#include "cpaldc.h"
#include "TCHAR.h"
#include "parserhh.h"
#include "collect.h"
#include "hhtypes.h"
#include "toc.h"
#include "contain.h"
#include "cctlww.h"

// Our header file.
#include "bookmark.h"

// Common Control Macros
#include <windowsx.h>

#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring

///////////////////////////////////////////////////////////
//
//                  Constants
//

const char c_PersistFolder[] = "Bookmarks\\v1" ;
const char c_TopicFolder[] = "Topic" ;
const char c_UrlFolder[] = "Url" ;
const char c_CountFolder[] = "Bookmarks\\v1\\Count" ;
const wchar_t c_KeywordSeparator[] = L"\n" ;

// This is the maximum bookmarks we store.
// The main reason for this is to ensure that we have a reasonable value
// when we read the collection in.
const int c_MaxBookmarks = 1024;

extern BOOL g_fUnicodeListView;
///////////////////////////////////////////////////////////
//
// Static Member functions
//

WNDPROC CBookmarksNavPane::s_lpfnlListViewWndProc = NULL;
WNDPROC CBookmarksNavPane::s_lpfnlCurrentTopicEditProc = NULL;
WNDPROC CBookmarksNavPane::s_lpfnlGenericBtnProc = NULL;
//WNDPROC CBookmarksNavPane::s_lpfnlGenericKeyboardProc = NULL ;

///////////////////////////////////////////////////////////
//
// Non-Member helper functions.
//
// Convert a rect from screen to client.
void ScreenRectToClientRect(HWND hWnd, /*in/out*/ RECT* prect) ;

///////////////////////////////////////////////////////////
//
//                  Construction
//
///////////////////////////////////////////////////////////
//
// CBookmarksNavPane();
//
CBookmarksNavPane::CBookmarksNavPane(CHHWinType* pWinType)
:   m_hWnd(NULL),
    m_hfont(NULL),
    m_padding(2),    // padding to put around the window
    m_pWinType(pWinType),
    m_pszCurrentUrl(NULL),
    m_bChanged(false)
{
    ASSERT(pWinType) ;
    m_pTitleCollection = pWinType->m_phmData->m_pTitleCollection;
    ASSERT(m_pTitleCollection);

   m_NavTabPos = pWinType->tabpos ;
}

///////////////////////////////////////////////////////////
//
//  ~CBookmarksNavPane
//
CBookmarksNavPane::~CBookmarksNavPane()
{
    //--- Persist Keywords in combo
    SaveBookmarks() ;

    //--- Empty the listview.
    int items = ListView_GetItemCount(m_aDlgItems[c_TopicsList].m_hWnd) ;
    if (items > 0)
    {
        // Iterate through each item get its size.
        for (int i = 0 ; i < items ; i++)
        {
            TCHAR* pUrl = GetUrl(i) ;
            ASSERT(pUrl) ;
            if (pUrl)
            {
                // Delete the attached url.
                delete [] pUrl ;
            }
        }

        // Delete all of the items
        W_ListView_DeleteAllItems(m_aDlgItems[c_TopicsList].m_hWnd) ;
    }

    //--- CleanUp
   if (m_hfont)
    {
        ::DeleteObject(m_hfont);
    }

    if (m_hWnd)
    {
        ::DestroyWindow(m_hWnd) ;
    }

    if (m_pszCurrentUrl)
    {
        delete m_pszCurrentUrl ;
    }

    //Don't free m_pTitleCollection
}

///////////////////////////////////////////////////////////
//
//              INavUI Interface functions.
//
///////////////////////////////////////////////////////////
//
// Create
//
BOOL
CBookmarksNavPane::Create(HWND hwndParent)
{
    bool bReturn = false ;

    if (m_hWnd)
    {
        return true ;
    }

    // ---Create the dialog.
    bool bUnicode = true;
    if (! (m_hWnd = CreateDialogParamW(
                        _Module.GetResourceInstance(),
                        MAKEINTRESOURCEW(IDPAGE_TAB_BOOKMARKS),
                        hwndParent,
                        s_DialogProc,
                        reinterpret_cast<LPARAM>(this))) ) // Pass over the this pointer.
    {
       bUnicode = FALSE;
       if (! (m_hWnd = CreateDialogParamA(
                           _Module.GetResourceInstance(),
                           MAKEINTRESOURCEA(IDPAGE_TAB_BOOKMARKS),
                           hwndParent,
                           s_DialogProc,
                           reinterpret_cast<LPARAM>(this))) ) // Pass over the this pointer.
          return FALSE;
    }

    //--- Initialize the DlgItem Array.
    InitDlgItemArray() ;

    //--- Initialize the bookmarks list
    // Setup the columnsin the listview ;
    LV_COLUMNW column;
    column.mask = LVCF_FMT | LVCF_WIDTH;
    column.cx = 1500; //TODO FIX
    column.fmt = LVCFMT_LEFT;
    //column.iSubItem = 0;

    W_EnableUnicode(m_aDlgItems[c_TopicsList].m_hWnd, W_ListView);
    W_ListView_InsertColumn(m_aDlgItems[c_TopicsList].m_hWnd, 0, &column );

    // Sub-class the list view
    if (s_lpfnlListViewWndProc == NULL)
    {
        s_lpfnlListViewWndProc = W_GetWndProc(m_aDlgItems[c_TopicsList].m_hWnd, bUnicode);
    }
    W_SubClassWindow(m_aDlgItems[c_TopicsList].m_hWnd, reinterpret_cast<LONG_PTR>(s_ListViewProc), bUnicode);
    SETTHIS(m_aDlgItems[c_TopicsList].m_hWnd);

    //--- Initialize the Current Topic Edit Control
    // Limit the amount of text which can be typed in.
    Edit_LimitText(m_aDlgItems[c_CurrentTopicEdit].m_hWnd, MAX_PATH-1) ;


    // Subclass the keyword combo so that we can process the keys
    if (s_lpfnlCurrentTopicEditProc == NULL)
    {
        s_lpfnlCurrentTopicEditProc = W_GetWndProc(m_aDlgItems[c_CurrentTopicEdit].m_hWnd, bUnicode);
    }
    W_SubClassWindow(m_aDlgItems[c_CurrentTopicEdit].m_hWnd, reinterpret_cast<LONG_PTR>(s_CurrentTopicEditProc), bUnicode);
    SETTHIS(m_aDlgItems[c_CurrentTopicEdit].m_hWnd);

    //--- Subclass all of the buttons
    // Start with the StartSearch button ;
    if (s_lpfnlGenericBtnProc == NULL)
    {
        s_lpfnlGenericBtnProc = W_GetWndProc(m_aDlgItems[c_DeleteBtn].m_hWnd, bUnicode);
    }
    W_SubClassWindow(m_aDlgItems[c_DeleteBtn].m_hWnd, reinterpret_cast<LONG_PTR>(s_GenericBtnProc), bUnicode);
    SETTHIS(m_aDlgItems[c_DeleteBtn].m_hWnd);

    // Bitmap btn
    W_SubClassWindow(m_aDlgItems[c_DisplayBtn].m_hWnd, reinterpret_cast<LONG_PTR>(s_GenericBtnProc), bUnicode);
    SETTHIS(m_aDlgItems[c_DisplayBtn].m_hWnd);

    // c_DisplayBtn
    W_SubClassWindow(m_aDlgItems[c_AddBookmarkBtn].m_hWnd, reinterpret_cast<LONG_PTR>(s_GenericBtnProc), bUnicode);
    SETTHIS(m_aDlgItems[c_AddBookmarkBtn].m_hWnd);

#if 0
    //--- Set the font. This will fix some dbcs issues.
    for (int i = 0 ; i < c_NumDlgItems ; i++)
    {
        SendMessage(m_aDlgItems[i].m_hWnd, WM_SETFONT, (WPARAM) GetFont(), FALSE);
    }
#endif

    SendMessage(m_aDlgItems[c_CurrentTopicEdit].m_hWnd, WM_SETFONT, (WPARAM) GetFont(), FALSE);
    SendMessage(m_aDlgItems[c_TopicsList].m_hWnd, WM_SETFONT, (WPARAM) GetAccessableContentFont(), FALSE);

    //--- Fill the combobox with persisted data.
    LoadBookmarks() ;

    // Set the focus to the appropriate control.
    SetDefaultFocus() ;

    //TODO: Fix
    return true;
}

///////////////////////////////////////////////////////////
//
// OnCommand
//
LRESULT
CBookmarksNavPane::OnCommand(HWND hwnd, UINT id, UINT NotifyCode, LPARAM lParam)
{
    switch(NotifyCode)
    {
    case BN_CLICKED:
        switch(id)
        {
        case IDC_BOOKMARKS_DELETE_BTN:
            OnDelete() ;
            break;
        case IDC_BOOKMARKS_DISPLAY_BTN:
            OnDisplay() ;
            break ;
        case IDC_BOOKMARKS_ADDBOOKMARK_BTN:
            OnAddBookmark();
            break;
        case IDC_BOOKMARKS_EDIT_BTN:
            OnEdit() ;
            break;
        default:
            return 0 ;
        }
        return 1 ;
    }
    return 0 ;
}

///////////////////////////////////////////////////////////
//
// ResizeWindow
//
void
CBookmarksNavPane::ResizeWindow()
{
    ASSERT(::IsValidWindow(m_hWnd)) ;

    // Resize to fit the client area of the parent.
    HWND hwndParent = GetParent(m_hWnd) ;
    ASSERT(::IsValidWindow(hwndParent)) ;

    //--- Get the size of the window
    RECT rcParent;
    GetParentSize(&rcParent, hwndParent, m_padding, m_NavTabPos);

    //--- Move and size the dialog box itself.
    ::SetWindowPos( m_hWnd, NULL, rcParent.left, rcParent.top,
                    rcParent.right-rcParent.left,
                    rcParent.bottom-rcParent.top,
                    SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOREDRAW);

    //---Fix the painting bugs. However, this is a little on the flashy side.
    ::InvalidateRect(m_hWnd, NULL, TRUE) ;

    RECT rcDlg;
    ::GetClientRect(m_hWnd, &rcDlg) ;

    //--- Now position each control within this space.

    for (int i = 0 ; i < c_NumDlgItems ; i++)
    {
        // Get Current Settings.
        int X = m_aDlgItems[i].m_rectCur.left;
        int Y = m_aDlgItems[i].m_rectCur.top;
        int CX = m_aDlgItems[i].m_rectCur.right - m_aDlgItems[i].m_rectCur.left;
        int CY = m_aDlgItems[i].m_rectCur.bottom - m_aDlgItems[i].m_rectCur.top;

        bool bChanged = false ;
        //--- RIGHT JUSTIFICATION
        if (m_aDlgItems[i].m_JustifyH == Justify::Right)
        {
            int NewX = rcDlg.right-m_aDlgItems[i].m_iOffsetH ; // subtract the offset
            int MinX = m_aDlgItems[i].m_rectMin.left;
            if (NewX < MinX)
            {
                NewX = MinX;  // Don't go below min.
            }

            if (X != NewX)
            {
                X = NewX ; // Update the current setting.
                bChanged = true ;
            }
        }

        //--- BOTTOM JUSTIFICATION
        if (m_aDlgItems[i].m_JustifyV == Justify::Bottom)
        {
            int NewY = rcDlg.bottom - m_aDlgItems[i].m_iOffsetV;
            int MinY = m_aDlgItems[i].m_rectMin.top ;
            if (NewY < MinY)
            {
                NewY = MinY ;
            }

            if (Y != NewY)
            {
                Y = NewY ; // Update Setting.
                bChanged = true ;
            }
        }

        //--- HORIZONTAL GROWING
        if (m_aDlgItems[i].m_bGrowH)
        {
            int MaxCX = m_aDlgItems[i].m_rectMax.right - m_aDlgItems[i].m_rectMax.left ;
            int MinCX = m_aDlgItems[i].m_rectMin.right - m_aDlgItems[i].m_rectMin.left ;
            int MinCY = m_aDlgItems[i].m_rectMin.bottom - m_aDlgItems[i].m_rectMin.top ;
            int NewRight = rcDlg.right - m_aDlgItems[i].m_iPadH ;
            int NewCX = NewRight - m_aDlgItems[i].m_rectMin.left;
            if (NewCX < MinCX)
            {
                NewCX = MinCX;
            }
            else if ((!m_aDlgItems[i].m_bIgnoreMax) && NewCX > MaxCX)
            {
                NewCX = MaxCX ;
            }

            if (CX != NewCX)
            {
                CX =  NewCX ; // Update Current ;
                bChanged = true ;
            }
        }

        //--- VERTICAL GROWING
        if (m_aDlgItems[i].m_bGrowV)
        {
            int MaxCY = m_aDlgItems[i].m_rectMax.bottom - m_aDlgItems[i].m_rectMax.top;
            int MinCY = m_aDlgItems[i].m_rectMin.bottom - m_aDlgItems[i].m_rectMin.top ;
            int MinCX = m_aDlgItems[i].m_rectMin.right - m_aDlgItems[i].m_rectMin.left;
            int NewBottom = rcDlg.bottom - m_aDlgItems[i].m_iPadV ;
            int NewCY = NewBottom - m_aDlgItems[i].m_rectMin.top;
            if (NewCY < MinCY)
            {
                NewCY = MinCY;
            }
            else if ((!m_aDlgItems[i].m_bIgnoreMax) && NewCY > MaxCY)
            {
                NewCY = MaxCY ;
            }

            if (CY != NewCY)
            {
                CY = NewCY ;
                bChanged = true ;
            }
        }

        if (bChanged)
        {
            m_aDlgItems[i].m_rectCur.left = X ;
            m_aDlgItems[i].m_rectCur.top = Y ;
            m_aDlgItems[i].m_rectCur.right = X + CX ;
            m_aDlgItems[i].m_rectCur.bottom = Y + CY ;

            ::SetWindowPos(m_aDlgItems[i].m_hWnd, NULL,
                           X, Y, CX, CY,
                           SWP_NOZORDER | SWP_NOOWNERZORDER /*| SWP_NOREDRAW*/);

            // If we have to change the size of the results list, lets change the size of the columns.
/*
            if (i == c_ResultsList)
            {
                m_plistview->SizeColumns() ;
            }
*/

        }
    }


}


///////////////////////////////////////////////////////////
//
// HideWindow
//
void
CBookmarksNavPane::HideWindow()
{
    if (::IsValidWindow(m_hWnd))
    {
        ::ShowWindow(m_hWnd, SW_HIDE) ;
    }
}


///////////////////////////////////////////////////////////
//
// ShowWindow
//
void
CBookmarksNavPane::ShowWindow()
{
    if (::IsValidWindow(m_hWnd))
    {
        // Turn the dialog items on/off
        ShowDlgItemsEnabledState() ;

        // Show the dialog window.
        ::ShowWindow(m_hWnd, SW_SHOW) ;
    }
}


///////////////////////////////////////////////////////////
//
// SetPadding
//
void
CBookmarksNavPane::SetPadding(int pad)
{
    m_padding = pad;
}


///////////////////////////////////////////////////////////
//
// SetTabPos
//
void
CBookmarksNavPane::SetTabPos(int tabpos)
{
    m_NavTabPos = tabpos;
}



///////////////////////////////////////////////////////////
//
// SetDefaultFocus --- Set focus to the most expected control, usually edit combo.
//
void
CBookmarksNavPane::SetDefaultFocus()
{
    if (::IsValidWindow(m_aDlgItems[c_TopicsList].m_hWnd))
    {
        BookmarkDlgItemInfoIndex ctrl ;

        int items = W_ListView_GetItemCount(m_aDlgItems[c_TopicsList].m_hWnd) ;
        if (items > 0)
        {
            // Set focus to the topics list if we have any entries in it.
            ctrl = c_TopicsList ;

            // Set the focus if nothing selected.
            if (GetSelectedItem() < 0)
            {
                W_ListView_SetItemState(m_aDlgItems[c_TopicsList].m_hWnd, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED) ;
            }
        }
        else
        {
            // Set focus to the edit control if the topic listis empty.
            ctrl = c_CurrentTopicEdit ;
        }

        SetFocus(m_aDlgItems[ctrl].m_hWnd) ;
    }
}

///////////////////////////////////////////////////////////
//
// ProcessMenuChar --- Process accelerator keys.
//
bool
CBookmarksNavPane::ProcessMenuChar(HWND hwndParent, int ch)
{
    return ::ProcessMenuChar(this, hwndParent, m_aDlgItems, c_NumDlgItems, ch) ;
}

///////////////////////////////////////////////////////////
//
// OnNotify --- Process WM_NOTIFY messages. Used by embedded Tree and List view controls.
//
LRESULT
CBookmarksNavPane::OnNotify(HWND hwnd, WPARAM idCtrl, LPARAM lParam)
{

    switch(idCtrl)
    {
    case IDC_BOOKMARKS_TOPICS_LISTVIEW:
        if (::IsValidWindow(m_aDlgItems[c_TopicsList].m_hWnd))
        {
            return ListViewMsg(m_aDlgItems[c_TopicsList].m_hWnd, (NM_LISTVIEW*) lParam);
        }
        break ;
    default:
        //return DefDlgProc(m_hWnd, WM_NOTIFY, idCtrl, lParam);
        return 0 ;
    }

    return 0 ;
}

///////////////////////////////////////////////////////////
//
// OnDrawItem --- Process WM_DRAWITEM messages.
//
void
CBookmarksNavPane::OnDrawItem(UINT id, LPDRAWITEMSTRUCT pdis)
{
}

///////////////////////////////////////////////////////////
//
// Seed --- Seed the nav ui with a search term or keyword.
//
void
CBookmarksNavPane::Seed(LPCSTR pszSeed)
{
}


///////////////////////////////////////////////////////////
//
//  Synchronize
//
BOOL
CBookmarksNavPane::Synchronize(PSTR pNotUsed, CTreeNode* pNotUsed2)
{
    if (pNotUsed == NULL && pNotUsed2 == NULL)
    {
        FillCurrentTopicEdit() ;
        return TRUE ;
    }
    else
    {
        return FALSE ;
    }
}
///////////////////////////////////////////////////////////
//
//              Helper Functions.
//
///////////////////////////////////////////////////////////
//
// InitDlgItemArray
//
void
CBookmarksNavPane::InitDlgItemArray()
{
    RECT rectCurrent ;
    RECT rectDlg ;
    ::GetClientRect(m_hWnd, &rectDlg) ;
    //--- Setup the dlg array for each control.

    //--- Topics ListView
    int i = c_TopicsList;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_BOOKMARKS_TOPICS_LISTVIEW) ;
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent) ; // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    DWORD_PTR dwCurrentExtendedStyles = GetWindowLongPtr(m_aDlgItems[i].m_hWnd, GWL_EXSTYLE);
    SetWindowLongPtr(m_aDlgItems[i].m_hWnd, GWL_EXSTYLE, dwCurrentExtendedStyles | g_RTL_Mirror_Style);

    m_aDlgItems[i].m_id = IDC_BOOKMARKS_TOPICS_LISTVIEW;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_hWnd, IDC_BOOKMARKS_TOPICS_STATIC);              // No accelerator.

    m_aDlgItems[i].m_Type = ItemInfo::Generic;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE ;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE ;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = TRUE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = TRUE ;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV = ;            // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left
    //m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
    m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
    m_aDlgItems[i].m_iPadV = rectDlg.bottom - rectCurrent.bottom;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax ;        // Max size.

    //--- Delete Button
    i = c_DeleteBtn;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_BOOKMARKS_DELETE_BTN) ;
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent) ; // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_BOOKMARKS_DELETE_BTN;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_aDlgItems[i].m_hWnd) ;

    m_aDlgItems[i].m_Type        = ItemInfo::Button;
    m_aDlgItems[i].m_bIgnoreEnabled = FALSE;
    m_aDlgItems[i].m_bEnabled       = FALSE;    // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax     = TRUE ;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH         = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV         = FALSE ;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Bottom;        // Do we stick to the top or the bottom.
    m_aDlgItems[i].m_iOffsetV = rectDlg.bottom - rectCurrent.top ; // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
    //m_aDlgItems[i].m_iPadH = ;               // Right Horizontal Padding.
    //m_aDlgItems[i].m_iPadV = ;               // Bottom Vertical Padding.

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax ;        // Max size.

    //--- Display Button
    i = c_DisplayBtn;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_BOOKMARKS_DISPLAY_BTN) ;
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent) ; // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_BOOKMARKS_DISPLAY_BTN;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_aDlgItems[i].m_hWnd) ;

    m_aDlgItems[i].m_Type        = ItemInfo::Button;
    m_aDlgItems[i].m_bIgnoreEnabled = FALSE;
    m_aDlgItems[i].m_bEnabled       = FALSE;       // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax     = TRUE ;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH         = FALSE;       // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV         = FALSE ;      // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Bottom;        // Do we stick to the top or the bottom.
    m_aDlgItems[i].m_iOffsetV = rectDlg.bottom - rectCurrent.top ; // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
    //m_aDlgItems[i].m_iPadH = ;               // Right Horizontal Padding.
    //m_aDlgItems[i].m_iPadV = ;               // Bottom Vertical Padding.

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax ;        // Max size.


    //--- Current Topics Static
    i = c_CurrentTopicStatic;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_BOOKMARKS_CURRENTTOPIC_STATIC) ;
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent) ; // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_BOOKMARKS_CURRENTTOPIC_STATIC;
    m_aDlgItems[i].m_accelkey = 0 ;

    m_aDlgItems[i].m_Type = ItemInfo::Generic;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE ;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE ;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE ;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Bottom;        // Do we stick to the top or the bottom.
    m_aDlgItems[i].m_iOffsetV = rectDlg.bottom - rectCurrent.top ; // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left
    //m_aDlgItems[i].m_iOffsetH =
    //m_aDlgItems[i].m_iPadH = ;               // Right Horizontal Padding.
    //m_aDlgItems[i].m_iPadV = ;               // Bottom Vertical Padding.

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax ;        // Max size.


    //--- Current Topics Edit control
    i = c_CurrentTopicEdit;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_BOOKMARKS_CURRENTTOPIC_EDIT) ;
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent) ; // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    dwCurrentExtendedStyles = GetWindowLongPtr(m_aDlgItems[i].m_hWnd, GWL_EXSTYLE);
    SetWindowLongPtr(m_aDlgItems[i].m_hWnd, GWL_EXSTYLE, dwCurrentExtendedStyles | g_RTL_Style);

    m_aDlgItems[i].m_id = IDC_BOOKMARKS_CURRENTTOPIC_EDIT;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_hWnd, IDC_BOOKMARKS_CURRENTTOPIC_STATIC);

    m_aDlgItems[i].m_Type = ItemInfo::Generic;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE ;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE ;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = TRUE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE ;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Bottom;        // Do we stick to the top or the bottom.
    m_aDlgItems[i].m_iOffsetV = rectDlg.bottom - rectCurrent.top ; // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left
    //m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
    m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
    //m_aDlgItems[i].m_iPadV = ;               // Bottom Vertical Padding.

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax ;        // Max size.


    //--- Add Button
    i = c_AddBookmarkBtn ;
    m_aDlgItems[i].m_hWnd = ::GetDlgItem(m_hWnd, IDC_BOOKMARKS_ADDBOOKMARK_BTN) ;
    ::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent) ; // Get screen coordinates.
    ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDC_BOOKMARKS_ADDBOOKMARK_BTN;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_aDlgItems[i].m_hWnd) ;

    m_aDlgItems[i].m_Type = ItemInfo::Button;
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE ;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE ;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE ;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Bottom;        // Do we stick to the top or the bottom.
    m_aDlgItems[i].m_iOffsetV = rectDlg.bottom - rectCurrent.top ; // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    m_aDlgItems[i].m_iOffsetH =rectDlg.right - rectCurrent.left;
    //m_aDlgItems[i].m_iPadH = ;               // Right Horizontal Padding.
    //m_aDlgItems[i].m_iPadV = ;               // Bottom Vertical Padding.

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax ;        // Max size.
}


///////////////////////////////////////////////////////////
//
// SetEnabledState
//
void
CBookmarksNavPane::ShowDlgItemsEnabledState()
{
    // Enable/Disable all the controls
    for (int i = 0 ; i < c_NumDlgItems ; i++)
    {
        if (!m_aDlgItems[i].m_bIgnoreEnabled && ::IsValidWindow(m_aDlgItems[i].m_hWnd))
        {
            EnableWindow(m_aDlgItems[i].m_hWnd, m_aDlgItems[i].m_bEnabled) ;
        }
    }
}


///////////////////////////////////////////////////////////
//
// EnableDlgItem
//
void
CBookmarksNavPane::EnableDlgItem(BookmarkDlgItemInfoIndex  index, bool bEnable)
{
    ASSERT(index >= 0 && index < c_NumDlgItems) ;

    if (!m_aDlgItems[index].m_bIgnoreEnabled)
    {
        // Are we enabled or not?
        m_aDlgItems[index].m_bEnabled = bEnable ;

        // Do it for real.
        if (::IsValidWindow(m_aDlgItems[index].m_hWnd))
        {
            EnableWindow(m_aDlgItems[index].m_hWnd, bEnable) ;
        }
    }

}


///////////////////////////////////////////////////////////
//
// SaveBookmarks --- Persists the bookmars to the storage
//
// The bookmarks are stored using the following format:
//  Bookmarks
//      \v1                 - Version.
//          \Count          - Number of bookmarks written.
//          \0              - First bookmark.
//              \Topic      - Topic Unicode String
//              \Url        - Url Unicode String
//          \1              - Second bookmark.
//           ...
//          \(count-1)
//
void
CBookmarksNavPane::SaveBookmarks()
{
    // Also save the bookmarks, if they have changed.
    if (!Changed())
    {
        return ;
    }

    // Keep track of the number of bookmarks written.
    int cWritten = 0 ;

    // Buffer for path to the state folder.
    char statepath[64] ;

    // Get the state pointer.
    CState* pstate = m_pTitleCollection->GetState();
    ASSERT(pstate) ;

    // Are there any keywords to save.
    int items = W_ListView_GetItemCount(m_aDlgItems[c_TopicsList].m_hWnd) ;
    if (items > 0)
    {
        // Limit the number. I hate limiting the number, but its much more robust.
        if (items > c_MaxBookmarks)
        {
            items = c_MaxBookmarks ;
        }

        // Buffer for retrieving the text.
        WCHAR Topic[MAX_URL] ;

        // Iterate through the items.
        for (int i = 0 ; i < items ; i++)
        {
            TCHAR* pUrl = NULL ;
            if (GetTopicAndUrl(i, Topic, sizeof(Topic), &pUrl))
            {
                //--- Write out topic.

                // Construct the path.
                wsprintf(statepath, "%s\\%d\\%s", c_PersistFolder, cWritten, c_TopicFolder);
                if (SUCCEEDED(pstate->Open(statepath, STGM_WRITE)))
                {
                    DWORD cb = (wcslen(Topic)+1)*sizeof(wchar_t) ;
                    DWORD dwResult = pstate->Write(Topic, cb);
                    pstate->Close();

                    // Is result okay?
                    if (cb == dwResult)
                    {
                        //--- Write out the URL.
                        // Convert to unicode.
                        CWStr url(pUrl) ;
                        ASSERT(url.pw) ;

                        // Construt the path.
                        wsprintf(statepath, "%s\\%d\\%s", c_PersistFolder, cWritten, c_UrlFolder);
                        // Write out.
                        if (SUCCEEDED(pstate->Open(statepath, STGM_WRITE)))
                        {
                            cb = (wcslen(url.pw)+1)*sizeof(wchar_t) ;
                            dwResult = pstate->Write(url.pw, cb);
                            pstate->Close();

                            // Check result.
                            if (cb == dwResult)
                            {
                                // We have been successful. So Increment the count.
                                cWritten++ ;
                            }
                        }
                    }
                }

            } //if
        } // for

    } // if items

    // How many entries are currently stored.
    int StoredCount = 0;
    if (SUCCEEDED(pstate->Open(c_CountFolder, STGM_READ)))
    {
        DWORD cbReadIn = 0 ;
        pstate->Read(&StoredCount , sizeof(StoredCount), &cbReadIn) ;
        pstate->Close() ;

        if (cbReadIn != sizeof(StoredCount))
        {
            // Assume that we don't have any stored.
            StoredCount = 0 ;
        }
    }

    // Delete the extra entries.
    if (StoredCount > cWritten)
    {
        // Delete extra entries.
        for(int j = cWritten ; j < StoredCount ; j++)
        {
            // Remove the URL folder.
            wsprintf(statepath, "%s\\%d\\%s", c_PersistFolder, j, c_UrlFolder);
            if (SUCCEEDED(pstate->Open(statepath, STGM_READ)))
            {
                HRESULT hr = pstate->Delete() ;
                ASSERT(SUCCEEDED(hr)) ;
                pstate->Close() ;
            }

            // Remove the topic folder.
            wsprintf(statepath, "%s\\%d\\%s", c_PersistFolder, j, c_TopicFolder);
            if (SUCCEEDED(pstate->Open(statepath, STGM_WRITE)))
            {
                HRESULT hr = pstate->Delete() ;
                ASSERT(SUCCEEDED(hr)) ;
                pstate->Close() ;
            }

            // Remove branch.
            wsprintf(statepath, "%s\\%d", c_PersistFolder, j);
            if (SUCCEEDED(pstate->Open(statepath, STGM_WRITE)))
            {
                HRESULT hr = pstate->Delete() ;
                ASSERT(SUCCEEDED(hr)) ;
                pstate->Close() ;
            }

        }
    }

    // Write out the count.
    if (cWritten >= 0) // We may have deleted everything, so count can be zero.
    {
        // Write out the new count.
        if (SUCCEEDED(pstate->Open(c_CountFolder, STGM_WRITE)))
        {
            DWORD cb = pstate->Write(&cWritten, sizeof(cWritten));
            ASSERT(cb == sizeof(cWritten)) ; // TODO: Handle error.
            pstate->Close() ;

            // Reset dirty flag ;
            SetChanged(false) ;
        }
    }
    else
    {
        //TODO: Erase everything. That is there.
    }
}

///////////////////////////////////////////////////////////
//
// LoadBookmarks - Loads the results list from the storage
//
void
CBookmarksNavPane::LoadBookmarks()
{
    CState* pstate = m_pTitleCollection->GetState();
    if (SUCCEEDED(pstate->Open(c_CountFolder, STGM_READ)))
    {
        // Read in the topics stored.
        DWORD cbReadIn = 0 ;
        int StoredCount = 0;
        pstate->Read(&StoredCount , sizeof(StoredCount), &cbReadIn) ;
        pstate->Close() ;

        // Did we get a reasonable number?
        if (cbReadIn == sizeof(StoredCount) &&
            StoredCount > 0 &&
            StoredCount < c_MaxBookmarks)  // We check the max here just to sure we have reasonable numbers.
        {
            // Buffer for path to the state folder.
            char statepath[64] ;

            WCHAR buffer[MAX_URL] ;

            // Now let's read them in.
            for (int i=0 ; i < StoredCount ; i++)
            {
                //--- Read in the URL.
                TCHAR* pUrl = NULL ;

                // Construct the path.
                wsprintf(statepath, "%s\\%d\\%s", c_PersistFolder, i, c_UrlFolder);

                // Open Topic in.
                if (SUCCEEDED(pstate->Open(statepath, STGM_READ)))
                {
                    // Read it into the buffer.
                    DWORD cb = NULL ;
                    HRESULT hr = pstate->Read(&buffer, sizeof(buffer), &cb);
                    pstate->Close();

                    // Check result.
                    if (SUCCEEDED(hr))
                    {
                        // Convert from unicode.
                        CStr strUrl(buffer) ;
                        ASSERT(strUrl.psz) ;

                        //--- Read in the topic.
                        // Construct the path.
                        wsprintf(statepath, "%s\\%d\\%s", c_PersistFolder, i, c_TopicFolder);
                        if (SUCCEEDED(pstate->Open(statepath, STGM_READ)))
                        {
                            cb = NULL;
                            hr = pstate->Read(&buffer, sizeof(buffer), &cb);
                            pstate->Close();
                            if (SUCCEEDED(hr))
                            {
                                //--- Save the URL.
                                TCHAR* pszUrl = new TCHAR[strUrl.strlen()+1] ;
                                _tcscpy(pszUrl, strUrl.psz) ;

                                //--- Add the string to the listview.
                                LV_ITEMW item;
                                item.mask    = LVIF_TEXT | LVIF_PARAM ; //| LVIF_STATE;
                                item.iImage    = 0;
                                //item.state      = LVIS_FOCUSED | LVIS_SELECTED;
                                //item.stateMask  = LVIS_FOCUSED | LVIS_SELECTED;
                                item.iItem     = 0 ;
                                item.iSubItem  = 0;
                                item.lParam    = (LPARAM)pszUrl;
                                item.pszText   = buffer;
                                W_ListView_InsertItem( m_aDlgItems[c_TopicsList].m_hWnd, &item );
                            }
                        }
                    }
                } // if --- opened topic.
            } // for

            // We haven't changed.
            SetChanged(false) ;

        } //if --- count valid
    } //if --- Can read count
}

///////////////////////////////////////////////////////////
//
// FillCurrentTopicEdit
//
void
CBookmarksNavPane::FillCurrentTopicEdit()
{
    ASSERT(m_pWinType && m_pWinType->m_pCIExpContainer && m_pWinType->m_pCIExpContainer->m_pWebBrowserApp) ;
    ASSERT(m_pTitleCollection) ;

    //--- Prepare to be re-entered!
    // Delete the current URL.
    if (m_pszCurrentUrl)
    {
        delete m_pszCurrentUrl ;
        m_pszCurrentUrl = NULL ;
    }

    // Clear out the edit control.
    W_SetWindowText(m_aDlgItems[c_CurrentTopicEdit].m_hWnd, L"") ;

    //--- Get to work.
    CStr url ;
    if (m_pWinType && m_pWinType->m_pCIExpContainer && m_pWinType->m_pCIExpContainer->m_pWebBrowserApp)
    {
        // Get the URL of the current topic.
        m_pWinType->m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL(&url); //Urg there is no error return!!!
        if (!url.IsEmpty())
        {
            //--- Save the URL before we normalize it.
            m_pszCurrentUrl = new TCHAR[url.strlen()+1] ;
            _tcscpy(m_pszCurrentUrl,url.psz) ;

            // Nomalize the URL
            NormalizeUrlInPlace(url) ;

            // Use the url to get a CExTitle pointer.
            bool bFoundTitle = false;   // Did we find a title?
            CExTitle *pTitle = NULL ;
            HRESULT hr = m_pTitleCollection->URL2ExTitle(m_pszCurrentUrl, &pTitle);
            if (SUCCEEDED(hr) && pTitle)
            {
                // Use the pTitle to get the topic number.
                //TOC_TOPIC topic ; // Don't need
                DWORD topicnumber;
                hr = pTitle->URL2Topic(url, NULL/*&topic*/, &topicnumber);
                if (SUCCEEDED(hr))
                {
                    // Now that we have a topic number we can get the location string.
                    WCHAR wszCurrentTopic[MAX_PATH] ;
                    hr = pTitle->GetTopicName(topicnumber, wszCurrentTopic, (MAX_PATH/2)) ;
                    if (SUCCEEDED(hr))
                    {
                        // Yea, we finally have a location
                        W_SetWindowText(m_aDlgItems[c_CurrentTopicEdit].m_hWnd, wszCurrentTopic) ;

                        // We have found the title!
                        bFoundTitle = true ;
                    }
                }
            }
            // We have not found the title. Maybe its a web site.
            if (!bFoundTitle)
            {
                ASSERT(m_pszCurrentUrl) ;
                // convert URL to wide...
                CWStr wurl(url) ;
                ASSERT(wurl.pw) ;
                // So put he normalized URL into the edit control.
                W_SetWindowText(m_aDlgItems[c_CurrentTopicEdit].m_hWnd, wurl.pw) ;
            }

        }
    }

}

///////////////////////////////////////////////////////////
//
// Get the selected item
//
CBookmarksNavPane::GetSelectedItem() const
{
    int indexSelected = -1 ;
    int selections = W_ListView_GetSelectedCount(m_aDlgItems[c_TopicsList].m_hWnd) ;
    if (selections > 0)
    {
        ASSERT(selections == 1) ;
        indexSelected = W_ListView_GetNextItem(m_aDlgItems[c_TopicsList].m_hWnd, -1, LVNI_SELECTED) ;
    }
    return indexSelected ;
}

///////////////////////////////////////////////////////////
//
// Get the Url for the item
//
TCHAR*
CBookmarksNavPane::GetUrl(int index) const
{
    TCHAR* pReturn = NULL ;
    if ((index >= 0) && (index < W_ListView_GetItemCount(m_aDlgItems[c_TopicsList].m_hWnd)))
    {
        LV_ITEMW item ;
        item.mask    = LVIF_PARAM;
        item.iItem     = index;
        item.iSubItem  = 0;
        item.lParam    = NULL;
        W_ListView_GetItem(m_aDlgItems[c_TopicsList].m_hWnd, &item) ;
        pReturn = (TCHAR*)item.lParam ;
    }
    return pReturn ;
}

///////////////////////////////////////////////////////////
//
// Get the URL and the Topic name.
//
bool
CBookmarksNavPane::GetTopicAndUrl(
      int index,                //[in] Index
      WCHAR* pTopicBuffer,      //[in] Buffer for the topic.
      int TopicBufferSize,      //[in] Size of the topic buffer.
      TCHAR** pUrl              //[out] Pointer to Url.
) const
{
    bool bReturn = false ;
    if ((index >= 0) && (index < W_ListView_GetItemCount(m_aDlgItems[c_TopicsList].m_hWnd)))
    {
        LV_ITEMW item ;
        item.mask    = LVIF_PARAM | LVIF_TEXT ;
        item.iItem     = index;
        item.iSubItem  = 0;
        item.lParam    = NULL ;
        item.pszText    = pTopicBuffer;
        item.cchTextMax = TopicBufferSize ;
        if (W_ListView_GetItem(m_aDlgItems[c_TopicsList].m_hWnd, &item))
        {
            *pUrl = (TCHAR*)item.lParam ;
            ASSERT(*pUrl) ;

            if (*pUrl)             //TODO: Validate pTopicBuffer ;
            {
                bReturn = true;
            }
        }
        else
        {
            bReturn = false ;
        }
    }
    return bReturn ;
}

///////////////////////////////////////////////////////////
//
// ContextMenu
//
void
CBookmarksNavPane::ContextMenu(bool bUseCursor)
{
    // Create the menu.
    HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDM_BOOKMARKS_OPTIONS_MENU)) ;
    ASSERT(hMenu) ;

    // Get the Popup Menu
    HMENU hPopupMenu = GetSubMenu(hMenu, 0) ;

    // Is an item selected?
    int bState ;

    int selection = GetSelectedItem() ;
    if (selection < 0)
    {
        // Nothing selected.
        bState = MF_GRAYED ;
    }
    else
    {
        bState = MF_ENABLED ;
    }

    // Set state of menu items.
    EnableMenuItem(hPopupMenu, IDC_BOOKMARKS_DELETE_BTN,    MF_BYCOMMAND  | bState) ;
    EnableMenuItem(hPopupMenu, IDC_BOOKMARKS_DISPLAY_BTN,   MF_BYCOMMAND  | bState ) ;
    EnableMenuItem(hPopupMenu, IDC_BOOKMARKS_EDIT_BTN,      MF_BYCOMMAND  | bState) ;

    // Always enabled.
    EnableMenuItem(hPopupMenu, IDC_BOOKMARKS_ADDBOOKMARK_BTN,      MF_BYCOMMAND  | MF_ENABLED) ;

    // Set the style of the menu.
    DWORD style = TPM_LEFTALIGN  | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RETURNCMD | TPM_RIGHTBUTTON;

    //--- Get the location to display the menu
    POINT pt ;
    if (bUseCursor)
    {
        // Use the mouse cursor position.
        GetCursorPos(&pt) ;
    }
    else
    {
        // Use the upper right of the client area. Probably invoked by shift-F10
        RECT rc;
        GetClientRect(m_aDlgItems[c_TopicsList].m_hWnd, &rc) ; //REVIEW: Upper corner should always be 0,0. Remove?
        pt.x = rc.left;
        pt.y = rc.top ;
        ClientToScreen(m_aDlgItems[c_TopicsList].m_hWnd, &pt);
    }

    // Display the menu.
    int iCmd = TrackPopupMenuEx(hPopupMenu,
                                style ,
                                pt.x, pt.y,
                                m_hWnd,
                                NULL) ;

    // Act on the item.
    if (iCmd != 0)
    {
        OnCommand(m_hWnd, iCmd, BN_CLICKED, NULL);
    }

    // Cleanup
    DestroyMenu(hMenu) ;
}

///////////////////////////////////////////////////////////
//
//                  Message Handlers
//
///////////////////////////////////////////////////////////
//
// OnDelete
//
void
CBookmarksNavPane::OnDelete()
{
    int indexSelected = GetSelectedItem() ;
   HWND hwndFocus = ::GetFocus();
   BOOL bDeletedLast = FALSE;
    if (indexSelected >= 0)
    {
        TCHAR* pUrl = GetUrl(indexSelected) ;
        ASSERT(pUrl) ;
        if (pUrl)
        {
            // Delete the attached url.
            delete [] pUrl ;
        }

        // Delete the item
        BOOL b = W_ListView_DeleteItem(m_aDlgItems[c_TopicsList].m_hWnd, indexSelected) ;
        ASSERT(b) ;
        // Set changed flag.
        SetChanged() ;
        // Select the item below the one we just deleted.
        int items = W_ListView_GetItemCount(m_aDlgItems[c_TopicsList].m_hWnd) ;
        if (items > 0)
        {
            if (indexSelected >= items)
            {
                indexSelected = items-1 ;
            }

            // The following should never happen, but its better safe in beta2...
            if (indexSelected < 0)
            {
                ASSERT(indexSelected < 0) ;
                indexSelected = 0 ;
            }
            W_ListView_SetItemState(m_aDlgItems[c_TopicsList].m_hWnd, indexSelected, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED) ;
        }
      else
         bDeletedLast = TRUE;

    }
   if (bDeletedLast == TRUE)
      ::SetFocus(m_aDlgItems[c_AddBookmarkBtn].m_hWnd);
   else
      if (hwndFocus != m_aDlgItems[c_TopicsList].m_hWnd)
         ::SetFocus(hwndFocus);

}

///////////////////////////////////////////////////////////
//
// OnDisplay
//
void
CBookmarksNavPane::OnDisplay()
{

    // Get the selected URL.
    TCHAR* pUrl = GetSelectedUrl() ;
    if (pUrl)
    {
        // Change to this URL.
        ChangeHtmlTopic(pUrl, m_hWnd, 0);
    }
}

///////////////////////////////////////////////////////////
//
// OnAddBookmark
//
void
CBookmarksNavPane::OnAddBookmark()
{

    int len = W_GetTextLengthExact(m_aDlgItems[c_CurrentTopicEdit].m_hWnd) ;
    if (len > 0)
    {
        // Get the string from the edit control
        WCHAR* pCurrentTopicTitle = new WCHAR[len+1] ;
        W_GetWindowText(m_aDlgItems[c_CurrentTopicEdit].m_hWnd, pCurrentTopicTitle, len+1) ;

        //--- Copy the URL.
        ASSERT(m_pszCurrentUrl) ;
        TCHAR* pszUrl = new TCHAR[_tcslen(m_pszCurrentUrl)+1] ;
        _tcscpy(pszUrl, m_pszCurrentUrl) ;

        //--- Add the string to the listview.
        LV_ITEMW item;
        item.mask      = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
        item.iImage    = 0;
        item.state     = LVIS_FOCUSED | LVIS_SELECTED;
        item.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        item.iItem     = 0 ;
        item.iSubItem  = 0;
        item.lParam    = (LPARAM)pszUrl;
        item.pszText    = pCurrentTopicTitle ;
        int i = W_ListView_InsertItem( m_aDlgItems[c_TopicsList].m_hWnd, &item );

        //Setfocus to list view
        SetFocus(m_aDlgItems[c_TopicsList].m_hWnd) ;

        // Cleanup
        delete [] pCurrentTopicTitle ;

        // Set changed flag.
        SetChanged() ;
    }

}

///////////////////////////////////////////////////////////
//
// OnEdit - Handles the edit menu item.
//
void
CBookmarksNavPane::OnEdit()
{
    // Edit the currently selected item.
    int selection = GetSelectedItem() ;
    if (selection >=0)
    {
        W_ListView_EditLabel(m_aDlgItems[c_TopicsList].m_hWnd, selection) ;

        // Set changed flag.
        SetChanged() ;
    }
}

///////////////////////////////////////////////////////////
//
// OnTab - Handles pressing of the tab key.
//
void
CBookmarksNavPane::OnTab(HWND hwndReceivedTab, BookmarkDlgItemInfoIndex  /*index*/)
{
    //if (index == c_NumDlgItems) --- caller doesn't know the index.
    ASSERT(::IsValidWindow(hwndReceivedTab)) ;

    //--- Is the shift key down?
    BOOL bPrevious = (GetKeyState(VK_SHIFT) < 0) ;
    {
        //--- Move to the next control .
        // Get the next tab item.
        HWND hWndNext = GetNextDlgTabItem(m_hWnd, hwndReceivedTab, bPrevious) ;
        // Set focus to it.
        ::SetFocus(hWndNext) ;
    }
}

///////////////////////////////////////////////////////////
//
// OnArrow
//
void
CBookmarksNavPane::OnArrow(HWND hwndReceivedTab, BookmarkDlgItemInfoIndex  /*index*/, INT_PTR key)
{
    //if (index == c_NumDlgItems) --- caller doesn't know the index.

    ASSERT(::IsValidWindow(hwndReceivedTab)) ;

    BOOL bPrevious = FALSE ;
    if (key == VK_LEFT || key == VK_UP)
    {
        bPrevious = TRUE ;
    }

    // Get the next tab item.
    HWND hWndNext = GetNextDlgGroupItem(m_hWnd, hwndReceivedTab, bPrevious) ;
    // Set focus to it.
    ::SetFocus(hWndNext) ;
}

///////////////////////////////////////////////////////////
//
// OnReturn - Default handling of the return key.
//
bool
CBookmarksNavPane::OnReturn(HWND hwndReceivedTab, BookmarkDlgItemInfoIndex  /*index*/)
{
    //if (index == c_NumDlgItems) --- caller doesn't know the index.

    // Do the default button action.
    // Always do a search topic, if its enabled.
    if (::IsWindowEnabled(m_aDlgItems[c_DisplayBtn].m_hWnd))
    {
        OnDisplay();
        return true ;
    }
    else
    {
        return false ;
    }

}

///////////////////////////////////////////////////////////
//
// ListViewMsg
//
LRESULT
CBookmarksNavPane::ListViewMsg(HWND hwnd, NM_LISTVIEW* lParam)
{
   switch(lParam->hdr.code)
   {
      case NM_DBLCLK:
      case NM_RETURN:
            OnDisplay() ;
         break;

        case NM_RCLICK:
            ContextMenu() ;
            break ;

        case LVN_ITEMCHANGED:
            {
                bool bEnable = GetSelectedItem() >= 0 ;
                EnableDlgItem(c_DisplayBtn, bEnable) ;
                EnableDlgItem(c_DeleteBtn, bEnable) ;
            }
            break ;
        case LVN_BEGINLABELEDITA:
        case LVN_BEGINLABELEDITW:
            /*
            //ListView_GetEditControl();
            //LimitText;
            */
            return FALSE ;
        case LVN_ENDLABELEDITA:
        case LVN_ENDLABELEDITW:
            {
                LV_DISPINFOW* pDispInfo = (LV_DISPINFOW*)lParam ;
                if (pDispInfo->item.iItem != -1 &&
                    pDispInfo->item.pszText &&
                    lstrlenW(pDispInfo->item.pszText) > 0)
                {
					if(g_fUnicodeListView)
					{
						W_ListView_SetItemText(m_aDlgItems[c_TopicsList].m_hWnd,
                            pDispInfo->item.iItem,
                            0,
                            pDispInfo->item.pszText) ;
					}
					else
					{
						ListView_SetItemText(m_aDlgItems[c_TopicsList].m_hWnd,
                            pDispInfo->item.iItem,
                            0,
                            (char *)pDispInfo->item.pszText) ;
					}

                    // Set changed flag.
                    SetChanged() ;

                    return TRUE ; // Accept Edit
                }
            }
            break ;
   }
   return 0;
}
///////////////////////////////////////////////////////////
//
//              Callback Functions.
//
///////////////////////////////////////////////////////////
//
// Static DialogProc
//
INT_PTR CALLBACK
CBookmarksNavPane::s_DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Call member function dialog proc.
    if (msg == WM_INITDIALOG)
    {
        // The lParam is the this pointer for this dialog box.
        // Save it in the window userdata section.
        ::SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
    }

    // Get the this pointer and call the non-static callback function.
    CBookmarksNavPane* p = reinterpret_cast<CBookmarksNavPane*>(::GetWindowLongPtr(hwnd, GWLP_USERDATA)) ;
    if (p)
    {
        return p->DialogProc(hwnd, msg, wParam, lParam) ;
    }
    else
    {
        return FALSE ;
    }
}

///////////////////////////////////////////////////////////
//
// ListViewProc
//
LRESULT WINAPI
CBookmarksNavPane::s_ListViewProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CBookmarksNavPane* pThis = reinterpret_cast<CBookmarksNavPane*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (msg)
    {
        case WM_KEYDOWN:
            if (wParam == VK_RETURN)
            {
                // A return means that we want to display the currently selected topic.
                pThis->OnDisplay() ; //Todo: Should this be a send message?
                return 0 ;
            }
            else if (wParam == VK_TAB)
            {
                pThis->OnTab(hwnd, c_TopicsList) ;
            }
            else if (wParam == VK_F2)
            {
                pThis->OnEdit() ;
                return 0 ;
            }
            break ;
        case WM_SYSKEYDOWN:
            if (wParam == VK_F10 && (GetKeyState(VK_SHIFT) < 0)) // SHIFT-F10
            {
                pThis->ContextMenu(false) ;
                return 0 ;
            }
            break;
    }
    return W_DelegateWindowProc(s_lpfnlListViewWndProc, hwnd, msg, wParam, lParam);
}

///////////////////////////////////////////////////////////
//
//  KeywordComboEditProc - Subclassed the Edit Control in the Keyword Combo Box
// The original reason for doing this was to save the selection location.
//
LRESULT WINAPI
CBookmarksNavPane::s_CurrentTopicEditProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CBookmarksNavPane* pThis = reinterpret_cast<CBookmarksNavPane*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (msg)
    {
    case WM_KEYDOWN:
        if (wParam == VK_TAB)
        {
            pThis->OnTab(hwnd,c_CurrentTopicEdit) ;
            return 0 ;
        }
        else if (wParam == VK_RETURN)
        {
            pThis->OnAddBookmark();
        }
        break;

    case WM_CHAR:
        if (wParam == VK_TAB)
        {
            //Stops the beep!
            return 0 ;
        }
    }
    return W_DelegateWindowProc(s_lpfnlCurrentTopicEditProc, hwnd, msg, wParam, lParam);
}


///////////////////////////////////////////////////////////
//
// Generic keyboard handling for all btns.
//
LRESULT WINAPI
CBookmarksNavPane::s_GenericBtnProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_KEYDOWN:
            if (wParam == VK_RETURN)
            {
                // Do the command associated with this btn.
                CBookmarksNavPane* pThis = reinterpret_cast<CBookmarksNavPane*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
                return pThis->OnCommand(pThis->m_hWnd, ::GetDlgCtrlID(hwnd), BN_CLICKED, lParam) ; // TODO: Should this be a sendmessage?
            }
            else if (wParam == VK_TAB)
            {
                CBookmarksNavPane* pThis = reinterpret_cast<CBookmarksNavPane*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
                pThis->OnTab(hwnd,c_NumDlgItems) ;
                return 0 ;
            }
            else if (wParam == VK_LEFT ||
                    wParam == VK_RIGHT ||
                    wParam == VK_UP ||
                    wParam == VK_DOWN)
            {
                CBookmarksNavPane* pThis = reinterpret_cast<CBookmarksNavPane*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
                pThis->OnArrow(hwnd,c_NumDlgItems, wParam) ;
                return 0 ;
            }
            break;
    }
    return W_DelegateWindowProc(s_lpfnlGenericBtnProc, hwnd, msg, wParam, lParam);
}



///////////////////////////////////////////////////////////
//
// DialogProc
//
INT_PTR
CBookmarksNavPane::DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
    case WM_COMMAND:
        return OnCommand(hwnd, LOWORD(wParam), HIWORD(wParam), lParam) ;
        break ;
    case WM_NOTIFY:
        return OnNotify(hwnd, wParam, lParam)  ;
    case WM_INITDIALOG:
        break;
    case WM_SHOWWINDOW:
        {
            BOOL bActive = (BOOL) wParam ;
            if (bActive)
            {
                FillCurrentTopicEdit() ;
            }
        }
        break ;
    case WM_ACTIVATE:
        {
            int active = LOWORD(wParam) ;
            if (active != WA_INACTIVE)
            {
                FillCurrentTopicEdit() ;
            }
        }
        break ;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\bookmark.h ===
#ifndef __BOOKMARK_H__
#define __BOOKMARK_H__
///////////////////////////////////////////////////////////
//
//
// AdSearch.h - Advanced Search UI
//
// This header file defines the Advanced Search Navigation
// pane class.

// INavPaneUI Interface
#include "navui.h"

// Other nav pane related structures.
#include "navpane.h"

///////////////////////////////////////////////////////////
//
// Forwards
//

///////////////////////////////////////////////////////////
//
// Constants
//


///////////////////////////////////////////////////////////
//
// CBookmarksNavPane
//
class CBookmarksNavPane : public INavUI
{
public:
    //---Construction
    CBookmarksNavPane(CHHWinType* pWinType);
    virtual ~CBookmarksNavPane() ;

    typedef enum BookmarkDlgItemInfoIndex
    {
        c_TopicsList,    // The Bookmarks list view.
        c_DeleteBtn,
        c_DisplayBtn,
        c_CurrentTopicStatic,
        c_CurrentTopicEdit,
        c_AddBookmarkBtn,

        c_NumDlgItems
    };

public:
    //--- INavUI Interface functions.
   virtual BOOL Create(HWND hwndParent);
   virtual LRESULT OnCommand(HWND hwnd, UINT id, UINT uNotifiyCode, LPARAM lParam);
   virtual void ResizeWindow();
   virtual void HideWindow() ;
   virtual void ShowWindow() ;
   virtual void SetPadding(int pad) ;
   virtual void SetTabPos(int tabpos) ;

    // Set focus to the most expected control, usually edit combo.
    virtual void SetDefaultFocus() ;

    // Process accelerator keys.
    virtual bool ProcessMenuChar(HWND hwndParent, int ch) ;

    // Process WM_NOTIFY messages. Used by embedded Tree and List view controls.
    virtual LRESULT  OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam) ;

    // Process WM_DRAWITEM messages.
    virtual void OnDrawItem(UINT id, LPDRAWITEMSTRUCT pdis) ;

    // Seed the nav ui with a search term or keyword.
    virtual void Seed(LPCSTR pszSeed) ;

    virtual BOOL Synchronize(PSTR , CTreeNode* ) ;

    void OnVKListNotify(NMHDR* pNMHdr) {/*Not Implemented*/}

private:
    //--- Helper Functions.
    void    SetFont (HFONT hfont) { m_hfont = hfont; }
    void    SaveBookmarks() ;
    void    LoadBookmarks() ;

    void    InitDlgItemArray() ;

    // Fill the edit control with the current topic.
    void    FillCurrentTopicEdit() ;

    // Get the selected item
    int     GetSelectedItem() const ;

    // Get the Url for the item;
    TCHAR*  GetUrl(int index) const;

    // Get the URL for the selected item
    TCHAR*  GetSelectedUrl() const {return GetUrl(GetSelectedItem()) ;}

    // Get the URL and the Topic name. --- See CPP file for more information.
    bool    GetTopicAndUrl(int index, WCHAR* pTopicBuffer,int TopicBufferSize, TCHAR** pUrl) const ;

    // Display the context menu.
    void    ContextMenu(bool bUseCursor = true) ;

    //--- Dirty Management.
    bool Changed() const {return m_bChanged; }
    void SetChanged(bool changed = true) {m_bChanged = changed;}

    //--- Share with AdSearch???
    void    ShowDlgItemsEnabledState() ;
    void    EnableDlgItem(BookmarkDlgItemInfoIndex index, bool bEnabled) ;

    HFONT GetFont() { return m_pWinType->GetContentFont(); }
    HFONT GetAccessableContentFont() { return m_pWinType->GetAccessableContentFont(); }

protected:
    //--- Message Handler Functions
    void    OnDelete() ;
    void    OnDisplay() ;
    void    OnAddBookmark();
    void    OnEdit() ; // Edit menu item.

    void    OnTab(HWND hwndReceivedTab, BookmarkDlgItemInfoIndex index) ;
    void    OnArrow(HWND hwndReceivedTab, BookmarkDlgItemInfoIndex index, INT_PTR key) ;
    bool    OnReturn(HWND hwndReceivedTab, BookmarkDlgItemInfoIndex /*index*/);

    LRESULT ListViewMsg(HWND hwnd, NM_LISTVIEW* lParam) ; // Handle the listview notification messages.

private:
    //--- Callbacks
    static INT_PTR CALLBACK s_DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) ;
    INT_PTR DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) ;
    static LRESULT WINAPI s_ListViewProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT WINAPI s_CurrentTopicEditProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // shared by all btns.
    static LRESULT WINAPI s_GenericBtnProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // shared by other ctrls to handle keyboard
    //static LRESULT WINAPI s_GenericKeyboardProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

protected:
    //--- Statics
    static WNDPROC s_lpfnlListViewWndProc;
    static WNDPROC s_lpfnlCurrentTopicEditProc;
    static WNDPROC s_lpfnlGenericBtnProc ; // Shared by all btns.
    static WNDPROC s_lpfnlGenericKeyboardProc ; // Shared by ctrls which don't use one of the other procs.

private:
    //--- Member Functions.
    HWND        m_hWnd;
    HFONT    m_hfont;    // author-specified font to use for child windows
    int      m_padding;
    int      m_NavTabPos;   // location of parent tabs

    // Array of dlgitems
    CDlgItemInfo m_aDlgItems[c_NumDlgItems] ;

    // Pointer to the TitleCollection on which we will search.
    CExCollection* m_pTitleCollection;

    // Holds a pointer to the wintype so we can send the WMP_HH_TAB_KEY message to it.
    CHHWinType* m_pWinType;

    // The URL corresponding to the topic in the edit control.
    TCHAR* m_pszCurrentUrl;

    // If this is true we should save the bookmarks.
    bool m_bChanged ;
};

#endif //__BOOKMARK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\autoobj.cpp ===
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.

// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown, dispatch and
// error info implementations for them.

#include "header.h"
#include "AutoObj.H"

#ifndef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

//=--------------------------------------------------------------------------=
// CAutomationObject::CAutomationObject
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//	  IUnknown *	  - [in] controlling Unknown
//	  int			  - [in] the object type that we are
//	  void *		  - [in] the VTable of of the object we really are.

CAutomationObject::CAutomationObject(IUnknown *pUnkOuter, int ObjType, void *pVTable)
	: CUnknownObject(pUnkOuter, pVTable), m_ObjectType (ObjType)
{
	m_fLoadedTypeInfo = FALSE;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::~CAutomationObject
//=--------------------------------------------------------------------------=

CAutomationObject::~CAutomationObject ()
{
	// if we loaded up a type info, release our count on the globally stashed
	// type infos, and release if it becomes zero.

	if (m_fLoadedTypeInfo) {

		// we have to crit sect this since it's possible to have more than
		// one thread partying with this object.

		// EnterCriticalSection(&g_CriticalSection);
		ASSERT_COMMENT(CTYPEINFOOFOBJECT(m_ObjectType), "Bogus ref counting on the Type Infos");
		CTYPEINFOOFOBJECT(m_ObjectType)--;

		// if we're the last one, free that sucker!

		if (!CTYPEINFOOFOBJECT(m_ObjectType)) {
			PTYPEINFOOFOBJECT(m_ObjectType)->Release();
			PTYPEINFOOFOBJECT(m_ObjectType) = NULL;
		}
		// LeaveCriticalSection(&g_CriticalSection);
	}

	return;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// the controlling unknown will call this for us in the case where they're
// looking for a specific interface.
//
// Parameters:
//	  REFIID		- [in]	interface they want
//	  void **		- [out] where they want to put the resulting object ptr.
//
// Output:
//	  HRESULT		- S_OK, E_NOINTERFACE

HRESULT CAutomationObject::InternalQueryInterface(REFIID riid, void **ppvObjOut)
{
#if 0
	ASSERT_COMMENT(ppvObjOut, "controlling Unknown should be checking this!");

	return E_NOTIMPL;
#endif

	// start looking for the guids we support, namely IDispatch, and the

	if (DO_GUIDS_MATCH(riid, IID_IDispatch)) {
		*ppvObjOut = (void *)(IDispatch *)m_pvInterface;
		((IUnknown *)(*ppvObjOut))->AddRef();
		return S_OK;
	}

	// just get our parent class to process it from here on out.

	return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfoCount
//=--------------------------------------------------------------------------=
// returns the number of type information interfaces that the object provides
//
// Parameters:
//	  UINT *			- [out] the number of interfaces supported.
//
// Output:
//	  HRESULT			- S_OK, E_NOTIMPL, E_INVALIDARG

STDMETHODIMP CAutomationObject::GetTypeInfoCount(UINT *pctinfo)
{
	if (!pctinfo)
		return E_INVALIDARG;

	*pctinfo = 1;
	return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfo
//=--------------------------------------------------------------------------=
// Retrieves a type information object, which can be used to get the type
// information for an interface.
//
// Parameters:
//	  UINT				- [in]	the type information they'll want returned
//	  LCID				- [in]	the LCID of the type info we want
//	  ITypeInfo **		- [out] the new type info object.
//
// Output:
//	  HRESULT			- S_OK, E_INVALIDARG, etc.
//
// Notes:
//

STDMETHODIMP CAutomationObject::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **ppTypeInfoOut)
{
	DWORD		dwPathLen;
	char		szDllPath[MAX_PATH];
	HRESULT 	hr;
	ITypeLib   *pTypeLib;
	ITypeInfo **ppTypeInfo =NULL;

	// arg checking

	if (itinfo != 0)
		return DISP_E_BADINDEX;

	if (!ppTypeInfoOut)
		return E_POINTER;

	*ppTypeInfoOut = NULL;

	// ppTypeInfo will point to our global holder for this particular
	// type info.  if it's null, then we have to load it up. if it's not
	// NULL, then it's already loaded, and we're happy.
	// crit sect this entire nightmare so we're okay with multiple
	// threads trying to use this object.

	// EnterCriticalSection(&g_CriticalSection);
	ppTypeInfo = PPTYPEINFOOFOBJECT(m_ObjectType);

	if (*ppTypeInfo == NULL) {

		ITypeInfo *pTypeInfoTmp;
		HREFTYPE   hrefType;

		// we don't have the type info around, so go load the sucker.
		//
		hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 0,
							LANG_NEUTRAL, &pTypeLib);

		// if, for some reason, we failed to load the type library this
		// way, we're going to try and load the type library directly out of
		// our resources.  this has the advantage of going and re-setting all
		// the registry information again for us.

		if (FAILED(hr)) {

			dwPathLen = GetModuleFileName(_Module.GetModuleInstance(), szDllPath, MAX_PATH);
			if (!dwPathLen) {
				hr = E_FAIL;
				goto CleanUp;
			}

			MAKE_WIDEPTR_FROMANSI(pwsz, szDllPath);
			hr = LoadTypeLib(pwsz, &pTypeLib);
			CLEANUP_ON_FAILURE(hr);
		}

		// we've got the Type Library now, so get the type info for the interface
		// we're interested in.
		//
		hr = pTypeLib->GetTypeInfoOfGuid((REFIID)INTERFACEOFOBJECT(m_ObjectType), &pTypeInfoTmp);
		pTypeLib->Release();
		CLEANUP_ON_FAILURE(hr);

		// the following couple of lines of code are to dereference the dual
		// interface stuff and take us right to the dispatch portion of the
		// interfaces.
		//
		hr = pTypeInfoTmp->GetRefTypeOfImplType(0xffffffff, &hrefType);
		if (FAILED(hr)) {
			pTypeInfoTmp->Release();
			goto CleanUp;
		}

		hr = pTypeInfoTmp->GetRefTypeInfo(hrefType, ppTypeInfo);
		pTypeInfoTmp->Release();
		CLEANUP_ON_FAILURE(hr);

		// add an extra reference to this object.  if it ever becomes zero, then
		// we need to release it ourselves.  crit sect this since more than
		// one thread can party on this object.
		//
		CTYPEINFOOFOBJECT(m_ObjectType)++;
		m_fLoadedTypeInfo = TRUE;
	}


	// we still have to go and addref the Type info object, however, so that
	// the people using it can release it.
	//
	(*ppTypeInfo)->AddRef();
	*ppTypeInfoOut = *ppTypeInfo;
	hr = S_OK;

CleanUp:
	// LeaveCriticalSection(&g_CriticalSection);
	return hr;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetIDsOfNames
//=--------------------------------------------------------------------------=
// Maps a single member and an optional set of argument names to a
// corresponding set of integer DISPIDs
//
// Parameters:
//	  REFIID			- [in]	must be IID_NULL
//	  OLECHAR **		- [in]	array of names to map.
//	  UINT				- [in]	count of names in the array.
//	  LCID				- [in]	LCID on which to operate
//	  DISPID *			- [in]	place to put the corresponding DISPIDs.
//
// Output:
//	  HRESULT			- S_OK, E_OUTOFMEMORY, DISP_E_UNKNOWNNAME,
//						  DISP_E_UNKNOWNLCID
//
// Notes:
//	  - we're just going to use DispGetIDsOfNames to save us a lot of hassle,
//		and to let this superclass handle it.
//
STDMETHODIMP CAutomationObject::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
	HRESULT 	hr;
	ITypeInfo  *pTypeInfo;

	if (!DO_GUIDS_MATCH(riid, IID_NULL))
		return E_INVALIDARG;

	hr = GetTypeInfo(0, lcid, &pTypeInfo);
	RETURN_ON_FAILURE(hr);

	// use the standard provided routines to do all the work for us.

	hr = pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
	pTypeInfo->Release();

	return hr;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::Invoke
//=--------------------------------------------------------------------------=
// provides access to the properties and methods on this object.
//
// Parameters:
//	  DISPID			- [in]	identifies the member we're working with.
//	  REFIID			- [in]	must be IID_NULL.
//	  LCID				- [in]	language we're working under
//	  USHORT			- [in]	flags, propput, get, method, etc ...
//	  DISPPARAMS *		- [in]	array of arguments.
//	  VARIANT * 		- [out] where to put result, or NULL if they don't care.
//	  EXCEPINFO *		- [out] filled in in case of exception
//	  UINT *			- [out] where the first argument with an error is.
//
// Output:
//	  HRESULT			- tonnes of them.

STDMETHODIMP CAutomationObject::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD		  wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
	HRESULT    hr;
	ITypeInfo *pTypeInfo;

	if (!DO_GUIDS_MATCH(riid, IID_NULL))
		return E_INVALIDARG;

	// get our typeinfo first!
	//
	hr = GetTypeInfo(0, lcid, &pTypeInfo);
	RETURN_ON_FAILURE(hr);

	// Clear exceptions

	SetErrorInfo(0L, NULL);

	// This is exactly what DispInvoke does--so skip the overhead.

	hr = pTypeInfo->Invoke(m_pvInterface, dispid, wFlags,
						   pdispparams, pvarResult,
						   pexcepinfo, puArgErr);
	pTypeInfo->Release();
	return hr;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::Exception
//=--------------------------------------------------------------------------=
// fills in the rich error info object so that both our vtable bound interfaces
// and calls through ITypeInfo::Invoke get the right error informaiton.
//
// Parameters:
//	  HRESULT		   - [in] the SCODE that should be associated with this err
//	  WORD			   - [in] the RESOURCE ID of the error message.
//	  DWORD 		   - [in] helpcontextid for the error
//
// Output:
//	  HRESULT		   - the HRESULT that was passed in.

HRESULT CAutomationObject::Exception(HRESULT hrExcep, WORD idException, DWORD dwHelpContextID)
{
	ICreateErrorInfo *pCreateErrorInfo;
	IErrorInfo *pErrorInfo;
	HRESULT hr;

	// first get the createerrorinfo object.

	hr = CreateErrorInfo(&pCreateErrorInfo);
	if (FAILED(hr)) return hrExcep;

	MAKE_WIDEPTR_FROMANSI(wszHelpFile, HELPFILEOFOBJECT(m_ObjectType));

	// set up some default information on it.
	//
	pCreateErrorInfo->SetGUID((REFIID)INTERFACEOFOBJECT(m_ObjectType));
	pCreateErrorInfo->SetHelpFile(wszHelpFile);
	pCreateErrorInfo->SetHelpContext(dwHelpContextID);

	// load in the actual error string value.  max of 256.

	CWStr cwzError(GetStringResource(idException));
	pCreateErrorInfo->SetDescription(cwzError);

	// load in the source

	cwzError = NAMEOFOBJECT(m_ObjectType);
	pCreateErrorInfo->SetSource(cwzError);

	// now set the Error info up with the system

	hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void **)&pErrorInfo);
	CLEANUP_ON_FAILURE(hr);

	SetErrorInfo(0, pErrorInfo);
	pErrorInfo->Release();

CleanUp:
	pCreateErrorInfo->Release();
	return hrExcep;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
// indicates whether or not the given interface supports rich error information
//
// Parameters:
//	  REFIID		- [in] the interface we want the answer for.
//
// Output:
//	  HRESULT		- S_OK = Yes, S_FALSE = No.

HRESULT CAutomationObject::InterfaceSupportsErrorInfo(REFIID riid)
{
	// see if it's the interface for the type of object that we are.

	if (riid == (REFIID)INTERFACEOFOBJECT(m_ObjectType))
		return S_OK;

	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\autocont.cpp ===
// Copyright (C) 1996 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "autocont.h"
#include <exdispid.h>
#include <exdisp.h>
#include "resource.h"
#include "system.h"

#include "highlite.h"
// make Don's stuff work
#ifdef HHCTRL
#include "parserhh.h"
#else
#include "parser.h"
#endif
#include "collect.h"
#include "hhtypes.h"
//#include "toc.h"

#define NDEF_AUTOMATIONOBJECTINFO
#include "secwin.h"

#include "hhfinder.h"

// from IE4 version of exdispid.h
//
#define DISPID_DOCUMENTCOMPLETE     259   // new document goes ReadyState_Complete
#define DISPID_BEFORENAVIGATE2      250   // hyperlink clicked on
#define DISPID_NAVIGATECOMPLETE2    252   // UIActivate new document

#include "wwheel.h"

#ifndef DISPID_DOCUMENTCOMPLETE
#define DISPID_DOCUMENTCOMPLETE     259   // new document goes ReadyState_Complete
#endif

CAutomateContent::CAutomateContent(CContainer * pOuter) : CUnknownObject(pOuter)
{
    m_pOuter = pOuter;
    m_cRef = 0;
    m_fLoadedTypeInfo = FALSE;
    m_bFirstTime = TRUE;
//    m_pPrintHook = NULL;
}

CAutomateContent::~CAutomateContent()
{
//    if (m_pPrintHook != NULL)
//        delete m_pPrintHook;
}

// aggregating IUnknown methods

STDMETHODIMP CAutomateContent::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (m_pOuter)
        return m_pOuter->QueryInterface(riid,ppv);

    if (riid == IID_IUnknown || riid == IID_IDispatch)
    {
        *ppv = (LPVOID)(IDispatch*)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CAutomateContent::AddRef(void)
{
    m_cRef++;

    if (m_pOuter)
        m_pOuter->AddRef();

    return m_cRef;
}

STDMETHODIMP_(ULONG) CAutomateContent::Release(void)
{
    ULONG c = --m_cRef;

    if (m_pOuter)
       m_pOuter->Release();

    if (c <= 0)
       delete this;

    return c;
}

// wrapping IDispatch methods

STDMETHODIMP CAutomateContent::GetTypeInfoCount(UINT* pui)
{
    // arg checking

    if (!pui)
        return E_INVALIDARG;

    // we support GetTypeInfo, so we need to return the count here.

    *pui = 1;
    return S_OK;
}

STDMETHODIMP CAutomateContent::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **ppTypeInfoOut)
{
    // arg checking

    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (!ppTypeInfoOut)
        return E_POINTER;

    *ppTypeInfoOut = NULL;

return E_NOTIMPL;

#if 0
    // ppTypeInfo will point to our global holder for this particular
    // type info.  if it's null, then we have to load it up. if it's not
    // NULL, then it's already loaded, and we're happy.
    // crit sect this entire nightmare so we're okay with multiple
    // threads trying to use this object.

    ITypeInfo** ppTypeInfo = PPTYPEINFOOFOBJECT(m_ObjectType);
    HRESULT hr = E_INVALIDARG;;

    if (*ppTypeInfo == NULL) {

        ITypeInfo *pTypeInfoTmp;
        HREFTYPE   hrefType;

        // we don't have the type info around, so go load the sucker.

        ITypeLib *pTypeLib;
        hr = LoadRegTypeLib(*g_pLibid, (USHORT) VERSIONOFOBJECT(m_ObjectType), 0,
                            LANG_NEUTRAL, &pTypeLib);

        // if, for some reason, we failed to load the type library this
        // way, we're going to try and load the type library directly out of
        // our resources.  this has the advantage of going and re-setting all
        // the registry information again for us.

        if (FAILED(hr)) {
            char szDllPath[MAX_PATH];
            DWORD dwPathLen = GetModuleFileName(_Module.GetModuleInstance(), szDllPath, MAX_PATH);
            if (!dwPathLen) {
                hr = E_FAIL;
                goto CleanUp;
            }

            CWStr cwz(szDllPath);
            hr = LoadTypeLib(cwz, &pTypeLib);
            if (FAILED(hr))
                return hr;
        }

        // we've got the Type Library now, so get the type info for the interface
        // we're interested in.

        hr = pTypeLib->GetTypeInfoOfGuid((REFIID)INTERFACEOFOBJECT(m_ObjectType), &pTypeInfoTmp);
        pTypeLib->Release();
        if (FAILED(hr))
            return hr;

        // the following couple of lines of code are to dereference the dual
        // interface stuff and take us right to the dispatch portion of the
        // interfaces.
        //
        hr = pTypeInfoTmp->GetRefTypeOfImplType(0xffffffff, &hrefType);
        if (FAILED(hr)) {
            pTypeInfoTmp->Release();
            goto CleanUp;
        }

        hr = pTypeInfoTmp->GetRefTypeInfo(hrefType, ppTypeInfo);
        pTypeInfoTmp->Release();
        if (FAILED(hr))
            return hr;

        // add an extra reference to this object.  if it ever becomes zero, then
        // we need to release it ourselves.  crit sect this since more than
        // one thread can party on this object.
        //
        CTYPEINFOOFOBJECT(m_ObjectType)++;
        m_fLoadedTypeInfo = TRUE;
    }


    // we still have to go and addref the Type info object, however, so that
    // the people using it can release it.
    //
    (*ppTypeInfo)->AddRef();
    *ppTypeInfoOut = *ppTypeInfo;
    hr = S_OK;

CleanUp:
    return hr;
#endif
}

STDMETHODIMP CAutomateContent::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    HRESULT     hr;
    ITypeInfo  *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get the type info for this dude!

    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    if (FAILED(hr))
        return hr;

    // use the standard provided routines to do all the work for us.

    hr = pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    pTypeInfo->Release();

    return hr;
}

// I don't know if this implementation of IDispatch::Invoke() is correct or not,
// but I haven't found anyone or anything that can tell me otherwise.

STDMETHODIMP CAutomateContent::Invoke(DISPID dispid, REFIID riid, LCID lcid,
    WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    char szURL[MAX_URL];
    char szTFN[MAX_URL];
    char szHeaders[MAX_URL];
    UINT uArgErr;
    if( !puArgErr )
      puArgErr = &uArgErr;

    // riid should always be IID_NULL.

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return DISP_E_UNKNOWNINTERFACE;

    // We only have to handle methods (no properties).

    if (!(wFlags & DISPATCH_METHOD))
        return E_INVALIDARG;

    HRESULT hr;
    VARIANTARG varg;

    // Initialize the variants.

    VariantInit(&varg);

#ifdef EXCEPTIONS

21-Sep-1997 [ralphw] Nothing in our code throws an exception, and removing
exception handling cuts down on C runtime usage.

    try
    {
#endif

        // The dispid determines which event has been fired.

        switch (dispid)
        {

      // case DISPID_FRAMEBEFORENAVIGATE:
      // case DISPID_FRAMENAVIGATECOMPLETE:
      // case DISPID_FRAMENEWWINDOW:
      // case DISPID_NEWWINDOW:


      case DISPID_COMMANDSTATECHANGE: {
        OnCommandStateChange(
          (long) pdispparams->rgvarg[1].lVal,      // VT_I4 == long
          (BOOL) pdispparams->rgvarg[0].boolVal ); // VT_BOOL == BOOL
        break;
      }

#if 0
// 31-May-1997  [ralphw] We don't use these

      case DISPID_PROGRESSCHANGE: {
        OnProgressChange(
          (long) pdispparams->rgvarg[1].lVal,   // VT_I4 == long
          (long) pdispparams->rgvarg[0].lVal ); // VT_I4 == long
        break;
      }

      case DISPID_PROPERTYCHANGE: {
        CStr strProperty(pdispparams->rgvarg[0].bstrVal);
        OnPropertyChange(
          (LPCTSTR) strProperty ); // VT_BSTR == LPCTSTR
        break;
      }

      case DISPID_QUIT: {   // also disabled in web.cpp
        OnQuit(
          (BOOL*) pdispparams->rgvarg[0].pboolVal ); // VT_BYREF|VT_BOOL == BOOL*
        break;
      }

      case DISPID_STATUSTEXTCHANGE: {
        CStr strText(pdispparams->rgvarg[0].bstrVal);
        OnStatusTextChange(
          (LPCTSTR) strText ); // VT_BSTR == LPCTSTR
        break;
      }

      case DISPID_DOWNLOADCOMPLETE:  // DownloadComplete
          OnDownloadComplete();
          break;

      case DISPID_DOWNLOADBEGIN: // DownloadBegin
          OnDownloadBegin();
          break;
#endif
      case DISPID_BEFORENAVIGATE2:     // ie4 version.
         WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[5].pvarVal->bstrVal, -1, szURL, sizeof(szURL), NULL, NULL);

         // 27-Sep-1997 [ralphw] IE 4 will send us a script command, followed
         // by a 1 then the current URL. We don't care about the current URL
         // in this case, so we nuke it.
         {
            PSTR pszCurUrl = StrChr(szURL, 1);
            if (pszCurUrl)
                *pszCurUrl = '\0';
         }
         szTFN[0] = 0;
         if( pdispparams->rgvarg[3].pvarVal->bstrVal )
           WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[3].pvarVal->bstrVal, -1, szTFN, sizeof(szTFN), NULL, NULL);
         szHeaders[0] = 0;
         if( pdispparams->rgvarg[1].pvarVal->bstrVal )
           WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[1].pvarVal->bstrVal, -1, szHeaders, sizeof(szHeaders), NULL, NULL);
         OnBeforeNavigate(szURL, (long)pdispparams->rgvarg[4].pvarVal->lVal, szTFN,
                          pdispparams->rgvarg[2].pvarVal, szHeaders, (BOOL*)pdispparams->rgvarg[0].pboolVal );
         break;

      case DISPID_BEFORENAVIGATE:      // ie3 version.
         WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[5].bstrVal, -1, szURL, sizeof(szURL), NULL, NULL);
         WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[3].bstrVal, -1, szTFN, sizeof(szTFN), NULL, NULL);
         WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[1].bstrVal, -1, szHeaders, sizeof(szHeaders), NULL, NULL);
         OnBeforeNavigate(szURL, pdispparams->rgvarg[4].lVal, szTFN, pdispparams->rgvarg[2].pvarVal,
                          szHeaders, (BOOL*)pdispparams->rgvarg[0].pboolVal);
         break;

      case DISPID_NAVIGATECOMPLETE2:       // ie4 version.
          if(g_hsemNavigate)
             ReleaseSemaphore(g_hsemNavigate, 1, NULL);  // signal our navigation semaphore

          WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[0].pvarVal->bstrVal, -1, szURL, sizeof(szURL), NULL, NULL);
          OnNavigateComplete(szURL);
          break;

      case DISPID_NAVIGATECOMPLETE:       // ie3 version.
          if(g_hsemNavigate)
             ReleaseSemaphore(g_hsemNavigate, 1, NULL);  // signal our navigation semaphore

          WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[0].bstrVal, -1, szURL, sizeof(szURL), NULL, NULL);
          OnNavigateComplete(szURL);
          break;

      case DISPID_DOCUMENTCOMPLETE: // DocumentComplete
          OnDocumentComplete();
          break;

      case DISPID_TITLECHANGE:
        {
          hr = DispGetParam(pdispparams, 0, VT_BSTR, &varg, puArgErr);
          if (FAILED(hr))
              return hr;

          CStr strURL(V_BSTR(&varg));
          OnTitleChange((PCSTR)strURL);
          VariantClear(&varg);
        }
        break;
        }
#ifdef EXCEPTIONS
    }
    catch (...)
    {
        if (pexcepinfo != NULL)
        {
            // Fill in the exception struct.
            // The struct should be filled in with more useful information than
            // is found here.
            pexcepinfo->wCode = 1001;
            pexcepinfo->wReserved = 0;
            pexcepinfo->bstrSource = L"";
            pexcepinfo->bstrDescription = NULL;
            pexcepinfo->bstrHelpFile = NULL;
            pexcepinfo->dwHelpContext = 0;
            pexcepinfo->pvReserved = NULL;
            pexcepinfo->pfnDeferredFillIn = NULL;
            pexcepinfo->scode = 0;
        }

        return DISP_E_EXCEPTION;
    }
#endif

    return S_OK;

#if 0
    HRESULT    hr;
    ITypeInfo *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get our typeinfo first!

    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    if (FAILED(hr))
        return hr;

    // Clear exceptions

    SetErrorInfo(0, NULL);

    // This is exactly what DispInvoke does--so skip the overhead.

    hr = pTypeInfo->Invoke(m_pvInterface, dispid, wFlags,
                           pdispparams, pvarResult,
                           pexcepinfo, puArgErr);
    pTypeInfo->Release();
    return hr;
#endif
}

// actual useful code, as it were...

void CAutomateContent::LookupKeyword(LPCSTR pszKeyword)
{
    // gpCOurPackage->LookupKeyword(pszKeyword);
}

////////////////////////////////////////////////////////////////////////////////////////////////
//
// WebBrowser Event Notification interface.
//
// More actual usefull code, thank god we have Craig!
//
// These are the WebBrowserEvents (I call them notifications ?)

void CAutomateContent::OnCommandStateChange(long Command, BOOL Enable)
{
    DBWIN("OnCommandStateChange Event Called.");
    HMENU hMenu;
    WPARAM btn_index;
    TBBUTTON tbbtn;

    CHHWinType* phh = FindHHWindowIndex(m_pOuter);
    if (!phh || !phh->hwndToolBar || !phh->hwndHelp)
       return;

    hMenu = GetMenu(phh->hwndHelp);
    btn_index = SendMessage(phh->hwndToolBar, TB_COMMANDTOINDEX, IDTB_OPTIONS, 0L);
    if( btn_index == (WPARAM) -1 )
      return;
    SendMessage(phh->hwndToolBar, TB_GETBUTTON, btn_index, (LPARAM) (LPTBBUTTON) &tbbtn);

    switch (Command)
    {
       case 1:
          if ( phh->fsToolBarFlags & HHWIN_BUTTON_FORWARD )
             SendMessage(phh->hwndToolBar, TB_ENABLEBUTTON, IDTB_FORWARD, Enable);
          if ( hMenu )
             EnableMenuItem(hMenu, IDTB_FORWARD, (MF_BYCOMMAND | (Enable?MF_ENABLED:MF_GRAYED)));
          if ( tbbtn.dwData )
             EnableMenuItem((HMENU)tbbtn.dwData, IDTB_FORWARD, (MF_BYCOMMAND | (Enable?MF_ENABLED:MF_GRAYED)));
          break;

       case 2:
          if ( phh->fsToolBarFlags & HHWIN_BUTTON_BACK )
             SendMessage(phh->hwndToolBar, TB_ENABLEBUTTON, IDTB_BACK, Enable);
          if ( hMenu )
             EnableMenuItem(hMenu, IDTB_BACK, (MF_BYCOMMAND | (Enable?MF_ENABLED:MF_GRAYED)));
          if ( tbbtn.dwData )
             EnableMenuItem((HMENU)tbbtn.dwData, IDTB_BACK, (MF_BYCOMMAND | (Enable?MF_ENABLED:MF_GRAYED)));
          break;

       default:
          break;
    }
}

void CAutomateContent::OnDownloadBegin()
{
    DBWIN("OnDownloadBegin Event Called.");

//    if (m_pPrintHook != NULL)
//        m_pPrintHook->OnDownloadBegin();

    // gpCOurPackage->m_bAllowStop = TRUE;       // Stopping allowed during download.
    // gpCOurPackage->m_EnableRefresh = FALSE;   // Refresh not allowed during download.
}

void CAutomateContent::OnDownloadComplete()
{
    DBWIN("OnDownloadComplete Event Called.");

//    if (m_pPrintHook != NULL)
//        m_pPrintHook->OnDownloadComplete();

    // gpCOurPackage->m_bAllowStop = FALSE;     // Disable stop after download complete.
    // gpCOurPackage->m_EnableRefresh = TRUE;   // Enable refresh.

}

void CAutomateContent::OnBeforeNavigate(LPCTSTR pszURL, long Flags,
    LPCTSTR TargetFrameName, VARIANT* pPostData, LPCTSTR Headers, BOOL* pfCancel)
{
#ifdef _DEBUG
    char sz[MAX_URL];
    wsprintf(sz, "OnBeforeNavigate Event Called: %s", pszURL);
    DBWIN(sz);
#endif

    CStr PathName;
    BOOL bInitNewTitle = FALSE;
    BOOL bNewNavigate = FALSE;
    WPARAM wParam = 0;
    LPARAM lParam = 0;

    UINT uiURLType = GetURLType( pszURL );

    // new jump pointer
    LPTSTR pszJumpURL = (LPTSTR) pszURL;

    // default cancel to false
    *pfCancel = FALSE;

    // if we get a javascript then get the current URL so we
    // can do some CD prompting to ensure the current topic is available
    // to avoid multiple prompts for the topic via the finder
    BOOL bJump = TRUE;
    CStr szCurrentURL;
    if( uiURLType == HH_URL_JAVASCRIPT ) {
      bJump = FALSE;
      //Don't use --> GetCurrentURL( &szCurrentURL ); this calls GetActiveWindow which is extrememly inaccurate and unnneeded.
      m_pOuter->m_pWebBrowserApp->GetLocationURL( &szCurrentURL );
      pszJumpURL = szCurrentURL.psz;
      if( !pszJumpURL || !*pszJumpURL )
        return;
      uiURLType = GetURLType( pszJumpURL ); // reset the type
    }

    CExCollection* pCollection = NULL;
    CExTitle* pTitle = NULL;
    BOOL bEnable = FALSE;
    HRESULT hr = S_OK;

    // check if this is a compiled file (one of ours) first
    BOOL bCompiled = (uiURLType != HH_URL_UNKNOWN);

    // is this a super automagic URL?
    //
    // if not a compiled name check if it is a super automagic URL
    // that is it is of the form: mytitle.chm::/mytopic.htm
    // if so, then prefix it with our moniker, and continue on
    //
    // Note, the automagic URL support below will take care
    // of fully qualifying the path and retry the navigate
    CHHWinType* phh = FindHHWindowIndex(m_pOuter);

    if(phh)
        phh->m_bCancel = TRUE;

    char szURL[MAX_URL];
    BOOL bWasPrefixLess = FALSE;
    if( uiURLType == HH_URL_PREFIX_LESS ) {
      bWasPrefixLess = TRUE;
      strcpy( szURL, (g_bMsItsMonikerSupport ? txtMsItsMoniker : txtMkStore) );
      strcat( szURL, pszJumpURL );
      pszJumpURL = szURL;
      uiURLType = HH_URL_UNQUALIFIED;
    }

    // The moniker gets first crack at finding the title and thus if the specified 
    // title is found in the current directory than the moniker will fully qualify
    // the URL and we only find out about it here first (the finder is never called).
    //
    // Thus, given a qualified URL we still have to check if it is external and if  
    // so we need to call the same "init and re-navigate" as we do for the automagic
    // form of an external title.
    //
    if( phh && (uiURLType == HH_URL_QUALIFIED) ) {
      if( pCollection = GetCurrentCollection(NULL, pszJumpURL) ) {
        hr = pCollection->URL2ExTitle( pszJumpURL, &pTitle );
        if( !pTitle ) {
          // we now know that we have an external URL 
          // so do our "init and re-navigate" thing
          GetCompiledName( pszJumpURL, &PathName );
          bInitNewTitle = TRUE;
          bNewNavigate = TRUE;
        }
      }
    }

    // is this an automagic URL?
    //
    // if so, convert the URL to the fully qualified URL (if necessary) and then\
    // re-navigate so that IE uses and knows about the the fully qualified URL
    //
    // we now have to support a new URL format for compiled files.  The format is:
    //
    //  mk:@MSITStore:mytitle.chm::/dir/mytopic.htm
    //
    // where "mk:@MSITStore:" can take any one of the many forms of our URL
    // prefix and it may be optional.  The "mytitle.chm" substring may or
    // may not be a full pathname to the title.  The remaining part is simply
    // the pathname inside of the compiled title.
    //
    // When the URL is in this format, we need to change it to the fully
    // qualified URL format which is:
    //
    //  mk:@MSITStore:c:\titles\mytitle.chm::/dir/mytopic.htm
    //
    // where "mytitle.chm" is now changed to the full path name
    // of the installed title "c:\titles\mytitle.chm".
    //
    char szJumpURL[MAX_URL];
    if( phh && (uiURLType == HH_URL_UNQUALIFIED) ) {
      if( pCollection = GetCurrentCollection(NULL, pszJumpURL) ) {
        hr = pCollection->URL2ExTitle( pszJumpURL, &pTitle );

        // If there is no title associated with this URL in the 
        // collection and this URL was previously a prefix-less 
        // URL then this means we probably have an external 
        // title reference and thus we need to resend the new 
        // unqualified URL through again and have it eventually
        // call the finder where it will try to locate the file 
        // and jump to the topic.
        //
        // Note, since such a jump eventually is resolved via the finder 
        // this means that IE will not know about the fully qualified 
        // path and thus the usual secondary window jump problems 
        // and and the like will surface if the user navigates via this 
        // new topic.
        //
        // To solve the problem we should port over the same code found
        // in the finder that handles the external URL condition and simply
        // do in here inline and repost this newly qualified URL instead.
        //

        if( pTitle ) 
          pTitle->ConvertURL( pszJumpURL, szJumpURL );

        // IE3 appears to automatically translate %20 into a space.
        // Thus, in order to determine if the URL has changed or not
        // we are going to have to put both URLs into a canonical form
        // and do the string compare.
        //
        // Note, technically szJumpURL is already in canonical form
        // since ConvertURL does this for us but it is better to be safe
        // and convert it again.  Yes, I am being paranoid but this code
        // make me so!
        //
        CStr TestURL1;
        CStr TestURL2;
        if( pTitle ) {
          ConvertSpacesToEscapes( szJumpURL, &TestURL1 );
          ConvertSpacesToEscapes( pszJumpURL, &TestURL2 );
        }

        if( !pTitle || StrCmpIA( TestURL1.psz, TestURL2.psz ) != 0 ) {          
          if( pTitle ) {
            pszJumpURL = szJumpURL;
          }
          else {
            // we need to add this new title to the list
            GetCompiledName( pszJumpURL, &PathName );

            // check if it is in the same dir as the master
            char szPathName[_MAX_PATH];
            char szFileName[_MAX_FNAME];  // add back the extension to this post-SplitPath
            char szExtension[_MAX_EXT];
            SplitPath((LPSTR)PathName.psz, NULL, NULL, szFileName, szExtension);
            strcat( szFileName, szExtension );
            char szMasterPath[_MAX_PATH];
            char szMasterDrive[_MAX_DRIVE];
            SplitPath((LPSTR)pCollection->m_csFile, szMasterDrive, szMasterPath, NULL, NULL);
            strcpy( szPathName, szMasterDrive );
            CatPath( szPathName, szMasterPath );
            CatPath( szPathName, szFileName );
            if( (GetFileAttributes(szPathName) != HFILE_ERROR) ) {
              PathName = szPathName;
            }
            else { // try the dreaded ::FindThisFile
              if( !::FindThisFile( NULL, szFileName, &PathName, FALSE ) ) {
                *pfCancel = TRUE;
                return;
              }
            }
            bInitNewTitle = TRUE;
          }
          bNewNavigate = TRUE;
        }
      }
    }

    // do we need to init this as a new title?
    if( bInitNewTitle ) {
      lParam = (LPARAM) (PSTR) LocalAlloc( LMEM_FIXED, strlen(PathName.psz)+1 );
      strcpy( (PSTR) lParam, PathName.psz );
    }

    // do we need to re-navigate to a new URL?
    if( bNewNavigate ) {
     #if 1
      wParam = (WPARAM) (PSTR) LocalAlloc( LMEM_FIXED, strlen(pszJumpURL)+1 );
      strcpy( (PSTR) wParam, pszJumpURL );
      PostMessage( phh->GetHwnd(), WMP_JUMP_TO_URL, wParam, lParam );
     #else
      phh->m_pCIExpContainer->m_pWebBrowserApp->Navigate( pszJumpURL, NULL, NULL, NULL, NULL );
     #endif

      *pfCancel = TRUE;
      return;
    }

    // get a pointer to the title
    if( bCompiled ) {
      pCollection = GetCurrentCollection(NULL, pszJumpURL);
      if( pCollection ) {
        if( !pTitle )
          hr = pCollection->URL2ExTitle( pszJumpURL, &pTitle );
      }
    }

    // Removable media support.
    //
    // if this is a topic in a chm file then ensure the storage is available
    // make sure it is one of our files and not a random URL
    //
    // Note, this must be one of the first things we do since the URL can change
    // if the user changes the title location
    //
    // Note, we cannot fully move this code into HHFinder since HHFinder has
    // no ability to cancel the jump if the user dismisses the swap dialog.  All
    // we can do is duplicate the code in HHFinder as a fallback for such cases
    // as the user pressing Refresh (which does not call BeforeNavigate)!
    //
    // Now that we have to support automagic URLs inline we are going to have
    // to detect if the pathname changed between CD swapping.  If so, then we
    // are going to have to reissue the jump so that IE gets/knows about the fully
    // qualified URL.
    //
    // Note, this only works for .col collections so skip the check for single title
    // and merge sets
    //
    char szJumpURL2[MAX_URL];
    if( bCompiled && phh && pCollection && !(pCollection->IsSingleTitle()) ) {
      if( !pTitle )
        hr = pCollection->URL2ExTitle( pszJumpURL, &pTitle );
      if( FAILED(hr = EnsureStorageAvailability( pTitle )) ) {
        if( hr == HHRMS_E_SKIP_ALWAYS )
          MsgBox(IDS_TOPIC_UNAVAILABLE);
        if( hr != E_FAIL )
          *pfCancel = TRUE;
        phh->m_fHighlight = FALSE;
        return;
      }
      else {
        if( hr == HHRMS_S_LOCATION_UPDATE ) {
          // fetch the new URL and try again
          pTitle->ConvertURL( pszJumpURL, szJumpURL2 );
          pszJumpURL = szJumpURL2;
          *pfCancel = TRUE;

         #if 1
          PSTR psz = (PSTR) LocalAlloc( LMEM_FIXED, strlen(pszJumpURL)+1 );
          strcpy( psz, pszJumpURL );
          PostMessage( phh->GetHwnd(), WMP_JUMP_TO_URL, (WPARAM) psz, 0 );
         #else
          phh->m_pCIExpContainer->m_pWebBrowserApp->Navigate( pszJumpURL, NULL, NULL, NULL, NULL );
         #endif

          return;
        }
      }
    }

    // if this is not a jump then bail out
    if( !bJump )
      return;

    // make sure the chm/chi pairs match
    //
    if( bCompiled && pTitle ) {
      if( !pTitle->EnsureChmChiMatch() ) {
         *pfCancel = TRUE;
         phh->m_fHighlight = FALSE;
         return;
      }
    }

    // This bit of code tells the collection where we think we are in the TOC. This is used for next and prev in the
    // TOC as well as any direct jump from the TOC. We can use this data (topic number and toc location information)
    // and compare it aginst the the information we get directly from the TOC to try and determine if we are navigating
    // to a topic that is referenced in multiple locations in the TOC. This make sync work much more reliably. As a
    // side affect, this code will also end up making autosync a little faster as well for binary TOC. Note also it
    // relies upon some setup work done in the removable media support code above. <mc>
    //
    // Update TOC "slot" and topic information here since we have decided to allow the navigation to proceed.
    //
    if ( phh && pCollection && pCollection->IsBinaryTOC(phh->pszToc) )
    {
       if ( SUCCEEDED(pCollection->URL2ExTitle( pszJumpURL, &pTitle )) || (pTitle = pCollection->GetCurSyncExTitle()) )
       {
          DWORD dwSlot, dwTN;
          if (! SUCCEEDED(pTitle->GetUrlTocSlot(pszJumpURL, &dwSlot, &dwTN)) )
          {
             dwSlot = 0;
             dwTN = 0;
          }
          pCollection->UpdateTopicSlot(dwSlot, dwTN, pTitle);
          if ( dwSlot )
             bEnable = TRUE;
       }
    }
    if ( phh && IsValidWindow(phh->hwndToolBar) && (phh->fsToolBarFlags & HHWIN_BUTTON_SYNC) )
    {
       if (pCollection && (! pCollection->IsBinaryTOC(phh->pszToc)) )
          bEnable = TRUE;                              // Always enable sync or "locate" button for sitemap.
       SendMessage(phh->hwndToolBar, TB_ENABLEBUTTON, IDTB_SYNC, bEnable);
       HMENU hMenu = NULL;
       if ( phh->hwndHelp )
          hMenu = GetMenu(phh->hwndHelp);
       if ( hMenu )
          EnableMenuItem(hMenu, HHM_SYNC, (MF_BYCOMMAND | (bEnable?MF_ENABLED:MF_GRAYED)));
    }
    if(!*pfCancel)
        phh->m_bCancel = FALSE;

    return;
}

void CAutomateContent::OnNavigateComplete(LPCTSTR pszURL)
{
#ifdef _DEBUG
    char sz[MAX_URL];
    wsprintf(sz, "OnNavigateComplete Event Called: %s", pszURL);
    DBWIN(sz);
#endif

//    if (m_pPrintHook != NULL)
//        m_pPrintHook->OnNavigateComplete();

    CHHWinType* phh = FindHHWindowIndex(m_pOuter);
    if (phh)
        phh->OnNavigateComplete(pszURL);

    if ( g_fIE3 )
       OnDocumentComplete();
}

void CAutomateContent::OnDocumentComplete()
{
    CHHWinType* phh = FindHHWindowIndex(m_pOuter);
    CToc* ptoc = NULL;

    // Bug 4710. This bit of code allows us to get focus right when we come need to init the focus to
    // our ie host.
    //
    if ( m_bFirstTime )
    {
       m_bFirstTime = FALSE;
       if ( (phh->fNotExpanded == TRUE) && phh->m_pCIExpContainer )
          phh->m_pCIExpContainer->SetFocus(TRUE);
    }

    // Get a pointer to the toc if it exists.
    if (phh && phh->m_aNavPane[HH_TAB_CONTENTS])
       ptoc = reinterpret_cast<CToc*>(phh->m_aNavPane[HH_TAB_CONTENTS]) ; // HACKHACK: Should use dynamic cast, but no RTTI.
    //
    // Do autosync if necessary.
    //
    // <mc>
    // I've moved the autosync and UI update code from DownloadComplete() because we ALWAYS get this call. We do
    // not get DownloadComplete() calls when we navigate from one anchor point to another within the same .HTM file.
    // 12-15-97
    // </mc>
    //
    if (phh && phh->IsProperty(HHWIN_PROP_AUTO_SYNC) && ptoc)
    {
       CStr cszUrl;
       phh->m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL(&cszUrl);
       if (cszUrl.IsNonEmpty())
       {
            ptoc->Synchronize(cszUrl.psz);
       }
    }

    if ( phh )
       phh->UpdateCmdUI();

    // highlight search terms
    //

    if(phh && phh->m_fHighlight && !phh->m_bCancel)
    {
        phh->m_fHighlight = FALSE;
        LPDISPATCH lpDispatch = m_pOuter->m_pWebBrowserApp->GetDocument();
        if(lpDispatch)
        {
            HWND hWnd = GetFocus();
            // UI active shdocvw to work around Trident bug
            //
            if (! phh->m_pCIExpContainer->m_pInPlaceActive )
                phh->m_pCIExpContainer->m_pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, phh->m_pCIExpContainer->m_pIOleClientSite, -1,phh->m_pCIExpContainer->m_hWnd, NULL);

            // Highlight the document
            //
            phh->m_phmData->m_pTitleCollection->m_pSearchHighlight->HighlightDocument(lpDispatch);
            lpDispatch->Release();

            // deactivate shdocvw UI after highlighting
            //
            phh->m_pCIExpContainer->UIDeactivateIE();
            SetFocus(hWnd);
        }
    }

    // set focus back to previous control after navigate
    if (phh && phh->m_hwndControl)
    {
            SetFocus(phh->m_hwndControl);
            phh->m_hwndControl = NULL;
    }

}

void CAutomateContent::OnTitleChange(LPCTSTR pszTitle)
{
    DBWIN("OnTitleChange Event Called.");

#ifdef _DEBUG
    CHHWinType* phh = FindHHWindowIndex(m_pOuter);
    if (phh) {
        CStr cszUrl;
        phh->m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL(&cszUrl);
        if (cszUrl.IsNonEmpty() && strcmp(cszUrl, pszTitle) != 0)
            phh->AddToHistory(pszTitle, cszUrl);
    }
#endif
}

CHHWinType* FindHHWindowIndex(CContainer* m_pOuter)
{
    static iLastWindow = 0;
    if (pahwnd[iLastWindow] && (pahwnd[iLastWindow]->m_pCIExpContainer == m_pOuter))
        return pahwnd[iLastWindow];

    for (iLastWindow = 0; iLastWindow < g_cWindowSlots; iLastWindow++) {
        if (pahwnd[iLastWindow] && pahwnd[iLastWindow]->m_pCIExpContainer == m_pOuter)
            return pahwnd[iLastWindow];
    }
    iLastWindow = 0;
    return NULL;
}

#if 0
void CAutomateContent::OnProgressChange(long Progress, long ProgressMax)
{
    DBWIN("OnProgressChange Event Called.");

    if (Progress < 0)
    {
    }
}
#endif

void CAutomateContent::OnPropertyChange(LPCTSTR pszProperty)
{
#ifdef _DEBUG
    char sz[256];
    wsprintf(sz, "OnPropertyChange Event Called: %s", pszProperty);
    DBWIN(sz);
#endif
}

void CAutomateContent::OnQuit(BOOL* pfCancel)
{
 DBWIN("OnQuit Event Called.");
}

void CAutomateContent::OnStatusTextChange(LPCTSTR pszText)
{
#ifdef _DEBUG
    char sz[256];
    wsprintf(sz, "OnStatusTextChange Event Called: %s", pszText);
    DBWIN(sz);
#endif
}

void CAutomateContent::OnWindowActivated()
{
  DBWIN("OnWindowActivated Event Called.");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cathelp.h ===
#include "comcat.h"

// Helper function to create a component category and associated description
//HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription);

// Helper function to register a CLSID as belonging to a component category
//HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid);

// Helper function to unregister a CLSID as belonging to a component category
//HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cathelp.cpp ===
#include "header.h"
#include "comcat.h"

// Helper function to create a component category and associated description

HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
{
	ICatRegister* pcr = NULL ;
	HRESULT hr = S_OK ;

	hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

	// Make sure the HKCR\Component Categories\{..catid...}
	// key is registered
	CATEGORYINFO catinfo;
	catinfo.catid = catid;
	catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len > 127)
		len = 127;
	wcsncpy(catinfo.szDescription, catDescription, len+1);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

	hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr; 
}

// Helper function to register a CLSID as belonging to a component category

HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{

	// Register your component categories information.

	ICatRegister* pcr = NULL;
	HRESULT hr = S_OK ;
	hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (SUCCEEDED(hr)) {
		// Register this category as being "implemented" by the class.
		CATID rgcatid[1] ;
		rgcatid[0] = catid;
		hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
	}

	if (pcr != NULL)
		pcr->Release();

	return hr;
}

// Helper function to unregister a CLSID as belonging to a component category

HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
	ICatRegister* pcr = NULL ;
	HRESULT hr = S_OK ;
	hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (SUCCEEDED(hr)) {
		// Unregister this category as being "implemented" by the class.

		CATID rgcatid[1] ;
		rgcatid[0] = catid;
		hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
	}

	if (pcr != NULL)
		pcr->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cctlww.cpp ===
// cctlww.cpp - commctl Unicode wrapper
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Paul Chase Dempsey - mailto:paulde@microsoft.com
// August 3, 1998
//----------------------------------------------------------------
#include "header.h"
#include <windowsx.h>
#include <wchar.h>
#include "cctlww.h"

#define MAX_ITEM_STRING (MAX_PATH*2)
#define Malloc(cb) lcMalloc((cb))
#define Free(ptr)  lcFree((ptr))

// debug help: this var allows you to futz with the codepage under the debugger
// if you change this to an MBCS codepage, set s_cb in W_cbchMaxAcp to 2.
#ifdef _DEBUG
UINT    _CODEPAGE = CP_ACP;
#else
#define _CODEPAGE   CP_ACP
#endif

//----------------------------------------------------------------
// global data

BOOL g_fAnsiAPIs        = FALSE;
BOOL g_fUnicodeListView = FALSE;
BOOL g_fUnicodeTreeView = FALSE;
BOOL g_fUnicodeTabCtrl  = FALSE;

// indexed by CCTLWINTYPE enum
static const LPCWSTR rgwszClass[] = { WC_LISTVIEWW, WC_TREEVIEWW, WC_TABCONTROLW };
static const LPCSTR  rgszClass[]  = { WC_LISTVIEWA, WC_TREEVIEWA, WC_TABCONTROLA };

//----------------------------------------------------------------
// private wrapper helpers
BOOL IsListViewUnicode(HWND hwnd);
BOOL IsTreeViewUnicode(HWND hwnd);
BOOL IsTabCtrlUnicode(HWND hwnd);

//----------------------------------------------------------------
// Return max bytes per character in the system default codepage
int WINAPI W_cbchMaxAcp()
{
    static int s_cb = 0;

    if (s_cb)
        return s_cb;

    CPINFO cpi;
    if (GetCPInfo(GetACP(), &cpi))
        s_cb = cpi.MaxCharSize;
    else
        s_cb = 2; // worst case
    return s_cb;
}

//----------------------------------------------------------------
HWND WINAPI W_CreateWindowEx (
    DWORD     dwExStyle,
    LPCWSTR   lpClassName,
    LPCWSTR   lpWindowName,
    DWORD     dwStyle,
    int       X,
    int       Y,
    int       nWidth,
    int       nHeight,
    HWND      hWndParent ,
    HMENU     hMenu,
    HINSTANCE hInstance,
    LPVOID    lpParam,
    BOOL *    pfUnicode /*out*/
    )
{
    HWND hwnd = CreateWindowExW (dwExStyle, lpClassName, lpWindowName, dwStyle,
                                 X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
    if (NULL != hwnd)
    {
        if (pfUnicode)
            *pfUnicode = TRUE;
        return hwnd;
    }
    if (pfUnicode)
        *pfUnicode = FALSE;
    if (ERROR_CALL_NOT_IMPLEMENTED != ::GetLastError())
    {
        ASSERT(0); // shouldn't be writing CreateWindow that fail
        return 0;
    }

    char * pszClass = 0;
    char * pszWindow = 0;

    if ((DWORD_PTR)lpClassName >= 0xC00)
    {
        int cb = 1 + W_cbchMaxAcp()*lstrlenW(lpClassName);
        pszClass = (PSTR)_alloca(cb);
        WideCharToMultiByte(_CODEPAGE, 0, lpClassName, -1, pszClass, cb, 0, 0);
    }
    else // it's a class atom: pass it through
        pszClass = PSTR(lpClassName);

    if (lpWindowName && *lpWindowName)
    {
        int cb = 1 + W_cbchMaxAcp()*lstrlenW(lpWindowName);
        pszWindow = (PSTR)_alloca(cb);
        WideCharToMultiByte(_CODEPAGE, 0, lpWindowName, -1, pszWindow, cb, 0, 0);
    }
    else
        pszWindow = "";
    hwnd = CreateWindowExA (dwExStyle, pszClass, pszWindow, dwStyle,
                           X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
    return hwnd;
}

//----------------------------------------------------------------
void WINAPI W_SubClassWindow(HWND hwnd, LONG_PTR Proc, BOOL fUnicode)
{
    if (fUnicode)
    {
        ASSERT(!g_fAnsiAPIs);
        SetWindowLongPtrW(hwnd, GWLP_WNDPROC, Proc);
    }
    else
        SetWindowLongPtrA(hwnd, GWLP_WNDPROC, Proc);
}

//----------------------------------------------------------------
WNDPROC WINAPI W_GetWndProc(HWND hwnd, BOOL fUnicode)
{
    if (fUnicode)
    {
        ASSERT(!g_fAnsiAPIs);
        return (WNDPROC) GetWindowLongPtrW(hwnd, GWLP_WNDPROC);
    }
    else
        return (WNDPROC) GetWindowLongPtrA(hwnd, GWLP_WNDPROC);
}

//----------------------------------------------------------------
LRESULT WINAPI W_DelegateWindowProc (WNDPROC Proc, HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (IsWindowUnicode(hwnd))
        return CallWindowProcW(Proc, hwnd, msg, wParam, lParam);
    else
        return CallWindowProcA(Proc, hwnd, msg, wParam, lParam);
}

//----------------------------------------------------------------
LRESULT  WINAPI W_DefWindowProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (IsWindowUnicode(hwnd))
        return DefWindowProcW(hwnd, msg, wParam, lParam);
    else
        return DefWindowProcA(hwnd, msg, wParam, lParam);
}

//----------------------------------------------------------------
LRESULT  WINAPI W_DefDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (IsWindowUnicode(hwnd))
        return DefDlgProcW(hwnd, msg, wParam, lParam);
    else
        return DefDlgProcA(hwnd, msg, wParam, lParam);
}

//----------------------------------------------------------------
BOOL WINAPI W_HasText(HWND hwnd)
{
   return (GetWindowTextLength(hwnd) > 0);
}


//----------------------------------------------------------------
int WINAPI W_GetTextLengthExact(HWND hwnd)
{
    ASSERT(hwnd && IsWindow(hwnd));
   if (IsWindowUnicode(hwnd))
   {
      int   cch1 = GetWindowTextLengthW(hwnd);
#ifdef _DEBUG
      PWSTR psz  = (PWSTR)_alloca((cch1+1)*2);
      int   cch2 = GetWindowTextW(hwnd, psz, (cch1+1)*2);
        ASSERT(cch2 == lstrlenW(psz));
#endif
        return cch1;
   }
   else
   {
      int  cb1 = GetWindowTextLengthA(hwnd);
      PSTR psz = (PSTR)_alloca(cb1+1);
      int  cb2 = GetWindowTextA(hwnd, psz, cb1+1);
        ASSERT(cb1 == cb2);
      return MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
   }
}

//----------------------------------------------------------------
int WINAPI W_GetWindowText (HWND hwnd, PWSTR psz, int cchMax)
{
    ASSERT(hwnd && IsWindow(hwnd));

    int cch = 0;
    *psz = 0;

    if (IsWindowUnicode(hwnd))
        return GetWindowTextW(hwnd, psz, cchMax);

    int cb = W_cbchMaxAcp()*cchMax;
    PSTR pszA = (PSTR)_alloca(cb);
    cb = GetWindowTextA(hwnd, pszA, cb);

    if (cb)
    {
        cch = MultiByteToWideChar(CP_ACP, 0, pszA, -1, psz, cchMax);
    }
    else
    {
        *psz = 0;
        cch = 0;
    }
    return cch;
}

//----------------------------------------------------------------
BOOL WINAPI W_SetWindowText (HWND hwnd, PCWSTR psz)
{
    ASSERT(hwnd && IsWindow(hwnd));

    if (IsWindowUnicode(hwnd))
        return SetWindowTextW(hwnd, psz);

    int cb = 1 + W_cbchMaxAcp()*lstrlenW(psz);
    PSTR pszA = (PSTR)_alloca(cb);
    WideCharToMultiByte(CP_ACP, 0, psz, -1, pszA, cb, 0, 0);
    return SetWindowTextA(hwnd, pszA);
}

//----------------------------------------------------------------
LRESULT WINAPI W_SendStringMessage(HWND hwnd, UINT msg, WPARAM wParam, PCWSTR psz)
{
    ASSERT(hwnd && IsWindow(hwnd));

    if (IsWindowUnicode(hwnd))
        return SendMessageW(hwnd, msg, wParam, (LPARAM)psz);

    int  cb   = 1 + W_cbchMaxAcp()*lstrlenW(psz);
    PSTR pszA = (PSTR)_alloca(cb);
    WideCharToMultiByte(_Module.GetCodePage(), 0, psz, -1, pszA, cb, 0, 0);
    return SendMessageA(hwnd, msg, wParam, (LPARAM)pszA);
}

//----------------------------------------------------------------
int WINAPI W_ComboBox_GetListText(HWND hwnd, PWSTR psz, int cchMax)
{
    *psz = 0;
    int count = ComboBox_GetCount(hwnd);
    if (count <= 0)
        return 0;

    if (IsWindowUnicode(hwnd))
    {
        PWSTR pch      = psz;
        int   cchTotal = 0;
        for (int i = 0; i < count; i++)
        {
            int cch = (int)SendMessageW(hwnd, CB_GETLBTEXTLEN, (WPARAM)i, 0L);
            cchTotal += cch;
            if (cchTotal < cchMax-1)
            {
                SendMessageW(hwnd, CB_GETLBTEXT, (WPARAM)i, (LPARAM)pch);
                pch += cch;
                *pch++ = L'\n';
                cchTotal++;
            }
            else
                cchTotal -= cch;
        }
        if (cchTotal) --pch;
        *pch = 0;
        return (int)(pch - psz);
    }
    else
    {
        int  cbMax = cchMax*W_cbchMaxAcp();
        PSTR pszA  = (PSTR)Malloc(cbMax);
        if (NULL == pszA)
            return 0;
        PSTR pch = pszA;
        int  cbTotal = 0;
        for (int i = 0; i < count; i++)
        {
            int cb = (int)SendMessageA(hwnd, CB_GETLBTEXTLEN, (WPARAM)i, 0L);
            cbTotal += cb;
            if (cbTotal < cbMax-1)
            {
                SendMessageA(hwnd, CB_GETLBTEXT, (WPARAM)i, (LPARAM)pch);
                pch += cb;
                *pch++ = '\n';
                cbTotal++;
            }
            else
                cbTotal -= cb;
        }
        if (cbTotal) --pch;
        *pch = 0;
        int iRet = MultiByteToWideChar(CP_ACP, 0, pszA, -1, psz, cchMax);
        Free(pszA);
        return iRet;
    }
}

//----------------------------------------------------------------
int WINAPI W_ComboBox_SetListText (HWND hwnd, PWSTR psz, int cItemsMax)
{
    ASSERT(hwnd && IsWindow(hwnd));

    int cItems = 0;
    psz = wcstok(psz, L"\n");
    while (psz && cItems < cItemsMax)
    {
        W_ComboBox_AddString(hwnd, psz);
        cItems++;
        psz = wcstok(NULL, L"\n");
    }
    return cItems;
}

//----------------------------------------------------------------
int WINAPI W_CompareString(LCID lcid, DWORD dwFlags, PCWSTR str1, int cch1, PCWSTR str2, int cch2)
{
    int iRet;

    if (g_fAnsiAPIs) goto _Ansi;
    iRet = CompareStringW(lcid, dwFlags, str1, cch1, str2, cch2);
    if (0 == iRet)
    {
        if (ERROR_CALL_NOT_IMPLEMENTED == GetLastError())
        {
            g_fAnsiAPIs = TRUE;
            goto _Ansi;
        }
    }
    return iRet;

_Ansi:
    if (-1 == cch1)
        cch1 = lstrlenW(str1);
    if (-1 == cch2)
        cch2 = lstrlenW(str2);
    int cb = W_cbchMaxAcp();
    char *psz1 = (char*)Malloc(cch1*cb);
    char *psz2 = (char*)Malloc(cch2*cb);
    if (NULL == psz1 || NULL == psz2)
    {
        iRet = memcmp(str1, str2, min(cch1,cch2)*sizeof(WCHAR));
        if (0 == iRet)
            iRet = cch1-cch2;
        iRet += 2; // convert to CompareString ret codes
    }
    else
    {
        UINT cp = CodePageFromLCID(lcid);
        cch1 = WideCharToMultiByte(cp, 0, str1, cch1, psz1, cch1*cb, 0, 0);
        cch2 = WideCharToMultiByte(cp, 0, str2, cch2, psz2, cch2*cb, 0, 0);
        iRet = CompareStringA(lcid, dwFlags, psz1, cch1, psz2, cch2);
    }
    Free(psz1);
    Free(psz2);
    return iRet;
}

//----------------------------------------------------------------
BOOL WINAPI W_IsListViewUnicode(HWND hwndLV)
{
    ASSERT(hwndLV && IsWindow(hwndLV)); // can't call this unless you've created a LV
    if (g_fUnicodeListView)
    {
        ASSERT(IsWindowUnicode(hwndLV) || (g_fAnsiAPIs && ListView_GetUnicodeFormat(hwndLV)));
        return TRUE;
    }
    else
    {
        ASSERT(!g_fAnsiAPIs);
        ASSERT(!IsWindowUnicode(hwndLV));
        return FALSE;
    }
}

//----------------------------------------------------------------
BOOL WINAPI W_IsTreeViewUnicode(HWND hwndTV)
{
    ASSERT(hwndTV && IsWindow(hwndTV)); // can't call this unless you've created a TV
    if (g_fUnicodeTreeView)
    {
        ASSERT(IsWindowUnicode(hwndTV) || (g_fAnsiAPIs && TreeView_GetUnicodeFormat(hwndTV)));
        return TRUE;
    }
    else
    {
        ASSERT(!g_fAnsiAPIs);
        ASSERT(!IsWindowUnicode(hwndTV));
        return FALSE;
    }
}

//----------------------------------------------------------------
BOOL WINAPI W_IsTabCtrlUnicode(HWND hwndTC)
{
    ASSERT(hwndTC && IsWindow(hwndTC)); // can't call this unless you've created a TC
    if (g_fUnicodeTabCtrl)
    {
        ASSERT(IsWindowUnicode(hwndTC) || (g_fAnsiAPIs && TabCtrl_GetUnicodeFormat(hwndTC)));
        return TRUE;
    }
    else
    {
        ASSERT(!g_fAnsiAPIs);
        ASSERT(!IsWindowUnicode(hwndTC));
        return FALSE;
    }
}

//----------------------------------------------------------------
HWND WINAPI W_CreateControlWindow (
    DWORD        dwStyleEx,
    DWORD        dwStyle,
    CCTLWINTYPE  wt,
    LPCWSTR      pwszName,
    int x, int y, int width, int height,
    HWND         parent,
    HMENU        menu,
    HINSTANCE    inst,
    LPVOID       lParam
    )
{
    ASSERT(W_ListView == wt || W_TreeView == wt || W_TabCtrl == wt);

    HWND hwnd;

    if (g_fAnsiAPIs)
        goto _AnsiAPI;

    hwnd = CreateWindowExW(dwStyleEx, rgwszClass[wt], pwszName, dwStyle, x, y, width, height, parent, menu, inst, lParam);
    if (NULL == hwnd)
    {
        if (ERROR_CALL_NOT_IMPLEMENTED != ::GetLastError())
        {
            ASSERT(0); // shouldn't be writing CreateWindow that fail
            return 0;
        }
        g_fAnsiAPIs = TRUE;

_AnsiAPI:
        char sz[MAX_PATH*2];

        sz[0] = 0;
        WideCharToMultiByte(_CODEPAGE, 0, pwszName, -1, sz, sizeof(sz), 0, 0);
        hwnd = CreateWindowExA(dwStyleEx, rgszClass[wt], sz, dwStyle, x, y, width, height, parent, menu, inst, lParam);
    }
    if (hwnd)
    {
        switch (wt)
        {
        case W_ListView:
            ListView_SetUnicodeFormat(hwnd, TRUE);
            if ( g_fAnsiAPIs )
            {
                g_fUnicodeListView = IsListViewUnicode(hwnd);
                ListView_SetUnicodeFormat(hwnd, g_fUnicodeListView); // ensure consistency
            }
            break;

        case W_TreeView:
            TreeView_SetUnicodeFormat(hwnd, TRUE);
            if ( g_fAnsiAPIs )
            {
                g_fUnicodeTreeView = IsTreeViewUnicode(hwnd);
                TreeView_SetUnicodeFormat(hwnd, g_fUnicodeTreeView); // ensure consistency
            }
            break;

        case W_TabCtrl:
            TabCtrl_SetUnicodeFormat(hwnd, TRUE);
            if ( g_fAnsiAPIs )
            {
                g_fUnicodeTabCtrl = IsTabCtrlUnicode(hwnd);
                TabCtrl_SetUnicodeFormat(hwnd, g_fUnicodeTabCtrl); // ensure consistency
            }
            break;
        }
    }
#ifdef _DEBUG
    else
    {
        ASSERT(0);
        DWORD dwerr = ::GetLastError();
    }
#endif
    return hwnd;
}

// use this for common controls on a dialog
BOOL WINAPI W_EnableUnicode(HWND hwnd, CCTLWINTYPE wt)
{
    if (IsWindowUnicode(hwnd))
    {
        switch (wt)
        {
        case W_ListView:
         ListView_SetUnicodeFormat(hwnd, TRUE);
         g_fUnicodeListView = TRUE;
         break;

        case W_TreeView:
            TreeView_SetUnicodeFormat(hwnd, TRUE);
         g_fUnicodeTreeView = TRUE;
         break;

        case W_TabCtrl:
            TabCtrl_SetUnicodeFormat(hwnd, TRUE);
         g_fUnicodeTabCtrl = TRUE;
         break;

        default: ASSERT(0); break;
        };
        return TRUE;
    }
   //else not unicode window
    switch (wt)
    {
    case W_ListView:
        if (g_fUnicodeListView)
        {
            ListView_SetUnicodeFormat(hwnd, TRUE);
            g_fUnicodeListView = IsListViewUnicode(hwnd);
            ListView_SetUnicodeFormat(hwnd, g_fUnicodeListView); // ensure consistency
        }
        return g_fUnicodeListView;
        break;

    case W_TreeView:
        if (g_fUnicodeTreeView)
        {
            TreeView_SetUnicodeFormat(hwnd, TRUE);
            g_fUnicodeTreeView = IsTreeViewUnicode(hwnd);
            TreeView_SetUnicodeFormat(hwnd, g_fUnicodeTreeView); // ensure consistency
        }
        return g_fUnicodeTreeView;
        break;

    case W_TabCtrl:
        if (g_fUnicodeTabCtrl)
        {
            TabCtrl_SetUnicodeFormat(hwnd, TRUE);
            g_fUnicodeTabCtrl = IsTabCtrlUnicode(hwnd);
            TabCtrl_SetUnicodeFormat(hwnd, g_fUnicodeTabCtrl); // ensure consistency
        }
        return g_fUnicodeTabCtrl;
        break;

    }
    return FALSE;
}

//================================================================
// List View
//================================================================
BOOL IsListViewUnicode(HWND hwnd)
{
    LV_ITEMW lvi;
    int      ii;   // item index
    BOOL     fRet;

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask       = LVIF_TEXT;
    lvi.pszText    = L" ";
    lvi.cchTextMax = 2;

    ii = (int)SendMessageA(hwnd, LVM_INSERTITEMW, 0, (LPARAM)&lvi);
    if (-1 == ii)
        return FALSE;

    // LVM_INSERTITEMW succeeds even in ANSI (unlike the tree view), so we have
    // to try LVM_GETITEMW to determine if we've really got Unicode support.
    WCHAR wsz[4];

    lvi.mask       = LVIF_TEXT;
    lvi.iItem      = ii;
    lvi.pszText    = wsz;
    lvi.cchTextMax = 4;

    fRet = SendMessageA(hwnd, LVM_GETITEMW, 0, (LPARAM)&lvi)!=NULL;

    // clean up the test item we added
    SendMessageA(hwnd, LVM_DELETEITEM, (WPARAM)ii, 0);

    return fRet;
}

//----------------------------------------------------------------
void WINAPI LV_ITEMAFromW (LV_ITEMA * pA, const LV_ITEMW *pW, BOOL fConvertString = TRUE)
{
    pA->mask        = pW->mask;
    pA->iItem       = pW->iItem;
    pA->iSubItem    = pW->iSubItem;
    pA->state       = pW->state;
    pA->stateMask   = pW->stateMask;
    if (fConvertString && pW->pszText && pA->pszText)
        WideCharToMultiByte(_Module.GetCodePage(), 0, pW->pszText, -1, pA->pszText, pA->cchTextMax, 0, 0);
    pA->iImage      = pW->iImage;
    pA->lParam      = pW->lParam;
    pA->iIndent     = pW->iIndent;
}

//----------------------------------------------------------------
void WINAPI LV_ITEMWFromA (const LV_ITEMA * pA, LV_ITEMW *pW, BOOL fConvertString = TRUE)
{
    pW->mask        = pA->mask;
    pW->iItem       = pA->iItem;
    pW->iSubItem    = pA->iSubItem;
    pW->state       = pA->state;
    pW->stateMask   = pA->stateMask;
    if (fConvertString && pW->pszText && pA->pszText)
        MultiByteToWideChar(_Module.GetCodePage(), 0, pA->pszText, -1, pW->pszText, pW->cchTextMax);
    pW->iImage      = pA->iImage;
    pW->lParam      = pA->lParam;
    pW->iIndent     = pA->iIndent;
}

//----------------------------------------------------------------
BOOL WINAPI ListView_ItemHelper(HWND hwnd, LV_ITEMW * pitem, UINT MsgW, UINT MsgA, BOOL fConvertIn, BOOL fConvertOut)
{
    ASSERT(!g_fUnicodeListView);
    // if no text, all the rest is the same
    if (0 == (pitem->mask & LVIF_TEXT) || (LPSTR_TEXTCALLBACKW == pitem->pszText))
        return SendMessageA(hwnd, MsgA, 0, (LPARAM)pitem)!=NULL;

    BOOL     fRet;
    LV_ITEMA item;
    char     sz[MAX_ITEM_STRING+1];

    item.pszText    = sz;
    item.cchTextMax = MAX_ITEM_STRING;
    LV_ITEMAFromW(&item, pitem, fConvertIn);

    fRet = SendMessageA(hwnd, MsgA, 0, (LPARAM)&item)!=NULL;
    if (fRet)
        LV_ITEMWFromA(&item, pitem, fConvertOut);
    return fRet;
}

//----------------------------------------------------------------
BOOL WINAPI W_ListView_GetItem_fn(HWND hwnd, LV_ITEMW * pitem)
{
    if (g_fUnicodeListView)
        return SendMessage(hwnd, LVM_GETITEMW, 0, (LPARAM)pitem)!=NULL;

    ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW));
    if (!((pitem->mask & LVIF_TEXT) && pitem->pszText && (LPSTR_TEXTCALLBACKW != pitem->pszText)))
        return SendMessageA(hwnd, LVM_GETITEMA, 0, (LPARAM)pitem)!=NULL;
    return ListView_ItemHelper(hwnd, pitem, LVM_GETITEMW, LVM_GETITEMA, FALSE, TRUE);
}

//----------------------------------------------------------------
BOOL WINAPI W_ListView_SetItem_fn(HWND hwnd, LV_ITEMW * pitem)
{
    if (g_fUnicodeListView)
        return SendMessage(hwnd, LVM_SETITEMW, 0, (LPARAM)pitem)!=NULL;

    ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW));
    if (!((pitem->mask & LVIF_TEXT) && pitem->pszText && (LPSTR_TEXTCALLBACKW != pitem->pszText)))
        return SendMessageA(hwnd, LVM_SETITEMA, 0, (LPARAM)pitem)!=NULL;
    return ListView_ItemHelper(hwnd, pitem, LVM_SETITEMW, LVM_SETITEMA, TRUE, FALSE)!=NULL;
}

//----------------------------------------------------------------
int  WINAPI W_ListView_InsertItem_fn(HWND hwnd, LV_ITEMW * pitem)
{
    if (g_fUnicodeListView)
        return (int)SendMessage(hwnd, LVM_INSERTITEMW, 0, (LPARAM)pitem);

    ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW));
    if (!((pitem->mask & LVIF_TEXT) && pitem->pszText && (LPSTR_TEXTCALLBACKW != pitem->pszText)))
        return (int)SendMessageA(hwnd, LVM_INSERTITEMA, 0, (LPARAM)pitem);
    return ListView_ItemHelper(hwnd, pitem, LVM_INSERTITEMW, LVM_INSERTITEMA, TRUE, FALSE);
}

//----------------------------------------------------------------
int  WINAPI W_ListView_FindItem_fn(HWND hwnd, int iStart, LV_FINDINFOW * plvfi)
{
    ASSERT(0); //NOT IMPLEMENTED
    return -1;
}

//----------------------------------------------------------------
int  WINAPI W_ListView_GetStringWidth_fn(HWND hwndLV, LPCWSTR psz)
{
    ASSERT(0); //NOT IMPLEMENTED
    return 0;
}

//----------------------------------------------------------------
HWND WINAPI W_ListView_EditLabel_fn(HWND hwnd, int i)
{
    return (HWND)SendMessage(hwnd, g_fUnicodeListView?LVM_EDITLABELW:LVM_EDITLABELA, (WPARAM)(int)(i), 0L);
}

//----------------------------------------------------------------
BOOL WINAPI W_ListView_GetColumn_fn(HWND hwnd, int iCol, LV_COLUMNW * pcol)
{
    ASSERT(0); // NYI
    return FALSE;
}

//----------------------------------------------------------------
BOOL WINAPI W_ListView_SetColumn_fn(HWND hwnd, int iCol, LV_COLUMNW * pcol)
{
    ASSERT(0); // NYI
    return FALSE;
}

//----------------------------------------------------------------
int  WINAPI W_ListView_InsertColumn_fn(HWND hwnd, int iCol, LV_COLUMNW * pcol)
{
    if (g_fUnicodeListView)
        return (int)SendMessage(hwnd, LVM_INSERTCOLUMNW, (WPARAM)iCol, (LPARAM)pcol);

    ASSERT(sizeof(LV_COLUMNA)==sizeof(LV_COLUMNW));
    if (0 == (pcol->mask & LVIF_TEXT) || (LPSTR_TEXTCALLBACKW == pcol->pszText))
        return (int)SendMessageA(hwnd, LVM_INSERTCOLUMNA, (WPARAM)iCol, (LPARAM)pcol);

    LV_COLUMNA lvc;
    char       sz[MAX_ITEM_STRING+1];
    memcpy(&lvc, pcol, sizeof(LV_COLUMNA));
    lvc.pszText    = sz;
    lvc.cchTextMax = WideCharToMultiByte(_CODEPAGE, 0, pcol->pszText, -1, sz, MAX_ITEM_STRING, 0, 0);
    return (int)SendMessageA(hwnd, LVM_INSERTCOLUMNA, (WPARAM)iCol, (LPARAM)&lvc);
}

//----------------------------------------------------------------
void WINAPI W_ListView_GetItemText_fn(HWND hwndLV, int i, int iSubItem_, LPWSTR  pszText_, int cchTextMax_)
{
    if (g_fUnicodeListView)
    {
        LV_ITEMW lvi;

        lvi.iSubItem   = iSubItem_;
        lvi.cchTextMax = cchTextMax_;
        lvi.pszText    = pszText_;
        SendMessage(hwndLV, LVM_GETITEMTEXTW, i, (LPARAM)&lvi);
    }
    else
    {
        int      i2;
        LV_ITEMA lvi;
        char     sz[MAX_ITEM_STRING+1];

        lvi.iSubItem   = iSubItem_;
        lvi.cchTextMax = MAX_ITEM_STRING;
        lvi.pszText    = sz;
        i2 = (int)SendMessage(hwndLV, LVM_GETITEMTEXTA, i, (LPARAM)&lvi);
        if (i2)
        {
            MultiByteToWideChar(_Module.GetCodePage(), 0, sz, -1, pszText_, cchTextMax_);
        }
        else
        {
            if (pszText_)
                *pszText_ = 0;
        }
    }
}

//----------------------------------------------------------------
void WINAPI W_ListView_SetItemText_fn(HWND hwndLV, int i, int iSubItem_, LPCWSTR pszText_)
{
    if (g_fUnicodeListView)
    {
        LV_ITEMW lvi;

        lvi.iSubItem = iSubItem_;
        lvi.pszText  = (LPWSTR)pszText_;
        SendMessage(hwndLV, LVM_SETITEMTEXTW, i, (LPARAM)&lvi);
    }
    else
    {
        LV_ITEMA lvi;
        char     sz[MAX_ITEM_STRING+1];

        lvi.iSubItem = iSubItem_;
        if (pszText_ && (LPSTR_TEXTCALLBACKW != pszText_))
        {
            WideCharToMultiByte(CP_ACP, 0, pszText_, -1, sz, MAX_ITEM_STRING, 0, 0);
            lvi.pszText = sz;
        }
        else
            lvi.pszText = (PSTR)pszText_;
        SendMessage(hwndLV, LVM_SETITEMTEXTA, i, (LPARAM)&lvi);
    }
}

//----------------------------------------------------------------
BOOL WINAPI W_ListView_GetISearchString_fn(HWND hwndLV, LPWSTR lpsz)
{
    if (g_fUnicodeListView)
        return SendMessage(hwndLV, LVM_GETISEARCHSTRINGW, 0, (LPARAM)(LPTSTR)lpsz)!=0;

    ASSERT(0); // NYI
    return FALSE;
}

//----------------------------------------------------------------
BOOL WINAPI W_ListView_SetBkImage_fn(HWND hwnd, LPLVBKIMAGEW plvbki)
{
    if (g_fUnicodeListView)
        return SendMessage(hwnd, LVM_SETBKIMAGEW, 0, (LPARAM)plvbki)!=0;

    ASSERT(0); // NYI
    return FALSE;
}

//----------------------------------------------------------------
BOOL WINAPI W_ListView_GetBkImage_fn(HWND hwnd, LPLVBKIMAGEW plvbki)
{
    if (g_fUnicodeListView)
        return SendMessage(hwnd, LVM_GETBKIMAGEW, 0, (LPARAM)plvbki)!=0;

    ASSERT(0); // NYI
    return FALSE;
}


//================================================================
// Tree View
//================================================================
BOOL IsTreeViewUnicode(HWND hwnd)
{
    TV_INSERTSTRUCTW tvis;
    ZeroMemory(&tvis, sizeof(tvis));
    tvis.hParent         = TVI_ROOT;
    tvis.hInsertAfter    = TVI_FIRST;
    tvis.item.mask       = LVIF_TEXT;
    tvis.item.pszText    = L" ";
    tvis.item.cchTextMax = 2;
    HTREEITEM hi = (HTREEITEM)SendMessageA(hwnd, TVM_INSERTITEMW, 0, (LPARAM)&tvis);
    if (NULL == hi)
        return FALSE;
    // if here, the insert succeeded
    // delete the item we added
    SendMessageA(hwnd, TVM_DELETEITEM, 0, (LPARAM)hi);
    return TRUE;
}

//----------------------------------------------------------------
HTREEITEM WINAPI W_TreeView_InsertItem_fn(HWND hwnd, LPTV_INSERTSTRUCTW lpis)
{
    if (g_fUnicodeTreeView)
        return (HTREEITEM)SendMessage(hwnd, TVM_INSERTITEMW, 0, (LPARAM)lpis);

    ASSERT(sizeof(TVINSERTSTRUCTA)==sizeof(TVINSERTSTRUCTW));
    if (!((lpis->item.mask & TVIF_TEXT) && lpis->item.pszText && (LPSTR_TEXTCALLBACKW != lpis->item.pszText)))
        return (HTREEITEM)SendMessageA(hwnd, TVM_INSERTITEMA, 0, (LPARAM)lpis);

    HTREEITEM htitem;
    TVINSERTSTRUCTA tvisA;
    memcpy(&tvisA, lpis, sizeof(TVINSERTSTRUCTA));
    tvisA.item.cchTextMax = 1 + lstrlenW(lpis->item.pszText);
    tvisA.item.pszText = (PSTR)Malloc(tvisA.item.cchTextMax);
    if (NULL != tvisA.item.pszText)
        tvisA.item.cchTextMax = WideCharToMultiByte(_Module.GetCodePage(), 0, lpis->item.pszText, -1, tvisA.item.pszText, tvisA.item.cchTextMax, 0, 0);
    else
        tvisA.item.cchTextMax = 0;
    htitem = (HTREEITEM)SendMessageA(hwnd, TVM_INSERTITEMA, 0, (LPARAM)&tvisA);
    if (tvisA.item.pszText)
        Free(tvisA.item.pszText);
    return htitem;
}

//----------------------------------------------------------------
BOOL WINAPI W_TreeView_GetItem_fn(HWND hwnd, TV_ITEMW * pitem)
{
    if (g_fUnicodeTreeView)
        return SendMessage(hwnd, TVM_GETITEMW, 0, (LPARAM)pitem)!=0;

    BOOL fRet = SendMessageA(hwnd, TVM_GETITEMA, 0, (LPARAM)pitem)!=0;
    if (fRet && (pitem->mask & TVIF_TEXT) && pitem->pszText && (LPSTR_TEXTCALLBACKW != pitem->pszText))
    {
        int  cch = lstrlen((PSTR)pitem->pszText);
        PSTR psz = (PSTR)Malloc(cch+1);
        strcpy(psz, (PSTR)pitem->pszText);
        MultiByteToWideChar(_Module.GetCodePage(), 0, psz, -1, pitem->pszText, pitem->cchTextMax);
        Free(psz);
    }
    return fRet;
}

//----------------------------------------------------------------
BOOL WINAPI W_TreeView_SetItem_fn(HWND hwnd, TV_ITEMW * pitem)
{
    if (g_fUnicodeTreeView)
        return SendMessage(hwnd, TVM_SETITEMW, 0, (LPARAM)pitem)!=0;

    ASSERT(sizeof(TV_ITEMA)==sizeof(TV_ITEMW));
    if (0 == (pitem->mask & TVIF_TEXT) || (LPSTR_TEXTCALLBACKW == pitem->pszText))
        return SendMessageA(hwnd, TVM_SETITEMA, 0, (LPARAM)pitem)!=0;

    BOOL fRet;
    TV_ITEMA tviA;
    memcpy(&tviA, pitem, sizeof(TV_ITEMA));
    if (tviA.pszText)
    {
        tviA.cchTextMax = 1 + lstrlenW(pitem->pszText);
        tviA.pszText = (PSTR)Malloc(tviA.cchTextMax);
        if (NULL != tviA.pszText)
            tviA.cchTextMax = WideCharToMultiByte(_Module.GetCodePage(), 0, pitem->pszText, -1, tviA.pszText, tviA.cchTextMax, 0, 0);
        else
            tviA.cchTextMax = 0;
    }
    fRet = SendMessageA(hwnd, TVM_SETITEMA, 0, (LPARAM)&tviA)!=0;
    if (tviA.pszText)
        Free(tviA.pszText);
    return fRet;
}

//----------------------------------------------------------------
HWND WINAPI W_TreeView_EditLabel_fn(HWND hwnd, HTREEITEM hitem)
{
    return (HWND)SendMessage(hwnd, g_fUnicodeTreeView?TVM_EDITLABELW:TVM_EDITLABELA, 0, (LPARAM)(HTREEITEM)(hitem));
}

//----------------------------------------------------------------
BOOL WINAPI W_TreeView_GetISearchString_fn(HWND hwndTV, LPWSTR lpsz)
{
    if (g_fUnicodeTreeView)
        return SendMessage(hwndTV, TVM_GETISEARCHSTRINGW, 0, (LPARAM)(LPTSTR)lpsz)!=0;
    ASSERT(0); // NYI
    return FALSE;
}

//================================================================
// Tab Control
//================================================================
BOOL IsTabCtrlUnicode(HWND hwnd)
{
    int ii, jj;
    TC_ITEMW tci;
    ZeroMemory(&tci, sizeof(tci));
    tci.mask       = TCIF_TEXT;
    tci.pszText    = L"X";
    tci.cchTextMax = 2;
    ii = (int)(DWORD)SendMessageA(hwnd, TCM_INSERTITEMW, 0, (LPARAM)&tci);
    if (-1 == ii)
        return FALSE;

    ZeroMemory(&tci, sizeof(tci));
    tci.mask       = TCIF_TEXT;
    tci.pszText    = L"Y";
    tci.cchTextMax = 2;
    jj = (int)(DWORD)SendMessageA(hwnd, TCM_INSERTITEMW, 0, (LPARAM)&tci);
    if (-1 == jj || (jj == 0) )
	{
		if (ii >= 0)
			SendMessageA(hwnd, TCM_DELETEITEM, (WPARAM)ii, 0);
		if (jj >= 0)
			SendMessageA(hwnd, TCM_DELETEITEM, (WPARAM)jj, 0);
        return FALSE;
	}
    //
    // might have to try to get the item back like we must do the list view
    // delete the item we added
    SendMessageA(hwnd, TCM_DELETEITEM, (WPARAM)ii, 0);
    SendMessageA(hwnd, TCM_DELETEITEM, (WPARAM)jj, 0);
    return TRUE;
}

//----------------------------------------------------------------
BOOL WINAPI W_TabCtrl_GetItem_fn(HWND hwnd, int iItem, TC_ITEMW * pitem)
{
    if (g_fUnicodeTabCtrl)
        return SendMessage(hwnd, TCM_GETITEMW, (WPARAM)iItem, (LPARAM)pitem)!=0;
    if (0 == (TCIF_TEXT & pitem->mask))
        return SendMessageA(hwnd, TCM_GETITEMA, (WPARAM)iItem, (LPARAM)pitem)!=0;

    BOOL fRet = SendMessageA(hwnd, TCM_GETITEMA, 0, (LPARAM)pitem)!=0;
    if (fRet && (pitem->mask & TCIF_TEXT) && pitem->pszText && (LPSTR_TEXTCALLBACKW != pitem->pszText))
    {
        int  cch = lstrlen((PSTR)pitem->pszText);
        PSTR psz = (PSTR)_alloca(cch+1);
        strcpy(psz, (PSTR)pitem->pszText);
        MultiByteToWideChar(_Module.GetCodePage(), 0, psz, -1, pitem->pszText, pitem->cchTextMax);
    }
    return fRet;
}

//----------------------------------------------------------------
BOOL WINAPI W_TabCtrl_SetItem_fn(HWND hwnd, int iItem, TC_ITEMW * pitem)
{
    if (g_fUnicodeTabCtrl)
        return SendMessage(hwnd, TCM_SETITEMW, (WPARAM)iItem, (LPARAM)pitem)!=0;
    if (0 == (TCIF_TEXT & pitem->mask))
        return SendMessageA(hwnd, TCM_SETITEMA, (WPARAM)iItem, (LPARAM)pitem)!=0;

    ASSERT(pitem->pszText);
    int cch = lstrlenW(pitem->pszText)*W_cbchMaxAcp() + 1;
    PSTR psz = (PSTR)_alloca(cch);
    WideCharToMultiByte(_Module.GetCodePage(), 0, pitem->pszText, -1, psz, cch, 0, 0);

    TC_ITEMA item;
    ASSERT(sizeof(TC_ITEMA)==sizeof(TC_ITEMW));
    memcpy(&item, pitem, sizeof(TC_ITEMA));
    item.pszText = psz;
    item.cchTextMax = cch;
    return SendMessageA(hwnd, TCM_SETITEMA, (WPARAM)iItem, (LPARAM)&item)!=0;
}

//----------------------------------------------------------------
int  WINAPI W_TabCtrl_InsertItem_fn(HWND hwnd, int iItem, TC_ITEMW * pitem)
{
    if (g_fUnicodeTabCtrl)
        return (int)SendMessage(hwnd, TCM_INSERTITEMW, (WPARAM)iItem, (LPARAM)pitem);
    if (0 == (TCIF_TEXT & pitem->mask))
        return (int)SendMessageA(hwnd, TCM_INSERTITEMA, (WPARAM)iItem, (LPARAM)pitem);

    ASSERT(pitem->pszText);
    int cch = lstrlenW(pitem->pszText)*W_cbchMaxAcp() + 1;
    PSTR psz = (PSTR)_alloca(cch);
    WideCharToMultiByte(_CODEPAGE, 0, pitem->pszText, -1, psz, cch, 0, 0);

    TC_ITEMA item;
    ASSERT(sizeof(TC_ITEMA)==sizeof(TC_ITEMW));
    memcpy(&item, pitem, sizeof(TC_ITEMA));
    item.pszText = psz;
    item.cchTextMax = cch;
    return (int)SendMessageA(hwnd, TCM_INSERTITEMA, (WPARAM)iItem, (LPARAM)&item);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cdefinss.h ===
#ifndef __CDEFINESS_H__
#define __CDEFINESS_H__

#ifndef __CSUBSET_H__
#include "csubset.h"
#endif

#ifndef HHCTRL
#ifndef _CDLG_H_
#include "..\hha\cdlg.h"
#endif
#else
#include "cdlg.h"
#endif

#include <commctrl.h>

#ifndef HHCTRL
#include "..\hhw\resource.h"
#else
#include "resource.h"
#endif


#define SS_IMAGELIST_WIDTH 10
#define SS_IMAGELIST_HEIGHT 10
#define CWIDTH_IMAGE_LIST 16

#ifdef HHCTRL

class CChooseSubsets : public CDlg
{
public:
    CChooseSubsets(HWND hwndParent, CHHWinType* phh) : CDlg(hwndParent, CChooseSubsets::IDD) {
        m_phh = phh;
    }
    BOOL OnBeginOrEnd(void);

    enum { IDD = IDDLG_CHOOSE_SUBSETS };

private:
    CHHWinType* m_phh;
};

#endif  // HHCTRL


class CDefineSubSet : public CDlg
{

public:
    CDefineSubSet( HWND hwndParent, CSubSets *pSubSets, CInfoType *pInfoType, BOOL fHidden );
    ~CDefineSubSet();

    BOOL        InitTreeView(int);
    void        SetItemFont(HFONT hFont);
    int         IncState(int const type);
    int         GetITState(int const type );

    LRESULT     OnDlgMsg(UINT msg, WPARAM wParam, LPARAM lParam);
    LRESULT     TreeViewMsg(NM_TREEVIEW* pnmhdr);


    BOOL        Save(); // returns TRUE if a new SubSet in m_aSubSets.
    BOOL        OnBeginOrEnd();
    void        OnSelChange( UINT id );
    void        OnButton(UINT id);

    void        Refresh();
    BOOL        GetDisplayHidden() const { return m_pSubSets->m_fPredefined; }
    void        SetDisplayHidden( BOOL const fHidden) { m_pSubSets->m_fPredefined = fHidden; }

protected:
    HWND        m_hwndTree;     // The tree view that contains all the categories and ITs
public:
    BOOL        m_fSaveHHP;     // TRUE if need to save the HHP file with subset changes.

private:
    BOOL        m_fModified;    // TRUE if the subset has changed;
    CSubSets    *m_pSubSets;
    CSubSet     *m_pSubSet;     // used for current state of treeview items.
    CInfoType   *m_pInfoType;   // The IT and Categories available to choose from
    HTREEITEM   *m_pSSRoot;
    int         m_cFonts;
    HFONT*      m_ahfonts;
    HIMAGELIST  m_hil;


#ifdef HHCTRL
    enum { IDD = IDDLG_HH_DEFINESUBSET };
#else
    enum { IDD = IDD_DEFINESUBSET };
#endif

    enum {EXCLUSIVE, DONT_CARE, INCLUSIVE};
#define BOLD INCLUSIVE
#define NORMAL DONT_CARE

};


class CNameSubSet : public CDlg
{
public:
#ifdef HHCTRL
    CNameSubSet(HWND hwndParent, CStr &cszName, int max_text) : CDlg(hwndParent, IDD) ,m_csz(cszName){ m_max_text = max_text; }
#else
    CNameSubSet(HWND hwndParent, CStr &cszName, int max_text) : CDlg(IDD, hwndParent),m_csz(cszName){ m_max_text = max_text; }
#endif

    CStr &m_csz;
    int m_max_text;
    BOOL OnBeginOrEnd() {if (m_fInitializing)
                            {
                                SetFocus( IDC_SUBSET_NAME );
                                SetWindowText(IDC_SUBSET_NAME, m_csz.psz);
                                m_fInitializing = FALSE;
                            }
                            else
                            {
                                CStr cszTemp;
                                lcHeapCheck();
                                cszTemp.ReSize(80);
                                GetWindowText(IDC_SUBSET_NAME, cszTemp.psz, 79);
                                lcHeapCheck();
                                m_csz = cszTemp.psz;
                                lcHeapCheck();
                            }
                            return TRUE;
                        }

    enum {IDD = IDD_SUBSET_NAME };
};

#endif // __CSUBSET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cdefinss.cpp ===
#include "header.h"

#ifndef __CDEFINESS_H__
#include "CDefinSS.h"
#endif

#ifndef HHCTRL
#include "..\hhw\strtable.h"
#else
#include "strtable.h"
#include "secwin.h"
#include "adsearch.h"
#endif

LRESULT WINAPI TreeViewProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
void FreeChildrenAllocations(HWND hwndTreeView, HTREEITEM ti);
void AddChildren( TVITEM* pTvi, HWND hwndTreeView );



CDefineSubSet::CDefineSubSet( HWND hwndParent, CSubSets *pSubSets, CInfoType *pInfoType, BOOL fHidden=FALSE )
#ifdef HHCTRL
:CDlg( hwndParent, CDefineSubSet::IDD )
#else
:CDlg( CDefineSubSet::IDD, hwndParent )
#endif
{
    m_pSSRoot   = NULL;
    m_pInfoType = pInfoType;
    m_hwndTree  = NULL;
    m_cFonts    = 0;
    m_pSSRoot   =NULL;
    m_pSubSets = pSubSets;
    m_ahfonts = (HFONT*) lcCalloc(3 * sizeof(HFONT));
    m_cFonts=0;
    m_fModified = FALSE;

    m_pSubSet = new CSubSet( pInfoType->InfoTypeSize());
    m_pSubSet->m_pIT = m_pSubSets->m_pIT;

    int fnWeight = 100;
    int err_cnt=0;
    while( (m_cFonts<3) && (fnWeight<900) )
    {
        m_ahfonts[m_cFonts] = CreateFont( 0,0,0,0,
            fnWeight,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
            CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,DEFAULT_PITCH,NULL );
        if ( m_ahfonts[m_cFonts] )
        {
            m_cFonts++;
            fnWeight +=300;
            err_cnt=0;
        }
        else
        {
            fnWeight += 100;
            err_cnt++;
            if ( err_cnt == 3)
            {
                m_cFonts++;
                err_cnt=0;
            }
        }
    }
}




CDefineSubSet::~CDefineSubSet(void)
{
TV_ITEM hCur;

    hCur.hItem = TreeView_GetRoot(m_hwndTree);

    hCur.mask = TVIF_PARAM;
    if (TreeView_GetItem(m_hwndTree, &hCur) == TRUE)
    {
        if (hCur.lParam)
        {
            //delete ( *)hCur.lParam;
        }
    }

    if (IsValidWindow(m_hwndTree))
        DestroyWindow(m_hwndTree);

    if (m_cFonts)
    {
        for (int i = 0; i < m_cFonts; i++)
            if ( m_ahfonts[i] )
                DeleteObject(m_ahfonts[i]);
        lcFree(m_ahfonts);
    }

    if (m_hil)
        ImageList_Destroy(m_hil);

//    if ( m_pSubSet )
//        delete m_pSubSet;

}




__inline HTREEITEM Tree_AddItem(HWND hwndTree,
    HTREEITEM htiParent, int iImage, UINT cChildren, LPARAM lParam,
    TV_INSERTSTRUCT* ptcInsert)
{
    ptcInsert->hParent = htiParent;
    ptcInsert->item.iImage = iImage;
    ptcInsert->item.iSelectedImage = iImage;
    ptcInsert->item.cChildren = cChildren;
    ptcInsert->item.lParam = lParam;

    return TreeView_InsertItem(hwndTree, ptcInsert);
}



BOOL CDefineSubSet::InitTreeView(int iSubSet=0) //By Default the first subset is selected.
{

        // Suspend drawing to the treeview while it is being populated
//    ::SendMessage(m_hwndTree, WM_SETREDRAW, FALSE, 0);

    TV_INSERTSTRUCT tcAdd;
    tcAdd.hInsertAfter = TVI_LAST;
    tcAdd.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM;
    tcAdd.item.hItem = NULL;

    HTREEITEM CatParent = TVI_ROOT;
    if ( m_pSubSets && m_pSubSets->m_cur_Set )
        *m_pSubSet = *m_pSubSets->m_cur_Set;

    TreeView_DeleteAllItems( m_hwndTree );
    for ( int cat=0; cat<m_pInfoType->HowManyCategories(); cat++)
    {
        CStr cszTemp = m_pInfoType->GetCategoryString(cat+1);
        tcAdd.item.pszText = cszTemp.psz;
        tcAdd.item.cchTextMax = (int)strlen(tcAdd.item.pszText);
        CatParent = Tree_AddItem(m_hwndTree,
                                TVI_ROOT, // The parent tree item
                                0,         // image Number, categories all have image 0... the image does not change
                                (m_pInfoType->m_itTables.m_aCategories[cat-1].c_Types>0)?1:0, // # children
                                (LPARAM) NULL,
                                &tcAdd);
        if ( m_pSSRoot == NULL )
            m_pSSRoot = &CatParent;

        int type = m_pInfoType->GetFirstCategoryType(cat);
        while( type != -1 )
        {
            CStr cszTemp = m_pInfoType->GetInfoTypeName( type );
            tcAdd.item.pszText = cszTemp.psz;
            tcAdd.item.cchTextMax = (int)strlen( tcAdd.item.pszText );
            int iState = GetITState(type);
            SetItemFont( m_ahfonts[iState] );
            Tree_AddItem(m_hwndTree,
                         CatParent,
                         iState,    // The image number
                         0,         // no children
                         (LPARAM)type,
                         &tcAdd);
            type = m_pInfoType->GetNextITinCategory();
        }
    }

    if ( m_pInfoType->HowManyCategories() == 0 )
    {
        for (int type = 1; type<m_pInfoType->HowManyInfoTypes(); type++)
        {
            CStr cszTemp = m_pInfoType->GetInfoTypeName( type );
            tcAdd.item.pszText = cszTemp.psz;
            tcAdd.item.cchTextMax = (int)strlen( tcAdd.item.pszText );
            int iState = GetITState(type);
            SetItemFont( m_ahfonts[iState] );
            HTREEITEM hret = Tree_AddItem(m_hwndTree,
                         TVI_ROOT,
                         iState,    // The image number
                         0,         // no children
                         (LPARAM)type,
                         &tcAdd);
            if ( m_pSSRoot == NULL )
                m_pSSRoot = &hret;
        }
    }

        // Activate redraws to the treeview.
//    ::SendMessage(m_hwndTree, WM_SETREDRAW, TRUE, 0);

return TRUE;
}



int CDefineSubSet::GetITState(int const type )
{
INFOTYPE *pIT;

    if ( !m_pSubSet )
        return DONT_CARE;

    pIT = m_pSubSet->m_pInclusive + (type/32)*4;
    if ( *pIT & 1<<type )
    {
        return INCLUSIVE;
    }
    else
    {
        pIT = m_pSubSet->m_pExclusive + (type/32)*4;
        if( *pIT & 1<<type )
        {
            return EXCLUSIVE;
        }
            else
            {
                return DONT_CARE;
            }
    }
}

    // Incerement treeview item state
int CDefineSubSet::IncState(int const type)
{
    int state;
    INFOTYPE *pIT;

    if ( !m_pSubSet )
        return DONT_CARE;

    pIT = m_pSubSet->m_pInclusive + (type/32)*4;
    if ( *pIT & 1<<type )
    {
        state=EXCLUSIVE;
        DeleteIT(type, m_pSubSet->m_pInclusive);
        AddIT(type, m_pSubSet->m_pExclusive);
    }
    else
    {
        pIT = m_pSubSet->m_pExclusive + (type/32)*4;
        if( *pIT & 1<<type )
        {
            state = DONT_CARE;
            DeleteIT(type, m_pSubSet->m_pExclusive);
        }
            else
            {
                state = INCLUSIVE;
                AddIT( type, m_pSubSet->m_pInclusive);
            }
    }

    return state;
}


void CDefineSubSet::SetItemFont(HFONT hFont)
{
    return;

    if ( hFont == NULL )
        return;
    ::SendMessage(m_hwndTree, WM_SETFONT, (WPARAM) hFont, 0);
}


BOOL CDefineSubSet::OnBeginOrEnd()
{
    if ( m_fInitializing )
    {
#ifdef HHCTRL
        m_hwndTree = ::GetDlgItem(m_hWnd, IDC_TREE1);
        HWND hlistBox = ::GetDlgItem(m_hWnd, IDC_LIST_SUBSETS);
        m_hil = ImageList_LoadImage(_Module.GetResourceInstance(),
            MAKEINTRESOURCE(IDBMP_HH_SS_IMAGE_LIST),
            SS_IMAGELIST_WIDTH, 0, 0x00FF00FF, IMAGE_BITMAP, LR_DEFAULTCOLOR);
#else
        m_hwndTree = ::GetDlgItem(m_hdlg, IDC_TREE1);
        HWND hlistBox = ::GetDlgItem(m_hdlg, IDC_LIST_SUBSETS);
        m_hil = ImageList_LoadImage(HINST_THIS,
            MAKEINTRESOURCE(IDBMP_SS_IMAGE_LIST),
            SS_IMAGELIST_WIDTH, 0, CLR_NONE, IMAGE_BITMAP, LR_DEFAULTCOLOR);
#endif


        for (int i=0; i< m_pSubSets->HowManySubSets(); i++)
        {
            CSubSet *pSSTemp = m_pSubSets->GetSubSet(i);
            if (pSSTemp == NULL )
                continue;
            ::SendMessage(hlistBox, LB_ADDSTRING, 0, (LPARAM)(PCSTR)pSSTemp->m_cszSubSetName.psz);
        }
        if ( m_pSubSets->m_cur_Set )
            SetWindowText(IDC_SUBSET_NAME, m_pSubSets->m_cur_Set->m_cszSubSetName.psz);

        TreeView_SetImageList(m_hwndTree, m_hil, TVSIL_NORMAL);
        InitTreeView();
        m_fInitializing = FALSE;
    }
    else
    {
    }
    return TRUE;
}



BOOL CDefineSubSet::Save()
{
CStr cszSaveName;
#ifndef HHCTRL
        HWND hwndLb = ::GetDlgItem(m_hdlg, IDC_LIST_SUBSETS);
#else
        HWND hwndLb = ::GetDlgItem(m_hWnd, IDC_LIST_SUBSETS);
#endif

CStr csz1 = GetStringResource(IDS_SAVESUBSET);
CStr csz2 = GetStringResource(IDS_SAVESUBSET_TITLE);

    cszSaveName.ReSize(80);

#ifndef HHCTRL
        cszSaveName.GetText(m_hdlg, IDC_SUBSET_NAME );
#else
        cszSaveName.GetText(m_hWnd, IDC_SUBSET_NAME );
#endif

    if( ::MessageBox(NULL, csz1.psz, csz2.psz, MB_YESNO|MB_TASKMODAL) == IDYES )
    {

        CNameSubSet SSName( *this, cszSaveName, 79);
        if ( !SSName.DoModal() )
            return FALSE;

        if ( m_pSubSets->GetSubSetIndex( cszSaveName.psz) == -1 )
        {       // Add a new subset
            m_pSubSet->m_cszSubSetName = cszSaveName.psz;
            m_pSubSets->AddSubSet( m_pSubSet );
        }
        else
        {
            m_pSubSets->SelectSubSet( cszSaveName.psz );
            memcpy(m_pSubSets->m_cur_Set, m_pSubSet->m_pInclusive, m_pSubSet->m_ITSize);
            memcpy(m_pSubSets->m_cur_Set, m_pSubSet->m_pExclusive, m_pSubSet->m_ITSize);
        }
        m_pSubSets->m_cur_Set->BuildMask();
        m_fSaveHHP = TRUE;
        return TRUE;
    }
    return FALSE;
}


void CDefineSubSet::OnSelChange(UINT id)
{
#ifndef HHCTRL
        HWND hwndLb = ::GetDlgItem(m_hdlg, IDC_LIST_SUBSETS);
#else
        HWND hwndLb = ::GetDlgItem(m_hWnd, IDC_LIST_SUBSETS);
#endif

    if (id == IDC_LIST_SUBSETS )
    {
        INT_PTR iSel = ::SendMessage(hwndLb, LB_GETCURSEL, (WPARAM)0, (LPARAM)0L);
        int ilen = (int)::SendMessage(hwndLb, LB_GETTEXTLEN, (WPARAM)iSel, (LPARAM)0L);
        CStr cszNewSS;
        cszNewSS.ReSize(ilen+1);
        ::SendMessage(hwndLb, LB_GETTEXT, (WPARAM) iSel, (LPARAM)(PSTR)cszNewSS.psz);
        SetWindowText( IDC_SUBSET_NAME, cszNewSS.psz );

        if ( m_fModified )
            Save();
        m_fModified = FALSE;

        *m_pSubSet = *(m_pSubSets->SelectSubSet(cszNewSS.psz));
        InitTreeView();
    }

}



void CDefineSubSet::OnButton( UINT id )
{
CStr cszNewSubSet(IDS_NEW);

#ifndef HHCTRL
        HWND hwndLb = ::GetDlgItem(m_hdlg, IDC_LIST_SUBSETS);
#else
        HWND hwndLb = ::GetDlgItem(m_hWnd, IDC_LIST_SUBSETS);
#endif

    switch( id )
    {
    case IDC_REMOVE:
        {
        INT_PTR iSel=::SendMessage(hwndLb, LB_GETCURSEL, (WPARAM) 0, (LPARAM)(PSTR)m_pSubSet->m_cszSubSetName.psz);
        if ( strcmp(m_pSubSet->m_cszSubSetName.psz, cszNewSubSet.psz) == 0)
            break;
        ::SendMessage(hwndLb, LB_DELETESTRING, (WPARAM) iSel, (LPARAM)0L);
        m_pSubSets->RemoveSubSet( m_pSubSet->m_cszSubSetName.psz );
        int iLen = (int)::SendMessage(hwndLb, LB_GETTEXTLEN, (WPARAM) 1, (LPARAM) 0L);
        m_pSubSet->m_cszSubSetName.ReSize(iLen);
        ::SendMessage(hwndLb, LB_GETTEXT, (WPARAM) 1, (LPARAM)(PSTR)m_pSubSet->m_cszSubSetName);
        if ( !m_pSubSet->m_cszSubSetName.IsEmpty() )
        {
            m_pSubSets->SelectSubSet( m_pSubSet->m_cszSubSetName );
            ::SendMessage(hwndLb, LB_SETCURSEL, (WPARAM) 1, (LPARAM) 0L);
            Refresh();
        }
        else
        {
            SetWindowText( IDC_SUBSET_NAME, " ");
            m_pSubSet = NULL;
            m_pSubSets->m_cur_Set = NULL;
        }
        InitTreeView();
        m_fSaveHHP = TRUE;
        break;
        }
    case IDC_SAVE:
        if ( Save() )
        {
            INT_PTR iSel = ::SendMessage(hwndLb, LB_ADDSTRING, (WPARAM) 0, (LPARAM)(PSTR)m_pSubSet->m_cszSubSetName.psz);
            ::SendMessage(hwndLb, LB_SETCURSEL, (WPARAM) iSel, (LPARAM)0L);
            Refresh();
        }
        m_fModified = FALSE;
        break;
    case IDC_CLOSE:
        EndDialog( TRUE );
        break;
    }
}


void CDefineSubSet::Refresh()
{
#ifndef HHCTRL
        HWND hwndLb = ::GetDlgItem(m_hdlg, IDC_LIST_SUBSETS);
#else
        HWND hwndLb = ::GetDlgItem(m_hWnd, IDC_LIST_SUBSETS);
#endif
    INT_PTR iSel = ::SendMessage(hwndLb, LB_GETCURSEL, (WPARAM) 0, (LPARAM)0L);
    ::SendMessage(hwndLb, LB_SETCURSEL, (WPARAM) iSel, (LPARAM)0L);
    SetWindowText(IDC_SUBSET_NAME, m_pSubSet->m_cszSubSetName.psz);
}


LRESULT CDefineSubSet::OnDlgMsg(UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
    case WM_NOTIFY:
        TreeViewMsg( (NM_TREEVIEW*) lParam );
        break;
    default:
        ;
    }
    return FALSE;
}



LRESULT CDefineSubSet::TreeViewMsg(NM_TREEVIEW* pnmhdr)
{
    switch(pnmhdr->hdr.code) {

        // The return key cycles through the states of the
        // currently selected item in the treeview.
        case NM_RETURN:
            {
                TV_ITEM tvi;

                tvi.hItem = TreeView_GetSelection(m_hwndTree);
                if (!tvi.hItem)
                    break;

                tvi.mask = TVIF_PARAM;
                TreeView_GetItem(m_hwndTree, &tvi);

                if ( tvi.lParam == NULL )
                {                               // This is a category... expand and contract the category
                    if ( tvi.state & TVIS_EXPANDED )
                    {
                        TreeView_Expand( m_hwndTree, tvi.hItem, TVE_COLLAPSE );
                    }
                    else
                    {
                        TreeView_Expand( m_hwndTree, tvi.hItem, TVE_EXPAND );
                        // The first time we send the TVE_EXPAND message we get a TVIS_ITEMEXPANDING message for the item.
                        // The TVIS_ITEMEXPANDING message is not sent on subsequent expands of the same item.
                    }
                }
                else
                {
                        // Set the correct image
                    int iState = GetITState((int)tvi.lParam );
                    SetItemFont( m_ahfonts[iState] );
                    tvi.mask = TVIF_TEXT | TVIF_IMAGE;
                    tvi.iImage = iState;
                    CStr cszTemp = m_pInfoType->GetInfoTypeName( (int)tvi.lParam );
                    tvi.pszText = cszTemp.psz;
                    tvi.cchTextMax = (int)strlen(tvi.pszText);
                    TreeView_SetItem(m_hwndTree, tvi.hItem);
                }

            }

            break;

        case TVN_SELCHANGING:
            {
            HTREEITEM htemp = pnmhdr->itemNew.hItem;
            break;
            }

        case TVN_SELCHANGED:
            {
            HTREEITEM htemp = pnmhdr->itemNew.hItem;
            break;
            }

        case NM_CLICK:
            {
            HTREEITEM htemp = pnmhdr->itemNew.hItem;
            TV_HITTESTINFO ht;
                GetCursorPos(&ht.pt);
                ScreenToClient(m_hwndTree, &ht.pt);

                TreeView_HitTest(m_hwndTree, &ht);

                TV_ITEM tvi;

                tvi.hItem = ht.hItem;
                if (!tvi.hItem)
                    break;          // probably ENTER with no selection

                m_fModified = TRUE;
                tvi.mask = TVIF_PARAM|TVIF_IMAGE;
                TreeView_GetItem(m_hwndTree, &tvi);
                tvi.iImage = IncState((int)tvi.lParam);
                tvi.iSelectedImage = tvi.iImage;
                tvi.mask = TVIF_IMAGE|TVIF_SELECTEDIMAGE;
                SetItemFont(m_ahfonts[tvi.iImage]);
                TreeView_SetItem(m_hwndTree, &tvi);
            break;
            }
            /*
             * We want a single click to open a topic. We already process
             * the case where the selection changes, and we jump if it does.
             * However, the user may click an existing selection, in which
             * case we want to jump (because the jump may have failed when
             * the item was first selected. However, we need to post the
             * message so that the treeview control will finish processing
             * the click (which could result in a selection change.
             */
#ifdef NOTYET

            if (!m_fSuppressJump) {
                TV_HITTESTINFO ht;
                GetCursorPos(&ht.pt);
                ScreenToClient(m_hwndTree, &ht.pt);

                TreeView_HitTest(m_hwndTree, &ht);
                if (ht.flags & TVHT_ONITEMBUTTON)
                    break; // just clicking the button, so ignore

                TV_ITEM tvi;

                tvi.hItem = ht.hItem;
                if (!tvi.hItem)
                    break;          // probably ENTER with no selection

                tvi.mask = TVIF_PARAM;
                TreeView_GetItem(m_hwndTree, &tvi);
                pSiteMapEntry = m_sitemap.GetSiteMapEntry(tvi.lParam);
                PostMessage(FindMessageParent(m_hwndTree), WM_COMMAND, ID_TV_SINGLE_CLICK,
                    (LPARAM) TreeView_GetSelection(m_hwndTree));
            }
            break;

        case TVN_ITEMEXPANDING:
            {
                if (m_fHack) {
                    m_fHack = FALSE;
                    break;
                }
                SITEMAP_ENTRY* pSiteMapEntry = m_sitemap.GetSiteMapEntry(pnmhdr->itemNew.lParam);
                    // if click on vacant area of TOC Tree view there is no sitemap entry.
                if ( pSiteMapEntry == NULL )
                    break;

                // REVIEW: need to update this to support multiple images
                // for multiple levels, and also to support "new" images

                if (pnmhdr->action & TVE_EXPAND) {
                    if (pSiteMapEntry->iImage == 0)
                        pSiteMapEntry->iImage =
                            m_sitemap.GetImageNumber(pSiteMapEntry);
                    if (pSiteMapEntry->iImage < IMAGE_OPEN_FOLDER_NEW)
                        pSiteMapEntry->iImage++;
                }
                else {
                    ASSERT(pnmhdr->action & TVE_COLLAPSE);
                    ASSERT(pSiteMapEntry->iImage);
                    if ( (pSiteMapEntry->iImage>1) && (pSiteMapEntry->iImage <= IMAGE_OPEN_FOLDER_NEW) )
                        pSiteMapEntry->iImage--;
                }

                // Set the correct image

                Tree_SetImage(m_hwndTree,
                    pSiteMapEntry->iImage, pnmhdr->itemNew.hItem);
            }
            break;


            // The right click creates and displayes a popup menu with the three states.
            // If an item is selected on the menu the state of the currently hightlited
            // item changes to that state and the menu goes away.
        case NM_RCLICK:
            {
                HMENU hmenu = CreatePopupMenu();
                if (!hmenu)
                    break;

                // NOTICE: Changes here must be reflected in the binary toc verison of this menu

                if (!(m_dwStyles & TVS_SINGLEEXPAND)) {
                    HxAppendMenu(hmenu, MF_STRING, ID_EXPAND_ALL,
                        GetStringResource(IDS_EXPAND_ALL));
                    HxAppendMenu(hmenu, MF_STRING, ID_CONTRACT_ALL,
                        GetStringResource(IDS_CONTRACT_ALL));
                }
                HxAppendMenu(hmenu, MF_STRING, ID_PRINT,
                    GetStringResource(IDS_PRINT));

                ASSERT( m_pInfoType );
                    // populate the InfoType member object of the CToc
                if ( !m_pInfoType )
                {
                    if (m_phh && m_phh->m_phmData && m_phh->m_phmData->m_pdInfoTypes  )
                    {       // load from the global IT store
                        m_pInfoType = new CInfoType;
                        m_pInfoType->CopyTo( m_phh->m_phmData );
                    }else
                    {
                            // no global IT's; load from the .hhc IT store
                        m_pInfoType = new CInfoType;
                        *m_pInfoType = m_sitemap;
                    }

                }
                else
                {
                    // Set the infotypes bits to set all the types

                }
                    // If there are infotypes add the "customize" option to the popup menu
                if (m_pInfoType && m_pInfoType->HowManyInfoTypes() && m_pInfoType->GetFirstHidden() != 1)
                    HxAppendMenu(hmenu, MF_STRING, ID_CUSTOMIZE_INFO_TYPES,
                        GetStringResource(IDS_CUSTOMIZE_INFO_TYPES));

                if (IsHelpAuthor(FindMessageParent(m_hwndTree))) {
                    AppendMenu(hmenu, MF_SEPARATOR, 0, 0);
                    HxAppendMenu(hmenu, MF_STRING, ID_VIEW_ENTRY,
                        pGetDllStringResource(IDS_VIEW_ENTRY));
					if (NoRun() == FALSE)
						HxAppendMenu(hmenu, MF_STRING, ID_JUMP_URL, pGetDllStringResource(IDS_JUMP_URL));
                }
#ifdef _DEBUG
                HxAppendMenu(hmenu, MF_STRING, ID_VIEW_MEMORY,
                    "Debug: memory usage...");
#endif

                TV_HITTESTINFO ht;
                GetCursorPos(&ht.pt);
                ScreenToClient(m_hwndTree, &ht.pt);
                TreeView_HitTest(m_hwndTree, &ht);
                TreeView_Select(m_hwndTree, ht.hItem, TVGN_CARET);
                ClientToScreen(m_hwndTree, &ht.pt);
                TrackPopupMenu(hmenu,
                    TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON,
                    ht.pt.x, ht.pt.y, 0, FindMessageParent(m_hwndTree), NULL);
                DestroyMenu(hmenu);
                return TRUE;
            }
            break;
#endif  // NOTYET

    }
    return FALSE;
}

#ifdef HHCTRL


BOOL CChooseSubsets::OnBeginOrEnd(void)
{
    CSubSets* pSS;
    CSubSet* pS;
    int i,n;

    CDlgComboBox cbToc(m_hWnd, IDCOMBO_TOC);
    CDlgComboBox cbIndex(m_hWnd, IDCOMBO_INDEX);
    CDlgComboBox cbFTS(m_hWnd, IDCOMBO_SEARCH);

    if (Initializing())
    {
       if ( m_phh && m_phh->m_phmData && m_phh->m_phmData->m_pTitleCollection &&
            (pSS= m_phh->m_phmData->m_pTitleCollection->m_pSubSets) )
       {
          i = pSS->HowManySubSets();
          for (n = 0; n < i ; n++ )
          {
             if ( (pS = pSS->GetSubSet(n)) )
             {
                cbToc.AddString(pS->m_cszSubSetName.psz);
                cbIndex.AddString(pS->m_cszSubSetName.psz);
                cbFTS.AddString(pS->m_cszSubSetName.psz);
             }
          }
          //
          // Select current selections.
          //
          if ( pSS->m_Toc && pSS->m_Toc->m_cszSubSetName.psz )
             cbToc.SelectString(pSS->m_Toc->m_cszSubSetName.psz);
          else
             cbToc.SetCurSel(0);
          if ( pSS->m_Index && pSS->m_Index->m_cszSubSetName.psz )
             cbIndex.SelectString(pSS->m_Index->m_cszSubSetName.psz);
          else
             cbIndex.SetCurSel(0);
          if ( pSS->m_FTS && pSS->m_FTS->m_cszSubSetName.psz )
             cbFTS.SelectString(pSS->m_FTS->m_cszSubSetName.psz);
          else
             cbFTS.SetCurSel(0);
       }
    }
    else
    {
       if ( m_phh && m_phh->m_phmData && m_phh->m_phmData->m_pTitleCollection &&
            (pSS= m_phh->m_phmData->m_pTitleCollection->m_pSubSets) )
       {
          TCHAR szBuf[256];

          cbToc.GetLBText(szBuf, (int)cbToc.GetCurSel());
          pSS->SetTocMask(szBuf, m_phh);

          cbIndex.GetLBText(szBuf, (int)cbIndex.GetCurSel());
          pSS->SetIndexMask(szBuf);

          cbFTS.GetLBText(szBuf, (int)cbFTS.GetCurSel());
          pSS->SetFTSMask(szBuf);

#ifdef HHCTRL
          // Sync the search tab's subset combo. REVIEW:: Need event firing!
        // If the search tab exists, then update the combo box. Slimy! We need a notification scheme for tabs.
          if (m_phh->m_aNavPane[HH_TAB_SEARCH])
          {
             CAdvancedSearchNavPane* pSearch = reinterpret_cast<CAdvancedSearchNavPane*>(m_phh->m_aNavPane[HH_TAB_SEARCH]) ;
             pSearch->UpdateSSCombo() ;
          }
#endif

       }
    }
    return TRUE;
}

#endif  // HHCTRL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cdlg.h ===
// Copyright (C) 1993-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CDLG_H_
#define _CDLG_H_

#include "cstr.h"

#ifndef _INC_COMMCTRL
#include <commctrl.h>
#endif

#ifndef _HHCTRL_H_
#include "hhctrl.h"
#endif

#include "clistbox.h"
#include "lockout.h"

void STDCALL CenterWindow(HWND hwndParent, HWND hwnd);

class CDlgCheckListBox;

/*
 * Similar to CDialog, but calls OnCommand() instead of using a message
 * map (i.e., this uses a smaller working set then CDialog). When
 * initializing or when IDOK is processed, Cdlg calls OnBeginOrEnd() (or
 * m_pBeginOrEnd() for non-subclassed instances). CDlg includes
 * CDlg_ and DDV_ variants which can be used instead of the MFC versions.
 * Unlike MFC, CDlg_Text works with either a CStr or an array.
 */

class CDlg
{
public:
    typedef BOOL (* BEGIN_OR_END_PROC)(CDlg*);

    CDlg(HWND hwndParent, UINT idTemplate);
    CDlg(CHtmlHelpControl* phhCtrl, UINT idTemplate);
    ~CDlg();

    BOOL m_fInitializing;
    inline BOOL Initializing(void) { return m_fInitializing; }

    // Following defaults to TRUE to have dialog centered in it's parent

    BOOL m_fCenterWindow;

    int  DoModal(void);
    HWND DoModeless(void);

    // To create the dialog as a Unicode dialog when possible, call SetUnicode(TRUE).
    // When turned on, we'll attempt to create the dialog using CreateDialog[Param]W.
    // If this fails (i.e. on Win9x) the dialog will be created as Ansi, and IsUnicode will
    // thereafter return FALSE. Thus IsUnicode won't be accurate until you've called
    // DoModal or DoModeless. It WILL be accurate during dialog init.
    void SetUnicode(BOOL fUnicode) { m_fUnicode = fUnicode; }
    BOOL IsUnicode() const { return m_fUnicode; }

    // Called before IDOK and IDCANCEL are processed. Return TRUE to continue
    // processing.

    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) { return OnMsg(wParam); };

    /*
     * Return FALSE to cancel ending of the dialog, TRUE to accept.
     * m_fInitializing will be set to TRUE if this function is being called
     * to initialize the dialog.
     */

    virtual BOOL OnBeginOrEnd() { return TRUE; };

    // The following functions are always called unless the dialog is
    // shutting down. You can use these instead of using a msg list.

    virtual void OnButton(UINT id) { }; // called before processing OKAY and Cancel
    virtual void OnSelChange(UINT id) { };   // either list box or combo box
    virtual void OnDoubleClick(UINT id) { }; // either list box or combo box
    virtual void OnEditChange(UINT id) { };

    // Called for everything except WM_INITDIALOG, WM_COMMAND, WM_HELP, and
    // WM_CONTEXTMENU.

    virtual LRESULT OnDlgMsg(UINT msg, WPARAM wParam, LPARAM lParam) { return FALSE; }

    void InitializeSpinControl(UINT idSpin, UINT idBuddy, int minVal, int maxVal) const
        {
            SendMessage(idSpin, UDM_SETBUDDY, (WPARAM) GetDlgItem(idBuddy));
            SendMessage(idSpin, UDM_SETRANGE, 0, MAKELPARAM(maxVal, minVal));
        }

    HWND GetDlgItem(int idDlgControl) const {
#ifdef _DEBUG
        ASSERT_COMMENT(::GetDlgItem(m_hWnd, idDlgControl), "Invalid Dialog Item id");
#endif
        return ::GetDlgItem(m_hWnd, idDlgControl); };

    void SetWindowText(int idControl, PCSTR pszText) const { (void) ::SetWindowText(GetDlgItem(idControl), pszText); };
    void SetWindowText(int idControl, int idResource) const { (void) ::SetWindowText(GetDlgItem(idControl), GetStringResource(idResource)); };
    void SetWindowText(PCSTR pszText) const { (void) ::SetWindowText(m_hWnd, pszText); };
    void GetWindowText(int idControl, PSTR pszText, int cchMax = MAX_PATH) const { (void) ::GetWindowText(GetDlgItem(idControl), pszText, cchMax); };
    int  GetWindowTextLength(int id) const { return ::GetWindowTextLength(GetDlgItem(id)); };
    void SetFocus(int id) const { (void) ::SetFocus(GetDlgItem(id)); };
    void EndDialog(int result) const { (void) ::EndDialog(m_hWnd, result); };
    void EnableWindow(int id, BOOL fEnable = TRUE) const { (void) ::EnableWindow(GetDlgItem(id), fEnable); };
    void DisableWindow(int id) const { (void) ::EnableWindow(GetDlgItem(id), FALSE); };
    void SetWindowLong(int index, LONG lval) const { ::SetWindowLong(m_hWnd, index, lval); }

    int  GetCheck(int id) const { return (int) SendDlgItemMessage(m_hWnd, id, BM_GETCHECK, 0, 0L); };
    void SetCheck(int id, int check = TRUE) const { (void) SendDlgItemMessage(m_hWnd, id, BM_SETCHECK, (WPARAM)(int)(check), 0); };
    void UnCheck(int id) const { (void) SendDlgItemMessage(m_hWnd, id, BM_SETCHECK, FALSE, 0); };

    INT_PTR SendMessage(int id, UINT msg, WPARAM wParam = 0, LPARAM lParam = 0) const { return ::SendDlgItemMessage(m_hWnd, id, msg, wParam, lParam); };
    void ShowWindow(int id, int flag = SW_SHOW) const { ::ShowWindow(GetDlgItem(id), flag); };
    void HideWindow(int id) const { ::ShowWindow(GetDlgItem(id), SW_HIDE); };

    // Point this to a function if you don't want to subclass CDlg.
    // The function will be called instead of OnBeginOrEnd().

    BEGIN_OR_END_PROC m_pBeginOrEnd;

    HWND m_hWnd;
    BOOL m_fFocusChanged; // set to TRUE if you change focus during initialization
    LPCTSTR m_lpDialogTemplate;

    /////////////////////////////////////////////////////////////////////

    /*
        Fill these in before calling DoModal() to get Context-Sensitive Help

        Alternatively, put the following in your constructor or OnBeginOrEnd():

            BEGIN_HELPIDS()
                IDHHA_CHECK_EXTENDED_INFO, IDH_CHECK_EXTENDED_INFO,
            END_HELPIDS(AfxGetApp()->m_pszHelpFilePath)
    */

    DWORD* m_aHelpIds;
    PCSTR m_pszHelpFile;

    #define BEGIN_HELPIDS() \
        static const DWORD aHelpIds[] = {
    #define END_HELPIDS(pszHelpFile) \
            0, 0 \
        }; \
        m_aHelpIds = (DWORD*) aHelpIds; \
        m_pszHelpFile = pszHelpFile;

    /////////////////////////////////////////////////////////////////////

    // For notification messages (e.g., EN_CHANGE, BN_CLICKED)
    // initialize m_pmsglist and you don't need OnButton and OnCommand

    typedef void (CDlg::* CDLG_PROC)(void);

    typedef struct {
        UINT idMessage;
        UINT idControl;
        void (CDlg::* pfunc)(void);
    } CDLG_MESSAGE_LIST;

    #define ON_CDLG_BUTTON(idButton, pfunc) \
        { BN_CLICKED, idButton, (CDLG_PROC) pfunc },
    #define ON_CDLG_MSG(idMsg, idButton, pfunc) \
        { idMsg, idButton, (CDLG_PROC) pfunc },

    #define BEGIN_MSG_LIST() \
        static const CDLG_MESSAGE_LIST msglist[] = {
    #define END_MSG_LIST() \
        { 0, 0, 0 } }; \
        m_pmsglist = &msglist[0];

    /*
        Sample usage:

        BEGIN_MSG_LIST()
            ON_CDLG_BUTTON(IDHHA_ADD_FOO, AddFoo)
            ON_CDLG_MSG(EN_CHANGE, IDHHA_EDIT, FooChanged)
        END_MSG_LIST()

        SET_MSG_LIST;   // use in constructor or OnBeginOrEnd()

    */

    const CDLG_MESSAGE_LIST* m_pmsglist;
    CHtmlHelpControl* m_phhCtrl;

    void MakeCheckedList(int idLB);
    CDlgCheckListBox* m_pCheckBox;

    operator HWND() const
        { return m_hWnd; }

protected:
    friend BOOL STDCALL CDlgProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT OnContextMenu(HWND hwnd);
    LRESULT OnHelp(HWND hwnd);
    BOOL OnMsg(WPARAM wParam);

    HWND m_hwndParent;
    BOOL m_fModeLess;
    BOOL m_fShuttingDown;
    CLockOut m_LockOut;
private:
    BOOL m_fUnicode; // Do we attempt to create a Unicode dialog?
};

// Header-only classes for coding convenience

class CDlgComboBox
{
public:
    CDlgComboBox() { m_hWnd = NULL; }
    CDlgComboBox(HWND hwndParent, int id) {
        m_hWnd = GetDlgItem(hwndParent, id);
        ASSERT_COMMENT(m_hWnd, "Invalid Combo-box id");
        }
    void Initialize(int id) { ASSERT(m_hWnd); m_hWnd = GetDlgItem(GetParent(m_hWnd), id); };
    void Initialize(HWND hdlg, int id) { m_hWnd = ::GetDlgItem(hdlg, id); };

    INT_PTR  SendMessage(UINT msg, WPARAM wParam = 0, LPARAM lParam = 0) const { return ::SendMessage(m_hWnd, msg, wParam, lParam); };

    void Enable(BOOL fEnable = TRUE) const { EnableWindow(m_hWnd, fEnable); };

    int  GetText(PSTR psz, int cchMax = MAX_PATH) const { return GetWindowText(m_hWnd, psz, cchMax); };
    INT_PTR  GetLBText(PSTR psz, int iSel) const {
            return SendMessage(CB_GETLBTEXT, iSel, (LPARAM) psz); }
    int  GetTextLength() const { return GetWindowTextLength(m_hWnd); };
    void SetText(PCSTR psz) const { (void) ::SetWindowText(m_hWnd, psz); };

    INT_PTR  GetCount() const { return SendMessage(CB_GETCOUNT); };
    void ResetContent() const { SendMessage(CB_RESETCONTENT); };
    void Reset() const { SendMessage(CB_RESETCONTENT); };

    INT_PTR  AddString(PCSTR psz) const { return SendMessage(CB_ADDSTRING, 0, (LPARAM) psz); };
    INT_PTR  InsertString(int index, PCSTR psz) const { return SendMessage(CB_INSERTSTRING, index, (LPARAM) psz); };
    INT_PTR  DeleteString(int index) const { return SendMessage(CB_DELETESTRING, index); };

    INT_PTR  GetItemData(int index) const {  return SendMessage(CB_GETITEMDATA, index); };
    INT_PTR  SetItemData(int index, int data) const {  return SendMessage(CB_SETITEMDATA, index, data); };

    INT_PTR  GetCurSel() const { return SendMessage(CB_GETCURSEL); };
    void SetCurSel(int index = 0) const { (void) SendMessage(CB_SETCURSEL, index); };
    void SetEditSel(int iStart, int iEnd) const { (void) SendMessage(CB_SETEDITSEL, 0, MAKELPARAM(iStart, iEnd)); };
    void SelectEditContol(void) const { SendMessage(CB_SETEDITSEL, 0, MAKELPARAM(0, -1)); };

    INT_PTR  FindString(PCSTR pszString, int iStart = -1) const { return SendMessage(CB_FINDSTRING, iStart, (LPARAM) pszString); };
    INT_PTR  SelectString(PCSTR pszString, int iStart = -1) const { return SendMessage(CB_SELECTSTRING, iStart, (LPARAM) pszString); };

    HWND m_hWnd;
};

#endif  // _CDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\chistory.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CHISTORY_H__
#define __CHISTORY_H__

#define DEFAULT_HISTORY_COUNT 30

#include "navui.h" // Clean up headers

class CHistory : public INavUI
{
public:
   CHistory(PCSTR pszPastHistory);
   virtual ~CHistory();

    //---INavUI Interface Functions
public:
   BOOL  Create(HWND hwndParent);
   LRESULT OnCommand(HWND /*hwnd*/, UINT id, UINT uNotifiyCode, LPARAM /*lParam*/);
   void  ResizeWindow();
   void  SetFont(HFONT hfont) { m_hfont = hfont; }
   void  SetPadding(int pad) { m_padding = pad; }
   void  SetTabPos(int tabpos) { m_NavTabPos = tabpos; }

   void  HideWindow(void);
   void  ShowWindow(void);

    void    SetDefaultFocus() {/*Not Implemented*/}
    bool    ProcessMenuChar(HWND hwndParent, int ch) {/*NotImplemented*/ return false;}
    LRESULT OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam) {/*Not Implemented*/ return 1;}
    void OnDrawItem(UINT id, LPDRAWITEMSTRUCT pdis) {/*Not Implemented*/}
    void    Seed(LPCSTR pszSeed) {/*Not Implemented*/}
    void OnVKListNotify(NMHDR* pNMHdr) {/*Not Implemented*/}

    //--- Other interface functions.
   void  FillListBox(BOOL fReset = FALSE);

    //--- Member Variables.
   HWND  m_hwndEditBox;
   HWND  m_hwndListBox;
   HWND  m_hwndDisplayButton;
   HWND  m_hwndAddButton;

   BOOL  m_fSelectionChange;
   HFONT m_hfont;    // author-specified font to use for child windows
   int   m_padding;
   int   m_NavTabPos;   // location of parent tabs
   CTable   m_tblHistory;  // URLs
   CStr  m_cszPastHistory;
   BOOL  m_fModified;

   // The window passed into create is not the actual parent window of the
   // controls. Instead, the controls are always parented to the Navigation window
   // which owns the tabs. For resizing, we need to have a pointer to the 
   // tabctrl window. So, we save this pointer here.
   HWND m_hwndResizeToParent ;

};

#endif   // __CHistory_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cctlww.h ===
// cctlww.h - commctl Unicode wrapper
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Paul Chase Dempsey - paulde@microsoft.com
// August 3, 1998
//----------------------------------------------------------------
#ifndef __CCTLWW_H__
#define __CCTLWW_H__

#include <commctrl.h>

UINT WINAPI CodePageFromLCID(LCID lcid);

enum CCTLWINTYPE { W_ListView, W_TreeView, W_TabCtrl };

// Just like CreateWindowEx, but uses CCTLWINTYPE enumeration
HWND WINAPI W_CreateControlWindow (
    DWORD        dwStyleEx,
    DWORD        dwStyle,
    CCTLWINTYPE  wt,
    LPCWSTR      pwszTitle,
    int x, int y, int width, int height,
    HWND         parent,
    HMENU        menu,
    HINSTANCE    inst,
    LPVOID       lParam
    );

// Call this for controls created via a dialog
BOOL     WINAPI W_EnableUnicode (HWND hwnd, CCTLWINTYPE wt);

int      WINAPI W_CompareString (LCID lcid, DWORD dwFlags, PCWSTR str1, int cch1, PCWSTR str2, int cch2);
int      WINAPI W_cbchMaxAcp(); // max bytes per char for CP_ACP (less ugly name would be nice :-)

//================================================================
// Generic A/W utils to support creating windows as Unicode when possible

HWND     WINAPI W_CreateWindowEx (
    // Standard CreateWindowEx params
    DWORD     dwExStyle,
    LPCWSTR   lpClassName,
    LPCWSTR   lpWindowName,
    DWORD     dwStyle,
    int       X,
    int       Y,
    int       nWidth,
    int       nHeight,
    HWND      hWndParent,
    HMENU     hMenu,
    HINSTANCE hInstance,
    LPVOID    lpParam,
    // Return flag whether we got a Unicode one (may be NULL).
    // You can always call IsWindowUnicode() to see if an hwnd is Unicode.
    BOOL *    pfUnicode = NULL
    );

inline HWND WINAPI W_CreateWindow(LPCWSTR lpClassName, LPCWSTR lpWindowName, 
                                  DWORD dwStyle, 
                                  int x, int y, int nWidth, int nHeight, 
                                  HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam, 
                                  BOOL * pfUni = NULL)
{
    return  W_CreateWindowEx(0L, lpClassName, lpWindowName, 
        dwStyle, 
        x, y, nWidth, nHeight, 
        hWndParent, hMenu, hInstance, lpParam, pfUni);
}

void     WINAPI W_SubClassWindow        (HWND hwnd, LONG_PTR Proc, BOOL fUnicode);
WNDPROC  WINAPI W_GetWndProc            (HWND hwnd, BOOL fUnicode);
LRESULT  WINAPI W_DelegateWindowProc    (WNDPROC Proc, HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT  WINAPI W_DefWindowProc         (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT  WINAPI W_DefDlgProc            (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL     WINAPI W_HasText               (HWND hwnd);
int      WINAPI W_GetTextLengthExact    (HWND hwnd);
int      WINAPI W_GetWindowText         (HWND hwnd, PWSTR psz, int cchMax);
BOOL     WINAPI W_SetWindowText         (HWND hwnd, PCWSTR psz);
LRESULT  WINAPI W_SendStringMessage     (HWND hwnd, UINT msg, WPARAM wParam, PCWSTR psz);

// ComboBox
// '\n'-delimited list of strings, return length of returned string
int      WINAPI W_ComboBox_GetListText  (HWND hwnd, PWSTR psz, int cchMax);
// '\n'-delimited list of strings, return count of items added
int      WINAPI W_ComboBox_SetListText  (HWND hwnd, PWSTR psz, int cItemsMax);

#define W_ComboBox_AddString(hwnd, psz)              ((int)(DWORD)W_SendStringMessage((hwnd), CB_ADDSTRING, 0L, psz))
#define W_ComboBox_InsertString(hwnd, index, psz)    ((int)(DWORD)W_SendStringMessage((hwnd), CB_INSERTSTRING,    (WPARAM)(int)(index), psz))
#define W_ComboBox_FindStringExact(hwnd, index, psz) ((int)(DWORD)W_SendStringMessage((hwnd), CB_FINDSTRINGEXACT, (WPARAM)(int)(index), psz))
#define W_ComboBox_SelectString(hwnd, index, psz)    ((int)(DWORD)W_SendStringMessage((hwnd), CB_SELECTSTRING,    (WPARAM)(int)(index), psz))

//================================================================
// List View
//================================================================
BOOL     WINAPI W_IsListViewUnicode(HWND hwndLV);

BOOL WINAPI W_ListView_GetItem_fn          (HWND hwnd, LV_ITEMW * pitem);
BOOL WINAPI W_ListView_SetItem_fn          (HWND hwnd, LV_ITEMW * pitem);
int  WINAPI W_ListView_InsertItem_fn       (HWND hwnd, LV_ITEMW * pitem);
int  WINAPI W_ListView_FindItem_fn         (HWND hwnd, int iStart, LV_FINDINFOW * plvfi);
int  WINAPI W_ListView_GetStringWidth_fn   (HWND hwnd, LPCWSTR psz);
HWND WINAPI W_ListView_EditLabel_fn        (HWND hwnd, int i);
BOOL WINAPI W_ListView_GetColumn_fn        (HWND hwnd, int iCol, LV_COLUMNW * pcol);
BOOL WINAPI W_ListView_SetColumn_fn        (HWND hwnd, int iCol, LV_COLUMNW * pcol);
int  WINAPI W_ListView_InsertColumn_fn     (HWND hwnd, int iCol, LV_COLUMNW * pcol);
void WINAPI W_ListView_GetItemText_fn      (HWND hwnd, int i, int iSubItem_, LPWSTR  pszText_, int cchTextMax_);
void WINAPI W_ListView_SetItemText_fn      (HWND hwnd, int i, int iSubItem_, LPCWSTR pszText_);
BOOL WINAPI W_ListView_GetISearchString_fn (HWND hwnd, LPWSTR lpsz);
BOOL WINAPI W_ListView_SetBkImage_fn       (HWND hwnd, LPLVBKIMAGEW plvbki);
BOOL WINAPI W_ListView_GetBkImage_fn       (HWND hwnd, LPLVBKIMAGEW plvbki);

#define W_ListView_GetBkColor(hwnd)                         ListView_GetBkColor(hwnd)
#define W_ListView_SetBkColor(hwnd, clrBk)                  ListView_SetBkColor(hwnd, clrBk)
#define W_ListView_GetImageList(hwnd, iImageList)           ListView_GetImageList(hwnd, iImageList)
#define W_ListView_SetImageList(hwnd, himl, iImageList)     ListView_SetImageList(hwnd, himl, iImageList)
#define W_ListView_GetItemCount(hwnd)                       ListView_GetItemCount(hwnd)
#define W_ListView_GetItem(hwnd, pitem)                   W_ListView_GetItem_fn(hwnd, pitem)
#define W_ListView_SetItem(hwnd, pitem)                   W_ListView_SetItem_fn(hwnd, pitem)
#define W_ListView_InsertItem(hwnd, pitem)                W_ListView_InsertItem_fn(hwnd, pitem)
#define W_ListView_DeleteItem(hwnd, i)                      ListView_DeleteItem(hwnd, i)
#define W_ListView_DeleteAllItems(hwnd)                     ListView_DeleteAllItems(hwnd)
#define W_ListView_GetCallbackMask(hwnd)                    ListView_GetCallbackMask(hwnd)
#define W_ListView_SetCallbackMask(hwnd, mask)              ListView_SetCallbackMask(hwnd, mask)
#define W_ListView_GetNextItem(hwnd, i, flags)              ListView_GetNextItem(hwnd, i, flags)
#define W_ListView_FindItem(hwnd, iStart, plvfi)          W_ListView_FindItem_fn(hwnd, iStart, plvfi)
#define W_ListView_GetItemRect(hwnd, i, prc, code)          ListView_GetItemRect(hwnd, i, prc, code)
#define W_ListView_SetItemPosition(hwndLV, i, x, y)         ListView_SetItemPosition(hwndLV, i, x, y)
#define W_ListView_GetItemPosition(hwndLV, i, ppt)          ListView_GetItemPosition(hwndLV, i, ppt)
#define W_ListView_GetStringWidth(hwndLV, psz)            W_ListView_GetStringWidth_fn(hwndLV, psz)
#define W_ListView_HitTest(hwndLV, pinfo)                   ListView_HitTest(hwndLV, pinfo)
#define W_ListView_EnsureVisible(hwndLV, i, fPartialOK)     ListView_EnsureVisible(hwndLV, i, fPartialOK)
#define W_ListView_Scroll(hwndLV, dx, dy)                   ListView_Scroll(hwndLV, dx, dy)
#define W_ListView_RedrawItems(hwndLV, iFirst, iLast)       ListView_RedrawItems(hwndLV, iFirst, iLast)
#define W_ListView_Arrange(hwndLV, code)                    ListView_Arrange(hwndLV, code)
#define W_ListView_EditLabel(hwndLV, i)                   W_ListView_EditLabel_fn(hwndLV, i)
#define W_ListView_GetEditControl(hwndLV)                   ListView_GetEditControl(hwndLV)
#define W_ListView_GetColumn(hwnd, iCol, pcol)            W_ListView_GetColumn_fn(hwnd, iCol, pcol)
#define W_ListView_SetColumn(hwnd, iCol, pcol)            W_ListView_SetColumn_fn(hwnd, iCol, pcol)
#define W_ListView_InsertColumn(hwnd, iCol, pcol)         W_ListView_InsertColumn_fn(hwnd, iCol, pcol)
#define W_ListView_DeleteColumn(hwnd, iCol)                 ListView_DeleteColumn(hwnd, iCol)
#define W_ListView_GetColumnWidth(hwnd, iCol)               ListView_GetColumnWidth(hwnd, iCol)
#define W_ListView_SetColumnWidth(hwnd, iCol, cx)           ListView_SetColumnWidth(hwnd, iCol, cx)
#define W_ListView_GetHeader(hwnd)                          ListView_GetHeader(hwnd)
#define W_ListView_CreateDragImage(hwnd, i, lpptUpLeft)     ListView_CreateDragImage(hwnd, i, lpptUpLeft)
#define W_ListView_GetViewRect(hwnd, prc)                   ListView_GetViewRect(hwnd, prc)
#define W_ListView_GetTextColor(hwnd)                       ListView_GetTextColor(hwnd)
#define W_ListView_SetTextColor(hwnd, clrText)              ListView_SetTextColor(hwnd, clrText)
#define W_ListView_GetTextBkColor(hwnd)                     ListView_GetTextBkColor(hwnd)
#define W_ListView_SetTextBkColor(hwnd, clrTextBk)          ListView_SetTextBkColor(hwnd, clrTextBk)
#define W_ListView_GetTopIndex(hwndLV)                      ListView_GetTopIndex(hwndLV)
#define W_ListView_GetCountPerPage(hwndLV)                  ListView_GetCountPerPage(hwndLV)
#define W_ListView_GetOrigin(hwndLV, ppt)                   ListView_GetOrigin(hwndLV, ppt)
#define W_ListView_Update(hwndLV, i)                        ListView_Update(hwndLV, i)
#define W_ListView_SetItemState(hwndLV, i, data, mask)      ListView_SetItemState(hwndLV, i, data, mask)
#define W_ListView_GetItemState(hwndLV, i, mask)            ListView_GetItemState(hwndLV, i, mask)
#define W_ListView_GetCheckState(hwndLV, i)                 ListView_GetCheckState(hwndLV, i)
#define W_ListView_GetItemText(hwndLV, i, iSubItem_, pszText_, cchTextMax_) W_ListView_GetItemText_fn(hwndLV, i, iSubItem_, pszText_, cchTextMax_)
#define W_ListView_SetItemText(hwndLV, i, iSubItem_, pszText_)              W_ListView_SetItemText_fn(hwndLV, i, iSubItem_, pszText_)
#define W_ListView_SetItemCount(hwndLV, cItems)             ListView_SetItemCount(hwndLV, cItems)
#define W_ListView_SetItemCountEx(hwndLV, cItems, dwFlags)  ListView_SetItemCountEx(hwndLV, cItems, dwFlags)
#define W_ListView_SortItems(hwndLV, _pfnCompare, _lPrm)    ListView_SortItems(hwndLV, _pfnCompare, _lPrm)
#define W_ListView_SetItemPosition32(hwndLV, i, x, y)       ListView_SetItemPosition32(hwndLV, i, x, y)
#define W_ListView_GetSelectedCount(hwndLV)                 ListView_GetSelectedCount(hwndLV)
#define W_ListView_GetItemSpacing(hwndLV, fSmall)           ListView_GetItemSpacing(hwndLV, fSmall)
#define W_ListView_GetISearchString(hwndLV, lpsz)         W_ListView_GetISearchString_fn(hwndLV, lpsz)
#define W_ListView_SetIconSpacing(hwndLV, cx, cy)           ListView_SetIconSpacing(hwndLV, cx, cy)

#define W_ListView_SetExtendedListViewStyle(hwndLV, dw)             ListView_SetExtendedListViewStyle(hwndLV, dw)
#define W_ListView_SetExtendedListViewStyleEx(hwndLV, dwMask, dw)   ListView_SetExtendedListViewStyleEx(hwndLV, dwMask, dw)
#define W_ListView_GetExtendedListViewStyle(hwndLV)                 ListView_GetExtendedListViewStyle(hwndLV)
#define W_ListView_GetExtendedListViewStyle(hwndLV)                 ListView_GetExtendedListViewStyle(hwndLV)

#define W_ListView_GetSubItemRect(hwnd, iItem, iSubItem, code, prc) ListView_GetSubItemRect(hwnd, iItem, iSubItem, code, prc)
#define W_ListView_SubItemHitTest(hwnd, plvhti)                     ListView_SubItemHitTest(hwnd, plvhti)
#define W_ListView_SetColumnOrderArray(hwnd, iCount, pi)            ListView_SetColumnOrderArray(hwnd, iCount, pi)
#define W_ListView_GetColumnOrderArray(hwnd, iCount, pi)            ListView_GetColumnOrderArray(hwnd, iCount, pi)
#define W_ListView_SetHotItem(hwnd, i)                              ListView_SetHotItem(hwnd, i)
#define W_ListView_GetHotItem(hwnd)                                 ListView_GetHotItem(hwnd)
#define W_ListView_SetHotCursor(hwnd, hcur)                         ListView_SetHotCursor(hwnd, hcur)
#define W_ListView_GetHotCursor(hwnd)                               ListView_GetHotCursor(hwnd)
#define W_ListView_ApproximateViewRect(hwnd, iWidth, iHeight, iCount)   ListView_ApproximateViewRect(hwnd, iWidth, iHeight, iCount)
#define W_ListView_SetWorkAreas(hwnd, nWorkAreas, prc)              ListView_SetWorkAreas(hwnd, nWorkAreas, prc)
#define W_ListView_GetWorkAreas(hwnd, nWorkAreas, prc)              ListView_GetWorkAreas(hwnd, nWorkAreas, prc)
#define W_ListView_GetNumberOfWorkAreas(hwnd, pnWorkAreas)          ListView_GetNumberOfWorkAreas(hwnd, pnWorkAreas)
#define W_ListView_GetSelectionMark(hwnd)                           ListView_GetSelectionMark(hwnd)
#define W_ListView_SetSelectionMark(hwnd, i)                        ListView_SetSelectionMark(hwnd, i)
#define W_ListView_SetHoverTime(hwndLV, dwHoverTimeMs)              ListView_SetHoverTime(hwndLV, dwHoverTimeMs)
#define W_ListView_GetHoverTime(hwndLV)                             ListView_GetHoverTime(hwndLV)
#define W_ListView_SetToolTipHwnd(hwndLV, hwndNewHwnd)              ListView_SetToolTipHwnd(hwndLV, hwndNewHwnd)
#define W_ListView_GetToolTipHwnd(hwndLV)                           ListView_GetToolTipHwnd(hwndLV)
#define W_ListView_SetBkImage(hwnd, plvbki)                       W_ListView_SetBkImage_fn(hwnd, plvbki)
#define W_ListView_GetBkImage(hwnd, plvbki)                       W_ListView_GetBkImage_fn(hwnd, plvbki)

//================================================================
// Tree View
//================================================================
BOOL      WINAPI W_IsTreeViewUnicode(HWND hwndTV);
HTREEITEM WINAPI W_TreeView_InsertItem_fn(HWND hwnd, LPTV_INSERTSTRUCTW lpis);
BOOL WINAPI W_TreeView_GetItem_fn(HWND hwnd, TV_ITEMW * pitem);
BOOL WINAPI W_TreeView_SetItem_fn(HWND hwnd, TV_ITEMW * pitem);
HWND WINAPI W_TreeView_EditLabel_fn(HWND hwnd, HTREEITEM hitem);
BOOL WINAPI W_TreeView_GetISearchString_fn(HWND hwndTV, LPWSTR lpsz);

#define W_TreeView_InsertItem(hwnd, lpis)                   W_TreeView_InsertItem_fn(hwnd, lpis)
#define W_TreeView_DeleteItem(hwnd, hitem)                  TreeView_DeleteItem(hwnd, hitem)
#define W_TreeView_DeleteAllItems(hwnd)                     TreeView_DeleteAllItems(hwnd)
#define W_TreeView_Expand(hwnd, hitem, code)                TreeView_Expand(hwnd, hitem, code)
#define W_TreeView_GetItemRect(hwnd, hitem, prc, code)      TreeView_GetItemRect(hwnd, hitem, prc, code)
#define W_TreeView_GetCount(hwnd)                           TreeView_GetCount(hwnd)
#define W_TreeView_GetIndent(hwnd)                          TreeView_GetIndent(hwnd)
#define W_TreeView_SetIndent(hwnd, indent)                  TreeView_SetIndent(hwnd, indent)
#define W_TreeView_GetImageList(hwnd, iImage)               TreeView_GetImageList(hwnd, iImage)
#define W_TreeView_SetImageList(hwnd, himl, iImage)         TreeView_SetImageList(hwnd, himl, iImage)
#define W_TreeView_GetNextItem(hwnd, hitem, code)           TreeView_GetNextItem(hwnd, hitem, code)
#define W_TreeView_GetChild(hwnd, hitem)                    TreeView_GetChild(hwnd, hitem)          
#define W_TreeView_GetNextSibling(hwnd, hitem)              TreeView_GetNextSibling(hwnd, hitem)    
#define W_TreeView_GetPrevSibling(hwnd, hitem)              TreeView_GetPrevSibling(hwnd, hitem)    
#define W_TreeView_GetParent(hwnd, hitem)                   TreeView_GetParent(hwnd, hitem)         
#define W_TreeView_GetFirstVisible(hwnd)                    TreeView_GetFirstVisible(hwnd)          
#define W_TreeView_GetNextVisible(hwnd, hitem)              TreeView_GetNextVisible(hwnd, hitem)    
#define W_TreeView_GetPrevVisible(hwnd, hitem)              TreeView_GetPrevVisible(hwnd, hitem)    
#define W_TreeView_GetSelection(hwnd)                       TreeView_GetSelection(hwnd)             
#define W_TreeView_GetDropHilight(hwnd)                     TreeView_GetDropHilight(hwnd)           
#define W_TreeView_GetRoot(hwnd)                            TreeView_GetRoot(hwnd)                  
#define W_TreeView_GetLastVisible(hwnd)                     TreeView_GetLastVisible(hwnd)
#define W_TreeView_Select(hwnd, hitem, code)                TreeView_Select(hwnd, hitem, code)
#define W_TreeView_SelectItem(hwnd, hitem)                  TreeView_SelectItem(hwnd, hitem)            
#define W_TreeView_SelectDropTarget(hwnd, hitem)            TreeView_SelectDropTarget(hwnd, hitem)      
#define W_TreeView_SelectSetFirstVisible(hwnd, hitem)       TreeView_SelectSetFirstVisible(hwnd, hitem) 
#define W_TreeView_GetItem(hwnd, pitem)                   W_TreeView_GetItem_fn(hwnd, pitem)
#define W_TreeView_SetItem(hwnd, pitem)                   W_TreeView_SetItem_fn(hwnd, pitem)
#define W_TreeView_EditLabel(hwnd, hitem)                 W_TreeView_EditLabel_fn(hwnd, hitem)
#define W_TreeView_GetEditControl(hwnd)                     TreeView_GetEditControl(hwnd)
#define W_TreeView_GetVisibleCount(hwnd)                    TreeView_GetVisibleCount(hwnd)
#define W_TreeView_HitTest(hwnd, lpht)                      TreeView_HitTest(hwnd, lpht)
#define W_TreeView_CreateDragImage(hwnd, hitem)             TreeView_CreateDragImage(hwnd, hitem)
#define W_TreeView_SortChildren(hwnd, hitem, recurse)       TreeView_SortChildren(hwnd, hitem, recurse)
#define W_TreeView_EnsureVisible(hwnd, hitem)               TreeView_EnsureVisible(hwnd, hitem)
#define W_TreeView_SortChildrenCB(hwnd, psort, recurse)     TreeView_SortChildrenCB(hwnd, psort, recurse)
#define W_TreeView_EndEditLabelNow(hwnd, fCancel)           TreeView_EndEditLabelNow(hwnd, fCancel)
#define W_TreeView_SetToolTips(hwnd,  hwndTT)               TreeView_SetToolTips(hwnd,  hwndTT)
#define W_TreeView_GetToolTips(hwnd)                        TreeView_GetToolTips(hwnd)
#define W_TreeView_GetISearchString(hwndTV, lpsz)         W_TreeView_GetISearchString_fn(hwndTV, lpsz)
#define W_TreeView_SetInsertMark(hwnd, hItem, fAfter)       TreeView_SetInsertMark(hwnd, hItem, fAfter)
#define W_TreeView_SetItemHeight(hwnd,  iHeight)            TreeView_SetItemHeight(hwnd,  iHeight)
#define W_TreeView_GetItemHeight(hwnd)                      TreeView_GetItemHeight(hwnd)
#define W_TreeView_SetBkColor(hwnd, clr)                    TreeView_SetBkColor(hwnd, clr)
#define W_TreeView_SetTextColor(hwnd, clr)                  TreeView_SetTextColor(hwnd, clr)
#define W_TreeView_GetBkColor(hwnd)                         TreeView_GetBkColor(hwnd)
#define W_TreeView_GetTextColor(hwnd)                       TreeView_GetTextColor(hwnd)
#define W_TreeView_SetScrollTime(hwnd, uTime)               TreeView_SetScrollTime(hwnd, uTime)
#define W_TreeView_GetScrollTime(hwnd)                      TreeView_GetScrollTime(hwnd)


//================================================================
// TabCtrl
//================================================================
BOOL WINAPI W_IsTabCtrlUnicode(HWND hwndTC);
BOOL WINAPI W_TabCtrl_GetItem_fn(HWND hwnd, int iItem, TC_ITEMW * pitem);
BOOL WINAPI W_TabCtrl_SetItem_fn(HWND hwnd, int iItem, TC_ITEMW * pitem);
int  WINAPI W_TabCtrl_InsertItem_fn(HWND hwnd, int iItem, TC_ITEMW * pitem);

#define W_TabCtrl_GetImageList(hwnd)                        TabCtrl_GetImageList(hwnd)
#define W_TabCtrl_SetImageList(hwnd, himl)                  TabCtrl_SetImageList(hwnd, himl)
#define W_TabCtrl_GetItemCount(hwnd)                        TabCtrl_GetItemCount(hwnd)
#define W_TabCtrl_GetItem(hwnd, iItem, pitem)             W_TabCtrl_GetItem_fn(hwnd, iItem, pitem)
#define W_TabCtrl_SetItem(hwnd, iItem, pitem)             W_TabCtrl_SetItem_fn(hwnd, iItem, pitem)
#define W_TabCtrl_InsertItem(hwnd, iItem, pitem)          W_TabCtrl_InsertItem_fn(hwnd, iItem, pitem)
#define W_TabCtrl_DeleteItem(hwnd, i)                       TabCtrl_DeleteItem(hwnd, i)                                                        
#define W_TabCtrl_DeleteAllItems(hwnd)                      TabCtrl_DeleteAllItems(hwnd)                                                        
#define W_TabCtrl_GetItemRect(hwnd, i, prc)                 TabCtrl_GetItemRect(hwnd, i, prc)                                                        
#define W_TabCtrl_GetCurSel(hwnd)                           TabCtrl_GetCurSel(hwnd)                                                        
#define W_TabCtrl_SetCurSel(hwnd, i)                        TabCtrl_SetCurSel(hwnd, i)                                                        
#define W_TabCtrl_HitTest(hwndTC, pinfo)                    TabCtrl_HitTest(hwndTC, pinfo)                                                        
#define W_TabCtrl_SetItemExtra(hwndTC, cb)                  TabCtrl_SetItemExtra(hwndTC, cb)                                                        
#define W_TabCtrl_AdjustRect(hwnd, bLarger, prc)            TabCtrl_AdjustRect(hwnd, bLarger, prc)                                                        
#define W_TabCtrl_SetItemSize(hwnd, x, y)                   TabCtrl_SetItemSize(hwnd, x, y)                                                        
#define W_TabCtrl_RemoveImage(hwnd, i)                      TabCtrl_RemoveImage(hwnd, i)                                                        
#define W_TabCtrl_SetPadding(hwnd,  cx, cy)                 TabCtrl_SetPadding(hwnd,  cx, cy)                                                        
#define W_TabCtrl_GetRowCount(hwnd)                         TabCtrl_GetRowCount(hwnd)                                                        
#define W_TabCtrl_GetToolTips(hwnd)                         TabCtrl_GetToolTips(hwnd)                                                        
#define W_TabCtrl_SetToolTips(hwnd, hwndTT)                 TabCtrl_SetToolTips(hwnd, hwndTT)                                                        
#define W_TabCtrl_GetCurFocus(hwnd)                         TabCtrl_GetCurFocus(hwnd)                                                        
#define W_TabCtrl_SetCurFocus(hwnd, i)                      TabCtrl_SetCurFocus(hwnd, i)                                                        
#define W_TabCtrl_SetMinTabWidth(hwnd, x)                   TabCtrl_SetMinTabWidth(hwnd, x)                                                        
#define W_TabCtrl_DeselectAll(hwnd, fExcludeFocus)          TabCtrl_DeselectAll(hwnd, fExcludeFocus)                                                        
#define W_TabCtrl_HighlightItem(hwnd, i, fHighlight)        TabCtrl_HighlightItem(hwnd, i, fHighlight)                                                        
#define W_TabCtrl_SetExtendedStyle(hwnd, dw)                TabCtrl_SetExtendedStyle(hwnd, dw)                                                        
#define W_TabCtrl_GetExtendedStyle(hwnd)                    TabCtrl_GetExtendedStyle(hwnd)                                                        
#define W_TabCtrl_SetUnicodeFormat(hwnd, fUnicode)          TabCtrl_SetUnicodeFormat(hwnd, fUnicode)                                                        
#define W_TabCtrl_GetUnicodeFormat(hwnd)                    TabCtrl_GetUnicodeFormat(hwnd)                                                        

#endif // __CCTLWW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\chistory.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "hha_strtable.h"
#include "strtable.h"
#include "hhctrl.h"
#include "resource.h"
#include "chistory.h"
#include "secwin.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

#define BOX_HEIGHT 24
#define DEF_BUTTON_WIDTH 70

LRESULT WINAPI EditProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
extern WNDPROC lpfnlEditWndProc;

CHistory::CHistory(PCSTR pszPastHistory)
: m_hwndResizeToParent(NULL)
{
   if (pszPastHistory)
      m_cszPastHistory = pszPastHistory;

   m_hfont = NULL;
   m_fSelectionChange = FALSE;
   m_padding = 2;    // padding to put around the Index
   m_NavTabPos = HHWIN_NAVTAB_TOP; //BUGBUG: If the navpos is different this is broken.
   m_fModified = FALSE;
}

CHistory::~CHistory()
{
   if (m_hfont)
      DeleteObject(m_hfont);
}

BOOL CHistory::Create(HWND hwndParent)
{
   RECT rcParent, rcChild;

    // Save the hwndParent for ResizeWindow.
    m_hwndResizeToParent = hwndParent ;

    // Note: GetParentSize will return hwndNavigation if hwndParent is the
    // tab ctrl.
   hwndParent = GetParentSize(&rcParent, hwndParent, m_padding, m_NavTabPos);

   CopyRect(&rcChild, &rcParent);
   rcChild.bottom = rcChild.top + BOX_HEIGHT;

   m_hwndEditBox = CreateWindowEx(WS_EX_CLIENTEDGE, "edit", "",
      WS_CHILD | WS_BORDER | WS_TABSTOP | ES_AUTOHSCROLL, rcChild.left, rcChild.top,
      RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), hwndParent,
      (HMENU) IDEDIT_INDEX, _Module.GetModuleInstance(), NULL);

   if (!m_hwndEditBox)
      return FALSE;

   rcChild.bottom = rcParent.bottom - 2;
   rcChild.top = rcChild.bottom - BOX_HEIGHT;

   m_hwndDisplayButton = CreateWindow("button",
      GetStringResource(IDS_ENGLISH_DISPLAY),
      WS_CHILD | WS_TABSTOP, rcChild.left, rcChild.top,
      RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), hwndParent,
      (HMENU) IDBTN_DISPLAY, _Module.GetModuleInstance(), NULL);

   if (!m_hwndDisplayButton) {
      DestroyWindow(m_hwndEditBox);
      return FALSE;
   }

   // +2 for border, +BOX_HEIGHT for edit box, +5 for spacing.

   rcChild.top = rcParent.top + 2 + BOX_HEIGHT + 5;
   rcChild.bottom = rcParent.bottom - (2 + BOX_HEIGHT + 5);

   m_hwndListBox = CreateWindowEx(WS_EX_CLIENTEDGE, "listbox",
      "", WS_CHILD | WS_BORDER | WS_TABSTOP | WS_VSCROLL |
         LBS_NOTIFY,
      rcChild.left, rcChild.top, RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild),
      hwndParent, (HMENU) IDLB_INDEX, _Module.GetModuleInstance(), NULL);

   if (!m_hwndListBox) {
      DestroyWindow(m_hwndDisplayButton);
      DestroyWindow(m_hwndEditBox);
      return FALSE;
   }

   // Use a more readable font

   SendMessage(m_hwndListBox, WM_SETFONT,
      m_hfont ? (WPARAM) m_hfont : (WPARAM) _Resource.GetUIFont(), FALSE);
   SendMessage(m_hwndEditBox, WM_SETFONT,
      m_hfont ? (WPARAM) m_hfont : (WPARAM) _Resource.GetUIFont(), FALSE);
   SendMessage(m_hwndDisplayButton, WM_SETFONT,
      m_hfont ? (WPARAM) m_hfont : (WPARAM) _Resource.GetUIFont(), FALSE);

   // Sub-class the edit box

   if (lpfnlEditWndProc == NULL)
      lpfnlEditWndProc = (WNDPROC) GetWindowLongPtr(m_hwndEditBox, GWLP_WNDPROC);
   SetWindowLongPtr(m_hwndEditBox, GWLP_WNDPROC, (LONG_PTR) EditProc);

   FillListBox();

   return TRUE;
}

void CHistory::HideWindow(void)
{
   ::ShowWindow(m_hwndEditBox, SW_HIDE);
   ::ShowWindow(m_hwndListBox, SW_HIDE);
   ::ShowWindow(m_hwndDisplayButton, SW_HIDE);
}

void CHistory::ShowWindow(void)
{
   ::ShowWindow(m_hwndEditBox, SW_SHOW);
   ::ShowWindow(m_hwndListBox, SW_SHOW);
   ::ShowWindow(m_hwndDisplayButton, SW_SHOW);
}

void CHistory::ResizeWindow()
{
    ASSERT(::IsValidWindow(m_hwndDisplayButton)) ;

    // Resize to fit the client area of the parent.
    HWND hwndParent = m_hwndResizeToParent ; // Use the original window.
    ASSERT(::IsValidWindow(hwndParent)) ;


   RECT rcParent, rcChild;
   GetParentSize(&rcParent, hwndParent, m_padding, m_NavTabPos);

   CopyRect(&rcChild, &rcParent);
   rcChild.bottom = rcChild.top + BOX_HEIGHT;
   MoveWindow(m_hwndEditBox, rcChild.left,
      rcChild.top, RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), TRUE);

   rcChild.bottom = rcParent.bottom - 2;
   rcChild.top = rcChild.bottom - BOX_HEIGHT;
   rcChild.left = rcChild.right - DEF_BUTTON_WIDTH;
   MoveWindow(m_hwndDisplayButton, rcChild.left,
      rcChild.top, RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), TRUE);

   // +2 for border, +BOX_HEIGHT for edit box, +5 for spacing.

   rcChild.top = rcParent.top + 2 + BOX_HEIGHT + 5;
   rcChild.bottom = rcParent.bottom - (2 + BOX_HEIGHT + 5);
   MoveWindow(m_hwndListBox, rcParent.left,
      rcChild.top, RECT_WIDTH(rcParent), RECT_HEIGHT(rcChild), TRUE);
}

void CHistory::FillListBox(BOOL fReset)
{
   // BUGBUG: do we need this?
}

// This function has the lookup code, so we want it as fast as possible

LRESULT CHistory::OnCommand(HWND /*hwnd*/, UINT id, UINT uNotifiyCode, LPARAM /*lParam*/)
{
#if 0
   CStr cszKeyword;
   int pos;
   SITEMAP_ENTRY* pSiteMapEntry;
   int i;

   switch (id) {
      case IDEDIT_INDEX:
       {
         if (uNotifiyCode != EN_CHANGE)
            return 0;
         if (m_fSelectionChange) {
            m_fSelectionChange = FALSE;
            return 0;
         }

         CStr cszKeyword(m_hwndEditBox);
         if (!*cszKeyword.psz)
            return 0;

         /*
          * REVIEW: This could be sped up by having a first character
          * lookup, ala the RTF tokens in lex.cpp (hcrtf). Putting this
          * in the thread would also improve user responsiveness.
          */

         for (i = 1; i <= CountStrings(); i++) {
            pSiteMapEntry = GetSiteMapEntry(i);
            ASSERT_COMMENT(pSiteMapEntry->GetKeyword(), "Index entry added without a keyword");

            /*
             * Unless the user specifically requested it, we don't
             * allow the keyboard to be used to get to anything other
             * then first level entries.
             */

            if (!g_fNonFirstKey && pSiteMapEntry->GetLevel() > 1)
               continue;

            // BUGBUG: isSameString is not lcid aware

            if (isSameString(pSiteMapEntry->GetKeyword(), cszKeyword)) {
               SendMessage(m_hwndListBox, LB_SETCURSEL, i - 1, 0);
               break;
            }
         }
        }
        return 0;

      case IDLB_INDEX:
         switch (uNotifiyCode) {
            case LBN_SELCHANGE:
               if ((pos = SendMessage(m_hwndListBox,
                     LB_GETCURSEL, 0, 0L)) == LB_ERR)
                  return 0;
               pSiteMapEntry = GetSiteMapEntry(pos + 1);

               m_fSelectionChange = TRUE; // ignore EN_CHANGE
               SetWindowText(m_hwndEditBox, pSiteMapEntry->GetKeyword());
               m_fSelectionChange = FALSE; // ignore EN_CHANGE
               return 0;

            case LBN_DBLCLK:
               PostMessage(FindMessageParent(m_hwndListBox), WM_COMMAND,
                  MAKELONG(IDBTN_DISPLAY, BN_CLICKED), 0);
               return 0;
         }
         return 0;

      case IDBTN_DISPLAY:
         if (uNotifiyCode == BN_CLICKED) {
            if ((pos = SendMessage(m_hwndListBox,
                  LB_GETCURSEL, 0, 0L)) == LB_ERR)
               return 0;
            CStr cszKeyword(m_hwndEditBox);
            pSiteMapEntry = GetSiteMapEntry(pos + 1);

#ifdef _DEBUG
PCSTR pszKeyword = pSiteMapEntry->GetKeyword();
#endif

            int cbKeyword = strlen(cszKeyword);
            if (strlen(pSiteMapEntry->GetKeyword()) < cbKeyword ||
                  CompareString(g_lcidSystem, NORM_IGNORECASE,
                     pSiteMapEntry->GetKeyword(), cbKeyword,
                     cszKeyword, cbKeyword) != 2) {
               MsgBox(IDS_NO_SUCH_KEYWORD);
               SetFocus(m_hwndEditBox);
               return 0;
            }

            if (pSiteMapEntry->fSeeAlso) {

               /*
                * A See Also entry simply jumps to another location
                * in the Index.
                */

               SetWindowText(m_hwndEditBox,
                  GetUrlString(pSiteMapEntry->pUrls->urlPrimary));
               return 0;
            }

            // If we have one or more titles, then give the user
            // a choice of what to jump to.

            if (pSiteMapEntry->cUrls > 1) {
               CHistoryTopics dlgTopics(
                  m_phhctrl ? m_phhctrl->m_hwnd : FindMessageParent(m_hwndEditBox),
                     pSiteMapEntry, this);
               if (m_phhctrl)
                  m_phhctrl->ModalDialog(TRUE);
               int fResult = dlgTopics.DoModal();
               if (m_phhctrl)
                  m_phhctrl->ModalDialog(FALSE);
               if (fResult)
                  JumpToUrl(m_pOuter, m_hwndListBox, pSiteMapEntry, this, dlgTopics.m_pUrl);
               SetFocus(m_hwndEditBox);
               return 0;
            }
            JumpToUrl(m_pOuter, m_hwndListBox, pSiteMapEntry, this, NULL);
            SetFocus(m_hwndEditBox);
         }
         return 0;

      case ID_VIEW_ENTRY:
         {
            if ((pos = SendMessage(m_hwndListBox,
                  LB_GETCURSEL, 0, 0L)) == LB_ERR)
               return 0;
            pSiteMapEntry = GetSiteMapEntry(pos + 1);
            DisplayAuthorInfo(this, pSiteMapEntry, FindMessageParent(m_hwndListBox), m_phhctrl);
         }
         return 0;

#ifdef _DEBUG
      case ID_VIEW_MEMORY:
         OnReportMemoryUsage();
         return 0;
#endif
   }
#endif   // 0
   return 0;
}

void CHHWinType::CreateHistoryTab(void)
{
#ifdef _DEBUG
   CHistory* pHistory = new CHistory(NULL);
    m_aNavPane[HH_TAB_HISTORY] = pHistory ;
   pHistory->SetPadding(10);
   pHistory->SetTabPos(tabpos);
   pHistory->Create((m_pTabCtrl ? m_pTabCtrl->hWnd() : hwndNavigation));
#endif
}

void CHHWinType::AddToHistory(PCSTR pszTitle, PCSTR pszUrl)
{
#ifndef _DEBUG
   return;
#else
   if (!m_aNavPane[HH_TAB_HISTORY])
      return;
    CHistory* pHistory = (CHistory*)m_aNavPane[HH_TAB_HISTORY]; //HACKHACK: Needs dynamic_cast.

   CDlgListBox lb;
   lb.m_hWnd = pHistory->m_hwndListBox;
   int lbpos = (int)lb.FindString(pszTitle);

   if (lbpos == LB_ERR) {

      /*
       * OnTitleChange gets called before we have the real title, so the
       * title may actually change. If so, we want to delete the previous
       * title and  the new one.
       */

      int pos = pHistory->m_tblHistory.IsStringInTable(pszUrl);
      if (pos > 0) {
         INT_PTR cbItems = lb.GetCount();
         ASSERT(cbItems != LB_ERR);
         for (int i = 0; i < cbItems; i++) {
            if (pos == lb.GetItemData(i))
               break;
         }
         if (i < cbItems)
            lb.DeleteString(i);
         if (IsProperty(HHWIN_PROP_CHANGE_TITLE))
            SetWindowText(*this, pszTitle);
      }
      else
         pos = pHistory->m_tblHistory.AddString(pszUrl);
      int lbpos = (int)lb.AddString(pszTitle);
      lb.SetItemData(lbpos, pos);
   }
   else {
      if (IsProperty(HHWIN_PROP_CHANGE_TITLE))
         SetWindowText(*this, pszTitle);
   }
   lb.SetCurSel(lbpos);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cdlg.cpp ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

#include "header.h"
#include "cdlg.h"
#include "strtable.h"
#include "cpaldc.h"

// CLockOut for disabling the outer level windows.
#include "lockout.h"

#ifndef IDBMP_CHECK
#include "resource.h"
#endif

static BOOL WINAPI EnumFontProc(HWND hwnd, LPARAM lval);
static BOOL WINAPI EnumBidiSettings(HWND hwnd, LPARAM lval);

CDlg::CDlg(HWND hwndParent, UINT idTemplate)
{
    ZERO_INIT_CLASS(CDlg);
    m_hwndParent = hwndParent;
	if(g_bWinNT5)
	    m_lpDialogTemplate = (char *)MAKEINTRESOURCEW(idTemplate);
	else
	    m_lpDialogTemplate = MAKEINTRESOURCE(idTemplate);
    m_fCenterWindow = TRUE;
    m_phhCtrl = NULL;
	m_fUnicode = g_bWinNT5;
}

CDlg::CDlg(CHtmlHelpControl* phhCtrl, UINT idTemplate)
{
    ZERO_INIT_CLASS(CDlg);
    ASSERT(phhCtrl);
    m_hwndParent = phhCtrl->m_hwnd;
	if(g_bWinNT5)
	    m_lpDialogTemplate = (char *)MAKEINTRESOURCEW(idTemplate);
	else
	    m_lpDialogTemplate = MAKEINTRESOURCE(idTemplate);
    m_fCenterWindow = TRUE;
    m_phhCtrl = phhCtrl;
	m_fUnicode = g_bWinNT5;
}

int CDlg::DoModal(void)
{
    if (m_phhCtrl)
        m_phhCtrl->ModalDialog(TRUE);
    else
        m_LockOut.LockOut(m_hwndParent) ;

    int result = -1;
    if (m_fUnicode || g_bWinNT5)
    {
        result = (int)::DialogBoxParamW(_Module.GetResourceInstance(), (LPCWSTR)m_lpDialogTemplate,
            m_hwndParent, (DLGPROC) CDlgProc, (LPARAM) this);
        // Docs say this returns -1 for failure, but returns 0 on 
        // Win95 like other unimplemented APIs.
        if (0 == result)
        {
            if (ERROR_CALL_NOT_IMPLEMENTED == GetLastError())
            {
                m_fUnicode = FALSE;
                goto _Ansi;
            }
        }
    }
    else
    {
_Ansi:  result = (int)::DialogBoxParamA(_Module.GetResourceInstance(), m_lpDialogTemplate,
            m_hwndParent, (DLGPROC) CDlgProc, (LPARAM) this);
    }

    if (m_phhCtrl)
        m_phhCtrl->ModalDialog(FALSE);

    return result;
}

CDlg::~CDlg()
{
    if (m_fModeLess && IsValidWindow(m_hWnd))
        DestroyWindow(m_hWnd);
    if (m_pCheckBox)
        delete m_pCheckBox;
}

void STDCALL CenterWindow(HWND hwndParent, HWND hwnd)
{
    RECT rcParent, rc;

    //BUGBUG: This is broken in the multiple monitor case.

    if (!hwndParent)
        hwndParent = GetDesktopWindow();

    GetWindowRect(hwndParent, &rcParent);
    GetWindowRect(hwnd, &rc);

    int cx = RECT_WIDTH(rc);
    int cy = RECT_HEIGHT(rc);
    int left = rcParent.left + (RECT_WIDTH(rcParent) - cx) / 2;
    int top  = rcParent.top + (RECT_HEIGHT(rcParent) - cy) / 2;

    // Make certain we don't cover the tray
    // Also make sure that the dialog box is completely visible.
    // If its not visible, then let the default happen.
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);
    if (left < rc.left)
        left = rc.left;
    if (top < rc.top)
        top = rc.top;

    // BUG 2426: Make sure that the window is visible.
    if (left+cx > rc.right)
        left = rc.right - cx ;
    if (top+cy > rc.bottom)
        top = rc.bottom - cy ;

    // Make sure that the dialog still fits.
    ASSERT(left >= rc.left && top >= rc.top);

    // Make sure that the window is completely visible before doing the move:
    MoveWindow(hwnd, left, top, cx, cy, TRUE);
}

BOOL CALLBACK CDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CDlg* pThis = (CDlg*) GetWindowLongPtr(hdlg, GWLP_USERDATA);

    switch (msg) {
        case WM_INITDIALOG:
            // Save this pointer in the window data area
            pThis = (CDlg*) lParam;
            SetWindowLongPtr(hdlg, GWLP_USERDATA, lParam);
            pThis->m_hWnd = hdlg;
            pThis->m_fInitializing = TRUE; // reset when IDOK processed

            if (pThis->m_fCenterWindow)
                CenterWindow(pThis->m_hwndParent, pThis->m_hWnd);

            if (pThis->m_pBeginOrEnd)
                pThis->m_pBeginOrEnd(pThis);
            else
                pThis->OnBeginOrEnd();

			// set the correct font
			//
			if(g_bWinNT5)
				EnumChildWindows(hdlg, (WNDENUMPROC) EnumFontProc, 0);

            if (g_fBiDi) {
                // If BiDi, make adjustments to list and combo boxes

                EnumChildWindows(hdlg, (WNDENUMPROC) EnumBidiSettings, 0);
            }

            if (pThis->m_aHelpIds)
                SetWindowLong(hdlg, GWL_EXSTYLE,
                    GetWindowLong(hdlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // If we're threaded, we may be behind our caller

            SetWindowPos(hdlg, HWND_TOP, 0, 0, 0, 0,
               SWP_NOMOVE | SWP_NOSIZE);

            //BUG 2035: Return TRUE to tell windows to set the keyboard focus.
            // m_fFocusChanged is FALSE if the derived class hasn't changed it.
            return !pThis->m_fFocusChanged;

        case WM_COMMAND:
            {
                pThis = (CDlg*) GetWindowLongPtr(hdlg, GWLP_USERDATA);
                if (!pThis || pThis->m_fShuttingDown)
                    return FALSE; // pThis == NULL if a spin control is being initialized

                switch (HIWORD(wParam)) {
                    case BN_CLICKED:
                        pThis->OnButton(LOWORD(wParam));
                        break;

                    case LBN_SELCHANGE: // same value as CBN_SELCHANGE
                        pThis->OnSelChange(LOWORD(wParam));
                        break;

                    case LBN_DBLCLK:    // same value as CBN_DBLCLK
                        pThis->OnDoubleClick(LOWORD(wParam));
                        break;

                    case EN_CHANGE:
                        pThis->OnEditChange(LOWORD(wParam));
                        break;
                }

                // If m_pmsglist is set, OnCommand will call OnMsg

                if (!pThis->OnCommand(wParam, lParam))
                    return FALSE;

                BOOL fResult;

                switch (LOWORD(wParam)) {
                    case IDOK:
                        pThis->m_fInitializing = FALSE;
                        fResult = -1;

                        if (pThis->m_pBeginOrEnd)
                            fResult = pThis->m_pBeginOrEnd(pThis);
                        else
                            fResult = pThis->OnBeginOrEnd();

                        if (!fResult)
                            break;

                        if (pThis->m_fModeLess) {
                            pThis->m_fShuttingDown = TRUE;
                            PostMessage(hdlg, WM_CLOSE, 0, 0);
                        }
                        else
                            pThis->m_LockOut.Unlock();
                            EndDialog(hdlg, TRUE);
                        break;

                    case IDCANCEL:
                        if (pThis->m_fModeLess) {
                            pThis->m_fShuttingDown = TRUE;
                            PostMessage(hdlg, WM_CLOSE, 0, 0);
                        }
                        else
                            pThis->m_LockOut.Unlock();
                            EndDialog(hdlg, FALSE);
                        break;

                    case IDNO:
                        if (pThis->m_fModeLess) {
                            pThis->m_fShuttingDown = TRUE;
                            PostMessage(hdlg, WM_CLOSE, 0, 0);
                        }
                        else
                            pThis->m_LockOut.Unlock();
                            EndDialog(hdlg, IDNO);
                        break;

                    case IDRETRY:
                        if (pThis->m_fModeLess) {
                            pThis->m_fShuttingDown = TRUE;
                            PostMessage(hdlg, WM_CLOSE, 0, 0);
                        }
                        else
                            pThis->m_LockOut.Unlock();
                            EndDialog(hdlg, IDRETRY);
                        break;

                    default:
                        break;
                }
            }
            break;

        case WM_HELP:
            pThis->OnHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle);
            break;

        case WM_CONTEXTMENU:
            pThis->OnContextMenu((HWND) wParam);
            break;

        case WM_DRAWITEM:
            if (!pThis)
                return FALSE;

            if (pThis->m_pCheckBox &&
                    GetDlgItem(hdlg, (int)wParam) == pThis->m_pCheckBox->m_hWnd) {
                ASSERT(IsValidWindow(pThis->m_pCheckBox->m_hWnd));
                pThis->m_pCheckBox->DrawItem((DRAWITEMSTRUCT*) lParam);
                return TRUE;
            }
            else
                return (int)pThis->OnDlgMsg(msg, wParam, lParam);

        case WM_VKEYTOITEM:
            if (pThis && pThis->m_pCheckBox && (HWND) lParam == pThis->m_pCheckBox->m_hWnd) {
                if (LOWORD(wParam) == VK_SPACE) {
                    int cursel = (int)pThis->m_pCheckBox->GetCurSel();
                    if (cursel != LB_ERR)
                        pThis->m_pCheckBox->ToggleItem(cursel);
                }
                return -1;  // always perform default action
            }
            else
                return (int)pThis->OnDlgMsg(msg, wParam, lParam);

        default:
            if (pThis)
                return (int)pThis->OnDlgMsg(msg, wParam, lParam);
            else
                return FALSE;
    }

    return FALSE;
}

/***************************************************************************

    FUNCTION:   CDlg::OnMsg

    PURPOSE:    Parse an array of messages and ids. If the message is
                intended for an id, call the associated function.

    PARAMETERS:
        wParam

    RETURNS:    TRUE if no message was processed (i.e., continue processing).
                FALSE if message processed

    COMMENTS:

    MODIFICATION DATES:
        16-Apr-1997 [ralphw]

***************************************************************************/

BOOL CDlg::OnMsg(WPARAM wParam)
{
    if (!m_pmsglist)
        return TRUE;

    UINT msg = HIWORD(wParam);
    UINT id   = LOWORD(wParam);
    const CDLG_MESSAGE_LIST* pmsglist = m_pmsglist;

    for (;pmsglist->idControl; pmsglist++) {
        if (msg == pmsglist->idMessage && id == pmsglist->idControl) {
            (this->*pmsglist->pfunc)();
            return FALSE;
        }
    }
    return TRUE;    // continue processing
}

HWND CDlg::DoModeless(void)
{
    HWND hwnd = NULL;
    m_fModeLess = TRUE;
    if (m_fUnicode)
    {
        hwnd = ::CreateDialogParamW(_Module.GetResourceInstance(), (LPCWSTR)m_lpDialogTemplate, 
            m_hwndParent, (DLGPROC) CDlgProc, (LPARAM) this);
        if (NULL == hwnd)
        {
            if (ERROR_CALL_NOT_IMPLEMENTED == GetLastError())
            {
                m_fUnicode = FALSE;
                goto _Ansi;
            }
        }
    }
    else
    {
_Ansi:  hwnd = ::CreateDialogParamA(_Module.GetResourceInstance(), m_lpDialogTemplate, m_hwndParent,
            (DLGPROC) CDlgProc, (LPARAM) this);
    }
    ASSERT(IsValidWindow(m_hWnd) && hwnd == m_hWnd);
    ::ShowWindow(m_hWnd, SW_SHOW);
    return m_hWnd;
}

LRESULT CDlg::OnContextMenu(HWND hwnd)
{
    if (m_aHelpIds)
        WinHelp(hwnd, m_pszHelpFile,
            HELP_CONTEXTMENU, (DWORD_PTR) (LPVOID) m_aHelpIds);
    return 0;
}

LRESULT CDlg::OnHelp(HWND hwnd)
{
    if (m_aHelpIds)
        WinHelp(hwnd, m_pszHelpFile,
            HELP_WM_HELP, (DWORD_PTR) (LPVOID) m_aHelpIds);
    return 0;
}

static BOOL WINAPI EnumFontProc(HWND hwnd, LPARAM lval)
{
    SendMessage(hwnd, WM_SETFONT, (WPARAM) _Resource.GetUIFont(), FALSE);
    return TRUE;
}

static BOOL WINAPI EnumBidiSettings(HWND hwnd, LPARAM lval)
{
    char szClass[MAX_PATH];
    VERIFY(GetClassName(hwnd, szClass, sizeof(szClass)));

    // In BiDi, flip the scroll bars to the left side

    if (IsSamePrefix(szClass, "LISTBOX", -2) ||
            IsSamePrefix(szClass, "COMBOBOX", -2)) {
        ::SetWindowLong(hwnd, GWL_EXSTYLE,
            WS_EX_LEFTSCROLLBAR | ::GetWindowLong(hwnd, GWL_EXSTYLE));
    }

    return TRUE;
}

void CDlgListBox::RemoveListItem()
{
    int cursel;
    if ((cursel = (int)GetCurSel()) != LB_ERR) {

        // Delete current selection, and select the item below it

        DeleteString(cursel);
        if (cursel < GetCount())
            SetCurSel(cursel);
        else if (cursel > 0)
            SetCurSel(--cursel);
        else if (GetCount())
            SetCurSel(0);
    }
}

void CDlg::MakeCheckedList(int idLB)
{
    if (!m_pCheckBox)
        m_pCheckBox = new CDlgCheckListBox;
    m_pCheckBox->Initialize(*this, idLB);
}

CDlgCheckListBox::CDlgCheckListBox()
{
    m_xMargin = GetSystemMetrics(SM_CXBORDER);
    m_yMargin = GetSystemMetrics(SM_CYBORDER);
    m_cxDlgFrame = GetSystemMetrics(SM_CXDLGFRAME);
    m_hbmpCheck = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDBMP_CHECK));
    ASSERT(m_hbmpCheck);

    BITMAP bmp;
    GetObject(m_hbmpCheck, sizeof(BITMAP), &bmp);
    m_cxCheck = bmp.bmWidth / 3;
    m_cyCheck = bmp.bmHeight;
    m_iLastSel = LB_ERR;
}

CDlgCheckListBox::~CDlgCheckListBox()
{
    DeleteObject(m_hbmpCheck);
}

BOOL CDlgCheckListBox::IsItemChecked (int nIndex) const
{
    return (BOOL) GetItemData(nIndex);
}

void CDlgCheckListBox::CheckItem(int nIndex, BOOL fChecked /*= TRUE*/)
{
    SetItemData(nIndex, fChecked);
    InvalidateItem(nIndex);
}

void CDlgCheckListBox::ToggleItem (int nIndex)
{
    CheckItem(nIndex, IsItemChecked(nIndex) ? FALSE : TRUE);
}

int CDlgCheckListBox::ItemHeight(void)
{
    HDC hdc = GetDC(m_hWnd);
    SIZE size;
    VERIFY(GetTextExtentPoint(hdc, "M", 1, &size));
    ReleaseDC(m_hWnd, hdc);
    return size.cy;     // + GetSystemMetrics (SM_CYBORDER);
}

void CDlgCheckListBox::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
    ASSERT (lpDrawItemStruct != NULL);

    // Ignore if not redrawing                               1

    if (lpDrawItemStruct->itemID != LB_ERR &&
            (lpDrawItemStruct->itemAction & (ODA_SELECT | ODA_DRAWENTIRE))) {
        CStr cszText;
        int cbText = (int)GetTextLength(lpDrawItemStruct->itemID);
        cszText.psz = (PSTR) lcMalloc(cbText + 1);
        GetText(cszText.psz, cbText + 1, lpDrawItemStruct->itemID);

        SetTextColor(lpDrawItemStruct->hDC,
            GetSysColor((lpDrawItemStruct->itemState & ODS_SELECTED) ?
            COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));
        SetBkColor(lpDrawItemStruct->hDC,
            GetSysColor((lpDrawItemStruct->itemState & ODS_SELECTED) ?
            COLOR_HIGHLIGHT : COLOR_WINDOW));

        RECT        rcItem;
        RECT        rcCheck;
        GetItemRect(&rcItem, lpDrawItemStruct->itemID);
        GetCheckRect(lpDrawItemStruct->itemID, &rcCheck);

        int yTextOffset = max(0, (RECT_HEIGHT(rcItem) - ItemHeight()) / 2);
        int xTextOffset = 2 * m_cxDlgFrame + RECT_WIDTH(rcCheck);

        ExtTextOut(lpDrawItemStruct->hDC,
            rcItem.left + xTextOffset, rcItem.top + yTextOffset,
            ETO_OPAQUE, &rcItem, cszText, cbText, NULL);

        DrawCheck(lpDrawItemStruct->hDC, &rcCheck, IsItemChecked(lpDrawItemStruct->itemID));
    }
}

void CDlgCheckListBox::InvalidateItem(int nIndex, BOOL fRedraw /*= FALSE*/)
{
    RECT rc;

    if (GetItemRect(&rc, nIndex) != LB_ERR)
        InvalidateRect(m_hWnd, &rc, fRedraw);
}

void CDlgCheckListBox::DrawCheck(HDC hdc, RECT* prc, BOOL fChecked)
{
    CPalDC dcBmp(m_hbmpCheck);

    BitBlt(hdc, prc->left, prc->top,
        m_cxCheck, m_cyCheck, dcBmp,
        m_cyCheck  * (fChecked ? 1 : 0), 0, SRCCOPY);
}

const int CHECK_MARGIN = 2;

int CDlgCheckListBox::GetCheckRect(int nIndex, RECT* prc)
{
    if (GetItemRect(prc, nIndex) == LB_ERR)
        return LB_ERR;

    prc->left += CHECK_MARGIN;
    prc->right = prc->left + m_cxCheck;
    if (RECT_HEIGHT(prc) > m_cyCheck) {
        int diff = (RECT_HEIGHT(prc) - m_cyCheck) / 2;
        prc->top += diff;
    }

    return 0;
}

void CDlgCheckListBox::OnSelChange(void)
{
    int pos = (int)GetCurSel();
    if (pos != LB_ERR) {
        POINT pt;
        GetCursorPos(&pt);
        ScreenToClient(*this, &pt);
        RECT rc;
        GetCheckRect(pos, &rc);
        if (PtInRect(&rc, pt))
            ToggleItem(pos);
        else if (pos == m_iLastSel)
            ToggleItem(pos);
    }
    m_iLastSel = pos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cindex.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CINDEX_H__
#define __CINDEX_H__

#ifndef __SITEMAP_H__
#include "sitemap.h"
#endif

#ifndef _CINFOTYPE_H
#include "cinfotyp.h"
#endif

#include "clistbox.h"
#include "navui.h" // Clean up headers

// CDlgItemInfo class --- currently only used for accelerator support.
#include "navpane.h"

#include "vlist.h"
// #include "secwin.h"

//////////////////////////////////////////////////////////////////////////
//
// Constants
//


///////////////////////////////////////////////////////////
//
// Forward References
//
class CHtmlHelpControl; // forward reference
class CHHWinType;    // forward reference

///////////////////////////////////////////////////////////
//
// CIndex
//
class CIndex :  MI_COUNT(CIndex) public INavUI, // NOTE: This interface must be first. Otherwise, you get an mem error.
                public CSiteMap
{
public:

    //--- Internal Contants
    typedef enum DlgItemInfoIndex
    {
        c_KeywordEdit,
        //c_KeywordsList,
        c_DisplayBtn,

        c_NumDlgItems
    };

    //--- Constructor
    CIndex(CHtmlHelpControl* phhctrl, IUnknown* pUnkOuter, CHHWinType* phh);
    virtual ~CIndex();

    //--- INavUI Interface
    BOOL  Create(HWND hwndParent);
    LRESULT OnCommand(HWND hwnd, UINT id, UINT uNotifiyCode, LPARAM lParam) ;
    void  ResizeWindow();
    void  HideWindow(void);
    void  ShowWindow(void);
    void  SetPadding(int pad) { m_padding = pad; }
    void  SetTabPos(int tabpos) { m_NavTabPos = tabpos; }

    void    SetDefaultFocus() ;
    bool    ProcessMenuChar(HWND hwndParent, int ch);
    LRESULT OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam) {return 1l;}
    void  OnDrawItem(UINT id, LPDRAWITEMSTRUCT pdis) {/*Not Implemented*/}
    void  Seed(PCSTR pszSeed);
    void  Seed(WCHAR* pwszSeed);
    void  Refresh(void)
    {
       if ( m_pVList )
          m_pVList->Refresh();
    }

    // Other member functions.
    void  ChangeOuter(IUnknown* pUnkOuter) { m_pOuter = pUnkOuter; }
    void  OnVKListNotify(NMHDR* pNMHdr);
    BOOL  ReadIndexFile(PCSTR pszFile);
    void  FillListBox(BOOL fReset = FALSE);

    //--- Helper functions.
    // Returns the font to be used.
    HFONT GetContentFont();

    // Initialize the DlgItemArray.
    void    InitDlgItemArray() ;

    //--- Member variables.
    int   m_cFonts;
    HFONT*   m_ahfonts;
    BOOL  m_fGlobal;  // means we've already initialized ourselves once
    LANGID   m_langid;

    CHtmlHelpControl* m_phhctrl;
    IUnknown*   m_pOuter;
    CHHWinType* m_phh;

    HPALETTE m_hpalBackGround;
    HBRUSH    m_hbrBackGround;  // background brush
    HBITMAP  m_hbmpBackGround;
    int    m_cxBackBmp;
    int    m_cyBackBmp;
    HWND  m_hwndEditBox;
    HWND  m_hwndListBox;
    HWND  m_hwndDisplayButton;
    HWND    m_hwndStaticKeyword;
    BOOL  m_fSelectionChange;
    int   m_padding;
    CDlgListBox m_listbox;
    int   m_NavTabPos;   // location of parent tabs
    BOOL  m_fBinary;
    CInfoType *pInfoType;   // the Information Types

   // The window passed into create is not the actual parent window of the
   // controls. Instead, the controls are always parented to the Navigation window
   // which owns the tabs. For resizing, we need to have a pointer to the
   // tabctrl window. So, we save this pointer here.
    HWND m_hwndResizeToParent ;
private:
    BOOL m_bInit;
    CVirtualListCtrl* m_pVList;

    // Array of dlgitems
    CDlgItemInfo m_aDlgItems[c_NumDlgItems] ;
    BOOL m_bUnicode;

};

#endif   // __CINDEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\classf.h ===
//=--------------------------------------------------------------------------=
// ClassF.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// header for the ClassFactory Object.  we support IClassFactory and 
// IClassFactory2
//
#ifndef _CLASSF_H_

#include "olectl.h"

class CClassFactory : public IClassFactory2 {

  public:
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IClassFactory methods
    //
    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppbObjOut);
    STDMETHOD(LockServer)(BOOL fLock);

    // IClassFactory2 methods
    //
    STDMETHOD(GetLicInfo)(LICINFO *pLicInfo);
    STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR *pbstrKey);
    STDMETHOD(CreateInstanceLic)(IUnknown *pUnkOuter, IUnknown *pUnkReserved, REFIID riid, BSTR bstrKey, void **ppvObjOut);

    CClassFactory(int iIndex);
    ~CClassFactory();

  private:
    ULONG m_cRefs;
    int   m_iIndex;
};


// global variable for Locks on our DLL
//
extern LONG g_cLocks;

#define _CLASSF_H_
#endif // _CLASSF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cinput.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "cinput.h"
#include "system.h"
#include "toc.h"

#ifndef _DEBUG
#pragma optimize("a", on)
#endif

const int INPUT_BUF_SIZE = (16 * 1024);

CInput::CInput()
{
    m_pfsClient = NULL;
    m_pbuf = NULL;
    m_hfile = INVALID_HANDLE_VALUE;
}

CInput::CInput(LPCSTR pszFile)
{
    m_pfsClient = NULL;
    m_pbuf = NULL;
    m_hfile = INVALID_HANDLE_VALUE;
    Open(pszFile);
}

BOOL  
CInput::isInitialized() 
{ 
    return (m_pbuf != NULL && (m_hfile != INVALID_HANDLE_VALUE || m_pfsClient != NULL));
}

BOOL CInput::Open(PCSTR pszFile, CHmData* phmData)
{
    CStr csz;
    if (phmData && !stristr(pszFile, txtDoubleColonSep) &&
            !stristr(pszFile, txtFileHeader) && !stristr(pszFile, txtHttpHeader)) {
        csz = phmData->GetCompiledFile();
        csz += txtDoubleColonSep;
        csz += pszFile;
        pszFile = csz.psz;
    }

    Close();

    // Is this a compiled HTML file?

    CStr cszCompiled;
    if (IsCompiledHtmlFile(pszFile, &cszCompiled)) {
        m_pfsClient = new CFSClient;
        CStr cszFind;
        PCSTR pszSubFile = GetCompiledName(cszCompiled, &cszFind);

        // Check if we have a valid subfile name.
        if (!pszSubFile || pszSubFile[0] == '\0')
        {
            Close() ;
            return FALSE ;
        }

        for (int i = 0; i < g_cHmSlots; i++) {
            if (g_phmData[i] &&
                    lstrcmpi(cszFind, g_phmData[i]->GetCompiledFile()) == 0) 
                break;
        }
        if (i < g_cHmSlots) {
            CExTitle* pTitle = g_phmData[i]->m_pTitleCollection->GetFirstTitle();
            if (pTitle->isChiFile())
                m_pfsClient->Initialize(cszFind);
            else
                m_pfsClient->Initialize(g_phmData[i]->m_pTitleCollection->GetFirstTitle()->GetFileSystem());
            if (FAILED(m_pfsClient->OpenStream(pszSubFile)))
            {
                Close();
                return FALSE;
            }
        }
        else if (!m_pfsClient->Initialize(cszCompiled)) {
            Close();
            return FALSE;
        }
        m_hfile = (HANDLE) 1;
    }
    else {
        m_pfsClient = NULL;
        m_hfile = CreateFile(pszFile, GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if (m_hfile == INVALID_HANDLE_VALUE) {
            Close();
            return FALSE;
        }
    }
    m_pbuf = (PBYTE) lcMalloc(INPUT_BUF_SIZE + 4);
    m_pbuf[INPUT_BUF_SIZE + 1] = 0;     // so we can search

    // Position current buffer at end to force a read

    m_pCurBuf = m_pEndBuf = m_pbuf + INPUT_BUF_SIZE;
    fFastRead = FALSE;
    return TRUE;
}

CInput::~CInput(void)
{
    Close();
}

void CInput::Close()
{
    if (m_pfsClient) {
        delete m_pfsClient;
        m_pfsClient = NULL;
    }
    else if (m_hfile != INVALID_HANDLE_VALUE) {
        CloseHandle(m_hfile);
    }
    m_hfile = INVALID_HANDLE_VALUE;
    if (m_pbuf)
        lcClearFree(&m_pbuf);
}

/***************************************************************************

    FUNCTION:   CInput::getline

    PURPOSE:    Reads a line into a CStr buffer, increasing that buffer
                as necessary to hold the line.

    PARAMETERS:
        pcsz    CStr pointer

    RETURNS:

    COMMENTS:
        This function relies HEAVILY on the implementation of the CStr
        class, namely in CStr's use of lcmem functions.

    MODIFICATION DATES:
        05-Sep-1994 [ralphw]

***************************************************************************/

BOOL CInput::getline(CStr* pcsz)
{
    // Only read the line if we are initialized.
    if (!isInitialized())
        return FALSE ;

    if (!pcsz->psz)
        pcsz->psz = (PSTR) lcMalloc(256);
    PSTR pszDst = pcsz->psz;
    PSTR pszEnd = pszDst + lcSize(pszDst);

    /*
     * If we previously saw a \r then we are going to assume we will see
     * files with \r\n, which means we can do a fast search to find the first
     * occurence of \r, copy everything up to that character into the
     * destination buffer, and the continue normally. This will die horribly
     * if there's only one \r in a file...
     */

    if (fFastRead) {
        if (m_pCurBuf >= m_pEndBuf) {
            if (!ReadNextBuffer()) {

                // End of file: return TRUE if we got any text.
                if (pszDst > pcsz->psz) {
                    *pszDst = '\0';
                    return TRUE;
                }
                else
                    return FALSE;
            }
        }
        PCSTR psz = StrChr((PCSTR) m_pCurBuf, '\r');
        if (psz) {
            INT_PTR cb = psz - (PCSTR) m_pCurBuf;
            while (pszDst + cb >= pszEnd) {

                /*
                 * Our input buffer is too small, so increase it by
                 * 128 bytes.
                 */

                INT_PTR offset = (pszDst - pcsz->psz);
                pcsz->ReSize((int)(pszEnd - pcsz->psz) + 128);
                pszDst = pcsz->psz + offset;
                pszEnd = pcsz->psz + pcsz->SizeAlloc();
            }
            memcpy(pszDst, m_pCurBuf, (int)cb);
            pszDst += cb;
            m_pCurBuf += (cb + 1);    // skip over the \r
        }
    }

    for (;;) {
        if (m_pCurBuf >= m_pEndBuf) {
            if (!ReadNextBuffer()) {

                // End of file: return TRUE if we got any text.
                if (pszDst > pcsz->psz) {
                    *pszDst = '\0';
                    return TRUE;
                }
                else
                    return FALSE;
            }
        }
        switch (*pszDst = *m_pCurBuf++) {
            case '\n':
                if (pszDst > pcsz->psz) {
                    while (pszDst[-1] == ' ') { // remove trailing spaces
                        pszDst--;
                        if (pszDst == pcsz->psz)
                            break;
                    }
                }
                *pszDst = '\0';
                return TRUE;

            case '\r':
                fFastRead = TRUE;
                break;                           // ignore it

            case 0: // This shouldn't happen in a text file

                /*
                 * Check to see if this is a WinWord file. This test is
                 * not definitve, but catches most .doc format files.
                 */

                if ((m_pbuf[0] == 0xdb || m_pbuf[0] == 0xd0) &&
                        (m_pbuf[1] == 0xa5 || m_pbuf[1] == 0xcf)) {
                    return FALSE;
                }
                break;

            default:
                pszDst++;
                if (pszDst == pszEnd) {

                    /*
                     * Our input buffer is too small, so increase it by
                     * 128 bytes.
                     */

                    INT_PTR offset = (pszDst - pcsz->psz);
                    pcsz->ReSize((int)(pszEnd - pcsz->psz) + 128);
                    pszDst = pcsz->psz + offset;
                    pszEnd = pcsz->psz + pcsz->SizeAlloc();
                }
                break;
        }
    }
}

BOOL CInput::ReadNextBuffer(void)
{
    DWORD cbRead;

    // Only read the line if we are initialized.
    if (!isInitialized())
        return FALSE ;

    if (m_pfsClient) {
        if (!SUCCEEDED(m_pfsClient->Read(m_pbuf, INPUT_BUF_SIZE, (ULONG*) &cbRead)) ||
                cbRead == 0)
            return FALSE;
    }
    else {
        if (!ReadFile(m_hfile, m_pbuf, INPUT_BUF_SIZE, &cbRead, NULL) || !cbRead)
            return FALSE;
    }
    m_pCurBuf = m_pbuf;
    m_pEndBuf = m_pbuf + cbRead;
    *m_pEndBuf = '\0'; // so we can search
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cinput.h ===
// Copyright (C) 1994-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CINPUT_H__
#define __CINPUT_H__

#include "cstr.h"

class CHmData;      // forward reference
class CFSClient;    // forward reference

class CInput
{
public:
    CInput();
    CInput(LPCSTR pszFileName);
    ~CInput(void);
    BOOL  Open(PCSTR pszFile, CHmData* phmData = NULL);
    void  Close();
    HANDLE GetFileHandle() { return m_hfile; }
    BOOL  isInitialized() ;

    BOOL getline(CStr* pcsz);

protected:
    BOOL ReadNextBuffer(void);

    CFSClient* m_pfsClient;

    HANDLE m_hfile;  // this will be non-NULL but invalid if m_pfsClient is used
    PBYTE m_pbuf;        // allocated buffer for reading
    PBYTE m_pCurBuf;     // current buffer location
    PBYTE m_pEndBuf;     // buffer end position
    BOOL  fFastRead;    // TRUE if we can search for /r in getline
};

typedef struct {
    CInput* pin;
    PSTR    pszBaseName;
} AINPUT;

const int MAX_NEST_INPUT = 20;  // maximum nested include file

class CAInput
{
public:
    CAInput()  { m_curInput = -1; }
    ~CAInput() {
        while (m_curInput >= 0)
        Remove();
    }
    BOOL Add(PCSTR pszFile);
    BOOL Remove(void) {
        if (m_curInput >= 0) {
            lcFree(m_ainput[m_curInput].pszBaseName);
            delete m_ainput[m_curInput].pin;
            --m_curInput;
        }
        return (m_curInput >= 0);
    }
    BOOL getline(CStr* pcsz) { return m_ainput[m_curInput].pin->getline(pcsz); }
    PSTR GetBaseName(void) const { return m_ainput[m_curInput].pszBaseName; }

protected:
    int m_curInput;
    AINPUT m_ainput[MAX_NEST_INPUT + 1];
};

#endif // __CINPUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cinfotyp.cpp ===
#include "header.h"
#include "system.h"
#include "..\hhctrl\Csubset.h"
#include "..\hhctrl\CInfoTyp.h"

//#pragma warning(disable:4554) // check operator precedence

    // Implememtaion file for CInfoTyp class; Information Type and Categories class

    // Constructor
CInfoType::CInfoType(void)
{
    m_itTables.m_ptblInfoTypes = new CTable(16 * 1024);
    m_itTables.m_ptblInfoTypeDescriptions = new CTable(64 * 1024);
    m_itTables.m_ptblCategories = new CTable(16 * 1024);
    m_itTables.m_ptblCatDescription = new CTable(64 * 1024);

    m_itTables.m_max_categories = MAX_CATEGORIES;
    m_itTables.m_aCategories = (CATEGORY_TYPE*) lcCalloc(MAX_CATEGORIES*sizeof(CATEGORY_TYPE) );

    m_itTables.m_cTypes = 0;
    m_itTables.m_cITSize = 1;   // Iniaially allocate one DWORD to hold info type bits.

#ifdef _DEBUG
    int cInfoTypeSize = InfoTypeSize();
#endif

    for(int i=0; i< MAX_CATEGORIES; i++)
        m_itTables.m_aCategories[i].pInfoType = (INFOTYPE*)lcCalloc(InfoTypeSize());

        // Allocate the exclusive information types.
    m_itTables.m_pExclusive = (INFOTYPE*)lcCalloc(InfoTypeSize());

        // Allocate the hidden information types
    m_itTables.m_pHidden = (INFOTYPE*)lcCalloc(InfoTypeSize());

        // Allocate the user selection of info types
    m_pInfoTypes = (INFOTYPE*)lcCalloc(InfoTypeSize());
    memset(m_pInfoTypes, 0xFFFF, InfoTypeSize() );  // by default all bits on

        // allocate the Typical Info Types
    m_pTypicalInfoTypes = (INFOTYPE *)lcCalloc(InfoTypeSize());
    m_fTypeCopy = TRUE;
    m_fInitialized = TRUE;
}

    // Destructor
CInfoType::~CInfoType()
{
    if ( m_itTables.m_ptblInfoTypes )
        delete m_itTables.m_ptblInfoTypes;
    if ( m_itTables.m_ptblInfoTypeDescriptions )
        delete m_itTables.m_ptblInfoTypeDescriptions;
    if ( m_itTables.m_ptblCategories )
        delete m_itTables.m_ptblCategories;
    if ( m_itTables.m_ptblCatDescription )
        delete m_itTables.m_ptblCatDescription;

    lcFree(m_pInfoTypes);
    lcFree(m_pTypicalInfoTypes);
    lcFree(m_itTables.m_pHidden);
    lcFree(m_itTables.m_pExclusive);

    if ( m_itTables.m_aCategories[0].pInfoType )
    {
        for (int i=0; i<m_itTables.m_max_categories; i++)
            lcFree( m_itTables.m_aCategories[i].pInfoType );
    }
    lcFree( m_itTables.m_aCategories );
}


    // copy constructors
const CInfoType& CInfoType::operator=(const CInfoType& ITSrc)
{
    if ( this == NULL )
        return *this;
    if ( this == &ITSrc )
        return *this;

    m_itTables.m_cTypes = ITSrc.m_itTables.m_cTypes;  // the number of ITs
    m_itTables.m_cITSize = ITSrc.m_itTables.m_cITSize;  // the number of DWORDS allocated to hold ITs

    CopyTable( &ITSrc.m_itTables );
    CopyCat( &ITSrc.m_itTables );

        // copy the member variables
    if (m_itTables.m_pExclusive)
        lcFree(m_itTables.m_pExclusive);
    m_itTables.m_pExclusive = (INFOTYPE*)lcCalloc( InfoTypeSize() );
    memcpy(m_itTables.m_pExclusive,
           ITSrc.m_itTables.m_pExclusive,
           InfoTypeSize());
    if (m_itTables.m_pHidden)
        lcFree(m_itTables.m_pHidden);
    m_itTables.m_pHidden = (INFOTYPE*)lcCalloc( InfoTypeSize() );
    memcpy(m_itTables.m_pHidden,
           ITSrc.m_itTables.m_pHidden,
           InfoTypeSize());


        // user-specified Information Types
    if ( m_pInfoTypes )
        lcFree(m_pInfoTypes);
    m_pInfoTypes = (INFOTYPE*)lcCalloc( InfoTypeSize() );
    memcpy(m_pInfoTypes, ITSrc.m_pInfoTypes, InfoTypeSize());
        // typical information types
    if ( m_pTypicalInfoTypes )
        lcFree(m_pTypicalInfoTypes);
    m_pTypicalInfoTypes = (INFOTYPE*)lcCalloc( InfoTypeSize() );
    memcpy(m_pTypicalInfoTypes, ITSrc.m_pTypicalInfoTypes, InfoTypeSize());
    m_fTypeCopy = TRUE;                             // TRUE if the tables are coppied

    return *this;
}


const CInfoType& CInfoType::operator=(const CSiteMap& ITSrc)
{

    if ( this == NULL )
        return *this;

    m_itTables.m_cTypes = ITSrc.m_itTables.m_cTypes;
    m_itTables.m_cITSize = ITSrc.m_itTables.m_cITSize;

    CopyTable( &ITSrc.m_itTables );
    CopyCat( &ITSrc.m_itTables );

        // copy the member variables
    if (m_itTables.m_pExclusive)
        lcFree(m_itTables.m_pExclusive);
    m_itTables.m_pExclusive = (INFOTYPE*)lcCalloc( InfoTypeSize() );
    memcpy(m_itTables.m_pExclusive,
           ITSrc.m_itTables.m_pExclusive,
           InfoTypeSize() );

    if (m_itTables.m_pHidden)
        lcFree(m_itTables.m_pHidden);
    m_itTables.m_pHidden = (INFOTYPE*)lcCalloc( InfoTypeSize() );
    memcpy(m_itTables.m_pHidden,
           ITSrc.m_itTables.m_pHidden,
           InfoTypeSize() );

    if ( m_pInfoTypes )
        lcFree(m_pInfoTypes);
    m_pInfoTypes = (INFOTYPE*)lcCalloc( InfoTypeSize() );
    memcpy(m_pInfoTypes, ITSrc.m_pInfoTypes, InfoTypeSize() );

    if ( m_pTypicalInfoTypes )
        lcFree(m_pTypicalInfoTypes);
    m_pTypicalInfoTypes = (INFOTYPE*)lcCalloc( InfoTypeSize() );
    memcpy(m_pTypicalInfoTypes, ITSrc.m_pTypicalInfoTypes, InfoTypeSize() );
    m_fTypeCopy = TRUE;                             // TRUE if the tables are coppied

    return *this;
}


void CInfoType::CopyTable( const INFOTYPE_TABLES *Src_itTables)
{
#ifdef HHCTRL
int count;
        // copy the Category and Information Type definitions and descriptions.
    if ( m_itTables.m_ptblInfoTypes != Src_itTables->m_ptblInfoTypes && Src_itTables->m_ptblInfoTypes)
        for (int pos = 1; pos<= Src_itTables->m_cTypes; pos++ )
        {
            m_itTables.m_ptblInfoTypes->AddString( Src_itTables->m_ptblInfoTypes->GetPointer(pos) );
            m_itTables.m_ptblInfoTypeDescriptions->AddString( Src_itTables->m_ptblInfoTypeDescriptions->GetPointer(pos) );
        }
        count = Src_itTables->m_ptblCategories?Src_itTables->m_ptblCategories->CountStrings():0;
    if ( m_itTables.m_ptblCategories != Src_itTables->m_ptblCategories && Src_itTables->m_ptblCategories)
        for ( int pos = 1; pos <= count; pos++ )
        {
            m_itTables.m_ptblCategories->AddString(Src_itTables->m_ptblCategories->GetPointer(pos));
            m_itTables.m_ptblCatDescription->AddString(Src_itTables->m_ptblCatDescription->GetPointer(pos) );
        }
#else
    if ( m_itTables.m_ptblInfoTypes != Src_itTables->m_ptblInfoTypes && Src_itTables->m_ptblInfoTypes)
    {
		m_itTables.m_ptblInfoTypes->Empty();
        m_itTables.m_ptblInfoTypes->CopyTable( Src_itTables->m_ptblInfoTypes );
		m_itTables.m_ptblInfoTypeDescriptions->Empty();
        m_itTables.m_ptblInfoTypeDescriptions->CopyTable( Src_itTables->m_ptblInfoTypeDescriptions );
    }
    if ( m_itTables.m_ptblCategories != Src_itTables->m_ptblCategories && Src_itTables->m_ptblCategories && Src_itTables->m_ptblCategories)
    {
		m_itTables.m_ptblCategories->Empty();
        m_itTables.m_ptblCategories->CopyTable( Src_itTables->m_ptblCategories);
		m_itTables.m_ptblCatDescription->Empty();
        m_itTables.m_ptblCatDescription->CopyTable( Src_itTables->m_ptblCatDescription );
    }
#endif

}


void CInfoType::CopyCat(const INFOTYPE_TABLES * Src_itTables)
{
        // copy the categories table
    m_itTables.m_max_categories = Src_itTables->m_max_categories;
    if ( m_itTables.m_max_categories > MAX_CATEGORIES )
        m_itTables.m_aCategories = (CATEGORY_TYPE *)lcReAlloc(m_itTables.m_aCategories,
                                        m_itTables.m_max_categories * sizeof(CATEGORY_TYPE) );
    for(int i=0; i<m_itTables.m_max_categories; i++)
    {
        if ( m_itTables.m_aCategories[i].pInfoType )
            lcFree(m_itTables.m_aCategories[i].pInfoType);
        m_itTables.m_aCategories[i].pInfoType = (INFOTYPE*) lcCalloc( InfoTypeSize() );
        if ( Src_itTables->m_aCategories[i].c_Types > 0 )
        {
            memcpy(m_itTables.m_aCategories[i].pInfoType,
                   Src_itTables->m_aCategories[i].pInfoType,
                   InfoTypeSize() );
            m_itTables.m_aCategories[i].c_Types = Src_itTables->m_aCategories[i].c_Types;
       }
        else
        {
            m_itTables.m_aCategories[i].c_Types = 0;
        }
    }

}

#ifdef HHCTRL
void CInfoType::CopyTo( CHmData * const phmData)
{
CStr csz;
int CatPos=0, CatDescPos=0;
int TypePos=0,TypeDescPos=0;

    if ( !phmData || !phmData->m_pdInfoTypes )
       return;

    m_itTables.m_cTypes = 0;
    m_itTables.m_cITSize = 1;
    for(int i=0;
        (phmData->m_pdInfoTypes[i].type>=IT_INCLUSICE_TYPE) &&
        (phmData->m_pdInfoTypes[i].type<=IT_CAT_DESCRIPTION); i++)
    {
        if ( phmData->m_pdInfoTypes[i].dwString == -1 )
            continue;

        // BUGBUG: The code below is wrong. See CHmData::GetString() for reason.

      csz = phmData->GetString( phmData->m_pdInfoTypes[i].dwString );

        switch( phmData->m_pdInfoTypes[i].type )
        {
        case IT_INCLUSICE_TYPE:
            if ( CatPos > 0 )
            {
                TypePos = GetInfoType( csz.psz );
                if ( TypePos > 0 )
                    AddITtoCategory(CatPos-1, TypePos);
                break;
            }
            if ( (m_itTables.m_cTypes > 0) && ((m_itTables.m_cTypes+1) % 32 == 0)  )
                ReSizeIT();  // increase by one DWORD
            TypePos = m_itTables.m_ptblInfoTypes->AddString( csz.psz );
            m_itTables.m_cTypes++;
            break;
        case IT_EXCLUSIVE_TYPE:
            if ( CatPos > 0 )
            {
                TypePos = GetInfoType( csz.psz );
                if ( TypePos > 0 )
                    AddITtoCategory(CatPos-1, TypePos);
                break;
            }
            if ( (m_itTables.m_cTypes > 0) && ((m_itTables.m_cTypes+1) % 32 == 0)  )
                ReSizeIT();  // increase by one DWORD
            TypePos = m_itTables.m_ptblInfoTypes->AddString( csz.psz );
            AddExclusiveIT(TypePos);
            m_itTables.m_cTypes++;
            break;
        case IT_HIDDEN_TYPE:
            if ( CatPos > 0 )
            {
                TypePos = GetInfoType( csz.psz );
                if ( TypePos > 0 )
                    AddITtoCategory(CatPos-1, TypePos);
                break;
            }
            if ( (m_itTables.m_cTypes > 0) && ((m_itTables.m_cTypes+1) % 32 == 0)  )
                ReSizeIT();  // increase by one DWORD
            TypePos = m_itTables.m_ptblInfoTypes->AddString( csz.psz );
            AddHiddenIT(TypePos);
            m_itTables.m_cTypes++;
            break;
        case IT_DESCRIPTION:
            while( TypePos > TypeDescPos+1 )
                TypeDescPos = m_itTables.m_ptblInfoTypeDescriptions->AddString( " ");
            TypeDescPos = m_itTables.m_ptblInfoTypeDescriptions->AddString( csz.psz );
            break;
        case IT_CATEGORY:
                CatPos = m_itTables.m_ptblCategories->AddString( csz.psz );
            break;
        case IT_CAT_DESCRIPTION:
            while( CatPos > CatDescPos+1 )
                CatDescPos = m_itTables.m_ptblCatDescription->AddString( " " );
            CatDescPos = m_itTables.m_ptblCatDescription->AddString( csz.psz );
            break;
        }
    }
}
#endif




void CInfoType::ReSizeIT(int Size)
{
    int oldSize = InfoTypeSize();

    if ( Size == 0 )
        m_itTables.m_cITSize++;     // increase by one
    else
        m_itTables.m_cITSize = Size;
        // Increase each category
    INFOTYPE * pIT;
    for(int i=0; i<m_itTables.m_max_categories; i++)
    {
        pIT = (INFOTYPE *) lcCalloc( InfoTypeSize() );
        memcpy(pIT, m_itTables.m_aCategories[i].pInfoType, oldSize);
        lcFree(m_itTables.m_aCategories[i].pInfoType);
        m_itTables.m_aCategories[i].pInfoType = pIT;
    }

    pIT = (INFOTYPE *) lcCalloc( InfoTypeSize() );
    memcpy(pIT, m_itTables.m_pExclusive, oldSize);
    lcFree(m_itTables.m_pExclusive);
    m_itTables.m_pExclusive = pIT;

       pIT = (INFOTYPE *) lcCalloc( InfoTypeSize() );
    memcpy(pIT, m_itTables.m_pHidden, oldSize);
    lcFree(m_itTables.m_pHidden);
    m_itTables.m_pHidden = pIT;

    pIT = (INFOTYPE *) lcCalloc( InfoTypeSize() );
    memcpy(pIT, m_pInfoTypes, oldSize);
    lcFree(m_pInfoTypes);
    m_pInfoTypes = pIT;

    pIT = (INFOTYPE *) lcCalloc( InfoTypeSize() );
    memcpy(pIT, m_pTypicalInfoTypes, oldSize);
    lcFree(m_pTypicalInfoTypes);
    m_pTypicalInfoTypes = pIT;

}


BOOL CInfoType::AnyInfoTypes(const INFOTYPE *pIT) const
{
    INFOTYPE *pInfoType;
    BOOL bRet;

    pInfoType = (INFOTYPE*)lcCalloc( InfoTypeSize() );
    bRet = (memcmp( pIT, pInfoType, InfoTypeSize()) == 0)?FALSE:TRUE;
    lcFree ( pInfoType );
    return bRet;
}


    // Check all the categories to see if this type is a member of any of them, return TRUE on first occurrence
BOOL CInfoType::IsInACategory( int type ) const
{
    for (int i=0; i<HowManyCategories(); i++ )
    {
        int offset;
        INFOTYPE *pIT;
        offset = type / 32;
        ASSERT ( m_itTables.m_aCategories[i].pInfoType );
        pIT = m_itTables.m_aCategories[i].pInfoType + offset;
        if ( *pIT & (1<<(type-(offset*32))) )
            return TRUE;
    }
return FALSE;
}

#if 0  // enable for subset filtering
BOOL CInfoType::IsEntryInCurTypeList(SITEMAP_ENTRY* pSiteMapEntry, CSubSets *pSSs) const
{
    return (BOOL) AreTheseInfoTypesDefined(pSiteMapEntry, pSSs);
}


SITE_ENTRY_URL* CInfoType::AreTheseInfoTypesDefined(SITEMAP_ENTRY* pSiteMapEntry,
    CSubSets *pSSs) const
{

    SITE_ENTRY_URL* pUrl = pSiteMapEntry->pUrls;
    if (!pUrl)
        return NULL;

    for (int iUrl = 0; iUrl < pSiteMapEntry->cUrls; iUrl++)
    {
        if ( !pSSs || pSSs->fTOCFilter( (pUrl+iUrl)->ainfoTypes ) )
            return pUrl;
    }
    return NULL;

}
#else
BOOL CInfoType::IsEntryInCurTypeList(SITEMAP_ENTRY* pSiteMapEntry) const
{
    int cTypes = m_itTables.m_ptblInfoTypes->CountStrings();
    if (cTypes < 32) {
        return AreTheseInfoTypesDefined(pSiteMapEntry, m_pInfoTypes[0], 0) != NULL;
    }
    else {
        for (int i = 0; cTypes > 32; i++) {
            if (AreTheseInfoTypesDefined(pSiteMapEntry, m_pInfoTypes[i], i))
                return TRUE;
            cTypes -= 32;
        }
        return AreTheseInfoTypesDefined(pSiteMapEntry, m_pInfoTypes[i], i) != NULL;
    }
}


SITE_ENTRY_URL* CInfoType::AreTheseInfoTypesDefined(SITEMAP_ENTRY* pSiteMapEntry,
    UINT types, int offset) const
{
    ASSERT((UINT) offset <= m_itTables.m_cTypes / sizeof(UINT));

    SITE_ENTRY_URL* pUrl = pSiteMapEntry->pUrls;
    if (!pUrl)
        return NULL;
    for (int iUrl = 0; iUrl < pSiteMapEntry->cUrls; iUrl++) {
        if (pUrl->ainfoTypes[offset] & types)
            return pUrl;
        pUrl = NextUrlEntry(pUrl);
    }
    return NULL;
}
#endif

int CInfoType::GetInfoType(PCSTR pszTypeName) const
{
    int type;
    CStr cszCat = pszTypeName;

    ASSERT(!IsEmptyString(pszTypeName));

    /*
      A category and type is specified as:
            category::type name
    */

    PSTR pszCat = strstr(cszCat.psz, "::");
    if ( !pszCat )
    {
        pszCat = StrChr(cszCat.psz, ':');
        if(pszCat != NULL)
        {
            *pszCat = '\0';
            pszCat++;
        }
    }
    else
    {
        *pszCat='\0';
        pszCat+=2;
    }

    if ( pszCat == NULL )
        return GetITIndex(pszTypeName); // there is not category.
    else
    {
        int cat = GetCatPosition( cszCat.psz );
        if (cat <= 0)
            return -1;
        type = GetFirstCategoryType( cat-1 );
        while( type != -1 )
        {
            if ( lstrcmpi( pszCat, GetInfoTypeName(type) ) == 0 )
                return type;
            type = GetNextITinCategory();

        }
    }
    return -1;
}


        // Static Data
        // ******************

static INFOTYPE curr_bit;   // used for getting the next IT in a category
static int curr_cat;
static int curr_offset;     // There are 32 info type bits per offset.


// ********************************************************
//
// Methods to operate on CInfoType Categories of Information Types
//
// ********************************************************

void CInfoType::AddITtoCategory(int cat, int type)
{
int       offset;
INFOTYPE *pInfoType;

    m_itTables.m_aCategories[cat].c_Types++;
    offset = type / 32;
    pInfoType = m_itTables.m_aCategories[cat].pInfoType + offset;
    *pInfoType |=  1<<type;

    if ( m_itTables.m_max_categories == (cat+1) )
    {
        m_itTables.m_aCategories = (CATEGORY_TYPE*) lcReAlloc( m_itTables.m_aCategories, (m_itTables.m_max_categories+5) * sizeof(CATEGORY_TYPE) );

        for(int i=m_itTables.m_max_categories; i < m_itTables.m_max_categories+5; i++)
        m_itTables.m_aCategories[i].pInfoType = (INFOTYPE*)lcCalloc(InfoTypeSize());

        m_itTables.m_max_categories += 5;
    }
}



void CInfoType::DeleteITfromCat(int cat, int type)
{
int       offset;
INFOTYPE *pInfoType;

    if ( cat < 0 )
        return;
    m_itTables.m_aCategories[cat].c_Types--;
    offset = type / 32;
    pInfoType = m_itTables.m_aCategories[cat].pInfoType + offset;
    *pInfoType &= ~(1<<type);

}



int CInfoType::GetFirstCategoryType( int pos ) const
{

    curr_offset = -1;    // gets incermented to 0 before first IT comparison.
    curr_cat = pos;      // keep the position of the category for calls to GetNextITinCagetory.
    curr_bit =1;         // bit zero of offset zero is reserved. But check it any way.

    if ( pos < 0 )
        return -1;
    int bitpos = GetITfromCat(&curr_offset,
                        &curr_bit,
                        m_itTables.m_aCategories[curr_cat].pInfoType,
                        InfoTypeSize()*8);
    if( (bitpos!=-1) && (IsDeleted(bitpos)) )
        return GetNextITinCategory();
    return bitpos;
}



int CInfoType::GetNextITinCategory( void ) const
{
    if ( curr_cat < 0 )
        return -1;  // must call GetFirstCategoryType() before calling this fn.

    int pos = GetITfromCat(&curr_offset,
                        &curr_bit,
                        m_itTables.m_aCategories[curr_cat].pInfoType,
                        InfoTypeSize()*8);
    while ((pos!=-1) && (IsDeleted(pos)) )
        pos = GetITfromCat(&curr_offset,
                        &curr_bit,
                        m_itTables.m_aCategories[curr_cat].pInfoType,
                        InfoTypeSize()*8);
    return pos;
}



int CInfoType::GetLastCategoryType(int pos) const
{   int cat;
    int offset;
    INFOTYPE bit;

    cat = pos;      // The category
    if ( cat < 0 )
        return -1;
    offset = -1;
    bit = 1;

    for (int i=0; i<m_itTables.m_aCategories[cat].c_Types-1; i++)
        if ( GetITfromCat(&offset,
                          &bit,
                          m_itTables.m_aCategories[cat].pInfoType,
                          InfoTypeSize()*8 ) == -1 )
            return -1;

    return  GetITfromCat(&offset,
                         &bit,
                         m_itTables.m_aCategories[cat].pInfoType,
                         InfoTypeSize() * 8 );
}



// ******************************************************
//
// Methods to operate on CInfoType Exclusive Information Types
//
// ******************************************************

static int ExclusiveOffset = -1;    // Gets incermented to zero before search begins
static INFOTYPE ExclusiveBit = 1;        // check bit 0 even though it is reserved.

int CInfoType::GetFirstExclusive(int offset, INFOTYPE bit) const
{
    ExclusiveOffset = offset;
    ExclusiveBit = bit;

    int pos = GetITBitfromIT(m_itTables.m_pExclusive,
                          &ExclusiveOffset,
                          &ExclusiveBit,
                          InfoTypeSize()*8 );
    if ( pos!=-1 && IsDeleted(pos) )
        return GetNextExclusive();
    return pos;
}


int CInfoType::GetNextExclusive(void) const
{
    if ( ExclusiveOffset < -1 || ExclusiveBit < 1 )
        return -1;
    int pos = GetITBitfromIT(m_itTables.m_pExclusive,
                          &ExclusiveOffset,
                          &ExclusiveBit,
                          InfoTypeSize()*8 );
    while( (pos!=-1) && (IsDeleted(pos)) )
        pos = GetITBitfromIT(m_itTables.m_pExclusive,
                          &ExclusiveOffset,
                          &ExclusiveBit,
                          InfoTypeSize()*8 );
    return pos;
}


int CInfoType::GetLastExclusive(void) const
{
    int i;
    int iLastExclusive=-1, temp;
    int offset=-1;
    INFOTYPE bit=1;

    for (i=0; i< HowManyInfoTypes(); i++)
        if ( (temp = GetITBitfromIT(m_itTables.m_pExclusive, &offset, &bit, InfoTypeSize()*8))  == -1 )
            return iLastExclusive;
        else
            iLastExclusive = temp;

    return -1;
}



// ******************************************************
//
// Methods to operate on CInfoType Hidden Information Types
//
// ******************************************************

static int HiddenOffset=-1;
static INFOTYPE HiddenBit=1;

int CInfoType::GetFirstHidden(int offset, INFOTYPE bit) const
{
    HiddenOffset = offset;
    HiddenBit = bit;

    int pos = GetITBitfromIT(m_itTables.m_pHidden,
                          &HiddenOffset,
                          &HiddenBit,
                          InfoTypeSize()*8 );
    if ( (pos!=-1) && (IsDeleted(pos)) )
       return GetNextHidden();
    return pos;
}


int CInfoType::GetNextHidden(void) const
{
    if ( HiddenOffset < -1 || HiddenBit < 1 )
        return -1;
    int pos = GetITBitfromIT(m_itTables.m_pHidden,
                          &HiddenOffset,
                          &HiddenBit,
                          InfoTypeSize()*8 );
    while ( (pos!=-1) && (IsDeleted(pos)) )
        pos = GetITBitfromIT(m_itTables.m_pHidden,
                          &HiddenOffset,
                          &HiddenBit,
                          InfoTypeSize()*8 );
    return pos;
}


int CInfoType::GetLastHidden(void) const
{
    int i;
    int iLastHidden=-1, temp;
    int offset=-1;
    INFOTYPE bit=1;

    for (i=0; i<HowManyInfoTypes(); i++)
        if ( (temp = GetITBitfromIT(m_itTables.m_pHidden, &offset, &bit, InfoTypeSize()*8)) == -1)
            return iLastHidden;
        else
            iLastHidden = temp;
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\classf.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"

#include "ClassF.H"
#include "Unknown.H"					// for CREATEFNOFOBJECT
#include "localobj.h"
#include "localsrv.h"

#ifndef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

HRESULT CreateOleObjectFromIndex(IUnknown *, int Index, void **, REFIID);

CClassFactory::CClassFactory(int iIndex)
{
	m_iIndex = iIndex;
	m_cRefs = 1;
}

CClassFactory::~CClassFactory ()
{
	ASSERT_COMMENT(m_cRefs == 0, "Object being deleted with refs!");
	return;
}

//=--------------------------------------------------------------------------=
// CClassFactory::QueryInterface
//=--------------------------------------------------------------------------=
// the user wants another interface.  we won't give 'em. very many.
//
// Parameters:
//	  REFIID		- [in]	interface they want
//	  void **		- [out] where they want to put the resulting object ptr.
//
// Output:
//	  HRESULT		- S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObjOut)
{
	void *pv;

	CHECK_POINTER(ppvObjOut);

	// we support IUnknown, and the two CF interfaces
	//
	if (DO_GUIDS_MATCH(riid, IID_IClassFactory)) {
		pv = (void *)(IClassFactory *)this;
	} else if (DO_GUIDS_MATCH(riid, IID_IClassFactory2)) {
		pv = (void *)(IClassFactory2 *)this;
	} else if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
		pv = (void *)(IUnknown *)this;
	} else {
		*ppvObjOut = NULL;
		return E_NOINTERFACE;
	}

	((IUnknown *)pv)->AddRef();
	*ppvObjOut = pv;
	return S_OK;
}

//=--------------------------------------------------------------------------=
// CClassFactory::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//	  ULONG 	   - the new reference count

ULONG CClassFactory::AddRef(void)
{
	return ++m_cRefs;
}

//=--------------------------------------------------------------------------=
// CClassFactory::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//	  ULONG 		- remaining refs

ULONG CClassFactory::Release(void)
{
	ASSERT_COMMENT(m_cRefs, "No Refs, and we're being released!");
	if(--m_cRefs)
		return m_cRefs;

	delete this;
	return 0;
}

//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstance
//=--------------------------------------------------------------------------=
// create an instance of some sort of object.
//
// Parameters:
//	  IUnknown *		- [in]	controlling IUknonwn for aggregation
//	  REFIID			- [in]	interface id for new object
//	  void **			- [out] pointer to new interface object.
//
// Output:
//	  HRESULT			- S_OK, E_NOINTERFACE, E_UNEXPECTED,
//						  E_OUTOFMEMORY, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstance
(
	IUnknown *pUnkOuter,
	REFIID	  riid,
	void	**ppvObjOut
)
{
	// check args
	//
	if (!ppvObjOut)
		return E_INVALIDARG;

	// check to see if we've done our licensing work.  we do this as late
	// as possible that people calling CreateInstanceLic don't suffer from
	// a performance hit here.
	//
	// crit sect this for apartment threading, since it's global
	//
	// EnterCriticalSection(&g_CriticalSection);
	if (!g_fCheckedForLicense) {
		g_fMachineHasLicense = TRUE;	// 17-Jun-1997 [ralphw] no license check
		g_fCheckedForLicense = TRUE;
	}
	// LeaveCriticalSection(&g_CriticalSection);

	// check to see if they have the appropriate license to create this stuff
	//
	//	08-Jan-1997 [ralphw] CLASS_E_NOTLICENSED disappeared from the header files
	//
	// if (!g_fMachineHasLicense)
	//	  return CLASS_E_NOTLICENSED;

	// try to create one of the objects that we support
	//
	return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CClassFactory::LockServer
//=--------------------------------------------------------------------------=
// lock the server so we can't unload
//
// Parameters:
//	  BOOL		  - [in] TRUE means addref, false means release lock count.
//
// Output:
//	  HRESULT	  - S_OK, E_FAIL, E_OUTOFMEMORY, E_UNEXPECTED

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
	// update the lock count. crit sect these in case of another thread.

	if (fLock)
		InterlockedIncrement(&g_cLocks);
	else {
		ASSERT_COMMENT(g_cLocks, "Lock Counting Problem");
		InterlockedDecrement(&g_cLocks);
	}

	return S_OK;
}

//=--------------------------------------------------------------------------=
// CClassFactory::GetLicInfo
//=--------------------------------------------------------------------------=
// IClassFactory2 GetLicInfo
//
// Parameters:
//	  LICINFO * 		 - unclear
//
// Output:
//	  HRESULT			 - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::GetLicInfo
(
	LICINFO *pLicInfo
)
{
	CHECK_POINTER(pLicInfo);

	pLicInfo->cbLicInfo = sizeof(LICINFO);

	// This says whether RequestLicKey will work

	pLicInfo->fRuntimeKeyAvail = g_fMachineHasLicense;

	// This says whether the standard CreateInstance will work

	pLicInfo->fLicVerified = g_fMachineHasLicense;

	return S_OK;
}

//=--------------------------------------------------------------------------=
// CClassFactory::RequestLicKey
//=--------------------------------------------------------------------------=
// IClassFactory2 RequestLicKey
//
// Parameters:
//	  DWORD 			- [in]	reserved
//	  BSTR *			- [out] unclear
//
// Output:
//	  HRESULT			- unclear
//
// Notes:
//

STDMETHODIMP CClassFactory::RequestLicKey(DWORD  dwReserved, BSTR *pbstr)
{
	*pbstr = NULL;
	return (*pbstr) ? S_OK : E_OUTOFMEMORY;
}


//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstanceLic
//=--------------------------------------------------------------------------=
// create a new instance given a licensing key, etc ...
//
// Parameters:
//	  IUnknown *		- [in]	controlling IUnknown for aggregation
//	  IUnknown *		- [in]	reserved, must be NULL
//	  REFIID			- [in]	IID We're looking for.
//	  BSTR				- [in]	license key
//	  void **			- [out] where to put the new object.
//
// Output:
//	  HRESULT			- unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstanceLic
(
	IUnknown *pUnkOuter,
	IUnknown *pUnkReserved,
	REFIID	  riid,
	BSTR	  bstrKey,
	void	**ppvObjOut
)
{
	*ppvObjOut = NULL;

	return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CreateOleObjectFromIndex
//=--------------------------------------------------------------------------=
// given an index in our object table, create an object from it.
//
// Parameters:
//	  IUnknown *	   - [in]  Controlling Unknown, if any, for aggregation
//	  int			   - [in]  index into our global table
//	  void **		   - [out] where to put resulting object.
//	  REFIID		   - [in]  the interface they want resulting object to be.
//
// Output:
//	  HRESULT		   - S_OK, E_OUTOFMEMORY, E_NOINTERFACE

HRESULT CreateOleObjectFromIndex
(
	IUnknown *pUnkOuter,
	int 	  iIndex,
	void	**ppvObjOut,
	REFIID	  riid
)
{
	ASSERT_COMMENT(CREATEFNOFOBJECT(iIndex), "All creatable objects must have creation fn!");
	IUnknown* pUnk = CREATEFNOFOBJECT(iIndex)(pUnkOuter);

	// sanity check and make sure the object actually got allocated.

	RETURN_ON_NULLALLOC(pUnk);

	// make sure we support aggregation here properly -- if they gave us
	// a controlling unknown, then they -must- ask for IUnknown, and we'll
	// give them the private unknown the object gave us.

	HRESULT   hr;
	if (pUnkOuter) {
		if (!DO_GUIDS_MATCH(riid, IID_IUnknown)) {
			pUnk->Release();
			return E_INVALIDARG;
		}

		*ppvObjOut = (void *)pUnk;
		hr = S_OK;
	} else {

		// QI for whatever the user wants.

		hr = pUnk->QueryInterface(riid, ppvObjOut);
		pUnk->Release();
		RETURN_ON_FAILURE(hr);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\clistbox.h ===
// Copyright (C) 1993-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CDLGLISTBOX_H__
#define __CDLGLISTBOX_H__

// Header-only classes for coding convenience

class CDlgListBox
{
public:
	CDlgListBox() { m_hWnd = NULL; }
	CDlgListBox(HWND hwndParent, int id) {
		m_hWnd = GetDlgItem(hwndParent, id);
		ASSERT_COMMENT(m_hWnd, "Invalid Listbox id");
		}
	void Initialize(int id) { ASSERT(m_hWnd); m_hWnd = GetDlgItem(GetParent(m_hWnd), id); };
	void Initialize(HWND hdlg, int id) { m_hWnd = ::GetDlgItem(hdlg, id); };

	INT_PTR  SendMessage(UINT msg, WPARAM wParam = 0, LPARAM lParam = 0) const { return ::SendMessage(m_hWnd, msg, wParam, lParam); };

	void Enable(BOOL fEnable = TRUE) const { EnableWindow(m_hWnd, fEnable); };

	INT_PTR  GetText(PSTR psz, int cchMax = MAX_PATH, int index = -1) const { return SendMessage(LB_GETTEXT,
		(index == -1) ? GetCurSel() : index, (LPARAM) psz); };
	INT_PTR  GetTextLength(int index = -1) const { return SendMessage(LB_GETTEXTLEN,
		(index == -1) ? GetCurSel() : index); };

	INT_PTR  GetCount() const { return SendMessage(LB_GETCOUNT); };
	void ResetContent() const { SendMessage(LB_RESETCONTENT); };
	void Reset() const { SendMessage(LB_RESETCONTENT); };

	INT_PTR  AddString(PCSTR psz) const { return SendMessage(LB_ADDSTRING, 0, (LPARAM) psz); };
	INT_PTR  InsertString(int index, PCSTR psz) const { return SendMessage(LB_INSERTSTRING, index, (LPARAM) psz); };
	INT_PTR  DeleteString(int index) const { return SendMessage(LB_DELETESTRING, index); };

	void RemoveListItem();	// removes currently selected item

	INT_PTR GetItemRect(RECT* prc, int index = -1)	const { return SendMessage(LB_GETITEMRECT,
		((index == -1) ? GetCurSel() : index), (LPARAM) prc); };

	INT_PTR  GetItemData(int index) const {  return SendMessage(LB_GETITEMDATA, index); };
	INT_PTR  SetItemData(int index, int data) const {  return SendMessage(LB_SETITEMDATA, index, data); };

	INT_PTR  GetCurSel() const {
		// works on single selection listbox only
		ASSERT(!(GetWindowLong(m_hWnd, GWL_STYLE) & LBS_MULTIPLESEL));
		return SendMessage(LB_GETCURSEL); };
	INT_PTR  SetCurSel(int index = 0) const {
		// works on single selection listbox only
		ASSERT(!(GetWindowLong(m_hWnd, GWL_STYLE) & LBS_MULTIPLESEL));
		return SendMessage(LB_SETCURSEL, index); };
	INT_PTR  GetTopIndex(void) const { return SendMessage(LB_GETTOPINDEX); };
	void SetTopIndex(int index) const { (void) SendMessage(LB_SETTOPINDEX, (WPARAM) index); };

	// For multi-select list boxes
	INT_PTR  GetSel(int index) const {
		// works on multiple selection listbox only
		ASSERT((GetWindowLong(m_hWnd, GWL_STYLE) & LBS_MULTIPLESEL));
		return SendMessage(LB_GETSEL, index); };
	void SetSel(int index, BOOL fSelect = TRUE) const {
		// works on multiple selection listbox only
		ASSERT((GetWindowLong(m_hWnd, GWL_STYLE) & LBS_MULTIPLESEL));
		(void) SendMessage(LB_SETSEL, fSelect, MAKELPARAM(index, 0)); };

	INT_PTR  FindString(PCSTR pszString, int iStart = -1) const { return SendMessage(LB_FINDSTRING, iStart, (LPARAM) pszString); };
	INT_PTR  SelectString(PCSTR pszString, int iStart = -1) const {
		// works on single selection listbox only
		ASSERT(!(GetWindowLong(m_hWnd, GWL_STYLE) & LBS_MULTIPLESEL));
		return SendMessage(LB_SELECTSTRING, iStart, (LPARAM) pszString); };

	void Invalidate(BOOL bErase = TRUE) { InvalidateRect(m_hWnd, NULL, bErase); }
	void DisableRedraw(void) { SendMessage(WM_SETREDRAW, FALSE); }
	void EnableRedraw(void)  { SendMessage(WM_SETREDRAW, TRUE); }

	HWND m_hWnd;

	operator HWND() const
		{ return m_hWnd; }
};

class CDlgCheckListBox : public CDlgListBox
{
public:
	CDlgCheckListBox();
	~CDlgCheckListBox();

	BOOL IsItemChecked(int nIndex) const;
	void CheckItem(int nIndex, BOOL fChecked = TRUE);
	void ToggleItem(int nIndex);

	void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	int  GetCheckRect(int nIndex, RECT* prc);
	void InvalidateItem(int nIndex, BOOL fRedraw = FALSE);
	int  ItemHeight(void);
	void DrawCheck(HDC hdc, RECT* prc, BOOL fChecked);
	void OnSelChange(void);

	int m_xMargin;
	int m_yMargin;
	int m_cxDlgFrame;
	int m_cxCheck;
	int m_cyCheck;
	int m_iLastSel;
	HBITMAP m_hbmpCheck;
};

#endif // __CDLGLISTBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cinfotyp.h ===
#ifndef _CINFOTYPE
#define _CINFOTYPE

#include "sitemap.h"
    // system.h is included so generally that it is not explicitly included even though it is required.
class CHmData;
class CSubSets;

class CInfoType {
private:
            // used by the copy consturctors
void CopyCat(const INFOTYPE_TABLES * Src_itTables);
void CopyTable( const INFOTYPE_TABLES *Src_itTables);

public:
    CInfoType(void);
    ~CInfoType();

        // Copy Constructor
        // *********************
    const CInfoType& operator=(const CInfoType& ITSrc); // copy constructor
    const CInfoType& operator=(const CSiteMap& ITSrc);
#ifdef HHCTRL
    void  CopyTo( CHmData * const phmData);
#endif
#if 0	// enable for subset filtering
    BOOL            IsEntryInCurTypeList(SITEMAP_ENTRY* pSiteMapEntry, CSubSets *pSSs) const;
    SITE_ENTRY_URL* AreTheseInfoTypesDefined(SITEMAP_ENTRY* pSiteMapEntry, CSubSets *pSSs) const;
#else
    BOOL            IsEntryInCurTypeList(SITEMAP_ENTRY* pSiteMapEntry) const;
    SITE_ENTRY_URL* AreTheseInfoTypesDefined(SITEMAP_ENTRY* pSiteMapEntry, UINT types, int offset) const;
#endif
    SITE_ENTRY_URL* NextUrlEntry(SITE_ENTRY_URL* pUrl) const { return (SITE_ENTRY_URL*) ((PBYTE) pUrl + m_cUrlEntry); }

    void            ReSizeIT(int Size=0);   

    int             GetInfoType(PCSTR pszTypeName) const ;//{ return GetITIndex(pszTypeName); }
    PCSTR           GetInfoTypeDescription(int pos) const { return m_itTables.m_ptblInfoTypeDescriptions->GetPointer(pos); }
    PCSTR           GetInfoTypeName(int pos) const { return m_itTables.m_ptblInfoTypes->GetPointer(pos); }
    int             GetITIndex(PCSTR pszString) const { return m_itTables.m_ptblInfoTypes->IsStringInTable( pszString ); }
    int             HowManyInfoTypes(void) const { return m_itTables.m_ptblInfoTypes ? m_itTables.m_ptblInfoTypes->CountStrings() : 0; }
    int             InfoTypeSize(void) const { return m_itTables.m_cITSize * sizeof(INFOTYPE); }
    BOOL            IsDeleted( const int pos) const {return ( *(GetInfoTypeName(pos))==' ' )?TRUE:FALSE;}
    BOOL            AnyInfoTypes(const INFOTYPE *pIT) const;
    BOOL            IsInACategory( int type ) const;

            // Exclusive Information Type methods
    int             GetFirstExclusive(int=-1, INFOTYPE=1) const;
    int             GetNextExclusive(void) const;
    int             GetLastExclusive(void) const;
    void            AddExclusiveIT(int const type) {AddIT(type, m_itTables.m_pExclusive); }
    void            DeleteExclusiveIT(int const type ) {DeleteIT(type, m_itTables.m_pExclusive); }
    BOOL            IsExclusive(int const type) const {return m_itTables.m_pExclusive?*(m_itTables.m_pExclusive+(type/32)) & (1<<(type%32)):0;}

            // Hidden Information Type methods
    int             GetFirstHidden(int=-1, INFOTYPE=1) const;
    int             GetNextHidden(void) const;
    int             GetLastHidden(void) const;
    void            AddHiddenIT( int const type ) {AddIT(type, m_itTables.m_pHidden); }
    void            DeleteHiddenIT( int const type ) {DeleteIT(type, m_itTables.m_pHidden); }
    BOOL            IsHidden(int const type) const {return m_itTables.m_pHidden?*(m_itTables.m_pHidden+(type/32)) & (1<<(type%32)):0;}

            // Category Methods
    int             GetFirstCategoryType(int pos) const ;
    int             GetNextITinCategory( void ) const ;
    int             GetLastCategoryType(int pos) const ;
    void            AddITtoCategory(int pos, int type);
    void            DeleteITfromCat(int pos, int type);
    int             GetCatPosition(PCSTR psz) const {return m_itTables.m_ptblCategories->IsStringInTable(psz); }
    int             HowManyCategories(void) const {return m_itTables.m_ptblCategories ? m_itTables.m_ptblCategories->CountStrings() : 0; }
    PCSTR           GetCategoryString(int pos) const { return m_itTables.m_ptblCategories->GetPointer(pos); }
    PCSTR           GetCategoryDescription(int pos) const {return m_itTables.m_ptblCatDescription?m_itTables.m_ptblCatDescription->GetPointer(pos):0; }
    BOOL            IsITinCategory( int pos, int type) const {return m_itTables.m_aCategories[pos].pInfoType?*(m_itTables.m_aCategories[pos].pInfoType+(type/32)) & (1<<(type%32)):0;}
    BOOL            IsCatDeleted( const int pos ) const {return ( *(GetCategoryString(pos))==' ' )?TRUE:FALSE;}

        // CInfotype members
        // ***********************
    BOOL            m_fTypeCopy;    // TRUE if following tables are pointers that must not be freed
    INFOTYPE_TABLES m_itTables;

    INFOTYPE*       m_pInfoTypes;           // user-specified Information Types
    INFOTYPE*       m_pTypicalInfoTypes;    // "typical" information types

    int             m_cUrlEntry;  // sizeof(SITE_ENTRY_URL) + sizeof(URL) for each additional 32 Information Types
    int             m_cInfoTypeOffsets; // number of additional offsets to check



private:
    BOOL    m_fInitialized;         // TRUE if IT and categorys read from disk.


};


#endif  // _CINFOTYPE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cnotes.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CNOTES_H__
#define __CNOTES_H__

#include "secwin.h"

class CNotes
{
public:
	CNotes(CHHWinType* phh);
	~CNotes();

	void	HideWindow(void);
	void	ShowWindow(void);
	void	ResizeWindow(BOOL fClientOnly);

protected:
	HWND	m_hwndNotes;
	HWND	m_hwndEditBox;
	BOOL	m_fModified;
	CHHWinType* m_phh;
};

#endif // __CNOTES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cnotes.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.
/*
    REVIEW: WHAT IS THE PURPOSE OF THIS CLASS? 
            WHO ARE THE CONSUMERS OF THIS CLASS?
*/

#include "header.h"
#include "cnotes.h"
#include "secwin.h"

CNotes::CNotes(CHHWinType* phh)
{
	m_phh = phh;
	m_hwndNotes = NULL;
	m_fModified = FALSE;
}

CNotes::~CNotes(void)
{
}

void CNotes::HideWindow(void)
{
	::ShowWindow(m_hwndNotes, SW_HIDE);
	m_phh->m_fNotesWindow = FALSE;

	// Force everything to resize

	SendMessage(m_phh->hwndHelp, WM_SIZE, SIZE_RESTORED, 0);
}

const int NOTES_BORDER = 3;

void CNotes::ShowWindow(void)
{
	m_phh->m_fNotesWindow = TRUE;
	if (!m_hwndNotes) {
		m_phh->CalcHtmlPaneRect();
		m_hwndNotes = CreateWindow(txtHtmlHelpChildWindowClass, NULL,
			WS_CHILD | WS_CLIPCHILDREN, m_phh->rcNotes.left, m_phh->rcNotes.top,
			RECT_WIDTH(m_phh->rcNotes), RECT_HEIGHT(m_phh->rcNotes), *m_phh, NULL,
			_Module.GetModuleInstance(), NULL);

		RECT rcClient;
		GetClientRect(m_hwndNotes, &rcClient);
		InflateRect(&rcClient, -NOTES_BORDER, -NOTES_BORDER);
		m_hwndEditBox = CreateWindowEx(WS_EX_CLIENTEDGE, "edit", NULL,
			WS_CHILD | ES_MULTILINE, rcClient.left, rcClient.top,
			RECT_WIDTH(rcClient), RECT_HEIGHT(rcClient),
			m_hwndNotes, NULL, _Module.GetModuleInstance(), NULL);
	}
	::ShowWindow(m_hwndNotes, SW_SHOW);
	::ShowWindow(m_hwndEditBox, SW_SHOW);

	// Force everything to resize

	SendMessage(m_phh->hwndHelp, WM_SIZE, SIZE_RESTORED, 0);
}

void CNotes::ResizeWindow(BOOL fClientOnly)
{
	ASSERT(m_phh->m_fNotesWindow);
	if (!fClientOnly) {
		m_phh->CalcHtmlPaneRect();
		MoveWindow(m_hwndNotes, m_phh->rcNotes.left,
			m_phh->rcNotes.top, RECT_WIDTH(m_phh->rcNotes),
			RECT_HEIGHT(m_phh->rcNotes), TRUE);
	}

	RECT rcClient;
	GetClientRect(m_hwndNotes, &rcClient);
	InflateRect(&rcClient, -NOTES_BORDER, -NOTES_BORDER);

	MoveWindow(m_hwndEditBox, rcClient.left,
		rcClient.top, RECT_WIDTH(rcClient),
		RECT_HEIGHT(rcClient), TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\collect.cpp ===
//*********************************************************************************************************************************************
//
//      File: collect.cpp
//  Author: Donald Drake
//  Purpose: Implements classes to support collections

#include "header.h"
#include "string.h"
#ifdef HHCTRL
#include "parserhh.h"
#include "toc.h"
#else
#include "stdio.h"
#include "windows.h"
#include "parser.h"
extern DWORD GetTitleVersion(const CHAR *szFileName);
extern LANGID GetLangId(const CHAR *szFileName);
#endif
#include "collect.h"

// Use CRT version in hhsetup

// Instance count checking:
AUTO_CLASS_COUNT_CHECK(CFolder);
AUTO_CLASS_COUNT_CHECK(CTitle);

#ifndef HHCTRL
#define Atoi atoi
#undef _splitpath
#endif

char gszColReg[MAX_PATH];
WCHAR *CreateUnicodeFromAnsi(LPSTR psz);

class CAnsi {
public:
    char *m_pszChar;
    CAnsi(WCHAR *);
    ~CAnsi();
    operator CHAR *() { return (CHAR *) m_pszChar; }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Helper functions
DWORD AllocSetValue(const CHAR *value, CHAR **dest)
{
   if (*dest)
      delete [] *dest;

   // REVIEW: confirm that len gets optimized out of existence

   int len = (int)strlen(value) + 1;

   *dest = new CHAR[len];

   if (*dest == NULL)
      return F_MEMORY;

   strcpy(*dest, value);
   return F_OK;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CPointerList implementation
void foo(void)
{

}

void CPointerList::RemoveAll()
{
   LISTITEM *p;

   while (m_pHead)
   {
      p = m_pHead->Next;
      delete m_pHead;
      m_pHead = p;
   }
}

CPointerList::~CPointerList()
{
   RemoveAll();
}

LISTITEM *CPointerList::Add(void *p)
{
   LISTITEM *pItem = new LISTITEM;

   if (pItem)
   {
      pItem->pItem = p;
      pItem->Next = m_pHead;
      m_pHead = pItem;
      return pItem;
   }
   return NULL;
}

LISTITEM *CPointerList::First()
{
   return m_pHead;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CColList implementation

CColList::CColList()
{
	m_dwColNo = 0;
    m_szFileName = NULL;
	m_pNext = NULL;
}

void CColList::SetFileName(CHAR *sz)
{
	if (sz)
	    AllocSetValue(sz, &m_szFileName);
}

CColList::~CColList()
{
	if (m_szFileName)
		delete m_szFileName;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CCollection implementation

CCollection::CCollection()
{
    m_bRemoved = FALSE;
    m_pwcSampleLocation = NULL;
    m_pwcMasterCHM = NULL;
    m_bFailNoFile = FALSE;
    m_bDirty = FALSE;
   m_szSampleLocation = NULL;
   m_szFileName = NULL;
    m_pwcFileName = NULL;
   m_szMasterCHM = NULL;
   m_pFirstTitle = NULL;
   m_pTitleTail = NULL;
   m_pColListHead = NULL;
   m_pColListTail = NULL;
   m_pLocationTail = NULL;
   m_pFirstLocation = NULL;
   m_pRootFolder = NULL;
   m_locationnum = 0;
   m_dwNextColNo = 1;
   m_dwColNo = 0;
   m_dwTitleRefCount = 0;
   m_dwRef = 0;
   m_dwVersion = 0;
   m_bFindMergedChms = FALSE;
   for (int i = 0; i < MAX_LEVELS; i++)
      m_pParents[i] = NULL;

   m_dwCurLevel = 0;
   m_dwLastLevel = 0;
   m_bConfirmTitles = FALSE;
   m_MasterLangId = ENGLANGID;
   gszColReg[0] = NULL;
#ifdef HHSETUP
   CoInitialize(NULL);   
#endif
}

CCollection::~CCollection()
{
   Close();
#ifdef HHSETUP
   CoUninitialize();   
#endif
}

DWORD CCollection::Release()
{
   if (m_dwRef == 0)
      return 0;
   m_dwRef--;
   return m_dwRef;
}

void CCollection::DeleteChildren(CFolder **p)
{
   if (!p || !(*p))
      return;

   CFolder *pChild, *pNext;
   if (pChild = (*p)->GetFirstChildFolder())
      DeleteChildren(&pChild);
   pNext = (*p)->GetNextFolder();
   delete (*p);
   *p = NULL;
   do {
      if (pNext)
         DeleteChildren(&pNext);
   } while (pNext && (pNext = pNext->GetNextFolder()));
}

void CCollection::SetSampleLocation(const CHAR *sz)
{
   if (!sz)
      return;
    Dirty();
   AllocSetValue(sz, &m_szSampleLocation);
}

CHAR *CCollection::GetSampleLocation()
{
   return m_szSampleLocation;
}


BOOL CCollection::GetMasterCHM(CHAR **szName, LANGID *pLang)
{
   *pLang = m_MasterLangId;
   *szName = m_szMasterCHM;
   if (m_szMasterCHM == NULL)
      return FALSE;
   return ((strlen(m_szMasterCHM) ? TRUE : FALSE));
}

void CCollection::SetMasterCHM(const CHAR *sz, LANGID lang)
{
   if (!sz)
      return;
    Dirty();
   m_MasterLangId = lang;
   AllocSetValue(sz, &m_szMasterCHM);
}

// Opens and loads the contents of the file into data structures
DWORD CCollection::Open(const CHAR * FileName)
{
   DWORD dw;
   BOOL bOld = FALSE;
   BOOL bTryAgain = FALSE;
   if (m_pRootFolder == NULL)
   {
      m_pRootFolder = new CFolder;
      if (m_pRootFolder == NULL)
         return F_MEMORY;
      m_pParents[0] = m_pRootFolder;
   }

   CHAR szBuffer[MAX_PATH];
   const CHAR *sz = szBuffer;
   BOOL bNewPath;
   HHGetGlobalCollectionPathname(szBuffer, sizeof(szBuffer), &bNewPath);

   dw = ParseFile(sz);

#ifdef HHCTRL  // hhsetup should only be concerned about the good location for this file
   if (dw == F_NOFILE && bNewPath)
   {
     // try windows dir for backward compatibity
try_again:
     bNewPath=FALSE;
     HHGetOldGlobalCollectionPathname(szBuffer, sizeof(szBuffer));
     dw = ParseFile(sz);
     bOld = TRUE;
   }
#endif

   if (dw != F_OK && dw != F_NOFILE)
      return dw;

   if (dw == F_NOFILE && m_bFailNoFile)
      return F_NOFILE;

   // save the hhcolreg file and path for save calls...  
   strcpy(gszColReg, sz);

   if (bNewPath && m_dwNextColNo < STARTINGCOLNO)
      m_dwNextColNo += STARTINGCOLNO;


   if (FileName)
      dw = ParseFile(FileName);

   if (dw != F_OK && dw != F_NOFILE)
      return dw;

   if (dw == F_NOFILE && m_bFailNoFile)
      return F_NOFILE;

   // now that we moved the file, if we did not get any titles found for the collection at runtime
   // and we have not looked at the old hhcolreg location let try it.

#ifdef HHCTRL // runtime only, I really hate this
    if (m_RefTitles.First() == NULL && bOld == FALSE && bTryAgain == FALSE)
    {
        Close();
        ConfirmTitles();
        m_bFailNoFile = TRUE;
        bTryAgain = TRUE;
        if (m_pRootFolder == NULL)
        {
            m_pRootFolder = new CFolder;
            if (m_pRootFolder == NULL)
                return F_MEMORY;
            m_pParents[0] = m_pRootFolder;
        }
        goto try_again;
    }

   // did we find any titles that matched
   if (m_RefTitles.First() == NULL)
   {
      return F_REFERENCED;
   }
#endif


   dw = AllocSetValue(FileName, &m_szFileName);

   m_bDirty = FALSE;

   CColList *pCol;

   if ((pCol = FindCollection(m_szFileName)) == NULL)
   {
	   // collection has never been added 
	   pCol = AddCollection();
	   pCol->SetFileName(m_szFileName);
#ifdef HHCTRL
	   if (m_dwColNo)
		   pCol->SetColNo(m_dwColNo);
	   else
	   {
   		   pCol->SetColNo(m_dwNextColNo);
  		   m_dwNextColNo++;
           if (bNewPath && m_dwNextColNo < STARTINGCOLNO)
            m_dwNextColNo += STARTINGCOLNO;
	   }
#else
  	   pCol->SetColNo(m_dwNextColNo);
	   m_dwNextColNo++;
       if (bNewPath && m_dwNextColNo < STARTINGCOLNO)
          m_dwNextColNo += STARTINGCOLNO;
#endif
	   m_bDirty = TRUE;
   }
   m_dwColNo = pCol->GetColNo();

   return dw;
}

CColList * CCollection::FindCollection(CHAR *szFileName)
{
   CColList *p = m_pColListHead;
   while (p)
   {
	   if (stricmp(p->GetFileName(), szFileName) == 0)
			return p;
	   p = p->GetNext();
   }
   return NULL;
}

CColList * CCollection::AddCollection()
{

   CColList *newCol = new CColList;
   if (!newCol)
   {
      return NULL;
   }

   if (m_pColListHead == NULL)
   {
      m_pColListHead = newCol;
   }
   else
   {
      m_pColListTail->SetNext(newCol);
   }
   m_pColListTail = newCol;
   return newCol;
}

void CCollection::RemoveCollectionEntry(CHAR *szFileName)
{
   CColList *p = m_pColListHead;
   CColList *pPrev = NULL;
   while (p)
   {
	   if (stricmp(p->GetFileName(), szFileName) == 0)
	   {
	      if (pPrev)
		  {
			  pPrev->SetNext(p->GetNext());
		  }
		  else
		  {
		      m_pColListHead = p->GetNext();
		  }
		  if (m_pColListTail == p)
			  m_pColListTail = pPrev;
		  delete p;
		  break;
	   }
	   pPrev = p;
	   p = p->GetNext();
   }
}



DWORD CCollection::AllocCopyValue(CParseXML *parser, CHAR *token, CHAR **dest)
{
   CHAR *sz;

   if (!parser || !token || !dest)
      return F_NULL;

   sz = parser->GetValue(token);
   if (*dest)
      delete [] *dest;

   int len = (int)strlen(sz) + 1;

   *dest = new CHAR[len];
   if (*dest == NULL)
      return F_MEMORY;

   strcpy(*dest, sz);
   return F_OK;
}

DWORD CCollection::ParseFile(const CHAR *FileName)
{
   CParseXML parser;
   CHAR *token;
   CHAR *sz;
   DWORD dw;

   if (!FileName)
      return F_NULL;

   if ((dw = parser.Start(FileName)) != F_OK)
      return dw;


   for (token = parser.GetToken(); token;)
   {
      if (token[0] == '/')
      {
         dw = m_Strings.GetTail(&sz);
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         if (strcmp(sz, &token[1]) != 0)
         {
            parser.End();
            delete sz;
            return F_TAGMISSMATCH;
         }
         delete sz;
         if (strcmp(token, "/Folder") == 0)
            m_dwCurLevel--;
         token = parser.GetToken();
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "XML") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
         continue;
      }
	  else if (stricmp(parser.GetFirstWord(token), "Collections") == 0)
	  {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
         continue;
	  }		 
      else if (stricmp(parser.GetFirstWord(token), "Collection") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         if ((dw = HandleCollectionEntry(&parser, token)) != F_OK)
         {
            parser.End();
            return dw;
         }
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "HTMLHelpCollection") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         if ((dw = HandleCollection(&parser, token)) != F_OK)
         {
            parser.End();
            return dw;
         }
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "NextCollectionId") == 0)
      {
         m_dwNextColNo = atoi(parser.GetValue(token));
         token = parser.GetToken();
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "Folders") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "Folder") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         if ((dw = HandleFolder(&parser, token)) != F_OK)
         {
            parser.End();
            return dw;
         }
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "HTMLHelpDocInfo") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "Locations") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "Location") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         if ((dw = HandleLocation(&parser, token)) != F_OK)
         {
            parser.End();
            return dw;
         }
         continue;
      }
      else if (strcmp(parser.GetFirstWord(token), "DocCompilations") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
         continue;
      }
      else if (strcmp(parser.GetFirstWord(token), "DocCompilation") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         if ((dw = HandleTitle(&parser, token)) != F_OK)
         {
            parser.End();
            return dw;
         }
         continue;
      }
      else
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
      }
   }

   // make sure all tags have been popped
   dw = F_OK;
   while (m_Strings.GetTail(&sz) == F_OK)
   {
      delete sz;
      dw = F_MISSINGENDTAG;
   }
   parser.End();
   return dw;
}
DWORD CCollection::HandleCollectionEntry(CParseXML *parser, CHAR *token)
{
   if (!parser || !token)
      return F_NULL;

   CColList *newCol = AddCollection();
   
   if (!newCol)
   {
      return F_MEMORY;
   }

   while (TRUE)
   {
      token = parser->GetToken();
      if (stricmp(parser->GetFirstWord(token), "colname") == 0)
      {
          newCol->SetFileName(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "colnum") == 0)
      {
		  newCol->SetColNo( atoi(parser->GetValue(token)));
      }
      else
         break;
   }
   return F_OK;
}

DWORD CCollection::HandleCollection(CParseXML *parser, CHAR *token)
{
   if (!parser || !token)
      return F_NULL;

   while (TRUE)
   {
      token = parser->GetToken();
      if (stricmp(parser->GetFirstWord(token), "homepage") == 0)
      {
            // need to be backward compatable with this tag
      }
      else if (stricmp(parser->GetFirstWord(token), "masterchm") == 0)
      {
            SetMasterCHM( parser->GetValue(token), ENGLANGID);
      }
      else if (stricmp(parser->GetFirstWord(token), "samplelocation") == 0)
      {
            SetSampleLocation( parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "masterlangid") == 0)
      {
         m_MasterLangId = (LANGID)atoi(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "refcount") == 0)
      {
         m_dwRef = atoi(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "version") == 0)
      {
         m_dwVersion = atoi(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "showhomepage") == 0)
      {
            // need to be backward compatable with this tag
      }
	  else if (stricmp(parser->GetFirstWord(token), "findmergedchms") == 0)
	  {
		 m_bFindMergedChms = atoi(parser->GetValue(token));
	  }
      else if (stricmp(parser->GetFirstWord(token), "CollectionNum") == 0)
      {
         m_dwColNo = atoi(parser->GetValue(token));
      }
      else
         break;
   }
   return F_OK;
}

DWORD CCollection::HandleFolder(CParseXML *parser, CHAR *token)
{
   if (!parser || !token)
      return F_NULL;
   CFolder *newFolder = new CFolder;
   if (newFolder == NULL)
      return F_MEMORY;

   m_dwCurLevel++;
   while (TRUE)
   {
      token = parser->GetToken();

      if (stricmp(parser->GetFirstWord(token), "TitleString") == 0)
      {
            newFolder->SetTitle(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "FolderOrder") == 0)
      {
            newFolder->SetOrder(atoi(parser->GetValue(token)));
      }
      else if (stricmp(parser->GetFirstWord(token), "LangId") == 0)
      {
            newFolder->SetLanguage((LANGID)atoi(parser->GetValue(token)));
      }
      else
         break;
   }

   CHAR *pTitle;
   pTitle = newFolder->GetTitle();
   if (pTitle && pTitle[0] == '=')
   {
      if (CheckTitleRef(pTitle, newFolder->GetLanguage()) != F_OK)
      {
         delete newFolder;
         return F_OK;
      }
      AddRefedTitle(newFolder);
   }

   m_pParents[m_dwCurLevel - 1]->AddChildFolder(newFolder);
   m_pParents[m_dwCurLevel] = newFolder;

   return F_OK;
}

DWORD CCollection::AddRefedTitle(CFolder *pFolder)
{
      m_dwTitleRefCount++;
      m_RefTitles.Add(pFolder);
      return F_OK;
}


DWORD CCollection::HandleLocation(CParseXML *parser, CHAR *token)
{
   if (!parser || !token)
      return F_NULL;
   CLocation *newLocation = NewLocation();

   if (newLocation == NULL)
      return F_MEMORY;

   newLocation->m_ColNum = 0;
   while (TRUE)
   {
      token = parser->GetToken();
      if (stricmp(parser->GetFirstWord(token), "LocName") == 0)
      {
            newLocation->SetId(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "TitleString") == 0)
      {
            newLocation->SetTitle(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "LocPath") == 0)
      {
            newLocation->SetPath(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "Volume") == 0)
      {
            newLocation->SetVolume(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "LocColNum") == 0)
      {
            newLocation->m_ColNum = atoi(parser->GetValue(token));
      }
      else
         break;
   }

   return F_OK;
}


DWORD CCollection::HandleTitle(CParseXML *parser, CHAR *token)
{

   if (!parser || !token)
      return F_NULL;

   LOCATIONHISTORY *pNew;
   CTitle *newTitle = NewTitle();
   DWORD dw;

    CHAR *pSampleLocation = NULL;
    BOOL bMerge = FALSE;

   if (newTitle == NULL)
      return F_MEMORY;

   while (TRUE)
   {
      token = parser->GetToken();
      if (stricmp(parser->GetFirstWord(token), "DocCompId") == 0)
      {
            newTitle->SetId(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "TitleString") == 0)
      {
            // no longer do anything with titlestring but need to support for backward compatiblity
            continue;
      }
      else if (stricmp(parser->GetFirstWord(token), "TitleSampleLocation") == 0)
      {
                if (newTitle->m_pTail == NULL)
                {
                    // old style global.col, save this for the locations to follow
                    AllocCopyValue(parser, token, &pSampleLocation);
                }
                else
               if ((dw = AllocCopyValue(parser, token, &(newTitle->m_pTail->SampleLocation))) != F_OK)
                  return dw;
      }
      else if (stricmp(parser->GetFirstWord(token), "DocCompLanguage") == 0)
      {
            newTitle->SetLanguage((LANGID)atoi(parser->GetValue(token)));
      }
      else if (stricmp(parser->GetFirstWord(token), "SupportsMerge") == 0)
      {
                if (newTitle->m_pTail == NULL)
                {
                    // old style global.col, save this for the locations to follow
                    bMerge = (BOOL)atoi(parser->GetValue(token));
                }
                else
               newTitle->m_pTail->bSupportsMerge = (BOOL)atoi(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "LocationHistory") == 0)
      {
            pNew = newTitle->NewLocationHistory();

            if (pNew == NULL)
               return F_MEMORY;

                if (pSampleLocation)
               if ((dw = AllocSetValue(pSampleLocation, &(newTitle->m_pTail->SampleLocation))) != F_OK)
                  return dw;

                newTitle->m_pTail->bSupportsMerge = bMerge;

            dw = m_Strings.AddTail(parser->GetFirstWord(token));
            if (dw != F_OK)
            {
               return dw;
            }
      }
      else if (stricmp(parser->GetFirstWord(token), "/LocationHistory") == 0)
      {
         CHAR *sz;
         dw = m_Strings.GetTail(&sz);
         if (dw != F_OK)
         {
            return dw;
         }

         if (strcmp(sz, &token[1]) != 0)
         {
            delete sz;
            return F_TAGMISSMATCH;
         }
         delete sz;
      }
      else if (stricmp(parser->GetFirstWord(token), "TitleLocation") == 0)
      {
         if ((dw = AllocCopyValue(parser, token, &(newTitle->m_pTail->FileName))) != F_OK)
            return dw;
      }
      else if (stricmp(parser->GetFirstWord(token), "QueryLocation") == 0)
      {
         if ((dw = AllocCopyValue(parser, token, &(newTitle->m_pTail->QueryFileName))) != F_OK)
            return dw;
      }
      else if (stricmp(parser->GetFirstWord(token), "TitleQueryLocation") == 0)
      {
         if ((dw = AllocCopyValue(parser, token, &(newTitle->m_pTail->QueryLocation))) != F_OK)
            return dw;
      }
      else if (stricmp(parser->GetFirstWord(token), "IndexLocation") == 0)
      {
         if ((dw = AllocCopyValue(parser, token, &(newTitle->m_pTail->IndexFileName))) != F_OK)
            return dw;
      }
      else if (stricmp(parser->GetFirstWord(token), "LocationRef") == 0)
      {
         if ((dw = AllocCopyValue(parser, token, &(newTitle->m_pTail->LocationId))) != F_OK)
            return dw;
      }
      else if (stricmp(parser->GetFirstWord(token), "Version") == 0)
      {
         newTitle->m_pTail->Version = atoi(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "LastPromptedVersion") == 0)
      {
         newTitle->m_pTail->LastPromptedVersion = atoi(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "ColNum") == 0)
      {
         newTitle->m_pTail->CollectionNumber = atoi(parser->GetValue(token));
      }
      else
         break;
   }

    if (pSampleLocation)
        delete pSampleLocation;

   return F_OK;
}

// Saves any changes made to the internal data structures to the file.
DWORD CCollection::Save()
{
   CHAR szBuffer[MAX_LINE_LEN];
   DWORD dwWritten;

#ifdef HHSETUP  // only hhsetup needs to rewrite the users .col file
                // don't want the control to add any new tags to old
                // collections, which would break uninstall and update
   // if no root folders delete the collection file
   if (m_bRemoved == TRUE)
   {
      DeleteFile(m_szFileName);
      m_bRemoved = FALSE;
   }
   else
   {
      if ((m_fh = CreateFile(m_szFileName, GENERIC_WRITE, FILE_SHARE_READ,  NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL )) == INVALID_HANDLE_VALUE) {
         return F_NOFILE;
      }

      strcpy(szBuffer, "<XML>\r\n");
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      // write out collection information
      strcpy(szBuffer, "<HTMLHelpCollection>\r\n");
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<masterchm value=\"%s\"/>\r\n", (m_szMasterCHM ? m_szMasterCHM : ""));
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<masterlangid value=%d/>\r\n", m_MasterLangId);
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<samplelocation value=\"%s\"/>\r\n", (m_szSampleLocation ? m_szSampleLocation : ""));
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<collectionnum value=%d/>\r\n", m_dwColNo);
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<refcount value=%d/>\r\n", m_dwRef);
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<version value=%d/>\r\n", m_dwVersion);
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<findmergedchms value=%d/>\r\n", m_bFindMergedChms);
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      // write out folders
      strcpy(szBuffer,"<Folders>\r\n");
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }
      m_dwCurLevel = 0;

      if (WriteFolders(&m_pRootFolder) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }


      // close tags
      strcpy(szBuffer, "</Folders>\r\n");
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      strcpy(szBuffer, "</HTMLHelpCollection>\r\n");
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      strcpy(szBuffer, "</XML>\r\n");
      if (WriteFile(m_fh, szBuffer, (ULONG)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      CloseHandle(m_fh);
   }

#endif

   // save the global titles and locations
   // open collection file
   if ((m_fh = CreateFile(gszColReg, GENERIC_WRITE, FILE_SHARE_READ,  NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL )) == INVALID_HANDLE_VALUE) {
      return F_NOFILE;
   }

   // write out XML tag
   strcpy(szBuffer, "<XML>\r\n");
   if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
   {
       CloseHandle(m_fh);
       return F_WRITE;
   }

   strcpy(szBuffer, "<HTMLHelpDocInfo>\r\n");
   if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
   {
       CloseHandle(m_fh);
       return F_WRITE;
   }

   wsprintf(szBuffer, "<NextCollectionId value=%d/>\r\n", m_dwNextColNo);
   if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
   {
       CloseHandle(m_fh);
       return F_WRITE;
   }

   // write out the collection list
   strcpy(szBuffer, "<Collections>\r\n");
   if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
   {
       CloseHandle(m_fh);
       return F_WRITE;
   }

   CColList *pCol = m_pColListHead;

   while (pCol)
   {
      strcpy(szBuffer, "<Collection>\r\n");
      if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
      {
          CloseHandle(m_fh);
          return F_WRITE;
      }
      wsprintf(szBuffer, "\t<ColNum value=%d/>\r\n",  pCol->GetColNo());
      if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
      {
          CloseHandle(m_fh);
          return F_WRITE;
      }
      wsprintf(szBuffer, "\t<ColName value=\"%s\"/>\r\n",  (pCol->GetFileName() ? pCol->GetFileName() : ""));
      if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
      {
          CloseHandle(m_fh);
          return F_WRITE;
      }
      strcpy(szBuffer, "</Collection>\r\n");
      if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
      {
          CloseHandle(m_fh);
          return F_WRITE;
      }

      pCol = pCol->GetNext();
   }
   strcpy(szBuffer, "</Collections>\r\n");
    if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        CloseHandle(m_fh);
        return F_WRITE;
    }

   // write out the locations
   strcpy(szBuffer, "<Locations>\r\n");
    if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        CloseHandle(m_fh);
        return F_WRITE;
    }

   CLocation *p = FirstLocation();

   while (p)
   {
      strcpy(szBuffer, "<Location>\r\n");
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<LocColNum value=%d/>\r\n",  p->m_ColNum);
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<LocName value=\"%s\"/>\r\n",  (p->GetId() ? p->GetId() : ""));
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<TitleString value=\"%s\"/>\r\n", (p->GetTitle() ? p->GetTitle() : ""));
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<LocPath value=\"%s\"/>\r\n", (p->GetPath() ? p->GetPath() : ""));
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<Volume value=\"%s\"/>\r\n", (p->GetVolume() ? p->GetVolume() : ""));
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      strcpy(szBuffer, "</Location>\r\n");
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }

      p = p->GetNextLocation();
   }
   strcpy(szBuffer, "</Locations>\r\n");
    if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        CloseHandle(m_fh);
        return F_WRITE;
    }


   // write out the titles
   strcpy(szBuffer, "<DocCompilations>\r\n");
    if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        CloseHandle(m_fh);
        return F_WRITE;
    }

   CTitle *pTitle = GetFirstTitle();
   LOCATIONHISTORY *pHist;
   while (pTitle)
   {
      strcpy(szBuffer, "<DocCompilation>\r\n");
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<DocCompId value=\"%s\"/>\r\n", (pTitle->GetId() ? pTitle->GetId() : ""));
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<DocCompLanguage value=%d/>\r\n", pTitle->GetLanguage());
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }

      pHist = pTitle->m_pHead;

      while (pHist)
      {
         strcpy(szBuffer, "\t<LocationHistory>\r\n");
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<ColNum value=%d/>\r\n",  pHist->CollectionNumber);
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<TitleLocation value=\"%s\"/>\r\n", (pHist->FileName ? pHist->FileName : ""));
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<IndexLocation value=\"%s\"/>\r\n", (pHist->IndexFileName ? pHist->IndexFileName : ""));
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<QueryLocation value=\"%s\"/>\r\n", (pHist->QueryFileName ? pHist->QueryFileName : ""));
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<LocationRef value=\"%s\"/>\r\n", (pHist->LocationId ? pHist->LocationId : ""));
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<Version value=%ld/>\r\n", pHist->Version);
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<LastPromptedVersion value=%ld/>\r\n", pHist->LastPromptedVersion);
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
          wsprintf(szBuffer, "\t\t<TitleSampleLocation value=\"%s\"/>\r\n", (pHist->SampleLocation ? pHist->SampleLocation : ""));
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
          wsprintf(szBuffer, "\t\t<TitleQueryLocation value=\"%s\"/>\r\n", (pHist->QueryLocation ? pHist->QueryLocation : ""));
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<SupportsMerge value=%d/>\r\n", pHist->bSupportsMerge);
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         strcpy(szBuffer, "\t</LocationHistory>\r\n");
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         pHist = pHist->pNext;
      }
      strcpy(szBuffer, "</DocCompilation>\r\n");
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      pTitle = pTitle->GetNextTitle();
   }

   strcpy(szBuffer, "</DocCompilations>\r\n");
    if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
         CloseHandle(m_fh);
         return F_WRITE;
    }
   strcpy(szBuffer, "</HTMLHelpDocInfo>\r\n");
    if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
         CloseHandle(m_fh);
         return F_WRITE;
    }
   strcpy(szBuffer,"</XML>\r\n");
    if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
         CloseHandle(m_fh);
         return F_WRITE;
    }
   if (CloseHandle(m_fh) == FALSE)
        return F_CLOSE;

   // make sure we can open this file for read
   if ((m_fh = CreateFile(gszColReg, GENERIC_READ, FILE_SHARE_READ,  NULL, OPEN_EXISTING , FILE_ATTRIBUTE_NORMAL, NULL )) == INVALID_HANDLE_VALUE) {
      return F_EXISTCHECK;
   }

   if (CloseHandle(m_fh) == FALSE)
        return F_CLOSE;

   return F_OK;
}

BOOL CCollection::WriteFolders(CFolder **p)
{
    BOOL b = TRUE;
   if (!p || !(*p))
      return FALSE;

   CFolder *pChild;

   pChild = (*p)->GetFirstChildFolder();

   if (pChild)
      b = WriteFolder(&pChild);

   delete *p;
   *p = NULL;
    return b;
}

BOOL CCollection::WriteFolder(CFolder **p)
{
   if (!p || !(*p))
      return FALSE;

   CHAR szBuffer[MAX_LINE_LEN];
   DWORD dwWritten;

   CFolder *pChild, *pNext;
   DWORD i;
   // write this folder
   // tab over the indent level
   strcpy(szBuffer, "\t");
   for (i = 0; i < m_dwCurLevel; i++)
   {
      if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            return FALSE;
        }
   }
   strcpy(szBuffer, "<Folder>\r\n");
    if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        return FALSE;
    }

   strcpy(szBuffer, "\t");
   for (i = 0; i < m_dwCurLevel+1; i++)
   {
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            return FALSE;
        }
   }
   wsprintf(szBuffer,  "<TitleString value=\"%s\"/>\r\n", (*p)->GetTitle());
    if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        return FALSE;
    }

   strcpy(szBuffer, "\t");
   for (i = 0; i < m_dwCurLevel+1; i++)
   {
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            return FALSE;
        }
    }

   wsprintf(szBuffer,  "<FolderOrder value=%d/>\r\n", (*p)->GetOrder());
    if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        return FALSE;
    }

   CHAR *pTitle = (*p)->GetTitle();
   if (pTitle[0] == '=')
   {
      strcpy(szBuffer, "\t");
      for (i = 0; i < m_dwCurLevel+1; i++)
      {
            if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                return FALSE;
            }
      }
      wsprintf(szBuffer,  "<LangId value=%d/>\r\n", (*p)->GetLanguage());
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            return FALSE;
        }
   }

   m_dwCurLevel++;
   if (pChild = (*p)->GetFirstChildFolder())
   {
      if (WriteFolder(&pChild) == FALSE)
            return FALSE;
   }
   if (m_dwCurLevel)
      m_dwCurLevel--;

   strcpy(szBuffer, "\t");
   for (i = 0; i < m_dwCurLevel; i++)
   {
        if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            return FALSE;
        }
   }
   strcpy(szBuffer, "</Folder>\r\n");
    if (WriteFile(m_fh, szBuffer, (int)strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        return FALSE;
    }

   pNext = (*p)->GetNextFolder();
   delete (*p);
   *p = NULL;
   do {
      if (pNext)
      {
         if (WriteFolder(&pNext) == FALSE)
                return FALSE;
      }
   } while (pNext && (pNext = pNext->GetNextFolder()));
    return TRUE;
}

DWORD CCollection::Close()
{
   m_locationnum = 0;
   gszColReg[0] = NULL;
   m_dwNextColNo = 1;
   m_dwColNo = 0;
   m_dwTitleRefCount = 0;
   m_dwRef = 0;
   m_dwVersion = 0;
   for (int i = 0; i < MAX_LEVELS; i++)
      m_pParents[i] = NULL;
   m_dwCurLevel = 0;
   m_dwLastLevel = 0;
   m_bConfirmTitles = FALSE;
   m_MasterLangId = ENGLANGID;
   m_bFindMergedChms = FALSE;
   m_Strings.RemoveAll();

   if (m_szFileName)
   {
      delete m_szFileName;
      m_szFileName = NULL;
   }

   if (m_pwcFileName)
   {
      delete m_pwcFileName;
      m_pwcFileName = NULL;
   }

   if (m_szMasterCHM)
   {
      delete m_szMasterCHM;
      m_szMasterCHM = NULL;
   }

   if (m_pwcMasterCHM)
   {
      delete m_pwcMasterCHM;
      m_pwcMasterCHM = NULL;
   }

   if (m_szSampleLocation)
   {
      delete m_szSampleLocation;
      m_szSampleLocation = NULL;
   }

   // clean up col list
   CColList *pCol, *pColNext;
   for (pCol = m_pColListHead; pCol; pCol = pColNext)
   {
      pColNext = pCol->GetNext();
	  delete pCol;
   }

   m_pColListHead = NULL;
   m_pColListTail = NULL;

   // clean up locations
   CLocation *p, *pNext;
   for (p = m_pFirstLocation; p; p=pNext)
   {
      pNext = p->GetNextLocation();
      delete p;
   }

   m_pFirstLocation=NULL;
   m_pLocationTail = NULL;
   // clean up titles
   CTitle *pTitle, *pNextTitle;
   for (pTitle = m_pFirstTitle; pTitle; pTitle=pNextTitle)
   {
      pNextTitle = pTitle->GetNextTitle();
      delete pTitle;
   }

   m_pFirstTitle = NULL;
   m_pTitleTail = NULL;
   // clean up folder
   if (m_pRootFolder)
   {
      DeleteChildren(&m_pRootFolder);
   }
   m_pRootFolder = NULL;
   return F_OK;
}

// Returns the first title
CTitle * CCollection::GetFirstTitle()
{
   return m_pFirstTitle;
}

// Locates a title based on id
CTitle * CCollection::FindTitle(const CHAR * Id, LANGID LangId)
{
   if (!Id)
      return NULL;

   CTitle *p;

   p = m_pFirstTitle;

   while (p)
   {
      if (stricmp(p->GetId(), Id) == 0 &&
            (LangId == 0 || p->GetLanguage() == LangId)) // Ignore LangId if its zero.
        {
         return p;
        }
      p = p->GetNextTitle();
   }
   return NULL;
}

#ifdef HHCTRL
// Try multiple LangIds before failing
CTitle * CCollection::FindTitleNonExact(const CHAR * Id, LANGID DesiredLangId)
{
    CTitle* pTitle = NULL ;

    CLanguageEnum* pEnum = _Module.m_Language.GetEnumerator(DesiredLangId) ;
    ASSERT(pEnum) ;
    LANGID langid = pEnum->start() ;
    while (langid != c_LANGID_ENUM_EOF)
    {
        pTitle = FindTitle(Id, langid);
        if (pTitle)
        {
            break ; //Found It!
        }

        langid = pEnum->next() ;
    }

    // Cleanup.
    if (pEnum)
    {
        delete pEnum ;
    }

    return pTitle;
}
#endif // #ifdef HHCTRL

// Returns the first location
CLocation* CCollection::FirstLocation()
{
   return m_pFirstLocation;
}

// Finds a location based on a name
CLocation * CCollection::FindLocation(const CHAR * Id, UINT* puiVolumeOrder )
{
   if (!Id)
      return NULL;

   CLocation *p;

   p = m_pFirstLocation;

    if( puiVolumeOrder )
      *puiVolumeOrder = 0;

   while (p)
   {
        if( puiVolumeOrder )
          *puiVolumeOrder = (*puiVolumeOrder)+1;

      if (stricmp(p->GetId(), Id) == 0 && (p->m_ColNum == m_dwColNo|| p->m_ColNum == 0))
         return p;
      p = p->GetNextLocation();
   }
   return NULL;
}

DWORD CCollection::CheckTitleRef(const CHAR *pId, const LANGID Lang)
{
   if (m_bConfirmTitles == FALSE)
      return F_OK;

   if (pId[0] != '=')
      return F_OK;

   CTitle *pTitle;
   if ((pTitle = FindTitle(&pId[1], Lang)) == NULL)
      return F_NOTITLE;

   LOCATIONHISTORY *p;

   p = pTitle->m_pHead;

   while (p)
   {
      if (p->CollectionNumber == GetColNo())
         return F_OK;
      p = p->pNext;
   }

   return F_NOTITLE;
}

//Adds a new folder to the top level of the table of contents, with the given name and order and returns a pointer to that folder object.  A return of NULL indicates a failure and pDWORD will be populated with one of  above DWORD codes.
CFolder * CCollection::AddFolder(const CHAR * szName, DWORD Order, DWORD *pDWORD, LANGID LangId)
{
   if (!szName)
   {
      if (pDWORD)
         *pDWORD = F_NULL;
      return NULL;
   }

   if (CheckTitleRef(szName, LangId) != F_OK)
   {
      if (pDWORD)
         *pDWORD = F_NOTITLE;
      return NULL;
   }

   CFolder *pNew;

   pNew = new CFolder;

   DWORD dwrc = F_OK;

   if (pNew)
   {
      pNew->SetTitle(szName);
      pNew->SetOrder(Order);
      pNew->SetLanguage(LangId);
      dwrc = m_pRootFolder->AddChildFolder(pNew);

      if (dwrc != F_OK)
      {
	 if (pDWORD)
            *pDWORD = dwrc;
         delete pNew;
         return NULL;
      }

      Dirty();
      return pNew;
   }

   if (pDWORD) 
      *pDWORD = F_MEMORY;
   return NULL;
}

CTitle * CCollection::NewTitle()
{
   CTitle *newTitle = new CTitle;
   if (newTitle == NULL)
      return NULL;

   if (m_pFirstTitle == NULL)
   {
      m_pFirstTitle = newTitle;
   }
   else
   {
      m_pTitleTail->SetNextTitle(newTitle);
   }
   m_pTitleTail = newTitle;

   return newTitle;
}

// Adds a title based on the provided information. A return of NULL indicates a failure and pDWORD will be  populated with one of  above DWORD codes.
// Note: you must add or find a CLocation object or pass null to indication no location is in use (local file).
CTitle * CCollection::AddTitle(const CHAR * Id, const CHAR * FileName,
   const CHAR * IndexFile, const CHAR * Query, const CHAR *SampleLocation,  LANGID Lang, UINT uiFlags,
   CLocation *pLocation,  DWORD *pDWORD, BOOL bSupportsMerge, const CHAR *QueryLocation)
{
   if (!Id || !FileName || !IndexFile)
      return NULL;
   DWORD dwrc;

   CTitle *pTitle;

   // check if the title exist
   if (pTitle = FindTitle(Id, Lang))
   {
      // add location
      dwrc = pTitle->AddLocationHistory(m_dwColNo, FileName, IndexFile, Query, pLocation, SampleLocation, QueryLocation, bSupportsMerge);
      if (pDWORD)
          *pDWORD = dwrc;
   }
   else
   {
      // just add the title then
      pTitle = NewTitle();
      if (pTitle == NULL)
      {
         if (pDWORD) 
	    *pDWORD = F_MEMORY;
         return NULL;
      }
      pTitle->SetId(Id);
      pTitle->SetLanguage(Lang);
      dwrc = pTitle->AddLocationHistory(m_dwColNo, FileName, IndexFile, Query, pLocation, SampleLocation, QueryLocation, bSupportsMerge);
      if (pDWORD)
          *pDWORD = dwrc;
   }
   Dirty();
   return pTitle;
}

CLocation * CCollection::NewLocation()
{
   CLocation *p = new CLocation;
   if (!p)
   {
      return NULL;
   }
   if (m_pFirstLocation == NULL)
   {
      m_pFirstLocation = p;
   }
   else
   {
      m_pLocationTail->SetNextLocation(p);
   }
   m_pLocationTail = p;
   return p;
}

// Adds location based on the given information. A return of NULL indicates a failure and pDWORD will be populated with one of  above DWORD codes.
CLocation * CCollection::AddLocation(const CHAR * Title, const CHAR * Path, const CHAR * Id, const CHAR * Volume, DWORD *pDWORD)
{
   if (!Title || !Path || !Id || !Volume)
      return NULL;

   CLocation *p;

   p = FindLocation(Id);

   // if not found then add new location entry
   if (!p)
      p = NewLocation();

   if (!p)
   {
      if (pDWORD) 
         *pDWORD = F_MEMORY;
      return NULL;
   }

   p->SetTitle(Title);
   p->SetPath(Path);
   p->SetId(Id);
   p->SetVolume(Volume);
   p->m_ColNum = m_dwColNo;
   if (pDWORD)
      *pDWORD = F_OK;
    Dirty();
   return p;
}


// removing objects
DWORD CCollection::DeleteFolder(CFolder *pDelete)
{

   if (!pDelete)
      return F_NULL;

   CFolder *pParent;
   CFolder *pPrev = NULL;
   CFolder *p;

   if ((pParent = pDelete->GetParent()) == NULL)
      return F_NOPARENT;

   p = pParent->GetFirstChildFolder();

   while (p)
   {
      if (p == pDelete)
      {
         // is this the head
         if  (!pPrev)
         {
            pParent->SetFirstChildFolder(p->GetNextFolder());
         }
         else
         {
            // fixup the list
            pPrev->SetNextFolder(p->GetNextFolder());
         }

         DeleteChildren(&pDelete);
       Dirty();
         return F_OK;

      }
      pPrev = p;
      p = p->GetNextFolder();
   }

   return F_NOTFOUND;
}

DWORD CCollection::DeleteTitle(CTitle *pDelete)
{
   if (!pDelete)
      return F_NULL;
   // remove all location history entries for this collection
   LOCATIONHISTORY *pHist, *pHistPrev;
   pHistPrev = NULL;
   pHist = pDelete->m_pHead;

   while (pHist)
   {
      if (pHist->CollectionNumber == m_dwColNo)
      {
         // head
         if (pHist == pDelete->m_pHead)
         {
            // and tail
            if (pHist == pDelete->m_pTail)
            {
               pDelete->m_pHead = NULL;
               pDelete->m_pTail = NULL;
               DeleteLocalFiles(pHist, pDelete);
               delete pHist;
               break;
            }
            pDelete->m_pHead = pHist->pNext;
            DeleteLocalFiles(pHist, pDelete);
            delete pHist;
            pHist = pDelete->m_pHead;
            pHistPrev = NULL;
            continue;
         }

         // tail
         if (pHist == pDelete->m_pTail)
         {
            pDelete->m_pTail = pHistPrev;
            if (pHistPrev)
               pHistPrev->pNext = NULL;
            DeleteLocalFiles(pHist, pDelete);
            delete pHist;
            break;
         }

         pHistPrev->pNext = pHist->pNext;
         DeleteLocalFiles(pHist, pDelete);
         delete pHist;
         pHist = pHistPrev->pNext;
      }
      else
      {
         pHistPrev = pHist;
         pHist = pHist->pNext;
      }
   }
    Dirty();

   // if no history remains remove the title
   if (pDelete->m_pHead != NULL)
      return F_OK;

   CTitle *p, *pPrev;

   p = m_pFirstTitle;
   pPrev = NULL;

   if (p== NULL)
      return F_NOTFOUND;

   while (p)
   {
      if (p == pDelete)
      {
         // is this the head
         if  (!pPrev)
         {
            m_pFirstTitle = p->GetNextTitle();
         }
         // is this the tail
         else if (p == m_pTitleTail)
         {
            m_pTitleTail = pPrev;
            pPrev->SetNextTitle(p->GetNextTitle());
         }
         else
         {
            // fixup the list
            pPrev->SetNextTitle(p->GetNextTitle());
         }

         delete p;
         return F_OK;
      }
      pPrev = p;
      p = p->GetNextTitle();
   }
   return F_NOTFOUND;
}

void CCollection::DeleteLocalFiles(LOCATIONHISTORY *pThisHist, CTitle *pTitle)
{
   if (m_bRemoveLocalFiles == FALSE)
        return;

   LOCATIONHISTORY *pHist;
   pHist = pTitle->m_pHead;

   // if the chm or chi is in use don't delete
   while (pHist)
   {
         if (strcmp(pHist->FileName, pThisHist->FileName) == 0)
            return;
         if (strcmp(pHist->IndexFileName, pThisHist->IndexFileName) == 0)
            return;
         pHist = pHist->pNext;
   }

   // if these are local files delete them
   char drive[_MAX_DRIVE+1];
   char dir[_MAX_DIR];
   char fname[_MAX_FNAME];
   char ext[_MAX_EXT];

   _splitpath( pThisHist->FileName, drive, dir, fname, ext );

    if(drive[1] == ':')
   {
       drive[2] = '\\';
      drive[3] = 0;
   }

   if (GetDriveType(drive) == DRIVE_FIXED)
   {
      // delete the title
      if (DeleteFile(pThisHist->FileName) == FALSE)
         m_bAllFilesDeleted = FALSE;
      // could need to check for and delete samples stuff here
   }

    // if files are different
    if (strcmp(pThisHist->IndexFileName, pThisHist->FileName))
   {
        _splitpath( pThisHist->IndexFileName, drive, dir, fname, ext );

        if(drive[1] == ':')
       {
          drive[2] = '\\';
          drive[3] = 0;
       }

      if (GetDriveType(drive) == DRIVE_FIXED)
      {
          // delete the index
          if (DeleteFile(pThisHist->IndexFileName) == FALSE)
              m_bAllFilesDeleted = FALSE;
          // could need to check for and delete samples stuff here
       }
    }
}


// only used from HHSETUP
LANGID CCollection::GetLangId(const CHAR *szFileName)
{
#ifdef HHSETUP
    return ::GetLangId(szFileName);
#else
    return 0;
#endif
}


DWORD CCollection::DeleteLocation(CLocation *pDelete)
{
   if (!pDelete)
      return F_NULL;
   CLocation *p, *pPrev;

   p = m_pFirstLocation;
   pPrev = NULL;

   if (p== NULL)
      return F_NOTFOUND;

   while (p)
   {
      if (p == pDelete)
      {
         // is this the head
         if  (!pPrev)
         {
            m_pFirstLocation = p->GetNextLocation();
         }
         // is this the tail
         else if (p == m_pLocationTail)
         {
            m_pLocationTail = pPrev;
            pPrev->SetNextLocation(NULL);
         }
         else
         {
            // fixup the list
            pPrev->SetNextLocation(p->GetNextLocation());
         }

         delete p;
       Dirty();
         return F_OK;
      }
      pPrev = p;
      p = p->GetNextLocation();
   }
   return F_NOTFOUND;
}


DWORD CCollection::RemoveCollection(BOOL bRemoveLocalFiles)
{
   // if release returns a positive ref count then don't delete
   if (Release())
      return F_OK;

   m_bRemoveLocalFiles = bRemoveLocalFiles;
   m_bAllFilesDeleted = TRUE;
   m_bRemoved = TRUE;

   CTitle *pT = GetFirstTitle();
   CTitle *pNext;
   while (pT)
   {
       pNext = pT->GetNextTitle();
       DeleteTitle(pT);
       pT  = pNext;
   }

   // delete locations for this collection
   CLocation *pL = FirstLocation();
   CLocation *pNextLoc;

   while (pL)
   {
        pNextLoc = pL->GetNextLocation();
        if (pL->m_ColNum == m_dwColNo)
            DeleteLocation(pL);
        pL = pNextLoc;
   }
	
   RemoveCollectionEntry(m_szFileName);

   Dirty();
   if (m_bRemoveLocalFiles == TRUE && m_bAllFilesDeleted == FALSE)
        return F_DELETE;
    return F_OK;
}

void CCollection::DeleteFolders(CFolder **p)
{
   CFolder *pChild, *pNext;
   if (pChild = (*p)->GetFirstChildFolder())
      DeleteFolders(&pChild);
   pNext = (*p)->GetNextFolder();

   // check if this is a title
   const CHAR *pTitle = (*p)->GetTitle();

   if (pTitle && pTitle[0] == '=')  // if so delete it.
   {
      CTitle *pT;

      pT = FindTitle(&pTitle[1], (*p)->GetLanguage());
      if (pT)
         DeleteTitle(pT);
   }

   delete (*p);
   *p = NULL;
   do {
      if (pNext)
         DeleteFolders(&pNext);
   } while (pNext && (pNext = pNext->GetNextFolder()));
}


// Merges the currently installed titles for the collection into the specified filename (path determined internally)
BOOL CCollection::MergeKeywords(CHAR * pwzFilename )
{
   return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CFolder implementation

CFolder::CFolder()
 {
   Title = NULL;
   pwcTitle = NULL;
   Order = 0;
   LangId = ENGLANGID;
   pNext = NULL;
   pKid = NULL;
   pParent = NULL;
   iLevel = 0;
   f_HasHash = 0;
   f_IsOrphan = 1;       // Assume the worst.
}

CFolder::~CFolder()
{
   if (Title)
      delete Title;
   if(pwcTitle)
       delete pwcTitle;
}

void CFolder::SetTitle(const  CHAR *sz)
{
   AllocSetValue(sz, &Title);
}

void CFolder::SetExTitlePtr(CExTitle* pTitle)
{
   CFolder* pTmp;

   pExTitle = pTitle;
   f_IsOrphan = 0;

   pTmp = pParent;
   while ( pTmp )
   {
      pTmp->f_IsOrphan = 0;
      pTmp = pTmp->pParent;
   }
}

void CFolder::SetOrder(DWORD newOrder)
{
   Order = newOrder;
}

DWORD CFolder::GetOrder()
{
   return Order;
}

// Returns the next sibling folder given a folder entry
CFolder * CFolder::GetNextFolder()
{
   return pNext;
}

// Returns the first child of a given folder if it exists
CFolder * CFolder::GetFirstChildFolder()
{
   return pKid;
}

CFolder * CFolder::AddChildFolder(const CHAR *szName, DWORD Order, DWORD *pError, LANGID LangId)
{
   CFolder *pFolder = new CFolder;

   if (pFolder == NULL)
      return NULL;

   pFolder->SetTitle(szName);
   pFolder->SetOrder(Order);
   pFolder->SetLanguage(LangId);

   DWORD dwrc = AddChildFolder(pFolder);
   if (pError)
      *pError = dwrc;
   return pFolder;
}

DWORD CFolder::AddChildFolder(CFolder *newFolder)
{
   CFolder* pTmp;
   newFolder->SetParent(this);
   if (pKid == NULL)
   {
      pKid = newFolder;
   }
   else
   {
      if (newFolder->GetOrder() < pKid->GetOrder())
      {
         // make this the first child
         newFolder->pNext = pKid;
         pKid = newFolder;
      }
      else
      {
         // search for an insertion point
         CFolder *pNext = pKid->pNext;
         CFolder *pPrev = pKid;
         while (pNext)
         {
            if (newFolder->GetOrder() < pNext->GetOrder())
            {
               newFolder->pNext = pNext;
               break;
            }
            pPrev = pNext;
            pNext = pNext->pNext;
         }
         pPrev->pNext = newFolder;
      }
   }
   //
   // Setup members to facilitate subsetting...
   //
   if ( newFolder->Title && newFolder->Title[0] == '=' )
   {
      newFolder->f_HasHash = 1;
      //
      // Leaf nodes will be rendered as open books in the subset dialog.
      //
      newFolder->f_A_Open = 1;
      newFolder->f_F_Open = 1;
   }
   pTmp = newFolder->pParent;
   while ( pTmp )
   {
      newFolder->iLevel++;
      pTmp = pTmp->pParent;
   }
   newFolder->iLevel--;
   return F_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CTitle implementation

void CTitle::SetId(const CHAR *sz)
{
   AllocSetValue(sz, &Id);
}

void CTitle::SetLanguage(LANGID l)
{
   Language = l;
}

CHAR *CTitle::GetId()
{
   return Id;
}

LANGID CTitle::GetLanguage()
{
   return Language;
}

LOCATIONHISTORY *CTitle::NewLocationHistory()
{
   LOCATIONHISTORY *p;

   p = new LOCATIONHISTORY;

   if (p == NULL)
      return NULL;

   p->SampleLocation = NULL;
   p->QueryLocation = NULL;
   p->FileName = NULL;
   p->IndexFileName = NULL;
   p->QueryFileName = NULL;
   p->LocationId = NULL;
   p->Version = 0;
   p->LastPromptedVersion = 0;
    p->bSupportsMerge = FALSE;
   p->pNext = NULL;

   if (m_pHead == NULL)
   {
      m_pHead = p;
   }
   else
   {
      m_pTail->pNext = p;
   }
   m_pTail = p;

   return p;
}


DWORD CTitle::AddLocationHistory(DWORD ColNo, const CHAR *FileName, const CHAR *IndexFile, const CHAR *Query, const CLocation *pLocation,  const CHAR *SampleLocation, const CHAR *QueryLocation, BOOL bSupportsMerge)
{
   LOCATIONHISTORY *p;
   // get version information
    DWORD dwNewVersion;
#ifdef HHSETUP
    if (IndexFile)
       dwNewVersion = GetTitleVersion(IndexFile);
    else  if (FileName)
       dwNewVersion = GetTitleVersion(FileName);
    else
        dwNewVersion = 0;
#else
    dwNewVersion = 0;
#endif

   // see of any current entries match is new one if so update the existing item.
    if (m_pHead)
   {
      p = m_pHead;

      while (p)
      {
            if (p->CollectionNumber == ColNo &&
                ((FileName == NULL && p->FileName[0] == NULL) || (FileName &&strcmp(p->FileName, FileName) == 0)) &&
                ((IndexFile == NULL && p->IndexFileName[0] == NULL) || (IndexFile &&strcmp(p->IndexFileName, IndexFile) == 0)) &&
                ((Query == NULL && p->QueryFileName[0] == NULL) || (Query &&strcmp(p->QueryFileName, Query) == 0)) &&
                ((SampleLocation == NULL && p->SampleLocation[0] == NULL) || (SampleLocation &&strcmp(p->SampleLocation, SampleLocation) == 0)) &&
                ((QueryLocation == NULL && p->QueryLocation[0] == NULL) || (QueryLocation &&strcmp(p->QueryLocation, QueryLocation) == 0)) &&
                p->bSupportsMerge == bSupportsMerge)
            {
                if (pLocation && strcmp(pLocation->GetId(), p->LocationId) != 0)
                {
                    p = p->pNext;
                    continue;
                }
                // everything matches just update the version number
                p->Version = dwNewVersion;
                return F_OK;
            }
           p = p->pNext;
      }
    }

    // see if we already have this version if so update to location
    if (m_pHead)
   {
      p = m_pHead;

      while (p)
      {
            if (p->Version == dwNewVersion && p->CollectionNumber == ColNo)
            {
                // same version update location
                p->bSupportsMerge = bSupportsMerge;
               if (FileName)
                  AllocSetValue(FileName, &p->FileName);
                else
                    p->FileName = NULL;

               if (IndexFile)
                  AllocSetValue(IndexFile, &p->IndexFileName);
                else
                    p->IndexFileName = NULL;

               if (SampleLocation)
                     AllocSetValue(SampleLocation, &p->SampleLocation);
                else
                    p->SampleLocation = NULL;

               if (QueryLocation)
                     AllocSetValue(QueryLocation, &p->QueryLocation);
                else
                    p->QueryLocation = NULL;

               if (Query)
                  AllocSetValue(Query, &p->QueryFileName);
                else
                    p->QueryFileName = NULL;

               if (pLocation)
                  AllocSetValue(pLocation->GetId() , &p->LocationId);
                else
                    p->LocationId = NULL;

                return F_OK;
            }
         p = p->pNext;
      }
    }

    p = NewLocationHistory();

   if (p == NULL)
      return F_MEMORY;

   p->Version = dwNewVersion;
   p->CollectionNumber = ColNo;
    p->bSupportsMerge = bSupportsMerge;
   if (FileName)
      AllocSetValue(FileName, &p->FileName);
   if (IndexFile)
      AllocSetValue(IndexFile, &p->IndexFileName);
   if (SampleLocation)
         AllocSetValue(SampleLocation, &p->SampleLocation);
   if (QueryLocation)
         AllocSetValue(QueryLocation, &p->QueryLocation);
   else
      AllocSetValue("", &p->QueryLocation);

   if (Query)
      AllocSetValue(Query, &p->QueryFileName);
   else
      AllocSetValue("", &p->QueryFileName);
      
   if (pLocation)
      AllocSetValue(pLocation->GetId() , &p->LocationId);

   return F_OK;
}

LOCATIONHISTORY * CTitle::GetLocation(DWORD Index)
{
   LOCATIONHISTORY *p;

   p = m_pHead;
   for (DWORD i = 0; p && i < Index; i++)
      p++;

   return p;
}

CTitle* CTitle::GetNextTitle()
{
   return NextTitle;
}

CTitle::~CTitle()
{
   if (Id) delete Id;
    if (pwcId)
       delete pwcId;

   // clean up location history
   LOCATIONHISTORY *p, *pNext;
   for (p = m_pHead; p; p=pNext)
   {
      pNext = p->pNext;
      if (p->FileName) delete p->FileName;
      if (p->IndexFileName) delete p->IndexFileName;
      if (p->QueryFileName) delete p->QueryFileName;
      if (p->LocationId) delete p->LocationId;
      if (p->SampleLocation) delete p->SampleLocation;
      if (p->QueryLocation) delete p->QueryLocation;
      delete p;
   }
}

CTitle::CTitle()
{
   Id = NULL;
   pwcId = NULL;
   Language = 0;
   NextTitle = NULL;
   m_pHead = NULL;
   m_pTail = NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CLocation implementation

// BUGBUG: 29-May-1997  [ralphw] This is a lot of code overhead to call
// functions that do nothing but return a value or exectue a single line
// of code. These should all be inlined, at least for the OCX version
// to cut down code size.

void CLocation::SetId(const CHAR *sz)
{
   AllocSetValue(sz, &Id);
}

void CLocation::SetTitle(const CHAR *sz)
{
   AllocSetValue(sz, &Title);
}

void CLocation::SetPath(const CHAR *sz)
{
   AllocSetValue(sz, &Path);
}

void CLocation::SetVolume(const CHAR *sz)
{
   AllocSetValue(sz, &Volume);
}

CHAR * CLocation::GetId() const
{
   return Id;
}

CHAR * CLocation::GetTitle()
{
   return Title;
}

CHAR * CLocation::GetPath()
{
   return Path;
}

CHAR * CLocation::GetVolume()
{
   return Volume;
}

// Returns the next location
CLocation * CLocation::GetNextLocation()
{
   return NextLocation;
}

// UNICODE APIs /////////////////////////////////////////////////////////////////////////////////////////////////
//

void CFolder::SetTitle(const WCHAR *pTitle)
{
    CAnsi cszTemp((WCHAR *)pTitle);
    SetTitle((char *)cszTemp);
}

const WCHAR * CFolder::GetTitleW()
{
    if(pwcTitle)
        delete [] pwcTitle;

    pwcTitle = CreateUnicodeFromAnsi(Title);

    return pwcTitle;
}

CFolder * CFolder::AddChildFolder(const WCHAR *szName, DWORD Order, DWORD *pError, LANGID LangId)
{
    CAnsi cszTemp1((WCHAR *)szName);
    return AddChildFolder((CHAR *)cszTemp1,Order,pError,LangId);
}


const WCHAR * CTitle::GetIdW()
{
    if(pwcId)
        delete [] pwcId;

    pwcId = CreateUnicodeFromAnsi(Id);

   return pwcId;
}

void CTitle::SetId(const WCHAR *pszId)
{
    CAnsi cszTemp1((WCHAR *)pszId);
    SetId((CHAR *)cszTemp1);
}

DWORD CTitle::AddLocationHistory(DWORD ColNo, const WCHAR *FileName, const WCHAR *IndexFile, const WCHAR *Query, const CLocation *pLocation, const WCHAR *Sample, const WCHAR *QueryLocation, BOOL bSupportsMerge)
{
    CAnsi cszTemp1((WCHAR *)FileName);
    CAnsi cszTemp2((WCHAR *)IndexFile);
    CAnsi cszTemp3((WCHAR *)Query);
    CAnsi cszTemp4((WCHAR *)Sample);
    CAnsi cszTemp5((WCHAR *)QueryLocation);
    return AddLocationHistory(ColNo, (CHAR *)cszTemp1, (CHAR *)cszTemp2, (CHAR *)cszTemp3, pLocation, (CHAR *)cszTemp4, (CHAR *)cszTemp5, bSupportsMerge);
}

void CLocation::SetId(const WCHAR *pwcTemp)
{
    CAnsi cszTemp1((WCHAR *)pwcTemp);
   SetId((CHAR *)cszTemp1);
}

void CLocation::SetTitle(const WCHAR *pwcTemp)
{
    CAnsi cszTemp1((WCHAR *)pwcTemp);
   SetTitle((CHAR *)cszTemp1);
}

void CLocation::SetPath(const WCHAR *pwcTemp)
{
    CAnsi cszTemp1((WCHAR *)pwcTemp);
   SetPath((CHAR *)cszTemp1);
}

void CLocation::SetVolume(const WCHAR *pwcTemp)
{
    CAnsi cszTemp1((WCHAR *)pwcTemp);
   SetVolume((CHAR *)cszTemp1);
}

const WCHAR * CLocation::GetIdW()
{
    if(pwcId)
        delete [] pwcId;

    pwcId = CreateUnicodeFromAnsi(Id);

   return pwcId;
}

const WCHAR * CLocation::GetTitleW()
{
    if(pwcTitle)
        delete [] pwcTitle;

    pwcTitle = CreateUnicodeFromAnsi(Title);

   return pwcTitle;
}

const WCHAR * CLocation::GetPathW()
{
    if(pwcPath)
        delete [] pwcPath;

    pwcPath = CreateUnicodeFromAnsi(Path);

    return pwcPath;
}

const WCHAR * CLocation::GetVolumeW()
{
    if(pwcVolume)
        delete [] pwcVolume;

    pwcVolume = CreateUnicodeFromAnsi(Volume);

    return pwcVolume;
}

DWORD CCollection::CheckTitleRef(const WCHAR *pId, const LANGID Lang)
{
    CAnsi cszTemp1((WCHAR *)pId);
    return CheckTitleRef(cszTemp1, Lang);
}

void CCollection::SetSampleLocation(const WCHAR *pwcItem1)
{
    CAnsi cszTemp1((WCHAR *)pwcItem1);
    SetSampleLocation(cszTemp1);
}

const WCHAR * CCollection::GetSampleLocationW()
{
    if(m_pwcSampleLocation)
        delete [] m_pwcSampleLocation;

    m_pwcSampleLocation = CreateUnicodeFromAnsi(m_szSampleLocation);

   return m_pwcSampleLocation;
}

void CCollection::SetMasterCHM(const WCHAR *szName, LANGID Lang)
{
    CAnsi cszTemp1((WCHAR *)szName);
    SetMasterCHM(cszTemp1, Lang);
}

BOOL CCollection::GetMasterCHM(WCHAR ** szName, LANGID *pLang)
{
   *pLang = m_MasterLangId;
    *szName = NULL;
   if (m_szMasterCHM == NULL)
      return FALSE;

    if(m_pwcMasterCHM)
        delete [] m_pwcMasterCHM;

    m_pwcMasterCHM = CreateUnicodeFromAnsi(m_szMasterCHM);

    *szName = m_pwcMasterCHM;

    return ((strlen(m_szMasterCHM) ? TRUE : FALSE));
}

DWORD CCollection::Open(const WCHAR * FileName)
{
    CAnsi cszTemp1((WCHAR *)FileName);
    return Open(cszTemp1);
}

CTitle * CCollection::FindTitle(const WCHAR * Id, LANGID LangId)
{
    CAnsi cszTemp1((WCHAR *)Id);
    return FindTitle(cszTemp1, LangId);
}

CLocation * CCollection::FindLocation(const WCHAR * Name, UINT* puiVolumeOrder)
{
    CAnsi cszTemp1((WCHAR *)Name);
    return FindLocation(cszTemp1,puiVolumeOrder);
}

CFolder * CCollection::AddFolder(const WCHAR * szName, DWORD Order, DWORD *pDWORD, LANGID LangId)
{
    CAnsi cszTemp1((WCHAR *)szName);
    return AddFolder(cszTemp1, Order, pDWORD, LangId);
}

CTitle * CCollection::AddTitle(const WCHAR * Id, const WCHAR * FileName,
                               const WCHAR * IndexFile, const WCHAR * Query,
                               const WCHAR *SampleLocation, LANGID Lang,
                               UINT uiFlags, CLocation *pLocation,
                               DWORD *pDWORD,  BOOL bSupportsMerge,
                               const WCHAR *QueryLocation)
{
    CAnsi cszTemp1((WCHAR *)Id);
    CAnsi cszTemp2((WCHAR *)FileName);
    CAnsi cszTemp3((WCHAR *)IndexFile);
    CAnsi cszTemp4((WCHAR *)Query);
    CAnsi cszTemp5((WCHAR *)SampleLocation);
    CAnsi cszTemp6((WCHAR *)QueryLocation);
    return AddTitle(cszTemp1, cszTemp2, cszTemp3, cszTemp4,cszTemp5, Lang, uiFlags, pLocation, pDWORD, bSupportsMerge, cszTemp6);
}

CLocation * CCollection::AddLocation(const WCHAR * Title, const WCHAR * Path, const WCHAR * Id, const WCHAR * Volume, DWORD *pDWORD)
{
    CAnsi cszTemp1((WCHAR *)Title);
    CAnsi cszTemp2((WCHAR *)Path);
    CAnsi cszTemp3((WCHAR *)Id);
    CAnsi cszTemp4((WCHAR *)Volume);
    return AddLocation(cszTemp1, cszTemp2,cszTemp3,cszTemp4,pDWORD);
}


BOOL CCollection::MergeKeywords(WCHAR * pwzFilename )
{
    CAnsi cszTemp1((WCHAR *)pwzFilename);
    return MergeKeywords(cszTemp1);
}

const WCHAR *CCollection::GetCollectionFileNameW(void)
{
    if(m_pwcFileName)
        delete [] m_pwcFileName;

    m_pwcFileName = CreateUnicodeFromAnsi(m_szFileName);

    return m_pwcFileName;
}

LANGID CCollection::GetLangId(const WCHAR *FileName)
{
    CAnsi cszTemp1((WCHAR *)FileName);
    return GetLangId(cszTemp1);
}

WCHAR *CreateUnicodeFromAnsi(LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    if(!psz)
        return NULL;

    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0)
        return NULL;

    pwsz = (LPWSTR) new WCHAR[i];

    if (!pwsz)
        return NULL;

    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i * sizeof(WCHAR));
    return pwsz;
}


CAnsi::CAnsi(WCHAR *pwcString)
{
    m_pszChar = NULL;

    int i;

    i =  WideCharToMultiByte(CP_ACP, 0, pwcString, -1, NULL, 0, NULL, NULL);

    if (i <= 0)
        return;

    m_pszChar = (CHAR *) new CHAR[i];

    WideCharToMultiByte(CP_ACP, 0, pwcString, -1, m_pszChar, i, NULL, NULL);
    m_pszChar[i - 1] = 0;
}

CAnsi::~CAnsi()
{
    if(m_pszChar)
        delete [] m_pszChar;
}


#ifdef HHCTRL

//
// CSlotLookupTable implementation...
//

int FASTCALL CSlotLookupTable::ltqs_callback(const void *elem1, const void *elem2)
{
   struct _slt* p1 = (struct _slt*)elem1;
   struct _slt* p2 = (struct _slt*)elem2;

   if ( p1->hash > p2->hash )
      return 1;
   else if ( p2->hash > p1->hash )
      return -1;
   else
      return 1;
}

CSlotLookupTable::CSlotLookupTable()
{
   m_pSLT = NULL;
   m_uiTotalCnt = m_uiHashCnt = m_uiTotalAllocated = 0;
}

CSlotLookupTable::~CSlotLookupTable()
{
   if ( m_pSLT )
      lcFree(m_pSLT);
}

void CSlotLookupTable::AddValue(CFolder* pFolder)
{
   if ( (m_uiTotalCnt &&  (!(m_uiTotalCnt % 8))) || (m_uiTotalAllocated == 0) )
   {
      m_uiTotalAllocated += 8;
      m_pSLT = (struct _slt*)lcReAlloc(m_pSLT, sizeof(struct _slt) * m_uiTotalAllocated);
   }
   m_pSLT[m_uiTotalCnt].pCFolder = pFolder;
   if ( pFolder->f_HasHash )
   {
      m_pSLT[m_uiTotalCnt].hash = pFolder->pExTitle->m_dwHash;
      m_uiHashCnt++;
   }
   else
      m_pSLT[m_uiTotalCnt].hash = (unsigned)(-1);
   m_uiTotalCnt++;
}

void CSlotLookupTable::SortAndAssignSlots(void)
{
   unsigned i;

   // First, sort by hash.
   //
   qsort(m_pSLT, m_uiTotalCnt, sizeof(struct _slt), ltqs_callback);
   //
   // Next, run through the table and assign the slots back to the CFolders.
   //
   for (i = 0; i < m_uiTotalCnt; i++)
      m_pSLT[i].pCFolder->dwSlot = i;
}

CFolder* CSlotLookupTable::HashToCFolder(HASH hash)
{
   if (! m_pSLT )
      return NULL;

   int mid,low = 0;
   int high = m_uiHashCnt - 1;

   while ( low <= high )
   {
      mid = ((low + high) / 2);
      if ( m_pSLT[mid].hash == hash )
         return m_pSLT[mid].pCFolder;                // Found it!
      else if ( m_pSLT[mid].hash > hash )
         high = mid - 1;
      else
         low = mid + 1;
   }
   return NULL;   // Oh bad!
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\contain.h ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CONTAIN_H_
#define _CONTAIN_H_

#include <servprov.h>
#include <docobj.h>

#ifndef INITGUIDS
#include <olectl.h>
#endif

#include "web.h"
#include "mshtmhst.h"

extern IServiceProvider *g_pExternalHostServiceProvider; 

typedef class CIPropertyNotifySink *PIPROPERTYNOTIFYSINK;
typedef class CIOleControlSite *PIOLECONTROLSITE;

class CAutomateContent;

class CDocHostUIHandler : public IDocHostUIHandler
{
private:
   ULONG m_cRef;

public:
   IUnknown * m_pOuter;

   CDocHostUIHandler(IUnknown * pOuter);
   STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);
   STDMETHODIMP ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
   STDMETHODIMP GetHostInfo(DOCHOSTUIINFO *pInfo);
   STDMETHODIMP ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget,
                     IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc);
   STDMETHODIMP HideUI(void);
   STDMETHODIMP UpdateUI(void);
   STDMETHODIMP EnableModeless(BOOL fEnable);
   STDMETHODIMP OnDocWindowActivate(BOOL fActivate);
   STDMETHODIMP OnFrameWindowActivate(BOOL fActivate);
   STDMETHODIMP ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
   STDMETHODIMP TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
   STDMETHODIMP GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw);
   STDMETHODIMP GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
   STDMETHODIMP GetExternal(IDispatch **ppDispatch);
   STDMETHODIMP TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
   STDMETHODIMP FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);
};

class CDocHostShowUI : public IDocHostShowUI
{
private:
   ULONG m_cRef;

public:
   IUnknown * m_pOuter;

   CDocHostShowUI(IUnknown * pOuter);
   STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   STDMETHODIMP ShowHelp( HWND hwnd, LPOLESTR pszHelpFile, UINT uCommand, DWORD dwData, POINT ptMouse, IDispatch* pDispatchObjectHit );
   STDMETHODIMP ShowMessage( HWND hwnd, LPOLESTR lpstrText, LPOLESTR lpstrCaption, DWORD dwType, LPOLESTR lpstrHelpFile, DWORD dwHelpContext, LRESULT* plResult );
};


class CIOleItemContainer : public IOleItemContainer
{
private:
   ULONG m_cRef;

public:
   IUnknown * m_pOuter;
   CIOleItemContainer(IUnknown *);

   STDMETHODIMP QueryInterface(REFIID, LPVOID *);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   STDMETHODIMP ParseDisplayName(IBindCtx*,LPOLESTR,ULONG*,IMoniker**);

   STDMETHODIMP EnumObjects(DWORD,LPENUMUNKNOWN*);
   STDMETHODIMP LockContainer(BOOL);

   STDMETHODIMP GetObject(LPOLESTR,DWORD,IBindCtx*,REFIID,void**);
   STDMETHODIMP GetObjectStorage(LPOLESTR,IBindCtx*,REFIID,void**);
   STDMETHODIMP IsRunning(LPOLESTR);
};

class CIOleClientSite : public IOleClientSite
{
protected:
   ULONG          m_cRef;
   class CContainer    *m_pContainer;
   LPUNKNOWN         m_pUnkOuter;

public:
   CIOleClientSite(class CContainer *);
   ~CIOleClientSite(void);

   STDMETHODIMP QueryInterface(REFIID, LPVOID *);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   STDMETHODIMP SaveObject(void);
   STDMETHODIMP GetMoniker(DWORD, DWORD, LPMONIKER *);
   STDMETHODIMP GetContainer(LPOLECONTAINER *);
   STDMETHODIMP ShowObject(void);
   STDMETHODIMP OnShowWindow(BOOL);
   STDMETHODIMP RequestNewObjectLayout(void);
};

typedef CIOleClientSite *PIOLECLIENTSITE;

class CIAdviseSink : public IAdviseSink2
{
protected:
   ULONG          m_cRef;
   class CContainer  *m_pContainer;
   LPUNKNOWN         m_pUnkOuter;

public:
   CIAdviseSink(class CContainer *);
   ~CIAdviseSink(void);

   STDMETHODIMP QueryInterface(REFIID, LPVOID *);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   STDMETHODIMP_(void)  OnDataChange(LPFORMATETC, LPSTGMEDIUM);
   STDMETHODIMP_(void)  OnViewChange(DWORD, LONG);
   STDMETHODIMP_(void)  OnRename(LPMONIKER);
   STDMETHODIMP_(void)  OnSave(void);
   STDMETHODIMP_(void)  OnClose(void);
   STDMETHODIMP_(void)  OnLinkSrcChange(LPMONIKER);
};


typedef CIAdviseSink *PIADVISESINK;


class CIOleInPlaceSite : public IOleInPlaceSite
{
protected:
   ULONG          m_cRef;
   class CContainer   *m_pContainer;

public:
   LPUNKNOWN         m_pUnkOuter;

   CIOleInPlaceSite(class CContainer *);
   ~CIOleInPlaceSite(void);

   STDMETHODIMP QueryInterface(REFIID, LPVOID *);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   STDMETHODIMP GetWindow(HWND *);
   STDMETHODIMP ContextSensitiveHelp(BOOL);
   STDMETHODIMP CanInPlaceActivate(void);
   STDMETHODIMP OnInPlaceActivate(void);
   STDMETHODIMP OnUIActivate(void);
   STDMETHODIMP GetWindowContext(LPOLEINPLACEFRAME *
               , LPOLEINPLACEUIWINDOW *, LPRECT, LPRECT
               , LPOLEINPLACEFRAMEINFO);
   STDMETHODIMP Scroll(SIZE);
   STDMETHODIMP OnUIDeactivate(BOOL);
   STDMETHODIMP OnInPlaceDeactivate(void);
   STDMETHODIMP DiscardUndoState(void);
   STDMETHODIMP DeactivateAndUndo(void);
   STDMETHODIMP OnPosRectChange(LPCRECT);
};

typedef CIOleInPlaceSite *PIOLEINPLACESITE;


class CIOleInPlaceFrame : public IOleInPlaceFrame
{
protected:
   ULONG          m_cRef;
   class CContainer  *m_pContainer;

public:
   LPUNKNOWN         m_pUnkOuter;

   CIOleInPlaceFrame(class CContainer *);
   ~CIOleInPlaceFrame(void);

   STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
   STDMETHODIMP_(ULONG) AddRef ();
   STDMETHODIMP_(ULONG) Release ();

   STDMETHODIMP GetWindow (HWND FAR* lphwnd);
   STDMETHODIMP ContextSensitiveHelp (BOOL fEnterMode);

   // *** IOleInPlaceUIWindow methods ***
   STDMETHODIMP GetBorder (LPRECT lprectBorder);
   STDMETHODIMP RequestBorderSpace (LPCBORDERWIDTHS lpborderwidths);
   STDMETHODIMP SetBorderSpace (LPCBORDERWIDTHS lpborderwidths);
   //@@WTK WIN32, UNICODE
   //STDMETHODIMP SetActiveObject (LPOLEINPLACEACTIVEOBJECT lpActiveObject,LPCSTR lpszObjName);
   STDMETHODIMP SetActiveObject (LPOLEINPLACEACTIVEOBJECT lpActiveObject,LPCOLESTR lpszObjName);

   // *** IOleInPlaceFrame methods ***
   STDMETHODIMP InsertMenus (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
   STDMETHODIMP SetMenu (HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
   STDMETHODIMP RemoveMenus (HMENU hmenuShared);
   //@@WTK WIN32, UNICODE
   //STDMETHODIMP SetStatusText (LPCSTR lpszStatusText);
   STDMETHODIMP SetStatusText (LPCOLESTR lpszStatusText);
   STDMETHODIMP EnableModeless (BOOL fEnable);
   STDMETHODIMP TranslateAccelerator (LPMSG lpmsg, WORD wID);
};

class CIOleControlSite : public IOleControlSite
{
protected:
   ULONG          m_cRef;
   class CContainer* m_pContainer;
   LPUNKNOWN         m_pUnkOuter;

public:
   CIOleControlSite(class CContainer *);
   ~CIOleControlSite(void);

   STDMETHODIMP QueryInterface(REFIID, LPVOID *);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   STDMETHODIMP OnControlInfoChanged(void);
   STDMETHODIMP LockInPlaceActive(BOOL);
   STDMETHODIMP GetExtendedControl(LPDISPATCH *);
   STDMETHODIMP TransformCoords(POINTL *, POINTF *, DWORD);
   STDMETHODIMP TranslateAccelerator(LPMSG, DWORD);
   STDMETHODIMP OnFocus(BOOL);
   STDMETHODIMP ShowPropertyFrame(void);
};

typedef CIOleInPlaceFrame *PIOLEINPLACEFRAME;

/***************************************************************************/

class CContainer : public IServiceProvider
{
   friend CIOleClientSite;
   friend CIAdviseSink;
   friend CIOleInPlaceSite;
   friend CIOleInPlaceFrame;

   //CONTROLMOD
   // friend CIOleControlSite;
   // friend CIPropertyNotifySink;
   //End CONTROLMOD

public:
   BOOL              m_OleInited;
   ULONG             m_cRef;
   IStorage*            m_pIStorage;
   LPOLEOBJECT          m_pOleObject;
   HWND m_hWnd;
   BOOL                 m_bIE4;

   //Our interfaces
   PIADVISESINK         m_pIAdviseSink;
   PIOLEINPLACESITE     m_pIOleInPlaceSite;
   PIOLECLIENTSITE      m_pIOleClientSite;
   PIOLEINPLACEFRAME    m_pIOleInPlaceFrame;
   CIOleItemContainer * m_pIOleItemContainer;
   CAutomateContent *      m_pIDispatch;
   PIOLECONTROLSITE     m_pIOleControlSite;
   // CHtmlHelpCallback *  m_pCallback;
   IDocHostUIHandler*   m_pCDocHostUIHandler;
   IDocHostShowUI*      m_pCDocHostShowUI;
   IOleInPlaceActiveObject   *m_pInPlaceActive;
   DWORD             m_dwEventCookie;

public:
   CContainer();
   ~CContainer(void);

   HRESULT ShutDown(void);

   class IWebBrowserImpl*      m_pWebBrowser;
   class IWebBrowserAppImpl*   m_pWebBrowserApp;
   class DWebBrowserEventsImpl* m_pWebBrowserEvents;
   LPOLECOMMANDTARGET       m_pIE3CmdTarget;
   void     UIDeactivateIE();
   HRESULT  Create(HWND hWnd, LPRECT lpRect, BOOL bInstallEventSink = TRUE);
   void     SetFocus(BOOL bForceActivation = FALSE);
   void     SizeIt(int width, int height);
   LRESULT  ForwardMessage(UINT msg, WPARAM wParam, LPARAM lParam);
   unsigned TranslateMessage(MSG * pMsg);
   BOOL     IsUIActive(void) { return m_pInPlaceActive != NULL; }
   HWND  m_hwndChild;

   // IUnknown
   //
   STDMETHODIMP QueryInterface(REFIID, LPVOID *);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   // IServiceProvider

   STDMETHOD(QueryService)(REFGUID, REFIID, LPVOID *);

#ifdef _DEBUG
   BOOL m_fDeleting;
#endif
};


typedef CContainer *PCONTAINER;

#if 0

class CIPropertyNotifySink : public IPropertyNotifySink
{
protected:
   ULONG       m_cRef;
   class CContainer  *m_pContainer;
   LPUNKNOWN      m_pUnkOuter;

public:
   CIPropertyNotifySink(class CContainer *, LPUNKNOWN);
   ~CIPropertyNotifySink(void);

   STDMETHODIMP QueryInterface(REFIID, LPVOID *);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   STDMETHODIMP OnChanged(DISPID);
   STDMETHODIMP OnRequestEdit(DISPID);
};

#endif

#endif //_CONTAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\collect.h ===
//*********************************************************************************************************************************************
//
//      File: collect.h
//  Author: Donald Drake
//  Purpose: Defines classes to support titles, collections, locations and folders

#ifndef _COLLECT_H
#define _COLLECT_H

#undef CLASS_IMPORT_EXPORT
#ifdef HHCTRL // define this only when building the HHCtrl DLL
  #define CLASS_IMPORT_EXPORT /**/
#else
 #ifdef HHSETUP // define this only when building the HHSetup DLL
  #define CLASS_IMPORT_EXPORT __declspec( dllexport )
 #else
  #define CLASS_IMPORT_EXPORT __declspec( dllimport )
 #endif
#endif

#ifndef HHCTRL

#undef COUNT
#define COUNT(x)

#undef MI_COUNT
#define MI_COUNT(x)

#undef SI_COUNT
#define SI_COUNT(x)

#undef MI2_COUNT
#define MI2_COUNT(x)

#undef AUTO_CLASS_COUNT_CHECK
#define AUTO_CLASS_COUNT_CHECK(x)

#undef CHECK_CLASS_COUNT
#define CHECK_CLASS_COUNT(x)

#undef DUMP_CLASS_COUNT
#define DUMP_CLASS_COUNT(x)

#endif

#ifdef HHCTRL
#include "parserhh.h"
#else
#include "parser.h"
#endif

#define  F_MSDN         0x0001
#define  F_TITLELOCAL   0x0002
#define  F_INDEXLOCAL   0x0004
#define  STARTINGCOLNO 10000

#define ENGLANGID 1033

#define MAX_LEVELS 100

typedef struct LocationHistory {
   CHAR * SampleLocation;
   CHAR * FileName;
   CHAR * IndexFileName;
   CHAR * QueryFileName;
   CHAR * LocationId;
   DWORD CollectionNumber;
   DWORD Version;
   DWORD LastPromptedVersion;
   BOOL bSupportsMerge;
   LocationHistory *pNext;
   CHAR * QueryLocation;
} LOCATIONHISTORY;

DWORD CLASS_IMPORT_EXPORT AllocSetValue(const CHAR *value, CHAR **dest);

// forward declarations
class CLocation;
class CTitle;
class CCollection;
class CFolder;
class CSlotLookupTable;
class CExTitle;
class CColList;

typedef struct ListItem {
   void *pItem;
   ListItem *Next;
} LISTITEM;

class CLASS_IMPORT_EXPORT CPointerList {
private:
   LISTITEM *m_pHead;

public:
   CPointerList()
   {
      m_pHead = NULL;
   }

   ~CPointerList();
   void RemoveAll();
   LISTITEM *Add(void *);
   LISTITEM *First();
   LISTITEM *Next(LISTITEM *p) { return p->Next; }
};

#ifdef HHCTRL // define this only when building the HHCtrl DLL

//
// <mc>
// This lookup table will facilitate a quick translation of a "slot" number into a CFolder* as well as a
// HASH value into a CFolder*. This will be done using two DWORDS per CFolder object, one for the HASH value
// and one for the CFolder*. After ALL the CFolders for a given collection have been created and this lookup
// table is fully populated the SortAndAssignSlots() member will be called. This will sort the table by HASH
// value and will assign the slot values back to the CFolders according to the sorted order. This will make
// slot --> CFolder* lookup a simple array index and will also allow us to use a bsearch for the
// HASH --> CFolder* lookup. Note that only leaf level CFolders have useful hash values, for the non leaf
// CFolders we will assign a hash of -1, these items in the table will then appear at the end of the table
// and will not interfear with a bsearch operation when translating a hash into a pSLT.
// </mc>
//
class CSlotLookupTable
{
public:
   CSlotLookupTable();
   ~CSlotLookupTable();

   static int FASTCALL ltqs_callback(const void *elem1, const void *elem2);
   void AddValue(CFolder* pFolder);
   void SortAndAssignSlots(void);
   CFolder* HashToCFolder(HASH hash);

   CFolder* SlotToCFolder(DWORD dwSlot)
   {
      if ( dwSlot > 0 && dwSlot <= m_uiTotalCnt )        // Slot 0 reserved for error case.
         return m_pSLT[dwSlot].pCFolder;
      else
         return NULL;
   }

private:
   struct _slt
   {
      HASH  hash;
      CFolder* pCFolder;
   };

   struct _slt*  m_pSLT;
   unsigned  m_uiTotalAllocated;
   unsigned  m_uiTotalCnt;
   unsigned  m_uiHashCnt;
};

#endif

class CLASS_IMPORT_EXPORT CFolder SI_COUNT(CFolder)
{
private:
   CHAR *Title;                           // name of the folder
   WCHAR *pwcTitle;
   DWORD Order;
   LANGID LangId;
   DWORD dwSlot;
   CExTitle* pExTitle;
   CFolder *pNext, *pKid, *pParent;
   //
   // This DWORD value is being added to support .CHM level subsetting.
   //
   WORD                     iLevel;
   WORD                     f_Filter:    1;  // render into filter LB.
   WORD                     f_Available: 1;  // render into Available LB.
   WORD                     f_F_Open:    1;  // Expanded or closed ?
   WORD                     f_A_Open:    1;  // Expanded or closed ?
   WORD                     f_HasHash:   1;  // Does Node have a prefix hash ?
   WORD                     f_IsOrphan:  1;  // Is this node an orphane ?
   WORD                     f_IsVisable: 1;  // Indicates membership in the currently selected TOC subset.

public:
   CFolder();
   ~CFolder();
   BOOL bIsVisable() { return (BOOL)f_IsVisable; }
   void SetTitle(const  CHAR *);
   void SetTitle(const  WCHAR *);
   void SetExTitlePtr(CExTitle* pTitle);
   CHAR *GetTitle() {  return Title; }
   const WCHAR *GetTitleW();
   void SetLanguage(LANGID Id) { LangId = Id; }
   LANGID GetLanguage() { return LangId; }
   void SetOrder(DWORD);
   DWORD GetOrder();
   // Returns the next sibling folder given a folder entry
   CFolder * GetNextFolder();
   void SetNextFolder(CFolder *p) { pNext = p; }
   // Returns the first child of a given folder if it exists
   CFolder * GetFirstChildFolder();
   void SetFirstChildFolder(CFolder *p) { pKid = p; }
   // Add a new folder as child of a given folder
   CFolder * AddChildFolder(const CHAR *szName, DWORD Order, DWORD *pError, LANGID LangId = ENGLANGID);
   CFolder * AddChildFolder(const WCHAR *szName, DWORD Order, DWORD *pError, LANGID LangId = ENGLANGID);
   DWORD AddChildFolder(CFolder *newFolder);
   void SetParent(CFolder *p) { pParent = p; }
   CFolder * GetParent() { return pParent; }

friend class CSlotLookupTable;
friend class CDefineSS;
friend class CStructuralSubset;

};


class CLASS_IMPORT_EXPORT CCollection SI_COUNT(CCollection)
{
public:
   CCollection();
   ~CCollection();
   void ConfirmTitles() { m_bConfirmTitles = TRUE; }
   void SetSampleLocation(const CHAR *);
   CHAR *GetSampleLocation();
   void SetMasterCHM(const CHAR *szName, LANGID Lang);
   BOOL GetMasterCHM(CHAR ** szName, LANGID *Lang);
   // Opens and loads the contents of the file into data structures
   DWORD Open(const CHAR * FileName);
   void SetSampleLocation(const WCHAR *);
   void SetFindMergedCHMS(BOOL bFind) { m_bFindMergedChms = bFind; }
   BOOL GetFindMergedCHMS() { return m_bFindMergedChms; }
   const WCHAR *GetSampleLocationW();
   void SetMasterCHM(const WCHAR *szName, LANGID Lang);
   BOOL GetMasterCHM(WCHAR ** szName, LANGID *Lang);
   // Opens and loads the contents of the file into data structures
   DWORD Open(const WCHAR * FileName);
   // Saves any changes made to the internal data structures to the file.
   DWORD Save();
   DWORD Close();

   void AddRef() { m_dwRef++; }

   DWORD GetVersion() { return m_dwVersion; }
   void SetVersion(DWORD dw) { m_dwVersion = dw; }
   // navigating the collection
   // Returns the first folder in the collection
   CFolder * GetRootFolder() { return m_pRootFolder; }
   CFolder * GetVisableRootFolder() { return m_pRootFolder->GetFirstChildFolder(); } // Returns the visable root.
   // Returns the first title
   CTitle * GetFirstTitle();
   // Locates a title based on id
   CTitle * FindTitle(const CHAR * Id, LANGID LangId = ENGLANGID);
   CTitle * FindTitle(const WCHAR * Id, LANGID LangId = ENGLANGID);
    // Try multiple LangIds, before failing.
#ifdef HHCTRL
    CTitle * FindTitleNonExact(const CHAR * Id, LANGID LangId) ;
#endif // #ifdef HHCTRL


   // Returns the first location
   CLocation* FirstLocation();
   // Finds a location based on a name
   CLocation * FindLocation(const CHAR * Name, UINT* puiVolumeOrder = NULL );

   // collection entry management
   CColList * FindCollection(CHAR *szFileName);
   CColList * AddCollection();
   void RemoveCollectionEntry(CHAR *szFileName);

   //Adds a new folder to the top level of the table of contents, with the given name and order and returns a pointer to that folder object.  A return of NULL indicates a failure and pDWORD will be populated with one of  above DWORD codes.
   CFolder * AddFolder(const CHAR * szName, DWORD Order, DWORD *pDWORD, LANGID LangId = ENGLANGID);

   DWORD DeleteFolder(CFolder *);
   //Adds a title based on the provided information.
   //A return of NULL indicates a failure and pDWORD will be
   //populated with one of  above DWORD codes.  Note: you must add or
   //find a CLocation object or pass null to indication no location is in
   // use (local file).
   CTitle * AddTitle(const CHAR * Id, const CHAR * FileName, const CHAR * IndexFile,
              const CHAR * Query, const CHAR *SampleLocation, LANGID Lang,
              UINT uiFlags, CLocation *pLocation,  DWORD *pDWORD,
              BOOL bSupportsMerge = FALSE, const CHAR *QueryLocation = NULL);


   // Adds location based on the given information. A return of NULL indicates a failure and pDWORD will be populated with one of  above DWORD codes.
   CLocation * AddLocation(const CHAR * Title, const CHAR * Path, const CHAR * Id, const CHAR * Volume, DWORD *pDWORD);

   CLocation * FindLocation(const WCHAR * Name, UINT* puiVolumeOrder = NULL );
   CFolder * AddFolder(const WCHAR * szName, DWORD Order, DWORD *pDWORD, LANGID LangId = ENGLANGID);
   CTitle * AddTitle(const WCHAR * Id, const WCHAR * FileName,
              const WCHAR * IndexFile, const WCHAR * Query,
              const WCHAR *SampleLocation, LANGID Lang, UINT uiFlags,
              CLocation *pLocation,  DWORD *pDWORD,
              BOOL bSupportsMerge = FALSE, const WCHAR *QueryLocation = NULL);
   CLocation * AddLocation(const WCHAR * Title, const WCHAR * Path, const WCHAR * Id, const WCHAR * Volume, DWORD *pDWORD);

   DWORD RemoveCollection(BOOL bRemoveLocalFiles = FALSE);

   DWORD GetRefTitleCount() { return m_dwTitleRefCount; }
   // Merges the currently installed titles for the collection into the specified filename (path determined internally)
   BOOL MergeKeywords(CHAR * pwzFilename );
   BOOL MergeKeywords(WCHAR * pwzFilename );
   DWORD GetColNo() { return m_dwColNo; }
   PCSTR GetCollectionFileName(void) { return m_szFileName; }
   const WCHAR *GetCollectionFileNameW(void);
   BOOL IsDirty() { return m_bDirty;}
   void IncrementRefTitleCount() { m_dwTitleRefCount++; }
   void DecrementRefTitleCount() { m_dwTitleRefCount--; }
   void Dirty() { m_bDirty = TRUE; }

   LANGID GetLangId(const CHAR *FileName);
   LANGID GetLangId(const WCHAR *FileName);
private:  // functions

   DWORD AddRefedTitle(CFolder *pFolder);
   // removing objects
   DWORD DeleteTitle(CTitle *);
   void DeleteLocalFiles(LOCATIONHISTORY *pHist, CTitle *pTitle);
   DWORD DeleteLocation(CLocation *);

   DWORD CheckTitleRef(const CHAR *pId, const LANGID Lang);
   DWORD CheckTitleRef(const WCHAR *pId, const LANGID Lang);
   DWORD ParseFile(const CHAR *FileName);
   DWORD HandleCollection(CParseXML *parser, CHAR *sz);
   DWORD HandleCollectionEntry(CParseXML *parser, CHAR *sz);
   DWORD HandleFolder(CParseXML *parser, CHAR *token);
   DWORD HandleLocation(CParseXML *parser, CHAR *token);
   DWORD HandleTitle(CParseXML *parser, CHAR *token);
   void DeleteChildren(CFolder **p);
   void DeleteFolders(CFolder **p);
   BOOL WriteFolders(CFolder **p);
   BOOL WriteFolder(CFolder **p);
   DWORD AllocCopyValue(CParseXML *parser, CHAR *token, CHAR **dest);
   CTitle *NewTitle();
   CLocation *NewLocation();

private:
   BOOL m_bRemoveLocalFiles;
   BOOL m_bRemoved;
   DWORD Release();
   CHAR * m_szFileName;
   WCHAR * m_pwcFileName;
   CHAR * m_szMasterCHM;
   WCHAR * m_pwcMasterCHM;
   CHAR * m_szSampleLocation;
   WCHAR * m_pwcSampleLocation;
   LANGID m_MasterLangId;
   CTitle * m_pFirstTitle;
   CTitle * m_pTitleTail;
   CLocation * m_pFirstLocation;
   CLocation * m_pLocationTail;
   CFolder *m_pRootFolder;
   DWORD m_locationnum;
   CFIFOString m_Strings;
   CFolder *m_pParents[MAX_LEVELS];
   DWORD m_dwCurLevel;
   DWORD m_dwLastLevel;
   DWORD m_dwNextColNo;
   DWORD m_dwColNo;
   DWORD m_dwTitleRefCount;
   BOOL m_bConfirmTitles;
   BOOL m_bFindMergedChms;
   DWORD m_dwRef;
   DWORD m_dwVersion;
   HANDLE m_fh;
   BOOL m_bDirty;
   CColList *m_pColListHead;
   CColList *m_pColListTail;
public:
   CPointerList  m_RefTitles;
   BOOL m_bFailNoFile;
   BOOL m_bAllFilesDeleted;
};

class CColList
{
private:
	DWORD m_dwColNo;
	CHAR * m_szFileName;
	CColList *m_pNext;
public:
	CColList();
	~CColList();
	void SetColNo(DWORD dw) { m_dwColNo = dw; }
	void SetFileName(CHAR *szFileName);
	DWORD GetColNo() { return m_dwColNo; }
	CHAR *GetFileName() { return m_szFileName; }
	CColList *GetNext() { return m_pNext; }
	void SetNext(CColList *p) { m_pNext = p; }
};

class CLASS_IMPORT_EXPORT CTitle SI_COUNT(CTitle)
{
private:
   CHAR * Id;                      // Title identifier
   WCHAR *pwcId;
   LANGID  Language;               // language identifier
   CTitle *NextTitle;              // pointer to the next title
public:
   LOCATIONHISTORY *m_pHead, *m_pTail;
   void SetId(const CHAR *);
   void SetId(const WCHAR *);
   void SetLanguage(LANGID);
   CHAR * GetId();
   const WCHAR * GetIdW();
   LANGID GetLanguage();
   LOCATIONHISTORY *GetLocation(DWORD Index);
   CTitle* GetNextTitle();
   ~CTitle();
   CTitle();
   LOCATIONHISTORY *NewLocationHistory();
   DWORD AddLocationHistory(DWORD ColNo, const CHAR *FileName, const CHAR *IndexFile, const CHAR *Query, const CLocation *pLocation, const CHAR *Sample, const CHAR *QueryLocation, BOOL bSupportsMerge);
   DWORD AddLocationHistory(DWORD ColNo, const WCHAR *FileName, const WCHAR *IndexFile, const WCHAR *Query, const CLocation *pLocation, const WCHAR *Sample, const WCHAR *QueryLocation, BOOL bSupportsMerge);
   void SetNextTitle(CTitle *p) { NextTitle = p; }
};

class CLASS_IMPORT_EXPORT CLocation SI_COUNT(CLocation)
{
private:
   CHAR * Id;
   CHAR * Title;                          // Friendly name for the title
   CHAR * Path;                           // location of the device
   CHAR * Volume;
   WCHAR * pwcId;
   WCHAR * pwcTitle;                          // Friendly name for the title
   WCHAR * pwcPath;                           // location of the device
   WCHAR * pwcVolume;
   CLocation *NextLocation;        // pointer to the next location if it exists
public:
   DWORD m_ColNum;
   CLocation()
   {
      Id = NULL;
      Title = NULL;
      Path = NULL;
      Volume = NULL;
      NextLocation = NULL;
        pwcId = NULL;
        pwcTitle = NULL;
        pwcPath = NULL;
        pwcVolume = NULL;
    }

   ~CLocation()
   {
      if (Id)
         delete Id;
      if (Title)
         delete Title;
      if (Path)
         delete Path;
      if (Volume)
         delete Volume;
      if (pwcId)
         delete pwcId;
      if (pwcTitle)
         delete pwcTitle;
      if (pwcPath)
         delete pwcPath;
      if (pwcVolume)
         delete pwcVolume;
   }

   void SetNextLocation(CLocation *p) { NextLocation = p; }
   void SetId(const CHAR *);
   void SetTitle(const CHAR *);
   void SetPath(const CHAR *);
   void SetVolume(const CHAR *);
   CHAR * GetId() const;
   CHAR * GetTitle();
   CHAR * GetPath();
   CHAR * GetVolume();
   void SetId(const WCHAR *);
   void SetTitle(const WCHAR *);
   void SetPath(const WCHAR *);
   void SetVolume(const WCHAR *);
   const WCHAR * GetIdW();
   const WCHAR * GetTitleW();
   const WCHAR * GetPathW();
   const WCHAR * GetVolumeW();

   // Returns the next location
   CLocation *GetNextLocation();
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\contents.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "strtable.h"
#include "hha_strtable.h"
#include "hhctrl.h"
#include "resource.h"
#include <intshcut.h>
#include "htmlhelp.h"
#include "secwin.h"
#include "cpaldc.h"
#include "cprint.h"
#include <wininet.h>
#include "contain.h"
#include "cdefinss.h"
#include "cctlww.h"

// Forward Declarations

LRESULT WINAPI TreeViewProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
void      LoadFirstLevel   (CTreeNode *pRoot, HWND hwndTreeView, HTREEITEM * m_tiFirstVisible );
HTREEITEM AddTitleChildren (CTreeNode *pNode, HTREEITEM hParent, HWND hwndTreeView);
HTREEITEM AddNode          (CTreeNode *pNode, HTREEITEM hParent, HWND hwndTreeView);
BOOL      HandleExpanding  (TVITEMW* pTvi, HWND hwndTreeView, UINT action, BOOL *pSync);
void AddChildren    (TVITEMW* pTvi, HWND hwndTreeView);
void DeleteChildren (TVITEMW* pTvi, HWND hwndTreeView);
void FreeChildrenAllocations (HWND hwndTreeView, HTREEITEM ti);

UINT cpTemp = CP_ACP;

WNDPROC lpfnlTreeViewWndProc = NULL;     // Initialize.

    // Constants
const int SITEMAP_MAX_LEVELS = 50;       // maximum nested folders

CToc::CToc(CHtmlHelpControl* phhctrl, IUnknown* pUnkOuter, CHHWinType* phh)
{
    m_phhctrl = phhctrl;
    m_pOuter = pUnkOuter;
    m_phh = phh;
    m_hwndTree = NULL;
    m_cntCurHighlight = m_cntFirstVisible = 0;
    m_fSuppressJump = FALSE;
    m_fIgnoreNextSelChange = FALSE;
    m_fHack = FALSE;
    m_exStyles = 0;
    m_dwStyles = 0;
    m_padding = 0;          // padding to put around the TOC
    if (phh)
        m_NavTabPos = phh->tabpos;
    else
        m_NavTabPos = HHWIN_NAVTAB_TOP ;;
    m_fSuspendSync = FALSE;
    m_hbmpBackGround = NULL;
    m_hbrBackGround = NULL;
    m_cFonts = 0;
    m_fGlobal = FALSE;
    m_tiFirstVisible = NULL;
    m_pInfoType = NULL;
    m_pBinTOCRoot = NULL;
    m_fBinaryTOC = NULL;
    m_fSyncOnActivation = FALSE;
    m_phTreeItem = NULL ;
    m_hil = NULL;
}

CToc::~CToc()
{
#if 1
   if ( m_pInfoType )
      delete m_pInfoType;
#endif
   
   if (m_fBinaryTOC)
   {
      // clean up memory for binary tree
      // get the root item
      TV_ITEMW hCur;
      HTREEITEM hNext;

      CTreeNode *pCurNode;
      hCur.hItem = W_TreeView_GetRoot(m_hwndTree);
      
      // this loop will iterate through the top level nodes
      // 
      while(hCur.hItem)
      {
         FreeChildrenAllocations(m_hwndTree, hCur.hItem);

         // get the next sibling (if any)
         //
         hNext = TreeView_GetNextSibling(m_hwndTree, hCur.hItem);

         // free this nodes item data
         //
         hCur.mask = TVIF_PARAM;
         if (W_TreeView_GetItem(m_hwndTree, &hCur) == TRUE)
         {
            if (hCur.lParam)
            {
               // delete the node from the treeview
               //
               W_TreeView_DeleteItem(m_hwndTree, hCur.hItem);

               // free the node's data
               //
               pCurNode = (CTreeNode *)hCur.lParam;
               delete pCurNode;
            }
         }
         
         // on to the next top level node
         //
         hCur.hItem = hNext;
      }
   }

   // free the node
   if (m_pBinTOCRoot)
      delete m_pBinTOCRoot;

   if (IsValidWindow(m_hwndTree))
   {
     DestroyWindow(m_hwndTree);
     // Destroying the TreeView control, make sure we no longer point to it as a valid
     // subclassed window.
     if (NULL != lpfnlTreeViewWndProc)
     {
       lpfnlTreeViewWndProc = NULL;
     }
   }

   if (m_hbrBackGround)
      DeleteObject(m_hbrBackGround);
   if (m_cFonts) {
      for (int i = 0; i < m_cFonts; i++)
         DeleteObject(m_ahfonts[i]);
      lcFree(m_ahfonts);
   }
   if (m_hbmpBackGround)
      DeleteObject(m_hbmpBackGround);
   if (m_hil)
   {
      ImageList_Destroy(m_hil);
      m_hil = NULL;
   }
   if ( m_phTreeItem )
      lcFree(m_phTreeItem);
}

BOOL CToc::ReadFile(PCSTR pszFile)
{
    if (m_phh && m_phh->m_phmData && m_phh->m_phmData->m_pTitleCollection &&
            HashFromSz(FindFilePortion(pszFile)) == m_phh->m_phmData->m_hashBinaryTocName) {
        m_pBinTOCRoot = m_phh->m_phmData->m_pTitleCollection->GetRootNode();
        m_fBinaryTOC = (m_pBinTOCRoot && m_phh->m_phmData->m_pTitleCollection->GetFirstTitle() != NULL) ? TRUE : FALSE;
        if (!m_fBinaryTOC) {
            delete m_pBinTOCRoot;
            m_pBinTOCRoot = NULL;
        }
        else
            return TRUE;
    }
    UINT CodePage = -1;
    if( m_phh && m_phh->m_phmData ) {
      CodePage = m_phh->m_phmData->GetInfo()->GetCodePage();
    }
    return m_sitemap.ReadFromFile(pszFile, FALSE, NULL, CodePage);
}

BOOL CToc::Create(HWND hwndParent)
{
    RECT rcParent;
    GetParentSize(&rcParent, hwndParent, m_padding, m_NavTabPos);

    DWORD dwTempStyle = 0;

//   Disable tooltips for bi-di due to common control bug
//
//   if(g_RTL_Mirror_Style)
//        dwTempStyle = TVS_NOTOOLTIPS;

   if(g_RTL_Style && !g_RTL_Mirror_Style)
       dwTempStyle |= TVS_RTLREADING;
   m_hwndTree = W_CreateControlWindow(
        m_exStyles | g_RTL_Mirror_Style,
        WS_CHILD | m_dwStyles | dwTempStyle,
        W_TreeView, L"",
        rcParent.left, rcParent.top, RECT_WIDTH(rcParent), RECT_HEIGHT(rcParent),
        hwndParent, NULL, _Module.GetModuleInstance(), NULL);
    return m_hwndTree != NULL; // REVIEW: notify here if failure?
}

void CToc::ResizeWindow()
{
    ASSERT(::IsValidWindow(m_hwndTree)) ;

    // Resize to fit the client area of the parent.
    HWND hwndParent = GetParent(m_hwndTree) ;
    ASSERT(::IsValidWindow(hwndParent)) ;

    RECT rcParent;
    GetParentSize(&rcParent, hwndParent, m_padding, m_NavTabPos);

    MoveWindow(m_hwndTree, rcParent.left,
        rcParent.top, RECT_WIDTH(rcParent), RECT_HEIGHT(rcParent), TRUE);
}

void CToc::HideWindow(void)
{
    ASSERT(::IsValidWindow(m_hwndTree)) ;
    ::ShowWindow(m_hwndTree, SW_HIDE);
}

void CToc::ShowWindow(void)
{
    ASSERT(::IsValidWindow(m_hwndTree)) ;
    ::ShowWindow(m_hwndTree, SW_SHOW);
    SetFocus(m_hwndTree);
}

/***************************************************************************

    FUNCTION:       LoadContentsFile

    PURPOSE:        Load the Contents file, convert it into g_pbTree

    PARAMETERS:
        pszMasterFile

    RETURNS:
        TRUE if successfully loaded

    COMMENTS:
        Assumes we are being run from a thread without a message queue.

    MODIFICATION DATES:
        09-Jul-1997 [ralphw]

***************************************************************************/

BOOL CHtmlHelpControl::LoadContentsFile(PCSTR pszMasterFile)
{
    TCHAR szPath[MAX_PATH];
    if (!ConvertToCacheFile(pszMasterFile, szPath)) {
        szPath[0] = '\0';
        if (!IsCompiledHtmlFile(pszMasterFile) && m_pWebBrowserApp) {
            CStr cszCurUrl;
            m_pWebBrowserApp->GetLocationURL(&cszCurUrl);
            cszCurUrl.ReSize(cszCurUrl.SizeAlloc() + (int)strlen(pszMasterFile));
            PSTR pszChmSep = strstr(cszCurUrl, txtDoubleColonSep);
            if (pszChmSep) {    // this is a compiled HTML file
                strcpy(pszChmSep + 2, pszMasterFile);
                strcpy(szPath, cszCurUrl);
            }
        }
        if (!szPath[0]) {
            AuthorMsg(IDS_CANT_OPEN, pszMasterFile);
            strncpy(szPath, pszMasterFile, MAX_PATH); // BugFix: Don't over write buffer.
         szPath[MAX_PATH-1] = 0;
        }
    }

    // Even if we failed, we continue on to let ReadFromFile create
    // a dummy entry.

    m_ptoc= new CToc(this, m_pUnkOuter);

    UINT CodePage = -1;
    if( m_ptoc && m_ptoc->m_phh && m_ptoc->m_phh->m_phmData ) {
      CodePage = m_ptoc->m_phh->m_phmData->GetInfo()->GetCodePage();
    }

    if (!m_ptoc->m_sitemap.ReadFromFile(szPath, FALSE, this, CodePage))
        return FALSE;

    if (m_ptoc->m_sitemap.CountStrings())
        m_ptoc->m_cntCurHighlight = m_ptoc->m_cntFirstVisible = 1;


        // populate the InfoType member object of the CToc
    if ( !m_ptoc->m_pInfoType )
    {
        if (m_ptoc->m_phh && m_ptoc->m_phh->m_phmData && m_ptoc->m_phh->m_phmData->m_pdInfoTypes  )
        {   // load from the global IT store
            m_ptoc->m_pInfoType = new CInfoType;
            m_ptoc->m_pInfoType->CopyTo( m_ptoc->m_phh->m_phmData );

                // if there are info type bits set by the API assign them here
            if ( m_ptoc->m_phh->m_phmData->m_pAPIInfoTypes &&
                 m_ptoc->m_pInfoType->AnyInfoTypes(m_ptoc->m_phh->m_phmData->m_pAPIInfoTypes) )
            {
                memcpy(m_ptoc->m_pInfoType->m_pInfoTypes,
                    m_ptoc->m_phh->m_phmData->m_pAPIInfoTypes,
                    m_ptoc->m_pInfoType->InfoTypeSize() );
            }
        }else
        {
                // no global IT's; load from the .hhc IT store
            m_ptoc->m_pInfoType = new CInfoType;
            *m_ptoc->m_pInfoType = m_ptoc->m_sitemap;
        }

    }
    return TRUE;
}

__inline HTREEITEM Tree_AddItem(HWND hwndTree,
    HTREEITEM htiParent, int iImage, UINT cChildren, LPARAM lParam,
    TV_INSERTSTRUCTW* ptcInsert)
{
    ptcInsert->hParent = htiParent;
    ptcInsert->item.iImage = iImage;
    ptcInsert->item.iSelectedImage = iImage;
    ptcInsert->item.cChildren = cChildren;
    ptcInsert->item.lParam = lParam;

    return W_TreeView_InsertItem(hwndTree, ptcInsert);
}

BOOL CToc::InitTreeView()
{
    // REVIEW: following line from WinHelp codebase. Do we need it?
    ASSERT(::IsValidWindow(m_hwndTree)) ;

    WORD dwImageListResource = IDBMP_CNT_IMAGE_LIST;

    if(g_RTL_Mirror_Style)
        dwImageListResource = IDBMP_IMAGE_LIST_BIDI;

    SetWindowPos(m_hwndTree, NULL, 0, 0, 1, 1,
        SWP_DRAWFRAME | SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE);

    if (!m_fGlobal ) { // BUGBUG [Pat H] Binary TOC needs to be enhanced for ImageLists.
        if (!m_sitemap.m_pszImageList || m_fBinaryTOC)
            m_hil = ImageList_LoadImage(_Module.GetResourceInstance(),
                MAKEINTRESOURCE(dwImageListResource),
                CWIDTH_IMAGE_LIST, 0, 0x00FF00FF, IMAGE_BITMAP, 0);
        else {
            char szBitmap[MAX_PATH];
            BOOL fResult;
            if (m_phhctrl)
                fResult = m_phhctrl->ConvertToCacheFile(m_sitemap.m_pszImageList, szBitmap);
            else
                fResult = ConvertToCacheFile(m_sitemap.m_pszImageList, szBitmap);

            if (fResult)
                m_hil = ImageList_LoadImage(NULL, szBitmap,
                    m_sitemap.m_cImageWidth, 0, m_sitemap.m_clrMask, IMAGE_BITMAP, LR_LOADFROMFILE);
            else
                m_hil = NULL;

            if (!m_hil) {
                AuthorMsg(IDS_CANT_OPEN, m_sitemap.m_pszImageList, FindMessageParent(m_hwndTree), m_phhctrl);
                m_hil = ImageList_LoadImage(_Module.GetResourceInstance(),
                    MAKEINTRESOURCE(dwImageListResource),
                    CWIDTH_IMAGE_LIST, 0, 0x00FF00FF, IMAGE_BITMAP, 0);
            }
        }
    }

    if ( !m_fBinaryTOC )
        m_sitemap.m_cImages = ImageList_GetImageCount(m_hil);

    W_TreeView_SetImageList(m_hwndTree, m_hil, TVSIL_NORMAL);

    SendMessage(m_hwndTree, WM_SETREDRAW, FALSE, 0);

    // BUGBUG [Pat H] Binary TOC needs to be enhanced for FONT information.
    if (!m_fBinaryTOC && m_sitemap.m_pszFont) {

        /*
         * If the TOC had a font, it will over-ride any font specified in
         * the CHM file.
         */

        if (!m_fGlobal) {
            m_cFonts++;
            if (m_cFonts == 1)
                m_ahfonts = (HFONT*) lcMalloc(m_cFonts * sizeof(HFONT));
            else
                m_ahfonts = (HFONT*) lcReAlloc(m_ahfonts, m_cFonts * sizeof(HFONT));
            //
            // Insure correct charset...
            //
            int iCharset = -1;
            if ( m_phh )
               iCharset = m_phh->GetContentCharset();
            else if ( m_phhctrl )
               iCharset = m_phhctrl->GetCharset();
            
            if(g_fSysWinNT)
            {
                UINT CodePage = CP_ACP;
                if( m_phh && m_phh->m_phmData )
                    CodePage = m_phh->m_phmData->GetInfo()->GetCodePage();
                
                WCHAR *pwcLocal = MakeWideStr((char *)m_sitemap.m_pszFont, CodePage);
                
                if(pwcLocal)
                {
                    m_ahfonts[m_cFonts - 1] = CreateUserFontW(pwcLocal, NULL, NULL, iCharset);
                    free(pwcLocal);
                }
                else
                    m_ahfonts[m_cFonts - 1] = CreateUserFont(m_sitemap.m_pszFont, NULL, NULL, iCharset);
            }
            else
                m_ahfonts[m_cFonts - 1] = CreateUserFont(m_sitemap.m_pszFont, NULL, NULL, iCharset);
        }
        if (m_ahfonts[m_cFonts - 1])
            SendMessage(m_hwndTree, WM_SETFONT, (WPARAM) m_ahfonts[m_cFonts - 1], 0);
    }
    else {
        if ( m_phh )
           SendMessage(m_hwndTree, WM_SETFONT, (WPARAM)m_phh->GetAccessableContentFont(), 0);
        else if ( m_phhctrl )
           SendMessage(m_hwndTree, WM_SETFONT, (WPARAM)m_phhctrl->GetContentFont(), 0);
    }
                                                                // +1 because we are a 1-based table
    if (!m_fBinaryTOC )
    {
        m_phTreeItem = (HTREEITEM*) lcCalloc((m_sitemap.CountStrings() + 1) * sizeof(HTREEITEM));

        TV_INSERTSTRUCTW tcAdd;
        tcAdd.hInsertAfter = TVI_LAST;
        tcAdd.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM;
        tcAdd.item.hItem = NULL;
        tcAdd.item.pszText = LPSTR_TEXTCALLBACKW;

        HTREEITEM ahtiParents[SITEMAP_MAX_LEVELS + 1];
        HTREEITEM hti = NULL;
        HTREEITEM htiParent = TVI_ROOT;

        int curLevel = 0;
        ahtiParents[0] = TVI_ROOT;
        int             pos;

        CSubSets *pSSs = NULL;
        if ( m_phh && m_phh->m_phmData && m_phh->m_phmData->m_pTitleCollection &&
             m_phh->m_phmData->m_pTitleCollection->m_pSubSets )
            pSSs = m_phh->m_phmData->m_pTitleCollection->m_pSubSets;

        for (pos = 1; pos <= m_sitemap.CountStrings(); pos++)
        {
dontAdd:
            SITEMAP_ENTRY* pSiteMapEntry = m_sitemap.GetSiteMapEntry(pos);

                // the m_pInfoType member is set by the customize
                // option on the right click menu.
            if (!pSiteMapEntry->fShowToEveryOne && pSiteMapEntry->cUrls &&
#if 0 // enable for subset filtering.
                m_pInfoType && !m_pInfoType->IsEntryInCurTypeList(pSiteMapEntry, pSSs ) )
#else
                m_pInfoType && !m_pInfoType->IsEntryInCurTypeList(pSiteMapEntry ) )
#endif
                //!m_sitemap.IsEntryInCurTypeList(pSiteMapEntry))
            {
                continue;
            }
            if (pSiteMapEntry->IsTopic()) {
                if (pSiteMapEntry->level > 0 && pSiteMapEntry->level <= curLevel) {
                    // if (pSiteMapEntry->level < 1)
                    //        pSiteMapEntry->level = 1;
                    htiParent = ahtiParents[curLevel = pSiteMapEntry->level - 1];
                }
                pSiteMapEntry->iImage = (BYTE)m_sitemap.GetImageNumber(pSiteMapEntry);

                // Add the topic to the treeview control

                HTREEITEM hItem = Tree_AddItem(m_hwndTree,
                    htiParent,              // parent
                    pSiteMapEntry->iImage - 1,
                    0,                              // has kids
                    (LPARAM) pos,   // extra data
                    &tcAdd);
                m_phTreeItem[pos] = hItem;
            }
            else {
                int i=0;
                SITEMAP_ENTRY *pSME;
                do {
                    i++;
                    pSME = m_sitemap.GetSiteMapEntry(pos+i);
                    if ( (pSME>0) && (pSME->level <= pSiteMapEntry->level) )
                    {
                        pos+=i;
                        goto dontAdd;  // don't add the node with no topics to the TV.
                    }
                }
                while( pSME > 0 && !pSME->fTopic );

                // *** FOLDER LINE ***

                if (pSiteMapEntry->level > curLevel + 1)        // can't skip levels
                    pSiteMapEntry->level = curLevel + 1;

                int this_level = pSiteMapEntry->level;
                if (this_level < 1)
                    this_level = 1;

                // -1 to get a closed book

                pSiteMapEntry->iImage = (BYTE)m_sitemap.GetImageNumber(pSiteMapEntry);

                // switch to closed image

                if (pSiteMapEntry->iImage == IMAGE_OPEN_BOOK ||
                        pSiteMapEntry->iImage == IMAGE_OPEN_BOOK_NEW ||
                        pSiteMapEntry->iImage == IMAGE_OPEN_FOLDER ||
                        pSiteMapEntry->iImage == IMAGE_OPEN_FOLDER_NEW)
                    pSiteMapEntry->iImage--;

                htiParent = Tree_AddItem(m_hwndTree,
                    ahtiParents[this_level - 1],
                    pSiteMapEntry->iImage - 1,
                    TRUE, (DWORD) pos, &tcAdd);
                m_phTreeItem[pos] = htiParent;
                ahtiParents[curLevel = this_level] = htiParent;
            }
        }
    }
    else
        LoadFirstLevel( m_pBinTOCRoot, m_hwndTree, &m_tiFirstVisible );  // binary TOC, load the first level of the tree view.

#if 0

    12-Aug-1997 [ralphw] This code is only useful if we are restoring
    a treeview control that was closed but not deleted.

    // REVIEW: this was in WinHelp code base

    // FlushMessageQueue(WM_USER);

    for (pos = 1; pos <= CountStrings(); pos++) {
        SITEMAP_ENTRY* pSiteMapEntry = GetSiteMapEntry(pos);

        // Restore our position

        if (pSiteMapEntry->iImage == IMAGE_OPEN_FOLDER) {
            W_TreeView_Expand(m_hwndTree, m_phTreeItem[pos],
                TVE_EXPAND);
    // REVIEW: this was in WinHelp code base
    //                FlushMessageQueue(WM_USER);
        }
    }
#endif
    // BUGBUG [Pat H] Binary TOC needs to be enhanced to support colors and background bitmaps
    if (!m_fBinaryTOC && !m_fGlobal) {
        if (m_sitemap.m_clrBackground != -1 && m_sitemap.m_clrForeground != -1) {
            HDC hdc = GetWindowDC(m_hwndTree);
            // If the colors are the same, then ignore them both
            if (GetHighContrastFlag() ||
                    GetNearestColor(hdc, m_sitemap.m_clrBackground) ==
                    GetNearestColor(hdc, m_sitemap.m_clrForeground))
                m_sitemap.m_clrBackground = m_sitemap.m_clrForeground = (COLORREF) -1;
            ReleaseDC(m_hwndTree, hdc);
        }

        if (m_sitemap.m_clrBackground != -1)
            m_hbrBackGround = CreateSolidBrush(m_sitemap.m_clrBackground);
        if (m_sitemap.m_pszBackBitmap && !m_hbmpBackGround) {
            char szBitmap[MAX_PATH];
            if (ConvertToCacheFile(m_sitemap.m_pszBackBitmap, szBitmap) &&
                    LoadGif(szBitmap, &m_hbmpBackGround, &m_hpalBackGround, NULL)) {
                BITMAP bmp;
                GetObject(m_hbmpBackGround, sizeof(BITMAP), &bmp);
                m_cxBackBmp = bmp.bmWidth;
                m_cyBackBmp = bmp.bmHeight;
            }
        }
    }

    if (m_phh || m_hbrBackGround || m_hbmpBackGround)
    {
        BOOL fUni = IsWindowUnicode(m_hwndTree);
        if (lpfnlTreeViewWndProc == NULL)
            lpfnlTreeViewWndProc = W_GetWndProc(m_hwndTree, fUni);
        W_SubClassWindow(m_hwndTree, (LONG_PTR) TreeViewProc, fUni);
        SETTHIS(m_hwndTree);
    }
    SendMessage(m_hwndTree, WM_SETREDRAW, TRUE, 0);

    m_fSuppressJump = TRUE;
    if ( !m_fBinaryTOC )
    {
        ASSERT(m_cntFirstVisible <= m_sitemap.CountStrings());
        if (m_cntFirstVisible && m_phTreeItem)
            W_TreeView_Select(m_hwndTree, m_phTreeItem[m_cntFirstVisible],
                TVGN_FIRSTVISIBLE);
    }
    else
    {
        if ( m_tiFirstVisible )
        {
            W_TreeView_Select(m_hwndTree, m_tiFirstVisible, TVGN_FIRSTVISIBLE);
            m_hitemCurHighlight = m_tiFirstVisible;
        }
    }

#ifdef _DEBUG
    HTREEITEM hItemFirstVisible = W_TreeView_GetFirstVisible(m_hwndTree);
#endif
    if (!m_fBinaryTOC && m_cntCurHighlight && m_phTreeItem)
        W_TreeView_SelectItem(m_hwndTree, m_phTreeItem[m_cntCurHighlight]);

    m_hitemCurHighlight = W_TreeView_GetSelection(m_hwndTree);
    m_fSuppressJump = FALSE;

    if (m_fGlobal && !m_cszCurUrl.IsEmpty()) {
        m_fSuspendSync = FALSE;
        Synchronize(m_cszCurUrl);
    }
    ::ShowWindow(m_hwndTree, SW_SHOW);
    return TRUE;
}

__inline void Tree_SetImage(HWND hwndTree, int iImage, HTREEITEM hItem)
{
    ASSERT(::IsValidWindow(hwndTree)) ;

    TV_ITEMW tvinfo;
    ZeroMemory(&tvinfo, sizeof(tvinfo));

    tvinfo.hItem = hItem;
    tvinfo.iImage = iImage - 1;
    tvinfo.iSelectedImage = iImage - 1;
    tvinfo.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    W_TreeView_SetItem(hwndTree, &tvinfo);
}

LRESULT CToc::OnSiteMapTVMsg( NM_TREEVIEW *pnmhdr )
{
    SITEMAP_ENTRY* pSiteMapEntry;
    TV_HITTESTINFO ht;

    switch(pnmhdr->hdr.code) {
        case TVN_GETDISPINFOA:
#define pdi ((TV_DISPINFOA*) pnmhdr)
            if (pdi->item.mask & TVIF_TEXT)
            {
                pSiteMapEntry = m_sitemap.GetSiteMapEntry((int)pdi->item.lParam);
                strncpy(pdi->item.pszText, pSiteMapEntry->pszText, pdi->item.cchTextMax);
            }
            break;
#undef pdi

        case TVN_GETDISPINFOW:
#define pdi ((TV_DISPINFOW*) pnmhdr)
            if (pdi->item.mask & TVIF_TEXT)
            {
                pSiteMapEntry = m_sitemap.GetSiteMapEntry((int)pdi->item.lParam);
                if (FAILED(pSiteMapEntry->GetKeyword(pdi->item.pszText, pdi->item.cchTextMax)))
                    _wcsncpy(pdi->item.pszText, GetStringResourceW(IDS_UNTITLED), pdi->item.cchTextMax);
            }
            break;
#undef pdi

        case NM_RETURN:
        case NM_DBLCLK:
            {
                TV_ITEMW tvi;

                ASSERT(::IsValidWindow(m_hwndTree)) ;
                tvi.hItem = W_TreeView_GetSelection(m_hwndTree);
                if (!tvi.hItem)
                    break;          // probably ENTER with no selection

                tvi.mask = TVIF_PARAM;
                W_TreeView_GetItem(m_hwndTree, &tvi);
                pSiteMapEntry = m_sitemap.GetSiteMapEntry((int)tvi.lParam);

                if (pSiteMapEntry->pUrls) {
                    m_fSuspendSync = TRUE;

                    if (pSiteMapEntry->fSendEvent && m_phhctrl) {
                        m_phhctrl->SendEvent(m_sitemap.GetUrlString(pSiteMapEntry->pUrls->urlPrimary));
                        return NULL;
                    }
                    JumpToUrl(m_pOuter, m_hwndTree, pSiteMapEntry,  m_pInfoType, &(this->m_sitemap), NULL);
                    if (m_phh)
                    {
                        m_phh->m_hwndControl = m_hwndTree;
                    }
                }

                // The treeview does not automatically expand the node with the enter key.
                // so we do it here.
                if ( pnmhdr->hdr.code == NM_RETURN )
                {
                    if ( tvi.state & TVIS_EXPANDED )
                    {
                        W_TreeView_Expand( m_hwndTree, tvi.hItem, TVE_COLLAPSE );
                        ASSERT(pSiteMapEntry->iImage);
                        if ( (pSiteMapEntry->iImage>1) && (pSiteMapEntry->iImage <= IMAGE_OPEN_FOLDER_NEW) )
                        {
                            pSiteMapEntry->iImage--;
                        }
                    }
                    else
                    {
                        W_TreeView_Expand( m_hwndTree, tvi.hItem, TVE_EXPAND );
                        // The first time we send the TVE_EXPAND message we get a TVIS_ITEMEXPANDING message for the item.
                        // The TVIS_ITEMEXPANDING message is not sent on subsequent expands of the same item.
                        if ( tvi.state & TVIS_EXPANDEDONCE )
                        {
                            if (pSiteMapEntry->iImage == 0)
                                pSiteMapEntry->iImage = (BYTE)m_sitemap.GetImageNumber(pSiteMapEntry);
                            if (pSiteMapEntry->iImage < IMAGE_OPEN_FOLDER_NEW)
                                pSiteMapEntry->iImage++;
                        }
                    }
                        // Set the correct image
                    Tree_SetImage(m_hwndTree, pSiteMapEntry->iImage, tvi.hItem);
                }
            }

            break;

        case TVN_SELCHANGING:
            m_hitemCurHighlight = pnmhdr->itemNew.hItem;
            break;

        case TVN_SELCHANGED:
            m_hitemCurHighlight = pnmhdr->itemNew.hItem;
            break;

        case NM_CLICK:
            /*
             * We want a single click to open a topic. We already process
             * the case where the selection changes, and we jump if it does.
             * However, the user may click an existing selection, in which
             * case we want to jump (because the jump may have failed when
             * the item was first selected. However, we need to post the
             * message so that the treeview control will finish processing
             * the click (which could result in a selection change.
             */

            if (!m_fSuppressJump) {
                ASSERT(::IsValidWindow(m_hwndTree)) ;
                TV_HITTESTINFO ht;
                GetCursorPos(&ht.pt);
                ScreenToClient(m_hwndTree, &ht.pt);

                W_TreeView_HitTest(m_hwndTree, &ht);
                if (ht.flags & TVHT_ONITEMBUTTON)
                    break; // just clicking the button, so ignore

                TV_ITEMW tvi;

                tvi.hItem = ht.hItem;
                if (!tvi.hItem)
                    break;          // probably ENTER with no selection

                m_hitemCurHighlight = tvi.hItem;
                tvi.mask = TVIF_PARAM;
                W_TreeView_GetItem(m_hwndTree, &tvi);
                pSiteMapEntry = m_sitemap.GetSiteMapEntry((int)tvi.lParam);
                PostMessage(FindMessageParent(m_hwndTree), WM_COMMAND, ID_TV_SINGLE_CLICK,
                    (LPARAM) W_TreeView_GetSelection(m_hwndTree));
            }
            break;

        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDINGW:
            {
                if (m_fHack) {
                    m_fHack = FALSE;
                    break;
                }
                SITEMAP_ENTRY* pSiteMapEntry = m_sitemap.GetSiteMapEntry((int)pnmhdr->itemNew.lParam);
                // if click on vacant area of TOC Tree view there is no sitemap entry.
                if ( pSiteMapEntry == NULL )
                    break;

                // REVIEW: need to update this to support multiple images
                // for multiple levels, and also to support "new" images

                if (pnmhdr->action & TVE_EXPAND) {
                    if ( !(pnmhdr->itemNew.state & TVIS_EXPANDED) )
                    {
                        if (pSiteMapEntry->iImage == 0)
                            pSiteMapEntry->iImage = (BYTE)m_sitemap.GetImageNumber(pSiteMapEntry);
                        if (pSiteMapEntry->iImage < IMAGE_OPEN_FOLDER_NEW)
                            pSiteMapEntry->iImage++;
                    }
                    else
                        break;
                }
                else {
                    ASSERT(pnmhdr->action & TVE_COLLAPSE);
                    ASSERT(pSiteMapEntry->iImage);

                    if ( pnmhdr->itemNew.state & TVIS_EXPANDED )
                    {
                        if ( (pSiteMapEntry->iImage>1) && (pSiteMapEntry->iImage <= IMAGE_OPEN_FOLDER_NEW) )
                            pSiteMapEntry->iImage--;
                    }
                    else
                        break;
                }

                // Set the correct image
                ASSERT(::IsValidWindow(m_hwndTree)) ;
                Tree_SetImage(m_hwndTree, pSiteMapEntry->iImage, pnmhdr->itemNew.hItem);
            }
            break;

        case TVN_KEYDOWN:
           TV_KEYDOWN* ptvkd;
           ptvkd = (TV_KEYDOWN*)pnmhdr;
           if ( ptvkd->wVKey != VK_F10 )
              break;
           else if ( GetKeyState(VK_SHIFT) >= 0 )
              break;
           else
           {
              ht.pt.x = ht.pt.y = 0;
              ClientToScreen(m_hwndTree, &ht.pt);
              goto sim_rclick;
           }
           break;

        case NM_RCLICK:
            {
                GetCursorPos(&ht.pt);
                ScreenToClient(m_hwndTree, &ht.pt);
                W_TreeView_HitTest(m_hwndTree, &ht);
                if ( ht.hItem )
                   W_TreeView_Select(m_hwndTree, ht.hItem, TVGN_CARET);
                ClientToScreen(m_hwndTree, &ht.pt);
sim_rclick:
                HMENU hmenu = CreatePopupMenu();
                if (!hmenu)
                    break;

                ASSERT(::IsValidWindow(m_hwndTree)) ;
                // NOTICE: Changes here must be reflected in the binary toc verison of this menu

                if (!(m_dwStyles & TVS_SINGLEEXPAND)) {
                    HxAppendMenu(hmenu, MF_STRING, ID_EXPAND_ALL, GetStringResource(IDS_EXPAND_ALL));
                    HxAppendMenu(hmenu, MF_STRING, ID_CONTRACT_ALL, GetStringResource(IDS_CONTRACT_ALL));
                }
				if ((m_phh == NULL) || (m_phh && m_phh->m_pCIExpContainer))
					HxAppendMenu(hmenu, MF_STRING, ID_PRINT, GetStringResource(IDS_PRINT));

                ASSERT( m_pInfoType );
                    // populate the InfoType member object of the CToc
                if ( !m_pInfoType )
                {
                    if (m_phh && m_phh->m_phmData && m_phh->m_phmData->m_pdInfoTypes  )
                    {       // load from the global IT store
                        m_pInfoType = new CInfoType;
                        m_pInfoType->CopyTo( m_phh->m_phmData );
                            // if there are info type bits set by the API assign them here
                        if ( m_phh->m_phmData->m_pAPIInfoTypes &&
                             m_pInfoType->AnyInfoTypes(m_phh->m_phmData->m_pAPIInfoTypes) )
                        {
                            memcpy(m_pInfoType->m_pInfoTypes,
                                m_phh->m_phmData->m_pAPIInfoTypes,
                                m_pInfoType->InfoTypeSize() );
                        }
                    }else
                    {
                            // no global IT's; load from the .hhc IT store
                        m_pInfoType = new CInfoType;
                        *m_pInfoType = m_sitemap;
                    }

                }
                else
                {
                    // Set the infotypes bits to set all the types

                }
                    // If there are infotypes add the "customize" option to the popup menu
                if (m_pInfoType && m_pInfoType->HowManyInfoTypes() && m_pInfoType->GetFirstHidden() != 1)
                    HxAppendMenu(hmenu, MF_STRING, ID_CUSTOMIZE_INFO_TYPES,
                        GetStringResource(IDS_CUSTOMIZE_INFO_TYPES));

                if (IsHelpAuthor(FindMessageParent(m_hwndTree))) {
                    AppendMenu(hmenu, MF_SEPARATOR, 0, 0);
                    HxAppendMenu(hmenu, MF_STRING, ID_VIEW_ENTRY, pGetDllStringResource(IDS_VIEW_ENTRY));
					if (NoRun() == FALSE)
                    HxAppendMenu(hmenu, MF_STRING, ID_JUMP_URL, GetStringResource(IDS_JUMP_URL));
                }
#ifdef _DEBUG
                HxAppendMenu(hmenu, MF_STRING, ID_VIEW_MEMORY,
                    "Debug: memory usage...");
#endif
                TrackPopupMenu(hmenu,
                    TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON,
                    ht.pt.x, ht.pt.y, 0, FindMessageParent(m_hwndTree), NULL);
                DestroyMenu(hmenu);
                return TRUE;
            }
            break;

        case NM_CUSTOMDRAW:
            return OnCustomDraw((LPNMTVCUSTOMDRAW) pnmhdr);
    }
    return FALSE;
}

// This is the message handler for the Tree View containing the Table of Contents.
LRESULT CToc::TreeViewMsg(NM_TREEVIEW* pnmhdr)
{
    if ( !m_fBinaryTOC )
        return OnSiteMapTVMsg( pnmhdr );
    else
        return OnBinaryTOCTVMsg ( pnmhdr );
}

BOOL (STDCALL *pResetTocAppearance)(HWND hwndParent, HHA_TOC_APPEARANCE* pappear);

LRESULT CToc::OnCommand(HWND /*hwnd*/, UINT id, UINT uNotifiyCode, LPARAM lParam)
{
    if ( m_fBinaryTOC )
        return OnBinTOCContentsCommand(id, uNotifiyCode, lParam);
    else
        return OnSiteMapContentsCommand(id, uNotifiyCode, lParam);

}

LRESULT CToc::OnSiteMapContentsCommand(UINT id, UINT uNotifyCode, LPARAM lParam)
{
    ASSERT(::IsValidWindow(m_hwndTree)) ;
    switch (id) {
        case ID_EXPAND_ALL:
            {
                ASSERT(::IsValidWindow(m_hwndTree)) ;
                m_hitemCurHighlight = W_TreeView_GetSelection(m_hwndTree);
                CHourGlass hourglass;
                SendMessage(m_hwndTree, WM_SETREDRAW, FALSE, 0);
                for (int pos = 1; pos <= m_sitemap.CountStrings(); pos++) {
                    SITEMAP_ENTRY* pSiteMapEntry = m_sitemap.GetSiteMapEntry(pos);

                    // If it is not a topic, and the book is closed
					TV_ITEMW tvi;

					tvi.hItem = m_phTreeItem[pos];
	
		            tvi.mask = TVIF_STATE;
					W_TreeView_GetItem(m_hwndTree, &tvi);

                    if (!pSiteMapEntry->IsTopic() && !(tvi.state & TVIS_EXPANDED)) {
                        m_fHack = TRUE; // ignore expansion notice
                        W_TreeView_Expand(m_hwndTree, m_phTreeItem[pos], TVE_EXPAND);
                        if (pSiteMapEntry->iImage < IMAGE_OPEN_FOLDER_NEW)
                            pSiteMapEntry->iImage++;
                        Tree_SetImage(m_hwndTree, pSiteMapEntry->iImage, m_phTreeItem[pos]);
                    }
                }

                SendMessage(m_hwndTree, WM_SETREDRAW, TRUE, 0);
                if (m_hitemCurHighlight) {
                    m_fSuppressJump = TRUE;
                    m_fHack = TRUE; // ignore expansion notice
                    W_TreeView_Select(m_hwndTree, m_hitemCurHighlight, TVGN_FIRSTVISIBLE);
                    W_TreeView_SelectItem(m_hwndTree, m_hitemCurHighlight);
                    m_fSuppressJump = FALSE;
                }
            }
            m_fHack = FALSE;        // process expansion/contraction normally
            return 0;

        case ID_CONTRACT_ALL:
            {
                ASSERT(::IsValidWindow(m_hwndTree)) ;
                m_hitemCurHighlight = W_TreeView_GetSelection(m_hwndTree);

                SendMessage(m_hwndTree, WM_SETREDRAW, FALSE, 0);
                for (int pos = 1; pos <= m_sitemap.CountStrings(); pos++) {
                    SITEMAP_ENTRY* pSiteMapEntry = m_sitemap.GetSiteMapEntry(pos);

                    // If it is not a topic, and the book is open
					TV_ITEMW tvi;

					tvi.hItem = m_phTreeItem[pos];
	
		            tvi.mask = TVIF_STATE;
					W_TreeView_GetItem(m_hwndTree, &tvi);

                    if (!pSiteMapEntry->IsTopic() && (tvi.state & TVIS_EXPANDED)) {
                        m_fHack = TRUE; // ignore contraction notice
                        W_TreeView_Expand(m_hwndTree, m_phTreeItem[pos], TVE_COLLAPSE);
                        if (pSiteMapEntry->iImage <= IMAGE_OPEN_FOLDER_NEW)
                            pSiteMapEntry->iImage--;
                        Tree_SetImage(m_hwndTree, pSiteMapEntry->iImage, m_phTreeItem[pos]);
                    }
                }
           SendMessage(m_hwndTree, WM_SETREDRAW, TRUE, 0);
            }
            m_fHack = FALSE;        // process expansion/contraction normally
            return 0;

#ifndef CHIINDEX
        case ID_PRINT:
            {
                if (m_phh) {
                    if (m_phh->OnTrackNotifyCaller(HHACT_PRINT))
                       break;
                    m_phh->OnPrint();
                    break;
                }
                CPrint prt(GetParent(m_hwndTree));
                prt.SetAction(PRINT_CUR_HEADING);
                if (!prt.DoModal())
                    break;
                int action = prt.GetAction();

                ASSERT(m_phhctrl);
                PrintTopics(action, this,
                    m_phhctrl->m_pWebBrowserApp, m_phhctrl->m_hwndHelp);
            }
            return 0;
#endif

        case ID_CUSTOMIZE_INFO_TYPES:
            {
                if ( m_phh && m_phh->m_phmData->m_pTitleCollection->m_pSubSets->GetTocSubset() )
                    m_phh->m_phmData->m_pTitleCollection->m_pSubSets->m_cur_Set = m_phh->m_phmData->m_pTitleCollection->m_pSubSets->GetTocSubset();  // set this so the wizard knows which subset to load the combo box with.
#if 0 // enable for subset filtering
                if (ChooseInformationTypes(m_pInfoType, &(this->m_sitemap),
                        m_hwndTree, m_phhctrl, m_phh)) {
#else
                if (ChooseInformationTypes(m_pInfoType, &(this->m_sitemap),
                        m_hwndTree, m_phhctrl)) {
#endif
                    if (m_phh)
                        m_phh->UpdateInformationTypes();
                    else {
                        HWND hwndParent = GetParent(m_hwndTree);
                        DestroyWindow(m_hwndTree);
                        // Destroying the TreeView control, make sure we no longer point to it as a valid
                        // subclassed window.
                        if (NULL != lpfnlTreeViewWndProc)
                        {
                          lpfnlTreeViewWndProc = NULL;
                        }
                        Create(hwndParent);
                        InitTreeView();
                    }
                }
            }
            break;

        case ID_VIEW_ENTRY:
            {
                TV_ITEMW tvi;

                tvi.hItem = W_TreeView_GetSelection(m_hwndTree);
                if (!tvi.hItem)
                    return 0;          // no current selection

                tvi.mask = TVIF_PARAM;
                W_TreeView_GetItem(m_hwndTree, &tvi);
                SITEMAP_ENTRY* pSiteMapEntry = m_sitemap.GetSiteMapEntry((int)tvi.lParam);
                DisplayAuthorInfo(m_pInfoType, &(this->m_sitemap), pSiteMapEntry, FindMessageParent(m_hwndTree), m_phhctrl);
            }
            return 0;

        case ID_JUMP_URL:
            {
                char szDstUrl[INTERNET_MAX_URL_LENGTH];
                CStr cszCurUrl;
                if (m_phhctrl)
                    m_phhctrl->m_pWebBrowserApp->GetLocationURL(&cszCurUrl);
                else
                    m_phh->m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL(&cszCurUrl);
                if (doJumpUrl(GetParent(m_hwndTree), cszCurUrl, szDstUrl) && szDstUrl[0]) {
                    if (m_phhctrl) {
                        CWStr cwJump(szDstUrl);
                        HlinkSimpleNavigateToString(cwJump, NULL,
                            NULL, m_phhctrl->GetIUnknown(), NULL, NULL, 0, NULL);
                    }
                    else {
                        ChangeHtmlTopic(szDstUrl, GetParent(m_hwndTree));
                    }
                }
            }
            break;

#ifdef _DEBUG
        case ID_VIEW_MEMORY:
            OnReportMemoryUsage();
            return 0;
#endif

        case ID_TV_SINGLE_CLICK:
            {
                TV_ITEMW tvi;
                tvi.mask = TVIF_PARAM;
                if (m_hitemCurHighlight == 0 )
                    break;
                tvi.hItem = m_hitemCurHighlight;
                W_TreeView_GetItem(m_hwndTree, &tvi);
                SITEMAP_ENTRY* pSiteMapEntry = m_sitemap.GetSiteMapEntry((int)tvi.lParam);
//                              if (pSiteMapEntry->fShortCut) {

                if (pSiteMapEntry->pUrls) {
                    m_fIgnoreNextSelChange = TRUE;
                    m_fSuspendSync = TRUE;
                    if (pSiteMapEntry->fSendEvent && m_phhctrl)
                        m_phhctrl->SendEvent(m_sitemap.GetUrlString(pSiteMapEntry->pUrls->urlPrimary));
                    else {
                        SaveCurUrl();   // so we can restore our state
                        JumpToUrl(m_pOuter, m_hwndTree, pSiteMapEntry,
                            m_pInfoType, &(this->m_sitemap), NULL);
                    }
                }
                if (m_phh)
                {
                    m_phh->m_hwndControl = m_hwndTree;
                }
            }
            break;

    }
    return 0;
}

BOOL CToc::Synchronize(LPCSTR pszURL)
{
    HRESULT hr;
    CTreeNode* pSyncNode, *pCurNode;

    if (m_phh && m_phh->curNavType != HHWIN_NAVTYPE_TOC) {
        m_fSyncOnActivation = TRUE;
        return TRUE;    // don't sync if we're not the active tab
    }
    ASSERT(::IsValidWindow(m_hwndTree)) ;

    if (m_fBinaryTOC)
    {
        BOOL bSynced = FALSE;
        CPointerList hier;
        LISTITEM *pItem;
        ASSERT(m_phh->m_phmData);
        ASSERT(!IsBadReadPtr(m_phh->m_phmData, sizeof(CHmData)));
        hr = m_phh->m_phmData->m_pTitleCollection->Sync(&hier, pszURL);
        if ( SUCCEEDED(hr) )
        {
            TV_ITEMW hCur;
            hCur.hItem = W_TreeView_GetRoot(m_hwndTree);
            pItem = hier.First();
            pSyncNode = (CTreeNode *)pItem->pItem;
            while (hCur.hItem && pSyncNode)
            {
                hCur.mask = TVIF_PARAM | TVIF_IMAGE;
                if (W_TreeView_GetItem(m_hwndTree, &hCur) == FALSE)
                    break;
                pCurNode = (CTreeNode *)hCur.lParam;

                if (pSyncNode->Compare(pCurNode) == TRUE)
                {
                    pItem = hier.Next(pItem);
                    if (pItem == NULL)
                    {
                        // just found it
                        bSynced = TRUE;
                        break;
                    }

                    // found a parent node, expand and find next item
                    if (pCurNode->m_Expanded == FALSE)
                    {
                        if (HandleExpanding(&hCur, m_hwndTree, TVE_EXPAND, &m_fSuspendSync) == FALSE)
                            break;
                        if (W_TreeView_Expand(m_hwndTree, hCur.hItem, TVE_EXPAND) == FALSE)
                            break;
                    }
                    hCur.hItem = W_TreeView_GetChild(m_hwndTree, hCur.hItem);

                    pSyncNode = (CTreeNode *)pItem->pItem;
                }
                else
                    hCur.hItem = W_TreeView_GetNextSibling(m_hwndTree, hCur.hItem);
            }

            if (bSynced == TRUE)
            {
                W_TreeView_SelectItem(m_hwndTree, hCur.hItem);
            }

            // clean up memory
            for (pItem = hier.First(); pItem; )
            {
                if (pItem->pItem)
                    delete pItem->pItem;
                pItem = hier.Next(pItem);
            }
            return bSynced;
        }
        return FALSE;
    }
    //
    // sitmap syncing code...
    //
    if (m_fSuspendSync) {
        m_fSuspendSync = FALSE;
        return TRUE;
    }

    TCHAR szUrl[MAX_URL];
    PSTR pszUrl = szUrl;

    if (IsEmptyString(pszURL)) // Avoid crash.
    {
        return FALSE ;
    }

    strcpy(pszUrl, pszURL);
    PSTR pszSep = strstr(pszUrl, txtDoubleColonSep);
    if (pszSep)
        strcpy(pszUrl, pszSep + 2);

    m_hitemCurHighlight = W_TreeView_GetSelection(m_hwndTree);
    TV_ITEMW tvi;
    if (m_hitemCurHighlight) {
        tvi.mask = TVIF_PARAM;
        tvi.hItem = m_hitemCurHighlight;
        W_TreeView_GetItem(m_hwndTree, &tvi);
    }
    else
        tvi.lParam = 0;

    BOOL fFoundMatch = FALSE;
    ConvertBackSlashToForwardSlash(pszUrl);
    if (IsCompiledURL(pszUrl)) {
        PSTR psz = strstr(pszUrl, txtDoubleColonSep);
        ASSERT(psz);
        pszUrl = psz + 2;
    }
    if (pszUrl[0] == '/' && pszUrl[1] != '/')
        pszUrl++;       // remove the root directive
    PSTR pszUrlBookMark = StrChr(pszUrl, '#');
    if (pszUrlBookMark)
        *pszUrlBookMark++ = '\0';

    CStr cszSiteUrl;

    // Start from our current position and go forward

    for (int pos = (int)tvi.lParam + 1; pos <= m_sitemap.CountStrings(); pos++) {
        SITEMAP_ENTRY* pSiteMapEntry = m_sitemap.GetSiteMapEntry(pos);

        for (int i = 0; i < pSiteMapEntry->cUrls; i++) {
            SITE_ENTRY_URL* pUrl = m_sitemap.GetUrlEntry(pSiteMapEntry, i);
            if (pUrl->urlPrimary) {
                cszSiteUrl = m_sitemap.GetUrlString(pUrl->urlPrimary);
                PSTR pszSiteUrl = cszSiteUrl.psz;
                ConvertBackSlashToForwardSlash(pszSiteUrl);

            // Bug 2362 we are syncing to a htm file where the same file and path exist
            // in two or more other merged chms we could sync to the wrong one.  This is
            // an acceptable trade off to the reams of changes require to fully fix the bug
             PSTR pszSep = strstr(pszSiteUrl, txtDoubleColonSep);
            if (pszSep)
               strcpy(pszSiteUrl, pszSep + 2);

                if (pszSiteUrl[0] == '/' && pszSiteUrl[1] != '/')
                    pszSiteUrl++;   // remove the root directive
                PSTR pszSiteBookMark = StrChr(pszSiteUrl, '#');
                if (pszSiteBookMark)
                    *pszSiteBookMark++ = '\0';
                if (lstrcmpi(pszUrl, pszSiteUrl) == 0) {

                    // If both URLS have bookmarks, then they must match

                    if (pszSiteBookMark && pszUrlBookMark) {
                        if (lstrcmpi(pszSiteBookMark, pszUrlBookMark) != 0)
                            continue;
                    }

                    fFoundMatch = TRUE;
                    break;
                }
            }
        }
        if (fFoundMatch)
            break;
    }

    // Start from current position - 1, and go backwards

    if (!fFoundMatch) {
        for (pos = (int)tvi.lParam; pos > 1; pos--) {
            SITEMAP_ENTRY* pSiteMapEntry = m_sitemap.GetSiteMapEntry(pos);

            for (int i = 0; i < pSiteMapEntry->cUrls; i++) {
                SITE_ENTRY_URL* pUrl = m_sitemap.GetUrlEntry(pSiteMapEntry, i);
                if (pUrl->urlPrimary) {
                    cszSiteUrl = m_sitemap.GetUrlString(pUrl->urlPrimary);
                    PSTR pszSiteUrl = cszSiteUrl.psz;
                    ConvertBackSlashToForwardSlash(pszSiteUrl);

                    // Bug 2362 we are syncing to a htm file where the same file and path exist
                    // in two or more other merged chms we could sync to the wrong one.  This is
                    // an acceptable trade off to the reams of changes require to fully fix the bug
                    PSTR pszSep = strstr(pszSiteUrl, txtDoubleColonSep);
                    if (pszSep)
                       strcpy(pszSiteUrl, pszSep + 2);

                    if (pszSiteUrl[0] == '/' && pszSiteUrl[1] != '/')
                        pszSiteUrl++;   // remove the root directive
                    PSTR pszSiteBookMark = StrChr(pszSiteUrl, '#');
                    if (pszSiteBookMark)
                        *pszSiteBookMark++ = '\0';
                    if (lstrcmpi(pszUrl, pszSiteUrl) == 0) {

                        // If both URLS have bookmarks, then they must match

                        if (pszSiteBookMark && pszUrlBookMark) {
                            if (lstrcmpi(pszSiteBookMark, pszUrlBookMark) != 0)
                                continue;
                        }

                        fFoundMatch = TRUE;
                        break;
                    }
                }
            }
            if (fFoundMatch)
                break;
        }
    }

    if (fFoundMatch) {
        m_fSuppressJump = TRUE;
        if (m_phTreeItem)
        {
            W_TreeView_SelectItem(m_hwndTree, m_phTreeItem[pos]);

            // For an unknown reason (we suspect a bug in the common control)
            // the treeview control does not always paint properly under Thai 
            // this situation.  This code forces a repaint (corrects the 
            // problem).  See HH Bug #5581.
            //
            if(g_langSystem == LANG_THAI && !g_fSysWinNT)
                InvalidateRect(GetParent(m_hwndTree), NULL, FALSE);
        }
        m_fSuppressJump = FALSE;
    }

    return fFoundMatch;
}

DWORD CToc::OnCustomDraw(LPNMTVCUSTOMDRAW pnmcdrw)
{
    switch (pnmcdrw->nmcd.dwDrawStage) {
        case CDDS_PREPAINT:
            return CDRF_NOTIFYITEMDRAW;

        case CDDS_ITEMPREPAINT:
            if (m_sitemap.m_clrBackground != (COLORREF) -1 && !(pnmcdrw->nmcd.uItemState & CDIS_SELECTED))
                pnmcdrw->clrTextBk = m_sitemap.m_clrBackground;
            if (m_sitemap.m_clrForeground != (COLORREF) -1 && !(pnmcdrw->nmcd.uItemState & CDIS_SELECTED))
                pnmcdrw->clrText = m_sitemap.m_clrForeground;
            // SetBkMode(pnmcdrw->nmcd.hdc, TRANSPARENT);
            break;
    }
    return CDRF_DODEFAULT;
}

LRESULT WINAPI TreeViewProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
        case WM_CHAR:                                        //Process this message to avoid beeps.
            if ((wParam == VK_RETURN) || (wParam == VK_TAB))
                return 0;
            return W_DelegateWindowProc(lpfnlTreeViewWndProc, hwnd, msg, wParam, lParam);

        case WM_KEYDOWN:
            if (wParam == VK_MULTIPLY)
               return 0;
            break;

       case WM_SYSKEYDOWN:
          if ( wParam == VK_LEFT || wParam == VK_RIGHT || wParam == VK_UP || wParam == VK_DOWN )
          {
             return TRUE;
          }
          break;

        case WM_ERASEBKGND:
            {
                CToc* pThis = (CToc*) GetWindowLongPtr(hwnd, GWLP_USERDATA);
                ASSERT(pThis);
                if (pThis && pThis->m_hbmpBackGround) {
                    RECT rc;
                    HDC hdc = (HDC) wParam;
                    GetClientRect(hwnd, &rc);
                    // GetClipBox(hdc, &rc);
                    CPalDC dc(pThis->m_hbmpBackGround);
                    HPALETTE hpalTmp = NULL;
                    if (pThis->m_hpalBackGround) {
                        hpalTmp = SelectPalette(hdc,
                            pThis->m_hpalBackGround, FALSE);
                        RealizePalette(hdc);
                    }
                    for (int left = 0; left <= rc.right; left += pThis->m_cxBackBmp) {
                        for (int top = 0; top <= rc.bottom; top += pThis->m_cyBackBmp) {
                            BitBlt((HDC) wParam, left, top, pThis->m_cxBackBmp,
                                pThis->m_cyBackBmp, dc,
                                0, 0, SRCCOPY);
                        }
                    }
                    if (hpalTmp)
                        SelectPalette(hdc, hpalTmp, FALSE);
                }
                else if (pThis && pThis->m_hbrBackGround) {
                    RECT rc;
                    GetClipBox((HDC) wParam, &rc);
                    FillRect((HDC) wParam, &rc, pThis->m_hbrBackGround);
                    return TRUE;
                }
                else
                    break;
            }
            return TRUE;
    }
    return W_DelegateWindowProc(lpfnlTreeViewWndProc, hwnd, msg, wParam, lParam);
}

void CToc::SaveCurUrl(void)
{
    ASSERT(::IsValidWindow(m_hwndTree)) ;

    TV_ITEMW tvi;

    tvi.hItem = W_TreeView_GetSelection(m_hwndTree);
    if (!tvi.hItem)
        return;          // no current selection

    tvi.mask = TVIF_PARAM;
    W_TreeView_GetItem(m_hwndTree, &tvi);
    SITEMAP_ENTRY* pSiteMapEntry = m_sitemap.GetSiteMapEntry((int)tvi.lParam);
    ASSERT(pSiteMapEntry);
    SITE_ENTRY_URL* pUrl = m_sitemap.GetUrlEntry(pSiteMapEntry, 0);
    if (pUrl) { // a book/folder may not have an URL to save
        if (pUrl->urlPrimary)
            m_cszCurUrl = m_sitemap.GetUrlString(pUrl->urlPrimary);
        else
            m_cszCurUrl = m_sitemap.GetUrlString(pUrl->urlSecondary);
    }
}

BOOL HandleExpanding(TVITEMW* pTvi, HWND hwndTreeView, UINT action, BOOL *pSync)
{
CTreeNode*      pNode;
        ASSERT(::IsValidWindow(hwndTreeView)) ;

        if (! (pNode = (CTreeNode *)pTvi->lParam) ) // A pointer into the binary TOC; a CTreeNode
                return FALSE;

        int iImage = pTvi->iImage;
        if (action & TVE_EXPAND)
        {
            if (pNode->m_Expanded == TRUE)
                return TRUE;
            pNode->m_Expanded = TRUE;
            AddChildren(pTvi, hwndTreeView);        // Add the items below the expanding parent
            iImage++;
        }
        else
        {
            *pSync = FALSE;
            pNode->m_Expanded = FALSE;
            ASSERT(action & TVE_COLLAPSE);
            DeleteChildren(pTvi, hwndTreeView);
            if ( iImage )
               iImage--;
        }
        // Set the correct image for the expanding/contracting node
        TV_ITEMW tvinfo;
        ZeroMemory(&tvinfo, sizeof(tvinfo));
        tvinfo.hItem = pTvi->hItem;
        tvinfo.iImage = tvinfo.iSelectedImage = iImage;
        tvinfo.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        W_TreeView_SetItem(hwndTreeView, &tvinfo);
        return TRUE;
}

LRESULT CToc::OnBinaryTOCTVMsg( NM_TREEVIEW *pnmhdr )
{
CTreeNode*      pNode;
TV_ITEMW        tvItem;
char          szTempURL[MAX_URL];
TV_DISPINFO* pdi;
TV_HITTESTINFO ht;

    switch(pnmhdr->hdr.code) {
        case TVN_GETDISPINFOA:   // Tree view wants to draw an item.
        case TVN_GETDISPINFOW:
            pdi = (TV_DISPINFO*)pnmhdr;
            pNode = (CTreeNode *)pdi->item.lParam;  // This is a pointer into the binary TOC it is a CTreeNode of some type
            if (! pNode )
                break;
            tvItem.mask = 0;
            if( pdi->item.mask & TVIF_CHILDREN )
            {
                tvItem.cChildren = (pNode->HasChildren())?1:0;
                tvItem.mask |= TVIF_CHILDREN;
            }
            if (pdi->item.mask & TVIF_TEXT)
            {
               if ( pnmhdr->hdr.code == TVN_GETDISPINFOW )
               {
                  if ( !SUCCEEDED(pNode->GetTopicName((WCHAR*)pdi->item.pszText, pdi->item.cchTextMax)) )
                     _wcsncpy((WCHAR*)pdi->item.pszText, GetStringResourceW(IDS_UNTITLED), pdi->item.cchTextMax);
               }
               else
               {
                  if ( !SUCCEEDED(pNode->GetTopicName(pdi->item.pszText, pdi->item.cchTextMax)) )
                     lstrcpy(pdi->item.pszText, GetStringResource(IDS_UNTITLED));
               }
            }
            break;

        case TVN_DELETEITEMA:
        case TVN_DELETEITEMW:
            break;

        case NM_RETURN:
        case NM_DBLCLK:
            ASSERT(::IsValidWindow(m_hwndTree)) ;
            tvItem.hItem = W_TreeView_GetSelection(m_hwndTree);
            if (!tvItem.hItem)
                break;          // probably ENTER with no selection

            tvItem.mask = TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN ;               // Get the pointer into the Binary TOC stored in the Tree View
            W_TreeView_GetItem(m_hwndTree, &tvItem);
            pNode = (CTreeNode *)tvItem.lParam;

            if (pNode && pNode->GetURL(szTempURL, sizeof(szTempURL)) )
            {
                m_fSuspendSync = TRUE;
                if ( m_phhctrl )
                {
                    m_phhctrl->SendEvent( szTempURL );
                    return NULL;
                }
                UpdateTOCSlot(pNode);
                ChangeHtmlTopic(szTempURL, m_hwndTree);
                if (m_phh)
                {
                    m_phh->m_hwndControl = m_hwndTree;
                }
            }

            // The treeview does not automatically expand the node with the enter key.
            // so we do it here.
            if ( !g_fIE3 && pnmhdr->hdr.code == NM_RETURN && pNode->HasChildren() )
            {
                if ( tvItem.state & TVIS_EXPANDED )
                {
                    if (HandleExpanding(&tvItem, m_hwndTree,TVE_COLLAPSE , &m_fSuspendSync))
                        W_TreeView_Expand( m_hwndTree, tvItem.hItem, TVE_COLLAPSE );
                }
                else
                {
                    if (HandleExpanding(&tvItem, m_hwndTree,TVE_EXPAND , &m_fSuspendSync))
                        W_TreeView_Expand( m_hwndTree, tvItem.hItem, TVE_EXPAND );
                }
            }

            break;

        case TVN_SELCHANGING:
            m_hitemCurHighlight = pnmhdr->itemNew.hItem;
            break;

        case TVN_SELCHANGED:
            m_hitemCurHighlight = pnmhdr->itemNew.hItem;
            break;

        case NM_CLICK:
            /*
             * We want a single click to open a topic. We already process
             * the case where the selection changes, and we jump if it does.
             * However, the user may click an existing selection, in which
             * case we want to jump (because the jump may have failed when
             * the item was first selected. However, we need to post the
             * message so that the treeview control will finish processing
             * the click (which could result in a selection change.
             */

            if (!m_fSuppressJump)
            {
                TV_HITTESTINFO ht;
                GetCursorPos(&ht.pt);
                ASSERT(::IsValidWindow(m_hwndTree)) ;
                ScreenToClient(m_hwndTree, &ht.pt);

                W_TreeView_HitTest(m_hwndTree, &ht);
                if (ht.flags & TVHT_ONITEMBUTTON)
                    break; // just clicking the button, so ignore

                tvItem.hItem = ht.hItem;
                if (!tvItem.hItem)
                    break;          // probably ENTER with no selection

                tvItem.mask = TVIF_PARAM;               // Get the pointer into the Binary TOC stored in the Tree View
                W_TreeView_GetItem(m_hwndTree, &tvItem);
                pNode = (CTreeNode *)tvItem.lParam;

                if (pNode && pNode->GetURL(szTempURL, sizeof(szTempURL)) )
                {
                    m_fSuspendSync = TRUE;
                    if ( m_phhctrl )
                    {
                        m_phhctrl->SendEvent( szTempURL );
                        return NULL;
                    }
                    UpdateTOCSlot(pNode);
                    ChangeHtmlTopic(szTempURL, GetParent(m_hwndTree));
                    if (m_phh)
                    {
                        m_phh->m_hwndControl = m_hwndTree;
                    }
                }

#if 0
                W_TreeView_Select(m_hwndTree, ht.hItem, TVGN_CARET);
                tvItem.mask = TVIF_PARAM;       // Get the pointer into the binary TOC stored in the Tree View.
                W_TreeView_GetItem(m_hwndTree, &tvItem);
                // pSiteMapEntry = m_sitemap.GetSiteMapEntry(tvItem.lParam);
                PostMessage(FindMessageParent(m_hwndTree), WM_COMMAND, ID_TV_SINGLE_CLICK,
                    (LPARAM) W_TreeView_GetSelection(m_hwndTree));
#endif
            }
            break;

        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDINGW:
        {
            ASSERT(::IsValidWindow(m_hwndTree)) ;
            SendMessage(m_hwndTree, WM_SETREDRAW, FALSE, 0);
         TV_ITEMW * pitem = (TV_ITEMW *)&pnmhdr->itemNew;
            HandleExpanding(pitem, m_hwndTree, pnmhdr->action, &m_fSuspendSync);
        }
        break;

        case TVN_ITEMEXPANDEDA:
        case TVN_ITEMEXPANDEDW:
        {
            SendMessage(m_hwndTree, WM_SETREDRAW, TRUE, 0);
        }
        break;

        case TVN_KEYDOWN:
           TV_KEYDOWN* ptvkd;
           ptvkd = (TV_KEYDOWN*)pnmhdr;
           if ( ptvkd->wVKey != VK_F10 )
              break;
           else if ( GetKeyState(VK_SHIFT) >= 0 )
              break;
           else
           {
              ht.pt.x = ht.pt.y = 0;
              ClientToScreen(m_hwndTree, &ht.pt);
              goto sim_rclick;
           }
           break;

        case NM_RCLICK:
            {
               GetCursorPos(&ht.pt);
               ScreenToClient(m_hwndTree, &ht.pt);
               W_TreeView_HitTest(m_hwndTree, &ht);
               if ( ht.hItem )
                  W_TreeView_Select(m_hwndTree, ht.hItem, TVGN_CARET);
               ClientToScreen(m_hwndTree, &ht.pt);
sim_rclick:
               HMENU hmenu = CreatePopupMenu();
               if (!hmenu)
                  break;

               if (!(m_dwStyles & TVS_SINGLEEXPAND)) {
                    if (m_phh->m_phmData->m_pTitleCollection->IsSingleTitle())  // no expand all for collections
                       HxAppendMenu(hmenu, MF_STRING, ID_EXPAND_ALL, GetStringResource(IDS_EXPAND_ALL));
                   HxAppendMenu(hmenu, MF_STRING, ID_CONTRACT_ALL, GetStringResource(IDS_CONTRACT_ALL));
               }
               if (m_phh->m_pCIExpContainer)
			       HxAppendMenu(hmenu, MF_STRING, ID_PRINT, GetStringResource(IDS_PRINT));

               ASSERT( m_pInfoType );
                   // populate the InfoType member object of the CToc
               if ( !m_pInfoType )
               {
                   if (m_phh && m_phh->m_phmData && m_phh->m_phmData->m_pdInfoTypes  )
                   {       // load from the global IT store
                       m_pInfoType = new CInfoType;
                       m_pInfoType->CopyTo( m_phh->m_phmData );
                           // if there are info type bits set by the API assign them here
                       if ( m_phh->m_phmData->m_pAPIInfoTypes &&
                            m_pInfoType->AnyInfoTypes(m_phh->m_phmData->m_pAPIInfoTypes))
                       {
                           memcpy(m_pInfoType->m_pInfoTypes,
                               m_phh->m_phmData->m_pAPIInfoTypes,
                               m_pInfoType->InfoTypeSize() );
                       }
                   }else
                   {
                           // no global IT's; load from the .hhc IT store
                       m_pInfoType = new CInfoType;
                       *m_pInfoType = m_sitemap;
                   }

               }
               else
               {
                   // Set the infotypes bits to set all the types

               }
#if 0  // not in 1.1b
                   // If there are infotypes add the "customize" option to the popup menu
               if (m_pInfoType && m_pInfoType->HowManyInfoTypes() && m_pInfoType->GetFirstHidden() != 1)
                   HxAppendMenu(hmenu, MF_STRING, ID_CUSTOMIZE_INFO_TYPES, GetStringResource(IDS_CUSTOMIZE_INFO_TYPES));
#endif
               ASSERT(::IsValidWindow(m_hwndTree)) ;
			   if (NoRun() == FALSE)
			   {
               AppendMenu(hmenu, MF_SEPARATOR, 0, 0);
               HxAppendMenu(hmenu, MF_STRING, ID_JUMP_URL, GetStringResource(IDS_JUMP_URL));
			   }
               //  AppendMenu(hmenu, MF_STRING, ID_VIEW_ENTRY, pGetDllStringResource(IDS_VIEW_ENTRY));
#ifdef _DEBUG
               HxAppendMenu(hmenu, MF_STRING, ID_VIEW_MEMORY, "Debug: memory usage...");
#endif
               TrackPopupMenu(hmenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON,
                   ht.pt.x, ht.pt.y, 0, FindMessageParent(m_hwndTree), NULL);
               DestroyMenu(hmenu);
               return TRUE;
            }
            break;

        case NM_CUSTOMDRAW:
            return OnCustomDraw((LPNMTVCUSTOMDRAW) pnmhdr);
    }
    return FALSE;
}

void CToc::UpdateTOCSlot(CTreeNode* pNode)
{
   DWORD dwSlot = 0;
   CTreeNode* pTmpNode, *pTmpNode2;
   CExTitle* pTitle;
   //
   // What a damn hack I've had to put in below. Somehow I had to get a slot number for these nodes in order to get
   // topic centricity working 100% correctly. Should we ever decide to to the binary TOC UI code right we really
   // should only store slots in the tree control and we could do away with all the silly new and deletes on tree
   // nodes. oh well...
   //
   if (m_phh && m_phh->m_phmData && m_phh->m_phmData->m_pTitleCollection )
   {
      if ( (pTmpNode = m_phh->m_phmData->m_pTitleCollection->GetPrev(pNode)) )
      {
         if ( (pTmpNode2 = m_phh->m_phmData->m_pTitleCollection->GetNextTopicNode(pTmpNode, &dwSlot)) )
         {
            if ( dwSlot && pTmpNode2->GetObjType() == EXNODE)
            {
               if ( (pTitle =  ((CExNode*)pTmpNode2)->GetTitle()) )
                  m_phh->m_phmData->m_pTitleCollection->SetTopicSlot(dwSlot,((CExNode*)pTmpNode2)->m_Node.dwOffsTopic, pTitle);
            }
            delete pTmpNode2;
         }
         delete pTmpNode;
      }
   }
}

// Public class member called to refresh the TOC view.
//
void  CToc::Refresh(void)
{
   HTREEITEM hNode;
   TVITEMW   Tvi;

   if (! m_hwndTree )
      return;

   if ( m_fBinaryTOC )
   {
       //
       // First, free all the CTreeNodes...
       //
       hNode = W_TreeView_GetRoot(m_hwndTree);
       while ( hNode )
       {
          FreeChildrenAllocations(m_hwndTree, hNode);
          hNode = W_TreeView_GetNextSibling(m_hwndTree, hNode);
       }

       Tvi.hItem = hNode;
       Tvi.mask = TVIF_PARAM;
       if ( W_TreeView_GetItem(m_hwndTree, &Tvi) )
       {
           if ( Tvi.lParam )
               delete ((CTreeNode *)Tvi.lParam);
       }
       //
       // Second, delete the items (visual elements) from the CTreeControl
       //
       W_TreeView_DeleteAllItems(m_hwndTree);
       //
       // Lastly, reload the root.
       //
           LoadFirstLevel(m_pBinTOCRoot, m_hwndTree, &m_tiFirstVisible);
   }
   else
   {
        HWND hwndParent = GetParent(m_hwndTree);
        DestroyWindow(m_hwndTree);
        // Destroying the TreeView control, make sure we no longer point to it as a valid
        // subclassed window.
        if (NULL != lpfnlTreeViewWndProc)
        {
          lpfnlTreeViewWndProc = NULL;
        }
        Create(hwndParent);
        InitTreeView();
   }
}


// Helper function for adding the first level to a tree view.
void LoadFirstLevel( CTreeNode *pRoot, HWND hwndTreeView, HTREEITEM *m_tiFirstVisible )
{
CTreeNode *pTempNode = pRoot->GetFirstChild();

    ASSERT(::IsValidWindow(hwndTreeView)) ;

    CHourGlass wait;
    while (pTempNode != NULL )
    {
        *m_tiFirstVisible = AddNode(pTempNode, TVI_ROOT, hwndTreeView);
        pTempNode  = pTempNode->GetNextSibling();
    }
}


// Helper functions for adding all the children to a parent node in a tree view.
//

HTREEITEM AddTitleChildren(CTreeNode *pNode, HTREEITEM hParent, HWND hwndTreeView)
{
CTreeNode *pTempNode;
HTREEITEM hItem = NULL;

    CHourGlass wait;

   pTempNode = pNode->GetFirstChild();

    while (pTempNode != NULL )
    {
        hItem = AddNode(pTempNode,  hParent,  hwndTreeView);
        pTempNode  = pTempNode->GetNextSibling();
    }
    return hItem;
}

HTREEITEM AddNode(CTreeNode *pNode, HTREEITEM hParent, HWND hwndTreeView)
{
        if (pNode->GetObjType() == EXTITLENODE)
        {
            return AddTitleChildren(pNode, hParent, hwndTreeView);
        }

TV_INSERTSTRUCTW tcAdd;
unsigned uType;

        tcAdd.hInsertAfter                      = TVI_LAST;
        tcAdd.hParent                           =  hParent;

        uType = pNode->GetType();
        if ( uType == TOPIC )
            if (pNode->IsNew())
                tcAdd.item.iImage = tcAdd.item.iSelectedImage = 11;
            else
                tcAdd.item.iImage = tcAdd.item.iSelectedImage = 10;
        else if ( uType == CONTAINER )
             if (pNode->IsNew())
                tcAdd.item.iImage = tcAdd.item.iSelectedImage = 2;
             else
                tcAdd.item.iImage = tcAdd.item.iSelectedImage = 0;
        else
             if (pNode->IsNew())
                tcAdd.item.iImage = tcAdd.item.iSelectedImage = 2;
             else
                tcAdd.item.iImage = tcAdd.item.iSelectedImage = 0;

        tcAdd.item.hItem                        = NULL;
        tcAdd.item.lParam                       = (LONG_PTR)pNode;
        tcAdd.item.cChildren            = (pNode->HasChildren())?1:0;
        tcAdd.item.pszText = LPSTR_TEXTCALLBACKW;
        tcAdd.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM;
        return W_TreeView_InsertItem(hwndTreeView, &tcAdd);
}

void AddChildren( TVITEMW* pTvi, HWND hwndTreeView )
{
CTreeNode *pNode;
CTreeNode *pTempNode;
TV_ITEM tvItem;
HTREEITEM hItem;

    ASSERT(::IsValidWindow(hwndTreeView)) ;

   if (! (pNode = (CTreeNode*)pTvi->lParam) )
        return;
    tvItem.hItem = pTvi->hItem;
    if (!tvItem.hItem)
        return;

    CHourGlass wait;

   pTempNode = pNode->GetFirstChild();

    //      Before we add. Delete the dummy kid.
    //
    if ( (hItem = W_TreeView_GetChild(hwndTreeView, pTvi->hItem)) )
        W_TreeView_DeleteItem(hwndTreeView, hItem);

    while (pTempNode != NULL )
    {
        AddNode(pTempNode,  pTvi->hItem, hwndTreeView);
        pTempNode = pTempNode->GetNextSibling();
    }
}

void FreeChildrenAllocations(HWND hwndTreeView, HTREEITEM ti)
{
    HTREEITEM tiChild;
    CTreeNode *pCurNode;
    TV_ITEMW hCur;

    if ( IsValidWindow(hwndTreeView) )
    {
       while ((tiChild = W_TreeView_GetChild(hwndTreeView, ti)) != NULL)
       {
           ZeroMemory(&hCur, sizeof(TV_ITEM));
           hCur.hItem = tiChild;
           hCur.mask = TVIF_PARAM;

           if (W_TreeView_GetItem(hwndTreeView, &hCur) == FALSE)
                   continue;

           FreeChildrenAllocations(hwndTreeView, tiChild);

           if ((hCur.mask & TVIF_PARAM) &&hCur.lParam)
           {
               pCurNode = (CTreeNode *)hCur.lParam;
               delete pCurNode;
           }

           W_TreeView_DeleteItem(hwndTreeView, tiChild);
       }
    }
}

void DeleteChildren( TVITEMW* pTvi, HWND hwndTreeView )
{
   TV_INSERTSTRUCTW tcAdd;
    CHourGlass wait;

    ASSERT(::IsValidWindow(hwndTreeView)) ;

    FreeChildrenAllocations(hwndTreeView, pTvi->hItem);
    //
    //      After we've deleted, add the dummk kid back.
    //
    ZeroMemory(&tcAdd, sizeof(TV_INSERTSTRUCT));
    tcAdd.hInsertAfter = TVI_LAST;
    tcAdd.hParent = pTvi->hItem;
   W_TreeView_InsertItem(hwndTreeView, &tcAdd);
}

// This is the Contents Command Handler for the Binary TOC

LRESULT CToc::OnBinTOCContentsCommand(UINT id, UINT uNotifyCode, LPARAM lParam )
{
    ASSERT(::IsValidWindow(m_hwndTree)) ;
    switch (id)
    {
    case ID_EXPAND_ALL:
    {
        m_hitemCurHighlight = W_TreeView_GetSelection(m_hwndTree);

        CTreeNode*      pNode;
        TV_ITEMW        tvItem;
        HTREEITEM hNext;
        DWORD dwCurLevel = 0;
        HTREEITEM hParents[50];

        tvItem.hItem = W_TreeView_GetRoot(m_hwndTree);
        CHourGlass wait;

        while ( tvItem.hItem)
        {
             tvItem.mask = TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN ;               // Get the pointer into the Binary TOC stored in the Tree View
            W_TreeView_GetItem(m_hwndTree, &tvItem);
            pNode = (CTreeNode *)tvItem.lParam;

            if (pNode->HasChildren() == FALSE)
                goto GetNext;
            if (pNode->m_Expanded == TRUE)
                goto GetNext;

            pNode->m_Expanded = TRUE;
            AddChildren(&tvItem, m_hwndTree);        // Add the items below the expanding parent
            W_TreeView_Expand( m_hwndTree, tvItem.hItem, TVE_EXPAND );
            // Set the correct image for the expanding/contracting node
            tvItem.iImage++;
            tvItem.iSelectedImage++;
            tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
            W_TreeView_SetItem(m_hwndTree, &tvItem);
GetNext:
            if (hNext = W_TreeView_GetChild(m_hwndTree, tvItem.hItem))
            {
                hParents[dwCurLevel] = tvItem.hItem;
                tvItem.hItem = hNext;
                dwCurLevel++;
            }
            else if (hNext = W_TreeView_GetNextSibling(m_hwndTree, tvItem.hItem))
                tvItem.hItem = hNext;
            else
            {
                // go up the parent tree
                while (TRUE)
                {
                    dwCurLevel--;
                    if (dwCurLevel == -1)
                    {
                        tvItem.hItem = NULL;
                        break;
                    }
                    else
                    {
                        if (hNext = W_TreeView_GetNextSibling(m_hwndTree, hParents[dwCurLevel]))
                        {
                            tvItem.hItem = hNext;
                            break;
                        }
                    }
                }
            }
        }


        if (m_hitemCurHighlight)
        {
            m_fSuppressJump = TRUE;
            W_TreeView_Select(m_hwndTree, m_hitemCurHighlight,
                TVGN_FIRSTVISIBLE);
            W_TreeView_SelectItem(m_hwndTree, m_hitemCurHighlight);
            m_fSuppressJump = FALSE;
        }
    }
    return 0;

    case ID_CONTRACT_ALL:
        {
            CHourGlass wait;

            SendMessage(m_hwndTree, WM_SETREDRAW, FALSE, 0);
            CTreeNode*      pNode;
            TV_ITEMW        tvItem;
            HTREEITEM hNext;
            tvItem.hItem = m_hitemCurHighlight = W_TreeView_GetRoot(m_hwndTree);
            while ( tvItem.hItem)
            {
                 tvItem.mask = TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN ;               // Get the pointer into the Binary TOC stored in the Tree View
                W_TreeView_GetItem(m_hwndTree, &tvItem);
                pNode = (CTreeNode *)tvItem.lParam;

                if (pNode->HasChildren() == FALSE)
                    goto GetNextSibling;
                if (pNode->m_Expanded == FALSE)
                    goto GetNextSibling;

                pNode->m_Expanded = FALSE;
                DeleteChildren(&tvItem, m_hwndTree);
                W_TreeView_Expand( m_hwndTree, tvItem.hItem, TVE_COLLAPSE );
                // Set the correct image for the expanding/contracting node
                tvItem.iImage--;
                tvItem.iSelectedImage--;
                tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                W_TreeView_SetItem(m_hwndTree, &tvItem);
GetNextSibling:
                 if (hNext = W_TreeView_GetNextSibling(m_hwndTree, tvItem.hItem))
                    tvItem.hItem = hNext;
                else
                    tvItem.hItem = NULL;
            }

            if (m_hitemCurHighlight)
            {
                m_fSuppressJump = TRUE;
                W_TreeView_Select(m_hwndTree, m_hitemCurHighlight,
                    TVGN_FIRSTVISIBLE);
                W_TreeView_SelectItem(m_hwndTree, m_hitemCurHighlight);
                m_fSuppressJump = FALSE;
            }
            m_fHack = FALSE;        // process expansion/contraction normally
        }
            SendMessage(m_hwndTree, WM_SETREDRAW, TRUE, 0);
            return 0;

#if 1
        case ID_CUSTOMIZE_INFO_TYPES:
            {
                if (m_phh->m_phmData->m_pTitleCollection->m_pSubSets->GetTocSubset())
                    m_phh->m_phmData->m_pTitleCollection->m_pSubSets->m_cur_Set = m_phh->m_phmData->m_pTitleCollection->m_pSubSets->GetTocSubset();  // set this so the wizard knows which subset to load the combo box with.
#if 0
                if (ChooseInformationTypes(m_pInfoType, &(this->m_sitemap), m_hwndTree, m_phhctrl, m_phh)) {
#else
                if (ChooseInformationTypes(m_pInfoType, &(this->m_sitemap), m_hwndTree, m_phhctrl)) {
#endif
                    if (m_phh)
                        m_phh->UpdateInformationTypes();
                    else {
                        HWND hwndParent = GetParent(m_hwndTree);
                        DestroyWindow(m_hwndTree);
                        // Destroying the TreeView control, make sure we no longer point to it as a valid
                        // subclassed window.
                        if (NULL != lpfnlTreeViewWndProc)
                        {
                          lpfnlTreeViewWndProc = NULL;
                        }
                        Create(hwndParent);
                        InitTreeView();
                    }
                }
            }
            break;
#endif
#ifndef CHIINDEX
       case ID_PRINT:
            {
                TV_ITEM tvi;

                tvi.hItem = W_TreeView_GetSelection(m_hwndTree);
                if (!tvi.hItem)
                    return 0;          // no current selection

                if (m_phh) {
                    if (m_phh->OnTrackNotifyCaller(HHACT_PRINT))
                       break;
                    m_phh->OnPrint();
                    break;
                }
                CPrint prt(GetParent(m_hwndTree));
                prt.SetAction(PRINT_CUR_HEADING);
                if (!prt.DoModal())
                    break;
                int action = prt.GetAction();

                ASSERT(m_phhctrl);
                PrintTopics(action, this,
                    m_phhctrl->m_pWebBrowserApp, m_phhctrl->m_hwndHelp);
            }
            return 0;
#endif
#if 0
        case ID_VIEW_ENTRY:
            {
                TV_ITEM tvi;

                tvi.hItem = W_TreeView_GetSelection(m_hwndTree);
                if (!tvi.hItem)
                    return 0;          // no current selection

                tvi.mask = TVIF_PARAM;
                W_TreeView_GetItem(m_hwndTree, &tvi);
                SITEMAP_ENTRY* pSiteMapEntry = m_sitemap.GetSiteMapEntry(tvi.lParam);
                DisplayAuthorInfo(&(this->m_sitemap), pSiteMapEntry, FindMessageParent(m_hwndTree), m_phhctrl);
            }
            return 0;
#endif

        case ID_JUMP_URL:
            {
                char szDstUrl[INTERNET_MAX_URL_LENGTH];
                CStr cszCurUrl;
                if (m_phhctrl)
                    m_phhctrl->m_pWebBrowserApp->GetLocationURL(&cszCurUrl);
                else
                    m_phh->m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL(&cszCurUrl);
                if (doJumpUrl(GetParent(m_hwndTree), cszCurUrl, szDstUrl)) {
                    if (m_phhctrl) {
                        CWStr cwJump(szDstUrl);
                        HlinkSimpleNavigateToString(cwJump, NULL,
                            NULL, m_phhctrl->GetIUnknown(), NULL, NULL, 0, NULL);
                    }
                    else {
                        ChangeHtmlTopic(szDstUrl, GetParent(m_hwndTree));
                    }
                }
            }
            break;

#ifdef _DEBUG
        case ID_VIEW_MEMORY:
            OnReportMemoryUsage();
            return 0;
#endif

#if 0
        case ID_TV_SINGLE_CLICK:
            {
                TV_ITEM tvi;
                tvi.mask = TVIF_PARAM;
                tvi.hItem = m_hitemCurHighlight;
                W_TreeView_GetItem(m_hwndTree, &tvi);
                SITEMAP_ENTRY* pSiteMapEntry = m_sitemap.GetSiteMapEntry(tvi.lParam);
    //                              if (pSiteMapEntry->fShortCut) {

                if (pSiteMapEntry->pUrls) {
                    m_fIgnoreNextSelChange = TRUE;
                    m_fSuspendSync = TRUE;
                    if (pSiteMapEntry->fSendEvent && m_phhctrl)
                        m_phhctrl->SendEvent(m_sitemap.GetUrlString(pSiteMapEntry->pUrls->urlPrimary));
                    else {
                        SaveCurUrl();   // so we can restore our state
                        JumpToUrl(m_pOuter, m_hwndTree, pSiteMapEntry, &(this->m_sitemap), NULL);
                    }
                    if (m_phh)
                    {
                        m_phh->m_hwndControl = m_hwndTree;
                    }
                }
            }
            break;
#endif
    }
    return 0;
}

///////////////////////////////////////////////////////////
//
// INavUI Interface Implementation
//
///////////////////////////////////////////////////////////
//
// OnNotify
//
LRESULT
CToc::OnNotify(HWND /*hwnd*/, WPARAM /*wParam*/, LPARAM lParam)
{
    if (::IsValidWindow(m_hwndTree))
    {
#ifdef _DEBUG
        BOOL f = TreeView_GetUnicodeFormat(m_hwndTree);
#endif
        TreeViewMsg((NM_TREEVIEW*) lParam);
    }

    return 1;
}

///////////////////////////////////////////////////////////
//
// SetDefaultFocus
//
void
CToc::SetDefaultFocus()
{
    if (::IsValidWindow(m_hwndTree))
    {
        if (m_fSyncOnActivation) // Move this to the new activation function.
        {
            //PostMessage(GetParent(GetParent(m_hwndTree)), WM_COMMAND, IDTB_SYNC, 0); // Verify: This was a post message.
            // HH Bug 2160: Sending the IDTB_SYNC message causes the TOC tab to get selected.
            // We don't want to select the TOC tab, but mark this thing as needing to be sync'ed.
            if (m_phh && m_phh->m_pCIExpContainer && m_phh->m_pCIExpContainer->m_pWebBrowserApp)
            {
                CStr cszUrl;
                m_phh->m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL(&cszUrl);
                if (!cszUrl.IsEmpty())
                {
                    m_fSyncOnActivation = FALSE;
                    Synchronize(cszUrl);
                }
            }
        }
        SetFocus(m_hwndTree );
    }
}

///////////////////////////////////////////////////////////
//
//                  Other Classes
//
///////////////////////////////////////////////////////////
//
// CJumpUrl
//
class CJumpUrl : public CDlg
{
public:
    CJumpUrl(HWND hwndParent, PCSTR pszCurUrl) : CDlg(hwndParent, IDDLG_JUMP_URL) {
        m_pszCurUrl = pszCurUrl;
    }
    BOOL OnBeginOrEnd();
    void OnEditChange(UINT id);

    PCSTR m_pszCurUrl;
    CStr  m_cszJumpUrl;
};

BOOL doJumpUrl(HWND hwndParent, PCSTR pszCurUrl, PSTR pszDstUrl)
{
    CJumpUrl jump(hwndParent, pszCurUrl);
    if (jump.DoModal()) {
        strcpy(pszDstUrl, jump.m_cszJumpUrl);
        return TRUE;
    }
    else
        return FALSE;
}

void CJumpUrl::OnEditChange(UINT id)
{
    if (id == IDEDIT_JUMP_URL)
    {
        m_cszJumpUrl.GetText(*this, IDEDIT_JUMP_URL);
        if (m_cszJumpUrl.psz[0])
        {
            EnableWindow(IDOK, TRUE);
        }
        else
        {
            EnableWindow(IDOK, FALSE);
        }
    }
}
BOOL CJumpUrl::OnBeginOrEnd()
{
    if (m_fInitializing) {
        SetWindowText(IDEDIT_CUR_URL, m_pszCurUrl);
        SendMessage(IDEDIT_JUMP_URL, WM_SETFONT, (WPARAM)_Resource.GetUIFont(), 0);
        EnableWindow(IDOK, FALSE);
    }
    else {
        m_cszJumpUrl.GetText(*this, IDEDIT_JUMP_URL);
        if (!StrChr(m_cszJumpUrl, CH_COLON) && m_pszCurUrl && strstr(m_pszCurUrl, "::")) {
            CStr csz(m_pszCurUrl);
            PSTR psz = strstr(csz, "::");
            ASSERT(psz);
            psz += 2;
            *psz = '\0';
            if (m_cszJumpUrl.psz[0] != CH_FORWARDSLASH && m_cszJumpUrl.psz[0] != CH_BACKSLASH)
                csz += "/";
            csz += m_cszJumpUrl.psz;
            m_cszJumpUrl = csz.psz;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\contain.cpp ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

#include "header.h"
#include "contain.h"
#include "autocont.h"
#include "htmlpriv.h"
#include "htmlhelp.h"
#include "strtable.h"
#include <exdisp.h>
#include "unicode.h"

static const WCHAR gszHHRegKey[] = L"Software\\Microsoft\\HtmlHelp";

// pointer to external IServiceProvider (fix for HelpCenter)
//
IServiceProvider *g_pExternalHostServiceProvider = NULL; 

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

/*
 * CContainer::CContainer
 * CContainer::~CContainer
 *
 * Constructor Parameters:
 */
CContainer::CContainer()
{
   m_cRef = 0;
   m_pIStorage = NULL;
   m_pOleObject = NULL;
   m_pIAdviseSink = NULL;
   m_pIOleInPlaceSite = NULL;
   m_pIOleClientSite = NULL;
   m_pIOleInPlaceFrame = NULL;
   m_pIOleControlSite = NULL;
   m_pWebBrowser = NULL;
   m_pWebBrowserApp = NULL;
   m_pIDispatch = NULL;
   m_pIOleItemContainer = NULL;
   // m_pCallback = NULL;
   m_pIE3CmdTarget = NULL;
   m_dwEventCookie = 0;
   m_pWebBrowserEvents = NULL;
   m_pCDocHostUIHandler = NULL;
   m_pCDocHostShowUI = NULL;
   m_pInPlaceActive = 0;

#ifdef _DEBUG
   m_fDeleting = FALSE;
#endif
}

CContainer::~CContainer(void)
{
#ifdef _DEBUG
   ASSERT(!m_fDeleting)
   m_fDeleting = TRUE;
#endif

//   if (m_pInPlaceActive)
//       m_pInPlaceActive->Release();

   // do this before we release m_pIAdviseSink
   // Reset the View Advise
   LPVIEWOBJECT2 lpViewObject2;
   if (m_pOleObject && SUCCEEDED(m_pOleObject->QueryInterface(IID_IViewObject2, (LPVOID FAR *) &lpViewObject2))) {
      lpViewObject2->SetAdvise(DVASPECT_CONTENT, ADVF_PRIMEFIRST, NULL );
      lpViewObject2->Release();
   }

   if (m_pIAdviseSink)
      m_pIAdviseSink->Release();

   if (m_pIOleInPlaceSite)
      m_pIOleInPlaceSite->Release();

   if (m_pIOleClientSite)
      m_pIOleClientSite->Release();

   if (m_pIOleInPlaceFrame)
      m_pIOleInPlaceFrame->Release();

   if (m_pIOleItemContainer)
      m_pIOleItemContainer->Release();

   if (m_pIOleControlSite)
     delete m_pIOleControlSite;

//   if (m_pIPropNoteSink)
//     delete m_pIPropNoteSink;

   if (m_pIE3CmdTarget)
      m_pIE3CmdTarget->Release();

   if ( m_pCDocHostUIHandler )
      m_pCDocHostUIHandler->Release();

   if ( m_pCDocHostShowUI )
      m_pCDocHostShowUI->Release();

   if (m_pWebBrowserApp) {
      m_pWebBrowserApp->Quit();
      delete m_pWebBrowserApp;
   }

   if (m_pIStorage)
      m_pIStorage->Release();
   if (m_pOleObject)
      m_pOleObject->Release();

   return;
}

HRESULT CContainer::ShutDown(void)
{
   if (m_pIDispatch)
   {
      // Unhook event interface, delete our interface object
      //
      LPCONNECTIONPOINTCONTAINER pCPC;
      if (SUCCEEDED(m_pOleObject->QueryInterface(IID_IConnectionPointContainer, (void **) &pCPC)))
      {
         LPCONNECTIONPOINT pCP;
         if (SUCCEEDED(pCPC->FindConnectionPoint(IID_IDispatch, &pCP)))
         {
            pCP->Unadvise(m_dwEventCookie);
            pCP->Release();
         }

         // Cleanup
         pCPC->Release() ;
      }

      // Cleanup m_pIDispatch pointer
      m_pIDispatch->Release();
      m_pIDispatch = NULL;  // part of fix for 4373
   }
   if(m_pOleObject)
   {
      m_pOleObject->Close(OLECLOSE_NOSAVE);
      m_pOleObject->SetClientSite(NULL);
   }

   delete this;
   return S_OK;
}

/*
 * CContainer::QueryInterface
 *
 * Purpose:
 * IUnknown members for CContainer object.
 */
STDMETHODIMP CContainer::QueryInterface(REFIID riid, LPVOID * ppv)
{
#ifdef DEBUG
   char sz[256];

   wsprintf(sz,"CContainer::QueryInterface('{%8.8X-%4.4X-%4.4X-%2.2X%2.2X-%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X}',...);\r\n",
       riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1],
         riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6],riid.Data4[7]);

   OutputDebugString(sz);
#endif

   *ppv=NULL;

   if ((IID_IUnknown == riid) || (IID_IServiceProvider == riid))
      *ppv = this;

   else if (IID_IOleClientSite == riid)
      *ppv = m_pIOleClientSite;

   else if (IID_IAdviseSink2==riid || IID_IAdviseSink==riid)
      *ppv = m_pIAdviseSink;

   else if (IID_IOleWindow==riid || IID_IOleInPlaceSite==riid)
      *ppv = m_pIOleInPlaceSite;

   else if (IID_IOleItemContainer == riid || IID_IOleContainer == riid || IID_IParseDisplayName == riid)
       *ppv = m_pIOleItemContainer;

   else if (riid == DIID_DWebBrowserEvents) {
      DBWIN("QueryInterface for DIID_DWebBrowserEvents");
      *ppv = (LPDISPATCH)m_pIDispatch;
   }
   else if (riid == DIID_DWebBrowserEvents2) {
      DBWIN("QueryInterface for DIID_DWebBrowserEvents2");
      *ppv = (LPDISPATCH)m_pIDispatch;
   }
   else if (IID_IOleControlSite==riid)
   {
      DBWIN("QueryInterface for IID_IOleControlSite");
      *ppv=m_pIOleControlSite;
   }
   else if ( riid == IID_IDocHostUIHandler )
   {
      DBWIN("QueryInterface for IID_IDocHostUIHandler");
      *ppv = m_pCDocHostUIHandler;
   }
   else if ( riid == IID_IDocHostShowUI )
   {
      DBWIN("QueryInterface for IID_IDocHostShowUI");
      *ppv = m_pCDocHostShowUI;
   }

   // BUGBUG what to do about this ?

   // Queries for IDispatch return the ambient properties interface *ppv=m_pIDispatch;
   else if (IID_IDispatch==riid)
   {
      DBWIN("QueryInterface for IID_IDispatch");
      *ppv = (IDispatch*)m_pIDispatch;
   }

   //End CONTROLMOD
   if (*ppv)
   {
      ((LPUNKNOWN)*ppv)->AddRef();
      return NOERROR;
   }

   return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP CContainer::QueryService(REFGUID rsid, REFIID riid, void ** pv)
{
  HRESULT hr = E_NOINTERFACE;

  // Hack for HelpCenter... 
  if (g_pExternalHostServiceProvider)
  {
     hr = g_pExternalHostServiceProvider->QueryService(rsid, riid, pv);
  }

  return hr;
}

STDMETHODIMP_(ULONG) CContainer::AddRef(void)
{
   return ++m_cRef;
}

STDMETHODIMP_(ULONG) CContainer::Release(void)
{
   ULONG cRefT = --m_cRef;

// we only delete when specifically told to
// if (m_cRef == 0)
//    delete this;

   return cRefT;
}

HRESULT CContainer::Create(HWND hWnd, LPRECT lpRect, BOOL bInstallEventSink)
{
   LPUNKNOWN      pObj;
   CLSID clsidWB1 = { 0xeab22ac3, 0x30c1, 0x11cf, { 0xa7, 0xeb, 0x0, 0x0, 0xc0, 0x5b, 0xae, 0xb } };
   CLSID clsidWB2 = { 0x8856f961, 0x340a, 0x11d0, { 0xa9, 0x6b, 0x0, 0xc0, 0x4f, 0xd7, 0x5, 0xa2 } };
   UINT           uRet = (UINT) E_FAIL;
   HRESULT hr;

   m_hWnd = hWnd;

   // Create storage, use OLE's temporary compound file support. (ie NULL as first arg.)

   if ((hr = StgCreateDocfile(NULL, (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE),
                    0, &m_pIStorage)) != S_OK) {
      DEBUG_ReportOleError(hr);
      return E_FAIL;
   }

   // Create the client site.

   m_pIOleClientSite = new CIOleClientSite(this);
   m_pIOleClientSite->AddRef();

   // Create the control site.

   m_pIOleControlSite = new CIOleControlSite(this);
   m_pIOleControlSite->AddRef();

   // Create the advise sink.

   m_pIAdviseSink = new CIAdviseSink(this);
   m_pIAdviseSink->AddRef();

   // Create the InPlaceSite.

   m_pIOleInPlaceSite = new CIOleInPlaceSite(this);
   m_pIOleInPlaceSite->AddRef();

   // Create the InPlaceFrame;

   m_pIOleInPlaceFrame = new CIOleInPlaceFrame(this);
   m_pIOleInPlaceFrame->AddRef();

   //
   // We don't install a sink for the special printing instance. HtmlHelp bug 5550.
   //
   if ( bInstallEventSink )
   {
      m_pIDispatch = new CAutomateContent(this);
      m_pIDispatch->AddRef();
   }

   m_pIOleItemContainer = new CIOleItemContainer(this);
   m_pIOleItemContainer->AddRef();

   /*
    * The OLE Control specifications mention that a a control might
    * implement IPersistStreamInit instead of IPersistStorage. In that
    * case you cannot use OleCreate on a control but must rather use
    * CoCreateInstance since OleCreate assumes that IPersistStorage is
    * available. With a control, you would have to create the object
    * first, then check if OLEMISC_SETCLIENTSITEFIRST is set, then send it
    * your IOleClientSite first. Then you check for IPersistStorage and
    * failing that, try IPersistStreamInit.

    * In this sample we do none of this and just assume controls are
    * normal embedded objects because there are questions as to dealing
    * with loading and initialization that are not resolved.
    */

   // These are IE4 specific.
   //
   m_pCDocHostUIHandler = new CDocHostUIHandler(this);
   m_pCDocHostUIHandler->AddRef();

   m_pCDocHostShowUI = new CDocHostShowUI(this);
   m_pCDocHostShowUI->AddRef();


   // first try for the IE4 object, if that fails, try for the IE3 object.
   //
   if ((hr = OleCreate(clsidWB2, IID_IOleObject, OLERENDER_NONE, NULL, m_pIOleClientSite, m_pIStorage, (void**)&pObj)) != S_OK )
   {
      if ((hr = OleCreate(clsidWB1, IID_IOleObject, OLERENDER_NONE, NULL, m_pIOleClientSite, m_pIStorage, (void**)&pObj)) != S_OK )
      {
         m_pIStorage->Release();
         m_pIOleClientSite->Release();
         return hr;
      }
      m_bIE4 = FALSE;
   }
   else
      m_bIE4 = TRUE;

   if ((hr = pObj->QueryInterface(IID_IOleObject, (void **) &m_pOleObject)) == S_OK) {
      LPVIEWOBJECT2 lpViewObject2;

      // Set a View Advise
      if (SUCCEEDED(m_pOleObject->QueryInterface(IID_IViewObject2, (LPVOID FAR *) &lpViewObject2))) {
         lpViewObject2->SetAdvise(DVASPECT_CONTENT, ADVF_PRIMEFIRST, m_pIAdviseSink);
         lpViewObject2->Release();
      }

      // 13-Oct-1997 [ralphw] Shouldn't need this...
      // m_pOleObject->SetHostNames(OLESTR("DevIV Package"), OLESTR("DevIV Container"));

      // inform object handler/DLL object that it is used in the embedding container's context

      OleSetContainedObject(m_pOleObject, TRUE);

      // Hook iDispatch up to COleDispatchDriver interface.

      LPDISPATCH pDispatch;

      if ((hr = m_pOleObject->QueryInterface(IID_IDispatch, (void **) &pDispatch)) == S_OK) {
         m_pWebBrowserApp = new IWebBrowserAppImpl(pDispatch);
      }

      //
      // We don't install a sink for the special printing instance. HtmlHelp bug 5550.
      //
      if ( bInstallEventSink )
      {
         // Hook event interface.

         LPCONNECTIONPOINTCONTAINER pCPC;
         if (SUCCEEDED(hr = m_pOleObject->QueryInterface(IID_IConnectionPointContainer, (void **) &pCPC)))
         {
            LPCONNECTIONPOINT pCP;
            if (SUCCEEDED(pCPC->FindConnectionPoint(DIID_DWebBrowserEvents2, &pCP))) {
               pCP->Advise((IDispatch*)m_pIDispatch, &m_dwEventCookie);
               pCP->Release();
            }
            else
            if (SUCCEEDED(pCPC->FindConnectionPoint(DIID_DWebBrowserEvents, &pCP))) {
               pCP->Advise((IDispatch*)m_pIDispatch, &m_dwEventCookie);
               pCP->Release();
                }

            pCPC->Release();
         }
      }

      // Let's get an interface pointer to IOleCommandTarget

      hr = m_pOleObject->QueryInterface(IID_IOleCommandTarget, (void **)&m_pIE3CmdTarget);
      if (FAILED(hr))
         m_pIE3CmdTarget = NULL;

      // Show the control.
      m_pOleObject->DoVerb(OLEIVERB_SHOW, NULL, m_pIOleClientSite, -1, m_hWnd, lpRect);
      uRet = S_OK;
   }


   pObj->Release(); // always release this ?


   if (uRet != S_OK) {
      m_pIStorage->Release();
      m_pIOleClientSite->Release();
      return uRet;
   }

   return uRet;
}

//
// Called when the window containing IE is losing activation (focus).
//
void CContainer::UIDeactivateIE()
{
   IOleInPlaceObject* pIOleInPlaceObject;
   HRESULT hr;

   if ( SUCCEEDED((hr = m_pOleObject->QueryInterface(IID_IOleInPlaceObject, (void**)&pIOleInPlaceObject))) )
   {
      pIOleInPlaceObject->UIDeactivate();
      pIOleInPlaceObject->Release();
   }
}

void CContainer::SetFocus(BOOL bForceActivation)
{
   HWND hwnd_child;
   TCHAR szClassName[150];

   if (! m_pInPlaceActive || bForceActivation )
      m_pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_pIOleClientSite, -1, m_hWnd, NULL);

   m_hwndChild = m_hWnd;
   while ((hwnd_child = GetWindow(m_hwndChild, GW_CHILD)) && IsWindowEnabled(hwnd_child) )
   {
      m_hwndChild = hwnd_child;
      GetClassName(hwnd_child, szClassName, sizeof(szClassName));
      if ( strstr(szClassName, "Internet Explorer") )
         break;
   }
   if ( hwnd_child && !IsWindowEnabled(hwnd_child) )
      m_hwndChild = GetParent(m_hwndChild);

   ::SetFocus(m_hwndChild);
}

//
// This needs to be called from the apps message pump to give shdocvw a crack at accelerators
// it implements. For example ^C for copy selected text.
//
// This function will return TRUE if shdocvw traslated the message and FALSE if it did not.
// Note that you can run into trouble if the app and shdocvw share acclerators. We'll want to
// always call TranslateAccelartor() from the message pump for the apps accelators and only if
// it returns false will we call this function to give IE a crack at the message.
//
// mikecole
//
unsigned CContainer::TranslateMessage(MSG * pMsg)
{
    if (m_pInPlaceActive)
    {
        if ( pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_F1 )
           return TAMSG_NOT_IE_ACCEL;

        if (pMsg->message == WM_KEYDOWN)
        {
            if (GetKeyState(VK_CONTROL))
            {
                    if (pMsg->wParam == 0x4F ||
                        pMsg->wParam == 0x4C ||
                        pMsg->wParam == 0x4E)
                        return TAMSG_NOT_IE_ACCEL;
            }
        }


        if (m_pInPlaceActive->TranslateAccelerator(pMsg) == S_OK)
            return TAMSG_IE_ACCEL;
        else
        {
           if ( (pMsg->message == WM_KEYDOWN) && (pMsg->wParam == VK_TAB) )
           {
            if ( IsUIActive() && !m_bIE4)
            {     // translateAccelerator does not work for the tab key in IE3,
                  // so forward the VK_TAB key message to IE3
               ForwardMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
               return TAMSG_IE_ACCEL;
            }
              UIDeactivateIE();
              SetFocus();
           }
        }
    }
    return TAMSG_NOT_IE_ACCEL;
}

LRESULT CContainer::ForwardMessage(UINT msg, WPARAM wParam, LPARAM lParam)
{
   HWND hwnd_child;
   HWND hwnd = m_hWnd;

   while ( (hwnd_child = GetWindow(hwnd, GW_CHILD)) && IsWindowEnabled(hwnd_child) )
      hwnd = hwnd_child;

   if ( hwnd_child && !IsWindowEnabled(hwnd_child) )
      hwnd = GetParent(hwnd);

   if (hwnd)
      return ::SendMessage(hwnd, msg, wParam, lParam);
   else
      return 0;
}

void CContainer::SizeIt(int width, int height)
{
   IOleInPlaceObject* pIOleInPlaceObject;

   if ( m_bIE4 )
   {
      if ( SUCCEEDED((m_pOleObject->QueryInterface(IID_IOleInPlaceObject, (void**)&pIOleInPlaceObject))) )
      {
         RECT rc;
         rc.left = rc.top = 0;
         rc.bottom = height;
         rc.right = width;
         pIOleInPlaceObject->SetObjectRects(&rc,&rc);
         pIOleInPlaceObject->Release();
      }
   }
   else
   {
      SIZEL sizel;
      sizel.cx = width;
      sizel.cy = height;

      HDC hdc = GetDC(NULL);
      SetMapMode(hdc, MM_HIMETRIC);
      DPtoLP(hdc, (LPPOINT) &sizel, 1);
      ReleaseDC(NULL, hdc);
      sizel.cy = abs(sizel.cy);

      m_pOleObject->SetExtent(DVASPECT_CONTENT, &sizel);
   }
}

/**************************************************************************************

 * AdviseSink code
 *
 *
 * CIAdviseSink implementation begins here!
 *
 **************************************************************************************/

/*
 * CIAdviseSink::CIAdviseSink
 * CIAdviseSink::~CIAdviseSink
 *
 * Parameters (Constructor):
 * pCContainer    pCContainer of the Container we're in.
 * pUnkOuter      LPUNKNOWN to which we delegate.
 */
CIAdviseSink::CIAdviseSink(PCONTAINER pCContainer)
{
   m_cRef=0;
   m_pUnkOuter = m_pContainer = pCContainer;
   return;
}

CIAdviseSink::~CIAdviseSink(void)
{
   return;
}

/*
 * CIAdviseSink::QueryInterface
 * CIAdviseSink::AddRef
 * CIAdviseSink::Release
 *
 * Purpose:
 * IUnknown members for CIAdviseSink object.
 */
STDMETHODIMP CIAdviseSink::QueryInterface(REFIID riid, LPVOID * ppv)
{
   return m_pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) CIAdviseSink::AddRef(void)
{
   m_pUnkOuter->AddRef();
   return ++m_cRef;
}

STDMETHODIMP_(ULONG) CIAdviseSink::Release(void)
{
   ULONG ul = --m_cRef;

   m_pUnkOuter->Release();
   if (ul <= 0)
      delete this;

   return ul;
}

/*
 * CIAdviseSink::OnDataChange
 *
 * Unused since we don't IDataObject::Advise.
 */
STDMETHODIMP_(void) CIAdviseSink::OnDataChange(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
   return;
}

/*
 * CIAdviseSink::OnViewChange
 *
 * Purpose:
 * Notifes the advise sink that presentation data changed in the
 * data object to which we're connected providing the right time
 * to update displays using such presentations.
 *
 * Parameters:
 * dwAspect    DWORD indicating which aspect has changed.
 * lindex         LONG indicating the piece that changed.
 *
 * Return Value:
 * None
 */
STDMETHODIMP_(void) CIAdviseSink::OnViewChange(DWORD dwAspect, LONG lindex)
{
   //Repaint only if this is the right aspect
   //m_pContainer->Repaint();

   return;
}

/*
 * CIAdviseSink::OnRename
 *
 * Purpose:
 * Informs the advise sink that a linked object has been renamed.
 * Generally only the OLE default handler cares about this.
 *
 * Parameters:
 * pmk         LPMONIKER providing the new name of the object
 *
 * Return Value:
 * None
 */
STDMETHODIMP_(void) CIAdviseSink::OnRename(LPMONIKER pmk)
{
   /*
    * As a container this is unimportant to us since it really
    * tells the handler's implementation of IOleLink that the
    * object's moniker has changed.  Since we get this call
    * from the handler, we don't have to do anything ourselves.
    */
   return;
}

/*
 * CIAdviseSink::OnSave
 *
 * Purpose:
 * Informs the advise sink that the OLE object has been saved
 * persistently.  The primary purpose of this is for containers
 * that want to make optimizations for objects that are not in a
 * saved state, so on this you have to disable such optimizations.
 *
 * Parameters:
 * None
 *
 * Return Value:
 * None
 */
STDMETHODIMP_(void) CIAdviseSink::OnSave(void)
{
   /*
    * A Container has nothing to do here as this notification is
    * only useful when we have an ADVFCACHE_ONSAVE advise set up,
    * which we don't.  So we ignore it.
    */
   return;
}

/*
 * CIAdviseSink::OnClose
 *
 * Purpose:
 * Informs the advise sink that the OLE object has closed and is
 * no longer bound in any way.
 *
 * Parameters:
 * None
 *
 * Return Value:
 * None
 */
STDMETHODIMP_(void) CIAdviseSink::OnClose(void)
{
   /*
    * This doesn't have anything to do with us again as it's only
    * used to notify the handler's IOleLink implementation of the
    * change in the object.  We don't have to do anything since
    * we'll also get an IOleClientSite::OnShowWindow(FALSE) to
    * tell us to repaint.
    */
   return;
}

/*
 * CIAdviseSink2::OnLinkSrcChange
 *
 * Purpose:
 * Informs the advise sink that a linked compound document object
 * has changed its link source to the object identified by the
 * given moniker. This is generally only of interest to the OLE
 * default handler's implementation of linked objects.
 *
 * Parameters:
 * pmk         LPMONIKER specifying the new link source.
 *
 * Return Value:
 * None
 */
STDMETHODIMP_(void) CIAdviseSink::OnLinkSrcChange(LPMONIKER pmk)
{
   return;
}

/**************************************************************************************
 *
 * ClientSite code
 *
 *
 * CIOleClientSite implementation begins here!
 *
 **************************************************************************************/

/*
 * CIOleClientSite::CIOleClientSite
 * CIOleClientSite::~CIOleClientSite
 *
 * Parameters (Constructor):
 * pCContainer    PCContainer of the container we're in.
 * pUnkOuter      LPUNKNOWN to which we delegate.
 */
CIOleClientSite::CIOleClientSite(PCONTAINER pCContainer)
{
   m_cRef=0;
   m_pUnkOuter = m_pContainer = pCContainer;
   return;
}

CIOleClientSite::~CIOleClientSite(void)
{
   return;
}

/*
 * CIOleClientSite::QueryInterface
 * CIOleClientSite::AddRef
 * CIOleClientSite::Release
 *
 * Purpose:
 * IUnknown members for CIOleClientSite object.
 */
STDMETHODIMP CIOleClientSite::QueryInterface(REFIID riid, LPVOID * ppv)
{
   return m_pUnkOuter->QueryInterface(riid, ppv);
}


STDMETHODIMP_(ULONG) CIOleClientSite::AddRef(void)
{
   m_pUnkOuter->AddRef();
   return ++m_cRef;
}

STDMETHODIMP_(ULONG) CIOleClientSite::Release(void)
{
   ULONG ul = --m_cRef;

   m_pUnkOuter->Release();
   if (ul <= 0)
      delete this;

   return ul;
}

/*
 * CIOleClientSite::SaveObject
 *
 * Purpose:
 * Requests that the container call OleSave for the object that
 * lives here.  Typically this happens on server shutdown.
 *
 * Parameters:
 * None
 *
 * Return Value:
 * HRESULT     Standard.
 */
STDMETHODIMP CIOleClientSite::SaveObject(void)
{
   // We're already set up with the tenant to save; this is trivial.
   //pCContainer->Update();
   return NOERROR;
}

/*
 * CIOleClientSite::GetMoniker
 *
 * Purpose:
 * Retrieves the moniker for the site in which this object lives,
 * either the moniker relative to the container or the full
 * moniker.
 *
 * Parameters:
 * dwAssign    DWORD specifying that the object wants moniker
 *             assignment.  Yeah.   Right.   Got any bridges to
 *             sell?
 * dwWhich     DWORD identifying which moniker the object
 *             wants, either the container's moniker, the
 *             moniker relative to this client site, or the
 *             full moniker.
 *
 * Return Value:
 * HRESULT     Standard.
 */
STDMETHODIMP CIOleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhich, LPMONIKER *ppmk)
{
   *ppmk=NULL;

   switch (dwWhich)
      {
      case OLEWHICHMK_CONTAINER:
         //This is just the file we're living in.
         break;

      case OLEWHICHMK_OBJREL:
         //This is everything but the filename.
         break;

      case OLEWHICHMK_OBJFULL:
         //Concatenate file and relative monikers for this one.
         break;
      }

   if (NULL==*ppmk)
      return ResultFromScode(E_FAIL);

   (*ppmk)->AddRef();
   return NOERROR;
}

/*
 * CIOleClientSite::GetContainer
 *
 * Purpose:
 * Returns a pointer to the document's IOleContainer interface.
 *
 * Parameters:
 * ppContainer    LPOLECONTAINER * in which to return the
 *             interface.
 *
 * Return Value:
 * HRESULT     Standard.
 */
STDMETHODIMP CIOleClientSite::GetContainer(LPOLECONTAINER* ppContainer)
{
   if (m_pContainer)
      return m_pContainer->QueryInterface(IID_IOleItemContainer, (LPVOID *)ppContainer);

   return ResultFromScode(E_FAIL);
}

/*
 * CIOleClientSite::ShowObject
 *
 * Purpose:
 * Tells the container to bring the object fully into view as much
 * as possible, that is, scroll the document.
 *
 * Parameters:
 * None
 *
 * Return Value:
 * HRESULT     Standard.
 */
STDMETHODIMP CIOleClientSite::ShowObject(void)
{
   // deligate back to CContainer
   // m_pContainer->ShowObject();
   return NOERROR;
}

/*
 * CIOleClientSite::OnShowWindow
 *
 * Purpose:
 * Informs the container if the object is showing itself or
 * hiding itself. This is done only in the opening mode and allows
 * the container to know when to shade or unshade the object.
 *
 * Parameters:
 * fShow       BOOL indiciating that the object is being shown
 *             (TRUE) or hidden (FALSE).
 * Return Value:
 * HRESULT     Standard.
 */
STDMETHODIMP CIOleClientSite::OnShowWindow(BOOL fShow)
{
   // deligate back to CContainer
   // m_pContainer->OnShowWindow(fShow);
   return NOERROR;
}

/*
 * CIOleClientSite::RequestNewObjectLayout
 *
 * Purpose:
 * Called when the object would like to have its layout
 * reinitialized. This is used by OLE Controls.
 *
 * Parameters:
 * None
 *
 * Return Value:
 * HRESULT     Standard.
 */
STDMETHODIMP CIOleClientSite::RequestNewObjectLayout(void)
{
   // deligate back to CContainer
   // m_pContainer->RequestNewObjectLayout();
   return NOERROR;
}

/**************************************************************************************
 *
 * InPlaceSite code
 *
 *
 * CIOleInPlaceSite implementation begins here!
 *
 **************************************************************************************/

/*
 * CIOleInPlaceSite::CIOleInPlaceSite
 * CIOleInPlaceSite::~CIOleInPlaceSite
 *
 * Parameters (Constructor):
 * pCContainer    Pointer to the container we're in.
 * pUnkOuter      LPUNKNOWN to which we delegate.
 */
CIOleInPlaceSite::CIOleInPlaceSite(PCONTAINER pCContainer)
{
   m_cRef=0;
   m_pUnkOuter = m_pContainer = pCContainer;
   return;
}

CIOleInPlaceSite::~CIOleInPlaceSite(void)
{
   ASSERT(m_cRef == 0);
   return;
}

/*
 * CIOleInPlaceSite::QueryInterface
 * CIOleInPlaceSite::AddRef
 * CIOleInPlaceSite::Release
 *
 * Purpose:
 * IUnknown members for CIOleInPlaceSite object.
 */
STDMETHODIMP CIOleInPlaceSite::QueryInterface(REFIID riid, LPVOID * ppv)
{
   return m_pUnkOuter->QueryInterface(riid, ppv);
}


STDMETHODIMP_(ULONG) CIOleInPlaceSite::AddRef(void)
{
   m_pUnkOuter->AddRef();
   return ++m_cRef;
}

STDMETHODIMP_(ULONG) CIOleInPlaceSite::Release(void)
{
   ULONG ul = --m_cRef;

   m_pUnkOuter->Release();
   if (ul <= 0)
      delete this;

   return ul;
}

/*
 * CIOleInPlaceActiveObject::GetWindow
 *
 * Purpose:
 * Retrieves the handle of the window associated with the object
 * on which this interface is implemented.
 *
 * Parameters:
 * phWnd       HWND * in which to store the window handle.
 *
 * Return Value:
 * HRESULT     NOERROR if successful, E_FAIL if there is no
 *             window.
 */
STDMETHODIMP CIOleInPlaceSite::GetWindow(HWND *phWnd)
{
   *phWnd = m_pContainer->m_hWnd;
   return NOERROR;
}

/*
 * CIOleInPlaceActiveObject::ContextSensitiveHelp
 *
 * Purpose:
 * Instructs the object on which this interface is implemented to
 * enter or leave a context-sensitive help mode.
 *
 * Parameters:
 * fEnterMode     BOOL TRUE to enter the mode, FALSE otherwise.
 *
 * Return Value:
 * HRESULT     NOERROR
 */
STDMETHODIMP CIOleInPlaceSite::ContextSensitiveHelp(BOOL fEnterMode)
{
   return NOERROR;
}

/*
 * CIOleInPlaceSite::CanInPlaceActivate
 *
 * Purpose:
 * Answers the server whether or not we can currently in-place
 * activate its object.  By implementing this interface we say
 * that we support in-place activation, but through this function
 * we indicate whether the object can currently be activated
 * in-place.  Iconic aspects, for example, cannot, meaning we
 * return S_FALSE.
 *
 * Parameters:
 * None
 *
 * Return Value:
 * HRESULT     NOERROR if we can in-place activate the object
 *             in this site, S_FALSE if not.
 */
STDMETHODIMP CIOleInPlaceSite::CanInPlaceActivate(void)
{
   return NOERROR;
}

/*
 * CIOleInPlaceSite::OnInPlaceActivate
 *
 * Purpose:
 * Informs the container that an object is being activated in-place
 * such that the container can prepare appropriately. The
 * container does not, however, make any user interface changes at
 * this point.  See OnUIActivate.
 *
 * Parameters:
 * None
 *
 * Return Value:
 * HRESULT     NOERROR or an appropriate error code.
 */
STDMETHODIMP CIOleInPlaceSite::OnInPlaceActivate(void)
{

   // BUGBUG: Mikecole - Does this belong here ?

   //if (FAILED(m_pOleObject->QueryInterface(IID_IOleInPlaceActiveObject, (void**)&m_pInPlaceActive)))
   //  m_pInPlaceActive = 0;


   return NOERROR;
}

/*
 * CIOleInPlaceSite::OnInPlaceDeactivate
 *
 * Purpose:
 * Notifies the container that the object has deactivated itself
 * from an in-place state.  Opposite of OnInPlaceActivate.  The
 * container does not change any UI at this point.
 *
 * Parameters:
 * None
 *
 * Return Value:
 * HRESULT     NOERROR or an appropriate error code.
 */
STDMETHODIMP CIOleInPlaceSite::OnInPlaceDeactivate(void)
{

   // BUGBUG: Mikecole - Does this belong here ?

   //if (FAILED(m_pOleObject->QueryInterface(IID_IOleInPlaceActiveObject, (void**)&m_pInPlaceActive)))
   //  m_pInPlaceActive = 0;

   return NOERROR;
}

/*
 * CIOleInPlaceSite::OnUIActivate
 *
 * Purpose:
 * Informs the container that the object is going to start munging
 * around with user interface, like replacing the menu.  The
 * container should remove any relevant UI in preparation.
 *
 * Parameters:
 * None
 *
 * Return Value:
 * HRESULT     NOERROR or an appropriate error code.
 */
STDMETHODIMP CIOleInPlaceSite::OnUIActivate(void)
{
   return NOERROR;
}

/*
 * CIOleInPlaceSite::OnUIDeactivate
 *
 * Purpose:
 * Informs the container that the object is deactivating its
 * in-place user interface at which time the container may
 * reinstate its own.   Opposite of OnUIActivate.
 *
 * Parameters:
 * fUndoable      BOOL indicating if the object will actually
 *             perform an Undo if the container calls
 *             ReactivateAndUndo.
 *
 * Return Value:
 * HRESULT     NOERROR or an appropriate error code.
 */
STDMETHODIMP CIOleInPlaceSite::OnUIDeactivate(BOOL fUndoable)
{
   return NOERROR;
}

/*
 * CIOleInPlaceSite::DeactivateAndUndo
 *
 * Purpose:
 * If immediately after activation the object does an Undo, the
 * action being undone is the activation itself, and this call
 * informs the container that this is, in fact, what happened.
 * The container should call IOleInPlaceObject::UIDeactivate.
 *
 * Parameters:
 * None
 *
 * Return Value:
 * HRESULT     NOERROR or an appropriate error code.
 */
STDMETHODIMP CIOleInPlaceSite::DeactivateAndUndo(void)
{
   //CONTROLMOD
   /*
    * Note that we don't pay attention to the locking
    * from IOleControlSite::LockInPlaceActive since only
    * the object calls this function and should know
    * that it's going to be deactivated.
    */
   //End CONTROLMOD
   return NOERROR;
}

/*
 * CIOleInPlaceSite::DiscardUndoState
 *
 * Purpose:
 * Informs the container that something happened in the object
 * that means the container should discard any undo information
 * it currently maintains for the object.
 *
 * Parameters:
 * None
 *
 * Return Value:
 * HRESULT     NOERROR or an appropriate error code.
 */
STDMETHODIMP CIOleInPlaceSite::DiscardUndoState(void)
{
   return ResultFromScode(E_NOTIMPL);
}

/*
 * CIOleInPlaceSite::GetWindowContext
 *
 * Purpose:
 * Provides an in-place object with pointers to the frame and
 * document level in-place interfaces (IOleInPlaceFrame and
 * IOleInPlaceUIWindow) such that the object can do border
 * negotiation and so forth.  Also requests the position and
 * clipping rectangles of the object in the container and a
 * pointer to an OLEINPLACEFRAME info structure which contains
 * accelerator information.
 *
 * Note that the two interfaces this call returns are not
 * available through QueryInterface on IOleInPlaceSite since they
 * live with the frame and document, but not the site.
 *
 * Parameters:
 * ppIIPFrame     LPOLEINPLACEFRAME * in which to return the
 *             AddRef'd pointer to the container's
 *             IOleInPlaceFrame.
 * ppIIPUIWindow  LPOLEINPLACEUIWINDOW * in which to return
 *             the AddRef'd pointer to the container document's
 *             IOleInPlaceUIWindow.
 * prcPos         LPRECT in which to store the object's position.
 * prcClip     LPRECT in which to store the object's visible
 *             region.
 * pFI         LPOLEINPLACEFRAMEINFO to fill with accelerator
 *             stuff.
 *
 * Return Value:
 * HRESULT     NOERROR
 */
STDMETHODIMP CIOleInPlaceSite::GetWindowContext(LPOLEINPLACEFRAME FAR* lplpFrame,
                                    LPOLEINPLACEUIWINDOW FAR* lplpDoc, LPRECT lprcPosRect,
                                    LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
   RECT rect;

   // the frame is associated with the application object.
   // need to AddRef() it...

   m_pContainer->m_pIOleInPlaceFrame->AddRef();
   *lplpFrame = m_pContainer->m_pIOleInPlaceFrame;
   *lplpDoc = NULL;  // must be NULL, cause we're SDI.

   // get the size of the object in pixels
   ::GetClientRect(m_pContainer->m_hWnd, &rect);   // This may be bogus!

   // Copy this to the passed buffer
   CopyRect(lprcPosRect, &rect);

   // fill the clipping region
   CopyRect(lprcClipRect, &rect);

   // fill the FRAMEINFO
   lpFrameInfo->fMDIApp = FALSE;
   lpFrameInfo->hwndFrame = m_pContainer->m_hWnd;
   lpFrameInfo->haccel = NULL;
   lpFrameInfo->cAccelEntries = 0;

   return ResultFromScode(S_OK);
}

/*
 * CIOleInPlaceSite::Scroll
 *
 * Purpose:
 * Asks the container to scroll the document, and thus the object,
 * by the given amounts in the sz parameter.
 *
 * Parameters:
 * sz          SIZE containing signed horizontal and vertical
 *             extents by which the container should scroll.
 *             These are in device units.
 *
 * Return Value:
 * HRESULT     NOERROR
 */

STDMETHODIMP CIOleInPlaceSite::Scroll(SIZE sz)
{
   return NOERROR;
}

/*
 * CIOleInPlaceSite::OnPosRectChange
 *
 * Purpose:
 * Informs the container that the in-place object was resized.
 * The container must call IOleInPlaceObject::SetObjectRects.
 * This does not change the site's rectangle in any case.
 *
 * Parameters:
 * prcPos         LPCRECT containing the new size of the object.
 *
 * Return Value:
 * HRESULT     NOERROR
 */
STDMETHODIMP CIOleInPlaceSite::OnPosRectChange(LPCRECT prcPos)
{
   // m_pContainer->UpdateInPlaceObjectRects(prcPos, FALSE);
   return NOERROR;
}

/**************************************************************************************
 *
 * InPlaceFrame code
 *
 *
 * CIOleInPlaceFrame implementation begins here!
 *
 **************************************************************************************/

/*
 * CIOleInPlaceFrame::CIOleInPlaceFrame
 * CIOleInPlaceFrame::~CIOleInPlaceFrame
 *
 * Parameters (Constructor):
 * pTen        PCTenant of the tenant we're in.
 * pUnkOuter      LPUNKNOWN to which we delegate.
 */
CIOleInPlaceFrame::CIOleInPlaceFrame(PCONTAINER pCContainer)
{
   m_cRef=0;
   m_pUnkOuter = m_pContainer = pCContainer;
   return;
}

CIOleInPlaceFrame::~CIOleInPlaceFrame(void)
{
   ASSERT(m_cRef == 0);
   return;
}

/*
 * CIOleInPlaceFrame::QueryInterface
 * CIOleInPlaceFrame::AddRef
 * CIOleInPlaceFrame::Release
 *
 * Purpose:
 * IUnknown members for CIOleInPlaceFrame object.
 */
STDMETHODIMP CIOleInPlaceFrame::QueryInterface(REFIID riid, LPVOID * ppv)
{
   //We only know IUnknown and IOleInPlaceFrame
   *ppv=NULL;

   //Remember to do ALL base interfaces
   if ( IID_IUnknown == riid ||
       IID_IOleInPlaceUIWindow == riid ||
       IID_IOleWindow == riid ||
       IID_IOleInPlaceFrame == riid )
      *ppv=(LPOLEINPLACEFRAME)this;

   if (NULL!=*ppv)
   {
      ((LPUNKNOWN)*ppv)->AddRef();
      return NOERROR;
   }
   return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CIOleInPlaceFrame::AddRef(void)
{
   m_pUnkOuter->AddRef();
   return ++m_cRef;
}

STDMETHODIMP_(ULONG) CIOleInPlaceFrame::Release(void)
{
   ULONG ul = --m_cRef;

   m_pUnkOuter->Release();
   if (ul <= 0)
      delete this;

   return ul;
}

/*
 * CIOleInPlaceFrame::GetWindow
 *
 * Purpose:
 * Retrieves the handle of the window associated with the object
 * on which this interface is implemented.
 *
 * Parameters:
 * phWnd       HWND * in which to store the window handle.
 *
 * Return Value:
 * HRESULT     NOERROR if successful, E_FAIL if there is no
 *             window.
 */
STDMETHODIMP CIOleInPlaceFrame::GetWindow(HWND *phWnd)
{
   *phWnd = m_pContainer->m_hWnd;
   return NOERROR;
}

/*
 * CIOleInPlaceFrame::ContextSensitiveHelp
 *
 * Purpose:
 * Instructs the object on which this interface is implemented to
 * enter or leave a context-sensitive help mode.
 *
 * Parameters:
 * fEnterMode     BOOL TRUE to enter the mode, FALSE otherwise.
 *
 * Return Value:
 * HRESULT     NOERROR
 */
STDMETHODIMP CIOleInPlaceFrame::ContextSensitiveHelp(BOOL fEnterMode)
{

   // If we had an embedded control with menus, this would get called on an
   // f1 keypress with a menu pulled down.
   //
   return NOERROR;
}

/*
 * CIOleInPlaceFrame::GetBorder
 *
 * Purpose:
 * Returns the rectangle in which the container is willing to
 * negotiate about an object's adornments.
 *
 * Parameters:
 * prcBorder      LPRECT in which to store the rectangle.
 *
 * Return Value:
 * HRESULT     NOERROR if all is well, INPLACE_E_NOTOOLSPACE
 *             if there is no negotiable space.
 */
STDMETHODIMP CIOleInPlaceFrame::GetBorder(LPRECT prcBorder)
{
   if (NULL==prcBorder)
      return ResultFromScode(E_INVALIDARG);
   /*
    * We return all the client area space sans the StatStrip,
    * which we control
    */
   GetClientRect(m_pContainer->m_hWnd, prcBorder);
   return NOERROR;
}

/*
 * CIOleInPlaceFrame::RequestBorderSpace
 *
 * Purpose:
 * Asks the container if it can surrender the amount of space
 * in pBW that the object would like for it's adornments.  The
 * container does nothing but validate the spaces on this call.
 *
 * Parameters:
 * pBW         LPCBORDERWIDTHS containing the requested space.
 *             The values are the amount of space requested
 *             from each side of the relevant window.
 *
 * Return Value:
 * HRESULT     NOERROR if we can give up space,
 *             INPLACE_E_NOTOOLSPACE otherwise.
 */
STDMETHODIMP CIOleInPlaceFrame::RequestBorderSpace(LPCBORDERWIDTHS pBW)
{
   //Everything is fine with us, so always return an OK.

   // mikecole/douglash Should either return inplace_e_notoolspace or we should honor the
   // request for border space below in setborderspace().

   return INPLACE_E_NOTOOLSPACE;
}

/*
 * CIOleInPlaceFrame::SetBorderSpace
 *
 * Purpose:
 * Called when the object now officially requests that the
 * container surrender border space it previously allowed
 * in RequestBorderSpace.  The container should resize windows
 * appropriately to surrender this space.
 *
 * Parameters:
 * pBW         LPCBORDERWIDTHS containing the amount of space
 *             from each side of the relevant window that the
 *             object is now reserving.
 *
 * Return Value:
 * HRESULT     NOERROR
 */
STDMETHODIMP CIOleInPlaceFrame::SetBorderSpace(LPCBORDERWIDTHS pBW)
{
   return NOERROR;
}

/*
 * CIOleInPlaceFrame::InsertMenus
 *
 * Purpose:
 * Instructs the container to place its in-place menu items where
 * necessary in the given menu and to fill in elements 0, 2, and 4
 * of the OLEMENUGROUPWIDTHS array to indicate how many top-level
 * items are in each group.
 *
 * Parameters:
 * hMenu       HMENU in which to add popups.
 * pMGW        LPOLEMENUGROUPWIDTHS in which to store the
 *             width of each container menu group.
 *
 * Return Value:
 * HRESULT     NOERROR
 */
STDMETHODIMP CIOleInPlaceFrame::InsertMenus(HMENU hMenu, LPOLEMENUGROUPWIDTHS pMGW)
{
   return NOERROR;
}

/*
 * CIOleInPlaceFrame::SetMenu
 *
 * Purpose:
 * Instructs the container to replace whatever menu it's currently
 * using with the given menu and to call OleSetMenuDescritor so OLE
 * knows to whom to dispatch messages.
 *
 * Parameters:
 * hMenu       HMENU to show.
 * hOLEMenu    HOLEMENU to the menu descriptor.
 * hWndObj     HWND of the active object to which messages are
 *             dispatched.
 * Return Value:
 * HRESULT     NOERROR
 */
STDMETHODIMP CIOleInPlaceFrame::SetMenu(HMENU hMenu, HOLEMENU hOLEMenu, HWND hWndObj)
{
   /*
    * Our responsibilities here are to put the menu on the frame
    * window and call OleSetMenuDescriptor.
    * CPatronClient::SetMenu which we call here takes care of
    * MDI/SDI differences.
    *
    * We also want to save the object's hWnd for use in WM_SETFOCUS
    * processing.
    */
   return NOERROR;
}

/*
 * CIOleInPlaceFrame::RemoveMenus
 *
 * Purpose:
 * Asks the container to remove any menus it put into hMenu in
 * InsertMenus.
 *
 * Parameters:
 * hMenu       HMENU from which to remove the container's
 *             items.
 *
 * Return Value:
 * HRESULT     NOERROR
 */
STDMETHODIMP CIOleInPlaceFrame::RemoveMenus(HMENU hMenu)
{
   /*
    * To be defensive, loop through this menu removing anything
    * we recognize (that is, anything in m_phMenu) just in case
    * the server didn't clean it up right.  At least we can
    * give ourselves the prophylactic benefit.
    */

   /*
    * Walk backwards down the menu.  For each popup, see if it
    * matches any other popup we know about, and if so, remove
    * it from the shared menu.
    */
   return NOERROR;
}

/*
 * CIOleInPlaceFrame::SetStatusText
 *
 * Purpose:
 * Asks the container to place some text in a status line, if one
 * exists.  If the container does not have a status line it
 * should return E_FAIL here in which case the object could
 * display its own.
 *
 * Parameters:
 * pszText     LPCTSTR to display.
 *
 * Return Value:
 * HRESULT     NOERROR if successful, S_TRUNCATED if not all
 *             of the text could be displayed, or E_FAIL if
 *             the container has no status line.
 */
STDMETHODIMP CIOleInPlaceFrame::SetStatusText(LPCOLESTR  pszText)
{
   /*
    * Just send this to the StatStrip.  Unfortunately it won't tell
    * us about truncation.  Oh well, we'll just act like it worked.
    */
   if (pszText) {
#if 0
      char buf[256];
25-Sep-1997 [ralphw] Can't find SetPrompt in IV source code
      if (ConvertWz(pszText, buf, sizeof(buf))) {
        if (*pszText)
          SetPrompt(buf, TRUE);
        else
          SetPrompt();
      }
#endif
   }
   return NOERROR;
}

/*
 * CIOleInPlaceFrame::EnableModeless
 *
 * Purpose:
 * Instructs the container to show or hide any modeless popup
 * windows that it may be using.
 *
 * Parameters:
 * fEnable     BOOL indicating to enable/show the windows
 *             (TRUE) or to hide them (FALSE).
 *
 * Return Value:
 * HRESULT     NOERROR
 */
STDMETHODIMP CIOleInPlaceFrame::EnableModeless(BOOL fEnable)
{
   return NOERROR;
}

/*
 * CIOleInPlaceFrame::TranslateAccelerator
 *
 * Purpose:
 * When dealing with an in-place object from an EXE server, this
 * is called to give the container a chance to process accelerators
 * after the server has looked at the message.
 *
 * Parameters:
 * pMSG        LPMSG for the container to examine.
 * wID         WORD the identifier in the container's
 *             accelerator table (from IOleInPlaceSite
 *             ::GetWindowContext) for this message (OLE does
 *             some translation before calling).
 *
 * Return Value:
 * HRESULT     NOERROR if the keystroke was used,
 *             S_FALSE otherwise.
 */
STDMETHODIMP CIOleInPlaceFrame::TranslateAccelerator(LPMSG pMSG, WORD wID)
{
   /*
    * wID already has anything translated from m_hAccelIP for us,
    * so we can just check for the commands we want and process
    * them instead of calling TranslateAccelerator which would be
    * redundant and which also has a possibility of dispatching to
    * the wrong window.
    */

//   if (pMSG->message == WM_KEYDOWN && pMSG->wParam == VK_ESCAPE)
//      PostMessage(CUR_HWND, WM_CLOSE, 0, 0);

   return S_FALSE;
}

/***********************************************************************
 *
 * COleInPlaceFrame::SetActiveObject
 *
 * Purpose:
 *
 *
 * Parameters:
 *
 *     LPOLEINPLACEACTIVEOBJECT lpActiveObject   -  Pointer to the
 *                                         objects
 *                                         IOleInPlaceActiveObject
 *                                         interface
 *
 * @@WTK WIN32, UNICODE
 *     //LPCSTR lpszObjName                     -   Name of the object
 *     LPCOLESTR lpszObjName                    -  Name of the object
 *
 * Return Value:
 *
 *     S_OK
 *
 * Function Calls:
 *     Function                      Location
 *
 *     OutputDebugString                Windows API
 *     IOleInPlaceActiveObject::AddRef  Object
 *     IOleInPlaceActiveObject::Release    Object
 *     ResultFromScode               OLE API
 *
 * Comments:
 *
 ********************************************************************/
STDMETHODIMP CIOleInPlaceFrame::SetActiveObject(LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                                    LPCOLESTR lpszObjName)
{
   // in an MDI app, this method really shouldn't be called,
   // this method associated with the doc is called instead.
   // should set window title here

  if ( m_pContainer->m_pInPlaceActive )
     m_pContainer->m_pInPlaceActive->Release();

  if (lpActiveObject)
     lpActiveObject->AddRef();

  m_pContainer->m_pInPlaceActive = lpActiveObject;

  return NOERROR;
}

/*********************************************************************
 *
 * CIOleControlSite  Implementation starts here.
 *
 *

/*
 * CIOleControlSite::CIOleControlSite
 * CIOleControlSite::~CIOleControlSite
 *
 * Parameters (Constructor):
 *  pTen            PCTenant of the object we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */
CIOleControlSite::CIOleControlSite(PCONTAINER pCContainer)
{
    m_cRef=0;
    m_pUnkOuter = m_pContainer = pCContainer;
    return;
}

CIOleControlSite::~CIOleControlSite(void)
{
    return;
}

/*
 * CIOleControlSite::QueryInterface
 * CIOleControlSite::AddRef
 * CIOleControlSite::Release
 *
 * Purpose:
 *  Delegating IUnknown members for CIOleControlSite.
 */
STDMETHODIMP CIOleControlSite::QueryInterface(REFIID riid, LPVOID *ppv)
{
   return m_pUnkOuter->QueryInterface(riid, ppv);
}


STDMETHODIMP_(ULONG) CIOleControlSite::AddRef(void)
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CIOleControlSite::Release(void)
{
    --m_cRef;
    return m_pUnkOuter->Release();
}

/*
 * CIOleControlSite::OnControlInfoChanged
 *
 * Purpose:
 *  Informs the site that the CONTROLINFO for the control has
 *  changed and we thus need to reload the data.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR
 */
STDMETHODIMP CIOleControlSite::OnControlInfoChanged(void)
{
    return NOERROR;
}

/*
 * CIOleControlSite::LockInPlaceActive
 *
 * Purpose:
 *  Forces the container to keep this control in-place active
 *  (but not UI active) regardless of other considerations, or
 *  removes this lock.
 *
 * Parameters:
 *  fLock           BOOL indicating to lock (TRUE) or unlock (FALSE)
 *                  in-place activation.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */
STDMETHODIMP CIOleControlSite::LockInPlaceActive(BOOL fLock)
{
    return NOERROR;
}

/*
 * CIOleControlSite::GetExtendedControl
 *
 * Purpose:
 *  Returns a pointer to the container's extended control that wraps
 *  the actual control in this site, if one exists.
 *
 * Parameters:
 *  ppDispatch      LPDISPATCH * in which to return the pointer
 *                  to the extended control's IDispatch interface.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */
STDMETHODIMP CIOleControlSite::GetExtendedControl(LPDISPATCH* ppDispatch)
{
    *ppDispatch=NULL;
    return ResultFromScode(E_NOTIMPL);
}

/*
 * CIOleControlSite::TransformCoords
 *
 * Purpose:
 *  Converts coordinates in HIMETRIC units into those used by the
 *  container.
 *
 * Parameters:
 *  pptlHiMet       POINTL * containing either the coordinates to
 *                  transform to container or where to store the
 *                  transformed container coordinates.
 *  pptlCont        POINTF * containing the container coordinates.
 *  dwFlags         DWORD containing instructional flags.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */
STDMETHODIMP CIOleControlSite::TransformCoords(POINTL *pptlHiMet, POINTF *pptlCont, DWORD dwFlags)
{
    if (NULL==pptlHiMet || NULL==pptlCont)
        return ResultFromScode(E_POINTER);

    /*
     * Convert coordinates.  We use MM_LOMETRIC which means that
     * to convert from HIMETRIC we divide by 10 and negate the y
     * coordinate.  Conversion to HIMETRIC means negate the y
     * and multiply by 10.  Note that size and position are
     * considered the same thing, that is, we don't differentiate
     * the two.
     */

    if (XFORMCOORDS_HIMETRICTOCONTAINER & dwFlags)
        {
        pptlCont->x=(float)(pptlHiMet->x/10);
        pptlCont->y=(float)-(pptlHiMet->y/10);
        }
    else
        {
        pptlHiMet->x=(long)(pptlCont->x*10);
        pptlHiMet->y=(long)-(pptlCont->y*10);
        }

    return NOERROR;
}

/*
 * CIOleControlSite::TranslateAccelerator
 *
 * Purpose:
 *  Instructs the container to translate a keyboard accelerator
 *  message that the control has picked up instead.
 *
 * Parameters:
 *  pMsg            LPMSG to the message to translate.
 *  grfModifiers    DWORD flags with additional instructions.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */
STDMETHODIMP CIOleControlSite::TranslateAccelerator(LPMSG pMsg, DWORD grfModifiers)
{
#ifdef _DEBUG
   char sz[1000];
   HWND hWnd;
   hWnd = GetFocus();
   wsprintf(sz,"CIOleControlSite::TranslateAccelerator()\nGetFocus == %X\npMsg->hwnd = %X\npMsg->message = %X\npMsg->wParam = %X\npMsg->lParam = %X\npMsg->time = %X\npMsg->pt.x = %X\npMsg->pt.y = %X\n",
            hWnd,pMsg->hwnd,pMsg->message,pMsg->wParam,pMsg->lParam,pMsg->time,pMsg->pt.x,pMsg->pt.y);
   OutputDebugString(sz);
#endif
   return ResultFromScode(E_NOTIMPL);
}

/*
 * CIOleControlSite::OnFocus
 *
 * Purpose:
 *  Informs the container that focus has either been lost or
 *  gained in the control.
 *
 * Parameters:
 *  fGotFocus       BOOL indicating that the control gained (TRUE)
 *                  or lost (FALSE) focus.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CIOleControlSite::OnFocus(BOOL fGotFocus)
{
    //We don't handle default buttons, so this is not interesting
    return NOERROR;
}

/*
 * CIOleControlSite::ShowPropertyFrame
 *
 * Purpose:
 *  Instructs the container to show the property frame if
 *  this is, in fact, an extended object.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CIOleControlSite::ShowPropertyFrame(void)
{
   //We don't do extended objects, so nothing to do here.
   return ResultFromScode(E_NOTIMPL);
}

//#endif    // CIOleControlSite

/********************************************************************
 *
 * Implementation of IOleItemContainer
 *
 * We don't actually use this interface, but need to return one so
 * the IE control can QI it for IDispatch.  Why they don't just QI the
 * site I don't know.
 */

CIOleItemContainer::CIOleItemContainer(IUnknown * pOuter)
{
   m_cRef = 0;
   m_pOuter = pOuter;
}

// aggregating IUnknown methods

STDMETHODIMP CIOleItemContainer::QueryInterface(REFIID riid, LPVOID * ppv)
{
   *ppv = 0;

   if (m_pOuter)
     return m_pOuter->QueryInterface(riid,ppv);
   else
      return E_NOINTERFACE;

#if 0
   if (riid == IID_IUnknown || riid == IID_IOleItemContainer
     || riid == IID_IOleContainer || riid == IID_IParseDisplayName)
   {
     *ppv = (LPVOID)(IDispatch*)this;
     AddRef();
     return S_OK;
   }

   return E_NOINTERFACE;
#endif
}

STDMETHODIMP_(ULONG) CIOleItemContainer::AddRef(void)
{
   m_cRef++;

   if (m_pOuter)
     m_pOuter->AddRef();

   return m_cRef;
}

STDMETHODIMP_(ULONG) CIOleItemContainer::Release(void)
{
   ULONG c = --m_cRef;

   if (m_pOuter)
     m_pOuter->Release();

   if (c <= 0)
     delete this;

   return c;
}

STDMETHODIMP CIOleItemContainer::ParseDisplayName(IBindCtx *, LPOLESTR,ULONG*,IMoniker**)
{
   return E_NOTIMPL;
}

STDMETHODIMP CIOleItemContainer::EnumObjects(DWORD,LPENUMUNKNOWN*)
{
   return E_NOTIMPL;
}

STDMETHODIMP CIOleItemContainer::LockContainer(BOOL)
{
   return E_NOTIMPL;
}

STDMETHODIMP CIOleItemContainer::GetObject(LPOLESTR,DWORD,IBindCtx*,REFIID,void**)
{
   return E_NOTIMPL;
}

STDMETHODIMP CIOleItemContainer::GetObjectStorage(LPOLESTR,IBindCtx*,REFIID,void**)
{
   return E_NOTIMPL;
}

STDMETHODIMP CIOleItemContainer::IsRunning(LPOLESTR)
{
   return S_FALSE;
}

int ConvertWz(const WCHAR * pwz, char * psz, int len)
{
   BOOL fDefault = FALSE;
   return WideCharToMultiByte(CP_ACP, 0, pwz, wcslen(pwz) + 1, psz, len, "*", &fDefault);
}

/*********************************************************************************************
 *
 *  CDocHostUIHandler
 *
 *  IE4 only QI()'s our control site for one of these. Most of these functions are called from
 *  IE's IOleInPlaceActiveObject coorisponding members. This gives us a great deal of control
 *  over UI compared to what we had with IE3. Using IDocHostUIHandler members me can:
 *
 *  Control the right click context menu.
 *  Control the window border.
 *  Keep seperate registry settings from IE.
 *  Handle keyboard accelarators more intelegently.
 */

CDocHostUIHandler::CDocHostUIHandler(IUnknown * pOuter)
{
   m_cRef = 0;
   m_pOuter = pOuter;
}

STDMETHODIMP CDocHostUIHandler::QueryInterface(REFIID riid, LPVOID * ppv)
{
   *ppv = 0;

   if (m_pOuter)
      return m_pOuter->QueryInterface(riid,ppv);
   else
      return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDocHostUIHandler::AddRef(void)
{
   m_cRef++;

   if (m_pOuter)
     m_pOuter->AddRef();

   return m_cRef;
}

STDMETHODIMP_(ULONG) CDocHostUIHandler::Release(void)
{
   ULONG c = --m_cRef;

   if (m_pOuter)
     m_pOuter->Release();

   if (c <= 0)
     delete this;

   return c;
}


STDMETHODIMP CDocHostUIHandler::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{

// We cannot define these below since they are already incorrectly defined in include\mshtmlhst.h
// so we will just use the hard-coded values instead
//#define CONTEXT_MENU_DEFAULT 0    // typically blank areas in the topic
//#define CONTEXT_MENU_IMAGE 1      // bitmaps, etc.
//#define CONTEXT_MENU_CONTROL 2
//#define CONTEXT_MENU_TABLE 3
//#define CONTEXT_MENU_DEBUG 4      // seleted text uses this id
//#define CONTEXT_MENU_1DSELECT 5   // these are links
//#define CONTEXT_MENU_ANCHOR 6
//#define CONTEXT_MENU_IMGDYNSRC 7

   if( dwID == 0 || dwID == 1 || dwID == 5 ) {

     if( HMENU hMenu = CreatePopupMenu() ) {
       #define IDTB_REBASE   1000
       #define HTMLID_REBASE 2000

       if( dwID == 0 ) {
         HxAppendMenu( hMenu, MF_STRING | MF_ENABLED, IDTB_REBASE+IDTB_BACK, GetStringResource(IDS_OPTION_BACK) );
         HxAppendMenu( hMenu, MF_STRING | MF_ENABLED, IDTB_REBASE+IDTB_FORWARD, GetStringResource(IDS_OPTION_FORWARD) );
         AppendMenu( hMenu, MF_SEPARATOR, -1, NULL );
         HxAppendMenu( hMenu, MF_STRING | MF_ENABLED, OLECMDID_SELECTALL, GetStringResource(IDS_OPTION_SELECTALL) );
         AppendMenu( hMenu, MF_SEPARATOR, -1, NULL );
         HxAppendMenu( hMenu, MF_STRING | MF_ENABLED, HTMLID_REBASE+HTMLID_VIEWSOURCE, GetStringResource(IDS_OPTION_VIEWSOURCE) );
         AppendMenu( hMenu, MF_SEPARATOR, -1, NULL );
         HxAppendMenu( hMenu, MF_STRING | MF_ENABLED, OLECMDID_PRINT, GetStringResource(IDS_OPTION_PRINT) );
         HxAppendMenu( hMenu, MF_STRING | MF_ENABLED, OLECMDID_REFRESH, GetStringResource(IDS_OPTION_REFRESH) );
         AppendMenu( hMenu, MF_SEPARATOR, -1, NULL );
       }

       if( dwID == 1 ) {
         HxAppendMenu( hMenu, MF_STRING | MF_ENABLED, OLECMDID_COPY, GetStringResource(IDS_OPTION_COPY) );
         AppendMenu( hMenu, MF_SEPARATOR, -1, NULL );
       }

       HxAppendMenu( hMenu, MF_STRING | MF_ENABLED, OLECMDID_PROPERTIES, GetStringResource(IDS_OPTION_PROPERTIES) );

       VARIANT vaIn;
       VARIANT vaOut;
       ::VariantInit(&vaIn);
       ::VariantInit(&vaOut);

       HWND hWndParent = NULL;
       hWndParent = ((CContainer*) m_pOuter)->m_hwndChild;
       if( !IsValidWindow(hWndParent) )
         hWndParent = GetActiveWindow();
       if( !hWndParent )
         hWndParent = GetDesktopWindow();

       int iCmd = TrackPopupMenu( hMenu,
         TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
         (*ppt).x, (*ppt).y, 0, hWndParent, NULL);
       DestroyMenu( hMenu );

       if( iCmd < IDTB_REBASE ) {
         if( iCmd == OLECMDID_PROPERTIES ) {  // Trident folks say the In value must be set to the mouse pos
           V_VT(&vaIn) = VT_I4;
           V_I4(&vaIn) = MAKELONG((*ppt).x,(*ppt).y);
         }
         ((IOleCommandTarget*)pcmdtReserved)->Exec( NULL, iCmd,
              OLECMDEXECOPT_DODEFAULT, &vaIn, &vaOut );
       }
       else if( iCmd < HTMLID_REBASE ) {
         iCmd -=IDTB_REBASE;
         if( iCmd == IDTB_BACK )
           ((CContainer*) m_pOuter)->m_pWebBrowserApp->GoBack();
         else if( iCmd == IDTB_FORWARD )
           ((CContainer*) m_pOuter)->m_pWebBrowserApp->GoForward();
       }
       else {
         iCmd -=HTMLID_REBASE;
         ((IOleCommandTarget*)pcmdtReserved)->Exec( &CGID_IWebBrowserPriv, iCmd,
              OLECMDEXECOPT_DODEFAULT, &vaIn, &vaOut );
       }
     }
     return S_OK;
   }
   else
     return S_FALSE;
}

STDMETHODIMP CDocHostUIHandler::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
   pInfo->dwFlags = 0;
   pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;
   return S_OK;
}

STDMETHODIMP CDocHostUIHandler::ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget,
                                       IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc)
{
   return S_OK;
}

STDMETHODIMP CDocHostUIHandler::HideUI(void)
{
   return S_OK;
}

STDMETHODIMP CDocHostUIHandler::UpdateUI(void)
{
   return S_OK;
}

STDMETHODIMP CDocHostUIHandler::EnableModeless(BOOL fEnable)
{
   return S_OK;
}

STDMETHODIMP CDocHostUIHandler::OnDocWindowActivate(BOOL fActivate)
{
   return S_OK;
}

STDMETHODIMP CDocHostUIHandler::OnFrameWindowActivate(BOOL fActivate)
{
   return S_OK;
}

STDMETHODIMP CDocHostUIHandler::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
   return S_OK;
}

STDMETHODIMP CDocHostUIHandler::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
   return S_FALSE;
}

STDMETHODIMP CDocHostUIHandler::GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw)
{
#if 0
   // The key given will be stored under HKEY_CURRETN_USER.
   //
   if ( (*pchKey = (LPOLESTR)CoTaskMemAlloc((lstrlenW(gszHHRegKey)*sizeof(WCHAR))+sizeof(WCHAR))) )
   {
      wcscpy(*pchKey, gszHHRegKey);
      return S_OK;
   }
#endif
   return S_FALSE;
}

STDMETHODIMP CDocHostUIHandler::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
   return E_NOTIMPL;
}

STDMETHODIMP CDocHostUIHandler::GetExternal(IDispatch **ppDispatch)
{
   *ppDispatch = NULL;
   return E_NOTIMPL;
}

STDMETHODIMP CDocHostUIHandler::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
   return S_FALSE;
}

STDMETHODIMP CDocHostUIHandler::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
   return S_FALSE;
}

/*********************************************************************************************
 *
 *  CDocHostShowUI
 *
 */

CDocHostShowUI::CDocHostShowUI(IUnknown * pOuter)
{
   m_cRef = 0;
   m_pOuter = pOuter;
}

STDMETHODIMP CDocHostShowUI::QueryInterface(REFIID riid, LPVOID * ppv)
{
   *ppv = 0;

   if (m_pOuter)
      return m_pOuter->QueryInterface(riid,ppv);
   else
      return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDocHostShowUI::AddRef(void)
{
   m_cRef++;

   if (m_pOuter)
     m_pOuter->AddRef();

   return m_cRef;
}

STDMETHODIMP_(ULONG) CDocHostShowUI::Release(void)
{
   ULONG c = --m_cRef;

   if (m_pOuter)
     m_pOuter->Release();

   if (c <= 0)
     delete this;

   return c;
}

STDMETHODIMP CDocHostShowUI::ShowHelp( HWND hwnd, LPOLESTR pszHelpFile, UINT uCommand, DWORD dwData, POINT ptMouse, IDispatch* pDispatchObjectHit )
{
  return S_FALSE;
}

STDMETHODIMP CDocHostShowUI::ShowMessage( HWND hwnd, LPOLESTR lpstrText, LPOLESTR lpstrCaption, DWORD dwType, LPOLESTR lpstrHelpFile, DWORD dwHelpContext, LRESULT* plResult )
{
  return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\comcat.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0101 */
/* at Fri Mar 08 18:28:13 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comcat_h__
#define __comcat_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumGUID_FWD_DEFINED__
#define __IEnumGUID_FWD_DEFINED__
typedef interface IEnumGUID IEnumGUID;
#endif 	/* __IEnumGUID_FWD_DEFINED__ */


#ifndef __IEnumCATEGORYINFO_FWD_DEFINED__
#define __IEnumCATEGORYINFO_FWD_DEFINED__
typedef interface IEnumCATEGORYINFO IEnumCATEGORYINFO;
#endif 	/* __IEnumCATEGORYINFO_FWD_DEFINED__ */


#ifndef __ICatRegister_FWD_DEFINED__
#define __ICatRegister_FWD_DEFINED__
typedef interface ICatRegister ICatRegister;
#endif 	/* __ICatRegister_FWD_DEFINED__ */


#ifndef __ICatInformation_FWD_DEFINED__
#define __ICatInformation_FWD_DEFINED__
typedef interface ICatInformation ICatInformation;
#endif 	/* __ICatInformation_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Mar 08 18:28:13 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: comcat.h
//
//--------------------------------------------------------------------------
			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */


////////////////////////////////////////////////////////////////////////////
//  Classes (link with uuid3.lib)

EXTERN_C const CLSID CLSID_StdComponentCategoriesMgr;

////////////////////////////////////////////////////////////////////////////
//  Types
			/* size is 16 */
typedef GUID CATID;

			/* size is 4 */
typedef REFGUID REFCATID;

#define IID_IEnumCLSID              IID_IEnumGUID
#define IEnumCLSID                  IEnumGUID
#define LPENUMCLSID                 LPENUMGUID
#define CATID_NULL                   GUID_NULL
#define IsEqualCATID(rcatid1, rcatid2)       IsEqualGUID(rcatid1, rcatid2)
#define IID_IEnumCATID       IID_IEnumGUID
#define IEnumCATID           IEnumGUID

////////////////////////////////////////////////////////////////////////////
//  Category IDs (link to uuid3.lib)
EXTERN_C const CATID CATID_Insertable;
EXTERN_C const CATID CATID_Control;
EXTERN_C const CATID CATID_Programmable;
EXTERN_C const CATID CATID_IsShortcut;
EXTERN_C const CATID CATID_NeverShowExt;
EXTERN_C const CATID CATID_DocObject;
EXTERN_C const CATID CATID_Printable;
EXTERN_C const CATID CATID_RequiresDataPathHost;
EXTERN_C const CATID CATID_PersistsToMoniker;
EXTERN_C const CATID CATID_PersistsToStorage;
EXTERN_C const CATID CATID_PersistsToStreamInit;
EXTERN_C const CATID CATID_PersistsToStream;
EXTERN_C const CATID CATID_PersistsToMemory;
EXTERN_C const CATID CATID_PersistsToFile;
EXTERN_C const CATID CATID_PersistsToPropertyBag;
EXTERN_C const CATID CATID_InternetAware;

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPENUMGUID_DEFINED
#define _LPENUMGUID_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IEnumGUID_INTERFACE_DEFINED__
#define __IEnumGUID_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumGUID
 * at Fri Mar 08 18:28:13 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumGUID __RPC_FAR *LPENUMGUID;


EXTERN_C const IID IID_IEnumGUID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumGUID : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumGUIDVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumGUID __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumGUID __RPC_FAR * This,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumGUIDVtbl;

    interface IEnumGUID
    {
        CONST_VTBL struct IEnumGUIDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGUID_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumGUID_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumGUID_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumGUID_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumGUID_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumGUID_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumGUID_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IEnumGUID_Next_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumGUID_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumGUID_Skip_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumGUID_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumGUID_Reset_Proxy( 
    IEnumGUID __RPC_FAR * This);


void __RPC_STUB IEnumGUID_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumGUID_Clone_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumGUID_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumGUID_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0006
 * at Fri Mar 08 18:28:13 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPENUMCATEGORYINFO_DEFINED
#define _LPENUMCATEGORYINFO_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_s_ifspec;

#ifndef __IEnumCATEGORYINFO_INTERFACE_DEFINED__
#define __IEnumCATEGORYINFO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumCATEGORYINFO
 * at Fri Mar 08 18:28:13 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumCATEGORYINFO __RPC_FAR *LPENUNCATEGORYINFO;

			/* size is 276 */
typedef struct  tagCATEGORYINFO
    {
    CATID catid;
    LCID lcid;
    OLECHAR szDescription[ 128 ];
    }	CATEGORYINFO;

			/* size is 4 */
typedef struct tagCATEGORYINFO __RPC_FAR *LPCATEGORYINFO;


EXTERN_C const IID IID_IEnumCATEGORYINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumCATEGORYINFO : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCATEGORYINFOVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumCATEGORYINFOVtbl;

    interface IEnumCATEGORYINFO
    {
        CONST_VTBL struct IEnumCATEGORYINFOVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCATEGORYINFO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCATEGORYINFO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCATEGORYINFO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCATEGORYINFO_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCATEGORYINFO_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCATEGORYINFO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCATEGORYINFO_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IEnumCATEGORYINFO_Next_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCATEGORYINFO_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumCATEGORYINFO_Skip_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCATEGORYINFO_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumCATEGORYINFO_Reset_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This);


void __RPC_STUB IEnumCATEGORYINFO_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumCATEGORYINFO_Clone_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumCATEGORYINFO_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCATEGORYINFO_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0007
 * at Fri Mar 08 18:28:13 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATREGISTER_DEFINED
#define _LPCATREGISTER_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0007_v0_0_s_ifspec;

#ifndef __ICatRegister_INTERFACE_DEFINED__
#define __ICatRegister_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatRegister
 * at Fri Mar 08 18:28:13 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ICatRegister __RPC_FAR *LPCATREGISTER;


EXTERN_C const IID IID_ICatRegister;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICatRegister : public IUnknown
    {
    public:
        virtual HRESULT __stdcall RegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]) = 0;
        
        virtual HRESULT __stdcall UnRegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT __stdcall RegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT __stdcall UnRegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT __stdcall RegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT __stdcall UnRegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatRegisterVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ICatRegister __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ICatRegister __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *RegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *UnRegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *RegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *UnRegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *RegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *UnRegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
    } ICatRegisterVtbl;

    interface ICatRegister
    {
        CONST_VTBL struct ICatRegisterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatRegister_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatRegister_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatRegister_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatRegister_RegisterCategories(This,cCategories,rgCategoryInfo)	\
    (This)->lpVtbl -> RegisterCategories(This,cCategories,rgCategoryInfo)

#define ICatRegister_UnRegisterCategories(This,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterCategories(This,cCategories,rgcatid)

#define ICatRegister_RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ICatRegister_RegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);


void __RPC_STUB ICatRegister_RegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_UnRegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_RegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_UnRegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_RegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_UnRegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatRegister_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0008
 * at Fri Mar 08 18:28:13 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATINFORMATION_DEFINED
#define _LPCATINFORMATION_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0008_v0_0_s_ifspec;

#ifndef __ICatInformation_INTERFACE_DEFINED__
#define __ICatInformation_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatInformation
 * at Fri Mar 08 18:28:13 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ICatInformation __RPC_FAR *LPCATINFORMATION;


EXTERN_C const IID IID_ICatInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICatInformation : public IUnknown
    {
    public:
        virtual HRESULT __stdcall EnumCategories( 
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo) = 0;
        
        virtual HRESULT __stdcall GetCategoryDesc( 
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc) = 0;
        
        virtual HRESULT __stdcall EnumClassesOfCategories( 
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid) = 0;
        
        virtual HRESULT __stdcall IsClassOfCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]) = 0;
        
        virtual HRESULT __stdcall EnumImplCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
        virtual HRESULT __stdcall EnumReqCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatInformationVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ICatInformation __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ICatInformation __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *EnumCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);
        
        HRESULT ( __stdcall __RPC_FAR *GetCategoryDesc )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc);
        
        HRESULT ( __stdcall __RPC_FAR *EnumClassesOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);
        
        HRESULT ( __stdcall __RPC_FAR *IsClassOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *EnumImplCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        HRESULT ( __stdcall __RPC_FAR *EnumReqCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
    } ICatInformationVtbl;

    interface ICatInformation
    {
        CONST_VTBL struct ICatInformationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatInformation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatInformation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatInformation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatInformation_EnumCategories(This,lcid,ppenumCategoryInfo)	\
    (This)->lpVtbl -> EnumCategories(This,lcid,ppenumCategoryInfo)

#define ICatInformation_GetCategoryDesc(This,rcatid,lcid,pszDesc)	\
    (This)->lpVtbl -> GetCategoryDesc(This,rcatid,lcid,pszDesc)

#define ICatInformation_EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)	\
    (This)->lpVtbl -> EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)

#define ICatInformation_IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)	\
    (This)->lpVtbl -> IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)

#define ICatInformation_EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)

#define ICatInformation_EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ICatInformation_EnumCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);


void __RPC_STUB ICatInformation_EnumCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_GetCategoryDesc_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCATID rcatid,
    /* [in] */ LCID lcid,
    /* [out] */ LPWSTR __RPC_FAR *pszDesc);


void __RPC_STUB ICatInformation_GetCategoryDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_EnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);


void __RPC_STUB ICatInformation_EnumClassesOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_IsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);


void __RPC_STUB ICatInformation_IsClassOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_EnumImplCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumImplCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_EnumReqCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumReqCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatInformation_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0009
 * at Fri Mar 08 18:28:13 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL__intf_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0009_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cpaldc.h ===
//  Copyright (C) Microsoft Corporation 1993-1997

// Stripped down version of cpaldc in hha.dll

const int SCREEN_DC = 0;
const int SCREEN_IC = 1;

class CPalDC
{
public:

    CPalDC(HBITMAP hbmp = NULL, HPALETTE hpal = NULL);
    CPalDC::~CPalDC(void);
    CPalDC(int type);

    void SelectPal(HPALETTE hpalSel);
    HPALETTE CreateBIPalette(HBITMAP hbmp);
    int GetDeviceWidth(void) const { return GetDeviceCaps(m_hdc, HORZRES); };
    int GetDeviceHeight(void) const { return GetDeviceCaps(m_hdc, VERTRES); };
    int GetDeviceColors(void) const { return GetDeviceCaps(m_hdc, NUMCOLORS); };

    HDC m_hdc;
    HPALETTE m_hpalOld;
    HPALETTE m_hpal;
    HBITMAP  m_hbmpOld;
    HBITMAP  m_hbmp;

    operator HDC() const { return m_hdc; }
    operator HBITMAP() const { return m_hbmp; }
    operator HPALETTE() const { return m_hpal; }

protected:
    BOOL m_fHdcCreated;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cpaldc.cpp ===
//  Copyright (C) Microsoft Corporation 1993-1997

#include "header.h"
#include "cpaldc.h"

CPalDC::CPalDC(HBITMAP hbmpSel, HPALETTE hpalSel)
{
    ClearMemory(this, sizeof(CPalDC));

    m_hdc = CreateCompatibleDC(NULL);
    ASSERT(m_hdc);

    if (hpalSel)
        SelectPal(hpalSel);

    m_hpal = hpalSel;
    m_hbmp = hbmpSel;
    if (m_hbmp) {

        // Can fail if hbmp is selected into another DC

        VERIFY((m_hbmpOld = (HBITMAP) SelectObject(m_hdc, m_hbmp)));
    }
}

CPalDC::CPalDC(int type)
{
    ClearMemory(this, sizeof(CPalDC));
    switch (type) {
        case SCREEN_DC:
            m_hdc = CreateDC("DISPLAY", NULL, NULL, NULL);
            break;

        case SCREEN_IC:
            m_hdc = CreateIC("DISPLAY", NULL, NULL, NULL);
            break;

        default:
            ASSERT(type == SCREEN_DC);
            break;
    }

    ASSERT(m_hdc);
}

CPalDC::~CPalDC(void)
{
    if (!m_hdc)
        return;
    if (m_hpalOld)
        SelectPalette(m_hdc, m_hpal, FALSE);
    if (m_hbmpOld)
        SelectObject(m_hdc, m_hbmpOld);
    DeleteDC(m_hdc);
}

void CPalDC::SelectPal(HPALETTE hpalSel)
{
    if (hpalSel) {
        if (m_hpalOld)       // m_hpalOld is set once, and only once
            SelectPalette(m_hdc, m_hpal, FALSE);
        else
            m_hpalOld = SelectPalette(m_hdc, m_hpal, FALSE);

        RealizePalette(m_hdc);
    }
    else if (m_hpalOld) {
        SelectPalette(m_hdc, m_hpalOld, FALSE);
        m_hpalOld = NULL;
    }
}

HPALETTE CPalDC::CreateBIPalette(HBITMAP hbmp)
{
    PBITMAPINFO pbmi = (PBITMAPINFO) lcCalloc(sizeof(BITMAPINFOHEADER) +
        sizeof(RGBQUAD) * 256);
    PBITMAPINFOHEADER pbih = (PBITMAPINFOHEADER) pbmi;

    BITMAP bmp;
    GetObject(hbmp, sizeof(BITMAP), &bmp);

    pbih->biPlanes = bmp.bmPlanes;
    pbih->biBitCount = bmp.bmBitsPixel;
    pbih->biWidth = bmp.bmWidth;
    pbih->biHeight = bmp.bmHeight;
    pbih->biSize = sizeof(BITMAPINFOHEADER);
    pbih->biCompression = BI_RGB;

    if (!GetDIBits(m_hdc, hbmp, 0, 1, NULL, pbmi, DIB_RGB_COLORS))
        return NULL;

    HPALETTE hpal = ::CreateBIPalette(pbih);
    lcFree(pbmi);
    return hpal;
}

// REVIEW: only works with 256-color bitmaps

#define PALVERSION      0x300

HPALETTE CreateBIPalette(PBITMAPINFOHEADER pbihd)
{
    // Allocate for the logical palette structure

    LOGPALETTE* pPal = (LOGPALETTE*) lcMalloc(sizeof(LOGPALETTE) +
        256 * sizeof(PALETTEENTRY));

    pPal->palNumEntries = 256;
    pPal->palVersion    = PALVERSION;

    /*
     * Fill in the palette entries from the DIB color table and
     * create a logical color palette.
     */

    RGBQUAD* pRgb = (RGBQUAD*)(((PBYTE) pbihd) + pbihd->biSize);

    for (int i = 0; i < (int) 256; i++){
        pPal->palPalEntry[i].peRed   = pRgb[i].rgbRed;
        pPal->palPalEntry[i].peGreen = pRgb[i].rgbGreen;
        pPal->palPalEntry[i].peBlue  = pRgb[i].rgbBlue;
        pPal->palPalEntry[i].peFlags = (BYTE) 0;
    }
    HPALETTE hpal = CreatePalette(pPal);
    lcFree(pPal);

    return hpal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cprint.cpp ===
// Copyright (c) 1996-1997, Microsoft Corp. All rights reserved.

#include "header.h"
#include "contain.h"
#include "cprint.h"
#include "secwin.h"
#include "web.h"
#include "contain.h"
#include <exdisp.h>
#include <exdispid.h>
#include "cdlg.h"
#include "resource.h"
#include "progress.h"
#include "cpaldc.h"
#include "hha_strtable.h"
#include "animate.h"
#include <wininet.h>

// #define INITGUID
#include <mshtmhst.h>
#include <mshtmcid.h>

BOOL CPrint::OnBeginOrEnd(void)
{
    if (m_fInitializing) {
        switch (m_action) {
            case PRINT_CUR_ALL:
                SetCheck(IDRADIO_PRINT_ALL);
                break;

            case PRINT_CUR_HEADING:
                SetCheck(IDRADIO_PRINT_BOOK);
                break;

            default:
                SetCheck(IDRADIO_PRINT_CURRENT);
                break;

        }
    }
    else {
        if (GetCheck(IDRADIO_PRINT_ALL))
            m_action = PRINT_CUR_ALL;
        else if (GetCheck(IDRADIO_PRINT_BOOK))
            m_action = PRINT_CUR_HEADING;
        else
            m_action = PRINT_CUR_TOPIC;
    }

    return TRUE;
}

void CHHWinType::OnPrint(void)
{
    HWND hWnd;

	if (m_pCIExpContainer == NULL)
	{
		return;
	}

    static BOOL fCurrentlyPrinting = FALSE;
    if (fCurrentlyPrinting) {
        MsgBox(IDS_PRINTING);
        return;
    }
    CToc* ptoc = reinterpret_cast<CToc*>(m_aNavPane[HH_TAB_CONTENTS]) ; // HACKHACK: This should be a dynamic_cast. However, we are not compiling with RTTI.
    hWnd = GetFocus();
    int action = PRINT_CUR_TOPIC;
    if (IsExpandedNavPane() && curNavType == HHWIN_NAVTYPE_TOC && ptoc != NULL)
    {
        HTREEITEM hitem = TreeView_GetSelection(ptoc->m_hwndTree);
        if (hitem) {
            CPrint prt(*this);
            prt.SetAction(action);
            if (!prt.DoModal())
            {
                SetFocus(hWnd);
                return;
            }
            action = prt.GetAction();
        }
    }

    if (action == PRINT_CUR_TOPIC) {
        m_pCIExpContainer->m_pIE3CmdTarget->Exec(NULL, OLECMDID_PRINT,
            OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
    }
    else {
        fCurrentlyPrinting = TRUE;
        PrintTopics(action, ptoc, m_pCIExpContainer->m_pWebBrowserApp, GetHwnd());
        fCurrentlyPrinting = FALSE;
    }
    SetFocus(hWnd);
}

void PrintTopics(int action, CToc* ptoc, IWebBrowserAppImpl* pWebApp, HWND hWndHelp /* = NULL */)
{
    ASSERT(pWebApp && pWebApp);

    if (ptoc == NULL || pWebApp == NULL)
        return;

    static BOOL fCurrentlyPrinting = FALSE;
    if (fCurrentlyPrinting) {
        MsgBox(IDS_PRINTING);
        return;
    }
    fCurrentlyPrinting = TRUE;
    CStr cszCurrentUrl;
    pWebApp->GetLocationURL(&cszCurrentUrl);
    CPrintHook ph(cszCurrentUrl, ptoc, hWndHelp);
    ph.BeginPrinting(action);
    fCurrentlyPrinting = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CPrintHook member functions
CPrintHook::CPrintHook(PCSTR pszFirstUrl, CToc* pToc, HWND hWndHelp /* = NULL */)
    : m_pcp(NULL), m_dwCookie(0), m_ref(0), m_pToc(pToc), m_action(PRINT_CUR_TOPIC),
    m_hWndHelp(hWndHelp), m_phh(NULL), m_level(0),
    m_fFirstHeading(TRUE), m_fDestroyHelpWindow(FALSE), m_cszFirstUrl(pszFirstUrl),
    m_fIsIE3(FALSE), m_cszPrintFile("")
{
    m_phh = pToc->m_phh;
}


BOOL CPrintHook::CreatePrintWindow(CStr* pcszUrl /* = NULL */)
{
    BOOL bReturn = FALSE;

    HH_WINTYPE hhWinType;
    ZERO_STRUCTURE(hhWinType);
    hhWinType.cbStruct = sizeof(HH_WINTYPE);
    hhWinType.pszType = txtPrintWindow;
    hhWinType.pszCaption = GetStringResource(IDS_PRINT_CAPTION);
    hhWinType.rcWindowPos.left = 0;
    hhWinType.rcWindowPos.top = 0;
    hhWinType.rcWindowPos.right = 200;
    hhWinType.rcWindowPos.bottom = 200;
    hhWinType.dwStyles = WS_MINIMIZE;
    hhWinType.fsValidMembers = HHWIN_PARAM_RECT | HHWIN_PARAM_STYLES;

    xHtmlHelpA(NULL, NULL, HH_SET_WIN_TYPE, (DWORD_PTR) &hhWinType);

    m_hWndHelp = xHtmlHelpA(NULL, txtPrintWindow, HH_DISPLAY_TOPIC, (DWORD_PTR) (pcszUrl ? pcszUrl->psz : m_cszFirstUrl.psz));
    m_fDestroyHelpWindow = TRUE;

    if (m_hWndHelp != NULL)
    {
        StartAnimation(IDS_GATHERING_PRINTS, m_hWndHelp);
        m_phh = FindWindowIndex(m_hWndHelp);

        if (!m_fDestroyHelpWindow)
            m_phh->m_pCIExpContainer->m_pWebBrowserApp->Navigate((pcszUrl ? (PCSTR)*pcszUrl : (PCSTR)m_cszFirstUrl),
                                                                    NULL, NULL, NULL, NULL);

        // Set up the event sink for the WebBrowser control.
        LPCONNECTIONPOINTCONTAINER pcpc;
        HRESULT hr = m_phh->m_pCIExpContainer->m_pWebBrowserApp->m_lpDispatch->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&pcpc);

        if (SUCCEEDED(hr))
        {
            // Try to find the connection point for DIID_DWebBrowserEvents2.
            // If that fails, try DIID_DWebBrowserEvents.
            hr = pcpc->FindConnectionPoint(DIID_DWebBrowserEvents2, &m_pcp);

            if (FAILED(hr))
            {
                m_fIsIE3 = TRUE;
                hr = pcpc->FindConnectionPoint(DIID_DWebBrowserEvents, &m_pcp);
            }

            pcpc->Release();

            if (SUCCEEDED(hr))
            {
                hr = m_pcp->Advise((LPUNKNOWN)(LPDISPATCH)this, &m_dwCookie);
                bReturn = TRUE;
            }
        }
    }

    return bReturn;
}


void CPrintHook::DestroyPrintWindow()
{
    // Disconnect the event sink.
    if (m_pcp != NULL)
    {
#ifdef _DEBUG
        HRESULT hr = m_pcp->Unadvise(m_dwCookie);
        ASSERT(SUCCEEDED(hr));
#else
        m_pcp->Unadvise(m_dwCookie);
#endif
        m_pcp->Release();
        m_pcp = NULL;
    }

    if (m_hWndHelp != NULL)
    {
        if (m_fDestroyHelpWindow)
        {
            DestroyWindow(m_hWndHelp);
            m_hWndHelp = NULL;
        }
    }

    DeleteFile(m_cszPrintFile);
}


CPrintHook::~CPrintHook()
{
    DestroyPrintWindow();

    ASSERT(m_ref == 0);
}


// Generic OLE method implementations.

STDMETHODIMP CPrintHook::QueryInterface(
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvObject)
{
    if (DO_GUIDS_MATCH(riid, IID_IUnknown) ||
        DO_GUIDS_MATCH(riid, IID_IDispatch) ||
        DO_GUIDS_MATCH(riid, DIID_DWebBrowserEvents) ||
        DO_GUIDS_MATCH(riid, DIID_DWebBrowserEvents2))
    {
        *ppvObject = (LPVOID)this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObject = NULL;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CPrintHook::AddRef(void)
{
    return ++m_ref;
}

STDMETHODIMP_(ULONG) CPrintHook::Release(void)
{
    return --m_ref;
}

// IDispatch method implementation.

STDMETHODIMP CPrintHook::GetTypeInfoCount(
    /* [out] */ UINT *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPrintHook::GetTypeInfo(
    /* [in] */ UINT iTInfo,
    /* [in] */ LCID lcid,
    /* [out] */ ITypeInfo **ppTInfo)
{
    // arg checking

    if (iTInfo != 0)
        return DISP_E_BADINDEX;

    if (!ppTInfo)
        return E_POINTER;

    *ppTInfo = NULL;

    return E_NOTIMPL;
}

STDMETHODIMP CPrintHook::GetIDsOfNames(
    /* [in] */ REFIID riid,
    /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
    /* [in] */ UINT cNames,
    /* [in] */ LCID lcid,
    /* [size_is][out] */ DISPID __RPC_FAR *rgDispId)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPrintHook::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID riid,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [out][in] */ DISPPARAMS *pdispparams,
    /* [out] */ VARIANT  *pVarResult,
    /* [out] */ EXCEPINFO  *pExcepInfo,
    /* [out] */ UINT  *puArgErr)
{
    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return DISP_E_UNKNOWNINTERFACE;

    if (!(wFlags & DISPATCH_METHOD))
        return E_INVALIDARG;

    switch (dispIdMember)
    {
       case DISPID_BEFORENAVIGATE:
            DBWIN("DISPID_BEFORENAVIGATE\n");
            break;

       case DISPID_BEFORENAVIGATE2:     // ie4 version.
          char szURL[MAX_URL];
          char szTFN[MAX_URL];
          char szHeaders[MAX_URL];
          WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[5].pvarVal->bstrVal, -1, szURL, sizeof(szURL), NULL, NULL);
          // 27-Sep-1997 [ralphw] IE 4 will send us a script command, followed
          // by a 1 then the current URL. We don't care about the current URL
          // in this case, so we nuke it.
          {
             PSTR pszCurUrl = StrChr(szURL, 1);
             if (pszCurUrl)
                 *pszCurUrl = '\0';
          }
          szTFN[0] = 0;
          if( pdispparams->rgvarg[3].pvarVal->bstrVal )
            WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[3].pvarVal->bstrVal, -1, szTFN, sizeof(szTFN), NULL, NULL);
          szHeaders[0] = 0;
          if( pdispparams->rgvarg[1].pvarVal->bstrVal )
            WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[1].pvarVal->bstrVal, -1, szHeaders, sizeof(szHeaders), NULL, NULL);

//        OnBeforeNavigate(szURL, (long)pdispparams->rgvarg[4].pvarVal->lVal, szTFN,
//                         pdispparams->rgvarg[2].pvarVal, szHeaders, (BOOL*)pdispparams->rgvarg[0].pboolVal );
          break;

#if 0
        case DISPID_STATUSTEXTCHANGE:
            DBWIN("DISPID_STATUSTEXTCHANGE\n");
            break;

        case DISPID_DOWNLOADBEGIN:
            DBWIN("DISPID_DOWNLOADBEGIN\n");
            break;

        case DISPID_NEWWINDOW:
            DBWIN("DISPID_NEWWINDOW\n");
            break;

        case DISPID_WINDOWMOVE:
            DBWIN("DISPID_WINDOWMOVE\n");
            break;

        case DISPID_WINDOWRESIZE:
            DBWIN("DISPID_WINDOWRESIZE\n");
            break;

        case DISPID_WINDOWACTIVATE:
            DBWIN("DISPID_WINDOWACTIVATE\n");
            break;

        case DISPID_PROPERTYCHANGE:
            DBWIN("DISPID_PROPERTYCHANGE\n");
            break;

        case DISPID_TITLECHANGE:
            DBWIN("DISPID_TITLECHANGE\n");
            break;

        case DISPID_FRAMEBEFORENAVIGATE:
            DBWIN("DISPID_FRAMEBEFORENAVIGATE\n");
            break;

        case DISPID_FRAMENAVIGATECOMPLETE:
            DBWIN("DISPID_FRAMENAVIGATECOMPLETE\n");
            break;

        case DISPID_FRAMENEWWINDOW:
            DBWIN("DISPID_FRAMENEWWINDOW\n");
            break;

        case DISPID_NAVIGATECOMPLETE:
            DBWIN("DISPID_NAVIGATECOMPLETE\n");
            break;

        case DISPID_DOWNLOADCOMPLETE:
            DBWIN("DISPID_DOWNLOADCOMPLETE\n");
            break;

        case DISPID_DOCUMENTCOMPLETE:
            DBWIN("DISPID_DOCUMENTCOMPLETE\n");
            break;
#endif
        case DISPID_PROGRESSCHANGE:
            ASSERT(pdispparams->cArgs == 2);
            DBWIN("DISPID_PROGRESSCHANGE\n");
            OnProgressChange(V_I4(&(pdispparams->rgvarg[1])), V_I4(&(pdispparams->rgvarg[0])));
#if 1
#ifdef _DEBUG
            char szDebug[80];
            wsprintf(szDebug, "ProgressChange(%li, %li)\n", V_I4(&(pdispparams->rgvarg[1])), V_I4(&(pdispparams->rgvarg[0])));
            DBWIN(szDebug);
#endif
#endif
    }

    return S_OK;
}

void CPrintHook::OnProgressChange(LONG lProgress, LONG lProgressMax)
{
    if (lProgress == -1)
    {
        StopAnimation();
        // Print the page if it isn't a duplicate.
        if (m_fIsPrinting)
        {
            Print();
            DBWIN("Printing");
        }
    }
    else
        NextAnimation();
}

// This function allows the WebBrowser to handle its queued messages before continuing.

BOOL CPrintHook::PumpMessages()
{
    MSG msg;

    // Handle WebBrowser window messages
    while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
      if (!m_fIsPrinting)
      {
          if (m_phh && m_phh->m_pCIExpContainer && m_phh->m_pCIExpContainer->m_pWebBrowserApp)
          {
              m_phh->m_pCIExpContainer->m_pWebBrowserApp->Stop();
          }
          return FALSE;
      }

      if(!IsDialogMessage(m_hWndHelp, &msg))
      {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
      }
    }

    return TRUE;
}

void CPrintHook::BeginPrinting(int action)
{
    m_pos = 1;
    m_level = 0;
    m_action = action;
    m_fIsPrinting = TRUE;
    m_fFirstHeading = TRUE;
    SITEMAP_ENTRY* psme = NULL;
    TV_ITEM tvi;

    if (m_action == PRINT_CUR_TOPIC || m_action == PRINT_CUR_HEADING)
    {
        tvi.hItem = TreeView_GetSelection(m_pToc->m_hwndTree);
        if (!tvi.hItem)
            goto ExitBegin;      // no current selection

        if (m_pToc->m_fBinaryTOC == FALSE)
        {
            tvi.mask = TVIF_PARAM;
            if (TreeView_GetItem(m_pToc->m_hwndTree, &tvi))
                psme = m_pToc->m_sitemap.GetSiteMapEntry((int)tvi.lParam);
            if (psme == NULL)
                goto ExitBegin;
            m_pos = (int)tvi.lParam;

            // Because the user may have selected a topic under a heading, but
            // wants to print all of the topics under that heading, we have to
            // search upward until we find the heading.
            if (m_action == PRINT_CUR_HEADING)
            {
                if (psme->fTopic || psme->cUrls <= 0)
                {
                    while (psme != NULL && psme->fTopic && m_pos > 0)
                    {
                        psme = m_pToc->m_sitemap.GetSiteMapEntry(--m_pos);
                    }
                }
            }
            // Set the current level for reference later.  If the user just
            // wants to print the current topic, the level isn't significant.
            m_level = ((m_action == PRINT_CUR_TOPIC || psme == NULL) ? 0 : psme->level);
        }
    }

    if (m_pToc->m_fBinaryTOC == FALSE)
    {
        // If the user isn't printing all topics and psme is NULL,
        // see if this is just a single topic and, if so, print it.
        if (m_action != PRINT_CUR_ALL && psme == NULL)
        {
            // Get the original sitemap entry.
            m_pos = (int)tvi.lParam;
            psme = m_pToc->m_sitemap.GetSiteMapEntry(m_pos);

            // If there's a URL, print it.
            if (psme->cUrls > 0)
            {
                m_action = PRINT_CUR_TOPIC;
            }
        }
    }
    if (BuildPrintTable())
    {
        // We sit in this loop while printing because we don't want this
        // function to return until printing is complete.
        while (PumpMessages());
        DestroyPrintWindow();
    }

ExitBegin:
    return;
}

BOOL CPrintHook::BuildPrintTable()
{
    BOOL bReturn = FALSE;

    if (!m_fIsPrinting)
        return bReturn;

    CTable table;
    CStr cszCurUrl;

    if (m_pToc->m_fBinaryTOC)
    {
        switch (m_action)
        {
            case PRINT_CUR_TOPIC:
                m_pToc->m_phhctrl->m_pWebBrowserApp->GetLocationURL(&cszCurUrl);
                table.AddString((PCSTR)cszCurUrl);
                break;

            case PRINT_CUR_HEADING:
                TV_ITEM tvi;

                tvi.hItem = TreeView_GetSelection(m_pToc->m_hwndTree);
                if (!tvi.hItem)
                {
                    m_pToc->m_phhctrl->m_pWebBrowserApp->GetLocationURL(&cszCurUrl);
                    table.AddString((PCSTR)cszCurUrl);
                 }
                else
                {
                    tvi.mask = TVIF_PARAM;
                    TreeView_GetItem(m_pToc->m_hwndTree, &tvi);

                    CTreeNode *p = (CTreeNode *)tvi.lParam;
                    CTreeNode *pParent = NULL;

                    if (p->GetType() == TOPIC)
                    {
                      pParent = p->GetParent();
                    }
               CHourGlass hour;
                    m_phh->m_phmData->m_pTitleCollection->GetChildURLS((pParent ? pParent: p), &table);
                    if (pParent)
                        delete pParent;
                 }
                 break;

            case PRINT_CUR_ALL:
                if (!m_pToc->m_pBinTOCRoot)
                {
                    m_pToc->m_phhctrl->m_pWebBrowserApp->GetLocationURL(&cszCurUrl);
                    table.AddString((PCSTR)cszCurUrl);
                }
                else
                    m_phh->m_phmData->m_pTitleCollection->GetChildURLS(m_pToc->m_pBinTOCRoot, &table);  // oh my god they are printing the entire TOC
                break;
        }
    }
    else
    {
        // Get the next sitemap entry.
        // Print the sitemap entry URL if the its level is greater than
        // the saved level.  If the sitemap entry is a heading at the same
        // level and contains a URL, proceed as well.
        for (SITEMAP_ENTRY* psme = m_pToc->m_sitemap.GetSiteMapEntry(m_pos);
            psme != NULL;
            psme = m_pToc->m_sitemap.GetSiteMapEntry(++m_pos))
        {
            if ((psme->level > m_level) ||
                (!psme->fTopic && psme->level == m_level && m_fFirstHeading))
            {
                // The top level heading could have a URL, so we
                // want to print it.  However, we don't want to print
                // any other headings at that level, so set the
                // m_fFirstHeading flag to FALSE.
                if (m_action == PRINT_CUR_HEADING &&
                    !psme->fTopic &&
                    psme->level == m_level)
                {
                    m_fFirstHeading = FALSE;
                }

                if (psme->cUrls > 0)
                {
                    // Get the URL from the sitemap entry.
                    LPCTSTR pszUrl = (psme->pUrls->urlPrimary ? psme->pUrls->urlPrimary : psme->pUrls->urlSecondary);
                    CStr cszUrl(pszUrl);

                    // Synchronize the TOC if we created the print window.
                    if (m_fDestroyHelpWindow)
                        m_pToc->Synchronize(cszUrl);

                    // Truncate the strings at the # character if there is one.
                    LPTSTR pszFind = StrChr(cszUrl, '#');
                    if (pszFind != NULL)
                       *pszFind = '\0';

                    ConvertBackSlashToForwardSlash(cszUrl);

                    if (table.IsStringInTable(cszUrl) == 0)
                        table.AddString((PCSTR)cszUrl);

                    if (m_action == PRINT_CUR_TOPIC)
                        break;
                }
            }
            else
                break;
        }
    }

    if (m_pToc->m_phhctrl != NULL)
    {
        m_pToc->m_phhctrl->m_pWebBrowserApp->GetLocationURL(&cszCurUrl);
        m_hwndParent = m_pToc->m_phhctrl->m_hwndParent;
    }
    else if (m_pToc->m_fBinaryTOC)
    {
        cszCurUrl = m_phh->GetToc();
        m_hwndParent = m_phh->GetHwnd();
    }
    else
    {
        cszCurUrl = m_pToc->m_sitemap.GetSiteMapFile();
        if (m_phh)
            m_hwndParent = m_phh->GetHwnd();
        else
            m_hwndParent = m_hWndHelp;
    }

    if (ConstructFile((PCSTR)cszCurUrl, &table, &m_cszPrintFile))
    {
        bReturn = CreatePrintWindow(&m_cszPrintFile);
    }

    return bReturn;
}

static const char txtTmpPrefix[] = "~hh";
static const char txtHtmlExtension[] = ".htm";
static const char txtImg[] = "IMG";
static const char txtSrc[] = "SRC";
static const char txtLink[] = "LINK";
static const char txtHREF[] = "HREF";
static const char txtTagBeginBody[] = "BODY";
static const char txtTagEndBody[] = "/BODY";
static const char txtTagItAll[] = "</BODY></HTML>";
static const char txtTmpPrintStinrg[] = "~hh%X.htm";
static const char txtFrame[] = "FRAME";
static const char txtBeginScript[] = "SCRIPT";
static const char txtEndScript[] = "/SCRIPT";

const int FILE_PAD = 16 * 1024;

BOOL CPrintHook::ConstructFile(PCSTR pszCurrentUrl, CTable* pFileTable,
    CStr* pm_cszPrintFile)
{
    char szTempPath[MAX_PATH];
    char szHtmlFile[MAX_PATH];
    char szThisURL[MAX_PATH];
    char szCurrentUrl[MAX_PATH];

    CProgress progress(GetStringResource(IDS_GATHERING_PRINTS),
        m_hwndParent, pFileTable->CountStrings() / 10, 10);

    strcpy(szCurrentUrl, pszCurrentUrl);
    PSTR pszFilePortion = (PSTR) FindFilePortion(szCurrentUrl);
    ASSERT(pszFilePortion);

    GetTempPath(sizeof(szHtmlFile), szHtmlFile);
    AddTrailingBackslash(szHtmlFile);
    wsprintf(szHtmlFile + strlen(szHtmlFile), txtTmpPrintStinrg, GetTickCount() & 0xFFFF);
    HFILE hfDst = _lcreat(szHtmlFile, 0);
    if (hfDst == HFILE_ERROR) {
        MsgBox(IDS_FILE_ERROR, szHtmlFile, MB_OK);
        return FALSE;
    }

    int endpos = pFileTable->CountStrings();
    PSTR pszMem = NULL;
    CStr cszTmpFile;

    for (int i = 1; i <= endpos; i++) {
        BOOL fSeenBody = FALSE;
        if (pszMem) {
            GlobalFree((HGLOBAL) pszMem);
            pszMem = NULL;
        }
        progress.Progress();

        ASSERT_COMMENT(pFileTable->CountStrings(), "Empty file list");

        PSTR pszFile;
        if (!StrChr(pFileTable->GetPointer(i), CH_COLON)) {
            if (*pFileTable->GetPointer(i) == '/' || *pFileTable->GetPointer(i) == '\\')
            {
                TranslateUrl(szCurrentUrl, pFileTable->GetPointer(i));
            }
            else
            {
                strcpy(pszFilePortion, pFileTable->GetPointer(i));
            }
            pszFile = szCurrentUrl;
        }
        else {
            pszFile = pFileTable->GetPointer(i);
            PSTR psz = stristr(pszFile, txtSysRoot);
            if (psz) {
                char szPath[MAX_PATH];
                GetRegWindowsDirectory(szPath);
                strcat(szPath, psz + strlen(txtSysRoot));
                cszTmpFile = szPath;
                pszFile = cszTmpFile.psz;
            }
            else if (IsCompiledHtmlFile(pszFile, &cszTmpFile)) {
                pszFile = cszTmpFile.psz;
            }
        }

      strcpy(szThisURL, pszFile);

        if (!ConvertToCacheFile(pszFile, szTempPath)) {
            // AuthorMsg(IDS_CANT_OPEN, pFileTable->GetPointer(i), m_hwndParent, NULL);
            continue;
        }

        int cbMem;
        UINT cbFile, cbFinalLen;
        PSTR psz, pszStart , pszTag;

        if ( IsCompiledURL(szTempPath ) ) {
            CStr cszCompiledName;
            PCSTR pszStream = GetCompiledName(szTempPath, &cszCompiledName);
			if (pszStream == NULL)
				continue;

            // BUGBUG: should use existing file system handle if available

            CFSClient fs;
            if (!fs.Initialize(cszCompiledName)) {
                MsgBox(IDS_FILE_ERROR, pFileTable->GetPointer(i), MB_OK);
                continue;
            }
            if (FAILED(fs.OpenStream(pszStream))) {
                // AuthorMsg(IDS_CANT_OPEN, pFileTable->GetPointer(i), m_hwndParent, NULL);
                continue;
            }

            cbFile = fs.SeekSub(0, SK_END);
         cbFinalLen = cbFile;
            fs.SeekSub(0, SK_SET);
            cbMem = cbFile + FILE_PAD;
            pszMem = (PSTR) GlobalAlloc(GMEM_FIXED, cbMem);
            ASSERT(pszMem);
            if (!pszMem) {
                GlobalFree((HGLOBAL) pszMem);
                fs.CloseStream();
                continue;
            }
            if (FAILED(fs.Read((PBYTE) pszMem, cbFile))) {
                fs.CloseStream();
                continue;
            }
            fs.CloseStream();
        }
        else {
            HANDLE hf = CreateFile(szTempPath, GENERIC_READ, FILE_SHARE_READ,
                NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
            if (hf == INVALID_HANDLE_VALUE)
                goto BadFile;

            ASSERT(hf);
            cbFile = GetFileSize(hf, NULL);
         cbFinalLen = cbFile;
            cbMem = cbFile + FILE_PAD;
            pszMem = (PSTR) GlobalAlloc(GMEM_FIXED, cbMem);
            ASSERT(pszMem);
            if (!pszMem) {
                GlobalFree((HGLOBAL) pszMem);
                CloseHandle(hf);
                continue;   // next HTML file might be smaller, so try again
            }
            DWORD cbRead;
            if (!ReadFile(hf, pszMem, cbFile, &cbRead, NULL) || cbRead != cbFile) {
                CloseHandle(hf);
                continue;
            }
            CloseHandle(hf);
        }
        pszMem[cbFile] = '\0';

        psz = pszMem;
        pszStart = psz;
        pszTag = psz;
        while ((pszTag = StrChr(pszTag, '<'))) {
            pszTag = FirstNonSpace(pszTag + 1);
            if (IsSamePrefix(pszTag, txtTagEndBody, sizeof(txtTagEndBody) - 1)) {
                while (*pszTag != '<')  // back up to the angle bracket
                    pszTag--;
                cbFile = (int)(pszTag - pszStart);
                break;
            }
         else if (IsSamePrefix(pszTag, txtBeginScript, sizeof(txtBeginScript) - 1)) {
            // skip to end tag
            while ((pszTag = StrChr(pszTag, '<'))) {
               pszTag = FirstNonSpace(pszTag + 1);
               if (IsSamePrefix(pszTag, txtEndScript, sizeof(txtEndScript) - 1))
                  break;
            }
         }
            else if (IsSamePrefix(pszTag, txtTagBeginBody, sizeof(txtTagBeginBody) - 1)) {

                // If this isn't the first HTML file, then we ignore everything
                // up to the body tag

                if (i > 1 && !fSeenBody) {
                    fSeenBody = TRUE;
                    pszStart = StrChr(pszTag, '>');
                    if (!pszStart) {
                        AuthorMsg(IDSHHA_CORRUPTED_HTML, pFileTable->GetPointer(i), m_hwndParent, NULL);
                        goto BadFile;
                    }
                    pszStart++;
                    cbFile -= (int)(pszStart - pszMem);
                }
            }
            else if (IsSamePrefix(pszTag, txtImg, sizeof(txtImg) - 1)) {

                // Change the URL for images to be a full path -- this lets
                // the browser pull it in without us having to copy it
                // anywhere.

                pszTag += sizeof(txtImg) - 1;
                for(;;) {
                    while (*pszTag != ' ' && *pszTag != '>') {
                        if (*pszTag == CH_QUOTE) {
                            pszTag = StrChr(pszTag + 1, CH_QUOTE);
                            if (!pszTag) {
                                AuthorMsg(IDSHHA_CORRUPTED_HTML, pFileTable->GetPointer(i), m_hwndParent, NULL);
                                goto BadFile;
                            }
                        }
                        pszTag++;
                    }
                    if (*pszTag == '>')
                        goto NoSrcTag;
                    pszTag++;
                    if (IsSamePrefix(pszTag, txtSrc, sizeof(txtSrc) - 1))
                        break;
                    pszTag++;
                }
                ASSERT(IsSamePrefix(pszTag, txtSrc, sizeof(txtSrc) - 1));
                pszTag = StrChr(pszTag, '=');
                if (!pszTag) {
                    AuthorMsg(IDSHHA_CORRUPTED_HTML, pFileTable->GetPointer(i), m_hwndParent, NULL);
                    goto BadFile;
                }
                pszTag = FirstNonSpace(pszTag + 1);
                char chSearch;
                if (*pszTag == CH_QUOTE) {
                    chSearch = CH_QUOTE;
                    pszTag = FirstNonSpace(pszTag + 1);
                }
                else
                    chSearch = ' ';
                PSTR pszBeginUrl = pszTag;
                pszTag = StrChr(pszTag + 1, chSearch);
                if (!pszTag) {
                    AuthorMsg(IDSHHA_CORRUPTED_HTML, pFileTable->GetPointer(i), m_hwndParent, NULL);
                    goto BadFile;
                }
                char chSave = *pszTag;
                *pszTag = '\0';
                if (!StrChr(pszBeginUrl, CH_COLON)) {

                    // This makes it relative to the original HTML file,
                    // but not necessarily relative to the current file

                    CStr cszCompiledName;
                    char fname[_MAX_FNAME]="";
                    int diff=0;
                    PSTR pszBeginFile='\0';
                    strcpy(szTempPath, szThisURL);

                    if ( IsCompiledURL(szTempPath ) )
                    {   // a compiled URL with an image in it.
                        PCSTR pszStream = GetCompiledName(szTempPath, &cszCompiledName);
                        SplitPath(pszStream, NULL, NULL, fname, NULL);
                        pszBeginFile = stristr(szTempPath, fname);
                        ASSERT( pszBeginFile );
                        diff = (int)(strlen(szThisURL) - strlen(pszBeginFile));
                    }else
                    {   // non-compiled URL; an html file with and image in it
                        pszBeginFile = strrchr(szTempPath, '/');
                        ASSERT(pszBeginFile);
                        diff = (int)(pszBeginFile - szTempPath) + 1;
                    }

                    cbFile += diff;
                    cbFinalLen += diff;
                    while (cbFinalLen > (UINT) cbMem) {
                        int StartDiff = (int)(pszStart - pszMem);
                        int TagDiff = (int)(pszTag - pszMem);
                        int BeginDiff = (int)(pszBeginUrl - pszMem);
                        PSTR pszNew = (PSTR) GlobalReAlloc((HGLOBAL) pszMem, cbMem += FILE_PAD, GMEM_MOVEABLE);
                        ASSERT(pszNew);
                        if (!pszNew) {
                            GlobalFree((HGLOBAL) pszMem);
                            MsgBox(IDS_OOM);
                            _lclose(hfDst);
                            DeleteFile(szHtmlFile);
                            if (pszMem) {
                                GlobalFree((HGLOBAL) pszMem);
                                pszMem = NULL;
                            }
                            return FALSE;
                        }
                        pszMem = pszNew;
                        pszStart = pszMem + StartDiff;
                        pszTag = pszMem + TagDiff;
                        pszBeginUrl = pszMem + BeginDiff;
                    }
                    MoveMemory(pszTag + diff, pszTag, cbFinalLen - (pszTag - pszMem) - diff);

                    if ( !IsCompiledURL(szTempPath) )
                    {
                        strcpy(pszBeginFile, "/");
                        pszBeginFile ++;  // pointing at the NULL
                    }
                    strcpy(pszBeginFile, pszBeginUrl);
                    strcpy( pszBeginUrl, szTempPath);
                    pszTag += diff;
                    *pszTag = chSave;
                }
                else
                    *pszTag = chSave;
            }
            else if (IsSamePrefix(pszTag, txtLink, sizeof(txtLink) - 1)) {

                // Change the URL for CSS to be a full path -- this lets
                // the browser pull it in without us having to copy it
                // anywhere.

                pszTag += sizeof(txtImg) - 1;
                for(;;) {
                    while (*pszTag != ' ' && *pszTag != '>') {
                        if (*pszTag == CH_QUOTE) {
                            pszTag = StrChr(pszTag + 1, CH_QUOTE);
                            if (!pszTag) {
                                AuthorMsg(IDSHHA_CORRUPTED_HTML, pFileTable->GetPointer(i), m_hwndParent, NULL);
                                goto BadFile;
                            }
                        }
                        pszTag++;
                    }
                    if (*pszTag == '>')
                        goto NoSrcTag;
                    pszTag++;
                    if (IsSamePrefix(pszTag, txtHREF, sizeof(txtHREF) - 1))
                        break;
                    pszTag++;
                }
                ASSERT(IsSamePrefix(pszTag, txtHREF, sizeof(txtHREF) - 1));
                pszTag = StrChr(pszTag, '=');
                if (!pszTag) {
                    AuthorMsg(IDSHHA_CORRUPTED_HTML, pFileTable->GetPointer(i), m_hwndParent, NULL);
                    goto BadFile;
                }
                pszTag = FirstNonSpace(pszTag + 1);
                char chSearch;
                if (*pszTag == CH_QUOTE) {
                    chSearch = CH_QUOTE;
                    pszTag = FirstNonSpace(pszTag + 1);
                }
                else
                    chSearch = ' ';
                PSTR pszBeginUrl = pszTag;
                pszTag = StrChr(pszTag + 1, chSearch);
                if (!pszTag) {
                    AuthorMsg(IDSHHA_CORRUPTED_HTML, pFileTable->GetPointer(i), m_hwndParent, NULL);
                    goto BadFile;
                }
                char chSave = *pszTag;
                *pszTag = '\0';
                char szScratch[MAX_URL];
                if (!StrChr(pszBeginUrl, CH_COLON)) {

                    // BUGBUG: This makes it relative to the original HTML file,
                    // but not necessarily relative to the current file
                    strcpy(pszFilePortion, pszBeginUrl);
                    strcpy(szScratch, szCurrentUrl);
                }
                else
                {
                   // qualify .CHM filespec which will look like: MK@MSITStore:foo.chm::/bar.css
                   //
                   CExCollection* pCollection;
                   CExTitle* pTitle;
                   HRESULT hr;

                   if ( (pCollection = GetCurrentCollection(NULL, pszBeginUrl)) )
                   {
                      if ( SUCCEEDED(hr = pCollection->URL2ExTitle( pszBeginUrl, &pTitle )) && pTitle )
                      {
                         const char* pszPathName;
                         char* psz;
                         lstrcpy(szScratch, pszBeginUrl);
                         if ( (pszPathName = pTitle->GetPathName()) )
                         {
                            if ( (psz = StrChr(szScratch, CH_COLON)) )
                            {
                               ++psz;
                               strcpy(psz, pszPathName);
                               if ( (psz = StrStr(pszBeginUrl, "::")) )
                                  strcat(szScratch, psz);
                            }
                         }
                      }
                   }
                }
                int diff = (int)(strlen(szScratch) - strlen(pszBeginUrl));
                cbFile += diff;
                cbFinalLen += diff;
                while (cbFinalLen >= (UINT) cbMem) {
                    int StartDiff = (int)(pszStart - pszMem);
                    int TagDiff = (int)(pszTag - pszMem);
                    int BeginDiff = (int)(pszBeginUrl - pszMem);
                    PSTR pszNew = (PSTR) GlobalReAlloc((HGLOBAL) pszMem, cbMem += FILE_PAD, GMEM_MOVEABLE);
                    ASSERT(pszNew);
                    if (!pszNew) {
                        GlobalFree((HGLOBAL) pszMem);
                        MsgBox(IDS_OOM);
                        _lclose(hfDst);
                        DeleteFile(szHtmlFile);
                        if (pszMem) {
                            GlobalFree((HGLOBAL) pszMem);
                            pszMem = NULL;
                        }
                        return FALSE;
                    }
                    pszMem = pszNew;
                    pszStart = pszMem + StartDiff;
                    pszTag = pszMem + TagDiff;
                    pszBeginUrl = pszMem + BeginDiff;
                }
                MoveMemory(pszTag + diff, pszTag, cbFinalLen - (pszTag - pszMem) - diff);
                strcpy(pszBeginUrl, szScratch);
                pszTag += diff;
                *pszTag = chSave;
            }
            else if (IsSamePrefix(pszTag, txtFrame, sizeof(txtFrame) - 1)) {
                MsgBox(IDS_CANT_PRINT_FRAMESET);
                _lclose(hfDst);
                DeleteFile(szHtmlFile);
                if (pszMem) {
                    GlobalFree((HGLOBAL) pszMem);
                    pszMem = NULL;
                }
                return FALSE;
            }

NoSrcTag:
            pszTag++;   // skip over the '<'
        }
        if (_lwrite(hfDst, pszStart, cbFile) != cbFile) {
            MsgBox(IDS_INSUFFICIENT_SPACE, szHtmlFile, MB_OK);
            _lclose(hfDst);
            DeleteFile(szHtmlFile);
        }
BadFile:
        continue;
    }
    if (pszMem) {
        GlobalFree((HGLOBAL) pszMem);
        pszMem = NULL;
    }
    _lclose(hfDst);
    *pm_cszPrintFile = szHtmlFile;
    return TRUE;

#if 0
    BOOL bReturn = (GetSystemDirectory(m_szPrintFile, _MAX_PATH) > 0);

    if (bReturn)
    {
        StrCat(m_szPrintFile, "\\hhtest.htm");
        *pm_cszPrintFile = m_szPrintFile;

        HANDLE hFile = CreateFile(m_szPrintFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dwBytesWritten = 0;
            TCHAR szOpenHTML[] = "<HTML>\r\n<BODY>\r\n" \
                                 "<H2>Printing is not currently implemented.</H2>\r\n" \
                                 "<P></P>\r\n" \
                                 "<B>Here is the list of files that you asked to print:</B>\r\n"
                                 "<P></P>\r\n";
            WriteFile(hFile, (LPCVOID)szOpenHTML, strlen(szOpenHTML) * sizeof(TCHAR), &dwBytesWritten, NULL);

            TCHAR szFile[_MAX_PATH], szFileHTML[_MAX_PATH * 2];

            pFileTable->SetPosition();
            while (pFileTable->GetString(szFile))
            {
                wsprintf(szFileHTML, "%s <BR>\r\n", szFile);
                WriteFile(hFile, (LPCVOID)szFileHTML, strlen(szFileHTML) * sizeof(TCHAR), &dwBytesWritten, NULL);
            }

            TCHAR szCloseHTML[] = "<P></P>\r\n" \
                                  "</BODY>\r\n</HTML>\r\n";
            WriteFile(hFile, (LPCVOID)szCloseHTML, strlen(szCloseHTML) * sizeof(TCHAR), &dwBytesWritten, NULL);
            CloseHandle(hFile);
        }
        else
            bReturn = FALSE;
    }

    return bReturn;
#endif
}

BOOL CPrintHook::TranslateUrl(PSTR pszFullUrl, PSTR pszRelUrl)
{
    BOOL bReturn;
    URL_COMPONENTS uc;
    ZERO_STRUCTURE(uc);

    uc.dwStructSize = sizeof(URL_COMPONENTS);
    uc.dwSchemeLength = 1;
    uc.nScheme = INTERNET_SCHEME_DEFAULT ;
    uc.dwHostNameLength = 1;
    uc.dwUserNameLength = 1;
    uc.dwPasswordLength = 1;
    uc.dwUrlPathLength = 1;
    uc.dwExtraInfoLength = 1;

    if ((bReturn = InternetCrackUrl(pszFullUrl, 0, 0, &uc)))
    {
        uc.lpszUrlPath = pszRelUrl;
        uc.dwUrlPathLength = 0;

        // Make a copy of uc.lpszExtraInfo because it will
        // be lost when InternetCreateUrl() modifies pszFullUrl.

        CStr cszExtraInfo(uc.lpszExtraInfo);

        uc.lpszExtraInfo = (PSTR)cszExtraInfo;
        uc.dwExtraInfoLength = 0;

        DWORD dwBufLen = MAX_PATH;

        bReturn = InternetCreateUrl(&uc, 0, pszFullUrl, &dwBufLen);
    }

    return bReturn;
}

// This function just tells the WebBrowser to print the current page.

HRESULT CPrintHook::Print()
{
    // Change the cursor to an hourglass.
    SetClassLongPtr(m_hWndHelp, GCLP_HCURSOR, (LONG_PTR)LoadCursor(NULL, (LPCTSTR) IDC_WAIT));

    HRESULT hr = E_FAIL;
    HRESULT hrCancelled = (m_fIsIE3 ? 0x80040100 : 0x80040104);

    LPOLECOMMANDTARGET lpOleCommandTarget = m_phh->m_pCIExpContainer->m_pIE3CmdTarget;
    ASSERT(lpOleCommandTarget);

    if (lpOleCommandTarget != NULL)
    {
        // Give printing 10 tries and then bail out if it doesn't work.

        for (USHORT i = 0; i < 10 && FAILED(hr); i++)
        {
            if (!PumpMessages())
                break;

#ifdef _DEBUG
            try
            {
#endif
                // Call the Exec() function to print the currently displayed page.

                if (m_fIsIE3)
                {
                    hr = lpOleCommandTarget->Exec(NULL,OLECMDID_PRINT,
                                                OLECMDEXECOPT_PROMPTUSER,
                                                NULL, NULL);
                }
                else
                {
                    hr = lpOleCommandTarget->Exec(&CGID_MSHTML,IDM_PRINT,
                                                MSOCMDEXECOPT_PROMPTUSER,
                                                NULL, NULL);
                }

#ifdef _DEBUG
                TCHAR szDebug[40];
                wsprintf(szDebug, "m_pos == %i, hr == %lx", m_pos, hr);
                DBWIN(szDebug);
#endif
#ifdef _DEBUG
            }
            catch(...)
            {
                ASSERT_COMMENT(TRUE, "An exception occurred when printing. " \
                               "Please send email to randyfe or ralphw.");
                hr = E_FAIL;
            }
#endif
            // On IE 4, wait for printing to finish before continuing.

            if (!m_fIsIE3)
            {
                OLECMD olecmd;
                olecmd.cmdID = IDM_PRINTQUERYJOBSPENDING;

                do
                {
                    DBWIN("Waiting for printing to finish...");
                    olecmd.cmdf = 0;

#ifdef _DEBUG
                    try
                    {
#else
                        if (m_phh && m_phh->m_pCIExpContainer && m_phh->m_pCIExpContainer->m_pIE3CmdTarget)
#endif
                            m_phh->m_pCIExpContainer->m_pIE3CmdTarget->QueryStatus(&CGID_MSHTML, 1, &olecmd, NULL);
#ifdef _DEBUG
                    }
                    catch(...)
                    {
                        ASSERT_COMMENT(TRUE, "An exception occurred when waiting for printing to finish. " \
                                       "Please send email to randyfe or ralphw.");
                        break;
                    }
#endif
                    PumpMessages();
                }
                while (olecmd.cmdf & OLECMDF_ENABLED);
            }

            if (hr == hrCancelled)
                break;
        }
    }

    m_fIsPrinting = FALSE;

    // Change the cursor back to an arrow.
    SetClassLongPtr(m_hWndHelp, GCLP_HCURSOR, (LONG_PTR)LoadCursor(NULL, (LPCTSTR) IDC_ARROW));

#ifdef _DEBUG
    TCHAR szDebug[50];
    wsprintf(szDebug, "Print complete... hr == %lx", hr);
    DBWIN(szDebug);
#endif

    return hr;
}

STATIC INT_PTR CALLBACK ProgressDialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

const int DEFAULT_WIDTH = 200;
const int DEFAULT_HEIGHT = 50;

CProgress::CProgress(PCSTR pszCaption, HWND hwndCallersParent, int cSteps,
    int cHowOften)
{
    cProgress = -1;
    steps = cSteps;
    cFrequency = cHowOften;
    pszTitle = lcStrDup(pszCaption);
    fWindowCreationFailed = FALSE;
    hwndProgress = NULL;
    hwndParent = hwndCallersParent;
    hwndFrame = NULL;

    dwStartTime = GetTickCount();

    counter = 0;
}

CProgress::~CProgress()
{
    if (hwndFrame && IsWindow(hwndFrame))
        DestroyWindow(hwndFrame);
    lcFree(pszTitle);
}

void CProgress::Progress() {
    if (++counter == cFrequency) {
        counter = 0;
        if (hwndProgress)
            SendMessage(hwndProgress, PBM_STEPIT, 0, 0);
        else {
            cProgress++;
            if (GetTickCount() - dwStartTime >= 1500)
                CreateTheWindow();
        }
    }
}

void CProgress::CreateTheWindow(void)
{
    if (fWindowCreationFailed)
        return; // couldn't create the window

    if (!hwndParent) {
        CPalDC dc(SCREEN_IC);
        rc.left = dc.GetDeviceWidth() - (DEFAULT_WIDTH / 2);
        rc.top = dc.GetDeviceHeight() - (DEFAULT_HEIGHT / 2);
    }
    else {
        RECT rcParent;
        GetWindowRect(hwndParent, &rcParent);
        rc.left = (RECT_WIDTH(rcParent) / 2) - (DEFAULT_WIDTH / 2);
        rc.top =  (RECT_HEIGHT(rcParent) / 2) - (DEFAULT_HEIGHT / 2);
    }

    hwndFrame = CreateDialog(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDDLG_PROGRESS),
        hwndParent, ProgressDialogProc);

    if (!hwndFrame) {
        fWindowCreationFailed = TRUE;
        return;
    }

    RECT rcFrame;
    GetWindowRect(hwndFrame, &rcFrame);
    MoveWindow(hwndFrame, rcFrame.left, rc.top, RECT_WIDTH(rcFrame),
        RECT_HEIGHT(rcFrame), FALSE);

    hwndProgress = GetDlgItem(hwndFrame, ID_PROGRESS);
    if (steps > 0) {
        SendMessage(hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, steps));
        SendMessage(hwndProgress, PBM_SETSTEP, (WPARAM) 1, 0);
    }

    SetWindowText(hwndFrame, pszTitle);

    while (cProgress-- >= 0)
        SendMessage(hwndProgress, PBM_STEPIT, 0, 0);

    ShowWindow(hwndFrame, SW_SHOW);
}

STATIC INT_PTR CALLBACK ProgressDialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (msg == WM_INITDIALOG)
        return TRUE;
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cprint.h ===
// Copyright (c) 1996-1997, Microsoft Corp. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CPRINT_H__
#define __CPRINT_H__

#ifndef _CDLG_H_
#include "cdlg.h"
#endif

#include "resource.h"

enum {
	PRINT_CUR_TOPIC,
	PRINT_CUR_HEADING,
	PRINT_CUR_ALL,
};

class CPrint : public CDlg
{
public:
	CPrint(HWND hwndParent) : CDlg(hwndParent, CPrint::IDD) {
		m_action = PRINT_CUR_TOPIC;
		};
	BOOL OnBeginOrEnd(void);

	__inline void SetAction(int action) { m_action = action; }
	__inline int  GetAction() { return m_action; }

	enum { IDD = IDDLG_TOC_PRINT };

	int 	m_action;
};

#endif // __CPRINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cstr.cpp ===
// CStr and CWStr Classes

#include "header.h"

#include "cstr.h"

// CStr Class

CStr::CStr(int idFormatString, PCSTR pszSubString)
{
    psz = NULL;
    FormatString(idFormatString, pszSubString);
}

void CStr::FormatString(int idFormatString, PCSTR pszSubString)
{
    if (psz)
        lcFree(psz);

    char szMsg[MAX_STRING_RESOURCE_LEN + 1];
    if (LoadString(_Module.GetResourceInstance(), idFormatString, szMsg, sizeof(szMsg)) == 0) {
#ifdef _DEBUG
        wsprintf(szMsg, "invalid string id #%u", idFormatString);
        AssertErrorReport(szMsg, __LINE__, THIS_FILE);
        psz = (PSTR) lcStrDup(szMsg);
#else
        psz = (PSTR) lcStrDup("");
#endif
    }
    else {
        ASSERT(strstr(szMsg, "%s"));
        psz = (PSTR) lcMalloc(::strlen(szMsg) + ::strlen(pszSubString));
        wsprintf(psz, szMsg, pszSubString);
    }
}

CStr::CStr(HWND hwnd)
{
    int cb = GetWindowTextLength(hwnd) + 1;
    psz = (PSTR) lcMalloc(cb);
    GetWindowText(hwnd, psz, cb);
}

/***************************************************************************

    FUNCTION:   CStr::GetText

    PURPOSE:    Get the text from a dialog control. This can handle edit,
                static, listbox, combobox, etc.

    PARAMETERS:
        hwndControl --  handle of the control, or the dialog if sel is the
                        control id

        sel     --  if hwndControl is a dialog, this must be the control id.
                    Otherwise, the meaning is determined by the control.

                    listbox:
                        -1 for current selection
                        >= 0 for specific selection

                    combobox:
                        -1 for edit box
                        >= 0 for listbox

    RETURNS:
        TRUE if text obtained, else FALSE.

    COMMENTS:
        For non-list type controls (edit, static, button, etc.), if you know
        the window handle, simply specify:

            csz.GetText(hwndControl);

        If you don't have the window handle, use the dialog handle and
        control id:

            csz.GetText(hwndDialog, idControl);

    MODIFICATION DATES:
        23-Nov-1996 [ralphw]
            Added this header, support for dialogs and comboboxes

***************************************************************************/

BOOL CStr::GetText(HWND hwndControl, int sel)
{
    if (psz)
        lcFree(psz);

    ASSERT(IsValidWindow(hwndControl));
    if (!IsValidWindow(hwndControl)) {
        psz = (PSTR) lcCalloc(1);
        return FALSE;
    }
    char szClass[MAX_PATH];
    VERIFY(GetClassName(hwndControl, szClass, sizeof(szClass)));

    if (_stricmp(szClass, "#32770") == 0) {
        // This is a dialog, therefore, sel must be an id rather then a selection
        hwndControl = GetDlgItem(hwndControl, sel);
        ASSERT(IsValidWindow(hwndControl));
        if (!IsValidWindow(hwndControl)) {
            psz = (PSTR) lcCalloc(1);
            return FALSE;
        }
        sel = -1;
        VERIFY(GetClassName(hwndControl, szClass, sizeof(szClass)));
    }

    if (_stricmp(szClass, "ListBox") == 0) {
        if (sel == -1)
            sel = (int)SendMessage(hwndControl, LB_GETCURSEL, 0, 0);
        if (sel == LB_ERR) {
            psz = (PSTR) lcCalloc(1);
            return FALSE;
        }
        int cb = (int)SendMessage(hwndControl, LB_GETTEXTLEN, sel, 0);
        ASSERT(cb != LB_ERR);
        if (cb == LB_ERR) {
            psz = (PSTR) lcCalloc(1);
            return FALSE;
        }
        psz = (PSTR) lcCalloc((int)SendMessage(hwndControl, LB_GETTEXTLEN, (WPARAM)sel, 0) + 1);
        return SendMessage(hwndControl, LB_GETTEXT, (WPARAM)sel, (LPARAM) psz)!= 0;
    }

    /*
     * If a selection was specified, we read from the list box of a combo
     * box. If no selection was specified, we read from the edit control of a
     * combobox.
     */

    else if (sel >= 0 && _stricmp(szClass, "ComboBox") == 0) {
        int cb = (int)SendMessage(hwndControl, CB_GETLBTEXTLEN, (WPARAM)sel, 0);
        ASSERT(cb != CB_ERR);
        if (cb == CB_ERR) {
            psz = (PSTR) lcCalloc(1);
            return FALSE;
        }
        psz = (PSTR) lcCalloc(cb + 1);
        return SendMessage(hwndControl, CB_GETLBTEXT, sel, (LPARAM) psz)!=NULL;
    }
    else {

        // Use lcCalloc in case the control can't return any text

        psz = (PSTR) lcCalloc(GetWindowTextLength(hwndControl) + 1);
        return GetWindowText(hwndControl, psz, (int)lcSize(psz));
    }
}

PSTR CStr::GetArg(PCSTR pszSrc, BOOL fCheckComma)
{
    ASSERT(pszSrc);
    if (!psz)
        psz = (PSTR) lcMalloc(256);
    if (*pszSrc == CH_QUOTE) {
        pszSrc++;
        PCSTR pszEnd = StrChr(pszSrc, CH_QUOTE);
        if (!pszEnd)
            pszEnd = pszSrc + ::strlen(pszSrc);
        psz = (PSTR) lcReAlloc(psz, (UINT)(pszEnd - pszSrc) + 1);
        lstrcpyn(psz, pszSrc, (int)(pszEnd - pszSrc) + 1);
        return (PSTR) (*pszEnd == CH_QUOTE ? pszEnd + 1 : pszEnd);
    }

    PSTR pszDst = psz;
    PSTR pszEnd = pszDst + lcSize(psz);
    pszSrc = FirstNonSpace(pszSrc); // skip leading white space

    while (*pszSrc != CH_QUOTE && !IsSpace(*pszSrc) && *pszSrc) {
        if (fCheckComma && *pszSrc == CH_COMMA)
            break;
        *pszDst++ = *pszSrc++;
        if (pszDst == pszEnd) {

            /*
             * Our input buffer is too small, so increase it by
             * 128 bytes.
             */

            int offset = (int)(pszDst - psz);
            ReSize((int)(pszEnd - psz) + 128);
            pszDst = psz + offset;
            pszEnd = psz + SizeAlloc();
        }
        if (g_fDBCSSystem && IsDBCSLeadByte(pszSrc[-1])) {
            *pszDst++ = *pszSrc++;
            if (pszDst == pszEnd) {

                /*
                 * Our input buffer is too small, so increase it by
                 * 128 bytes.
                 */

                int offset = (int)(pszDst - psz);
                ReSize((int)(pszEnd - psz) + 128);
                pszDst = psz + offset;
                pszEnd = psz + SizeAlloc();
            }
        }
    }
    *pszDst = '\0';
    psz = (PSTR) lcReAlloc(psz, strlen() + 1);
    if (fCheckComma && *pszSrc)
        pszSrc++;   // skip over comma, or quote, or space
    return (PSTR) pszSrc;
}

void CStr::operator=(LPCWSTR pszNew)
{
    if (psz)
        lcFree(psz);
    ASSERT(pszNew);
    if (!pszNew || !*pszNew ) {
        psz = NULL;
        return;
    }
    int cb = lstrlenW(pszNew);
    psz = (PSTR) lcMalloc(cb + 1);
    int cbWritten = WideCharToMultiByte(CP_ACP, 0, pszNew, cb, psz, cb, NULL, NULL);

    // Check for insufficient buffer size
    //
    if(!cbWritten && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        // request destination buffer size
        //
        int cMultiByteLen = WideCharToMultiByte(CP_ACP, 0, pszNew, cb, psz, 0, NULL, NULL);
        lcFree(psz);
        psz = (PSTR) lcMalloc(cMultiByteLen + 1);
        cbWritten = WideCharToMultiByte(CP_ACP, 0, pszNew, cb, psz, cMultiByteLen, NULL, NULL);
    }
    psz[cbWritten] = '\0';
}

// CWStr Class

CWStr::CWStr(HWND hwnd)
{
  int iLen = GetWindowTextLengthW(hwnd) + 1;
  pw = (LPWSTR) lcMalloc(iLen*sizeof(WCHAR));
  GetWindowTextW(hwnd, pw, iLen);
}

void CWStr::operator=(PCSTR psz)
{
    ASSERT(psz);
    if (pw)
        lcFree(pw);
    if (IsEmptyString(psz)) {
        pw = NULL;
        return;
    }
    int cb = (int)strlen(psz) + 1;
    pw = (LPWSTR) lcCalloc(cb * 2);
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pw, cb * 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cprop.cpp ===
// Copyright (C) Microsoft Corporation 1993-1997, All Rights reserved.

#include "header.h"
#include "cprop.h"

// enumerated type so debugger can show us what codes are being sent

typedef enum {
    tPSN_SETACTIVE           = (PSN_FIRST-0),
    tPSN_KILLACTIVE          = (PSN_FIRST-1),
    tPSN_APPLY               = (PSN_FIRST-2),
    tPSN_RESET               = (PSN_FIRST-3),
    tPSN_HELP                = (PSN_FIRST-5),
    tPSN_WIZBACK             = (PSN_FIRST-6),
    tPSN_WIZNEXT             = (PSN_FIRST-7),
    tPSN_WIZFINISH           = (PSN_FIRST-8),
    tPSN_QUERYCANCEL         = (PSN_FIRST-9),
} TYPE_PSN;

int CALLBACK CPropSheetProc(HWND hdlg, UINT msg, LPARAM lParam);

BOOL CALLBACK CPropPageProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CPropPage* pThis = (CPropPage*) GetWindowLongPtr(hdlg, GWLP_USERDATA);;
    TYPE_PSN code;
    BOOL fResult;

    switch (msg) {
        case WM_INITDIALOG:
            pThis = (CPropPage*) ((LPPROPSHEETPAGE) lParam)->lParam;
            CDlgProc(hdlg, msg, wParam, (LPARAM) pThis);
            //BUG 2035: Return TRUE to tell windows to set the keyboard focus.
            // m_fFocusChanged is FALSE if the derived class hasn't changed it.
            return !pThis->m_fFocusChanged;

        case WM_COMMAND:
            if (!pThis || pThis->m_fShuttingDown)
                return FALSE; // pThis == NULL if a spin control is being initialized

            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    pThis->OnButton(LOWORD(wParam));
                    break;

                case LBN_SELCHANGE: // same value as CBN_SELCHANGE
                    pThis->OnSelChange(LOWORD(wParam));
                    break;

                case LBN_DBLCLK:    // same value as CBN_DBLCLK
                    pThis->OnDoubleClick(LOWORD(wParam));
                    break;

                case EN_CHANGE:
                    pThis->OnEditChange(LOWORD(wParam));
                    break;
            }

            // If m_pmsglist is set, OnCommand will call OnMsg

            if (!pThis->OnCommand(wParam, lParam))
                return FALSE;
            break;

        case WM_NOTIFY:
            code = (TYPE_PSN) ((NMHDR*) lParam) ->code;
            switch(code) {
                case tPSN_APPLY: // OK or Apply Now
                    pThis->m_fInitializing = FALSE;
                    if (pThis->m_pBeginOrEnd)
                        pThis->m_pBeginOrEnd(pThis);
                    else
                        pThis->OnBeginOrEnd();
                    return FALSE;

                case tPSN_WIZNEXT:
                case tPSN_WIZFINISH:
                    pThis->m_fInitializing = FALSE;
                    fResult = -1;

                    if (pThis->m_pBeginOrEnd)
                        fResult = pThis->m_pBeginOrEnd(pThis);
                    else
                        fResult = pThis->OnBeginOrEnd();

                    if (!fResult) {
                        pThis->SetResult(-1);
                        return TRUE;
                    }
                    else
                        return pThis->OnNotify((UINT) code);
                    break;

                default:
                    return pThis->OnNotify((UINT) code);

            }
            break;

        case WM_HELP:
            pThis->OnHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle);
            break;

        case WM_CONTEXTMENU:
            pThis->OnContextMenu((HWND) wParam);
            break;

        case WM_DRAWITEM:
            if (!pThis)
                return FALSE;

            if (pThis->m_pCheckBox &&
                    GetDlgItem(hdlg, (int)wParam) == pThis->m_pCheckBox->m_hWnd) {
                ASSERT(IsValidWindow(pThis->m_pCheckBox->m_hWnd));
                pThis->m_pCheckBox->DrawItem((DRAWITEMSTRUCT*) lParam);
                return TRUE;
            }
            else
                return pThis->OnDlgMsg(msg, wParam, lParam) != NULL;

        case WM_VKEYTOITEM:
            if (pThis && pThis->m_pCheckBox && (HWND) lParam == pThis->m_pCheckBox->m_hWnd) {
                if (LOWORD(wParam) == VK_SPACE) {
                    int cursel = (int)pThis->m_pCheckBox->GetCurSel();
                    if (cursel != LB_ERR)
                        pThis->m_pCheckBox->ToggleItem(cursel);
                }
                return -1;  // always perform default action
            }
            else
                return pThis->OnDlgMsg(msg, wParam, lParam)!=NULL;

        default:
            if (pThis)
                return pThis->OnDlgMsg(msg, wParam, lParam)!=NULL;
            else
                return FALSE;
    }

    return FALSE;
}

CPropSheet::CPropSheet(PCSTR pszTitle, DWORD dwFlags, HWND hwndParent)
{
    ZERO_INIT_CLASS(CPropSheet);

    m_psh.dwSize = sizeof(m_psh);
    m_psh.dwFlags = dwFlags;
    m_psh.hwndParent = hwndParent;
    m_psh.hInstance = _Module.GetResourceInstance();
    m_psh.pszCaption = pszTitle;
    m_psh.phpage = (HPROPSHEETPAGE*)
        lcCalloc(sizeof(HPROPSHEETPAGE) * MAXPROPPAGES);
    m_fNoCsHelp = FALSE;
}

CPropPage::CPropPage(int idTemplate) : CDlg((HWND) NULL, idTemplate)
{
    ClearMemory(&m_psp, sizeof(m_psp));

    m_psp.dwSize = sizeof(m_psp);
    m_psp.dwFlags = PSP_DEFAULT;
    m_psp.hInstance = _Module.GetResourceInstance();   // means the dll can't create a property sheet [REVIEW: What does this comment meand 3/98 dalero]
    m_psp.lParam = (LPARAM) this;
    m_idTemplate = idTemplate;
    if (idTemplate) {
        m_psp.pszTemplate = MAKEINTRESOURCE(idTemplate);
        ASSERT(m_psp.pszTemplate);
    }
    m_psp.pfnDlgProc = (DLGPROC) CPropPageProc;
    m_fCenterWindow = FALSE;    // Don't automatically center the window
}

CPropSheet::~CPropSheet()
{
    lcFree(m_psh.phpage);
}

void CPropSheet::AddPage(CPropPage* pPage)
{
    HPROPSHEETPAGE hprop = CreatePropertySheetPage(&pPage->m_psp);
    ASSERT_COMMENT(hprop, "Failed to create property sheet page.");
    if (hprop)
        m_psh.phpage[m_psh.nPages++] = hprop;
}

int CPropSheet::DoModal(void)
{
    if (m_fNoCsHelp) {
        m_psh.dwFlags |= PSH_USECALLBACK;
        m_psh.pfnCallback = CPropSheetProc;
    }

    int err = (int)PropertySheet(&m_psh);
    ASSERT(err >= 0);
    return err;
}


/***************************************************************************

    FUNCTION:   CPropSheetProc

    PURPOSE:    Called to remove context-sensitive help

***************************************************************************/

int CALLBACK CPropSheetProc(HWND hdlg, UINT msg, LPARAM lParam)
{
    if (msg == PSCB_INITIALIZED) {
        SetWindowLong(hdlg, GWL_EXSTYLE,
            (GetWindowLong(hdlg, GWL_EXSTYLE) & ~WS_EX_CONTEXTHELP));
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cstream.h ===
#ifndef _CSTREAM_INCLUDED
#define _CSTREAM_INCLUDED

static const UINT CSTREAM_BUF_SIZE = (64 * 1024);
static const UINT HFILE_NOTREAD = ((UINT) -2);
static const UINT DUAL_CSTREAM_BUF_SIZE = (8 * 1024);

#define chEOF       ((unsigned char) 255)

class CStream
{
public:
    CStream(PCSTR pszFileName);
    ~CStream(void);
    int STDCALL seek(int pos, SEEK_TYPE seek = SK_SET);
    int Remaining() { return (int)(pEndBuf - pCurBuf); };

#ifndef _DEBUG
    char cget() {
        if (pCurBuf < pEndBuf)
            return (char) *pCurBuf++;
        else if (pEndBuf < pbuf + cbBuf) {
            m_fEndOfFile = TRUE;
            return chEOF;   // WARNING! check m_fEndOfFile to confirm return of chEOF is valid
        }
        else
            return ReadBuf();
    };
#else
    char cget();
#endif

    int tell(void) const { return lFileBuf + (int)(pCurBuf - pbuf); };
    BOOL STDCALL doRead(void* pbDst, int cbBytes) {
        return (read(pbDst, cbBytes) == (UINT) cbBytes);
    }
    UINT STDCALL read(void* pbDst, int cbBytes);
    char ReadBuf(void);
    friend DWORD WINAPI ReadAhead(LPVOID pv);
    void Cleanup(void);

    BOOL fInitialized;
    PBYTE pCurBuf;   // current position in the buffer
    PBYTE pEndBuf;   // last position in buffer
    BOOL  m_fEndOfFile;

    HFILE hfile;    // file handle

protected:

    void WaitForReadAhead(void);

    int   lFilePos; // position in the file
    int   lFileBuf; // file position at first of buffer
    PBYTE pbuf;     // address of allocated buffer
    PSTR  pszFile;  // copy of the filename
    int   cbBuf;    // buffer size
    int   cThrdRead; // result from read-ahead thread
    HANDLE hthrd;
    DWORD idThrd;
    BOOL  fDualCPU;
};

#endif // _CSTREAM_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cprop.h ===
// Copyright (C) Microsoft Corporation 1993-1997, All Rights reserved.

#ifndef _CPROP_H_
#define _CPROP_H_

#include <prsht.h>
#ifndef _CDLG_H_
#include "cdlg.h"
#endif

class CPropPage : public CDlg
{
public:
	CPropPage(int idTemplate = 0);

	PROPSHEETPAGE m_psp;

	virtual BOOL OnNotify(UINT code) { return FALSE; }

	void SetTitle(int idResource) const {
		PostMessage(GetParent(m_hWnd), PSM_SETTITLE, 0,
			(LPARAM) GetStringResource(idResource));
	}
	void SetWizButtons(DWORD dwFlags) const { PostMessage(GetParent(m_hWnd),
		PSM_SETWIZBUTTONS, 0, (LPARAM) dwFlags); }
	void SetResult(LONG result) const { ::SetWindowLong(m_hWnd, DWLP_MSGRESULT, result); }

	int m_idTemplate;

protected:
	friend BOOL CALLBACK CPropPageProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
};

class CPropSheet
{
public:
	CPropSheet(PCSTR pszTitle, DWORD dwFlags = PSH_DEFAULT,
		HWND hwndParent = NULL);
	~CPropSheet();

	void AddPage(CPropPage* pPage);
	int DoModal(void);

	PROPSHEETHEADER m_psh;
	BOOL m_fNoCsHelp;
};

#endif // _CPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\csubset.cpp ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#include "header.h"

#ifndef HHCTRL
#include "hha_strtable.h"
#endif

#ifdef HHCTRL
#include "strtable.h"
#include "secwin.h"
#endif

#include "system.h"
#include "csubset.h"
#include "ctable.h"

const char g_szUDSKey[] = "ssv2\\UDS";  // User Defined Subsets


// Shared init.
//
void CSubSets::_CSubSets(void)
{
   m_max_subsets   = MAX_SUBSETS;
   m_aSubSets = (CSubSet**)lcCalloc( m_max_subsets * sizeof( CSubSet* ) );
   m_cur_Set       = NULL;
   m_Toc           = NULL;
   m_Index         = NULL;
   m_FTS           = NULL;
   m_cSets         = 0;
   m_pszFilename   = NULL;
}

#ifdef HHCTRL

CSubSets::CSubSets(int ITSize, CHmData* const phmData, BOOL fPredefined=FALSE ) : CSubSet(ITSize)
{
    _CSubSets();
    m_fPredefined   = fPredefined;
    m_bPredefined = fPredefined;
    m_pIT = new CInfoType();
    m_pIT->CopyTo(phmData);
}

#endif

CSubSets::CSubSets( int ITSize = 4, CInfoType *pIT=NULL, BOOL fPredefined=FALSE ) : CSubSet( ITSize)
{
    _CSubSets();
    m_fPredefined   = fPredefined;
    m_bPredefined = fPredefined;
    m_pIT = new CInfoType();
    if ( pIT != NULL )
        *m_pIT = *pIT;              // BUGBUG: This will fault if you ever use the defult for the parameter.
}

CSubSets::CSubSets( int ITSize, CTable *ptblSubSets, CSiteMap *pSiteMap, BOOL fPredefined=FALSE ) : CSubSet(ITSize)
{
    _CSubSets();
    m_fPredefined = fPredefined;
    m_bPredefined = fPredefined;
    m_pIT = new CInfoType();
    if ( pSiteMap )
        *m_pIT = *pSiteMap;

    // populate subsets with declarations in ptblSubSets
CStr cszSSDecl; // one item of a subset
CStr cszSubSetName;
CStr cszITName;
int cDeclarations = ptblSubSets->CountStrings();

    for (int i=1; i<cDeclarations; i++ )
    {
      cszSSDecl = ptblSubSets->GetPointer( i );

      int type ;
      if ( isSameString(cszSSDecl.psz, txtSSInclusive) )
          type = SS_INCLUSIVE;
      else if ( isSameString(cszSSDecl.psz, txtSSExclusive) )
          type = SS_EXCLUSIVE;

      cszSubSetName = StrChr(cszSSDecl.psz, ':')+1;
      PSTR psz = StrChr(cszSubSetName, ':');
      *psz = '\0';
      cszITName = StrChr( cszSSDecl.psz, ':')+1;

      if ( GetSubSetIndex( cszSubSetName ) < 0 )
      {
         AddSubSet();   // create a new subset
         m_cur_Set->m_cszSubSetName = cszSubSetName.psz;
         m_cur_Set->m_bPredefined = TRUE;
      }

      int pos = m_pIT->m_itTables.m_ptblInfoTypes->IsStringInTable( cszITName.psz );
      if ( pos <= 0 )
         continue;
      if ( type == SS_INCLUSIVE )
         m_cur_Set->AddIncType( pos );                     // Add this "include" bit.
      else
         m_cur_Set->AddExcType( pos );                     // Add this "exclude" bit.
    }
}


CSubSets::~CSubSets()
{
    if (m_aSubSets) //leak fix
    {
        for(int i=0; i<m_max_subsets; i++)
        {
            if ( m_aSubSets[i] )
                delete m_aSubSets[i];
        }
        lcFree(m_aSubSets);
    }

    if ( m_pszFilename )
        lcFree(m_pszFilename );

    if ( m_pIT )
        delete( m_pIT );
}

const CSubSets& CSubSets::operator=( const CSubSets& SetsSrc )   // Copy Constructor
{
    if ( this == NULL )
        return *this;

    if (m_max_subsets < SetsSrc.m_max_subsets )
        m_aSubSets = (CSubSet **) lcReAlloc(m_aSubSets, SetsSrc.m_max_subsets*sizeof(CSubSet*) );

    m_cSets = SetsSrc.m_cSets;
    m_max_subsets = SetsSrc.m_max_subsets;
    if ( m_pszFilename )
        lcFree( m_pszFilename );
    m_pszFilename = lcStrDup( SetsSrc.m_pszFilename);
    m_fPredefined = SetsSrc.m_fPredefined;

    for(int i=0; i< m_cSets; i++)
    {
        if ( m_aSubSets[i] )
            delete m_aSubSets[i];

        *m_aSubSets[i] = *SetsSrc.m_aSubSets[i];
        if ( SetsSrc.m_Toc == SetsSrc.m_aSubSets[i] )
            m_Toc = m_aSubSets[i];
        if ( SetsSrc.m_Index == SetsSrc.m_aSubSets[i] )
            m_Index = m_aSubSets[i];
        if ( SetsSrc.m_FTS == SetsSrc.m_aSubSets[i] )
            m_FTS = m_aSubSets[i];
        if ( SetsSrc.m_cur_Set == SetsSrc.m_aSubSets[i] )
            m_cur_Set = m_aSubSets[i];
    }

    m_pIT = new CInfoType();
    *m_pIT = *SetsSrc.m_pIT;

    return *this;
}

#ifdef HHCTRL

void CSubSets::CopyTo( CHmData * const phmData )
{
CStr cszSubSetName;
CStr cszITName;

    if ( !phmData->m_pdSubSets )
        return;
    for(int i=0; (phmData->m_pdSubSets[i].type>=SS_INCLUSIVE) && (phmData->m_pdSubSets[i].type<=SS_EXCLUSIVE); i++)
    {
      cszSubSetName = phmData->GetString( phmData->m_pdSubSets[i].dwStringSubSetName );
      if ( GetSubSetIndex( cszSubSetName ) < 0 )
      {
         AddSubSet();   // create a new subset
         m_cur_Set->m_cszSubSetName = cszSubSetName.psz;
         m_cur_Set->m_bPredefined = TRUE;
      }
      cszITName = phmData->GetString( phmData->m_pdSubSets[i].dwStringITName );
      int pos = m_pIT->m_itTables.m_ptblInfoTypes->IsStringInTable( cszITName.psz );
      if ( pos <= 0 )
         continue;
      if ( phmData->m_pdSubSets[i].type == SS_INCLUSIVE )
         m_cur_Set->AddIncType( pos );                     // Add this "include" bit.
      else
         m_cur_Set->AddExcType( pos );                     // Add this "exclude" bit.
   }

        // Read in all the user defined Subsets.
   CState* pstate = phmData->m_pTitleCollection->GetState();
   static const int MAX_PARAM = 4096;
   CMem memParam( MAX_PARAM );
   PSTR pszParam = (PSTR)memParam;   // for notational convenience
   DWORD cb;
   int  nKey=1;
   char buf[5];
   CStr cszKey = g_szUDSKey;
   wsprintf(buf,"%d",nKey++);
   cszKey += buf;
   while( SUCCEEDED(pstate->Open(cszKey.psz,STGM_READ)) )
   {
       int type;
       cszKey = g_szUDSKey;
       wsprintf(buf, "%d", nKey++);
       cszKey += buf;
        if ( SUCCEEDED(pstate->Read(pszParam,MAX_PATH,&cb)) )
        {
            if ( isSameString( (PCSTR)pszParam, txtSSInclusive) )
                type = SS_INCLUSIVE;
            else
                if ( isSameString((PCSTR)pszParam, txtSSExclusive) )
                    type = SS_EXCLUSIVE;
                else
                    break;
        }
        else
            break;
            // format INCLUSIVE|EXCLUSIVE:SubSetName:ITName
        PSTR psz = StrChr((PCSTR)pszParam, ':');
        if (psz)
            psz++;
        else
            psz = "";
        CStr cszTemp = psz;
        PSTR pszTemp = StrChr(cszTemp.psz, ':');
        *pszTemp = '\0';
        if ( GetSubSetIndex(cszTemp) < 0)
        {
            AddSubSet();  // create a new subset
            m_cur_Set->m_cszSubSetName = cszTemp.psz;
            m_cur_Set->m_bPredefined = FALSE;  // The subset is user defined.
        }
            // Get the name of the type
        psz = StrChr(psz, ':');
        if ( psz )
            psz++;
        else
            psz ="";
        if (IsNonEmptyString(psz))
        {
            int pos = m_pIT->m_itTables.m_ptblInfoTypes->IsStringInTable( psz );
            if ( pos <= 0 )
                continue;
            if ( type == SS_INCLUSIVE )
                m_cur_Set->AddIncType( pos );
            else if ( type == SS_EXCLUSIVE)
                m_cur_Set->AddExcType( pos );
        }
        pstate->Close();
        pstate->Delete();
   }    // while reading user defined subsets

   for ( int n = 0; n < m_cSets; n++ )
      m_aSubSets[n]->BuildMask();
}
#endif

    // Import a subset
    // ******************
CSubSet *CSubSets::AddSubSet(CSubSet *pSubSet )
{
    if ( !pSubSet || pSubSet->m_cszSubSetName.IsEmpty() )
        return NULL;

    if ( GetSubSetIndex( pSubSet->m_cszSubSetName.psz ) >= 0)
        return NULL;  // the SS is already defined

    if ( m_cSets >= m_max_subsets )
        ReSizeSubSet();   // allocate space for more subsets

    m_aSubSets[m_cSets] = new CSubSet( m_ITSize );
    m_cur_Set = m_aSubSets[m_cSets];
    m_cSets++;

    *m_cur_Set = *pSubSet;  // populate the new SubSet

    return m_cur_Set;
}



    // Create a new (empty) subset
    // **********************
CSubSet *CSubSets::AddSubSet( )
{

    if ( (m_cSets >= m_max_subsets) )
        ReSizeSubSet();

    m_aSubSets[m_cSets] = new CSubSet( m_ITSize);
    m_cur_Set = m_aSubSets[m_cSets];
    m_cSets++;
    m_cur_Set->m_bPredefined = m_bPredefined; // from the base class
    m_cur_Set->m_pIT = m_pIT;

    return m_cur_Set;
}



    // Removes a subset from m_aSubSets.
    // ***********************************
void CSubSets::RemoveSubSet( PCSTR pszName )
{
    int pos;

    if ( IsEmptyString(pszName) )
        return;
    pos = GetSubSetIndex( pszName );
    if ( (pos < 0) || (pos>m_max_subsets) )
        return;  // subset name is not defined
    delete m_aSubSets[pos];
    m_aSubSets[pos] = NULL;
    m_cur_Set = NULL;

}




//  NOTE:
// Only user defined Subsets are saved to file.  Author defined subsets (ie predefined
// subsets live in the master .chm file.  And are saved in the .hhp file and in the future
// in the .hhc and .hhk file.

// First try to save in the same directory as the .chm is in. next put it in the windows help directory.
//
// Format:
//          [SUBSETS]
//          SetName:Inclusive:TypeName
//          SetName:Exclusive:TypeName
BOOL CSubSets::SaveToFile( PCSTR filename )
{

    if ( m_fPredefined )
        return FALSE;
// finish this
    return TRUE;
}




BOOL CSubSets::ReadFromFile( PCSTR filename )
{

// finish this


    if ( m_fPredefined )
        return FALSE;
    // Read the user defined subsets from the .sub file and add them to this subset.

    return TRUE;
}

int CSubSets::GetSubSetIndex( PCSTR pszName ) const
{
    for (int i=0; i<m_cSets; i++ )
    {
        if (m_aSubSets[i] && m_aSubSets[i]->IsSameSet( pszName ) )
            return i;
    }
    return -1;
}


    // Adds 5 more subsets.
void CSubSets::ReSizeSubSet()
{
    ASSERT(m_aSubSets);

    m_max_subsets += 5;

    m_aSubSets = (CSubSet**)lcReAlloc( m_aSubSets, m_max_subsets * sizeof(CSubSet*) );

}

#ifdef HHCTRL

void CSubSets::SetTocMask( PCSTR  psz, CHHWinType* phh)
{
   CSubSet* pSS;

   int i = GetSubSetIndex(psz);
   if ( i >= 0 )
       pSS = m_aSubSets[i];
   else
       pSS = NULL;

   if ( pSS != m_Toc )
   {
      m_Toc = pSS;
      // Need to re-init the TOC!
      if (phh)
         phh->UpdateInformationTypes();
   }
}

#endif

////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSubSet
//

CSubSet::CSubSet(int const ITSize)
{
    // Round up to nearest DWORD boundary and allocate the bit fields. We have to do this becuase
    // m_pInclusive and m_pExclusive are DWORD pointers rather than byte pointers. As an optimization, if
    // ITSize is <= 4 We'll just use CSubSet member DWORDS as the bit fields. <mc>
    //
    int iRem = ITSize % 4;
    if ( iRem )
       m_ITSize = (ITSize + (4 - iRem));
    else
       m_ITSize = ITSize;

    if ( ITSize > 4 )
    {
       m_pInclusive = (INFOTYPE*) lcCalloc(m_ITSize);
       m_pExclusive = (INFOTYPE*) lcCalloc(m_ITSize);
    }
    else
    {
       dwI = dwE = 0;
       m_pInclusive = &dwI;
       m_pExclusive = &dwE;
    }
    m_aCatMasks = NULL;
    m_bIsEntireCollection = FALSE;
}

CSubSet::~CSubSet()
{
    if ( m_ITSize > 4 )
    {
        if ( m_pInclusive )
            lcFree(m_pInclusive);
        if ( m_pExclusive )
            lcFree(m_pExclusive);
    }
    if ( m_aCatMasks )
    {
        for(int i=0; i<m_pIT->HowManyCategories(); i++)
            lcFree(m_aCatMasks[i]);
        lcFree(m_aCatMasks);
    }
}


    // Copy constructor
    // *********************
const CSubSet& CSubSet::operator=(const CSubSet& SetSrc)
{
    if ( this == NULL )
        return *this;
    if ( this == &SetSrc )
        return *this;
    m_cszSubSetName = SetSrc.m_cszSubSetName.psz;   // copy the set name
    memcpy(m_pInclusive, SetSrc.m_pInclusive, SetSrc.m_ITSize);
    memcpy(m_pExclusive, SetSrc.m_pExclusive, SetSrc.m_ITSize);
    m_ITSize = SetSrc.m_ITSize;
    m_bPredefined = SetSrc.m_bPredefined;
    m_pIT = SetSrc.m_pIT;
    return *this;
}


void CSubSet::BuildMask(void)
{
    if ( m_bIsEntireCollection )
       return;

    int cCategories = m_pIT->HowManyCategories();
    m_aCatMasks = (INFOTYPE **) lcCalloc(cCategories * sizeof(INFOTYPE *) );
    for(int i =0; i<cCategories; i++)
    {
        INFOTYPE *pIT, *pCatMask;
        m_aCatMasks[i] = (INFOTYPE*)lcCalloc( m_ITSize);
        pIT = m_aCatMasks[i];
        INFOTYPE *pSSMask = m_pInclusive;
        pCatMask = m_pIT->m_itTables.m_aCategories[i].pInfoType;
        for(int j=0; j<m_ITSize; j+=4)
        {
            *pIT = (*pSSMask & *pCatMask);
            pIT++;
            pCatMask++;
            pSSMask++;
        }
    }
}

BOOL CSubSet::IsSameSet (PCSTR pszName) const
{
    if ( pszName && strcmp(m_cszSubSetName.psz, pszName) == 0)
        return TRUE;
    else
        return FALSE;
}

static int ExclusiveOffset=-1;
static INFOTYPE curExclusiveBit=1;

int CSubSet::GetFirstExcITinSubSet(void) const
{
    ExclusiveOffset = -1;
    curExclusiveBit = 1;

    int pos = GetITBitfromIT(m_pExclusive,
                          &ExclusiveOffset,
                          &curExclusiveBit,
                          m_ITSize*8 );
    while ( (pos != -1) && IsDeleted(pos) )
        pos = GetNextExcITinSubSet();
    return pos;
}



int CSubSet::GetNextExcITinSubSet(void) const
{
    if ( ExclusiveOffset <=-1 || curExclusiveBit <=1 )
        return -1;

    return GetITBitfromIT(m_pExclusive,
                          &ExclusiveOffset,
                          &curExclusiveBit,
                          m_ITSize*8 );
}



static int InclusiveOffset=-1;
static INFOTYPE curInclusiveBit=1;

int CSubSet::GetFirstIncITinSubSet( void) const
{

    InclusiveOffset = -1;
    curInclusiveBit = 1;

    int pos = GetITBitfromIT(m_pInclusive,
                          &InclusiveOffset,
                          &curInclusiveBit,
                          m_ITSize*8 );
    while ( (pos != -1) && IsDeleted( pos ) )
        pos = GetNextIncITinSubSet();
    return pos;
}


int CSubSet::GetNextIncITinSubSet( void) const
{

    if ( InclusiveOffset <= -1 || curInclusiveBit <= 1 )
        return -1;

    return GetITBitfromIT(m_pInclusive,
                          &InclusiveOffset,
                          &curInclusiveBit,
                          m_ITSize*8 );
}


BOOL CSubSet::Filter( INFOTYPE const *pTopicIT ) const
{
INFOTYPE   const *pTopicOffset = pTopicIT;
INFOTYPE   MaskOffset;
//INFOTYPE   *pExcITOffset, ExcITMask, ExcITBits;
int         cCategories = m_pIT->HowManyCategories();
BOOL     NoMask;

    if ( m_bIsEntireCollection )
       return TRUE;

    // Filter on the Subset's Exclusive Bit Mask
#if 0
    pTopicOffset = pTopicIT;
    memcpy(&MaskOffset,m_pInclusive, sizeof(INFOTYPE) );
    memcpy(&ExcITBits, m_pExclusive, sizeof(INFOTYPE) );
    pExcITOffset = m_pIT->m_itTables.m_pExclusive;
    ExcITMask = MaskOffset & *pExcITOffset;  // ExcITMask has the EX ITs that are set in the filter.
    ExcITMask = (~ExcITMask | ExcITBits);                // flip the exclusive bits in the filter mask
    ExcITMask = ExcITMask ^ ~*pExcITOffset;  // To get rid of those extra 1's from the previous ~.
#endif
    NoMask = FALSE;
    for ( int i=0; i<m_ITSize; i+=4)
    {
#if 0
        if ( (ExcITMask & *pTopicOffset) )
            return FALSE;
        memcpy(&MaskOffset,m_pInclusive+i, sizeof(INFOTYPE) );
        memcpy(&ExcITBits, m_pExclusive+i, sizeof(INFOTYPE) );
        pTopicOffset++;
        pExcITOffset++;
        ExcITMask = MaskOffset & *pExcITOffset;  // ExcITMask has the EX ITs that are set in the filter.
        ExcITMask = (~ExcITMask | ExcITBits);                // flip the exclusive bits in the filter mask
        ExcITMask = ExcITMask ^ ~*pExcITOffset;  // To get rid of those extra 1's from the previous ~.
#else
        if ( *m_pExclusive & *pTopicOffset )
            return FALSE;
#endif
    }

        // Filter on the Subset's Inclusive Bit Mask
#if 0
    if ( cCategories > 0)
    {
        for (int i=0; i<cCategories; i++)
        {
            pTopicOffset = pTopicIT;
            pMaskOffset  = m_aCatMasks[i];
#if 0
            NoMask = TRUE;
            for( int j=0; j<m_ITSize; j+=4)
            {
                if ( NoMask && *pTopicOffset == 0L  )
                    NoMask = TRUE;
                else
                    NoMask = FALSE;

                if (! *pMaskOffset )
                {
                   pMaskOffset++;
                   pTopicOffset++;
                   continue;
                }

                if (!NoMask && !(*pMaskOffset & *pTopicOffset) )
                    return FALSE;
                pMaskOffset++;
                pTopicOffset++;
            }
#endif
            BOOL bOk = TRUE;
            for(int j=0; j<m_ITSize; j+=4, pMaskOffset++, pTopicOffset++ )
            {
               if ( *pTopicOffset == 0L || *pMaskOffset == 0L )
                  continue;
               if ( (bOk = (BOOL)(*pMaskOffset & *pTopicOffset)) )
                  break;
            }
            if (! bOk )
            {
               //
               // Before we filter the topic out of existance we need to figure out if the topic is void of
               // any IT's from the current catagory. If it is we will NOT filter this topic based upon subset
               // bits for this catagory.
               //
               for(int n=0; n < (m_ITSize / 4); n++)
               {
                  if ( m_pIT->m_itTables.m_aCategories[i].pInfoType[n] & pTopicIT[n] )
                     return FALSE;   // Yep, topic has an IT from the catagory.
               }
            }
            if (NoMask && *pTopicIT&1L )    // bit zero ==1 Inclusive logic
                return FALSE;
        }
    }
    else
#endif
    {       // No categories,
        pTopicOffset = pTopicIT;
        MaskOffset = *m_pInclusive;
        BOOL NoMask = TRUE;
        for ( int i=0; i<m_ITSize/4; i++)
        {
            if ( NoMask && *pTopicOffset == 0L  )
                NoMask = TRUE;
            else
                NoMask = FALSE;
//            MaskOffset &= ~(*(m_pIT->m_itTables.m_pExclusive+i));
            if (!NoMask && !(MaskOffset & *pTopicOffset) )
                return FALSE;
            MaskOffset = (*m_pInclusive)+i;
            pTopicOffset++;
        }
        if (NoMask && *pTopicIT&1L )    // bit zero ==1 Inclusive logic
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cstr.h ===
// Copyright (C) 1993-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CSTR_H__
#define __CSTR_H__

#include "lcmem.h"

class CStr
{
public:
    CStr(PCSTR pszOrg) { psz = lcStrDup(pszOrg); }
    CStr(LPCWSTR  pszNew) {
        psz = NULL;
        *this = pszNew;
    }
    CStr(int idResource) { psz = lcStrDup(GetStringResource(idResource)); }

    CStr(void) { psz = NULL; }

    // Get a format string from a resource id and merge the string:
    // Equivalent to wsprintf(buffer, GetStringResource(id), pszString)

    CStr(int idFormatString, PCSTR pszSubString);

    // Get the text of a window

    CStr(HWND hwnd);

    ~CStr() {
        if (psz)
            lcFree(psz); }

    void FormatString(int idFormatString, PCSTR pszSubString);
    PSTR GetArg(PCSTR pszSrc, BOOL fCheckComma = FALSE);
    int  GetText(HWND hwnd, int id_or_sel = -1);
    BOOL IsEmpty(void) { return (psz ? (BOOL) (*psz == '\0') : TRUE); }
    BOOL IsNonEmpty(void) const { return (psz ? (BOOL) (*psz != '\0') : FALSE); }
    int  SizeAlloc(void) { return (psz ? lcSize(psz) : 0); }
    int  strlen(void) { return (psz ? ::strlen(psz) : 0); }
    void ReSize(int cbNew) {
            if (!psz)
                psz = (PSTR) lcMalloc(cbNew);
            else
                psz = (PSTR) lcReAlloc(psz, cbNew);
        }

    void TransferPointer(PSTR* ppsz) {
        *ppsz = psz;
        psz = NULL;
    }
    void TransferPointer(PCSTR* ppsz) {
        *ppsz = psz;
        psz = NULL;
    }

    operator PCSTR() { return (PCSTR) psz; }
    operator PSTR() { return psz; }       // as a C string
    void operator+=(PCSTR pszCat)
        {
            ASSERT(psz);
            ASSERT(pszCat);
            psz = (PSTR) lcReAlloc(psz, strlen() + ::strlen(pszCat) + 1);
            strcat(psz, pszCat);
        }
    void operator=(PCSTR pszNew)
        {
            ASSERT(pszNew);
            // Duplicate first in case we are assigning part of ourselves
            PSTR pszTmp = lcStrDup(pszNew);
            if (psz)
                lcFree(psz);
            psz = pszTmp;
        }
    void operator=(LPCWSTR pszNew);

    PSTR psz;
};

class CWStr
{
public:
    CWStr() : pw(NULL) {}
    CWStr(HWND hwnd);
    CWStr(PCSTR psz) {
        pw = NULL;
        *this = psz;
    }
    CWStr(int idResource) { pw = lcStrDupW(GetStringResourceW(idResource)); }

    ~CWStr() { if (pw) lcFree(pw); }

    void operator=(PCWSTR pszNew)
    {
        ASSERT(pszNew);
        PWSTR pszTmp = lcStrDupW(pszNew);
        if (pw)
            lcFree(pw);
        pw = pszTmp;
    }
    void operator=(PCSTR psz);
    operator LPWSTR() { return (LPWSTR) pw; };
    int Length()     { return pw ? lstrlenW(pw) : 0; }
    int ByteLength() { return Length()*sizeof(WCHAR); }
//private:
    LPWSTR pw;
};

#endif // __CSTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\cstream.cpp ===
/*****************************************************************************
*																			 *
*  CSTREAM.CPP																 *
*																			 *
*  Copyright (C) Microsoft Corporation 1990-1997							 *
*  All Rights reserved. 													 *
*																			 *
*****************************************************************************/

#include "header.h"

#include "cstream.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef _DEBUG
static LONG hsemReadCount;
static LONG hsemStartCount;
#define PTR_SEM_READ_COUNT	&hsemReadCount
#define PTR_SEM_START_COUNT &hsemStartCount
#else
#define PTR_SEM_READ_COUNT	NULL
#define PTR_SEM_START_COUNT NULL
#endif

#ifndef SEEK_CUR
#define SEEK_CUR	1
#define SEEK_END	2
#define SEEK_SET	0
#endif

static HANDLE hsemRead;  // semaphore used for dual-cpu processing
static HANDLE hsemStart; // semaphore used for dual-cpu processing
static CStream *pThis;
static BOOL fReadAheadStarted;
static BOOL fExitThread;
static PBYTE pbuf1;    // first buffer for dual-cpu processing
static PBYTE pbuf2;    // second buffer for dual-cpu processing

/////////////////////// CStream implementation ////////////////////////////

// We use our own stream class instead of using the C runtime, because this
// change alone doubled the speed of the help compiler. I.e., the C runtime
// implementation of stream io is horribly slow. 26-Feb-1994	[ralphw]
// Also, this CStream will take advantage of a dual-CPU and will do
// read-aheads in a thread.

CStream::CStream(PCSTR pszFileName)
{
	// Only one CStream can use the read-ahead thread

	if (!pThis) {
        fDualCPU = g_fDualCPU==-1?FALSE:g_fDualCPU;
		pThis = this;
	}
	else
		fDualCPU = FALSE;

	if ((hfile = _lopen(pszFileName, OF_READ)) == HFILE_ERROR) {
		fInitialized = FALSE;
		if (fDualCPU) 
			pThis = NULL;
		return;
	}
	if (fDualCPU) {
		cbBuf = DUAL_CSTREAM_BUF_SIZE;
		if (!hsemRead) {
			hsemRead = CreateSemaphore(NULL, 1, 1, NULL);
			hsemStart = CreateSemaphore(NULL, 1, 1, NULL);
			pbuf2 = (PBYTE) lcMalloc(DUAL_CSTREAM_BUF_SIZE + 2);
			pbuf1 = (PBYTE) lcMalloc(DUAL_CSTREAM_BUF_SIZE + 2);
		}
		pbuf = pbuf1;
	}
	else {
		cbBuf = CSTREAM_BUF_SIZE;

		// +2 because we add a zero just past the buffer in case anyone expects strings

		pbuf = (PBYTE) lcMalloc(CSTREAM_BUF_SIZE + 2);
	}

	ASSERT(pbuf);
	fInitialized = TRUE;

	int cread = _lread(hfile, pbuf, cbBuf);
	if (cread == HFILE_ERROR) {
		_lclose(hfile);
		fInitialized = FALSE;
		if (fDualCPU) 
			pThis = NULL;
		return;
	}

	if (fDualCPU) {
		// Start reading the next buffer

		cThrdRead = HFILE_NOTREAD;
		if (!fReadAheadStarted) {
			hthrd = CreateThread(NULL, 0,
				(LPTHREAD_START_ROUTINE) &ReadAhead, NULL,
				0, &idThrd);
			ASSERT(hthrd);
			if (!hthrd)
				fDualCPU = FALSE;
			else
				fReadAheadStarted = TRUE;
		}
		else {
			ReleaseSemaphore(hsemRead, 1, PTR_SEM_READ_COUNT);
			ReleaseSemaphore(hsemStart, 1, PTR_SEM_START_COUNT); // start read-ahead thread
		}
	}

	pCurBuf = pbuf;
	pEndBuf = pbuf + cread;
	pEndBuf[1] = '\0';
	lFilePos = cread;
	lFileBuf = 0;
	pszFile = lcStrDup(pszFileName);
	fInitialized = TRUE;
	m_fEndOfFile = FALSE;
}

CStream::~CStream()
{
	if (fInitialized) {
		if (fDualCPU) {
            Cleanup();
			WaitForReadAhead();
			pThis = NULL;
		}
		else
        {
			lcFree(pbuf);
        }
		lcFree(pszFile);
		_lclose(hfile);
	}
	
}

/***************************************************************************

	FUNCTION:	CStream::ReadBuf

	PURPOSE:	Read the next block into buffer

	PARAMETERS:
		void

	RETURNS:

	COMMENTS:
		Zero-terminates the buffer

	MODIFICATION DATES:
		13-Nov-1994 [ralphw]

***************************************************************************/

char CStream::ReadBuf(void)
{
	int cread;

	if (fDualCPU) {
		ASSERT(fReadAheadStarted);
		WaitForReadAhead();
		if (pbuf == pbuf1)
			pbuf = pbuf2;
		else
			pbuf = pbuf1;

		cread = cThrdRead;
		cThrdRead = HFILE_NOTREAD;
		ReleaseSemaphore(hsemRead, 1, PTR_SEM_READ_COUNT);

		// Error-checking must occur AFTER we release the read semaphore

		if (cread == HFILE_ERROR) {
			return chEOF;
		}
		ReleaseSemaphore(hsemStart, 1, PTR_SEM_START_COUNT); // start read-ahead thread
	}
	else {
		cread = _lread(hfile, pbuf, cbBuf);
		if (cread == HFILE_ERROR) {
			return chEOF;
		}
	}

	lFileBuf = lFilePos;
	lFilePos += cread;

	pCurBuf = pbuf;
	pEndBuf = pbuf + cread;
	pEndBuf[1] = '\0';

	if (!cread) {
		m_fEndOfFile = TRUE;
		return chEOF;
	}
	return (char) *pCurBuf++;
}

UINT STDCALL CStream::read(void* pbDest, int cbBytes)
{
	if (pEndBuf - pbuf < cbBuf)
		if (pEndBuf - pCurBuf < cbBytes)
			cbBytes = (int)(pEndBuf - pCurBuf);

	if (pCurBuf + cbBytes < pEndBuf) {
		memcpy(pbDest, pCurBuf, cbBytes);
		pCurBuf += cbBytes;
		return cbBytes;
	}
	PBYTE pbDst = (PBYTE) pbDest;

	// If destination buffer is larger then our internal buffer, then
	// recursively call until we have filled up the destination.

	int cbRead =  (int)(pEndBuf - pCurBuf);
	memcpy(pbDest, pCurBuf, cbRead);
	pbDst += cbRead;
	ReadBuf();
	if (m_fEndOfFile)
		return cbRead;
	else
		pCurBuf--; // since ReadBuf incremented it

	return read(pbDst, cbBytes - cbRead) + cbRead;
}

int STDCALL CStream::seek(int pos, SEEK_TYPE seek)
{
	ASSERT(seek != SK_END); // we don't support this one

	if (seek == SK_CUR)
		pos = lFileBuf + (int)(pCurBuf - pbuf) + pos;

	if (pos >= lFileBuf && pos < lFilePos) {
		pCurBuf = pbuf + (pos - lFileBuf);
		if (pCurBuf >= pEndBuf && pEndBuf < pbuf + cbBuf) 
			m_fEndOfFile = TRUE;
		return lFileBuf + (int)(pCurBuf - pbuf);
	}
	else {
		if (fDualCPU) {
			WaitForReadAhead();
		}
		lFileBuf = _llseek(hfile, pos, SEEK_SET);
		int cread = _lread(hfile, pbuf, cbBuf);
		if (cread == HFILE_ERROR) {
			m_fEndOfFile = TRUE;
			return chEOF;
		}
		lFilePos = lFileBuf + cread;
		pCurBuf = pbuf;
		pEndBuf = pbuf + cread;
		if (fDualCPU) {
			cThrdRead = HFILE_NOTREAD;
			ReleaseSemaphore(hsemRead, 1, PTR_SEM_READ_COUNT);
			if (fReadAheadStarted)
				ReleaseSemaphore(hsemStart, 1, PTR_SEM_START_COUNT); // start read-ahead thread
		}
		if (cread == 0)
			m_fEndOfFile = TRUE;

		return lFilePos;
	}
}

void CStream::WaitForReadAhead(void)
{
	for(;;) {
		WaitForSingleObject(hsemRead, INFINITE);
		if (cThrdRead == HFILE_NOTREAD) {
			ReleaseSemaphore(hsemRead, 1, PTR_SEM_READ_COUNT);
			Sleep(1); // give read-ahead thread a chance to run
		}
		else
			return;
	}
}

/***************************************************************************

	FUNCTION:	ReadAhead

	PURPOSE:	Reads the next block of data from a file

	PARAMETERS:
		pthis

	RETURNS:

	COMMENTS:
		Two semaphores control this thread:
			hsemStart: keeps the thread suspended while waiting for the
				caller to finish reading one of its blocks.
			hsemRead: used as a signal between the main thread and this
				thread as to when this thread has completed.

		Because it is theoretically possible for a thread switch to occur
		between the time the hsemStart thread starts this thread and this
		thread's call to WaitForSingleObject(hsemRead), the caller also sets
		the read return value to HFILE_NOTREAD to ensure that it does not
		attempt to use this buffer until in fact the read has completed.

		NOTE: this thread approach only makes sense on a system with more
		then one CPU.

	MODIFICATION DATES:
		05-Feb-1997 [ralphw]

***************************************************************************/

DWORD WINAPI ReadAhead(LPVOID pv)
{
	/*
	 * Each time through the loop, we block on hsemStart, waiting for our
	 * caller to release it. The hsemRead is used to block the caller until
	 * we have completed our read.
	 */

	for (;;) {
		PBYTE pbReadBuf;
		WaitForSingleObject(hsemStart, INFINITE);
		if (fExitThread)
			break;
		WaitForSingleObject(hsemRead, INFINITE);
		pbReadBuf = (pThis->pbuf == pbuf1) ? pbuf2 : pbuf1;
		pThis->cThrdRead = _lread(pThis->hfile, pbReadBuf, pThis->cbBuf);
		ReleaseSemaphore(hsemRead, 1, PTR_SEM_READ_COUNT);
	}
	ExitThread(0);
	return 0;
}

/***************************************************************************

	FUNCTION:	CStream::Cleanup

	PURPOSE:	Cleanup global variables

	PARAMETERS:
		void

	RETURNS:

	COMMENTS:

	MODIFICATION DATES:
		05-Feb-1997 [ralphw]

***************************************************************************/

void CStream::Cleanup(void)
{
	if (fReadAheadStarted) {
		fExitThread = TRUE;
		ReleaseSemaphore(hsemStart, 1, PTR_SEM_START_COUNT); // start read-ahead thread
		Sleep(1); // Let the other thread run
		CloseHandle(hsemStart);
		CloseHandle(hsemRead);
		lcFree(pbuf1);
		lcFree(pbuf2);
		hsemStart = hsemRead = pbuf1 = pbuf2 = NULL;
	}
}

#ifdef _DEBUG

char CStream::cget()
{
	if (pCurBuf < pEndBuf)
		return (char) *pCurBuf++;
	else if (pEndBuf < pbuf + cbBuf) {
		m_fEndOfFile = TRUE;
		return chEOF;
	}
	else
		return ReadBuf();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\csubset.h ===
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CSUBSET_H__
#define __CSUBSET_H__

#include "cinfotyp.h"

#define MAX_SUBSETS 10

class CHHWinType;

class CSubSet
{

private:
    INFOTYPE dwI;
    INFOTYPE dwE;

public:
    CStr        m_cszSubSetName;
    INFOTYPE    *m_pInclusive;    // A bit field of the ITs to include in the subset
    INFOTYPE    *m_pExclusive;    // A bit field of the ITs to exclude in from the subset
    CInfoType   *m_pIT;
    int         m_ITSize;         // the size of INFOTYPE
    BOOL        m_bPredefined;    // Created by author or user, author created SS are read only
    BOOL        m_bIsEntireCollection;
    INFOTYPE    **m_aCatMasks;

public:
    CSubSet( int const ITSize); // Constructor
    ~CSubSet();                            // Descructor
    const   CSubSet& operator=(const CSubSet& SetSrc);   // Copy constructor

    BOOL    Filter( INFOTYPE const *pTopicIT ) const;// { return TRUE; }
    void    DeleteIncType( int const type ){ if(m_pInclusive) DeleteIT(type, m_pInclusive);}
    void    DeleteExcType( int const type ){ if(m_pExclusive) DeleteIT(type, m_pExclusive);}
    void    AddIncType(int const type ){if(m_pInclusive) AddIT(type, m_pInclusive);}
    void    AddExcType(int const type) {if(m_pExclusive) AddIT(type, m_pExclusive);}
    void    BuildMask(void);
    BOOL    IsSameSet (PCSTR pszName) const;

    int     GetFirstExcITinSubSet(void) const;
    int     GetNextExcITinSubSet(void) const;
    int     GetFirstIncITinSubSet(void) const;
    int     GetNextIncITinSubSet(void) const;
    BOOL    IsDeleted( const int pos ) const {if (!m_pIT) return TRUE; 
                        return ( ((m_pIT->m_itTables.m_ptblInfoTypes->CountStrings()>0)&&
                                 *(m_pIT->m_itTables.m_ptblInfoTypes->GetPointer(pos))==' ' ))?TRUE:FALSE;}

};


class CSubSets : public CSubSet
{

friend class CChooseSubsets;
friend class CAdvancedSearchNavPane;

public:
    CSubSets( int ITSize, CTable *ptblSubSets, CSiteMap *pSiteMap, BOOL fPredefined );
    CSubSets( int ITSize, CInfoType *pIT, BOOL fPredefined );  // constructor
    ~CSubSets(void);                                             // Destructor
    const CSubSets& operator=( const CSubSets& SetsSrc );              // Copy Constructor
#ifdef HHCTRL
    CSubSets( int ITSize, CHmData* const phmData, BOOL fPredefined);
    void CopyTo( CHmData * const phmData );
#endif

protected:
    void _CSubSets(void);
    CSubSet **m_aSubSets;   // An allocated array of allocated subsets.
    int     m_cSets;        // The number of subsets defined in m_aSubSets
    int     m_max_subsets;  // the number of allocated locations in m_aSubSets
    PSTR    m_pszFilename;  // Where user defined subsets persist on disk

    CSubSet *m_Toc;
    CSubSet *m_Index;
    CSubSet *m_FTS;

public:
    BOOL    m_fPredefined;  // TRUE if the SS are predefined
    CSubSet *m_cur_Set;

public:
    BOOL    fTOCFilter( INFOTYPE const *pTopicIT ) const { return m_Toc?m_Toc->Filter( pTopicIT ):TRUE; }
    BOOL    fIndexFilter( INFOTYPE const *pTopicIT ) const { return m_Index?m_Index->Filter( pTopicIT ):TRUE; }
    BOOL    fFTSFilter( INFOTYPE const *pTopicIT ) const { return m_FTS?m_FTS->Filter( pTopicIT ):TRUE; }

    CSubSet * GetTocSubset() { return m_Toc; }
    CSubSet * GetIndexSubset() { return m_Index; }
    CSubSet * GetFTSSubset() { return m_FTS; }

    BOOL    fTocMask(void) const { return ( m_Toc == NULL)?FALSE:TRUE; }
    BOOL    fIndexMask(void) const { return ( m_Index == NULL)?FALSE:TRUE; }
    BOOL    fFTSMask(void) const { return ( m_FTS == NULL)?FALSE:TRUE; }

#ifdef HHCTRL
    void    SetTocMask( PCSTR  psz, CHHWinType* phh);
#else
    void    SetTocMask( PCSTR  psz ) { if (int i = GetSubSetIndex(psz)>=0) m_Toc = m_aSubSets[i]; else m_Toc = NULL ;}
#endif
    void    SetIndexMask( PCSTR psz) { if (int i = GetSubSetIndex(psz)>=0) m_Index = m_aSubSets[i]; else m_Index = NULL ;}
    void    SetFTSMask( PCSTR  psz ) { if (int i = GetSubSetIndex(psz)>=0) m_FTS = m_aSubSets[i]; else m_FTS = NULL ;}

    CSubSet *AddSubSet(CSubSet *SubSet); // import a subset
    CSubSet *AddSubSet( ); // create a new subset.
    void    RemoveSubSet( PCSTR cszName );

    BOOL    SaveToFile( PCSTR filename );   // user defined subsets
    BOOL    ReadFromFile( PCSTR filename ); // user degined subsets
    PCSTR   GetSubSetFile(void) { return m_pszFilename; }
    void    SetSubSetFile(PCSTR pszFile) {
                            if (!m_pszFilename && pszFile)
                                m_pszFilename = lcStrDup(pszFile); }
    int     HowManySubSets() const { return m_cSets; }
    int     GetSubSetIndex( PCSTR pszName ) const;

    CSubSet *GetSubSet( int const SubSet ) const { return m_aSubSets[SubSet]; }
    CSubSet *GetSubSet( PCSTR pszName ) const { return m_aSubSets[GetSubSetIndex(pszName)]; }
    CSubSet *SelectSubSet( PCSTR pszName ) {m_cur_Set = m_aSubSets[GetSubSetIndex(pszName)];return m_cur_Set;}

protected:
    void    ReSizeSubSet(); // called from AddSubSet()
};


#endif  // __CSUBSET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ctlmisc.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "CtlHelp.H"
#include "StdEnum.H"
#include "internet.h"
#include "hhctrl.h"
#include <stddef.h>

#include <stdarg.h>

#ifndef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

// this is used in our window proc so that we can find out who was last created

static COleControl *s_pLastControlCreated;

//=--------------------------------------------------------------------------=
// COleControl::COleControl
//=--------------------------------------------------------------------------=
// constructor
//
// Parameters:
//   IUnknown *        - [in] controlling Unknown
//   int            - [in] type of primary dispatch interface OBJECT_TYPE_*
//   void *         - [in] pointer to entire object
//
// Notes:
//
COleControl::COleControl
(
   IUnknown *pUnkOuter,
   int     iPrimaryDispatch,
   void   *pMainInterface
)
: CAutomationObject(pUnkOuter, iPrimaryDispatch, pMainInterface),
  m_cpEvents(SINK_TYPE_EVENT),
  m_cpPropNotify(SINK_TYPE_PROPNOTIFY)
{
   // initialize all our variables -- we decided against using a memory-zeroing
   // memory allocator, so we sort of have to do this work now ...
   //
   m_nFreezeEvents = 0;

   m_pClientSite = NULL;
   m_pControlSite = NULL;
   m_pInPlaceSite = NULL;
   m_pInPlaceFrame = NULL;
   m_pInPlaceUIWindow = NULL;


   m_pInPlaceSiteWndless = NULL;

   // certain hosts don't like 0,0 as your initial size, so we're going to set
   // our initial size to 100,50 [so it's at least sort of visible on the screen]

   m_Size.cx = 100;
   m_Size.cy = 50;
   SetRectEmpty(&m_rcLocation);

   m_hwnd = NULL;
   m_hwndParent = NULL;

   m_nFreezeEvents = 0;
   // m_pSimpleFrameSite = NULL;
   m_pOleAdviseHolder = NULL;
   m_pViewAdviseSink = NULL;
   m_pDispAmbient = NULL;

   m_fDirty = FALSE;
   m_fModeFlagValid = FALSE;
   m_fInPlaceActive = FALSE;
   m_fInPlaceVisible = FALSE;
   m_fUIActive = FALSE;
   m_fSaveSucceeded = FALSE;
   m_fViewAdvisePrimeFirst = FALSE;
   m_fViewAdviseOnlyOnce = FALSE;
   m_fRunMode = FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::~COleControl
//=--------------------------------------------------------------------------=
// "We are all of us resigned to death; it's life we aren't resigned to."
//   - Graham Greene (1904-91)
//
// Notes:
//
COleControl::~COleControl()
{
   // if we've still got a window, go and kill it now.
   //
   if (m_hwnd) {
      // so our window proc doesn't crash.
      //
      SetWindowLong(m_hwnd, GWLP_USERDATA, 0xFFFFFFFF);
      DestroyWindow(m_hwnd);
   }

   // clean up all the pointers we're holding around.

   QUICK_RELEASE(m_pClientSite);
   QUICK_RELEASE(m_pControlSite);
   QUICK_RELEASE(m_pInPlaceSite);
   QUICK_RELEASE(m_pInPlaceFrame);
   QUICK_RELEASE(m_pInPlaceUIWindow);
   // QUICK_RELEASE(m_pSimpleFrameSite);
   QUICK_RELEASE(m_pOleAdviseHolder);
   QUICK_RELEASE(m_pViewAdviseSink);
   QUICK_RELEASE(m_pDispAmbient);

   QUICK_RELEASE(m_pInPlaceSiteWndless);
}

//=--------------------------------------------------------------------------=
// COleControl::InternalQueryInterface
//=--------------------------------------------------------------------------=
// derived-controls should delegate back to this when they decide to support
// additional interfaces
//
// Parameters:
//   REFIID    - [in]   interface they want
//   void **      - [out] where they want to put the resulting object ptr.
//
// Output:
//   HRESULT      - S_OK, E_NOINTERFACE
//
// Notes:
//   - NOTE: this function is speed critical!!!!
// Using the typedef'd enum lets use see what the value of riid.Data1 is

typedef enum {
    tgIUnknown                = 0x00000000,
    tgIClassFactory           = 0x00000001,
    tgIMalloc                 = 0x00000002,
    tgIMarshal                = 0x00000003,
    tgIPSFactory              = 0x00000009,
    tgILockBytes              = 0x0000000a,
    tgIStorage                = 0x0000000b,
    tgIStream                 = 0x0000000c,
    tgIEnumSTATSTG            = 0x0000000d,
    tgIBindCtx                = 0x0000000e,
    tgIMoniker                = 0x0000000f,
    tgIRunningObjectTable        = 0x00000010,
    tgIInternalMoniker        = 0x00000011,
    tgIRootStorage            = 0x00000012,
    tgIMessageFilter          = 0x00000016,
    tgIStdMarshalInfo            = 0x00000018,
    tgIExternalConnection        = 0x00000019,
    tgIWeakRef                = 0x0000001a,
    tgIEnumUnknown            = 0x00000100,
    tgIEnumString             = 0x00000101,
    tgIEnumMoniker            = 0x00000102,
    tgIEnumFORMATETC          = 0x00000103,
    tgIEnumOLEVERB            = 0x00000104,
    tgIEnumSTATDATA           = 0x00000105,
    tgIEnumGeneric            = 0x00000106,
    tgIEnumHolder             = 0x00000107,
    tgIEnumCallback           = 0x00000108,
    tgIPersistStream          = 0x00000109,
    tgIPersistStorage            = 0x0000010a,
    tgIPersistFile            = 0x0000010b,
    tgIPersist                = 0x0000010c,
    tgIViewObject             = 0x0000010d,
    tgIDataObject             = 0x0000010e,
    tgIAdviseSink             = 0x0000010f,
    tgIDataAdviseHolder       = 0x00000110,
    tgIOleAdviseHolder        = 0x00000111,
    tgIOleObject              = 0x00000112,
    tgIOleInPlaceObject       = 0x00000113,
    tgIOleWindow              = 0x00000114,
    tgIOleInPlaceUIWindow        = 0x00000115,
    tgIOleInPlaceFrame        = 0x00000116,
    tgIOleInPlaceActiveObject    = 0x00000117,
    tgIOleClientSite          = 0x00000118,
    tgIOleInPlaceSite            = 0x00000119,
    tgIParseDisplayName       = 0x0000011a,
    tgIOleContainer           = 0x0000011b,
    tgIOleItemContainer       = 0x0000011c,
    tgIOleLink                = 0x0000011d,
    tgIOleCache               = 0x0000011e,
    tgIOleManager             = 0x0000011f,
    tgIOlePresObj             = 0x00000120,
    tgIDropSource             = 0x00000121,
    tgIDropTarget             = 0x00000122,
    tgIAdviseSink2            = 0x00000125,
    tgIRunnableObject            = 0x00000126,
    tgIViewObject2            = 0x00000127,
    tgIOleCache2              = 0x00000128,
    tgIOleCacheControl        = 0x00000129,
    tgIDispatch               = 0x00020400,
    tgITypeInfo               = 0x00020401,
    tgITypeLib                = 0x00020402,
    tgITypeComp               = 0x00020403,
    tgIEnumVARIANT            = 0x00020404,
    tgICreateTypeInfo            = 0x00020405,
    tgICreateTypeLib          = 0x00020406,
    tgIPropertyPage2          = 0x01e44665,
    tgIOleInPlaceObjectWindowless   = 0x1c2056cc,
    tgIErrorInfo              = 0x1cf2b120,
    tgICreateErrorInfo        = 0x22f03340,
    tgIPerPropertyBrowsing       = 0x376bd3aa,
    tgIPersistPropertyBag        = 0x37D84F60,
    tgIAdviseSinkEx           = 0x3af24290,
    tgIViewObjectEx           = 0x3af24292,
    tgICategorizeProperties      = 0x4d07fc10,
    tgIPointerInactive        = 0x55980ba0,
    tgIFormExpert             = 0x5aac7f70,
    tgIOleInPlaceComponent       = 0x5efc7970,
    tgIGangConnectWithDefault    = 0x6d5140c0,
    tgIServiceProvider        = 0x6d5140c1,
    tgISelectionContainer        = 0x6d5140c6,
    tgIRequireClasses            = 0x6d5140d0,
    tgIProvideDynamicClassInfo   = 0x6d5140d1,
    tgIDataFrameExpert        = 0x73687490,
    tgISimpleFrameSite        = 0x742b0e01,
    tgIPicture                = 0x7bf80980,
    tgIPictureDisp            = 0x7bf80981,
    tgIPersistStreamInit         = 0x7fd52380,
    tgIOleUndoAction          = 0x894ad3b0,
    tgIOleInPlaceSiteWindowless  = 0x922eada0,
    tgIDataFrame              = 0x97F254E0,
    tgIControl_95             = 0x9a4bbfb5,
    tgIPropertyNotifySink        = 0x9bfbbc02,
    tgIOleInPlaceSiteEx       = 0x9c2cad80,
    tgIOleCompoundUndoAction     = 0xa1faf330,
    tgIControl                = 0xa7fddba0,
    tgIProvideClassInfo       = 0xb196b283,
    tgIConnectionPointContainer  = 0xb196b284,
    tgIEnumConnectionPoints      = 0xb196b285,
    tgIConnectionPoint        = 0xb196b286,
    tgIEnumConnections        = 0xb196b287,
    tgIOleControl             = 0xb196b288,
    tgIOleControlSite            = 0xb196b289,
    tgISpecifyPropertyPages      = 0xb196b28b,
    tgIPropertyPageSite       = 0xb196b28c,
    tgIPropertyPage           = 0xb196b28d,
    tgIClassFactory2          = 0xb196b28f,
    tgIEnumOleUndoActions        = 0xb3e7c340,
    tgIMsoDocument            = 0xb722bcc5,
    tgIMsoView                = 0xb722bcc6,
    tgIMsoCommandTarget       = 0xb722bccb,
    tgIOlePropertyFrame       = 0xb83bb801,
    tgIPropertyPageInPlace       = 0xb83bb802,
    tgIPropertyPage3          = 0xb83bb803,
    tgIPropertyPageSite2         = 0xb83bb804,
    tgIFont                = 0xbef6e002,
    tgIFontDisp               = 0xbef6e003,
    tgIQuickActivate          = 0xcf51ed10,
    tgIOleUndoActionManager      = 0xd001f200,
    tgIPSFactoryBuffer        = 0xd5f569d0,
    tgIOleStandardTool        = 0xd97877c4,
    tgISupportErrorInfo       = 0xdf0b3d60,
    tgICDataDoc               = 0xF413E4C0,
} DATA1_GUIDS;


HRESULT COleControl::InternalQueryInterface(REFIID riid, void **ppvObjOut)
{
#ifdef _DEBUG
   DATA1_GUIDS gd = (DATA1_GUIDS) riid.Data1;
#endif
   switch (riid.Data1) {
      // private interface for prop page support
      case Data1_IControlPrv:
        if (DO_GUIDS_MATCH(riid, IID_IControlPrv)) {
         *ppvObjOut = (void *)this;
         ExternalAddRef();
         return S_OK;
        }
        goto NoInterface;

      case Data1_IOleControl:
         if (DO_GUIDS_MATCH(riid, IID_IOleControl))
            *ppvObjOut = (void *) (IOleControl*) this;
         break;

      case Data1_IPointerInactive:
         if (DO_GUIDS_MATCH(riid, IID_IPointerInactive))
            *ppvObjOut = (void *) (IPointerInactive*) this;
         break;

      case Data1_IQuickActivate:
         if (DO_GUIDS_MATCH(riid, IID_IQuickActivate))
            *ppvObjOut = (void *) (IQuickActivate*) this;
         break;

      case Data1_IOleObject:
         if (DO_GUIDS_MATCH(riid, IID_IOleObject))
            *ppvObjOut = (void *) (IOleObject*) this;
         break;

      QI_INHERITS((IPersistStorage *)this, IPersist);
      QI_INHERITS(this, IPersistStreamInit);
      QI_INHERITS(this, IOleInPlaceObject);
      QI_INHERITS(this, IOleInPlaceObjectWindowless);
      QI_INHERITS((IOleInPlaceActiveObject *)this, IOleWindow);
      QI_INHERITS(this, IOleInPlaceActiveObject);
      QI_INHERITS(this, IViewObject);
      QI_INHERITS(this, IViewObject2);
      QI_INHERITS(this, IViewObjectEx);
      QI_INHERITS(this, IConnectionPointContainer);
      // QI_INHERITS(this, ISpecifyPropertyPages);
      QI_INHERITS(this, IPersistStorage);
      QI_INHERITS(this, IPersistPropertyBag);
      QI_INHERITS(this, IProvideClassInfo);

      default:
         goto NoInterface;
   }

   // we like the interface, so addref and return

   ((IUnknown *)(*ppvObjOut))->AddRef();
   return S_OK;

NoInterface:
   // delegate to super-class for automation interfaces, etc ...

   return CAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
// COleControl::FindConnectionPoint    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// given an IID, find a connection point sink for it.
//
// Parameters:
//   REFIID         - [in]  interfaces they want
//   IConnectionPoint ** - [out] where the cp should go
//
// Output:
//   HRESULT

STDMETHODIMP COleControl::FindConnectionPoint(REFIID riid, IConnectionPoint **ppConnectionPoint)
{
   CHECK_POINTER(ppConnectionPoint);

   // we support the event interface, and IDispatch for it, and we also
   // support IPropertyNotifySink.
   //
   if (DO_GUIDS_MATCH(riid, EVENTIIDOFCONTROL(m_ObjectType)) || DO_GUIDS_MATCH(riid, IID_IDispatch))
      *ppConnectionPoint = &m_cpEvents;
   else if (DO_GUIDS_MATCH(riid, IID_IPropertyNotifySink))
      *ppConnectionPoint = &m_cpPropNotify;
   else
      return E_NOINTERFACE;

   // generic post-processing.
   //
   (*ppConnectionPoint)->AddRef();
   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::EnumConnectionPoints   [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// creates an enumerator for connection points.
//
// Parameters:
//   IEnumConnectionPoints **   - [out]
//
// Output:
//   HRESULT

STDMETHODIMP COleControl::EnumConnectionPoints(IEnumConnectionPoints **ppEnumConnectionPoints)
{
   IConnectionPoint **rgConnectionPoints;

   CHECK_POINTER(ppEnumConnectionPoints);

   // Alloc an array of connection points [since our standard enum
   // assumes this and free's it later ]

   rgConnectionPoints = (IConnectionPoint **) lcCalloc(sizeof(IConnectionPoint *) * 2);
   RETURN_ON_NULLALLOC(rgConnectionPoints);

   // we support the event interface for this dude as well as IPropertyNotifySink
   //
   rgConnectionPoints[0] = &m_cpEvents;
   rgConnectionPoints[1] = &m_cpPropNotify;

   *ppEnumConnectionPoints = (IEnumConnectionPoints *)(IEnumGeneric *) new CStandardEnum(IID_IEnumConnectionPoints,
                        2, sizeof(IConnectionPoint *), (void *)rgConnectionPoints,
                        CopyAndAddRefObject);
   if (!*ppEnumConnectionPoints) {
      lcFree(rgConnectionPoints);
      return E_OUTOFMEMORY;
   }

   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::m_pOleControl
//=--------------------------------------------------------------------------=
// returns a pointer to the control in which we are nested.
//
// Output:
//   COleControl *
//
// Notes:
//
inline COleControl *COleControl::CConnectionPoint::m_pOleControl
(
   void
)
{
   return (COleControl *)((BYTE *)this - ((m_bType == SINK_TYPE_EVENT)
                                ? offsetof(COleControl, m_cpEvents)
                                : offsetof(COleControl, m_cpPropNotify)));
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::QueryInterface
//=--------------------------------------------------------------------------=
// standard qi
//
// Parameters:
//   REFIID    - [in]   interface they want
//   void **      - [out] where they want to put the resulting object ptr.
//
// Output:
//   HRESULT      - S_OK, E_NOINTERFACE

STDMETHODIMP COleControl::CConnectionPoint::QueryInterface
(
   REFIID riid,
   void **ppvObjOut
)
{
   if (DO_GUIDS_MATCH(riid, IID_IConnectionPoint) || DO_GUIDS_MATCH(riid, IID_IUnknown)) {
      *ppvObjOut = (IConnectionPoint *)this;
      AddRef();
      return S_OK;
   }

   return E_NOINTERFACE;
}

ULONG COleControl::CConnectionPoint::AddRef(void)
{
   return m_pOleControl()->ExternalAddRef();
}

ULONG COleControl::CConnectionPoint::Release(void)
{
   return m_pOleControl()->ExternalRelease();
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::GetConnectionInterface
//=--------------------------------------------------------------------------=
// returns the interface we support connections on.
//
// Parameters:
//   IID *     - [out] interface we support.
//
// Output:
//   HRESULT

STDMETHODIMP COleControl::CConnectionPoint::GetConnectionInterface(IID *piid)
{
   if (m_bType == SINK_TYPE_EVENT)
      *piid = EVENTIIDOFCONTROL(m_pOleControl()->m_ObjectType);
   else
      *piid = IID_IPropertyNotifySink;

   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::GetConnectionPointContainer
//=--------------------------------------------------------------------------=
// returns the connection point container
//
// Parameters:
//   IConnectionPointContainer **ppCPC
//
// Output:
//   HRESULT

STDMETHODIMP COleControl::CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
   return m_pOleControl()->ExternalQueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectiontPoint::Advise
//=--------------------------------------------------------------------------=
// someboyd wants to be advised when something happens.
//
// Parameters:
//   IUnknown *      - [in]   guy who wants to be advised.
//   DWORD *         - [out] cookie
//
// Output:
//   HRESULT

STDMETHODIMP COleControl::CConnectionPoint::Advise(IUnknown *pUnk, DWORD *pdwCookie)
{
   HRESULT    hr;
   void    *pv;

   CHECK_POINTER(pdwCookie);

   // first, make sure everybody's got what they thinks they got

   if (m_bType == SINK_TYPE_EVENT) {

      /*
       * CONSIDER: 12.95 -- this theoretically is broken -- if they do
       * a find connection point on IDispatch, and they just happened to
       * also support the Event IID, we'd advise on that. this is not
       * awesome, but will prove entirely acceptable short term.
       */

      hr = pUnk->QueryInterface(EVENTIIDOFCONTROL(m_pOleControl()->m_ObjectType), &pv);
      if (FAILED(hr))
         hr = pUnk->QueryInterface(IID_IDispatch, &pv);
   }
   else
      hr = pUnk->QueryInterface(IID_IPropertyNotifySink, &pv);
   RETURN_ON_FAILURE(hr);

   // finally, add the sink. It's now been cast to the correct type and has
   // been AddRef'd.

   return AddSink(pv, pdwCookie);
}

#ifdef _WIN64
IUnknown* COleControl::CConnectionPoint::CookieToSink( DWORD dwCookie )
{
    for ( short i=0; i<m_cSinks; i++ )
	{
       if ( m_rgSinks64[i].dwCookie == dwCookie )
	      return m_rgSinks64[i].pUnk;
	}
	return NULL;
}

DWORD COleControl::CConnectionPoint::NextCookie()
{
   DWORD dw = m_dwNextCookie;
   if ( dw==0 )
   {
      // Try to find an available cookie
      // There must be an available cookie, since m_cSinks is a short, cookie is DWORD
	  dw = 1;
	  while ( CookieToSink(dw) != NULL )  // dw is used
         dw++;
   }
   else
      m_dwNextCookie++;
   return dw;
}
#endif

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::AddSink
//=--------------------------------------------------------------------------=
// in some cases, we'll already have done the QI, and won't need to do the
// work that is done in the Advise routine above.  thus, these people can
// just call this instead. [this stems really from IQuickActivate]
//
// Parameters:
//   void *    - [in]   the sink to add. it's already been addref'd
//   DWORD *      - [out] cookie
//
// Output:
//   HRESULT

HRESULT COleControl::CConnectionPoint::AddSink(void *pv, DWORD *pdwCookie)
{
#ifdef _WIN64
   CONNECTDATA*  rgUnkNew;

   if ( m_cSinks == 0 )
   {
      ASSERT_COMMENT(!m_rgSinks64, "this should be null when there are no sinks");
      m_rgSinks64 = (CONNECTDATA*)lcCalloc(8 * sizeof(CONNECTDATA));
      RETURN_ON_NULLALLOC(m_rgSinks64);
   }
   else if (!(m_cSinks & 0x7)) {
      rgUnkNew = (CONNECTDATA*)lcReAlloc(m_rgSinks64, (m_cSinks + 8) * sizeof(CONNECTDATA));
      RETURN_ON_NULLALLOC(rgUnkNew);
      m_rgSinks64 = rgUnkNew;
   }

   m_rgSinks64[m_cSinks].pUnk = (IUnknown *)pv;
   *pdwCookie = m_rgSinks64[m_cSinks].dwCookie = NextCookie();
   m_cSinks++;
   return S_OK;

#else
   IUnknown **rgUnkNew;
   int      i = 0;

   // we optimize the case where there is only one sink to not allocate
   // any storage.  turns out very rarely is there more than one.
   //
   switch (m_cSinks) {

      case 0:
         ASSERT_COMMENT(!m_rgSinks, "this should be null when there are no sinks");
         m_rgSinks = (IUnknown **)pv;
         break;

      case 1:
         // go ahead and do the initial allocation.   we'll get 8 at a time

         rgUnkNew = (IUnknown **)lcCalloc(8 * sizeof(IUnknown *));
         RETURN_ON_NULLALLOC(rgUnkNew);
         rgUnkNew[0] = (IUnknown *)m_rgSinks;
         rgUnkNew[1] = (IUnknown *)pv;
         m_rgSinks = rgUnkNew;
         break;

      default:
         // if we're out of sinks, then we have to increase the size
         // of the array

         if (!(m_cSinks & 0x7)) {
            rgUnkNew = (IUnknown **) lcReAlloc(m_rgSinks, (m_cSinks + 8) * sizeof(IUnknown *));
            RETURN_ON_NULLALLOC(rgUnkNew);
            m_rgSinks = rgUnkNew;
         } else
            rgUnkNew = m_rgSinks;

         rgUnkNew[m_cSinks] = (IUnknown *)pv;
         break;
   }

   *pdwCookie = (DWORD)pv;
   m_cSinks++;
   return S_OK;
#endif
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::Unadvise
//=--------------------------------------------------------------------------=
// they don't want to be told any more.
//
// Parameters:
//   DWORD     - [in]  the cookie we gave 'em.
//
// Output:
//   HRESULT

STDMETHODIMP COleControl::CConnectionPoint::Unadvise(DWORD dwCookie)
{
   IUnknown *pUnk;
   int     x;

   if (!dwCookie)
      return S_OK;

   // see how many sinks we've currently got, and deal with things based
   // on that.
#ifdef _WIN64
   pUnk = CookieToSink(dwCookie);

   if (pUnk == NULL)
      return CONNECT_E_NOCONNECTION;

   switch (m_cSinks) {
      case 1:
         lcFree(m_rgSinks64);
         m_rgSinks64 = NULL;
		 m_dwNextCookie = 1;
         break;

      default:
         // there are more than one sinks.  just clean up the hole we've
         // got in our array now.
         //
         for (x = 0; x < m_cSinks; x++) 
		 {
            if ((DWORD)m_rgSinks64[x].dwCookie == dwCookie)
               break;
         }
         if (x == m_cSinks) 
			 return CONNECT_E_NOCONNECTION;
         else  // (x < m_cSinks - 1)
            memcpy(&(m_rgSinks64[x]), &(m_rgSinks64[x + 1]), (m_cSinks -1 - x) * sizeof(CONNECTDATA));
         break;
   }

   // we're happy
   //
   m_cSinks--;
   pUnk->Release();
   return S_OK;

#else
   switch (m_cSinks) {
      case 1:
         // it's the only sink.  make sure the ptrs are the same, and
         // then free things up

         if ((DWORD)m_rgSinks != dwCookie)
            return CONNECT_E_NOCONNECTION;
         m_rgSinks = NULL;
         break;

      case 2:
         // there are two sinks.  go back down to one sink scenario
         //
         if ((DWORD)m_rgSinks[0] != dwCookie && (DWORD)m_rgSinks[1] != dwCookie)
            return CONNECT_E_NOCONNECTION;

         pUnk = ((DWORD)m_rgSinks[0] == dwCookie)
               ? m_rgSinks[1]
               : ((DWORD)m_rgSinks[1] == dwCookie) ? m_rgSinks[0] : NULL;

         if (!pUnk) return CONNECT_E_NOCONNECTION;

         lcFree(m_rgSinks);
         m_rgSinks = (IUnknown **)pUnk;
         break;

      default:
         // there are more than two sinks.  just clean up the hole we've
         // got in our array now.
         //
         for (x = 0; x < m_cSinks; x++) {
            if ((DWORD)m_rgSinks[x] == dwCookie)
               break;
         }
         if (x == m_cSinks) return CONNECT_E_NOCONNECTION;
         if (x < m_cSinks - 1)
            memcpy(&(m_rgSinks[x]), &(m_rgSinks[x + 1]), (m_cSinks -1 - x) * sizeof(IUnknown *));
         else
            m_rgSinks[x] = NULL;
         break;
   }


   // we're happy
   //
   m_cSinks--;
   ((IUnknown *)dwCookie)->Release();
   return S_OK;
#endif
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::EnumConnections
//=--------------------------------------------------------------------------=
// enumerates all current connections
//
// Paramters:
//   IEnumConnections ** - [out] new enumerator object
//
// Output:
//   HRESULT
//
// NOtes:
//
STDMETHODIMP COleControl::CConnectionPoint::EnumConnections
(
   IEnumConnections **ppEnumOut
)
{
   CONNECTDATA *rgConnectData = NULL;
   int i;

   if (m_cSinks) {
      // allocate some memory big enough to hold all of the sinks.

      rgConnectData = (CONNECTDATA *)lcCalloc(m_cSinks * sizeof(CONNECTDATA));
      RETURN_ON_NULLALLOC(rgConnectData);
#ifdef _WIN64
      for (i = 0; i < m_cSinks; i++) {
          rgConnectData[i].pUnk = m_rgSinks64[i].pUnk;
          rgConnectData[i].dwCookie = m_rgSinks64[i].dwCookie;
      }
#else

      // fill in the array
      //
      if (m_cSinks == 1) {
         rgConnectData[0].pUnk = (IUnknown *)m_rgSinks;
         rgConnectData[0].dwCookie = (DWORD)m_rgSinks;
      } else {
         // loop through all available sinks.
         //
         for (i = 0; i < m_cSinks; i++) {
            rgConnectData[i].pUnk = m_rgSinks[i];
            rgConnectData[i].dwCookie = (DWORD)m_rgSinks[i];
         }
      }
#endif
   }

   // create yon enumerator object.
   //
   *ppEnumOut = (IEnumConnections *)(IEnumGeneric *)new CStandardEnum(IID_IEnumConnections,
                  m_cSinks, sizeof(CONNECTDATA), rgConnectData, CopyAndAddRefObject);
   if (!*ppEnumOut) {
      lcFree(rgConnectData);
      return E_OUTOFMEMORY;
   }

   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::~CConnectionPoint
//=--------------------------------------------------------------------------=
// cleans up
//
// Notes:
//
COleControl::CConnectionPoint::~CConnectionPoint ()
{
   int x;

#ifdef _WIN64
   if (!m_cSinks)
      return;
   else {
      for (x = 0; x < m_cSinks; x++)
         QUICK_RELEASE(m_rgSinks64[x].pUnk);
      lcFree(m_rgSinks64);
   }
#else
   // clean up some memory stuff
   //
   if (!m_cSinks)
      return;
   else if (m_cSinks == 1)
      ((IUnknown *)m_rgSinks)->Release();
   else {
      for (x = 0; x < m_cSinks; x++)
         QUICK_RELEASE(m_rgSinks[x]);
      lcFree(m_rgSinks);
   }
#endif
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPiont::DoInvoke
//=--------------------------------------------------------------------------=
// fires an event to all listening on our event interface.
//
// Parameters:
//   DISPID       - [in] event to fire.
//   DISPPARAMS      - [in]

void COleControl::CConnectionPoint::DoInvoke(DISPID dispid, DISPPARAMS *pdispparams)
{
   int iConnection;

   // if we don't have any sinks, then there's nothing to do.  we intentionally
   // ignore errors here.

#ifdef _WIN64
   if (m_cSinks == 0)
      return;
   else
      for (iConnection = 0; iConnection < m_cSinks; iConnection++)
         ((IDispatch *)m_rgSinks64[iConnection].pUnk)->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
#else
   if (m_cSinks == 0)
      return;
   else if (m_cSinks == 1)
      ((IDispatch *)m_rgSinks)->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
   else
      for (iConnection = 0; iConnection < m_cSinks; iConnection++)
         ((IDispatch *)m_rgSinks[iConnection])->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
#endif
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::DoOnChanged
//=--------------------------------------------------------------------------=
// fires the OnChanged event for IPropertyNotifySink listeners.
//
// Parameters:
//   DISPID       - [in] dude that changed.
//
// Output:
//   none

void COleControl::CConnectionPoint::DoOnChanged(DISPID dispid)
{
   ASSERT_COMMENT(FALSE, "DoOnChanged called, restore the code");
#if 0
   int iConnection;

   // if we don't have any sinks, then there's nothing to do.

   if (m_cSinks == 0)
      return;
   else if (m_cSinks == 1)
      ((IPropertyNotifySink *)m_rgSinks)->OnChanged(dispid);
   else
      for (iConnection = 0; iConnection < m_cSinks; iConnection++)
         ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnChanged(dispid);
#endif
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::DoOnRequestEdit
//=--------------------------------------------------------------------------=
// fires the OnRequestEdit for IPropertyNotifySinkListeners
//
// Parameters:
//   DISPID        - [in] dispid user wants to change.
//
// Output:
//   BOOL             - false means you cant

BOOL COleControl::CConnectionPoint::DoOnRequestEdit(DISPID dispid)
{
   HRESULT hr;
   int   iConnection;

#ifdef _WIN64
   if (m_cSinks == 0)
      hr = S_OK;
   else {
      for (iConnection = 0; iConnection < m_cSinks; iConnection++) {
         hr = ((IPropertyNotifySink *)m_rgSinks64[iConnection].pUnk)->OnRequestEdit(dispid);
         if (hr != S_OK) break;
      }
   }
#else
   // if we don't have any sinks, then there's nothing to do.

   if (m_cSinks == 0)
      hr = S_OK;
   else if (m_cSinks == 1)
      hr =((IPropertyNotifySink *)m_rgSinks)->OnRequestEdit(dispid);
   else {
      for (iConnection = 0; iConnection < m_cSinks; iConnection++) {
         hr = ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnRequestEdit(dispid);
         if (hr != S_OK) break;
      }
   }
#endif
   return (hr == S_OK) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::CreateInPlaceWindow
//=--------------------------------------------------------------------------=
// creates the window with which we will be working.
// yay.
//
// Parameters:
//   int        - [in] left
//   int        - [in] top
//   BOOL          - [in] can we skip redrawing?
//
// Output:
//   HWND
//
// Notes:
//   - DANGER! DANGER!  this function is protected so that anybody can call it
//    from their control.  however, people should be extremely careful of when
//    and why they do this.  preferably, this function would only need to be
//    called by an end-control writer in design mode to take care of some
//    hosting/painting issues.  otherwise, the framework should be left to
//    call it when it wants.

HWND COleControl::CreateInPlaceWindow(int x, int y, BOOL fNoRedraw)
{
   BOOL  fVisible;
   DWORD dwWindowStyle, dwExWindowStyle;
   char  szWindowTitle[128];

   // if we've already got a window, do nothing.

   if (m_hwnd)
      return m_hwnd;

   // get the user to register the class if it's not already
   // been done.  we have to critical section this since more than one thread
   // can be trying to create this control

   if (!CTLWNDCLASSREGISTERED(m_ObjectType)) {
      // EnterCriticalSection(&g_CriticalSection);
      if (!RegisterClassData()) {
         // LeaveCriticalSection(&g_CriticalSection);
         return NULL;
      }
      else
         CTLWNDCLASSREGISTERED(m_ObjectType) = TRUE;
      // LeaveCriticalSection(&g_CriticalSection);
   }

   dwWindowStyle = dwExWindowStyle = 0;
   szWindowTitle[0] = '\0';
   if (!BeforeCreateWindow(&dwWindowStyle, &dwExWindowStyle, szWindowTitle))
      return NULL;

   dwWindowStyle |= (WS_CHILD | WS_CLIPSIBLINGS);

   // create window visible if parent hidden (common case)
   // otherwise, create hidden, then shown.  this is a little subtle, but
   // it makes sense eventually.

   ASSERT(m_hwndParent);   // why would this ever occur? [rw]
   if (!m_hwndParent)
      m_hwndParent = GetParkingWindow();

   fVisible = IsWindowVisible(m_hwndParent);
   if (!fVisible)
      dwWindowStyle |= WS_VISIBLE;

   // we have to mutex the entire create window process since we need to use
   // the s_pLastControlCreated to pass in the object pointer.  nothing too
   // serious

   // EnterCriticalSection(&g_CriticalSection);
   s_pLastControlCreated = this;
   m_fCreatingWindow = TRUE;

   // finally, go create the window, parenting it as appropriate.

   m_hwnd = CreateWindowEx(dwExWindowStyle,
                     WNDCLASSNAMEOFCONTROL(m_ObjectType),
                     szWindowTitle,
                     dwWindowStyle,
                     x, y,
                     m_Size.cx, m_Size.cy,
                     m_hwndParent,
                     NULL, _Module.GetModuleInstance(), NULL);

   // clean up some variables, and leave the critical section

   m_fCreatingWindow = FALSE;
   s_pLastControlCreated = NULL;
   // LeaveCriticalSection(&g_CriticalSection);

   if (IsValidWindow(m_hwnd)) {
      // let the derived-control do something if they so desire

      if (!AfterCreateWindow()) {
         BeforeDestroyWindow();
         SetWindowLong(m_hwnd, GWLP_USERDATA, 0xFFFFFFFF);
         DestroyWindow(m_hwnd);
         m_hwnd = NULL;
         return m_hwnd;
      }

      // if we didn't create the window visible, show it now.

      if (fVisible)
         SetWindowPos(m_hwnd,
            // m_hwndParent,
            NULL, // RAID #30314
               0, 0, 0, 0,
               SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW | (fNoRedraw) ? SWP_NOREDRAW : 0);
   }

   // finally, tell the host of this

   if (m_pClientSite)
      m_pClientSite->ShowObject();

   return m_hwnd;
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceParent [helper]
//=--------------------------------------------------------------------------=
// sets up the parent window for our control.
//
// Parameters:
//   HWND           - [in] new parent window

void COleControl::SetInPlaceParent(HWND hwndParent)
{
   ASSERT_COMMENT(!m_pInPlaceSiteWndless, "This routine should only get called for windowed OLE controls");

   if (m_hwndParent == hwndParent)
      return;

   m_hwndParent = hwndParent;
   if (m_hwnd)
      SetParent(m_hwnd, hwndParent);
}

//=--------------------------------------------------------------------------=
// COleControl::ControlWindowProc
//=--------------------------------------------------------------------------=
// default window proc for an OLE Control.    controls will have their own
// window proc called from this one, after some processing is done.
//
// Parameters:
//   - see win32sdk docs.
//
// Notes:
//

LRESULT CALLBACK COleControl::ControlWindowProc(HWND hwnd, UINT msg,
   WPARAM wParam, LPARAM lParam)
{
   COleControl *pCtl = ControlFromHwnd(hwnd);
   LRESULT lResult;

   // if the value isn't a positive value, then it's in some special
   // state [creation or destruction]  this is safe because under win32,
   // the upper 2GB of an address space aren't available.

   if (!pCtl) {
      pCtl = s_pLastControlCreated;
      SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pCtl);
      pCtl->m_hwnd = hwnd;
   }

   // 17-Sep-1997 [ralphw] Changed to 0xFFFFFFFF to avoid 32-bit dependencies

   else if ((DWORD_PTR) pCtl == (DWORD_PTR) 0xFFFFFFFF) {
      return DefWindowProc(hwnd, msg, wParam, lParam);
   }

   // message preprocessing

#if 0
   if (pCtl->m_pSimpleFrameSite) {
      hr = pCtl->m_pSimpleFrameSite->PreMessageFilter(hwnd, msg, wParam, lParam, &lResult, &dwCookie);
      if (hr == S_FALSE)
         return lResult;
   }
#endif

   // for certain messages, do not call the user window proc. instead,
   // we have something else we'd like to do.

   switch (msg) {
     case WM_MOUSEACTIVATE:
      {
			 pCtl->InPlaceActivate(OLEIVERB_UIACTIVATE);
			 break;
      }
     case WM_PAINT:
      {
         // call the user's OnDraw routine.

         PAINTSTRUCT ps;
         RECT     rc;
         HDC      hdc;

         // if we're given an HDC, then use it

         // REVIEW: 17-Sep-1997  [ralphw] who's handing us a dc in wParam?

         if (!wParam)
            hdc = BeginPaint(hwnd, &ps);
         else
            hdc = (HDC)wParam;

         GetClientRect(hwnd, &rc);
         pCtl->OnDraw(DVASPECT_CONTENT, hdc, (RECTL *)&rc, NULL, NULL, TRUE);

         if (!wParam)
            EndPaint(hwnd, &ps);
      }
      break;

     default:
      // call the derived-control's window proc

      lResult = pCtl->WindowProc(msg, wParam, lParam);
      break;
   }

   // message postprocessing

   switch (msg) {
     case WM_NCDESTROY:
      // after this point, the window doesn't exist any more

      pCtl->m_hwnd = NULL;
      break;

     // REVIEW: 14-Oct-1997 [ralphw] This message never arrives

     case WM_SETFOCUS:
     case WM_KILLFOCUS:
      // give the control site focus notification

      if (pCtl->m_fInPlaceActive && pCtl->m_pControlSite) {
         DBWIN("Focus change");
         pCtl->m_pControlSite->OnFocus(msg == WM_SETFOCUS);
      }
      break;

     case WM_SIZE:
      // a change in size is a change in view

      if (!pCtl->m_fCreatingWindow)
         pCtl->ViewChanged();
      break;
   }

   // lastly, simple frame postmessage processing

#if 0
   if (pCtl->m_pSimpleFrameSite)
      pCtl->m_pSimpleFrameSite->PostMessageFilter(hwnd, msg, wParam, lParam, &lResult, dwCookie);
#endif

   return lResult;
}

//=--------------------------------------------------------------------------=
// COleControl::SetFocus
//=--------------------------------------------------------------------------=
// we have to override this routine to get UI Activation correct.
//
// Parameters:
//   BOOL            - [in] true means take, false release
//
// Output:
//   BOOL
//
// Notes:
//   - CONSIDER: this is pretty messy, and it's still not entirely clear
//    what the ole control/focus story is.

// REVIEW: 14-Oct-1997 [ralphw] Doesn't look like it is ever called

BOOL COleControl::SetFocus(BOOL fGrab)
{
   DBWIN("COleControl::SetFocus");

   HRESULT hr;
   HWND  hwnd;

   // first thing to do is check out UI Activation state, and then set
   // focus [either with windows api, or via the host for windowless
   // controls]

   if (m_pInPlaceSiteWndless) {
      if (!m_fUIActive && fGrab)
         if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE))) return FALSE;

      hr = m_pInPlaceSiteWndless->SetFocus(fGrab);
      return (hr == S_OK) ? TRUE : FALSE;
   }
   else {

      // we've got a window.

      if (m_fInPlaceActive) {
         hwnd = (fGrab) ? m_hwnd : m_hwndParent;
         if (!m_fUIActive && fGrab)
            return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
         else
            return (::SetFocus(hwnd) == hwnd);
      } else
         return FALSE;
   }

   // dead code
}

#if 0

//=--------------------------------------------------------------------------=
// COleControl::ReflectWindowProc
//=--------------------------------------------------------------------------=
// reflects window messages on to the child window.
//
// Parameters and Output:
//   - see win32 sdk docs

// REVIEW: 14-Oct-1997 [ralphw] Doesn't seem to ever be called

LRESULT CALLBACK COleControl::ReflectWindowProc(HWND hwnd, UINT msg,
   WPARAM wParam, LPARAM lParam)
{
   COleControl *pCtl;

   switch (msg) {
      case WM_COMMAND:
      case WM_NOTIFY:
      case WM_CTLCOLORBTN:
      case WM_CTLCOLORDLG:
      case WM_CTLCOLOREDIT:
      case WM_CTLCOLORLISTBOX:
      case WM_CTLCOLORMSGBOX:
      case WM_CTLCOLORSCROLLBAR:
      case WM_CTLCOLORSTATIC:
      case WM_DRAWITEM:
      case WM_MEASUREITEM:
      case WM_DELETEITEM:
      case WM_VKEYTOITEM:
      case WM_CHARTOITEM:
      case WM_COMPAREITEM:
      case WM_HSCROLL:
      case WM_VSCROLL:
      case WM_PARENTNOTIFY:
      case WM_SETFOCUS:
      case WM_SIZE:
         pCtl = (COleControl *) GetWindowLong(hwnd, GWLP_USERDATA);
         if (pCtl)
            return SendMessage(pCtl->m_hwnd, msg, wParam, lParam);
         break;
   }

   return DefWindowProc(hwnd, msg, wParam, lParam);
}
#endif

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientProperty    [callable]
//=--------------------------------------------------------------------------=
// returns the value of an ambient property
//
// Parameters:
//   DISPID    - [in]   property to get
//   VARTYPE      - [in]   type of desired data
//   void *    - [out] where to put the data
//
// Output:
//   BOOL         - FALSE means didn't work.

BOOL COleControl::GetAmbientProperty(DISPID dispid, VARTYPE vt, void *pData)
{
   DISPPARAMS dispparams;
   VARIANT v, v2;
   HRESULT hr;

   v.vt = VT_EMPTY;
   v.lVal = 0;
   v2.vt = VT_EMPTY;
   v2.lVal = 0;

   // get a pointer to the source of ambient properties.
   //
   if (!m_pDispAmbient) {
      if (m_pClientSite)
         m_pClientSite->QueryInterface(IID_IDispatch, (void **)&m_pDispAmbient);

      if (!m_pDispAmbient)
         return FALSE;
   }

   // now go and get the property into a variant.

   memset(&dispparams, 0, sizeof(DISPPARAMS));
   hr = m_pDispAmbient->Invoke(dispid, IID_NULL, 0, DISPATCH_PROPERTYGET, &dispparams,
                        &v, NULL, NULL);
   if (FAILED(hr))
      return FALSE;

   // we've got the variant, so now go an coerce it to the type that the user
   // wants.  if the types are the same, then this will copy the stuff to
   // do appropriate ref counting ...
   //
   hr = VariantChangeType(&v2, &v, 0, vt);
   if (FAILED(hr)) {
      VariantClear(&v);
      return FALSE;
   }

   // copy the data to where the user wants it

   CopyMemory(pData, &(v2.lVal), g_rgcbDataTypeSize[vt]);
   VariantClear(&v);
   return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientFont     [callable]
//=--------------------------------------------------------------------------=
// gets the current font for the user.
//
// Parameters:
//   IFont **        - [out] where to put the font.
//
// Output:
//   BOOL            - FALSE means couldn't get it.

BOOL COleControl::GetAmbientFont(IFont **ppFont)
{
   IDispatch *pFontDisp;

   // we don't have to do much here except get the ambient property and QI
   // it for the user.

   *ppFont = NULL;
   if (!GetAmbientProperty(DISPID_AMBIENT_FONT, VT_DISPATCH, &pFontDisp))
      return FALSE;

   pFontDisp->QueryInterface(IID_IFont, (void **)ppFont);
   pFontDisp->Release();
   return (*ppFont) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::DesignMode
//=--------------------------------------------------------------------------=
// returns TRUE if we're in Design mode.
//
// Output:
//   BOOL           - true is design mode, false is run mode
//
// Notes:
//

BOOL COleControl::DesignMode(void)
{
   // BUGBUG: if we never call this, then remove it

   VARIANT_BOOL f;

   // if we don't already know our run mode, go and get it.  we'll assume
   // it's true unless told otherwise [or if the operation fails ...]

   if (!m_fModeFlagValid) {
      f = TRUE;
      m_fModeFlagValid = TRUE;
      GetAmbientProperty(DISPID_AMBIENT_USERMODE, VT_BOOL, &f);
      m_fRunMode = f;
   }

   return !m_fRunMode;
}

//=--------------------------------------------------------------------------=
// COleControl::FireEvent
//=--------------------------------------------------------------------------=
// fires an event.   handles arbitrary number of arguments.
//
// Parameters:
//   EVENTINFO *      - [in] struct that describes the event.
//   ...           - arguments to the event
//
// Output:
//   none
//
// Notes:
//   - use stdarg's va_* macros.

void __cdecl COleControl::FireEvent(EVENTINFO *pEventInfo, ...)
{
   va_list    valist;
   DISPPARAMS dispparams;
   VARIANT    rgvParameters[MAX_ARGS];
   VARIANT   *pv;
   VARTYPE    vt;
   int      iParameter;
   int      cbSize;

   ASSERT_COMMENT(pEventInfo->cParameters <= MAX_ARGS, "Doesn't support more than MAX_ARGS params.");

   va_start(valist, pEventInfo);

   // copy the Parameters into the rgvParameters array.  make sure we reverse
   // them for automation
   //
   pv = &(rgvParameters[pEventInfo->cParameters - 1]);
   for (iParameter = 0; iParameter < pEventInfo->cParameters; iParameter++) {

      vt = pEventInfo->rgTypes[iParameter];

      // if it's a by value variant, then just copy the whole thing

      if (vt == VT_VARIANT)
         *pv = va_arg(valist, VARIANT);
      else {
         // copy the vt and the data value.

         pv->vt = vt;
         if (vt & VT_BYREF)
            cbSize = sizeof(void *);
         else
            cbSize = g_rgcbDataTypeSize[vt];

         // small optimization -- we can copy 2/4 bytes over quite
         // quickly.

         if (cbSize == sizeof(short))
            V_I2(pv) = va_arg(valist, short);
         else if (cbSize == 4)
            V_I4(pv) = va_arg(valist, long);
         else {
            // copy over 8 bytes

            ASSERT_COMMENT(cbSize == 8, "don't recognize the type!!");
            V_CY(pv) = va_arg(valist, CURRENCY);
         }
      }

      pv--;
   }

   // fire the event

   dispparams.rgvarg = rgvParameters;
   dispparams.cArgs = pEventInfo->cParameters;
   dispparams.rgdispidNamedArgs = NULL;
   dispparams.cNamedArgs = 0;

   m_cpEvents.DoInvoke(pEventInfo->dispid, &dispparams);

   va_end(valist);
}

#if 0
//=--------------------------------------------------------------------------=
// COleControl::AfterCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
//
// Output:
//   BOOL            - false means fatal error, can't continue

BOOL COleControl::AfterCreateWindow(void)
{
   return TRUE;
}
#endif

//=--------------------------------------------------------------------------=
// COleControl::InvalidateControl    [callable]
//=--------------------------------------------------------------------------=

void COleControl::InvalidateControl(LPCRECT lpRect)
{
   if (m_fInPlaceActive)
      InvalidateRect(m_hwnd, lpRect, TRUE);
   else
      ViewChanged();
}

//=--------------------------------------------------------------------------=
// COleControl::SetControlSize     [callable]
//=--------------------------------------------------------------------------=
// sets the control size. they'll give us the size in pixels.  we've got to
// convert them back to HIMETRIC before passing them on!
//
// Parameters:
//   SIZEL *       - [in] new size
//
// Output:
//   BOOL
//
// Notes:
//

BOOL COleControl::SetControlSize(SIZEL *pSize)
{
   HRESULT hr;
   SIZEL slHiMetric;

   PixelToHiMetric(pSize, &slHiMetric);
   hr = SetExtent(DVASPECT_CONTENT, &slHiMetric);
   return (FAILED(hr)) ? FALSE : TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::RecreateControlWindow   [callable]
//=--------------------------------------------------------------------------=
// called by a [subclassed, typically] control to recreate it's control
// window.
//
// Parameters:
//   none
//
// Output:
//   HRESULT
//
// Notes:
//   - NOTE: USE ME EXTREMELY SPARINGLY! THIS IS AN EXTREMELY EXPENSIVE
//    OPERATION!
//

#if 0

HRESULT COleControl::RecreateControlWindow(void)
{
   HRESULT hr;
   HWND  hwndPrev;

   DBWIN("RecreateControlWindow called -- it probably shouldn't be.");

   // we need to correctly preserve the control's position within the
   // z-order here.

   if (m_hwnd)
      hwndPrev = ::GetWindow(m_hwnd, GW_HWNDPREV);

   // if we're in place active, then we have to deactivate, and reactivate
   // ourselves with the new window ...

   if (m_fInPlaceActive) {

      hr = InPlaceDeactivate();
      RETURN_ON_FAILURE(hr);
      hr = InPlaceActivate((m_fUIActive) ? OLEIVERB_UIACTIVATE : OLEIVERB_INPLACEACTIVATE);
      RETURN_ON_FAILURE(hr);

   } else if (m_hwnd) {
      DestroyWindow(m_hwnd);
      m_hwnd = NULL;

      CreateInPlaceWindow(0, 0, FALSE);
   }

   // restore z-order position

   if (m_hwnd)
      SetWindowPos(m_hwnd, hwndPrev, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

   return m_hwnd ? S_OK : E_FAIL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ctlembed.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

//=--------------------------------------------------------------------------=
//
// implementation of the interfaces required for inplace activation for
// COleControl

#include "header.h"

#include "CtlHelp.H"
#include "StdEnum.H"
#include "ctrlobj.h"

#ifndef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

// External Functions
BOOL IsBusy() ; // See wwheel.cpp - TRUE if we are merging.

// all controls support the following in-place verbs at an absolute minimum.

#define CINPLACEVERBS 4

const VERBINFO rgInPlaceVerbs [] = {
   { OLEIVERB_SHOW,        0, 0, 0},
   { OLEIVERB_HIDE,        0, 0, 0},
   { OLEIVERB_INPLACEACTIVATE, 0, 0, 0},
   { OLEIVERB_PRIMARY,     0, 0, 0}
};

// NOTE: Resource ID for Properties string must be 1000

const VERBINFO ovProperties =
   { CTLIVERB_PROPERTIES, 1000, 0, OLEVERBATTRIB_ONCONTAINERMENU };

const VERBINFO ovUIActivate =
   { OLEIVERB_UIACTIVATE, 0, 0, 0};

//=--------------------------------------------------------------------------=
// COleControl::GetControlInfo     (IOleControl)
//=--------------------------------------------------------------------------=
// returns some information on a control, such as an accelerator table, and
// flags.  really used for keyboard handling and mnemonics
//
// Parameters:
//   CONTROLINFO *      - [in]  where to put said information

STDMETHODIMP COleControl::GetControlInfo(CONTROLINFO *pControlInfo)
{
   DBWIN("COleControl::GetControlInfo()\n");

   CHECK_POINTER(pControlInfo);

   // certain hosts have a bug in which it doesn't initialize the cb in the
   // CONTROLINFO structure, so we can only assert on that here.

   ASSERT_COMMENT(pControlInfo->cb == sizeof(CONTROLINFO), "Host doesn't initialize CONTROLINFO structure");

   // NOTE: control writers should override this routine if they want to
   // return accelerator information in their control.

   pControlInfo->hAccel = NULL;
   pControlInfo->cAccel = NULL;

   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnMnemonic   [IOleControl]
//=--------------------------------------------------------------------------=
// the container has decided to pass on a key that the end-user has pressed to
// us.   default implementation will be to just activate the control.  people
// looking for more functionality should override this method.
//
// Parameters:
//   LPMSG           - [in] message for this mnemonic

STDMETHODIMP COleControl::OnMnemonic(LPMSG pMsg)
{
   // OVERRIDE: default implementation is to just activate our control.
   // user can override if they want more interesting behaviour.
   DBWIN("COleControl::OnMnemonic()\n");
   return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl:OnAmbientPropertyChange   [IOleControl]
//=--------------------------------------------------------------------------=
// a container calls this whenever it changes an ambient property.
//
// Parameters:
//   DISPID       - [in] dispid of the property that changed.
//
// Output:
//   HRESULT         - S_OK

STDMETHODIMP COleControl::OnAmbientPropertyChange(DISPID dispid)
{
   // if we're being told about a change in mode [design/run] then
   // remember that so our stashing of mode will update itself
   // correctly
   DBWIN("COleControl::OnAmbientPropertyChange()\n");

   if (dispid == DISPID_AMBIENT_USERMODE || dispid == DISPID_UNKNOWN)
      m_fModeFlagValid = FALSE;

   // just pass this on to the derived control and see if they want
   // to do anything with it.
   //
   AmbientPropertyChanged(dispid);
   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControL::FreezeEvents  [IOleControl]
//=--------------------------------------------------------------------------=
// allows a container to freeze all of a controls events.  when events are
// frozen, a control will not fire any of them.
//
// Parameters:
//   BOOL           - [in] TRUE means FREEZE, FALSE means THAW
//
// Output:
//   HRESULT        - S_OK
//
// Notes:
//   - we maintain an internal count of freezes versus thaws.

STDMETHODIMP COleControl::FreezeEvents(BOOL fFreeze)
{
   // OVERRIDE: by default, we don't care.  user can override if they want to.
   DBWIN("COleControl::FreezeEvents()\n");

   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetClientSite  [IOleObject]
//=--------------------------------------------------------------------------=
// informs the embedded object [control] of it's client site [display
// location] within it's container
//
// Parameters:
//   IOleClientSite *        - [in] pointer to client site.
//
// Output:
//   HRESULT              - S_OK, E_UNEXPECTED

STDMETHODIMP COleControl::SetClientSite(IOleClientSite *pClientSite)
{
   RELEASE_OBJECT(m_pClientSite);
   RELEASE_OBJECT(m_pControlSite);
//   RELEASE_OBJECT(m_pSimpleFrameSite);

   // store away the new client site

   m_pClientSite = pClientSite;

   // if we've actually got one, then get some other interfaces we want to keep
   // around, and keep a handle on it

   if (m_pClientSite) {
      m_pClientSite->AddRef();
      m_pClientSite->QueryInterface(IID_IOleControlSite, (void **)&m_pControlSite);

#ifdef _DEBUG
      if (OLEMISCFLAGSOFCONTROL(m_ObjectType) & OLEMISC_SIMPLEFRAME)
         ASSERT_COMMENT(FALSE, "We took out simple frame support...");
         // m_pClientSite->QueryInterface(IID_ISimpleFrameSite, (void **)&m_pSimpleFrameSite);
#endif
   }

   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClientSite  [IOleObject]
//=--------------------------------------------------------------------------=
// obtains a pointer to the controls client site.
//
// Parameters:
//   IOleClientSite **     - [out]

STDMETHODIMP COleControl::GetClientSite(IOleClientSite **ppClientSite)
{
   CHECK_POINTER(ppClientSite);

   *ppClientSite = m_pClientSite;
   ADDREF_OBJECT(*ppClientSite);
   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetHostNames  [IOleObject]
//=--------------------------------------------------------------------------=
// Provides the control with the name of its container application and the
// compound document in which it is embedded
//
// Parameters:
//   LPCOLESTR       - [in] name of container application
//   LPCOLESTR       - [in] name of container document

STDMETHODIMP COleControl::SetHostNames(LPCOLESTR szContainerApp,
   LPCOLESTR szContainerObject)
{
   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Close    [IOleObject]
//=--------------------------------------------------------------------------=
// Changes the control from the running to the loaded state
//
// Parameters:
//   DWORD        - [in] indicates whether to save the object before closing
//
// Output:
//   HRESULT         - S_OK, OLE_E_PROMPTSAVECANCELLED

STDMETHODIMP COleControl::Close(DWORD dwSaveOption)
{
   HRESULT hr;

   if (m_fInPlaceActive) {
      hr = InPlaceDeactivate();
      RETURN_ON_FAILURE(hr);
   }

#if 0
   // handle the save flag.

   14-Aug-1997 [ralphw] We don't support any form of saving

   if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY || dwSaveOption == OLECLOSE_PROMPTSAVE) && m_fDirty) {
      if (m_pClientSite) m_pClientSite->SaveObject();
      if (m_pOleAdviseHolder) m_pOleAdviseHolder->SendOnSave();
   }
#endif
   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetMoniker   [IOleObject]
//=--------------------------------------------------------------------------=
// Notifies an object of its container's moniker, the object's own moniker
// relative to the container, or the object's full moniker
//
// Parameters:
//   DWORD           - [in] which moniker is being set
//   IMoniker *         - [in] the moniker
//
// Output:
//   HRESULT            - S_OK, E_FAIL
//
// Notes:
//   - we don't support monikers.

STDMETHODIMP COleControl::SetMoniker(DWORD dwWhichMoniker, IMoniker *pMoniker)
{
   return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetMoniker   [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a embedded object's moniker, which the caller can use to link to
// the object
//
// Parameters:
//   DWORD        - [in]  how it's assigned
//   DWORD        - [in]  which moniker
//   IMoniker **     - [out] duh.
//
// Output:
//   HRESULT         - E_NOTIMPL
//
// Notes:
//   - we don't support monikers

STDMETHODIMP COleControl::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
   IMoniker **ppMonikerOut)
{
   return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InitFromData  [IOleObject]
//=--------------------------------------------------------------------------=
// Initializes a newly created object with data from a specified data object,
// which can reside either in the same container or on the Clipboard
//
// Parameters:
//   IDataObject*   - [in] data object with the data
//   BOOL           - [in] how object is created
//   DWORD       - reserved
//
// Output:
//   HRESULT        - S_OK, S_FALSE, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//   - we don't have data object support

STDMETHODIMP COleControl::InitFromData(IDataObject *pDataObject,
   BOOL fCreation, DWORD dwReserved)
{
   return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClipboardData [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves a data object containing the current contents of the control.
// Using the pointer to this data object, it is possible to create a new control
// with the same data as the original
//
// Parameters:
//   DWORD      - reserved
//   IDataObject ** - [out] data object for this control
//
// Output:
//   HREUSLT       - S_OK, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//

STDMETHODIMP COleControl::GetClipboardData(DWORD dwReserved,
   IDataObject **ppDataObject)
{
   *ppDataObject = NULL;       // be a good neighbour
   return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::DoVerb    [IOleObject]
//=--------------------------------------------------------------------------=
// Requests an object to perform an action in response to an end-user's
// action.
//
// Parameters:
//   LONG            - [in]  verb to be performed
//   LPMSG        - [in]  event that invoked the verb
//   IOleClientSite * - [in]  the controls active client site
//   LONG            - [in]  reserved
//   HWND            - [in]  handle of window containing the object.
//   LPCRECT         - [in]  pointer to objects's display rectangle
//
// Output:
//   HRESULT         - S_OK, OLE_E_NOTINPLACEACTIVE, OLE_E_CANT_BINDTOSOURCE,
//                 DV_E_LINK, OLEOBJ_S_CANNOT_DOVERB_NOW, OLEOBJ_S_INVALIDHWND,
//                 OLEOBJ_E_NOVERBS, OLEOBJ_S_INVALIDVERB, MK_E_CONNECT,
//                 OLE_CLASSDIFF, E_NOTIMPL

STDMETHODIMP COleControl::DoVerb(LONG lVerb, LPMSG pMsg,
   IOleClientSite *pActiveSite, LONG lIndex, HWND hwndParent,
   LPCRECT prcPosRect)
{
   HRESULT hr;

   switch (lVerb) {
     case OLEIVERB_SHOW:
     case OLEIVERB_INPLACEACTIVATE:
     case OLEIVERB_UIACTIVATE:
         // Check to see if we are merging?
         if (IsBusy()) 
         {
             // We cannot precess these if we are merging. 
             return OLEOBJ_S_CANNOT_DOVERB_NOW ;
         }
         else
         {
            return InPlaceActivate(lVerb);
         }

     case OLEIVERB_HIDE:
      UIDeactivate();
      if (m_fInPlaceVisible)
         SetInPlaceVisible(FALSE);
      return S_OK;

     // we used to have OLEIVERB_PRIMARY InPlaceActivate Ourselves, but it
     // turns out that the CDK and certain hosts expect this to show the
     // properties instead.  Users can change what this verb does at will.

     case OLEIVERB_PRIMARY:
     case CTLIVERB_PROPERTIES:
     case OLEIVERB_PROPERTIES:
      {
      // show the frame ourselves if the hose can't.

      if (m_pControlSite) {
         hr = m_pControlSite->ShowPropertyFrame();
         if (hr != E_NOTIMPL)
            return hr;
      }
      IUnknown *pUnk = (IUnknown *)(IOleObject *)this;
      MAKE_WIDEPTR_FROMANSI(pwsz, NAMEOFOBJECT(m_ObjectType));

#if 0
      ModalDialog(TRUE);
      hr = OleCreatePropertyFrame(GetActiveWindow(),
                     GetSystemMetrics(SM_CXSCREEN) / 2,
                     GetSystemMetrics(SM_CYSCREEN) / 2,
                     pwsz,
                     1,
                     &pUnk,
                     CPROPPAGESOFCONTROL(m_ObjectType),
                     (LPCLSID)*(PPROPPAGESOFCONTROL(m_ObjectType)),
                     g_lcidLocale,
                     NULL, NULL);
      ModalDialog(FALSE);
#endif
      return hr;
      }

     default:
      // if it's a derived-control defined verb, pass it on to them
      //
      if (lVerb > 0) {
         hr = DoCustomVerb(lVerb);

         if (hr == OLEOBJ_S_INVALIDVERB) {
            // unrecognised verb -- just do the primary verb and
            // activate the sucker.
            //
            hr = InPlaceActivate(OLEIVERB_PRIMARY);
            return (FAILED(hr)) ? hr : OLEOBJ_S_INVALIDVERB;
         } else
            return hr;
      }
      else {
         FAIL("Unrecognized Negative verb in DoVerb().");
         return E_NOTIMPL;
      }
      break;
   }

   // dead code
   FAIL("this should be dead code!");
}

//=--------------------------------------------------------------------------=
// COleControl::EnumVerbs   [IOleObject]
//=--------------------------------------------------------------------------=
// create an enumerator object for the verbs this object supports.
//
// Parameters:
//   IEnumOleVERB **  - [out] new enumerator.
//
// Output:
//   HRESULT          - S_OK, E_OUTOFMEMORY

STDMETHODIMP COleControl::EnumVerbs(IEnumOLEVERB **ppEnumVerbs)
{
   int cVerbs;
   OLEVERB *rgVerbs, *pVerb;

   DWORD dw = OLEMISCFLAGSOFCONTROL(m_ObjectType);
   BOOL fCanInPlace = !(dw & OLEMISC_INVISIBLEATRUNTIME) || (dw & OLEMISC_ACTIVATEWHENVISIBLE);
   BOOL fCanUIActivate = !(dw & OLEMISC_NOUIACTIVATE);
   BOOL fHasProperties = (CPROPPAGESOFCONTROL(m_ObjectType) != 0);

   int cVerbExtra = CCUSTOMVERBSOFCONTROL(m_ObjectType);

   // count up all the verbs

   cVerbs = (fCanInPlace ? CINPLACEVERBS : 0) + (fCanUIActivate ? 1 : 0)
          + (fHasProperties ? 1 : 0) + cVerbExtra;

   // if there aren't any, this suddenly gets really easy !

   if (cVerbs == 0)
      return OLEOBJ_E_NOVERBS;

   if (! (rgVerbs = (OLEVERB *) lcCalloc(cVerbs * sizeof(OLEVERB))))
      return E_OUTOFMEMORY;

   // start copying over verbs.  first, the in-place guys

   pVerb = rgVerbs;
   if (fCanInPlace) {
      memcpy(pVerb, rgInPlaceVerbs, CINPLACEVERBS * sizeof(OLEVERB));
      pVerb += CINPLACEVERBS;
     }

   if (fCanUIActivate)
      memcpy(pVerb++, &ovUIActivate, sizeof(OLEVERB));

   // if their control has properties, copy that over now.
   //
   if (fHasProperties) {
      memcpy(pVerb, &ovProperties, sizeof(OLEVERB));
      pVerb++;
   }

   // finally, any custom verbs!
   //
   if (cVerbExtra) {
      memcpy(pVerb, CUSTOMVERBSOFCONTROL(m_ObjectType), sizeof(OLEVERB) * cVerbExtra);
   }

   *ppEnumVerbs = (IEnumOLEVERB *) (IEnumGeneric *) new CStandardEnum(IID_IEnumOLEVERB,
                            cVerbs, sizeof(OLEVERB), rgVerbs, CopyOleVerb);
   if (!*ppEnumVerbs)
      return E_OUTOFMEMORY;

   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Update    [IOleObject]
//=--------------------------------------------------------------------------=
// Updates an object handler's or link object's data or view caches.

STDMETHODIMP COleControl::Update(void)
{
   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::IsUpToDate   [IOleObject]
//=--------------------------------------------------------------------------=
// Checks recursively whether or not an object is up to date.

STDMETHODIMP COleControl::IsUpToDate(void)
{
   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserClassID     [IOleObject]
//=--------------------------------------------------------------------------=
// Returns the controls class identifier, the CLSID corresponding to the
// string identifying the object to an end user.
//
// Parameters:
//   CLSID *      - [in] where to put the CLSID

STDMETHODIMP COleControl::GetUserClassID(CLSID *pclsid)
{
   // this is the same as IPersist::GetClassID

   return GetClassID(pclsid);
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserType    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the user-type name of the control for display in user-interface
// elements such as menus, list boxes, and dialog boxes.
//
// Parameters:
//   DWORD     - [in]  specifies the form of the type name.
//   LPOLESTR *   - [out] where to put user type
//
// Output:
//   HRESULT      - S_OK, OLE_S_USEREG, E_OUTOFMEMORY

STDMETHODIMP COleControl::GetUserType(DWORD dwFormOfType,
   LPOLESTR *ppszUserType)
{
   *ppszUserType = OLESTRFROMANSI(NAMEOFOBJECT(m_ObjectType));
   return (*ppszUserType) ? S_OK : E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// COleControl::SetExtent   [IOleObject]
//=--------------------------------------------------------------------------=
// Informs the control of how much display space its container has assigned it.
//
// Parameters:
//   DWORD        - [in] which form or 'aspect'  is to be displayed.
//   SIZEL *         - [in] size limit for the control.
//
// Output:
//   HRESULT         - S_OK, E_FAIL, OLE_E_NOTRUNNING

STDMETHODIMP COleControl::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
   SIZE  sl;
   RECT  rect;
   BOOL  f;

   if (dwDrawAspect & DVASPECT_CONTENT) {

      // change the units to pixels, and resize the control.

      HiMetricToPixel(psizel, &sl);

      // first call the user version.  if they return FALSE, they want
      // to keep their current size

      f = OnSetExtent(&sl);
      if (f)
         HiMetricToPixel(psizel, &m_Size);

      // set things up with our HWND if we've got one.

      if (!m_pInPlaceSiteWndless) {
         if (m_fInPlaceActive) {

            // theoretically, one should not need to call OnPosRectChange
            // here, but there appear to be a few host related issues that
            // will make us keep it here.  we won't, however, bother with
            // windowless ole controls, since they are all new hosts who
            // should know better

            GetWindowRect(m_hwnd, &rect);
            MapWindowPoints(NULL, m_hwndParent, (LPPOINT)&rect, 2);
            rect.right = rect.left + m_Size.cx;
            rect.bottom = rect.top + m_Size.cy;
            m_pInPlaceSite->OnPosRectChange(&rect);

            if (m_hwnd) {
               // just go and resize

               SetWindowPos(m_hwnd, 0, 0, 0, m_Size.cx, m_Size.cy,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
            }
         } else if (m_hwnd) {
            SetWindowPos(m_hwnd, NULL, 0, 0, m_Size.cx, m_Size.cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
         } else {
            ViewChanged();
         }
      } else
         if (m_pInPlaceSite) m_pInPlaceSite->OnPosRectChange(&rect);

      // return code depending on whether or not user accepted given
      // size

      return (f) ? S_OK : E_FAIL;

   } else {
      // we don't support any other aspects.

      return DV_E_DVASPECT;
   }

   // dead code
   FAIL("This should be dead code");
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent   [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the control's current display size.
//
// Parameters:
//   DWORD        - [in] aspect
//   SIZEL *         - [in] where to put results
//
// Output:
//   S_OK, E_INVALIDARG
//
// Notes:
//

STDMETHODIMP COleControl::GetExtent(DWORD dwDrawAspect, SIZEL *pSizeLOut)
{

   if (dwDrawAspect & DVASPECT_CONTENT) {
      PixelToHiMetric((const SIZEL *)&m_Size, pSizeLOut);
      return S_OK;
   } else {
      return DV_E_DVASPECT;
   }

   // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::Advise    [IOleObject]
//=--------------------------------------------------------------------------=
// establishes and advisory connection between the control and the container,
// in which the control will notify the container of certain events.
//
// Parameters:
//   IAdviseSink *   - [in]   advise sink of calling object
//   DWORD        - [out] cookie
//
// Output:
//   HRESULT         - S_OK, E_OUTOFMEMORY

STDMETHODIMP COleControl::Advise(IAdviseSink *pAdviseSink,
   DWORD *pdwConnection)
{
   HRESULT hr;

   // if we haven't yet created a standard advise holder object, do so
   // now

   if (!m_pOleAdviseHolder) {
      hr = CreateOleAdviseHolder(&m_pOleAdviseHolder);
      RETURN_ON_FAILURE(hr);
   }

   // just get it to do the work for us!

   return m_pOleAdviseHolder->Advise(pAdviseSink, pdwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::Unadvise   [IOleObject]
//=--------------------------------------------------------------------------=
// Deletes a previously established advisory connection.
//
// Parameters:
//   DWORD     - [in] connection cookie
//
// Output:
//   HRESULT      - S_OK, E_FAIL, OLE_E_NOCONNECTION

STDMETHODIMP COleControl::Unadvise(DWORD dwConnection)
{
   if (!m_pOleAdviseHolder) {
      FAIL("Somebody called Unadvise on IOleObject without calling Advise!");
      CONNECT_E_NOCONNECTION;
   }

   return m_pOleAdviseHolder->Unadvise(dwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::EnumAdvise   [IOleObject]
//=--------------------------------------------------------------------------=
// Enumerates the advisory connections registered for an object, so a container
// can know what to release prior to closing down.
//
// Parameters:
//   IEnumSTATDATA **     - [out] where to put enumerator
//
// Output:
//   HRESULT           - S_OK, E_FAIL, E_NOTIMPL

STDMETHODIMP COleControl::EnumAdvise ( IEnumSTATDATA **ppEnumOut )
{
   if (!m_pOleAdviseHolder) {
      FAIL("Somebody Called EnumAdvise without setting up any connections");
      *ppEnumOut = NULL;
      return E_FAIL;
   }

   return m_pOleAdviseHolder->EnumAdvise(ppEnumOut);
}

//=--------------------------------------------------------------------------=
// COleControl::GetMiscStatus  [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a value indicating the status of an object at creation and loading.
//
// Parameters:
//   DWORD     - [in]   aspect desired
//   DWORD *      - [out] where to put the bits.
//
// Output:
//   HRESULT      - S_OK, OLE_S_USEREG, CO_E_CLASSNOTREG, CO_E_READREGDB
//
// Notes:
//

STDMETHODIMP COleControl::GetMiscStatus(DWORD  dwAspect, DWORD *pdwStatus)
{
   CHECK_POINTER(pdwStatus);

   if (dwAspect == DVASPECT_CONTENT) {
      *pdwStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
      return S_OK;
   }
   else
      return DV_E_DVASPECT;
}

//=--------------------------------------------------------------------------=
// COleControl::SetColorScheme     [IOleObject]
//=--------------------------------------------------------------------------=
// Specifies the color palette that the object application should use when it
// edits the specified object.
//
// Parameters:
//   LOGPALETTE *    - [in] new palette
//
// Output:
//   HRESULT         - S_OK, E_NOTIMPL, OLE_E_PALETTE, OLE_E_NOTRUNNING
//
// Notes:
//   - we don't care.

STDMETHODIMP COleControl::SetColorScheme(LOGPALETTE *pLogpal)
{
   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetWindow   [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Returns the window handle to one of the windows participating in in-place
// activation (frame, document, parent, or in-place object window).
//
// Parameters:
//   HWND *    - [out] where to return window handle.
//
// Output:
//   HRESULT      - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL
//
// Notes:
//   - this routine has slightly different semantics for windowless controls

STDMETHODIMP COleControl::GetWindow(HWND *phwnd)
{
   // if we're windowles, then we want to return E_FAIL for this so hosts
   // know we're windowless

   if (m_pInPlaceSiteWndless)
      return E_FAIL;

   // otherwise, just return our outer window.
   //
   *phwnd = m_hwnd;

   return (*phwnd) ? S_OK : E_UNEXPECTED;
}

//=--------------------------------------------------------------------------=
// COleControl::ContextSensitiveHelp   [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Determines whether context-sensitive help mode should be entered during an
// in-place activation session.
//
// Parameters:
//   BOOL           - [in] whether or not to enter help mode.
//
// Output:
//   HRESULT        - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED

STDMETHODIMP COleControl::ContextSensitiveHelp(BOOL fEnterMode)
{
   return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceActivate
//=--------------------------------------------------------------------------=
// activates the control, and depending on the verb, optionally ui activates
// it as well.
//
// Parameters:
//   LONG         - [in] the verb that caused us to activate
//
// Output:
//   HRESULT
//
// Notes:
//   - this is spaghetti code at it's worst.  effectively, we have to
//    be able to handle three types of site pointers -- IOleInPlaceSIte,
//    IOleInPlaceSiteEx, and IOleInPlaceSiteWindowless.  not terribly
//    pretty.
//

HRESULT COleControl::InPlaceActivate(LONG lVerb)
{
   BOOL f;
   SIZEL sizel;
   IOleInPlaceSiteEx *pIPSEx = NULL;
   HRESULT hr;
   BOOL  fNoRedraw = FALSE;

   // if we don't have a client site, then there's not much to do.

   if (!m_pClientSite)
      return S_OK;
   //
   // <mc>
   // This code attempts to insure that we don't give UI activation to a control that is not
   // enabled.
   // </mc>
   if ( m_hwnd )
   {
      HWND hWndButton;
      if ( !(hWndButton = ::GetWindow(m_hwnd, GW_CHILD)) || !IsWindowEnabled(hWndButton) )
         return OLEOBJ_S_CANNOT_DOVERB_NOW;
   }
   //
   // <mc>
   // This code catches the control creation entry to this function and calls a new virtual to insure that we
   // do indeed need a control window. If we don't need a control window we MUST return E_NOTIMPL from the
   // doverb() call which is the caller of this function. See ShouldCreateWindow() for more details.
   // </mc>
   if ( !m_hwnd )
   {
      if (! ShouldCreateWindow() )
         return E_NOTIMPL;
   }

   // get an InPlace site pointer.

   if (!GetInPlaceSite()) {

      // if they want windowless support, then we want IOleInPlaceSiteWindowless

      if (FCONTROLISWINDOWLESS(m_ObjectType))
         m_pClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_pInPlaceSiteWndless);

      // if we're not able to do windowless siting, then we'll just get an
      // IOleInPlaceSite pointer.

      if (!m_pInPlaceSiteWndless) {
         hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
         RETURN_ON_FAILURE(hr);
      }
   }

   // now, we want an IOleInPlaceSiteEx pointer for windowless and flicker free
   // activation. if we're windowless, we've already got it, else we need to
   // try and get it

   if (m_pInPlaceSiteWndless) {
      pIPSEx = (IOleInPlaceSiteEx *)m_pInPlaceSiteWndless;
      pIPSEx->AddRef();
   } else
      m_pClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&pIPSEx);

   // if we're not already active, go and do it.
   //
   if (!m_fInPlaceActive) {
      OLEINPLACEFRAMEINFO InPlaceFrameInfo;
      RECT rcPos, rcClip;

      // if we have a windowless site, see if we can go in-place windowless
      // active
      //
      hr = S_FALSE;
      if (m_pInPlaceSiteWndless) {
         hr = m_pInPlaceSiteWndless->CanWindowlessActivate();
         CLEANUP_ON_FAILURE(hr);

         // if they refused windowless, we'll try windowed
         //
         if (S_OK != hr) {
            RELEASE_OBJECT(m_pInPlaceSiteWndless);
            hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
            CLEANUP_ON_FAILURE(hr);
         }
      }

      // just try regular windowed in-place activation
      //
      if (hr != S_OK) {
         hr = m_pInPlaceSite->CanInPlaceActivate();
         if (hr != S_OK) {
            hr = (FAILED(hr)) ? E_FAIL : hr;
            goto CleanUp;
         }
      }

      // if we are here, then we have permission to go in-place active.
      // now, announce our intentions to actually go ahead and do this.
      //
      hr = (pIPSEx) ? pIPSEx->OnInPlaceActivateEx(&fNoRedraw, (m_pInPlaceSiteWndless) ? ACTIVATE_WINDOWLESS : 0)
                  : m_pInPlaceSite->OnInPlaceActivate();
      CLEANUP_ON_FAILURE(hr);

      // if we're here, we're ready to go in-place active.  we just need
      // to set up some flags, and then create the window [if we have
      // one]
      //
      m_fInPlaceActive = TRUE;

      // we need to get some information about our location in the parent
      // window, as well as some information about the parent
      //
      InPlaceFrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
      hr = GetInPlaceSite()->GetWindow(&m_hwndParent);
      if (SUCCEEDED(hr))
         hr = GetInPlaceSite()->GetWindowContext(&m_pInPlaceFrame, &m_pInPlaceUIWindow, &rcPos, &rcClip, &InPlaceFrameInfo);
      CLEANUP_ON_FAILURE(hr);

      // make sure we'll display ourselves in the correct location with the correct size
      //
      sizel.cx = rcPos.right - rcPos.left;
      sizel.cy = rcPos.bottom - rcPos.top;
      f = OnSetExtent(&sizel);
      if (f)
         m_Size = sizel;
      SetObjectRects(&rcPos, &rcClip);

      // finally, create our window if we have to!

      if (!m_pInPlaceSiteWndless) {

         SetInPlaceParent(m_hwndParent);

         // create the window, and display it.  die horribly if we couldnt'
         //
         if (!CreateInPlaceWindow(rcPos.left, rcPos.top, fNoRedraw)) {
            hr = E_FAIL;
            goto CleanUp;
         }
      }
   }

   // don't need this any more
   //
   RELEASE_OBJECT(pIPSEx);

   // if we're not inplace visible yet, do so now.
   //
   if (!m_fInPlaceVisible)
      SetInPlaceVisible(TRUE);

   // if we weren't asked to UIActivate, then we're done.
   //
   if (lVerb != OLEIVERB_PRIMARY && lVerb != OLEIVERB_UIACTIVATE)
      return S_OK;

   // if we're not already UI active, do sow now.
   //
   if (!m_fUIActive) {
      m_fUIActive = TRUE;

      // inform the container of our intent

      GetInPlaceSite()->OnUIActivate();

      // take the focus  [which is what UI Activation is all about !]

      DBWIN("Activate focus");
      SetFocus(TRUE);

      // set ourselves up in the host.

      m_pInPlaceFrame->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);
      if (m_pInPlaceUIWindow)
         m_pInPlaceUIWindow->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);

      // we have to explicitly say we don't wany any border space.
      //
      m_pInPlaceFrame->SetBorderSpace(NULL);
      if (m_pInPlaceUIWindow)
         m_pInPlaceUIWindow->SetBorderSpace(NULL);
   }

   // be-de-be-de-be-de that's all folks!
   //
   return S_OK;

  CleanUp:
   // something catastrophic happened [or, at least something bad].
   // die a horrible fiery mangled painful death.
   //
   QUICK_RELEASE(pIPSEx);
   m_fInPlaceActive = FALSE;
   return hr;

}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Deactivates an active in-place object and discards the object's undo state.
//
// Output:
//   HRESULT       - S_OK, E_UNEXPECTED

STDMETHODIMP COleControl::InPlaceDeactivate(void)
{
   // if we're not in-place active yet, then this is easy.

   if (!m_fInPlaceActive)
      return S_OK;

   // transition from UIActive back to active
   //
   if (m_fUIActive)
      UIDeactivate();

   m_fInPlaceActive = FALSE;
   m_fInPlaceVisible = FALSE;

   // if we have a window, tell it to go away.
   //
   if (m_hwnd) {
      ASSERT_COMMENT(!m_pInPlaceSiteWndless, "internal state really messed up");

      // so our window proc doesn't crash.
      //
      BeforeDestroyWindow();
      SetWindowLong(m_hwnd, GWLP_USERDATA, 0xFFFFFFFF);
      DestroyWindow(m_hwnd);
      m_hwnd = NULL;
   }

   RELEASE_OBJECT(m_pInPlaceFrame);
   RELEASE_OBJECT(m_pInPlaceUIWindow);
   GetInPlaceSite()->OnInPlaceDeactivate();
   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::UIDeactivate  [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// transitions us from UI Active to merely being active [visible]  for
// a control, this doesn't mean all that much.
//
// Output:
//   HRESULT        - S_OK, E_UNEXPECTED

STDMETHODIMP COleControl::UIDeactivate(void)
{
   // if we're not UIActive, not much to do.
   //
   if (!m_fUIActive)
      return S_OK;

   m_fUIActive = FALSE;

   // notify frame windows, if appropriate, that we're no longer ui-active.
   //
   if (m_pInPlaceUIWindow) m_pInPlaceUIWindow->SetActiveObject(NULL, NULL);
   m_pInPlaceFrame->SetActiveObject(NULL, NULL);

   // we don't need to explicitly release the focus here since somebody
   // else grabbing the focus is what is likely to cause us to get lose it
   //
   GetInPlaceSite()->OnUIDeactivate(FALSE);

   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetObjectRects     [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Indicates how much of the control is visible.
//
// Parameters:
//   LPCRECT       - [in] position of the control.
//   LPCRECT       - [in] clipping rectangle for the control.
//
// Output:
//   HRESULT       - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//

#if 0
STDMETHODIMP COleControl::SetObjectRects(LPCRECT prcPos, LPCRECT prcClip)
{
   BOOL fRemoveWindowRgn;

   // verify our information

   // This assertion doesn't seem valid because the container (IE 3) never
   // calls SetExtent().
   // ASSERT_COMMENT(m_Size.cx == (prcPos->right - prcPos->left) && m_Size.cy == (prcPos->bottom - prcPos->top), "Somebody called SetObjectRects without first setting the extent");

   /*
    * Move our window to the new location and handle clipping. Not
    * applicable for windowless controls, since the container will be
    * responsible for all clipping.
    */

   if (m_hwnd) {
      fRemoveWindowRgn = m_fUsingWindowRgn;
      if (prcClip) {
         // the container wants us to clip, so figure out if we really
         // need to

         RECT rcIXect;
         if (IntersectRect(&rcIXect, prcPos, prcClip)) {
            if (!EqualRect(&rcIXect, prcPos)) {
               OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));
               SetWindowRgn(m_hwnd, CreateRectRgnIndirect(&rcIXect), TRUE);
               m_fUsingWindowRgn = TRUE;
               fRemoveWindowRgn  = FALSE;
            }
         }
      }

      if (fRemoveWindowRgn) {
         SetWindowRgn(m_hwnd, NULL, TRUE);
         m_fUsingWindowRgn = FALSE;
      }

      // set our control's location and size
      // [people for whom zooming is important should set that up here]

      if (!EqualRect(prcPos, &m_rcLocation)) {
         m_Size.cx = (prcPos->right - prcPos->left);
         m_Size.cy = (prcPos->bottom - prcPos->top);
         SetWindowPos(m_hwnd, NULL, prcPos->left, prcPos->top, m_Size.cx, m_Size.cy, SWP_NOZORDER | SWP_NOACTIVATE);
         CopyRect(&m_rcLocation, prcPos);
         return S_OK;
      }
   }

   // save out our current location. windowless controls want this more
   // then windowed ones do, but everybody can have it just in case

   // BUGBUG: 20-Apr-1997  [ralphw] why do we care about this for
   // windowless controls

   CopyRect(&m_rcLocation, prcPos);

   return S_OK;
}
#endif

//=--------------------------------------------------------------------------=
// COleControl::ReactivateAndUndo    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Reactivates a previously deactivated object, undoing the last state of the object.
//
// Output:
//   HRESULT       - S_OK, E_NOTUNDOABLE

STDMETHODIMP COleControl::ReactivateAndUndo(void)
{
   return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnWindowMessage    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method lets the container dispatch a message to a windowless OLE
// object.
//
// Parameters:
//   UINT              - [in]  the message
//   WPARAM         - [in]  the messages wparam
//   LPARAM         - [in]  duh.
//   LRESULT *         - [out] the output value
//
// Output:
//   HRESULT           - S_OK
//
// Notes:
//   - people should call m_pInPlaceSiteWndless->OnDefWindowMessage [control
//    writers should just call OcxDefWindowProc(msg, wparam, lparam)];
//

// REVIEW: if we don't have a windowless command, this should get nuked

STDMETHODIMP COleControl::OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
   // little bit of pre-processing -- we need to handle some cases here
   // before passing the messages on

   switch (msg) {
      // make sure our UI Activation correctly matches the focus
      //
      case WM_KILLFOCUS:
      case WM_SETFOCUS:
         // give the control site focus notification
         //
         DBWIN("windowless focus");
         if (m_fInPlaceActive && m_pControlSite)
            m_pControlSite->OnFocus(msg == WM_SETFOCUS);
         break;
   }

   // just pass it to the control's window proc.

   *plResult = WindowProc(msg, wParam, lParam);
   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetDropTarget  [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method returns a pointer to the objects IDropTarget interface.  since
// they do not have a window, windowless objects cannot register an IDropTarget
// interface.
//
// Parameters:
//   IDropTarget **     - [out]
//
// Output:
//   HRESULT            - S_OK, E_NOTIMPL

STDMETHODIMP COleControl::GetDropTarget(IDropTarget **ppDropTarget)
{
   // OVERRIDE: if you want to do drag and drop and you're windowless,
   // override me.

   return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::TranslateAccelerator   [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Processes menu accelerator-key messages from the container's message queue.
//
// Parameters:
//   LPMSG        - [in] the message that has the special key in it.
//
// Output:
//   HRESULT         - S_OK, S_FALSE, E_UNEXPECTED

STDMETHODIMP COleControl::TranslateAccelerator(LPMSG pmsg)
{
   DBWIN("TranslateAccelerator");

   // see if we want it or not.

   if (OnSpecialKey(pmsg))
      return S_OK;

// 30-Jul-1997 [ralphw] The docs don't talk about this, and I can't
// find anyone else who calls into controlsite.

   // if not, then we want to forward it back to the site for further processing

   if (m_pControlSite)
      return m_pControlSite->TranslateAccelerator(pmsg, _SpecialKeyState());

   // we didn't want it.

   return S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnFrameWindowActivate   [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the control when the container's top-level frame window is
// activated or deactivated.
//
// Parameters:
//   BOOL        - [in] state of containers top level window.
//
// Output:
//   HRESULT     - S_OK

STDMETHODIMP COleControl::OnFrameWindowActivate(BOOL fActivate)
{
   // we're supposed to go UI active in this case

   return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl::OnDocWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the active control when the container's document window is
// activated or deactivated.
//
// Parameters:
//   BOOL           - state of mdi child window.

STDMETHODIMP COleControl::OnDocWindowActivate(BOOL fActivate)
{
   // we're supposed to go UI active in this case

   return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl::ResizeBorder  [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Alerts the control that it needs to resize its border space.
//
// Parameters:
//   LPCRECT            - [in] new outer rectangle for border space
//   IOleInPlaceUIWindow * - [in] the document or frame who's border has changed
//   BOOL               - [in] true if it was the fram window taht called.

STDMETHODIMP COleControl::ResizeBorder(LPCRECT prcBorder,
   IOleInPlaceUIWindow *pInPlaceUIWindow, BOOL fFrame)
{
   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::EnableModeless     [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Enables or disables modeless dialog boxes when the container creates or
// destroys a modal dialog box.
//
// Parameters:
//   BOOL           - [in] enable or disable modeless dialogs.

STDMETHODIMP COleControl::EnableModeless(BOOL fEnable)
{
   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassInfo  [IProvideClassInfo]
//=--------------------------------------------------------------------------=
// returns the TypeInfo for the control's coclass.
//
// Parameters:
//   ITypeInfo **      - [out]
//

STDMETHODIMP COleControl::GetClassInfo(ITypeInfo **ppTypeInfo)
{
   ITypeLib *pTypeLib;
   HRESULT hr;

   CHECK_POINTER(ppTypeInfo);
   *ppTypeInfo = NULL;

   // go and get our type library.
   // CONSIDER: - go to the same sorta scheme that we use for TypeInfo caching.

   hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 0,
                  LANGIDFROMLCID(g_lcidLocale), &pTypeLib);
   if (FAILED(hr))
   {
      // Load and register our type library.

      if (g_fServerHasTypeLibrary) {
         char szTmp[MAX_PATH];
         DWORD dwPathLen = GetModuleFileName(_Module.GetModuleInstance(), szTmp, MAX_PATH);
         MAKE_WIDEPTR_FROMANSI(pwsz, szTmp);

         hr = LoadTypeLib(pwsz, &pTypeLib);
         RETURN_ON_FAILURE(hr);
         hr = RegisterTypeLib(pTypeLib, pwsz, NULL);
         if (FAILED(hr))
         {
            pTypeLib->Release();
            return hr;
         }
      }
   }

   // got the typelib. get typeinfo for our coclass.

   hr = pTypeLib->GetTypeInfoOfGuid((REFIID)CLSIDOFOBJECT(m_ObjectType), ppTypeInfo);
   pTypeLib->Release();
   RETURN_ON_FAILURE(hr);

   return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ViewChange   [callable]
//=--------------------------------------------------------------------------=
// called whenever the view of the object has changed.

void COleControl::ViewChanged(void)
{
   // send the view change notification to anybody listening.

   if (m_pViewAdviseSink) {
      m_pViewAdviseSink->OnViewChange(DVASPECT_CONTENT, -1);

      // if they only asked to be advised once, kill the connection

      if (m_fViewAdviseOnlyOnce)
         SetAdvise(DVASPECT_CONTENT, 0, NULL);
   }
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceVisible    [helper]
//=--------------------------------------------------------------------------=
// controls the visibility of the control window.
//
// Parameters:
//   BOOL        - TRUE shows FALSE hides.

void COleControl::SetInPlaceVisible(BOOL fShow)
{
   BOOL fVisible;

   m_fInPlaceVisible = fShow;

   // don't do anything if we don't have a window.  otherwise, set it

   if (m_hwnd) {
      fVisible = ((GetWindowLong(m_hwnd, GWL_STYLE) & WS_VISIBLE) != 0);

      if (fVisible && !fShow)
         ShowWindow(m_hwnd, SW_HIDE);
      else if (!fVisible && fShow)
         ShowWindow(m_hwnd, SW_SHOWNA);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ctlhelp.h ===
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.

#ifndef _CTLHELP_H_

//=--------------------------------------------------------------------------=
// these two tables are used to get information on sizes about data types
// the first is used mostly in persistence, while the second is used for
// events

extern const BYTE g_rgcbDataTypeSize [];
extern const BYTE g_rgcbPromotedDataTypeSize [];

//=--------------------------------------------------------------------------=
// misc functions

short		_SpecialKeyState(void);
void WINAPI CopyAndAddRefObject(void *, const void *, DWORD);
void WINAPI CopyOleVerb(void *, const void *, DWORD);

void		CleanupReflection();

//=--------------------------------------------------------------------------=
// little private guid we'll use to help identify our objects
// {00D97180-FCF7-11ce-A09E-00AA0062BE57}
//
#define Data1_IControlPrv	0xd97180

DEFINE_GUID(IID_IControlPrv, 0xd97180, 0xfcf7, 0x11ce, 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

#define _CTLHELP_H_
#endif // _CTLHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ctlhelp.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

// helper routines for our COleControl implementation

#include "header.h"
#include "internet.h"

#include "CtlHelp.H"
#include <windowsx.h>

#ifndef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

// define this here, since it's the only guid we really need to define in the
// framework -- the user control defines all other interesting guids.

static const GUID IID_IControlPrv =
{ 0xd97180, 0xfcf7, 0x11ce, { 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57 } };

// this table is used for copying data around, and persisting properties.
// basically, it contains the size of a given data type

const BYTE g_rgcbDataTypeSize[] = {
	0,						// VT_EMPTY= 0,
	0,						// VT_NULL= 1,
	sizeof(short),			// VT_I2= 2,
	sizeof(long),			// VT_I4 = 3,
	sizeof(float),			// VT_R4  = 4,
	sizeof(double), 		// VT_R8= 5,
	sizeof(CURRENCY),		// VT_CY= 6,
	sizeof(DATE),			// VT_DATE = 7,
	sizeof(BSTR),			// VT_BSTR = 8,
	sizeof(IDispatch *),	// VT_DISPATCH	  = 9,
	sizeof(SCODE),			// VT_ERROR    = 10,
	sizeof(VARIANT_BOOL),	// VT_BOOL	  = 11,
	sizeof(VARIANT),		// VT_VARIANT= 12,
	sizeof(IUnknown *), 	// VT_UNKNOWN= 13,
};

const BYTE g_rgcbPromotedDataTypeSize[] = {
	0,						// VT_EMPTY= 0,
	0,						// VT_NULL= 1,
	sizeof(int ),			// VT_I2= 2,
	sizeof(long),			// VT_I4 = 3,
	sizeof(double), 		// VT_R4  = 4,
	sizeof(double), 		// VT_R8= 5,
	sizeof(CURRENCY),		// VT_CY= 6,
	sizeof(DATE),			// VT_DATE = 7,
	sizeof(BSTR),			// VT_BSTR = 8,
	sizeof(IDispatch *),	// VT_DISPATCH	  = 9,
	sizeof(SCODE),			// VT_ERROR    = 10,
	sizeof(int),			// VT_BOOL	  = 11,
	sizeof(VARIANT),		// VT_VARIANT= 12,
	sizeof(IUnknown *), 	// VT_UNKNOWN= 13,
};

//=--------------------------------------------------------------------------=
// _SpecialKeyState
//=--------------------------------------------------------------------------=
// returns a short with some information on which of the SHIFT, ALT, and CTRL
// keys are set.
//
// Output:
//	  short 	   - bit 0 is shift, bit 1 is ctrl, bit 2 is ALT.

short _SpecialKeyState()
{
	// don't appear to be able to reduce number of calls to GetKeyState
	//
	BOOL bShift = (GetKeyState(VK_SHIFT) < 0);
	BOOL bCtrl	= (GetKeyState(VK_CONTROL) < 0);
	BOOL bAlt	= (GetKeyState(VK_MENU) < 0);

	return (short)(bShift + (bCtrl << 1) + (bAlt << 2));
}

//=--------------------------------------------------------------------------=
// CopyAndAddRefObject
//=--------------------------------------------------------------------------=
// copies an object pointer, and then addref's the object.
//
// Parameters:
//	  void *		- [in] dest.
//	  const void *	- [in] src
//	  DWORD 		- [in] size, ignored, since it's always 4

void WINAPI CopyAndAddRefObject(void *pDest, const void *pSource, DWORD dwSize)
{
	ASSERT_COMMENT(pDest && pSource, "Bogus Pointer(s) passed into CopyAndAddRefObject!!!!");

	*((IUnknown **)pDest) = *((IUnknown **)pSource);
	ADDREF_OBJECT(*((IUnknown **)pDest));

	return;
}

//=--------------------------------------------------------------------------=
// CopyOleVerb	  [helper]
//=--------------------------------------------------------------------------=
// copies an OLEVERB structure.  used in CStandardEnum
//
// Parameters:
//	  void *		- [out] where to copy to
//	  const void *	- [in]	where to copy from
//	  DWORD 		- [in]	bytes to copy

void WINAPI CopyOleVerb(void *pvDest, const void *pvSrc, DWORD cbCopy)
{
	VERBINFO * pVerbDest = (VERBINFO *) pvDest;
	const VERBINFO * pVerbSrc = (const VERBINFO *) pvSrc;

	*pVerbDest = *pVerbSrc;
	((OLEVERB *)pVerbDest)->lpszVerbName = OLESTRFROMRESID((WORD)((VERBINFO *)pvSrc)->idVerbName);
}

//=--------------------------------------------------------------------------=
// ControlFromUnknown	 [helper, callable]
//=--------------------------------------------------------------------------=
// given an unknown, get the COleControl pointer for it.
//
// Parameters:
//	  IUnknown *		- [in]

COleControl *ControlFromUnknown(IUnknown *pUnk)
{
	COleControl *pCtl = NULL;

	if (!pUnk) return NULL;
	pUnk->QueryInterface(IID_IControlPrv, (void **)&pCtl);

	return pCtl;
}

// in case the user doesn't want our default window proc, we support
// letting them specify one themselves. this is defined in their main ipserver
// file.

extern WNDPROC g_ParkingWindowProc;

//=--------------------------------------------------------------------------=
// GetParkingWindow
//=--------------------------------------------------------------------------=
// creates the global parking window that we'll use to parent things, or
// returns the already existing one
//
// Output:
//	  HWND				  - our parking window

HWND GetParkingWindow(void)
{
	WNDCLASS wndclass;

	// crit sect this creation for apartment threading support.

	// EnterCriticalSection(&g_CriticalSection);
	if (g_hwndParking)
		goto CleanUp;

	ZeroMemory(&wndclass, sizeof(wndclass));
	wndclass.lpfnWndProc = (g_ParkingWindowProc) ? g_ParkingWindowProc : DefWindowProc;
	wndclass.hInstance	 = _Module.GetModuleInstance();
	wndclass.lpszClassName = "CtlFrameWork_Parking";

	if (!RegisterClass(&wndclass)) {
		FAIL("Couldn't Register Parking Window Class!");
		goto CleanUp;
	}

	g_hwndParking = CreateWindow("CtlFrameWork_Parking", NULL, WS_POPUP, 0, 0, 0, 0, NULL, NULL, _Module.GetModuleInstance(), NULL);
	if (g_hwndParking != NULL)
		++g_cLocks;

	ASSERT_COMMENT(g_hwndParking, "Couldn't Create Global parking window!!");

CleanUp:
	// LeaveCriticalSection(&g_CriticalSection);
	return g_hwndParking;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ctable.cpp ===
//  Copyright (C) Microsoft Corporation 1993-1997

#include "header.H"

#ifndef _CTABLE_INCLUDED
#include "ctable.h"
#endif

const int TABLE_ALLOC_SIZE = 4096;     // allocate in page increments
const int MAX_POINTERS = (1024 * 1024); // 1 meg, 260,000+ strings
const int MAX_STRINGS  = (10 * 1024 * 1024) - 4096L; // 10 megs

// Align on 32 bits for Intel, 64 bits for MIPS

#ifdef _X86_
const int ALIGNMENT = 4;
#else
const int ALIGNMENT = 8;
#endif

#ifdef _DEBUG
int g_cbTableAllocated;
int g_cbTableReserved;
int g_cTables;
#endif

CTable::CTable()
{
    cbMaxBase = MAX_STRINGS;
    cbMaxTable = MAX_POINTERS;
    InitializeTable();
#ifdef _DEBUG
    g_cTables++;
#endif
}

// Use this constructor to reduce reserved memory

CTable::CTable(int cbStrings)
{
    cbMaxBase = cbStrings;
    cbMaxTable = cbStrings / 4;
    InitializeTable();
#ifdef _DEBUG
    g_cTables++;
#endif
}

/***************************************************************************

    FUNCTION:   =

    PURPOSE:    Copies a table -- only works with tables containing ONLY
                strings. Won't work with tables that combined data with
                the strings.

    PARAMETERS:
        tblSrc

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        26-Mar-1994 [ralphw]

***************************************************************************/

#pragma warning(disable:4172) // returning address of local variable or temporary

const CTable& CTable::operator =(const CTable& tblSrc)
{
    Empty();

    int srcpos = 1;
    while (srcpos < tblSrc.endpos) {
        if (endpos >= maxpos)
            IncreaseTableBuffer();

        if (endpos >= maxpos)
        {
            return NULL;
	}	    

        if ((ppszTable[endpos] =
                TableMalloc((int)strlen(tblSrc.ppszTable[srcpos]) + 1)) == NULL) {
            OOM();
            return *this;
        }
        strcpy(ppszTable[endpos++], tblSrc.ppszTable[srcpos++]);
    }
    return *this;
}

/***************************************************************************

    FUNCTION:   ~CTable

    PURPOSE:    Close the table and free all memory associated with it

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        26-Feb-1990 [ralphw]
        27-Mar-1990 [ralphw]
            Pass the address of the handle, so that we can set it to NULL.
            This eliminates the chance of using a handle after it's memory
            has been freed.

***************************************************************************/

CTable::~CTable()
{
    Cleanup();
#ifdef _DEBUG
    g_cTables--;
#endif
}

void CTable::Cleanup(void)
{
    if (pszBase) {
        VirtualFree(pszBase, cbStrings, MEM_DECOMMIT);
        VirtualFree(pszBase, 0, MEM_RELEASE);
    }
    if (ppszTable) {
        VirtualFree(ppszTable, cbPointers, MEM_DECOMMIT);
        VirtualFree(ppszTable, 0, MEM_RELEASE);
    }
    if (m_pFreed)
        lcClearFree(&m_pFreed);
#ifdef _DEBUG
    g_cbTableAllocated -= (cbPointers + cbStrings);
    g_cbTableReserved -= (cbMaxBase + cbMaxTable);
#endif
}

/***************************************************************************

    FUNCTION:   CTable::Empty

    PURPOSE:    Empties the current table by freeing all memory, then
                recreating the table using the default size

    PARAMETERS:
        void

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        22-Feb-1994 [ralphw]

***************************************************************************/

void CTable::Empty(void)
{
    Cleanup();
    InitializeTable();
}

/***************************************************************************

    FUNCTION:  GetString

    PURPOSE:   get a line from the table

    RETURNS:   FALSE if there are no more lines

    COMMENTS:
        If no strings have been placed into the table, the return value
        is FALSE.

    MODIFICATION DATES:
        01-Jan-1990 [ralphw]

***************************************************************************/

BOOL CTable::GetString(PSTR pszDst)
{
    *pszDst = 0;      // clear the line no matter what happens

    if (curpos >= endpos)
        return FALSE;
    strcpy(pszDst, (PCSTR) ppszTable[curpos++]);
    return TRUE;
}

BOOL CTable::GetString(PSTR pszDst, int pos) const
{
    *pszDst = 0;      // clear the line no matter what happens

    if (pos >= endpos || pos == 0)
        return FALSE;
    strcpy(pszDst, (PCSTR) ppszTable[pos]);
    return TRUE;
}

BOOL CTable::GetIntAndString(int* plVal, PSTR pszDst)
{
    *pszDst = 0;      // clear the line no matter what happens

    if (curpos >= endpos)
        return FALSE;
    *plVal = *(int *) ppszTable[curpos];
    strcpy(pszDst, (PCSTR) ppszTable[curpos++] + sizeof(int));
    return TRUE;
}

/***************************************************************************

    FUNCTION:  AddString

    PURPOSE:   Add a string to a table

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        01-Jan-1990 [ralphw]

***************************************************************************/

int CTable::AddString(PCSTR pszString)
{
    if (!pszString)
        return 0;

    if (endpos >= maxpos)
        IncreaseTableBuffer();

    if (endpos >= maxpos)
        return 0;

    if ((ppszTable[endpos] =
            TableMalloc((int)strlen(pszString) + 1)) == NULL)
        return 0;

    strcpy(ppszTable[endpos], pszString);

    return endpos++;
}

int CTable::AddString(PCWSTR pszString)
{
    if (!pszString)
        return 0;
    if (endpos >= maxpos)
        IncreaseTableBuffer();

    if (endpos >= maxpos)
        return 0;

    if ((ppszTable[endpos] =
            TableMalloc((int)lstrlenW(pszString) + 2)) == NULL)
        return 0;

    lstrcpyW((PWSTR) ppszTable[endpos], pszString);

    return endpos++;
}

int CTable::AddData(int cb, const void* pdata)
{
    if (endpos >= maxpos)
        IncreaseTableBuffer();

    if (endpos >= maxpos)
        return 0;

    if ((ppszTable[endpos] = TableMalloc(cb)) == NULL)
        return 0;

    if (pdata)
        CopyMemory(ppszTable[endpos], pdata, cb);

    return endpos++;
}

int CTable::AddIntAndString(int lVal, PCSTR pszString)
{
    if (endpos >= maxpos)
        IncreaseTableBuffer();

    if (endpos >= maxpos)
        return 0;

    if ((ppszTable[endpos] =
            TableMalloc((int)strlen(pszString) + 1 + (int)sizeof(int))) == NULL)
        return 0;

    *(int*) ppszTable[endpos] = lVal;
    strcpy(ppszTable[endpos] + sizeof(int), pszString);

    return endpos++;
}

/***************************************************************************

    FUNCTION:   IncreaseTableBuffer

    PURPOSE:    Called when we need more room for string pointers

    PARAMETERS:

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        23-Feb-1992 [ralphw]

***************************************************************************/

void CTable::IncreaseTableBuffer(void)
{
    ASSERT(cbPointers < cbMaxTable);
    if (!VirtualAlloc((PBYTE) ppszTable + cbPointers, TABLE_ALLOC_SIZE,
            MEM_COMMIT, PAGE_READWRITE)) {
        OOM();
        return;
    }
    cbPointers += TABLE_ALLOC_SIZE;
#ifdef _DEBUG
    g_cbTableAllocated += TABLE_ALLOC_SIZE;
#endif
    maxpos = cbPointers / sizeof(PSTR);
}

/***************************************************************************

    FUNCTION:   TableMalloc

    PURPOSE:    Suballocate memory

    RETURNS:
        pointer to the memory

    COMMENTS:
        Instead of allocating memory for each string, memory is used from 4K
        blocks. When the table is freed, all memory is freed as a single
        unit. This has the advantage of speed for adding strings, speed for
        freeing all strings, and low memory overhead to save strings.

    MODIFICATION DATES:
        26-Feb-1990 [ralphw]
        26-Mar-1994 [ralphw]
            Ported to 32-bits

***************************************************************************/

PSTR CTable::TableMalloc(int cb)
{
    /*
     * Align allocation request so that all allocations fall on an
     * alignment boundary (32 bits for Intel, 64 bits for MIPS).
     */

    cb = (cb & (ALIGNMENT - 1)) ?
        cb / ALIGNMENT * ALIGNMENT + ALIGNMENT : cb;

    if (m_pFreed) {

        // First look for an exact match

        for (int i = 0; i < m_cFreedItems; i++) {
            ASSERT_COMMENT(m_pFreed[i].cb, "This memory has been used again -- it shouldn't be in the array");
            if (cb > m_pFreed[i].cb)
                break;
            if (cb == m_pFreed[i].cb)
                goto GotAMatch;
        }

        // Couldn't find an exact match, so find the first one that fits

        for (i--; i >= 0; i--) {
            ASSERT_COMMENT(m_pFreed[i].cb, "This memory has been used again -- it shouldn't be in the array");

            if (cb < m_pFreed[i].cb) {

                // If there's more then 32 bytes left, then suballoc

                if (cb + 32 < m_pFreed[i].cb) {
                    PSTR psz = (PSTR) m_pFreed[i].pMem;
                    m_pFreed[i].pMem += cb;
                    m_pFreed[i].cb -= cb;
                    // Keep the sizes sorted

                    QSort(m_pFreed, m_cFreedItems, sizeof(TABLE_FREED_MEMORY),
                        CompareIntPointers);
                    return psz;
                }
GotAMatch:
                m_cFreedItems--;
                PSTR psz = (PSTR) m_pFreed[i].pMem;
                if (i < m_cFreedItems) {
                    MemMove(&m_pFreed[i], &m_pFreed[i + 1],
                        sizeof(TABLE_FREED_MEMORY) * (m_cFreedItems - i));
#ifdef _DEBUG
                    m_pFreed[m_cFreedItems].cb = 0;
#endif
                }
#ifdef _DEBUG
                else
                    m_pFreed[i].cb = 0;
#endif
                return psz;
            }
        }
    }

    if (CurOffset + cb >= cbStrings) {
        int cbNew = cbStrings + TABLE_ALLOC_SIZE;
        while (cbNew < CurOffset + cb)
            cbNew += TABLE_ALLOC_SIZE;

        // We rely on VirtualAlloc to fail if cbStrings exceeds cbMaxBase

        if(cbNew > cbMaxBase)
        {
            ASSERT_COMMENT(FALSE, "Table memory overflow");
            return NULL;
        }

        if (!VirtualAlloc(pszBase + cbStrings, cbNew - cbStrings,
                MEM_COMMIT, PAGE_READWRITE)) {
            ASSERT_COMMENT(FALSE, "Table memory overflow");
            OOM();
            return NULL;
        }
#ifdef _DEBUG
        g_cbTableAllocated += (cbNew - cbStrings);
#endif
        cbStrings = cbNew;
    }

    int offset = CurOffset;
    CurOffset += cb;
    return pszBase + offset;
}

/***************************************************************************

    FUNCTION:   SetPosition

    PURPOSE:    Sets the position for reading from the table

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        26-Feb-1990 [ralphw]
        16-Oct-1990 [ralphw]
            If table position is to large, set to the end of the table,
            not the last line.

***************************************************************************/

BOOL FASTCALL CTable::SetPosition(int pos)
{
    if (pos >= endpos)
        pos = endpos;

    curpos = ((pos == 0) ? 1 : pos);
    return TRUE;
}

/***************************************************************************

    FUNCTION:   CTable::IsHashInTable

    PURPOSE:    Find out if the hash number exists in the table

    PARAMETERS:
        hash

    RETURNS:

    COMMENTS:
        Assumes case-insensitive hash number, and no collisions

    MODIFICATION DATES:
        05-Feb-1997 [ralphw]

***************************************************************************/

int CTable::IsHashInTable(HASH hash)
{
    for (int i = 1; i < endpos; i++) {
        if (hash == *(HASH *) ppszTable[i])
            return i;
    }
    return 0;
}

/***************************************************************************

    FUNCTION:   IsStringInTable

    PURPOSE:    Determine if the string is already in the table

    RETURNS:    position if the string is already in the table,
                0 if the string isn't found

    COMMENTS:
        The comparison is case-insensitive, and is considerably
        slower then IsCSStringInTable

        if lcid has been set, NLS string comparisons are used

    MODIFICATION DATES:
        02-Mar-1990 [ralphw]

***************************************************************************/

int CTable::IsStringInTable(PCSTR pszString) const
{
    int i;

    if (!lcid) {

        /*
         * Skip over as many strings as we can by just checking the first
         * letter. This avoids the overhead of the _strcmpi() function call.
         */

        char chLower = ToLower(*pszString);
        char chUpper = ToUpper(*pszString);

        for (i = 1; i < endpos; i++) {
            if ((*ppszTable[i] == chLower || *ppszTable[i] == chUpper)
                    && lstrcmpi(ppszTable[i], pszString) == 0)
                return i;
        }
    }
    else {      // Use NLS string comparison
        for (i = 1; i < endpos; i++) {
            if (CompareStringA(lcid, fsCompareI | NORM_IGNORECASE,
                    pszString, -1, ppszTable[i], -1) == 1)
                return i;
        }
    }

    return 0;
}

/***************************************************************************

    FUNCTION:   CTable::IsCSStringInTable

    PURPOSE:    Case-sensitive search for a string in a table

    PARAMETERS:
        pszString

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        12-Jun-1994 [ralphw]

***************************************************************************/

int CTable::IsCSStringInTable(PCSTR pszString) const
{
    char szBuf[sizeof(DWORD) + 1];
    DWORD cmp;

    if (strlen(pszString) < sizeof(DWORD)) {
        ZeroMemory(szBuf, sizeof(DWORD) + 1);
        strcpy(szBuf, pszString);
        cmp = *(DWORD*) szBuf;
    }
    else
        cmp = *(DWORD*) pszString;

    for (int i = 1; i < endpos; i++) {
        if (cmp == *(DWORD*) ppszTable[i] &&
                strcmp(ppszTable[i], pszString) == 0)
            return i;
    }
    return 0;
}

int CTable::IsStringInTable(HASH hash, PCSTR pszString) const
{
    for (int i = 1; i < endpos; i++) {
        if (hash == *(HASH *) ppszTable[i] &&
                // this avoids the very rare hash collision
                strcmp(ppszTable[i] + sizeof(HASH), pszString) == 0)
            return i;
    }
    return 0;
}

/***************************************************************************

    FUNCTION:   AddDblToTable

    PURPOSE:    Add two strings to the table

    RETURNS:

    COMMENTS:
        This function checks to see if the second string has already been
        added, and if so, it merely sets the pointer to the original string,
        rather then allocating memory for a new copy of the string.

    MODIFICATION DATES:
        08-Mar-1991 [ralphw]

***************************************************************************/

int CTable::AddString(PCSTR pszStr1, PCSTR pszStr2)
{
    int ui;

    AddString(pszStr1);
    if ((ui = IsSecondaryStringInTable(pszStr2)) != 0) {
        if (endpos >= maxpos)
            IncreaseTableBuffer();
        ppszTable[endpos++] = ppszTable[ui];
        return endpos - 1;
    }
    else {
        return AddString(pszStr2);
    }
}

/***************************************************************************

    FUNCTION:    IsPrimaryStringInTable

    PURPOSE:

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        03-Apr-1991 [ralphw]

***************************************************************************/

int CTable::IsPrimaryStringInTable(PCSTR pszString) const
{
    int i;

    /*
     * Skip over as many strings as we can by just checking the first
     * letter. This avoids the overhead of the _strcmpi() function call.
     * Since the strings aren't necessarily alphabetized, we must trudge
     * through the entire table using the _strcmpi() as soon as the first
     * character matches.
     */

    char chLower = ToLower(*pszString);
    char chUpper = ToUpper(*pszString);
    for (i = 1; i < endpos; i += 2) {
        if (*ppszTable[i] == chLower || *ppszTable[i] == chUpper)
            break;
    }
    for (; i < endpos; i += 2) {
        if (lstrcmpi(ppszTable[i], pszString) == 0)
            return i;
    }
    return 0;
}

/***************************************************************************

    FUNCTION:    IsSecondaryStringInTable

    PURPOSE:

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        03-Apr-1991 [ralphw]

***************************************************************************/

int CTable::IsSecondaryStringInTable(PCSTR pszString) const
{
    int i;

    /*
     * Skip over as many strings as we can by just checking the first
     * letter. This avoids the overhead of the _strcmpi() function call.
     * Since the strings aren't necessarily alphabetized, we must trudge
     * through the entire table using the _strcmpi() as soon as the first
     * character matches.
     */

    char chLower = ToLower(*pszString);
    char chUpper = ToUpper(*pszString);
    for (i = 2; i < endpos; i += 2) {
        if (*ppszTable[i] == chLower || *ppszTable[i] == chUpper)
            break;
    }
    for (; i < endpos; i += 2) {
        if (lstrcmpi(ppszTable[i], pszString) == 0)
            return i;
    }
    return 0;
}

/***************************************************************************

    FUNCTION:  SortTable

    PURPOSE:   Sort the current buffer

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        01-Jan-1990 [ralphw]

***************************************************************************/

void CTable::SortTable(int sortoffset)
{
    if (endpos < 3) // don't sort one entry
        return;
    m_sortoffset = sortoffset;

    if (lcid) {
        fsSortFlags = fsCompare;
        doLcidSort(1, (int) endpos - 1);
    }
    else
        doSort(1, (int) endpos - 1);
}

/***************************************************************************

    FUNCTION:   doSort

    PURPOSE:

    RETURNS:

    COMMENTS:
        Use QSORT algorithm

    MODIFICATION DATES:
        27-Mar-1990 [ralphw]

***************************************************************************/

void CTable::doSort(int left, int right)
{
    int last;

    if (left >= right)  // return if nothing to sort
        return;

    // REVIEW: should be a flag before trying this -- we may already know
    // that they won't be in order.

    // Only sort if there are elements out of order.

    j = right - 1;
    while (j >= left) {

        // REVIEW: strcmp is NOT case-sensitive!!!

        if (strcmp(ppszTable[j] + m_sortoffset,
                ppszTable[j + 1] + m_sortoffset) > 0)
            break;
        else
            j--;
    }
    if (j < left)
        return;

    sTmp = (left + right) / 2;
    pszTmp = ppszTable[left];
    ppszTable[left] = ppszTable[sTmp];
    ppszTable[sTmp] = pszTmp;

    last = left;
    for (j = left + 1; j <= right; j++) {
        if (strcmp(ppszTable[j] + m_sortoffset,
                ppszTable[left] + m_sortoffset) < 0) {
            sTmp = ++last;
            pszTmp = ppszTable[sTmp];
            ppszTable[sTmp] = ppszTable[j];
            ppszTable[j] = pszTmp;
        }
    }
    pszTmp = ppszTable[left];
    ppszTable[left] = ppszTable[last];
    ppszTable[last] = pszTmp;

    /*
     * REVIEW: we need to add some sort of stack depth check to prevent
     * overflow of the stack.
     */

    if (left < last - 1)
        doSort(left, last - 1);
    if (last + 1 < right)
        doSort(last + 1, right);
}

/***************************************************************************

    FUNCTION:   CTable::doLcidSort

    PURPOSE:    Sort using CompareStringA

    PARAMETERS:
        left
        right

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        03-Jun-1994 [ralphw]

***************************************************************************/

void CTable::doLcidSort(int left, int right)
{
    int last;
#ifdef _DEBUG
    static BOOL fWarned = FALSE;
    if (!fWarned) {
        char szBuf[256];
        wsprintf(szBuf, "*** fsSortFlags == %u", fsSortFlags);
        DBWIN(szBuf);
        fWarned = TRUE;
    }
#endif

    if (left >= right)  // return if nothing to sort
        return;

    // REVIEW: should be a flag before trying this -- we may already know
    // that they won't be in order.

    // Only sort if there are elements out of order.

    j = right - 1;
    while (j >= left) {
        if (CompareStringA(lcid, fsSortFlags, ppszTable[j] + m_sortoffset, -1,
                ppszTable[j + 1] + m_sortoffset, -1) > 2)
            break;
        else
            j--;
    }
    if (j < left)
        return;

    sTmp = (left + right) / 2;
    pszTmp = ppszTable[left];
    ppszTable[left] = ppszTable[sTmp];
    ppszTable[sTmp] = pszTmp;

    last = left;
    for (j = left + 1; j <= right; j++) {
        if (CompareStringA(lcid, fsSortFlags, ppszTable[j] + m_sortoffset, -1,
                ppszTable[left] + m_sortoffset, -1) < 2) {
            sTmp = ++last;
            pszTmp = ppszTable[sTmp];
            ppszTable[sTmp] = ppszTable[j];
            ppszTable[j] = pszTmp;
        }
    }
    pszTmp = ppszTable[left];
    ppszTable[left] = ppszTable[last];
    ppszTable[last] = pszTmp;

    if (left < last - 1)
        doLcidSort(left, last - 1);
    if (last + 1 < right)
        doLcidSort(last + 1, right);
}

/***************************************************************************

    FUNCTION:   CTable::InitializeTable

    PURPOSE:    Initializes the table

    PARAMETERS:
        uInitialSize

    RETURNS:

    COMMENTS:
        Called by constructor and Empty()


    MODIFICATION DATES:
        23-Feb-1994 [ralphw]

***************************************************************************/

void CTable::InitializeTable(void)
{
    // Allocate memory for the strings

    pszBase = (PSTR) VirtualAlloc(NULL, cbMaxBase, MEM_RESERVE,
        PAGE_READWRITE);
    if (!pszBase) {
        ASSERT_COMMENT(FALSE, "Out of virtual address space");
        OOM();
        return;
    }
    if (!VirtualAlloc(pszBase, cbStrings = TABLE_ALLOC_SIZE, MEM_COMMIT,
            PAGE_READWRITE))
        OOM();

    // Allocate memory for the string pointers

    ppszTable = (PSTR *) VirtualAlloc(NULL, cbMaxTable, MEM_RESERVE,
        PAGE_READWRITE);
    if (!ppszTable) {
        OOM();
        return;
    }
    if (!VirtualAlloc(ppszTable, cbPointers = TABLE_ALLOC_SIZE, MEM_COMMIT,
            PAGE_READWRITE))
        OOM();

#ifdef _DEBUG
    g_cbTableAllocated += (cbStrings + cbPointers);
    g_cbTableReserved += (cbMaxBase + cbMaxTable);
#endif

    curpos = 1;   // set to one so that sorting works
    endpos = 1;
    maxpos = cbPointers / sizeof(PSTR);
    CurOffset = 0;
    lcid = 0;
    m_pFreed = NULL;
}

void FASTCALL CTable::SetSorting(LCID lcid, DWORD fsCompareI, DWORD fsCompare)
{
    this->lcid = lcid;
    this->fsCompareI = fsCompareI;
    this->fsCompare = fsCompare;
}

/***************************************************************************

    FUNCTION:   CTable::AddIndexHitString

    PURPOSE:    Add an index, a hit number, and a string

    PARAMETERS:
        index
        hit
        pszString

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        27-Oct-1993 [ralphw]

***************************************************************************/

void CTable::AddIndexHitString(UINT index, UINT hit, PCSTR pszString)
{
    if (endpos >= maxpos)
        IncreaseTableBuffer();

    if ((ppszTable[endpos] =
            TableMalloc((int)strlen(pszString) + 1 + (int)sizeof(UINT) * 2)) == NULL)
        return;

    *(UINT*) ppszTable[endpos] = index;
    *(UINT*) (ppszTable[endpos] + sizeof(UINT)) = hit;

    strcpy(ppszTable[endpos++] + sizeof(UINT) * 2, pszString);
}

/***************************************************************************

    FUNCTION:  SortTablei

    PURPOSE:   Case-insensitive sort

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        01-Jan-1990 [ralphw]

***************************************************************************/

void CTable::SortTablei(int sortoffset)
{
    if (endpos < 3) // don't sort one entry
        return;
    m_sortoffset = sortoffset;
    if (!lcid)
        lcid = g_lcidSystem;

    ASSERT(lcid);
    fsSortFlags = fsCompareI | NORM_IGNORECASE;
    doLcidSort(1, endpos - 1);

    // REVIEW: what is this for?
#if 0
    int pos;

    for (pos = 1; pos < endpos - 2; pos++) {
        if (strlen(ppszTable[pos]) ==
                strlen(ppszTable[pos + 1]) &&
                CompareStringA(lcid, fsCompare, ppszTable[pos] + m_sortoffset, -1,
                    ppszTable[pos + 1] + m_sortoffset, -1) == 3) {
            PSTR pszTmp = ppszTable[pos];
            ppszTable[pos] = ppszTable[pos + 1];
            ppszTable[pos + 1] = pszTmp;
            if (pos > 2)
                pos -= 2;
        }
    }
#endif
}

UINT CTable::GetPosFromPtr(PCSTR psz)
{
    int pos = 1;
    do {
        if (psz == ppszTable[pos])
            return pos;
    } while (++pos < endpos);
    return 0;
}

/***************************************************************************

    FUNCTION:   ReplaceString

    PURPOSE:    Replaces the current string at the specified position with
                a new string

    RETURNS:    TRUE if the function is successful, FALSE if an error occurred.
                An error occurs if the specified position is beyond the end
                of the table.


    COMMENTS:
        If the new string is the same size or smaller then the original
        string, then it is copied over the original string. Otherwise,
        a new string buffer is allocated, and the pointer for the specified
        position is changed to point to the new buffer. Note that the old
        string's memory is not freed -- it simply becomes unavailable.

    MODIFICATION DATES:
        08-Oct-1991 [ralphw]
            Updated to transfer associated line number

***************************************************************************/

BOOL CTable::ReplaceString(const char * pszNewString, int pos)
{
    if (pos > endpos)
        return FALSE;

    if (pos == 0)
        pos = 1;

    /*
     * If the new string is larger then the old string, then allocate a
     * new buffer for it.
     */

    if (strlen(pszNewString) > (size_t) strlen(ppszTable[pos])) {
        if ((ppszTable[pos] =
                TableMalloc((int)strlen(pszNewString) + 1)) == NULL)
            return FALSE;
    }

    strcpy(ppszTable[pos], pszNewString);

    return TRUE;
}

void CTable::FreeMemory(PCSTR psz, int cb)
{
    if (cb == -1)
        cb = (int)strlen(psz) + 1;
    /*
     * Change the size of cb to match what would have been originally
     * allocated. See TableMalloc().
     */

    cb = (cb & (ALIGNMENT - 1)) ?
        cb / ALIGNMENT * ALIGNMENT + ALIGNMENT : cb;

    if (!m_pFreed) {
        m_cFreedMax = 5;
        m_cFreedItems = 0;
        m_pFreed = (TABLE_FREED_MEMORY*) lcMalloc(m_cFreedMax * sizeof(TABLE_FREED_MEMORY));
    }
    else if (m_cFreedItems >= m_cFreedMax) {
        m_cFreedMax += 5;
        m_pFreed = (TABLE_FREED_MEMORY*) lcReAlloc(m_pFreed, m_cFreedMax * sizeof(TABLE_FREED_MEMORY));
    }
    m_pFreed[m_cFreedItems].cb = cb;
    m_pFreed[m_cFreedItems].pMem = psz;
    m_cFreedItems++;

    // Keep the sizes sorted

    QSort(m_pFreed, m_cFreedItems, sizeof(TABLE_FREED_MEMORY), CompareIntPointers);
}


//////////////////////////////////////////////////////////////////////////
// CWTable
//////////////////////////////////////////////////////////////////////////

void CWTable::_CWTable( UINT CodePage )
{
  m_CodePage = CodePage;
}

CWTable::CWTable( UINT CodePage )
{
  _CWTable( CodePage );
}

CWTable::CWTable(int cbStrings, UINT CodePage ) : CTable( cbStrings )
{
  _CWTable( CodePage );
}

CWTable::~CWTable()
{
}

/***************************************************************************

    FUNCTION:   GetStringW

    PURPOSE:    Gets a Unicode version fo the stored string.

    RETURNS:    S_OK if the function is successful, S_FALSE otherwise.

    COMMENTS:   Stored string must be MBCS.

    MODIFICATION DATES:
        08-Sep-1998 [paulti]

***************************************************************************/

HRESULT CWTable::GetStringW( int pos, WCHAR* pwsz, int cch )
{
  CHAR* psz = CTable::GetPointer( pos );

  int iReturn = MultiByteToWideChar( m_CodePage, 0, psz, (int)strlen(psz), pwsz, cch );

  if( iReturn == 0 )
    return S_FALSE;

  pwsz[iReturn] = 0;

  return S_OK;
}


/***************************************************************************

    FUNCTION:   GetHashStringW

    PURPOSE:    Gets a Unicode versions of the string when the both a Hash
                and a string pair are stored.

    RETURNS:    S_OK if the function is successful, S_FALSE otherwise.

    COMMENTS:   Stored string must be MBCS.

    MODIFICATION DATES:
        08-Sep-1998 [paulti]

***************************************************************************/

HRESULT CWTable::GetHashStringW( int pos, WCHAR* pwsz, int cch )
{
  CHAR* psz = CTable::GetHashStringPointer( pos );

  int iReturn = MultiByteToWideChar( m_CodePage, 0, psz, (int)strlen(psz), pwsz, cch );

  if( iReturn == 0 )
    return S_FALSE;

  pwsz[iReturn] = 0;

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ctable.h ===
//  Copyright (C) Microsoft Corporation 1993-1997

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef DESCRIPTION

        The CTable class is used for storing strings or data which will be
        freed in one call when the destructor is called.

#endif // DESCRIPTION

#ifndef _CTABLE_INCLUDED
#define _CTABLE_INCLUDED

typedef struct {
    int cb;
    PCSTR pMem;
} TABLE_FREED_MEMORY;

const int OFF_FILENAME   = 5;           // offset to filename

class CTable ;

class CTable SI_COUNT(CTable)
{
public:
    CTable();
    CTable(int cbStrings); // cbStrings == maximum memory allocated for strings
    virtual ~CTable();
    const CTable& operator=(const CTable& tblSrc);  // copy constructor

    UINT GetPosFromPtr(PCSTR psz);

    // Used for ALink -- adds index, hit number, and string

    void  AddIndexHitString(UINT index, UINT hit, PCSTR pszString);
    UINT  GetIndex(int pos) { ASSERT(pos > 0 && pos < endpos); return *(UINT*) ppszTable[pos]; };
    UINT  GetHit(int pos) { ASSERT(pos > 0 && pos < endpos); return *(UINT*) (ppszTable[pos] + sizeof(UINT)); };
    PSTR  GetIHPointer(int pos) { ASSERT(pos > 0 && pos < endpos); return  (ppszTable[pos] + (sizeof(UINT) * 2)); };

    /*
     REVIEW: this is the complete set from ..\common\ctable.h. We use
     very few of these. Theoretically, this shouldn't have any impact
     on the size of WinHelp (linker should toss all non-used functions).
     One alternative would be to create a derived class from the
     ctable.h/ctable.cpp in the ..\common directory, and add the
     above functions to the derived class.
     */

    int   AddData(int cb, const void* pdata);
    int   AddIntAndString(int lVal, PCSTR psz);
    int   AddString(PCSTR  pszString);
    int   AddString(PCWSTR  pszString);
    int   AddString(PCSTR pszStr1, PCSTR pszStr2);
    int   AddString(HASH hash, PCSTR psz) {
                    return AddIntAndString((int) hash, psz); };
    int   CountStrings(void) const { return endpos - 1; }
    void  Empty(void);
    void  FreeMemory(PCSTR psz, int cb);
    BOOL  GetIntAndString(int* plVal, PSTR pszDst);
    int   GetInt(int pos) { return *(int *) ppszTable[pos]; }
    BOOL  GetHashAndString(HASH* phash, PSTR pszDst) {
                    return GetIntAndString((int*) phash, pszDst); };
    BOOL  GetHashAndString(HASH* phash, PSTR pszDst, int pos) {
                    SetPosition(pos);
                    return GetIntAndString((int*) phash, pszDst); };
    PSTR  GetHashStringPointer(int pos) { return ppszTable[pos] + sizeof(HASH); };
    PSTR  GetPointer(int pos) const { return ppszTable[pos]; };
    int   GetPosition(void) const { return curpos; }
    BOOL  GetString(PSTR pszDst);
    BOOL  GetString(PSTR pszDst, int pos) const;
    int   IsPrimaryStringInTable(PCSTR pszString) const;
    int   IsSecondaryStringInTable(PCSTR pszString) const;
    int   IsStringInTable(PCSTR pszString) const;
    int   IsStringInTable(HASH hash, PCSTR pszString) const;
    int   IsCSStringInTable(PCSTR pszString) const;
    BOOL  ReplaceString(PCSTR pszNewString, int pos);
    BOOL FASTCALL SetPosition(int pos = 1);
    virtual void  SortTable(int sortoffset = 0);
    void FASTCALL SetSorting(LCID lcid, DWORD fsCompareI = 0, DWORD fsCompare = 0);
    void  SortTablei(int sortoffset = 0);
    PSTR  TableMalloc(int cb);
    void  IncreaseTableBuffer(void);
    int   IsHashInTable(HASH hash);
    __inline PCSTR* GetStringPointers() { return (PCSTR*) ppszTable; }

    /*
     * Use this for efficient memory allocation for strings that will not
     * be freed until the entire CIndex is freed.
     */

    __inline PCSTR StrDup(PCSTR psz) { return strcpy(TableMalloc((int)strlen(psz) + 1), psz); }

    // Warning! all variables must match hha\ctable.h

    PSTR    pszBase;
    PSTR *  ppszTable;

    int     cbMaxBase;
    int     cbMaxTable;

    int     endpos;
    int     maxpos;

protected:
    int     curpos;
    int     CurOffset;
    int     cbStrings;
    int     cbPointers;
    int     SortColumn;
    LCID    lcid;
    DWORD   fsCompareI;
    DWORD   fsCompare;
    DWORD   fsSortFlags;
    int     m_sortoffset;

    TABLE_FREED_MEMORY* m_pFreed;   // pointer to freed memory
    int m_cFreedMax;                // number of allocated items
    int m_cFreedItems;              // current number of freed items

    // following are used by sort

    PSTR    pszTmp;
    int     j, sTmp;

    void  doSort(int left, int right);
    void  doLcidSort(int left, int right);
    void  doSorti(int left, int right);
    void  InitializeTable();
    void  Cleanup(void);

};

// retrieves only MBCS strings from the base CTable
// and converts them to Unicode according to the codepage
//
class CWTable : private CTable
{
public:

  CWTable( UINT CodePage );
  CWTable( int cbStrings, UINT CodePage );
  virtual ~CWTable();

  // new methods that return Unicode buffers
  HRESULT GetStringW( int pos, WCHAR* pwsz, int cch );
  HRESULT GetHashStringW( int pos, WCHAR* pwsz, int cch );
  inline UINT GetCodePage() { return m_CodePage; }

  // stuff from CTable we want to give access to
  CTable::CountStrings;
  CTable::AddString;
  CTable::IsStringInTable;
  CTable::AddIntAndString;
  CTable::SetSorting;
  CTable::SortTable;
  CTable::GetInt;

  // stuff from CTable that returns the MBCS string--BEWARE!!!
  CTable::GetString;
  CTable::GetStringPointers;
  CTable::GetHashStringPointer;


private:

  void _CWTable( UINT CodePage );


  UINT m_CodePage;

};

#endif  // _CTABLE_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ctlocx96.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

//
// implementation of the OCX 96 interfaces that don't quite fit in to the
// categories covered by embedding, persistence, and ctlmisc.cpp
//
//

#include "header.h"
#include "internet.h"

//=--------------------------------------------------------------------------=
// COleControl::GetActivationPolicy    [IPointerInactive]
//=--------------------------------------------------------------------------=
// returns the present activation policy for this object.  for non-subclassed
// windows controls, this means we can put off in-place activation for quite
// a while.
//
// Parameters:
//	  DWORD *		 - [out] activation policy
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetActivationPolicy
(
	DWORD *pdwPolicy
)
{
	CHECK_POINTER(pdwPolicy);

	// just get the policy in the global structure describing this control.
	//
	*pdwPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);
	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnInactiveMouseMove    [IPointerInactive]
//=--------------------------------------------------------------------------=
// indicates to an inactive oobject that the mouse pointer has moved over the
// object.
//
// Parameters:
//	  LPCRECT			 - [in]
//	  long				 - [in]
//	  long				 - [in]
//	  DWORD 			 - [in]
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveMouseMove
(
	LPCRECT pRectBounds,
	long	x,
	long	y,
	DWORD	dwMouseMsg
)
{
	// OVERRIDE: end control writers should just override this if they want
	// to have a control that is never in-place active.
	//
	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnInactiveSetCursor    [IPointerInactive]
//=--------------------------------------------------------------------------=
// called by the container for the inactive object under the mouse pointer on
// recept of a WM_SETCURSOR message.
//
// Parameters:
//	  LPCRECT			 - [in]
//	  long				 - [in]
//	  long				 - [in]
//	  DWORD 			 - [in]
//	  BOOL				 - [in]
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveSetCursor
(
	LPCRECT pRectBounds,
	long	x,
	long	y,
	DWORD	dwMouseMsg,
	BOOL	fSetAlways
)
{
	// OVERRIDE:  just get the user to override this if they want to never
	// be activated
	//
	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QuickActivate	 [IQuickActivate]
//=--------------------------------------------------------------------------=
// allows the container to activate the control.
//
// Parameters:
//	  QACONTAINER * 	   - [in]  info about the container
//	  QACONTROL *		   - [out] info about the control
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QuickActivate
(
	QACONTAINER *pContainer,
	QACONTROL *pControl
)
{
	HRESULT hr;
	DWORD	dw;

	// we need these guys.
	//
	if (!pContainer) return E_UNEXPECTED;
	if (!pControl) return E_UNEXPECTED;

	// start grabbing things from the QACONTAINER structure and apply them
	// as relevant
	//
	if (pContainer->cbSize < sizeof(QACONTAINER)) return E_UNEXPECTED;
	if (pControl->cbSize < sizeof(QACONTROL)) return E_UNEXPECTED;

	// save out the client site, of course.
	//
	if (pContainer->pClientSite) {
		hr = SetClientSite(pContainer->pClientSite);
		RETURN_ON_FAILURE(hr);
	}

	// if the lcid is not LANG_NEUTRAL, score!
	//
	if (pContainer->lcid) {
		g_lcidLocale = pContainer->lcid;
		g_fHaveLocale = TRUE;
	}

	// hook up some notifications.	first property notifications.

	if (pContainer->pPropertyNotifySink) {
		pContainer->pPropertyNotifySink->AddRef();
		hr = m_cpPropNotify.AddSink((void *)pContainer->pPropertyNotifySink, &pControl->dwPropNotifyCookie);
		if (FAILED(hr)) {
			pContainer->pPropertyNotifySink->Release();
			return hr;
		}
	}

	// then the event sink.
	//
	if (pContainer->pUnkEventSink) {
		hr = m_cpEvents.Advise(pContainer->pUnkEventSink, &pControl->dwEventCookie);
		if (FAILED(hr)) {
			pContainer->pUnkEventSink->Release();
			return hr;
		}
	}

	// finally, the advise sink.
	//
	if (pContainer->pAdviseSink) {
		// don't need to pass the cookie back since there can only be one
		// person advising at a time.
		//
		hr = Advise(pContainer->pAdviseSink, &dw);
		RETURN_ON_FAILURE(hr);
	}

	// set up a few things in the QACONTROL structure.	we're opaque by default
	//
	pControl->dwMiscStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
	pControl->dwViewStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
	pControl->dwPointerActivationPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);

	// that's pretty much all we're interested in.	we will, however, pass on the
	// rest of the things to the end control writer and see if they want to do
	// anything with them. they shouldn't touch any of the above except for the
	// ambients.
	//
	return OnQuickActivate(pContainer, &(pControl->dwViewStatus));
}

//=--------------------------------------------------------------------------=
// COleControl::SetContentExtent	[IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to set the content extent of the control.
//
// Parameters:
//	  LPSIZEL			 - [in] the size of the content extent
//
// Output:
//	  HRESULT			 - S_OK, or E_FAIL for fixed size control
//
// Notes:
//
STDMETHODIMP COleControl::SetContentExtent
(
	LPSIZEL pSize
)
{
	return SetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::GetContentExtent	[IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to get the content extent of the control
//
// Parameters:
//	  LPSIZEL		 - [out] returns current size
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetContentExtent
(
	LPSIZEL pSize
)
{
	return GetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::OnQuickActivate    [overridable]
//=--------------------------------------------------------------------------=
// not all the of the members of the QACONTAINER need to be consumed by the
// framework, but are, at least, extremely interesting.  thus, we will pass
// on the struture to the end control writer, and let them consume these.
//
// Parameters:
//	  QACONTAINER * 		   - [in]  contains additional information
//	  DWORD *				   - [out] put ViewStatus flags here.
//
// Output:
//	  HRESULT
//
// Notes:
//	  - control writers should only look at/consume:
//		  a. dwAmbientFlags
//		  b. colorFore/colorBack
//		  c. pFont
//		  d. pUndoMgr
//		  e. dwAppearance
//		  f. hpal
//
//	  - all the others are set up the for the user by the framework.
//	  - control writers should set up the pdwViewStatus with flags as per
//		IViewObjectEx::GetViewStatus.  if you don't know what this is or don't
//		care, then don't touch.
//
HRESULT COleControl::OnQuickActivate
(
	QACONTAINER *pContainer,
	DWORD		*pdwViewStatus
)
{
	// by default, nuthin much to do!
	//
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ctlpsst.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

//
// implementation of persistence interfaces for COleControl.
//
#include "header.h"
#include "internet.h"

#include "CtlHelp.H"

// this is the name of the stream we'll save our ole controls to.
//
const WCHAR wszCtlSaveStream [] = L"CONTROLSAVESTREAM";

#ifndef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

//=--------------------------------------------------------------------------=
// to help with out stream save implementation ...
//
#define STREAMHDR_SIGNATURE 0x12344321	// Signature to identify our format (avoid crashes!)
#define IPROP_END 0xFF					// Marker at end of property list
#define MAXAUTOBUF 3800 				// Best if < 1 page.

typedef struct tagSTREAMHDR {

	DWORD  dwSignature; 	// Signature.
	size_t cbWritten;		// Number of bytes written

} STREAMHDR;

//=--------------------------------------------------------------------------=
// COleControl persistence interfaces
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// COleControl::Load	[IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// IPersistPropertyBag.  we've got a property bag, so let's load our properties
// from it.
//
// Parameters:
//	  IPropertyBag *	  - [in] pbag from which to read props.
//	  IErrorLog *		  - [in] error log to write to
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
	IPropertyBag *pPropertyBag,
	IErrorLog	 *pErrorLog
)
{
	HRESULT hr;

	// load in our standard state first.  nothing serious here ... currently,
	// we've just got two properties, for cx and cy.
	//
	hr = LoadStandardState(pPropertyBag, pErrorLog);
	RETURN_ON_FAILURE(hr);

	// now call the user text load function, and get them to load in whatever
	// they're interested in.
	//
	hr = LoadTextState(pPropertyBag, pErrorLog);

	return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save	[IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// given a property bag, save out all the relevant state information.
//
// Parameters:
//	  IPropertyBag *		- [in] property to write to
//	  BOOL					- [in] do we clear the dirty bit?
//	  BOOL					- [in] do we write out default values anyhoo?
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
	IPropertyBag *pPropertyBag,
	BOOL		  fClearDirty,
	BOOL		  fWriteDefault
)
{
	HRESULT hr;

	// save out standard state information
	//
	hr = SaveStandardState(pPropertyBag);
	RETURN_ON_FAILURE(hr);

	// now call the user function and get them to save out
	// all of their properties.

	hr = SaveTextState(pPropertyBag, fWriteDefault);
	RETURN_ON_FAILURE(hr);

	// now clear the dirty flag and send out notification that we're
	// done.

	if (fClearDirty)
		m_fDirty = FALSE;

	if (m_pOleAdviseHolder)
		m_pOleAdviseHolder->SendOnSave();

	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassID	  [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// returns the classid of this mamma
//
// Parameters:
//	  CLSID *		  - [out] where to put the clsid
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassID
(
	CLSID *pclsid
)
{
	CHECK_POINTER(pclsid);

	// copy the thing over
	//
	*pclsid = CLSIDOFOBJECT(m_ObjectType);
	return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::IsDirty    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// asks if we're dirty or not.  duh.
//
// Output:
//	  HRESULT		 - S_OK: dirty, S_FALSE: not dirty
//
// Notes:
//
STDMETHODIMP COleControl::IsDirty
(
	void
)
{
	return (m_fDirty) ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// causes the control to intialize itself with a new bunch of state information
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
	void
)
{
	BOOL f;

	// call the overridable function to do this work
	//
	f = InitializeNewState();
	return (f) ? S_OK : E_FAIL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetSizeMax	  [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//	  ULARGE_INTEGER *	  - [out]
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetSizeMax
(
	ULARGE_INTEGER *pulMaxSize
)
{
	return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Load	[IPersistStreamInit]
//=--------------------------------------------------------------------------=
// load from an IStream
//
// Parameters:
//	  IStream *    - [in] stream from which to load
//
// Output:
//	  HRESULT
//
// Notes:
//

STDMETHODIMP COleControl::Load(IStream *pStream)
{
	HRESULT hr;

	// first thing to do is read in standard properties the user don't
	// persist themselves.

	hr = LoadStandardState(pStream);
	RETURN_ON_FAILURE(hr);

	// load in the user properties.  this method is one they -have- to implement
	// themselves.

	hr = LoadBinaryState(pStream);

	return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save	[IPersistStreamInit]
//=--------------------------------------------------------------------------=
// saves out our state using streams
//
// Parameters:
//	  IStream * 	   - [in]
//	  BOOL			   - [in] clear dirty bit?
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
	IStream *pStream,
	BOOL	 fClearDirty
)
{
	HRESULT hr;

	// use our helper routine that we share with the IStorage persistence
	// code.
	//
	hr = m_SaveToStream(pStream);
	RETURN_ON_FAILURE(hr);

	// clear out dirty flag [if appropriate] and notify that we're done
	// with save.
	//
	if (fClearDirty)
		m_fDirty = FALSE;
	if (m_pOleAdviseHolder)
		m_pOleAdviseHolder->SendOnSave();

	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStorage]
//=--------------------------------------------------------------------------=
// ipersiststorage version of this.  fweee
//
// Parameters:
//	  IStorage *	- [in] we don't use this
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
	IStorage *pStorage
)
{
	// we already have an implementation of this [for IPersistStreamInit]
	//
	return InitNew();
}

//=--------------------------------------------------------------------------=
// COleControl::Load	[IPersistStorage]
//=--------------------------------------------------------------------------=
// Ipersiststorage version of this
//
// Parameters:
//	  IStorage *	- [in] DUH.
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load(IStorage *pStorage)
{
	IStream *pStream;
	HRESULT  hr;

	// we're going to use IPersistStream::Load from the CONTENTS stream.
	//
	hr = pStorage->OpenStream(wszCtlSaveStream, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStream);
	RETURN_ON_FAILURE(hr);

	// IPersistStreamInit::Load
	//
	hr = Load(pStream);
	pStream->Release();
	return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save	[IPersistStorage]
//=--------------------------------------------------------------------------=
// save into the contents stream of the given storage object.
//
// Parameters:
//	  IStorage *		- [in] 10 points if you figure it out
//	  BOOL				- [in] is the storage the same as the load storage?
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
	IStorage *pStorage,
	BOOL	  fSameAsLoad
)
{
	IStream *pStream;
	HRESULT  hr;

	// we're just going to save out to the CONTENTES stream.
	//
	hr = pStorage->CreateStream(wszCtlSaveStream, STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
								0, 0, &pStream);
	RETURN_ON_FAILURE(hr);

	// use our helper routine.
	//
	hr = m_SaveToStream(pStream);
	m_fSaveSucceeded = (FAILED(hr)) ? FALSE : TRUE;
	pStream->Release();
	return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveCompleted	 [IPersistStorage]
//=--------------------------------------------------------------------------=
// lets us clear out our flags.
//
// Parameters:
//	  IStorage *	- ignored
//
// Output:
//	  HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SaveCompleted
(
	IStorage *pStorageNew
)
{
	// if our save succeeded, then we can do our post save work.
	//
	if (m_fSaveSucceeded) {
		m_fDirty = FALSE;
		if (m_pOleAdviseHolder)
			m_pOleAdviseHolder->SendOnSave();
	}

	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::HandsOffStorage    [IPersistStorage]
//=--------------------------------------------------------------------------=
// not interesting
//
// Output:
//	  S_OK
//
// Notes:
//
STDMETHODIMP COleControl::HandsOffStorage
(
	void
)
{
	// we don't ever hold on to  a storage pointer, so this is remarkably
	// uninteresting to us.
	//
	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::m_SaveToStream	  [helper: IPersistStreamInit/IPersistStorage]
//=--------------------------------------------------------------------------=
// save ourselves to a stream
//
// Parameters:
//	  IStream * 	   - figure it out
//
// Output:
//	  HRESULT

HRESULT COleControl::m_SaveToStream ( IStream *pStream )
{
	return SaveStandardState(pStream);

#if 0
	01-Sep-1997 [ralphw] We don't save binary state

	HRESULT hr;

	// save out standard state information that the user has no control
	// over

	hr = SaveStandardState(pStream);
	RETURN_ON_FAILURE(hr);

	// save out user-specific satte information.  they MUST implement this
	// function

	hr = SaveBinaryState(pStream);

	return hr;
#endif
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState	 [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// text persistence APIs.  there is another version for streams.
//
// Parameters:
//	  IPropertyBag *	- [in]
//	  IErrorLog *		- [in]
//
// Output:
//	  HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
	IPropertyBag *pPropertyBag,
	IErrorLog	 *pErrorLog
)
{
	VARIANT v;
	HRESULT hr;
	SIZEL	slHiMetric = { 100, 50 };

	// currently, our only standard properties are related to size.
	// if we can't find them, then we'll just use some defaults.
	//
	v.vt = VT_I4;
	v.lVal = 0;
	hr = pPropertyBag->Read(L"Width", &v, pErrorLog);
	if (SUCCEEDED(hr)) slHiMetric.cx = v.lVal;

	v.lVal = 0;
	hr = pPropertyBag->Read(L"Height", &v, pErrorLog);
	if (SUCCEEDED(hr)) slHiMetric.cy = v.lVal;

	HiMetricToPixel(&slHiMetric, &m_Size);
	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState	 [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// stream persistence APIs.  there is another version for text.
//
// Parameters:
//	  IStream * 		- [in]
//
// Output:
//	  HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
	IStream *pStream
)
{
	STREAMHDR stmhdr;
	HRESULT hr;
	SIZEL	slHiMetric;

	// look for our header structure, so we can verify stream validity.
	//
	hr = pStream->Read(&stmhdr, sizeof(STREAMHDR), NULL);
	RETURN_ON_FAILURE(hr);

	if (stmhdr.dwSignature != STREAMHDR_SIGNATURE)
		return E_UNEXPECTED;

	// currently, the only standard state we're writing out is
	// a SIZEL structure describing the control's size.
	//
	if (stmhdr.cbWritten != sizeof(m_Size))
		return E_UNEXPECTED;

	// we like the stream.	let's go load in our two properties.
	//
	hr = pStream->Read(&slHiMetric, sizeof(slHiMetric), NULL);
	RETURN_ON_FAILURE(hr);

	HiMetricToPixel(&slHiMetric, &m_Size);
	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState	 [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using text
// persistence APIs.  there is another version for stream persistence.
//
// Parameters:
//	  IPropertyBag *		- [in]
//
// Output:
//	  HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
	IPropertyBag *pPropertyBag
)
{
	HRESULT hr;
	VARIANT v;
	SIZEL	slHiMetric;

	// currently, the only standard proprerties we persist are Size related
	//
	PixelToHiMetric(&m_Size, &slHiMetric);

	v.vt = VT_I4;
	v.lVal = slHiMetric.cx;

	hr = pPropertyBag->Write(L"Width", &v);
	RETURN_ON_FAILURE(hr);

	v.lVal = slHiMetric.cy;

	hr = pPropertyBag->Write(L"Height", &v);

	return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState	 [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using stream
// persistence APIs.  there is another version for text persistence.
//
// Parameters:
//	  IStream * 		   - [in]
//
// Output:
//	  HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
	IStream *pStream
)
{
	STREAMHDR streamhdr = { STREAMHDR_SIGNATURE, sizeof(SIZEL) };
	HRESULT hr;
	SIZEL	slHiMetric;


	// first thing to do is write out our stream hdr structure.
	//
	hr = pStream->Write(&streamhdr, sizeof(STREAMHDR), NULL);
	RETURN_ON_FAILURE(hr);

	// the only properties we're currently persisting here are the size
	// properties for this control.  make sure we do that in HiMetric
	//
	PixelToHiMetric(&m_Size, &slHiMetric);

	hr = pStream->Write(&slHiMetric, sizeof(slHiMetric), NULL);
	return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::InitializeNewState	  [overridable]
//=--------------------------------------------------------------------------=
// the user can override this to initialize variables
//
// Output:
//	  BOOL		  - FALSE means couldn't do it.
//
// Notes:
//
BOOL COleControl::InitializeNewState
(
	void
)
{
	// we find this largely uninteresting
	//
	return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ctlview.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "internet.h"
#include <stddef.h>

#ifndef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

HDC _CreateOleDC(DVTARGETDEVICE *ptd);

//=--------------------------------------------------------------------------=
// COleControl::Draw	[IViewObject2]
//=--------------------------------------------------------------------------=
// Draws a representation of an object onto the specified device context.
//
// Parameters:
//	  DWORD 			   - [in] draw aspect
//	  LONG				   - [in] part of object to draw [not relevant]
//	  void *			   - NULL
//	  DVTARGETDEVICE *	   - [in] specifies the target device
//	  HDC				   - [in] information context for target device
//	  HDC				   - [in] target device context
//	  LPCRECTL			   - [in] rectangle in which the object is drawn
//	  LPCRECTL			   - [in] window extent and origin for metafiles
//	  BOOL (*)(DWORD)	   - [in] callback for continuing or cancelling drawing
//	  DWORD 			   - [in] parameter to pass to callback.
//
// Output:
//	  HRESULT
//
// Notes:
//	  - we support the following OCX 96 extensions
//		  a. flicker free drawing [multi-pass drawing]
//		  b. pvAspect != NULL for optimized DC handling
//		  c. prcBounds == NULL for windowless inplace active objects

STDMETHODIMP COleControl::Draw(DWORD dwDrawAspect, LONG lIndex,
	void *pvAspect, DVTARGETDEVICE	*ptd, HDC hicTargetDevice,
	HDC hdcDraw, LPCRECTL prcBounds,
	LPCRECTL prcWBounds,
	BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue),
	ULONG_PTR dwContinue)
{
	HRESULT hr;
	RECTL rc;
	POINT pVp, pW;
	BOOL  fOptimize = FALSE;
	int iMode;
	BYTE fMetafile = FALSE;
	BYTE fDeleteDC = FALSE;

	// support the aspects required for multi-pass drawing

	switch (dwDrawAspect) {
		case DVASPECT_CONTENT:
		case DVASPECT_OPAQUE:
		case DVASPECT_TRANSPARENT:
			break;
		default:
			return DV_E_DVASPECT;
	}

	// first, have to do a little bit to support printing.

	if (GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE) {

		// We are dealing with a metafile.
		//
		fMetafile = TRUE;

		// If attributes DC is NULL, create one, based on ptd.

		if (!hicTargetDevice) {

			// Does _CreateOleDC have to return an hDC
			// or can it be flagged to return an hIC
			// for this particular case?
			//
			hicTargetDevice = _CreateOleDC(ptd);
			fDeleteDC = TRUE;
		}
	}

	// check to see if we have any flags passed in the pvAspect parameter.

	if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb == sizeof(DVASPECTINFO))
		fOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE) ? TRUE : FALSE;

	// if we are windowless, then we just pass this on to the end control code.

	if (m_fInPlaceActive) {
		// Can't use CopyRect because OLE decided to use RECTL instead of RECT
		memcpy(&rc, &m_rcLocation, sizeof(m_rcLocation));
	} else {
		memcpy(&rc, prcBounds, sizeof(rc));

		// first -- convert the DC back to MM_TEXT mapping mode so that the
		// window proc and OnDraw can share the same painting code.  save
		// some information on it, so we can restore it later [without using
		// a SaveDC/RestoreDC]
		//

		// Don't do anything to hdcDraw if it's a metafile.
		// The control's Draw method must make the appropriate
		// accomodations for drawing to a metafile
		//
		if (!fMetafile) {
			LPtoDP(hdcDraw, (POINT *)&rc, 2);
			SetViewportOrgEx(hdcDraw, 0, 0, &pVp);
			SetWindowOrgEx(hdcDraw, 0, 0, &pW);
			iMode = SetMapMode(hdcDraw, MM_TEXT);
		}
	}

	// prcWBounds is NULL and not used if we are not dealing with a metafile.
	// For metafiles, we pass on rc as *prcBounds, we should also include
	// prcWBounds

	hr = OnDraw(dwDrawAspect, hdcDraw, &rc, prcWBounds, hicTargetDevice, fOptimize);

	// clean up the DC when we're done with it, if appropriate.

	if (!m_fInPlaceActive) {
		SetViewportOrgEx(hdcDraw, pVp.x, pVp.y, NULL);
		SetWindowOrgEx(hdcDraw, pW.x, pW.y, NULL);
		SetMapMode(hdcDraw, iMode);
	}

	// if we created a dc, blow it away now

	if (fDeleteDC)
		DeleteDC(hicTargetDevice);
	return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::DoSuperClassPaint
//=--------------------------------------------------------------------------=
// design time painting of a subclassed control.
//
// Parameters:
//	  HDC				 - [in]  dc to work with
//	  LPCRECTL			 - [in]  rectangle to paint to.  should be in pixels

HRESULT COleControl::DoSuperClassPaint(HDC hdc, LPCRECTL prcBounds)
{
	HWND hwnd;
	RECT rcClient;
	int  iMapMode;
	POINT ptWOrg, ptVOrg;
	SIZE  sWOrg, sVOrg;

	// make sure we have a window.

	hwnd = CreateInPlaceWindow(0,0, FALSE);
	if (!hwnd)
		return E_FAIL;

	GetClientRect(hwnd, &rcClient);

	// set up the DC for painting.	this code largely taken from the MFC CDK
	// DoSuperClassPaint() fn.	doesn't always get things like command
	// buttons quite right ...
	//
	// NOTE: there is a windows 95 problem in which the font instance manager
	// will leak a bunch of bytes in the global GDI pool whenever you
	// change your extents and have an active font.  this code gets around
	// this for on-screen cases, but not for printing [which shouldn't be
	// too serious, because you're not often changing your control size and
	// printing rapidly in succession]

	if ((rcClient.right - rcClient.left != prcBounds->right - prcBounds->left)
		&& (rcClient.bottom - rcClient.top != prcBounds->bottom - prcBounds->top)) {

		iMapMode = SetMapMode(hdc, MM_ANISOTROPIC);
		SetWindowExtEx(hdc, rcClient.right, rcClient.bottom, &sWOrg);
		SetViewportExtEx(hdc, prcBounds->right - prcBounds->left, prcBounds->bottom - prcBounds->top, &sVOrg);
	}

	SetWindowOrgEx(hdc, 0, 0, &ptWOrg);
	SetViewportOrgEx(hdc, prcBounds->left, prcBounds->top, &ptVOrg);

	CallWindowProc((WNDPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetColorSet    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the logical palette that the control will use for drawing in its
// IViewObject::Draw method with the corresponding parameters.
//
// Parameters:
//	  DWORD 			   - [in]  how the object is to be represented
//	  LONG				   - [in]  part of the object to draw [not relevant]
//	  void *			   - NULL
//	  DVTARGETDEVICE *	   - [in]  specifies the target device
//	  HDC				   - [in]  information context for the target device
//	  LOGPALETTE ** 	   - [out] where to put palette
//
// Output:
//	  S_OK				   - Control has a palette, and returned it through the out param.
//	  S_FALSE			   - Control does not currently have a palette.
//	  E_NOTIMPL 		   - Control will never have a palette so optimize handling of this control.

STDMETHODIMP COleControl::GetColorSet(DWORD dwDrawAspect, LONG lindex,
	void *IgnoreMe, DVTARGETDEVICE *ptd, HDC hicTargetDevice,
	LOGPALETTE **ppColorSet)
{
	if (dwDrawAspect != DVASPECT_CONTENT)
		return DV_E_DVASPECT;

	*ppColorSet = NULL;
	return (OnGetPalette(hicTargetDevice, ppColorSet)) ? ((*ppColorSet) ? S_OK : S_FALSE) : E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Freeze	  [IViewObject2]
//=--------------------------------------------------------------------------=
// Freezes a certain aspect of the object's presentation so that it does not
// change until the IViewObject::Unfreeze method is called.
//
// Parameters:
//	  DWORD 		   - [in] aspect
//	  LONG			   - [in] part of object to draw
//	  void *		   - NULL
//	  DWORD *		   - [out] for Unfreeze

STDMETHODIMP COleControl::Freeze(DWORD dwDrawAspect, LONG lIndex,
	void *IgnoreMe, DWORD *pdwFreeze)
{
	return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Unfreeze	[IVewObject2]
//=--------------------------------------------------------------------------=
// Releases a previously frozen drawing. The most common use of this method
// is for banded printing.
//
// Parameters:
//	  DWORD 	   - [in] cookie from freeze

STDMETHODIMP COleControl::Unfreeze(DWORD dwFreeze)
{
	return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::SetAdvise	 [IViewObject2]
//=--------------------------------------------------------------------------=
// Sets up a connection between the control and an advise sink so that the
// advise sink can be notified about changes in the control's view.
//
// Parameters:
//	  DWORD 		   - [in] aspect
//	  DWORD 		   - [in] info about the sink
//	  IAdviseSink *    - [in] the sink

STDMETHODIMP COleControl::SetAdvise(DWORD dwAspects, DWORD dwAdviseFlags,
	IAdviseSink *pAdviseSink)
{
	// if it's not a content aspect, we don't support it.

	if (!(dwAspects & DVASPECT_CONTENT)) {
		return DV_E_DVASPECT;
	}

	// set up some flags  [we gotta stash for GetAdvise ...]

	m_fViewAdvisePrimeFirst = (dwAdviseFlags & ADVF_PRIMEFIRST) ? TRUE : FALSE;
	m_fViewAdviseOnlyOnce = (dwAdviseFlags & ADVF_ONLYONCE) ? TRUE : FALSE;

	RELEASE_OBJECT(m_pViewAdviseSink);
	m_pViewAdviseSink = pAdviseSink;
	ADDREF_OBJECT(m_pViewAdviseSink);

	// prime them if they want it [we need to store this so they can get flags later]

	if (m_fViewAdvisePrimeFirst)
		ViewChanged();

	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAdvise	 [IViewObject2]
//=--------------------------------------------------------------------------=
// Retrieves the existing advisory connection on the control if there is one.
// This method simply returns the parameters used in the most recent call to
// the IViewObject::SetAdvise method.
//
// Parameters:
//	  DWORD *			 - [out]  aspects
//	  DWORD *			 - [out]  advise flags
//	  IAdviseSink **	 - [out]  the sink

STDMETHODIMP COleControl::GetAdvise(DWORD *pdwAspects, DWORD *pdwAdviseFlags,
	IAdviseSink **ppAdviseSink)
{
	// if they want it, give it to them

	if (pdwAspects)
		*pdwAspects = DVASPECT_CONTENT;

	if (pdwAdviseFlags) {
		*pdwAdviseFlags = 0;
		if (m_fViewAdviseOnlyOnce) *pdwAdviseFlags |= ADVF_ONLYONCE;
		if (m_fViewAdvisePrimeFirst) *pdwAdviseFlags |= ADVF_PRIMEFIRST;
	}

	if (ppAdviseSink) {
		*ppAdviseSink = m_pViewAdviseSink;
		ADDREF_OBJECT(*ppAdviseSink);
	}

	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent	 [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the size that the control will be drawn on the
// specified target device.
//
// Parameters:
//	  DWORD 		   - [in] draw aspect
//	  LONG			   - [in] part of object to draw
//	  DVTARGETDEVICE * - [in] information about target device
//	  LPSIZEL		   - [out] where to put the size

STDMETHODIMP COleControl::GetExtent(DWORD dwDrawAspect, LONG lindex,
	DVTARGETDEVICE *ptd, LPSIZEL psizel)
{
	// we already have an implementation of this [from IOleObject]

	return GetExtent(dwDrawAspect, psizel);
}

//=--------------------------------------------------------------------------=
// COleControl::OnGetPalette	[overridable]
//=--------------------------------------------------------------------------=
// called when the host wants palette information.	ideally, people should use
// this sparingly and carefully.
//
// Parameters:
//	  HDC			 - [in]  HIC for the target device
//	  LOGPALETTE **  - [out] where to put the palette
//
// Output:
//	  BOOL			 - TRUE means we processed it, false means nope.

BOOL COleControl::OnGetPalette(HDC hicTargetDevice, LOGPALETTE **ppColorSet)
{
	return FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::GetRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns a rectnagle describing a given drawing aspect
//
// Parameters:
//	  DWORD 			- [in]	aspect
//	  LPRECTL			- [out] region rectangle

STDMETHODIMP COleControl::GetRect(DWORD dvAspect, LPRECTL prcRect)
{
	RECTL rc;
	BOOL  f;

	// call the user routine and let them return the size

	f = OnGetRect(dvAspect, &rc);
	if (!f) return DV_E_DVASPECT;

	// transform these dudes.

	PixelToHiMetric((LPSIZEL)&rc, (LPSIZEL)prcRect);
	PixelToHiMetric((LPSIZEL)(LPBYTE)&rc + sizeof(SIZEL), (LPSIZEL)((LPBYTE)prcRect + sizeof(SIZEL)));

	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetViewStatus	 [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns information about the opactiy of the object and what drawing
// aspects are supported
//
// Parameters:
//	  DWORD *			 - [out] the status

STDMETHODIMP COleControl::GetViewStatus(DWORD *pdwStatus)
{
	// depending on the flag in the CONTROLOBJECTINFO structure, indicate our
	// transparency vs opacity.
	// OVERRIDE:  controls that wish to support multi-pass drawing should
	// override this routine and return, in addition to the flags indication
	// opacity, flags indicating what sort of drawing aspects they support.

	*pdwStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitPoint	 [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates whether a point is within a given aspect of an object.
//
// Parameters:
//	  DWORD 			   - [in]  aspect
//	  LPCRECT			   - [in]  Bounds rectangle
//	  POINT 			   - [in]  hit location client coordinates
//	  LONG				   - [in]  what the container considers close
//	  DWORD *			   - [out] info about the hit

STDMETHODIMP COleControl::QueryHitPoint(DWORD dvAspect, LPCRECT prcBounds,
	POINT ptLocation, LONG lCloseHint, DWORD *pdwHitResult)
{
	// OVERRIDE: override me if you want to provide additional [non-opaque]
	// functionality

	if (dvAspect != DVASPECT_CONTENT)
		return DV_E_DVASPECT;

	*pdwHitResult = PtInRect(prcBounds, ptLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitRect	[IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates whether any point in a rectangle is within a given drawing aspect
// of an object.
//
// Parameters:
//	  DWORD 		   - [in]  aspect
//	  LPCRECT		   - [in]  bounds
//	  LPCRECT		   - [in]  location
//	  LONG			   - [in]  what host considers close
//	  DWORD *		   - [out] hit result

STDMETHODIMP COleControl::QueryHitRect(DWORD dvAspect, LPCRECT prcBounds,
	LPCRECT prcLocation, LONG lCloseHint, DWORD *pdwHitResult)
{
	RECT rc;

	// OVERRIDE: override this for additional behaviour

	if (dvAspect != DVASPECT_CONTENT)
		return DV_E_DVASPECT;

	*pdwHitResult = IntersectRect(&rc, prcBounds, prcLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
	return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetNaturalExtent	[IViewObjectEx]
//=--------------------------------------------------------------------------=
// supports two types of control sizing, content and integral.
//
// Parameters:
//	  DWORD 		   - [in]  aspect
//	  LONG			   - [in]  index
//	  DVTARGETDEVICE * - [in]  target device information
//	  HDC			   - [in]  HIC
//	  DVEXTENTINFO *   - [in]  sizing data
//	  LPSIZEL		   - [out] sizing data retunred by control

STDMETHODIMP COleControl::GetNaturalExtent(DWORD dvAspect, LONG lIndex,
	DVTARGETDEVICE *ptd, HDC hicTargetDevice, DVEXTENTINFO *pExtentInfo,
	LPSIZEL pSizel)
{
	return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnGetRect	 [overridable
//=--------------------------------------------------------------------------=
// returns our rectangle
//
// Parameters:
//	  DWORD 			 - [in]  aspect they want the rect for
//	  RECTL *			 - [out] the rectangle that matches this aspect
//
// Output:
//	  BOOL				 - false means we don't like the aspect

BOOL COleControl::OnGetRect(DWORD dvAspect, RECTL *pRect)
{
	// by default, we only support content drawing.

	if (dvAspect != DVASPECT_CONTENT)
		return FALSE;

	// just give them our bounding rectangle

	*((LPRECT)pRect) = m_rcLocation;
	return TRUE;
}

//=--------------------------------------------------------------------------=
// _CreateOleDC
//=--------------------------------------------------------------------------=
// creates an HDC given a DVTARGETDEVICE structure.
//
// Parameters:
//	  DVTARGETDEVICE *				- [in] duh.

HDC _CreateOleDC(DVTARGETDEVICE *ptd)
{
	LPDEVMODEW	 pDevModeW;
	DEVMODEA	 DevModeA, *pDevModeA;
	LPOLESTR	 lpwszDriverName;
	LPOLESTR	 lpwszDeviceName;
	LPOLESTR	 lpwszPortName;
	HDC 		 hdc;

	// return screen DC for NULL target device

	if (!ptd)
		return CreateDC("DISPLAY", NULL, NULL, NULL);

	if (ptd->tdExtDevmodeOffset == 0)
		pDevModeW = NULL;
	else
		pDevModeW = (LPDEVMODEW)((LPSTR)ptd + ptd->tdExtDevmodeOffset);

	lpwszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
	lpwszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
	lpwszPortName	= (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

	MAKE_ANSIPTR_FROMWIDE(pszDriverName, lpwszDriverName);
	MAKE_ANSIPTR_FROMWIDE(pszDeviceName, lpwszDeviceName);
	MAKE_ANSIPTR_FROMWIDE(pszPortName,	 lpwszPortName);

	if (pDevModeW) {
		WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmDeviceName, -1,
			(LPSTR) DevModeA.dmDeviceName, CCHDEVICENAME, NULL, NULL);
	memcpy(&DevModeA.dmSpecVersion, &pDevModeW->dmSpecVersion,
		offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion));
		WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmFormName, -1, (LPSTR)DevModeA.dmFormName, CCHFORMNAME, NULL, NULL);
	memcpy(&DevModeA.dmLogPixels, &pDevModeW->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels));
		if (pDevModeW->dmDriverExtra) {
			pDevModeA = (DEVMODEA *)lcCalloc(sizeof(DEVMODEA) + pDevModeW->dmDriverExtra);
			if (!pDevModeA)
				return NULL;
			memcpy(pDevModeA, &DevModeA, sizeof(DEVMODEA));
			memcpy(pDevModeA + 1, pDevModeW + 1, pDevModeW->dmDriverExtra);
		}
		else
			pDevModeA = &DevModeA;

	DevModeA.dmSize = sizeof(DEVMODEA);
	}
	else
		pDevModeA = NULL;

	hdc = CreateDC(pszDriverName, pszDeviceName, pszPortName, pDevModeA);
	if (pDevModeA != &DevModeA)
		lcFree(pDevModeA);
	return hdc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ctlwrap.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

// wrappers for various routines that have slightly different implementations
// for windowed and windowless controls.

#include "header.h"
#include "internet.h"

#ifndef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

//=--------------------------------------------------------------------------=
// COleControl::OcxGetFocus    [wrapper]
//=--------------------------------------------------------------------------=
// indicates whether or not we have the focus.
//
// Parameters:
//	  none
//
// Output:
//	  TRUE if we have focus, else false

BOOL COleControl::OcxGetFocus(void)
{
	DBWIN("COleControl::OcxGetFocus");

	// if we're windowless, the site provides this functionality

	if (m_pInPlaceSiteWndless) {
		return (m_pInPlaceSiteWndless->GetFocus() == S_OK);
	}
	else {

		// we've got a window.  just let the APIs do our work

		if (m_fInPlaceActive)
			return (GetFocus() == m_hwnd);
		else
			return FALSE;
	}
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetWindowRect	[wrapper]
//=--------------------------------------------------------------------------=
// returns the current rectangle for this control, and correctly handles
// windowless vs windowed.
//
// Parameters:
//	  LPRECT				- [out]  duh.
//
// Output:
//	  BOOL					- false means unexpected.

BOOL COleControl::OcxGetWindowRect(LPRECT prc)
{
	// if we're windowless, then we have this information already.

	if (Windowless()) {
		CopyRect(prc, &m_rcLocation);
		return TRUE;
	}
	else
		return GetWindowRect(m_hwnd, prc);
}

//=--------------------------------------------------------------------------=
// COleControl::OcxDefWindowProc	[wrapper]
//=--------------------------------------------------------------------------=
// default window processing

LRESULT COleControl::OcxDefWindowProc(UINT msg, WPARAM wParam, LPARAM lParam)
{
	// if we're windowless, this is a site provided pointer

	if (m_pInPlaceSiteWndless) {
		LRESULT result;
		m_pInPlaceSiteWndless->OnDefWindowMessage(msg, wParam, lParam, &result);
		return result;
	}
	else
		// we've got a window -- just pass it along

		return DefWindowProc(m_hwnd, msg, wParam, lParam);
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetDC	[wrapper]
//=--------------------------------------------------------------------------=
// wraps the functionality of GetDC, and correctly handles windowless controls
//
// Parameters:
//	  none
//
// Output:
//	  HDC			 - null means we couldn't get one
//
// Notes:
//	  - we don't bother with a bunch of the IOleInPlaceSiteWindowless::GetDc
//		parameters, since the windows GetDC doesn't expose these either. users
//		wanting that sort of fine tuned control can call said routine
//		explicitly
//

HDC COleControl::OcxGetDC(void)
{
	// if we're windowless, the site provides this functionality.

	if (m_pInPlaceSiteWndless) {
		HDC hdc;
		m_pInPlaceSiteWndless->GetDC(NULL, 0, &hdc);
		return hdc;
	}
	else
		return GetDC(m_hwnd);
}

//=--------------------------------------------------------------------------=
// COleControl::OcxReleaseDC	[wrapper]
//=--------------------------------------------------------------------------=
// releases a DC returned by OcxGetDC
//
// Parameters:
//	  HDC			  - [in] release me

void COleControl::OcxReleaseDC(HDC hdc)
{
	// if we're windowless, the site does this for us

	if (m_pInPlaceSiteWndless)
		m_pInPlaceSiteWndless->ReleaseDC(hdc);
	else
		ReleaseDC(m_hwnd, hdc);
}

//=--------------------------------------------------------------------------=
// COleControl::OcxSetCapture	 [wrapper]
//=--------------------------------------------------------------------------=
// provides a means for the control to get or release capture.
//
// Parameters:
//	  BOOL			  - [in] true means take, false release
//
// Output:
//	  BOOL			  - true means it's yours, false nuh-uh
//
// Notes:
//

BOOL COleControl::OcxSetCapture(BOOL fGrab)
{
	HRESULT hr;

	// the host does this for us if we're windowless

	if (m_pInPlaceSiteWndless) {
		hr = m_pInPlaceSiteWndless->SetCapture(fGrab);
		return (hr == S_OK);
	} else {
		// people shouldn't call this when they're not in-place active, but
		// just in case...

		if (m_fInPlaceActive) {
			SetCapture(m_hwnd);
			return TRUE;
		} else
			return FALSE;
	}

	// dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetCapture	 [wrapper]
//=--------------------------------------------------------------------------=
// tells you whether or not you have the capture.
//
// Parameters:
//	  none
//
// Output:
//	  BOOL		   - true it's yours, false it's not

BOOL COleControl::OcxGetCapture ( void )
{
	// host does this for windowless dudes

	if (m_pInPlaceSiteWndless)
		return m_pInPlaceSiteWndless->GetCapture() == S_OK;
	else {
		// people shouldn't call this when they're not in-place active, but
		// just in case.

		if (m_fInPlaceActive)
			return GetCapture() == m_hwnd;
		else
			return FALSE;
	}
}

//=--------------------------------------------------------------------------=
// COleControl::OcxInvalidateRect	 [wrapper]
//=--------------------------------------------------------------------------=
// invalidates the control's rectangle
//
// Parameters:
//	  LPCRECT			 - [in] rectangle to invalidate
//	  BOOL				 - [in] do we erase background first?

BOOL COleControl::OcxInvalidateRect(LPCRECT prcInvalidate, BOOL fErase)
{
	// if we're windowless, then we need to get the site to do all this for
	// us

	if (m_pInPlaceSiteWndless)
		return m_pInPlaceSiteWndless->InvalidateRect(prcInvalidate, fErase) == S_OK;
	else {
		// otherwise do something different depending on whether or not we're
		// in place active or not

		if (m_fInPlaceActive)
			return InvalidateRect(m_hwnd, prcInvalidate, TRUE);
		else
			ViewChanged();
	}

	return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxScrollRect	 [wrapper]
//=--------------------------------------------------------------------------=
// does some window scrolling for the control
//
// Parameters:
//	  LPCRECT			  - [in] region to scroll
//	  LPCRECT			  - [in] region to clip
//	  int				  - [in] dx to scroll
//	  int				  - [in] dy to scroll

BOOL COleControl::OcxScrollRect(LPCRECT prcBounds, LPCRECT prcClip, int dx, int dy)
{
	// if we're windowless, the site provides this functionality, otherwise
	// APIs do the job

	if (m_pInPlaceSiteWndless)
		return m_pInPlaceSiteWndless->ScrollRect(dx, dy, prcBounds, prcClip) == S_OK;
	else {
		if (m_fInPlaceActive)
			ScrollWindowEx(m_hwnd, dx, dy, prcBounds, prcClip, NULL, NULL, SW_INVALIDATE);
		else
			return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ctoc.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif


#ifndef __CTOC_H__
#define __CTOC_H__

#ifndef __SITEMAP_H__
#include "sitemap.h"
#endif
#include "stdio.h"
#include "parserhh.h"
#include "collect.h"
#include "hhtypes.h"
#include "toc.h"

#include "navui.h" // Cleanup headers.

class CHtmlHelpControl; // forward reference
class CHHWinType;       // forward reference

class CToc : public INavUI
{
private:
    void UpdateTOCSlot(CTreeNode* pNode);

public:
    CToc(CHtmlHelpControl* phhctrl, IUnknown* pUnkOuter, CHHWinType* phh = NULL);
    virtual ~CToc();

    //--- INavUI Functions.
    BOOL    Create(HWND hwndParent);
    LRESULT OnCommand(HWND hwnd, UINT id, UINT uNotifiyCode, LPARAM lParam);
    void    HideWindow(void);
    void    ShowWindow(void);
    void    ResizeWindow();
    void    SetPadding(int pad) { m_padding = pad; }
    void    SetTabPos(int tabpos) { m_NavTabPos = tabpos; }
    LRESULT OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam) ;
    void    SetDefaultFocus() ;
    void    Refresh(void);

    // Not Implemented
    bool    ProcessMenuChar(HWND hwndParent, int ch) { /*Not Implemented*/ return false;}
    void OnDrawItem(UINT id, LPDRAWITEMSTRUCT pdis) {/*Not Implemented*/}
    void    Seed(LPCSTR pszSeed) {/*Not Implemented*/}
    void OnVKListNotify(NMHDR* pNMHdr) {/*Not Implemented*/}

    //--- Other Member Functions
    void    ChangeOuter(IUnknown* pUnkOuter) { m_pOuter = pUnkOuter; }
    BOOL    InitTreeView(void);

    LRESULT OnSiteMapContentsCommand(UINT id, UINT uNotifiyCode, LPARAM lParam);
    LRESULT OnBinTOCContentsCommand(UINT id, UINT uNotifiyCode, LPARAM lParam);
    BOOL    ReadFile(PCSTR pszFile);

    void    SetStyles(DWORD exStyles, DWORD dwStyles) { m_exStyles = exStyles; m_dwStyles = dwStyles; }

    LRESULT TreeViewMsg( NM_TREEVIEW* pnmhdr );     // The treeview message handeler
    LRESULT OnSiteMapTVMsg( NM_TREEVIEW *pnmhdr );  // The message handeler for handeling SITEMAP
    LRESULT OnBinaryTOCTVMsg( NM_TREEVIEW *pnmhdr );// The message handeler for handeling Binary TOC
    BOOL    Synchronize(LPCSTR pszUrl);
    DWORD   OnCustomDraw(LPNMTVCUSTOMDRAW nmcdrw);
    void    SaveCurUrl(void);

    BOOL        m_fBinaryTOC;   // TRUE if compiled TOC (.chm/.chi) is available, else FALSE
    CTreeNode*  m_pBinTOCRoot;  // The root of the binary table of contents
    CTreeNode*  pCurrentTreeNode;
    CSiteMap    m_sitemap;      // the sitemap that holds an uncompiled TOC.

    HTREEITEM   m_tiFirstVisible;   // Binary TOC, the initial tree view visible when the Tree
                                    // view is first displayed.
    HTREEITEM*  m_phTreeItem;
    int         m_cntFirstVisible;
    int         m_cntCurHighlight;
    HTREEITEM   m_hitemCurHighlight;
    BOOL        m_fSuppressJump; // TRUE to prevent jumping on selection change
    BOOL        m_fIgnoreNextSelChange;
    BYTE*       m_pSelectedTocInfoTypes;
    HWND        m_hwndTree;
    HBITMAP     m_hbmpBackGround;
    HPALETTE    m_hpalBackGround;
    HBRUSH      m_hbrBackGround;    // background brush
    int         m_cxBackBmp;
    int         m_cyBackBmp;
    int         m_cFonts;
    HFONT*      m_ahfonts;
    BOOL        m_fGlobal;  // means we've already initialized ourselves once
    HIMAGELIST  m_hil;

    CHtmlHelpControl* m_phhctrl;
    IUnknown*   m_pOuter;
    BOOL        m_fHack;
    DWORD       m_exStyles;
    DWORD       m_dwStyles;
    int         m_padding;
    int         m_NavTabPos;
    BOOL        m_fSuspendSync;
    CHHWinType* m_phh;
    CStr        m_cszCurUrl;
    BOOL        m_fSyncOnActivation;    // TRUE to sync when TOC tab is activated

    CInfoType*  m_pInfoType;    // The information Types
};

#endif  // __CTOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ctrlobj.h ===
// Copyright  1995-1997  Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CTRLOBJ_H_
#define _CTRLOBJ_H_

// we need the automation object and ctlole.h

#include "AutoObj.H"
#include <olectl.h>

// forward declaration

class COleControl;

//=--------------------------------------------------------------------------=
// Misc Helper Functions
//=--------------------------------------------------------------------------=
//
// given an Unknown pointer, get the COleControl * for it.  used typically
// in property page code.

COleControl *ControlFromUnknown(IUnknown *);

//=--------------------------------------------------------------------------=
// Misc Constants
//=--------------------------------------------------------------------------=
// maximum number of arguments that can be sent to FireEvent()

#define MAX_ARGS  32

// for the types of sinks that the COleControl class has.  you shouldn't ever
// need to use these

#define SINK_TYPE_EVENT     0
#define SINK_TYPE_PROPNOTIFY 1

// superclass window support.  you can pass this in to DoSuperClassPaint

#define DRAW_SENDERASEBACKGROUND    1

//=--------------------------------------------------------------------------=
// Various Hosts don't handle OLEIVERB_PROPERTIES correctly, so we can't use
// that as our Properties verb number. Instead, we're going to define
// CTLIVERB_PROPERTIES as 1, and return that one in IOleObject::EnumVerbs,
// but we'll still handle OLEIVERB_PROPERTIES correctly in DoVerb.

#define CTLIVERB_PROPERTIES   1


//=--------------------------------------------------------------------------=
// this structure is like the OLEVERB structure, except that it has a resource ID
// instead of a string for the verb's name.  better support for localization.

typedef struct tagVERBINFO {

   LONG  lVerb;              // verb id
   ULONG idVerbName;         // resource ID of verb name
   DWORD fuFlags;         // verb flags
   DWORD grfAttribs;         // Specifies some combination of the verb attributes in the OLEVERBATTRIB enumeration.

} VERBINFO;

// describes an event

typedef struct tagEVENTINFO {

   DISPID     dispid;                // dispid of the event
   int     cParameters;           // number of arguments to the event
   VARTYPE  *rgTypes;                // type of each argument

} EVENTINFO;

//=--------------------------------------------------------------------------=
// CONTROLOBJECTINFO
//=--------------------------------------------------------------------------=
// for each control you wish to expose to the programmer/user, you need to
// declare and define one of the following structures.   the first part should
// follow the rules of the AUTOMATIONOBJECTINFO structure.  it's pretty hard,
// however, to imagine a scenario where the control isn't CoCreatable ...
// once this structre is declared/defined, an entry should be put in the
// global g_ObjectInfo table.
//
typedef struct {

   AUTOMATIONOBJECTINFO AutomationInfo;         // automation and creation information
   const IID      *piidEvents;               // IID of primary event interface
   DWORD       dwOleMiscFlags;            // control flags
   DWORD       dwActivationPolicy;        // IPointerInactive support
   VARIANT_BOOL   fOpaque;                // is your control 100% opaque?
   VARIANT_BOOL   fWindowless;               // do we do windowless if we can?
   WORD        wToolboxId;                // resource ID of Toolbox Bitmap
   LPCSTR         szWndClass;                // name of window control class
   VARIANT_BOOL   fWindowClassRegistered;       // has the window class been registered yet?
   WORD        cPropPages;                // number of property pages
   const GUID    **rgPropPageGuids;          // array of the property page GUIDs
   WORD        cCustomVerbs;              // number of custom verbs
   const VERBINFO *rgCustomVerbs;               // description of custom verbs
   WNDPROC     pfnSubClass;               // for subclassed controls.

} CONTROLOBJECTINFO;

#ifndef INITOBJECTS

#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo,  w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \


#else
#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL } \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, fo, TRUE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL } \

#endif // !INITOBJECTS

#define OLEMISCFLAGSOFCONTROL(index)    ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwOleMiscFlags
#define FCONTROLISWINDOWLESS(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowless
#define FCONTROLISOPAQUE(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fOpaque
#define ACTIVATIONPOLICYOFCONTROL(index) ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwActivationPolicy
#define EVENTIIDOFCONTROL(index)     (*(((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->piidEvents))
#define WNDCLASSNAMEOFCONTROL(index)    ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->szWndClass
#define CPROPPAGESOFCONTROL(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cPropPages
#define PPROPPAGESOFCONTROL(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgPropPageGuids
#define CCUSTOMVERBSOFCONTROL(index)    ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cCustomVerbs
#define CUSTOMVERBSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgCustomVerbs
#define BITMAPIDOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->wToolboxId
#define CTLWNDCLASSREGISTERED(index)    ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowClassRegistered
#define SUBCLASSWNDPROCOFCONTROL(index)  ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->pfnSubClass

// These need to match what is in COleControl::InternalQueryInterface

class COleControl : public CAutomationObject,
               public IOleObject,
               public IOleControl,
               public IOleInPlaceObjectWindowless,
               public IOleInPlaceActiveObject,
               public IViewObjectEx,
               public IPersistPropertyBag,
               public IPersistStreamInit,
               public IPersistStorage,
               public IConnectionPointContainer,
               public IProvideClassInfo,
               public IPointerInactive,
               public IQuickActivate
{
public:
   // IUnknown methods -- there are required since we inherit from variuos
   // people who themselves inherit from IUnknown.  just delegate to controlling
   // unknown

   DECLARE_STANDARD_UNKNOWN();

   //=--------------------------------------------------------------------------=
   // IPersist methods.  used by IPersistStream and IPersistStorage

   STDMETHOD(GetClassID)(THIS_ LPCLSID lpClassID);

   // IPersistStreamInit methods

   STDMETHOD(IsDirty)(THIS);
   STDMETHOD(Load)(LPSTREAM pStm);
   STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);
   STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* pcbSize);
   STDMETHOD(InitNew)();

   // IPersistStorage

   STDMETHOD(InitNew)(IStorage  *pStg);
   STDMETHOD(Load)(IStorage  *pStg);
   STDMETHOD(Save)(IStorage  *pStgSave, BOOL fSameAsLoad);
   STDMETHOD(SaveCompleted)(IStorage  *pStgNew);
   STDMETHOD(HandsOffStorage)(void);

   // IPersistPropertyBag

   STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
   STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty,
               BOOL fSaveAllProperties);

   // IOleControl methods

   STDMETHOD(GetControlInfo)(LPCONTROLINFO pCI);
   STDMETHOD(OnMnemonic)(LPMSG pMsg);
   STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);
   STDMETHOD(FreezeEvents)(BOOL bFreeze);

   // IOleObject methods

   STDMETHOD(SetClientSite)(IOleClientSite  *pClientSite);
   STDMETHOD(GetClientSite)(IOleClientSite  * *ppClientSite);
   STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
   STDMETHOD(Close)(DWORD dwSaveOption);
   STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker  *pmk);
   STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker  * *ppmk);
   STDMETHOD(InitFromData)(IDataObject  *pDataObject, BOOL fCreation, DWORD dwReserved);
   STDMETHOD(GetClipboardData)(DWORD dwReserved, IDataObject  * *ppDataObject);
   STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite  *pActiveSite, LONG lindex,
                            HWND hwndParent, LPCRECT lprcPosRect);
   STDMETHOD(EnumVerbs)(IEnumOLEVERB  * *ppEnumOleVerb);
   STDMETHOD(Update)(void);
   STDMETHOD(IsUpToDate)(void);
   STDMETHOD(GetUserClassID)(CLSID  *pClsid);
   STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR  *pszUserType);
   STDMETHOD(SetExtent)(DWORD dwDrawAspect,SIZEL  *psizel);
   STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL  *psizel);
   STDMETHOD(Advise)(IAdviseSink  *pAdvSink, DWORD  *pdwConnection);
   STDMETHOD(Unadvise)(DWORD dwConnection);
   STDMETHOD(EnumAdvise)(IEnumSTATDATA  * *ppenumAdvise);
   STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD  *pdwStatus);
   STDMETHOD(SetColorScheme)(LOGPALETTE  *pLogpal);

   // IOleWindow. required for IOleInPlaceObject and IOleInPlaceActiveObject

   STDMETHOD(GetWindow)(HWND *phwnd);
   STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

   // IOleInPlaceObject/IOleInPlaceObjectWindowless

   STDMETHOD(InPlaceDeactivate)(void);
   STDMETHOD(UIDeactivate)(void);
   // STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect,LPCRECT lprcClipRect) ;
   STDMETHOD(ReactivateAndUndo)(void);
   STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
   STDMETHOD(GetDropTarget)(IDropTarget **ppDropTarget);

   // IOleInPlaceActiveObject

   STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);
   STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
   STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
   STDMETHOD(ResizeBorder)(LPCRECT prcBorder,
                     IOleInPlaceUIWindow  *pUIWindow,
                     BOOL fFrameWindow);
   STDMETHOD(EnableModeless)(BOOL fEnable);

   // IViewObject2/IViewObjectEx

   STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void  *pvAspect,
               DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
               LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
               BOOL ( __stdcall  *pfnContinue )(ULONG_PTR dwContinue),
               ULONG_PTR dwContinue);
   STDMETHOD(GetColorSet)(DWORD dwDrawAspect,LONG lindex, void  *pvAspect,
                     DVTARGETDEVICE  *ptd, HDC hicTargetDev,
                     LOGPALETTE  * *ppColorSet);
   STDMETHOD(Freeze)(DWORD dwDrawAspect, LONG lindex,
                 void   *pvAspect,DWORD  *pdwFreeze);
   STDMETHOD(Unfreeze)(DWORD dwFreeze);
   STDMETHOD(SetAdvise)(DWORD aspects, DWORD advf, IAdviseSink  *pAdvSink);
   STDMETHOD(GetAdvise)(DWORD *pAspects, DWORD  *pAdvf, IAdviseSink  * *ppAdvSink);
   STDMETHOD(GetExtent)(DWORD dwDrawAspect, LONG lindex, DVTARGETDEVICE __RPC_FAR *ptd, LPSIZEL lpsizel);
   STDMETHOD(GetRect)(DWORD dwAspect, LPRECTL pRect);
   STDMETHOD(GetViewStatus)(DWORD *pdwStatus);
   STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG lCloseHint, DWORD *pHitResult);
   STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG lCloseHint, DWORD *pHitResult);
   STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG lindex, DVTARGETDEVICE *ptd, HDC hicTargetDev, DVEXTENTINFO *pExtentInfo, LPSIZEL psizel);

   // IConnectionPointContainer methods

   STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS FAR* ppEnum);
   STDMETHOD(FindConnectionPoint)(REFIID iid, LPCONNECTIONPOINT FAR* ppCP);

   // ISpecifyPropertyPages

   // STDMETHOD(GetPages)(CAUUID * pPages);

   // IProvideClassInfo methods

   STDMETHOD(GetClassInfo)(LPTYPEINFO * ppTI);

   // IPointerInactive methods

   STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy);
   STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg);
   STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways);

   // IQuickActivate methods

   STDMETHOD(QuickActivate)(QACONTAINER *pqacontainer, QACONTROL *pqacontrol);
   STDMETHOD(SetContentExtent)(LPSIZEL);
   STDMETHOD(GetContentExtent)(LPSIZEL);

   // constructor and destructor

   COleControl(IUnknown *pUnkOuter, int iPrimaryDispatch, void *pMainInterface);
   virtual ~COleControl();

   //=--------------------------------------------------------------------------=
   // callable by anybody

   static LRESULT CALLBACK ControlWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
//   static LRESULT CALLBACK ReflectWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
   static COleControl * ControlFromHwnd(HWND hwnd) {
      return (COleControl *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
   }

   void __cdecl FireEvent(EVENTINFO * pEventInfo, ...);

   /*
    * ole controls that want to support both windowed and windowless
    * operations should use these wrappers instead of the appropriate win32
    * api routine. controls that don't care and just want to be windowed
    * all the time can just go ahead and use the api routines.
    */

   BOOL  SetFocus(BOOL fGrab);                  // SetFocus API
   BOOL  OcxGetFocus(void);                     // GetFocus() == m_hwnd
   BOOL  OcxGetWindowRect(LPRECT);              // gets your current window rect
   LRESULT OcxDefWindowProc(UINT, WPARAM, LPARAM);    // DefWindowProc
   HDC   OcxGetDC(void);                     // GetDC(m_hwnd);
   void  OcxReleaseDC(HDC hdc);                 // ReleaseDC(m_hwnd, hdc);
   BOOL  OcxSetCapture(BOOL fGrab);             // SetCapture(fGrab ? m_hwnd : NULL);
   BOOL  OcxGetCapture(void);                // GetCapture() == m_hwnd
   BOOL  OcxInvalidateRect(LPCRECT, BOOL);         // InvalidateRect(m_hwnd, prc, f);
   BOOL  OcxScrollRect(LPCRECT, LPCRECT, int, int);   // ScrollWindowEx(...);

protected:

   //=--------------------------------------------------------------------------=
   // member variables that derived controls can get at.
   //
   // derived controls Should NOT modify the following.

   IOleClientSite    *m_pClientSite;            // client site
   IOleControlSite    *m_pControlSite;          // IOleControlSite ptr on client site
   IOleInPlaceSite    *m_pInPlaceSite;          // IOleInPlaceSite for managing activation
   IOleInPlaceFrame   *m_pInPlaceFrame;         // IOleInPlaceFrame ptr on client site
   IOleInPlaceUIWindow *m_pInPlaceUIWindow;     // for negotiating border space with client
   ISimpleFrameSite   *m_pSimpleFrameSite;      // simple frame site
   IDispatch         *m_pDispAmbient;        // ambient dispatch pointer
   SIZEL          m_Size;              // the size of this control
   RECT           m_rcLocation;           // where we at

public:
   HWND           m_hwnd;              // our window
   HWND           m_hwndParent;           // our parent window

protected:
   // Windowless OLE controls support

   IOleInPlaceSiteWindowless *m_pInPlaceSiteWndless; // IOleInPlaceSiteWindowless pointer

   // flags indicating internal state.  do not modify.

   unsigned m_fDirty:1;                   // does the control need to be resaved?
   unsigned m_fInPlaceActive:1;              // are we in place active or not?
   unsigned m_fInPlaceVisible:1;             // we are in place visible or not?
   unsigned m_fUIActive:1;                   // are we UI active or not.
   unsigned m_fCreatingWindow:1;             // indicates if we're in CreateWindowEx or not

   //=--------------------------------------------------------------------------=
   // methods that derived controls can override, but may need to be called
   // from their versions.

   virtual void   ViewChanged(void);
   virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

   //=--------------------------------------------------------------------------=
   // member functions that provide for derived controls, or that we use, but
   // derived controls might still find useful.

   HRESULT   DoSuperClassPaint(HDC, LPCRECTL);
//   HRESULT      RecreateControlWindow(void);
   BOOL      DesignMode(void);
   BOOL      GetAmbientProperty(DISPID, VARTYPE, void *);
   BOOL      GetAmbientFont(IFont **ppFontOut);

public:
   void      ModalDialog(BOOL fShow) {
      // notify the container of our intention to show a modal dialog...

      if (m_pInPlaceFrame)
         m_pInPlaceFrame->EnableModeless(!fShow);
   }
   HRESULT   InPlaceActivate(LONG lVerb);

   void      InvalidateControl(LPCRECT prc);
protected:
   BOOL      SetControlSize(SIZEL *pSizel);

   HWND      CreateInPlaceWindow(int x, int y, BOOL fNoRedraw);
   void      SetInPlaceVisible(BOOL);
   void      SetInPlaceParent(HWND);

   // IPropertyNotifySink stuff.

   inline void  PropertyChanged(DISPID dispid) {
      m_cpPropNotify.DoOnChanged(dispid);
   }
   inline BOOL  RequestPropertyEdit(DISPID dispid) {
      return m_cpPropNotify.DoOnRequestEdit(dispid);
   }

   // subclassed windows controls support ...

   // little routine for people to tell if they are windowless or not
   //
   inline BOOL  Windowless(void) {
      return !m_fInPlaceActive || m_pInPlaceSiteWndless;
   }

   // some people don't care if they're windowed or not -- they just need
   // a site pointer.   this makes it a little easier.
   //
   inline IOleInPlaceSite    *GetInPlaceSite(void) {
      return (IOleInPlaceSite *)(m_pInPlaceSiteWndless ? m_pInPlaceSiteWndless : m_pInPlaceSite);
   }

protected:
   //=--------------------------------------------------------------------------=
   // the following are methods that ALL control writers must override and implement

   STDMETHOD(LoadBinaryState)(IStream *pStream) PURE;
   // STDMETHOD(SaveBinaryState)(IStream *pStream) PURE;
   STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog) PURE;
   STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault) PURE;
   STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize) PURE;
   virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam) PURE;
   virtual BOOL   RegisterClassData(void) PURE;

   //=--------------------------------------------------------------------------=
   // OVERRIDABLES -- methods controls can implement for customized functionality

   virtual void   AmbientPropertyChanged(DISPID dispid) { };
   virtual BOOL   ShouldCreateWindow() { return TRUE; }
   virtual BOOL   BeforeCreateWindow(DWORD *, DWORD *, LPSTR) { return TRUE; }
   virtual void   BeforeDestroyWindow(void) { }
   virtual HRESULT DoCustomVerb(LONG lVerb) { return OLEOBJ_S_INVALIDVERB; }
   virtual BOOL   OnSetExtent(const SIZE* pSize) { return TRUE; }
   virtual BOOL   OnSpecialKey(LPMSG) { return FALSE; }
   virtual BOOL   OnGetPalette(HDC, LOGPALETTE **);
   virtual HRESULT OnQuickActivate(QACONTAINER *, DWORD *);
   virtual BOOL   InitializeNewState();
   virtual BOOL   AfterCreateWindow(void) { return TRUE; }
   virtual BOOL   OnGetRect(DWORD dvAspect, LPRECTL prcRect);

   //=--------------------------------------------------------------------------=
   // methods that various people internally will share.  not needed, however, by
   // any inherting classes.

   HRESULT     m_SaveToStream(IStream *pStream);
   HRESULT     LoadStandardState(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);
   HRESULT     LoadStandardState(IStream *pStream);
   HRESULT     SaveStandardState(IPropertyBag *pPropertyBag);
   HRESULT     SaveStandardState(IStream *pStream);

   //=--------------------------------------------------------------------------=
   // member variables we don't want anybody to get their hands on, including
   // inheriting classes

   IOleAdviseHolder *m_pOleAdviseHolder;        // IOleObject::Advise holder object
   IAdviseSink     *m_pViewAdviseSink;       // IViewAdvise sink for IViewObject2
   unsigned short   m_nFreezeEvents;            // count of freezes versus thaws

   // internal flags.   various other flags are visible to the end control class.

   unsigned m_fModeFlagValid:1;              // we stash the mode as much as possible
   unsigned m_fSaveSucceeded:1;              // did an IStorage save work correctly?
   unsigned m_fViewAdvisePrimeFirst: 1;         // for IViewobject2::setadvise
   unsigned m_fViewAdviseOnlyOnce: 1;           // for iviewobject2::setadvise
   unsigned m_fUsingWindowRgn:1;             // for SetObjectRects and clipping
   unsigned m_fRunMode:1;                    // are we in run mode or not?

   class CConnectionPoint : public IConnectionPoint {
public:
#ifdef _WIN64
      CONNECTDATA * m_rgSinks64;
#else
      IUnknown **m_rgSinks;
#endif
      // IUnknown methods
      //
      STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) ;
      STDMETHOD_(ULONG,AddRef)(THIS) ;
      STDMETHOD_(ULONG,Release)(THIS) ;

      // IConnectionPoint methods
      //
      STDMETHOD(GetConnectionInterface)(IID FAR* pIID);
      STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer FAR* FAR* ppCPC);
      STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie);
      STDMETHOD(Unadvise)(DWORD dwCookie);
      STDMETHOD(EnumConnections)(LPENUMCONNECTIONS FAR* ppEnum);

      void  DoInvoke(DISPID dispid, DISPPARAMS * pdispparam);
      void  DoOnChanged(DISPID dispid);
      BOOL  DoOnRequestEdit(DISPID dispid);
      HRESULT AddSink(void *, DWORD *);

      COleControl *m_pOleControl();
      CConnectionPoint(BYTE b){
         m_bType = b;
         m_cSinks = 0;
#ifdef _WIN64
         m_rgSinks64 = NULL;
         m_dwNextCookie = 1;
#else
         m_rgSinks = NULL;
#endif
      }
      ~CConnectionPoint();

private:
      BYTE   m_bType;
      short  m_cSinks;
#ifdef _WIN64
      DWORD  m_dwNextCookie;
	  DWORD  NextCookie();
	  IUnknown* CookieToSink( DWORD dwCookie );
#endif
   } m_cpEvents, m_cpPropNotify;

   // so they can get at some of our protected things, like AddRef, QI, etc.

   friend CConnectionPoint;
};

#endif // _CTRLOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\custmtab.h ===
#ifndef __CUSTMTAB_H__
#define __CUSTMTAB_H__

///////////////////////////////////////////////////////////
//
//
// CustmTab.h - CustomTab Proxy object. 
//
// This header defines the class which manages custom
// navigation panes.

// INavPaneUI Interface
#include "navui.h"

// Other nav pane related structures.
#include "navpane.h"

// The IHHWindowPane header file:
#include "HTMLHelp_.h"

///////////////////////////////////////////////////////////
//
// Forwards
//

///////////////////////////////////////////////////////////
//
// Constants
//


///////////////////////////////////////////////////////////
//
// CBookmarksNavPane
//
class CCustomNavPane : public INavUI
{
public:
    //---Construction
    CCustomNavPane (CHHWinType* pWinType);
    virtual ~CCustomNavPane () ;

public:
    //--- INavUI Interface functions.
   virtual BOOL Create(HWND hwndParent);
   virtual LRESULT OnCommand(HWND hwnd, UINT id, UINT uNotifiyCode, LPARAM lParam);
   virtual void ResizeWindow();
   virtual void HideWindow() ;
   virtual void ShowWindow() ;
   virtual void SetPadding(int pad) ;
   virtual void SetTabPos(int tabpos) ;

    // Set focus to the most expected control, usually edit combo.
    virtual void SetDefaultFocus() ;

    // Process accelerator keys.
    virtual bool ProcessMenuChar(HWND hwndParent, int ch) ;

    // Process WM_NOTIFY messages. Used by embedded Tree and List view controls.
    virtual LRESULT  OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam) ;

    // Process WM_DRAWITEM messages.
    virtual void OnDrawItem(UINT id, LPDRAWITEMSTRUCT pdis) ;

    // Seed the nav ui with a search term or keyword.
    virtual void Seed(LPCSTR pszSeed) ;

    virtual BOOL Synchronize(PSTR , CTreeNode* ) ;

    void OnVKListNotify(NMHDR* pNMHdr) {/*Not Implemented*/}

    //--- Public Functions.
public:
    HRESULT SetControlProgId(LPCOLESTR ProgId);

    //--- Public Static functions
public:
    // Registers the window class for this window.
    static void RegisterWindowClass() ;

private:
    //--- Helper Functions.
    void    SetFont (HFONT hfont) { m_hfont = hfont; }
    void    SaveCustomTabState() ;
    void    LoadCustomTabState() ;

    //int     GetAcceleratorKey(HWND hwndctrl) ;
    //int     GetAcceleratorKey(int ctrlid) {return GetAcceleratorKey(::GetDlgItem(m_hWnd, ctrlid)) ; }

protected:
    //--- Message Handler Functions
#if 0 
    void    OnTab(HWND hwndReceivedTab, BookmarkDlgItemInfoIndex index) ;
    void    OnArrow(HWND hwndReceivedTab, BookmarkDlgItemInfoIndex index, int key) ;
    bool    OnReturn(HWND hwndReceivedTab, BookmarkDlgItemInfoIndex /*index*/);
#endif

private:
    //--- Callbacks

    // Window Proc
    LRESULT CustomNavePaneProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) ;

    // Static Window Proc.
    static LRESULT WINAPI s_CustomNavePaneProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) ;


protected: 
    //--- Statics
   
private:
    //--- Member Functions.
    HWND        m_hWnd;
    HFONT    m_hfont;    // author-specified font to use for child windows
    int      m_padding;
    int      m_NavTabPos;   // location of parent tabs

    // Window handle to the embedded component.
    HWND m_hwndComponent ;

    // Holds a pointer to the wintype so we can send the WMP_HH_TAB_KEY message to it.
    CHHWinType* m_pWinType;

    // Pointer to the GUID.
    CLSID m_clsid ; 

    // Smart pointer to the IHHWindowPane interface on the component.
    CComPtr<IHHWindowPane>  m_spIHHWindowPane;
};

#endif //__CUSTMTAB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\darwin.cpp ===
// Copyright (C) 1997-1998 Microsoft Corporation. All rights reserved.

#include "header.h"
#include <msi.h>

extern HMODULE  g_hmodMSI;      // msi.dll module handle

static const char txtMsiProvideQualifiedComponent[] = "MsiProvideQualifiedComponentA";
static const char txtMsiDll[] = "Msi.dll";

UINT (WINAPI *pMsiProvideQualifiedComponent)(LPCSTR szCategory, LPCSTR szQualifier, DWORD dwInstallMode, LPSTR lpPathBuf, DWORD *pcchPathBuf);

/***************************************************************************

    FUNCTION:   FindDarwinURL

    PURPOSE:    Given a GUID and CHM filename, find the full path to the
                CHM file using Darwin.

    PARAMETERS:
        pszGUID
        pszChmFile
        cszResult

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        01-Dec-1997 [ralphw]

***************************************************************************/

BOOL FindDarwinURL(PCSTR pszGUID, PCSTR pszChmFile, CStr* pcszResult)
{
    if (!pMsiProvideQualifiedComponent) {
        if (!g_hmodMSI) {
            g_hmodMSI = LoadLibrary(txtMsiDll);
            ASSERT_COMMENT(g_hmodMSI, "Cannot load msi.dll");
            if (!g_hmodMSI)
                return FALSE;
        }
        (FARPROC&) pMsiProvideQualifiedComponent = GetProcAddress(g_hmodMSI,
            txtMsiProvideQualifiedComponent);
        ASSERT_COMMENT(pMsiProvideQualifiedComponent, "Cannot find the MsiProvideQualifiedComponent in msi.dll");
        if (!pMsiProvideQualifiedComponent)
            return FALSE;
    }
    char szPath[MAX_PATH];
    DWORD cb = sizeof(szPath);

	// Office passes in the LCID on the end of the GUID. Ick. Parse out the LCID.
	CStr szGUID(pszGUID) ;
	CStr szLCID;
	// Check last character for the ending bracket.
	int len = szGUID.strlen() ;
	if (szGUID.psz[len-1] != '}')
	{
		// No bracket. Assume we have a LCID.
		char* pLcid = strchr(szGUID.psz, '}') ;
		if (pLcid)
		{
			// Copy the LCID.
			pLcid++ ;
			szLCID = pLcid; 
			// Remove from the guid.
			*pLcid = '\0' ;
		}
	}
	else
	{
		ASSERT(0) ;
		return FALSE ;
	}

	// Prepend the LCID to the CHM file name.
	CStr szQualifier ;
	szQualifier = szLCID.psz ;
	szQualifier += "\\" ;
	szQualifier += pszChmFile ;

	// Ask for the file.
    if (pMsiProvideQualifiedComponent(szGUID, szQualifier/*pszChmFile*/, INSTALLMODE_EXISTING,
            szPath, &cb) != ERROR_SUCCESS)
        return FALSE;

    *pcszResult = szPath;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\custmtab.cpp ===
// Copyright (C) Microsoft Corporation 1997-1998, All Rights reserved.

///////////////////////////////////////////////////////////
//
//
// CustmTab.cpp - Implementation of the Custom Tab frame.
//
// This source implements the frame window which manages
// custom tabs. It mainly serves as a parent for the custom tab
// window.

///////////////////////////////////////////////////////////
//
// Include section
//
#include "header.h"

#include "strtable.h" // These headers were copied from search.cpp. Are they all needed?
#include "system.h"
#include "hhctrl.h"
#include "resource.h"
#include "secwin.h"
#include "htmlhelp.h"
#include "cpaldc.h"
#include "TCHAR.h"
#include "parserhh.h"
#include "collect.h"
#include "hhtypes.h"
#include "toc.h"
#include "contain.h"

// Our header file.
#include "custmtab.h"

// Common Control Macros
// #include <windowsx.h>

// The GUIDS --- PUT IN A SHARED LOCATION
#include "HTMLHelpId_.c"


///////////////////////////////////////////////////////////
//
//                  Constants
//
static const char txtCustomNavPaneWindowClass[] = "HH CustomNavPane";

///////////////////////////////////////////////////////////
//
// Static Member functions
//

///////////////////////////////////////////////////////////
//
// Non-Member helper functions.
//

///////////////////////////////////////////////////////////
//
//                  Construction
//
///////////////////////////////////////////////////////////
//
// CCustomNavPane();
//
CCustomNavPane::CCustomNavPane(CHHWinType* pWinType)
:   m_hWnd(NULL),
    m_hfont(NULL),
    m_padding(2),    // padding to put around the window
    m_pWinType(pWinType),
    m_hwndComponent(NULL)
{
    ASSERT(pWinType) ;

    m_NavTabPos = pWinType->tabpos ;

    // Save the prog id.
    m_clsid = CLSID_NULL;
}

///////////////////////////////////////////////////////////
//
//  ~CCustomNavPane
//
CCustomNavPane::~CCustomNavPane()
{
    //--- Persist Keywords in combo
    SaveCustomTabState() ;

    //--- Close down the component's pane.
    if (m_spIHHWindowPane.p)
    {
        HRESULT hr = m_spIHHWindowPane->ClosePane() ;
//        ASSERT(SUCCEEDED(hr)) ;
    }

    //--- CleanUp
    if (m_hfont)
    {
        ::DeleteObject(m_hfont);
    }

    if (m_hWnd)
    {
        ::DestroyWindow(m_hWnd) ;
    }

    //Don't free m_pTitleCollection
}

///////////////////////////////////////////////////////////
//
//              INavUI Interface functions.
//
///////////////////////////////////////////////////////////
//
// Create
//
BOOL
CCustomNavPane::Create(HWND hwndParent)
{
    bool bReturn = FALSE ;

    if (m_hWnd)
    {
        return TRUE ;
    }

    // Get the size of the parent.
    RECT rcParent;
    GetParentSize(&rcParent, hwndParent, m_padding, m_NavTabPos);

    // ---Create the frame window to hold the customtab dialog.
    m_hWnd  = CreateWindow(txtCustomNavPaneWindowClass,
                    NULL,
                    WS_CHILD | WS_VISIBLE,
                    rcParent.left, rcParent.top,
                    RECT_WIDTH(rcParent), RECT_HEIGHT(rcParent),
                    hwndParent, NULL, _Module.GetModuleInstance(), NULL);

    if (m_hWnd)
    {
        // Set the userdata to our this pointer.
        SetWindowLongPtr(m_hWnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));

        //--- Create the component.
        HRESULT hr = ::CoCreateInstance(m_clsid,
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        IID_IHHWindowPane,
                                        (void**)&m_spIHHWindowPane) ;
        if (SUCCEEDED(hr))
        {

            //--- Create the window.
            hr = m_spIHHWindowPane->CreatePaneWindow(m_hWnd,
                                                    0, 0,
                                                    RECT_WIDTH(rcParent), RECT_HEIGHT(rcParent),
                                                    &m_hwndComponent) ;
            if (SUCCEEDED(hr))
            {
                ASSERT(m_spIHHWindowPane.p) ;

                //--- Restore the persisted state.
                LoadCustomTabState() ;

                bReturn = TRUE;
            }
            else
            {
                //TODO: Cleanup.
            }
        }
        else {
            // BUGBUG: we now have an empty window. We shouldn't
            // have created this tab...

            return FALSE;
        }
    }

    return bReturn ;
}

///////////////////////////////////////////////////////////
//
// OnCommand
//
LRESULT
CCustomNavPane::OnCommand(HWND hwnd, UINT id, UINT NotifyCode, LPARAM lParam)
{
    return 0 ;
}

///////////////////////////////////////////////////////////
//
// ResizeWindow
//
void
CCustomNavPane::ResizeWindow()
{
    if (!::IsValidWindow(m_hWnd))
    {
		ASSERT(::IsValidWindow(m_hWnd)) ;
        return ;
    }

    // Resize to fit the client area of the parent.
    HWND hwndParent = GetParent(m_hWnd) ;
    ASSERT(::IsValidWindow(hwndParent)) ;

    //--- Get the size of the window
    RECT rcParent;
    GetParentSize(&rcParent, hwndParent, m_padding, m_NavTabPos);

    ::MoveWindow(m_hWnd, rcParent.left, rcParent.top,
        RECT_WIDTH(rcParent), RECT_HEIGHT(rcParent), FALSE);
    RECT rcChild;
    GetWindowRect(m_hWnd, &rcChild);
    MoveClientWindow(m_hWnd, m_hwndComponent, &rcChild, TRUE);
    // ::MoveWindow(m_hwndComponent, rcChild.left, rcChild.top,
    //    RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), TRUE);

#if 0
    //--- Move and size the dialog box itself.
    ::SetWindowPos( m_hWnd, NULL, rcParent.left, rcParent.top,
                    rcParent.right-rcParent.left,
                    rcParent.bottom-rcParent.top,
                    SWP_NOZORDER | SWP_NOOWNERZORDER);

    //---Fix the painting bugs. However, this is a little on the flashy side.
    ::InvalidateRect(m_hWnd, NULL, TRUE) ;
#endif
}


///////////////////////////////////////////////////////////
//
// HideWindow
//
void
CCustomNavPane::HideWindow()
{
    if (::IsValidWindow(m_hWnd))
    {
        ::ShowWindow(m_hWnd, SW_HIDE) ;
    }
}


///////////////////////////////////////////////////////////
//
// ShowWindow
//
void
CCustomNavPane::ShowWindow()
{
    if (::IsValidWindow(m_hWnd))
    {
         // Show the window.
        ::ShowWindow(m_hWnd, SW_SHOW) ;
    }
}


///////////////////////////////////////////////////////////
//
// SetPadding
//
void
CCustomNavPane::SetPadding(int pad)
{
    m_padding = pad;
}


///////////////////////////////////////////////////////////
//
// SetTabPos
//
void
CCustomNavPane::SetTabPos(int tabpos)
{
    m_NavTabPos = tabpos;
}



///////////////////////////////////////////////////////////
//
// SetDefaultFocus --- Set focus to the most expected control, usually edit combo.
//
void
CCustomNavPane::SetDefaultFocus()
{
//TODO: Needs to be implemented
    if (IsWindow(m_hwndComponent))
    {
        SetFocus(m_hwndComponent) ;
    }
}

///////////////////////////////////////////////////////////
//
// ProcessMenuChar --- Process accelerator keys.
//
bool
CCustomNavPane::ProcessMenuChar(HWND hwndParent, int ch)
{
    bool iReturn = FALSE ;
/*
    for (int i = 0 ; i < c_NumDlgItems  ; i++)
    {
        if (m_aDlgItems[i].m_accelkey == ch)
        {
            if (m_aDlgItems[i].m_Type == ItemInfo::Button)
            {
                // Its a button so do the command.
                OnCommand(hwndParent, m_aDlgItems[i].m_id, BN_CLICKED, 0) ;
            }
            else
            {
                // Set focus.
                ::SetFocus(m_aDlgItems[i].m_hWnd) ;
            }

            // Found it!
            iReturn = TRUE ;
            // Finished
            break ;
        }
    }
*/
    return iReturn;
}

///////////////////////////////////////////////////////////
//
// OnNotify --- Process WM_NOTIFY messages. Used by embedded Tree and List view controls.
//
LRESULT
CCustomNavPane::OnNotify(HWND hwnd, WPARAM idCtrl, LPARAM lParam)
{
    //TODO: Implement
    return 0 ;
}

///////////////////////////////////////////////////////////
//
// OnDrawItem --- Process WM_DRAWITEM messages.
//
void
CCustomNavPane::OnDrawItem(UINT id, LPDRAWITEMSTRUCT pdis)
{
}

///////////////////////////////////////////////////////////
//
// Seed --- Seed the nav ui with a search term or keyword.
//
void
CCustomNavPane::Seed(LPCSTR pszSeed)
{
}


///////////////////////////////////////////////////////////
//
//  Synchronize
//
BOOL
CCustomNavPane::Synchronize(PSTR /*pNotUsed*/, CTreeNode* /*pNotUsed2*/)
{
    // TODO: Forward to imbedded window.
    return FALSE ;
}
///////////////////////////////////////////////////////////
//
//              Helper Functions.
//
///////////////////////////////////////////////////////////
//
// SaveCustomTabState --- Persists the tab to the storage
// Do it by GUID...
//
//
void
CCustomNavPane::SaveCustomTabState()
{
    //REVIEW: We should save this based on the GUID of the navpane.
    // Once we open the guid section they can party on it.
}

///////////////////////////////////////////////////////////
//
// LoadCustomTabState- Loads the results list from the storage
//
void
CCustomNavPane::LoadCustomTabState()
{
}

///////////////////////////////////////////////////////////
//
// GetAcceleratorKey - Find the accelerator key from the ctrl.
//
#if 0 //-------DISABLED
int
CCustomNavPane::GetAcceleratorKey(HWND hwndctrl)
{
    int iReturn = 0 ;
    char text[256] ;
    ::GetWindowText(hwndctrl, text, 256) ;

    int len = strlen(text) ;
    if (len != 0)
    {
        // Find the '&' key.
        char* p = strchr(text, '&') ;
        if (p < text + len -1) // Make sure that it's not the last char.
        {
            iReturn = tolower(*(p+1)) ;
        }
    }
    return iReturn ;
}
#endif

///////////////////////////////////////////////////////////
//
//              Public Functions.
//
HRESULT
CCustomNavPane::SetControlProgId(LPCOLESTR ProgId)
{
    HRESULT hr = E_FAIL ;
    // Check string.
    ASSERT(ProgId) ;

    // Covert ProgId to CLSID.
    if (m_clsid == CLSID_NULL)
    {
        if (SUCCEEDED(CLSIDFromProgID(ProgId, &m_clsid)))
        {
            hr = S_OK ;
        }
    }
    else
    {
        // Already initialized
        hr = S_FALSE ;
    }
    return hr;
}

///////////////////////////////////////////////////////////
//
//                  Message Handlers
//

///////////////////////////////////////////////////////////
//
// OnTab - Handles pressing of the tab key.
//
#if 0 //-------DISABLED
void
CCustomNavPane::OnTab(HWND hwndReceivedTab, BookmarkDlgItemInfoIndex  /*index*/)
{
    //if (index == c_NumDlgItems) --- caller doesn't know the index.
    ASSERT(::IsValidWindow(hwndReceivedTab)) ;

    //--- Is the shift key down?
    BOOL bPrevious = (GetKeyState(VK_SHIFT) < 0) ;

    //---Are we the first or last control?
    if ((bPrevious && hwndReceivedTab == m_aDlgItems[c_TopicsList].m_hWnd) || // The c_KeywordCombo control is the first control, so shift tab goes to the topic window.
        (!bPrevious && hwndReceivedTab == m_aDlgItems[c_AddBookmarkBtn].m_hWnd)) // The c_TitlesOnlyCheck is the last control, so tab goes to the topic window.
    {

        PostMessage(m_pWinType->GetHwnd(), WMP_HH_TAB_KEY, 0, 0);
    }
    else
    {
        //--- Move to the next control .
        // Get the next tab item.
        HWND hWndNext = GetNextDlgTabItem(m_hWnd, hwndReceivedTab, bPrevious) ;
        // Set focus to it.
        ::SetFocus(hWndNext) ;
    }
}
#endif

///////////////////////////////////////////////////////////
//
// OnArrow
//
#if 0 //-------DISABLED
void
CCustomNavPane::OnArrow(HWND hwndReceivedTab, BookmarkDlgItemInfoIndex  /*index*/, int key)
{
    //if (index == c_NumDlgItems) --- caller doesn't know the index.

    ASSERT(::IsValidWindow(hwndReceivedTab)) ;

    BOOL bPrevious = FALSE ;
    if (key == VK_LEFT || key == VK_UP)
    {
        bPrevious = TRUE ;
    }

    // Get the next tab item.
    HWND hWndNext = GetNextDlgGroupItem(m_hWnd, hwndReceivedTab, bPrevious) ;
    // Set focus to it.
    ::SetFocus(hWndNext) ;
}
#endif

///////////////////////////////////////////////////////////
//
// OnReturn - Default handling of the return key.
//
#if 0 //-------DISABLED
bool
CCustomNavPane::OnReturn(HWND hwndReceivedTab, BookmarkDlgItemInfoIndex  /*index*/)
{
    //if (index == c_NumDlgItems) --- caller doesn't know the index.

    // Do the default button action.
    // Always do a search topic, if its enabled.
    if (::IsWindowEnabled(m_aDlgItems[c_DisplayBtn].m_hWnd))
    {
        OnDisplay();
        return TRUE ;
    }
    else
    {
        return FALSE ;
    }

}
#endif

///////////////////////////////////////////////////////////
//
//              Callback Functions.
//
///////////////////////////////////////////////////////////
//
// Member function Window Proc
//
LRESULT
CCustomNavPane::CustomNavePaneProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
#if 0
    switch (msg)
    {
    case WM_PAINT:
        //TODO: REMOVE THIS IS TEST CODE!
        // Draw an edige on the left side of the size bar.
        {
        PAINTSTRUCT ps;
        HDC hdcPaint = BeginPaint(hwnd, &ps) ;
                //Draw() ;
                HDC hdc = GetDC(hwnd) ;
                    // get the rectangle to draw on.
                    RECT rc ;
                    GetClientRect(hwnd, &rc) ;

                    // Draw the edge.
                    POINT dumb;
                    MoveToEx(hdc, rc.left, rc.top, &dumb);
                    LineTo(hdc, rc.right, rc.bottom) ;
                // Clean up.
                ReleaseDC(hwnd, hdc) ;

        EndPaint(hwnd, &ps) ;
        }
        break;
    default:
         return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
#endif

    return DefWindowProc(hwnd, msg, wParam, lParam);

};
///////////////////////////////////////////////////////////
//
// Static Window Proc
//
LRESULT WINAPI
CCustomNavPane::s_CustomNavePaneProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CCustomNavPane* pThis = reinterpret_cast<CCustomNavPane*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    if (pThis)
        return pThis->CustomNavePaneProc(hwnd, msg, wParam, lParam) ;
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);
}

///////////////////////////////////////////////////////////
//
//                  Static Functions
//
///////////////////////////////////////////////////////////
//
// RegisterWindowClass
//
void
CCustomNavPane::RegisterWindowClass()
{
    WNDCLASS wc;

    ZeroMemory(&wc, sizeof(WNDCLASS));  // clear all members

    wc.hInstance = _Module.GetModuleInstance();
    wc.hbrBackground = (HBRUSH) COLOR_WINDOW;
    wc.lpfnWndProc = s_CustomNavePaneProc;
    wc.lpszClassName = txtCustomNavPaneWindowClass;
    wc.hCursor = LoadCursor(NULL, IDC_SIZEWE);

    VERIFY(RegisterClass(&wc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\dibcls.h ===
#ifndef __DIBCLASSES_H
#define __DIBCLASSES_H


//
//	class CDibFile
//
class CDibFile 
{
public:
	CDibFile();
	~CDibFile();
	
	HRESULT	GetFileHeader(IStream *);
	HRESULT	GetInfoHeader(IStream *);

	DWORD	HeaderSize()			{ return(m_headerSize); }
	DWORD	CalcImageSize();

	operator BITMAPINFO * ()		{ return(m_bmi.p); }
	operator BITMAPINFOHEADER * ()	{ return(&m_bmi.p->bmiHeader); }
	
private:
	
	DWORD	m_headerSize;
	union 
	{
		BITMAPINFO *	p;
		unsigned char *	bytes;
	} m_bmi;
};

class CDibSection
{
public:
	CDibSection();
	~CDibSection();
	
	HRESULT Create	( CDibFile& );
	HRESULT	Setup	( HDC basedOnThisDC);
	HRESULT ReadFrom( IStream * strm, DWORD amount );
	HRESULT	PaintTo	( HDC hdc, int x = 0, int y = 0 );
	HRESULT	GetSize	( SIZEL &sz);

	DWORD	ImageSize() { return(m_imageSize); }
	void	ImageSize(DWORD dw) { m_imageSize = dw; }

	operator HANDLE() { return m_handle; }

	unsigned char * Base() { return(m_bitsBase); }

private:
	unsigned char *		m_bitsBase;
	unsigned char *		m_current;
	HDC					m_memDC;
	HBITMAP				m_handle;
	HBITMAP				m_oldBitmap;
	LONG				m_h;
	LONG				m_w;
	DWORD				m_imageSize;
};



#endif __DIBCLASSES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\dibcls.cpp ===
#include "header.h"

#include "DibCls.H"
#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)
#include <urlmon.h>

#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)

//=--------------------------------------------------------------------------=
// DIB Utitilty Classes
//=--------------------------------------------------------------------------=
// Not wholey generic but getting there...
//
// Notes:
//
CDibFile::CDibFile()
{
	m_headerSize = 0;
	m_bmi.p = 0;
}

CDibFile::~CDibFile()
{
	if( m_bmi.p )
		delete m_bmi.p;
}


DWORD CDibFile::CalcImageSize()
{
	DWORD & dw = m_bmi.p->bmiHeader.biSizeImage;
	if( dw == 0)
        dw = WIDTHBYTES((DWORD)m_bmi.p->bmiHeader.biWidth *
                m_bmi.p->bmiHeader.biBitCount) * m_bmi.p->bmiHeader.biHeight;

	return(dw);
}

HRESULT CDibFile::GetInfoHeader( IStream * strm )
{
	HRESULT hr = S_OK;
	m_bmi.bytes = new unsigned char[ m_headerSize ];

	if( !m_bmi.bytes )
		hr = E_OUTOFMEMORY;

	if( SUCCEEDED(hr) )
		hr = strm->Read(m_bmi.bytes,m_headerSize,0);

	if( SUCCEEDED(hr) )
		CalcImageSize();

	return(hr);
}

HRESULT CDibFile::GetFileHeader(IStream * strm)
{
	BITMAPFILEHEADER	bmfh;

	HRESULT	hr = strm->Read(&bmfh,sizeof(bmfh),0);
	
	if( SUCCEEDED(hr) && (bmfh.bfType != 0x4d42 ))
		hr = E_UNEXPECTED;

	if( SUCCEEDED(hr) )
		m_headerSize = bmfh.bfOffBits - sizeof(bmfh);

	return(hr);
}


CDibSection::CDibSection()
{
	m_bitsBase	= 0;
	m_current	= 0;
	m_memDC		= 0;
	m_handle	=
	m_oldBitmap = 0;
	m_w			=
	m_h			= 32;  // totally arbitrary
}

CDibSection::~CDibSection()
{
	if( m_memDC )
	{
		if( m_oldBitmap )
			::SelectObject( m_memDC, m_oldBitmap );

		::DeleteDC(m_memDC);
	}

	if( m_handle )
		::DeleteObject(m_handle);

}
	
	
HRESULT CDibSection::Create(CDibFile& dibFile)
{
	HRESULT				hr		= S_OK;
	BITMAPINFOHEADER *	bmih	= dibFile;	// will convert itself

	m_handle = ::CreateDIBSection(
					m_memDC,				// handle to device context
					dibFile,				// pointer to structure containing bitmap size,
											//	format, and color data
					DIB_RGB_COLORS,			// color data type indicator: RGB values or
											//	palette indices
					(void **)&m_bitsBase,	// pointer to variable to receive a pointer
											//	to the bitmap's bit values
					0,						// optional handle to a file mapping object
					0						// offset to the bitmap bit values
											//	within the file mapping object
					);

	if( !m_handle )
		hr = E_FAIL;
	
	if( SUCCEEDED(hr) )
	{
		m_oldBitmap = ::SelectObject( m_memDC, m_handle );
		
		if( !m_oldBitmap )
			hr = E_FAIL;
	}

	if( SUCCEEDED(hr) )
	{
		m_current = m_bitsBase;

		m_w = bmih->biWidth;
		m_h = bmih->biHeight;
		
		if( m_h < 0 )
			m_h *= -1;
	}
		
	return(hr);
}

HRESULT CDibSection::ReadFrom( IStream * strm, DWORD amount )
{
   DWORD    dwRead      = 0;
   DWORD    dwReadTotal = 0;
   HRESULT  hr;

   do
   {
      hr = strm->Read(m_current,amount,&dwRead);

   	if( SUCCEEDED(hr) || hr == E_PENDING )
      {
         m_current += dwRead;
         dwReadTotal += dwRead;
      }
   }
   while ( (hr == S_OK) && (dwReadTotal <= amount) );

   return (hr);
}


HRESULT CDibSection::Setup(HDC hdc)
{
	m_memDC = ::CreateCompatibleDC(hdc);

	return( m_memDC ? NOERROR : E_FAIL );
}


HRESULT	CDibSection::PaintTo(HDC hdc, int x, int y)
{
	BOOL b = BitBlt(
				 hdc,		// handle to destination device context
				 x,			// x-coordinate of destination rectangle's upper-left corner
				 y,			// x-coordinate of destination rectangle's upper-left corner
				 m_w,		// width of destination rectangle
				 m_h,		// height of destination rectangle
				 m_memDC,	// handle to source device context
				 0,			// x-coordinate of source rectangle's upper-left corner
				 0,			// y-coordinate of source rectangle's upper-left corner
				 SRCCOPY	// raster operation code
				);

	return( b ? NOERROR : E_FAIL );
}

HRESULT	CDibSection::GetSize(SIZEL &sz)
{
	sz.cx = m_w;
	sz.cy = m_h;

	return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\dispids.h ===
// Copyright 1996-1997	Microsoft Corporation. All Rights Reserved.

#ifndef _DISPIDS_H_
#define _DISPIDS_H_

#define DISPID_ONCLICK 0	// default
#define DISPID_BMPPATH 1
#define DISPID_HHCFILE 2
#define DISPID_HHKFILE 3

#define DISPID_METHOD_SYNC_URL	4
#define DISPID_METHOD_CLICK 	5
#define DISPID_METHOD_PRINT 	6
#define DISPID_METHOD_TCARD 	7
#define DISPID_METHOD_TXT_POPUP 8
#define DISPID_METHOD_HHCLICK   9

#endif // _DISPIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\dwinvers.h ===
#define vszMakeDate	"January 8, 1996\0\0"
#define vszMakeVers	"Version 2508 - DEBUG - ntfs-e\0\0"
#define vszVersNum	"2508\0"
#define vszVersNumAll	"5.00.2508\0"
#define vusVersNuml2	 8
#define vusVersNumf2	25
#define vszCopyright	"Copyright  1987-1995 Microsoft Corp.\0\0"
#define VBA_VERHI	0x30000
#define VBA_VERLO	0x170F
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\debug.h ===
//=--------------------------------------------------------------------------=
// Debug.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the various macros and the like which are only useful in DEBUG
// builds
//
#ifndef _DEBUG_H_

//=---------------------------------------------------------------------------=
// all the things required to handle our ASSERT mechanism
//=---------------------------------------------------------------------------=
//
#if DEBUG

// Function Prototypes
//
VOID DisplayAssert(LPSTR pszMsg, LPSTR pszAssert, LPSTR pszFile, UINT line);

// Macros
//
// *** Include this macro at the top of any source file using *ASSERT*() macros ***
//
#define SZTHISFILE	static char _szThisFile[] = __FILE__;


// our versions of the ASSERT and FAIL macros.
//
#define ASSERT(fTest, szMsg)                                \
    if (!(fTest))  {                                        \
        static char szMsgCode[] = szMsg;                    \
        static char szAssert[] = #fTest;                    \
        DisplayAssert(szMsgCode, szAssert, _szThisFile, __LINE__); \
    }

#define FAIL(szMsg)                                         \
        { static char szMsgCode[] = szMsg;                    \
        DisplayAssert(szMsgCode, "FAIL", _szThisFile, __LINE__); }



// macro that checks a pointer for validity on input
//
#define CHECK_POINTER(val) if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) return E_POINTER

#else  // DEBUG

#define SZTHISFILE
#define ASSERT(fTest, err)
#define FAIL(err)

#define CHECK_POINTER(val)
#endif	// DEBUG




#define _DEBUG_H_
#endif // _DEBUG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\debug.cpp ===
//=--------------------------------------------------------------------------=
// Debug.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains various methods that will only really see any use in DEBUG builds
//

#include "header.h"

#ifdef _DEBUG

#include <stdlib.h>

//=--------------------------------------------------------------------------=
// Private Constants
//---------------------------------------------------------------------------=
//
static const char szFormat[]  = "%s\nFile %s, Line %d";
static const char szFormat2[] = "%s\n%s\nFile %s, Line %d";

#define _SERVERNAME_ "ActiveX Framework"

static const char szTitle[]  = _SERVERNAME_ " Assertion  (Abort = UAE, Retry = INT 3, Ignore = Continue)";


//=--------------------------------------------------------------------------=
// Local functions
//=--------------------------------------------------------------------------=
int NEAR _IdMsgBox(LPSTR pszText, LPCSTR pszTitle, UINT mbFlags);

//=--------------------------------------------------------------------------=
// DisplayAssert
//=--------------------------------------------------------------------------=
// Display an assert message box with the given pszMsg, pszAssert, source
// file name, and line number. The resulting message box has Abort, Retry,
// Ignore buttons with Abort as the default.  Abort does a FatalAppExit;
// Retry does an int 3 then returns; Ignore just returns.
//
VOID DisplayAssert
(
    LPSTR	 pszMsg,
    LPSTR	 pszAssert,
    LPSTR	 pszFile,
    UINT	 line
)
{
    char	szMsg[250];
    LPSTR	lpszText;

    lpszText = pszMsg;		// Assume no file & line # info

    // If C file assert, where you've got a file name and a line #
    //
    if (pszFile) {

        // Then format the assert nicely
        //
        wsprintf(szMsg, szFormat, (pszMsg&&*pszMsg) ? pszMsg : pszAssert, pszFile, line);
        lpszText = szMsg;
    }

    // Put up a dialog box
    //
    switch (_IdMsgBox(lpszText, szTitle, MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SYSTEMMODAL)) {
        case IDABORT:
            FatalAppExit(0, lpszText);
            return;

        case IDRETRY:
            // call the win32 api to break us.
            //
#ifdef _DEBUG
            DebugBreak();
#endif
            return;
    }

    return;
}


//=---------------------------------------------------------------------------=
// Beefed-up version of WinMessageBox.
//=---------------------------------------------------------------------------=
//
int NEAR _IdMsgBox
(
    LPSTR	pszText,
    LPCSTR	pszTitle,
    UINT	mbFlags
)
{
    HWND hwndActive;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags);

    return id;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\fs.cpp ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#include "header.h"

#include "fs.h"

static const WCHAR txtwUncompressed[] =  L"uncompressed";

CFileSystem::CFileSystem()
{
   m_pITStorage    = NULL;
   m_pStorage      = NULL;
   m_szPathName[0] = 0;
}

CFileSystem::~CFileSystem()
{
  ReleaseObjPtr(m_pStorage);
  ReleaseObjPtr(m_pITStorage);
}

HRESULT CFileSystem::Init(void)
{
   if (! m_pITStorage) {
      IClassFactory* pICFITStorage;

      HRESULT hr = CoGetClassObject(CLSID_ITStorage, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **) &pICFITStorage);

      if (!SUCCEEDED(hr))
         return hr;

      hr = pICFITStorage->CreateInstance(NULL, IID_ITStorage,(void **) &m_pITStorage);
      ReleaseObjPtr( pICFITStorage );

      if (!SUCCEEDED(hr))
         return hr;

   }
   return S_OK;
}

typedef struct tagITSControlData
{
   UINT cdwFollowing;          // Must be 6 or 13
   DWORD cdwITFS_Control;      // Must be 5
   DWORD dwMagicITS;           // Must be MAGIC_ITSFS_CONTROL (see below)
   DWORD dwVersionITS;         // Must be 1
   DWORD cbDirectoryBlock;     // Size in bytes of directory blocks (Default is 8192)
   DWORD cMinCacheEntries;     // Least upper bound on the number of directory blocks
                               // which we'll cache in memory. (Default is 20)
   DWORD fFlags;               // Control bit flags (see below).
                               // Default value is fDefaultIsCompression.
   UINT  cdwControlData;       // Must be 6
   DWORD dwLZXMagic;           // Must be LZX_MAGIC (see below)
   DWORD dwVersion;            // Must be 2
   DWORD dwMulResetBlock;      // Number of blocks between compression resets.  (Default: 4)
   DWORD dwMulWindowSize;      // Maximum number of blocks kept in data history (Default: 4)
   DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
   DWORD dwOptions;            // Option flags (Default: fOptimizeCodeStreams)
} ITCD;

HRESULT CFileSystem::Create( PCSTR pszPathName )
{
   HRESULT hr;
   ITCD itcd;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   itcd.cdwFollowing      = 13;
   itcd.cdwITFS_Control   = 5;
   itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
   itcd.dwVersionITS      = 1;
   itcd.cbDirectoryBlock  = 4096;     // default = 8192
   itcd.cMinCacheEntries  = 10;       // default = 20
   itcd.fFlags            = 1;        // 0 == Uncompressed, 1 == Compressed.
   itcd.cdwControlData        = 6;
   itcd.dwLZXMagic            = LZX_MAGIC;
   itcd.dwVersion             = 2;
   itcd.dwMulResetBlock       = 2;    // Default = 4
   itcd.dwMulWindowSize       = 2;    // Default = 4
   itcd.dwMulSecondPartition  = 1;    // Default = 2
   itcd.dwOptions             = 0;    // Default = fOptimizeCodeStreams

   m_pITStorage->SetControlData(PITS_Control_Data(&itcd));

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgCreateDocfile( (LPCWSTR) wsz, STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return S_OK;
}

// NOTE: The below function is required for the ITIR full-text indexer to
//     initialize.  I'm working to find out why this is and what impact
//     the below has on the file system.
//
HRESULT CFileSystem::CreateUncompressed( PCSTR pszPathName )
{
   HRESULT hr;
   ITCD itcd;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   itcd.cdwFollowing      = 6;
   itcd.cdwITFS_Control   = 5;
   itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
   itcd.dwVersionITS      = 1;
   itcd.cbDirectoryBlock  = 8192;     // default = 8192
   itcd.cMinCacheEntries  = 20;        // default = 20
   itcd.fFlags            = 0;        // 0 == Uncompressed, 1 == Compressed.

   m_pITStorage->SetControlData(PITS_Control_Data(&itcd));

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgCreateDocfile( (LPCWSTR) wsz, STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CFileSystem::Open(PCSTR pszPathName, DWORD dwAccess)
{
   HRESULT hr = S_OK;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   // force access modes
   if( (dwAccess & STGM_WRITE) || (dwAccess & STGM_READWRITE) ) {
     dwAccess &= ~STGM_WRITE;
     dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     dwAccess |= STGM_SHARE_DENY_WRITE;

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgOpenStorage( (LPCWSTR) wsz, NULL, dwAccess, NULL, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return hr;
}

HRESULT CFileSystem::Compact(LPCSTR pszPathName)
{
   WCHAR wszPathName[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, wszPathName, sizeof(wszPathName));
   m_pITStorage->Compact(wszPathName, COMPACT_DATA_AND_PATH);

   return S_OK;
}

HRESULT CFileSystem::Close()
{
   ReleaseObjPtr(m_pStorage);

   return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Here are a set of "sub" file I/O calls.
//
//
CSubFileSystem::CSubFileSystem(CFileSystem* pFS)
{
   m_pFS = pFS;
   m_pStorage = NULL;
   m_pStream = NULL;
   m_szPathName[0] = 0;
}

CSubFileSystem::~CSubFileSystem()
{
   if ( m_pStorage && (m_pStorage != m_pFS->m_pStorage) )
      ReleaseObjPtr(m_pStorage);

   ReleaseObjPtr(m_pStream);
}

HRESULT CSubFileSystem::CreateSub(PCSTR pszPathName)
{
   PCSTR pszFilePortion;
   HRESULT hr;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   if ((pszFilePortion = FindFilePortion(pszPathName)) && pszFilePortion > pszPathName)
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';

      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);

      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage);
      if (!SUCCEEDED(hr) || !m_pStorage) // storage didn't exist, so create it
         hr = m_pFS->m_pStorage->CreateStorage(wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage);
      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = m_pStorage->CreateStream(wszStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSub(PCSTR pszPathName)
{
   PCSTR pszFilePortion;
   HRESULT hr;
   IStorageITEx* pIStorageEx;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   if ((pszFilePortion = FindFilePortion(pszPathName)) && pszFilePortion > pszPathName)
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';
      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);
      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage);
      if (!SUCCEEDED(hr) || !m_pStorage) // storage didn't exist, so create it
         hr = m_pFS->m_pStorage->CreateStorage(wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage);
      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }

   if ( !(SUCCEEDED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx))) )
      pIStorageEx = (IStorageITEx*)m_pStorage;  // BUGBUG the QI call above should work!

   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = pIStorageEx->CreateStreamITEx(wszStream, txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream);
   ReleaseObjPtr(pIStorageEx);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

HRESULT CSubFileSystem::CreateSystemFile(PCSTR pszPathName)
{
   m_pStorage = m_pFS->m_pStorage;
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wszStream, MAX_PATH);
   HRESULT hr = m_pStorage->CreateStream(wszStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSystemFile(PCSTR pszPathName)
{
   IStorageITEx* pIStorageEx;
   HRESULT hr;

   m_pStorage = m_pFS->m_pStorage;

   if ( !(SUCCEEDED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx))) )
      pIStorageEx = (IStorageITEx*)m_pStorage;  // BUGBUG the QI call above should work!

   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wszStream, MAX_PATH);
   hr = pIStorageEx->CreateStreamITEx(wszStream, txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream);
   ReleaseObjPtr(pIStorageEx);
   if (!SUCCEEDED(hr))
   {
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CSubFileSystem::OpenSub(PCSTR pszPathName, DWORD dwAccess)
{
   PCSTR pszFilePortion;
   HRESULT hr;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   // force access modes
   if( (dwAccess & STGM_WRITE) || (dwAccess & STGM_READWRITE) ) {
     dwAccess &= ~STGM_WRITE;
     dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     dwAccess |= STGM_SHARE_DENY_WRITE;

   if ((pszFilePortion = FindFilePortion(pszPathName)) &&
         pszFilePortion > pszPathName + 2) // +2 to support / && ./
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';
      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);
      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, dwAccess, NULL, 0, &m_pStorage);

      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage ? m_pFS->m_pStorage : m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = m_pStorage->OpenStream(wszStream, NULL, dwAccess, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

ULONG CSubFileSystem::WriteSub(const void* pData, int cb)
{
   if ( !m_pStorage || !m_pStream )
      return (ULONG) -1;

   ULONG cbWritten;

   HRESULT hr = m_pStream->Write(pData, cb, &cbWritten);

   if (!SUCCEEDED(hr) || (cbWritten != (ULONG)cb) )
   {
      return (ULONG) -1;
   }
   // REVIEW: 30-May-1997  [ralphw] Why are we returning this? We fail if
   // we don't write cb bytes.
   return cbWritten;
}

/*
 * iOrigin:
 *    0 = Seek from beginning.
 *    1 = Seek from current.
 *    2 = Seek from end.
 */
ULONG CSubFileSystem::SeekSub(int cb, int iOrigin)
{
   LARGE_INTEGER liCount = {0,0};
   ULARGE_INTEGER liNewPos;

   if ( !m_pStorage || !m_pStream )
      return (ULONG) -1;

   liCount.LowPart = cb;
   HRESULT hr =  m_pStream->Seek(liCount, iOrigin, &liNewPos);

   if (!SUCCEEDED(hr) )
   {
      return (ULONG) -1;
   }
   return liNewPos.LowPart;
}

//
// Pre-allocate the size of the stream.
//

HRESULT CSubFileSystem::SetSize(unsigned uSize)
{
   ULARGE_INTEGER liSize = {0,0};
   HRESULT hr;

   if ( !m_pStorage || !m_pStream )
      return E_FAIL;

   liSize.LowPart = uSize;
   hr =  m_pStream->SetSize(liSize);

   if (!SUCCEEDED(hr) )
   {
      return (ULONG) -1;
   }
   return hr;
}

//
// Delete substorage.
//
HRESULT
CSubFileSystem::DeleteSub()
{
    if (m_pStorage)
    {
        if (m_pStream)
        {
            // Release the stream.
            ReleaseObjPtr(m_pStream) ;
        }

        // Now delete the storage.
        WCHAR element[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, m_szPathName, -1, (PWSTR) element, MAX_PATH);

        HRESULT hr = m_pStorage->DestroyElement(element) ;
        if (SUCCEEDED(hr))
        {
            // Get back to the constructor state.
            if ( m_pStorage && (m_pStorage != m_pFS->m_pStorage) )
            {
                ReleaseObjPtr(m_pStorage);
            }
            return S_OK ;
        }
    }
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\fs.h ===
// Copyright  1997-1997  Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _FS_H_
#define _FS_H_

#include <unknwn.h>
#include "msitstg.h"

#ifdef ReleaseObjPtr
#undef ReleaseObjPtr
#endif
#define ReleaseObjPtr(pObj) \
{                           \
  if( pObj )                \
  {                         \
    pObj->Release();        \
    pObj= NULL;             \
  }                         \
}

//
// Sub-File System
//
class CSubFileSystem
{

public:
   CSubFileSystem(class CFileSystem* pfs);
   ~CSubFileSystem();

   HRESULT CreateSub(PCSTR pszPathName);
   HRESULT CreateUncompressedSub(PCSTR pszPathName);
   HRESULT OpenSub(PCSTR pszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE));
   ULONG WriteSub(const void* pData, int cb);
   ULONG SeekSub(int cb, int iOrigin);
   HRESULT CreateSystemFile(PCSTR pszPathName);
   HRESULT CreateUncompressedSystemFile(PCSTR pszPathName);
   HRESULT SetSize(unsigned uSize);
   HRESULT DeleteSub() ;

   inline HRESULT ReadSub(void* pData, ULONG cb, ULONG* pcbRead) {
      return m_pStream->Read(pData, cb, pcbRead);
   }

   inline ULONG GetUncompressedSize(void) { return SeekSub(0,2); }

   inline HRESULT Stat(STATSTG *pstatstg, DWORD grfStatFalg)
   {
      return m_pStream->Stat(pstatstg,grfStatFalg);
   }

   inline HRESULT CopyTo(IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER* pcbWritten)
   {
      return m_pStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
   }

   inline IStream * GetStream(void)
   {
      return m_pStream;
   }

   inline IStorage* GetITStorageDocObj(void) const
   {
      return m_pStorage;
   }

private:
   class CFileSystem* m_pFS;
   IStorage*          m_pStorage;
   IStream*           m_pStream;
   char               m_szPathName[MAX_PATH]; // Needed for delete.
};

//
// File System
//
class CFileSystem
{
   friend class CSubFileSystem;

public:
   CFileSystem();
   ~CFileSystem();

   HRESULT Init(void);
   HRESULT Create( PCSTR pszPathName );
   HRESULT CreateUncompressed( PCSTR pszPathName );
   HRESULT Open( PCSTR pszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE));
   HRESULT Compact(LPCSTR lpszFileName);
   HRESULT Close(void);

   inline HRESULT GetPathName( LPSTR pszPathName ) { strcpy(pszPathName, m_szPathName); return S_OK; }

   inline IITStorage* GetITStorageObj(void) const
   {
      return m_pITStorage;
   }

   inline IStorage* GetITStorageDocObj(void) const
   {
      return m_pStorage;
   }

private:
   IITStorage*   m_pITStorage;
   IStorage*     m_pStorage;
   char          m_szPathName[MAX_PATH];

};

#endif // _FS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\fsclient.cpp ===
// Copyright 1997  Microsoft Corporation.  All Rights Reserved.

#include "header.h"
#include "fsclient.h"
#include "sitemap.h"

static const UINT CSTREAM_BUF_SIZE = (4 * 1024);

CFSClient::CFSClient()
{
    ClearMemory(this, sizeof(CFSClient));
}

CFSClient::CFSClient(CFileSystem* pFS, PCSTR pszSubFile)
{
    ClearMemory(this, sizeof(CFSClient));
    m_pFS = pFS;
    m_fNoDeleteFS = TRUE;
    OpenStream(pszSubFile);
}

CFSClient::~CFSClient()
{
    if (m_pSubFS)
        delete m_pSubFS;
    if (m_pFS && !m_fNoDeleteFS)
        delete m_pFS;

    if (m_pbuf)
        lcFree(m_pbuf);
}

BOOL CFSClient::Initialize(PCSTR pszCompiledFile)
{
    CStr cszCompiledFile;
    PCSTR pszFilePortion = GetCompiledName(pszCompiledFile, &cszCompiledFile);

    ASSERT(cszCompiledFile.IsNonEmpty());
    ASSERT(!m_pFS);

    m_pFS = new CFileSystem;

    if (! SUCCEEDED(m_pFS->Init()) )
        return FALSE;

    if ( !SUCCEEDED(m_pFS->Open((PSTR)cszCompiledFile)) )
    {
        delete m_pFS;
        m_pFS = NULL;
        return FALSE;
    }

    if (pszFilePortion)
        return SUCCEEDED(OpenStream(pszFilePortion));

    return TRUE;
}

HRESULT CFSClient::OpenStream(PCSTR pszFile, DWORD dwAccess)
{
    HRESULT hr;
    ASSERT(m_pFS);
    if (! m_pFS )
        return E_FAIL;

    m_pSubFS = new CSubFileSystem(m_pFS);

	PSTR pszFileCopy = _strdup(pszFile);

    ReplaceEscapes(pszFile, pszFileCopy, ESCAPE_URL);

    if (! SUCCEEDED(hr = m_pSubFS->OpenSub(pszFileCopy, dwAccess)) )
    {
        delete m_pSubFS;
        m_pSubFS = NULL;
    }
	free(pszFileCopy);
    return hr;
}

void CFSClient::WriteStorageContents(PCSTR pszRootFolder, OLECHAR* wszFSName)
{
    IStorage* pStorage;
    HRESULT hr;
    BOOL fDoRelease = FALSE;

    if (! m_pFS )
        return;

    if (wszFSName != NULL)
   {
        IStorage* pStorage2 = m_pFS->GetITStorageDocObj();
        HRESULT hr = pStorage2->OpenStorage(wszFSName, NULL, STGM_READ, NULL, 0, &pStorage);
        if (!SUCCEEDED(hr))
        {
            DEBUG_ReportOleError(hr);
            return;
        }
        fDoRelease = TRUE;
    }
    else
        pStorage = m_pFS->GetITStorageDocObj();

    IEnumSTATSTG* pEnum;
    hr = pStorage->EnumElements(0, NULL, 0, &pEnum);
    if (!SUCCEEDED(hr)) {
        DEBUG_ReportOleError(hr);
        return;
    }

    STATSTG Stat;

    if (GetFileAttributes(pszRootFolder) == HFILE_ERROR) {
        // Only ask about creating the root folder
        if (!CreateFolder(pszRootFolder))
            return;
    }

    while (GetElementStat(pEnum, &Stat)) {
        char szFullPath[MAX_PATH];
        CStr cszName(Stat.pwcsName);    // convert to Multi-Byte
        CoTaskMemFree(GetStatName());
        if (cszName.psz[0] == '#' || cszName.psz[0] == '$') {
            continue;   // we don't decompile system files
        }
        if (Stat.type == STGTY_STORAGE) {
            strcpy(szFullPath, pszRootFolder);
            AddTrailingBackslash(szFullPath);
            strcat(szFullPath, cszName);
			WCHAR wszTemp[MAX_PATH];
			wszTemp[0] = NULL;
			if (wszFSName)
			{
				lstrcpyW(wszTemp,wszFSName);
				lstrcatW(wszTemp, L"\\");
			}
			lstrcatW(wszTemp, Stat.pwcsName);
            WriteStorageContents(szFullPath, wszTemp);
        }
        else {
            strcpy(szFullPath, pszRootFolder);
            AddTrailingBackslash(szFullPath);
            strcat(szFullPath, cszName);

            HANDLE hf = CreateFile(szFullPath, GENERIC_WRITE, 0,
                NULL, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
            if (hf == INVALID_HANDLE_VALUE)
                continue;

            CMem mem(Stat.cbSize.LowPart);
            ULONG cbRead;
            if (wszFSName) {
                CStr cszFsName(wszFSName);
                strcpy(szFullPath, cszFsName);
                AddTrailingBackslash(szFullPath);
                strcat(szFullPath, cszName);
                cszName = szFullPath;
            }
            hr = OpenStream(cszName);
            if (SUCCEEDED(hr)) {
                hr = Read(mem, Stat.cbSize.LowPart, &cbRead);
                DWORD cbWritten;
                if (SUCCEEDED(hr))
                    WriteFile(hf, mem, cbRead, &cbWritten, NULL);
                CloseStream();
            }
            CloseHandle(hf);
            if (!SUCCEEDED(hr))
                DeleteFile(szFullPath);
        }
    }

    ReleaseObjPtr(pEnum);
    if ( fDoRelease )
        ReleaseObjPtr(pStorage);
}

ULONG CFSClient::GetElementStat(ULONG nNumber, STATSTG* stat, IEnumSTATSTG* pEnum)
{
    ULONG nReturned = 0;
    HRESULT hr;

    if (pEnum == NULL) {
        if (m_pEnum) {
            hr = m_pEnum->Next(nNumber, stat, &nReturned);
        }
        else
            hr = S_FALSE;
    }
    else {
        hr = pEnum->Next(nNumber, stat, &nReturned);
    }
    return (SUCCEEDED(hr) ? nReturned : 0);
}

HRESULT CFSClient::Read(void* pDst, const ULONG cbRead, ULONG* pcbRead)
{
    ASSERT(m_pFS);
    ASSERT(m_pSubFS);
    if (m_cbBuf) {  // we've streamed it
        *pcbRead = Read((PBYTE) pDst, cbRead);
        return S_OK;
    }
    else
        return m_pSubFS->ReadSub(pDst, cbRead, pcbRead);
}

ULONG CFSClient::Read(PBYTE pbDest, ULONG cbBytes)
{
    if (!m_cbBuf)
        ReadBuf();

    if (m_pEndBuf - m_pbuf < m_cbBuf) { // adjust cbBytes for actual remaining size
        if (m_pEndBuf - m_pCurBuf < (int) cbBytes)
            cbBytes = (ULONG)(m_pEndBuf - m_pCurBuf);
    }
    if (m_pCurBuf + cbBytes < m_pEndBuf) {
        memcpy(pbDest, m_pCurBuf, cbBytes);
        m_pCurBuf += cbBytes;
        return cbBytes;
    }
    PBYTE pbDst = (PBYTE) pbDest;

    // If destination buffer is larger then our internal buffer, then
    // recursively call until we have filled up the destination.

    int cbRead =  (int)(m_pEndBuf - m_pCurBuf);
    memcpy(pbDest, m_pCurBuf, cbRead);
    pbDst += cbRead;
    if (!m_fEndOfFile)
        ReadBuf();
    if (m_fEndOfFile)
        return cbRead;

    return Read(pbDst, cbBytes - cbRead) + cbRead;
}

void CFSClient::ReadBuf(void)
{
    ULONG cRead;
    if (!m_cbBuf) {
        m_cbBuf = CSTREAM_BUF_SIZE; // use constant in case we pull in read-ahead code from CStream

        // +2 because we add a zero just past the buffer in case anyone expects strings

        m_pbuf = (PBYTE) lcMalloc(CSTREAM_BUF_SIZE);
        m_pSubFS->ReadSub(m_pbuf, m_cbBuf, &cRead);
        m_pCurBuf = m_pbuf;
        m_pEndBuf = m_pbuf + cRead;
        m_lFilePos = cRead;
        m_lFileBuf = 0;
        return;
    }
    m_pSubFS->ReadSub(m_pbuf, m_cbBuf, &cRead);
    m_lFileBuf = m_lFilePos;
    m_lFilePos += cRead;

    m_pCurBuf = m_pbuf;
    m_pEndBuf = m_pbuf + cRead;

    if (!cRead)
        m_fEndOfFile = TRUE;
}

HRESULT CFSClient::seek(int pos, SEEK_TYPE seek)
{
    ASSERT(seek != SK_END); // we don't support this one

    if (seek == SK_CUR) // convert to SEEK_SET equivalent
        pos = m_lFileBuf + (int)(m_pCurBuf - m_pbuf) + pos;

    if (pos >= m_lFileBuf && pos < m_lFilePos) {
        m_pCurBuf = m_pbuf + (pos - m_lFileBuf);
        if (m_pCurBuf >= m_pEndBuf && m_pEndBuf < m_pbuf + m_cbBuf)
            m_fEndOfFile = TRUE;
        return S_OK;
    }
    else {
        m_lFileBuf = m_pSubFS->SeekSub(pos, SK_SET);
        ULONG cread;
        if (FAILED(m_pSubFS->ReadSub(m_pbuf, m_cbBuf, &cread))) {
            m_fEndOfFile = TRUE;
            return STG_E_READFAULT;
        }
        m_lFilePos = m_lFileBuf + cread;
        m_pCurBuf = m_pbuf;
        m_pEndBuf = m_pbuf + cread;
        if (cread == 0)
            m_fEndOfFile = TRUE;

        return S_OK;
    }
}

void CFSClient::CloseStream(void)
{
    if (m_pSubFS) {
        delete m_pSubFS;
        m_pSubFS = NULL;
    }
    if (m_pbuf) {
        lcFree(m_pbuf);
        m_pbuf = NULL;
        m_cbBuf = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\fm.cpp ===
//  Copyright (C) Microsoft Corporation 1990-1997

#include "header.h"
#include "strtable.h"
#include <commdlg.h>
#include "system.h"
#include <dlgs.h>
#include "resource.h"
#include "cdlg.h"

// Set the last error for the HTML Help API callers.
#include "lasterr.h"

#define MAX_MESSAGE     512
#define MAX_TABLE_STRINGS 1024

static const char txtHelpDirKey[] = "Software\\Microsoft\\Windows\\HTML Help";
static const char txtHhIni[] = "hh.ini";
static const char txtFiles[] = "files";

// Can't be const since RegCreateKeyEx() thinks it can modify this

static char txtDirectoryClass[] = "Folder";

// persistent local memory class
class CDataFM {
  public:
    CDataFM::CDataFM() { m_ptblFoundFiles = NULL; }
    CDataFM::~CDataFM() { if( m_ptblFoundFiles ) delete m_ptblFoundFiles; }

    CTable* GetFoundFiles(void) { if( !m_ptblFoundFiles ) m_ptblFoundFiles = new CTable(MAX_TABLE_STRINGS * 256); return m_ptblFoundFiles; }

  private:
    CTable* m_ptblFoundFiles;
};

static CDataFM s_Data;

/***************************************************************************

    FUNCTION:   GetRegWindowsDirectory

    PURPOSE:    Equivalent to GetWindowsDirectory() only it checks the
                registration first for the proper location

    PARAMETERS:
        pszDst

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        04-Dec-1994 [ralphw]

***************************************************************************/

void GetRegWindowsDirectory(PSTR pszDstPath)
{
  HHGetWindowsDirectory(pszDstPath, MAX_PATH);
}

/***************************************************************************

    FUNCTION:   FindThisFile

    PURPOSE:    Searches for the specified file:

                1) Searches the registry
                2) Searches windows\help
                3) Searches hh.ini

    PARAMETERS:
        pszFile  -- input filename
        pcsz     -- receives full path
        fAskUser -- TRUE to ask the user to find the file

    RETURNS:    TRUE if the file was found

    COMMENTS:

    MODIFICATION DATES:
        04-Dec-1994 [ralphw]
        10-May-1997 [ralphw] -- ported from WinHelp code

***************************************************************************/

BOOL FindThisFile(HWND hwndParent, PCSTR pszFile, CStr* pcszFile, BOOL fAskUser /*= TRUE*/ )
{
    char szFullPath[MAX_PATH + MAX_MESSAGE];
    LONG result = -1;
    HKEY hkey;
    DWORD type;

    CStr cszCompiledName;
    PCSTR pszName = GetCompiledName(pszFile, &cszCompiledName);

    /*
     * Extract just the filename portion of the path, and use that as the
     * lookup key in the registry. If found, the key value is the path to
     * use.
     */

    pszName = FindFilePortion(pszName ? pszName : pszFile);
    if (!pszName)
    {
        // Set the last error. We couldn't find the file.
        //g_LastError.Set(idProcess, HH_E_FILENOTFOUND) ; // Need idProcess to set.
        return FALSE;
    }

    if( s_Data.GetFoundFiles() ) {
        HASH hash = HashFromSz(pszName);
        int pos = s_Data.GetFoundFiles()->IsHashInTable(hash);
        if (pos > 0) {
            *pcszFile = s_Data.GetFoundFiles()->GetHashStringPointer(pos);
            return TRUE;
        }
    }

    // Check all open CHM files for a match

    for (int i = 0; i < g_cHmSlots; i++) {
        // BUGBUG: enumerate all CExTitles in collection

        if (g_phmData[i] && stristr(g_phmData[i]->GetCompiledFile(), pszName)) {
            if (s_Data.GetFoundFiles()->CountStrings() < MAX_TABLE_STRINGS)
                s_Data.GetFoundFiles()->AddString(HashFromSz(pszName), g_phmData[i]->GetCompiledFile());
            *pcszFile = g_phmData[i]->GetCompiledFile();
            return TRUE;
        }
    }

    if (GetFileAttributes(cszCompiledName) != (DWORD) -1) {
        GetFullPathName(cszCompiledName, sizeof(szFullPath), szFullPath,
            NULL);
        *pcszFile = szFullPath;
        return TRUE;
    }

    // major hack for bug 5909 which is breaking VBA, MSE and external clients, the above BUGBUG
    // would also fix this but we don't have a reliable way to get all collections..
    // look in the directories of the currently open files for this file
    char szTmp[MAX_PATH];
    for (i = 0; i < g_cHmSlots; i++) {
        if (g_phmData[i]) {
            // get the path to this file and append the new file and check if it exists
            SplitPath((LPSTR)g_phmData[i]->GetCompiledFile(), szFullPath, szTmp, NULL, NULL);
            CatPath(szFullPath, szTmp);
            CatPath(szFullPath, pszName);
            if (GetFileAttributes(szFullPath) != HFILE_ERROR )
            {
                *pcszFile = szFullPath;
           return TRUE;
            }
        }
    }


    // See if we have a Darwin GUID for this process ID

    BOOL bDone = FALSE;

    g_Busy.Set( TRUE );

    if (g_pszDarwinGuid) {
        CStr cszPath;
        if (FindDarwinURL(g_pszDarwinGuid/*BOGUS g_phmData[i]->m_pszDarwinGuid*/, pszName, &cszPath)) {
            if (GetFileAttributes(cszPath) != (DWORD) -1)
            {
               PSTR ptr = strrchr(cszPath.psz, '\\');
               *(++ptr) = '\0';
               cszPath += pszName;
               if (GetFileAttributes(cszPath) != (DWORD) -1)
               {
                  if (s_Data.GetFoundFiles()->CountStrings() < MAX_TABLE_STRINGS)
                     s_Data.GetFoundFiles()->AddString(HashFromSz(pszName), cszPath);
                  *pcszFile = cszPath.psz;
                  bDone = TRUE;
               }
            }
        }
    }

    // If the first Darwin GUID can't be found, try the alternate GUID

    else if (g_pszDarwinBackupGuid) {
        CStr cszPath;
        if (FindDarwinURL(g_pszDarwinBackupGuid /*BOGUS: g_phmData[i]->m_pszDarwinBackupGuid*/, pszName, &cszPath)) {
            if (GetFileAttributes(cszPath) != (DWORD) -1) {
                if (s_Data.GetFoundFiles()->CountStrings() < MAX_TABLE_STRINGS)
                    s_Data.GetFoundFiles()->AddString(HashFromSz(pszName), cszPath);
                *pcszFile = cszPath.psz;
                bDone = TRUE;
            }
        }
    }

    g_Busy.Set( FALSE );

    if( bDone )
      return bDone;


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, txtHelpDirKey, 0, KEY_READ, &hkey) ==
            ERROR_SUCCESS) {
        DWORD cbPath = MAX_PATH;
        result = RegQueryValueEx(hkey, pszName, 0, &type, (PBYTE) szFullPath, &cbPath);
        RegCloseKey(hkey);
    }

    if (result == ERROR_SUCCESS) {
        AddTrailingBackslash(szFullPath);
        strcat(szFullPath, pszName);
        if (GetFileAttributes(szFullPath) != (DWORD) -1) {
            if (s_Data.GetFoundFiles()->CountStrings() < MAX_TABLE_STRINGS)
                s_Data.GetFoundFiles()->AddString(HashFromSz(pszName), szFullPath);
            *pcszFile = szFullPath;
            return TRUE;
        }
    }

    // If the user's os ui language is different from the os's ui language. try help.xxxx where xxx is the langid of the ui. (NT 5 only)
    LANGID uilangid = _Module.m_Language.GetUserOsUiLanguage() ;
    if (uilangid)
    {
        // SM 8021: Avoid possible buffer overrun by allocating sufficient memory (was [5]).
        char szLangId[15] ;
        wsprintf(szLangId,"\\mui\\%04x", uilangid);

        GetRegWindowsDirectory(szFullPath);
        AddTrailingBackslash(szFullPath);
        strcat(szFullPath, txtHlpDir);
        strcat(szFullPath, szLangId) ;  // Tack on the langid.
        AddTrailingBackslash(szFullPath);
        strcat(szFullPath, pszName);
        if (GetFileAttributes(szFullPath) != (DWORD) -1)
        {
            if (s_Data.GetFoundFiles()->CountStrings() < MAX_TABLE_STRINGS)
                s_Data.GetFoundFiles()->AddString(HashFromSz(pszName), szFullPath);
            *pcszFile = szFullPath;
            return TRUE;
        }
    }

    // Next, try the registered Windows\help directory

    GetRegWindowsDirectory(szFullPath);
    AddTrailingBackslash(szFullPath);
    strcat(szFullPath, txtHlpDir);
    AddTrailingBackslash(szFullPath);
    strcat(szFullPath, pszName);
    if (GetFileAttributes(szFullPath) != (DWORD) -1)
    {
        if (s_Data.GetFoundFiles()->CountStrings() < MAX_TABLE_STRINGS)
            s_Data.GetFoundFiles()->AddString(HashFromSz(pszName), szFullPath);
        *pcszFile = szFullPath;
        return TRUE;
    }

	// Next, try the Windows\help directory

    GetSystemDirectory(szFullPath, MAX_PATH + MAX_MESSAGE);
	i = (int)strlen(szFullPath);
	char *p = &szFullPath[i-1];
	while (p > szFullPath && *p != '\\')
	{
		*p = NULL;
		p--;
	}
	strcat(szFullPath, txtHlpDir);
	AddTrailingBackslash(szFullPath);
	strcat(szFullPath, pszName);
	if (GetFileAttributes(szFullPath) != (DWORD) -1)
	{
		if (s_Data.GetFoundFiles()->CountStrings() < MAX_TABLE_STRINGS)
			s_Data.GetFoundFiles()->AddString(HashFromSz(pszName), szFullPath);
		*pcszFile = szFullPath;
		return TRUE;
	
	}
    // Next, try hh.ini

    if (GetPrivateProfileString(txtFiles, pszName, txtZeroLength, szFullPath,
            sizeof(szFullPath), txtHhIni) > 1) {

        /*--------------------------------------------------------------------*\
        | The original profile string looks something like this
        |   a:\setup\helpfiles,Please place fred's disk in drive A:
        |                                                          ^
        | We transform this to look like:
        |   a:\setup\helpfiles\foobar.hlp Please place fred's disk in drive A:
        |   \_________________/\________/^\__________________________________/^
        |       MAX_PATH   cchFileName 1              MAX_MESSAGE             1
        |
        \*--------------------------------------------------------------------*/
        PCSTR pszMsg = FirstNonSpace(pcszFile->GetArg(szFullPath));
        if (GetFileAttributes(*pcszFile) != (DWORD) -1) {
            return TRUE;
        }
        if (fAskUser && !IsEmptyString(pszMsg)) {
            do {
                if (MessageBox(hwndParent, pszMsg, _Resource.MsgBoxTitle(),
                        MB_OKCANCEL | MB_TASKMODAL | MB_ICONHAND |
                        g_fuBiDiMessageBox) != IDOK)
                    break;
            } while (GetFileAttributes(*pcszFile) == (DWORD) -1);
            if (s_Data.GetFoundFiles()->CountStrings() < MAX_TABLE_STRINGS)
                s_Data.GetFoundFiles()->AddString(HashFromSz(*pcszFile), szFullPath);
            return TRUE;
        }
    }

#if 0
    if (!fAskUser)
    {
        // Tell the API callers that we couldn't find the help file.
        g_LastError.Set(idProcess, HH_E_FILENOTFOUND) ;
        return FALSE;
    }

    // VS98 Bugs 15405. There are numerous bugs assigned against the following dialog
    // box. We have much more important bugs to fix. Therefore, let's not display the
    // dialog. Here are the bugs:
    //  Does not work correctly with COL files.
    //  User can change from COL to CHM file or vice versa.
    //  User can change name of CHM file which breaks the registry entry.
    //  There are no filters in this dialog.
    //  NOTE: Most callers assume that the name/path does not change!!! However, it can.

    /*
     * At this point, we don't know where the heck this file is, so let's
     * get the user to find it for us.
     */

    wsprintf(szFullPath, GetStringResource(IDS_FIND_YOURSELF), pszName);
    if (MessageBox(hwndParent,
            szFullPath, _Resource.MsgBoxTitle(), MB_YESNO | MB_ICONQUESTION | g_fuBiDiMessageBox) != IDYES)
        return FALSE;

    // Save pszName in case pszFile == pcszFile->psz

    CStr cszName(pszName);
    if (DlgOpenFile(hwndParent, pszFile, pcszFile)) {
        DWORD disposition;
        PSTR psz = (PSTR) FindFilePortion(*pcszFile);
        if (psz) {
            char ch = *psz;
            *psz = '\0';

            // Add it to the registry so we can find it next time

            if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, txtHelpDirKey, 0,
                    txtDirectoryClass, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                    NULL, &hkey, &disposition) == ERROR_SUCCESS) {
                RegSetValueEx(hkey, cszName, 0, REG_SZ, (PBYTE) pcszFile->psz,
                    strlen(*pcszFile) + 1);
                RegCloseKey(hkey);
            }
            *psz = ch;
        }
        if (s_Data.GetFoundFiles()->CountStrings() < MAX_TABLE_STRINGS)
            s_Data.GetFoundFiles()->AddString(HashFromSz(*pcszFile), szFullPath);
        return TRUE;
    }
#endif

    // Tell the API callers that we couldn't find the help file.
    //g_LastError.Set(idProcess, HH_E_FILENOTFOUND) ;// Need idProcess to set.
    return FALSE;
}

PCSTR FindFilePortion(PCSTR pszFile)
{
    PCSTR psz = StrRChr(pszFile, '\\');
    if (psz)
        pszFile = psz + 1;
    psz = StrRChr(pszFile, '/');
    if (psz)
        return psz + 1;
    psz = StrRChr(pszFile, ':');
    return (psz ? psz + 1 : pszFile);
}

static const char txtGetOpenFile[] = "GetOpenFileNameA";
static const char txtCommDlg[] = "comdlg32.dll";
static const char txtEditHack[] = "Junk";

typedef BOOL (WINAPI* GETOPENFILENAME)(LPOPENFILENAME popn);

DWORD_PTR CALLBACK BrowseDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

/////////////////////////////////////////////////////////////////////////////
// Browse Dialog

DWORD_PTR CALLBACK BrowseDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
  switch( uMsg ) {

    case WM_INITDIALOG: {

      CenterWindow( GetParent( hDlg ), hDlg );

      //Let's hide these windows so the user cannot tab to them.  Note that in
      //the private template (in cddemo.dlg) the coordinates for these guys are
      //*outside* the coordinates of the dlg window itself.  Without the following
      //ShowWindow()'s you would not see them, but could still tab to them.
      ShowWindow( GetDlgItem( hDlg, stc2 ), SW_HIDE );
      ShowWindow( GetDlgItem( hDlg, stc3 ), SW_HIDE );
      ShowWindow( GetDlgItem( hDlg, edt1 ), SW_HIDE );
      ShowWindow( GetDlgItem( hDlg, lst1 ), SW_HIDE );
      ShowWindow( GetDlgItem( hDlg, cmb1 ), SW_HIDE );

      //We must put something in this field, even though it is hidden.  This is
      //because if this field is empty, or has something like "*.txt" in it,
      //and the user hits OK, the dlg will NOT close.  We'll jam something in
      //there (like "Junk") so when the user hits OK, the dlg terminates.
      //Note that we'll deal with the "Junk" during return processing (see below)
      SetDlgItemText( hDlg, edt1, txtEditHack );

      //Now set the focus to the directories listbox.  Due to some painting
      //problems, we *must* also process the first WM_PAINT that comes through
      //and set the current selection at that point.  Setting the selection
      //here will NOT work.  See comment below in the on paint handler.
      SetFocus( GetDlgItem( hDlg, lst2 ) );

      return FALSE;
    }

    case WM_PAINT: {
      break;
    }

#if 0
    case WM_COMMAND: {
      if( LOWORD(wParam) == IDOK ) {
        EndDialog( hDlg, LOWORD( wParam ) );
      }
      break;
    }
#endif

  }

  return FALSE;
}

BOOL DlgOpenDirectory(HWND hwndParent, CStr* pcsz)
{
    static HINSTANCE hmodule = NULL;
    if (hmodule || (hmodule = LoadLibrary(txtCommDlg)) != NULL) {
        static GETOPENFILENAME qfnbDlg = NULL;
        if (qfnbDlg || (qfnbDlg = (GETOPENFILENAME) GetProcAddress(hmodule,
                txtGetOpenFile)) != NULL) {
            OPENFILENAME  ofn;
            char szPath[MAX_PATH];
            strcpy(szPath, "");

            for(;;) {
                ZeroMemory(&ofn, sizeof(ofn));
                ofn.lStructSize = sizeof ofn;
                ofn.hwndOwner = hwndParent;
                ofn.hInstance = _Module.GetResourceInstance();
                ofn.lpstrFile = szPath;
                ofn.nMaxFile = sizeof(szPath);
                ofn.lpTemplateName = MAKEINTRESOURCE( IDD_BROWSE );
                ofn.lpfnHook = BrowseDialogProc;

                ofn.Flags = OFN_HIDEREADONLY | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;

                if (!qfnbDlg(&ofn))
                    return FALSE;
                // remove our edit control hack text
                *(ofn.lpstrFile+strlen(ofn.lpstrFile)-strlen(txtEditHack)) = 0;
                *pcsz = ofn.lpstrFile;
                return TRUE;
            }
        }
        else
            return FALSE;
    }
    else
        return FALSE;
}

BOOL DlgOpenFile(HWND hwndParent, PCSTR pszFile, CStr* pcsz)
{
    static HINSTANCE hmodule = NULL;
    if (hmodule || (hmodule = LoadLibrary(txtCommDlg)) != NULL) {
        static GETOPENFILENAME qfnbDlg = NULL;
        if (qfnbDlg || (qfnbDlg = (GETOPENFILENAME) GetProcAddress(hmodule,
                txtGetOpenFile)) != NULL) {
            OPENFILENAME  ofn;
            char szPath[MAX_PATH];
            strcpy(szPath, pszFile);

            for(;;) {
                ZeroMemory(&ofn, sizeof(ofn));
                ofn.lStructSize = sizeof ofn;
                ofn.hwndOwner = hwndParent;
                ofn.hInstance = _Module.GetResourceInstance();
                ofn.lpstrFile = szPath;
                ofn.nMaxFile = sizeof(szPath);
                ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST |
                    OFN_NOCHANGEDIR;

                if (!qfnbDlg(&ofn))
                    return FALSE;
                *pcsz = ofn.lpstrFile;
                return TRUE;
            }
        }
        else
            return FALSE;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\fts.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.
//
// FTS.H
//
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __FTS_H__
#define __FTS_H__

#ifndef __SITEMAP_H__
#include "sitemap.h"
#endif

// Shroom header files
//
#include "itquery.h"
#include "itgroup.h"
#include "itcc.h"
#include "itrs.h"
#include "itdb.h"
#include "itww.h"

class CExCollection;
class CExTitle;
class CCombinedFTS;
class CSubSet;
class CUWait;

#define FTS_TITLE_ONLY	        0x0001
#define FTS_ENABLE_STEMMING     0x0002
#define FTS_SEARCH_PREVIOUS     0x0004


#define FTS_NO_INDEX        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,100)
#define FTS_NOT_INITIALIZED MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,101)
#define FTS_E_SKIP_TITLE    MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,102)
#define FTS_E_SKIP_VOLUME   MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,103)
#define FTS_E_SKIP_ALL      MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,104)
#define FTS_INVALID_SYNTAX  MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,105)
#define FTS_CANCELED        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,106)

#define MAX_HIGHLIGHT_TERMS 128

typedef struct CHM_MapEntry
{
    char                szChmName[50];
    WORD                iIndex;
    FILETIME            versioninfo;
    LCID                language;
    DWORD               dwTopicCount;
} CHM_MAP_ENTRY;

DWORD Han2Zen(unsigned char *lpInBuffer, unsigned char *lpOutBuffer, UINT codepage);
WCHAR* PreProcessQuery(WCHAR *pwcQuery, UINT codepage);
BOOL compareOperator(char *pszQuery, char *pszTerm);
int IsJOperator(char *pszQuery);
int FASTCALL CompareIntValues(const void *pval1, const void *pval2);

ERR SearchMessageFunc(DWORD dwFlag, LPVOID pUserData, LPVOID pMessage);

BOOL IsQuery(char *pszQuery);

// FTS Results structure
//
typedef struct _search_result
{
	DWORD dwTopicNumber;
    DWORD dwRank;
	CExTitle *pTitle;
} SEARCH_RESULT;

class CTitleFTS;

//
// Topic numbers in IVQ files will be reduced from 32bit numbers to 22bit numbers.
// The high 10 bits will be used as an CHM ID.
//
// Conversion from DWORD to CHM_ID and Topic Number.
//
#define CHM_ID(exp)     (0x000003ff & (exp >> 22))
#define TOPIC_NUM(exp)  (0x003fffff & exp)

// Conversion from CHM_ID and Topic Number to DWORD.
//
#define PACKED_TOPICNUM(iTopNum, iChmID)    ((iChmID << 22) | iTopNum)

// Title array structure
//
typedef struct _titleArray
{
    CExTitle        *pExTitle;
    CCombinedFTS    *pCombinedFTI;
    BOOL            bSearch;
    BOOL            bCombinedIndex;
    WORD            iTitleIndex;
    FILETIME        versioninfo;
    char            *pszQueryName;
    char            *pszIndexName;
    char            *pszShortName;
    LCID            language;
    DWORD           dwTopicCount;
    UINT            uiVolumeOrder;
    BOOL            bHasResults;
    BOOL            bAlreadyQueried;
} TITLE_ENTRY;

// CFullTextSearch class
//
class CFullTextSearch
{
public:
	CFullTextSearch(CExCollection *pTitleCollection);
	~CFullTextSearch();
	HRESULT SimpleQuery(WCHAR *pszQuery, int *cResultCount, SEARCH_RESULT **);
    HRESULT ComplexQuery(WCHAR *pszQuery, DWORD dwFlags, int *cResultCount, SEARCH_RESULT **, CSubSet *pSubSet);
	HRESULT AbortQuery();
	HRESULT SetProximity(WORD wNear);
	HRESULT SetResultCount(LONG cRows);
	HRESULT SetOptions(DWORD dwFlag);
    void InitTitleArray(void);
    BOOL LoadCombinedIndex(DWORD);
    CCombinedFTS * GetPreviousInstance(char *pszQueryName);
    CExTitle *LookupTitle(CCombinedFTS *, DWORD);
	HRESULT AddHLTerm(WCHAR *, int len);
    HRESULT CFullTextSearch::AddQueryToTermList(WCHAR *pwsBuffer);
	HRESULT TermListRemoveAll(void);
	WCHAR * GetHLTermAt(int index);
	INT GetHLTermCount(void);
	VOID FreeResults(SEARCH_RESULT *);
	long ComputeResultCount(IITResultSet *pResultSet);
	PCSTR	m_pszITSSFile;
	BOOL Initialize();
	long m_lMaxRowCount;
	WORD m_wQueryProximity;
	DWORD m_dwQueryFlags;
    int m_iLastResultCount;
    TITLE_ENTRY *m_pTitleArray;
	BOOL m_bMergedChmSetWithCHQ;  // When true, we are running a merged chm set that has
								  // a combined index (NT5 Help).
protected:
	LANGID m_SystemLangID;
	WCHAR *m_HLTermArray[MAX_HIGHLIGHT_TERMS];
	int m_iHLIndex;
	BOOL m_bInit;
	BOOL m_InitFailed;
	BOOL m_SearchActive;
	CExCollection *m_pTitleCollection;
    BOOL m_bTitleArrayInit;
    INT m_TitleArraySize;
};

// CTitleFTS class
//
class CTitleFTS
{
public:
	CTitleFTS(PCSTR pwszTitlePath, LCID lcid, CExTitle *);
    void ReleaseObjects();
	~CTitleFTS();
    HRESULT Query(WCHAR *pszQuery, DWORD dwFlags, IITResultSet **, CFullTextSearch *pFullTextSearch, CUWait *, int);
	HRESULT AbortQuery();
	IITResultSet * GetResultsSet(void) { return m_pITResultSet; }
	HRESULT SetProximity(WORD wNear);
	HRESULT SetResultCount(LONG cRows);
	HRESULT SetOptions(DWORD dwFlag);
	VOID FreeResults(SEARCH_RESULT *);
	HRESULT Initialize();
    HRESULT UpdateOptions(WORD wNear, LONG cRows);
protected:
    UINT m_codepage;
    long m_iLastResultCount;
    WCHAR *m_pPrevQuery;
	BOOL m_bInit;
    CExTitle *m_pTitle;
	HRESULT m_InitError;
	BOOL m_InitFailed;
	BOOL m_SearchActive;
	DWORD m_dwQueryFlags;
	LCID m_lcid;
	IITIndex *m_pIndex;
	IITQuery *m_pQuery;
	IITResultSet *m_pITResultSet;
	IITDatabase *m_pITDB;
	LANGID m_SystemLangID;
    LANGID m_langid;
	BOOL m_fDBCS;
	WCHAR m_tcTitlePath[MAX_PATH];
	long m_lMaxRowCount;
	WORD m_wQueryProximity;

    inline BOOL Init() { if( !m_bInit ) Initialize(); return m_bInit; }
};

// CCombinedFTS class
//
class CCombinedFTS
{
public:
	CCombinedFTS(CExTitle *, LCID lcid, CFullTextSearch *);
	~CCombinedFTS();
    HRESULT Query(WCHAR *pszQuery, DWORD dwFlags, IITResultSet **, CFullTextSearch *pFullTextSearch, CUWait *, int);
	HRESULT AbortQuery();
	IITResultSet * GetResultsSet(void) { return m_pITResultSet; }
	VOID FreeResults(SEARCH_RESULT *);
	HRESULT Initialize();
    HRESULT UpdateOptions(WORD wNear, LONG cRows);
    void ReleaseObjects();
protected:
    UINT m_codepage;
    long m_iLastResultCount;
	HRESULT SetProximity(WORD wNear);
	HRESULT SetResultCount(LONG cRows);
	HRESULT SetOptions(DWORD dwFlag);
    CExTitle *m_pTitle;
    CFullTextSearch *m_pFullTextSearch;
	BOOL m_SearchActive;
	DWORD m_dwQueryFlags;
	LCID m_lcid;
    WCHAR *m_pPrevQuery;
	IITIndex *m_pIndex;
	IITQuery *m_pQuery;
	IITResultSet *m_pITResultSet;
	IITDatabase *m_pITDB;
	LANGID m_SystemLangID;
    LANGID m_langid;
	BOOL m_fDBCS;
	WCHAR m_tcTitlePath[MAX_PATH];
	long m_lMaxRowCount;
	WORD m_wQueryProximity;
};


#endif	// __FTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\fts.cpp ===
// FTS.CPP : implementation file
//
// by DougO
//
#include "header.h"
#include "stdio.h"
#include "string.h"
#include "TCHAR.h"
#ifdef HHCTRL
#include "parserhh.h"
#else
#include "parser.h"
#endif
#include "collect.h"
#include "hhtypes.h"
#include "toc.h"

#include "highlite.h"
#include "lockout.h"
#include "userwait.h"

#include "fts.h"
#include "hhfinder.h"
#include "csubset.h"
#include "subset.h"
#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

#include "ftsnames.cpp"

#define CENTAUR_TERMS 1

/*************************************************************************
 *
 *              SINGLE TO DOUBLE-WIDTH KATAKANA MAPPING ARRAY
 *
 *************************************************************************/

// Single-Width to Double-Width Mapping Array
//

static const int mtable[][2]={
   {129,66},{129,117},{129,118},{129,65},{129,69},{131,146},{131,64},
   {131,66},{131,68},{131,70},{131,72},{131,131},{131,133},{131,135},
   {131,98},{129,91},{131,65},{131,67},{131,69},{131,71},{131,73},
   {131,74},{131,76},{131,78},{131,80},{131,82},{131,84},{131,86},
   {131,88},{131,90},{131,92},{131,94},{131,96},{131,99},{131,101},
   {131,103},{131,105},{131,106},{131,107},{131,108},{131,109},
   {131,110},{131,113},{131,116},{131,119},{131,122},{131,125},
   {131,126},{131,128},{131,129},{131,130},{131,132},{131,134},
   {131,136},{131,137},{131,138},{131,139},{131,140},{131,141},
   {131,143},{131,147},{129,74},{129,75} };

// note, cannot put in .text since the pointers themselves are uninitialized
static const char* pJOperatorList[] =   {"","????","???","????","??????","?m?d?`?q","?n?q","?`?m?c","?m?n?s",""};
static const char* pEnglishOperator[] = {"","and "  ,"or " ,"not "  ,"near "   ,"NEAR "   ,"OR " ,"AND "  ,"NOT "  ,""};

int FASTCALL CompareVolumeOrder( const void* p1, const void* p2 )
{
  int iReturn;

  TITLE_ENTRY* pEntry1= (TITLE_ENTRY*) p1;
  TITLE_ENTRY* pEntry2= (TITLE_ENTRY*) p2;

  if( pEntry1->uiVolumeOrder < pEntry2->uiVolumeOrder )
    iReturn = -1;
  else if ( pEntry1->uiVolumeOrder > pEntry2->uiVolumeOrder )
    iReturn = 1;
  else
    iReturn = 0;

  return iReturn;
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch Class
//
// This class provides full-text search functionality to HTML Help.  This
// class encapsulates multi-title searches and combined indexes.
//

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch class constructor
//
CFullTextSearch::CFullTextSearch(CExCollection *pTitleCollection)
{
    m_bInit  = FALSE;
    m_bTitleArrayInit = FALSE;
    m_SearchActive = FALSE;
    m_InitFailed = FALSE;
    m_pTitleCollection = pTitleCollection;
    m_pTitleArray = NULL;
	m_bMergedChmSetWithCHQ = FALSE;
	m_SystemLangID = PRIMARYLANGID(GetSystemDefaultLangID());
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch class destructor
//
CFullTextSearch::~CFullTextSearch()
{
    TermListRemoveAll();

    INT iTitle, iTitle2;

    // Delete the CCombinedFTS objects
    //
    if(m_pTitleArray)
    {
        for(iTitle = 0; iTitle < m_TitleArraySize; ++iTitle)
        {
            if(m_pTitleArray[iTitle].pCombinedFTI)
            {
                CCombinedFTS *pObject = m_pTitleArray[iTitle].pCombinedFTI;

                for(iTitle2 = 0; iTitle2 < m_TitleArraySize; ++iTitle2)
                {
                    if(m_pTitleArray[iTitle2].pCombinedFTI == pObject)
                        m_pTitleArray[iTitle2].pCombinedFTI = NULL;
                }

                delete pObject;
            }

           // cleanup strings in title array
           CHECK_AND_FREE( m_pTitleArray[iTitle].pszQueryName );
           CHECK_AND_FREE( m_pTitleArray[iTitle].pszIndexName );
           CHECK_AND_FREE( m_pTitleArray[iTitle].pszShortName );

        }
    }
    if(m_pTitleArray)
        lcFree(m_pTitleArray);
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch initialization
//
BOOL CFullTextSearch::Initialize()
{
    if(m_InitFailed)
        return FALSE;

    if(m_bInit)
        return TRUE;

    m_InitFailed = TRUE;
    // init here

    m_bInit = TRUE;
    m_InitFailed = FALSE;

    ZeroMemory(m_HLTermArray, sizeof(m_HLTermArray));
    m_iHLIndex = 0;

    m_lMaxRowCount = 500;
    m_wQueryProximity = 8;

    // DOUGO - insert code here to init system language member

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch simple query
//
//   pszQuery           pointer to null terminated query string.
//
//   pcResultCount      pointer to variable to receive results count.
//
//   ppSearchResults    pointer to a SEARCH_RESULT pointer to receive
//                      results list.  Upon return, this pointer will
//                      point to an array of SEARCH_RESULTS structures
//                      of size pcResultCount.
//
HRESULT CFullTextSearch::SimpleQuery(WCHAR *pszQuery, int *pcResultCount, SEARCH_RESULT **ppSearchResults)
{
    if(!m_bInit)
        return FTS_NOT_INITIALIZED;

    return ComplexQuery(pszQuery, FTS_ENABLE_STEMMING, pcResultCount, ppSearchResults, NULL);
}
/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch complex query
//
HRESULT CFullTextSearch::ComplexQuery(WCHAR *pszQuery, DWORD dwFlags, int *pcResultCount, SEARCH_RESULT **ppSearchResults, CSubSet *pSubSet)
{
    int wcb = 0, cb = 0;
    HRESULT hr;

    *ppSearchResults = NULL;
    *pcResultCount = 0;

    if(!m_bInit)
        return E_FAIL;

    if(!pszQuery)
        return E_FAIL;

    CUWait cWaitDlg(GetActiveWindow());

    // no chars in string
    //
    if(!*pszQuery)
        return S_OK;

    // Initialize the title array
    //
    if(!m_bTitleArrayInit) {
        InitTitleArray();
    }

    // Make sure title array exists
    //
    if(!m_pTitleArray)
        return E_FAIL;

    INT iTitle;

    // reset the results flags (this flag is set when a title has results to collect)
   //
    for(iTitle = 0; iTitle < m_TitleArraySize; ++iTitle)
    {
        m_pTitleArray[iTitle].bHasResults = FALSE;
        m_pTitleArray[iTitle].bAlreadyQueried = FALSE;
    }

    BOOL bDbcsQuery = FALSE;
    char *pszDbcsQuery = NULL;

    WCHAR *pwsBuffer = NULL; 
	
    pwsBuffer = lcStrDupW(pszQuery);
	
	if(!pwsBuffer)
	    return E_FAIL;

    TermListRemoveAll();

    AddQueryToTermList(pwsBuffer);

    // Add field identifier to query (VFLD 0 = full content, VFLD 1 = title only)
	//
    wcb = lstrlenW(pwsBuffer)*2;
    WCHAR *pwsField = (WCHAR *) lcMalloc(wcb+22);

    if(!pwsField)
        return E_FAIL;

    // check for title only search
    //
    wcscpy(pwsField,L"(");
    if(dwFlags & FTS_TITLE_ONLY)
        wcscat(pwsField,L"VFLD 1 ");
	else
        wcscat(pwsField,L"VFLD 0 ");

    wcscat(pwsField,pwsBuffer);
    wcscat(pwsField,L")");
    lcFree(pwsBuffer);
    pwsBuffer = pwsField;

    // Append the subset filter query to the user query
    //
    // Construct the subset query based on the current FTS subset.
    //
    WCHAR szSubsetFilter[65534];
    DWORD dwSubsetTitleCount = 0;
    CStructuralSubset *pSubset;

	// pre-load combined index for merged chm sets (NT5)
	//
	if(m_bMergedChmSetWithCHQ)
		LoadCombinedIndex(0);

    // copy the user query into buffer larger enough for subset add-on query
    //
    wcscpy(szSubsetFilter, pwsBuffer);

	// Create subset for titles in current merged chm set when running with 
	// combined index outside of collection (NT5 feature).
	//
	if(!(dwFlags & FTS_SEARCH_PREVIOUS) && m_bMergedChmSetWithCHQ)
	{
		wcscat(szSubsetFilter,L" AND (VFLD 1 ");
		
		for(iTitle = 0; iTitle < m_TitleArraySize; ++iTitle)
		{
			if(!m_pTitleArray[iTitle].bCombinedIndex)
				continue;

			if(dwSubsetTitleCount != 0)
				wcscat(szSubsetFilter,L" OR ");

			// Convert title name to Unicode
			//
			char szTempIdentifier[256], szTempLang[20];
			WCHAR wszTempIdentifier[256];
			// generate the magic title identifier
			//
			strcpy(szTempIdentifier,"HHTitleID");
			strcat(szTempIdentifier,m_pTitleArray[iTitle].pszShortName);
			szTempLang[0] = 0;
			Itoa(m_pTitleArray[iTitle].language, szTempLang);
			strcat(szTempIdentifier,szTempLang);
			
			MultiByteToWideChar(CP_ACP, 0, szTempIdentifier, -1, wszTempIdentifier, sizeof(wszTempIdentifier));
			
			// Append the title identifier to the subset query
			//
			wcscat(szSubsetFilter,wszTempIdentifier);
			dwSubsetTitleCount++;
		}
		// Close the expression
		//
		wcscat(szSubsetFilter,L")");
	}
	else
    // Get the current CStructuralSubset and check if "search previous" is active.
    // When "search previous" is on, we don't use subsetting (we query within the previous results)
    //
    if(m_pTitleCollection && m_pTitleCollection->m_pSSList)
    {
        if( (pSubset = m_pTitleCollection->m_pSSList->GetFTS()) && !(dwFlags & FTS_SEARCH_PREVIOUS) && !pSubset->IsEntire() )
        {
           wcscat(szSubsetFilter,L" AND (VFLD 1 ");

            for(iTitle = 0; iTitle < m_TitleArraySize; ++iTitle)
            {
                // Check if this title is part of the current subset
                //
                if(pSubset->IsTitleInSubset(m_pTitleArray[iTitle].pExTitle))
                {
                    if(dwSubsetTitleCount != 0)
                        wcscat(szSubsetFilter,L" OR ");

                    // Convert title name to Unicode
                    //
					char szTempIdentifier[256], szTempLang[20];
                    WCHAR wszTempIdentifier[256];
					// generate the magic title identifier
                    //
					strcpy(szTempIdentifier,"HHTitleID");
					strcat(szTempIdentifier,m_pTitleArray[iTitle].pszShortName);
					szTempLang[0] = 0;
                    Itoa(m_pTitleArray[iTitle].language, szTempLang);
					strcat(szTempIdentifier,szTempLang);
					
                    MultiByteToWideChar(CP_ACP, 0, szTempIdentifier, -1, wszTempIdentifier, sizeof(wszTempIdentifier));

                    // Append the title identifier to the subset query
                    //
                    wcscat(szSubsetFilter,wszTempIdentifier);
                    dwSubsetTitleCount++;
                }
            }
            // Close the expression
            //
             wcscat(szSubsetFilter,L")");
        }
    }

    IITResultSet* pITRS = NULL;
    LONG CombinedResultCount = 0;
    SEARCH_RESULT *pNextResult;
    BOOL bNeverPrompt;
    int QueryPhase;

    // Query Phase #1 - submit queries to any titles currently available (in CD drive, or on HD)
    // Query Phase #2 - submit queries to all titles in CD order
    //
    for(QueryPhase = 0; QueryPhase < 2; QueryPhase++)
    {
        for(iTitle = 0; iTitle < m_TitleArraySize; ++iTitle)
        {
          if(QueryPhase)
              bNeverPrompt = FALSE;
         else
             bNeverPrompt = TRUE;

            if(m_pTitleArray[iTitle].bSearch && !m_pTitleArray[iTitle].bAlreadyQueried)
            {
                if(m_pTitleArray[iTitle].bCombinedIndex)
                {
                    // Query combined index
                    //
                    CExTitle* pTitle = m_pTitleArray[iTitle].pExTitle;

                    // skip title if bad pTitle or we already have results for this query
               //
                    if(!pTitle | m_pTitleArray[iTitle].bHasResults | m_pTitleArray[iTitle].bAlreadyQueried)
                   continue;

                    // Make sure the storage is available
                    //
					if(!m_bMergedChmSetWithCHQ && m_pTitleCollection && !(m_pTitleCollection->IsSingleTitle()))
						if( FAILED(hr = EnsureStorageAvailability( pTitle, HHRMS_TYPE_COMBINED_QUERY, FALSE, FALSE, bNeverPrompt ) ) )
							continue;

                    // create combined index object if it doesn't exist
                    //
                    if(!m_pTitleArray[iTitle].pCombinedFTI)
                    {
                        // [paulti] must re-init query location before calling LoadCombinedIndex if dirty
                        if(m_pTitleArray[iTitle].pExTitle->m_pCollection->m_Collection.IsDirty())
                       {
                            lcFree( m_pTitleArray[iTitle].pszQueryName );
                            m_pTitleArray[iTitle].pszQueryName = lcStrDup(
                                m_pTitleArray[iTitle].pExTitle->GetUsedLocation()->QueryFileName );
                       }

						if(!m_bMergedChmSetWithCHQ)
						{
	                        if(!LoadCombinedIndex(iTitle))
		                    {
			                    // Load failed - not part of specified combined index.
				                // This title is now disabled for this session.
					            //
						        m_pTitleArray[iTitle].bSearch = FALSE;
							    continue;
						   }
						}
                    }

                    // All is happy - set options and query the combined index
                    //
                    m_pTitleArray[iTitle].pCombinedFTI->UpdateOptions(m_wQueryProximity,m_lMaxRowCount);

                    if(FAILED(hr = m_pTitleArray[iTitle].pCombinedFTI->Query(szSubsetFilter, dwFlags, &pITRS, this, &cWaitDlg, iTitle)))
                    {
                        if(hr == FTS_INVALID_SYNTAX || hr == FTS_CANCELED)
                        {
                            m_iLastResultCount = 0;
                           return hr;
                        }

                        // error accessing title
                        m_pTitleArray[iTitle].bSearch = FALSE;
                        continue;
                    }
                    m_pTitleArray[iTitle].bHasResults = TRUE;
                    m_pTitleArray[iTitle].bAlreadyQueried = TRUE;
                    CombinedResultCount+=ComputeResultCount(pITRS);

                    // Mark all other titles that use this combined index as having been queried
                    //
                    INT iTempTitle;
                    for(iTempTitle = 0; iTempTitle < m_TitleArraySize; ++iTempTitle)
                        if(m_pTitleArray[iTempTitle].pCombinedFTI == m_pTitleArray[iTitle].pCombinedFTI)
                            m_pTitleArray[iTempTitle].bAlreadyQueried = TRUE;

                }
                else
                {
                    // Query index in individual title
                    //
                    CExTitle* pTitle = m_pTitleArray[iTitle].pExTitle;

                    // skip title if bad pTitle or we already have results for this query
                    //
                    if(!pTitle || m_pTitleArray[iTitle].bHasResults || m_pTitleArray[iTitle].bAlreadyQueried )
                       continue;

                    CTitleInformation *pTitleInfo = m_pTitleArray[iTitle].pExTitle->GetInfo();
                    if(!(pTitleInfo && pTitleInfo->IsFullTextSearch()))
                    {
                        // This title turned out to not contain a FTI.  We delay this check until now
                        // for performance reasons.
                        //
                        m_pTitleArray[iTitle].bSearch = FALSE;
                        continue;
                    }
					if(!m_bMergedChmSetWithCHQ && m_pTitleCollection && !(m_pTitleCollection->IsSingleTitle()))
	                    if( FAILED(hr = EnsureStorageAvailability( pTitle, HHRMS_TYPE_TITLE, TRUE, FALSE, bNeverPrompt ) ) )
		                    continue;

                    m_pTitleArray[iTitle].pExTitle->m_pTitleFTS->UpdateOptions(m_wQueryProximity,m_lMaxRowCount);

                    if(FAILED(hr = m_pTitleArray[iTitle].pExTitle->m_pTitleFTS->Query(pwsBuffer, dwFlags, &pITRS, this, &cWaitDlg, iTitle)))
                    {
                        m_pTitleArray[iTitle].bAlreadyQueried = TRUE;
                        if(hr == FTS_INVALID_SYNTAX || hr == FTS_CANCELED)
                        {
                            m_iLastResultCount = 0;
                            return hr;
                        }
                        continue;
                    }

                    m_pTitleArray[iTitle].bHasResults = TRUE;
                    m_pTitleArray[iTitle].bAlreadyQueried = TRUE;
                    CombinedResultCount+=ComputeResultCount(pITRS);
                }

            }
        }
    }
    lcFree(pwsBuffer);

    // check for zero results
    //
    if(!CombinedResultCount)
    {
        *ppSearchResults = NULL;
        m_iLastResultCount = 0;
        return S_OK;
    }

    // compute the max size of the results structure
    //
    cb = ((CombinedResultCount) * sizeof(SEARCH_RESULT));

    // allocate the results structure
    //
    *ppSearchResults = pNextResult = (SEARCH_RESULT *) lcMalloc(cb);

    // Clear the structure
    //
    memset(pNextResult,0,cb);

    int cFilteredResultCount = 0;

    long lRowCount;

    // Query Phase #3 - collect the query results from each search object
    //
    for(iTitle = 0; iTitle < m_TitleArraySize; ++iTitle)
    {
        if(m_pTitleArray[iTitle].bHasResults)
        {
            if(m_pTitleArray[iTitle].bCombinedIndex)
                pITRS = m_pTitleArray[iTitle].pCombinedFTI->GetResultsSet();
            else if( m_pTitleArray[iTitle].pExTitle->m_pTitleFTS )
                pITRS = m_pTitleArray[iTitle].pExTitle->m_pTitleFTS->GetResultsSet();
            else
              continue;

            if( !pITRS )
              continue;

            // Get the results row count
            //
            pITRS->GetRowCount(lRowCount);

            // Make sure we have results
            //
            if(lRowCount)
            {
                int i,rank = 1;
                CProperty Prop;
                DWORD dwLastTopic = 0xffffffff;

                // walk through the results
                //
                for (i = 0; i < lRowCount; i++)
                {
                    pITRS->Get(i, 0, Prop);

                    if(Prop.dwValue != dwLastTopic)
                    {
                        if(m_pTitleArray[iTitle].bCombinedIndex)
                        {
                            pNextResult->dwTopicNumber = TOPIC_NUM(Prop.dwValue);
                            pNextResult->pTitle = LookupTitle(m_pTitleArray[iTitle].pCombinedFTI,CHM_ID(Prop.dwValue));
                            if(!pNextResult->pTitle)
                                    continue; // skip results from title that are out of date or not loaded

                            if(!pSubSet || pSubSet->m_bIsEntireCollection )  // no subset specified, add the topic
                            {
                                    pNextResult->dwRank = rank++;
                                    pNextResult++;
                                    ++cFilteredResultCount;
                                    dwLastTopic = Prop.dwValue;

                            }
                            else
                                if(pNextResult->pTitle->InfoTypeFilter(pSubSet,pNextResult->dwTopicNumber))
                                {
                                    pNextResult->dwRank = rank++;
                                    pNextResult++;
                                    ++cFilteredResultCount;
                                    dwLastTopic = Prop.dwValue;
                                }
                        }
                        else
                        {
                            pNextResult->dwTopicNumber = Prop.dwValue;
                            pNextResult->pTitle = m_pTitleArray[iTitle].pExTitle;
                            if(!pSubSet || pSubSet->m_bIsEntireCollection )
                            {
                                pNextResult->dwRank = rank++;
                                pNextResult++;
                                ++cFilteredResultCount;
                                dwLastTopic = Prop.dwValue;
                            }
                            else
                                if(pNextResult->pTitle->InfoTypeFilter(pSubSet,pNextResult->dwTopicNumber))
                                {
                                    pNextResult->dwRank = rank++;
                                    pNextResult++;
                                    ++cFilteredResultCount;
                                    dwLastTopic = Prop.dwValue;
                                }
                        }

                    }
                }
            }
        }
    }

    // Save the result count for client
    //
    if(cFilteredResultCount > m_lMaxRowCount)
        *pcResultCount = m_lMaxRowCount;
    else
        *pcResultCount = cFilteredResultCount;


    m_iLastResultCount = *pcResultCount;

#ifdef _DEBUG

    OutputDebugString("FTS: Full-Text Index Query Array\n\n");
    OutputDebugString("Entry      Title          Enabled   CHQ  Results\n");
    OutputDebugString("================================================\n");
    for(iTitle = 0; iTitle < m_TitleArraySize; ++iTitle)
    {
        char szTemp[500];
        wsprintf(szTemp,"%03d     %16s     %1d       %1d     %1d\n",iTitle, m_pTitleArray[iTitle].pszShortName,m_pTitleArray[iTitle].bSearch,m_pTitleArray[iTitle].bCombinedIndex,m_pTitleArray[iTitle].bHasResults);
        OutputDebugString(szTemp);
    }
    OutputDebugString("================================================\n\n");

#endif

//  Below is some test code that dumps the results list to the debug window
//
//  int x;
//  char szTemp[100];
//  for(x=0;x<cFilteredResultCount;++x)
//  {
//      wsprintf(szTemp,"Title=%0x Rank=%03d\n",(*ppSearchResults)[x].pTitle,(*ppSearchResults)[x].dwRank);
//      OutputDebugString(szTemp);
//  }

    QSort(*ppSearchResults,cFilteredResultCount,sizeof(SEARCH_RESULT),CompareIntValues);

    return S_OK;
}

int FASTCALL CompareIntValues(const void *pval1, const void *pval2)
{
    return ((SEARCH_RESULT *)pval1)->dwRank - ((SEARCH_RESULT *)pval2)->dwRank;
}

long CFullTextSearch::ComputeResultCount(IITResultSet *pResultSet)
{
    long count = 0, uniqueCount = 0;

    if(!pResultSet)
        return 0;

    if(FAILED(pResultSet->GetRowCount(count)))
        return 0;

    if(count)
    {
        int i;
        CProperty Prop;
        DWORD dwLastTopic = 0xffffffff;

        // walk through the results
        //
        for (i = 0; i < count; i++)
        {
            pResultSet->Get(i, 0, Prop);
            if(Prop.dwValue != dwLastTopic)
            {
                ++uniqueCount;
                dwLastTopic = Prop.dwValue;
            }
        }
    }
    return uniqueCount;
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch lookup title
//
CExTitle *CFullTextSearch::LookupTitle(CCombinedFTS *pCombinedFTS, DWORD dwValue)
{
    static CCombinedFTS *pCacheObject= NULL;
    static DWORD pCacheValue = NULL;
    static CExTitle *pPreviousResult;

    // see if we are looking up the same title again
    //
    if(pCacheObject == pCombinedFTS && dwValue == pCacheValue)
        return pPreviousResult;

    INT iTitle;

    for(iTitle = 0; iTitle < m_TitleArraySize; ++iTitle)
    {
        if(m_pTitleArray[iTitle].pCombinedFTI == pCombinedFTS &&
            m_pTitleArray[iTitle].iTitleIndex == dwValue && m_pTitleArray[iTitle].bCombinedIndex)
        {
            pCacheObject = pCombinedFTS;
            pCacheValue = dwValue;
            pPreviousResult = m_pTitleArray[iTitle].pExTitle;
            return m_pTitleArray[iTitle].pExTitle;
        }
    }

    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch Initialize title array
//
void CFullTextSearch::InitTitleArray()
{
    if(m_bTitleArrayInit)
        return;

    m_TitleArraySize = 0;

    // Iterate through the titles
    //
    CExTitle *pTitle = m_pTitleCollection->GetFirstTitle();

    // Count the entries in the title list
    //
    while(pTitle)
    {
        pTitle = pTitle->GetNext();
        ++m_TitleArraySize;
    }

    int cb = m_TitleArraySize * sizeof(TITLE_ENTRY);

    // allocate the results structure
    //
    m_pTitleArray = (TITLE_ENTRY *) lcMalloc(cb);

    if(!m_pTitleArray)
        return;

    // Clear the structure
    //
    memset(m_pTitleArray,0,cb);

    // Iterate through the titles and init members
    //
    pTitle = m_pTitleCollection->GetFirstTitle();

    INT iTitle;

    for(iTitle = 0; iTitle < m_TitleArraySize; ++iTitle)
    {
        if(pTitle == NULL)
        {
            lcFree(m_pTitleArray);
            m_pTitleArray = NULL;
            return;
        }
        m_pTitleArray[iTitle].pExTitle = pTitle;
        char *pszQueryName = (char *) pTitle->GetQueryName();
        if(pszQueryName && *pszQueryName)
        {
            m_pTitleArray[iTitle].pszQueryName = lcStrDup(pszQueryName);
            m_pTitleArray[iTitle].bCombinedIndex = TRUE;
        }
        else
            m_pTitleArray[iTitle].bCombinedIndex = FALSE;

        // Check if combined index for master chm exists
		// This feature was added for NT5
		//
        if(iTitle == 0 && m_pTitleCollection->IsSingleTitle())
		{
            char *pszFilePath = lcStrDup((char *) pTitle->GetIndexFileName());
			if(pszFilePath)
			{
			    _strupr(pszFilePath);
                char *pszTemp = strstr(pszFilePath,".CHM");
				if(pszTemp)
				{
				    pszTemp[3] = 'Q';    
					// Check if combined index exists
					//
					if(IsFile(pszFilePath))
					{
			            m_pTitleArray[iTitle].pszQueryName = lcStrDup(pszFilePath);
						m_pTitleArray[iTitle].bCombinedIndex = TRUE;
						m_bMergedChmSetWithCHQ = TRUE;  // This disables CD swapping
					}
				}
                if(pszFilePath)
    				lcFree(pszFilePath);
			}
		}

        if(!m_pTitleCollection->IsSingleTitle())
    		m_bMergedChmSetWithCHQ = FALSE;
			
        // Get version and name info from the index file
        //
        m_pTitleArray[iTitle].pszIndexName = lcStrDup((char *) pTitle->GetIndexFileName());
        CTitleInformation2 Info2(m_pTitleArray[iTitle].pszIndexName);
        m_pTitleArray[iTitle].pszShortName = lcStrDup(Info2.GetShortName());
        m_pTitleArray[iTitle].versioninfo  = Info2.GetFileTime();
        m_pTitleArray[iTitle].language = Info2.GetLanguage();


        // Mark title as having a internal FTI for now.  If the title is not part of a combined index
        // I'll check for FTI before querying (this prevents opening all the titles during this
        // initialization (which saves about 80% on init time).
        //
        m_pTitleArray[iTitle].bSearch = TRUE;

        WORD wTitlePrimaryLang = PRIMARYLANGID(LANGIDFROMLCID(m_pTitleArray[iTitle].language));

        if(m_SystemLangID == LANG_JAPANESE || m_SystemLangID == LANG_KOREAN ||
            m_SystemLangID == LANG_CHINESE)
      {
          // Disable a DBCS title not running on a corresponding DBCS OS
         //
          if(m_SystemLangID != wTitlePrimaryLang && (wTitlePrimaryLang == LANG_JAPANESE
            || wTitlePrimaryLang == LANG_KOREAN || wTitlePrimaryLang == LANG_CHINESE))
                m_pTitleArray[iTitle].bSearch = FALSE;
      }

        // get the volume order
        pTitle->GetVolumeOrder( &(m_pTitleArray[iTitle].uiVolumeOrder),
                    pszQueryName ? HHRMS_TYPE_COMBINED_QUERY : HHRMS_TYPE_TITLE );

        pTitle = pTitle->GetNext();
    }

    // sort the title list based on volume order
	if(!m_bMergedChmSetWithCHQ)
	    QSort( m_pTitleArray, m_TitleArraySize, sizeof(TITLE_ENTRY), CompareVolumeOrder );

    m_bTitleArrayInit = TRUE;

}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch GetPreviousInstance
//
CCombinedFTS *CFullTextSearch::GetPreviousInstance(char *pszQueryName)
{
    static char *pCacheName = NULL;
    static CCombinedFTS *pCacheObject = NULL;

    if(pCacheName)
        if(!strcmp(pszQueryName,pCacheName))
            return pCacheObject;

    INT iTitle;

    for(iTitle = 0; iTitle < m_TitleArraySize; ++iTitle)
    {
        if(!strcmp(m_pTitleArray[iTitle].pszQueryName,pszQueryName) && m_pTitleArray[iTitle].pCombinedFTI)
        {
            pCacheName = pszQueryName;
            pCacheObject = m_pTitleArray[iTitle].pCombinedFTI;
            return m_pTitleArray[iTitle].pCombinedFTI;
        }

    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch LoadCombinedIndex
//
BOOL CFullTextSearch::LoadCombinedIndex(DWORD iCurTitle)
{
    HRESULT hr;

    CCombinedFTS *pCombinedFTS = NULL;

    CFileSystem* pDatabase = new CFileSystem;

    char *pszQueryName = m_pTitleArray[iCurTitle].pszQueryName;

    if( SUCCEEDED(hr = pDatabase->Init()) && SUCCEEDED(hr = pDatabase->Open(pszQueryName)))
    {
        CSubFileSystem* pTitleMap = new CSubFileSystem( pDatabase );
        if( SUCCEEDED(hr = pTitleMap->OpenSub( "$TitleMap" ) ) )
        {
            ULONG cbRead = 0;
            WORD wCount = 0;
            pTitleMap->ReadSub( (void*) &wCount, sizeof(wCount), &cbRead );

            for( int iCount = 0; iCount < (int) wCount; iCount++ )
            {
                CHM_MAP_ENTRY mapEntry;

                pTitleMap->ReadSub( (void*) &mapEntry, sizeof(mapEntry), &cbRead );

                if(cbRead != sizeof(mapEntry))
                    return FALSE;

                INT iTitle;

                // walk through the title array and set title index for matching titles
                //
                for(iTitle = 0; iTitle < m_TitleArraySize; ++iTitle)
                {
                    // if a combined index wasn't specified for the title, skip it
                    //
                    if(!m_pTitleArray[iTitle].pszQueryName && !m_bMergedChmSetWithCHQ)
                        continue;

                    FILETIME titleTime = m_pTitleArray[iTitle].versioninfo;
                    char *pszShortName = m_pTitleArray[iTitle].pszShortName;
                    if(!strcmpi(mapEntry.szChmName,pszShortName) && !m_pTitleArray[iTitle].pCombinedFTI &&
                        (!strcmpi(pszQueryName,m_pTitleArray[iTitle].pszQueryName) || m_bMergedChmSetWithCHQ) &&
                        mapEntry.language == m_pTitleArray[iTitle].language &&
                        (mapEntry.versioninfo.dwLowDateTime == titleTime.dwLowDateTime &&
                        mapEntry.versioninfo.dwHighDateTime == titleTime.dwHighDateTime ))
                    {
                        if(!pCombinedFTS)
                        {
                             pCombinedFTS = m_pTitleArray[iTitle].pCombinedFTI =
                             new CCombinedFTS(m_pTitleArray[iTitle].pExTitle,
                             m_pTitleArray[iTitle].pExTitle->GetInfo2()->GetLanguage(), this);
                             // This is the master title for this combined index
                             //
                             m_pTitleArray[iTitle].bSearch = TRUE;
                        }
                        else
                        {
                            m_pTitleArray[iTitle].pCombinedFTI = pCombinedFTS;
                            m_pTitleArray[iTitle].bSearch = TRUE;
                        }
                        m_pTitleArray[iTitle].bCombinedIndex = TRUE;
                        m_pTitleArray[iTitle].versioninfo = mapEntry.versioninfo;
                        m_pTitleArray[iTitle].iTitleIndex = mapEntry.iIndex;
                        m_pTitleArray[iTitle].dwTopicCount = mapEntry.dwTopicCount;
                    }
                }
            }
        }
        delete pTitleMap;
    }

    delete pDatabase;

	// special case where the master chm is out of date in respects to combined index (NT5)
	//
	if(m_bMergedChmSetWithCHQ && m_pTitleArray[0].bCombinedIndex && !m_pTitleArray[0].pCombinedFTI)
		m_pTitleArray[0].bCombinedIndex = 0;


#ifdef _DEBUG
/*
    INT iTitle;

    OutputDebugString("Full-Text Search Query Map Array:\n");
    for(iTitle = 0; iTitle < m_TitleArraySize; ++iTitle)
    {
        char szTemp[500];
        wsprintf(szTemp,"  %d bSearch=%d bCombinedIndex=%d iIndex=%02d pExTitle=%d pCombinedFTI=%d\n",iTitle,
            m_pTitleArray[iTitle].bSearch,m_pTitleArray[iTitle].bCombinedIndex,m_pTitleArray[iTitle].iTitleIndex,
            m_pTitleArray[iTitle].pExTitle,m_pTitleArray[iTitle].pCombinedFTI);
        OutputDebugString(szTemp);
    }
*/
#endif


    // Check to see if the title that initiated the loading of this combined index
    // was validated for this index.
    if(m_pTitleArray[iCurTitle].pCombinedFTI)
        return TRUE;
    else
        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch abort query function
//
HRESULT CFullTextSearch::AbortQuery()
{
    if(!m_bInit)
        return E_FAIL;

    CExTitle *pTitle = m_pTitleCollection->GetFirstTitle();

    while(pTitle)
    {
        // BUGBUG: If this is the first title in a collection, it will
        // reread the system data.
        CTitleInformation *pTitleInfo = pTitle->GetInfo();
        if(pTitleInfo && pTitleInfo->IsFullTextSearch())
        {
            pTitle->m_pTitleFTS->AbortQuery();
        }
        pTitle = pTitle->GetNext();
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch set query options
//
// dwFlag can be one or more of the following:
//
// IMPLICIT_AND
//   Search terms are AND'd if no operator is specified
//
// IMPLICIT_OR
//   Search terms are OR'd if no operator is specified
//
// COMPOUNDWORD_PHRASE
//   Use PHRASE operator for compound words
//
// QUERYRESULT_RANK
//   Results are returned in ranked order
//
// QUERYRESULT_UIDSORT
//   Results are returned in UID order
//
// QUERYRESULT_SKIPOCCINFO
//   Only topic-level hit information is returned
//
// STEMMED_SEARCH
//   The search returns stemmed results
//
HRESULT CFullTextSearch::SetOptions(DWORD dwFlag)
{
    if(!m_bInit)
        return E_FAIL;

    m_dwQueryFlags = dwFlag;

    CExTitle *pTitle = m_pTitleCollection->GetFirstTitle();

    while(pTitle)
    {
        // BUGBUG: If this is the first title in a collection, it will
        // reread the system data.
        CTitleInformation *pTitleInfo = pTitle->GetInfo();
        if(pTitleInfo && pTitleInfo->IsFullTextSearch())
        {
            pTitle->m_pTitleFTS->SetOptions(dwFlag);
        }
        pTitle = pTitle->GetNext();
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch set proximity
//
HRESULT CFullTextSearch::SetProximity(WORD wNear)
{
    if(!m_bInit)
        return E_FAIL;

    CExTitle *pTitle = m_pTitleCollection->GetFirstTitle();

    while(pTitle)
    {
        // BUGBUG: If this is the first title in a collection, it will
        // reread the system data.
        CTitleInformation *pTitleInfo = pTitle->GetInfo();
        if(pTitleInfo && pTitleInfo->IsFullTextSearch())
        {
            pTitle->m_pTitleFTS->SetProximity(wNear);
        }
        pTitle = pTitle->GetNext();
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch set result count
//   This sets max number of rows to be returned by query
//
HRESULT CFullTextSearch::SetResultCount(LONG cRows)
{
    if(!m_bInit)
        return E_FAIL;

    CExTitle *pTitle = m_pTitleCollection->GetFirstTitle();

    while(pTitle)
    {
        // BUGBUG: If this is the first title in a collection, it will
        // reread the system data.
        CTitleInformation *pTitleInfo = pTitle->GetInfo();
        if(pTitleInfo && pTitleInfo->IsFullTextSearch())
        {
            pTitle->m_pTitleFTS->SetResultCount(cRows);
        }
        pTitle = pTitle->GetNext();
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch free results data structure
//
VOID CFullTextSearch::FreeResults(SEARCH_RESULT *pResults)
{
    if(!m_bInit)
        return;

    if(pResults)
        lcFree(pResults);
}
/*
/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch AddHLTerm
//      Add a term to the highlight list
//
HRESULT CFullTextSearch::AddHLTerm(WCHAR *pwcTerm)
{
    if(!pwcTerm || !*pwcTerm)
        return E_FAIL;

    if(m_iHLIndex < MAX_HIGHLIGHT_TERMS)
        return E_FAIL;

    int len = (wcslen(pwcTerm) + 1) * sizeof(WCHAR);

    m_HLTermArray[m_iHLIndex] = (WCHAR *) lcMalloc(len);

    wcscpy(m_HLTermArray[m_iHLIndex],pwcTerm);

    m_iHLIndex++;

    return S_OK;
}
*/
/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch AddHLTerm
//      Add a term to the highlight list
//
HRESULT CFullTextSearch::AddHLTerm(WCHAR *pwcTerm, int cTermLength)
{
    if(!pwcTerm || !*pwcTerm || !cTermLength)
        return E_FAIL;


    if(*pwcTerm == L')' || *pwcTerm == L'(' || *pwcTerm == L'\"')
        return S_OK;

    if(m_iHLIndex >= MAX_HIGHLIGHT_TERMS)
        return E_FAIL;

    if(!wcsnicmp(pwcTerm,L"HHTitleID",9))
        return S_OK;
    
    int i;

    // do not accept duplicates
    //
    for(i=0;i<m_iHLIndex;++i)
    {
        int cLen = wcslen(m_HLTermArray[i]);
    
        if(cTermLength == cLen && !wcsnicmp(pwcTerm, m_HLTermArray[i], cLen))
            return S_OK;
    }

    int len = (cTermLength + 1) * sizeof(WCHAR);

    m_HLTermArray[m_iHLIndex] = (WCHAR *) lcMalloc(len);

    CopyMemory(m_HLTermArray[m_iHLIndex],pwcTerm,len-sizeof(WCHAR));

    *(m_HLTermArray[m_iHLIndex]+cTermLength) = NULL;

    m_iHLIndex++;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch AddHLTerm
//      Add a term to the highlight list
//
HRESULT CFullTextSearch::AddQueryToTermList(WCHAR *pwsBuffer)
{
    WCHAR *pwsStart, *pwsTemp = pwsBuffer;

    if(!pwsBuffer || !*pwsBuffer)
	    return E_FAIL;

    while(*pwsTemp)
    {
        // Remove white space
        //
        while(*pwsTemp && (*pwsTemp == L' ' || *pwsTemp == L'(' || *pwsTemp == L')'))
            ++pwsTemp;

		if(!*pwsTemp)
			continue;

        pwsStart = pwsTemp;

        if(*pwsTemp == L'"')
        {
            pwsStart++;
            pwsTemp++;

            while(*pwsTemp && *pwsTemp != L'"')
                ++pwsTemp;
        }
        else
        {
            while(*pwsTemp && !(*pwsTemp == L' ' || *pwsTemp == L'(' || *pwsTemp == L')'))
                ++pwsTemp;
        }

		if(!*pwsTemp)
			continue;

        if(pwsStart != pwsTemp)
        {
              if(wcsnicmp(pwsStart,L"and",(int)(pwsTemp-pwsStart)) && wcsnicmp(pwsStart,L"or",(int)(pwsTemp-pwsStart))
                   && wcsnicmp(pwsStart,L"near",(int)(pwsTemp-pwsStart)) && wcsnicmp(pwsStart,L"not",(int)(pwsTemp-pwsStart))
                   && wcsnicmp(pwsStart,L"VFLD 0",(int)(pwsTemp-pwsStart)) && wcsnicmp(pwsStart,L"VFLD 1",(int)(pwsTemp-pwsStart))
                   && wcsnicmp(pwsStart,L"HHTitleID",9))
                    AddHLTerm(pwsStart,(int)(pwsTemp-pwsStart));
        }

        if(!wcsnicmp(pwsStart,L"HHTitleID",(int)(pwsTemp-pwsStart)))
        {
            while(*pwsTemp && !(*pwsTemp == L' ' || *pwsTemp == L'(' || *pwsTemp == L')'))
                ++pwsTemp;
        }

        if(!wcsnicmp(pwsStart,L"VFLD 0",(int)(pwsTemp-pwsStart)) && !wcsnicmp(pwsStart,L"VFLD 1",(int)(pwsTemp-pwsStart)))
            pwsTemp+=2;



        if(*pwsTemp == L'"')
            ++pwsTemp;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch TermListRemoveAll
//      Delete all entries in the highlight term list
//
HRESULT  CFullTextSearch::TermListRemoveAll(void)
{
    int i;

    for(i=0;i<m_iHLIndex;++i)
    {
        if(m_HLTermArray[i])
        {
            lcFree(m_HLTermArray[i]);
            m_HLTermArray[i] = NULL;
        }
    }

    m_iHLIndex = 0;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch  GetHLTerm
//      Retrieve a term from the highlight term list
//
WCHAR *  CFullTextSearch::GetHLTermAt(int index)
{
    if(index >= m_iHLIndex)
        return NULL;

    return m_HLTermArray[index];
}

/////////////////////////////////////////////////////////////////////////////
// CFullTextSearch GetHLTermCount
//      Get the count of entries in the highlight term list
//
INT  CFullTextSearch::GetHLTermCount(void)
{
    return m_iHLIndex;
}


/////////////////////////////////////////////////////////////////////////////
// CTitleFTS Class
//
// This class provides full-text search functionality for a single open
// title.  In a multi-title environment, there will be an instance of this
// class for each open title.
//
// This class is intended only for use by the CFullTextSearch class which
// provides full-text search services for both single and multi-title
// configurations.


/////////////////////////////////////////////////////////////////////////////
// CTitleFTS class constructor
//
CTitleFTS::CTitleFTS( PCSTR pszTitlePath, LCID lcid, CExTitle *pTitle)
{
    MultiByteToWideChar(CP_ACP, 0, pszTitlePath, -1, m_tcTitlePath, sizeof(m_tcTitlePath) );
    m_lcid = lcid;
	m_langid = LANGIDFROMLCID(lcid);
	m_codepage = CodePageFromLCID(lcid);
    m_bInit  = FALSE;
    m_SearchActive = FALSE;
    m_pIndex = NULL;
    m_pQuery = NULL;
    m_pITResultSet = NULL;
    m_pITDB = NULL;
    m_InitFailed = FALSE;
    m_InitError = E_FAIL;
    m_pTitle = pTitle;
    m_pPrevQuery = NULL;

    m_SystemLangID = PRIMARYLANGID(GetSystemDefaultLangID());
    m_fDBCS = FALSE;

    m_lMaxRowCount = 500;
    m_wQueryProximity = 8;
    m_iLastResultCount = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleFTS class destructor
//
CTitleFTS::~CTitleFTS()
{
    ReleaseObjects();
    if(m_pPrevQuery)
        lcFree(m_pPrevQuery);
}

/////////////////////////////////////////////////////////////////////////////
// CTitleFTS release objects
//
void CTitleFTS::ReleaseObjects()
{
    if(!m_bInit)
        return;

    if (m_pITResultSet)
    {
        m_pITResultSet->Clear();
        m_pITResultSet->Release();
    }

    if(m_pQuery)
        m_pQuery->Release();

    if(m_pIndex)
    {
        m_pIndex->Close();
        m_pIndex->Release();
    }

    if(m_pITDB)
    {
        m_pITDB->Close();
        m_pITDB->Release();
    }

   m_pITResultSet = NULL;
   m_pQuery = NULL;
   m_pIndex = NULL;
   m_pITDB = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleFTS class initialization
//
HRESULT CTitleFTS::Initialize()
{
    if(m_InitFailed)
        return E_FAIL;

    if(m_bInit)
        return S_OK;

    m_InitFailed = TRUE;

    WORD PrimaryLang = PRIMARYLANGID(m_langid);
  
    if(PrimaryLang == LANG_JAPANESE || PrimaryLang == LANG_CHINESE || PrimaryLang == LANG_KOREAN)
	    m_fDBCS = TRUE;
	else
	    m_fDBCS = FALSE;  

    if(m_lcid == 1033)
        m_dwQueryFlags = IMPLICIT_AND | QUERY_GETTERMS | STEMMED_SEARCH; // QUERYRESULT_RANK
    else
        m_dwQueryFlags = IMPLICIT_AND | QUERY_GETTERMS;

    //  char szLangID[20];
    //GetLocaleInfo(m_lcid,LOCALE_ILANGUAGE,szLangID,sizeof(szLangID));

    // Make sure we have a path
    //
    if(!*m_tcTitlePath)
    {
        m_InitError = FTS_NOT_INITIALIZED;
        return E_FAIL;
    }

    // DOUGO - insert code here to initialize language information

    // Get IITIndex pointer
    //
    HRESULT hr = CoCreateInstance(CLSID_IITIndexLocal, NULL, CLSCTX_INPROC_SERVER,
                     IID_IITIndex, (VOID**)&m_pIndex);
    if (FAILED(hr))
    {
        m_InitError = FTS_NOT_INITIALIZED;
        return E_FAIL;
    }

    // Get IITDatabase pointer
    //
    hr = CoCreateInstance(CLSID_IITDatabaseLocal, NULL, CLSCTX_INPROC_SERVER,
                     IID_IITDatabase, (VOID**)&m_pITDB);
    if (FAILED(hr))
    {
        m_InitError = FTS_NOT_INITIALIZED;
        return E_FAIL;
    }

    // Open the storage system
    //
    hr = m_pITDB->Open(NULL, m_tcTitlePath, NULL);
    if (FAILED(hr))
    {
        m_InitError = FTS_NO_INDEX;
        return E_FAIL;
    }

    // open the index.
    //
    hr = m_pIndex->Open(m_pITDB, txtwFtiMain, TRUE);
    if (FAILED(hr))
    {
        m_InitError = FTS_NO_INDEX;
        return E_FAIL;
    }

    // Create query instance
    //
    hr = m_pIndex->CreateQueryInstance(&m_pQuery);
    if (FAILED(hr))
    {
        m_InitError = FTS_NOT_INITIALIZED;
        return E_FAIL;
    }

    // set search options
    //
    hr = m_pQuery->SetOptions(m_dwQueryFlags);
    if (FAILED(hr))
    {
        m_InitError = FTS_NOT_INITIALIZED;
        return E_FAIL;
    }

    // Create Result Set object
    //
    hr = CoCreateInstance(CLSID_IITResultSet, NULL, CLSCTX_INPROC_SERVER,
                          IID_IITResultSet, (VOID**) &m_pITResultSet);
    if (FAILED(hr))
    {
        m_InitError = FTS_NOT_INITIALIZED;
        return E_FAIL;
    }

    m_bInit = TRUE;
    m_InitFailed = FALSE;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleFTS query function
//
HRESULT CTitleFTS::Query(WCHAR *pwcQuery, DWORD dwFlags, IITResultSet **ppITRS, CFullTextSearch *pFullTextSearch, CUWait *pWaitDlg, int iTitle)
{
    HRESULT hr;

    WCHAR *pNewQuery = NULL;
	
    if(!Init())
        return m_InitError;

    // Reinit the object if the dirty bit is set
   //
    if(m_pTitle->m_pCollection->m_Collection.IsDirty())
    {
       ReleaseObjects();
        MultiByteToWideChar(CP_ACP, 0, m_pTitle->GetContentFileName(), -1, m_tcTitlePath, sizeof(m_tcTitlePath) );
        m_InitFailed = FALSE;
        m_bInit = FALSE;
        m_InitError = E_FAIL;
        if(!Init())
            return m_InitError;
    }

    WCHAR *pszQuery = pwcQuery;
	
    pszQuery = PreProcessQuery(pwcQuery, m_codepage);

    if(!pszQuery)
	    return E_FAIL;

    *ppITRS = NULL;

    // return if search previous set, but no previous query
    //
    if((dwFlags & FTS_SEARCH_PREVIOUS) && !m_pPrevQuery)
        return S_OK;

    // If this title resulted in no hits last query, but the global result count was non-zero, then 
    // return no hits.  The only time we want to query this title using the last known good query is
    // when the global query count (combined results) was also zero.  In that case, we want to 
    // revert all titles and combined indexes back to the last known good query.  Otherwise, we skip
    // this title because the last query (which resulted in some results globally) is still valid.
    //
    if((dwFlags & FTS_SEARCH_PREVIOUS) && pFullTextSearch->m_iLastResultCount && !m_iLastResultCount)
    {
        lcFree(m_pPrevQuery);
		m_pPrevQuery = NULL;
        return S_OK;
    }

    WCHAR *pPrevQuerySaved = NULL;
	
    if(m_pPrevQuery)
	{
        pPrevQuerySaved = (WCHAR *) lcMalloc((wcslen(m_pPrevQuery)+ 2) * sizeof(WCHAR));
        wcscpy(pPrevQuerySaved,m_pPrevQuery);		
	}

    CStructuralSubset *pSubset;

    // Check if this title is part of the current subset
    //
    if(m_pTitle->m_pCollection && m_pTitle->m_pCollection->m_pSSList)
        if( (pSubset = m_pTitle->m_pCollection->m_pSSList->GetFTS()) && !pSubset->IsEntire() )
            if(!pSubset->IsTitleInSubset(m_pTitle) && !(dwFlags & FTS_SEARCH_PREVIOUS) )
            {
                // clear the previous results
                //
                hr = m_pITResultSet->Clear();
                m_iLastResultCount = 0;
                if(m_pPrevQuery)
                    lcFree(m_pPrevQuery);
           		m_pPrevQuery = NULL;
               if(pPrevQuerySaved)
	              lcFree(pPrevQuerySaved);
                return S_OK;
            }
    if(dwFlags & FTS_ENABLE_STEMMING)
        m_dwQueryFlags |= STEMMED_SEARCH;
     else
        m_dwQueryFlags &= (~STEMMED_SEARCH);

    // Set previous options
    //
    m_pQuery->ReInit();
    m_pQuery->SetOptions(m_dwQueryFlags);
    m_pQuery->SetResultCount(m_lMaxRowCount);
    m_pQuery->SetProximity(m_wQueryProximity);

    FCALLBACK_MSG fCallBackMsg;

    fCallBackMsg.MessageFunc = SearchMessageFunc;
    fCallBackMsg.pUserData = (PVOID)pWaitDlg;
    fCallBackMsg.dwFlags = 0;  // not recommended for use
    m_pQuery->SetResultCallback(&fCallBackMsg);

    // Search Previous
	//
    if(dwFlags & FTS_SEARCH_PREVIOUS)
    {
        // append new query onto old query for "search previous"
        //
        int cQuery = wcslen(pszQuery);
        int cPrevQuery = wcslen(m_pPrevQuery);
        pNewQuery = (WCHAR *) lcMalloc((cQuery+cPrevQuery+20) * sizeof(WCHAR));
        if(!pNewQuery)
            return E_FAIL;

        *pNewQuery = 0;
        wcscat(pNewQuery,m_pPrevQuery);
        wcscat(pNewQuery,L" and ");
        wcscat(pNewQuery,pszQuery);
        wcscat(pNewQuery,L" ");
    }

    // free the previous prev query
    //
    if(m_pPrevQuery)
	{
        lcFree(m_pPrevQuery);
		m_pPrevQuery = NULL;
	}
    // Save the new query for next time
    //
    if(pNewQuery)
        m_pPrevQuery = (WCHAR *) lcMalloc((wcslen(pNewQuery)+ 2) * sizeof(WCHAR));
    else
        m_pPrevQuery = (WCHAR *) lcMalloc((wcslen(pszQuery)+ 2) * sizeof(WCHAR));

    if(pNewQuery)
        wcscpy(m_pPrevQuery,pNewQuery);
    else
        wcscpy(m_pPrevQuery,pszQuery);

    // clear the previous results
    //
    hr = m_pITResultSet->Clear();
    if (FAILED(hr))
    {
        // Error clearing results set
        if(pPrevQuerySaved)
	        lcFree(pPrevQuerySaved);
        return E_FAIL;
    }

    // we want topic numbers back
    //
    hr = m_pITResultSet->Add(STDPROP_UID, (DWORD) 0, PRIORITY_NORMAL);
    if (FAILED(hr))
    {
        // Error adding result property
        m_InitError = FTS_NOT_INITIALIZED;
       if(pPrevQuerySaved)
	      lcFree(pPrevQuerySaved);
        return E_FAIL;
    }

    hr = m_pITResultSet->Add(STDPROP_TERM_UNICODE_ST, (DWORD)NULL, PRIORITY_NORMAL);
    if (FAILED(hr))
    {
        // Error adding result property
        m_InitError = FTS_NOT_INITIALIZED;
        if(pPrevQuerySaved)
	      lcFree(pPrevQuerySaved);
        return E_FAIL;

    }

    hr = m_pITResultSet->Add(STDPROP_COUNT, (DWORD)NULL, PRIORITY_NORMAL);
    if (FAILED(hr))
    {
        // Error adding result property
        m_InitError = FTS_NOT_INITIALIZED;
        if(pPrevQuerySaved)
	        lcFree(pPrevQuerySaved);
        return E_FAIL;
    }

    // Set the query
    //
    if(pNewQuery)
	{
        pFullTextSearch->AddQueryToTermList(pNewQuery);
        hr = m_pQuery->SetCommand(pNewQuery);
//		MessageBoxW(NULL,pNewQuery,L"Query",MB_OK);
	}
    else
	{
        pFullTextSearch->AddQueryToTermList(pszQuery);
        hr = m_pQuery->SetCommand(pszQuery);
//		MessageBoxW(NULL,pwcQuery,L"Query",MB_OK);		
	}

    if (FAILED(hr))
    {
        // Error setting query
       if(pPrevQuerySaved)
	      lcFree(pPrevQuerySaved);
        return E_FAIL;
    }

    if(pNewQuery)
        lcFree(pNewQuery);

    // Execute the query
    //
    hr = m_pIndex->Search(m_pQuery, m_pITResultSet);

    // if we receive a no stemmer error, re-query with stemming turned off
    //
    if(hr == E_NOSTEMMER)
    {
        m_dwQueryFlags &= (~STEMMED_SEARCH);
        m_pQuery->SetOptions(m_dwQueryFlags);
        m_pQuery->SetCommand(pszQuery);
        hr = m_pIndex->Search(m_pQuery, m_pITResultSet);
    }

    long lRowCount;

    m_pITResultSet->GetRowCount(lRowCount);

    m_iLastResultCount = lRowCount;

    // If query failed, then restore the previous query (for next search previous)
	//
    if((FAILED(hr) || !lRowCount) && pPrevQuerySaved)
	{
        if(m_pPrevQuery)
	        lcFree(m_pPrevQuery);
			
        m_pPrevQuery = (WCHAR *) lcMalloc((wcslen(pPrevQuerySaved)+ 2) * sizeof(WCHAR));
        wcscpy(m_pPrevQuery,pPrevQuerySaved);		
	}

    if(pPrevQuerySaved)
        lcFree(pPrevQuerySaved);

    if (hr ==E_NULLQUERY || hr == E_MISSQUOTE || hr == E_EXPECTEDTERM || hr == E_MISSLPAREN
        || hr == E_MISSRPAREN || hr == E_ALL_WILD)
    {
        // Error invalid syntax
        //
        return FTS_INVALID_SYNTAX;
    }

    if(hr == FTS_CANCELED)
        return FTS_CANCELED;

    // Generic error
    //
    if (FAILED(hr))
        return E_FAIL;

    // Add search terms to term list
    //

    // Make sure we have results
    //
    if(lRowCount)
    {
        WCHAR wcBuffer[2048];

        int i;
        CProperty Prop, Prop2, Prop3;
        DWORD dwLastTopic = 0xffffffff, dwNextWordCount;

        WCHAR *pwcTemp = wcBuffer;

        *pwcTemp = 0;

        // prime the topic number
        //
        m_pITResultSet->Get(0,0, Prop3);
        dwLastTopic = Prop3.dwValue;

        // walk through the results
        //
        for (i = 0; i < lRowCount; i++)
        {
            m_pITResultSet->Get(i,0, Prop3);
            if(i<lRowCount)
            {
                m_pITResultSet->Get(i+1,2, Prop2);
                dwNextWordCount = Prop2.dwValue;
            }
            else
                dwNextWordCount = 0;

            m_pITResultSet->Get(i,1, Prop);
            m_pITResultSet->Get(i,2, Prop2);

         if(!Prop.dwValue)
            continue;

         WORD wFlags[2];
		 wFlags[0]=0;

		 // Convert term from Unicode to ANSI because GetStringTypeW is not supported on Win95.
		 //
         WORD dwStrLen = (WORD)(wcslen(&Prop.lpszwData[1]) * sizeof(WCHAR));
         if(dwStrLen)
         {
             char *pAnsiString = (char *) lcMalloc(dwStrLen);
			 DWORD dwTermLen = 1;

             //UNICODE WORK:  will have to use title cp when doing this conversion to ANSI (Damn Win98 and no Unicode support!!).

             WideCharToMultiByte(m_codepage, 0, Prop.lpszwData + 1, -1, pAnsiString, dwStrLen, NULL, NULL);
             
			 if(IsDBCSLeadByteEx(m_codepage, *pAnsiString))
				dwTermLen=2;

             GetStringTypeA(m_lcid, CT_CTYPE3, pAnsiString, dwTermLen, wFlags);

             lcFree(pAnsiString);
         }		 
         // skip DB chars (DB words were already added)
         //
         if(wFlags[0] & C3_FULLWIDTH || wFlags[0] & C3_KATAKANA || wFlags[0] & C3_HIRAGANA)
         {
            if(*pwcTemp)
            {
                   pFullTextSearch->AddHLTerm(wcBuffer,wcslen(wcBuffer));
                  pwcTemp = wcBuffer;
               *pwcTemp = 0;
            }
            dwLastTopic = Prop3.dwValue;
            continue;
         }

            CopyMemory(pwcTemp, Prop.lpszwData + 1, (*((WORD *)Prop.lpszwData) * sizeof(WCHAR)));
            pwcTemp+=*((WORD *)Prop.lpszwData);
            *pwcTemp = 0;

            if(dwNextWordCount != (Prop2.dwValue+1) || (wcslen(wcBuffer) > 500))
            {
                pFullTextSearch->AddHLTerm(wcBuffer,wcslen(wcBuffer));
                pwcTemp = wcBuffer;
            *pwcTemp = 0;
            }
            else
            {
                *pwcTemp++ = L' ';
                *pwcTemp = 0;
            }
            dwLastTopic = Prop3.dwValue;
        }
    }

    // Send the results set back
    //
    *ppITRS = m_pITResultSet;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleFTS abort current query
//
HRESULT CTitleFTS::AbortQuery()
{
    if(!Init())
        return E_FAIL;

    // DOUGO - insert abort code here when Centaur support is available

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleFTS update FTS options without calling into Centaur
//
HRESULT CTitleFTS::UpdateOptions(WORD wNear, LONG cRows)
{
    m_wQueryProximity = wNear;
    m_lMaxRowCount = cRows;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTitleFTS set title FTS options
//
HRESULT CTitleFTS::SetOptions(DWORD dwFlag)
{
    HRESULT hr;

    if(!Init())
        return E_FAIL;

    m_dwQueryFlags = dwFlag;

    hr = m_pQuery->SetOptions(dwFlag);

    if (FAILED(hr))
        return E_FAIL;
    else
        return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleFTS set proximity for title
//
HRESULT CTitleFTS::SetProximity(WORD wNear)
{
    if(!Init())
        return E_FAIL;

    m_wQueryProximity = wNear;
    return m_pQuery->SetProximity(wNear);
}

/////////////////////////////////////////////////////////////////////////////
// CTitleFTS set max result count for title query
//
HRESULT CTitleFTS::SetResultCount(LONG cRows)
{
    if(!Init())
        return E_FAIL;

    m_lMaxRowCount = cRows;

    return m_pQuery->SetResultCount(cRows);
}

// Han2Zen
//
// This function converts half-width katakana character to their
// full-width equivalents while taking into account the nigori
// and maru marks.
//
DWORD Han2Zen(unsigned char *lpInBuffer, unsigned char *lpOutBuffer, UINT codepage )
{
   // Note: The basic algorithm (including the mapping table) used here to
   // convert half-width Katakana characters to full-width Katakana appears
   // in the book "Understanding Japanese Information Systems" by
   // O'Reily & Associates.

    while(*lpInBuffer)
    {
        if(*lpInBuffer >= 161 && *lpInBuffer <= 223)
        {
            // We have a half-width Katakana character. Now compute the equivalent
            // full-width character via the mapping table.
            //
            *lpOutBuffer     = (unsigned char)mtable[*lpInBuffer-161][0];
            *(lpOutBuffer+1) = (unsigned char)mtable[*lpInBuffer-161][1];

            lpInBuffer++;

            // check if the second character is nigori mark.
            //
            if(*lpInBuffer == 222)
            {
                // see if we have a half-width katakana that can be modified by nigori.
                //
                if((*(lpInBuffer-1) >= 182 && *(lpInBuffer-1) <= 196) ||
                   (*(lpInBuffer-1) >= 202 && *(lpInBuffer-1) <= 206) || (*(lpInBuffer-1) == 179))
                {
                    // transform kana into kana with maru
                    //
                    if((*(lpOutBuffer+1) >= 74   && *(lpOutBuffer+1) <= 103) ||
                     (*(lpOutBuffer+1) >= 110 && *(lpOutBuffer+1) <= 122))
                    {
                         (*(lpOutBuffer+1))++;
                         ++lpInBuffer;
                    }
                    else if(*lpOutBuffer == 131 && *(lpOutBuffer+1) == 69)
                    {
                        *(lpOutBuffer+1) = 148;
                        ++lpInBuffer;
                    }
                }
            }
            else if(*lpInBuffer==223) // check if following character is maru mark
            {
                // see if we have a half-width katakana that can be modified by maru.
                //
                if((*(lpInBuffer-1) >= 202 && *(lpInBuffer-1) <= 206))
                {
                    // transform kana into kana with nigori
                    //
                    if(*(lpOutBuffer+1) >= 110 && *(lpOutBuffer+1) <= 122)
                    {
                        *(lpOutBuffer+1)+=2;
                        ++lpInBuffer;
                    }
                }
            }

            lpOutBuffer+=2;
        }
        else
        {
            if(IsDBCSLeadByteEx(codepage, *lpInBuffer))
            {
                *lpOutBuffer++ = *lpInBuffer++;
                if(*lpInBuffer)
                    *lpOutBuffer++ = *lpInBuffer++;
            }
            else
                *lpOutBuffer++ = *lpInBuffer++;
        }
    }

    *lpOutBuffer = 0;
    return TRUE;
}


WCHAR* PreProcessQuery(WCHAR *pwcQuery, UINT codepage)
{
    if(!pwcQuery)
	    return NULL;
    
    char *pszQuery = NULL;

    // compute max length for ANSI/DBCS conversion buffer
	//
	DWORD dwTempLen = ((wcslen(pwcQuery)*2)+4);
	
    // allocate buffer for ANSI/DBCS version of query string
    //	
    char *pszTempQuery1 = (char *) lcMalloc(dwTempLen);

    // return on fail
	//
    if(!pszTempQuery1)
	    return NULL;

    // Convert our Unicode query to ANSI/DBCS
    //    
    int ret = WideCharToMultiByte(codepage, 0, pwcQuery, -1, pszTempQuery1, dwTempLen, "%", NULL);

    // return on fail
    //	
	if(!ret || !pszTempQuery1)
	    return NULL;

    int cUnmappedChars = 0; 
    char *pszTempQuery5 = pszTempQuery1;

    // Count the number of unmappable characters
    //	
	while(*pszTempQuery5)
	{
        if(*pszTempQuery5 == '%')
            ++cUnmappedChars;
            
        if(IsDBCSLeadByteEx(codepage, *pszTempQuery5))
	    {
		    pszTempQuery5++;
			if(*pszTempQuery5)
			    pszTempQuery5++;
		}
		else
	        ++pszTempQuery5;
	}

    // allocate a new buffer large enough for unmapped character place holders plus original query
    //    	
    DWORD dwTranslatedLen = (DWORD)strlen(pszTempQuery1) + (cUnmappedChars * 4) + 16;	

    char *pszTempQuery6 = (char *)lcMalloc(dwTranslatedLen);
    char *pszTempQuery7 = pszTempQuery6;
	
	if(!pszTempQuery6)
	    return NULL;
	
    pszTempQuery5 = pszTempQuery1;
    
    // construct the new query string (inserting unmappable character place holders)
	//
	while(*pszTempQuery5)
	{
	    if(*pszTempQuery5 == '%')
		{
		    ++pszTempQuery5;
		    *pszTempQuery7++='D';
		    *pszTempQuery7++='X';
		    *pszTempQuery7++='O';		
		    continue;
		}

        if(IsDBCSLeadByteEx(codepage, *pszTempQuery5))
	    {
		    *pszTempQuery7++ = *pszTempQuery5++;
			if(*pszTempQuery5)
    		    *pszTempQuery7++ = *pszTempQuery5++;
		}
		else
            *pszTempQuery7++ = *pszTempQuery5++;
	}

    *pszTempQuery7 = 0;

    lcFree(pszTempQuery1);
		
    char *pszTempQuery2 = pszTempQuery6;
       		
    // If we are running a Japanese title then we nomalize Katakana characters
    // by converting half-width Katakana characters to full-width Katakana.
    // This allows the user to receive hits for both the full and half-width
    // versions of the character regardless of which version they type in the
    // query string.
    //
    if(codepage == 932)
    {
        int cb = (int)strlen(pszTempQuery2)+1;

        // allocate new buffer for converted query
        //
        char *pszTempQuery3 = (char *) lcMalloc(cb*2);

        // convert half-width katakana to full-width
        //
        Han2Zen((unsigned char *)pszTempQuery2,(unsigned char *)pszTempQuery3, codepage);
		
		if(pszTempQuery2)
		    lcFree(pszTempQuery2);
			
		pszTempQuery2 = pszTempQuery3;
    }
    // done half-width normalization
	
    // For Japanese queries, convert all double-byte quotes into single byte quotes
    //
    if(codepage == 932)
    {
        char *pszTemp = pszTempQuery2;

        while(*pszTemp)
        {
            if(*pszTemp == '' && (*(pszTemp+1) == 'h' || *(pszTemp+1) == 'g' || *(pszTemp+1) == 'J') )
            {
                *pszTemp = ' ';
                *(pszTemp+1) = '\"';
            }
            pszTemp = CharNext(pszTemp);
        }
    }
    // done convert quotes

    // This section converts contigious blocks of DBCS characters into phrases (enclosed in double quotes).
    // Converting DBCS words into phrases is required with the character based DBCS indexer we use.
    //
    int i, cb = (int)strlen(pszTempQuery2);

    // allocate new buffer for processed query
    //
    char *pszDest, *pszTemp;

    char *pszTempQuery4  = (char *) lcMalloc(cb*8);

    if(!pszTempQuery4)
        return NULL;

    pszTemp = pszTempQuery2;
    pszDest = pszTempQuery4;

    while(*pszTemp)
    {
        // check for quoted string - if found, copy it
        if(*pszTemp == '"')
        {
            *pszDest++=*pszTemp++;
            while(*pszTemp && *pszTemp != '"')
            {
                if(IsDBCSLeadByteEx(codepage, *pszTemp))
                {
                    *pszDest++=*pszTemp++;
                    *pszDest++=*pszTemp++;
                }
                else
                    *pszDest++=*pszTemp++;
            }
            if(*pszTemp == '"')
                    *pszDest++=*pszTemp++;
            continue;
        }

    	// Convert Japanese operators to English operators
	    //
        if(IsDBCSLeadByteEx(codepage, *pszTemp))
        {
            // check for full-width operator, if found, convert to ANSI
            if(i = IsJOperator(pszTemp))
            {
                strcpy(pszDest,pEnglishOperator[i]);
                pszDest+=strlen(pEnglishOperator[i]);
                pszTemp+=strlen(pJOperatorList[i]);
                continue;
            }

            *pszDest++=' ';
            *pszDest++='"';
            while(*pszTemp && *pszTemp !='"' && IsDBCSLeadByteEx(codepage, *pszTemp))
            {
                *pszDest++=*pszTemp++;
                *pszDest++=*pszTemp++;
            }
            *pszDest++='"';
            *pszDest++=' ';
            continue;
        }

        *pszDest++=*pszTemp++;
    }
    *pszDest = 0;

    if(pszTempQuery2)
        lcFree(pszTempQuery2);

    // compute size of Unicode buffer;

    int cbUnicodeSize = ((MultiByteToWideChar(codepage, 0, pszTempQuery4, -1, NULL, 0) + 2) *2);

    WCHAR *pszUnicodeBuffer = (WCHAR *) lcMalloc(cbUnicodeSize);

    ret = MultiByteToWideChar(codepage, 0, pszTempQuery4, -1, pszUnicodeBuffer, cbUnicodeSize);

    if(!ret)
        return NULL;

    if(pszTempQuery4)
        lcFree(pszTempQuery4);

    return (WCHAR *) pszUnicodeBuffer;
}

// This function computes if pszQuery is a FTS operator in full-width alphanumeric.
//
// return value
//
//      0 = not operator
//      n = index into pEnglishOperator array of translated English operator
//
int IsJOperator(char *pszQuery)
{
    if((PRIMARYLANGID(GetSystemDefaultLangID())) != LANG_JAPANESE)
        return FALSE;

    if(!pszQuery)
        return 0;

    int i = 1;
    char *pTerm = (char*)pJOperatorList[i];

    while(*pTerm)
    {
        if(compareOperator(pszQuery,pTerm))
            return i;

        pTerm = (char*)pJOperatorList[++i];
    }

    return 0;
}

// Compare operator to query.  This is similar to a stricmp.
//
BOOL compareOperator(char *pszQuery, char *pszTerm)
{
    if(!*pszQuery || !*pszTerm)
        return FALSE;

    while(*pszQuery && *pszTerm)
    {
        if(*pszQuery != *pszTerm)
            return FALSE;

        ++pszQuery;
        ++pszTerm;
    }

    if(*pszTerm)
        return FALSE;

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CCombinedFTS Class
//
// This class provides full-text search functionality for multiple titles.
//
// This class is intended only for use by the CFullTextSearch class which
// provides full-text search services for both single and multi-title
// configurations.


/////////////////////////////////////////////////////////////////////////////
// CCombinedFTS class constructor
//
CCombinedFTS::CCombinedFTS(CExTitle *pExTitle, LCID lcid, CFullTextSearch *pFTS)
{
    m_lcid = lcid;
	m_langid = LANGIDFROMLCID(lcid);	
	m_codepage = CodePageFromLCID(lcid);
    m_pTitle = pExTitle;
    m_SearchActive = FALSE;
    m_pIndex = NULL;
    m_pQuery = NULL;
    m_pITResultSet = NULL;
    m_pITDB = NULL;
    m_pFullTextSearch = pFTS;
    m_pPrevQuery = NULL;
    m_SystemLangID = PRIMARYLANGID(GetSystemDefaultLangID());
    m_fDBCS = FALSE;
    m_lMaxRowCount = 500;
    m_wQueryProximity = 8;
    m_iLastResultCount = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CCombinedFTS class destructor
//
CCombinedFTS::~CCombinedFTS()
{
    if (m_pITResultSet)
    {
        m_pITResultSet->Clear();
        m_pITResultSet->Release();
    }
    if(m_pPrevQuery)
        lcFree(m_pPrevQuery);

}

/////////////////////////////////////////////////////////////////////////////
// CCombinedFTS class destructor
//
void CCombinedFTS::ReleaseObjects()
{

    if(m_pQuery)
    {
        m_pQuery->Release();
        m_pQuery = NULL;
    }

    if(m_pIndex)
    {
        m_pIndex->Close();
        m_pIndex->Release();
        m_pIndex = NULL;
    }

    if(m_pITDB)
    {
        m_pITDB->Close();
        m_pITDB->Release();
        m_pITDB = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CCombinedFTS class initialization
//
HRESULT CCombinedFTS::Initialize()
{
	const char *pszQueryName;

	if(m_pFullTextSearch && m_pFullTextSearch->m_bMergedChmSetWithCHQ)
		pszQueryName = m_pFullTextSearch->m_pTitleArray[0].pszQueryName;
	else
		pszQueryName = m_pTitle->GetQueryName();

	if(!pszQueryName)
		return E_FAIL;

	MultiByteToWideChar(CP_ACP, 0, pszQueryName, -1, m_tcTitlePath, sizeof(m_tcTitlePath) );

    WORD PrimaryLang = PRIMARYLANGID(m_langid);
  
    if(PrimaryLang == LANG_JAPANESE || PrimaryLang == LANG_CHINESE || PrimaryLang == LANG_KOREAN)
	    m_fDBCS = TRUE;
	else
	    m_fDBCS = FALSE;  

    if(m_lcid == 1033)
        m_dwQueryFlags = IMPLICIT_AND | QUERY_GETTERMS | STEMMED_SEARCH;
    else
        m_dwQueryFlags = IMPLICIT_AND | QUERY_GETTERMS;

    //  char szLangID[20];
    //GetLocaleInfo(m_lcid,LOCALE_ILANGUAGE,szLangID,sizeof(szLangID));

    // Make sure we have a path
    //
    if(!*m_tcTitlePath)
    {
        return E_FAIL;
    }

    // Get IITIndex pointer
    //
    HRESULT hr = CoCreateInstance(CLSID_IITIndexLocal, NULL, CLSCTX_INPROC_SERVER,
                     IID_IITIndex, (VOID**)&m_pIndex);
    if (FAILED(hr))
    {
        return E_FAIL;
    }

    // Get IITDatabase pointer
    //
    hr = CoCreateInstance(CLSID_IITDatabaseLocal, NULL, CLSCTX_INPROC_SERVER,
                     IID_IITDatabase, (VOID**)&m_pITDB);
    if (FAILED(hr))
    {
        return E_FAIL;
    }

    // Open the storage system
    //
    hr = m_pITDB->Open(NULL, m_tcTitlePath, NULL);
    if (FAILED(hr))
    {
        return E_FAIL;
    }

    // open the index.
    //
    hr = m_pIndex->Open(m_pITDB, txtwFtiMain, TRUE);
    if (FAILED(hr))
    {
        return E_FAIL;
    }

    // Create query instance
    //
    hr = m_pIndex->CreateQueryInstance(&m_pQuery);
    if (FAILED(hr))
    {
        return E_FAIL;
    }

    // set search options
    //
    hr = m_pQuery->SetOptions(m_dwQueryFlags);
    if (FAILED(hr))
    {
        return E_FAIL;
    }

    // Create Result Set object
    //
    if(!m_pITResultSet)
    {
        hr = CoCreateInstance(CLSID_IITResultSet, NULL, CLSCTX_INPROC_SERVER,
                              IID_IITResultSet, (VOID**) &m_pITResultSet);
        if (FAILED(hr))
        {
            return E_FAIL;
        }
    }

    m_pITResultSet->Clear();

    // we want topic numbers back
    //
    hr = m_pITResultSet->Add(STDPROP_UID, (DWORD) 0, PRIORITY_NORMAL);
    if (FAILED(hr))
    {
        // Error adding result property
        return E_FAIL;
    }

    hr = m_pITResultSet->Add(STDPROP_TERM_UNICODE_ST, (DWORD)NULL, PRIORITY_NORMAL);
    if (FAILED(hr))
    {
        // Error adding result property
        return E_FAIL;

    }

    hr = m_pITResultSet->Add(STDPROP_COUNT, (DWORD)NULL, PRIORITY_NORMAL);
    if (FAILED(hr))
    {
        // Error adding result property
        return E_FAIL;
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCombinedFTS query function
//
HRESULT CCombinedFTS::Query(WCHAR *pwcQuery, DWORD dwFlags, IITResultSet **ppITRS, CFullTextSearch *pFullTextSearch, CUWait *pWaitDlg, int iTitle)
{
    HRESULT hr;

    WCHAR *pNewQuery = NULL;

    if(FAILED(hr = Initialize()))
       return hr;

    *ppITRS = NULL;

    // return if search previous set, but no previous query
    //
    if((dwFlags & FTS_SEARCH_PREVIOUS) && !m_pPrevQuery)
    {
       ReleaseObjects();
        return S_OK;
    }

    WCHAR *pszQuery = pwcQuery;
	
    pszQuery = PreProcessQuery(pwcQuery, m_codepage);

    if(!pszQuery)
	    return E_FAIL;

    // If this combined index resulted in no hits last query, but the global result count was non-zero, then 
    // return no hits.  The only time we want to query this combined index using the last known good query is
    // when the global query count (combined results) was also zero.  In that case, we want to 
    // revert all titles and combined indexes back to the last known good query.  Otherwise, we skip
    // this combined index because the last query (which resulted in some results globally) is still valid.
    //
    if((dwFlags & FTS_SEARCH_PREVIOUS) && pFullTextSearch->m_iLastResultCount && !m_iLastResultCount)
    {
        lcFree(m_pPrevQuery);
		m_pPrevQuery = NULL;
        return S_OK;
    }

    WCHAR *pPrevQuerySaved = NULL;
	
    if(m_pPrevQuery)
	{
        pPrevQuerySaved = (WCHAR *) lcMalloc((wcslen(m_pPrevQuery)+ 2) * sizeof(WCHAR));
        wcscpy(pPrevQuerySaved,m_pPrevQuery);		
	}
	
    if(dwFlags & FTS_ENABLE_STEMMING)
        m_dwQueryFlags |= STEMMED_SEARCH;
    else
        m_dwQueryFlags &= (~STEMMED_SEARCH);

    // Set previous options
    //
    m_pQuery->ReInit();
    m_pQuery->SetOptions(m_dwQueryFlags);
    m_pQuery->SetResultCount(m_lMaxRowCount);
    m_pQuery->SetProximity(m_wQueryProximity);


   FCALLBACK_MSG fCallBackMsg;

   fCallBackMsg.MessageFunc = SearchMessageFunc;
   fCallBackMsg.pUserData = (PVOID)pWaitDlg;  // used to pass back userdata
   fCallBackMsg.dwFlags = 0;  // not recommended for use
   m_pQuery->SetResultCallback(&fCallBackMsg);

    // create group if doing "search previous results"
    //
    if(dwFlags & FTS_SEARCH_PREVIOUS)
    {
        // append new query onto old query for "search previous"
        //
        int cQuery = wcslen(pszQuery);
        int cPrevQuery = wcslen(m_pPrevQuery);
        pNewQuery = (WCHAR *) lcMalloc((cQuery+cPrevQuery+20) * sizeof(WCHAR));
        if(!pNewQuery)
       {
           ReleaseObjects();
            return E_FAIL;
       }
        *pNewQuery = 0;
        wcscat(pNewQuery,m_pPrevQuery);
        wcscat(pNewQuery,L" and ");
        wcscat(pNewQuery,pszQuery);
        wcscat(pNewQuery,L" ");
    }

    // free the previous prev query
    //
    if(m_pPrevQuery)
        lcFree(m_pPrevQuery);

    // Save the new query for next time
    //
    if(pNewQuery)
        m_pPrevQuery = (WCHAR *) lcMalloc((wcslen(pNewQuery)+ 2) * sizeof(WCHAR));
    else
        m_pPrevQuery = (WCHAR *) lcMalloc((wcslen(pszQuery)+ 2) * sizeof(WCHAR));

    if(!m_pPrevQuery)
   {
       ReleaseObjects();
        return E_FAIL;
   }

    if(pNewQuery)
        wcscpy(m_pPrevQuery,pNewQuery);
    else
        wcscpy(m_pPrevQuery,pszQuery);

    // clear the previous results
    //
    hr = m_pITResultSet->ClearRows();
    if (FAILED(hr))
   {
       if(pPrevQuerySaved)
	      lcFree(pPrevQuerySaved);
       ReleaseObjects();
        return E_FAIL;
   }

    // Set the query
    //
    if(pNewQuery)
	{
        pFullTextSearch->AddQueryToTermList(pNewQuery);
        hr = m_pQuery->SetCommand(pNewQuery);
	}
    else
	{
        pFullTextSearch->AddQueryToTermList(pszQuery);
        hr = m_pQuery->SetCommand(pszQuery);
	}

    if (FAILED(hr))
   {
       if(pPrevQuerySaved)
	      lcFree(pPrevQuerySaved);
       ReleaseObjects();
        return E_FAIL;
   }

    if(pNewQuery)
        lcFree(pNewQuery);

    // Execute the query
    //
    hr = m_pIndex->Search(m_pQuery, m_pITResultSet);


    if(hr == E_NOSTEMMER)
    {
        m_dwQueryFlags &= (~STEMMED_SEARCH);
        m_pQuery->SetOptions(m_dwQueryFlags);
        m_pQuery->SetCommand(pszQuery);
        hr = m_pIndex->Search(m_pQuery, m_pITResultSet);
    }

    long lRowCount;

    m_pITResultSet->GetRowCount(lRowCount);

    m_iLastResultCount = lRowCount;

    // If query failed, then restore the previous query (for next search previous)
	//
    if((FAILED(hr) || !lRowCount) && pPrevQuerySaved)
	{
        if(m_pPrevQuery)
	        lcFree(m_pPrevQuery);
			
        m_pPrevQuery = (WCHAR *) lcMalloc((wcslen(pPrevQuerySaved)+ 2) * sizeof(WCHAR));
        wcscpy(m_pPrevQuery,pPrevQuerySaved);		
	}

    if(pPrevQuerySaved)
        lcFree(pPrevQuerySaved);

    if (hr ==E_NULLQUERY || hr == E_MISSQUOTE || hr == E_EXPECTEDTERM || hr == E_MISSLPAREN
        || hr == E_MISSRPAREN || hr == E_ALL_WILD)
    {
        // Error invalid syntax
        //
        ReleaseObjects();
        return FTS_INVALID_SYNTAX;
    }

    if(hr == FTS_CANCELED)
    {
       ReleaseObjects();
       return FTS_CANCELED;
    }

    // Generic error
    //
    if (FAILED(hr))
    {
       ReleaseObjects();
       return E_FAIL;
    }

    // Add search terms to term list
    //

    // Make sure we have results
    //
    if(lRowCount)
    {
        WCHAR wcBuffer[2048];

        int i;
        CProperty Prop, Prop2, Prop3;
        DWORD dwLastTopic = 0xffffffff, dwNextWordCount;

        WCHAR *pwcTemp = wcBuffer;

        *pwcTemp = 0;

        // prime the topic number
        //
        m_pITResultSet->Get(0,0, Prop3);
        dwLastTopic = Prop3.dwValue;

        // walk through the results
        //
        for (i = 0; i < lRowCount; i++)
        {
            m_pITResultSet->Get(i,0, Prop3);
            if(i<lRowCount)
            {
                m_pITResultSet->Get(i+1,2, Prop2);
                dwNextWordCount = Prop2.dwValue;
            }
            else
                dwNextWordCount = 0;

            m_pITResultSet->Get(i,1, Prop);
            m_pITResultSet->Get(i,2, Prop2);


             if(!Prop.dwValue)
                continue;

             WORD wFlags[2];
			 wFlags[0]=0;

             // Convert term from Unicode to ANSI because GetStringTypeW is not supported on Win95.
	    	 //
             WORD dwStrLen = (WORD)(wcslen(Prop.lpszwData + 1) * sizeof(WCHAR));
             if(dwStrLen)
             {
                char *pAnsiString = (char *) lcMalloc(dwStrLen);
				DWORD dwTermLen = 1;

                WideCharToMultiByte(m_codepage, 0, Prop.lpszwData + 1, -1, pAnsiString, dwStrLen, NULL, NULL);
				
				if(IsDBCSLeadByteEx(m_codepage, *pAnsiString))
					dwTermLen=2;

                GetStringTypeA(m_lcid, CT_CTYPE3, pAnsiString, dwTermLen, wFlags);

                lcFree(pAnsiString);
             }		 

             // skip DB chars (DB words were already added)
             //
             if(wFlags[0] & C3_FULLWIDTH || wFlags[0] & C3_KATAKANA || wFlags[0] & C3_HIRAGANA)
             {
                if(*pwcTemp)
                {
                       pFullTextSearch->AddHLTerm(wcBuffer,wcslen(wcBuffer));
                      pwcTemp = wcBuffer;
                   *pwcTemp = 0;
                }
                dwLastTopic = Prop3.dwValue;
                continue;
             }

            CopyMemory(pwcTemp, Prop.lpszwData + 1, (*((WORD *)Prop.lpszwData) * sizeof(WCHAR)));
            pwcTemp+=*((WORD *)Prop.lpszwData);
            *pwcTemp = 0;

            if(dwNextWordCount != (Prop2.dwValue+1) || (wcslen(wcBuffer) > 500))
            {
                pFullTextSearch->AddHLTerm(wcBuffer,wcslen(wcBuffer));
                pwcTemp = wcBuffer;
            }
            else
            {
                *pwcTemp++ = L' ';
                *pwcTemp = 0;
            }
            dwLastTopic = Prop3.dwValue;
        }
    }

    // Send the results set back
    //
    *ppITRS = m_pITResultSet;

    ReleaseObjects();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCombinedFTS abort current query
//
HRESULT CCombinedFTS::AbortQuery()
{
    // DOUGO - insert abort code here when Centaur support is available

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCombinedFTS update FTS options without calling into Centaur
//
HRESULT CCombinedFTS::UpdateOptions(WORD wNear, LONG cRows)
{
    m_wQueryProximity = wNear;
    m_lMaxRowCount = cRows;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCombinedFTS set title FTS options
//
HRESULT CCombinedFTS::SetOptions(DWORD dwFlag)
{
    HRESULT hr = E_FAIL;

    m_dwQueryFlags = dwFlag;

    if(m_pQuery)
        hr = m_pQuery->SetOptions(dwFlag);

    if (FAILED(hr))
        return E_FAIL;
    else
        return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCombinedFTS set proximity for title
//
HRESULT CCombinedFTS::SetProximity(WORD wNear)
{
    HRESULT hr = E_FAIL;

    m_wQueryProximity = wNear;

    if(m_pQuery)
        hr = m_pQuery->SetProximity(wNear);

   return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CCombinedFTS set max result count for title query
//
HRESULT CCombinedFTS::SetResultCount(LONG cRows)
{
    HRESULT hr = E_FAIL;

    m_lMaxRowCount = cRows;

    if(m_pQuery)
        hr = m_pQuery->SetResultCount(cRows);

    return hr;
}

ERR SearchMessageFunc(DWORD dwFlag, LPVOID pUserData, LPVOID pMessage)
{
    MSG msg;
    CUWait *pUW = (CUWait *)pUserData;

    if(!pUW->m_bVisable)
    {
        ShowWindow(pUW->m_hwndUWait, SW_SHOW);
        pUW->m_bVisable = TRUE;
    }

    while (PeekMessage(&msg, pUW->m_hwndUWait, 0, 0, PM_REMOVE))
    {
        if(!IsDialogMessage(pUW->m_hwndUWait, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
	    }
    }

    if (pUW->m_bUserCancel == TRUE)
        return FTS_CANCELED;

   return S_OK; // return something else to abort
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\fsclient.h ===
// Copyright 1997  Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _FSCLIENT_H_
#define _FSCLIENT_H_

//#include "msitstg.h"
#include "fs.h"

#ifdef ReleaseObjPtr
#undef ReleaseObjPtr
#endif
#define ReleaseObjPtr(pObj) \
{                           \
  if( pObj )                \
  {                         \
    pObj->Release();        \
    pObj= NULL;             \
  }                         \
}

class CFSClient
{
public:
    CFSClient();
    CFSClient(CFileSystem* pFS, PCSTR pszSubFile);
    ~CFSClient();

    BOOL    Initialize(PCSTR pszCompiledFile);
    void    Initialize(CFileSystem* pFS) { m_pFS = pFS; m_fNoDeleteFS = TRUE; }
    HRESULT OpenStream(PCSTR pszFile, DWORD dwAccess = STGM_READ);
    BOOL    isStreamOpen() { return m_pSubFS != NULL; }

    // ********** Internal stream functions **********

    HRESULT Read(void* pDst, const ULONG cbRead, ULONG* pcbRead);
    ULONG   Read(PBYTE pbDest, ULONG cbBytes);    // stream read
    HRESULT doRead(void* pbDst, ULONG cbBytes) {
        if (Read((PBYTE) pbDst, cbBytes) == cbBytes)
            return S_OK;
        else
            return STG_E_READFAULT;
    }
    int tell(void) const { return m_lFileBuf + (int)(m_pCurBuf - m_pbuf); };
    HRESULT seek(int pos, SEEK_TYPE seek = SK_SET);

    // ********** End Internal stream functions **********

    void    CloseStream(void);
    ULONG   GetElementStat() { return GetElementStat(1, &m_Stat); }
    ULONG   GetElementStat(IEnumSTATSTG* pEnum, STATSTG* pStat) { return GetElementStat(1, pStat, pEnum); }
    ULONG   GetElementStat(ULONG nNumber, STATSTG* stat, IEnumSTATSTG* pEnum = NULL);
    LPWSTR  GetStatName() const { return m_Stat.pwcsName; }
    DWORD   GetStatType() const { return m_Stat.type; }
    void    WriteStorageContents(PCSTR pszRootFolder, OLECHAR* wszFSName);
//    void    WaitForReadAhead(void);
    void    ReadBuf(void);
    ULONG   SeekSub(int cb, int iOrigin) {
                ASSERT(m_pSubFS);
                return m_pSubFS->SeekSub(cb, iOrigin); }

    STATSTG         m_Stat;
    IEnumSTATSTG*   m_pEnum;
    CFileSystem*    m_pFS;
    CSubFileSystem* m_pSubFS;

    PBYTE m_pCurBuf;   // current position in the buffer
    PBYTE m_pEndBuf;   // last position in buffer
    BOOL  m_fEndOfFile;
    int   m_lFilePos;  // position in the file
    int   m_lFileBuf;  // file position at first of buffer
    PBYTE m_pbuf;      // address of allocated buffer
    int   m_cbBuf;     // buffer size
    int   m_cThrdRead; // result from read-ahead thread
    HANDLE m_hthrd;
    DWORD m_idThrd;
    BOOL  m_fDualCPU;
    BOOL    m_fNoDeleteFS;
};

#endif  // _FSCLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\funcs.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#ifndef FASTCALL
#define FASTCALL __fastcall
#endif

#define SETTHIS(hwnd)        SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
#define GETTHIS(Class,hwnd)  (reinterpret_cast<Class*>(GetWindowLongPtr(hwnd, GWLP_USERDATA)))
#define DESTROYIFVALID(hwnd) if (IsValidWindow(hwnd)) DestroyWindow(hwnd);

#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR)

#define UnregisterControlObject UnregisterAutomationObject

#define ELEMENTS(array) (sizeof(array) / sizeof(array[0]))

#define HH_URL_PREFIX_LESS  1
#define HH_URL_UNQUALIFIED  2
#define HH_URL_QUALIFIED    3
#define HH_URL_JAVASCRIPT   ((UINT)-2)
#define HH_URL_UNKNOWN      ((UINT)-1)

// *********************** Assertion Definitions ************************** //

// Get rid of any previously defined versions

#undef ASSERT
#undef VERIFY

#ifndef THIS_FILE
#define THIS_FILE __FILE__
#endif

// *********************** Function Prototypes **************************** //

#if defined(_DEBUG)
void AssertErrorReport(PCSTR pszExpression, UINT line, LPCSTR pszFile);
#endif

class CStr; // forward reference

// functions formerly in hhctrlex.h
#ifdef __cplusplus
extern "C" {
#endif	// __cplusplus
//PSTR  stristr(PCSTR pszMain, PCSTR pszSub);  // case-insensitive string search
PSTR  FirstNonSpace(PCSTR psz); 			 // return pointer to first non-space character
WCHAR *FirstNonSpaceW(WCHAR *psz); 			 // return pointer to first non-space character
//PSTR  StrChr(PCSTR pszString, char ch); 	 // DBCS-aware character search
PSTR  StrRChr(PCSTR pszString, char ch);	 // DBCS-aware character search
DWORD WinHelpHashFromSz(PCSTR pszKey);		 // converts string into a WinHelp-compatible hash number
#ifdef __cplusplus
}
#endif // __cplusplus

BOOL __cdecl _FormatMessage(LPCSTR szTemplate, LPSTR szBuf, UINT cchBuf, ...);

LRESULT WINAPI HelpWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI ChildWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

DWORD       CreatePath(PSTR pszPath);
void        AddTrailingBackslash(PSTR psz);
LPSTR       CatPath(LPSTR lpTop, LPCSTR lpTail);
HWND        ChangeHtmlTopic(PCSTR pszFile, HWND hwndChild, BOOL bHighlight = FALSE);
BOOL        CheckForLicense();
BOOL        CheckLicenseKey(LPWSTR wszCheckme);
void        CheckWindowPosition(RECT* prc, BOOL fAllowShrinkage);
void        ConvertBackSlashToForwardSlash(PSTR pszUrl);
void        ConvertSpacesToEscapes(PCSTR pszSrc, CStr* pcszDst);
BOOL        ConvertToCacheFile(PCSTR pszSrc, PSTR pszDst);
int         ConvertWz(const WCHAR * pwz, char * psz, int len);
HPALETTE    CreateBIPalette(PBITMAPINFOHEADER pbihd);
HRESULT     CreateComponentCategory(GUID catid, WCHAR* catDescription);
void        CreateDefaultWindowType(PCSTR pszCompiledFile, PCSTR pszWindow);
BOOL        CreateFolder(PCSTR pszPath);
int         IEColorToWin32Color( PCWSTR pwsz );
HFONT       CreateUserFont(PCSTR pszFont, COLORREF* pclrFont = NULL, HDC hDC = NULL, INT charset = -1);
HFONT       CreateUserFontW(WCHAR *pszFont, COLORREF* pclrFont = NULL, HDC hDC = NULL, INT charset = -1);
void        DeleteAllHmData();
BOOL        DeleteKeyAndSubKeys(HKEY hk, LPSTR pszSubKey);
BOOL        DlgOpenFile(HWND hwndParent, PCSTR pszFile, CStr* pcsz);
BOOL        DlgOpenDirectory(HWND hwndParent, CStr* pcsz);
void        doAuthorMsg(UINT idStringFormatResource, PCSTR pszSubString);
HWND        doDisplayIndex(HWND hwndCaller, LPCSTR pszFile, LPCTSTR pszKeyword);
HWND        doDisplayToc(HWND hwndCaller, LPCSTR pszFile, DWORD_PTR dwData);
void        doHhctrlVersion(HWND hwndParent, PCSTR pszCHMVersion);
void        doHHWindowJump(PCSTR pszUrl, HWND hwndChild);
BOOL        doJumpUrl(HWND hwndParent, PCSTR pszCurUrl, PSTR pszDstUrl);
void        doRelatedTopics(HWND);
HWND        doTpHelpWmHelp(HWND hwndMain, LPCSTR pszFile, DWORD_PTR ulData);
HWND        doTpHelpContextMenu(HWND hwndMain, LPCSTR pszFile, DWORD_PTR ulData);
BOOL        FindDarwinURL(PCSTR pszGUID, PCSTR pszChmFile, CStr* pcszResult);
PCSTR       FindEqCharacter(PCSTR pszLine);
PCSTR       FindFilePortion(PCSTR pszFile);
HWND        FindMessageParent(HWND hwndChild);
BOOL        FindThisFile(HWND hwndParent, PCSTR pszFile, CStr* pcszFile, BOOL fAskUser = TRUE);
HWND        FindTopLevelWindow(HWND hwnd);
DWORD       GetButtonDimensions(HWND hwnd, HFONT hFont, PCSTR psz);
PCSTR       GetCompiledName(PCSTR pszName, CStr* pcsz);
BOOL        GetHighContrastFlag(void);
PSTR        GetLeftOfEquals(PCSTR pszString);
BSTR        GetLicenseKey(void);
HWND        GetParentSize(RECT* prcParent, HWND hwndParent, int padding, int navpos);
HWND        GetParkingWindow(void);
void        GetRegWindowsDirectory(PSTR pszDstPath);
void        GetScreenResolution(HWND hWnd, RECT* prc);
void        GetWorkArea() ;
DWORD       GetStaticDimensions(HWND hwnd, HFONT hFont, PCSTR psz, int max_len );
DWORD       GetStaticDimensionsW(HWND hwnd, HFONT hFont, WCHAR *psz, int max_len );
PCSTR       GetStringResource(int idString);
PCSTR       GetStringResource(int idString, HINSTANCE);
PCWSTR      GetStringResourceW(int idString);
PCWSTR      GetStringResourceW(int idString, HINSTANCE);
HASH        HashFromSz(PCSTR pszKey);
int         HHA_Msg(UINT command, WPARAM wParam = 0, LPARAM lParam = 0);
void        HiMetricToPixel(const SIZEL *pSizeInHiMetric, SIZEL *pSizeinPixels);
HWND        xHtmlHelpA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData);
HWND        xHtmlHelpW(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData);
BOOL        IsCollectionFile(PCSTR pszFile);
BOOL        IsCompiledURL( PCSTR pszFile );
UINT        GetURLType( PCSTR pszURL );
BOOL        IsCompiledHtmlFile(PCSTR pszFile, CStr* pcszFile = NULL);
BOOL        IsHelpAuthor(HWND hwndCaller);
BOOL        IsSamePrefix(PCWSTR pwszMain, PCWSTR pwszSub, int cchPrefix = -1);
BOOL        IsSamePrefix(PCSTR pszMain, PCSTR pszSub, int cbPrefix = -1);
BOOL        IsThisAWinHelpFile(HWND hwndCaller, PCSTR pszFile);
BOOL        IsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE);
BOOL        IsValidString(LPCSTR lpsz, int nLength = -1);
BOOL        IsValidString(LPCWSTR lpsz, int nLength = -1);
void        ItDoesntWork(void);
LPWSTR      MakeWideStr(LPSTR psz, UINT codepage);
LPWSTR      MakeWideStrFromAnsi(LPSTR, BYTE bType);
LPWSTR      MakeWideStrFromResourceId(WORD, BYTE bType);
LPWSTR      MakeWideStrFromWide(LPWSTR, BYTE bType);
void        MemMove(void * dst, const void * src, int count);
BOOL        MoveClientWindow(HWND hwndParent, HWND hwndChild, const RECT *prc, BOOL fRedraw);
int         MsgBox(int idFormatString, PCSTR pszSubString, UINT nType = MB_OK);
int         MsgBox(int idString, UINT nType = MB_OK);
int         MsgBox(PCSTR pszMsg, UINT nType = MB_OK);
LPVOID      OleAlloc(UINT cb);
void        OleFree(LPVOID pb);
HRESULT     OleInitMalloc(void);
HWND        OnDisplayPopup(HWND hwndCaller, LPCSTR pszFile, DWORD dwData);
HWND        OnDisplayTopic(HWND hwndCaller, LPCSTR pszFile, DWORD_PTR dwData);
HWND        OnHelpContext(HWND hwndCaller, LPCSTR pszFile, DWORD_PTR dwData);
void        OOM(void);
BOOL        PaintShadowBackground(HWND hwnd, HDC hdc, COLORREF clrBackground = (COLORREF) -1);
void        PixelToHiMetric(const SIZEL *pSizeInPixels, SIZEL *pSizeInHiMetric);
void        QSort(void *pbase, UINT num, UINT width, int (FASTCALL *compare)(const void *, const void *));
BOOL        RegisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject);
HRESULT     RegisterCLSIDInCategory(REFCLSID clsid, GUID catid);
BOOL        RegisterControlObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject, DWORD dwMiscStatus, WORD wToolboxBitmapId);
void        RegisterOurWindow();
BOOL        RegisterUnknownObject(LPCSTR pszObjectName, REFCLSID riidObject);
BOOL        RegSetMultipleValues(HKEY hkey, ...);
void        RemoveTrailingSpaces(PSTR pszString);
void        SendStringToParent(PCSTR pszMsg);
PSTR        StrToken(PSTR pszList, PCSTR pszDelimeters);
PSTR        SzTrimSz(PSTR pszOrg);
BOOL        UnregisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidObject);
HRESULT     UnRegisterCLSIDInCategory(REFCLSID clsid, GUID catid);
BOOL        UnregisterData(void);
BOOL        UnregisterTypeLibrary(REFCLSID riidLibrary);
BOOL        UnregisterUnknownObject(REFCLSID riidObject);

typedef UINT (WINAPI *PFN_GETWINDOWSDIRECTORY)( LPTSTR lpBuffer, UINT uSize );
typedef enum { HH_SYSTEM_WINDOWS_DIRECTORY, HH_USERS_WINDOWS_DIRECTORY } SYSDIRTYPES;

UINT HHGetWindowsDirectory( LPSTR lpBuffer, UINT uSize, UINT uiType = HH_SYSTEM_WINDOWS_DIRECTORY );
UINT HHGetHelpDirectory( LPSTR lpBuffer, UINT uSize );
UINT HHGetGlobalCollectionPathname( LPTSTR lpBuffer, UINT uSize , BOOL *pbNewPath);
UINT HHGetOldGlobalCollectionPathname( LPTSTR lpBuffer, UINT uSize );

HRESULT HHGetUserDataPath( LPSTR pszPath );
HRESULT HHGetHelpDataPath( LPSTR pszPath );
HRESULT HHGetUserDataPathname( LPSTR lpBuffer, UINT uSize );
HRESULT HHGetCurUserDataPath( LPSTR pszPath );

// Internal API definitions.
#include "hhpriv.h"
// Look for the information in the hhcolreg.dat file.
int         GetLocationFromTitleTag(LPCSTR szCollection, HH_TITLE_FULLPATH* pTitleFullPath) ;

int FASTCALL CompareIntPointers(const void *pval1, const void *pval2);
void FASTCALL Itoa(int val, PSTR pszDst);
int FASTCALL Atoi(PCSTR psz);

// *********************** Debug/Internal Functions ********************** //

#ifdef _DEBUG

// IASSERT is available in _DEBUG builds

#define IASSERT(exp) \
    { \
        ((exp) ? (void) 0 : \
            AssertErrorReport(#exp, __LINE__, THIS_FILE)); \
    }

#define IASSERT_COMMENT(exp, pszComment) \
    { \
        ((exp) ? (void) 0 : \
            AssertErrorReport(pszComment, __LINE__, THIS_FILE)); \
    }

#else

#define IASSERT(exp)
#define IASSERT_COMMENT(exp, pszComment)

#endif

#ifdef _DEBUG

#define ASSERT(exp) \
    { \
        ((exp) ? (void) 0 : \
            AssertErrorReport(#exp, __LINE__, THIS_FILE)); \
    }

#define ASSERT_COMMENT(exp, pszComment) \
    { \
        ((exp) ? (void) 0 : \
            AssertErrorReport(pszComment, __LINE__, THIS_FILE)); \
    }

#define FAIL(pszComment) AssertErrorReport(pszComment, __LINE__, THIS_FILE);

#define VERIFY(exp)     ASSERT(exp)
#define VERIFY_RESULT(exp1, exp2)   ASSERT((exp1) == (exp2))
#define DEBUG_ReportOleError doReportOleError
void doReportOleError(HRESULT hres);
__inline void DBWIN(PCSTR psz) {
    SendStringToParent(psz);
    SendStringToParent("\r\n");
}

#define CHECK_POINTER(val) if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) return E_POINTER

#else // non-debugging version

#define ASSERT(exp)
#define ASSERT_COMMENT(exp, pszComment)
#define VERIFY(exp) ((void)(exp))
#define VERIFY_RESULT(exp1, exp2) ((void)(exp))
#define DEBUG_ReportOleError(hres)
#define DBWIN(psz)
#define FAIL(pszComment)
#define CHECK_POINTER(val)

#define THIS_FILE  __FILE__

#endif

// zero fill everything after the vtbl pointer
#define ZERO_INIT_CLASS(base_class) \
    ClearMemory((PBYTE) ((base_class*) this) + sizeof(base_class*), \
        sizeof(*this) - sizeof(base_class*));
#define ZERO_STRUCTURE(foo) ClearMemory(&foo, sizeof(foo))
#define ClearMemory(p, cb) memset(p, 0, cb)

__inline void StrCopyWide(LPWSTR psz1, LPCWSTR psz2) {
    while (*psz1++ = *psz2++);
}

// HHA functions

extern int (STDCALL *pDllMsgBox)(int idFormatString, PCSTR pszSubString, UINT nType);
extern PCSTR (STDCALL *pGetDllStringResource)(int idFormatString);

void WINAPI AWMessagePump(HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ftsnames.cpp ===
// Include this to assure identical names between compiler and hhctrl

static const WCHAR txtwFtiMain[] = L"ftiMain";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\genit.cpp ===
#include "header.h"
#include "sitemap.h"


        // Static Data
        // ******************

static INFOTYPE curr_bit;   // used for getting the next IT in a category
static int curr_cat;
static int curr_offset;     // There are 32 info type bits per offset.


// ********************************************************
//
// Methods to operate on CSitemap Categories of Information Types
//
// ********************************************************

void CSiteMap::AddITtoCategory(int cat, int type)
{
int       offset;
INFOTYPE *pInfoType;

    if ( cat < 0 )
        return;
    m_itTables.m_aCategories[cat].c_Types++;
    offset = type / 32;
    pInfoType = m_itTables.m_aCategories[cat].pInfoType + offset;
    *pInfoType |=  1<<type;

    if ( m_itTables.m_max_categories == (cat+1) )
    {
        m_itTables.m_aCategories = (CATEGORY_TYPE*) lcReAlloc( m_itTables.m_aCategories, (m_itTables.m_max_categories+5) * sizeof(CATEGORY_TYPE) );

        for(int i=m_itTables.m_max_categories; i < m_itTables.m_max_categories+5; i++)
        m_itTables.m_aCategories[i].pInfoType = (INFOTYPE*)lcCalloc(InfoTypeSize());

        m_itTables.m_max_categories += 5;
    }
}



void CSiteMap::DeleteITfromCat(int cat, int type)
{
int       offset;
INFOTYPE *pInfoType;

    if ( cat < 0 )
        return;
    m_itTables.m_aCategories[cat].c_Types--;
    offset = type / 32;
    pInfoType = m_itTables.m_aCategories[cat].pInfoType + offset;
    *pInfoType &= ~(1<<type);

}



int CSiteMap::GetFirstCategoryType( int pos ) const
{

    curr_offset = -1;    // gets incermented to 0 before first IT comparison.
    curr_cat = pos;      // keep the position of the category for calls to GetNextITinCagetory.
    curr_bit =1;         // bit zero of offset zero is reserved. But check it any way.

    if ( pos < 0 )
        return -1;
    int bitpos = GetITfromCat(&curr_offset,
                        &curr_bit,
                        m_itTables.m_aCategories[curr_cat].pInfoType,
                        InfoTypeSize()*8);
    if( (bitpos!=-1) && (IsDeleted(bitpos)) )
        bitpos = GetNextITinCategory();
    return bitpos;

}



int CSiteMap::GetNextITinCategory( void ) const
{
    if ( curr_cat < 0 )
        return -1;  // must call GetFirstCategoryType() before calling this fn.

    int pos = GetITfromCat(&curr_offset,
                        &curr_bit,
                        m_itTables.m_aCategories[curr_cat].pInfoType,
                        InfoTypeSize()*8);
    while ( (pos!=-1) && (IsDeleted(pos)))
        pos = GetITfromCat(&curr_offset,
                        &curr_bit,
                        m_itTables.m_aCategories[curr_cat].pInfoType,
                        InfoTypeSize()*8);
    return pos;
}



int CSiteMap::GetLastCategoryType(int pos) const
{   int cat;
    int offset;
    INFOTYPE bit;

    cat = pos;      // The category
    if ( cat < 0 )
        return -1;
    offset = -1;
    bit = 1;

    for (int i=0; i<m_itTables.m_aCategories[cat].c_Types-1; i++)
        if ( GetITfromCat(&offset,
                          &bit,
                          m_itTables.m_aCategories[cat].pInfoType,
                          InfoTypeSize()*8 ) == -1 )
            return -1;

    return  GetITfromCat(&offset,
                         &bit,
                         m_itTables.m_aCategories[cat].pInfoType,
                         InfoTypeSize() * 8 );
}

static int BitToDec( int binary )
{
register int count=0;
register int bit=1;

//    if ( binary < 1 )
//        return -1;
    if ( binary == 1 )
        return 1;

    while ( bit != binary )
    {
        bit = bit<<1;
        count++;
    }
    return count;
}


// ***********************************************
//
// Generic methods to operate on Categories.
//
// ***********************************************

/*
    GetITfromCat        A helper function used to convert a bit position to it's to a decimal number.
                        Given a Category and offset, and a bit field with on bit set returns the
                        next bit set in the category.  ie. a bit corresponds to an information
                        type.
    Parameters:
            int const cat     <I>       The category to work on
            int* offset       <I/O>     The offset into the infotype bits, an offset is 4 bytes long
                                        must be -1 for the first offset, 0 for second offset ...
            int* bit          <I/O>     The first bit position to test.

    Return Value        The decimal number of the bit position.  ie. bit position 5 returns 5.
*/

int GetITfromCat(int* offset, INFOTYPE* bit, INFOTYPE* pInfoType, int cTypes)
{
   INFOTYPE InfoType;

   if ( *offset < 0 )
       *offset = 0;
   memcpy(&InfoType, pInfoType + *offset, sizeof(INFOTYPE) );

   for(int i=BitToDec(*bit)+(*offset*32); i < cTypes; i++)
   {              // offset: 0      1      2
        if ( i % 32 == 0 )// 0-31, 32-63, 64-95 ...
        {
            (*offset)++;
            *bit = 1;   // bit 0, 32, 64 ... depending on the offset.
            memcpy(&InfoType, pInfoType + *offset, sizeof(INFOTYPE) );
        }
        if ( *bit & InfoType )
        {
            int ret = (int)((*offset*32)+(BitToDec(*bit)));   // return the decimal value of the bit position.
            *bit = *bit << 1;
            return ret;
        }
        else
            *bit = *bit << 1;
    }
    return -1;  // There are no infotypes in this category.
}


// ******************************************************
//
// Methods to operate on CSiteMap Exclusive Information Types
//
// ******************************************************

static int ExclusiveOffset = -1;    // Gets incermented to zero before search begins
static INFOTYPE ExclusiveBit = 1;        // check bit 0 even though it is reserved.

int CSiteMap::GetFirstExclusive(int offset, INFOTYPE bit) const
{
    ExclusiveOffset = offset;
    ExclusiveBit = bit;

    int pos = GetITBitfromIT(m_itTables.m_pExclusive,
                          &ExclusiveOffset,
                          &ExclusiveBit,
                          InfoTypeSize()*8 );
    if( (pos!=-1) && (IsDeleted(pos)) )
        pos = GetNextExclusive();
    return pos;
}


int CSiteMap::GetNextExclusive(void) const
{
    if ( ExclusiveOffset < -1 || ExclusiveBit < 1 )
        return -1;
    int pos = GetITBitfromIT(m_itTables.m_pExclusive,
                          &ExclusiveOffset,
                          &ExclusiveBit,
                          InfoTypeSize()*8 );
    while ((pos!=-1) && (IsDeleted(pos)))
        pos = GetITBitfromIT(m_itTables.m_pExclusive,
                          &ExclusiveOffset,
                          &ExclusiveBit,
                          InfoTypeSize()*8 );
    return pos;
}


int CSiteMap::GetLastExclusive(void) const
{
    int i;
    int iLastExclusive=-1, temp;
    int offset=-1;
    INFOTYPE bit=1;

    for (i=0; i< HowManyInfoTypes(); i++)
        if ( (temp = GetITBitfromIT(m_itTables.m_pExclusive, &offset, &bit, InfoTypeSize()*8))  == -1 )
            return iLastExclusive;
        else
            iLastExclusive = temp;

    return -1;
}



// ******************************************************
//
// Methods to operate on CSiteMap Hidden Information Types
//
// ******************************************************

static int HiddenOffset=-1;
static INFOTYPE HiddenBit=1;

int CSiteMap::GetFirstHidden(int offset, INFOTYPE bit) const
{
    HiddenOffset = offset;
    HiddenBit = bit;

    int pos = GetITBitfromIT(m_itTables.m_pHidden,
                          &HiddenOffset,
                          &HiddenBit,
                          InfoTypeSize()*8 );
    if( (pos != -1) && (IsDeleted(pos)) )
        pos = GetNextHidden();
    return pos;
}


int CSiteMap::GetNextHidden(void) const
{
    if ( HiddenOffset < -1 || HiddenBit < 1 )
        return -1;
    int pos = GetITBitfromIT(m_itTables.m_pHidden,
                          &HiddenOffset,
                          &HiddenBit,
                          InfoTypeSize()*8 );
    while((pos!=-1) &&(IsDeleted(pos)) )
        pos = GetITBitfromIT(m_itTables.m_pHidden,
                          &HiddenOffset,
                          &HiddenBit,
                          InfoTypeSize()*8 );
    return pos;
}


int CSiteMap::GetLastHidden(void) const
{
    int i;
    int iLastHidden=-1, temp;
    int offset=-1;
    INFOTYPE bit=1;

    for (i=0; i<HowManyInfoTypes(); i++)
        if ( (temp = GetITBitfromIT(m_itTables.m_pHidden, &offset, &bit, InfoTypeSize()*8)) == -1)
            return iLastHidden;
        else
            iLastHidden = temp;
    return -1;
}


// ***************************************************************************
//
// Generic Methods to operate on Hidden and Exclusive Information Types
//
// ***************************************************************************

void DeleteIT(int const type, INFOTYPE *pIT )
{
int offset;
INFOTYPE *pInfoType;
INFOTYPE deleteIT;

    if ( type <= 0 || !pIT)
        return;

    deleteIT = 1<<type;
    offset = type / 32;
    pInfoType = pIT + offset;
    *pInfoType &= ~deleteIT;
}


void AddIT(int const type, INFOTYPE *pIT )
{
int offset;
INFOTYPE *pInfoType;

    if ( type <= 0 || !pIT)
        return;

    offset = type / 32;
    pInfoType = pIT + offset;
    *pInfoType |= 1<<type;
}


void CopyITBits(INFOTYPE** ITDst, INFOTYPE* ITSrc, int size)
{
    if ( !*ITDst || !ITSrc )
        return;

    lcFree( *ITDst );
    *ITDst = (INFOTYPE*)lcCalloc( size );

    memcpy( *ITDst, ITSrc, size);
}


int GetITBitfromIT(INFOTYPE const *IT, int* offset, INFOTYPE* bit, int cTypes)
{
   INFOTYPE InfoType;

   if ( *offset < 0 )
       *offset = 0;
   memcpy(&InfoType, IT + *offset, sizeof(INFOTYPE) );

   for(int i=BitToDec(*bit)+(*offset*32); i < cTypes; i++)   // we are checking bit 0 even though it is reserved.
   {               // offset: 0      1      2
        if ( i % 32 == 0 )// 0-31, 32-63, 64-95 ...
        {
            (*offset)++;
            *bit = 1;   // bit 0, 32, 64 ... depending on the offset.
            memcpy(&InfoType, IT + *offset, sizeof(INFOTYPE) );
        }
        if ( *bit & InfoType )
        {
            int ret = (int)((*offset*32)+(BitToDec(*bit)));   // return the decimal value of the bit position.
            *bit = *bit << 1;
            return ret;
        }
        else
            *bit = *bit << 1;
    }
    return -1;  // There are no infotype bits in this InfoType field.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\guids.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#ifndef _GUIDS_H_
#define _GUIDS_H_

// for each property page this server will have, put the guid definition for it
// here so that it gets defined ...
//
// DEFINE_GUID(CLSID_newbGeneralPage, 0x6571ef80, 0x7374, 0x11cf, 0xa3, 0xa9, 0x00, 0xa0, 0xc9, 0x03, 0x49, 0x20);
// {250960A5-BACC-11cf-94AC-00AA0042A1F7} New GUID for fmperf0 (was newb cool control)
#ifdef PPGS
DEFINE_GUID(CLSID_HhCtrlGeneralPage, 0x250960a5, 0xbacc, 0x11cf, 0x94, 0xac, 0x0, 0xaa, 0x0, 0x42, 0xa1, 0xf7);
#endif

#endif // _GUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\gif.h ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

#include "cstream.h"

#pragma pack(push, 1)

typedef struct {
	WORD log_width;
	WORD log_height;
	struct {
		BYTE ceGCT:3;
		BYTE fSort:1;
		BYTE cPrimaries:3;
		BYTE fGCT:1;
	} b;
	BYTE iBackground;
	BYTE wAspect;
} LSD;

#pragma pack(pop)

// IFFERROR: Possible errors

typedef int IFFERROR;
const int IFFERR_NONE		  = 0;	 // no error
const int IFFERR_HANDLELIMIT  = 1;	 // too many open files
const int IFFERR_PARAMETER	  = 2;	 // programmer error
const int IFFERR_NOTSUPPORTED = 3;	 // feature not supported by format
const int IFFERR_NOTAVAILABLE = 4;	 // item not available
const int IFFERR_MEMORY 	  = 5;	 // insufficient memory
const int IFFERR_IMAGE		  = 6;	 // bad image data (decompression error)
const int IFFERR_HEADER 	  = 7;	 // header has bad fields
const int IFFERR_IO_OPEN	  = 8;	 // error on open()
const int IFFERR_IO_CLOSE	  = 9;	 // error on close()
const int IFFERR_IO_READ	  = 10;  // error on read()
const int IFFERR_IO_WRITE	  = 11;  // error on write()
const int IFFERR_IO_SEEK	  = 12;  // error on lseek()

typedef enum {
	IFFCL_BILEVEL,		// 1 BPP
	IFFCL_GRAY, 		// 2,4,6,8 BPP
	IFFCL_PALETTE,		// 2,4,6,8 BPP
	IFFCL_RGB,			// 24 BPP chunky
	IFFCL_RGBPLANAR,	// 24 BPP in 8 bit planes
	IFFCL_RGBA, 		// 32 BPP chunky
	IFFCL_RGBAPLANAR,	// 32 BPP in four 8 bit planes*/
	IFFCL_CMYK,
	IFFCL_YCC,
	IFFCL_CIELAB,
} IFFCLASS;

// IFFCOMPRESSION:	 Compression options

typedef enum {
	IFFCOMP_NONE,		// no compression
	IFFCOMP_DEFAULT,	// whatever is defined for the format
	IFFCOMP_LZW,		// Lempel-Zif
} IFFCOMPRESSION;

// IFFSEQUENCE:  Line sequences

typedef enum {
	IFFSEQ_TOPDOWN,
	IFFSEQ_BOTTOMUP,	// BMP and TGA compressed
	IFFSEQ_INTERLACED,	// for GIF
} IFFSEQUENCE;

typedef struct {
	int 	CharSize;	// size of input data
	int 	CodeSize;	// Max bits in a code
	int 	ClearCode;	// based on CharSize
	int 	CurBits;	// current size of a code
	int 	BitPos; 	// range = 0 - 7, 0 is MSB
	int 	OldCode;	// continuity data for STREAMEXPAND
	int 	TableEntry;
	UINT	LastChar;
	int 	OutString;		// offset into Stack
	int 	CodeJump;
	int 	*CodeTable; 	// Compress and Expand
	PBYTE	StringTable;	// Expand only
	int 	*HashTable; 	// Compress only
	PBYTE	Stack;			// Expand only

	LPBYTE		CodeInput;
	LPBYTE		CodeOutput;
} LZDATA;

typedef struct
{
	IFFCLASS	Class;	// Class of file
	int Bits;
	int DimX;
	int DimY;
	int LineOffset; 	// Offset between lines in output buffer
	int LineBytes;	  // Bytes per line w/o padding - LineBytes <= LineOffset
	int PackMode;	  // Packing.

	int curline;	  // Current line number
	int linelen;	  // For seeking and other stuff (<0 if not seekable)

	IFFERROR	Error;			// file format error
	CStream*	prstream;		// read stream

	// End of required fields

	int 		BytesPerLine;
	IFFSEQUENCE Sequence;

	int 		BytesInRWBuffer;		// number of bytes in rwbuffer
	int 		CompBufferSize;
	int 		DecompBufferSize;
	LPBYTE		RWBuffer;				// allocated buffer
	LPBYTE		rw_ptr;
	LPBYTE		DecompBuffer;
	LPBYTE		dcmp_ptr;
	int 		ReadItAll;
	int 		BytesLeft;
	int 		StripLines;
	int 		LinesPerStrip;
	int 		ActualLinesPerStrip;

	int 		PaletteSize;
	LPBYTE		Palette;

	LZDATA* 	plzData;

	BOOL	BlackOnWhite;
	LSD 	lsd;
} IFF_FID, IFF_GIF;

FSERR SetupForRead(int pos, int iWhichImage, IFF_FID* piff);

typedef IFF_FID *IFFPTR;

// IFFPACKMODE:   Packing modes

typedef enum {
	IFFPM_PACKED,
	IFFPM_UNPACKED,
	IFFPM_LEFTJUSTIFIED,
	IFFPM_NORMALIZED,
	IFFPM_RAW,
} IFFPACKMODE;

#ifndef _MAC_
#define MYCPU		0
#define INTELSWAP16(X)
#define INTELSWAP32(X)
#else
#define MYCPU		1
#define INTELSWAP16(X) { unsigned char c, *p=(unsigned char *)&X; c=p[0]; p[0]=p[1]; p[1]=c; }
#define INTELSWAP32(X) { unsigned char c, *p=(unsigned char *)&X; c=p[0]; p[0]=p[3]; p[3]=c; c = p[1]; p[1] = p[2]; p[2] = c; }
#endif

enum CPUTYPE {
	INTEL = 0,
	MOTOROLA=1
};

#define MAXSIZE	8192
#ifndef RWBUFFSIZE
#define RWBUFFSIZE (8 * 4096)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\gif.cpp ===
// Copyright (C) Microsoft Corporation 1990-1997, All Rights reserved.

#include "header.h"
#include "cpaldc.h"
#include "gif.h"
#include "hha_strtable.h"
#include "hhctrl.h"

#define GIF_HDR_SIZE 6

#define MAX_BUFFER_SIZE (2L * MAXSIZE)
#define END_INFO		(plzData->ClearCode+1)
#define FIRST_ENTRY 	(plzData->ClearCode+2)
#define HASH_SIZE		5003

STATIC int		GetImagePalette(IFFPTR piff, LPBYTE pal);
STATIC FSERR	GetInit(PCSTR pszFileName, IFFPTR piff, UINT GetFlag);
STATIC void 	GIFFreeMemory(IFFPTR piff);
STATIC void 	SetUserParams(IFFPTR);
STATIC int		IFF_PackLine(PBYTE ToBuff, const BYTE* FromBuff, int Pixels, int Bits);
STATIC LZDATA*	LZInitialize(int CharSize);
STATIC void 	LZCleanUp(LZDATA*);
STATIC int		LZExpand(LZDATA*, PBYTE, PBYTE, unsigned, unsigned);
STATIC void 	BitmapHeaderFromIff(IFFPTR piff, LPBITMAPINFOHEADER pbih);
STATIC IFFPTR	GifOpen(PCSTR pszFileName);
STATIC void 	GifClose(IFFPTR piff);
STATIC int		GifGetLine(int NumLines, PBYTE Buffer, IFFPTR piff);

INLINE void InvertLine(LPBYTE Buffer, int DimX);
INLINE int	ColorsFromBitDepth(int bitsperpixel);
INLINE int	ScanLineWidth(int width, int bitcount);

static const int InterlaceMultiplier[] = { 8, 8, 4, 2 };
static const int InterlaceOffset[] =	 { 0, 4, 2, 1 };

void BitmapHeaderFromIff(IFFPTR piff, LPBITMAPINFOHEADER pbih)
{
	pbih->biSize		 = sizeof(BITMAPINFOHEADER);
	pbih->biWidth		 = piff->DimX;
	pbih->biHeight		 = piff->DimY;
	pbih->biPlanes		 = 1;
	pbih->biCompression  = 0;
	pbih->biXPelsPerMeter= 0;
	pbih->biYPelsPerMeter= 0;
	pbih->biClrImportant = 0;
	
	switch (piff->Class) {
		case IFFCL_BILEVEL:
			pbih->biBitCount = 1;
			pbih->biClrUsed  = 2;
			break;

		case IFFCL_PALETTE:
			if (piff->Bits <= 4) {
				pbih->biBitCount = 4;
				pbih->biClrUsed  = 16;
			}
			else {
				pbih->biBitCount = 8;
				pbih->biClrUsed  = 256;
			}
			break;

		case IFFCL_GRAY:
			pbih->biBitCount = 8;
			pbih->biClrUsed  = 256;
			break;
	}

	pbih->biSizeImage = (pbih->biWidth * pbih->biBitCount + 31) / 32;
	pbih->biSizeImage *= 4 * pbih->biHeight;
}

BOOL LoadGif(PCSTR pszFile, HBITMAP* phbmp, HPALETTE* phpal, CHtmlHelpControl* phhctrl)
{
	IFFPTR piff = GifOpen(pszFile);
	if (!piff)
		return FALSE;

	CMem memBmi(sizeof(BITMAPINFOHEADER) +
		sizeof(RGBQUAD) * (piff->Bits > 8 ? 0 : 256));

	PBITMAPINFO pbmi = (PBITMAPINFO) memBmi.pb;
	PBITMAPINFOHEADER pbih = (PBITMAPINFOHEADER) pbmi;

	BitmapHeaderFromIff(piff, pbih);

	if (pbih->biBitCount)
		pbih->biBitCount = 8;	// filter always returns 256-color image

	ASSERT(pbih->biBitCount);

	// Read in the palette

	if (pbih->biBitCount && phpal) {
		CMem memPal(768);
		int cColors = ColorsFromBitDepth(pbih->biBitCount);
		if (piff->Class == IFFCL_PALETTE || piff->Class == IFFCL_BILEVEL) {
			GetImagePalette(piff, memPal.pb);
			for (int i = 0; i < cColors; i++) {
				pbmi->bmiColors[i].rgbRed = memPal.pb[i * 3];
				pbmi->bmiColors[i].rgbGreen = memPal.pb[i * 3 + 1];
				pbmi->bmiColors[i].rgbBlue = memPal.pb[i * 3 + 2];
				pbmi->bmiColors[i].rgbReserved = 0;
			}
		}
		else {
			for (int i = 0; i < cColors; i++) {
				pbmi->bmiColors[i].rgbRed =
				pbmi->bmiColors[i].rgbGreen =
				pbmi->bmiColors[i].rgbBlue = (BYTE) i;
				pbmi->bmiColors[i].rgbReserved = 0;
			}
		}

		*phpal = CreateBIPalette(pbih);
	}

	CPalDC dc;

	if (phpal && *phpal)
		dc.SelectPal(*phpal);

	int cbLineWidth = ScanLineWidth(pbih->biWidth, pbih->biBitCount);

	PBYTE pBits;
	*phbmp = CreateDIBSection(dc.m_hdc, pbmi, DIB_RGB_COLORS,
		(void**) &pBits, NULL, 0);
	if (!*phbmp)
		goto ErrorReturn;

	if (piff->Sequence == IFFSEQ_INTERLACED) {
		int InterPass = 0;
		int InterLine = InterlaceOffset[InterPass];
		for (int i = 0; i < pbih->biHeight; i++) {
			int TmpLine = InterlaceMultiplier[InterPass] * InterLine + InterlaceOffset[InterPass];

			// Small images will skip one or more passes

			while (TmpLine >= pbih->biHeight) {
				InterPass++;
				InterLine = 0;
				TmpLine = InterlaceOffset[InterPass];
				if (TmpLine >= pbih->biHeight)
					TmpLine = pbih->biHeight - 1;
			}
			PBYTE pbBits = pBits +
				((pbih->biHeight - 1) - TmpLine) * cbLineWidth;
			ASSERT(pbBits <= (pBits + ((pbih->biHeight - 1) * cbLineWidth)));
			if (GifGetLine(1, pbBits, piff) == IFFERR_NONE) {
				InterLine++;
			}
			else {
				goto ErrorReturn;
			}
		}
	}
	else {
		for (int i = 0; i < pbih->biHeight; i++) {
			PBYTE pbBits = pBits +
				((pbih->biHeight - 1) - i) * cbLineWidth;
			int result = GifGetLine(1, pbBits, piff);
			if (result != IFFERR_NONE) {
				goto ErrorReturn;
			}
		}
	}

	GifClose(piff);
	return TRUE;

ErrorReturn:
	if (phhctrl)
		phhctrl->AuthorMsg(IDSHHA_GIF_CORRUPT, pszFile);
	else
		doAuthorMsg(IDSHHA_GIF_CORRUPT, pszFile);
	GifClose(piff);
	if (phpal && *phpal) {
		dc.SelectPal(NULL);
		DeleteObject(*phpal);
	}
	return FALSE;
}

STATIC IFFPTR GifOpen(PCSTR pszFileName)
{
	IFFPTR piff = (IFFPTR) lcCalloc(sizeof(IFF_FID));

	UINT GetFlag = 0;

	piff->Error = IFFERR_NONE;
	piff->PackMode = IFFPM_NORMALIZED;
	piff->linelen = -1;

	if ((piff->Error = GetInit(pszFileName, piff, GetFlag)) != FSERR_NONE) {
		if (piff->prstream) {
			delete piff->prstream;
		}
		GIFFreeMemory(piff);
		lcFree(piff);
		return NULL;
	}
	SetUserParams(piff);

	switch (piff->Class) {
		case IFFCL_BILEVEL:
			piff->LineBytes = (piff->DimX + 7) / 8;
			piff->LineOffset = piff->DimX;
			break;

		case IFFCL_RGB:
			piff->LineBytes = piff->DimX * 3;
			piff->LineOffset = piff->LineBytes;
			break;

		default:
			piff->LineBytes = piff->DimX;
			piff->LineOffset = piff->LineBytes;
			break;
	}

	return piff;
}

STATIC void GifClose(IFFPTR piff)
{
	if (piff->prstream)
		delete piff->prstream;

	GIFFreeMemory(piff);
	lcFree(piff);
}

STATIC int GifGetLine(int NumLines, PBYTE Buffer, IFFPTR piff)
{
	int 		Count, RetCnt;
	int 		UserWidth;
	LPBYTE		ptr;

	if (piff == NULL)
		return (IFFERR_PARAMETER);

	if (piff->PackMode == IFFPM_PACKED)
		UserWidth = piff->BytesPerLine;
	else
		UserWidth = piff->DimX;

	do {
		// if there are uncompressed lines in the buffer, just copy them

		if (piff->StripLines > 0) {
			ptr = piff->DecompBuffer + ((piff->ActualLinesPerStrip - piff->StripLines) * piff->BytesPerLine);
			if (piff->PackMode == IFFPM_PACKED) {
				IFF_PackLine(Buffer, ptr, piff->DimX, piff->Bits);
				if (piff->BlackOnWhite)
					InvertLine(Buffer, piff->DimX);
			}
			else
				memcpy(Buffer, ptr, piff->DimX);

			piff->StripLines--;
			NumLines--;
			piff->curline++;
			Buffer += UserWidth;
		}
		else {

			// decompress a strip, first get enough compressed data

			if (!piff->ReadItAll) {

				//	copy already read lines to beginning of comp buffer

				if (piff->BytesInRWBuffer)
					memcpy(piff->RWBuffer, piff->rw_ptr, piff->BytesInRWBuffer);
				piff->rw_ptr = piff->RWBuffer + piff->BytesInRWBuffer;

				// read compressed blocks until comp buffer is full

				while (piff->BytesInRWBuffer < (piff->CompBufferSize - 256)) {
					BYTE BlockSize = piff->prstream->cget();
					if (piff->prstream->m_fEndOfFile) {
						piff->Error = IFFERR_IO_READ;
						return piff->Error;
					}
					if (BlockSize == 0) {
						piff->ReadItAll = 1;
						break;
					}

					Count = BlockSize;
					if (!piff->prstream->doRead(piff->rw_ptr, BlockSize)) {
						piff->Error = IFFERR_IO_READ;
						return piff->Error;
					}

					piff->BytesInRWBuffer += Count;
					piff->rw_ptr += Count;
				}

				piff->rw_ptr = piff->RWBuffer;
			}

			// copy back already decompressed bytes to beginning of decomp buffer

			if (piff->BytesLeft)
				memcpy(piff->DecompBuffer, piff->dcmp_ptr, piff->BytesLeft);
			piff->dcmp_ptr = piff->DecompBuffer + piff->BytesLeft;

			// decompress to fill the decomp buffer

			Count = piff->DecompBufferSize;
			ASSERT(piff->plzData);
			RetCnt = LZExpand(piff->plzData, piff->dcmp_ptr, piff->rw_ptr, Count, piff->BytesInRWBuffer);
			if (RetCnt <= 0)
				return IFFERR_IMAGE;
			piff->BytesInRWBuffer -= RetCnt;
			piff->rw_ptr += RetCnt;
			piff->StripLines = Count / piff->BytesPerLine;
			piff->BytesLeft = Count % piff->BytesPerLine;
			piff->ActualLinesPerStrip = piff->StripLines;
			piff->dcmp_ptr = piff->DecompBuffer + piff->StripLines * piff->BytesPerLine;
		}
	} while (NumLines);

	return IFFERR_NONE;
}

STATIC void SetUserParams(IFFPTR piff)
{
	int 		i;
	BOOL		fIsPalette;

	piff->BlackOnWhite = FALSE;
	fIsPalette = TRUE;
	if (piff->Bits == 1) {
		if (piff->Palette == NULL)
			fIsPalette = FALSE;
		else {
			if (piff->Palette[0] == piff->Palette[1] &&
				piff->Palette[1] == piff->Palette[2] &&
				piff->Palette[0] == 0 &&
				piff->Palette[3] == piff->Palette[4] &&
				piff->Palette[4] == piff->Palette[5] &&
				piff->Palette[3] == 255)
				fIsPalette = FALSE;
			if (piff->Palette[0] == piff->Palette[1] &&
				piff->Palette[1] == piff->Palette[2] &&
				piff->Palette[0] == 255 &&
				piff->Palette[3] == piff->Palette[4] &&
				piff->Palette[4] == piff->Palette[5] &&
				piff->Palette[3] == 0)
			{
				piff->BlackOnWhite = TRUE;
				fIsPalette = FALSE;
			}
		}
		if (!fIsPalette)
			piff->Class = IFFCL_BILEVEL;
	}
	if (fIsPalette) {
		for (i = 0; i < piff->PaletteSize / 3; i++)
			if (piff->Palette[i * 3] != piff->Palette[i * 3 + 1] ||
				piff->Palette[i * 3 + 1] != piff->Palette[i * 3 + 2] ||
				piff->Palette[i * 3] != (BYTE)i)
				break;

		if (i == piff->PaletteSize / 3) {
			for (i = 0; i < piff->PaletteSize / 3; i++)
				piff->Palette[i] = piff->Palette[i * 3];
			piff->PaletteSize /= 3;
			piff->Class = IFFCL_GRAY;
		}
		else
			piff->Class = IFFCL_PALETTE;
	}
}

STATIC int GetImagePalette(IFFPTR piff, LPBYTE Pal)
{
	if (piff->PaletteSize > 0)
		memcpy (Pal, piff->Palette, (unsigned) piff->PaletteSize);
	else
		return IFFERR_NOTAVAILABLE;

	return IFFERR_NONE;
}

STATIC FSERR GetInit(PCSTR pszFileName, IFFPTR piff, UINT GetFlag)
{
	BYTE	Buffer[13];

	piff->prstream = new CStream(pszFileName);
	if (!piff->prstream->fInitialized) {
		GIFFreeMemory(piff);
		return FSERR_CANT_OPEN;
	}

	if (!piff->prstream->doRead(Buffer, GIF_HDR_SIZE)) {
		GIFFreeMemory(piff);
		piff->Error = IFFERR_IO_READ;
		return FSERR_TRUNCATED;
	}

	if (((Buffer[0] != 'G') || (Buffer[1] != 'I') || (Buffer[2] != 'F') ||
			(Buffer[3] != '8') || (Buffer[5] != 'a')) ||
			((Buffer[4] != '7') && (Buffer[4] != '9'))) {
		GIFFreeMemory(piff);
		piff->Error = IFFERR_HEADER;
		return FSERR_INVALID_FORMAT;
	}

	piff->prstream->read(&piff->lsd, sizeof(LSD));

	piff->Bits = (int) (piff->lsd.b.ceGCT + 1);
	piff->PaletteSize = 3 * (1 << piff->Bits);

	if (piff->lsd.b.fGCT) {
		piff->Palette = (PBYTE) lcMalloc(piff->PaletteSize);
		if (!piff->prstream->doRead(piff->Palette, piff->PaletteSize)) {
			GIFFreeMemory(piff);
			piff->Error = IFFERR_IO_READ;
			return FSERR_TRUNCATED;
		}
	}

	for (;;) {
		if (piff->prstream->m_fEndOfFile) {
			piff->Error = IFFERR_IO_READ;
			return FSERR_CORRUPTED_FILE;
		}
		Buffer[0] = piff->prstream->cget();

		switch (*Buffer) {
		case 0x21:		// control extension
			if (!piff->prstream->doRead(Buffer, 2)) {
				GIFFreeMemory(piff);
				piff->Error = IFFERR_IO_READ;
				return FSERR_TRUNCATED;
			}

			switch (*Buffer) {
				case 0xFF:		// Application Specific Block
				case 0xF9:		// Graphics Control Extension
				case 0x01:		// Plain Text Extension
				case 0xFE:		// Comment Extension
					while (Buffer[1] != 0) {
						piff->prstream->seek((long) Buffer[1], SK_CUR);

						if (piff->prstream->m_fEndOfFile) {
							piff->Error = IFFERR_IO_READ;
							return FSERR_CORRUPTED_FILE;
						}
						Buffer[1] = piff->prstream->cget();
					}
					break;

				default:
					ASSERT_COMMENT(FALSE, "The following code needs verification");
					piff->prstream->seek(Buffer[1] + 1, SK_CUR);
					break;
			}
			break;

		case 0x3B:		// end of file
			return FSERR_NONE;

		case 0x2C:
			if (!piff->prstream->doRead((Buffer + 1), 9)) {
				GIFFreeMemory(piff);
				piff->Error = IFFERR_IO_READ;
				return FSERR_TRUNCATED;
			}

			short	IntData[2];
			memcpy(IntData, Buffer + 5, 2 * sizeof(short));
			INTELSWAP16 (IntData[0]);
			INTELSWAP16 (IntData[1]);

			piff->DimX = IntData[0];
			piff->DimY = IntData[1];

			if (Buffer[9] & 0x40)
				piff->Sequence = IFFSEQ_INTERLACED;
			else
				piff->Sequence = IFFSEQ_TOPDOWN;

			if (Buffer[9] & 0x80) {
				piff->Bits = (Buffer[9] & 0x07) + 1;
				int Size = (3 * (1 << piff->Bits));

				// Ignore local color table for now

				piff->prstream->seek(Size, SK_CUR);
			}

			BYTE CodeSize = piff->prstream->cget();

			piff->BytesPerLine = piff->DimX;

			piff->CompBufferSize = MAX_BUFFER_SIZE;
			piff->DecompBufferSize = (MAX_BUFFER_SIZE >> 1) + (MAX_BUFFER_SIZE >> 2);

			// calculate the number of lines in a strip

			piff->StripLines = 0;
			piff->LinesPerStrip = piff->DecompBufferSize / piff->BytesPerLine;
			piff->DecompBufferSize = (piff->LinesPerStrip * piff->BytesPerLine);
			piff->BytesInRWBuffer = 0;
			piff->BytesLeft = 0;

			piff->RWBuffer = (PBYTE) lcMalloc(piff->CompBufferSize);
			piff->DecompBuffer = (PBYTE) lcMalloc(piff->DecompBufferSize);
			piff->rw_ptr = piff->RWBuffer;
			piff->dcmp_ptr = piff->DecompBuffer;

			piff->curline = 0;

			piff->plzData = LZInitialize(CodeSize);
			if (piff->plzData == NULL) {
				GIFFreeMemory(piff);
				piff->Error = IFFERR_MEMORY;
				return FSERR_INSF_MEMORY;
			}
			return FSERR_NONE;
		}
	}

	return FSERR_NONE;
}

STATIC void GIFFreeMemory(IFFPTR piff)
{
	if (piff->plzData != NULL)
		LZCleanUp(piff->plzData);

	if (piff->Palette)
		lcClearFree(&piff->Palette);
	if (piff->RWBuffer)
		lcClearFree(&piff->RWBuffer);
	if (piff->DecompBuffer)
		lcClearFree(&piff->DecompBuffer);

	piff->plzData = NULL;

	return;
}

INLINE void InvertLine(LPBYTE Buffer, int DimX)
{
	int il = (DimX + 7) >> 3;
	for (int i = 0; i < il; i++)
		*Buffer++ = 255 - *Buffer;
}

FSERR SetupForRead(int pos, int iWhichImage, IFF_FID* piff)
{
	piff->prstream->seek(pos);
	BYTE CodeSize = piff->prstream->cget();

	piff->BytesPerLine = piff->DimX;

	piff->CompBufferSize = MAX_BUFFER_SIZE;
	piff->DecompBufferSize = (MAX_BUFFER_SIZE >> 1) + (MAX_BUFFER_SIZE >> 2);

	// calculate the number of lines in a strip

	piff->StripLines = 0;
	piff->LinesPerStrip = piff->DecompBufferSize / piff->BytesPerLine;
	piff->DecompBufferSize = (piff->LinesPerStrip * piff->BytesPerLine);
	piff->BytesInRWBuffer = 0;
	piff->BytesLeft = 0;

	if (piff->RWBuffer)
		lcFree(piff->RWBuffer);
	piff->RWBuffer = (PBYTE) lcMalloc(piff->CompBufferSize);
	if (piff->DecompBuffer)
		lcFree(piff->DecompBuffer);
	piff->DecompBuffer = (PBYTE) lcMalloc(piff->DecompBufferSize);
	piff->rw_ptr = piff->RWBuffer;
	piff->dcmp_ptr = piff->DecompBuffer;

	piff->curline = 0;

	if (piff->plzData)
		LZCleanUp(piff->plzData);
	piff->plzData = LZInitialize(CodeSize);
	if (piff->plzData == NULL) {
		GIFFreeMemory(piff);
		piff->Error = IFFERR_MEMORY;
		return FSERR_UNSUPPORTED_GIF_FORMAT;
	}
	// piff->Sequence = pGifImage->fInterlaced ? IFFSEQ_INTERLACED : IFFSEQ_TOPDOWN;

	return FSERR_NONE;
}

int IFF_PackLine(PBYTE ToBuff, const BYTE* FromBuff, int Pixels, int Bits)
{
	int  Mask;
	int  PMask;
	int  Pix;
	int  Shift;
	int  i;

	switch (Bits) {
		case 1:
		case 4:
			Mask = ((8 / Bits) - 1);
			Pix = 0;
			Shift = (WORD) (8 - Bits);
			PMask = (WORD) (0xFF >> Shift);
			for (i = 0; i < Pixels; i++)
			{
				Pix |= *FromBuff++ & PMask;

				if ((i & Mask) == Mask)
				{
					*ToBuff++ = (BYTE) Pix;
					Pix = 0;
				}
				else
					Pix <<= Bits;
			}
			if ((i & Mask) != 0)
			{
				while ((++i & Mask) != 0)
					Pix <<= Bits;
				*ToBuff = (BYTE) Pix;
			}
			return (Pixels + Mask) / (Mask + 1);
			break;

		case 8: 	// degenerate case
			memcpy(ToBuff, FromBuff, Pixels);
			return Pixels;

		default:
			IASSERT_COMMENT(FALSE, "Invalid bit depth");
			break;
	}
	return 0;
}

INLINE void ExpandReset(LZDATA* plzData)
{
	plzData->BitPos = 0;
	plzData->CurBits = plzData->CharSize + 1;
	plzData->OutString = 0;
	plzData->CodeJump = (1 << plzData->CurBits) - 1;
	plzData->CodeJump++;
}

INLINE unsigned GetNextCode(LZDATA* plzData)
{
	unsigned short	code;
	int		newbitpos;

	code = (unsigned short) (*plzData->CodeInput | (plzData->CodeInput[1] << 8));

	code >>= plzData->BitPos;						 // ditch previous bits
	code &= 0xFFFF >> (16 - plzData->CurBits);		 // ditch next bits

	newbitpos = plzData->BitPos + plzData->CurBits;

	if (newbitpos > 7)
		++plzData->CodeInput;	 // used up at least one * byte

	if (newbitpos >= 16)
		++plzData->CodeInput;	 // used up two bytes

	if (newbitpos > 16) {			// need more bits
		code |= (*plzData->CodeInput << (32 - newbitpos)) >> (16 - plzData->CurBits);
		code &= 0xFFFF >> (16 - plzData->CurBits);		// ditch next bits
	}
	plzData->BitPos = newbitpos & 7;

	return code;			// need mask in 32 bit
}

STATIC int LZExpand(LZDATA* plzData, LPBYTE ToBuff, LPBYTE FromBuff, unsigned ToCnt, unsigned FromCnt)
{
	unsigned		cnt;
	LPBYTE		outbuff = ToBuff;
	int		code, incode;

	ASSERT(plzData);
	plzData->CodeInput = FromBuff;
	cnt = ToCnt;

	while (plzData->OutString > 0 && cnt > 0) {
		*outbuff++ = plzData->Stack[--plzData->OutString];
		cnt--;
	}

	while (cnt > 0) {
		if ((code = GetNextCode(plzData)) == END_INFO)
			break;

		if (code == plzData->ClearCode) {

			ZeroMemory(plzData->CodeTable, sizeof(int*) * HASH_SIZE);

			for (int i = 0; i < HASH_SIZE; i++) {
			//	  plzData->CodeTable[i] = 0;
				plzData->StringTable[i] = (unsigned char) i;
			}

			plzData->CurBits = plzData->CharSize + 1;  // start beginning
			plzData->TableEntry = FIRST_ENTRY;
			plzData->OutString = 0;
			plzData->CodeJump = (1 << plzData->CurBits) - 1;
			plzData->CodeJump++;
			plzData->LastChar = plzData->OldCode = GetNextCode(plzData);
			if (plzData->OldCode == END_INFO)
				break;
			*outbuff++ = (unsigned char) plzData->LastChar;  // output a code
			cnt--;
		}
		else {
			if ((incode = code) >= plzData->TableEntry) {  // is_in_code_table ?
				plzData->Stack[plzData->OutString++] = (unsigned char) plzData->LastChar;  /* not in table */
				code = plzData->OldCode;
			}
			while (code >= plzData->ClearCode) {	 // need decoding
				if ((plzData->OutString >= (1L << 12)) || (code > HASH_SIZE))
					return -1;
				plzData->Stack[plzData->OutString++] = plzData->StringTable[code];
				code = plzData->CodeTable[code];
			}

			if (code < 0 || code > HASH_SIZE || plzData->TableEntry >= HASH_SIZE) {

				// pretend that we decoded all data.

				return min((int) (plzData->CodeInput - FromBuff), (int) FromCnt);
			}
			plzData->Stack[plzData->OutString++] =
				(BYTE) (plzData->LastChar =
					plzData->StringTable[code]);

			// output string

			while (plzData->OutString > 0 && cnt > 0) {
				*outbuff++ = plzData->Stack[--plzData->OutString];
				cnt--;
			}

			plzData->CodeTable[plzData->TableEntry] = plzData->OldCode;  // Add string to table
			plzData->StringTable[plzData->TableEntry++] = (unsigned char) plzData->LastChar;
			if (plzData->TableEntry == plzData->CodeJump && plzData->CurBits < 12) {
				plzData->CodeJump += 1 << plzData->CurBits;
				plzData->CurBits++;
			}
			plzData->OldCode = incode;
		}
	}	// End while

	cnt = (UINT)(plzData->CodeInput - FromBuff);

	return (cnt);
}

STATIC LZDATA* LZInitialize(int CharSize)
{
	if (CharSize < 2)
		CharSize = 2;

	LZDATA* plzData = (LZDATA*) lcCalloc(sizeof(LZDATA));

	plzData->CharSize = CharSize;
	plzData->CodeSize = 12;
	plzData->ClearCode = (1 << CharSize);

	plzData->CodeTable = (int*) lcCalloc(sizeof(int) * HASH_SIZE);
	plzData->StringTable = (PBYTE) lcCalloc(HASH_SIZE);
	plzData->Stack = (PBYTE) lcCalloc(1 << 12);

	ExpandReset(plzData);

	return plzData;
}

STATIC void LZCleanUp(LZDATA* plzData)
{
	if (plzData == NULL)
		return;

	if (plzData->CodeTable)
		lcFree(plzData->CodeTable);
	if (plzData->StringTable)
		lcFree(plzData->StringTable);
	if (plzData->HashTable)
		lcFree(plzData->HashTable);
	if (plzData->Stack)
		lcFree(plzData->Stack);

	lcFree(plzData);
}

INLINE int ColorsFromBitDepth(int bitsperpixel)
{
	switch (bitsperpixel) {
		case 1:
			return 2;

		case 4:
			return 16;

		case 8:
			return 256;
			break;

		default:
			return 0;
	}
}

INLINE int ScanLineWidth(int width, int bitcount)
{
	switch (bitcount) {
		case 1: // REVIEW: is this true?
			return ((width + 31) & ~31) * bitcount / 8;

		case 4:
			return ((width * 4 + 31) / 32 * 4);

		case 8:
			break;
		
		default:
			IASSERT(!"Invalid bitcount value in ScanLineWidth");
			break;
	}

	if (width & 0x03)
		width += (4 - width % 4);
	return width;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\global.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

// This module contains global data variables

#include "header.h"

BOOL g_fMachineHasLicense;
BOOL g_fCheckedForLicense;

BOOL g_fServerHasTypeLibrary = TRUE;

HINSTANCE    g_hinstOcx;
VARIANT_BOOL g_fHaveLocale;

BOOL    g_fSysWin95;        // we're under Win95 system, not just NT SUR
BOOL    g_fSysWinNT;        // we're under some form of Windows NT
BOOL    g_fSysWin95Shell;   // we're under Win95 or Windows NT SUR { > 3/51)
BOOL    g_bWinNT5 = FALSE;  // we're under NT5
BOOL    g_bWin98 = FALSE;   // we're under Win98
BOOL    g_fBiDi;            // TRUE if this is a BiDi title
BOOL    g_fRegisteredSpash; // TRUE if Splash window has been registered
BOOL    g_bBiDiUi;          // TRUE when we have a localized Hebrew or Arabic UI
BOOL    g_bArabicUi;        // TRUE when we have a Arabic UI
DWORD   g_RTL_Mirror_Style; // Bi-Di RTL style (Win98 & NT5 only)
DWORD   g_RTL_Style;        // Bi-Di RTL style


HMODULE  g_hmodHHA = 0;      // HHA.dll module handle
HMODULE  g_hmodMSI;      // msi.dll module handle
BOOL     g_fTriedHHA = 0;    // whether or not we tried to find HHA.dll
BOOL     g_fDBCSSystem;
LCID     g_lcidSystem;
LANGID   g_langSystem;
HWND     g_hwndParking;
BOOL     g_fDualCPU = -1;    // will be TRUE or FALSE when initialized
BOOL     g_fThreadRunning;   // TRUE if our thread is doing something
WORD     g_defcharset;
HBITMAP  g_hbmpSplash;
HPALETTE g_hpalSplash;
HWND     g_hwndSplash;
BOOL     g_fNonFirstKey; // accept keyboard entry for non-first level index keys
BOOL     g_bMsItsMonikerSupport = FALSE;  // "ms-its:" moniker supported starting with IE 4
BOOL     g_fCoInitialized;   // means we called CoInitialize()
BOOL     g_fIE3 = TRUE; // affects which features we can support
// ref count for LockServer

LONG  g_cLocks;

// These are used for reflection in OLE Controls.  Not that big of a hit that
// we mind defining them for all servers, including automation or generic
// COM.

// Following is global data for windowing

int     g_cWindowSlots; // current number of allocated window slots
int     g_curHmData;    // current title collection
int     g_cHmSlots;     // number of CHmData slots available

RECT    g_rcWorkArea;
int     g_cxScreen;
int     g_cyScreen;
BOOL    g_fOleInitialized;
CRITICAL_SECTION g_cs;       // per-instance
UINT    g_fuBiDiMessageBox;

UINT MSG_MOUSEWHEEL;

HCURSOR hcurRestore;
HCURSOR hcurWait;

#ifndef VSBLDENV
#ifndef RISC
extern "C" const int _fltused = 0;
#endif
#endif

const char txtInclude[]    = ":include";
const char txtFileHeader[] = "file:";
const char txtHttpHeader[] = "http:";
const char txtFtpHeader[] = "ftp:";
const char txtZeroLength[] = "";
const char txtHtmlHelpWindowClass[] = "HH Parent";
const char txtHtmlHelpChildWindowClass[] = "HH Child";
const char txtSizeBarChildWindowClass[] = "HH SizeBar";
//const char txtHtmlHelpNavigationClass[] = "HH Navigation Frame" ; // TODO: Make a window class for the nav frame.
const char txtSysRoot[] = "%SystemRoot%";
const char txtMkStore[] = "mk:@MSITStore:";
const char txtItsMoniker[] = "its:";
const char txtMsItsMoniker[] = "ms-its:";
const char txtHlpDir[] =  "Help";
const char txtOpenCmd[] = "htmlfile\\shell\\open\\command";
const char txtDoubleColonSep[] = "::";
const char txtSepBack[]  = "::/";
const char txtDefExtension[] = ".chm";
const char txtCollectionExtension[] = ".col";
const char txtChmColon[] = ".chm::";
const char txtDefFile[] = "::/default.htm";
const char g_szReflectClassName[] = "CtlFrameWork_ReflectWindow";

// Internal window defs.
const char txtDefWindow[] = ">hhwin";
const char txtGlobalDefWindow[] = ">$global_hhwin";

// Special window types --- filename is ignored.
const char txtPrintWindow[] = ">$global_hhPrint";

#include "sysnames.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\gwintype.h ===
#ifndef __GWINTYPE_H__
#define __GWINTYPE_H__
/////////////////////////////////////////////////////////////////////
//
//
// gwintype.h ---	Header file for CGlobalWinTypes
//
//
/*
	Contains an array of global window type names. Names are added to this array, when
	HH_SET_WIN_TYPE is called with a NULL pszFile parameter. This class provides backwards
	compatibility with code which called HH_SET_WIN_TYPE with the second parameter NULL.

Created:	7 Jul 98
By:			dalero

*/

/////////////////////////////////////////////////////////////////////
//
// CGlobalWinTypes
//
class CGlobalWinTypes
{
public:
//--- Construction

	// Ctor
	CGlobalWinTypes() ;

	// Dtor
	virtual ~CGlobalWinTypes() ;

public:
//--- Operations

	// Add a window type to the list.
	void Add(LPCSTR pszWinType) ;

	// Is the window type in the list.
	bool Find(LPCSTR pszWinType) ;
	bool Find(LPCWSTR pszWinType) ;

private:
//--- Helper functions

    // Allocate the array.
    LPCSTR* AllocateArray(int elements) ;

    // Deallocate the array. Does not free the members.
    void DeallocateArray(LPCSTR* p) ;

    // Destroy the array, including all members.
    void DestroyArray() ;

private:
//--- Member variables

    // Pointer to the array.
    LPCSTR* m_NameArray;

    // The number of allocated elements in the array.
    int m_maxindex ;

    // The last used index
    int m_lastindex ;

};

#endif // __GWINTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\gwintype.cpp ===
/////////////////////////////////////////////////////////////////////
//
//
// gwintype.cpp ---	Implementation file for CGlobalWinTypes
//
//
/*

Created:	7 Jul 98
By:			dalero
*/

// Precompiled header
#include "header.h"

// Our header
#include "gwintype.h"

///////////////////////////////////////////////////////////
//
// Constants
//
// Grow the array by 10 elements each time.
const int c_GwtGrowBy = 10; 

/////////////////////////////////////////////////////////////////////
//
//	                    Construction
//
/////////////////////////////////////////////////////////////////////
//
// Ctor
//
CGlobalWinTypes::CGlobalWinTypes()
:   m_NameArray(NULL),
    m_maxindex(0),
    m_lastindex(0)
{
}

/////////////////////////////////////////////////////////////////////
//
// Dtor
//
CGlobalWinTypes::~CGlobalWinTypes()
{
    DestroyArray() ;
}

/////////////////////////////////////////////////////////////////////
//
//                          Operations
//
/////////////////////////////////////////////////////////////////////
//
// Add a window type to the list.
//
void 
CGlobalWinTypes::Add(LPCSTR pszWinType)
{
    ASSERT(pszWinType) ;

    LPCSTR* p = NULL ;
    if (m_lastindex < m_maxindex)
    {
        // Don't need to grow. Just add it to the existing array.
        p = &m_NameArray[m_lastindex] ;
    }
    else
    {
        // We have used up our slots, so we need to allocate more.
        int newmaxindex = m_maxindex + c_GwtGrowBy;

        // Allocate a new array.
        p = AllocateArray(newmaxindex) ;

        // Copy existing entries.
        for (int i = 0 ; i < m_maxindex ; i++)
        {
            // Copy the pointers
            p[i] = m_NameArray[i] ;
        }

        // Delete the original array.
        DeallocateArray(m_NameArray) ;

        // Use the new array.
        m_NameArray = p;

        // get the pointer.
        p = &m_NameArray[m_lastindex] ;

        // reset the endpoint.
        m_maxindex = newmaxindex ;
    }

    // Increment the index ;
    m_lastindex++ ;

    // Post condition.
    ASSERT(p) ;

    // Duplicate string and save.
    *p = lcStrDup(pszWinType) ;
   
    //return p ;
}

/////////////////////////////////////////////////////////////////////
//
// Is the window type in the list.
//
bool 
CGlobalWinTypes::Find(LPCSTR pszWinType)
{
    ASSERT(pszWinType) ;

   for (int i = 0 ; i < m_lastindex ; i++)
    {
        ASSERT(m_NameArray[i]) ;
        if (m_NameArray[i])
        {
            if (_stricmp(pszWinType, m_NameArray[i]) == 0)
            {
                return true ;
            }
        }
   }
   return false ;
}

/////////////////////////////////////////////////////////////////////
//
// Find ---- Wide version
//
bool 
CGlobalWinTypes::Find(LPCWSTR pszWinType)
{
    ASSERT(pszWinType) ;

    CStr aWinType(pszWinType) ;
    return Find(aWinType.psz) ;
}


/////////////////////////////////////////////////////////////////////
//
//              Helper Functions
//
///////////////////////////////////////////////////////////
//
// Allocate Array
//
LPCSTR* 
CGlobalWinTypes::AllocateArray(int elements)
{
    return new LPCSTR[elements] ;
}

///////////////////////////////////////////////////////////
//
// Deallocate Array
//
void 
CGlobalWinTypes::DeallocateArray(LPCSTR* p)
{
    if (p)
    {
        delete [] p ;
    }
}

///////////////////////////////////////////////////////////
//
// DestroyArray
void 
CGlobalWinTypes::DestroyArray()
{
    for (int i = 0 ; i < m_lastindex ; i++)
    {
        ASSERT(m_NameArray[i]) ;
        if (m_NameArray[i])
        {
            lcFree(m_NameArray[i]) ;
            m_NameArray[i] = NULL ;
        }
    }

    // No more array.
    m_lastindex = 0 ; 
    m_maxindex = 0 ;

    // Release the memory from the array. 
    DeallocateArray(m_NameArray ) ;
    m_NameArray = NULL ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhatable.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

// WARNING! Do not modify this file unless you are modifying the original!
// The original is in the hha source tree.

// All resource ID's >= 0x1D700 get special-cased in hha.dll code to load
// from the DLL instead of the app

#define IDHHA_WAVE_CLIP             0x705
#define IDHHA_WAVE_AUTOCLIP         0x706
#define IDHHA_WAVE_CONVERT          0x707
#define IDHHA_WAVE_UNDO             0x708
#define IDHHA_WAVE_CUT              0x709
#define IDHHA_WAVE_PASTE            0x70B
#define IDHHA_WAVE_FAN              0x70C


#define IDS_AUTHOR_MSG_TITLE        0x1D700
#define IDS_HHA_HH_HELP_CONTEXT     0x1D701
#define IDS_HHA_MISSING_MAP_ID      0x1D702
#define IDS_HHA_MISSING_HELP_ID     0x1D703
#define IDS_HHA_HELP_ID             0x1D704
#define IDS_HHA_MISSING_TP_TXT      0x1D705
#define IDS_CHANGE_APPEARANCE       0x1D706
#define IDS_VIEW_ENTRY              0x1D708
#define IDS_DLL_OUT_OF_DATE         0x1D709
#define IDS_SHORTCUT_NOT_REGISTERED 0x1D70A
#define IDS_PARAMETER_NOT_REGISTERED 0x1D70B
#define IDS_INVALID_SHORTCUT_ITEM1  0x1D70C
#define IDS_SHORTCUT_ARGULESS       0x1D70D
#define IDS_HHA_TOC_PROPERTIES      0x1D70F
#define IDS_HHA_DEFAULT             0x1D710
#define IDS_HHA_UNTITLED            0x1D712
#define IDS_HHA_ALREADY_EXISTS      0x1D713
#define IDS_ASSERTION_FAILURE       0x1D715
#define IDS_ASSRT_COPY_MSG          0x1D716
#define IDS_INTERNAL_ERROR          0x1D717
#define IDS_ASSERTION_ERROR         0x1D718
#ifndef IDS_OOM
#define IDS_OOM                     0x1D71A
#endif
#ifndef IDS_UNTITLED
#define IDS_UNTITLED                0x1D71B
#endif
#define IDS_COMMDLG_ERROR           0x1D71C
#define IDS_HTMLHELP_CAPTION        0x1D71D
#define IDS_LOADING_IMAGE           0x1D71E
#define IDS_SAVING_IMAGE            0x1D71F
#define IDS_FAILED_MAPI_LOAD        0x1D720
#define IDS_FAILED_MAPI_SEND        0x1D721
#define IDS_CHAR_OVERFLOW           0x1D724
#define IDS_RANGE_OVERFLOW          0x1D725
#define IDS_HHA_TEXT_LABEL          0x1D726
#define IDS_HHA_BITMAP_LABEL        0x1D727
#define IDS_HHA_ICON_LABEL          0x1D728
#define IDSHHA_INVALID_KEYWORD      0x1D729
#ifndef IDS_BROWSER_FAVORITES
#define IDS_BROWSER_FAVORITES       0x1D72A
#endif
#define IDS_INCLUDED_FILE           0x1D72B
#define IDS_IDH_GENERIC_STRING      0x1D72C
#define IDS_HHA_NO_URL              0x1D72D
#define IDS_HHCTRL_VERSION          0x1D72F
#define IDS_COMPILED_WITH           0x1D730

// Error messages

#define IDS_INVALID_INITIALIZER     0x1D800
#define IDS_WINTYPE_UNDEFINED       0x1D801
#define IDS_MISSING_COMMAND         0x1D802
#define IDS_MISSING_RELATED         0x1D803
#define IDS_LISTBOX_OVERFLOW        0x1D804
#define IDS_CANT_OPEN               0x1D805
#define IDS_FOLDER_NOT_FILE         0x1D806
#define IDS_READ_ONLY               0x1D807
#define IDS_MUST_SPECIFY_HHC        0x1D808
#define IDS_INVALID_BUTTON_CMD      0x1D809
#define IDS_SELECT_FIRST            0x1D80A
#define IDS_MISSING_TITLE           0x1D80B
#define IDS_TITLE_DEFINED           0x1D80C
#define IDS_MISSING_URL             0x1D80D
#define IDS_MUST_SPECIFY_HHK        0x1D80E
#define IDS_CLASS_NOT_FOUND         0x1D80F
#define IDS_CANNOT_RUN              0x1D810
#define IDS_ACT_WINHELP_NO_HELP     0x1D811
#define IDS_ACT_WINHELP_NO_ID       0x1D812
#define IDS_WIZ_NEED_HELP_FILE      0x1D813
#define IDS_WIZ_NEED_TOPIC_ID       0x1D814
#define IDS_WIZ_NEED_IMAGE          0x1D815
#define IDSHHA_GIF_IMAGE_DAMAGED    0x1D816
#define IDSHHA_GIF_CORRUPT          0x1D817
#define IDSHHA_NO_EXIST             0x1D818
#define IDSHHA_UNABLE_TO_CREATE     0x1D819
#define IDS_HHA_JPEG_NOT_ALLOWED    0x1D81A
#define IDS_CANT_CREATE_THREAD      0x1D81B
#define IDS_NOT_SAVED               0x1D81C
#define IDSHHA_HHCTRL_MISMATCH      0x1D81D
#define IDSHHA_MISSING_PROGRAM      0x1D81E
#define IDSHHA_INVALID_MSG          0x1D81F
#define IDSHHA_INVALID_SH_ITEM      0x1D820
#define IDSHHA_INVALID_COMMAND      0x1D821
#define HCERR_256_BMP               0x1D822
#define HCERR_24BIT_BMP             0x1D823
#define HCERR_COMP_BMP              0x1D824
#define HCERR_BMP_TRUNCATED         0x1D825
#define HCERR_BITMAP_CORRUPTED      0x1D826
#define HCERR_UNKNOWN_BMP           0x1D827
#define HCERR_24BIT_PCX             0x1D828
#define IDSHHA_INVALID_HHWIN        0x1D829
#define IDSHHA_NO_COMMAND_LINE      0x1D82A
#define IDSHHA_INCOMPLETE_COMMAND_LINE 0x1D82B
#define IDS_MISSING_HELP            0x1D82C
#define IDS_CANT_WRITE              0x1D82D
#define IDS_ERR_NOKEYWORD_FILE      0x1D82E
#define IDS_ERR_INVALID_HHK         0x1D82F
#define IDS_ERR_NOKEYWORDS          0x1D830
#define IDSHHA_HH_GET_WIN_TYPE      0x1D831
#define IDSHHA_NO_HH_GET_WIN_TYPE   0x1D832
#define IDSHHA_REMOVE_SELECT_FIRST  0x1D833
#define IDSHHA_COMPILE_LOGO         0x1D834
#define IDSHHA_COMPILING_START      0x1D835
#define IDSHHA_ADDING_KEYWORDS      0x1D836
#define IDSHHA_ADDING_FTS           0x1D837
#define IDSHHA_USER_ABORTING        0x1D838
#define IDSHHA_PLURAL               0x1D839
#define IDSHHA_FATAL_ERRORS         0x1D83A
#define IDSHHA_COMPILE_TIME         0x1D83B
#define IDSHHA_STATS                0x1D83C
#define IDSHHA_CREATED_MSG          0x1D83D
#define IDSHHA_INCREASED            0x1D83E
#define IDSHHA_DECREASED            0x1D83F
#define IDSHHA_COMPRESSION_SAVE     0x1D840
#define IDSHHA_COMPILED_URL         0x1D841
#define IDSHHA_COMPILE_WARNING      0x1D842
#define IDSHHA_COMPILE_ERROR        0x1D843
#define IDSHHA_COMPILE_NOTE         0x1D844
#define IDSHHA_ICON_FILTER          0x1D845
#define IDSHHA_BMP_FILTER           0x1D846
#define IDSHHA_MISSING_RELATE       0x1D847
#define IDSHHA_MISSING_KEYWORD      0x1D848
#define IDSHHA_HTML_NEW_FILE1       0x1D849
#define IDHHA_TXT_SCRIPT_FINISH     0x1D84A
#define IDSHHA_CORRUPTED_HTML       0x1D84B
#define IDSHHA_COMPACTING           0x1d84c


// Keep the following together

#define IDS_STYLE_WS_EX_CLIENTEDGE      0x1D900
#define IDS_STYLE_WS_EX_WINDOWEDGE      0x1D901
#define IDS_STYLE_WS_EX_RTLREADING      0x1D902
#define IDS_STYLE_WS_EX_LEFTSCROLLBAR   0x1D903
#define IDS_STYLE_WS_BORDER             0x1D904
#define IDS_STYLE_WS_DLGFRAME           0x1D905
#define IDS_STYLE_TVS_HASBUTTONS        0x1D906
#define IDS_STYLE_TVS_HASLINES          0x1D907
#define IDS_STYLE_TVS_LINESATROOT       0x1D908
#define IDS_STYLE_TVS_SHOWSELALWAYS     0x1D909
#define IDS_STYLE_TVS_TRACKSELECT       0x1D90A
#define IDS_STYLE_TVS_SINGLEEXPAND      0x1D90B
#define IDS_STYLE_TVS_FULLROWSELECT     0x1D90C

#define FIRST_ACTION 0x1D950

#define ID_ACTION_ALINK             0x1D950
#define ID_ACTION_CLOSE             0x1D951
#define ID_ACTION_VERSION           0x1D952
#define ID_ACTION_INDEX             0x1D953
#define ID_ACTION_KLINK             0x1D954
#define ID_ACTION_RELATED_TOPICS    0x1D955
#define ID_ACTION_SHORTCUT          0x1D956
#define ID_ACTION_SPLASH            0x1D957
#define ID_ACTION_TOC               0x1D958
#define ID_ACTION_WINHELP           0x1D959

#define LAST_ACTION ID_ACTION_WINHELP


#define ID_ACTION_MACRO_ABOUT       0x1D963
#define ID_ACTION_WINHELP_POPUP     0x1D964
#define ID_ACTION_TEXT_POPUP        0x1D965
#define ID_ACTION_MACRO_SHORTCUT    0x1D966

#define FIRST_SCRIPT 0x1DA00

#define IDHHA_SCRIPT_CLICK          0x1DA00
#define IDHHA_SCRIPT_TCARD          0x1DA01
#define IDHHA_SCRIPT_TEXT_POPUP     0x1DA02

#define LAST_SCRIPT IDHHA_SCRIPT_TEXT_POPUP

#define IDHHAD_SCRIPT_CLICK          0x1DB00
#define IDHHAD_SCRIPT_TCARD          0x1DB01
#define IDHHAD_SCRIPT_TEXT_POPUP     0x1DB02
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hha.cpp ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

// This module contains all the routines necessary for talking to hha.dll.
// This dll is installed as part of HtmlHelp Workshop, indicating that a Help
// Author is working with the HtmlHelp display.

/*
    TODO:   This function calls the following lines TOO many times
        if (g_hmodHHA == NULL) {
            if (g_fTriedHHA || !LoadHHA(NULL, _Module.GetModuleInstance())) {

    this code needs to be consolidated.


*/
#include "header.h"
#include "hhctrl.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

#include "strtable.h"
#include "hha_strtable.h"
#include "hhctrl.h"
#include "secwin.h"

#define DLL_VERSION 0x0018  // from hhafunc.h (help authoring dll project)

int (WINAPI *pHHA_msg)(UINT command, WPARAM wParam, LPARAM lParam);
PCSTR (STDCALL *pGetDllStringResource)(int idFormatString);
int (STDCALL *pDllMsgBox)(int idFormatString, PCSTR pszSubString, UINT nType);
static BOOL InitializeHHA(HWND hwnd, HINSTANCE hinst);

// persistent local memory class
class CDataHHA {
  public:
    CDataHHA::CDataHHA() { m_pszMsgBoxTitle = NULL; }
    CDataHHA::~CDataHHA() { CHECK_AND_FREE( m_pszMsgBoxTitle ); }

    char* GetMsgBoxTitle(void) { if( !m_pszMsgBoxTitle ) m_pszMsgBoxTitle = lcStrDup(pGetDllStringResource(IDS_AUTHOR_MSG_TITLE)); return m_pszMsgBoxTitle; } 

  private:
    char* m_pszMsgBoxTitle;

};

static CDataHHA s_Data;

#if defined(_DEBUG)

void WINAPI CopyAssertInfo(PSTR pszDst);

void (WINAPI *pAssertErrorReport)(PCSTR pszExpression, UINT line, LPCSTR pszFile);

void AssertErrorReport(PCSTR pszExpression, UINT line, LPCSTR pszFile)
{
    if (g_hmodHHA == NULL) {
        if (g_fTriedHHA || !LoadHHA(NULL, _Module.GetModuleInstance())) {
HHAUnavailable:
            char szMsg[MAX_PATH*2];
            wsprintf(szMsg, "%s\n%s (%u)",
                pszExpression, pszFile, line);
#ifdef _DEBUG
            int answer = ::MessageBox(GetActiveWindow(), pszExpression, "Retry to call DebugBreak()",
                MB_ABORTRETRYIGNORE);

            if (answer == IDRETRY) {
                DebugBreak();
                return;
            }
            else if (answer == IDIGNORE) {
                return;
            }
#else
            MessageBox(GetActiveWindow(), szMsg, "Assertion error",
                MB_ICONEXCLAMATION);
#endif
        }
    }

    if (pAssertErrorReport == NULL) {
        (FARPROC&) pAssertErrorReport =
            GetProcAddress(g_hmodHHA, MAKEINTATOM(26));
        if (pAssertErrorReport == NULL)
            goto HHAUnavailable;
    }

    pAssertErrorReport(pszExpression, line, pszFile);
}

/***************************************************************************

    FUNCTION:   CopyAssertInfo

    PURPOSE:    Allows additional information to be written to the
                assertion file.

    PARAMETERS:
        pszDst  -- where to put the additional information. About 900
                   bytes is available.

    RETURNS:    void

    COMMENTS:   Used when hha.dll is found, and therefore hooked up to
                assertion errors (HHA will call this). See InitializeHHA.

    MODIFICATION DATES:
        25-Feb-1997 [ralphw]

***************************************************************************/

void WINAPI CopyAssertInfo(PSTR pszDst)
{
    *pszDst = '\0';
    return;
}

#endif  // _DEBUG

const TCHAR txtRegKeySection[] = "Software\\Microsoft\\HtmlHelp Author";
const TCHAR txtRegKey[] = "location";

extern "C" HMODULE LoadHHA(HWND hwnd, HINSTANCE hinst)
{
    HKEY hkey;
    TCHAR szPath[MAX_PATH];

    if (RegOpenKeyEx(HKEY_CURRENT_USER,
            txtRegKeySection, 0, KEY_READ, &hkey) ==
            ERROR_SUCCESS) {
        DWORD type;
        DWORD cbPath = sizeof(szPath);
        LONG result = RegQueryValueEx(hkey, txtRegKey, 0, &type,
            (PBYTE) szPath, &cbPath);
        RegCloseKey(hkey);
        if (result == ERROR_SUCCESS) {
            g_hmodHHA = LoadLibrary(szPath);
            if (g_hmodHHA != NULL) {
                if (!InitializeHHA(hwnd, hinst)) {
                    FreeLibrary(g_hmodHHA);
                    g_hmodHHA = NULL;
                    g_fTriedHHA = TRUE;
                    return NULL;
                }
                return g_hmodHHA;
            }
        }
    }
    g_fTriedHHA = TRUE;
    return NULL;
}

/***************************************************************************

    FUNCTION:   InitializeHHA

    PURPOSE:    Initialize the Help Authoring dll

    PARAMETERS:
        hwnd    -- will be used as the parent of HHA.dll message boxes

    RETURNS:    FALSE if InitializeHHA can't be found, which means
                a very corrupted HHA.dll

    COMMENTS:
        Call this whenever the window handle for messages boxes changes.

    MODIFICATION DATES:
        25-Feb-1997 [ralphw]

***************************************************************************/

typedef void (WINAPI* COPYASSERTINFO)(PSTR pszDst);

typedef struct {
    int cb;
    HINSTANCE hinstApp;
    PCSTR pszErrorFile;
    HWND hwndWindow;
    COPYASSERTINFO CopyAssertInfo;
    PCSTR pszMsgBoxTitle;

    // The following will be filled in by the dll

    BOOL fDBCSSystem;
    LCID lcidSystem;
    BOOL fDualCPU;
    UINT version;
} HHA_INIT;


typedef void (WINAPI* INITIALIZEHHA)(HHA_INIT* pinit);
void (WINAPI *pInitializeHHA)(HHA_INIT* pinit);

static BOOL InitializeHHA(HWND hwnd, HINSTANCE hinst)
{
    ASSERT(g_hmodHHA != NULL);
    static HWND hwndLast = (HWND) -1;

    if (hwnd == hwndLast)
        return TRUE;  // no change to window handle, so already initialized

    if (pInitializeHHA == NULL) {
        pInitializeHHA =
            (INITIALIZEHHA) GetProcAddress(g_hmodHHA, MAKEINTATOM(78));
        if (pInitializeHHA == NULL)
            return FALSE;
    }

    (FARPROC&) pGetDllStringResource = GetProcAddress(g_hmodHHA, MAKEINTATOM(194));

    HHA_INIT hwInit;
    hwInit.cb = sizeof(HHA_INIT);
    hwInit.hinstApp = hinst;                // BUGBUG: HHA doesn't separate Resource from App. Will get English resource strings in some instances. (HINST_THIS)
#if defined(_DEBUG)
    hwInit.pszErrorFile = "c:\\HtmlHelp.err";
    hwInit.CopyAssertInfo = CopyAssertInfo;
#else
    hwInit.pszErrorFile = "";
    hwInit.CopyAssertInfo = NULL;
#endif
    hwInit.pszMsgBoxTitle = s_Data.GetMsgBoxTitle();
    hwInit.hwndWindow = hwnd;   // parent for message boxes
    hwInit.version = DLL_VERSION;
    pInitializeHHA(&hwInit);

    (FARPROC&) pDllMsgBox = GetProcAddress(g_hmodHHA, MAKEINTATOM(115));
    (FARPROC&) pHHA_msg = GetProcAddress(g_hmodHHA, MAKEINTATOM(106));

    return TRUE;
}

/***************************************************************************

    FUNCTION:   doAuthorMessage

    PURPOSE:    Use a format string from HHA.dll, format the message
                with the supplied string and display it in a message box.

    PARAMETERS:
        idStringFormatResource  -- must have been defined in HHA.dll
        pszSubString

    RETURNS:    void

    COMMENTS:
        The reason for doing this is to allow for larger, more informative
        strings for help authors without having to ship those strings in
        a retail package where users would never see them.

    MODIFICATION DATES:
        25-Feb-1997 [ralphw]

***************************************************************************/

void doAuthorMsg(UINT idStringFormatResource, PCSTR pszSubString)
{
    // Work around known stack overwrite problem in hha.dll
    //
    char *pszTempString = lcStrDup(pszSubString);

    if(pszTempString && strlen(pszTempString) > 768)
            pszTempString[768] = 0;

    if (g_hmodHHA == NULL) {
        if (g_fTriedHHA || !LoadHHA(NULL, _Module.GetModuleInstance()))
            return; // no HHA.dll, so not a help author
    }

    if (pDllMsgBox == NULL) {
        (FARPROC&) pDllMsgBox = GetProcAddress(g_hmodHHA, MAKEINTATOM(15));
        if (pDllMsgBox == NULL)
            return;
    }

    // Note that the resource id is in hha.dll

    pDllMsgBox(idStringFormatResource, pszTempString, MB_OK);

    // Track the message in HtmlHelp Workshop
    if( !pszTempString || !*pszTempString )
      HHA_Msg(HHA_SEND_RESID_TO_PARENT, idStringFormatResource, (LPARAM) NULL );
    else
      HHA_Msg(HHA_SEND_RESID_AND_STRING_TO_PARENT, idStringFormatResource,
          (LPARAM) pszTempString);
}

void (WINAPI *pReportOleError)(HRESULT, PCSTR);

#ifdef _DEBUG

void doReportOleError(HRESULT hres)
{
    if (g_hmodHHA == NULL) {
        if (g_fTriedHHA || !LoadHHA(NULL, _Module.GetModuleInstance()))
            return; // no HHA.dll, so not a help author
    }

    if (pReportOleError == NULL) {
        (FARPROC&) pReportOleError = GetProcAddress(g_hmodHHA, MAKEINTATOM(234));
        if (pReportOleError == NULL)
            return;
    }
    pReportOleError(hres, NULL);
}

#endif // _DEBUG

void SendStringToParent(PCSTR pszMsg)
{
#ifdef _DEBUG
    OutputDebugString(pszMsg);
#endif

    if (g_hmodHHA == NULL) {
        if (g_fTriedHHA || !LoadHHA(NULL, _Module.GetModuleInstance()))
            return; // no HHA.dll, so not a help author
    }
    ASSERT(pHHA_msg);
    if (!pHHA_msg) {
        return;
    }

    pHHA_msg(HHA_SEND_STRING_TO_PARENT, (WPARAM) pszMsg, 0);
}

int HHA_Msg(UINT command, WPARAM wParam, LPARAM lParam)
{
    if (g_hmodHHA && pHHA_msg)
        return pHHA_msg(command, wParam, lParam);

    if (g_hmodHHA == NULL) {
        if (g_fTriedHHA || !LoadHHA(NULL, _Module.GetModuleInstance()))
            return 0; // no HHA.dll, so not a help author
    }
    ASSERT(pHHA_msg);
    if (!pHHA_msg) {
        return 0;
    }

    return pHHA_msg(command, wParam, lParam);
}

void CHtmlHelpControl::FillGeneralInformation(HHA_GEN_INFO* pgenInfo)
{
    pgenInfo->m_pszBitmap = m_pszBitmap;
    // pgenInfo->m_cImages = m_cImages;
    pgenInfo->pflags = m_flags;
    pgenInfo->m_hfont = m_hfont;
    pgenInfo->m_clrFont = m_clrFont;
    pgenInfo->m_hpadding = m_hpadding;
    pgenInfo->m_vpadding = m_vpadding;
    pgenInfo->m_hImage = m_hImage;
    pgenInfo->m_fPopupMenu = m_fPopupMenu;
    pgenInfo->m_fWinHelpPopup = m_fWinHelpPopup;

    /*
     * A TOC image uses an imagelist, the handle for which is not
     * interchangeable with a "regular" bitmap. To show what it looks like,
     * we must load it as a regular bitmap. This instance of the bitmap
     * will get deleted when the CHtmlHelpControl class is deleted.
     */

    if (m_pszBitmap && !m_hImage) {
        char szBitmap[MAX_PATH];
        if (ConvertToCacheFile(m_pszBitmap, szBitmap)) {
            pgenInfo->m_hImage = m_hImage =
                LoadImage(_Module.GetResourceInstance(), szBitmap, IMAGE_BITMAP, 0, 0,
                    LR_LOADFROMFILE);
        }
    }

    if (m_ptblItems) {
        pgenInfo->cItems = m_ptblItems->CountStrings();
        pgenInfo->apszItems = m_ptblItems->GetStringPointers();
    }
    else
        pgenInfo->cItems = 0;
}

void (STDCALL *pViewEntry)(HWND hwndParent, HHA_ENTRY_APPEARANCE* pAppear);

void DisplayAuthorInfo(CInfoType *pInfoType, CSiteMap* pSiteMap, SITEMAP_ENTRY* pSiteMapEntry, HWND hwndParent, CHtmlHelpControl* phhctrl)
{
    if (!pViewEntry)
        (FARPROC&) pViewEntry = GetProcAddress(g_hmodHHA,
            MAKEINTATOM(262));
    if (!pViewEntry) {
        pDllMsgBox(IDS_DLL_OUT_OF_DATE, "", MB_OK);
        return;
    }
    HHA_ENTRY_APPEARANCE entry;
    ZeroMemory(&entry, sizeof(entry));
    entry.version = HHA_REQUIRED_VERSION;
    entry.pSiteMap = pSiteMap;
    entry.pSiteMapEntry = pSiteMapEntry;

    entry.pszWindowName = pSiteMapEntry->GetWindowIndex() ?
        pSiteMap->GetEntryWindow(pSiteMapEntry) : pSiteMap->GetWindowName();
    entry.pszFrameName  = pSiteMapEntry->GetFrameIndex() ?
        pSiteMap->GetEntryFrame(pSiteMapEntry) : pSiteMap->GetFrameName();

    /*
     * We use a CTable so that we can free all the strings in one fell
     * swoop.
     */

    CTable tblData;
    entry.apszUrlNames = (PCSTR*) tblData.TableMalloc(
        (pSiteMapEntry->cUrls * 2) * sizeof(PCSTR));

    SITE_ENTRY_URL* pUrl = pSiteMapEntry->pUrls;
    for (int i = 0; i < pSiteMapEntry->cUrls; i++) {
        entry.apszUrlNames[i * 2] =
            pUrl->urlPrimary ?
                pSiteMap->GetUrlString(pUrl->urlPrimary) : "";
        entry.apszUrlNames[i * 2 + 1] =
            pUrl->urlSecondary ?
                pSiteMap->GetUrlString(pUrl->urlSecondary) : "";
        pUrl = pSiteMap->NextUrlEntry(pUrl);
    }

    // Now add the type names

    if (pInfoType && pInfoType->HowManyInfoTypes()) {
        entry.apszTypes = (PCSTR*) tblData.TableMalloc(pInfoType->HowManyInfoTypes() * sizeof(PCSTR));
        int end = pInfoType->HowManyInfoTypes();
        for (int i = 0; i < end; i++)
            entry.apszTypes[i] = pInfoType->GetInfoTypeName(i + 1);
        entry.cTypes = end;
    }
    else {
        entry.apszTypes = NULL;
        entry.cTypes = 0;
    }

    if (phhctrl)
        phhctrl->FillGeneralInformation(&entry.genInfo);
    entry.genInfo.pszDefWindowName = pSiteMap->GetWindowName();
    entry.genInfo.pszDefFrameName = pSiteMap->GetFrameName();
    entry.genInfo.pszBackBitmap = pSiteMap->m_pszBackBitmap;

    if (phhctrl)
        phhctrl->ModalDialog(TRUE);
    pViewEntry(FindTopLevelWindow(hwndParent), &entry);
    if (phhctrl)
        phhctrl->ModalDialog(FALSE);
}

// BUGBUG: remove when everything works!

void (STDCALL *pItDoesntWork)(void);

void ItDoesntWork()
{
    if (g_hmodHHA == NULL) {
        if (g_fTriedHHA || !LoadHHA(NULL, _Module.GetModuleInstance()))
            return; // no HHA.dll, so not a help author
    }

    if (!pItDoesntWork)
        (FARPROC&) pItDoesntWork = GetProcAddress(g_hmodHHA,
            MAKEINTATOM(296));
    if (pItDoesntWork)
        pItDoesntWork();
}

BOOL IsHelpAuthor(HWND hwndCaller)
{
    if (g_hmodHHA == NULL) {
        if (g_fTriedHHA || !LoadHHA(hwndCaller, _Module.GetModuleInstance()))
            return FALSE; // no HHA.dll, so not a help author
    }
    return TRUE;
}

void (STDCALL *pDoHhctrlVersion)(HWND hwndParent, PCSTR pszCHMVersion);

void doHhctrlVersion(HWND hwndParent, PCSTR pszCHMVersion)
{
    if (!pDoHhctrlVersion)
        (FARPROC&) pDoHhctrlVersion = GetProcAddress(g_hmodHHA,
            MAKEINTATOM(323));
    if (pDoHhctrlVersion)
        pDoHhctrlVersion(hwndParent, pszCHMVersion);
}

void (STDCALL *pShowWindowType)(PHH_WINTYPE phh);

void doWindowInformation(HWND hwndParent, CHHWinType* phh)
{
    if (!pShowWindowType)
        (FARPROC&) pShowWindowType = GetProcAddress(g_hmodHHA,
            MAKEINTATOM(380));
    if (pShowWindowType) {
        CStr csz("");
        if (!phh->pszCustomTabs) {
            for (int iTab = HHWIN_NAVTYPE_CUSTOM_FIRST; iTab < HH_MAX_TABS+1; iTab++) {
                if (phh->fsWinProperties & (HHWIN_PROP_TAB_CUSTOM1 << (iTab - HH_TAB_CUSTOM_FIRST))) {
                    if (csz.IsNonEmpty())
                        csz += "\1";
                    csz += phh->GetExtTab(iTab - HH_TAB_CUSTOM_FIRST)->pszTabName;
                    csz += " -- ";
                    csz += phh->GetExtTab(iTab - HH_TAB_CUSTOM_FIRST)->pszProgId;
                }
            }
            if (csz.IsNonEmpty())
                csz += "\1";
            phh->pszCustomTabs = csz.psz;
            PSTR psz = StrChr(phh->pszCustomTabs, '\1');
            while (psz) {
                *psz = '\0';
                psz = StrChr(psz + 1, '\1');
            }
        }
        pShowWindowType(phh);
    }
    else if (pDllMsgBox)
        pDllMsgBox(IDS_DLL_OUT_OF_DATE, "", MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhamsgs.h ===
// commands that can be sent to HHA_Msg()

#ifndef __HHA_MSGS_h__
#define __HHA_MSGS_h__

typedef struct {
	char szImageLocation[MAX_PATH];
	COLORREF clr;
	UINT exWindowStyles;
	UINT tvStyles;
} HHA_TOC_APPEARANCE;

typedef struct {
	PCSTR m_pszBitmap;
	int   m_cImages;
	PCSTR pszDefWindowName;
	PCSTR pszDefFrameName;
	PCSTR pszBackBitmap;
	DWORD* pflags;		// array of flags
	HFONT m_hfont;		  // author-specified font to use for child windows
	COLORREF m_clrFont;   // Font color
	int   m_hpadding;	  // horizontal padding around index, contents, and find
	int   m_vpadding;	  // vertical padding around index, contents, and find
	HGDIOBJ m_hImage;
	BOOL  m_fPopupMenu;
	BOOL  m_fWinHelpPopup;
	BOOL  m_fBinarySitemap; // binary TOC or Index

	int    cItems;
	PCSTR* apszItems;	// pointers from m_ptblItems
} HHA_GEN_INFO;

const int HHA_REQUIRED_VERSION = 2;

typedef struct {
	int version;
	CSiteMap*	   pSiteMap;
	SITEMAP_ENTRY* pSiteMapEntry;

	PCSTR pszWindowName;
	PCSTR pszFrameName;

	PCSTR* apszUrls;
	PCSTR* apszUrlNames;

	int    cTypes;
	PCSTR* apszTypes;

	HHA_GEN_INFO genInfo;
} HHA_ENTRY_APPEARANCE;

#define DEFAULT_TOC_STYLES (UINT) (WS_BORDER | TVS_DISABLEDRAGDROP | TVS_HASBUTTONS | TVS_LINESATROOT | TVS_SHOWSELALWAYS )

#endif // __HHA_MSGS_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hha_strtable.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

// WARNING! Do not modify this file unless you are modifying the original!
// The original is in the hha source tree.

// All resource ID's >= 0x1D700 get special-cased in hha.dll code to load
// from the DLL instead of the app

#define IDHHA_WAVE_CLIP             0x705
#define IDHHA_WAVE_AUTOCLIP         0x706
#define IDHHA_WAVE_CONVERT          0x707
#define IDHHA_WAVE_UNDO             0x708
#define IDHHA_WAVE_CUT              0x709
#define IDHHA_WAVE_PASTE            0x70B
#define IDHHA_WAVE_FAN              0x70C

#define IDS_AUTHOR_MSG_TITLE        0x1D700
#define IDS_HHA_HH_HELP_CONTEXT     0x1D701
#define IDS_HHA_MISSING_MAP_ID      0x1D702
#define IDS_HHA_MISSING_HELP_ID     0x1D703
#define IDS_HHA_HELP_ID             0x1D704
#define IDS_HHA_MISSING_TP_TXT      0x1D705
#define IDS_CHANGE_APPEARANCE       0x1D706
#define IDS_VIEW_ENTRY              0x1D708
#define IDS_DLL_OUT_OF_DATE         0x1D709
#define IDS_SHORTCUT_NOT_REGISTERED 0x1D70A
#define IDS_PARAMETER_NOT_REGISTERED 0x1D70B
#define IDS_INVALID_SHORTCUT_ITEM1  0x1D70C
#define IDS_SHORTCUT_ARGULESS       0x1D70D
#define IDS_HHA_TOC_PROPERTIES      0x1D70F
#define IDS_HHA_DEFAULT             0x1D710
#define IDS_HHA_UNTITLED            0x1D712
#define IDS_HHA_ALREADY_EXISTS      0x1D713
#define IDS_ASSERTION_FAILURE       0x1D715
#define IDS_ASSRT_COPY_MSG          0x1D716
#define IDS_INTERNAL_ERROR          0x1D717
#define IDS_ASSERTION_ERROR         0x1D718
#ifndef IDS_OOM
#define IDS_OOM                     0x1D71A
#endif
#ifndef IDS_UNTITLED
#define IDS_UNTITLED                0x1D71B
#endif
#define IDS_COMMDLG_ERROR           0x1D71C
#define IDS_HTMLHELP_CAPTION        0x1D71D
#define IDS_LOADING_IMAGE           0x1D71E
#define IDS_SAVING_IMAGE            0x1D71F
#define IDS_FAILED_MAPI_LOAD        0x1D720
#define IDS_FAILED_MAPI_SEND        0x1D721
#define IDS_CHAR_OVERFLOW           0x1D724
#define IDS_RANGE_OVERFLOW          0x1D725
#define IDS_HHA_TEXT_LABEL          0x1D726
#define IDS_HHA_BITMAP_LABEL        0x1D727
#define IDS_HHA_ICON_LABEL          0x1D728
#define IDSHHA_INVALID_KEYWORD      0x1D729
#ifndef IDS_BROWSER_FAVORITES
#define IDS_BROWSER_FAVORITES       0x1D72A
#endif
#define IDS_INCLUDED_FILE           0x1D72B
#define IDS_IDH_GENERIC_STRING      0x1D72C
#define IDS_HHA_NO_URL              0x1D72D
#define IDS_HHCTRL_VERSION          0x1D72F
#define IDS_COMPILED_WITH           0x1D730
#define IDS_WINDOW_INFO             0x1D731

// Error messages

#define IDS_INVALID_INITIALIZER     0x1D800
#define IDS_WINTYPE_UNDEFINED       0x1D801
#define IDS_MISSING_COMMAND         0x1D802
#define IDS_MISSING_RELATED         0x1D803
#define IDS_LISTBOX_OVERFLOW        0x1D804
#define IDS_CANT_OPEN               0x1D805
#define IDS_FOLDER_NOT_FILE         0x1D806
#define IDS_READ_ONLY               0x1D807
#define IDS_MUST_SPECIFY_HHC        0x1D808
#define IDS_INVALID_BUTTON_CMD      0x1D809
#define IDS_SELECT_FIRST            0x1D80A
#define IDS_MISSING_TITLE           0x1D80B
#define IDS_TITLE_DEFINED           0x1D80C
#define IDS_MISSING_URL             0x1D80D
#define IDS_MUST_SPECIFY_HHK        0x1D80E
#define IDS_CLASS_NOT_FOUND         0x1D80F
#define IDS_CANNOT_RUN              0x1D810
#define IDS_ACT_WINHELP_NO_HELP     0x1D811
#define IDS_ACT_WINHELP_NO_ID       0x1D812
#define IDS_WIZ_NEED_HELP_FILE      0x1D813
#define IDS_WIZ_NEED_TOPIC_ID       0x1D814
#define IDS_WIZ_NEED_IMAGE          0x1D815
#define IDSHHA_GIF_IMAGE_DAMAGED    0x1D816
#define IDSHHA_GIF_CORRUPT          0x1D817
#define IDSHHA_NO_EXIST             0x1D818
#define IDSHHA_UNABLE_TO_CREATE     0x1D819
#define IDS_HHA_JPEG_NOT_ALLOWED    0x1D81A
#define IDS_CANT_CREATE_THREAD      0x1D81B
#define IDS_NOT_SAVED               0x1D81C
#define IDSHHA_HHCTRL_MISMATCH      0x1D81D
#define IDSHHA_MISSING_PROGRAM      0x1D81E
#define IDSHHA_INVALID_MSG          0x1D81F
#define IDSHHA_INVALID_SH_ITEM      0x1D820
#define IDSHHA_INVALID_COMMAND      0x1D821
#define HCERR_256_BMP               0x1D822
#define HCERR_24BIT_BMP             0x1D823
#define HCERR_COMP_BMP              0x1D824
#define HCERR_BMP_TRUNCATED         0x1D825
#define HCERR_BITMAP_CORRUPTED      0x1D826
#define HCERR_UNKNOWN_BMP           0x1D827
#define HCERR_24BIT_PCX             0x1D828
#define IDSHHA_INVALID_HHWIN        0x1D829
#define IDSHHA_NO_COMMAND_LINE      0x1D82A
#define IDSHHA_INCOMPLETE_COMMAND_LINE 0x1D82B
#define IDS_MISSING_HELP            0x1D82C
#define IDS_CANT_WRITE              0x1D82D
#define IDS_ERR_NOKEYWORD_FILE      0x1D82E
#define IDS_ERR_INVALID_HHK         0x1D82F
#define IDS_ERR_NOKEYWORDS          0x1D830
#define IDSHHA_HH_GET_WIN_TYPE      0x1D831
#define IDSHHA_NO_HH_GET_WIN_TYPE   0x1D832
#define IDSHHA_REMOVE_SELECT_FIRST  0x1D833
#define IDSHHA_COMPILE_LOGO         0x1D834
#define IDSHHA_COMPILING_START      0x1D835
#define IDSHHA_ADDING_KEYWORDS      0x1D836
#define IDSHHA_ADDING_FTS           0x1D837
#define IDSHHA_USER_ABORTING        0x1D838
#define IDSHHA_PLURAL               0x1D839
#define IDSHHA_FATAL_ERRORS         0x1D83A
#define IDSHHA_COMPILE_TIME         0x1D83B
#define IDSHHA_STATS                0x1D83C
#define IDSHHA_CREATED_MSG          0x1D83D
#define IDSHHA_INCREASED            0x1D83E
#define IDSHHA_DECREASED            0x1D83F
#define IDSHHA_COMPRESSION_SAVE     0x1D840
#define IDSHHA_COMPILED_URL         0x1D841
#define IDSHHA_COMPILE_WARNING      0x1D842
#define IDSHHA_COMPILE_ERROR        0x1D843
#define IDSHHA_COMPILE_NOTE         0x1D844
#define IDSHHA_ICON_FILTER          0x1D845
#define IDSHHA_BMP_FILTER           0x1D846
#define IDSHHA_MISSING_RELATE       0x1D847
#define IDSHHA_MISSING_KEYWORD      0x1D848
#define IDSHHA_HTML_NEW_FILE1       0x1D849
#define IDHHA_TXT_SCRIPT_FINISH     0x1D84A
#define IDSHHA_CORRUPTED_HTML       0x1D84B
#define IDSHHA_COMPACTING           0x1d84c
#define IDS_HHA_NO_MAP_SECTION      0x1d84d
#define IDSHHA_TAB_AUTHOR           0x1d84f

// Keep the following together

#define IDS_STYLE_WS_EX_CLIENTEDGE      0x1D900
#define IDS_STYLE_WS_EX_WINDOWEDGE      0x1D901
#define IDS_STYLE_WS_EX_RTLREADING      0x1D902
#define IDS_STYLE_WS_EX_LEFTSCROLLBAR   0x1D903
#define IDS_STYLE_WS_BORDER             0x1D904
#define IDS_STYLE_WS_DLGFRAME           0x1D905
#define IDS_STYLE_TVS_HASBUTTONS        0x1D906
#define IDS_STYLE_TVS_HASLINES          0x1D907
#define IDS_STYLE_TVS_LINESATROOT       0x1D908
#define IDS_STYLE_TVS_SHOWSELALWAYS     0x1D909
#define IDS_STYLE_TVS_TRACKSELECT       0x1D90A
#define IDS_STYLE_TVS_SINGLEEXPAND      0x1D90B
#define IDS_STYLE_TVS_FULLROWSELECT     0x1D90C

#define FIRST_ACTION 0x1D950

#define ID_ACTION_ALINK             0x1D950
#define ID_ACTION_CLOSE             0x1D951
#define ID_ACTION_VERSION           0x1D952
#define ID_ACTION_INDEX             0x1D953
#define ID_ACTION_KLINK             0x1D954
#define ID_ACTION_RELATED_TOPICS    0x1D955
#define ID_ACTION_SHORTCUT          0x1D956
#define ID_ACTION_SPLASH            0x1D957
#define ID_ACTION_TOC               0x1D958
#define ID_ACTION_TCARD             0x1D959
#define ID_ACTION_WINHELP           0x1D95A

#define LAST_ACTION ID_ACTION_WINHELP


#define ID_ACTION_MACRO_ABOUT       0x1D963
#define ID_ACTION_WINHELP_POPUP     0x1D964
#define ID_ACTION_TEXT_POPUP        0x1D965
#define ID_ACTION_MACRO_SHORTCUT    0x1D966

#define FIRST_SCRIPT 0x1DA00

#define IDHHA_SCRIPT_CLICK          0x1DA00
#define IDHHA_SCRIPT_TCARD          0x1DA01
#define IDHHA_SCRIPT_TEXT_POPUP     0x1DA02

#define LAST_SCRIPT IDHHA_SCRIPT_TEXT_POPUP

#define IDHHAD_SCRIPT_CLICK          0x1DB00
#define IDHHAD_SCRIPT_TCARD          0x1DB01
#define IDHHAD_SCRIPT_TEXT_POPUP     0x1DB02
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\header.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#ifndef __HEADER_H__
#define __HEADER_H__

#ifndef STDCALL
#define STDCALL __stdcall
#endif

#ifndef INLINE
#define INLINE __inline         // Remove for profiling
#endif

#define  MAX_TOPIC_NAME 256
#define  MAX_STRING_RESOURCE_LEN 256
#define  STRING_SEP_CHAR    '|'
const int MAX_FLAGS = 3;

const char CH_MACRO = '!';  // means a macro in a .hhc file

typedef unsigned long HASH;

#define _WINUSERP_  // so winuserp.h doesn't get pulled (which causes fatal errors)

//////////////////////////////////// Includes ///////////////////////////////

// Don't mess with the order header files are included
#include <windows.h>
#include <winnls.h>
#include <ole2.h>
#include <stddef.h>
#include <malloc.h>
#include <crtdbg.h>

#include "IPServer.h"

#define NO_SHLWAPI_PATH
#define NO_SHLWAPI_REG
#define NO_SHLWAPI_STREAM
#define NO_SHLWAPI_GDI
#include <shlwapi.h>


//
// W2K contants which aren't in our headers.
//
#ifndef WM_CHANGEUISTATE
//--- New messages in NT5 only.
#define WM_CHANGEUISTATE 0x0127
#define WM_UPDATEUISTATE 0x0128
#define WM_QUERYUISTATE  0x0129
//--- LOWORD(wParam) values in WM_*UISTATE.
#define UIS_SET         1
#define UIS_CLEAR       2
#define UIS_INITIALIZE  3
//--- HIWORD(wParam) values in WM_*UISTATE
#define UISF_HIDEFOCUS  0x1
#define UISF_HIDEACCEL  0x2
#endif

// Debugging Support Class --- ClassObjectCount
#include "objcnt.h"

#undef StrChr
#undef StrRChr
#include "unicode.h"
#include "funcs.h"
#include "cstr.h"
#include "shared.h"
#include "lcmem.h"
#include "ctable.h"
#include "wmp.h"

// Language Information
#include "language.h"

// Get the ATL includes.
#include "atlinc.h"

#ifdef HHCTRL
// Include the definitions for HTML Help API
#include "htmlhelp.h"

// Include out global resource cache
#include "rescache.h"
#endif

/////////////////////////////////////////////////////////////////////////////

// map as many CRT functions to Win32, ShlWAPI, or private functions as we can
//

// UNICODE
#define wcscat    StrCatW
#define wcscpy    StrCpyW
#define _wcscpy   StrCpyW
#define wcsncpy   StrCpyNW
#define _wcsncpy  StrCpyNW
#define wcscmp    StrCmpW
#define _wcscmp   StrCmpW
#define wcsicmp   StrCmpIW
#define _wcsicmp  StrCmpIW
#define wcsnicmp  StrCmpNIW
#define wcslen    lstrlenW

// intrinsics -- no need to map these
// #define strcat    lstrcatA
// #define strlen    lstrlenA
// #define strcpy    lstrcpyA
// #define strcmp    lstrcmpA

// ANSI
#define StrChr    StrChrA
#define strchr    StrChrA
#define strncpy   lstrcpynA
#define stricmp   lstrcmpiA
#define _stricmp  lstrcmpiA
#define strcmpi   lstrcmpiA
#define _strcmpi  lstrcmpiA
#define strncmp   StrCmpNA
#define strnicmp  StrCmpNIA
#define _strnicmp StrCmpNIA
#define strstr    StrStrA
#define stristr   StrStrIA

// #define strncat   StrCatN --> not supported in IE3 shlwapi

// MISC
#define splitpath  SplitPath
#define _splitpath SplitPath
#define atoi       Atoi
#define isspace    IsSpace
#define strpbrk    StrPBrk
#define qsort      QSort
#define tolower    ToLower
#define strrchr    StrRChr

#ifdef _DEBUG
#define STATIC      // because icecap doesn't believe in static functions
#else
#define STATIC static
#endif

// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL

const int GUID_STR_LEN = 40;

typedef enum {
    ACT_NOTHING,
    ACT_ABOUT_BOX,
    ACT_CONTENTS,
    ACT_INDEX,
    ACT_RELATED_TOPICS,
    ACT_TEXT_POPUP,
    ACT_WINHELP,
    ACT_HHCTRL_VERSION,
    ACT_SPLASH,
    ACT_SHORTCUT,
    ACT_CLOSE,
    ACT_MINIMIZE,
    ACT_MAXIMIZE,
    ACT_KEYWORD_SEARCH,
    ACT_TCARD,      // data stored in m_pszActionData, not m_ptblItems
    ACT_HHWIN_PRINT,    // tell hhwin to print the current frameset
    ACT_KLINK,
    ACT_ALINK,
    ACT_SAMPLE,
} CTRL_ACTION;

// The type of image to display for the control

typedef enum {
    IMG_BITMAP,
    IMG_CHILD_WINDOW,
    IMG_TEXT,
    IMG_RELATED,    // Related topics
    IMG_BUTTON,
} IMAGE_TYPE;

enum THRD_COMMAND {
    THRD_ANY,
    THRD_TERMINATE,
};

typedef enum {
    SK_SET,
    SK_CUR,
    SK_END
} SEEK_TYPE;

#define CH_OPEN_PAREN     '('
#define CH_CLOSE_PAREN    ')'
#define CH_COLON          ':'
#define CH_SEMICOLON      ';'
#define CH_START_QUOTE     '`'
#define CH_END_QUOTE      '\''
#define CH_QUOTE          '"'
#define CH_BACKSLASH      '\\'
#define CH_FORWARDSLASH   '/'
#define CH_EQUAL          '='
#define CH_SPACE          ' '
#define CH_COMMA          ','
#define CH_LEFT_BRACKET   '['
#define CH_RIGHT_BRACKET  ']'
#define CH_TAB            '\t'

// Same errors as used by hha.dll

typedef enum {              // File System errors
    FSERR_NONE = 0,         // no error
    FSERR_CANCELLED,        // user cancelled
    FSERR_CANT_OPEN,        // can't open file
    FSERR_CANT_READ,        // error while reading the file
    FSERR_CANT_WRITE,       // error while writing to the file
    FSERR_INVALID_FORMAT,   // invalid file format
    FSERR_TRUNCATED,        // file is truncated
    FSERR_INSF_MEMORY,      // insuficient global memory
    FSERR_INTERNAL,         // internal error
    FSERR_24BIT_NOT_SUPPORTED, // not supported by this file format
    FSERR_REALLY_A_BMP,     // This is really a BMP file.
    FSERR_MONO_NOT_SUPPORTED,
    FSERR_256_NOT_SUPPORTED,
    FSERR_NOROOM_FOR_TMP,   // insufficient room in windows directory
    FSERR_NON_FLASH_EPS,    // not a Flash EPS file
    FSERR_GETDIBITS_FAILURE,
    FSERR_ACCESS_DENIED,
    FSERR_INS_FILE_HANDLES,
    FSERR_INVALID_PATH,
    FSERR_FILE_NOT_FOUND,
    FSERR_DISK_FULL,
    FSERR_UNSUPPORTED_FORMAT,
    FSERR_UNSUPPORTED_GIF_FORMAT,
    FSERR_INVALID_GIF_COLOR,
    FSERR_UNSUPPORTED_GIF_EXTENSION,
    FSERR_CORRUPTED_FILE,
    FSERR_TRY_FILTER,   // native doesn't support, so use filter
    FSERR_UNSUPPORTED_JPEG,
    FSERR_UNSUPPORTED_OUTPUT_FORMAT,

} FSERR;

#define MAX_SS_NAME_LEN             51           // 50 char limit + NULL

#define TAMSG_IE_ACCEL         1
#define TAMSG_TAKE_FOCUS       2
#define TAMSG_NOT_IE_ACCEL     3

#define ANY_PROCESS_ID 0

#define WS_EX_LAYOUT_RTL 0x00400000L // Right to left mirroring (Win98 and NT5 only)

extern DWORD g_RTL_Style; // additional windows style for RTL layout (all platforms)
extern DWORD g_RTL_Mirror_Style; // additional windows style for RTL mirroring
extern BOOL  g_fThreadRunning;  // TRUE if our thread is doing something
extern HANDLE  g_hsemNavigate;
extern const CLSID *g_pLibid;
extern BOOL     g_fMachineHasLicense;
extern BOOL     g_fCheckedForLicense;
extern BOOL     g_fServerHasTypeLibrary;
extern HWND     g_hwndParking;
extern BOOL g_fDualCPU;   // -1 until initialized, then TRUE or FALSE
extern CRITICAL_SECTION g_CriticalSection;
extern HINSTANCE    g_hinstOcx;
extern HBRUSH   g_hbrBackGround;    // background brush
extern HBITMAP  g_hbmpSplash;
extern HPALETTE g_hpalSplash;
extern HWND     g_hwndSplash;
extern int      g_cWindowSlots; // current number of allocated window slots
extern int      g_curHmData;
extern int      g_cHmSlots;
extern UINT     g_fuBiDiMessageBox;
extern BOOL     g_fCoInitialized;   // means we called CoInitialize()

extern VARIANT_BOOL       g_fHaveLocale;
extern LCID               g_lcidLocale;
extern BOOL g_fSysWin95;        // we're under Win95 system, not just NT SUR
extern BOOL g_fSysWinNT;        // we're under some form of Windows NT
extern BOOL g_fSysWin95Shell;  // we're under Win95 or Windows NT SUR { > 3/51)
extern BOOL g_bWinNT5;          // we're under NT5
extern BOOL g_bWin98;          // we're under Win98
extern BOOL g_fBiDi;            // TRUE if this is a BiDi system
extern BOOL g_bBiDiUi;          // TRUE when we have a localized Hebrew or Arabic UI
extern BOOL g_bArabicUi;        // TRUE when we have a Arabic UI
extern BOOL g_fRegisteredSpash; // TRUE if Splash window has been registered
extern BOOL g_fNonFirstKey; // accept keyboard entry for non-first level index keys
extern BOOL g_bMsItsMonikerSupport;  // "ms-its:" moniker supported starting with IE 4
extern BOOL g_fIE3;               // affects which features we can support

extern BOOL     g_fDBCSSystem;
extern LCID     g_lcidSystem;       // Only used for input to CompareString. used in util.cpp stristr()
extern LANGID   g_langSystem;       // used only by fts.cpp, ipserver.cpp and rescache.cpp

extern const char g_szLibName[];
extern const CLSID *g_pLibid;

extern CTable* g_ptblItems;

extern const char g_szReflectClassName[]; // "CtlFrameWork_ReflectWindow";
extern UINT MSG_MOUSEWHEEL;

extern const char txtInclude[];    // ":include";
extern const char txtFileHeader[]; // "file:";
extern const char txtHttpHeader[]; // "http:";
extern const char txtFtpHeader[]; // "ftp:";
extern const char txtZeroLength[]; // "";
extern const char txtHtmlHelpWindowClass[];
extern const char txtHtmlHelpChildWindowClass[];
extern const char txtSizeBarChildWindowClass[];
extern const char txtSysRoot[];
extern const char txtMkStore[]; // "mk:@MSITStore:";
extern const char txtItsMoniker[]; // "its:";
extern const char txtMsItsMoniker[]; // "ms-its:";
extern const char txtHlpDir[];  // "Help";
extern const char txtOpenCmd[]; // "htmlfile\\shell\\open\\command";
extern const char txtDoubleColonSep[]; // "::";
extern const char txtSepBack[];      // "::/";
extern const char txtDefExtension[]; // ".chm";
extern const char txtCollectionExtension[]; // ".col";
extern const char txtChmColon[]; // ".chm::";
extern const char txtDefFile[];      // "::/default.htm";

// Internal window types
extern const char txtDefWindow[];  // Per-chm version.
extern const char txtGlobalDefWindow[] ; // Global version.

// Special windows --- The filename parameter is ignored for these windows.
extern const char txtPrintWindow[] ;

#include "Util.H"

// inline function only support for hour glass

struct CHourGlass
{
    CHourGlass()
        { hcurRestore = SetCursor(LoadCursor(NULL,
            (LPCTSTR) IDC_WAIT)); }
    ~CHourGlass()
        { SetCursor(hcurRestore); }

    void Restore()
        { SetCursor(hcurRestore); }

    HCURSOR hcurRestore;
};

//=--------------------------------------------------------------------------=
// Global object information table
//=--------------------------------------------------------------------------=
// for each object in your application, you have an entry in this table.  they
// do not necessarily have to be CoCreatable, but if they are used, then they
// should reside here.  use the macros to fill in this table.
//
typedef struct tagOBJECTINFO {

    unsigned short usType;
    void          *pInfo;

} OBJECTINFO;

extern OBJECTINFO g_ObjectInfo[];

class CBusy
{
public:

  CBusy() { m_iBusyCount = 0; }

  BOOL Set( BOOL bBusy )
  {
    if( bBusy )
      m_iBusyCount++;
    else
      m_iBusyCount--;
    if( m_iBusyCount < 0 )
      m_iBusyCount = 0;
    return IsBusy();
  }
  inline BOOL IsBusy() { return (BOOL) m_iBusyCount; }

private:

  BOOL m_iBusyCount;
};

extern CBusy g_Busy;


#endif // __HEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hh.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

// This code is called by hh.exe -- we put it here to gain access to
// the ITSS IStorage code that hhctrl already supports.

#include "header.h"
#include "hha_strtable.h"
#include <shellapi.h>
#include "system.h"
#include "htmlhelp.h"
#include "fsclient.h"
#include "strtable.h"
#include "hhshell.h"
#include "contain.h"
#include "secwin.h"
#include "resource.h"

//#define __TEST_HH_SET_GLOBAL_PROPRERTY_API
//#define __TEST_GPROPID_UI_LANGUAGE__
#include "hhpriv.h"

void SetRegKey(LPCTSTR pszKey, LPCTSTR pszValue);
void DeCompile(PCSTR pszFolder, PCSTR pszCompiledFile);
int doInternalWinMain(HINSTANCE hinstApp, PCSTR lpszCmdLine) ;

// Defined in htmlhelp.cpp
bool InitializeSession(UNALIGNED DWORD_PTR* pCookie) ;
bool UninitializeSession(DWORD_PTR Cookie) ;

extern "C" {
    DWORD WINAPI HhWindowThread(LPVOID pParam);
}

void RegisterHH(PCSTR pszHHPath);   // in ipserver.cpp

static const char txtCmdTitle[] = "title";
static const char txtCmd800[] = "800"; // maximum 800 x 600 window

static const char txtCmdBrowser[]  = "browser"; // display in browser
static const char txtCmdRegister[] = "register";
static const char txtCmdUnRegister[] = "unregister";
static const char txtCmdDecompile[] = "decompile";
static const char txtApiWindow[] = "api";
static const char txtMapID[] = "mapid";
static const char txtGlobalSubset[] = "subset" ;

extern BOOL    g_fStandAlone;  // no need for threading in standalone version

/*
    Command line switches

        -register
            registers hh, hhctrl, itss, and itircl
        -unregister
            unregisters hh, hhctrl, itss, and itircl
        -decompile folder chm
            decompiles the CHM file into specified folder
        -800
            Creates an 800 x 600 window, without covering the tray. Ignored
            if there is a default window type
        -title text
            Specifies the title to use for the 800 x 600 window
        -mapid id
            Equivalent to callint HH_HELP_CONTEXT with map id

*/

extern "C"
int doWinMain(HINSTANCE hinstApp, PCSTR lpszCmdLine)
{
    int iReturn = -1 ;
    DWORD_PTR dwCookie = NULL ;
    if (InitializeSession(&dwCookie))
    {
        iReturn = doInternalWinMain(hinstApp, lpszCmdLine) ;

        UninitializeSession(dwCookie) ;
    }
    return iReturn ;
}

int doInternalWinMain(HINSTANCE hinstApp, PCSTR lpszCmdLine)
{
    int  retval = 0;
    BOOL fDisplayInBrowser = FALSE;
    BOOL fTriPane = FALSE;
    BOOL fRegister = FALSE;
    BOOL fDecompile = FALSE;
    CStr cszTitle;
    BOOL f800 = FALSE;
    int  mapID = -1;

#if 0    // test the set toolbar margin API Global property
    HH_GLOBAL_PROPERTY prop ;
    prop.id = HH_GPROPID_TOOLBAR_MARGIN;
    VariantInit(&prop.var);
    prop.var.vt = VT_UI4;
    prop.var.ulVal = MAKELONG(80, 0);

    HtmlHelp(NULL, NULL, HH_SET_GLOBAL_PROPERTY, (DWORD)&prop) ;
    VariantClear(&prop.var);
#endif


    PCSTR pszCommand = FirstNonSpace(lpszCmdLine);
    if (IsEmptyString(pszCommand)) {
        doAuthorMsg(IDSHHA_NO_COMMAND_LINE, "");
        return -1;
    }

#ifdef __TEST_HH_SET_GLOBAL_PROPRERTY_API
    HH_GLOBAL_PROPERTY prop ;
    prop.id = HH_GPROPID_SINGLETHREAD ;
    VariantInit(&prop.var) ;
    prop.var.vt = VT_BOOL ;
    prop.var.boolVal = VARIANT_TRUE ;

    HtmlHelp(NULL, NULL, HH_SET_GLOBAL_PROPERTY, (DWORD)&prop) ; // Call hhshell.cpp version.
    VariantClear(&prop.var);
#endif
    while (*pszCommand == '-') {
        pszCommand = FirstNonSpace(pszCommand + 1);
        if (IsSamePrefix(pszCommand, txtCmdBrowser, sizeof(txtCmdBrowser) - 1)) {
            pszCommand += (sizeof(txtCmdBrowser) - 1);
            fDisplayInBrowser = TRUE;
        }
        else if (IsSamePrefix(pszCommand, txtCmd800, sizeof(txtCmd800) - 1)) {
            pszCommand += (sizeof(txtCmd800) - 1);
            f800 = TRUE;
        }
        else if (IsSamePrefix(pszCommand, txtCmdRegister, sizeof(txtCmdRegister) - 1)) {
            pszCommand += (sizeof(txtCmdBrowser) - 1);
            fRegister = TRUE;
        }
        else if (IsSamePrefix(pszCommand, txtCmdTitle, sizeof(txtCmdTitle) - 1)) {
            pszCommand += (sizeof(txtCmdTitle) - 1);
            pszCommand = cszTitle.GetArg(pszCommand);
        }
        else if (IsSamePrefix(pszCommand, txtCmdDecompile, sizeof(txtCmdDecompile) - 1)) {
            pszCommand += (sizeof(txtCmdDecompile) - 1);
            pszCommand = cszTitle.GetArg(pszCommand);
            fDecompile = TRUE;
        }
        else if (hinstApp != _Module.GetModuleInstance() && IsSamePrefix(pszCommand, txtApiWindow, sizeof(txtApiWindow) - 1)) {
            HhWindowThread(NULL);
            return 0;
        }
        else if (IsSamePrefix(pszCommand, txtMapID, sizeof(txtMapID) - 1)) {
            pszCommand += (sizeof(txtMapID) - 1);
            pszCommand = FirstNonSpace(pszCommand);
            mapID = Atoi(pszCommand);
        }
        else if (IsSamePrefix(pszCommand, txtGlobalSubset, sizeof(txtGlobalSubset)-1))
        {
            // Change the subset. This is for test purposes ONLY!
            pszCommand += (sizeof(txtGlobalSubset) - 1);
            char *pstart = FirstNonSpace(pszCommand);
            char *pend = strchr(pstart, ' ') ;
            char save = *pend;
            *pend = '\0' ;
            CWStr subset(pstart) ;
            *pend = save ;
            pszCommand = pend ;

            HH_GLOBAL_PROPERTY prop ;
            prop.id = HH_GPROPID_CURRENT_SUBSET; 
            VariantInit(&prop.var) ;
            prop.var.vt = VT_BSTR;
            prop.var.bstrVal = ::SysAllocString(subset);

            HtmlHelp(NULL, NULL, HH_SET_GLOBAL_PROPERTY, (DWORD_PTR)&prop) ; // Call hhshell.cpp version.
            VariantClear(&prop.var);
        }

        // step past any text

        while (*pszCommand && !IsSpace(*pszCommand))
            pszCommand = CharNext(pszCommand);

        // step past any whitespace

        while (*pszCommand && IsSpace(*pszCommand))
            pszCommand++;
    }

    char szFullPath[MAX_PATH + 10];

    if (fRegister) {
        ::GetModuleFileName(hinstApp, szFullPath, MAX_PATH);
        RegisterHH(szFullPath);
        return 0;
    }

    if (IsEmptyString(pszCommand)) {
        AuthorMsg(IDSHHA_NO_COMMAND_LINE, "", NULL, NULL);
        retval = -1;
    }

    if (fDecompile) {
        // BUGBUG: nag author if we don't have both parameters

        if (!cszTitle.IsEmpty() && !IsEmptyString(pszCommand))
            DeCompile(cszTitle, pszCommand);
        return 0;
    }

    PSTR pszFileName = NULL;
    BOOL fSystemFile = FALSE;

    /*
     * We need to deal with all the ways we can be called:
     *      hh full path
     *      hh file.chm
     *      hh file.chm::/foo.htm
     *      hh mk:@MSItstore:file.chm::/foo.htm
     *      hh its:file.chm::/foo.htm
     *      hh its:c:\foo\file.chm
     *  etc.
     */

    CStr cszFile;
    if (*pszCommand == CH_QUOTE) {
        pszCommand = lcStrDup(pszCommand + 1);
        PSTR pszEndQuote = StrChr(pszCommand, CH_QUOTE);
        if (pszEndQuote)
            *pszEndQuote = '\0';
    }

    /*
     * First see if it is a compiled HTML file, and if so, call again to
     * get it's location.
     */

    BOOL bCollection = IsCollectionFile(pszCommand);

    if (bCollection || IsCompiledHtmlFile(pszCommand, NULL))
    {
        if (!bCollection && !IsCompiledHtmlFile(pszCommand, &cszFile))
            return -1;
        if (bCollection)
            cszFile = pszCommand;

        CStr cszCompressed;
        PCSTR pszFilePortion;
        CStr cszFilePortion;
        if ( (pszFilePortion = GetCompiledName(cszFile, &cszCompressed)) )
            cszFilePortion = pszFilePortion;

        CHmData*  pchm =  FindCurFileData(cszCompressed);
        if (pchm == NULL)
        {
            MsgBox(IDS_FILE_ERROR, cszFile, MB_OK);
            return -1;
        }
        if (bCollection && pchm)
            cszCompressed = pchm->GetCompiledFile();

        CStr cszWindow(g_phmData[g_curHmData]->GetDefaultWindow() ?
            g_phmData[g_curHmData]->GetDefaultWindow() : txtDefWindow);
        HH_WINTYPE* phhWinType;


#if 0
//  For testing The INFOTYPE API
        {
HH_ENUM_IT enum_IT;
PHH_ENUM_IT penum_IT = &enum_IT;
HH_ENUM_CAT enum_cat;
PHH_ENUM_CAT penum_cat=&enum_cat;
HH_SET_INFOTYPE set_IT;
PHH_SET_INFOTYPE pset_IT=&set_IT;
HWND ret;

        enum_IT.cbStruct = sizeof(HH_ENUM_IT);
        CWStr cszW("c:\\wintools\\docs\\htmlhelp\\htmlhelp.chm");
        do{
            ret = xHtmlHelpW(NULL, cszW, HH_ENUM_INFO_TYPE, (DWORD)&penum_IT);
        }while(ret != (HWND)-1 );
        set_IT.cbStruct = sizeof(HH_SET_INFOTYPE);
        set_IT.pszCatName = "";
        CWStr cszIT = "Web";
        set_IT.pszInfoTypeName = (PCSTR)cszIT.pw;//"Web";
        ret = xHtmlHelpW(NULL, cszW, HH_SET_INFO_TYPE, (DWORD)&pset_IT);
        enum_cat.cbStruct = sizeof(HH_ENUM_CAT);
        do {
            ret = xHtmlHelpW(NULL, cszW, HH_ENUM_CATEGORY, (DWORD)&penum_cat);
        }while ( ret != (HWND)-1 );
        enum_IT.pszCatName = "cat 1";
        do {
            ret = xHtmlHelpW(NULL, cszW, HH_ENUM_CATEGORY_IT, (DWORD)&penum_IT);
        } while (ret != (HWND)-1);
        ret = xHtmlHelpW(NULL, cszW, HH_SET_EXCLUSIVE_FILTER, NULL);
        ret = xHtmlHelpW(NULL, cszW, HH_RESET_IT_FILTER, NULL);
        ret = xHtmlHelpW(NULL, cszW, HH_SET_INCLUSIVE_FILTER, NULL);
        }
//  End INFOTYPE API TEST
#endif


        /*
         * We need to inlcude the name of the .CHM file with the window
         * type name in order to know which .CHM file to read/create the
         * window type from.
         */

        if (!(*cszWindow.psz == '>'))
            cszCompressed += ">";
        cszCompressed += cszWindow.psz;

        if (xHtmlHelpA(NULL, cszCompressed, HH_GET_WIN_TYPE, (DWORD_PTR) &phhWinType) == (HWND) -1) 
        {
            CreateDefaultWindowType(pchm->GetCompiledFile(), cszWindow);
            xHtmlHelpA(NULL, cszCompressed, HH_GET_WIN_TYPE, (DWORD_PTR) &phhWinType);
        }

        if (hinstApp != _Module.GetModuleInstance()) {
            phhWinType->fsWinProperties |= HHWIN_PROP_POST_QUIT;
            phhWinType->fsValidMembers |= HHWIN_PARAM_PROPERTIES;
        }

        if (cszFilePortion.psz) {
            PSTR pszWinPos = StrChr(cszCompressed.psz, '>');
            if (pszWinPos)
                *pszWinPos = '\0';
            cszCompressed += txtSepBack;
            cszCompressed += (*cszFilePortion.psz == '/' ?
                cszFilePortion.psz + 1: cszFilePortion.psz);
            if (!(*cszWindow.psz == '>'))
                cszCompressed += ">";
            cszCompressed += cszWindow.psz;
        }
        else if (mapID == -1 && !phhWinType->pszFile && g_phmData[g_curHmData]->GetDefaultHtml()) {
            PSTR pszWinPos = StrChr(cszCompressed.psz, '>');
            if (pszWinPos)
                *pszWinPos = '\0';
            if (IsCompiledHtmlFile(g_phmData[g_curHmData]->GetDefaultHtml())) {
                cszCompressed = g_phmData[g_curHmData]->GetDefaultHtml();
            }
            else {
                cszCompressed += txtSepBack;
                cszCompressed += *g_phmData[g_curHmData]->GetDefaultHtml() == '/' ?
                    g_phmData[g_curHmData]->GetDefaultHtml() + 1 :
                    g_phmData[g_curHmData]->GetDefaultHtml();
            }
            if (!(*cszWindow.psz == '>'))
                cszCompressed += ">";
            cszCompressed += cszWindow.psz;
        }

        // BUGBUG This is probably not the correct place for this code but it will do until
        // Ralph can complete the code necessary to get hhctrl onto it's own message loop.
        //
        HWND hwnd;
        if (mapID != -1)
            hwnd = xHtmlHelpA(NULL, cszCompressed, HH_HELP_CONTEXT, mapID);
        else
            hwnd = OnDisplayTopic(NULL, cszCompressed, 0);
        AWMessagePump(hwnd);
        return retval;
    }
    /*
     * Try to call the browser with "foo.htm" and it will think you meant
     * "http:foo.htm", so we need to attempt to convert the file to a full
     * path.
     */

    else if (!stristr(pszCommand, txtHttpHeader) && !stristr(pszCommand, txtFtpHeader) &&
            *pszCommand != '\\' && (*pszCommand == '.' || pszCommand[1] != ':'))
    {
        if (GetFullPathName(pszCommand, sizeof(szFullPath), szFullPath, &pszFileName) != 0)
        {
            pszCommand = lcStrDup(szFullPath);
        }
    }

    // REVIEW: If we reach here, we will NOT have a COL or CHM.
    if (!fDisplayInBrowser)
    {
        HH_WINTYPE hhWinType;
        ZERO_STRUCTURE(hhWinType);
        hhWinType.cbStruct = sizeof(HH_WINTYPE);
        hhWinType.pszType = txtGlobalDefWindow;
        hhWinType.fNotExpanded = TRUE;
        hhWinType.fsWinProperties =
            (HHWIN_PROP_POST_QUIT | HHWIN_PROP_TRI_PANE |
             HHWIN_PROP_CHANGE_TITLE
#ifdef DEBUG
// REVIEW: this should only be added if FTI is enabled
                | HHWIN_PROP_TAB_SEARCH
#endif
                    );
        hhWinType.fsValidMembers =
            (HHWIN_PARAM_PROPERTIES | HHWIN_PARAM_EXPANSION |
                HHWIN_PARAM_TB_FLAGS);
        hhWinType.fsToolBarFlags =
            (HHWIN_BUTTON_BACK | HHWIN_BUTTON_STOP | HHWIN_BUTTON_REFRESH |
                HHWIN_BUTTON_PRINT | HHWIN_BUTTON_OPTIONS);

        if (f800) {
            hhWinType.rcWindowPos.left = 0;
            hhWinType.rcWindowPos.right = 800;
            hhWinType.rcWindowPos.top = 0;
            hhWinType.rcWindowPos.bottom = 600;
            hhWinType.pszCaption = (cszTitle.IsEmpty() ? "" : cszTitle.psz);
            hhWinType.fsWinProperties = HHWIN_PROP_POST_QUIT;
            hhWinType.fsValidMembers =
                HHWIN_PARAM_PROPERTIES | HHWIN_PARAM_RECT |
                HHWIN_PARAM_EXPANSION;
            hhWinType.fNotExpanded = TRUE;
            fTriPane = FALSE;
        }

#if 0 // 28 Apr 98 [dalero] dead code if'd out.
        // REVIEW: fTriPane is ALWAYS false.
        if (fTriPane) {
            // BUGBUG: this should be pulled from the window definition

            CStr cszCommand(pszCommand);
            PSTR pszSep = strstr(cszCommand, txtDoubleColonSep);
            ASSERT(pszSep);
            pszSep[2] = '\0';
            cszCommand += "/";
            if (g_phmData[g_curHmData]->m_pszDefToc) {
                CStr csz(cszCommand.psz);
                csz += g_phmData[g_curHmData]->m_pszDefToc;
                hhWinType.pszToc = lcStrDup(csz.psz);
            }
            if (g_phmData[g_curHmData]->GetDefaultIndex()) {
                CStr csz(cszCommand.psz);
                csz += g_phmData[g_curHmData]->GetDefaultIndex();
                hhWinType.pszIndex = lcStrDup(csz.psz);
                if (!g_phmData[g_curHmData]->m_pszDefToc) {
                    hhWinType.curNavType = HHWIN_NAVTYPE_INDEX;
                    hhWinType.fsValidMembers |= HHWIN_PARAM_TABPOS;
                }
            }
            if (g_phmData[g_curHmData]->GetDefaultHtml()) {
                CStr csz(cszCommand.psz);
                csz += g_phmData[g_curHmData]->GetDefaultHtml();
                hhWinType.pszHome = lcStrDup(csz.psz);
            }

            hhWinType.fNotExpanded = FALSE;
            hhWinType.fsToolBarFlags |= HHWIN_BUTTON_EXPAND;
            hhWinType.fsValidMembers |= (HHWIN_PARAM_PROPERTIES | HHWIN_PARAM_RECT);
            hhWinType.fsWinProperties |= (HHWIN_PROP_TRI_PANE | HHWIN_PROP_AUTO_SYNC
                | HHWIN_PROP_TAB_SEARCH
                    );
        }
#endif

        if (!hhWinType.pszCaption)
            hhWinType.pszCaption = lcStrDup(GetStringResource(IDS_DEF_WINDOW_CAPTION));

        // This is a HTM file or some other type of file...so we use a global wintype. The wintype will not change.
        xHtmlHelpA(NULL, NULL /*Uses a global wintype*/, HH_SET_WIN_TYPE, (DWORD_PTR) &hhWinType);
        CStr csz(pszCommand);
        csz += txtGlobalDefWindow;

        HWND hwnd = OnDisplayTopic(NULL, csz, 0);
		AWMessagePump(hwnd);
    }
    else {  // display in default browser
        char szValue[MAX_PATH];
        LONG cbValue = sizeof(szValue);
        if (RegQueryValue(HKEY_CLASSES_ROOT, txtOpenCmd, szValue,
                &cbValue) == ERROR_SUCCESS && szValue[0] == '\042') {
#if 0
            CStr csz(szValue);
            csz += " ";
            csz += pszCommand;
            WinExec(csz, SW_SHOW);
#else
            PSTR psz = StrChr(szValue + 1, '\042');
            if (psz) {
                *psz = '\0';
                CStr csz(FirstNonSpace(psz + 1));
                csz += " ";
                csz += pszCommand;
                ShellExecute(NULL, NULL, szValue + 1, csz, NULL, SW_SHOW);
            }
#endif
        }
    }

    return retval;
}

void DeCompile(PCSTR pszFolder, PCSTR pszCompiledFile)
{
    CFSClient fsls;
    if (fsls.Initialize(pszCompiledFile)) {
        fsls.WriteStorageContents(pszFolder, NULL);
    }
}

CBusy g_Busy;


void WINAPI AWMessagePump(HWND hwnd)
{
	if (hwnd)
	{
		MSG msg;
		BOOL fMsg;
		BOOL fUnicodeMsg;
		
		for (;;)
		{
			// Check for messages.
			fMsg = PeekMessageA(&msg, NULL, 0, 0, PM_NOREMOVE);
			// Remove W/A according to the type of window the message is directed to.
			if (fMsg)
			{
				if (msg.hwnd && IsWindowUnicode(msg.hwnd))
				{
					fUnicodeMsg = TRUE;
					fMsg = PeekMessageW(&msg, NULL, 0, 0, PM_REMOVE);
				}
				else
				{
					fUnicodeMsg = FALSE;
					fMsg = PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE);
				}
			}
			if (fMsg)
			{
				// We got a message, lets go process it
				
				if (msg.message == WM_QUIT) {
                                        if( g_Busy.IsBusy() )
                                          continue;
                                        else
                                          break;  // exit current loop.
                                }
				
				if (!hhPreTranslateMessage(&msg))
				{
					TranslateMessage(&msg); // TranslateMessage doesn't have A/W flavors
					if (fUnicodeMsg)
						DispatchMessageW(&msg);
					else
						DispatchMessageA(&msg);
				}
			}
			else
			{
				if (!PeekMessageA(&msg, NULL, 0, 0, PM_NOREMOVE))
				{
					WaitMessage();
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhctrl.cxx ===
//Microsoft Developer Studio generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#define APSTUDIO_HIDDEN_SYMBOLS
#include "windows.h"
#undef APSTUDIO_HIDDEN_SYMBOLS
#include "dwinvers.h"
#include "winver.h"
#include "commctrl.h"
#include "htmlhelp.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (U.S.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
#endif //_WIN32

/////////////////////////////////////////////////////////////////////////////
//
// Bitmap
//

SHORTCUT                BITMAP  DISCARDABLE     "res\\shortcut.bmp"
RESID_TOOLBOX_BITMAP    BITMAP  DISCARDABLE     "res\\hhctrl.bmp"
IDBMP_CNT_IMAGE_LIST    BITMAP  DISCARDABLE     "res\\cntimage.bmp"
IDBMP_INFOTYPE_WIZARD   BITMAP  DISCARDABLE     "res\\infowiz.bmp"
IDBMP_CHECK             BITMAP  DISCARDABLE     "res\\check.bmp"
IDBMP_TOOLBAR           BITMAP  DISCARDABLE     "res\\toolbar.bmp"

/////////////////////////////////////////////////////////////////////////////
//
// Cursor
//

IDCUR_HAND              CURSOR  DISCARDABLE     "res\\BRHAND.CUR"

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDICO_HHCTRL            ICON    DISCARDABLE     "res\\hhctrl.ico"
IDICO_HTMLHELP          ICON    DISCARDABLE     "res\\htmlhelp.ico"

/////////////////////////////////////////////////////////////////////////////
//
// TYPELIB
//

1                       TYPELIB MOVEABLE PURE   "hhctrl.TLB"

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDDLG_ABOUTBOX DIALOG DISCARDABLE  0, 0, 186, 71
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Dialog"
FONT 8, "MS Shell Dlg"
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,70,53,50,14
    LTEXT           "1",IDC_LINE1,5,7,177,8
    LTEXT           "1",IDC_LINE2,5,18,177,8
    LTEXT           "1",IDC_LINE3,5,29,177,8
END

IDDLG_RELATED_TOPICS DIALOG DISCARDABLE  16, 64, 192, 131
STYLE DS_MODALFRAME | DS_3DLOOK | WS_POPUP | WS_VISIBLE | WS_CAPTION | 
    WS_SYSMENU
CAPTION "Topics Found"
FONT 8, "MS Shell Dlg"
BEGIN
    LTEXT           "&Click a topic, then click Display.",IDC_DUP_TEXT,7,7,
                    159,10
    LISTBOX         IDC_TOPIC_LIST,7,20,178,83,LBS_SORT | 
                    LBS_NOINTEGRALHEIGHT | WS_VSCROLL | WS_GROUP | 
                    WS_TABSTOP
    DEFPUSHBUTTON   "&Display",IDOK,81,110,50,14,WS_GROUP
    PUSHBUTTON      "Cancel",IDCANCEL,135,110,50,14,WS_GROUP
END

IDPAGE_CONTENTS DIALOG DISCARDABLE  16, 31, 260, 188
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Contents"
FONT 8, "MS Shell Dlg"
BEGIN
    LTEXT           "",IDC_CONTENTS_INSTRUCTIONS,0,0,252,8
    CONTROL         "",ID_TREEVIEW,"SysTreeView32",TVS_DISABLEDRAGDROP | 
                    TVS_TRACKSELECT | WS_TABSTOP,0,16,252,169
END

IDPAGE_TAB_INDEX DIALOG DISCARDABLE  12, 31, 256, 192
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Contents"
FONT 8, "MS Shell Dlg"
BEGIN
    LTEXT           "1  &Type the first few letters of the word you're looking for.",
                    IDC_STATIC,4,0,252,8
    EDITTEXT        IDC_EDIT,12,12,239,12,ES_AUTOHSCROLL | WS_GROUP
    LTEXT           "2  &Click the index entry you want, and then click Display.",
                    IDC_STATIC,3,30,237,8
    LISTBOX         IDC_LIST,12,42,239,144,LBS_OWNERDRAWFIXED | LBS_NODATA | 
                    WS_VSCROLL | WS_TABSTOP
END

IDDLG_CUSTOMIZE_BOTH_INFOTYPES DIALOG DISCARDABLE  0, 0, 319, 236
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Customize Information Types"
FONT 8, "MS Shell Dlg"
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,262,215,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,201,215,50,14
    LTEXT           "Use this dialog to specify what types of information you want to see.",
                    IDTXT_INTRODUCTION,6,7,306,18
    LTEXT           "Pick as &many as you want:",IDTXT_INCLUSIVE,6,29,85,8
    LISTBOX         IDLB_INFO_TYPES,6,41,137,93,LBS_SORT | 
                    LBS_NOINTEGRALHEIGHT | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON      "Select &All",IDBTN_SELECT_ALL,6,140,50,14
    GROUPBOX        "Description",IDC_STATIC,19,164,280,40
    LTEXT           "",IDTXT_DESCRIPTION,22,176,274,24
    LTEXT           "Pick &one from each categroy:",IDC_STATIC,175,29,94,8
    LISTBOX         IDC_LIST2,175,42,137,92,LBS_SORT | LBS_NOINTEGRALHEIGHT | 
                    WS_VSCROLL | WS_TABSTOP
END

IDDLG_CUSTOMIZE_INFOTYPES DIALOG DISCARDABLE  0, 0, 190, 239
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Customize Information Types"
FONT 8, "MS Shell Dlg"
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,133,220,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,76,220,50,14
    LTEXT           "Use this dialog to specify what types of information you want to see.",
                    IDTXT_INTRODUCTION,7,7,168,26
    LTEXT           "&Check each information type you are interested in:",
                    IDTXT_INCLUSIVE,7,38,158,8
    LISTBOX         IDLB_INFO_TYPES,7,48,176,93,LBS_SORT | 
                    LBS_NOINTEGRALHEIGHT | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON      "Select &All",IDBTN_SELECT_ALL,7,146,50,14
    GROUPBOX        "Description",IDC_STATIC,7,170,176,43
    LTEXT           "",IDTXT_DESCRIPTION,13,182,164,25
END

IDDLG_DUP_INFOTYPE DIALOG DISCARDABLE  0, 0, 182, 156
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Choose Type of Information to Display"
FONT 8, "MS Shell Dlg"
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,125,135,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,66,135,50,14
    LTEXT           "Several types of information are available about this subject. Choose the type of information you want to display.",
                    IDC_STATIC,7,7,168,28
    LISTBOX         IDLB_INFO_TYPES,7,35,168,89,LBS_SORT | 
                    LBS_NOINTEGRALHEIGHT | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON      "&Customize...",IDBTN_CUSTOMIZE,7,135,50,14
END

IDWIZ_INFOTYPE_INTRO DIALOG DISCARDABLE  0, 0, 260, 160
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Customize Information"
FONT 8, "MS Shell Dlg"
BEGIN
    CONTROL         505,IDBMP_INFOTYPE_WIZARD,"Static",SS_BITMAP | 
                    SS_CENTERIMAGE | SS_SUNKEN,6,6,80,146
    LTEXT           "You can create a comprehensive information system that displays all the subjects that are available. Or you can customize it so that you see only the subjects that you're interested in.",
                    IDC_STATIC,96,6,158,35
    LTEXT           "How much information do you want to display?",
                    IDC_STATIC,96,44,147,8
    CONTROL         "&Typical",IDRADIO_TYPICAL,"Button",BS_AUTORADIOBUTTON | 
                    WS_TABSTOP,96,65,39,10
    LTEXT           "Provides the most commonly used information",IDC_STATIC,
                    108,77,144,8
    CONTROL         "&All",IDRADIO_ALL,"Button",BS_AUTORADIOBUTTON | 
                    WS_TABSTOP,96,90,23,10
    LTEXT           "Provides all information.",IDC_STATIC,108,101,147,11
    CONTROL         "&Custom",IDRADIO_CUSTOM,"Button",BS_AUTORADIOBUTTON | 
                    WS_TABSTOP,96,114,39,10
    LTEXT           "Enables you to specify which information you want to see.",
                    IDC_STATIC,108,125,146,20
END

IDWIZ_INFOTYPE_FINISH DIALOG DISCARDABLE  0, 0, 260, 160
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Customize Information"
FONT 8, "MS Shell Dlg"
BEGIN
    CONTROL         505,IDBMP_INFOTYPE_WIZARD,"Static",SS_BITMAP | 
                    SS_CENTERIMAGE | SS_SUNKEN,6,6,80,146
    LTEXT           "Only the categories of information that you selected will appear. You can change these categories at any time by clicking the Index or Table of Contents with your right mouse button, and then clicking Customize.",
                    IDC_STATIC,96,9,159,52
END

IDWIZ_INFOTYPE_CUSTOM_INCLUSIVE DIALOG DISCARDABLE  0, 0, 260, 160
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Customize Information"
FONT 8, "MS Shell Dlg"
BEGIN
    CONTROL         505,IDBMP_INFOTYPE_WIZARD,"Static",SS_BITMAP | 
                    SS_CENTERIMAGE | SS_SUNKEN,6,6,80,146
    LTEXT           "&Choose one or more of the following types of information:",
                    IDC_STATIC,96,9,159,19
    LISTBOX         IDLB_INFO_TYPES,96,30,159,56,LBS_OWNERDRAWFIXED | 
                    LBS_HASSTRINGS | LBS_NOINTEGRALHEIGHT | 
                    LBS_WANTKEYBOARDINPUT | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON      "&Select All",IDBTN_SELECT_ALL,96,93,50,14,NOT 
                    WS_VISIBLE
    GROUPBOX        "Description",IDC_STATIC,96,112,159,40
    LTEXT           "",IDTXT_DESCRIPTION,104,123,144,25
END

IDWIZ_INFOTYPE_CUSTOM_EXCLUSIVE DIALOG DISCARDABLE  0, 0, 260, 160
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Customize Information"
FONT 8, "MS Shell Dlg"
BEGIN
    CONTROL         505,IDBMP_INFOTYPE_WIZARD,"Static",SS_BITMAP | 
                    SS_CENTERIMAGE | SS_SUNKEN,6,6,80,146
    LTEXT           "&Choose one of the following:",IDC_STATIC,96,9,90,8
    LISTBOX         IDLB_INFO_TYPES,96,23,159,83,LBS_SORT | 
                    LBS_NOINTEGRALHEIGHT | WS_VSCROLL | WS_TABSTOP
    GROUPBOX        "Description",IDC_STATIC,96,112,159,40
    LTEXT           "",IDTXT_DESCRIPTION,104,123,144,25
END

IDDLG_TOC_PRINT DIALOG DISCARDABLE  0, 0, 229, 116
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Print"
FONT 8, "MS Shell Dlg"
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,115,95,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,172,95,50,14
    LTEXT           "You can print the current topic, all the topics in the current heading, or everything in the table of contents. What would you like to do?",
                    IDC_STATIC,7,7,215,21
    CONTROL         "Print the current &page.",IDRADIO_PRINT_CURRENT,"Button",
                    BS_AUTORADIOBUTTON,7,37,86,10
    CONTROL         "Print everything contained in the current &heading",
                    IDRADIO_PRINT_BOOK,"Button",BS_AUTORADIOBUTTON,7,52,169,
                    10
    CONTROL         "Print everything contained in the &contents",
                    IDRADIO_PRINT_ALL,"Button",BS_AUTORADIOBUTTON,7,67,147,
                    10
END

IDPAGE_SIMPLE_SEARCH DIALOGEX 12, 31, 236, 228
STYLE WS_CHILD | WS_CAPTION | WS_SYSMENU
CAPTION "Simple Search"
FONT 8, "MS Sans Serif"
BEGIN
    LTEXT           "Type in the keyword to find:",ID_STATIC_KEYWORDS,7,7,
                    222,12
    LTEXT           "Select &topic to display:",ID_STATIC_SELECT_TOPIC,7,66,
                    222,12
    PUSHBUTTON      "&List Topics",IDBTN_LIST_TOPICS,179,38,50,24
    PUSHBUTTON      "&Display >>",IDBTN_DISPLAY,179,197,50,24
    CONTROL         "List1",IDSEARCH_LIST,"SysListView32",LVS_REPORT | 
                    LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_OWNERDRAWFIXED | 
                    LVS_NOSORTHEADER | WS_BORDER | WS_TABSTOP,7,78,222,117,
                    WS_EX_CLIENTEDGE
    COMBOBOX        IDSIMPLESEARCH_COMBO,7,23,222,30,CBS_DROPDOWN | CBS_SORT | 
                    WS_VSCROLL | WS_TABSTOP
END

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE DISCARDABLE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE DISCARDABLE 
BEGIN
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include ""windows.h""\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include ""dwinvers.h""\r\n"
    "#include ""winver.h""\r\n"
    "#include ""commctrl.h""\r\n"
	"#include ""htmlhelp.h""\r\n"
    "\0"
END

3 TEXTINCLUDE DISCARDABLE 
BEGIN
    "// non-App Studio edited resources\r\n"
    "\r\n"
    "#include ""strtable.rc2""\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO DISCARDABLE 
BEGIN
    IDDLG_TOC_PRINT, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 222
        TOPMARGIN, 7
        BOTTOMMARGIN, 109
    END

    IDPAGE_SIMPLE_SEARCH, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 229
        TOPMARGIN, 7
        BOTTOMMARGIN, 221
    END
END
#endif    // APSTUDIO_INVOKED

#endif    // English (U.S.) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
// non-App Studio edited resources

#include "strtable.rc2"

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhctrlex.h ===
// Copyright  1995-1997  Microsoft Corporation.  All Rights Reserved.

// This header file can only be used by non-UNICODE programs

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _HHCTRLEX_H_
#define _HHCTRLEX_H_

#ifdef __cplusplus
extern "C" {
#endif	// __cplusplus

PSTR  stristr(PCSTR pszMain, PCSTR pszSub);  // case-insensitive string search
PSTR  FirstNonSpace(PCSTR psz); 			 // return pointer to first non-space character
PSTR  StrChr(PCSTR pszString, char ch); 	 // DBCS-aware character search
PSTR  StrRChr(PCSTR pszString, char ch);	 // DBCS-aware character search
DWORD WinHelpHashFromSz(PCSTR pszKey);		 // converts string into a WinHelp-compatible hash number

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _HHCTRLEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhctrl.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "sitemap.h"

#include "hhctrl.h"
#include "LocalObj.h"
#include "Resource.h"
#include "strtable.h"
#include "hha_strtable.h"
#include "infowiz.h"
#include "web.h"
#include "cprint.h"
#include <exdisp.h>

#undef WINUSERAPI
#define WINUSERAPI
#include "htmlhelp.h"

#include <stdio.h>

#ifndef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif


const DWORD STREAMHDR_MAGIC = 12678L;

// DO NOT LOCALIZE THESE!

static const char txtAboutBox[] = "AboutBox";
static const char txtHhCtrlVersion[] = "HH Version";
static const char txtSplash[] = "Splash";
static const char txtTCard[] = "TCard";
static const char txtWinHelp[] = "WinHelp";
static const char txtRelatedTopics[] = "Related Topics";
static const char txtKeywordSearch[] = "Keyword Search";
static const char txtContents[] = "Contents";
static const char txtHelpContents[] = "HelpContents";
static const char txtShortcut[] = "Shortcut";
static const char txtClose[] = "Close";
static const char txtHHWinPrint[] = "HHWinPrint";
static const char txtMinimize[] = "Minimize";
static const char txtMaximize[] = "Maximize";
static const char txtIndex[] = "Index";
static const char txtItem[] = "Item%u";
static const char txtBitmap[] = "Bitmap:";
static const char txtIcon[] = "Icon:";
static const char txtText[] = "Text:";
static const char txtHPad[] = "HPAD=";
static const char txtVPad[] = "VPAD=";
static const char txtHHWin[] = "hhwin:";
static const char txtFileUrl[] = "file:";
static const char txtActKLink[] = "KLink";
static const char txtActSample[] = "Sample";
static const char txtActALink[] = "ALink";
static const char txtMenu[] = "MENU";
static const char txtPopup[] = "Popup";

static const WCHAR txtwImage[]  = L"Image";
static const WCHAR txtwFrame[]  = L"Frame";
static const WCHAR txtwWindow[] = L"Window";
static const WCHAR txtwFont[]   = L"Font";
static const WCHAR txtwFlags[]  = L"Flags";
static const WCHAR txtwWebMap[] = L"WebMap";
static const WCHAR txtwCommand[] = L"Command";
static const WCHAR txtwButton[] = L"Button";
static const WCHAR txtwText[] = L"Text";
static const WCHAR txtwDefaultTopic[] = L"DefaultTopic";
// shanemc 7883 - Support bgcolor for index
static const WCHAR txtwBgColor[] = L"BgColor";

// utility functions -- move to util.cpp someday

/***************************************************************************

    FUNCTION:   FindMessageParent

    PURPOSE:    Find the parent to send messages to

    PARAMETERS:
        hwndChild

    RETURNS:

    COMMENTS:
        A control may be a child of a Tab Control, in which case, we
        need to send any messages to the Tab Control's parent

    MODIFICATION DATES:
        20-Mar-1997 [ralphw]

***************************************************************************/

HWND FindMessageParent(HWND hwndChild)
{
    HWND hwndParent = GetParent(hwndChild);
    char szClass[50];
    GetClassName(hwndParent, szClass, sizeof(szClass));
    if (IsSamePrefix(szClass, WC_TABCONTROL, -2))
        hwndParent = GetParent(hwndParent);
    return hwndParent;
}

/***************************************************************************

    FUNCTION:   JumpToUrl

    PURPOSE:    Jump to a URL specified in a sitemapentry or SITE_ENTRY_RUL

    PARAMETERS:
        pUnkOuter   -- used for HlinkSimpleNavigateToString
        hwndParent     -- parent for secondary window (if jumped to)
        pSiteMapEntry
        pSiteMap
        pUrl

    RETURNS:    Window handle if a secondary window is created, else NULL

    COMMENTS:
        Special processing for %SYSTEMROOT% anywhere in URL
        Special processing for "hhwin:" and "file:"

    MODIFICATION DATES:
        04-Mar-1997 [ralphw]

***************************************************************************/

HWND JumpToUrl(IUnknown* pUnkOuter, HWND hwndParent, SITEMAP_ENTRY* pSiteMapEntry, CInfoType *pInfoType,
    CSiteMap* pSiteMap, SITE_ENTRY_URL* pUrl, IWebBrowserAppImpl* pWebApp /* = NULL */)
{
    ASSERT(pSiteMapEntry);
    ASSERT(pSiteMap);

    PCSTR pszFrame = pSiteMapEntry->GetFrameIndex() ?
        pSiteMap->GetEntryFrame(pSiteMapEntry) : pSiteMap->GetFrameName();

    PSTR pszInterTopic = NULL;
    PCSTR pszUrl = NULL;
    PCSTR pszSecondaryUrl = NULL;

    if (!pUrl) {
        if (pSiteMapEntry->fShowToEveryOne) {
            pUrl = pSiteMapEntry->pUrls;
        }
        else {  // choose based on Information Type

            // If we get here, then we must match information types

            ASSERT_COMMENT(pSiteMap->m_pInfoTypes,
                "Info-type only URL specified without any user-specified Information Types");

       //     for (UINT j = 0; j < pSiteMap->m_cUrlEntry - (sizeof(URL) * 2); j++) {
            INFOTYPE *pIT = pSiteMap->m_pInfoTypes;
            for (int j=0; j<pSiteMap->InfoTypeSize()/4;j++)
            {
                pUrl = pSiteMap->AreTheseInfoTypesDefined(pSiteMapEntry, *pIT+(INFOTYPE)j, j);
                if (pUrl)
                    break;
            }

            //ASSERT_COMMENT(pUrl, "This entry should not have been displayed, since there is no matching info type.");
            if (!pUrl) {
                AuthorMsg(IDS_HHA_NO_URL, "", hwndParent, NULL);
                return NULL; // BUGBUG: we should notify the user
            }
        }
    }
    ASSERT(pUrl);
    if (pUrl->urlPrimary) {
        pszUrl = pSiteMap->GetUrlString(pUrl->urlPrimary);
        if (pUrl->urlSecondary)
            pszSecondaryUrl = pSiteMap->GetUrlString(pUrl->urlSecondary);
    }
    else if (pSiteMapEntry->pUrls->urlSecondary) {
        pszUrl = pSiteMap->GetUrlString(pUrl->urlSecondary);
    }
    else {  // no primary or secondary URL
        AuthorMsg(IDS_HHA_NO_URL, "", hwndParent, NULL);
        return NULL;
    }

    /*
     * If the primary URL is a compiled HTML file, then first see if the
     * compiled HTML file exists. If not, switch to the alternate URL.
     */

    if (pszSecondaryUrl && IsCompiledHtmlFile(pszUrl, NULL)) {
        CStr cszPath;
        GetCompiledName(pszUrl, &cszPath);
        if (!FindThisFile(NULL, cszPath, &cszPath, FALSE)) {
            pszUrl = pszSecondaryUrl;
            pszSecondaryUrl = NULL;
        }
    }

TrySecondary:

    CStr cszUrl;
    // Parse %SystemRoot%

    PSTR psz = stristr(pszUrl, txtSysRoot);
    if (psz) {
        char szPath[MAX_PATH];
        GetRegWindowsDirectory(szPath);
        strcat(szPath, psz + strlen(txtSysRoot));
        cszUrl = szPath;
        pszUrl = cszUrl.psz;
    }

    PCSTR pszWindowName =
        (pSiteMapEntry->GetWindowIndex() ?
            pSiteMap->GetEntryWindow(pSiteMapEntry) :
            pSiteMap->GetWindowName());

    if (IsNonEmptyString(pszWindowName) && (IsEmptyString(pszFrame) ||
            lstrcmpi(pszWindowName, pszFrame) != 0)) {
        cszUrl = "hhwin:";
        cszUrl += pszWindowName;
        cszUrl += ":";
        cszUrl += pszUrl;
        pszUrl = cszUrl.psz;
    }

    /*
     * If the URL is prefixed with hhwin: then we need to display this
     * topic in a secondary window.
     */

    CStr cszPrefix;

    int cb = CompareSz(pszUrl, txtHHWin);
    if (cb) {
        pszUrl += cb;
        CStr csz(pSiteMap->GetSiteMapFile() ? pSiteMap->GetSiteMapFile() : "");
        CStr cszWindow(pszUrl);
        PSTR pszTmp = StrChr(cszWindow, ':');
        if (!pszTmp) {
            // AuthorMsg(IDSHHA_INVALID_HHWIN, cszWindow);
            return NULL; // REVIEW: should we notify the user?
        }
        *pszTmp = '\0';
        pszUrl = FirstNonSpace(pszTmp + 1);

        /*
         * If we have a relative path specified, then we need to make it
         * relative to the location of our sitemap file. Look for the last
         * backslash or forward slash, and add our URL to the end.
         */

        if (*pszUrl == '.') {
            PSTR pszFilePortion = StrRChr(csz, '\\');
            PSTR pszTmp = StrRChr(pszFilePortion ? pszFilePortion : csz, '/');
            if (pszTmp)
                pszFilePortion = pszTmp;
            if (pszFilePortion) {
                pszFilePortion[1] = '\0';
                csz += pszUrl;
                pszUrl = csz.psz;
            }
        }

        if (!StrChr(pszUrl, ':') && pSiteMap->GetSiteMapFile() &&
                IsCompiledHtmlFile(pSiteMap->GetSiteMapFile(), &cszPrefix)) {
            PSTR pszSep = strstr(cszPrefix, txtDoubleColonSep);
            ASSERT(pszSep);
            if (!pszSep)
                return NULL;    // should never happen, but beats GPF if it does
            strcpy(pszSep + 2, "/");
            while (*pszUrl == '.')
                pszUrl++;
            if (*pszUrl == '/' || *pszUrl == '\\')
                pszUrl++;
            cszPrefix += pszUrl;
        }
        else
            cszPrefix = pszUrl;

        /*
            Workaround for bug #5851
            Once upon a time there was a bug in that window types were not CHM specific.
            HTML Help shipped with this bug. Many people depended on the bug. In 1.1b we
            fixed the bug and broke exisiting content. Bug 5851 is such a case. Before, the fix
            below, the code was working EXACTLY as it should. However, we can't break those who
            have shipped no matter how broken the previous version. So, here we actually add in
            a bug to upbreak the already broken.

            The fix is as follows. If you are jumping to an url and you provide a window type,
            we check to see if there is a collection open which contains that url. If there is,
            we check to see if that window type is defined by the master chm in the collection
            and if it is open. If both of these are true, then we just navigate and don't create
            a new window.

            The result is that included CHMs cannot define windows with the same name as the MASTER CHM.

        */
        // Is this file part of a collection?
        CExCollection* pCollection = GetCurrentCollection(NULL, pszUrl);
        if (pCollection)
        {
            // Is the window we are attempting to open defined by the master CHM?
            CHHWinType* phh = FindWindowType(cszWindow.psz, NULL, pCollection->GetPathName());
            // Does this window actually exist?
            if (phh && IsWindow(phh->hwndHelp))
            {
                // We are going to reuse the exisiting window and just navigate.
                if (pWebApp)
                {
                    pWebApp->Navigate(cszPrefix, NULL, NULL, NULL, NULL);
                    return NULL ;
                }
                else if (IsWindow(hwndParent)) //--- Bug Fix for 7697: If hwndParent is NULL call OnDisplayTopic.
                {
                    doHHWindowJump(cszPrefix, phh->hwndHelp);
                    return NULL ;
                }
                /* fall through */
            }
        }

        // We will use a possiblity new window type, so call OnDisplayTopic.
        cszPrefix += ">";
        cszPrefix += cszWindow.psz;
        return OnDisplayTopic(hwndParent, cszPrefix, 0);
    }

    /*
     * If this is a file: URL, then first find out if the file
     * actually exits. If not, then switch to the remote URL.
     */

    cb = CompareSz(pszUrl, txtFileUrl);
    if (cb) {
        if ((pszInterTopic = StrChr(pszUrl, '#')))
            *pszInterTopic = '\0';

        if (GetFileAttributes(pszUrl + cb) == HFILE_ERROR) {
            if (pszSecondaryUrl) {
                pszUrl = pszSecondaryUrl;
                pszSecondaryUrl = NULL;
                goto TrySecondary;
            }
            AuthorMsg(IDS_HHA_NO_URL, "", hwndParent, NULL);
            return NULL;
        }
    }

    if (!pszInterTopic) {
        if ((pszInterTopic = StrChr(pszUrl, '#')))
            *pszInterTopic = '\0';
    }


    // Bug 7153, when this pointer gets moved pszInterTopic is pointing into the wrong string
    // and therefore the fragment gets lost for this jump.  Doing a sugical fix to reduce
    // the massive regressions that could be caused by changing IsCompiledHtmlFile to correctly
    // handle URL's with fragments.
    BOOL bMovedPointer = FALSE;
    if (IsCompiledHtmlFile(pszUrl, &cszPrefix))
    {
        bMovedPointer = TRUE;
        pszUrl = cszPrefix.psz;
    }

    CWStr cwJump(pszUrl);
    if (pszInterTopic)
    {
        *pszInterTopic = '#';    // restore the original line
        if (bMovedPointer)
        {
            cszPrefix += pszInterTopic;
            pszUrl = cszPrefix.psz;
        }
    }

    CWStr cwLocation((pszInterTopic ? pszInterTopic : ""));

    if (!pUnkOuter) {
        /*
         * I couldn't find anything to to give
         * HlinkSimpleNavigateToString for pUnkOuter that wouldn't cause it
         * to fire of a new instance of IE. Trouble is, doHHWindowJump ends
         * up calling IWebBrowserAppImpl->Navigate who thinks all relative
         * paths start with http: instead of the current root (which could
         * be mk:). If we jump from a sitemap file, we fix that here.
         */

        CStr cszPrefix;
        if (!StrChr(pszUrl, ':') && pSiteMap &&
                IsCompiledHtmlFile(pSiteMap->GetSiteMapFile(), &cszPrefix)) {
            PSTR pszSep = strstr(cszPrefix, txtDoubleColonSep);
            ASSERT(pszSep);
            if (!pszSep)
                return NULL;    // should never happen, but beats GPF if it does
            strcpy(pszSep + 2, "/");
            while (*pszUrl == '.')
                pszUrl++;
            if (*pszUrl == '/' || *pszUrl == '\\')
                pszUrl++;
            cszPrefix += pszUrl;
            if (pWebApp == NULL)
                doHHWindowJump(cszPrefix, hwndParent);
            else
                pWebApp->Navigate(cszPrefix, NULL, NULL, NULL, NULL);
            return NULL;
        }
        if (pWebApp == NULL)
            doHHWindowJump(pszUrl, hwndParent);
        else
            pWebApp->Navigate(pszUrl, NULL, NULL, NULL, NULL);
        return NULL;
    }

    CWStr cwFrame(pszFrame);

    // REVIEW: if authoring is on, might want to call IsValidURL and
    // let the author know if they messed up.

    /*
     * REVIEW: if we are inside of a compiled HTML file and this is a
     * relative jump, then do our own checking first to avoid the browser
     * error message.
     */

    HRESULT hr = HlinkSimpleNavigateToString(cwJump, cwLocation,
        cwFrame, pUnkOuter, NULL, NULL, 0, NULL);

    /*
     * If the jump failed, try the Remote jump (unless that's what we
     * have already tried).
     */

    if (!SUCCEEDED(hr)) {
        if (pszSecondaryUrl) {
            pszUrl = pszSecondaryUrl;
            pszSecondaryUrl = NULL;
            goto TrySecondary;
        }
    }
    return NULL;
}

#if 0 // enable for subset filtering
BOOL ChooseInformationTypes(CInfoType *pInfoType, CSiteMap* pSiteMap, HWND hwndParent, CHtmlHelpControl* phhctrl, CHHWinType* phh)
#else
BOOL ChooseInformationTypes(CInfoType *pInfoType, CSiteMap* pSiteMap, HWND hwndParent, CHtmlHelpControl* phhctrl)
#endif
{
    if (!pInfoType->HowManyInfoTypes()) {
#ifdef _DEBUG
        MsgBox("No Information Types have been defined");
#endif
        return FALSE;
    }

    CInfoTypePageContents* apwiz[MAX_CATEGORIES + 1];
    int iMaxWizard = 0;
    CMem mem((int)lcSize(pInfoType->m_pInfoTypes));
    memcpy(mem.pb, pInfoType->m_pInfoTypes, lcSize(pInfoType->m_pInfoTypes));

    CMem memE((int)lcSize(pInfoType->m_pInfoTypes));
    memset(memE.pb, '\0', lcSize(pInfoType->m_pInfoTypes));

    INFO_PARAM infoParam;
    ZERO_STRUCTURE( infoParam );
    infoParam.pTypicalInfoTypes = pInfoType->m_pTypicalInfoTypes ?
        pInfoType->m_pTypicalInfoTypes : pInfoType->m_pInfoTypes;
    infoParam.pInfoTypes = (INFOTYPE*) mem.pb;
#if 0 // enable for subset filtering
    infoParam.pExclusive = (INFOTYPE*) memE.pb;
#endif
    infoParam.pSiteMap = pSiteMap;
    infoParam.idDlgTemplate = IDWIZ_INFOTYPE_CUSTOM_INCLUSIVE;
    infoParam.fExclusive = FALSE;
    infoParam.idNextPage = 0;
    infoParam.idPreviousPage = 0;
    infoParam.iCategory = -1;
    infoParam.fAll  = FALSE;
    infoParam.fTypical = TRUE;
    infoParam.fCustom = FALSE;
    infoParam.pInfoType = pInfoType;

    CPropSheet cprop(NULL, PSH_WIZARD, hwndParent);
#if 0 // enable for subset filtering
    CWizardIntro wizIntro(phh? phh->m_phmData->m_pTitleCollection : NULL, &infoParam);
    CInfoWizFinish wizFinish(phh, &infoParam);
#else
    CWizardIntro wizIntro(phhctrl, &infoParam);
    CInfoWizFinish wizFinish(phhctrl, &infoParam);
#endif

int type;

    if ( pInfoType->HowManyCategories() > 0 )
    {
        for (int CatCount = 0; CatCount<pInfoType->HowManyCategories(); CatCount++)
        {
            BOOL fAllHidden = TRUE;
            infoParam.iCategory = CatCount;
            infoParam.pagebits = pInfoType->m_itTables.m_aCategories[CatCount].pInfoType;
            type = pInfoType->GetFirstCategoryType(CatCount); // check all the IT's to see if there is an exclusive type in the category.
            if ( type == -1 )
                continue;   // we dont want categories without information types in them
            while ( type != -1 )
            {
                if ( !pInfoType->IsHidden ( type ) )
                    fAllHidden = FALSE;
                if ( pInfoType->IsExclusive(type) )
                {
                    infoParam.idDlgTemplate = IDWIZ_INFOTYPE_CUSTOM_EXCLUSIVE;
                    infoParam.fExclusive = TRUE;
                    break;
                }
                type = pInfoType->GetNextITinCategory();
            }
            if ( !fAllHidden )
#if 0 // enable for subset filtering
                apwiz[iMaxWizard++] = new CInfoTypePageContents(phh->m_phmData->m_pTitleCollection, &infoParam);
#else
            apwiz[iMaxWizard++] = new CInfoTypePageContents(phhctrl, &infoParam);
#endif
            infoParam.idDlgTemplate = IDWIZ_INFOTYPE_CUSTOM_INCLUSIVE;
            infoParam.fExclusive = FALSE;
        }
        iMaxWizard--;
    }
    else
    {   // there are no categories
        if ( pInfoType->HowManyInfoTypes() > 0 )
        {
            infoParam.iCategory = -1;
            infoParam.idNextPage = CInfoWizFinish::IDD;
            if ( pInfoType->GetFirstExclusive() != -1 )  // we have a set of exclusive ITs
            {
                infoParam.idDlgTemplate = IDWIZ_INFOTYPE_CUSTOM_EXCLUSIVE;
                infoParam.fExclusive = TRUE;
                infoParam.pagebits = pInfoType->m_itTables.m_pExclusive;
#if 0 // enable for subset filtering
                apwiz[iMaxWizard] = new CInfoTypePageContents(phh->m_phmData->m_pTitleCollection, &infoParam);
#else
                apwiz[iMaxWizard] = new CInfoTypePageContents(phhctrl, &infoParam);
#endif
            }
            else        // we have a set of inclusive ITs
            {
                infoParam.pagebits = NULL;  // look in CInfoType for Inclusive IT.
#if 0 // enable for subset filtering
                apwiz[iMaxWizard] = new CInfoTypePageContents(phh ? phh->m_phmData->m_pTitleCollection : NULL, &infoParam);
#else
                apwiz[iMaxWizard] = new CInfoTypePageContents(phhctrl, &infoParam);
#endif
            }
        }
    }

    cprop.AddPage(&wizIntro);

    ASSERT_COMMENT(iMaxWizard >= 0, "No information types specified")
    for (int i = 0; i <= iMaxWizard; i++)
        cprop.AddPage(apwiz[i]);

    cprop.AddPage(&wizFinish);

    if (phhctrl)
        phhctrl->ModalDialog(TRUE);
    BOOL fResult = cprop.DoModal();
    if (phhctrl)
        phhctrl->ModalDialog(FALSE);

        // Free the Wizzard Pages
    for (int j=0; j<iMaxWizard; j++)
    {
        if ( apwiz[j] >= 0 )
            delete apwiz[j];
    }

    if (!fResult)
        return FALSE;

#if 1  // disable for subset filtering
    memcpy(pInfoType->m_pInfoTypes, infoParam.pInfoTypes, lcSize(pInfoType->m_pInfoTypes));
#endif

    return TRUE;
}

//=--------------------------------------------------------------------------=
// ActiveX Event Firing
//=--------------------------------------------------------------------------=

static VARTYPE rgBstr[] = { VT_BSTR };

typedef enum {
    HHCtrlEvent_Click = 0,
} HHCTRLEVENTS;

static EVENTINFO rgHHCtrlEvents [] = {
    { DISPID_ONCLICK, 1, rgBstr }           // Click method
};

//=--------------------------------------------------------------------------=
// CHtmlHelpControl Class
//=--------------------------------------------------------------------------=


AUTO_CLASS_COUNT_CHECK( CHtmlHelpControl );

CHtmlHelpControl::CHtmlHelpControl(IUnknown *pUnkOuter)
    : CInternetControl(pUnkOuter, OBJECT_TYPE_CTLHHCTRL, (IDispatch *)this)
{
    memset(&m_state, 0, sizeof(HHCTRLCTLSTATE));

    m_state.bmpPath = 0;
    m_clrFont = CLR_INVALID;
    m_hpadding = -1;
    m_vpadding = -1;

    m_readystate = bdsNoBitsYet;

    m_ptoc = NULL;
    m_pindex = NULL;
    m_hfont = NULL;
    bSharedFont = FALSE;
    m_pszBitmap = NULL;
    m_pszWebMap = NULL;
    m_pszActionData = NULL;
    m_pwszButtonText = NULL;
    m_fButton = FALSE;
    m_fBuiltInImage = FALSE;
    m_ptblItems = NULL;
    m_hbrBackGround = NULL;
    m_hImage = NULL;
    m_pSiteMap = NULL;
    m_hwndHelp = NULL;
    m_pszEventString = NULL;
    m_pWebBrowserApp = NULL;
    m_ptblTitles = NULL;
    m_ptblURLs = NULL;
    m_ptblLocations = NULL;
    m_pszFrame = NULL;
    m_pszWindow = NULL;
    m_pszDefaultTopic = NULL;
    m_pInfoType = NULL;

    if (!g_hmodHHA && !g_fTriedHHA)
        LoadHHA(NULL, _Module.GetModuleInstance());

    m_pSelectedIndexInfoTypes = NULL;
    m_lpfnlStaticTextControlWndProc = NULL;
    m_hwndDisplayButton = NULL;
    m_dc = NULL;
    m_idBitmap = -1;
    m_fWinHelpPopup = 0;
    m_fPopupMenu = 0;
    memset( &m_rcButton, 0, sizeof(m_rcButton) );
    m_fIcon = 0;
    m_oldSize = 0;

    m_clrFontDisabled = GetSysColor(COLOR_GRAYTEXT);
    m_clrFontLink = RGB(0,0,255);
    m_clrFontLinkVisited = RGB(128,0,128);
    m_clrFontHover = RGB(255,0,0);
    m_szFontSpec[0] = '\0';
    m_Charset = -1;
    m_pIFont = 0;
}

CHtmlHelpControl::~CHtmlHelpControl ()
{
    if (IsValidWindow(m_hwndHelp))
        DestroyWindow(m_hwndHelp);

    if ( m_pIFont && m_hfont )
    {
       m_pIFont->AddRefHfont(m_hfont);
       m_pIFont->ReleaseHfont(m_hfont);
       m_pIFont->Release();
       m_hfont = 0;
    }
    if (m_state.bmpPath)
        delete m_state.bmpPath;
    if (m_hfont && !bSharedFont )
        DeleteObject(m_hfont);
    if (m_pszActionData)
        lcFree(m_pszActionData);
    if ( m_pindex )
       delete m_pindex;
    if ( m_ptoc )
       delete m_ptoc;
    if (m_pwszButtonText)
        lcFree(m_pwszButtonText);
    if (m_pszBitmap)
        lcFree(m_pszBitmap);
    if (m_pszWebMap)
        lcFree(m_pszWebMap);
    if (m_ptblItems)
        delete m_ptblItems;
    if (m_pSiteMap)
        delete m_pSiteMap;
    if (m_hbrBackGround)
        DeleteObject((HGDIOBJ) m_hbrBackGround);
    if (!m_fBuiltInImage && m_hImage)
        DeleteObject(m_hImage);
    if (m_pszEventString)
        lcFree(m_pszEventString);
    if (m_pszFrame)
        lcFree(m_pszFrame);
    if (m_pszWindow)
        lcFree(m_pszWindow);
    if (m_pszDefaultTopic)
        lcFree(m_pszDefaultTopic);
    if (m_pWebBrowserApp)
        delete m_pWebBrowserApp;
    if (m_ptblTitles)
        delete m_ptblTitles;
    if (m_ptblURLs)
        delete m_ptblURLs;
    if ( m_ptblLocations )
        delete m_ptblLocations;

#if 0
    if (m_dibFile)
        delete m_dibFile;
    if (m_dib)
        delete m_dib;
#endif

#if 0 // it appears that someone else (IE maybe) is destroying this for us
    if( m_hwndDisplayButton && IsValidWindow(m_hwndDisplayButton) )
      if( DestroyWindow( m_hwndDisplayButton ) == 0 )
        DWORD dwError = GetLastError();
#endif

#ifdef _DEBUG
    m_ptoc = NULL;
    m_pindex = NULL;
    m_state.bmpPath = 0;
    m_hfont = 0;
    m_pszActionData = 0;
    m_pwszButtonText = 0;
    m_pszBitmap = 0;
    m_pszWebMap = 0;
    m_ptblItems = 0;
    m_pSiteMap = 0;
    m_hImage = NULL;
    m_hbrBackGround = 0;
    m_pszEventString = 0;
    m_pszFrame = 0;
    m_pszWindow = 0;
    m_pWebBrowserApp = 0;
    m_ptblTitles = 0;
    m_ptblURLs = 0;
    m_ptblLocations = 0;
#endif
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::Create
//=--------------------------------------------------------------------------=
//
IUnknown* CHtmlHelpControl::Create(IUnknown *pUnkOuter)
{
    // make sure we return the private unknown so that we support aggregation
    // correctly!

    CHtmlHelpControl *pNew = new CHtmlHelpControl(pUnkOuter);
    return pNew->PrivateUnknown();
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::RegisterClassData
//=--------------------------------------------------------------------------=
//
BOOL CHtmlHelpControl::RegisterClassData(void)
{
    WNDCLASS wndclass;

    ZeroMemory(&wndclass, sizeof(WNDCLASS));
    wndclass.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
    wndclass.lpfnWndProc    = CInternetControl::ControlWindowProc;
    wndclass.hInstance      = _Module.GetModuleInstance();

    switch (m_action) {
        // Non-UI or specialized UI

        case ACT_CONTENTS:
        case ACT_INDEX:
        case ACT_SPLASH:
            wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
            break;

        default:
            if (!m_fButton)
                wndclass.hCursor = LoadCursor(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDCUR_HAND));
            else
                wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
            break;
    }

    wndclass.hbrBackground  =
        m_hbrBackGround ? m_hbrBackGround : (HBRUSH)(COLOR_WINDOW + 1);
    wndclass.lpszClassName  = WNDCLASSNAMEOFCONTROL(OBJECT_TYPE_CTLHHCTRL);

    DBWIN("Class registered");

    return RegisterClass(&wndclass);
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::ShouldCreateWindow
//=--------------------------------------------------------------------------=
//
// Essintialy called from Controls DoVerb() on OLEIVERB_SHOW, OLEIVERB_UIACTIVATE,
// and OLEIVERB_INPLACEACTIVATE calls. We can safely implement code in this function
// to cancel the creation of an ole control window.
//
// Output:
//    BOOL               - false don't create the control.
//
BOOL CHtmlHelpControl::ShouldCreateWindow()
{
   if ( (m_action == ACT_CONTENTS) || (m_action == ACT_INDEX) || (m_action == ACT_SPLASH))
      return TRUE;
   else return m_fButton;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::BeforeCreateWindow
//=--------------------------------------------------------------------------=
// called just before the window is created.  Great place to set up the
// window title, etc, so that they're passed in to the call to CreateWindowEx.
// speeds things up slightly.
//
// Parameters:
//    DWORD *            - [out] dwWindowFlags
//    DWORD *            - [out] dwExWindowFlags
//    LPSTR              - [out] name of window to create
//
// Output:
//    BOOL               - false means fatal error

BOOL CHtmlHelpControl::BeforeCreateWindow(DWORD *pdwWindowStyle,
    DWORD *pdwExWindowStyle, LPSTR  pszWindowTitle)
{
    /*
     * TODO: users should set the values of *pdwWindowStyle,
     * *pdwExWindowStyle, and pszWindowTitle so that the call to
     * CreateWindowEx can use them. setting them here instead of calling
     * SetWindowStyle in WM_CREATE is a huge perf win if you don't use this
     * function, then you can probably just remove it.
     */
    switch (m_action)
    {
       case ACT_CONTENTS:
          break;

       case ACT_INDEX:
          *pdwExWindowStyle = WS_EX_CONTROLPARENT;    // allow tab key in children
          break;

       case ACT_SPLASH:
          break;

       default:
          break;
    }
    return TRUE;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::AfterCreateWindow
//=--------------------------------------------------------------------------=
//
BOOL CHtmlHelpControl::AfterCreateWindow()
{
    switch (m_action) {
        case ACT_CONTENTS:
            if (!m_ptblItems) {
                AuthorMsg(IDS_MUST_SPECIFY_HHC);
                break;
            }
            LoadContentsFile(
                IsEmptyString(m_pszWebMap) ? m_ptblItems->GetPointer(1) : m_pszWebMap);
            m_ptoc->SetStyles(m_flags[0], m_flags[1]);
            if (IsValidWindow(m_ptoc->m_hwndTree))
                return TRUE;

            if (!m_ptoc->Create(m_hwnd)) {

                // BUGBUG: default to a generic display

                return FALSE; // window can't be created
            }

            m_ptoc->m_fHack = FALSE;

            m_ptoc->InitTreeView();
            return TRUE;

        case ACT_INDEX:
            if (!m_ptblItems) {
                AuthorMsg(IDS_MUST_SPECIFY_HHC);
                break;
            }
            LoadIndexFile(IsEmptyString(m_pszWebMap) ? m_ptblItems->GetPointer(1) : m_pszWebMap);
            if ( m_pindex )
               m_pindex->m_phhctrl = this;
            if (!m_pindex || !m_pindex->Create(m_hwnd)) {

                // BUGBUG: default to a generic display

                return FALSE; // window can't be created
            }
            return TRUE;

        case ACT_SPLASH:
            CreateSplash();
            return TRUE;

       case ACT_TEXT_POPUP:
       case ACT_ALINK:
       case ACT_KLINK: {
         IHTMLDocument2* pHTMLDocument2 = NULL;
         if( m_pWebBrowserApp ) {
           LPDISPATCH lpDispatch = m_pWebBrowserApp->GetDocument();
           if( lpDispatch && SUCCEEDED(lpDispatch->QueryInterface(IID_IHTMLDocument2, (void **)&pHTMLDocument2))) {
             m_clrFontDisabled = GetSysColor(COLOR_GRAYTEXT);
             VARIANT varColor;
             ::VariantInit(&varColor);
             if( SUCCEEDED( pHTMLDocument2->get_linkColor(&varColor) ) )
             {
               m_clrFontLink = IEColorToWin32Color(varColor.puiVal);
              VariantClear(&varColor);                                // Delete memory allocated.
             }
             ::VariantInit(&varColor);
             if( SUCCEEDED( pHTMLDocument2->get_vlinkColor(&varColor) ) )
             {
               m_clrFontLinkVisited = IEColorToWin32Color(varColor.puiVal);
               VariantClear(&varColor);                                // Delete memory allocated.
             }
#if 0 // [PaulTi] I don't know how to query this from IE4 -- so red it is for now
             ::VariantInit(&varColor);
             if( SUCCEEDED( pHTMLDocument2->get_alinkColor(&varColor) ) )
             {
               m_clrFontHover = IEColorToWin32Color(varColor.puiVal);
               VariantClear(&varColor);                                // Delete memory allocated.
             }
#endif
           }
           if( lpDispatch )
             lpDispatch->Release();

         }
         if( pHTMLDocument2 )
           pHTMLDocument2->Release();
       }

         // intentionally fall thru

        default:
            if (m_fButton) {
                if (!CreateOnClickButton()) {
                    // BUGBUG: default to a generic display

                    return FALSE; // window can't be created
                }
                {
                    SIZE size;
                    size.cx = RECT_WIDTH(m_rcButton);
                    size.cy = RECT_HEIGHT(m_rcButton);
                    SetControlSize(&size);
                }
                ShowWindow(m_hwndDisplayButton, SW_SHOW);
                break;
            }
            break;
    }

    // REVIEW: not necessary if we aren't using 256-color bitmaps. Also,
    // shouldn't we be destroying this palette when we are done with it?

#if 0
    m_dc = ::GetDC(m_hwnd);
    HPALETTE hpal = ::CreateHalftonePalette(m_dc);
    ::SelectPalette(m_dc, hpal, TRUE);
#endif

    UpdateImage();
    return TRUE;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::LoadTextState
//=--------------------------------------------------------------------------=
// load in our text state for this control.
//
// Parameters:
//    IPropertyBag *        - [in] property bag to read from
//    IErrorLog *           - [in] errorlog object to use with proeprty bag
//
// Output:
//    HRESULT
//
// Notes:
//    - NOTE: if you have a binary object, then you should pass an unknown
//      pointer to the property bag, and it will QI it for IPersistStream, and
//      get said object to do a Load()
//
//
//    We expect to see a single Name=Command, Value=command type followed by
//    any number of Name=Item<n> where n is any sequential digit. Note that in
//    some cases, the command value will include optional information
//    affecting the command.
//
//            WinHelp Popup, help file
//                item1 = number or string for WinHelp popup
//            Text Popup
//                item1 = popup text
//
//            AboutBox, title
//                item 1-3 = lines 1-3
//
//            Related Topics[, Dialog | Menu] (default is Dialog)
//               item1=title=url
//               ...
//               item<n>=title=url
//            Contents, file.cnt
//            Index, file.kwd
//
STDMETHODIMP CHtmlHelpControl::LoadTextState(IPropertyBag *pPropertyBag,
    IErrorLog *pErrorLog)
{
    VARIANT v;
    HRESULT hr;
    ZeroMemory(&v, sizeof(VARIANT));
    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = NULL;
    CHHWinType* phh = NULL;
    HWND hWnd;


    ZeroMemory(m_flags, sizeof(m_flags));
    m_flags[2] = (DWORD) -1;

    if ( (hWnd = GetHtmlHelpFrameWindow()) ) // Tunnels from the ActiveX control through IE to get to the HWND of HHCTRL.
    {
       if ( (phh = FindHHWindowIndex(hWnd)) )
          m_Charset = phh->GetContentCharset();
    }

    m_imgType = IMG_BITMAP; // default image type

    // Get the command for this control to perform

    hr = pPropertyBag->Read(txtwCommand, &v, pErrorLog);
    if (SUCCEEDED(hr)) {
        MAKE_ANSIPTR_FROMWIDE(psz, v.bstrVal);
        if (!g_fIE3)  // fix for bug 5664, 5665
            VariantClear(&v);                          // Delete memory allocated for BSTR
/*
#ifdef _DEBUG
        {
            char szMsg[512];
            wsprintf(szMsg, "Command: %s\r\n", psz);
            SendStringToParent(szMsg);
        }
#endif
*/
        // truncate command at 255 characters
        //
        if(strlen(psz) > 255)
            psz[255] = 0;

        // Always save a copy in this string...
        //
        lstrcpy(m_szRawAction, psz);
        if (isSameString(psz, txtWinHelp)) {

            // Let author know we're initialized

            m_action = ACT_WINHELP;
            m_fWinHelpPopup = ( stristr(psz, txtPopup) != NULL );
        }
        else if (isSameString(psz, txtRelatedTopics)) {
            m_action = ACT_RELATED_TOPICS;
            SetActionData(psz);
            m_fPopupMenu = isSameString(m_pszActionData, txtMenu);
            if (!m_pSiteMap)
                m_pSiteMap = new CSiteMap(MAX_RELATED_ENTRIES);
        }
        else if (isSameString(psz, txtActKLink)) {
            m_action = ACT_KLINK;
            SetActionData(psz);
            m_fPopupMenu = isSameString(m_pszActionData, txtMenu);
        }
        else if (isSameString(psz, txtActALink)) {
            m_action = ACT_ALINK;
            SetActionData(psz);
            m_fPopupMenu = isSameString(m_pszActionData, txtMenu);
        }
        else if (isSameString(psz, txtActSample)) {
            m_action = ACT_SAMPLE;
            SetActionData(psz);
            m_fPopupMenu = isSameString(m_pszActionData, txtMenu);
        }
        else if (isSameString(psz, txtKeywordSearch)) {
            m_action = ACT_KEYWORD_SEARCH;
            SetActionData(psz);
            m_fPopupMenu = isSameString(m_pszActionData, txtMenu);
            if (!m_pSiteMap)
                m_pSiteMap = new CSiteMap(MAX_KEYSEARCH_ENTRIES);
        }
        else if (isSameString(psz, txtShortcut)) {
            m_action = ACT_SHORTCUT;
        }
        else if (isSameString(psz, txtContents)) {
            m_flags[0] = WS_EX_CLIENTEDGE;
            m_flags[1] = DEFAULT_TOC_STYLES;

            m_action = ACT_CONTENTS;
            m_imgType = IMG_CHILD_WINDOW;
            SetActionData(psz);
            ProcessPadding(m_pszActionData);
        }
        else if (isSameString(psz, txtIndex)) 
        {
            // Let author know we're initialized

            m_flags[0] = WS_EX_WINDOWEDGE;
            m_action = ACT_INDEX;
            m_imgType = IMG_CHILD_WINDOW;
            SetActionData(psz);
            ProcessPadding(m_pszActionData);
            
            // see if the client has requested RTL layout
            //
            if(SUCCEEDED(pPropertyBag->Read(L"LayoutRTL", &v, pErrorLog)))
            {
               if(v.bstrVal)
               {
                  // convert the value to ANSI
                  //
                  char szValue[32];
                  WideCharToMultiByte(CP_ACP, 0, v.bstrVal, -1, szValue, sizeof(szValue), NULL, NULL);
                  szValue[sizeof(szValue) - 1] = 0;

                  VariantClear(&v);
                  
                  if(!stricmp(szValue, "TRUE"))
                  {
                     // turn on RTL styles
                     //
                     g_RTL_Mirror_Style = 0;
                     g_RTL_Style = WS_EX_RTLREADING | WS_EX_RIGHT;
                     g_fuBiDiMessageBox = MB_RIGHT | MB_RTLREADING;
                     g_fBiDi = TRUE;
                  }
               }
            }       
        }
        else if (isSameString(psz, txtHhCtrlVersion)) {
            m_action = ACT_HHCTRL_VERSION;
        }
        else if (isSameString(psz, txtSplash)) {
            m_action = ACT_SPLASH;
        }
        else if (isSameString(psz, txtTCard)) {
            m_action = ACT_TCARD;
        }
        else if (isSameString(psz, txtClose)) {
            m_action = ACT_CLOSE;
        }
        else if (isSameString(psz, txtHHWinPrint)) {
            m_action = ACT_HHWIN_PRINT;
        }
        else if (isSameString(psz, txtMinimize)) {
            m_action = ACT_MINIMIZE;
        }
        else if (isSameString(psz, txtMaximize)) {
            m_action = ACT_MAXIMIZE;
        }
        else if (isSameString(psz, txtAboutBox)) {

            // Let author know we're initialized

            m_action = ACT_ABOUT_BOX;
            SetActionData(psz);
        }
        else {
            AuthorMsg(IDS_INVALID_INITIALIZER, psz);
            return E_INVALIDARG;
        }

        //
        // DANGER! DANGER! DANGER! DANGER! DANGER! DANGER! DANGER!
        //

        // [PaulTi] so far the code block below has been accidently
        // removed twice with new checkins and has totally broken A/KLinks.
        //
        // Before ANYONE changes this code you must check with PaulTi
        // to make sure you have not caused this code to break again
        // (three strikes and you are out!).
        //

        // get the remaining arguments
        PSTR pszArguments = StrChr(psz, ',');
        if( pszArguments && *pszArguments == ',' ) // skip over the comma
          pszArguments++;
        pszArguments = FirstNonSpace(pszArguments);  // skip over whitespace

        while (pszArguments && *pszArguments) {
            if (isSameString(pszArguments, txtBitmap)) {
                // Skip to the filename
                PSTR pszFile = FirstNonSpace(pszArguments + strlen(txtBitmap));
                pszArguments = StrChr(pszFile, ',');
                if( *pszArguments == ',' )
                  pszArguments++; // skip over the comma
                if (pszArguments) {
                    *pszArguments = '\0';
                    pszArguments = FirstNonSpace(pszArguments + 1);
                }
                RemoveTrailingSpaces(pszFile);
                m_pszBitmap = lcStrDup(pszFile);
            }

            // BUGBUG: finish processing the rest of the commands

            else {
              if( pszArguments ) {
                pszArguments = StrChr(pszArguments, ',');
                if( pszArguments && *pszArguments == ',' ) // skip over the comma
                  pszArguments++;
                pszArguments = FirstNonSpace(pszArguments);
              }
            }
        }

    }
    else {  // Command not specified

        AuthorMsg(IDS_MISSING_COMMAND, "");
        return E_INVALIDARG;
    }

 	// shanemc 7883 - Support bgcolor for index
	if (ACT_INDEX == m_action) 
	{
	    VARIANT v;
	    ZeroMemory(&v, sizeof(VARIANT));
	    VariantInit(&v);
	    v.vt = VT_BSTR;
	    v.bstrVal = NULL;

	    // Get the background color 
	    HRESULT hr = pPropertyBag->Read(txtwBgColor, &v, pErrorLog);
		if (SUCCEEDED(hr) && (v.vt == VT_BSTR)) {
			MAKE_ANSIPTR_FROMWIDE(psz, v.bstrVal);
			VariantClear(&v);                          // Delete memory allocated for BSTR
	
            // default to button face color
            ULONG ulColor = GetSysColor(COLOR_BTNFACE);
            // HACK for special case requested by Millennium team: Check for button face color.
            // Really we should check for all the system and named colors supported by IE, but
            // this isn't an ideal world.
            if (strcmpi(psz, "buttonface") == 0) {
                // Don't do anything; default is correct color
            }
            else {
			    // Format is like Web--6 hex digits
			    if ('#' == *psz) psz++;		// skip optional #
                
                // Only override default if we get a valid number.
                if (isxdigit(*psz)) {
                    
                    ulColor = strtoul(psz, NULL, 16);

			        // Need to flip the bytes from BGR to RGB
			        BYTE bB = static_cast<BYTE>(ulColor & 0xff);
			        BYTE bG = static_cast<BYTE>((ulColor >> 8) & 0xff);
			        BYTE bR = static_cast<BYTE>(ulColor >> 16);
			        ulColor = RGB(bR, bG, bB);
                }
            }


            if (m_hbrBackGround) DeleteObject((HGDIOBJ) m_hbrBackGround);
            m_hbrBackGround = CreateSolidBrush(ulColor);
            m_clrFontHover = ulColor;   // HACK!!! this color not used for Index
                                        // (I don't want to change hhctrl.h to add new var)
        }
	}
   // end shanemc 7883 




   // Read all item data starting with Item1, then Item2, etc. until
    // an item isn't found.

    char szBuf[20];
    int iItem = 1;
    for (;;) {
        wsprintf(szBuf, txtItem, iItem++);
        WCHAR uniBuf[sizeof(szBuf) * 2];
        MultiByteToWideChar(CP_ACP, 0, szBuf, -1, uniBuf, sizeof(uniBuf));

        // REVIEW: Do we need to convert to unicode?

        hr = pPropertyBag->Read(uniBuf, &v, pErrorLog);
        if (SUCCEEDED(hr)) {
            // Choose the amount of memory the CTable needs to reserve based
            // on the command
            if (m_ptblItems == NULL) {
                switch (m_action) {
                    case ACT_ABOUT_BOX:
                    case ACT_CONTENTS:
                    case ACT_INDEX:
                    case ACT_WINHELP:
                    case ACT_SPLASH:
                    case ACT_SHORTCUT:
                        m_ptblItems = new CTable(4096);
                        break;

                    case ACT_CLOSE:
                    case ACT_MINIMIZE:
                    case ACT_MAXIMIZE:
                    case ACT_TCARD:  // data stored in m_pszActionData, not m_ptblItems
                    case ACT_HHWIN_PRINT:
                        break;

                    case ACT_KLINK:
                    case ACT_ALINK:
                        m_ptblItems = new CTable(1024 * 1024);
                        break;

                    case ACT_RELATED_TOPICS:
                    case ACT_KEYWORD_SEARCH:
                    case ACT_TEXT_POPUP:
                    default:
                        m_ptblItems = new CTable(256 * 1024);
                        break;
                }
            }

            CStr csz(v.bstrVal);
            if ( !g_fIE3 )  // fix for bug 5661 ...
                VariantClear(&v);                        // Delete memory allocated for BSTR
            if (m_action == ACT_RELATED_TOPICS) {
                // Format is "title;url1;url2

                PSTR pszUrl = StrChr(csz, ';');
                if (pszUrl)
                    *pszUrl++ = '\0';

                SITEMAP_ENTRY* pSiteMapEntry = m_pSiteMap->AddEntry();
            if (pSiteMapEntry != NULL)
                {
               ClearMemory(pSiteMapEntry, sizeof(SITEMAP_ENTRY));
               pSiteMapEntry->pszText = m_pSiteMap->StrDup((csz));

               if (pszUrl) {
                       CSiteEntryUrl SiteUrl( sizeof(SITE_ENTRY_URL) );

                  PSTR psz = pszUrl;
                  pszUrl = StrChr(psz, ';');
                  if (pszUrl)
                           *pszUrl++ = '\0';
                  SiteUrl.m_pUrl->urlPrimary = m_pSiteMap->AddUrl(psz);
                  if (pszUrl)
                      SiteUrl.m_pUrl->urlSecondary = m_pSiteMap->AddUrl(pszUrl);
                  SiteUrl.SaveUrlEntry(m_pSiteMap, pSiteMapEntry);
               }
            }
            else
               break;
            }
            else if (m_action == ACT_TCARD) {
                if(!m_pszActionData)
                    csz.TransferPointer(&m_pszActionData);
            }
            else if (m_ptblItems) { // not a related topic, so treat normally

              //
              // DANGER! DANGER! DANGER! DANGER! DANGER! DANGER! DANGER!
              //

              // [PaulTi] so far the code block below has been accidently
              // removed twice with new checkins and has totally broken A/KLinks.
              //
              // Before ANYONE changes this code you must check with PaulTi
              // to make sure you have not caused this code to break again
              // (three strikes and you are out!).
              //

              LPSTR psz = FirstNonSpace(csz);
              m_ptblItems->AddString(psz?psz:"");  // Save the item
            }
/* csz can be significantly larger than 512 characters.
#ifdef _DEBUG
        if (csz.psz) {
            char szMsg[512];
            wsprintf(szMsg, "%s: %s\r\n", szBuf, csz.psz);
            SendStringToParent(szMsg);
        }
#endif
*/

        }
        else
            break;
    }

    if (m_action != ACT_CONTENTS && m_action != ACT_INDEX) {

        hr = pPropertyBag->Read(txtwButton, &v, pErrorLog);
        if (SUCCEEDED(hr)) {
            CStr csz(v.bstrVal);
            int cb;
            if ((cb = CompareSz(csz, txtText)))
                m_pwszButtonText = lcStrDupW(v.bstrVal + cb);
            else if ((cb = CompareSz(csz, txtBitmap))) {
                m_pszBitmap = lcStrDup(FirstNonSpace(csz.psz + cb));
                m_flags[1] |= BS_BITMAP;
                m_fIcon = FALSE;
            }
            else if ((cb = CompareSz(csz, txtIcon))) {
                m_pszBitmap = lcStrDup(FirstNonSpace(csz.psz + cb));
                m_flags[1] |= BS_ICON;
                m_fIcon = TRUE;
            }
            else  // default to a text button
                m_pwszButtonText = lcStrDupW(v.bstrVal);
            m_fButton = TRUE;
            m_imgType = IMG_BUTTON;
            VariantClear(&v);                        // Delete memory allocated for BSTR
        }
        else {  // Button, Text and Icon are mutually exclusive
            hr = pPropertyBag->Read(txtwText, &v, pErrorLog);
            if (SUCCEEDED(hr)) {
                MAKE_ANSIPTR_FROMWIDE(psz, v.bstrVal);
                int cb;
                if ((cb = CompareSz(psz, txtText)))
                {
                   WCHAR* pwsz =  v.bstrVal + cb;
                   while ( *pwsz == L' ' )
                      ++pwsz;
                   m_pwszButtonText = lcStrDupW(pwsz);
                }
                else if ((cb = CompareSz(psz, txtBitmap))) {
                    m_pszBitmap = lcStrDup(FirstNonSpace(psz + cb));
                    m_fIcon = FALSE;
                    m_flags[1] |= SS_BITMAP;
                }
                else if ((cb = CompareSz(psz, txtIcon))) {
                    m_pszBitmap = lcStrDup(FirstNonSpace(psz + cb));
                    m_fIcon = TRUE;
                    m_flags[1] |= SS_ICON;
                }
                else if (*psz) // no text is a chiclet button
                    AuthorMsg(IDS_INVALID_BUTTON_CMD, psz);
                m_fButton = TRUE;
                m_imgType = IMG_TEXT;
                m_flags[1] |= SS_NOTIFY | (m_pszBitmap ? 0 : SS_OWNERDRAW);
                VariantClear(&v); // Delete memory allocated for BSTR
            }
        }
    }

    hr = pPropertyBag->Read(txtwImage, &v, pErrorLog);
    if (SUCCEEDED(hr)) {
        CStr csz(v.bstrVal);
        VariantClear(&v); // Delete memory allocated for BSTR
        SzTrimSz(csz);
        if (m_pszBitmap)
            lcFree(m_pszBitmap);
        csz.TransferPointer(&m_pszBitmap);
    }

    hr = pPropertyBag->Read(txtwWebMap, &v, pErrorLog);
    if (SUCCEEDED(hr)) {
        MAKE_ANSIPTR_FROMWIDE(psz, v.bstrVal);
        VariantClear(&v); // Delete memory allocated for BSTR
        if (m_pszWebMap)
            lcFree(m_pszWebMap);
        m_pszWebMap = lcStrDup(FirstNonSpace(psz));
        RemoveTrailingSpaces((PSTR) m_pszWebMap);
    }

    hr = pPropertyBag->Read(txtwFont, &v, pErrorLog);
    if (SUCCEEDED(hr)) {
        MAKE_ANSIPTR_FROMWIDE(psz, v.bstrVal);
        VariantClear(&v); // Delete memory allocated for BSTR
        if (m_hfont)
            DeleteObject(m_hfont);
        m_hfont = CreateUserFont(psz, &m_clrFont, NULL, m_Charset);
        lstrcpy(m_szFontSpec, psz);
    }

    /*
     * Flags should be read after any command, since commands may set
     * default flag values.
     */

    hr = pPropertyBag->Read(txtwFlags, &v, pErrorLog);
    if ( SUCCEEDED(hr) && (v.vt == VT_BSTR) ) {
        MAKE_ANSIPTR_FROMWIDE(psz, v.bstrVal);
        VariantClear(&v); // Delete memory allocated for BSTR
        for (int i = 0; i < MAX_FLAGS; i++) {
            while (*psz && (*psz < '0' || *psz > '9') && *psz != ',')
                psz++;
            if (!*psz)
                break;
            if (*psz != ',')
                m_flags[i] = Atoi(psz);
            psz = strchr(psz, ',');
            if (!psz)
                break;
            psz = FirstNonSpace(psz + 1);
        }
        if (m_flags[2] != (DWORD) -1 && m_action != ACT_KLINK && m_action != ACT_ALINK) {
            if (m_hbrBackGround)
                DeleteObject((HGDIOBJ) m_hbrBackGround);
            m_hbrBackGround = CreateSolidBrush(m_flags[2]);
        }
    }

    hr = pPropertyBag->Read(txtwFrame, &v, pErrorLog);
    if (SUCCEEDED(hr)) {
        CStr csz(v.bstrVal);
        VariantClear(&v); // Delete memory allocated for BSTR
        if (m_pSiteMap)
            m_pSiteMap->SetFrameName(csz);
        else {
            if (m_pszFrame)
                lcFree(m_pszFrame);
            csz.TransferPointer(&m_pszFrame);
        }
    }

    hr = pPropertyBag->Read(txtwWindow, &v, pErrorLog);
    if (SUCCEEDED(hr)) {
        CStr csz(v.bstrVal);
        VariantClear(&v); // Delete memory allocated for BSTR
        if (m_pSiteMap)
            m_pSiteMap->SetWindowName(csz);
        else {
            if (m_pszWindow)
                lcFree(m_pszWindow);
            csz.TransferPointer(&m_pszWindow);
        }
    }

    hr = pPropertyBag->Read(txtwDefaultTopic, &v, pErrorLog);
    if (SUCCEEDED(hr)) {
        CStr csz(v.bstrVal);
        VariantClear(&v); // Delete memory allocated for BSTR
        csz.TransferPointer(&m_pszDefaultTopic);
    }
    //
    // We need to create an appropiate font for the display of alinks/klinks/dynalinks. This
    // needs to be a content font rather than a UI font.
    //
    if (! m_hfont )
    {
       if ( phh )
       {
          m_hfont = phh->GetContentFont();
          bSharedFont = TRUE;
       }
       if (! m_hfont )                    // This code asks our container (IE) for a resolable font.
       {
          if ( GetAmbientFont(&m_pIFont) )
          {
             m_pIFont->get_hFont(&m_hfont);
             m_pIFont->AddRefHfont(m_hfont);
#ifdef _DEBUG
             LOGFONT lf ;
             int r = GetObject(m_hfont, sizeof(lf), &lf) ;
#endif
          }
       }
    }
    if (! m_hfont )
       m_hfont = CreateUserFont(GetStringResource(IDS_DEFAULT_CONTENT_FONT));   // Last resort!
    //
    // Now figure out a charset identifier and codepage...
    //
    CHARSETINFO cs;
    if ( phh )
    {
       m_Charset = phh->GetContentCharset();
       if ( TranslateCharsetInfo ((DWORD *)(DWORD_PTR)MAKELONG(m_Charset, 0), &cs, TCI_SRCCHARSET) )
          m_CodePage = cs.ciACP;
       else
          m_CodePage = CP_ACP;
    }
    else
    {
       TEXTMETRIC  tm;
       HDC hDC;
       HFONT hFontOrig;

       hDC = GetDC(NULL);
       hFontOrig = (HFONT)SelectObject(hDC, m_hfont);
       GetTextMetrics (hDC, &tm);
       if ( TranslateCharsetInfo ((DWORD *)(DWORD_PTR)MAKELONG(tm.tmCharSet, 0), &cs, TCI_SRCCHARSET) )
          m_CodePage = cs.ciACP;
       else
          m_CodePage = CP_ACP;
       m_Charset = tm.tmCharSet;
       SelectObject(hDC, hFontOrig);
       ReleaseDC(NULL, hDC);
    }
    _Module.SetCodePage(m_CodePage);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::SetActionData
//=--------------------------------------------------------------------------=
//
void CHtmlHelpControl::SetActionData(PCSTR psz)
{
    m_pszActionData = StrChr(psz, ',');
    if (m_pszActionData) {
        m_pszActionData = lcStrDup(FirstNonSpace(m_pszActionData + 1));
    }
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::ProcessPadding
//=--------------------------------------------------------------------------=
//
void CHtmlHelpControl::ProcessPadding(PCSTR pszPad)
{
    if (IsEmptyString(pszPad))
        return;
    PCSTR psz = stristr(pszPad, txtHPad);
    if (psz) {
        psz = FirstNonSpace(psz + strlen(txtHPad));
        m_hpadding = Atoi(psz);
    }

    psz = stristr(pszPad, txtVPad);
    if (psz) {
        psz = FirstNonSpace(psz + strlen(txtVPad));
        m_vpadding = Atoi(psz);
    }
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::SaveTextState
//=--------------------------------------------------------------------------=
// saves properties using IPropertyBag.
//
// Parameters:
//    IPropertyBag *           - [in] stream to write to.
//    fWriteDefault            - [in] ?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CHtmlHelpControl::SaveTextState(IPropertyBag *pPropertyBag, BOOL fWriteDefault)
{
    // Save the state of various properties.

    WCHAR uniBufProperty[MAX_URL];
    WCHAR uniBufValue[MAX_URL];
    VARIANT v;
    char szBuf[20];
    char szTmp[MAX_URL];
    int iItem = 1;
    HRESULT hr = S_OK;

    CHECK_POINTER(pPropertyBag);
    //
    // Remember the action data. i.e. ACT_KLINK, ACT_SAMPLE, ect.
    //
    MultiByteToWideChar(CP_ACP, 0, m_szRawAction, -1, uniBufValue, MAX_URL);    // Value.
    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(uniBufValue);
    pPropertyBag->Write(txtwCommand, &v);
    VariantClear(&v);
    //
    // Now remember all the parameters we put into the CTable...
    //
    while ( m_ptblItems && m_ptblItems->GetString(szTmp, iItem) )
    {
        wsprintf(szBuf, txtItem, iItem++);
        MultiByteToWideChar(CP_ACP, 0, szBuf, -1, uniBufProperty, MAX_URL);  // Property.
        MultiByteToWideChar(CP_ACP, 0, szTmp, -1, uniBufValue, MAX_URL);        // Value.
        v.vt = VT_BSTR;
        v.bstrVal = SysAllocString(uniBufValue);
        pPropertyBag->Write(uniBufProperty, &v);
        VariantClear(&v);
    }
    //
    // Lastly, restore the button text and font.
    //
    if ( m_pwszButtonText )
    {
       v.vt = VT_BSTR;
       v.bstrVal = SysAllocString(m_pwszButtonText);
       pPropertyBag->Write(txtwButton, &v);
       VariantClear(&v);
    }
    if ( m_szFontSpec[0] )
    {
       MultiByteToWideChar(CP_ACP, 0, m_szFontSpec, -1, uniBufValue, MAX_URL);        // Value.
       v.vt = VT_BSTR;
       v.bstrVal = SysAllocString(uniBufValue);
       pPropertyBag->Write(txtwFont, &v);
       VariantClear(&v);
    }
    return hr;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::LoadBinaryState
//=--------------------------------------------------------------------------=
// loads in our binary state using streams.
//
// Parameters:
//    IStream *            - [in] stream to write to.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CHtmlHelpControl::LoadBinaryState(IStream *pStream)
{
    DWORD       sh;
    HRESULT     hr;

    // first read in the streamhdr, and make sure we like what we're getting

    hr = pStream->Read(&sh, sizeof(sh), NULL);
    RETURN_ON_FAILURE(hr);

    // sanity check

    if (sh != STREAMHDR_MAGIC)
        return E_UNEXPECTED;
    hr = pStream->Read(&(m_state.endDate), sizeof(m_state.endDate), NULL);

    return(SetBmpPath(pStream));
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::SaveBinaryState
//=--------------------------------------------------------------------------=
//
STDMETHODIMP CHtmlHelpControl::SaveBinaryState(IStream *pStream)
{
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::SetClientSite   [IOleObject]
//=--------------------------------------------------------------------------=
// informs the embedded object [control] of it's client site [display
// location] within it's container
//
// Parameters:
//    IOleClientSite *        - [in] pointer to client site.
//
// Output:
//    HRESULT                 - S_OK, E_UNEXPECTED

STDMETHODIMP CHtmlHelpControl::SetClientSite(IOleClientSite* pClientSite)
{
    // Call the base class implementation first.
    HRESULT hr = CInternetControl::SetClientSite(pClientSite);

    LPSERVICEPROVIDER pISP;

    if (m_pClientSite != NULL)
    {
        hr = m_pClientSite->QueryInterface(IID_IServiceProvider, (LPVOID*)&pISP);

        if (SUCCEEDED(hr))
        {
            LPDISPATCH pIEDisp = NULL;

            hr = pISP->QueryService(IID_IWebBrowserApp, IID_IDispatch, (LPVOID*)&pIEDisp);

            if (SUCCEEDED(hr))
            {
                m_pWebBrowserApp = new IWebBrowserAppImpl(pIEDisp);
            }
#ifdef _DEBUG
            if (FAILED(hr))
                OutputDebugString("Failed to get a pointer to IE's IDispatch\n");
#endif
            pISP->Release();

            return S_OK;  // It's ok to fail the IWebBrowserApp wireing when we're printing.
        }
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::OnDraw
//=--------------------------------------------------------------------------=
//
// Parameters:
//    DWORD              - [in]  drawing aspect
//    HDC                - [in]  HDC to draw to
//    LPCRECTL           - [in]  rect we're drawing to
//    LPCRECTL           - [in]  window extent and origin for meta-files
//    HDC                - [in]  HIC for target device
//    BOOL               - [in]  can we optimize dc handling?

HRESULT CHtmlHelpControl::OnDraw(DWORD dvaaspect, HDC hdcDraw,
    LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDevice,
    BOOL fOptimize)
{

    if (DesignMode()) {
        HBRUSH hBrush = (HBRUSH)GetStockObject(BLACK_BRUSH);
        FillRect(hdcDraw, (LPRECT)prcBounds, hBrush);
        return S_OK;
    }

    if (prcWBounds != NULL) {   // printing to a metafile ?
        DBWIN("Metafile Printing not currently supported. <mikecole>");
        return S_OK;
    }

    // Are we printing to a printer DC ?
    //
    if ( GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_RASPRINTER )
    {
       // On IE4 we have to do the printing ourselves.
       //
       if ( m_imgType != IMG_BITMAP && m_pwszButtonText && *m_pwszButtonText )
       {
          HFONT hfont;
          if ( m_szFontSpec[0] )
             hfont = CreateUserFont(m_szFontSpec, NULL, hdcDraw, m_Charset);
          else
             hfont = _Resource.DefaultPrinterFont(hdcDraw);

          HFONT hfontOld = (HFONT) SelectObject(hdcDraw, hfont);

          IntlExtTextOutW(hdcDraw, prcBounds->left, prcBounds->top, 0, NULL, m_pwszButtonText, lstrlenW(m_pwszButtonText), NULL);
          SelectObject(hdcDraw, hfontOld);
          DeleteObject(hfont);
       }
       return S_OK;
    }

    switch(m_imgType) {
        case IMG_CHILD_WINDOW:
            return S_OK;    // no background to redraw

        case IMG_TEXT:
        case IMG_BUTTON:
            return S_OK;
    }

    if ( (m_idBitmap == 0 || m_idBitmap == -1) && m_pszBitmap == NULL)
    {
        SIZEL szl;
        szl.cx = 0;
        szl.cy = 0;
        SetControlSize(&szl);
    }
    else
    {
       HDC hdcTemp = CreateCompatibleDC(hdcDraw);
       HBITMAP hBitmap = LoadBitmap(_Module.GetResourceInstance(), "shortcut");
       HBITMAP hOld = (HBITMAP) SelectObject(hdcTemp, hBitmap);
       BITMAP bm;
       GetObject(hBitmap, sizeof(BITMAP), (LPSTR) &bm);

       POINT ptSize;
       ptSize.x = bm.bmWidth;            // Get width of bitmap
       ptSize.y = bm.bmHeight;           // Get height of bitmap
       DPtoLP(hdcTemp, &ptSize, 1);      // Convert from device
                                         // to logical points

       SIZEL szl;
       szl.cx = bm.bmWidth;
       szl.cy = bm.bmHeight;
       SetControlSize(&szl);
       SelectObject(hdcTemp,hOld);
       DeleteDC( hdcTemp );
       DeleteObject(hBitmap);
    }
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::WindowProc
//=--------------------------------------------------------------------------=
//
LRESULT CHtmlHelpControl::WindowProc(UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg) {
        case WM_ERASEBKGND:
          {
			// shanemc 7883: Support non-transparent index
			if (ACT_INDEX == m_action && m_hbrBackGround != NULL) {
                RECT rc;
                GetClipBox((HDC) wParam, &rc);
                FillRect((HDC) wParam, &rc, m_hbrBackGround);
                return TRUE;
			}
			// end shanemc 7883

            // Make the parent draw our background.

            /*
             * REVIEW: We could take advantage of this by having a flag
             * set that would grab the pixel in the upper left corner and
             * convert that into a background brush (m_hbrBackGround) that
             * all of our transparent controls would use. That would save
             * them from having to specify the background color in the
             * object tag.
             */

            HWND hwndParent = GetParent(m_hwnd);
            if (hwndParent) {
                // Adjust the origin so the parent paints in the right place
                POINT pt;
                ZERO_STRUCTURE(pt);
                MapWindowPoints(m_hwnd, hwndParent, &pt, 1);
                OffsetWindowOrgEx((HDC) wParam, pt.x, pt.y, &pt);

                LRESULT lres = SendMessage(hwndParent, msg, wParam, lParam);

                SetWindowOrgEx((HDC) wParam, pt.x, pt.y, NULL);

                if (lres)
                    return lres;
            }
          }
          break;

        case WM_WINDOWPOSCHANGING:             // bug HH 4281
            RECT rect;
            GetWindowRect(m_hwnd, &rect);
            if ( memcmp((void*)&m_rect, (void*)&rect, sizeof(RECT)) != 0 )
               InvalidateRect(m_hwnd, NULL, WM_ERASEBKGND);
            m_rect = rect;
            break;

        case WM_CTLCOLORBTN:
            if (m_hbrBackGround && m_hwndDisplayButton != (HWND) lParam)
                return (LRESULT) m_hbrBackGround;
            break;

        case WM_CTLCOLOREDIT:
            if (m_hbrBackGround && m_ptoc && IsValidWindow(m_ptoc->m_hwndTree))
                return (LRESULT) m_hbrBackGround;
            break;

        case WM_CTLCOLORSTATIC:
            if (m_hbrBackGround) {
                // shanemc 7883 - Set the background color if Index
                if (ACT_INDEX == m_action) {
                    SetBkColor((HDC)wParam, m_clrFontHover);
                    // Note hack of using FontHover color which to hold BkColor.
                    // FontHover color isn't used by Index and I don't want to change
                    // hhctrl.h if I can avoid it.

                    // shanemc 7924
                    // Setting the background color apparently changes the system's
                    // default foreground color to be black instead of window text color.
                    // This breaks readability. Unfortunately, we don't really know (at this
                    // point) whether the caller asked for the button background color or some
                    // other specific color. But we do know that Millennium will always ask 
                    // for button face, so we'll do the following:
                    // 1) Assume btnface is the background color.
                    // 2) Assume btntext is the best foreground color.
                    // 3) Confirm that the background color isn't the same as the 
                    //    button text color
                    // 4) If they are the same, use windowtext, black, or white 
                    //    (whichever doesn't match)
                    COLORREF clrText = GetSysColor(COLOR_BTNTEXT);
                    if (clrText == m_clrFontHover) {
                        clrText = GetSysColor(COLOR_WINDOWTEXT);
                        if (clrText == m_clrFontHover) {
                            clrText = RGB(0,0,0);
                        }
                        if (clrText == m_clrFontHover) {
                            clrText = RGB(255,255,255);
                        }
                    }
                    SetTextColor((HDC)wParam, clrText);
                    // end shanemc 7924
                }
                // end shanemc 7883
                return (LRESULT) m_hbrBackGround;
            }
            break;

        case WMP_AUTHOR_MSG:
            AuthorMsg((UINT)wParam, (PCSTR) lParam);
            lcFree((void*) lParam);
            return 0;

        case WMP_USER_MSG:
            if (lParam) {
                char szMsg[512];
                wsprintf(szMsg, GetStringResource((int)wParam), (PCSTR) lParam);
                ModalDialog(TRUE);
                MessageBox(GetParent(m_hwnd), szMsg, "", MB_OK | MB_ICONHAND);
                ModalDialog(FALSE);
                lcFree((void*) lParam);
            }
            else {
                ModalDialog(TRUE);
                MessageBox(GetParent(m_hwnd), GetStringResource((int)wParam), "",
                    MB_OK | MB_ICONHAND);
                ModalDialog(FALSE);
            }
            return 0;

        case WM_NOTIFY:
            if (m_action == ACT_CONTENTS)
                return m_ptoc->TreeViewMsg((NM_TREEVIEW*) lParam);
            else if (m_action == ACT_INDEX)
            {
               if ( wParam == IDC_KWD_VLIST )
                  m_pindex->OnVKListNotify((NMHDR*)lParam);
               return 0;
            }
            break;

        case WM_DRAWITEM:
            if (m_imgType == IMG_TEXT) {
                OnDrawStaticText((DRAWITEMSTRUCT*) lParam);
                break;
            }

            switch (m_action) {
                case ACT_INDEX:
//                    m_pindex->OnDrawItem(wParam, (LPDRAWITEMSTRUCT) lParam);
                    return 0;
            }
            break;

        case WM_SETFOCUS:
            HWND hWndButton;
            if ( m_fButton && (hWndButton = ::GetWindow(m_hwnd, GW_CHILD)) )
            {
               ::SetFocus(hWndButton);
               return 0;
            }
            else if ( (m_action == ACT_INDEX) && m_pindex)
            {
               m_pindex->SetDefaultFocus();
               return 0;
            }
            break;

        case WM_COMMAND:
            // BN_CLICKED and STN_CLICKED have the same value
            switch (HIWORD(wParam))
            {
               case BN_SETFOCUS:
                  ::SendMessage((HWND)lParam, BM_SETSTYLE, (BS_DEFPUSHBUTTON | BS_NOTIFY), 1L);
                  return 0;

               case BN_KILLFOCUS:
                  ::SendMessage((HWND)lParam, BM_SETSTYLE, (BS_PUSHBUTTON | BS_NOTIFY), 1L);
                  return 0;

               case BN_CLICKED:
               case BN_DOUBLECLICKED:
                  if ( m_fButton && LOWORD(wParam) < ID_VIEW_ENTRY )
                  {
#ifdef _DEBUG
                     if (LOWORD(wParam) == ID_VIEW_MEMORY) {
                        OnReportMemoryUsage();
                        return 0;
                     }
#endif
                     if (LOWORD(wParam) >= IDM_RELATED_TOPIC && LOWORD(wParam) <= IDM_RELATED_TOPIC + 100) {
                        OnRelatedCommand(LOWORD(wParam));
                     }
                     else {
                       OnClick();
                     }
                     return 0;
                  }
                  // Hmmm, I wonder if a fall through is intended here ?
            default:
               switch (m_action) {
                  case ACT_INDEX:
                     return m_pindex->OnCommand(m_hwnd, LOWORD(wParam), HIWORD(wParam), lParam);

                  case ACT_CONTENTS:
                  {
                     LRESULT lr = m_ptoc->OnCommand(m_hwnd, LOWORD(wParam), HIWORD(wParam), lParam);
#if 0
                     // Since SendEvent() has to be a member of CHtmlHelpControl, it's called
                     // at this point.
                     SendEvent();
#endif
                    return lr;
                  }

                  case ACT_RELATED_TOPICS:
                  case ACT_ALINK:
                  case ACT_KLINK:
                     OnRelatedCommand(LOWORD(wParam));
                     return 0;
               }
            }
            break;

        case WM_CONTEXTMENU:
            switch (m_action) {
                case ACT_RELATED_TOPICS:
                case ACT_INDEX:
                    if (IsHelpAuthor(GetParent(m_hwnd))) {
                        HMENU hmenu = CreatePopupMenu();
                        if (!hmenu)
                            break;
                        if (m_action == ACT_RELATED_TOPICS) {
                            CStr csz;
                            for (int i = 1; i <= m_pSiteMap->Count(); i++) {
                                csz = GetStringResource(IDS_VIEW_RELATED);
                                csz += m_pSiteMap->GetSiteMapEntry(i)->pszText;
                                HxAppendMenu(hmenu, MF_STRING, ID_VIEW_ENTRY + i,
                                    csz);
                            }
                        }
                        else {
                            HxAppendMenu(hmenu, MF_STRING, ID_VIEW_ENTRY,
                                pGetDllStringResource(IDS_VIEW_ENTRY));
                        }
#ifdef _DEBUG
                        HxAppendMenu(hmenu, MF_STRING, ID_VIEW_MEMORY,
                            "Debug: memory usage...");
#endif

                        POINT pt;
                        GetCursorPos(&pt);
                        TrackPopupMenu(hmenu,
                            TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON,
                            pt.x, pt.y, 0, m_hwnd, NULL);
                    }
                    break;
            }
            break;
    }
    return OcxDefWindowProc(msg, wParam, lParam);
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::SetObjectRects
//=--------------------------------------------------------------------------=
//
STDMETHODIMP CHtmlHelpControl::SetObjectRects(LPCRECT prcPos, LPCRECT prcClip)
{
    BOOL fRemoveWindowRgn;

    // verify our information

    // This assertion doesn't seem valid because the container (IE 3) never
    // calls SetExtent().
    // ASSERT_COMMENT(m_Size.cx == (prcPos->right - prcPos->left) && m_Size.cy == (prcPos->bottom - prcPos->top), "Somebody called SetObjectRects without first setting the extent");

    /*
     * Move our window to the new location and handle clipping. Not
     * applicable for windowless controls, since the container will be
     * responsible for all clipping.
     */

    if (m_hwnd) {
        fRemoveWindowRgn = m_fUsingWindowRgn;
        if (prcClip) {
            // the container wants us to clip, so figure out if we really
            // need to

            RECT rcIXect;
            if (IntersectRect(&rcIXect, prcPos, prcClip)) {
                if (!EqualRect(&rcIXect, prcPos)) {
                    OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));
                    SetWindowRgn(m_hwnd, CreateRectRgnIndirect(&rcIXect), TRUE);
                    m_fUsingWindowRgn = TRUE;
                    fRemoveWindowRgn  = FALSE;
                }
            }
        }

        if (fRemoveWindowRgn) {
            SetWindowRgn(m_hwnd, NULL, TRUE);
            m_fUsingWindowRgn = FALSE;
        }

        // set our control's location and size
        // [people for whom zooming is important should set that up here]

        // if (!EqualRect(prcPos, &m_rcLocation)) {
            m_Size.cx = RECT_WIDTH(prcPos);
            m_Size.cy = RECT_HEIGHT(prcPos);
            SetWindowPos(m_hwnd, NULL, prcPos->left, prcPos->top, m_Size.cx, m_Size.cy, SWP_NOZORDER | SWP_NOACTIVATE);
            CopyRect(&m_rcLocation, prcPos);
            switch (m_action) {
                case ACT_CONTENTS:
                if(m_ptoc)
                        m_ptoc->ResizeWindow();
                    return S_OK;

                case ACT_INDEX:
                if(m_pindex)
                        m_pindex->ResizeWindow();
                    // OnSizeIndex(&m_rcLocation);
                    return S_OK;
            }
            return S_OK;
        // }
    }

    // save out our current location. windowless controls want this more
    // then windowed ones do, but everybody can have it just in case

    // BUGBUG: 20-Apr-1997  [ralphw] why do we care about this for
    // windowless controls

    CopyRect(&m_rcLocation, prcPos);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::JumpToUrl
//=--------------------------------------------------------------------------=
//
void CHtmlHelpControl::JumpToUrl(SITEMAP_ENTRY* pSiteMapEntry, CSiteMap* pSiteMap, SITE_ENTRY_URL* pUrl)
{
    // REVIEW: we should make this an array of m_hwndHelp to handle more then
    // on help window open at once.

    HWND hwnd = ::JumpToUrl(m_pUnkOuter, m_hwndParent, pSiteMapEntry, m_pInfoType, pSiteMap, pUrl);
//    if (hwnd) {
//        if (m_hwndHelp && hwnd != m_hwndHelp)
//            DestroyWindow(m_hwndHelp);
//        m_hwndHelp = hwnd;
//    }
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::OnSpecialKey
//
// Function is called from COleControl::TranslateAccelerator() and should
// return TRUE if the key has been handled.
//
//=--------------------------------------------------------------------------=
BOOL CHtmlHelpControl::OnSpecialKey(LPMSG pmsg)
{
    static int sDisplayAccel = 'd';
    static int sEditAccel = 'w';
    static BOOL sbIsAccelsSet = FALSE;

    DBWIN("OnSpecialKey");

    // Get the current state of the SHIFT key.

    BOOL fShiftDown = (GetKeyState(VK_SHIFT) < 0);

    if (m_action == ACT_CONTENTS) {
        if (GetFocus() == m_hwnd)
            ::SetFocus(m_ptoc->m_hwndTree);

        // If the user pressed the Tab key, let the container
        // process it so it can set focus to the appropriate object.

        if (pmsg->wParam == VK_TAB &&
                (pmsg->message == WM_KEYUP || pmsg->message == WM_KEYDOWN))
            return FALSE;

        SendMessage(m_ptoc->m_hwndTree, pmsg->message, pmsg->wParam, pmsg->lParam);
        return TRUE;
    }
    if (m_action == ACT_INDEX) {

        // The main control window shouldn't have the focus; so if it
        // does, move it to the appropriate control depending on the
        // state of the SHIFT key.  (Tabbing to the control on an HTML
        // page will set the focus to the main window.)

        if (pmsg->message == WM_SYSKEYDOWN)
        {
            if (sbIsAccelsSet == FALSE)
            {
                sbIsAccelsSet = TRUE;
                PCSTR psz = StrChr(GetStringResource(IDS_ENGLISH_DISPLAY), '&');
                if (psz)
                    sDisplayAccel = ToLower(psz[1]);
                psz = StrChr(GetStringResource(IDS_TYPE_KEYWORD), '&');
                if (psz)
                    sEditAccel = ToLower(psz[1]);
            }
            if (ToLower((char)pmsg->wParam) == sEditAccel)
            {
                ::SetFocus(m_pindex->m_hwndEditBox);
                return TRUE;
            }
            else if (ToLower((char)pmsg->wParam) == sDisplayAccel)
            {
                ::SendMessage(GetParent(m_pindex->m_hwndDisplayButton), WM_COMMAND, MAKELONG(IDBTN_DISPLAY, BN_CLICKED), (LPARAM)m_pindex->m_hwndDisplayButton);
                return TRUE;
            }
        }

        if (GetFocus() == m_hwnd){
            if (fShiftDown)
                ::SetFocus(m_pindex->m_hwndDisplayButton);
            else
                ::SetFocus(m_pindex->m_hwndEditBox);
            return TRUE;
        }

        if (GetFocus() == m_pindex->m_hwndEditBox) {
            if ((pmsg->message == WM_KEYUP || pmsg->message == WM_KEYDOWN) &&
                pmsg->wParam == VK_TAB) {
                if (fShiftDown) {
                    return FALSE;   // Let the container handle this.
                }
                else {

                    // The focus only needs to be set once on WM_KEYDOWN.

                    if (pmsg->message == WM_KEYDOWN)
                        ::SetFocus(m_pindex->m_hwndListBox);
                    return TRUE;
                }
            }
            else
            {
               if ( pmsg->message == WM_KEYDOWN && (pmsg->wParam >= VK_PRIOR && pmsg->wParam <= VK_DOWN))
               {
                  SendMessage(m_pindex->m_hwndEditBox, pmsg->message, pmsg->wParam, pmsg->lParam);
                  return TRUE;
               }
               else
                  return FALSE;
            }
        }
        else if (GetFocus() == m_pindex->m_hwndListBox) {
            if ((pmsg->message == WM_KEYUP || pmsg->message == WM_KEYDOWN) &&
                pmsg->wParam == VK_TAB) {
                if (fShiftDown) {
                    if (pmsg->message == WM_KEYUP)
                        ::SetFocus(m_pindex->m_hwndEditBox);
                    return TRUE;
                }
                else {
                    if (pmsg->message == WM_KEYDOWN)
                        ::SetFocus(m_pindex->m_hwndDisplayButton);
                    return TRUE;
                }
            }
            else {
                // DonDr - Return TRUE instead of !SendMessage because it was causing double
                // scrolls if there was no scroll bar in IE.
                SendMessage(m_pindex->m_hwndListBox, pmsg->message, pmsg->wParam, pmsg->lParam);
                return TRUE;
            }
        }
        else if (GetFocus() == m_pindex->m_hwndDisplayButton) {
            if ((pmsg->message == WM_KEYUP || pmsg->message == WM_KEYDOWN) &&
                pmsg->wParam == VK_TAB) {
                if (fShiftDown) {
                    if (pmsg->message == WM_KEYDOWN)
                        ::SetFocus(m_pindex->m_hwndListBox);
                    return TRUE;
                }
                else {
                    return FALSE;
                }
            }
        }
    }
    return FALSE;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::OnSetExtent
//=--------------------------------------------------------------------------=
//

BOOL CHtmlHelpControl::OnSetExtent(const SIZE* pSize)
{
   BOOL bRet = TRUE;

   if ( m_fButton )
   {
      if ( IsValidWindow(m_hwndDisplayButton) )
      {
         m_Size.cx = RECT_WIDTH(m_rcButton);
         m_Size.cy = RECT_HEIGHT(m_rcButton);
         bRet = FALSE;
      }
      else  if ( m_pwszButtonText && m_pwszButtonText[0] )
      {
         // Compute the rect for the text. NOTE: This code will only be entered at print time.
         // for buttons that contain text.
         //
         HDC hDC;
         SIZE Size;

         if ( (hDC = GetDC(NULL)) )
         {
            HFONT hfontOld = (HFONT) SelectObject(hDC, m_hfont);
            IntlGetTextExtentPoint32W(hDC, m_pwszButtonText, lstrlenW(m_pwszButtonText), &Size);
            SelectObject(hDC, hfontOld);
            m_Size.cx = Size.cx + 2;     // The two pel "fudge factor" is a lazy way to avoid potential ABC spacing problems.
            m_Size.cy = Size.cy + 2;
            if ( m_imgType == IMG_BUTTON )
               m_Size.cy += 12;
            bRet = FALSE;
            ReleaseDC(NULL, hDC);
         }
      }
   }
   return bRet;
}


//=--------------------------------------------------------------------------=
// CHtmlHelpControl::get_Image
//=--------------------------------------------------------------------------=
//
STDMETHODIMP CHtmlHelpControl::get_Image(BSTR* path)
{
    CHECK_POINTER(path);
    BSTR * pbstrPath = path;
    *pbstrPath = (m_state.bmpPath && *(m_state.bmpPath)) ? BSTRFROMANSI(m_state.bmpPath) : SysAllocString(L"");
    return (*pbstrPath) ? S_OK : E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::put_Image
//=--------------------------------------------------------------------------=
//
STDMETHODIMP CHtmlHelpControl::put_Image(BSTR path)
{
    char * tmp = 0;

    if (m_state.bmpPath)
        delete m_state.bmpPath;

    int len = wcslen(path);
    HRESULT hr;

    tmp = new char[len+1];

    if (!tmp) {
        FAIL("No memory");
        hr = E_OUTOFMEMORY;
    }
    else if (WideCharToMultiByte(CP_ACP, 0, path, len, tmp, len, NULL, NULL) == 0)
            return E_FAIL;

    *(tmp + len) = '\0';

    // if it hasn't changed, don't waste any time.
	if(m_state.bmpPath)
	{
		if (!strcmp(m_state.bmpPath, tmp))
			return S_OK;
	}

    if (m_state.bmpPath)
        delete m_state.bmpPath;

    m_state.bmpPath = tmp;

    UpdateImage();

    return(hr);
}



//=--------------------------------------------------------------------------=
// CHtmlHelpControl::Click
//=--------------------------------------------------------------------------=
//
// This is called from scripting in the browser
//
STDMETHODIMP CHtmlHelpControl::Click()
{
    OnClick();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::HHClick
//=--------------------------------------------------------------------------=
//
// HHClick is a duplicate of Click() because in IE 4, VBScript decided to
// implement a Click command that overrides the OCX.
//
STDMETHODIMP CHtmlHelpControl::HHClick()
{
    OnClick();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::syncURL
//=--------------------------------------------------------------------------=
//
STDMETHODIMP CHtmlHelpControl::syncURL(BSTR pszUrl)
{
    if (pszUrl != NULL && m_ptoc)
    {
        CStr cszUrl((WCHAR*) pszUrl);
        m_ptoc->Synchronize(cszUrl);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::TCard
//=--------------------------------------------------------------------------=
//
STDMETHODIMP CHtmlHelpControl::TCard(WPARAM wParam, LPARAM lParam)
{
    HWND hwndParent = FindTopLevelWindow(GetParent(m_hwnd));
    if (hwndParent) {
        SendMessage(hwndParent, WM_TCARD, wParam, lParam);
        return S_OK;
    }
    else
        return S_FALSE;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::Print
//=--------------------------------------------------------------------------=
//
STDMETHODIMP CHtmlHelpControl::Print()
{
    HRESULT hr = S_OK;

    if (m_pWebBrowserApp->m_lpDispatch != NULL &&
        m_ptoc != NULL)
    {
        PostMessage(m_hwnd, WM_COMMAND, ID_PRINT, 0);
#if 0
        int action = PRINT_CUR_TOPIC;
        HTREEITEM hitem = TreeView_GetSelection(m_ptoc->m_hwndTree);
        if (hitem) {
            CPrint prt(m_hwndParent);
            prt.SetAction(action);
            if (!prt.DoModal())
                return hr;
            action = prt.GetAction();
        }

        PrintTopics(action, m_ptoc, m_pWebBrowserApp);
#endif
    }
    else
        hr = E_FAIL;

    return hr;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::TextPopup
//=--------------------------------------------------------------------------=
//
STDMETHODIMP CHtmlHelpControl::TextPopup(BSTR pszText, BSTR pszFont,
    int horzMargins, int vertMargins, COLORREF clrForeground, COLORREF clrBackground)
{
    if (pszText != NULL) {
        HH_POPUP popup;
        popup.cbStruct = sizeof(HH_POPUP);
        popup.hinst =  NULL; // This should be zero if idString is zero.
        popup.idString = 0;
        popup.pszText = (PCSTR) pszText;
        GetCursorPos(&popup.pt);
        popup.clrForeground = clrForeground;
        popup.clrBackground = clrBackground;
        popup.rcMargins.left = horzMargins;
        popup.rcMargins.top = vertMargins;
        popup.rcMargins.right = horzMargins;
        popup.rcMargins.bottom = vertMargins;
        popup.pszFont = (PCSTR) pszFont;

        xHtmlHelpW(FindTopLevelWindow(GetParent(m_hwnd)), NULL,
            HH_DISPLAY_TEXT_POPUP, (DWORD_PTR) &popup);
        return S_OK;
    }
    else
        return S_FALSE;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::SetBmpPath
//=--------------------------------------------------------------------------=
//
HRESULT CHtmlHelpControl::SetBmpPath(IStream * strm)
{
    CHECK_POINTER(strm);

    char * tmp = 0;

    if (m_state.bmpPath)
        delete m_state.bmpPath;

    DWORD   dw;
    HRESULT hr = strm->Read(&dw, sizeof(dw), 0);

    if (SUCCEEDED(hr)) {
        if (!dw) {
            hr = S_OK;
        }
        else {
            tmp = new char[dw+1];

            if (!tmp) {
                FAIL("No memory");
                hr = E_OUTOFMEMORY;
            }
            else {
                hr = strm->Read(tmp, dw + 1, 0);
            }
        }
    }


    // if it hasn't changed, don't waste any time.

    if ((!tmp && !m_state.bmpPath) || !strcmp(m_state.bmpPath, tmp))
        return S_OK;

    if (m_state.bmpPath)
        delete m_state.bmpPath;

    m_state.bmpPath = tmp;

    UpdateImage();

    return(hr);
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::UpdateImage
//=--------------------------------------------------------------------------=
//
HRESULT CHtmlHelpControl::UpdateImage()
{
    if (!m_hwnd)
        return(S_OK);

    if (!m_state.bmpPath)
        return(S_OK);

    FireReadyStateChange(READYSTATE_INTERACTIVE);

    return(SetupDownload(OLESTRFROMANSI(m_state.bmpPath), DISPID_BMPPATH));

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::OnData
//=--------------------------------------------------------------------------=
//
HRESULT CHtmlHelpControl::OnData(DISPID propId, DWORD grfBSCF,
    IStream * strm, DWORD dwSize)
{
    HRESULT hr      = NOERROR;

    switch(m_readystate) {
        case bdsNoBitsYet:
#if 0
            if (dwSize >= sizeof(BITMAPFILEHEADER)) {
                if( m_dibFile )
                    delete m_dibFile;

                m_dibFile = new CDibFile;

                if (!m_dibFile) {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                hr = m_dibFile->GetFileHeader(strm);
                if (FAILED(hr))
                    break;

                m_readystate = bdsGotFileHeader;

                // now FALL THRU!
            }
            else
#endif
                break;

        case bdsGotFileHeader:
#if 0
            if (dwSize >= (m_dibFile->HeaderSize() + sizeof(BITMAPFILEHEADER)))
            {
                if (m_dibFile)
                    hr = m_dibFile->GetInfoHeader(strm);
                else
                    hr = E_OUTOFMEMORY;

                if (FAILED(hr))
                    break;

                if (m_dib)
                    delete m_dib;

                m_dib = new CDibSection;

                if (!m_dib) {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                m_dib->Setup(m_dc);

                hr = m_dib->Create(*m_dibFile);

                if (FAILED(hr))
                    break;

                m_dib->ImageSize(m_dibFile->CalcImageSize());
                m_readystate = bdsGotBitmapInfo;

                // FALL THRU!

            }
            else
#endif
                break;

        case bdsGotBitmapInfo:
#if 0
            SIZEL   sz;
            m_dib->GetSize(sz);
            SetControlSize(&sz);

            m_oldSize = (m_dibFile->HeaderSize() + sizeof(BITMAPFILEHEADER));

            m_readystate = bdsGettingBits;
#endif
            // FALL THRU

        case bdsGettingBits:
#if 0
            if (dwSize > m_oldSize) {
                hr = m_dib->ReadFrom(strm, dwSize - m_oldSize);

                if (FAILED(hr))
                    break;

                ::RealizePalette(m_dc);

                m_dib->PaintTo(m_dc);

                m_oldSize = dwSize;
            }

            if (grfBSCF & BSCF_LASTDATANOTIFICATION)
                m_readystate = bdsBitsAreDone;
            else
#endif
                break;

        case bdsBitsAreDone:
#if 0
            m_readystate = bdsNoBitsYet;
            FireReadyStateChange(READYSTATE_COMPLETE);
            InvalidateControl(0);
#endif
            break;

    }

    return(hr);
}

#ifndef PPGS
//=--------------------------------------------------------------------------=
// CHtmlHelpControl::DoVerb
//=--------------------------------------------------------------------------=
//
STDMETHODIMP CHtmlHelpControl::DoVerb
(
    LONG            lVerb,
    LPMSG           pMsg,
    IOleClientSite *pActiveSite,
    LONG            lIndex,
    HWND            hwndParent,
    LPCRECT         prcPosRect
)
{
    switch (lVerb) {
      case OLEIVERB_PRIMARY:
      case CTLIVERB_PROPERTIES:
      case OLEIVERB_PROPERTIES:
      case OLEIVERB_OPEN:
      case OLEIVERB_HIDE:
            return S_OK;
#ifdef _DEBUG
      case OLEIVERB_INPLACEACTIVATE:
      case OLEIVERB_UIACTIVATE:
            //DBWIN("ACTIVATE");
            break;
#endif

    }
    return COleControl::DoVerb(lVerb, pMsg, pActiveSite, lIndex, hwndParent, prcPosRect);
}
#endif

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::InternalQueryInterface
//=--------------------------------------------------------------------------=
// qi for things only we support.
//
// Parameters:
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE

HRESULT CHtmlHelpControl::InternalQueryInterface(REFIID riid, void **ppvObjOut)
{
    IUnknown *pUnk;

    if (!ppvObjOut)
        return E_INVALIDARG;
    *ppvObjOut = NULL;

    /*
     * TODO: if you want to support any additional interrfaces, then you
     * should indicate that here. never forget to call CInternetControl's
     * version in the case where you don't support the given interface.
     */

    if (DO_GUIDS_MATCH(riid, IID_IHHCtrl)) {
        pUnk = (IUnknown *)(IHHCtrl *)this;
    } else{
        return CInternetControl::InternalQueryInterface(riid, ppvObjOut);
    }

    pUnk->AddRef();
    *ppvObjOut = (void *)pUnk;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::ConvertToCacheFile
//=--------------------------------------------------------------------------=
//
BOOL CHtmlHelpControl::ConvertToCacheFile(PCSTR pszSrc, PSTR pszDst)
{
    CStr cszTmp;

    PSTR psz = stristr(pszSrc, txtSysRoot);
    if (psz) {
        char szPath[MAX_PATH];
        GetRegWindowsDirectory(szPath);
        strcat(szPath, psz + strlen(txtSysRoot));
        cszTmp = szPath;
        pszSrc = (PCSTR) cszTmp.psz;
    }


TryThatAgain:
    PCSTR pszChmSep = strstr(pszSrc, txtDoubleColonSep);
    if (pszChmSep) {
        if (pszSrc != cszTmp.psz) {
            cszTmp = pszSrc;
            int offset = (int)(pszChmSep - pszSrc);
            pszSrc = cszTmp;
            pszChmSep = pszSrc + offset;
        }
        *(PSTR) pszChmSep = '\0';   // Remove the separator
        HRESULT hr = URLDownloadToCacheFile(m_pUnkOuter, pszSrc, pszDst, MAX_PATH, 0, NULL);
        if (!SUCCEEDED(hr)) {
            CStr cszNew;
            ModalDialog(TRUE);
            BOOL fResult = FindThisFile(m_hwnd, pszSrc, &cszNew, TRUE);
            ModalDialog(FALSE);
            if (fResult) {
                strcpy(pszDst, cszNew.psz);
                *(PSTR) pszChmSep = ':';   // Put the separator back
                strcat(pszDst, pszChmSep);
                return TRUE;
            }
        }
        else {  // we downloaded it, or have a pointer to it
            *(PSTR) pszChmSep = ':';   // Put the separator back
            strcat(pszDst, pszChmSep);
            return TRUE;
        }
    }

    // BUGBUG: need to get the current ULR -- if this is a "mk:" URL, then
    // we need to change the path before this will work

    HRESULT hr = URLDownloadToCacheFile(m_pUnkOuter, pszSrc, pszDst, MAX_PATH, 0, NULL);
    if (!SUCCEEDED(hr)) {
        if (!StrChr(pszSrc, ':')) { // no protocol, check current .CHM file
            HWND hwndParent = FindTopLevelWindow(GetParent(m_hwnd));
            char szClass[256];
            GetClassName(hwndParent, szClass, sizeof(szClass));
            if (IsSamePrefix(szClass, txtHtmlHelpWindowClass, -2)) {
                PCSTR pszFile = (PCSTR) SendMessage(hwndParent,
                    WMP_GET_CUR_FILE, 0, 0);
                if (IsNonEmptyString(pszFile)) {
                    cszTmp = pszFile;
                    cszTmp += txtDoubleColonSep;
                    cszTmp += pszSrc;
                    pszSrc = cszTmp;
                    goto TryThatAgain;
                }
            }
        }

        return FALSE;
    }
    return TRUE;
}

//=--------------------------------------------------------------------------=
// CHtmlHelpControl::SendEvent
//=--------------------------------------------------------------------------=
//
HRESULT CHtmlHelpControl::SendEvent(LPCTSTR pszEventString)
{
    if (!IsEmptyString(pszEventString)) {
        CWStr cwsz(pszEventString); // convert to WIDE
        BSTR bstr;
        if ((bstr = SysAllocString(cwsz)) != NULL)
            FireEvent(&::rgHHCtrlEvents[HHCtrlEvent_Click], bstr);
        SysFreeString(bstr);
    }
    return S_OK;
}


//=--------------------------------------------------------------------------=
// GetHtmlHelpFrameWindow
//=--------------------------------------------------------------------------=
//
/*
    This function gets the HWND for HTML Helps frame. HTML Help (CContainer) contains IE.
    IE contains an AKLink ActiveX contain (CHtmlHelpControl). This function gives CHtmlHelpControl
    a way to get to the HWND of its big daddy.
*/
HWND
CHtmlHelpControl::GetHtmlHelpFrameWindow()
{
    HWND hWndReturn = NULL ;

    if (m_pWebBrowserApp)
    {
        //--- Get a pointer to the container's IDispatch. This points to the IDispatch of CContainer (contain.cpp).
        IDispatch* pDispatchContainer = m_pWebBrowserApp->GetContainer() ;
        if (pDispatchContainer)
        {
            //--- Get the IOleWindow interface implemented by the container.
            IOleWindow* pIOleWindow = NULL ;
            HRESULT hr = pDispatchContainer->QueryInterface(IID_IOleWindow, (void**)&pIOleWindow) ;
            if (SUCCEEDED(hr) && pIOleWindow)
            {
                //--- Get the window for this container.
                HWND hWndTemp = NULL ;
                hr = pIOleWindow->GetWindow(&hWndTemp) ;
                if (SUCCEEDED(hr) && IsWindow(hWndTemp))
                {
                    //--- We found the container window! Now, get the HTML Help Frame window from this.
                    CHHWinType* phh = FindHHWindowIndex(hWndTemp) ;
                    if (phh && IsWindow(phh->hwndHelp))
                    {
                        hWndReturn = phh->hwndHelp ;
                    }
                }

                // Clean up.
                pIOleWindow->Release() ;
            }

            // Clean up some more.
            pDispatchContainer->Release() ;
        }
    }
    return hWndReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhctrl.h ===
// Copyright  1995-1997  Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _HHCTRL_H_
#define _HHCTRL_H_

#include "IPServer.H"
#include "CtrlObj.H"

#ifndef __IHHCtrl_FWD_DEFINED__
#include "hhIfc.H"
#endif

#include "Dispids.H"

#include "internet.h"
#include <commctrl.h>

#include "sitemap.h"
#include "hhamsgs.h"
#include "cindex.h"
#include "ctoc.h"
#include "prthook.h"

#include <mshtml.h>


typedef struct tagHHCtrlCTLSTATE
{
    char *bmpPath;
    DATE endDate;
} HHCTRLCTLSTATE;

enum BMP_DOWNLOAD_STATES
{
    bdsNoBitsYet,
    bdsGotFileHeader,
    bdsGotBitmapInfo,
    bdsGettingBits,
    bdsBitsAreDone
};

class CHtmlHelpControl; // forward reference
class IWebBrowserAppImpl; // forward reference

HWND  JumpToUrl(IUnknown* pUnkOuter, HWND hwndParent, SITEMAP_ENTRY* pSiteMapEntry, CInfoType *pInfoType, CSiteMap* pSiteMap, SITE_ENTRY_URL* pUrl, IWebBrowserAppImpl* pWebApp = NULL);
#if 0 //enable for subset filtering
BOOL ChooseInformationTypes(CInfoType *pInfoType, CSiteMap* pSiteMap, HWND hwndParent, CHtmlHelpControl* phhctrl, CHHWinType* m_phh);
#else
BOOL ChooseInformationTypes(CInfoType *pInfoType, CSiteMap* pSiteMap, HWND hwndParent, CHtmlHelpControl* phhctrl);
#endif
void DisplayAuthorInfo(CInfoType *pInfoType, CSiteMap* pSiteMap, SITEMAP_ENTRY* pSiteMapEntry, HWND hwndParent, CHtmlHelpControl* phhctrl);

HRESULT OnWordWheelLookup( PSTR pszKeywords, CExCollection* pExCollection,
                           PCSTR pszDefaultTopic = NULL,
                           POINT* ppt = NULL, HWND hWndParent = NULL,
                           BOOL bDialog = TRUE, BOOL bKLink = TRUE,
                           BOOL bTestMode = FALSE, BOOL bSkipCurrent = FALSE,
                           BOOL bAlwaysShowList = FALSE,
                           BOOL bAlphaSortHits = TRUE,
                     PCSTR pszWindow = NULL);

class CHtmlHelpControl : public CInternetControl, public IHHCtrl,
    public ISupportErrorInfo MI2_COUNT( CHtmlHelpControl )
{

public:
    // IUnknown methods

    DECLARE_STANDARD_UNKNOWN();

    // IDispatch methods

    DECLARE_STANDARD_DISPATCH();

    // ISupportErrorInfo methods

    DECLARE_STANDARD_SUPPORTERRORINFO();

    // IHHCtrl methods

    // OLE Control stuff follows:

    STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect,LPCRECT lprcClipRect) ;
    CHtmlHelpControl(IUnknown *pUnkOuter);
    virtual ~CHtmlHelpControl();
#ifndef PPGS
    STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite  *pActiveSite, LONG lindex,
          HWND hwndParent, LPCRECT lprcPosRect);
#endif
    STDMETHOD_(void, OnClick)(THIS);

    // static creation function.  all controls must have one of these!

    static IUnknown *Create(IUnknown *);


private:
    // overridables that the control must implement.

    STDMETHOD(LoadBinaryState)(IStream *pStream);
    STDMETHOD(SaveBinaryState)(IStream *pStream);
    STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);
    STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault);
    STDMETHOD(OnDraw)(DWORD dvaspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize);
    STDMETHOD(SetClientSite)(IOleClientSite  *pClientSite);

    // Exposed methods

    STDMETHOD(Click)();
    STDMETHOD(HHClick)();
    STDMETHOD(Print)();
    STDMETHOD(syncURL)(BSTR pszUrl);
    STDMETHOD(TCard)(WPARAM wParam, LPARAM lParam);
    STDMETHOD(get_Image) (THIS_ BSTR* path);
    STDMETHOD(put_Image)(BSTR path);
    STDMETHOD(TextPopup)(BSTR pszText, BSTR pszFont, int horzMargins, int vertMargins, COLORREF clrForeground, COLORREF clrBackground);

    LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam);
    void JumpToUrl(SITEMAP_ENTRY* pSiteMapEntry, CSiteMap* pSiteMap, SITE_ENTRY_URL* pUrl = NULL);
    void OnLButton(WPARAM wParam, LPARAM lParam);
    BOOL OnSetExtent(const SIZE *pSize);
    void ProcessPadding(PCSTR psz);
    BOOL RegisterClassData(void);
    void SetActionData(PCSTR psz);

    BOOL    AfterCreateWindow(void);
    BOOL    BeforeCreateWindow(DWORD *pdwWindowStyle, DWORD *pdwExWindowStyle, LPSTR pszWindowTitle);
    HRESULT InternalQueryInterface(REFIID, void **);
    HRESULT OnData( DISPID id, DWORD grfBSCF,IStream * bitstrm, DWORD amount );
    BOOL    OnSpecialKey(LPMSG);
    BOOL    ShouldCreateWindow();

public:
    void    doAboutBox();
    BOOL    ConvertToCacheFile(PCSTR pszSrc, PSTR pszDst);
    void    FillGeneralInformation(HHA_GEN_INFO* pgetInfo);
//  BOOL    ChooseInformationTypes(CSiteMap* pSiteMap, HWND hwndParent) { return ::ChooseInformationTypes(pSiteMap, hwndParent, this); }
    void    DisplayAuthorInfo(CSiteMap* pSiteMap, SITEMAP_ENTRY* pSiteMapEntry) { ::DisplayAuthorInfo(m_pInfoType, pSiteMap, pSiteMapEntry, m_hwnd, this); }
    void    OnKeywordSearch(int idCommand);
    BOOL    OnCopySample(void);
    BOOL    LocateSFLFile(PCSTR *,PCSTR *, BOOL);
    void    AuthorMsg(UINT idStringFormatResource, PCSTR pszSubString = "") { ::AuthorMsg(idStringFormatResource, pszSubString, m_hwndParent, this); }
    _inline IUnknown* GetIUnknown() { return m_pUnkOuter; }
    HRESULT SendEvent(LPCTSTR pszEventString);
    BOOL    OnAKLink(BOOL fKLink = TRUE, BOOL bTestMode = FALSE );

    HWND    GetHtmlHelpFrameWindow() ; // Tunnels from the ActiveX control through IE to get to the HWND of HHCTRL.

    UINT     GetCodePage(void) { return m_CodePage; }
    INT      GetCharset(void) { return m_Charset; }
    HFONT    GetContentFont(void) { return m_hfont; }

    // TOC functions

    BOOL    LoadContentsFile(PCSTR pszMasterFile);
    void    OnHelpTopics(void);

    // Index functions

    BOOL    LoadIndexFile(PCSTR pszMasterFile);
    void    OnSizeIndex(LPRECT prc);

    HRESULT UpdateImage();

    // Related Topics functions

    void OnRelatedMenu();
    void OnRelatedCommand(int idCommand);

    // Splash functions

    void CreateSplash(void);

    // Button and Static text funcions

    void OnDrawStaticText(DRAWITEMSTRUCT* pdis);
    BOOL CreateOnClickButton(void);

    // private state information.

    HRESULT SetBmpPath(IStream *);

    CTRL_ACTION                 m_action;
    IMAGE_TYPE                  m_imgType;
    PCSTR                       m_pszActionData;
    int                         m_idBitmap;     // bitmap to display
    PCSTR                       m_pszBitmap;    // bitmap parameter
    PCSTR                       m_pszWebMap;    // webmap file
    DWORD                       m_flags[MAX_FLAGS]; // author-specified flags
    HBRUSH                      m_hbrBackGround;    // background brush
    COLORREF                    m_clrFont;          // Font color
    BOOL                        m_fBuiltInImage;
    HGDIOBJ                     m_hImage;
    int                         m_hpadding; // horizontal padding around index, contents, and find
    int                         m_vpadding; // vertical padding around index, contents, and find
    HWND                        m_hwndHelp; // HTML Help window
    HWND                        m_hwndDisplayButton;    // regular button handle
    PCSTR                       m_pszEventString;   // string to send to event handler
    PCSTR                       m_pszFrame;     // frame to display jump in
    PCSTR                       m_pszWindow;    // window to display jump in
    PCSTR                       m_pszDefaultTopic;    // where to jump if alink/klink fails

    class IWebBrowserAppImpl*   m_pWebBrowserApp;   // Pointer the IE object model
    CTable*                     m_ptblItems;       // for A/KLinks
    CTable*                     m_ptblTitles;      // for A/KLinks
    CTable*                     m_ptblURLs;        // for A/KLinks
    CTable*                     m_ptblLocations;   // for A/KLinks
    CSiteMap*                   m_pSiteMap; // used by Related Topics and Keyword Search
    CInfoType*                  m_pInfoType;
    IFont*                      m_pIFont;


    // REVIEW: using BOOLs increases data size, bitflags would increase
    // code size. Which is better (multiple data seg, single code seg)?

    BOOL        m_fButton;
    BOOL        m_fWinHelpPopup;
    BOOL        m_fPopupMenu;   // TRUE to display popup menu instead of dialog

    WCHAR*      m_pwszButtonText;   // bitmap or text
    RECT        m_rcButton;         // button window dimensions

    CToc*       m_ptoc;
    CIndex*     m_pindex;
    //CSearch*    m_pSearch;

    BOOL        m_fIcon;                // bitmap is an icon or a cursor

    HHCTRLCTLSTATE      m_state;
    HDC                 m_dc;
    BMP_DOWNLOAD_STATES m_readystate;
    DWORD               m_oldSize;
    BYTE*               m_pSelectedIndexInfoTypes;


    COLORREF            m_clrFontDisabled;          // disabled Font color (disabled)
    COLORREF            m_clrFontLink;              // Link Font color
    COLORREF            m_clrFontLinkVisited;       // Visited Link Font color
    COLORREF            m_clrFontHover;             // Hover Font color

private:
    WNDPROC m_lpfnlStaticTextControlWndProc;
    static LRESULT StaticTextControlSubWndProc(HWND, UINT, WPARAM, LPARAM);
    char m_szRawAction[256];
    char m_szFontSpec[256];
    BOOL bSharedFont;
    UINT  m_CodePage;
    INT   m_Charset;
    HFONT m_hfont;        // author-specified font to use for child windows
    RECT  m_rect;
};

BOOL LoadGif(PCSTR pszFile, HBITMAP* phbmp, HPALETTE* phpal, CHtmlHelpControl* phhctrl);
BOOL ShortCut(CHtmlHelpControl* phhctrl, LPCSTR pszString1, LPCSTR pszString2, HWND hwndMsgOwner);

#ifdef CHIINDEX
#define PrintTopics
#else
void PrintTopics(int action, CToc* ptoc, IWebBrowserAppImpl* pWebApp, HWND hWndHelp = NULL);
#endif

// TODO: if you have an array of verbs, then add an extern here with the name
//       of it, so that you can include it in the DEFINE_CONTROLOBJECT.
//       ie.  extern VERBINFO m_HHCtrlCustomVerbs [];

extern const GUID *rgHHCtrlPropPages[];

DEFINE_CONTROLOBJECT(HHCtrl,
    &CLSID_HHCtrl,
    "HHCtrl",
    CHtmlHelpControl::Create,
    1,
    &IID_IHHCtrl,
    "",   // BUGBUG: change when OLE supports HtmlHelp files
    &DIID__HHCtrlEvents,
        OLEMISC_SETCLIENTSITEFIRST |
        OLEMISC_ACTIVATEWHENVISIBLE |
        OLEMISC_RECOMPOSEONRESIZE |
        OLEMISC_CANTLINKINSIDE |
        OLEMISC_INSIDEOUT,
    0,
    RESID_TOOLBOX_BITMAP,
    "HHCtrlWndClass",
    0,
    NULL,
    0,
    NULL);

#endif // _HHCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhfinder.cpp ===
///////////////////////////////////////////////////////////
//
//
// HHFinder.cpp : Implementation of CHHFinder
//
//
#include "header.h"

#ifdef _DEBUG
#undef THIS_FILE
static const CHAR THIS_FILE[] = __FILE__;
#endif

#include "resource.h"
#include "strtable.h"

#include "atlinc.h"     // includes for ATL.

#include "HHFinder.h"
#include "cdlg.h"
#include "wwheel.h"
#include "secwin.h"

// Used to lock toplevel windows before displaying a dialog.
#include "lockout.h"

// defines
#define HH_VERSION_1_3 // define this is build HH 1.3 or newer

///////////////////////////////////////////////////////////
//
//          Internal Structure Definition
//
///////////////////////////////////////////////////////////
//
// HHREMOVEABLE
//
typedef struct _hhremovable
{
  UINT  uiDriveType;
  PCSTR pszDriveLetter;
  PCSTR pszVolumeName;
  PSTR* ppszLocation;
} HHREMOVABLE;

///////////////////////////////////////////////////////////
//
// Globals
//
#ifdef _DEBUG
static BOOL g_bShowMessage = TRUE;
#endif

///////////////////////////////////////////////////////////
//
//  Prototypes
//
INT_PTR CALLBACK RemovableMediaDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

///////////////////////////////////////////////////////////
//
//                  Functions
//
///////////////////////////////////////////////////////////
//
// GetPathAndFileName
//
PCSTR GetPathAndFileName( PCSTR pszFilename, PSTR pszPathBuffer, PSTR pszFilenameBuffer )
{
  CHAR szPathname[MAX_PATH];
  PSTR pszFile;
  GetFullPathName( pszFilename, sizeof(szPathname), szPathname, &pszFile );
  lstrcpyn( pszPathBuffer, szPathname,  (int)(((DWORD_PTR)pszFile) - ((DWORD_PTR)&szPathname)) );
  strcpy( pszFilenameBuffer, pszFile );

  return( pszFilename );
}

/////////////////////////////////////////////////////////////////////////////
// CLocationNode
class CLocationNode {
public:
  CLocationNode::CLocationNode( PCSTR pszLocationId )
  {
    m_pszLocationId = new CHAR[strlen(pszLocationId)+1];
    strcpy( (PSTR) m_pszLocationId, pszLocationId );
    m_pNext = NULL;
  }
  CLocationNode::~CLocationNode( )
  {
    delete [] (PSTR) m_pszLocationId;
  }
  CLocationNode* GetNext() { return m_pNext; }
  CLocationNode* SetNext( CLocationNode* pNext ) { m_pNext = pNext; return m_pNext; }
  PCSTR      GetLocationId() { return m_pszLocationId; }
private:
  PCSTR      m_pszLocationId;
  CLocationNode* m_pNext;
};

/////////////////////////////////////////////////////////////////////////////
// CLocationList
class CLocationList {
public:
  CLocationList::CLocationList()
  {
    m_iCount = 0;
    m_pHead = NULL;
    m_pTail = NULL;
  }
  CLocationList::~CLocationList()
  {
    Free();
  }
  void CLocationList::Free()
  {
    CLocationNode* pNode = m_pHead;
    for( int i=0; i < m_iCount; i++ ) {
      CLocationNode* pNodeNext = pNode->GetNext();
      delete pNode;
      pNode = pNodeNext;
    }
    m_iCount = 0;
    m_pHead = NULL;
    m_pTail = NULL;
  }
  CLocationNode* CLocationList::Add( PCSTR pszLocationId )
  {
    CLocationNode* pNode = new CLocationNode( pszLocationId );
    if( m_iCount )
      m_pTail->SetNext( pNode );
    else
      m_pHead = pNode;
    m_pTail = pNode;
    m_iCount++;
    return pNode;
  }
  CLocationNode* CLocationList::Find( PCSTR pszLocationId )
  {
    CLocationNode* pNode = m_pHead;
    for( int i=0; i < m_iCount; i++ ) {
      if( strcmp( pszLocationId, pNode->GetLocationId() ) == 0 )
        break;
      CLocationNode* pNodeNext = pNode->GetNext();
      pNode = pNodeNext;
    }
    return pNode;
  }

private:
  int            m_iCount;
  CLocationNode* m_pHead;
  CLocationNode* m_pTail;
};

CLocationList g_LocationSkipList;

/////////////////////////////////////////////////////////////////////////////
// CHHFinder

HRESULT STDMETHODCALLTYPE CHHFinder::FindThisFile(const WCHAR* pwszFileName,
                             WCHAR** ppwszPathName, BOOL* pfRecordPathInRegistry )
{
  CExCollection* pCollection;
  CExTitle* pTitle = NULL;
  PCSTR pszPathName = NULL;
  CStr PathName;
  HRESULT hr = S_OK;

  // guarantee that we never record this value in the registry since it can always change.
  *pfRecordPathInRegistry = FALSE;

  CHAR pszFileName[MAX_PATH];
  WideCharToMultiByte(CP_ACP, 0, pwszFileName, -1, pszFileName, MAX_PATH, NULL, NULL);

  // get a pointer to the title and use this to get the fullpathname
  pCollection = GetCurrentCollection(NULL, pszFileName);

  if( pCollection )
    hr = pCollection->URL2ExTitle( pszFileName, &pTitle );

#if 0
  // if this is not a collection or we could not find the title then give
  // the ::FindThisFile function a try (since we know removable media
  // is not supported for non-collections anyway)

  if( !pCollection || !pTitle ) {
    // check the directory where the master file of the current collection lives
    CExCollection* pCurCollection = NULL;

    if( g_pCurrentCollection )
      pCurCollection = g_pCurrentCollection;
    else if( g_phmData && g_phmData[0] )
      pCurCollection = g_phmData[0]->m_pTitleCollection;

    if( pCurCollection ) {
      CHAR szPathName[_MAX_PATH];
      CHAR szFileName[_MAX_FNAME];
      CHAR szExtension[_MAX_EXT];
      SplitPath((PSTR)pszFileName, NULL, NULL, szFileName, szExtension);
      CHAR szMasterPath[_MAX_PATH];
      CHAR szMasterDrive[_MAX_DRIVE];
      SplitPath((PSTR)pCurCollection->m_csFile, szMasterDrive, szMasterPath, NULL, NULL);
      strcpy( szPathName, szMasterDrive );
      CatPath( szPathName, szMasterPath );
      CatPath( szPathName, szFileName );
      strcat( szPathName, szExtension );
      if( (GetFileAttributes(szPathName) != HFILE_ERROR) ) {
        PathName = szPathName;
        pszPathName = PathName.psz;
      }
    }

    if( !pszPathName ) {
      if( ::FindThisFile( NULL, pszFileName, &PathName, FALSE ) ) {
        pszPathName = PathName.psz;
      }
      else {
      #ifdef _DEBUG
        CHAR szMsg[1024];
        wsprintf( szMsg, "HHFinder Debug Message\n\nCould not locate the file \"%s\".", pszFileName );
        MsgBox( szMsg, MB_OK );
      #endif
        return S_OK;
      }
    }
  }
#endif

  // Removable media support (Refresh bypasses BeforeNavigate so we need this here).
  //
  // Note, this must be one of the first things we do since the user can
  // change the title's location
  //
  if( pTitle ) {
    pszPathName = pTitle->GetPathName();
    if( FAILED(hr = EnsureStorageAvailability( pTitle )) ) {
      return S_OK;
    }
  }

  // if we made it here than this mean we found it (if is does exist)
  // and pszPathName points to the full pathname
  LPMALLOC pMalloc;
  WCHAR pwszPathName[MAX_PATH];
  *ppwszPathName = NULL;
  if( pszPathName && *pszPathName ) {
    MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, pwszPathName, MAX_PATH);

    // allocate and copy the pathname
    if( SUCCEEDED(hr = CoGetMalloc(1, &pMalloc)) ) {
      *ppwszPathName = (WCHAR*) pMalloc->Alloc( (wcslen(pwszPathName)+1)*sizeof(WCHAR) );
      if( !*ppwszPathName ) {
        hr = E_OUTOFMEMORY;
      }
      else {
        wcscpy( *ppwszPathName, pwszPathName );
        hr = S_OK;
      }
      pMalloc->Release();
    }
  }

  if (*ppwszPathName == NULL)
	  hr = STG_E_FILENOTFOUND;

  return hr;
}

/////////////////////////////////////////////////////////////////////////////
// EnsureStorageAvailability

// Code to detect and handle Advanced Media Support issues (formerly RMS issues)
//
// Types are:
//
//  HHRMS_TYPE_TITLE (default)
//  HHRMS_TYPE_COMBINED_QUERY
//  HHRMS_TYPE_ATTACHMENT  // a.k.a Sample
//
// return values are as follows:
//  S_OK                    - The storage is available (party on!)
//  HHRMS_S_LOCATION_UPDATE - The user changed the location of the volume
//  E_FAIL                  - The storage is unknown (caller should handle this failure condition)
//  HHRMS_E_SKIP            - User choose to skip this volume just this time
//  HHRMS_E_SKIP_ALWAYS     - User choose to skip this volume for this entire session
//
//  For URL navigation, we should always volume check and always prompt.
//
//  For Queries, we should volume check for chm files and not volume check for chq files
//    and we will always prompt for the volume for this session unless the user
//    selects cancel.
//

HRESULT EnsureStorageAvailability( CExTitle* pTitle, UINT uiFileType,
                                   BOOL bVolumeCheckIn, BOOL bAlwaysPrompt,
                                   BOOL bNeverPrompt )
{
  HRESULT hr = S_OK;

  // if we do not have a title pointer this indicates that the URL does not belong to a
  // compressed title and thus we should claim the storage is available and let IE decide
  // what to do with it
  if( !pTitle )
    return S_OK;

  BOOL bVolumeCheck = bVolumeCheckIn;

  // Get the location information
  LOCATIONHISTORY* pLocationHistory = pTitle->GetUsedLocation();

  // Get the collection
  CExCollection* pCollection = pTitle->m_pCollection;

  // Only check removable media when running in a collection
  //
  if(pCollection && pCollection->IsSingleTitle())
    return S_OK;

  // Get the location identifier
  CHAR szLocationId[MAX_PATH];
  CLocation* pLocation = NULL;
  if( pLocationHistory ) {

    switch( uiFileType ) {

      case HHRMS_TYPE_TITLE:
        strcpy( szLocationId, pLocationHistory->LocationId );
        break;

      case HHRMS_TYPE_COMBINED_QUERY:
        if( pLocationHistory->QueryLocation && pLocationHistory->QueryLocation[0] )
          strcpy( szLocationId, pLocationHistory->QueryLocation );
        else if( pLocationHistory->LocationId && pLocationHistory->LocationId[0] )
          strcpy( szLocationId, pLocationHistory->LocationId );
        break;

      case HHRMS_TYPE_ATTACHMENT:
        if( pLocationHistory->SampleLocation && pLocationHistory->SampleLocation[0] )
          strcpy( szLocationId, pLocationHistory->SampleLocation );
        else if( pLocationHistory->LocationId && pLocationHistory->LocationId[0] )
          strcpy( szLocationId, pLocationHistory->LocationId );
        break;

      default:
        strcpy( szLocationId, pLocationHistory->LocationId );
        break;

    }

    pLocation = pCollection->m_Collection.FindLocation( szLocationId );
  }

  // if we have location information then get the details about it
  // otherwise never prompt or volume check (check existence only).
  PCSTR pszVolumeLabel = NULL;
  PCSTR pszVolumeName = NULL;
  if( pLocation ) {
    pszVolumeLabel = pLocation->GetVolume(); // Get the volume label
    pszVolumeName = pLocation->GetTitle(); // Get volume's friendly name
  }
  else {
    bVolumeCheck = FALSE;
    bNeverPrompt = TRUE;
  }

  // Get the pathname
  PCSTR pszPathname = NULL;
  switch( uiFileType ) {

    case HHRMS_TYPE_TITLE:
      pszPathname = pTitle->GetPathName();
      break;

    case HHRMS_TYPE_COMBINED_QUERY:
      pszPathname = pTitle->GetQueryName();
      break;

    case HHRMS_TYPE_ATTACHMENT:
      pszPathname = pTitle->GetCurrentAttachmentName();
      break;

    default:
      return E_FAIL;
      break;

  }

  // Get the location path and filename
  CHAR szPath[MAX_PATH];
  CHAR szFilename[MAX_PATH];
  PCSTR pszPath = szPath;
  szPath[0]= 0;
  szFilename[0]= 0;
  if( pLocation ) {
    strcpy( szPath, pLocation->GetPath() );
    CHAR szExt[MAX_PATH];
    CHAR szTmpPath[MAX_PATH];
    CHAR szDrive[MAX_PATH];
    CHAR szDir[MAX_PATH];
    szTmpPath[0] = 0;
    SplitPath( pszPathname, szDrive, szDir, szFilename, szExt );
    strcat( szFilename, szExt );
    // make sure that the filename includes and subdirs not part of the path
    //
    // for example the path may be e:\samples but the pathname is c:\samples\sfl\samp.sfl
    // and thus the path is e:\samples but the filename should be sfl\samp.sfl and not
    // just samp.sfl
    if( szDrive[0] )
      strcpy( szTmpPath, szDrive );
    if( szDir )
      strcat( szTmpPath, szDir );
// STang:
//    Buggy, must make sure pszPath is a prefix of szTmpPath ( except the drive letter )
//    if( strlen( szTmpPath ) != strlen( pszPath ) )
    if( strnicmp(pszPath+1,szTmpPath+1,(int)strlen(pszPath)-1) == 0 &&  strlen( szTmpPath ) > strlen( pszPath ) ) 
	{
      CHAR sz[MAX_PATH];
      strcpy( sz, &szTmpPath[strlen(pszPath)] );
      strcat( sz, szFilename );
      strcpy( szFilename, sz );
    }
  }
  else
    GetPathAndFileName( pszPathname, szPath, szFilename );

  // make sure to disable the default error message the OS displays
  // when doing a file check on removable media
  UINT uiErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

  // get the drive of the path
  CHAR szDriveRoot[4];
  lstrcpyn( szDriveRoot, szPath, 4 );
  #define mkupper(c) ((c)-'a'+'A')
  if( szDriveRoot[0] >= 'a' )
    szDriveRoot[0] = mkupper(szDriveRoot[0]); // make it upper case

  // Make copies of various settings to support location updating
  CHAR szVolumeLabelTry[MAX_PATH];
  CHAR szPathTry[MAX_PATH];
  CHAR szPathnameTry[MAX_PATH];
  CHAR szDriveRootTry[4];

  // setup the paths to try
  strcpy( szPathTry, szPath );
  strcpy( szPathnameTry, pszPathname );
  strcpy( szDriveRootTry, szDriveRoot );
  if( bVolumeCheck ) { //HH Bug 2521: Make sure pszVolumeLabel is non-null before copy.
    ASSERT( pszVolumeLabel );
    strcpy( szVolumeLabelTry, pszVolumeLabel );
  }
  else {
    strcpy( szVolumeLabelTry, "" );
  }

  // Setup prompting loop starting conditions
  BOOL bExistenceCheck = TRUE;
  BOOL bPrompt = FALSE;

  // === MAIN PROMPTING LOOP BEGINS HERE === //

  while( TRUE ) {

    // make sure to add a backslash if the second CHAR is a colon
    // sometimes we will get just "d:" instead of "d:\" and thus
    // GetDriveType will fail under this circumstance
    if( szDriveRootTry[1] == ':' ) {
      szDriveRootTry[2] = '\\';
      szDriveRootTry[3] = 0;
    }
    
    // Get media type
    UINT uiDriveType = DRIVE_UNKNOWN;
    if( szDriveRootTry[1] == ':' && szDriveRootTry[2] == '\\' ) {
      uiDriveType = GetDriveType(szDriveRootTry);
    }
    else if( szDriveRootTry[0] == '\\' && szDriveRootTry[1] == '\\' ) {
      uiDriveType = DRIVE_REMOTE;
      bVolumeCheck = FALSE; // never check volume label of network drives
    }

    // Determine and handle the drive types
    bExistenceCheck = TRUE;
    switch( uiDriveType ) {

      case DRIVE_FIXED:
      case DRIVE_RAMDISK:
        uiDriveType = DRIVE_FIXED;
        // fall thru

      case DRIVE_REMOTE:
        bVolumeCheck = FALSE;
        break;

      case DRIVE_REMOVABLE:
      case DRIVE_CDROM:
      case DRIVE_UNKNOWN:
      case DRIVE_NO_ROOT_DIR:
        if( bVolumeCheckIn )
          bVolumeCheck = TRUE;
        break;

      default: // unknown types
        bVolumeCheck = FALSE;
        bExistenceCheck = FALSE;
        break;
    }

    // Prompt for media
    if( bPrompt ) {
      CHAR szDriveLetter[4];
      szDriveLetter[0] = szDriveRoot[0];
      szDriveLetter[1] = szDriveRoot[1];
      szDriveLetter[2] = 0;

      HHREMOVABLE Removable;
      Removable.uiDriveType = uiDriveType;
      Removable.pszDriveLetter = szDriveLetter;
      Removable.pszVolumeName = pszVolumeName;
      PSTR pszPathTry = szPathTry;
      Removable.ppszLocation = &pszPathTry;

      HCURSOR hCursor = GetCursor();

      // Disable all of the toplevel application windows, before we bring up the dialog.
      CLockOut LockOut ;
      LockOut.LockOut(GetActiveWindow()) ;

      // Display the dialog box.
      INT_PTR iReturn = DialogBoxParam( _Module.GetResourceInstance(),
                      MAKEINTRESOURCE(IDD_REMOVEABLE_MEDIA_PROMPT),
                      GetActiveWindow(), RemovableMediaDialogProc,
                      (LPARAM) &Removable );

      // Enable all of the windows which we disabled.
      LockOut.Unlock() ;

      SetCursor( hCursor );

      if( iReturn == IDOK ) {
        strcpy( szPathnameTry, pszPathTry );
        CatPath( szPathnameTry, szFilename );
        lstrcpyn( szDriveRootTry, pszPathTry, 4 );
        bPrompt = FALSE;
        continue;
      }
      else if( iReturn == IDCANCEL ) {
        if( !bAlwaysPrompt )
          g_LocationSkipList.Add( szLocationId );
        hr = HHRMS_E_SKIP;
        break;
      }
    }

    // Validate media is present using the volume label, if needed
    if( bVolumeCheck ) {
      CHAR szVolume[MAX_PATH];
      szVolume[0] = 0;
      CHAR szFileSystemName[MAX_PATH];
      DWORD dwMaximumComponentLength = 0;
      DWORD dwFileSystemFlags = 0;
      BOOL bReturn = GetVolumeInformation( szDriveRootTry, szVolume, sizeof(szVolume),
        NULL, &dwMaximumComponentLength, &dwFileSystemFlags, szFileSystemName, sizeof(szFileSystemName) );
      if( bVolumeCheckIn && (!bReturn || (strcmp( szVolume, szVolumeLabelTry ) != 0)) )
        bExistenceCheck = FALSE;
    }

    // if the file exists, and it matches the chi file (for title checks only) the we have the right media
    if( bExistenceCheck && IsFile( szPathnameTry ) && ((uiFileType==HHRMS_TYPE_TITLE)?pTitle->EnsureChmChiMatch( szPathnameTry ):TRUE ) ) {
      hr = S_OK;

      // TODO: the version of MSDN that shipped with VS 6.0 is broken for net installs.
      // For a network install, they erroneously set the volume label for CD2, also
      // known as "98VS-1033-CD2", to "DN600ENU1" instead of "DN600ENU2".  To fix this we
      // need to ignore the language settings of "1033" or "ENU" and make the appropriate
      // change to the volume label.  We must do this before we call UpdateLocation since
      // it could change the location information for CD1 when the user updates the CD2
      // location information.

      // Never change the volume label unless the new destination is
      // removable media!
      //
      // Setup should adhere to the following rules:
      //
      // 1. Each local disk and network destination path must use a
      //    volume name unique for each set of titles from each CD source
      //    and they must be unique from the CD source volume label.
      //    It is advised that these volume names be the volume label name
      //    of the removable media (sahipped media) that the group came
      //    from appended with the destination type name and number such as
      //    "-LocalX" or "-NetX".
      // 2. Volume names for CD "destinations" must be identical to the
      //    CD's volume name.
      // 3. Note, locations with the same volume name will automatically
      //    get their path updated when any one of them changes.
      //

      // if the path did change then update the information, otherwise were done
      if( lstrcmpi( szPathTry, szPath ) != 0 ) {
		  // STang 
		  char * pcVolume = NULL;
		  if ( ( (uiDriveType == DRIVE_REMOVABLE) || (uiDriveType == DRIVE_CDROM) )
			    && bVolumeCheck )
			  pcVolume = szVolumeLabelTry;

        pCollection->UpdateLocation( (PSTR) szLocationId, szPathTry, pcVolume );

//        pCollection->UpdateLocation( (PSTR) szLocationId, szPathTry,
//                       ( (uiDriveType == DRIVE_REMOVABLE) || (uiDriveType == DRIVE_CDROM)) ? szVolumeLabelTry : NULL );
        hr = HHRMS_S_LOCATION_UPDATE;
      }

      break;
    }

    // Bail out if we never want to prompt for media 
    if( bNeverPrompt ) {

     #ifdef _DEBUG
      if( g_bShowMessage && (uiFileType != HHRMS_TYPE_COMBINED_QUERY) ) {
        CHAR szMsg[1024];
        wsprintf( szMsg, "HHFinder Debug Message\n\n"
                         "Could not find the file:\n  \"%s\"\n"
                         "at the location specified.", szPathnameTry );
        if( pTitle && pTitle->m_pTitle ) {
          CHAR szMsg2[1024];
          wsprintf( szMsg2, "\n\nTitle ID: \"%s\".", pTitle->m_pTitle->GetId() );
          strcat( szMsg, szMsg2 );
        }
        strcat( szMsg, "\n\nPress 'OK' to continue or 'Cancel' to disable this warning.");
        int iReturn = MsgBox( szMsg, MB_OKCANCEL );
        if( iReturn == IDCANCEL )
          g_bShowMessage = FALSE;
      }
     #endif

      // if existence check was desired then this is a failure condition
      if( bExistenceCheck ) {
        hr = E_FAIL;
        break;
      }

      // Bailout and let the caller know we are skipping this one
      hr = HHRMS_E_SKIP;
      break; 
    }

    // If we do not require that we always prompt, check the volume against
    // our skip list
    if( !bAlwaysPrompt ) {
      if( !bNeverPrompt )
        if( g_LocationSkipList.Find( szLocationId ) ) {
          hr = HHRMS_E_SKIP_ALWAYS;
          break;
        }
    }

  #ifdef _DEBUG
    // Let the user know that we could not find the title at the location specified 
    if( bPrompt ) {
      CHAR szMsg[1024];
          wsprintf( szMsg, "HHFinder Debug Message\n\n"
                           "Could not find the file:\n  \"%s\"\n"
                           "at the location specified.", szFilename );
      if( pTitle && pTitle->m_pTitle ) {
        CHAR szMsg2[1024];
        wsprintf( szMsg2, "\n\nTitle ID: \"%s\".", pTitle->m_pTitle->GetId() );
        strcat( szMsg, szMsg2 );
      }
      MsgBox( szMsg, MB_OKCANCEL );
    }
  #endif      

    // restore the original path information, and continue
    strcpy( szPathTry, szPath );
    strcpy( szPathnameTry, pszPathname );
    strcpy( szDriveRootTry, szDriveRoot );
    if( bVolumeCheck ) { //HH Bug 2521: Make sure pszVolumeLabel is non-null before copy.
      ASSERT( pszVolumeLabel );
      strcpy( szVolumeLabelTry, pszVolumeLabel );
    }
    else {
      strcpy( szVolumeLabelTry, "" );
    }
    bPrompt = TRUE;
    
  }

  // === MAIN PROMPTING LOOP ENDS HERE === //

  // restore the previous error mode
  SetErrorMode( uiErrorMode );

  return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CD Swap Dialog

INT_PTR CALLBACK RemovableMediaDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
  static HHREMOVABLE* pRemovable = NULL;
  static HWND hWndIcon = NULL;

  switch( uMsg ) {

    case WM_INITDIALOG: {
      pRemovable = (HHREMOVABLE*) lParam;

      // get and set our dialog title title
      PCSTR pszTitle = GetStringResource( IDS_MSGBOX_TITLE );
      SetWindowText( hDlg, pszTitle );

      //get media name and icon
      PCSTR pszMediaName = NULL;
      PCSTR pszIcon = NULL;
      DWORD dwFormatMessage = 0;

      if( pRemovable->uiDriveType == DRIVE_REMOVABLE ) {
        pszIcon = "IconDisk350";
        pszMediaName = GetStringResource( IDS_REMOVABLE_MEDIA_DISK ); // "disk"
        dwFormatMessage = IDS_REMOVABLE_MEDIA_MESSAGE_FORMAT;
      }
#ifdef HH_VERSION_1_3
      else if( pRemovable->uiDriveType == DRIVE_REMOTE ) {
        pszIcon = "IconRemote";
        pszMediaName = GetStringResource( IDS_REMOVABLE_MEDIA_REMOTE ); // "Network location"
        dwFormatMessage = IDS_REMOVABLE_MEDIA_MESSAGE_FORMAT2;
      }
      else if( pRemovable->uiDriveType == DRIVE_FIXED ) {
        pszIcon = "IconFixed";
        pszMediaName = GetStringResource( IDS_REMOVABLE_MEDIA_FIXED ); // "local disk"
        dwFormatMessage = IDS_REMOVABLE_MEDIA_MESSAGE_FORMAT2;
      }
#endif
      else /* if( pRemovable->uiDriveType == DRIVE_CDROM ) */ {
        pszIcon = "IconCDROM";
        pszMediaName = GetStringResource( IDS_REMOVABLE_MEDIA_CDROM ); // "CD-ROM disc"
        dwFormatMessage = IDS_REMOVABLE_MEDIA_MESSAGE_FORMAT;
      }

      CHAR szMediaName[64];
      strcpy( szMediaName, pszMediaName );

      // set the icon
      hWndIcon = CreateWindow( TEXT( "static" ), pszIcon,
        WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | SS_ICON,
        15, 15, 0, 0, hDlg, NULL, _Module.GetModuleInstance(), NULL );

      // get location message format string
      PCSTR pszFormat = GetStringResource( dwFormatMessage );
      CHAR szFormat[256];
      strcpy( szFormat, pszFormat );

      // format the location message
      DWORD dwArgCount = 3;
#ifdef HH_VERSION_1_3
      if( dwFormatMessage == IDS_REMOVABLE_MEDIA_MESSAGE_FORMAT2 )
        dwArgCount = 2;
#endif

      DWORD_PTR* pArg = new DWORD_PTR[dwArgCount];

      pArg[0] = (DWORD_PTR) szMediaName;
      pArg[1] = (DWORD_PTR) pRemovable->pszVolumeName;
      if( dwArgCount == 3 )
        pArg[2] = (DWORD_PTR) pRemovable->pszDriveLetter;

      CHAR szMessage[1024];

      FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
          szFormat, 0, 0, szMessage, sizeof(szMessage), (va_list*) pArg );

      delete [] pArg;

      // set the location message
#ifdef HH_VERSION_1_3
      ::SendMessage(GetDlgItem( hDlg, IDC_LOCATION_NAME ), WM_SETFONT, (WPARAM) _Resource.GetUIFont(), FALSE);
#else
      ::SendMessage(GetDlgItem( hDlg, IDC_LOCATION_NAME ), WM_SETFONT, (WPARAM) _Resource.DefaultFont(), FALSE);
#endif

      SetWindowText( GetDlgItem( hDlg, IDC_LOCATION_NAME ), szMessage );

      // set the location path
#ifdef HH_VERSION_1_3
      ::SendMessage(GetDlgItem( hDlg, IDC_LOCATION_PATH ), WM_SETFONT, (WPARAM) _Resource.GetUIFont(), FALSE);
#else
      ::SendMessage(GetDlgItem( hDlg, IDC_LOCATION_PATH ), WM_SETFONT, (WPARAM) _Resource.DefaultFont(), FALSE);
#endif

      SetWindowText( GetDlgItem( hDlg, IDC_LOCATION_PATH ), *(pRemovable->ppszLocation) );

      // disable the location path for now
      //EnableWindow( GetDlgItem( hDlg, IDC_LOCATION_PATH ), FALSE );

      // center the dialog
      CenterWindow( GetParent( hDlg ), hDlg );

      return TRUE;
    }

    case WM_COMMAND:
      if( LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL ) {
        // return the path
        GetWindowText( GetDlgItem( hDlg, IDC_LOCATION_PATH ), (PSTR) *(pRemovable->ppszLocation), MAX_PATH );
        // make sure the returned path includes a trailing backslash
        PSTR* ppsz = pRemovable->ppszLocation;
        int iLen = (int)strlen(*ppsz);
        if( (*ppsz)[iLen-1] != '\\' ) {
          (*ppsz)[iLen] = '\\';
          (*ppsz)[iLen+1] = 0;
        }
        DestroyWindow( hWndIcon );
        pRemovable = NULL;
        hWndIcon = NULL;
        EndDialog( hDlg, LOWORD( wParam ) );
      }
      else if( LOWORD(wParam) == ID_BROWSE ) {
        CStr strPath;
        if( DlgOpenDirectory( hDlg, &strPath ) ) {
          SetWindowText( GetDlgItem( hDlg, IDC_LOCATION_PATH ), strPath.psz );
        }
      }
      break;
  }

  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hherror.h ===
/****************************************************************************
*                                                                           *
* HHERROR.H --- HTML Help API errors                                        *
*                                                                           *
* Copyright (c) 1996-1997, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __HHERROR_H__
#define __HHERROR_H__

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


// HH_LAST_ERROR Command Related structures and constants

typedef struct tagHH_LAST_ERROR
{
    int cbStruct ;
    HRESULT hr ;            // The last error code.
    BSTR description ;      // Unicode description string.
} HH_LAST_ERROR ;

// Error codes

//#define HH_E_COULDNOTSTART             MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0200L ) // Could not start help system.
#define HH_E_FILENOTFOUND              MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0201L ) // %1 could not be found.
#define HH_E_TOPICDOESNOTEXIST         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0202L ) // The requested topic doesn't exist.
#define HH_E_INVALIDHELPFILE           MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0203L ) // %1 is not a valid help file.

//#define HH_E_INVALIDFUNCTION         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0204L ) // Unable to perform requested operation.
//#define HH_E_INVALIDPOINTER          MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0205L ) // Invalid pointer error.
//#define HH_E_INVALIDPARAMETER        MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0206L ) // Invalid parameter error.
//#define HH_E_INVALIDHWND             MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0207L ) // Invalid window handle.
//#define HH_E_INVALIDEXTENSION        MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0208L ) // Bad extension for file
//#define HH_E_ACCESSDENIED            MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0209L ) // Access Denied.

#define HH_E_NOCONTEXTIDS              MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x020AL ) // Help file does not contain context ids.
#define HH_E_CONTEXTIDDOESNTEXIT       MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x020BL ) // The context id doesn't exists.

// 0x0300 - 0x03FF reserved for keywords
#define HH_E_KEYWORD_NOT_FOUND         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0300L ) // no hits found.
#define HH_E_KEYWORD_IS_PLACEHOLDER    MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0301L ) // keyword is a placeholder or a "runaway" see also.
#define HH_E_KEYWORD_NOT_IN_SUBSET     MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0302L ) // no hits found due to subset exclusion.
#define HH_E_KEYWORD_NOT_IN_INFOTYPE   MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0303L ) // no hits found due to infotype exclusion.
#define HH_E_KEYWORD_EXCLUDED          MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0304L ) // no hits found due to infotype and subset exclusion.
#define HH_E_KEYWORD_NOT_SUPPORTED     MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x0305L ) // no hits found due to keywords not being supported in this mode.

#ifdef __cplusplus
}
#endif  // __cplusplus


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhfinder.h ===
// HHFinder.h : Declaration of the CHHFinder

#ifndef __HHFINDER_H__
#define __HHFINDER_H__

#include "header.h"

#include "msitstg.h"
#include "atlinc.h"     // includes for ATL.

// defines
#define HHRMS_TYPE_TITLE          0
#define HHRMS_TYPE_COMBINED_QUERY 1
#define HHRMS_TYPE_ATTACHMENT     2 // a.k.a Sample

// make Don's stuff work
#include <stdio.h>
#ifdef HHCTRL
#include "parserhh.h"
#else
#include "parser.h"
#endif
#include "collect.h"
#include "hhtypes.h"
#include "toc.h"

#define HHFINDER_VERSION        1
#define HHFINDER_VERSION_ID_STR "HHCtrl.FileFinder.1"
#define HHFINDER_ID_STR         "HHCtrl.FileFinder"
#define HHFINDER_GUID           "{adb880a4-d8ff-11cf-9377-00aa003b7a11}"
#define HHFINDER_EXTENSION      ".chm"

// success codes
#define HHRMS_S_LOCATION_UPDATE MAKE_HRESULT(SEVERITY_SUCCESS,FACILITY_ITF,100)

// error codes
#define HHRMS_E_SKIP            MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,100)
#define HHRMS_E_SKIP_ALWAYS     MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,101)

// Interface ID for the File Finder interface (used with URLs):
// "adb880a4-d8ff-11cf-9377-00aa003b7a11";
DEFINE_GUID( CLSID_HHFinder,
0xadb880a4, 0xd8ff, 0x11cf, 0x93, 0x77, 0x00, 0xaa, 0x00, 0x3b, 0x7a, 0x11);

/////////////////////////////////////////////////////////////////////////////
// CHHFinder

class ATL_NO_VTABLE CHHFinder :
        public IITFileFinder,
        public CComObjectRootEx<CComMultiThreadModel>,
        public CComCoClass<CHHFinder, &CLSID_HHFinder>
{
public:
        CHHFinder() {}

DECLARE_REGISTRY( CLSID_HHFinder, HHFINDER_VERSION_ID_STR, HHFINDER_ID_STR, 0, THREADFLAGS_BOTH )

BEGIN_COM_MAP(CHHFinder)
        COM_INTERFACE_ENTRY(IITFileFinder)
END_COM_MAP()

public:
        HRESULT STDMETHODCALLTYPE FindThisFile(const WCHAR* pwszFileName,
                             WCHAR** ppwszPathName, BOOL* pfRecordPathInRegistry );
};

/////////////////////////////////////////////////////////////////////////////
// CD Swap Dialog

HRESULT EnsureStorageAvailability( CExTitle* pTitle,
                                   UINT uiFileType = HHRMS_TYPE_TITLE,
                                   BOOL bVolumeCheck = TRUE,
                                   BOOL bAlwaysPrompt = TRUE,
                                   BOOL bNeverPrompt = FALSE );
#endif //__HHFINDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhpriv.h ===
///////////////////////////////////////////////////////////
//
//
// private.h --- Private API
//
//
#ifndef __PRIVATE_H__
#define __PRIVATE_H__

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#pragma pack(push, 8) // REVIEW: Why doesn't htmlhelp.h have this?

//////////////////////////////////////////////////////////
//
// Private APIs
//
#define HH_TITLE_PATHNAME           0x00ff
#define HH_HELP_CONTEXT_COLLECTION  0x00fe   // Does a HELP Context in the Collection Space
#define HH_PRETRANSLATEMESSAGE2     0x0100   // Fix for millinium pretranslate problem. Bug 7921

// Reloads the navigation panes with data from new CHM. 
#define HH_RELOAD_NAV_DATA          0x00fb  // (hwndCaller, pszFile>windowtype, NULL)

// Gets a pointer to the WebBrowser control.
#define HH_GET_BROWSER_INTERFACE    0x00fa // (hWndOfBrowserParent, NULL,,IWebBrowser)

// For Microsoft Installer -- dwData is a pointer to the GUID string
#define HH_SET_GUID             0x001A  
// For Microsoft Installer -- dwData is a pointer to the GUID string
#define HH_SET_BACKUP_GUID      0x001B  

///////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct tagHH_TITLE_FULLPATH
{
    LCID lcid ;             // [in]     The LCID of the collection to find.
    LPCSTR szTag ;          // [in]     The tag to be looked up. (CHM name = tag for UI chm's) . 
    BSTR fullpathname ;    // [out]    The full pathname to the CHM.
} HH_TITLE_FULLPATH ;

///////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct tagHH_COLLECTION_CONTEXT
{
    LPCSTR      szTag;
    LCID        lcid;   // lcid of the context.
    DWORD        id ;
} HH_COLLECTION_CONTEXT;

///////////////////////////////////////////////////////////////////////////////
//
// Nav Data structure for reloading the nav panes.
//
typedef struct tagHH_NAVDATA
{
    LPCWSTR pszName ;   // Name of the window type. Must be global.
    LPCWSTR pszFile ;   // Name of the CHM file which contains the new nav data.
} HH_NAVDATA ;

#pragma pack(pop)

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __PRIVATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhshell.h ===
// Copyright (C) Microsoft Corporation 1997, All Rights reserved.

typedef struct {
    HWND   hwndCaller;
    LPCSTR pszFile;
    UINT   uCommand;
    DWORD_PTR  dwData;
} HH_ANSI_DATA;

typedef struct {
    HWND    hwndCaller;
    LPCWSTR pszFile;
    UINT    uCommand;
    DWORD_PTR   dwData;
} HH_UNICODE_DATA;

extern PSTR    g_pszShare;
extern HANDLE  g_hSharedMemory;
extern HANDLE  g_hsemMemory;
extern HWND    g_hwndApi;

void WaitForNavigationComplete(void);
// Handle message translation.
BOOL hhPreTranslateMessage(MSG* pMsg, HWND hWndCaller = NULL) ;

extern BOOL    g_fStandAlone ;
extern SHORT   g_tbRightMargin;   
extern SHORT   g_tbLeftMargin;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhshell.cpp ===
// Copyright (C) Microsoft Corporation 1997, All Rights reserved.

#include "header.h"
#include "hhshell.h"
#include "secwin.h"
#include "contain.h"
#include "resource.h"

//Support for HH_GET_LAST_ERROR
#include "lasterr.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////
//
// Function prototypes
//
static void FlushMessageQueue(UINT msgEnd = 0);
extern "C"
{
HANDLE WINAPI ShCreateHHWindow(void);
}

// Prototype
#define _CURRENT_TREAD_
#ifndef _CURRENT_TREAD_
void CALLBACK SendAsyncProc(HWND, UINT, DWORD dwData, LRESULT lResult);
#endif

static const char txtHHApiWindow[] = "HH_API";
static const char txtSharedMem[] = "hh_share";
static const char txtSempahore[] = "hh_semaphore";

const int CB_SHARED_MEM = 8 * 1024;

PSTR    g_pszShare;
HANDLE  g_hSharedMemory;
HANDLE  g_hsemMemory;
HANDLE  g_hsemNavigate = NULL;
HWND    g_hwndApi;
BOOL    g_fThreadCall;
BOOL    g_fStandAlone = FALSE;  // no need for threading in standalone version
SHORT   g_tbRightMargin = 0;    // magrin on the right end of the tool bar for the office animation character
SHORT   g_tbLeftMargin  = 0;    //      "        left       "


static HANDLE hThrd;
static DWORD thrdID;

extern "C"
HWND WINAPI HtmlHelpW(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData)
{
    //--- Don't display wait cursor for HH_PRETRANSLATEMESSAGE message.
    if ( (uCommand == HH_PRETRANSLATEMESSAGE) || (uCommand == HH_PRETRANSLATEMESSAGE2) )
    {
        ASSERT(g_fStandAlone) ; // We have to be on same thread for this to work.
        return xHtmlHelpW(hwndCaller, pszFile, uCommand, dwData);
    }

    if(uCommand == HH_SET_QUERYSERVICE)
    {
       // see if we currently have an interface, if so, release it.
       //
       if(g_pExternalHostServiceProvider)
       {
          g_pExternalHostServiceProvider->Release();
          g_pExternalHostServiceProvider = 0;
       }
       
       if(dwData)
       {
          g_pExternalHostServiceProvider = (IServiceProvider*) dwData;
          g_pExternalHostServiceProvider->AddRef();
       }
       
       return hwndCaller;
    }

    CHourGlass hourglass;
    if (g_fStandAlone ||
        uCommand == HH_GET_WIN_TYPE ||
        uCommand == HH_SET_WIN_TYPE ||
        uCommand == HH_SET_GLOBAL_PROPERTY ||
        uCommand == HH_INITIALIZE ||
        uCommand == HH_UNINITIALIZE)
    {
        return xHtmlHelpW(hwndCaller, pszFile, uCommand, dwData);
    }

    if (!g_hwndApi)
    {
        ShCreateHHWindow();
    }

    if(uCommand == HH_DISPLAY_TOPIC || uCommand == HH_DISPLAY_TOC || uCommand == HH_CLOSE_ALL ||
       uCommand == HH_KEYWORD_LOOKUP || uCommand == HH_ALINK_LOOKUP)
    {
        WaitForNavigationComplete();
    }

    if (g_hwndApi)
    {
        HH_UNICODE_DATA data;
        data.hwndCaller = hwndCaller;
        data.pszFile = pszFile;
        data.uCommand = uCommand;
        data.dwData = dwData;
        g_fThreadCall = TRUE;
        return (HWND) SendMessage(g_hwndApi, WMP_HH_UNI_THREAD_API, (WPARAM) &data, 0);
    }
    else
    {
        //Reset the last error.
        if (uCommand != HH_GET_LAST_ERROR)
        {
            g_LastError.Reset() ;
        }
        return xHtmlHelpW(hwndCaller, pszFile, uCommand, dwData);
    }
}

extern "C"
HWND WINAPI HtmlHelpA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData)
{
    //--- Don't display wait cursor for HH_PRETRANSLATEMESSAGE message.
    if ( (uCommand == HH_PRETRANSLATEMESSAGE) || (uCommand == HH_PRETRANSLATEMESSAGE2) )
    {
        ASSERT(g_fStandAlone) ; // We have to be on same thread for this to work.
        return xHtmlHelpA(hwndCaller, pszFile, uCommand, dwData);
    }

    if(uCommand == HH_SET_QUERYSERVICE)
    {
       // see if we currently have an interface, if so, release it.
       //
       if(g_pExternalHostServiceProvider)
       {
          g_pExternalHostServiceProvider->Release();
          g_pExternalHostServiceProvider = 0;
       }
       
       if(dwData)
       {
          g_pExternalHostServiceProvider = (IServiceProvider*) dwData;
          g_pExternalHostServiceProvider->AddRef();
       }
       
       return hwndCaller;
    }

    CHourGlass hourglass;
    if (g_fStandAlone ||
        uCommand == HH_GET_WIN_TYPE ||
        uCommand == HH_SET_WIN_TYPE ||
        uCommand == HH_SET_GLOBAL_PROPERTY ||
        uCommand == HH_INITIALIZE ||
        uCommand == HH_UNINITIALIZE)
    {
        return xHtmlHelpA(hwndCaller, pszFile, uCommand, dwData);
    }

    if (!g_hwndApi)
    {
        ShCreateHHWindow();
    }

    if(uCommand == HH_DISPLAY_TOPIC || uCommand == HH_DISPLAY_TOC || uCommand == HH_CLOSE_ALL ||
       uCommand == HH_KEYWORD_LOOKUP || uCommand == HH_ALINK_LOOKUP)
    {
        WaitForNavigationComplete();
    }

    if (g_hwndApi)
    {
        HH_ANSI_DATA data;
        data.hwndCaller = /*GetDesktopWindow() ;*/ hwndCaller;
        data.pszFile = pszFile;
        data.uCommand = uCommand;
        data.dwData = dwData;
        g_fThreadCall = TRUE;
#ifdef _CURRENT_TREAD_
        return (HWND) SendMessage(g_hwndApi, WMP_HH_ANSI_THREAD_API, (WPARAM) &data, 0);
#else
        HWND hwndReturn = NULL;
        BOOL b = SendMessageCallback(   g_hwndApi, WMP_HH_ANSI_THREAD_API, (WPARAM) &data, 0,
                                        SendAsyncProc, reinterpret_cast<DWORD>(&hwndReturn));
        WaitForNavigationComplete() ;
        return hwndReturn ;
#endif

    }
    else
    {
        //Reset the last error.
        if (uCommand != HH_GET_LAST_ERROR)
        {
            g_LastError.Reset() ;
        }

        return xHtmlHelpA(hwndCaller, pszFile, uCommand, dwData);
    }
}

/*
* This window procedure is used to handle HtmlHelp API messages, and
* communication from individual HH windows
*/

static BOOL fForcedShutDown;

LRESULT WINAPI ApiWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT result;

    switch(msg) {
        case WM_CREATE:
            g_hwndApi = hwnd;
            return 0;

        case WMP_ANSI_API_CALL:
            {
                HH_ANSI_DATA* pData = (HH_ANSI_DATA*) g_pszShare;
                HH_WINTYPE* phhWinType;

                switch (pData->uCommand) {
                    case HH_GET_WIN_TYPE:
                        DBWIN("Shell HH_GET_WIN_TYPE");
                        result = (LRESULT) xHtmlHelpA(pData->hwndCaller,
                            g_pszShare + (UINT_PTR) pData->pszFile, pData->uCommand,
                            (DWORD_PTR) &phhWinType);
                        CopyMemory(pData, phhWinType, sizeof(HH_WINTYPE));
                        phhWinType = (HH_WINTYPE*) pData;

                        // BUGBUG: We don't copy the strings

                        phhWinType->pszType =
                        phhWinType->pszCaption =
                        phhWinType->pszToc =
                        phhWinType->pszIndex =
                        phhWinType->pszFile =
                        phhWinType->pszHome =
                        phhWinType->pszJump1 =
                        phhWinType->pszJump2 =
                        phhWinType->pszUrlJump1 =
                        phhWinType->pszUrlJump2 =
                            NULL;

                        // Note that the caller must call ReleaseSemaphore

                        return result;

                    case HH_SET_WIN_TYPE:
                        DBWIN("Shell HH_SET_WIN_TYPE");
                        phhWinType = (HH_WINTYPE*) ((PSTR) pData + pData->dwData);

                        // Change offsets to pointers

                        if (phhWinType->pszType)
                            phhWinType->pszType = (PSTR) pData + (UINT_PTR) phhWinType->pszType;
                        if (phhWinType->pszCaption)
                            phhWinType->pszCaption = (PSTR) pData + (UINT_PTR) phhWinType->pszCaption;
                        if (phhWinType->pszToc)
                            phhWinType->pszToc = (PSTR) pData + (UINT_PTR) phhWinType->pszToc;
                        if (phhWinType->pszIndex)
                            phhWinType->pszIndex = (PSTR) pData + (UINT_PTR) phhWinType->pszIndex;
                        if (phhWinType->pszFile)
                            phhWinType->pszFile = (PSTR) pData + (UINT_PTR) phhWinType->pszFile;
                        if (phhWinType->pszHome)
                            phhWinType->pszHome = (PSTR) pData + (UINT_PTR) phhWinType->pszHome;
                        if (phhWinType->pszJump1)
                            phhWinType->pszJump1 = (PSTR) pData + (UINT_PTR) phhWinType->pszJump1;
                        if (phhWinType->pszJump2)
                            phhWinType->pszJump2 = (PSTR) pData + (UINT_PTR) phhWinType->pszJump2;
                        if (phhWinType->pszUrlJump1)
                            phhWinType->pszUrlJump1 = (PSTR) pData + (UINT_PTR) phhWinType->pszUrlJump1;
                        if (phhWinType->pszUrlJump2)
                            phhWinType->pszUrlJump2 = (PSTR) pData + (UINT_PTR) phhWinType->pszUrlJump2;
                        break;

                    case HH_KEYWORD_LOOKUP:
                        {
                            DBWIN("Shell HH_KEYWORD_LOOKUP");
                            HH_AKLINK* phhLink = (HH_AKLINK*) pData;
                            if (phhLink->pszKeywords)
                                phhLink->pszKeywords = (PSTR) pData + (UINT_PTR) phhLink->pszKeywords;
                            if (phhLink->pszUrl)
                                phhLink->pszUrl = (PSTR) pData + (UINT_PTR) phhLink->pszUrl;
                            if (phhLink->pszMsgText)
                                phhLink->pszMsgText = (PSTR) pData + (UINT_PTR) phhLink->pszMsgText;
                            if (phhLink->pszMsgTitle)
                                phhLink->pszMsgTitle = (PSTR) pData + (UINT_PTR) phhLink->pszMsgTitle;
                            if (phhLink->pszWindow)
                                phhLink->pszWindow = (PSTR) pData + (UINT_PTR) phhLink->pszWindow;
                        }
                        break;

                    case HH_DISPLAY_TEXT_POPUP:
                        {
                            DBWIN("Shell HH_DISPLAY_TEXT_POPUP");
                            HH_POPUP* phhSrcPop = (HH_POPUP*) pData;
                            if (phhSrcPop->pszText)
                                phhSrcPop->pszText = (PSTR) pData + (UINT_PTR) phhSrcPop->pszText;
                            if (phhSrcPop->pszFont)
                                phhSrcPop->pszFont = (PSTR) pData + (UINT_PTR) phhSrcPop->pszFont;
                        }
                        break;

                    case HH_DISPLAY_TOPIC:
                        DBWIN("Shell HH_DISPLAY_TOPIC");
                        if (pData->dwData)
                            pData->dwData = (DWORD_PTR) ((PSTR) pData + pData->dwData);
                        break;

#ifdef _DEBUG
                    default:
                        DBWIN("Shell unsupported command");
                        break;
#endif
                }
                result = (LRESULT) xHtmlHelpA(pData->hwndCaller,
                    g_pszShare + (UINT_PTR) pData->pszFile, pData->uCommand,
                    pData->dwData);
                ReleaseSemaphore(g_hsemMemory, 1, NULL);
                return result;
            }

        case WMP_UNICODE_API_CALL:
            {
                HH_UNICODE_DATA* pData = (HH_UNICODE_DATA*) g_pszShare;
                if (pData->uCommand == HH_GET_WIN_TYPE) {
                    DBWIN("Shell UniCode command");
                    HH_WINTYPE* phhWinType;
                    result = (LRESULT) xHtmlHelpW(pData->hwndCaller, pData->pszFile, pData->uCommand,
                        (DWORD_PTR) &phhWinType);
                    CopyMemory(pData, phhWinType, sizeof(HH_WINTYPE));
                    phhWinType = (HH_WINTYPE*) pData;

                    // We don't copy the strings

                    phhWinType->pszType =
                    phhWinType->pszCaption =
                    phhWinType->pszToc =
                    phhWinType->pszIndex =
                    phhWinType->pszFile =
                    phhWinType->pszHome =
                    phhWinType->pszJump1 =
                    phhWinType->pszJump2 =
                    phhWinType->pszUrlJump1 =
                    phhWinType->pszUrlJump2 =
                        NULL;

                    // Note that the caller must call ReleaseSemaphore

                    return result;
                }
#ifdef _DEBUG
                else {
                    DBWIN("Shell unsupported UniCode command");
                }
#endif
                result = (LRESULT) xHtmlHelpW(pData->hwndCaller, pData->pszFile, pData->uCommand,
                    pData->dwData);
                ReleaseSemaphore(g_hsemMemory, 1, NULL);
                return result;
            }

        case WMP_HH_WIN_CLOSING:
            if (!fForcedShutDown)
            {
                for (int i = 0; i < g_cWindowSlots; i++) {
                    if (pahwnd[i] != NULL)
                        return 0;
                }

                // If we get here, all our windows are closed -- time to
                // shut down.

                FlushMessageQueue();
                DeleteAllHmData();
                g_hwndApi = NULL;
                PostQuitMessage(0);
                break;
            }

        // Use this message to forceably shut down HH

        case WMP_FORCE_HH_API_CLOSE:
            {
                fForcedShutDown = TRUE;
                for (int i = 0; i < g_cWindowSlots; i++) {
                    if (pahwnd[i] != NULL)
                        SendMessage(*pahwnd[i], WM_CLOSE, 0, 0);
                }
                FlushMessageQueue();
                DeleteAllHmData();
                g_hwndApi = NULL;
                PostQuitMessage(0);
                break;
            }

        case WMP_HH_ANSI_THREAD_API:
            {
                HH_ANSI_DATA* pData = (HH_ANSI_DATA*) wParam;

                //Reset the last error.
                if (pData->uCommand != HH_GET_LAST_ERROR)
                {
                    g_LastError.Reset() ;
                }

                DBWIN("Threaded ANSI call");
                return (LRESULT) xHtmlHelpA(pData->hwndCaller, pData->pszFile,
                    pData->uCommand, pData->dwData);
            }

        case WMP_HH_UNI_THREAD_API:
            {
                HH_UNICODE_DATA* pData = (HH_UNICODE_DATA*) wParam;

                //Reset the last error, unless we are trying to get the last error.
                if (pData->uCommand != HH_GET_LAST_ERROR)
                {
                    g_LastError.Reset() ;
                }

                DBWIN("Threaded Unicode call");
                return (LRESULT) xHtmlHelpW(pData->hwndCaller, pData->pszFile,
                    pData->uCommand, pData->dwData);
            }

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

static void FlushMessageQueue(UINT msgEnd)
{
    MSG msg;

    while (PeekMessage(&msg, NULL, 0, msgEnd, PM_REMOVE)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

extern "C"
DWORD WINAPI HhWindowThread(LPVOID pParam)
{
#ifdef _DEBUG
    _CrtMemState m_MemState ;
    _CrtMemCheckpoint(&m_MemState) ;
#endif

    static BOOL fRegistered = FALSE;
    if (!fRegistered) {
        fRegistered = TRUE;
        WNDCLASS wc;

        ZeroMemory(&wc, sizeof(WNDCLASS));  // clear all members

        wc.lpfnWndProc = ApiWndProc;
        wc.hInstance = _Module.GetModuleInstance();
        wc.lpszClassName = txtHHApiWindow;

        VERIFY(RegisterClass(&wc));
    }

    g_hSharedMemory = CreateFileMapping((HANDLE) -1, NULL, PAGE_READWRITE, 0,
        CB_SHARED_MEM, txtSharedMem);
    if (!g_hSharedMemory) {
        hThrd = NULL;
        if (g_hsemMemory)
            ReleaseSemaphore(g_hsemMemory, 1, NULL);
        return 0;
    }
    g_pszShare = (PSTR) MapViewOfFile(g_hSharedMemory, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
    if (!g_hsemMemory)
        g_hsemMemory = CreateSemaphore(NULL, 1, 9999, txtSempahore);

    g_hwndApi = CreateWindow(txtHHApiWindow, "", WS_OVERLAPPED, 0, 0, 0, 0, NULL,
        NULL, _Module.GetModuleInstance(), NULL);
    OleInitialize(NULL);
    ReleaseSemaphore(g_hsemMemory, 1, NULL);

    AWMessagePump(g_hwndApi);
    g_hwndApi = NULL;

    if (g_hSharedMemory)
        CloseHandle(g_hSharedMemory);
    OleUninitialize();

#ifdef _DEBUG
    _CrtMemDumpAllObjectsSince(&m_MemState) ;
#endif

    // If we are launched from the shell, we should tell the shell to unload
    // our dll.

    hThrd = NULL;
    return 0;
}

extern "C"
HANDLE WINAPI ShCreateHHWindow(void)
{
    if (!hThrd) {
        if (!g_hsemMemory)
            g_hsemMemory = CreateSemaphore(NULL, 1, 9999, txtSempahore);
        // Signal the semaphore. The thread will release it
#ifdef _CURRENT_TREAD_
        WaitForSingleObject(g_hsemMemory, INFINITE);
#else
        AtlWaitWithMessageLoop(g_hsemNavigate) ;
#endif

        hThrd = CreateThread(NULL, 0, &HhWindowThread, NULL,
            0, &thrdID);
        SetThreadPriority(hThrd, THREAD_PRIORITY_NORMAL);

        // wait for the thread to release the semaphore

#ifdef _CURRENT_TREAD_
        WaitForSingleObject(g_hsemMemory, INFINITE);
#else
        AtlWaitWithMessageLoop(g_hsemNavigate) ;
#endif

        /*
         * Clear the signaled state now that we know the thread has
         * created its window
         */

        ReleaseSemaphore(g_hsemMemory, 1, NULL);

        CloseHandle( hThrd );
    }
    return hThrd;
}

void WaitForNavigationComplete()
{
    // Create unnamed semaphore (if it doesn't exist)
    //
    if (!g_hsemNavigate)
        g_hsemNavigate = CreateSemaphore(NULL, 1, 1, NULL);

    // Wait for previous navigation to reach BEFORENAVIGATE stage.
    // Time-out after 1000ms just in case the previous navigation
    // halted for some reason (don't want to wait here forever!).
    //
#ifdef _CURRENT_TREAD_
    DWORD dwResult = WaitForSingleObject(g_hsemNavigate, 1000);
#else
    AtlWaitWithMessageLoop(g_hsemNavigate) ;
#endif

//  if(dwResult == WAIT_TIMEOUT)
//      MessageBox(NULL,"Wait for navigation semaphore timed out.","Notice!",MB_OK);
}


//////////////////////////////////////////////////////////////////
//
//
//
#ifndef _CURRENT_TREAD_
void CALLBACK SendAsyncProc(HWND, UINT, DWORD dwData, LRESULT lResult)
{
    HWND* pWnd = reinterpret_cast<HWND*>(dwData) ;
    HWND hWnd = reinterpret_cast<HWND>(lResult) ;
    *pWnd = hWnd ;
}
#endif
//////////////////////////////////////////////////////////////////
//
// Handles pretranslating messages for HH.
//
BOOL hhPreTranslateMessage(MSG* pMsg, HWND hWndCaller /* = NULL*/ )
{
    // REVIEW: Performance
    BOOL bReturn = false ;
    if (pMsg && IsWindow(pMsg->hwnd))
    {
        CHHWinType* phh;
 
        if ( hWndCaller )
           phh = FindHHWindowIndex(hWndCaller);
        else
           phh = FindHHWindowIndex(pMsg->hwnd);

        if (phh && phh->m_pCIExpContainer)
        {

            unsigned uiResult = phh->m_pCIExpContainer->TranslateMessage(pMsg);
            if ( uiResult == TAMSG_NOT_IE_ACCEL )
            {
                if ((pMsg->message == WM_SYSKEYDOWN) && (pMsg->wParam == VK_MENU))
                {
                    UiStateChangeOnAlt(pMsg->hwnd) ;
                }
                if ((pMsg->message == WM_KEYDOWN) && (pMsg->wParam == VK_TAB))
                {
                    UiStateChangeOnTab(pMsg->hwnd) ;
                }

                if (phh->DynamicTranslateAccelerator(pMsg))
                {
                   bReturn = true ;
                }
            }
            else
            {
                //TAMSG_TAKE_FOCUS is obsolete. Don't worry about.
                bReturn = true ;
            }
        }
    }

    return bReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhsyssrt.cpp ===
/*************************************************************************
*  @doc SHROOM EXTERNAL API
*
*  HHSYSSRT.CPP
*
*  Copyright (C) Microsoft Corporation 1997
*  All Rights reserved.
*
*  This file contains the implementation of CHHSysSort methods.
*  CHHSysSort is a pluggable sort object that uses the system's
*  CompareString function to do comparisons.  CHHSysSort supports
*  NULL terminated strings that are either Unicode or ANSI.
*
**************************************************************************
*
*  Written By   : Bill Aloof modified by Paul Tissue
*  Current Owner: PaulTi
*
**************************************************************************/

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

#include "header.h"

#include "atlinc.h"     // includes for ATL.

#include "iterror.h"
#include "itSort.h"
#include "itSortid.h"

#include "hhsyssrt.h"
#include "animate.h"

#ifndef ITWW_CBKEY_MAX  //defined in itww.h
  #define ITWW_CBKEY_MAX 1024 
#endif

#ifndef ITWW_CBREC_MAX  // itww.h does not define this
  #define ITWW_CBREC_MAX 8
#endif

#define HHWW_MAX_KEYWORD_OBJECT_SIZE       (ITWW_CBKEY_MAX-ITWW_CBREC_MAX)
#define HHWW_MAX_KEYWORD_LENGTH            (((HHWW_MAX_KEYWORD_OBJECT_SIZE-sizeof(HHKEYINFO)-sizeof(DWORD))/sizeof(WCHAR))-sizeof(WCHAR))

#ifdef _DEBUG
static BOOL g_bShowMessage = TRUE;
#endif

inline int __cdecl my_wcslen( const WCHAR* p ) { const WCHAR* pwz=p; while(*pwz++); return (int)(pwz-p-1); }
inline WCHAR* __cdecl my_wcscpy( WCHAR* pdst, const WCHAR* psrc ) { WCHAR* pwz=pdst; while(*pwz++=*psrc++); return(pdst); }

//---------------------------------------------------------------------------
// Constructor and Destructor
//---------------------------------------------------------------------------

CHHSysSort::CHHSysSort()
{
  OSVERSIONINFO   osvi;

  m_fInitialized = m_fDirty = FALSE;
  memset(&m_srtctl, NULL, sizeof(SRTCTL));
  m_hmemAnsi1 = m_hmemAnsi2 = NULL;
  m_cbBufAnsi1Cur = m_cbBufAnsi2Cur = 0;

  // See if we're running on NT; if GetVersionEx fails, we'll assume
  // we're not since that's causes us do take the more conservative route
  // when doing comparisons.
  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
  m_fWinNT = (GetVersionEx(&osvi) ?
                                  (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) : FALSE);

  //MessageBox( GetActiveWindow(), "Creating HTML Help sort object!", "HHSort Module", MB_OK | MB_SETFOREGROUND | MB_SYSTEMMODAL );
}

CHHSysSort::~CHHSysSort()
{
  Close();

  //MessageBox( GetActiveWindow(), "Destroying HTML Help sort object!", "HHSort Module", MB_OK | MB_SETFOREGROUND | MB_SYSTEMMODAL );
}

//---------------------------------------------------------------------------
// IHHSortKey Method Implementations
//---------------------------------------------------------------------------

#pragma optimize( "agtw", on )

/********************************************************************
 * @method STDMETHODIMP | IHHSortKey | GetSize |
 *         Determines the size of a key.
 * @parm LPCVOID* | pvKey | Pointer to key
 * @parm DWORD* | pcbSize | Out param containing key size.
 *
 * @rvalue E_POINTER | pvKey or pcbSize was NULL
 *
 ********************************************************************/
STDMETHODIMP
CHHSysSort::GetSize(LPCVOID pvKey, DWORD* pcbSize)
{
  if (pvKey == NULL || pcbSize == NULL)
    return ((E_POINTER));

  if (!m_fInitialized)
    return ((E_NOTOPEN));

  *pcbSize = sizeof(WCHAR) * (my_wcslen((WCHAR *)pvKey) + 1);
  DWORD dwLength = *pcbSize;

  // now add our info struct size
  *pcbSize += sizeof(HHKEYINFO);

  HHKEYINFO* pInfo = (HHKEYINFO*)(((DWORD_PTR)(pvKey))+dwLength);

  // now add the size representing the SeeAlso
  if( (pInfo->wFlags) & HHWW_SEEALSO ) {
    *pcbSize += sizeof(WCHAR) * (my_wcslen((WCHAR *)(((DWORD_PTR)pvKey)+*pcbSize)) + 1);
  }
  // now add the size representing the UIDs
  else if( !((pInfo->wFlags) & HHWW_UID_OVERFLOW) && pInfo->dwCount ) {
    *pcbSize += pInfo->dwCount*sizeof(DWORD);
  }

#ifdef _DEBUG
  // if we get a keyword object that is too big then lets truncate it and 
  // lie to Centaur and say every thing is OK (otherwise Centaur will fault!).
  if( *pcbSize > HHWW_MAX_KEYWORD_OBJECT_SIZE ) {
    if( g_bShowMessage ) {
      TCHAR szKeyword[1024];
      WideCharToMultiByte(m_srtctl.dwCodePageID, NULL,
          (PCWSTR) pvKey, wcslen((PCWSTR)pvKey)+1, szKeyword, 1024, NULL, NULL);
      TCHAR szMsg[4096];
      wsprintf( szMsg, "The keyword \"%s\" contains too many hits.  Centaur will crash now!", szKeyword );
      strcat( szMsg, "\n\nPress 'OK' to continue or 'Cancel' to disable this warning.");
      int iReturn = MsgBox( szMsg, MB_OKCANCEL | MB_SETFOREGROUND | MB_SYSTEMMODAL );
      if( iReturn == IDCANCEL )
        g_bShowMessage = FALSE;
    }
    return E_UNEXPECTED;
  }
#endif

  return (S_OK);
}

#pragma optimize( "", off )

#pragma optimize( "agtw", on )

/********************************************************************
 * @method        STDMETHODIMP | IITSortKey | Compare |
 * Compares two keys and returns information about their sort order.
 *
 * @parm LPCVOID | pvKey1 | Pointer to a key.
 * @parm LPCVOID | pvKey2 | Pointer to a key.
 * @parm LONG* | plResult | (out) Indicates whether pvKey1 is less than, equal to, or
 * greater than pvKey2.
 * @parm DWORD* | pgrfReason | (out) Provides additional information about
 *      the comparison (see comments below).
 *
 * @rvalue E_POINTER | Either pvKey1, pvKey2, or *plResult was NULL
 *
 * @comm
 * On exit, *plResult is set according to strcmp conventions:
 *      <lt> 0, = 0, <gt> 0, depending on whether pvKey1 is less than, equal to, or
 * greater than pvKey2.  If pgrfReason is not NULL, *pgrfReason may be
 * filled in on exit with one or more bit flags giving more information about
 * the result of the comparison, if the result was affected by something other
 * than raw lexical comparison (such as special character mappings).  If
 * *pgrfReason contains 0 on exit, that means the comparison result
 * was purely lexical; if *pgrfReason contains IITSK_COMPREASON_UNKNOWN,
 * then the sort object implementation wasn't able to provide additional
 * information about the comparison result.
 *
 ********************************************************************/
STDMETHODIMP
CHHSysSort::Compare(LPCVOID pvKey1, LPCVOID pvKey2, LONG* plResult,
                    DWORD* pgrfReason)
{
  HRESULT hr = S_OK;
  LONG    lResult;

  if (pvKey1 == NULL || pvKey2 == NULL || plResult == NULL)
    return ((E_POINTER));

  if (!m_fInitialized)
    return ((E_NOTOPEN));

  // for leveling to work, we must take leveling into consideration
  // so that "heading" keywords get sorted just above the associated
  // leveled keywords.
  //
  // for example:
  //
  // Security
  //   rights
  //     Admins
  //     Users
  //   token
  // Security Zones
  // Security, rights of Administrators
  //
  // is actually (word sorted as):
  //
  // Security
  // Security Zones
  // Security, rights
  // Security, rights, Admins
  // Security, rights, Users

  // Security, token
  //
  // but we want it to be:
  //
  // Security
  // Security, rights
  // Security, rights, Admins
  // Security, rights, Users
  // Security, token
  // Security Zones
  //
  // and we want to ignore tilde and underscore prefixing
  // for root level keywords


  // check if we need to do a new sort
  if( m_srtctl.dwKeyType == IHHSK100_KEYTYPE_UNICODE_SZ ) {

    // make copies of the keywords and substitute a space+space
    // for each comma+space delimiter pair
    //
    // note, work backward in the list and only substitute
    // in the same number has levels we have for the keyword

    int iChar;

    // keyword #1
    WCHAR wszKey1[HHWW_MAX_KEYWORD_LENGTH+1];
    my_wcscpy( (PWSTR) wszKey1, (PCWSTR) pvKey1 );
    PCWSTR pwszKey1 = wszKey1;
    int iLen1 = my_wcslen( pwszKey1 );
    DWORD dwLevel1 = *((DWORD*)(((DWORD_PTR)pvKey1)+(sizeof(WCHAR)*(iLen1+1)))) >> 16;
    if( dwLevel1 ) { // leveled string?
      UNALIGNED DWORD* updw = ((DWORD*)(((DWORD_PTR)pvKey1)+((sizeof(WCHAR)*(iLen1+1))+sizeof(DWORD))));
      int iOffset =(int)(*updw);
      DWORD dwCount = 0;
      for( iChar = iOffset; iChar > 0; iChar-- ) {
        if( wszKey1[iChar] == L' ' ) {
          if( ((iChar-1) > 0) && (wszKey1[iChar-1] == L',') ) {
            wszKey1[iChar]   = L' ';
            wszKey1[iChar-1] = L' ';
            if( ++dwCount == dwLevel1 )
              break;
          }
        }
      }
    }

    // keyword #2
    WCHAR wszKey2[HHWW_MAX_KEYWORD_LENGTH+1];
    my_wcscpy( (PWSTR) wszKey2, (PCWSTR) pvKey2 );
    PCWSTR pwszKey2 = wszKey2;
    int iLen2 = my_wcslen( pwszKey2 );
    DWORD dwLevel2 = *((DWORD*)(((DWORD_PTR)pvKey2)+(sizeof(WCHAR)*(iLen2+1)))) >> 16;
    if( dwLevel2 ) { // leveled string?
      UNALIGNED DWORD* updw = (DWORD*)(((DWORD_PTR)pvKey2) + ((sizeof(WCHAR)*(iLen2+1))+sizeof(DWORD)));
      int iOffset =(int)(*updw);
      DWORD dwCount = 0;
      iChar = iOffset;
      while (iChar > 0)
      {
         iChar--;
      }

      for( iChar = iOffset; iChar > 0; iChar-- ) {
        if( wszKey2[iChar] == L' ' ) {
          if( ((iChar-1) > 0) && (wszKey2[iChar-1] == L',') ) {
            wszKey2[iChar]   = L' ';
            wszKey2[iChar-1] = L' ';
            if( ++dwCount == dwLevel2 )
              break;
          }
        }
      }
    }

    // determine number of special char prefixes

    // keyword #1
    WCHAR  wszPrefix1[HHWW_MAX_KEYWORD_LENGTH+1];
    int iSpecialChars1 = 0;  // a value of -1 means all chars are special
    for( iChar = 0; iChar < iLen1; iChar++ ) {
      if( ( (*pwszKey1) == L'_') || ( (*pwszKey1) == L'~') ) {
        wszPrefix1[iChar] = *pwszKey1;
        iSpecialChars1++;
        pwszKey1++;
      }
      else
        break;
    }
    wszPrefix1[iSpecialChars1] = L'\0';
    if( iChar == iLen1 ) {
      iSpecialChars1 = -1;
    }

    // keyword #2
    WCHAR  wszPrefix2[HHWW_MAX_KEYWORD_LENGTH+1];
    int iSpecialChars2 = 0;  // a value of -1 means all chars are special
    for( iChar = 0; iChar < iLen2; iChar++ ) {
      if( ( (*pwszKey2) == L'_') || ( (*pwszKey2) == L'~') ) {
        wszPrefix2[iChar] = *pwszKey2;
        iSpecialChars2++;
        pwszKey2++;
      }
      else
        break;
    }
    wszPrefix2[iSpecialChars2] = L'\0';
    if( iChar == iLen2 ) {
      iSpecialChars2 = -1;
    }

    // if both of the keywords contains just special chars or
    // none of them contain special characters then we do a normal sort
    if( !( ((iSpecialChars1 == -1) && (iSpecialChars2 == -1)) ||
           ((!iSpecialChars1) && (!iSpecialChars2)) ) ) {

      // do a normal sort with the special characters ignored
      if( iSpecialChars1 == -1 )
        *plResult = -1;
      else if( iSpecialChars2 == -1 )
        *plResult = 1;
      else if( SUCCEEDED(hr = CompareSz(pwszKey1,
                                /*my_wcslen(pwszKey1)*/ (iSpecialChars1==-1)?0:iLen1-(int)((((DWORD_PTR)pwszKey1)-((DWORD_PTR)&wszKey1))/sizeof(WCHAR)),
                                pwszKey2,
                                /*my_wcslen(pwszKey2)*/ (iSpecialChars2==-1)?0:iLen2-(int)((((DWORD_PTR)pwszKey2)-((DWORD_PTR)&wszKey2))/sizeof(WCHAR)),
                                &lResult, TRUE)) ) {
        *plResult = lResult;

        // if identical then sort based on the prefixes
        if( lResult == 0 ) {

          // if both contain special prefixes then sort based on the prefixes
          if( iSpecialChars1 && iSpecialChars2 ) {
            if( SUCCEEDED(hr = CompareSz(wszPrefix1,
                                         /*my_wcslen(wszPrefix1)*/ (iSpecialChars1==-1)?(LONG)((((DWORD_PTR)pwszKey1)-((DWORD_PTR)&wszKey1))/sizeof(WCHAR)):iSpecialChars1,
                                         wszPrefix2,
                                         /*my_wcslen(wszPrefix2)*/ (iSpecialChars2==-1)?(LONG)((((DWORD_PTR)pwszKey2)-((DWORD_PTR)&wszKey2))/sizeof(WCHAR)):iSpecialChars2,
                                         &lResult, TRUE)) ) {
              *plResult = lResult;
            }
          }
          else if( iSpecialChars1 )
            *plResult = 1;
          else if( iSpecialChars2 )
            *plResult = -1;
          else
            *plResult = 0;
        }

        // verify that they do not differ by level alone
        // if they do differ then place the lowest level one last
        if( lResult == 0  ) {
          if( dwLevel1 > dwLevel2 )
            *plResult = -1;
          if( dwLevel1 < dwLevel2 )
            *plResult = 1;
        }

      }

      return (hr);
    }

    // normal sort
    if (SUCCEEDED(hr = CompareSz(wszKey1, iLen1, wszKey2, iLen2, &lResult, TRUE ) ) ) {
      *plResult = lResult;

      // verify that they do not differ by level alone
      // if they do differ then place the lowest level one last
      if( lResult == 0  ) {
        if( dwLevel1 > dwLevel2 )
          *plResult = -1;
        if( dwLevel1 < dwLevel2 )
          *plResult = 1;
      }

    }

    return (hr);
  }

  // normal sort
  if( SUCCEEDED(hr = CompareSz(pvKey1, -1, pvKey2, -1, &lResult, TRUE) ) )
  {
    // We can set the out params now that we know no error occurred.
    *plResult = lResult;
    if (pgrfReason != NULL)
      *pgrfReason = IITSK_COMPREASON_UNKNOWN;
  }
  else
  {
    // Some kind of unexpected error occurred.
    //SetErrCode(&hr, E_UNEXPECTED);
  }

  return (hr);
}

#pragma optimize( "", off )

/********************************************************************
 * @method        STDMETHODIMP | IITSortKey | IsRelated |
 * Compares two keys and returns information about their sort order.
 *
 * @parm LPCVOID | pvKey1 | Pointer to a key.
 * @parm LPCVOID | pvKey2 | Pointer to a key.
 * @parm DWORD | dwKeyRelation | Specifies the relationship to check.
 * Valid parameters are:  <nl>
 *                 IITSK_KEYRELATION_PREFIX     ((DWORD) 0) <nl>
 *                 IITSK_KEYRELATION_INFIX              ((DWORD) 1) <nl>
 *                 IITSK_KEYRELATION_SUFFIX     ((DWORD) 2) <nl>
 * @parm DWORD* | pgrfReason | (out) Provides additional information about
 *      the comparison.
 *
 * @rvalue S_OK | Indicates that pvKey1 is related to pvKey2 according to
 *      dwKeyRelation.
 * @rvalue S_FALSE | pvKey1 is not related to pvKey2.
 * @rvalue E_INVALIDARG | The value specified for dwKeyRelation is not supported.
 *
 * @comm
 *       If pgrfReason is not NULL, *pgrfReason will be filled in
 *       just as it would be by IITSortKey::Compare.
 *
 *
 ********************************************************************/
STDMETHODIMP
CHHSysSort::IsRelated(LPCVOID pvKey1, LPCVOID pvKey2, DWORD dwKeyRelation,
                      DWORD* pgrfReason)
{
  HRESULT hr;
  LONG    lResult;

  // We will let the first call to Compare catch any entry error
  // conditions because it checks for everything we would, except for
  // the type of key relation the caller is testing for.
  if (dwKeyRelation != IITSK_KEYRELATION_PREFIX)
    return ((E_INVALIDARG));

  if (SUCCEEDED(hr = Compare(pvKey1, pvKey2, &lResult, NULL)))
  {
    if (lResult < 0)
    {
      LONG    cchKey1;

      cchKey1 = my_wcslen((WCHAR *) pvKey1);

      if (SUCCEEDED(hr = CompareSz(pvKey1, cchKey1,
        pvKey2, cchKey1,
        &lResult, TRUE)))
      {
        hr = (lResult == 0 ? S_OK : S_FALSE);
      }
    }
    else
      hr = (lResult == 0 ? S_OK : S_FALSE);
  }

  if (SUCCEEDED(hr) && pgrfReason != NULL)
    *pgrfReason = IITSK_COMPREASON_UNKNOWN;

  return (hr);
}


/*****************************************************************
 *@method        STDMETHODIMP | IITSortKey | Convert |
 * Converts a key of one type into a key of another type.
 * @parm DWORD | dwKeyTypeIn | Type of input key
 * @parm LPCVOID | pvKeyIn | Pointer to input key
 * @parm DWORD | dwKeyTypeOut | Type to convert key to.
 * @parm LPCVOID | pvKeyOut | Pointer to buffer for output key.
 * @parm DWORD | *pcbSizeOut | Size of output buffer.
 *
 * @rvalue S_OK | The operation completed successfully.
 * @rvalue E_INVALIDARG | the specified conversion is not supported,
 *        for example, one or both of the REFGUID parameters is invalid.
 * @rvalue E_FAIL | the buffer pointed to by pvKeyOut was too small
 *      to hold the converted key.
 * @comm
 *       This is intended mainly for converting an uncompressed key
 *       into a compressed key, but a sort object is free to provide
 *       whatever conversion combinations it wants to.
 *       *pcbSizeOut should contain the size of the buffer pointed
 *       to by pvKeyOut.  To make sure the buffer size specified in
 *       *pcbSizeOut is adequate, pass 0 on entry.
 *
 *      @comm
 *      Not implemented yet.
 ****************************************************************/
STDMETHODIMP
CHHSysSort::Convert(DWORD dwKeyTypeIn, LPCVOID pvKeyIn,
                    DWORD dwKeyTypeOut, LPVOID pvKeyOut, DWORD* pcbSizeOut)
{
  if (!m_fInitialized)
    return ((E_NOTOPEN));

  return (E_NOTIMPL);
}

STDMETHODIMP
CHHSysSort::ResolveDuplicates( LPCVOID pvKey1, LPCVOID pvKey2,
         LPCVOID pvKeyOut, DWORD* pcbSizeOut)
{
  HRESULT hr = S_OK;

  NextAnimation();

  // get keyword 1 stuff
  int iLen1 = my_wcslen( (WCHAR*) pvKey1 );
  int iOffsetInfo1 = sizeof(WCHAR) * (iLen1+1);
  HHKEYINFO* pInfo1 = (HHKEYINFO*)(((DWORD_PTR)pvKey1)+iOffsetInfo1);
  int iOffsetURLIds1 = iOffsetInfo1 + sizeof(HHKEYINFO);

  // get keyword 2 stuff
  int iLen2 = my_wcslen( (WCHAR*) pvKey2 );
  int iOffsetInfo2 = sizeof(WCHAR) * (iLen2+1);
  HHKEYINFO* pInfo2 = (HHKEYINFO*)(((DWORD_PTR)pvKey2)+iOffsetInfo2);
  int iOffsetURLIds2 = iOffsetInfo2 + sizeof(HHKEYINFO);

  // copy the string (from the shortest or the first key)
  const WCHAR* pwszKeyOut = NULL;
  int iOffsetOut = 0;
  if( iOffsetInfo2 < iOffsetInfo1 ) {
    iOffsetOut = iOffsetInfo2;
    pwszKeyOut = (WCHAR*) pvKey2;
  }
  else {
    iOffsetOut = iOffsetInfo1;
    pwszKeyOut = (WCHAR*) pvKey1;
  }
  my_wcscpy( (WCHAR*) pvKeyOut, pwszKeyOut );

  // if either key has reached the maximum size or the other key is a
  // See Also, then return just that key and continue
  DWORD dwKey1URLIdsSize = ((pInfo1->wFlags) & HHWW_SEEALSO) ? 0 : ((pInfo1->dwCount)*sizeof(DWORD));
  DWORD dwKey2URLIdsSize = ((pInfo2->wFlags) & HHWW_SEEALSO) ? 0 : ((pInfo2->dwCount)*sizeof(DWORD));
  DWORD dwKey1Size = iOffsetInfo1 + sizeof(HHKEYINFO) + dwKey1URLIdsSize;
  DWORD dwKey2Size = iOffsetInfo2 + sizeof(HHKEYINFO) + dwKey2URLIdsSize;
  DWORD dwKeyOutSize = iOffsetOut + sizeof(HHKEYINFO) + dwKey1URLIdsSize + dwKey2URLIdsSize;

  // default largest stuff to key 1
  BOOL  bCopyLargest = FALSE;
  LPCVOID pvKeyLargest = pvKey1;
  HHKEYINFO* pInfoLargest = pInfo1;
  int iOffsetInfoLargest = iOffsetInfo1;
  int iOffsetURLIdsLargest = iOffsetURLIds1;

  // determine if any single key exceeds the max or if just one key is a see also
  DWORD dwTruncate = 0;
  if( (dwKey1Size >= HHWW_MAX_KEYWORD_OBJECT_SIZE) || ((pInfo2->wFlags) & HHWW_SEEALSO) ) {
    bCopyLargest = TRUE;
  }
  else if( (dwKey2Size >= HHWW_MAX_KEYWORD_OBJECT_SIZE) || ((pInfo1->wFlags) & HHWW_SEEALSO) ) {
    bCopyLargest = TRUE;
    pvKeyLargest = pvKey2;
    pInfoLargest = pInfo2;
    iOffsetInfoLargest = iOffsetInfo2;
    iOffsetURLIdsLargest = iOffsetURLIds2;
  }
  else if( dwKeyOutSize > HHWW_MAX_KEYWORD_OBJECT_SIZE ) {
    dwTruncate = ((dwKeyOutSize - HHWW_MAX_KEYWORD_OBJECT_SIZE) / sizeof(DWORD)) + ((dwKeyOutSize%sizeof(DWORD))?1:0);
  }

  // copy the info struct
  HHKEYINFO Info = *pInfoLargest;
  if( !bCopyLargest ) {
    Info.dwCount = pInfo1->dwCount + pInfo2->dwCount - dwTruncate;
  }
  if( (Info.wFlags) & HHWW_SEEALSO )
    Info.dwCount = 0; // reset the UID count if this is just a See Also
  *( (HHKEYINFO*)( ( (DWORD_PTR)pvKeyOut)+iOffsetOut) ) = Info;
  iOffsetOut += sizeof(Info);

  // append the UIDs
  if( !bCopyLargest ) {

    // add first set of UIDs
    DWORD dwCount = pInfo1->dwCount;
    if( dwCount > Info.dwCount ) {
      dwCount = Info.dwCount;
      dwTruncate = pInfo2->dwCount;
    }
    UNALIGNED DWORD* pdwURLId = (DWORD*)(((DWORD_PTR)pvKey1)+iOffsetURLIds1);
    for( int iURLId = 0; iURLId < (int) dwCount; iURLId++ ) {
      *((UNALIGNED DWORD*)(((DWORD_PTR)pvKeyOut)+iOffsetOut)) = *(pdwURLId+iURLId);
      iOffsetOut += sizeof(DWORD);
    }

    // add second set of UIDs
    dwCount = pInfo2->dwCount - dwTruncate;
    pdwURLId = (DWORD*)(((DWORD_PTR)pvKey2)+iOffsetURLIds2);
    for( iURLId = 0; iURLId < (int) dwCount; iURLId++ ) {
      *((UNALIGNED DWORD*)(((DWORD_PTR)pvKeyOut)+iOffsetOut)) = *(pdwURLId+iURLId);
      iOffsetOut += sizeof(DWORD);
    }

  }
  else { // copy largest 
  
    // if it is a See Also, then just store that
    if( (pInfoLargest->wFlags) & HHWW_SEEALSO ) {
      // we just need to copy the see also string and update the offset
      WCHAR* pwszSeeAlso = (WCHAR*)(((DWORD_PTR)pvKeyLargest)+iOffsetURLIdsLargest);
      int iLen = my_wcslen(pwszSeeAlso) + 1;
      for( int iChar = 0; iChar < iLen; iChar++ ) {
        *((WCHAR*)(((DWORD_PTR)pvKeyOut)+iOffsetOut)) = *((WCHAR*)(((DWORD_PTR)pwszSeeAlso)+(iChar*sizeof(WCHAR))));
        iOffsetOut += sizeof(WCHAR);
      }
    }
    else {  // otherwise, add the UIDs only
      DWORD dwCount = pInfoLargest->dwCount;
      UNALIGNED DWORD* pdwURLId = (DWORD*)(((DWORD_PTR)pvKeyLargest)+iOffsetURLIdsLargest);
      for( int iURLId = 0; iURLId < (int) dwCount; iURLId++ ) {
        *((UNALIGNED DWORD*)(((DWORD_PTR)pvKeyOut)+iOffsetOut)) = *(pdwURLId+iURLId);
        iOffsetOut += sizeof(DWORD);
      }
    }

  }

  *pcbSizeOut = iOffsetOut;

  return hr;
}

//---------------------------------------------------------------------------
// IHHSortKeyConfig Method Implementations
//---------------------------------------------------------------------------


/*******************************************************************
 * @method        STDMETHODIMP | IITSortKeyConfig | SetLocaleInfo |
 * Sets locale information to be used by the sort key interface.
 *
 * @parm DWORD | dwCodePageID | ANSI code page no. specified at build time.
 * @parm LCID | lcid | Win32 locale identifier specified at build time.
 *
 * @rvalue S_OK | The operation completed successfully.
 *
 ********************************************************************/
STDMETHODIMP
CHHSysSort::SetLocaleInfo(DWORD dwCodePageID, LCID lcid)
{
  if (!m_fInitialized)
    return ((E_NOTOPEN));

  m_cs.Lock();

  m_srtctl.dwCodePageID = dwCodePageID;
  m_srtctl.lcid = lcid;

  m_fDirty = TRUE;

  m_cs.Unlock();

  return (S_OK);
}


/*******************************************************************
 * @method        STDMETHODIMP | IITSortKeyConfig | GetLocaleInfo |
 * Retrieves locale information used by the sort key interface.
 *
 * @parm DWORD | dwCodePageID | ANSI code page no. specified at build time.
 * @parm LCID | lcid | Win32 locale identifier specified at build time.
 *
 * @rvalue E_POINTER | Either pdwCodePageID or plcid is NULL.
 * @rvalue E_NOTOPEN | (?) is not initialized.
 * @rvalue S_OK | The operation completed successfully.
 *
 ********************************************************************/
STDMETHODIMP
CHHSysSort::GetLocaleInfo(DWORD* pdwCodePageID, LCID* plcid)
{
  if (pdwCodePageID == NULL || plcid == NULL)
    return ((E_POINTER));

  if (!m_fInitialized)
    return ((E_NOTOPEN));

  m_cs.Lock();

  *pdwCodePageID = m_srtctl.dwCodePageID;
  *plcid = m_srtctl.lcid;

  m_cs.Unlock();

  return (S_OK);
}

/*******************************************************************
 * @method        STDMETHODIMP | IITSortKeyConfig | SetKeyType |
 * Sets the sort key type that the sort object expects to see in calls
 * that take keys as parameters (IITSortKey::GetSize, Compare, IsRelated).
 *
 * @parm DWORD | dwKeyType | Sort key type. Possible values are:
 *                      IITSK_KEYTYPE_UNICODE_SZ or IITSK_KEYTYPE_ANSI_SZ
 *
 * @rvalue S_OK | The sort key type was understood by the sort object.
 * @rvalue E_INVALIDARG | Invalid sort key type.
 *
 ********************************************************************/
STDMETHODIMP
CHHSysSort::SetKeyType(DWORD dwKeyType)
{
  if (!m_fInitialized)
    return ((E_NOTOPEN));

  switch (dwKeyType)
  {
    case IHHSK666_KEYTYPE_UNICODE_SZ:
    case IHHSK100_KEYTYPE_UNICODE_SZ:
      break;

    default:
      return ((E_INVALIDARG));
  };

  m_cs.Lock();

  m_srtctl.dwKeyType = dwKeyType;
  m_fDirty = TRUE;

  m_cs.Unlock();

  return (S_OK);
}


/*******************************************************************
 * @method        STDMETHODIMP | IITSortKeyConfig | GetKeyType |
 * Retrieves the sort key type that the sort object expects to see in calls
 * that take keys as parameters (IITSortKey::GetSize, Compare, IsRelated).
 *
 * @parm DWORD* | pdwKeyType | Pointer to the sort key type.
 *
 * @rvalue S_OK | The operation completed successfully.
 * @rvalue E_POINTER | The key type is null.
 *
 ********************************************************************/
STDMETHODIMP
CHHSysSort::GetKeyType(DWORD* pdwKeyType)
{
  if (pdwKeyType == NULL)
    return ((E_POINTER));

  if (!m_fInitialized)
    return ((E_NOTOPEN));

  *pdwKeyType = m_srtctl.dwKeyType;

  return (S_OK);
}


/*******************************************************************
 * @method        STDMETHODIMP | IITSortKeyConfig | SetControlInfo |
 * Sets data that controls how sort key comparisons are made.
 *
 * @parm DWORD | grfSortFlags | One or more of the following sort flags:<nl>
 * IITSKC_SORT_STRINGSORT        0x00001000       use string sort method  <nl>
 * IITSKC_NORM_IGNORECASE        0x00000001       ignore case  <nl>
 * IITSKC_NORM_IGNORENONSPACE    0x00000002       ignore nonspacing chars  <nl>
 * IITSKC_NORM_IGNORESYMBOLS     0x00000004       ignore symbols  <nl>
 * IITSKC_NORM_IGNOREKANATYPE    0x00010000       ignore kanatype  <nl>
 * IITSKC_NORM_IGNOREWIDTH       0x00020000       ignore width  <nl>
 *
 * @parm DWORD | dwReserved | Reserved for future use.
 *
 *
 ********************************************************************/
STDMETHODIMP
CHHSysSort::SetControlInfo(DWORD grfSortFlags, DWORD dwReserved)
{
  DWORD   grfFlagsUnsupported;

  if (!m_fInitialized)
    return ((E_NOTOPEN));

  grfFlagsUnsupported = ~(IITSKC_SORT_STRINGSORT |
                          IITSKC_NORM_IGNORECASE |
                          IITSKC_NORM_IGNORENONSPACE |
                          IITSKC_NORM_IGNORESYMBOLS |
                          IITSKC_NORM_IGNORESYMBOLS |
                          IITSKC_NORM_IGNOREKANATYPE |
                          IITSKC_NORM_IGNOREWIDTH);

  if ((grfSortFlags & grfFlagsUnsupported) != 0)
    return ((E_INVALIDARG));

  m_cs.Lock();

  m_srtctl.grfSortFlags = grfSortFlags;
  m_fDirty = TRUE;

  m_cs.Unlock();

  return (S_OK);
}


/*******************************************************************
 * @method        STDMETHODIMP | IITSortKeyConfig | GetControlInfo |
 * Retrieves data that controls how sort key comparisons are made.
 *
 * @parm DWORD* | pgrfSortFlags | Pointer to the sort key flags. See
 *       <om .SetControlInfo> for a list of valid flags.
 *
 * @parm DWORD* | pdwReserved | Reserved for future use.
 *
 *
 * @rvalue E_POINTER | The value pgrfSortFlags is NULL.
 * @rvalue S_OK | The operation completed successfully.
 *
 ********************************************************************/
STDMETHODIMP
CHHSysSort::GetControlInfo(DWORD* pgrfSortFlags, DWORD* pdwReserved)
{
  if (pgrfSortFlags == NULL)
    return ((E_POINTER));

  if (!m_fInitialized)
    return ((E_NOTOPEN));

  *pgrfSortFlags = m_srtctl.grfSortFlags;

  return (S_OK);
}


/*******************************************************************
 * @method        STDMETHODIMP | IITSortKeyConfig | LoadExternalSortData |
 *      Loads external sort data such as tables containing the relative
 *      sort order of specific characters for a textual key type, from the
 *      specified stream.
 *
 * @parm IStream* | pStream | Pointer to the external stream object
 *       from which to load data.
 * @parm DWORD | dwExtDataType | Describes the format of sort data.
 *
 * @comm
 * Although the format of the external sort data is entirely
 * implementation-specific, this interface provides a general type for
 * data that can be passed in dwExtDataType: IITWBC_EXTDATA_SORTTABLE   ((DWORD) 2).
 *
 * @comm
 * Not implemented yet.
 ********************************************************************/
STDMETHODIMP
CHHSysSort::LoadExternalSortData(IStream* pStream, DWORD dwExtDataType)
{
  if (!m_fInitialized)
    return ((E_NOTOPEN));

  return (E_NOTIMPL);
}


//---------------------------------------------------------------------------
// IPersistStreamInit Method Implementations
//---------------------------------------------------------------------------


STDMETHODIMP
CHHSysSort::GetClassID(CLSID* pclsid)
{
  if (pclsid == NULL)
    return ((E_POINTER));

  *pclsid = CLSID_HHSysSort;
  return (S_OK);
}


STDMETHODIMP
CHHSysSort::IsDirty(void)
{
  if (!m_fInitialized)
    return ((E_NOTOPEN));

  return (m_fDirty ? S_OK : S_FALSE);
}


STDMETHODIMP
CHHSysSort::Load(IStream* pStream)
{
  HRESULT hr;
  DWORD   dwVersion;
  DWORD   cbRead;

  if (pStream == NULL)
    return ((E_POINTER));

  // Lock before checking m_fInitialized to make sure we don't compete
  // with a call to ::InitNew.
  m_cs.Lock();

  if (m_fInitialized)
    return ((E_ALREADYOPEN));

  if (SUCCEEDED(hr = pStream->Read((LPVOID) &dwVersion, sizeof(DWORD), &cbRead)) &&
    SUCCEEDED(hr = ((cbRead == sizeof(DWORD)) ? S_OK : E_BADFORMAT)) &&
    SUCCEEDED(hr = ((dwVersion == HHSYSSORT_VERSION) ? S_OK : E_BADVERSION)) &&
    SUCCEEDED(hr = pStream->Read((LPVOID) &m_srtctl, sizeof(SRTCTL),  &cbRead)) &&
    SUCCEEDED(hr = ((cbRead == sizeof(SRTCTL)) ? S_OK : E_BADFORMAT)))
  {
    m_fInitialized = TRUE;
  }

  m_cs.Unlock();
  return (hr);
}


STDMETHODIMP
CHHSysSort::Save(IStream* pStream, BOOL fClearDirty)
{
  HRESULT hr;
  DWORD   dwVersion;
  DWORD   cbWritten;

  if (pStream == NULL)
    return ((E_POINTER));

  if (!m_fInitialized)
    return ((E_NOTOPEN));

  m_cs.Lock();

  dwVersion = HHSYSSORT_VERSION;
  if (SUCCEEDED(hr = pStream->Write((LPVOID) &dwVersion, sizeof(DWORD), &cbWritten)) &&
    SUCCEEDED(hr = pStream->Write((LPVOID) &m_srtctl, sizeof(SRTCTL), &cbWritten)) &&
    fClearDirty)
  {
    m_fDirty = FALSE;
  }

  m_cs.Unlock();

  return (hr);
}


STDMETHODIMP
CHHSysSort::GetSizeMax(ULARGE_INTEGER* pcbSizeMax)
{
  return (E_NOTIMPL);
}


STDMETHODIMP
CHHSysSort::InitNew(void)
{
  // Lock before checking m_fInitialized to make sure we don't compete
  // with a call to ::Load.
  m_cs.Lock();

  if (m_fInitialized)
    return ((E_ALREADYOPEN));

  m_srtctl.dwCodePageID = GetACP();
  m_srtctl.lcid = GetUserDefaultLCID();
  m_srtctl.dwKeyType = IHHSK100_KEYTYPE_UNICODE_SZ;

  // CompareString does word sort by default, but we have to
  // tell it to ignore case.
  m_srtctl.grfSortFlags = IITSKC_NORM_IGNORECASE;

  m_fInitialized = TRUE;

  m_cs.Unlock();
  return (S_OK);
}


//---------------------------------------------------------------------------
// Private Method Implementations
//---------------------------------------------------------------------------

#pragma optimize( "agtw", on )

// Compares either two Unicode strings or two Ansi strings, calling the
// appropriate variant of CompareString.  The cch params should denote
// count of characters, NOT bytes, not including a NULL terminator. -1
// is a valid value for the cch params, which means compare the strings
// until a NULL terminator is found.  If fUnicode is TRUE, this routine
// may decide to convert the string to Ansi before doing the compare if
// the system doesn't support CompareStringW.  The result of the
// comparison is returned in *plResult in strcmp-compatible form.
HRESULT
CHHSysSort::CompareSz(LPCVOID pvSz1, LONG cch1, LPCVOID pvSz2, LONG cch2,
                                                LONG* plResult, BOOL fUnicode)
{
  HRESULT hr = S_OK;
  LONG    lResult;
  BOOL    fAnsiCompare;
  SRTCTL  srtctl;
  PSTR   psz1 = NULL;
  PSTR   psz2 = NULL;

  m_cs.Lock();
  srtctl = m_srtctl;
  m_cs.Unlock();

  fAnsiCompare = !fUnicode || !m_fWinNT;

  // See if we need to convert from Unicode to ANSI.
  if (fAnsiCompare && fUnicode)
  {
    DWORD   cbAnsi1;
    DWORD   cbAnsi2;

    m_cs.Lock();

    if (cch1 < 0)
      hr = GetSize(pvSz1, &cbAnsi1);
    else
      // leave enough space for double byte chars in MBCS.
      cbAnsi1 = (cch1 + 1) * sizeof(WCHAR);

    if (cch2 < 0)
      hr = GetSize(pvSz2, &cbAnsi2);
    else
      // leave enough space for double byte chars in MBCS.
      cbAnsi2 = (cch2 + 1) * sizeof(WCHAR);

    if (SUCCEEDED(hr) &&
      SUCCEEDED(hr = ReallocBuffer(&m_hmemAnsi1, &m_cbBufAnsi1Cur, cbAnsi1)) &&
      SUCCEEDED(hr = ReallocBuffer(&m_hmemAnsi2, &m_cbBufAnsi2Cur, cbAnsi2)))
    {
      // We lock the ansi buffers here, but we won't unlock them
      // until the end of this routine so that we can pass them
      // to compare string.
      psz1 = (PSTR) GlobalLock(m_hmemAnsi1);
      psz2 = (PSTR) GlobalLock(m_hmemAnsi2);

      if ((cch1 = WideCharToMultiByte(srtctl.dwCodePageID, NULL,
        (PCWSTR) pvSz1, cch1, psz1, m_cbBufAnsi1Cur, NULL, NULL)) != 0 &&
        (cch2 = WideCharToMultiByte(srtctl.dwCodePageID, NULL,
        (PCWSTR) pvSz2, cch2, psz2, m_cbBufAnsi2Cur, NULL, NULL)) != 0)
      {
        // Set up for call to CompareStringA.
        psz1[cch1] = 0;
        psz2[cch2] = 0;
        pvSz1 = (LPCVOID) psz1;
        pvSz2 = (LPCVOID) psz2;
      }
      else
        hr = E_UNEXPECTED;
    }

  }

  if (SUCCEEDED(hr))
  {
    if (fAnsiCompare)
      lResult = CompareStringA(srtctl.lcid, srtctl.grfSortFlags,
                (PCSTR) pvSz1, cch1, (PCSTR) pvSz2, cch2);
    else
      lResult = CompareStringW(srtctl.lcid, srtctl.grfSortFlags,
                (PCWSTR) pvSz1, cch1, (PCWSTR) pvSz2, cch2);

    if (lResult == 0)
      // Some kind of unexpected error occurred.
      ; //SetErrCode(&hr, E_UNEXPECTED);
    else
      // We need to subtract 2 from the lResult to convert
      // it into a strcmp-compatible form.
      *plResult = lResult - 2;
  }

  if (psz1 != NULL)
    GlobalUnlock(m_hmemAnsi1);

  if (psz2 != NULL)
    GlobalUnlock(m_hmemAnsi2);

  if (fAnsiCompare && fUnicode)
    m_cs.Unlock();

  return (hr);
}

#pragma optimize( "", off )

/*************************************************************************
 * @doc    INTERNAL
 *
 * @func   HRESULT  | ReallocBufferHmem |
 *                 This function will reallocate or allocate anew a buffer of
 *                 requested size.
 *
 * @parm   HGLOBAL* | phmemBuf |
 *                 Pointer to buffer handle; buffer handle can be NULL if
 *                 a new buffer needs to be allocated.  New buffer handle
 *                 is returned through this param.
 *
 * @parm   DWORD* | pcbBufCur |
 *                 Current size of existing buffer, if any.  Should be
 *                 0 if *phmemBuf == 0.  New size is returned through
 *                 this param.
 *
 * @parm   DWORD | cbBufNew |
 *                 Current size of existing buffer, if any.  Should be
 *                 0 if *phmemBuf == 0.
 *
 * @rvalue E_POINTER | phmemBuf or pcbBufCur was NULL
 * @rvalue E_OUTOFMEMORY | Ran out of memory (re)allocating the buffer.
 *************************************************************************/
HRESULT ReallocBufferHmem(HGLOBAL* phmemBuf, DWORD* pcbBufCur,
                                                                                                                        DWORD cbBufNew)
{
  HRESULT hr = S_OK;

  if (phmemBuf == NULL || pcbBufCur == NULL)
    return (E_POINTER);

  // Need to make sure we have a buffer big enough to hold what the caller
  // needs to store.
  if (cbBufNew > *pcbBufCur)
  {
    HGLOBAL hmemNew;

    if (*phmemBuf == NULL)
      hmemNew = GlobalAlloc(GMEM_MOVEABLE, cbBufNew);
    else
      hmemNew = GlobalReAlloc(*phmemBuf, cbBufNew, GMEM_MOVEABLE);

    if (hmemNew != NULL)
    {
      // Do reassignment just in case the new hmem is different
      // than the old or if we just allocated a buffer for the
      // first time.
      *phmemBuf = hmemNew;
      *pcbBufCur = cbBufNew;
    }
    else
      // A pre-existing *phmemBuf is still valid;
      // we'll free it in Close().
      hr = E_OUTOFMEMORY;
  }

  return (hr);
}

HRESULT
CHHSysSort::ReallocBuffer(HGLOBAL* phmemBuf, DWORD* pcbBufCur, DWORD cbBufNew)
{
  HRESULT hr = S_OK;

  m_cs.Lock();
  hr = ReallocBufferHmem(phmemBuf, pcbBufCur, max(cbBufNew, cbAnsiBufInit));
  m_cs.Unlock();

  return (hr);
}

void
CHHSysSort::Close(void)
{
  if (m_hmemAnsi1 != NULL)
  {
    GlobalFree(m_hmemAnsi1);
    m_hmemAnsi1 = NULL;
    m_cbBufAnsi1Cur = 0;
  }

  if (m_hmemAnsi2 != NULL)
  {
    GlobalFree(m_hmemAnsi2);
    m_hmemAnsi2 = NULL;
    m_cbBufAnsi2Cur = 0;
  }

  memset(&m_srtctl, NULL, sizeof(SRTCTL));
  m_fInitialized = m_fDirty = FALSE;
}

#pragma optimize( "", off )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhsyssrt.h ===
// HHSYSSRT.H:  Definition of CHHSysSort sort object implementation.

#ifndef __HHSYSSRT_H__
#define __HHSYSSRT_H__

#define HHSYSSORT_VERSION        666
#define HHSYSSORT_VERSION_ID_STR "HHCtrl.SystemSort.666"
#define HHSYSSORT_ID_STR         "HHCtrl.SystemSort"

// New format
#define IHHSK100_KEYTYPE_ANSI_SZ    ((DWORD) 30) // NULL-term. MBCS string + extra data
#define IHHSK100_KEYTYPE_UNICODE_SZ ((DWORD) 31) // NULL-term. Unicode string + extra data

#if 0
// New format
#define IHHSK100_KEYTYPE_ANSI_SZ    ((DWORD) 10030) // NULL-term. MBCS string + extra data
#define IHHSK100_KEYTYPE_UNICODE_SZ ((DWORD) 10031) // NULL-term. Unicode string + extra data
#endif

// old format
#define IHHSK666_KEYTYPE_ANSI_SZ    ((DWORD) 66630) // NULL-term. MBCS string + extra data
#define IHHSK666_KEYTYPE_UNICODE_SZ ((DWORD) 66631) // NULL-term. Unicode string + extra data

// {4662dab0-d393-11d0-9a56-00c04fb68b66}
// HACKHACK: I simply changed the last value of CLSID_ITSysSort from 0xf7 to 0x66
DEFINE_GUID(CLSID_HHSysSort,
0x4662dab0, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0x66);

#if 0
// {adb880a5-d8ff-11cf-9377-00aa003b7a11}
DEFINE_GUID(CLSID_HHSysSort0,
0xadb880a5, 0xd8ff, 0x11cf, 0x93, 0x77, 0x00, 0xaa, 0x00, 0x3b, 0x7a, 0x11);
#endif

// the format of our sort key object is as follows:
//
//  + Null terminated MBCS string
//  + HHKEYINFO structure
//  + trailing UIDs (DWORD) or the SeeAlso string
//
//  If we overflow the buffer then the UIDs are stored in the occurence data and the
//  SeeAlso string stored as a property (STDPROP_USERPROP_BASE+1).

#ifndef HHWW_FONT
  #define HHWW_FONT             0x1 // bit 0
  #define HHWW_SEEALSO          0x2 // bit 1
  #define HHWW_UID_OVERFLOW     0x4 // bit 2
#endif

// Our sort key information struct
#pragma pack(push, 2)
typedef struct _hhkeyinfo
{
  WORD  wFlags; // indicates what data is stored with this keyword
  WORD  wLevel;
  DWORD dwLevelOffset;
  DWORD dwFont;
  DWORD dwCount; // number of UIDs that follow this structure in the sortkey
} HHKEYINFO;
#pragma pack(pop)

// Sort control structure that contains all the information that can
// vary how keys are compared.
typedef struct _srtctl
{
  DWORD   dwCodePageID;
  LCID    lcid;
  DWORD   dwKeyType;
  DWORD   grfSortFlags;
} SRTCTL;

class CHHSysSort :
  public IITSortKey,
  public IITSortKeyConfig,
  public IPersistStreamInit,
  public CComObjectRootEx<CComMultiThreadModel>,
  public CComCoClass<CHHSysSort,&CLSID_HHSysSort>
{
public:
  CHHSysSort();
  virtual ~CHHSysSort();

BEGIN_COM_MAP(CHHSysSort)
  COM_INTERFACE_ENTRY(IITSortKey)
  COM_INTERFACE_ENTRY(IITSortKeyConfig)
  COM_INTERFACE_ENTRY(IPersistStreamInit)
END_COM_MAP()

DECLARE_REGISTRY(CLSID_HHSysSort, HHSYSSORT_VERSION_ID_STR, HHSYSSORT_ID_STR, 0, THREADFLAGS_BOTH )

  // IHHSortKey methods
  STDMETHOD(GetSize)(LPCVOID pvKey, DWORD* pcbSize);
  STDMETHOD(Compare)(LPCVOID pvKey1, LPCVOID pvKey2,
                                          LONG* plResult, DWORD* pgrfReason);
  STDMETHOD(IsRelated)(LPCVOID pvKey1, LPCVOID pvKey2,
                                           DWORD dwKeyRelation, DWORD* pgrfReason);
  STDMETHOD(Convert)(DWORD dwKeyTypeIn, LPCVOID pvKeyIn,
                                          DWORD dwKeyTypeOut, LPVOID pvKeyOut,
                                          DWORD* pcbSizeOut);
  STDMETHOD(ResolveDuplicates)(LPCVOID pvKey1, LPCVOID pvKey2,
                                          LPCVOID pvKeyOut, DWORD* pcbSizeOut);

  // IHHSortKeyConfig methods
  STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid);
  STDMETHOD(GetLocaleInfo)(DWORD* pdwCodePageID, LCID* plcid);
  STDMETHOD(SetKeyType)(DWORD dwKeyType);
  STDMETHOD(GetKeyType)(DWORD* pdwKeyType);
  STDMETHOD(SetControlInfo)(DWORD grfSortFlags, DWORD dwReserved);
  STDMETHOD(GetControlInfo)(DWORD* pgrfSortFlags, DWORD* pdwReserved);
  STDMETHOD(LoadExternalSortData)(IStream* pStream, DWORD dwExtDataType);

  // IPersistStreamInit methods
  STDMETHOD(GetClassID)(CLSID* pclsid);
  STDMETHOD(IsDirty)(void);
  STDMETHOD(Load)(IStream* pStream);
  STDMETHOD(Save)(IStream* pStream, BOOL fClearDirty);
  STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbSizeMax);
  STDMETHOD(InitNew)(void);

private:
  // Private methods
  void    Close(void);
  HRESULT ReallocBuffer(HGLOBAL* phmemBuf, DWORD* cbBufCur, DWORD cbBufNew);
  HRESULT CompareSz(LPCVOID pvSz1, LONG cch1, LPCVOID pvSz2, LONG cch2,
                                                                                          LONG* plResult, BOOL fUnicode);
  // Private data members
  BOOL    m_fInitialized;
  BOOL    m_fDirty;
  BOOL    m_fWinNT;
  SRTCTL  m_srtctl;
  HGLOBAL m_hmemAnsi1, m_hmemAnsi2;
  DWORD   m_cbBufAnsi1Cur, m_cbBufAnsi2Cur;
  _ThreadModel::AutoCriticalSection m_cs;      // Critical section obj.
};

// Initial size of Ansi string buffers.
#define cbAnsiBufInit   256

#endif  // __HHSYSSRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\hhtypes.h ===
// hhtypes.h

#ifndef _HHTYPES_H
#define _HHTYPES_H

#include <wininet.h>

typedef DWORD INODE;

// Manifest constants and Enums

#define PAGE_SIZE  4096
#define NUM_IN_LOCATE_GROUP 4  // 100
#define MAX_URL INTERNET_MAX_URL_LENGTH

// CHM_SIGNATURE is the master CHM signature value
// (or internal CHM file format version if you will)
//
// hhw: all code that needs to set the file format version
// of the CMH should use this number to "stamp" a value in the CHM
// it is okay to stamp the CHM in several place just as long as
// we all stamp the same number
//
// hhctrl: all code that is specific to an CHM file format
// version should check at runtime this value against your
// specific stamp in the CHM and make sure that it is an
// exact match otherwise don't bother reading the CHM and just
// do not perform the requested feature (dislay an warning if you wish)
//
// Note: currently when the user tries to load the title via the TOC
// if CHM_SIGNATURE is not an exact match then we display an appropriate
// message and prevent the title from loading.  However, this doe not prevent
// the title from loading via another mechanism (such as F1 lookup jumps) unless
// that feature is coded to check this stamp (F1 lookups currently do).
//

#define FS_SIGNATURE     'M' << 24 | 'S' << 16 | 'F' << 7 | 'T'
#define CHM_SIGNATURE    0x0001

#define CACHE_CHM_FILES 3
#define VERSION_SYSTEM 3    // system file version

// TOC Node Flags
#define TOC_HAS_CHILDREN   0x00000001
#define TOC_NEW_NODE       0x00000002
#define TOC_FOLDER         0x00000004
#define TOC_TOPIC_NODE     0x00000008
#define TOC_NOLOCATION     0x00000010
#define TOC_CHM_ROOT       0x00000020
#define TOC_SS_LEAF        0x00000040
#define TOC_MERGED_REF     0x00000080
#define TOC_HAS_UNTYPED    0x00000100

// Topic Table entry flags.
#define F_TOPIC_FRAGMENT   0x0001
#define F_TOPIC_HASIPOS    0x0002    // Used at COMPILE time only! Has no meaning at runtime.
#define F_TOPIC_MULTI_REF  0x0004    // Used at COMPILE time only! Has no meaning at runtime.

//
// flags used in the flag word of the url tree chunklets.
//

#define F_URLC_LEAF     0x01
#define F_URLC_LEAF_HTM    0x02
#define F_URLC_HAS_KIDS    0x04
#define F_URLC_IS_FRAGMENT 0x08
#define F_URLC_IS_TOC_ITEM 0x10
#define F_URLC_IGNORE_URL  0x20
#define F_URLC_FILE_PROCESSED 0x40
#define F_URLC_KEEPER      0x80

// WARNING: Never, ever change the order of these enums or you break
// backwards compatibility

typedef enum {
    TAG_DEFAULT_TOC,        // needed if no window definitions
    TAG_DEFAULT_INDEX,      // needed if no window definitions
    TAG_DEFAULT_HTML,       // needed if no window definitions
    TAG_DEFAULT_CAPTION,    // needed if no window definitions
    TAG_SYSTEM_FLAGS,
    TAG_DEFAULT_WINDOW,
    TAG_SHORT_NAME,    // short name of title (ex. root filename)
    TAG_HASH_BINARY_INDEX,
    TAG_INFO_TYPES,
    TAG_COMPILER_VERSION,   // specifies the version of the compiler used
    TAG_TIME,               // the time the file was compiled
    TAG_HASH_BINARY_TOC,    // binary TOC
    TAG_INFOTYPE_COUNT,     // Total number if infotypes found in .chm
    TAG_IDXHEADER,          // Much of this is duplicate, used to live in it's own subile.
    TAG_EXT_TABS,           // extensible tabs
    TAG_INFO_TYPE_CHECKSUM,
    TAG_DEFAULT_FONT,       // font to use in all CHM-supplied UI
    TAG_NEVER_PROMPT_ON_MERGE, // never prompt during index merge
} SYSTEM_TAG_TYPE;

typedef enum {
    IT_INCLUSICE_TYPE,
    IT_EXCLUSIVE_TYPE,
    IT_HIDDEN_TYPE,
    IT_DESCRIPTION,
    IT_CATEGORY,
    IT_CAT_DESCRIPTION,
} SYSTEM_IT;

typedef enum
{
    SS_INCLUSIVE,
    SS_EXCLUSIVE,
} SUBSET_TYPES;

typedef enum {
    TAG_SUBSET_DEF,
} SUBSET_TAG_TYPE;

// Structs

#pragma pack(push, 2)

typedef struct {
    WORD tag;
    WORD cbTag;
} SYSTEM_TAG;

typedef struct {
    LCID     lcid;
    BOOL     fDBCS;  // Don't use bitflags! Can't assume byte-order
    BOOL     fFTI;   // full-text search enabled
    BOOL     fKeywordLinks;
    BOOL     fALinks;
    FILETIME FileTime; // title uniqueness (should match .chi file)
    BOOL     fDoSS;
    BOOL     fHasPreDefinedSS;
} SYSTEM_FLAGS;

typedef struct {
    DWORD idTopic;
    DWORD offUrl;   // actually, string table for now
} MAPPED_ID;

typedef struct {
    PCSTR pszProgId;
    PCSTR pszTabName;
} EXTENSIBLE_TAB;

typedef struct
{
    SUBSET_TYPES type;
    DWORD   dwStringSubSetName;
    DWORD   dwStringITName;
} SUBSET_DATA;

typedef struct {
    SYSTEM_IT type;
    DWORD     dwString;
} INFOTYPE_DATA;

#pragma pack(pop)

//
// Compiled sitemap goo.
//
typedef struct _tagSMI
{
   DWORD    dwOffsImageList;
   DWORD    dwCntImages;
   DWORD    dwfFolderImages;
   COLORREF clrBackground;
   COLORREF clrForeground;
   DWORD    dwOffsFont;
   DWORD    m_tvStyles;
   DWORD    m_exStyles;
   DWORD    dwOffsBackBitmap;
   DWORD    dwOffsFrameName;
   DWORD    dwOffsWindowName;
} SMI, *PSMI;

// Warning: If you add members to IDXHEADER they must be added before the dwOffsMergedTitle DWORD array and you
//          MUST adjust the padding of the struct. Note that the structure is padded out to one page.

typedef struct _tagIdxHeader
{
   DWORD  dwSignature;
   DWORD  dwTimeStamp;
   DWORD  dwReqVersion;
   DWORD  cTopics;
   DWORD  dwFlags;
   SMI    smi;                 // (S)ite (M)ap (I)nfo.
   DWORD  dwCntIT;             // Count of unique infotypes.
   DWORD  dwITWidth;           // The width in DWORDS of each infotype bit field.
   DWORD  dwCntMergedTitles;
   DWORD  dwOffsMergedTitles;                                    // Array of DWORDS which utilizes the padded area of this
   BYTE   pad[PAGE_SIZE - (sizeof(SMI) + (sizeof(DWORD) * 9))];  // struct. It must be the last defined item in the structure.
} IDXHEADER, *PIDXHEADER;

typedef struct _tagTOCIDX_HEADER
{
   DWORD    dwOffsRootNode;   // Offset to the root node of the TOC.
   DWORD    dwOffsGrpTbl;        // Offset to the beginning of the group table.
   DWORD    dwGrpCnt;             // Count of groups.
   DWORD    dwOffsTopicArray;    // Offset to beginning of topic array used to facilitate FTS and F1 lookup filtration based on runtime defined subsets.
} TOCIDX_HDR, *PTOCIDX_HDR;

typedef struct TOC_FolderNode
{
   WORD  wFontIdx;      // Index into a font table used to specify a particular facename, style and weight.
   WORD    wGrpIdx;     // Index into Group table. Facilitates runtime TOC subsetting.
   DWORD   dwFlags;     // Flag bits used to assign attributes to the node.
   DWORD   dwOffsTopic;    // Offset into the 0 to n linear topic array. if folder just offset to title
   DWORD   dwOffsParent;   // Offset to parent node.
   DWORD   dwOffsNext;     // Next sibling offset, needed only for non-leaves.
   DWORD   dwOffsChild;    // Child offset.
   DWORD   dwIT_Idx;       // !!<WARNING>!! This must remain the last member of this struct. Infotype index. Needed only on folders for TOC filtering.
} TOC_FOLDERNODE, *PTOC_FOLDERNODE;       // 28 bytes.


typedef struct TOC_LeafNode
{
   WORD  wFontIdx;      // Index into a font table used to specify a particular facename, style and weight.
   WORD    wGrpIdx;     // Index into Group table. Facilitates runtime TOC subsetting.
   DWORD   dwFlags;     // Flag bits used to assign attributes to the node.
   DWORD   dwOffsTopic;    // Offset into the 0 to n linear topic array. if folder just offset to title
   DWORD   dwOffsParent;   // Offset to parent node.
   DWORD   dwOffsNext;     // Next sibling offset.
} TOC_LEAFNODE, *PTOC_LEAFNODE;     // 20 bytes.


typedef struct _tag_TOC_Topic
{
   DWORD dwOffsTOC_Node;   // This is the "sync to information"
   DWORD dwOffsTitle;      // Offset to the title string.
   DWORD dwOffsURL;        // Offset to URL data for the topic.
   WORD  wFlags;           // 16 flags should be enough.
   WORD  wIT_Idx;          // InfoType index. !!<WARNING>!! This MUST be the last member of this struct!
} TOC_TOPIC, *PTOC_TOPIC;     // Size == 16 bytes.


typedef struct _tag_url_entry
{
   DWORD dwHash;        // Hashed URL value.
   DWORD dwTopicNumber;    // Index into topic array table, needed for sync.
   DWORD dwOffsURL;        // Offset into URL string data. Secondary URLs will be specified via DWORD that
                       // preceedes the primary URL which will indicate an offset to the secondary URL
                       // in the URL_STRINGS subfile. If the preceeding DOWRD in the URL_STRINGS
                       // subfile is NULL, no secondary URL exists.
} CURL, *PCURL;

// URL String data storage (URL_STRINGS):
//
// This will be the repository for all URL string data for a given title. In addition, this subfile will also
// contain references to secondary URLs.

typedef struct _tag_url_strings
{
   DWORD dwOffsSecondaryURL;  // Offset to the secondary URL. If NULL, no secondary URL exists.
   DWORD dwOffsFrameName;   // Offset to the optional frame name URL is to be displayed in. If NULL, Defualt frame is used.
   union
   {
      int   iPosURL;     // used at compile time only!
      char  szURL[4];       // Primary URL. NULL terminated string.
   };
} URLSTR, *PURLSTR;

// An array of these lives right after the topic array in the GRPINF subfile. the dwOffsGrpTable
// will get you to the array of these.
//
// DANGER Will Robinson --> Note that this struct is 16 bytes in size. Since out page size
//                   is divisable by 16 there is no code needed to assure that these
//                   don't cross page boundrys. If you change the size of this struct
//                   then you'll need to take care of page alignement problems.
//
typedef struct _GroupTable
{
   DWORD iNode;            // offset into node tree.
   DWORD dwID;          // Group identifier.
   DWORD dwOffsTopicArray; // Index into topic array. Indicates first topic of the group.
   DWORD dwTopicCount;     // Count of topics in the array.
} GRPTBL, *PGRPTBL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\highlite.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.
//
// HIGHLITE.H
//
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __HIGHLITE_H__
#define __HIGHLITE_H__

// Trident includes
//
#include <mshtml.h>
#include "web.h"

void DoF1Lookup(IWebBrowserAppImpl* pWBApp);
WCHAR * GetSelectionText(LPDISPATCH lpDispatch);

// CSearchHighlight class
//
class CSearchHighlight
{
public:
   CSearchHighlight(CExCollection *pTitleCollection);
   ~CSearchHighlight();
   void EnableHighlight(BOOL bStatus);
   HRESULT JumpFirst(void);
   HRESULT JumpNext(void);
   int HighlightDocument(LPDISPATCH lpDispatch);
   BOOL HighlightTerm(IHTMLDocument2* pHTMLDocument2, WCHAR *pTerm);
   WCHAR *m_pTermList;
   BOOL m_bHighlightEnabled;
protected:
   int m_iJumpIndex;
   BOOL m_Initialized;
   CExCollection *m_pTitleCollection;
};

#endif   // __HIGHLITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\highlite.cpp ===
// HIGHLITE.CPP : implementation file
//
// by DougO
//
#include "header.h"
#include "stdio.h"
#include "string.h"
#include "TCHAR.h"

//#include "cprint.h"
#include "secwin.h"
#include "contain.h"


#include "collect.h"
#include "hhtypes.h"
#include "toc.h"
#include "fts.h"

#include "highlite.h"

#include "hhctrl.h"

#define HIGHLIGHT_TIMEOUT 6000

/////////////////////////////////////////////////////////////////////////////
// CSearchHighlight HighlightTerm
//
BOOL CSearchHighlight::HighlightTerm(IHTMLDocument2* pHTMLDocument2, WCHAR *pTerm)
{
    HRESULT hr;

    if(!pTerm || !*pTerm)
        return FALSE;

    BSTR pSearchTerm = SysAllocString(pTerm);

    IHTMLBodyElement* pBodyElement;
    IHTMLElement *pElement;

    // get the document element from the document
    //
    if(FAILED(hr = pHTMLDocument2->get_body(&pElement)))
        return FALSE;

    if(FAILED(hr = pElement->QueryInterface(IID_IHTMLBodyElement, (void **)&pBodyElement)))
    {
        pElement->Release();
        return FALSE;
    }

    IHTMLTxtRange *pBeginRange = NULL;

    // Create the initial text range
    //
    if(FAILED(hr = pBodyElement->createTextRange(&pBeginRange)))
    {
        pBodyElement->Release();
        pElement->Release();
        return FALSE;
    }

    VARIANT_BOOL vbRet = VARIANT_TRUE;
    VARIANT_BOOL bUI = VARIANT_FALSE;
    VARIANT vBackColor, vForeColor;

    BSTR bstrCmd   = SysAllocString(L"BackColor");
    BSTR bstrCmd2   = SysAllocString(L"ForeColor");

    vBackColor.vt = vForeColor.vt =  VT_I4;
    vForeColor.lVal = GetSysColor(COLOR_HIGHLIGHTTEXT);
    vBackColor.lVal = GetSysColor(COLOR_HIGHLIGHT);

    long lret = 0;

    DWORD dwRet = TRUE;

    DWORD dwStartTickCount = GetTickCount();

    while(vbRet == VARIANT_TRUE)
    {
        if(FAILED(hr = pBeginRange->findText(pSearchTerm,1000000,2,&vbRet)))
            break;

        if(vbRet == VARIANT_TRUE)
        {
            if(FAILED(hr = pBeginRange->execCommand(bstrCmd2, VARIANT_FALSE, vForeColor, &bUI)))
         {
             dwRet = FALSE;
                break;
         }

         if(GetTickCount() > (dwStartTickCount + HIGHLIGHT_TIMEOUT))
         {
             dwRet = FALSE;
                break;
         }

            if(FAILED(hr = pBeginRange->execCommand(bstrCmd, VARIANT_FALSE, vBackColor, &bUI)))
         {
             dwRet = FALSE;
                break;
         }

         if(GetTickCount() > (dwStartTickCount + HIGHLIGHT_TIMEOUT))
         {
             dwRet = FALSE;
                break;
         }

            if(FAILED(hr = pBeginRange->collapse(FALSE)))
         {
             dwRet = FALSE;
                break;
         }

         if(GetTickCount() > (dwStartTickCount + HIGHLIGHT_TIMEOUT))
         {
             dwRet = FALSE;
                break;
         }
        }
    }

    SysFreeString(bstrCmd);
    SysFreeString(bstrCmd2);
    SysFreeString(pSearchTerm);

    pBodyElement->Release();
    pElement->Release();
    pBeginRange->Release();

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSearchHighlight
//
CSearchHighlight::CSearchHighlight(CExCollection *pTitleCollection)
{

    m_pTitleCollection = pTitleCollection;
    m_iJumpIndex = 0;
    m_pTermList = NULL;
    m_bHighlightEnabled = !g_fIE3;
    m_Initialized = TRUE;

}

/////////////////////////////////////////////////////////////////////////////
// CSearchHighlight constructor
//
CSearchHighlight::~CSearchHighlight()
{
}

/////////////////////////////////////////////////////////////////////////////
// CSearchHighlight HighlightDocument
//
int CSearchHighlight::HighlightDocument(LPDISPATCH lpDispatch)
{
    CHourGlass wait;

    if(!m_bHighlightEnabled)
        return FALSE;

    if ( lpDispatch != NULL )
    {
        // request the "document" object from the object
        //
        IHTMLDocument2* pHTMLDocument2;

        // If this fails, then we are probably running on IE3
        //
        if(FAILED(lpDispatch->QueryInterface(IID_IHTMLDocument2, (void **)&pHTMLDocument2)))
            return FALSE;

        int i, cTerms = m_pTitleCollection->m_pFullTextSearch->GetHLTermCount();

        DWORD dwStartTickCount = GetTickCount();

        for(i=0;i<cTerms;++i)
      {
            if(!HighlightTerm(pHTMLDocument2,m_pTitleCollection->m_pFullTextSearch->GetHLTermAt(i)))
         {
                pHTMLDocument2->Release();
             return TRUE;
         }

         if(GetTickCount() > (dwStartTickCount + HIGHLIGHT_TIMEOUT))
             break;
      }

        pHTMLDocument2->Release();
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSearchHighlight enable highlight
//
//  bStatus:
//              TRUE  = Highlighting Enabled
//              FALSE = Highlighting Disabled
//
void CSearchHighlight::EnableHighlight(BOOL bStatus)
{
    m_bHighlightEnabled = bStatus;
}

/////////////////////////////////////////////////////////////////////////////
// CSearchHighlight jump to first highlight term
//
HRESULT CSearchHighlight::JumpFirst(void)
{
    // DOUG TODO
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSearchHighlight jump to next highlight term
//
HRESULT CSearchHighlight::JumpNext(void)
{
    // DOUG TODO
    return S_OK;
}

// DoF1Lookup
//
// Get current selection in mshtml and perform a F1 lookup
//

void DoF1Lookup(IWebBrowserAppImpl* pWBApp)
{
   LPDISPATCH lpDispatch;

   if ( pWBApp && (lpDispatch = pWBApp->GetDocument()) )
   {
      WCHAR *pText = GetSelectionText(lpDispatch);
      if(pText)
      {
        char szTerm[512] = "";

        WideCharToMultiByte(CP_ACP, 0, pText, -1, szTerm, sizeof(szTerm), NULL, NULL);
        SysFreeString(pText);
        //
        // <mc> Find a CExCollection pointer...
        //
        CExCollection* pExCollection = NULL;
        CStr cstr;

        pWBApp->GetLocationURL(&cstr);
        pExCollection = GetCurrentCollection(NULL, (PCSTR)cstr);

        OnWordWheelLookup(szTerm, pExCollection);
      }
      lpDispatch->Release();
   }
}


WCHAR * GetSelectionText(LPDISPATCH lpDispatch)
{
    if(lpDispatch)
    {
        HRESULT hr;

        IHTMLSelectionObject *pSelection;

        // request the "document" object from the object
        //
        IHTMLDocument2* pHTMLDocument2;

        // If this fails, then we are probably running on IE3
        //
        if(FAILED(lpDispatch->QueryInterface(IID_IHTMLDocument2, (void **)&pHTMLDocument2)))
            return NULL;

        if(FAILED(hr = pHTMLDocument2->get_selection(&pSelection)))
        {
            pHTMLDocument2->Release();
            return NULL;
        }
        IHTMLTxtRange *pBeginRange = NULL;
        LPDISPATCH lpRangeDispatch;
        BSTR bstr = NULL;

        if ( (hr = pSelection->get_type( &bstr )) != S_OK )
        {
           pHTMLDocument2->Release();
           pSelection->Release();
           return NULL;
        }

        if( (bstr == NULL) || wcscmp(bstr,L"Text") )
        {
            pHTMLDocument2->Release();
            pSelection->Release();
            SysFreeString( bstr );
            return NULL;
        }
        SysFreeString( bstr );

        // Create the initial text range
        //
        if(FAILED(hr = pSelection->createRange(&lpRangeDispatch)))
        {
            pSelection->Release();
            pHTMLDocument2->Release();
            return NULL;
        }

        if(FAILED(lpRangeDispatch->QueryInterface(IID_IHTMLTxtRange, (void **)&pBeginRange)))
        {
            pSelection->Release();
            pHTMLDocument2->Release();
            return NULL;
        }

        BSTR pSelectedText;

        pBeginRange->get_text(&pSelectedText);

        pSelection->Release();
        pHTMLDocument2->Release();
        pBeginRange->Release();

        if(!pSelectedText)
            return NULL;

        if(*pSelectedText == NULL)
        {
            SysFreeString(pSelectedText);
            return NULL;
        }

        return pSelectedText;
    }
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\htmlhelp.cpp ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

#include "header.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

#include "strtable.h"
#include "hha_strtable.h"
#include "resource.h"
#include "contain.h"
#include "system.h"
#include "secwin.h"
#include "popup.h"
#include "highlite.h"

// Get hhPreTranslateMessage
#include "hhshell.h"

// Internal API definitions.
#include "hhpriv.h"

// HH_GET_LAST_ERROR support
#include "lasterr.h"

/////////////////////////////////////////////////////////////////////
//
// Internal function prototypes.
//
HWND ReactivateDisplayTopic(HWND hwndCaller, LPCSTR pszFile, DWORD_PTR dwData) ;
HWND InternalHelpContext(HWND hwndCaller, LPCSTR pszFile, DWORD_PTR id, HH_COLLECTION_CONTEXT* pContext);
HWND OnHelpContextInCollection(HWND hwndCaller, LPCSTR pszColFile, DWORD_PTR dwData);
bool SetGlobalProperty(HH_GLOBAL_PROPERTY* prop, CHHWinType*) ;
bool GetNameAndWinType(LPCSTR pszFile, CStr& pszName, CStr& pszWindow) ;
HWND OnReloadNavData(HWND hwndCaller, LPCSTR pszFile, HH_NAVDATA* pNavData) ;

bool GetBrowserInterface(HWND hWndBrowserParent, IDispatch** ppWebBrowser);

// Used by hh.cpp
bool InitializeSession(UNALIGNED DWORD_PTR* pCookie) ;
bool UninitializeSession(DWORD_PTR Cookie) ;
/////////////////////////////////////////////////////////////////////
//
// Constants
//
static const char txtWinHelpFileExt[] = ".hlp";
static const char txtForceWindowType[] = "$Lee";

// Pointer to global array of window types.

HWND xHtmlHelpW(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData)
{
    CStr cszFile;
    if (pszFile)
        cszFile = (WCHAR*) pszFile;

    switch (uCommand) {
        case HH_DISPLAY_TEXT_POPUP:
            {
                HH_POPUP* ppopup = (HH_POPUP*) dwData;
                CStr cszString;
                if (!ppopup->idString) {
                    cszString = (WCHAR*) ppopup->pszText;
                    ppopup->pszText = cszString.psz;
                }
                CStr cszFont;
                if (ppopup->pszFont) {
                    cszFont = (WCHAR*) ppopup->pszFont;
                    ppopup->pszFont = cszFont.psz;
                }

                return xHtmlHelpA(hwndCaller, cszFile, uCommand, dwData);
            }

        case HH_DISPLAY_INDEX:
        case HH_GET_WIN_HANDLE:
        case HH_DISPLAY_TOPIC:
            if (dwData && !IsBadReadPtr((LPCSTR) dwData, sizeof(LPCSTR))) {
                char szURL[MAX_PATH];
                szURL[WideCharToMultiByte(CP_ACP, 0,
                    (const WCHAR*) dwData, -1,
                    szURL, MAX_PATH, NULL, NULL)] = '\0';
                return xHtmlHelpA(hwndCaller, cszFile, uCommand, (DWORD_PTR) szURL);
            }
            else
                return xHtmlHelpA(hwndCaller, cszFile, uCommand, dwData);

        case HH_KEYWORD_LOOKUP:
            {
                HH_AKLINK* pakLink = (HH_AKLINK*) dwData;
                if (IsBadReadPtr(pakLink, sizeof(HH_AKLINK*)))
                    // BUGBUG: nag the help author
                    return NULL;
                pakLink->fReserved = TRUE;
                return xHtmlHelpA(hwndCaller, cszFile, uCommand, dwData);
            }

        case HH_SET_INFO_TYPE:
            {
                PHH_SET_INFOTYPE pSetInfoType = *(PHH_SET_INFOTYPE *)dwData;
                CStr cszType;
                CStr cszCat;
                if (*pSetInfoType->pszCatName != NULL) {
                    cszCat = (WCHAR*) pSetInfoType->pszCatName;
                    pSetInfoType->pszCatName = cszCat.psz;
                }
                if (*pSetInfoType->pszInfoTypeName != NULL) {
                    cszType = (WCHAR*) pSetInfoType->pszInfoTypeName;
                    pSetInfoType->pszInfoTypeName = cszType.psz;
                }
                return xHtmlHelpA(hwndCaller, cszFile, uCommand, dwData);
            }
        case HH_ENUM_INFO_TYPE:
            {
                PHH_ENUM_IT penumIT;

                penumIT = (PHH_ENUM_IT)(*(PHH_ENUM_IT*)dwData);
                HWND ret = xHtmlHelpA(hwndCaller, cszFile, uCommand, dwData);
                if ( ret != (HWND)-1 )
                {
                    CHmData* phmData = FindCurFileData( cszFile.psz);
                    if ( phmData == NULL )
                        return (HWND)-1;
                    phmData->PopulateUNICODETables();
                    penumIT->pszITName = phmData->m_ptblIT->GetPointer((int)(DWORD_PTR)ret);
                    penumIT->pszITDescription = phmData->m_ptblIT_Desc->GetPointer((int)(DWORD_PTR)ret);
                }
                return ret;
            }
        case HH_ENUM_CATEGORY:
            {
                PHH_ENUM_CAT penumCat;

                HWND ret = xHtmlHelpA(hwndCaller, cszFile, uCommand, dwData);
                if ( ret != (HWND)-1 )
                {
                    penumCat = *(PHH_ENUM_CAT*) dwData;

                    CHmData* phmData = FindCurFileData( cszFile.psz);
                    if ( phmData == NULL )
                        return (HWND)-1;
                    phmData->PopulateUNICODETables();
                    penumCat->pszCatName = phmData->m_ptblCat->GetPointer((int)(DWORD_PTR)ret+1);
                    penumCat->pszCatDescription = phmData->m_ptblCat_Desc->GetPointer((int)(DWORD_PTR)ret+1);
                }
                return ret;
            }
        case HH_ENUM_CATEGORY_IT:
            {
                PHH_ENUM_IT penumIT;
                CStr csz;
                penumIT = *(PHH_ENUM_IT*)dwData;
                csz = (WCHAR*) penumIT->pszCatName;
                penumIT->pszCatName = csz.psz;

                HWND ret = xHtmlHelpA(hwndCaller, cszFile, uCommand, dwData);
                if ( ret != (HWND)-1 )
                {
                    CHmData* phmData = FindCurFileData( cszFile.psz);
                    if ( phmData == NULL )
                        return (HWND)-1;
                    phmData->PopulateUNICODETables();
                    penumIT->pszITName = phmData->m_ptblIT->GetPointer((int)(DWORD_PTR)ret);
                    penumIT->pszITDescription = phmData->m_ptblIT_Desc->GetPointer((int)(DWORD_PTR)ret);
                }
                return ret;
            }

        case HH_SET_GUID:
            {
                // Set all CHM files matching this process ID to use this GUID

                // BUGBUG: should NOT be using a global for this -- breaks
                // the moment you share instances of HHCTRL accross processes

                if (g_pszDarwinGuid)
                    lcFree(g_pszDarwinGuid);

            // Convert to ANSI
            CStr pszGuid((LPCWSTR) dwData);
            // Save pointer.
                pszGuid.TransferPointer(&g_pszDarwinGuid ) ;

            }
            return NULL;

        case HH_SET_BACKUP_GUID:
            {
                // Set all CHM files matching this process ID to use this GUID

                // BUGBUG: should NOT be using a global for this -- breaks
                // the moment you share instances of HHCTRL accross processes

                if (g_pszDarwinBackupGuid)
                    lcFree(g_pszDarwinBackupGuid);

            // Convert to ANSI
            CStr pszGuid((LPCWSTR) dwData);
            // Save pointer.
                pszGuid.TransferPointer(&g_pszDarwinBackupGuid) ;
            }
            return NULL;

        default:
            return xHtmlHelpA(hwndCaller, cszFile, uCommand, dwData);
    }
    return NULL;
}

HWND xHtmlHelpA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData)
{
#if 0
#ifdef _DEBUG
static int count = 0;
if (!count)
    DebugBreak();
count++;
#endif
#endif

    switch (uCommand) {
        case HH_RESERVED1:  // this is a WinHelp HELP_CONTEXTMENU call
            WinHelp(hwndCaller, pszFile, HELP_CONTEXTMENU, dwData);
            return NULL;

        case HH_RESERVED2:  // this is a WinHelp HELP_FINDER call
            WinHelp(hwndCaller, pszFile, HELP_FINDER, 0);
            return NULL;

        case HH_RESERVED3:  // this is a WinHelp HELP_WM_HELP call
            WinHelp(hwndCaller, pszFile, HELP_WM_HELP, dwData);
            return NULL;

        case HH_DISPLAY_TOPIC:
            DBWIN("HH_DISPLAY_TOPIC");
            return OnDisplayTopic(hwndCaller, pszFile, dwData);

        case HH_SET_WIN_TYPE:
            DBWIN("HH_SET_WIN_TYPE");
            return SetWinType(pszFile, (HH_WINTYPE*) dwData) ;

        case HH_GET_WIN_TYPE:
            DBWIN("HH_GET_WIN_TYPE");
            return GetWinType(hwndCaller, pszFile, (HH_WINTYPE**)dwData) ;

        case HH_DISPLAY_SEARCH:
            DBWIN("HH_DISPLAY_SEARCH");
            return doDisplaySearch(hwndCaller, pszFile, (HH_FTS_QUERY*) dwData) ;

        case HH_DISPLAY_INDEX:
            DBWIN("HH_DISPLAY_INDEX");
            return doDisplayIndex(hwndCaller, pszFile, (LPCTSTR)dwData);

        case HH_DISPLAY_TOC:
            DBWIN("HH_DISPLAY_TOC");
            if (IsThisAWinHelpFile(hwndCaller, pszFile)) {
                WinHelp(hwndCaller, pszFile, HELP_CONTEXT, dwData);
                return NULL;
            }
            return doDisplayToc(hwndCaller, pszFile, dwData);

        case HH_DISPLAY_TEXT_POPUP:
            DBWIN("HH_DISPLAY_TEXT_POPUP");
            return doDisplayTextPopup(hwndCaller, pszFile, (HH_POPUP*)dwData) ;

        case HH_TP_HELP_WM_HELP:
            DBWIN("HH_TP_HELP_WM_HELP");
            if (IsThisAWinHelpFile(hwndCaller, pszFile)) {
                WinHelp(hwndCaller, pszFile, HELP_WM_HELP, dwData);
                return NULL;
            }
            return doTpHelpWmHelp(hwndCaller, pszFile, dwData);

        case HH_TP_HELP_CONTEXTMENU:
            DBWIN("HH_TP_HELP_CONTEXTMENU");
            if (IsThisAWinHelpFile(hwndCaller, pszFile)) {
                WinHelp(hwndCaller, pszFile, HELP_CONTEXTMENU, dwData);
                return NULL;
            }
            return doTpHelpContextMenu(hwndCaller, pszFile, dwData);


        case HH_GET_WIN_HANDLE:
            {
                DBWIN("HH_GET_WIN_HANDLE");
                if (!dwData || IsBadReadPtr((LPCSTR) dwData, sizeof(LPCSTR)))
                {
                    return NULL;
                }

                if (!pszFile || IsEmptyString(pszFile))
                {
                    return NULL ;
                }

                // Need to include compiled filename with window lookup
                // since there can be two or more .CHM files with identical window type
                // names, but different definitions

                CHHWinType* phh = FindWindowType(FirstNonSpace((PCSTR) dwData), hwndCaller, pszFile);
                if (!phh)
                {
                    return NULL;
                }
                return phh->GetHwnd();
            }

        case HH_SYNC:
            {
                DBWIN("HH_SYNC");
                // pszFile has two pieces of information which we need. The filename and the window type name.
                // Window type provided?

                CStr cszChmName ;
                CStr cszWindow ;
                if (!GetNameAndWinType(pszFile, cszChmName, cszWindow))
                {
                    return NULL;
                }

                /*
                REVIEW: 27 Apr 98 [dalero] - I'm adding the code to make FindOrCreateWindowSlot
                take a filename parameter, and I have to say that this function makes no sense to me.
                Why does HH_SYNC require a window type? Shouldn't it figure one out if you don't give
                it one? Leave as is for now...
                */

                CHHWinType* phh = FindWindowType(cszWindow, hwndCaller, cszChmName);
                if (phh->m_aNavPane[HH_TAB_CONTENTS])
                {
                    CStr cszUrl((PCSTR) dwData);
                    CToc* ptoc = reinterpret_cast<CToc*>(phh->m_aNavPane[HH_TAB_CONTENTS]) ; // HACKHACK: Should use dynamic cast.
                    ptoc->Synchronize(cszUrl);
                }
                return phh->GetHwnd();
            }

        case HH_KEYWORD_LOOKUP:
            DBWIN("HH_KEYWORD_LOOKUP");
            return OnKeywordSearch(hwndCaller, pszFile, (HH_AKLINK*) dwData);

        case HH_ALINK_LOOKUP:
            DBWIN("HH_ALINK_LOOKUP");
            return OnKeywordSearch(hwndCaller, pszFile, (HH_AKLINK*) dwData, FALSE);

        case HH_HELP_CONTEXT:
            DBWIN("HH_HELP_CONTEXT");
            return OnHelpContext(hwndCaller, pszFile, dwData);

        case HH_CLOSE_ALL:
            {
            DBWIN("HH_CLOSE_ALL");
            DeleteWindows() ; // This deletes everything. Windows and chm data.
            }
            return NULL;

        case HH_GET_LAST_ERROR:
            DBWIN("HH_GET_LAST_ERROR");
            if (SUCCEEDED(hhGetLastError((HH_LAST_ERROR*)(dwData))))
                return (HWND)TRUE;
            else
                return NULL;

        case HH_ENUM_INFO_TYPE:
            {
            DBWIN("HH_ENUM_INFO_TYPE");
static HH_ENUM_IT ITData;
static PHH_ENUM_IT pITData=&ITData;

            CHmData* phmData = FindCurFileData( pszFile ) ;
            if ( phmData == NULL )
                return (HWND)-1;
            if ( phmData->m_cur_IT == 0 )
                phmData->m_cur_IT = 1;
            if ( !phmData->m_pInfoType )
            {
                phmData->m_pInfoType = new CInfoType();
                phmData->m_pInfoType->CopyTo( phmData );
            }
                // get the information type
            if ( phmData->m_cur_IT > phmData->m_pInfoType->HowManyInfoTypes() )
            {
                phmData->m_cur_IT = 0;
                return (HWND)-1;
            }
            ITData.iType = IT_INCLUSIVE;
            if ( phmData->m_pInfoType->IsHidden( phmData->m_cur_IT) )
                ITData.iType = IT_HIDDEN;
            else
                if ( phmData->m_pInfoType->IsExclusive( phmData->m_cur_IT ) )
                    ITData.iType = IT_EXCLUSIVE;
            ITData.pszITName = phmData->m_pInfoType->GetInfoTypeName(phmData->m_cur_IT);
            ITData.pszITDescription = phmData->m_pInfoType->GetInfoTypeDescription(phmData->m_cur_IT);
            ITData.cbStruct = sizeof(HH_ENUM_IT);
            memcpy(*(PHH_ENUM_IT*)dwData, (PHH_ENUM_IT)(pITData), sizeof(HH_ENUM_IT) );
            phmData->m_cur_IT++;
            return reinterpret_cast<HWND>((DWORD_PTR)(phmData->m_cur_IT-1));
            }

        case HH_SET_INFO_TYPE:
            DBWIN("HH_SET_INFO_TYPE");
            if (IsThisAWinHelpFile(hwndCaller, pszFile)) {
                WinHelp(hwndCaller, pszFile, HELP_CONTEXTPOPUP, dwData);
                return NULL;
            }
            {
HH_SET_INFOTYPE set_type;
CStr cszIT;
                CHmData* phmData = FindCurFileData( pszFile );
                if ( phmData == NULL )
                    return (HWND)-1;
                memcpy(&set_type, *(PHH_SET_INFOTYPE*)dwData, (int)(**(int**)dwData));
                if ( set_type.pszCatName && *set_type.pszCatName!= NULL)
                {
                    cszIT = set_type.pszCatName;
                    cszIT+=":";
                }
                if ( set_type.pszInfoTypeName )
                    if ( cszIT.IsEmpty() )
                        cszIT = set_type.pszInfoTypeName;
                    else
                        cszIT += set_type.pszInfoTypeName;
                else
                    return (HWND)-1;
                if ( !phmData->m_pInfoType )
                {
                    phmData->m_pInfoType = new CInfoType();
                    phmData->m_pInfoType->CopyTo( phmData );
                }
                int IT = phmData->m_pInfoType->GetInfoType( cszIT.psz );
                if ( IT <= 0 )
                    return (HWND)-1;
                if (!phmData->m_pAPIInfoTypes )
                    phmData->m_pAPIInfoTypes = (INFOTYPE*)lcCalloc(phmData->m_pInfoType->InfoTypeSize());
                AddIT(IT, phmData->m_pAPIInfoTypes);
                return reinterpret_cast<HWND>((DWORD_PTR)(IT));
            }

        case HH_ENUM_CATEGORY:
            DBWIN("HH_ENUM_CATEGORY");
            {
static HH_ENUM_CAT ITData;
static PHH_ENUM_CAT pITData = &ITData;

            CHmData* phmData = FindCurFileData( pszFile );
            if ( phmData == NULL )
                return (HWND)-1;
            if ( !phmData->m_pInfoType )
            {
                phmData->m_pInfoType = new CInfoType();
                phmData->m_pInfoType->CopyTo( phmData );
            }
            if ( phmData->m_cur_Cat+1 > phmData->m_pInfoType->HowManyCategories() )
            {
                phmData->m_cur_Cat = 0;
                return (HWND)-1;
            }
            ITData.pszCatName = phmData->m_pInfoType->GetCategoryString(phmData->m_cur_Cat+1);
            ITData.pszCatDescription = phmData->m_pInfoType->GetCategoryDescription(phmData->m_cur_Cat+1);
            ITData.cbStruct = sizeof(HH_ENUM_CAT);
            memcpy(*(PHH_ENUM_CAT*)dwData, (PHH_ENUM_CAT)(pITData), sizeof(HH_ENUM_CAT) );
            phmData->m_cur_Cat++;
            return reinterpret_cast<HWND>((DWORD_PTR)(phmData->m_cur_Cat-1));
            }
        case HH_ENUM_CATEGORY_IT:
            {
            DBWIN("HH_ENUM_CATEGORY_IT");
static HH_ENUM_IT ITData;
static PHH_ENUM_IT pITData = &ITData;

            CHmData* phmData = FindCurFileData( pszFile );
            if ( phmData == NULL )
                return (HWND)-1;
            if ( phmData->m_cur_IT == -1 )
            {
                phmData->m_cur_Cat = 0;
                phmData->m_cur_IT = 0;
            }
            if ( !phmData->m_pInfoType )
            {
                phmData->m_pInfoType = new CInfoType();
                phmData->m_pInfoType->CopyTo( phmData );
            }
            if ( !dwData )
                return (HWND)-1;
            memcpy(&ITData, *(PHH_ENUM_IT*)dwData, (int)(**(int**)dwData));
            phmData->m_cur_Cat = phmData->m_pInfoType->GetCatPosition(ITData.pszCatName);
            if( phmData->m_cur_Cat == -1 )
                return (HWND)-1;
            if ( phmData->m_cur_IT ==0 )
                phmData->m_cur_IT = phmData->m_pInfoType->GetFirstCategoryType( phmData->m_cur_Cat-1 );
            else
                phmData->m_cur_IT = phmData->m_pInfoType->GetNextITinCategory( );
            if ( phmData->m_cur_IT == -1 )
                return (HWND)-1;
            ITData.iType = IT_INCLUSIVE;
            if ( phmData->m_pInfoType->IsHidden( phmData->m_cur_IT) )
                ITData.iType = IT_HIDDEN;
            else
                if ( phmData->m_pInfoType->IsExclusive( phmData->m_cur_IT ) )
                    ITData.iType = IT_EXCLUSIVE;
            ITData.pszITName = phmData->m_pInfoType->GetInfoTypeName( phmData->m_cur_IT );
            ITData.pszITDescription = phmData->m_pInfoType->GetInfoTypeDescription( phmData->m_cur_IT );
            memcpy(*(PHH_ENUM_IT*)dwData, (PHH_ENUM_IT)(pITData), sizeof(HH_ENUM_IT) );
            return reinterpret_cast<HWND>((DWORD_PTR)(phmData->m_cur_IT));
            }
        case HH_SET_INCLUSIVE_FILTER:
            DBWIN("HH_SET_INCLUSIVE_FILTER");
            {
CHmData* phmData=NULL;
            phmData = FindCurFileData( pszFile );
            if ( phmData == NULL )
                return (HWND)-1;
            if ( !phmData->m_pInfoType )
            {
                phmData->m_pInfoType = new CInfoType();
                phmData->m_pInfoType->CopyTo( phmData );
            }
            if ( !phmData->m_pAPIInfoTypes )
                return (HWND)-1;
            *phmData->m_pAPIInfoTypes &= ~1L;  // turn bit zero off for inclusive filtering; ie to 0.
            return NULL;
            }
            break;
        case HH_SET_EXCLUSIVE_FILTER:
            DBWIN("HH_SET_EXCLUSIVE_FILTER");
            {
CHmData* phmData=NULL;
            phmData = FindCurFileData( pszFile );
            if ( phmData == NULL )
                return (HWND)-1;
            if ( !phmData->m_pInfoType )
            {
                phmData->m_pInfoType = new CInfoType();
                phmData->m_pInfoType->CopyTo( phmData );
            }
            if ( !phmData->m_pAPIInfoTypes )
                return (HWND)-1;
            *phmData->m_pAPIInfoTypes |= 1L;  // turn bit zero on for exclusive filtering; ie to 1.
            return NULL;
            }
            break;
        case HH_RESET_IT_FILTER:
            DBWIN("HH_RESET_IT_FILTER");
            {
CHmData* phmData=NULL;
BOOL fExclusive;
            phmData = FindCurFileData( pszFile );
            if ( phmData == NULL )
                return (HWND)-1;
            if ( !phmData->m_pInfoType )
            {
                phmData->m_pInfoType = new CInfoType();
                phmData->m_pInfoType->CopyTo( phmData );
            }
            if ( !phmData->m_pAPIInfoTypes )
                return NULL;
            if ( *phmData->m_pAPIInfoTypes & 1L )
                fExclusive = TRUE;
            memset(phmData->m_pAPIInfoTypes, '\0', phmData->m_pInfoType->InfoTypeSize() );
            if ( fExclusive )
                *phmData->m_pAPIInfoTypes |= 1L;  // turn bit zero on for exclusive filtering; ie to 1.
            return NULL;
            }


        case HH_INITIALIZE:
            return (HWND)(DWORD_PTR)InitializeSession(reinterpret_cast<DWORD_PTR*>(dwData)) ;

        case HH_UNINITIALIZE:
            return (HWND)(DWORD_PTR)UninitializeSession(dwData) ;

//--- These were internal and are now external.
        case HH_PRETRANSLATEMESSAGE:
            return (HWND)(DWORD_PTR)hhPreTranslateMessage((MSG*)dwData) ;

        case HH_SET_GLOBAL_PROPERTY:
            {
            CHHWinType *phh = FindCurWindow( );
            return (HWND)SetGlobalProperty(reinterpret_cast<HH_GLOBAL_PROPERTY*>(dwData), phh) ;
            }

//--- Internal HH Commands.
        case HH_TITLE_PATHNAME : // Get the location of the title from its tag.
            DBWIN("HH_TITLE_PATHNAME");
            return reinterpret_cast<HWND>((DWORD_PTR)(GetLocationFromTitleTag(NULL/*pszFile*/, reinterpret_cast<HH_TITLE_FULLPATH*>(dwData)))) ;

       case HH_PRETRANSLATEMESSAGE2:
           return (HWND)(DWORD_PTR)hhPreTranslateMessage((MSG*)dwData, hwndCaller);

        case HH_HELP_CONTEXT_COLLECTION:
            DBWIN("HH_HELP_CONTEXT_COLLECTION");
            return OnHelpContextInCollection(hwndCaller, pszFile, dwData) ;

        case HH_RELOAD_NAV_DATA:
            {
                return OnReloadNavData(hwndCaller, pszFile, reinterpret_cast<HH_NAVDATA*>(dwData)) ;
            }

        case HH_GET_BROWSER_INTERFACE:
            {
                return reinterpret_cast<HWND>(GetBrowserInterface(hwndCaller, reinterpret_cast<IDispatch**>(dwData))) ;
            }
        default:
            DBWIN("Unsupported API call");
            return NULL;
    }
}

// <mc> As per HH bug 7487 NT5 bug 303099 I am placing a check here to see if we
//      appear to have a valid IE intallation. <mc/>
//
BOOL ValidateIE()
{
   BOOL bRet = FALSE;
   HKEY hkey;

   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Internet Explorer", 0, KEY_READ, &hkey) == ERROR_SUCCESS)
   {
       char szVersion[MAX_URL];
       DWORD cbPath = sizeof(szVersion);
       if ( (RegQueryValueEx(hkey, "Version", NULL, NULL, (LPBYTE) szVersion, &cbPath) == ERROR_SUCCESS) )
          bRet = TRUE;
       else if ( (RegQueryValueEx(hkey, "IVer", NULL, NULL, (LPBYTE) szVersion, &cbPath) == ERROR_SUCCESS) )
          bRet = TRUE;
       else if ( (RegQueryValueEx(hkey, "Build", NULL, NULL, (LPBYTE) szVersion, &cbPath) == ERROR_SUCCESS) )
          bRet = TRUE;
       RegCloseKey(hkey);
   }
   return bRet;
}


/***************************************************************************

    FUNCTION:   OnDisplayTopic

    PURPOSE:    Display topic in current or specified window, creating the
                window if necessary.

    PARAMETERS:
        hwndCaller  -- window requesting this topic
        pszFile     -- file and optionally the window to display
        dwData      -- optional data

    RETURNS:
        Window handle on success
        NULL on failure

    COMMENTS:
        A window name is specified by following the filename (if any) with
        a '>' character immediately followed by the window name:

            foo.hh>proc4

        If a window of the specified type isn't currently created, it will
        be created and activated. If the window type has been created, but
        is not active, it will be activated and the topic displayed in that
        window.

    MODIFICATION DATES:
        27-Feb-1996 [ralphw]

***************************************************************************/

HWND OnDisplayTopic(HWND hwndCaller, LPCSTR pszFile, DWORD_PTR dwData)
{
    if (dwData && IsBadReadPtr((LPCSTR) dwData, sizeof(LPCSTR)))
        return NULL ;

    // <mc> As per HH bug 7487 NT5 bug 303099 I am placing a check here to see if we
    //      appear to have a valid IE intallation. <mc/>
    //
    if ( ! ValidateIE() )
       return NULL;

    //--- If name has string %SystemRoot% add the windows directory.
    CStr cszTmp;
    PSTR psz = stristr(pszFile, txtSysRoot);
    if (psz) {
        char szPath[MAX_PATH];
        GetRegWindowsDirectory(szPath);
        strcat(szPath, psz + strlen(txtSysRoot));
        cszTmp = szPath;
        pszFile = (PCSTR) cszTmp.psz;
    }

    //--- Find the window name.
    CStr cszFile(pszFile);
    CStr cszWindow;
    PSTR pszWindow = StrChr(cszFile, WINDOW_SEPARATOR);
    if (pszWindow != NULL) {
        *pszWindow = '\0';
        RemoveTrailingSpaces(cszFile);
        cszWindow = FirstNonSpace(pszWindow + 1);
    }

    // Is the file a collection?
    BOOL bCollection = IsCollectionFile(pszFile);

    //--- dwData can point to a particular topic to which to jump. Add this topic.
    CStr cszExternal;
    if (dwData) {
        if (cszFile.IsEmpty())
            cszFile = (LPCSTR) dwData;
        else
        {
            //--- Hack: If there is a '::' assume we are specifying a chm file...
            PCSTR psz = (LPCSTR) dwData;
            if (bCollection && strstr(psz, "::"))
            {
                // Only valid if we are passing in a collection.
                cszExternal = psz;

                // If there is a window type at the end, remove it. We get the window type from the collection.
                PSTR pszWindowType = StrChr(cszExternal, WINDOW_SEPARATOR);
                if (pszWindowType != NULL)
                {
                    *pszWindowType = '\0';
                }
            }
            else
            {
                cszFile += txtSepBack;
                cszFile += (*psz == '/' ? psz + 1 : psz);
            }
        }
    }

    //--- CHmData used by the CreateWindow call
    CHmData* pHmDataCreateWindow = NULL ;

    //--- We have a filename from which we can get the file.
    CHHWinType* phh = NULL;

    if (bCollection || IsCompiledHtmlFile(cszFile, &cszFile))
    {
        //--- Initialize the CHmData structure.
        CStr cszCompressed;
        PCSTR pszFilePortion = GetCompiledName(cszFile, &cszCompressed); // pszFilePortion is everything is cszFile after the '::', in other words the topic path.
        if (!FindThisFile(hwndCaller, cszCompressed, &cszCompressed, FALSE))
        {
            //TODO: Move error message into FindThisFile.
            g_LastError.Set(HH_E_FILENOTFOUND) ;
            return NULL;
        }

        CHmData* phmData = NULL;
        CExCollection* pCollection = GetCurrentCollection(NULL, pszFile);
        //
        // if  ( .COL file AND g_Col != returned col )  OR ( .CHM file and g_col == returned col )
        //
        if ( !pCollection
            || ((bCollection && (pCollection != g_pCurrentCollection))
            || (!bCollection && (pCollection == g_pCurrentCollection))
            || (!bCollection && (pCollection == g_phmData[0]->m_pTitleCollection)))) //Bug:: May not have been loaded!!!
        {
           phmData = FindCurFileData(cszCompressed);
        }
        else
        {
           phmData = pCollection->m_phmData;
        }

        if (phmData == NULL)
        {
            g_LastError.Set(HH_E_INVALIDHELPFILE) ; // TODO: FindCurFileData should set this.
            return NULL;
        }
        ASSERT(phmData) ; // See the previous if statement!

        // IsCompiledHtmlFile has numerous side effects. We need those effects.
        if (bCollection)
        {
            // Get the name of the master chm.
            cszFile = phmData->GetCompiledFile();
            // Parse it to get the various pieces.
            IsCompiledHtmlFile(cszFile, &cszFile);
        }

        // Get the CHmData associated with the specified window type.
        if (cszWindow.IsNonEmpty()
         && !IsGlobalWinType(cszWindow.psz)) // Only use the information from window type if its non-global. Currently, means get the default topic from CHM passed in.
        {
            phh = FindWindowType(cszWindow, hwndCaller, cszFile);
            if (phh)
            {
                if (phh->m_phmData) // Bug 6799 - This is NULL until the window is created...
                {
                    phmData = phh->m_phmData; //Review: Is the FindCurFileData above a waste in this case?
                }
            }
            else if (strcmp(cszWindow, txtDefWindow + 1) != 0 && strcmp(cszWindow, txtForceWindowType) != 0)
            {
                AuthorMsg(IDSHHA_NO_HH_GET_WIN_TYPE, cszWindow, hwndCaller, NULL);
                // Get the CHmData associated with the default window.
                // We could do this in the section outside the outer if, but I'm paranoid about breaking things...
                // The default window type is used only if it exists. Therefore, if we have to create a window,
                // will use the correct name.
                if (phmData->GetDefaultWindow() && 
                    FindWindowType(phmData->GetDefaultWindow(), hwndCaller, cszFile)) 
                {
                    AuthorMsg(IDSHHA_NO_HH_GET_WIN_TYPE, cszWindow, hwndCaller, NULL);
                    cszWindow = phmData->GetDefaultWindow();
                }
            }
        }

        // Get the CHmData associated with the default window.
        if (cszWindow.IsEmpty() && phmData->GetDefaultWindow())
            cszWindow = phmData->GetDefaultWindow();

        //--- If the user didn't supply a topic, try and find one...
        if (pszFilePortion)
        {
            // If we have a topic, make sure that the slashes are correct.
            ConvertBackSlashToForwardSlash(const_cast<LPSTR>(pszFilePortion)) ; // Danger! Danger! Will Robinson! Casting away const on a pointer inside of a CStr...
        }
        else
        {
            LPCTSTR pTopic = NULL ;
            if (phh && phh->pszFile) // the window type has a topic
            {
                pTopic = phh->pszFile ;
            }
            else if (phmData && phmData->GetDefaultHtml()) // the CHmData struct's default html page.
            {
                pTopic = phmData->GetDefaultHtml() ;
            }

            if (pTopic)
            {
                if (*pTopic == '/') // Look for an initial separator.
                {
                    pTopic++ ; // Skip the initial separator.
                }
                cszFile += txtSepBack;
                cszFile += pTopic ;
            }
        }

        // Get the CHmData structure we want to use with the window.
        if (cszExternal.IsEmpty())
            pHmDataCreateWindow = g_phmData[g_curHmData] ;
        else
            pHmDataCreateWindow = phmData ; // CHmdata for the collection.

    } // if IsCompiledFile.

    if (cszWindow.IsEmpty() && (!phh || phh->m_pCIExpContainer == NULL))
        cszWindow = txtForceWindowType;

    //--- The user supplied a window type or we have a default window type.
    if (cszWindow.IsNonEmpty())
    {
        CStr cszChmFile;
        if (cszFile.IsNonEmpty())
            GetCompiledName(cszFile, &cszChmFile); //Have to call this again, because pszFile was built back up.

        phh = FindWindowType(cszWindow, hwndCaller, cszChmFile); // Review: We may have already gotten the window type.
        if (!phh) // Can't find the window type, so create it.
        {
            if (strcmp(cszWindow, txtDefWindow + 1) != 0 && strcmp(cszWindow, txtForceWindowType) != 0)
                AuthorMsg(IDSHHA_NO_HH_GET_WIN_TYPE, cszWindow, hwndCaller, NULL);
            CreateDefaultWindowType(cszChmFile.IsEmpty() ?
                txtZeroLength : cszChmFile.psz, cszWindow); // This only does a HH_SET_WIN_TYPE
            phh = FindWindowType(cszWindow, hwndCaller, pszFile); // Try again to get the window type.
        }

        // We still don't have a valid window type or we don't have a valid window.
        if (!phh || !IsValidWindow(phh->GetHwnd()))
        {
            // Create the help window. This does a lot of work.
            phh = CreateHelpWindow(cszWindow, cszChmFile, hwndCaller, pHmDataCreateWindow);

            if (!phh)
            {
               g_LastError.Set(HH_E_INVALIDHELPFILE) ; // TODO: FindCurFileData should set this.
               return NULL ;
            }

            RECT rc;
            GetClientRect(phh->GetHwnd(), &rc);
            SendMessage(phh->GetHwnd(), WM_SIZE, SIZE_RESTORED, MAKELONG(RECT_WIDTH(rc),RECT_HEIGHT(rc)));

            // HTML Help Bug 6334 - For some reason on win95, we have a problem with coming up in the background.
            // Not sure why, however the following code which is basically what happens if we don't have
            // a window fixes the issue.
            if (!IsIconic(phh->GetHwnd()))
            {
                phh->SetActiveHelpWindow();
            }
        }
        else
        {
            // Bring the existing window to the front and restore if needed.
            phh->SetActiveHelpWindow();
        }

        ASSERT(phh) ; // This has to be true by now.

        // Still futzing with the filename. Review: Reduce the futzing.
        if (cszFile.IsEmpty())
        {
            if (phh->pszFile)
                cszFile = phh->pszFile;
        }
    }

    // If we are displaying the file in the collection space, just use the string passed in
    // the dwData parameter.
    return ChangeHtmlTopic(cszExternal.IsNonEmpty() ? cszExternal : cszFile, phh->GetHwnd());
}

HWND ChangeHtmlTopic(PCSTR pszFile, HWND hwndChild, BOOL bHighlight)
{
    if (IsEmptyString(pszFile))
        return NULL;

    CHHWinType* phh;
    ASSERT_COMMENT(hwndChild, "It is not valid to call ChangeHtmlTopic with NULL for the calling window handle");
    phh = FindHHWindowIndex(hwndChild);

    CStr cszTmp;
    if ( IsCompiledURL( pszFile ) ) {
        if (!strstr(pszFile, txtDoubleColonSep)) {
            cszTmp = pszFile;
            cszTmp += txtDefFile;
            pszFile = cszTmp;
        }
    }
    if (phh->m_pCIExpContainer) {
        phh->m_fHighlight = bHighlight;
        phh->m_pCIExpContainer->m_pWebBrowserApp->Navigate(pszFile, NULL, NULL, NULL, NULL);
#if 0
        if (phh->IsProperty(HHWIN_PROP_AUTO_SYNC))
        {
            if (phh->m_aNavPane[HH_TAB_CONTENTS])
            {
                cszTmp = pszFile;
                CToc* ptoc = reinterpret_cast<CToc*>(phh->m_aNavPane[HH_TAB_CONTENTS]) ; // HACKHACK: Should use dynamic cast.
                ptoc->Synchronize(cszTmp);
            }
        }
#endif
        if (IsValidWindow(phh->GetHwnd())) {
            DBWIN("Bringing window to the front");
            SetWindowPos(phh->GetHwnd(), HWND_TOP, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE);
        }
#ifdef DEBUG
        else
            DBWIN("Invalid window handle");
#endif
        return phh->GetHwnd();
    }

    return NULL;
}

BOOL ConvertToCacheFile(PCSTR pszSrc, PSTR pszDst)
{
    if (!pszSrc)
        return FALSE;

    CStr cszTmp;

    PSTR psz = stristr(pszSrc, txtSysRoot);
    if (psz) {
        char szPath[MAX_PATH];
        GetRegWindowsDirectory(szPath);
        strcat(szPath, psz + strlen(txtSysRoot));
        cszTmp = szPath;
        pszSrc = (PCSTR) cszTmp.psz;
    }
    if ( IsCompiledURL( pszSrc ) )
    {
       strcpy(pszDst, pszSrc);
       if ( (GetURLType(pszDst) == HH_URL_UNQUALIFIED) )
       {
          // We need to qualify the .CHM filespec.
          //
          CExCollection *pCollection;
          CExTitle *pTitle;
          PSTR pszSep;
          if( (pCollection = GetCurrentCollection(NULL, pszDst)) )
          {
             if ( (SUCCEEDED(pCollection->URL2ExTitle(pszDst, &pTitle))) && pTitle )
             {
                if ( (pszSep = stristr(pszDst, txtDoubleColonSep)) )
                {
                   while ( ((*(--pszSep) != ':')) && (pszSep != pszDst) );
                   if ( *pszSep == ':' )
                      *(++pszSep) = '\0';
                   lstrcat(pszDst, pTitle->GetContentFileName());
                   pszSep = stristr(pszSrc, txtDoubleColonSep);
                   lstrcat(pszDst, pszSep);
                   return TRUE;
                }
             }
          }
       }
       else
          return TRUE;
    }

    PCSTR pszChmSep = strstr(pszSrc, txtDoubleColonSep);
    if (pszChmSep) {
        if (pszSrc != cszTmp.psz) {
            cszTmp = pszSrc;
            int offset = (int)(pszChmSep - pszSrc);
            pszSrc = cszTmp;
            pszChmSep = pszSrc + offset;
        }
        *(PSTR) pszChmSep = '\0';   // Remove the separator
        HRESULT hr = URLDownloadToCacheFile(NULL, pszSrc, pszDst, MAX_PATH, 0, NULL);
        if (!SUCCEEDED(hr)) {
            CStr cszNew;
            BOOL fResult = FindThisFile(NULL, pszSrc, &cszNew, FALSE);
            if (fResult) {
                strcpy(pszDst, cszNew.psz);
                *(PSTR) pszChmSep = ':';   // Put the separator back
                strcat(pszDst, pszChmSep);
                return TRUE;
            }
        }
        else {  // we downloaded it, or have a pointer to it
            *(PSTR) pszChmSep = ':';   // Put the separator back
            strcat(pszDst, pszChmSep);
            return TRUE;
        }
    }

    HRESULT hr = URLDownloadToCacheFile(NULL, pszSrc, pszDst, MAX_PATH, 0, NULL);
    if (!SUCCEEDED(hr)) {
#if 0
        if (MessageBox(NULL, pszSrc, "URLDownloadToCacheFile failure", MB_RETRYCANCEL) == IDRETRY)
            DebugBreak();
#endif
        return FALSE;
    }
    return TRUE;
}

void doAuthorMsg(UINT idStringFormatResource, PCSTR pszSubString);
int (STDCALL *pHhaChangeParentWindow)(HWND hwndNewParent);

extern "C" void AuthorMsg(UINT idStringFormatResource, PCSTR pszSubString, HWND hwndParent, void* phhctrl)
{
    if (g_hmodHHA == NULL) {
        if (g_fTriedHHA || !LoadHHA(hwndParent, _Module.GetModuleInstance()))
            return; // no HHA.dll, so not a help author
    }
    if (!pHhaChangeParentWindow) {
        (FARPROC&) pHhaChangeParentWindow = GetProcAddress(g_hmodHHA, MAKEINTATOM(311));
        if (!pHhaChangeParentWindow)
            return;
    }
    pHhaChangeParentWindow(hwndParent);

    if (phhctrl)
        ((CHtmlHelpControl*)phhctrl)->ModalDialog(TRUE);
    doAuthorMsg(idStringFormatResource, pszSubString);
    if (phhctrl)
        ((CHtmlHelpControl*)phhctrl)->ModalDialog(FALSE);
}

void CreateDefaultWindowType(PCSTR pszCompiledFile, PCSTR pszWindow)
{
    HH_WINTYPE hhWinType;
    ZERO_STRUCTURE(hhWinType);
    hhWinType.cbStruct = sizeof(HH_WINTYPE);
    hhWinType.fsToolBarFlags = HHWIN_DEF_BUTTONS;
    hhWinType.pszType = pszWindow;
    CStr cszToc;    // use CStr so we automatically free the memory
    CStr cszIndex;

    bool bFail = true ;

    if (!IsEmptyString(pszCompiledFile) &&
        g_phmData && g_phmData[g_curHmData])
    {
        bool bHasFTS = !((g_phmData[g_curHmData]->m_sysflags.fFTI) == 0) == TRUE;
        bool bHasToc = IsNonEmptyString(g_phmData[g_curHmData]->GetDefaultToc()) == TRUE;
        bool bHasIndex = IsNonEmptyString(g_phmData[g_curHmData]->GetDefaultIndex()) == TRUE;
        bool bHasNavData = (bHasFTS || bHasToc || bHasIndex) ;

        if (bHasNavData)
        {
            hhWinType.fsToolBarFlags |= HHWIN_BUTTON_EXPAND;
            hhWinType.fsValidMembers |= HHWIN_PARAM_PROPERTIES | HHWIN_PARAM_TB_FLAGS;
            hhWinType.fsWinProperties |= HHWIN_PROP_CHANGE_TITLE | HHWIN_PROP_TRI_PANE ;

            if (bHasFTS)
            {
                hhWinType.fsWinProperties |= HHWIN_PROP_TAB_SEARCH;
            }
            if (bHasToc)
            {
                cszToc = pszCompiledFile;
                cszToc += "::/";
                cszToc += g_phmData[g_curHmData]->GetDefaultToc();
                hhWinType.pszToc = cszToc.psz;
                hhWinType.fsWinProperties |= HHWIN_PROP_AUTO_SYNC ;
            }
            if (bHasIndex)
            {
                cszIndex = pszCompiledFile;
                cszIndex += "::/";
                cszIndex += g_phmData[g_curHmData]->GetDefaultIndex();
                hhWinType.pszIndex = cszIndex.psz;
                if (!bHasToc) // REVIEW: 30 Jun 98 : Can this be removed? [dalero]
                {
                    hhWinType.curNavType = HHWIN_NAVTYPE_INDEX;
                    hhWinType.fsValidMembers |= HHWIN_PARAM_TABPOS;
                }
            }
            if (IsNonEmptyString(g_phmData[g_curHmData]->GetDefaultHtml()))
            {
                CStr csz, cszFull;
                csz = g_phmData[g_curHmData]->GetDefaultHtml();
                if (!stristr(csz, txtDoubleColonSep) &&
                    !stristr(csz, txtFileHeader) && !stristr(csz, txtHttpHeader)) 
                {
                    cszFull = g_phmData[g_curHmData]->GetCompiledFile();
                    cszFull += txtSepBack;
                    cszFull += csz.psz;
                    cszFull.TransferPointer(&hhWinType.pszHome);
                }
                else
                    csz.TransferPointer(&hhWinType.pszHome);
            }
            if (IsNonEmptyString(g_phmData[g_curHmData]->GetDefaultCaption()))
                hhWinType.pszCaption = g_phmData[g_curHmData]->GetDefaultCaption();
            else
                hhWinType.pszCaption = lcStrDup(GetStringResource(IDS_DEF_WINDOW_CAPTION));

            // We've made a nice default window type.
            bFail = false ;
        }
    }

    if (bFail)
    {
        hhWinType.pszCaption = lcStrDup(GetStringResource(IDS_DEF_WINDOW_CAPTION));
    }

    xHtmlHelpA(NULL, pszCompiledFile, HH_SET_WIN_TYPE, (DWORD_PTR) &hhWinType);
}

BOOL IsThisAWinHelpFile(HWND hwndCaller, PCSTR pszFile)
{
    if (stristr(pszFile, txtWinHelpFileExt)) {
        CStr cszFile;
        if (FindThisFile(hwndCaller, pszFile, &cszFile, FALSE)) {
            HFILE hf = _lopen(cszFile, OF_READ);
            if (hf != HFILE_ERROR) {
                BYTE aMagic[2];
                _lread(hf, aMagic, sizeof(aMagic));
                _lclose(hf);
                if (aMagic[0] == '?' && aMagic[1] == '_') {    // yep, this is a WinHelp file
                    return TRUE;
                }
            }
        }
    }
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//
// This does a Context ID lookup in the CollectionSpace.
//
HWND OnHelpContextInCollection(HWND hwndCaller,
                               LPCSTR pszColFile,
                               DWORD_PTR dwData)
{
    HH_COLLECTION_CONTEXT* pContext = reinterpret_cast<HH_COLLECTION_CONTEXT*>(dwData);

    //TODO: Validate.
    if (!pContext)
    {
        return NULL ;
    }

    HWND hwndReturn = InternalHelpContext(hwndCaller, pszColFile, pContext->id, pContext);
    if (!hwndReturn)
    {
        // We can be left in weird states after failures.
        // So, we are going to be very aggresive about this and dump all the Hmdata if we don't end up
        // with a window. We do this by deleting all of the CHHWinType structures.
        // This is somewhat overkill, but the safest solution.
        DeleteWindows() ;
    }
    return hwndReturn ;

}

///////////////////////////////////////////////////////////////////////////////
//
// This is the original OnHelpContext
//
HWND OnHelpContext(HWND hwndCaller, LPCSTR pszFile, DWORD_PTR dwData)
{
    return InternalHelpContext(hwndCaller, pszFile, dwData, NULL);
}

///////////////////////////////////////////////////////////////////////////////
//
// Do the actual lookup.
//
HWND InternalHelpContext(HWND hwndCaller,
                         LPCSTR pszFile,
                         DWORD_PTR dwData,
                         HH_COLLECTION_CONTEXT* pContext)
{
    CExTitle* pExTitle;
    PSTR pszJumpFile;
    char szMsg[256];

    // Is this a WinHelp file?

    if (IsThisAWinHelpFile(hwndCaller, pszFile)) {
        WinHelp(hwndCaller, pszFile, HELP_CONTEXT, dwData);
        return NULL;
    }

    PSTR psz = stristr(pszFile, txtSysRoot);
    CStr cszTmp;
    if (psz) {
        char szPath[MAX_PATH];
        GetRegWindowsDirectory(szPath);
        strcat(szPath, psz + strlen(txtSysRoot));
        cszTmp = szPath;
        pszFile = (PCSTR) cszTmp.psz;
    }

    CStr cszFile(pszFile);  // copy it so we can modify it
    CStr cszWindow;
    PSTR pszWindow = StrChr(cszFile, WINDOW_SEPARATOR);
    if (pszWindow != NULL) {
        *pszWindow = '\0';
        RemoveTrailingSpaces(cszFile);
        cszWindow = FirstNonSpace(pszWindow + 1);
    }

    //--- We want to be able to do a lookup in the context of a CHM.
    BOOL bCollection = IsCollectionFile(cszFile);
    if ((bCollection && pContext) // Only allow lookup in the collection space with valid pContext structure.
        || IsCompiledHtmlFile(cszFile, &cszFile))
    {
        CStr cszCompressed;
        PCSTR pszFilePortion = GetCompiledName(cszFile, &cszCompressed);
        if (!FindThisFile(hwndCaller, cszCompressed, &cszCompressed))
        {
            g_LastError.Set(HH_E_FILENOTFOUND) ; // Let FindThisFile do this when it gets a process id.
            return NULL;
        }
        CHmData* phmData = FindCurFileData(cszCompressed);
        if (!phmData)
        {
            g_LastError.Set(HH_E_INVALIDHELPFILE) ; // TODO: FindCurFileData should set this.
            return NULL ;
        }
        // Handle if we have a collection.
        if ( bCollection )
        {
            // We have to have the tag name.
            if (IsEmptyString(pContext->szTag))
            {
                // TODO: use pszFilePortion...((*pszFilePortion == '/') ? pszFilePortion+1 : pszFilePortion
                return NULL ;
            }

            //---Get the path to the CHM.
            pExTitle = phmData->m_pTitleCollection->FindTitleNonExact(pContext->szTag,
                                                                        LANGIDFROMLCID(pContext->lcid)) ;
            if (!pExTitle)
            {
                return NULL ;
            }
            //
            // We're setting cszFile to the FQ .CHM name for use later in this function (only in the collection case).
            //
            cszFile = pExTitle->GetFileName();
            //
            // Yes, This has a side affect we're relying on. We want IsCompiledHtmlFile to decorate the URL for us.
            //
            //IsCompiledHtmlFile(cszFile, &cszFile); // Doesn't work in CD swaping case.
            char szTmp[MAX_PATH*4];  //REVIEW:: Inefficient
            wsprintf(szTmp, "%s%s", (g_bMsItsMonikerSupport ? txtMsItsMoniker : txtMkStore), //TODO: We are adding moniker information. This should be centralized.
                            cszFile.psz);
            cszFile = szTmp ;

        }
        else
        {
           if (! phmData->m_pTitleCollection->IsSingleTitle() )
           {
              g_LastError.Set(HH_E_INVALIDHELPFILE) ; // TODO: FindCurFileData should set this.
              return NULL;
           }
           pExTitle = phmData->GetExTitle();
        }
        //
        // Now translate the context hash int a URL so we can jump!
        //
        HRESULT hr = pExTitle->ResolveContextId((DWORD)dwData, &pszJumpFile);
        if ( hr != S_OK )
        {
           g_LastError.Set(hr);
           if (IsHelpAuthor(NULL))
           {
              if ( hr == HH_E_NOCONTEXTIDS )
                 doAuthorMsg(IDS_HHA_NO_MAP_SECTION, "");
              else if ( hr == HH_E_CONTEXTIDDOESNTEXIT )
              {
                 wsprintf(szMsg, pGetDllStringResource(IDS_HHA_MISSING_MAP_ID), dwData, cszFile.psz);
                 SendStringToParent(szMsg);
              }
           }
           return NULL;
        }
#if 0 // TEST TEST TEST
        CStr test("vbcmn98.chm::/html\\vbproMaxMinPropertiesActiveXControls.htm") ;
        pszJumpFile = test ;
#endif //TEST TEST TEST

        BOOL fIsInterFileJump = IsCompiledHtmlFile(pszJumpFile);

        char szUrl[MAX_PATH*4];
        if (bCollection & fIsInterFileJump)
        {
            //--- This is an interfile jump in the context of the collection.
            // We need a full path to this file so that we can find it.
            CStr pszChmName;
            PCSTR pszTopic = GetCompiledName(pszJumpFile, &pszChmName);

            // Remove the extension.
            PSTR pszExt = stristr(pszChmName, txtDefExtension); // case insensitive search.
            if (pszExt)
                *pszExt = '\0' ;

            // Look in the global col file for this chm.
            HH_TITLE_FULLPATH tf ;
            tf.lcid = pContext->lcid ;
            tf.szTag = pszChmName ;
            tf.fullpathname = NULL;
            if (GetLocationFromTitleTag(NULL/*cszCompressed*/, &tf))
            {
                // Found it.
                CStr full(tf.fullpathname) ; // Convert.
                wsprintf(szUrl, "%s%s::%s", (g_bMsItsMonikerSupport ? txtMsItsMoniker : txtMkStore), //TODO: We are adding moniker information. This should be centralized.
                                            full.psz,
                                            pszTopic);

                ::SysFreeString(tf.fullpathname); // cleanup.
            }
            else
            {
                // Didn't find it. hope for the best...maybe its in the windows help directory.
                strcpy(szUrl, pszJumpFile);
            }
        }
        else if (fIsInterFileJump)
        {
            // On an interfile jump we are given the name of the chm and the topic: "help.chm::topic.htm"
            // So we don't combine the two together.
            // BUGBUG: This will rarely work, since we will not have a fullpath to the chm.
            // To work, it must be in the windows help directory.
            strcpy(szUrl, pszJumpFile);
        }
        else
        {
            // Combine the chm name with the topic name.
            wsprintf(szUrl, "%s::/%s", cszFile.psz, pszJumpFile);
        }

        // Add on the window.
        if (cszWindow.IsNonEmpty()) {
            strcat(szUrl, ">");
            strcat(szUrl, cszWindow);
        }

        if (IsHelpAuthor(NULL)) {
            wsprintf(szMsg, pGetDllStringResource(IDS_HHA_HH_HELP_CONTEXT),
                fIsInterFileJump ? "" : cszFile.psz, dwData, pszJumpFile);
            SendStringToParent(szMsg);
        }

        // Send the COL file to HH_DISPLAY_TOPIC. Also send the chm::htm string.
        if (bCollection)
        {
            return OnDisplayTopic(hwndCaller, cszCompressed, (DWORD_PTR)szUrl);
        }
        else
        {
            return OnDisplayTopic(hwndCaller, szUrl,  NULL);
        }
    }
    else
    {
        return NULL ;
    }
}
/***************************************************************************

    FUNCTION: SetWinType

    PURPOSE:

    PARAMETERS:
        hwndCaller  -- window requesting this topic
        pszFile     -- file and window

        bFindCurdata -- if true, it will call FindCurFileData.
                        Only ReadSystemFiles should call this with True. Its main purpose is to prevent
                        re-entering ReadSystemFiles.
    RETURNS:


    COMMENTS:

    MODIFICATION DATES:
        27-Apr-98


***************************************************************************/

HWND
SetWinType(LPCSTR pszFile, HH_WINTYPE* phhWinType, CHmData* phmDataOrg /*= NULL*/)
{
    // Check for uninitialized or invalid pointers

    if (IsBadReadPtr(phhWinType, sizeof(HH_WINTYPE*)))
        // BUGBUG: nag the help author
        return FALSE;
    if (IsBadReadPtr(phhWinType->pszType, sizeof(PCSTR)) || IsEmptyString(phhWinType->pszType))
        // BUGBUG: nag the help author
        return FALSE;

   if (IsNonEmptyString(pszFile))
   {
       // If a CHM happens to have a global window type in it, we do not want to re-load the window type information
    // from the CHM if it has already been loaded. Bug 1.1c 5175
       if (IsGlobalWinType(phhWinType->pszType))
       {
          // We are attempting to load the win type information from the CHM.
          // Check to see if it has already been loaded.
          CHHWinType* phh = FindWindowType(phhWinType->pszType, NULL, NULL);
          if (phh)
          {
             // Don't over write the window type.
             return FALSE ;
          }
       }

        // Window types are owned by a particular chm. Unless they are global....
        if (!phmDataOrg)
        {
            FindCurFileData(pszFile); // We aren't getting loaded by SetWinType. So we don't have an Org file...
        }


   }
   else
   {
       // No filename specified. Must be a global window type.
       if (!IsGlobalWinType(phhWinType->pszType))
       {
            // Force it to be a global window type.
           _Module.m_GlobalWinTypes.Add(phhWinType->pszType) ;
       }
   }

    // The following code will over write any current definitions of this window type.
    CHHWinType* phh = FindOrCreateWindowSlot(phhWinType->pszType, pszFile);
    if (!phh)
        return FALSE ;

    CHHWinType* phhNew = (CHHWinType*) phhWinType;

    phh->SetUniCodeStrings(phhWinType);
    phh->SetCaption(phhWinType);
    phh->SetToc(phhWinType);
    phh->SetIndex(phhWinType);
    phh->SetFile(phhWinType);
    phh->SetValidMembers(phhWinType);
    phh->SetProperties(phhWinType);
    phh->SetStyles(phhWinType);
    phh->SetExStyles(phhWinType);
    phh->SetWindowRect(phhWinType);
    phh->SetDisplayState(phhWinType);
    phh->SetNavExpansion(phhWinType);
    phh->SetNavWidth(phhWinType);
    phh->SetCaller(phhWinType);
    phh->SetHome(phhWinType);
    phh->SetToolBar(phhWinType);
    phh->SetTabPos(phhWinType);
    phh->SetTabOrder(phhWinType);
    phh->SetJump1(phhWinType);
    phh->SetJump2(phhWinType);
    phh->SetCurNavType(phhWinType);

    phh->idNotify = phhWinType->idNotify;


    if (phmDataOrg)
    {
        /*
        We are being loaded from ReadSystemFiles. We need to store the CHMDATA from which we are created,
        so that we get the custom tab information from the [options] sections of the correct CHM. The
        m_pChmData paramter isn't good enough since it is arbitarily set during create window and is over written
        as a result of the HH_RELOAD_NAV_DATA.
        */
        phh->m_phmDataOrg = phmDataOrg ;
    }


    // If there isn't a table of contents, turn off various parameters.
    if (!phh->IsValidNavPane(HH_TAB_CONTENTS))
    {
        if (phh->IsValidMember(HHWIN_PARAM_TB_FLAGS))
        {
            phh->fsToolBarFlags &= ~HHWIN_BUTTON_TOC_PREV ;
            phh->fsToolBarFlags &= ~HHWIN_BUTTON_TOC_NEXT ;
        }
    }

    // If we are a tri-pane window with nothing to expand,
    // then shut off the automatic expansion

    if (!phh->AnyValidNavPane())
    {
        phh->fNotExpanded = TRUE;
        // Bug 1084 Disable the Expand button also.
        phh->fsToolBarFlags &= ~HHWIN_BUTTON_EXPAND ;
    }

    #ifdef _DEBUG
    DWORD dwOldStyle;
    #endif

    // Does this window type name already exist.
    if (!phh->GetTypeName())
    {
        phh->SetTypeName(phhWinType);
        return phh->GetHwnd();
    }
    else
    {
        // Change the existing window type.

        // REVIEW: IsValidWindow(phh->GetHwnd() is called TOO often
        // Set Caption
        if (phhNew->GetCaption() && IsValidWindow(phh->GetHwnd()))
            SetWindowText(phh->GetHwnd(), phh->GetCaption());

        // Set window styles
        bool bStyleChanged = false ;
        if (phhNew->IsValidMember(HHWIN_PARAM_STYLES))
        {
            phh->AddStyle(WS_VISIBLE | WS_CLIPSIBLINGS); //REVIEW: Why isn't this part of DEFAULT_STYLE?
            if (IsValidWindow(phh->GetHwnd()))
            {
    #ifdef _DEBUG
                dwOldStyle = GetWindowLong(*phh, GWL_STYLE);
    #endif
                SetWindowLong(*phh, GWL_STYLE, phh->GetStyles());
                bStyleChanged = true;
            }
        }

        // Change extended window styles.
        if (phhNew->IsValidMember(HHWIN_PARAM_EXSTYLES))
        {
            if (!(phhNew->IsProperty(HHWIN_PROP_NODEF_EXSTYLES)))
            {
                if (IsValidWindow(phh->GetHwnd()))
                    phh->AddStyle(GetWindowLong(phh->GetHwnd(), GWL_EXSTYLE));

                if (phhWinType->fsWinProperties & HHWIN_PROP_ONTOP)
                    phh->AddStyle(WS_EX_TOPMOST);
            }

            if (IsValidWindow(phh->GetHwnd())) {
    #ifdef _DEBUG
                dwOldStyle = GetWindowLong(phh->GetHwnd(), GWL_EXSTYLE);
    #endif
                SetWindowLong(phh->GetHwnd(), GWL_EXSTYLE, phh->GetExStyles());
                bStyleChanged = true;
            }
        }

        if (bStyleChanged)
        {
            // Must call this for SetWindowLong to take affect. See docs for SetWindowPos and SetWindowLong.
            SetWindowPos(phh->GetHwnd(), NULL, 0,0,0,0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_FRAMECHANGED) ;
        }

        // Change the rect.
        if (phhNew->IsValidMember(HHWIN_PARAM_RECT))
        {
            phh->GetWindowRect();
            if (phhNew->GetLeft() >= 0)
                phh->rcWindowPos.left = phhNew->GetLeft();
            if (phhNew->GetRight() >= 0)
                phh->rcWindowPos.right = phhNew->GetRight();
            if (phhNew->GetTop() >= 0)
                phh->rcWindowPos.top = phhNew->GetTop();
            if (phhNew->GetBottom() >= 0)
                phh->rcWindowPos.bottom = phhNew->GetBottom();
            if (IsValidWindow(*phh))
                MoveWindow(*phh, phh->GetLeft(), phh->GetTop(),
                    phh->GetWidth(), phh->GetHeight(), TRUE);
        }

        // Change the show state.
        if (phhNew->IsValidMember(HHWIN_PARAM_SHOWSTATE))
        {
            if (IsValidWindow(phh->GetHwnd()))
                ShowWindow(phh->GetHwnd(), phh->GetShowState());
        }

        return phh->GetHwnd();
    }
}

/***************************************************************************

    FUNCTION: GetWinType

    PURPOSE:

    PARAMETERS:
        hwndCaller  -- window requesting this topic
        pszFile     -- file and window

    RETURNS:


    COMMENTS:

    MODIFICATION DATES:
        27-Apr-98


***************************************************************************/
HWND
GetWinType(HWND hwndCaller, LPCSTR pszFile,  HH_WINTYPE** pphh)
{
        CStr cszChmName ;
        CStr cszWindow ;

        // Support global window types
      //
      if(pszFile)
        {
            LPCSTR pszWinType = pszFile;
            if(pszWinType[0]=='>')
                pszWinType++;

            if(pszWinType && IsGlobalWinType(pszWinType))
         {
                CHHWinType* phh = FindWindowType(pszWinType, hwndCaller, cszChmName);
                if (!phh)
                    return (HWND) -1;

                *pphh = phh;
                return phh->GetHwnd();
         }
        }

        // A filename and window type name are required to get the window type.

        if (!GetNameAndWinType(pszFile, cszChmName, cszWindow))
        {
            return (HWND) -1;
        }

        // Read in the chm information.
        if (!IsCompiledHtmlFile(cszChmName, &cszChmName))
        {
            return (HWND) -1;
        }

      CStr cszCompressed ;
      GetCompiledName(cszChmName, &cszCompressed);
        CHmData* phm = FindCurFileData(cszCompressed);
      if (!phm)
      {
         return (HWND) -1;
      }

        // Need to include compiled filename with window lookup
        // since there can be two or more .CHM files with identical window type
        // names, but different definitions

        CHHWinType* phh = FindWindowType(cszWindow, hwndCaller, cszChmName);
        if (!phh)
        {
            //BUG 5004: Not sure what the purpose of all of this stuff is. However,
            // cszWindow doesn't have the '>' prefix and txtDefWindow does...[dalero]
            if (strcmp(cszWindow, (txtDefWindow+1)) != 0)
            {
                AuthorMsg(IDSHHA_NO_HH_GET_WIN_TYPE, cszWindow, hwndCaller, NULL);
            }
            return (HWND) -1;
        }
        *pphh = phh;
        return phh->GetHwnd();

}
/***************************************************************************

    FUNCTION: doDisplaySearch

    PURPOSE:    Save as HH_DISPLAY_TOPIC, but forces search tab to front.

    PARAMETERS:
        hwndCaller  -- window requesting this topic
        pszFile     -- file and optionally the window to display
        pFtsQuery   -- the query information structure.

    RETURNS:
        Window handle on success
        NULL on failure


    COMMENTS:

    MODIFICATION DATES:
        26-Jun-97

***************************************************************************/

HWND doDisplaySearch(HWND hwndCaller, LPCSTR pszFile, HH_FTS_QUERY* pFtsQuery)
{
    //
    // Pre-conditions
    //
    // Null pointers
    ASSERT(IsNonEmptyString(pszFile));
    ASSERT(pFtsQuery);

    if (IsEmptyString(pszFile) || IsBadReadPtr(pFtsQuery, sizeof(HH_FTS_QUERY*)))
    {
        FAIL("HH_DISPLAY_SEARCH: pszFile or pFtsQuery is invalid.") ;
        return NULL;
    }

    // Incorrect structure size.
    if (pFtsQuery->cbStruct != sizeof(HH_FTS_QUERY))
    {
        // REVIEW: means all previous versions fail the instant we change the
        // structure size. We should just fill in the parts of the structure
        // we don't know about.

        FAIL("HH_DISPLAY_SEARCH: pFtsQuery points to structure with incorrect size.");
        return NULL ;
    }

    //
    // Handle parameters.
    //

    // String pointer can be NULL, if search is not seeded.
    // TODO - Query string.

    // Change Proximity
    if (pFtsQuery->iProximity != HH_FTS_DEFAULT_PROXIMITY)
    {
    }

    // Convert Strings
    if (pFtsQuery->fUniCodeStrings)
    {
        FAIL("HH_DISPLAY_SEARCH: fUniCodeStrings is not yet implemented. Ignoring.") ;
    }

    // Manipulate options
    if (pFtsQuery->fStemmedSearch)
    {
        FAIL("HH_DISPLAY_SEARCH: fStemmedSearch is not yet implemented. Ignoring.") ;
    }

    if (pFtsQuery->fTitleOnly)
    {
        FAIL("HH_DISPLAY_SEARCH: fTitleOnly is not yet implemented. Ignoring.") ;
    }

    // Can only Execute if there is a search string.
    if (pFtsQuery->fExecute)
    {
        FAIL("HH_DISPLAY_SEARCH: fExecute is not yet implemented. Ignoring.") ;
    }

    // Merge the window with the filename.
    CStr cszFile(pszFile);
    if (!IsEmptyString(pFtsQuery->pszWindow))
    {
        cszFile += ">";
        // BUGBUG: Doesn't handle UNICODE
        cszFile += pFtsQuery->pszWindow;
    }

    // Display the topic
    HWND hwnd = ReactivateDisplayTopic(hwndCaller, pszFile, 0);

    // Did it succeed?
    if (!hwnd || !IsValidWindow(hwnd))
    {
        FAIL("HH_DISPLAY_SEARCH: Could not start help system.") ;
        return NULL ;
    }

    // BUGBUG: 19-Jun-1997  [ralphw] Why are we doing this? It's already on top
    // Bring help window to front.
    ::BringWindowToTop(hwnd);

    // Change the current tab.
    CHHWinType* phh = FindHHWindowIndex(hwnd);
    ASSERT(phh);
    phh->doSelectTab(HH_TAB_SEARCH) ;

    // TODO: Seed edit box.

    // Done
    return hwnd;
}

/***************************************************************************

    FUNCTION: doDisplayIndex

    PURPOSE:    Does a DISPLAY_TOPIC but ensures that the Index tab is selected.

    PARAMETERS:
        hwndCaller  -- window requesting this topic
        pszFile     -- file and optionally the window to display
        pszKeyword  -- keyword with which to seed edit control


    RETURNS:
        Window handle on success
        NULL on failure

    COMMENTS:

    MODIFICATION DATES:
        26-Jun-97 [dalero] created.

***************************************************************************/

HWND doDisplayIndex(HWND hwndCaller, LPCSTR pszFile, LPCSTR pszKeyword)
{
    //
    // Pre-conditions
    //
    // Null pointers
    ASSERT(IsNonEmptyString(pszFile));

    if (IsEmptyString(pszFile))
    {
        FAIL("HH_DISPLAY_SEARCH: pszFile or pFtsQuery is invalid.") ;
        return NULL;
    }

    // Display the topic
    HWND hwnd = ReactivateDisplayTopic(hwndCaller, pszFile, 0);

    // Did it succeed?
    if (!hwnd || !IsValidWindow(hwnd))
    {
        FAIL("HH_DISPLAY_SEARCH: Could not start help system.") ;
        return NULL ;
    }

    // Bring help window to front.
    ::BringWindowToTop(hwnd);

    // Change the current tab.
    CHHWinType* phh = FindHHWindowIndex(hwnd);
    ASSERT(phh);
    phh->doSelectTab(HH_TAB_INDEX) ;

#define _SEED_ON_
#ifdef _SEED_ON_
    // Seed Edit Control
    //ASSERT(phh->m_pindex != NULL) ;
    if ((phh->m_aNavPane[HH_TAB_INDEX] != NULL) && pszKeyword )
    {
        phh->m_aNavPane[HH_TAB_INDEX]->Seed(pszKeyword) ;
    }
#endif

    // Done
    return hwnd;
}

/***************************************************************************

    FUNCTION: doDisplayToc

    PURPOSE:    Does a DISPLAY_TOPIC but ensures that the TOC tab is selected.

    PARAMETERS:
        hwndCaller  -- window requesting this topic
        pszFile     -- file and optionally the window to display


    RETURNS:
        Window handle on success
        NULL on failure

    COMMENTS:

    MODIFICATION DATES:
        26-Jun-97 [dalero] created.

***************************************************************************/

HWND doDisplayToc(HWND hwndCaller, LPCSTR pszFile, DWORD_PTR dwData)
{
    //
    // Pre-conditions
    //
    // Null pointers
    ASSERT(IsNonEmptyString(pszFile));

    if (IsEmptyString(pszFile))
    {
        FAIL("HH_DISPLAY_SEARCH: pszFile or pFtsQuery is invalid.") ;
        return NULL;
    }

    HWND hwnd = ReactivateDisplayTopic(hwndCaller, pszFile, dwData);

    // Did it succeed?
    if (!hwnd || !IsValidWindow(hwnd))
    {
        FAIL("HH_DISPLAY_SEARCH: Could not start help system.") ;
        return NULL ;
    }
    // Bring help window to front.
    ::BringWindowToTop(hwnd);

    // Change the current tab.
    CHHWinType* phh = FindHHWindowIndex(hwnd);
    ASSERT(phh);
    phh->doSelectTab(HH_TAB_CONTENTS) ;

    // Done
    return hwnd;
}

/***************************************************************************

    FUNCTION:   GetLocationFromTitleTag

    PURPOSE:    Looks in the global col to find the location for this TitleTag

    PARAMETERS:
        pszFile --- Filename of the collection to look in. NULL for global.col
        HH_TITLE_FULLPATH pTitleFullPath


    RETURNS:
        NULL on failure

    COMMENTS:

    MODIFICATION DATES:
        31-Oct-97 [dalero] created.
        03-Apr-98 [dalero] the szCollection parameter is currently not used.

***************************************************************************/

int
GetLocationFromTitleTag(LPCSTR szCollection, HH_TITLE_FULLPATH* pTitleFullPath)
{
    int iReturn = false ;

    // Open a dummy collection.
    CCollection collection ;
    DWORD e = collection.Open(szCollection ? szCollection : "placeholder") ;
    if (e == F_OK)
    {
        // Locates a title based on id
       CTitle* pTitle = collection.FindTitleNonExact(pTitleFullPath->szTag, LANGIDFROMLCID(pTitleFullPath->lcid)) ;
        if (pTitle)
        {
            // Always get the last one.
            LOCATIONHISTORY* pLocationHistory = pTitle->m_pTail;//LOCATIONHISTORY* pLocationHistory = pTitle->GetLocation(/*DWORD Index*/0);
            if (pLocationHistory && pLocationHistory->FileName)
            {
                CWStr wide(pLocationHistory->FileName) ;
                pTitleFullPath->fullpathname = ::SysAllocString(wide) ;
                iReturn = true ;
            }
        }
    }
    return iReturn ;
}

/***************************************************************************

    FUNCTION:   ReactivateDisplayTopic

    PURPOSE:    If default window type exists, returns HWND.
                Otherwise, does an OnDisplayTopic.
                This allows OnDisplayToc and others to not change the current topic when changing the tab.

    PARAMETERS:

    RETURNS:
        NULL on failure

    COMMENTS:

    MODIFICATION DATES:
        13 Jan 98 [dalero] created.

***************************************************************************/
HWND ReactivateDisplayTopic(HWND hwndCaller, LPCSTR pszFile, DWORD_PTR dwData)
{
    // A lot of this is copied from OnDisplayTopic...
    CStr cszFile(pszFile);
    CStr cszCompressed ;
    GetCompiledName(cszFile, &cszCompressed);
    if (FindThisFile(hwndCaller, cszCompressed, &cszCompressed, FALSE))
    {
        // Get the CHmData for this file.
        CHmData* phmData = FindCurFileData(cszCompressed); // Get the
        if (phmData)
        {
            // Get the info for the default window type structure.
            CHHWinType* phh = FindWindowType(phmData->GetDefaultWindow(), hwndCaller, cszCompressed);
            if (phh && phh->GetHwnd() && IsWindow(phh->GetHwnd()))
            {
                WINDOWPLACEMENT wp;
                wp.length = sizeof(WINDOWPLACEMENT);
                GetWindowPlacement(phh->GetHwnd(), &wp);
                if  (wp.showCmd == SW_SHOWMINIMIZED)
                {
                    ShowWindow(phh->GetHwnd(), SW_RESTORE);
                }
				SetForegroundWindow(phh->GetHwnd());
                return phh->GetHwnd() ;
            }
        }
    }

    // Display the topic
    return OnDisplayTopic(hwndCaller, pszFile, 0);
}

/***************************************************************************

    FUNCTION:   ReactivateDisplayTopic

    PURPOSE:    If default window type exists, returns HWND.
                Otherwise, does an OnDisplayTopic.
                This allows OnDisplayToc and others to not change the current topic when changing the tab.

    PARAMETERS:

    RETURNS:
        NULL on failure

    COMMENTS:

    MODIFICATION DATES:
        13 Jan 98 [dalero] created.

***************************************************************************/

bool
SetGlobalProperty(HH_GLOBAL_PROPERTY* prop, CHHWinType *phh)
{
    bool bReturn = false ;
    if (!prop)
        return bReturn;

    switch(prop->id)
    {
    case HH_GPROPID_SINGLETHREAD:
        if (prop->var.vt == VT_BOOL)
        {
            g_fStandAlone = (prop->var.boolVal == VARIANT_TRUE) ;
            bReturn = true ;
        }
        break ;
    case HH_GPROPID_TOOLBAR_MARGIN:
        if ( prop->var.vt == VT_UI4 || prop->var.vt == VT_UINT )
        {
            long L, R;
            R = HIWORD( prop->var.ulVal );
            L = LOWORD( prop->var.ulVal );
            if ( (L == g_tbLeftMargin) && (R == g_tbRightMargin) )
                return TRUE;
            g_tbRightMargin = HIWORD( prop->var.ulVal );
            g_tbLeftMargin  = LOWORD( prop->var.ulVal );
            if ( phh && phh->hwndToolBar )
            {
                ::SendMessage(phh->hwndHelp, WM_SIZE, SIZE_RESTORED, (LPARAM)0 );
               // Due to a repaint bug in IE 3.02 Comctrl with the toolbar, we need to
               // reapint the whole toolbar region including the margins on the left and right.
            RECT rcvoid;
            rcvoid.top = 0;
            rcvoid.bottom = RECT_HEIGHT(phh->rcToolBar);
            rcvoid.left = 0;
            rcvoid.right = RECT_WIDTH(phh->rcWindowPos);
            InvalidateRect(phh->hwndHelp, &rcvoid, TRUE);
            UpdateWindow(phh->hwndHelp);

                bReturn = true ;
            }
        }
        break;
    case HH_GPROPID_UI_LANGUAGE:// Set the language for hhctrl's ui.
        {
            LANGID request = NULL ;
            // Convert the val to a LANGID.
            if (prop->var.vt == VT_I4)
            {
                request = static_cast<LANGID>(prop->var.lVal) ;
            }
            else if (prop->var.vt = VT_I2)
            {
                request = prop->var.iVal ;
            }
            else if (prop->var.vt = VT_UI4)
            {
                request = prop->var.uiVal ;
            }
            else if (prop->var.vt = VT_UI2)
            {
                request = static_cast<LANGID>(prop->var.ulVal) ;
            }
            if (request)
            {
                // Request this langid.
                LANGID result = _Module.m_Language.SetUiLanguage(request) ;
                bReturn = (result == request) ;
            }
        }
        break ;

    case HH_GPROPID_CURRENT_SUBSET:
        {
           if ( prop->var.vt == VT_BSTR && prop->var.bstrVal && *(prop->var.bstrVal) )
           {
              WideCharToMultiByte(CP_ACP, 0, prop->var.bstrVal, -1, _Module.szCurSS, MAX_SS_NAME_LEN, NULL, NULL);
              bReturn = true ; // TODO: Increase robustness!
           }
        }
        break;

    default:
        ASSERT(0) ;
    }

    return bReturn ;
}
//////////////////////////////////////////////////////////////////////////
//
// GetNameAndWinType ---(from pszfile) Splits out the name and window type.
//
bool
GetNameAndWinType(LPCSTR pszFile, CStr& cszName, CStr& cszWindow)
{
    if (IsEmptyString(pszFile))
    {
        return false ;
    }

    // Copy the string.
    cszName = pszFile;

    // Parse out window type.
    PSTR pszWindow = StrChr(cszName, WINDOW_SEPARATOR);
    if (pszWindow != NULL)
    {
        // Terminate the string.
        *pszWindow = '\0';
        RemoveTrailingSpaces(cszName);
        cszWindow = FirstNonSpace(pszWindow + 1);
    }
   else
   {
        if(pszFile && IsGlobalWinType(pszFile))
          cszWindow = pszFile;
   }

    // Must have a window type.
    if (cszWindow.IsNonEmpty())
    {
        // Must either be a global window type, or have a filename.
        if (IsGlobalWinType(cszWindow) || cszName.IsNonEmpty())
        {
            return true ;
        }
    }
    return false;
}

//////////////////////////////////////////////////////////////////////////
//
// Reload the nav panes with data from a different CHM.
// NOTE: This is a dangerous Hack for Office.
//
HWND OnReloadNavData(HWND hwndCaller, LPCSTR pszFile, HH_NAVDATA* pNavData)
{
    // Remember that the members of pNavData are unicode...

    if (IsNonEmptyString(pszFile) // pszFile is not used
        //|| !IsValidWindow(hwndCaller) --- Allows reparenting. See FindWindowType
        || !pNavData
        || IsEmptyStringW(pNavData->pszName)
        || IsEmptyStringW(pNavData->pszFile)
        || !IsGlobalWinTypeW(pNavData->pszName) // Window Type must be global!
        )
    {
        return NULL ;
    }

    // Make sure that we have a compiled filename.
    CStr cszFile(pNavData->pszFile) ; // Convert to ANSI.
    if (!IsCompiledHtmlFile(cszFile, &cszFile))
    {
        return NULL ;
    }

    // Parse out all of the unnecessary bits...
    GetCompiledName(cszFile, &cszFile);
    if (cszFile.IsEmpty())
    {
        return NULL ;
    }

    // Get the CHmData structure for this file.
    CHmData* phmdata = FindCurFileData(cszFile) ;
    if (!phmdata)
    {
        return NULL;
    }

    // Find the window type.
    CStr cszName(pNavData->pszName) ; // Convert to ANSI.
    CHHWinType* phh = FindWindowType(cszName, hwndCaller, NULL) ; // WindowType must be global!
    if (!phh)
    {
        // Couldn't find the window type. It must be defined.
        return NULL ;
    }

    // Go do it!
    phh->ReloadNavData(phmdata) ;

    return phh->GetHwnd() ;
}

//////////////////////////////////////////////////////////////////////////
//
// CSession - This is a placeholder class. This will eventually do something.
//
// This should be moved to its own C++ file...
//
class CSession
{
public:
    CSession();
    ~CSession();
private:
    DWORD* m_dwData ;
};

// Constructor
CSession::CSession()
: m_dwData(0)
{
    //--- Initialize OLE. Competes with process detach/attach.
   if ( !g_fCoInitialized )
   {
      if (S_FALSE == OleInitialize(NULL)) 
	  {
         // shanemc/dalero
         // If S_FALSE is returned OLE was already init'd. We don't want to uninit later 
         // because it can hose apps that have called OleInit (like IE).
         OleUninitialize();
      }
      else
	  {
         g_fCoInitialized = TRUE;    // so that we call CoUninitialize() when dll is unloaded
      }
   }
}

// Destructor
CSession::~CSession()
{
    //--- Unitialize OLE.
    ASSERT(g_fCoInitialized); // Should never be FALSE here.
    if (g_fCoInitialized)
    {
      OleUninitialize();
      g_fCoInitialized = FALSE;
    }
}

//////////////////////////////////////////////////////////////////////////
//
// Initializes everything we need initialized.
//
bool
InitializeSession(UNALIGNED DWORD_PTR* pCookie)
{
    bool bReturn = false ;
    if (pCookie)
    {
        //--- Create a session object.
        CSession* p = new CSession() ;

        // The session object is used as a cookie.
        *pCookie = (DWORD_PTR)p;

        // Initializing a session, implies standalone.
        g_fStandAlone = TRUE ;

        // A-ok
        bReturn = true ;
    }
    return bReturn;
}

//////////////////////////////////////////////////////////////////////////
//
// Uninitalizes everything we need initialized.
//
bool
UninitializeSession(DWORD_PTR Cookie)
{
    bool bReturn = false ;

    ASSERT(g_fStandAlone) ; // Must be standalone.

    //--- Need a valid cookie to uninitialize.
    if (Cookie)
    {
        // Convert to a session pointer.
        CSession* p = reinterpret_cast<CSession*>(Cookie) ;

        // Do something useful.
        bReturn = true ;

        // Delete the session.
        delete p ;
    }
    return bReturn ;
}


//////////////////////////////////////////////////////////////////////////
//
// Private function which returns the interface pointer to the embedded
// WebBrowser control given a particular window handle.
//
bool 
GetBrowserInterface(HWND hWndBrowserParent, IDispatch** ppWebBrowser)
{
    bool bReturn = false ;
    if (IsWindow(hWndBrowserParent) && !IsBadReadPtr(ppWebBrowser, sizeof(IDispatch**)))
    {
        CHHWinType* phh = FindHHWindowIndex(hWndBrowserParent);
        if (phh && 
            phh->m_pCIExpContainer && 
            phh->m_pCIExpContainer->m_pWebBrowserApp && 
            phh->m_pCIExpContainer->m_pWebBrowserApp->m_lpDispatch)
        {
            *ppWebBrowser = phh->m_pCIExpContainer->m_pWebBrowserApp->m_lpDispatch;
            bReturn = true ;
        }
    }
    return bReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\htmlpriv.h ===
#ifndef _HTMLPRIV_H_
#define _HTMLPRIV_H_

// CGID_WebBrowserPriv: {ED016940-BD5B-11cf-BA4E-00C04FD70816}
DEFINE_GUID(CGID_IWebBrowserPriv,0xED016940L,0xBD5B,0x11cf,0xBA,0x4E,0x00,0xC0,0x4F,0xD7,0x08,0x16);

// CommandTarget ids. for private menu driving
enum
{
    HTMLID_FIND         = 1,
    HTMLID_VIEWSOURCE   = 2,
    HTMLID_OPTIONS      = 3,
    HTMLID_CCALLBACK    = 4,    // callback to arbitrary C func
    HTMLID_MENUEXEC     = 5,    // do menu command
    HTMLID_MENUQS       = 6,    // query menu commands
};

#endif //_HTMLPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\htmlhelpid_.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Wed Dec 17 15:51:21 1997
 */
/* Compiler settings for HTMLHelp.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IHHWindowPane = {0x60571de0,0x7735,0x11d1,{0x92,0xa6,0x00,0x60,0x97,0xc9,0xa9,0x82}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\htmlhelp.h ===
/****************************************************************************
*                                                                           *
* HtmlHelp.h                                                                *
*                                                                           *
* Copyright (c) 1996-1997, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __HTMLHELP_H__
#define __HTMLHELP_H__

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#if _MSC_VER < 1200
// Defines for Win64
#ifndef _WIN64
#define DWORD_PTR DWORD
#endif
#endif

// Commands to pass to HtmlHelp()

#define HH_DISPLAY_TOPIC        0x0000
#define HH_HELP_FINDER          0x0000  // WinHelp equivalent
#define HH_DISPLAY_TOC          0x0001  
#define HH_DISPLAY_INDEX        0x0002  
#define HH_DISPLAY_SEARCH       0x0003  
#define HH_SET_WIN_TYPE         0x0004
#define HH_GET_WIN_TYPE         0x0005
#define HH_GET_WIN_HANDLE       0x0006
#define HH_ENUM_INFO_TYPE       0x0007  // Get Info type name, call repeatedly to enumerate, -1 at end
#define HH_SET_INFO_TYPE        0x0008  // Add Info type to filter.
#define HH_SYNC                 0x0009
#define HH_RESERVED1            0x000A
#define HH_RESERVED2            0x000B
#define HH_RESERVED3            0x000C
#define HH_KEYWORD_LOOKUP       0x000D
#define HH_DISPLAY_TEXT_POPUP   0x000E  // display string resource id or text in a popup window
#define HH_HELP_CONTEXT         0x000F  // display mapped numeric value in dwData
#define HH_TP_HELP_CONTEXTMENU  0x0010  // text popup help, same as WinHelp HELP_CONTEXTMENU
#define HH_TP_HELP_WM_HELP      0x0011  // text popup help, same as WinHelp HELP_WM_HELP
#define HH_CLOSE_ALL            0x0012  // close all windows opened directly or indirectly by the caller
#define HH_ALINK_LOOKUP         0x0013  // ALink version of HH_KEYWORD_LOOKUP
#define HH_GET_LAST_ERROR       0x0014  // not currently implemented // See HHERROR.h
#define HH_ENUM_CATEGORY        0x0015	// Get category name, call repeatedly to enumerate, -1 at end
#define HH_ENUM_CATEGORY_IT     0x0016  // Get category info type members, call repeatedly to enumerate, -1 at end
#define HH_RESET_IT_FILTER      0x0017  // Clear the info type filter of all info types.
#define HH_SET_INCLUSIVE_FILTER 0x0018  // set inclusive filtering method for untyped topics to be included in display
#define HH_SET_EXCLUSIVE_FILTER 0x0019  // set exclusive filtering method for untyped topics to be excluded from display
#define HH_INITIALIZE            0x001C  // Initializes the help system.
#define HH_UNINITIALIZE          0x001D  // Uninitializes the help system.
#define HH_SET_QUERYSERVICE     0x001E  // Set the Host IQueryService interface
#define HH_PRETRANSLATEMESSAGE  0x00fd  // Pumps messages. (NULL, NULL, MSG*). 
#define HH_SET_GLOBAL_PROPERTY  0x00fc  // Set a global property. (NULL, NULL, HH_GPROP)

#define HHWIN_PROP_TAB_AUTOHIDESHOW (1 << 0)    // Automatically hide/show tri-pane window
#define HHWIN_PROP_ONTOP            (1 << 1)    // Top-most window
#define HHWIN_PROP_NOTITLEBAR       (1 << 2)    // no title bar
#define HHWIN_PROP_NODEF_STYLES     (1 << 3)    // no default window styles (only HH_WINTYPE.dwStyles)
#define HHWIN_PROP_NODEF_EXSTYLES   (1 << 4)    // no default extended window styles (only HH_WINTYPE.dwExStyles)
#define HHWIN_PROP_TRI_PANE         (1 << 5)    // use a tri-pane window
#define HHWIN_PROP_NOTB_TEXT        (1 << 6)    // no text on toolbar buttons
#define HHWIN_PROP_POST_QUIT        (1 << 7)    // post WM_QUIT message when window closes
#define HHWIN_PROP_AUTO_SYNC        (1 << 8)    // automatically ssync contents and index
#define HHWIN_PROP_TRACKING         (1 << 9)    // send tracking notification messages
#define HHWIN_PROP_TAB_SEARCH       (1 << 10)   // include search tab in navigation pane
#define HHWIN_PROP_TAB_HISTORY      (1 << 11)   // include history tab in navigation pane
#define HHWIN_PROP_TAB_FAVORITES    (1 << 12)   // include favorites tab in navigation pane
#define HHWIN_PROP_CHANGE_TITLE     (1 << 13)   // Put current HTML title in title bar
#define HHWIN_PROP_NAV_ONLY_WIN     (1 << 14)   // Only display the navigation window
#define HHWIN_PROP_NO_TOOLBAR       (1 << 15)   // Don't display a toolbar
#define HHWIN_PROP_MENU             (1 << 16)   // Menu
#define HHWIN_PROP_TAB_ADVSEARCH    (1 << 17)   // Advanced FTS UI.
#define HHWIN_PROP_USER_POS         (1 << 18)   // After initial creation, user controls window size/position
#define HHWIN_PROP_TAB_CUSTOM1      (1 << 19)   // Use custom tab #1
#define HHWIN_PROP_TAB_CUSTOM2      (1 << 20)   // Use custom tab #2
#define HHWIN_PROP_TAB_CUSTOM3      (1 << 21)   // Use custom tab #3
#define HHWIN_PROP_TAB_CUSTOM4      (1 << 22)   // Use custom tab #4
#define HHWIN_PROP_TAB_CUSTOM5      (1 << 23)   // Use custom tab #5
#define HHWIN_PROP_TAB_CUSTOM6      (1 << 24)   // Use custom tab #6
#define HHWIN_PROP_TAB_CUSTOM7      (1 << 25)   // Use custom tab #7
#define HHWIN_PROP_TAB_CUSTOM8      (1 << 26)   // Use custom tab #8
#define HHWIN_PROP_TAB_CUSTOM9      (1 << 27)   // Use custom tab #9
#define HHWIN_TB_MARGIN             (1 << 28)   // the window type has a margin

#define HHWIN_PARAM_PROPERTIES      (1 << 1)    // valid fsWinProperties
#define HHWIN_PARAM_STYLES          (1 << 2)    // valid dwStyles
#define HHWIN_PARAM_EXSTYLES        (1 << 3)    // valid dwExStyles
#define HHWIN_PARAM_RECT            (1 << 4)    // valid rcWindowPos
#define HHWIN_PARAM_NAV_WIDTH       (1 << 5)    // valid iNavWidth
#define HHWIN_PARAM_SHOWSTATE       (1 << 6)    // valid nShowState
#define HHWIN_PARAM_INFOTYPES       (1 << 7)    // valid apInfoTypes
#define HHWIN_PARAM_TB_FLAGS        (1 << 8)    // valid fsToolBarFlags
#define HHWIN_PARAM_EXPANSION       (1 << 9)    // valid fNotExpanded
#define HHWIN_PARAM_TABPOS          (1 << 10)   // valid tabpos
#define HHWIN_PARAM_TABORDER        (1 << 11)   // valid taborder
#define HHWIN_PARAM_HISTORY_COUNT   (1 << 12)   // valid cHistory
#define HHWIN_PARAM_CUR_TAB         (1 << 13)   // valid curNavType

#define HHWIN_BUTTON_EXPAND         (1 << 1)    // Expand/contract button
#define HHWIN_BUTTON_BACK           (1 << 2)    // Back button
#define HHWIN_BUTTON_FORWARD        (1 << 3)    // Forward button
#define HHWIN_BUTTON_STOP           (1 << 4)    // Stop button
#define HHWIN_BUTTON_REFRESH        (1 << 5)    // Refresh button
#define HHWIN_BUTTON_HOME           (1 << 6)    // Home button
#define HHWIN_BUTTON_BROWSE_FWD     (1 << 7)    // not implemented
#define HHWIN_BUTTON_BROWSE_BCK     (1 << 8)    // not implemented
#define HHWIN_BUTTON_NOTES          (1 << 9)    // not implemented
#define HHWIN_BUTTON_CONTENTS       (1 << 10)   // not implemented
#define HHWIN_BUTTON_SYNC           (1 << 11)   // Sync button
#define HHWIN_BUTTON_OPTIONS        (1 << 12)   // Options button
#define HHWIN_BUTTON_PRINT          (1 << 13)   // Print button
#define HHWIN_BUTTON_INDEX          (1 << 14)   // not implemented
#define HHWIN_BUTTON_SEARCH         (1 << 15)   // not implemented
#define HHWIN_BUTTON_HISTORY        (1 << 16)   // not implemented
#define HHWIN_BUTTON_FAVORITES      (1 << 17)   // not implemented
#define HHWIN_BUTTON_JUMP1          (1 << 18)
#define HHWIN_BUTTON_JUMP2          (1 << 19)
#define HHWIN_BUTTON_ZOOM           (1 << 20)
#define HHWIN_BUTTON_TOC_NEXT       (1 << 21)
#define HHWIN_BUTTON_TOC_PREV       (1 << 22)

#define HHWIN_DEF_BUTTONS           \
            (HHWIN_BUTTON_EXPAND |  \
             HHWIN_BUTTON_BACK |    \
             HHWIN_BUTTON_OPTIONS | \
             HHWIN_BUTTON_PRINT)

// Button IDs

#define IDTB_EXPAND             200
#define IDTB_CONTRACT           201
#define IDTB_STOP               202
#define IDTB_REFRESH            203
#define IDTB_BACK               204
#define IDTB_HOME               205
#define IDTB_SYNC               206
#define IDTB_PRINT              207
#define IDTB_OPTIONS            208
#define IDTB_FORWARD            209
#define IDTB_NOTES              210 // not implemented
#define IDTB_BROWSE_FWD         211
#define IDTB_BROWSE_BACK        212
#define IDTB_CONTENTS           213 // not implemented
#define IDTB_INDEX              214 // not implemented
#define IDTB_SEARCH             215 // not implemented
#define IDTB_HISTORY            216 // not implemented
#define IDTB_FAVORITES          217 // not implemented
#define IDTB_JUMP1              218
#define IDTB_JUMP2              219
#define IDTB_CUSTOMIZE          221
#define IDTB_ZOOM               222
#define IDTB_TOC_NEXT           223
#define IDTB_TOC_PREV           224

// Notification codes

#define HHN_FIRST       (0U-860U)
#define HHN_LAST        (0U-879U)

#define HHN_NAVCOMPLETE   (HHN_FIRST-0)
#define HHN_TRACK         (HHN_FIRST-1)
#define HHN_WINDOW_CREATE (HHN_FIRST-2)

typedef struct tagHHN_NOTIFY
{
    NMHDR   hdr;
    PCSTR   pszUrl; // Multi-byte, null-terminated string
} HHN_NOTIFY;

typedef struct tagHH_POPUP
{
    int       cbStruct;      // sizeof this structure
    HINSTANCE hinst;         // instance handle for string resource
    UINT      idString;      // string resource id, or text id if pszFile is specified in HtmlHelp call
    LPCTSTR   pszText;       // used if idString is zero
    POINT     pt;            // top center of popup window
    COLORREF  clrForeground; // use -1 for default
    COLORREF  clrBackground; // use -1 for default
    RECT      rcMargins;     // amount of space between edges of window and text, -1 for each member to ignore
    LPCTSTR   pszFont;       // facename, point size, char set, BOLD ITALIC UNDERLINE
} HH_POPUP;

typedef struct tagHH_AKLINK
{
    int       cbStruct;     // sizeof this structure
    BOOL      fReserved;    // must be FALSE (really!)
    LPCTSTR   pszKeywords;  // semi-colon separated keywords
    LPCTSTR   pszUrl;       // URL to jump to if no keywords found (may be NULL)
    LPCTSTR   pszMsgText;   // Message text to display in MessageBox if pszUrl is NULL and no keyword match
    LPCTSTR   pszMsgTitle;  // Message text to display in MessageBox if pszUrl is NULL and no keyword match
    LPCTSTR   pszWindow;    // Window to display URL in
    BOOL      fIndexOnFail; // Displays index if keyword lookup fails.
} HH_AKLINK;

enum {
    HHWIN_NAVTYPE_TOC,
    HHWIN_NAVTYPE_INDEX,
    HHWIN_NAVTYPE_SEARCH,
    HHWIN_NAVTYPE_FAVORITES,
    HHWIN_NAVTYPE_HISTORY,   // not implemented
    HHWIN_NAVTYPE_AUTHOR,
    HHWIN_NAVTYPE_CUSTOM_FIRST = 11
};

enum {
    IT_INCLUSIVE,
    IT_EXCLUSIVE,
    IT_HIDDEN,
};

typedef struct tagHH_ENUM_IT
{
    int       cbStruct;          // size of this structure
    int       iType;             // the type of the information type ie. Inclusive, Exclusive, or Hidden
    LPCSTR    pszCatName;        // Set to the name of the Category to enumerate the info types in a category; else NULL
    LPCSTR    pszITName;         // volitile pointer to the name of the infotype. Allocated by call. Caller responsible for freeing
    LPCSTR    pszITDescription;  // volitile pointer to the description of the infotype.
} HH_ENUM_IT, *PHH_ENUM_IT;

typedef struct tagHH_ENUM_CAT
{
    int       cbStruct;          // size of this structure
    LPCSTR    pszCatName;        // volitile pointer to the category name
    LPCSTR    pszCatDescription; // volitile pointer to the category description
} HH_ENUM_CAT, *PHH_ENUM_CAT;

typedef struct tagHH_SET_INFOTYPE
{
    int       cbStruct;          // the size of this structure
    LPCSTR    pszCatName;        // the name of the category, if any, the InfoType is a member of.
    LPCSTR    pszInfoTypeName;   // the name of the info type to add to the filter
} HH_SET_INFOTYPE, *PHH_SET_INFOTYPE;

typedef DWORD HH_INFOTYPE;
typedef HH_INFOTYPE* PHH_INFOTYPE;

enum {
    HHWIN_NAVTAB_TOP,
    HHWIN_NAVTAB_LEFT,
    HHWIN_NAVTAB_BOTTOM,
};

#define HH_MAX_TABS 19  // maximum number of tabs

enum {
    HH_TAB_CONTENTS,
    HH_TAB_INDEX,
    HH_TAB_SEARCH,
    HH_TAB_FAVORITES,
    HH_TAB_HISTORY,
    HH_TAB_AUTHOR,

    HH_TAB_CUSTOM_FIRST = 11,
    HH_TAB_CUSTOM_LAST = HH_MAX_TABS
};

#define HH_MAX_TABS_CUSTOM (HH_TAB_CUSTOM_LAST - HH_TAB_CUSTOM_FIRST + 1)

// HH_DISPLAY_SEARCH Command Related Structures and Constants

#define HH_FTS_DEFAULT_PROXIMITY (-1)

typedef struct tagHH_FTS_QUERY
{
    int cbStruct;            // Sizeof structure in bytes.
    BOOL fUniCodeStrings;    // TRUE if all strings are unicode.
    LPCTSTR pszSearchQuery;  // String containing the search query.
    LONG iProximity;         // Word proximity.
    BOOL fStemmedSearch;     // TRUE for StemmedSearch only.
    BOOL fTitleOnly;         // TRUE for Title search only.
    BOOL fExecute;           // TRUE to initiate the search.
    LPCTSTR pszWindow;       // Window to display in
} HH_FTS_QUERY;

// HH_WINTYPE Structure

typedef struct tagHH_WINTYPE {
    int     cbStruct;        // IN: size of this structure including all Information Types
    BOOL    fUniCodeStrings; // IN/OUT: TRUE if all strings are in UNICODE
    LPCTSTR pszType;         // IN/OUT: Name of a type of window
    DWORD   fsValidMembers;  // IN: Bit flag of valid members (HHWIN_PARAM_)
    DWORD   fsWinProperties; // IN/OUT: Properties/attributes of the window (HHWIN_)

    LPCTSTR pszCaption;      // IN/OUT: Window title
    DWORD   dwStyles;        // IN/OUT: Window styles
    DWORD   dwExStyles;      // IN/OUT: Extended Window styles
    RECT    rcWindowPos;     // IN: Starting position, OUT: current position
    int     nShowState;      // IN: show state (e.g., SW_SHOW)

    HWND  hwndHelp;          // OUT: window handle
    HWND  hwndCaller;        // OUT: who called this window

    HH_INFOTYPE* paInfoTypes;  // IN: Pointer to an array of Information Types

    // The following members are only valid if HHWIN_PROP_TRI_PANE is set

    HWND  hwndToolBar;      // OUT: toolbar window in tri-pane window
    HWND  hwndNavigation;   // OUT: navigation window in tri-pane window
    HWND  hwndHTML;         // OUT: window displaying HTML in tri-pane window
    int   iNavWidth;        // IN/OUT: width of navigation window
    RECT  rcHTML;           // OUT: HTML window coordinates

    LPCTSTR pszToc;         // IN: Location of the table of contents file
    LPCTSTR pszIndex;       // IN: Location of the index file
    LPCTSTR pszFile;        // IN: Default location of the html file
    LPCTSTR pszHome;        // IN/OUT: html file to display when Home button is clicked
    DWORD   fsToolBarFlags; // IN: flags controling the appearance of the toolbar
    BOOL    fNotExpanded;   // IN: TRUE/FALSE to contract or expand, OUT: current state
    int     curNavType;     // IN/OUT: UI to display in the navigational pane
    int     tabpos;         // IN/OUT: HHWIN_NAVTAB_TOP, HHWIN_NAVTAB_LEFT, or HHWIN_NAVTAB_BOTTOM
    int     idNotify;       // IN: ID to use for WM_NOTIFY messages
    BYTE    tabOrder[HH_MAX_TABS + 1];    // IN/OUT: tab order: Contents, Index, Search, History, Favorites, Reserved 1-5, Custom tabs
    int     cHistory;       // IN/OUT: number of history items to keep (default is 30)
    LPCTSTR pszJump1;       // Text for HHWIN_BUTTON_JUMP1
    LPCTSTR pszJump2;       // Text for HHWIN_BUTTON_JUMP2
    LPCTSTR pszUrlJump1;    // URL for HHWIN_BUTTON_JUMP1
    LPCTSTR pszUrlJump2;    // URL for HHWIN_BUTTON_JUMP2
    RECT    rcMinSize;      // Minimum size for window (ignored in version 1)
    int     cbInfoTypes;    // size of paInfoTypes;
    LPCTSTR pszCustomTabs;  // multiple zero-terminated strings
} HH_WINTYPE, *PHH_WINTYPE;

enum {
    HHACT_TAB_CONTENTS,
    HHACT_TAB_INDEX,
    HHACT_TAB_SEARCH,
    HHACT_TAB_HISTORY,
    HHACT_TAB_FAVORITES,

    HHACT_EXPAND,
    HHACT_CONTRACT,
    HHACT_BACK,
    HHACT_FORWARD,
    HHACT_STOP,
    HHACT_REFRESH,
    HHACT_HOME,
    HHACT_SYNC,
    HHACT_OPTIONS,
    HHACT_PRINT,
    HHACT_HIGHLIGHT,
    HHACT_CUSTOMIZE,
    HHACT_JUMP1,
    HHACT_JUMP2,
    HHACT_ZOOM,
    HHACT_TOC_NEXT,
    HHACT_TOC_PREV,
    HHACT_NOTES,

    HHACT_LAST_ENUM,
};

typedef struct tagHHNTRACK
{
    NMHDR   hdr;
    PCSTR   pszCurUrl;      // Multi-byte, null-terminated string
    int     idAction;       // HHACT_ value
    HH_WINTYPE* phhWinType; // Current window type structure
} HHNTRACK;

HWND
WINAPI
HtmlHelpA(
    HWND hwndCaller,
    LPCSTR pszFile,
    UINT uCommand,
    DWORD_PTR dwData
    );

HWND
WINAPI
HtmlHelpW(
    HWND hwndCaller,
    LPCWSTR pszFile,
    UINT uCommand,
    DWORD_PTR dwData
    );
#ifdef UNICODE
#define HtmlHelp  HtmlHelpW
#else
#define HtmlHelp  HtmlHelpA
#endif // !UNICODE

// Use the following for GetProcAddress to load from hhctrl.ocx

#define ATOM_HTMLHELP_API_ANSI    (LPTSTR)((DWORD)((WORD)(14)))
#define ATOM_HTMLHELP_API_UNICODE (LPTSTR)((DWORD)((WORD)(15)))

///////////////////////////////////////////////////////////////////////////////
//
// Global Control Properties. 
//
typedef enum tagHH_GPROPID
{
    HH_GPROPID_SINGLETHREAD=1,      // VARIANT_BOOL: True for single thread
    HH_GPROPID_TOOLBAR_MARGIN=2,    // long: Provides a left/right margin around the toolbar.
    HH_GPROPID_UI_LANGUAGE=3,       // long: LangId of the UI.
    HH_GPROPID_CURRENT_SUBSET=4,    // BSTR: Current subset.
    HH_GPROPID_CONTENT_LANGUAGE=5   // long: LandId for desired content.
} HH_GPROPID;

///////////////////////////////////////////////////////////////////////////////
//
// Global Property structure
//
#ifdef __oaidl_h__

#pragma pack(push, 8)

typedef struct tagHH_GLOBAL_PROPERTY
{
    HH_GPROPID  id;
    VARIANT     var;
} HH_GLOBAL_PROPERTY ;

#pragma pack(pop)
#endif

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __HTMLHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\index.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "hha_strtable.h"
#include "strtable.h"
#include "hhctrl.h"
#include "resource.h"
#include "index.h"
#include "htmlhelp.h"
#include "cpaldc.h"
#include "secwin.h"
#include "wwheel.h"
#include "onclick.h"
#include <wininet.h>
#include "secwin.h"
#include "contain.h"
#include "subset.h"
#include "cctlww.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

AUTO_CLASS_COUNT_CHECK( CIndex );

//////////////////////////////////////////////////////////////////////////
//
// Constants
//
#define BOX_HEIGHT 24
#define ODA_CLEAR 0x0008
const int c_StaticControlSpacing = 3; // Space between text and static control.
const int c_ControlSpacing  = 8 ; // Space between two controls.


//////////////////////////////////////////////////////////////////////////
//
// Window Proc Prototypes.
//
LRESULT WINAPI EditProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
WNDPROC lpfnlEditWndProc = NULL;
static LRESULT WINAPI ButtonProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
WNDPROC lpfnlBtnWndProc = NULL;

//////////////////////////////////////////////////////////////////////////
//
// Constructor
//
CIndex::CIndex(CHtmlHelpControl* phhctrl, IUnknown* pUnkOuter, CHHWinType* phh)
: m_hwndResizeToParent(NULL)
{
    m_phhctrl = phhctrl;
    m_pOuter = pUnkOuter;
    m_phh = phh;

    m_hwndEditBox = NULL;
    m_hwndStaticKeyword = NULL ;

    m_hwndListBox = NULL;
    m_hwndDisplayButton = NULL;
    m_fSelectionChange = FALSE;
    m_padding = 0;      // padding to put around the Index
    if (phh)
        m_NavTabPos = phh->tabpos  ;
    else
        m_NavTabPos = HHWIN_NAVTAB_TOP ;

    m_cFonts = 0;
    m_ahfonts = NULL;
    m_fGlobal = FALSE;
    m_hbmpBackGround = NULL;
    m_hbrBackGround = NULL;
    m_langid = PRIMARYLANGID(LANGIDFROMLCID(GetUserDefaultLCID()));
    m_fBinary = FALSE;  // default to FALSE until we find out which index we are reading
    pInfoType = NULL;
    m_bInit = FALSE;
    m_pVList = NULL;
    m_bUnicode = FALSE;
}

CIndex::~CIndex()
{
    DESTROYIFVALID(m_hwndListBox);
    DESTROYIFVALID(m_hwndDisplayButton);
    DESTROYIFVALID(m_hwndEditBox);
    DESTROYIFVALID(m_hwndStaticKeyword);

    if (m_cFonts) {
        for (int i = 0; i < m_cFonts; i++)
            DeleteObject(m_ahfonts[i]);
        lcFree(m_ahfonts);
    }

    if( m_pVList )
      delete m_pVList;
}

void CIndex::HideWindow(void)
{
    ::ShowWindow(m_hwndEditBox, SW_HIDE);
    ::ShowWindow(m_hwndListBox, SW_HIDE);
    ::ShowWindow(m_hwndDisplayButton, SW_HIDE);
    ::ShowWindow(m_hwndStaticKeyword, SW_HIDE);
}

void CIndex::ShowWindow(void)
{
    ::ShowWindow(m_hwndEditBox, SW_SHOW);
    ::ShowWindow(m_hwndListBox, SW_SHOW);
    ::ShowWindow(m_hwndDisplayButton, SW_SHOW);
    ::ShowWindow(m_hwndStaticKeyword, SW_SHOW);

    HWND hWnd;
    char szClassName[MAX_PATH];

    if ( (hWnd = GetParent(m_hwndEditBox)) )
    {
        GetClassName(hWnd, szClassName, sizeof(szClassName));
        if (! lstrcmpi(szClassName, "HHCtrlWndClass") )
        {
            // Ok, we're up as an axtive x control.
            //
            COleControl* pCtl;
            if ( (pCtl = (COleControl*)GetWindowLongPtr(hWnd, GWLP_USERDATA)) )
            {
                pCtl->InPlaceActivate(OLEIVERB_UIACTIVATE);
                return;
            }
        }
    }
    SetFocus(m_hwndEditBox);
}

// Can't inline this because of dereferencing m_phh
//
//
HFONT CIndex::GetContentFont()
{
    if ( m_cFonts && m_ahfonts[m_cFonts - 1] )
       return m_ahfonts[m_cFonts - 1];
    else
    {
       if ( m_phh )
          return m_phh->GetContentFont();
       else
       {
          if ( m_phhctrl && m_phhctrl->GetContentFont() )
             return m_phhctrl->GetContentFont();
          else
          {
             // this is likely the case where the control is being instantiated via object script on an html page. We
             // won't have a phh. Correct thing to do would be to ask IE about content language? Maybe look in the
             // sitemap? For now we'll use the UI font.
             //
             return _Resource.GetUIFont();
          }
       }
    }
}

void
CIndex::InitDlgItemArray()
{
    // Currently we are only using the m_accel member.
    //--- Setup the dlg array for each control.

    //--- Keyword edit control
    int i = c_KeywordEdit;
    m_aDlgItems[i].m_hWnd = m_hwndEditBox ; //::GetDlgItem(m_hWnd, IDEDIT_INDEX) ;
    //::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent) ; // Get screen coordinates.
    //ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDEDIT_INDEX;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_hwndStaticKeyword);              // No accelerator.

    m_aDlgItems[i].m_Type = ItemInfo::Generic;

/* TODO: Finish using this
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE ;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE ;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = TRUE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = TRUE ;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV = ;            // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left
    //m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
    m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
    m_aDlgItems[i].m_iPadV = rectDlg.bottom - rectCurrent.bottom;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax ;        // Max size.
*/

    //--- Display btn
    i = c_DisplayBtn;
    m_aDlgItems[i].m_hWnd = m_hwndDisplayButton; //::GetDlgItem(m_hWnd, IDBTN_DISPLAY) ;
    //::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent) ; // Get screen coordinates.
    //ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDBTN_DISPLAY;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_aDlgItems[i].m_hWnd);

    m_aDlgItems[i].m_Type = ItemInfo::Button;

/* TODO: Finish using this
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE ;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE ;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = TRUE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = TRUE ;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV = ;            // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Left;        // Do we stick to the right or the left
    //m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
    m_aDlgItems[i].m_iPadH = rectDlg.right - rectCurrent.right; // Maintain same distance. If someone to the right grows we are broken.
    m_aDlgItems[i].m_iPadV = rectDlg.bottom - rectCurrent.bottom;

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax ;        // Max size.
*/


}

BOOL CIndex::Create(HWND hwndParent)
{
    /* Note: hwndParent is either the Navigation Frame or its the tab ctrl.
        This class does not parent to the tab ctrl, but to the navigation frame.
        GetParentSize will always return the hwndNavigation, if hwndParent is the
        tabctrl.
        The reason that it doesn't parent to the tab ctrl is that the tab ctrl
        steals commands. What should really have happened is that all of the windows
        in this control should be contained in another window. However, its too late to
        change this now.
    */

    RECT rcParent, rcChild;
    // Save the hwndParent for ResizeWindow.
    m_hwndResizeToParent = hwndParent ;

    // Note: GetParentSize will return hwndNavigation if hwndParent is the
    // tab ctrl.
    // ???BUG??? Is bypassing the tab ctrl in the parenting structure causing painting problems?
    hwndParent = GetParentSize(&rcParent, hwndParent, m_padding, m_NavTabPos);
    rcParent.top += GetSystemMetrics(SM_CYSIZEFRAME)*2 ; //HACK: Fudge the top since we are not parented to the tabctrl.

    CopyRect(&rcChild, &rcParent);

    //--- Keyword Static Text Control
    // Place the "Keyword" static text on top of the edit control
    m_hwndStaticKeyword = W_CreateWindowEx(WS_EX_TRANSPARENT, L"STATIC", GetStringResourceW(IDS_TYPE_KEYWORD),
        WS_CHILD , rcChild.left, rcChild.top,
        RECT_WIDTH(rcChild), BOX_HEIGHT, hwndParent,
        (HMENU) ID_STATIC_KEYWORDS, _Module.GetModuleInstance(), NULL, &m_bUnicode);

    if (!m_hwndStaticKeyword)
    {
        return FALSE ;
    }

    // Get the dimensions of the text for sizing and spacing needs.
    DWORD dwExt = GetStaticDimensions( m_hwndStaticKeyword, _Resource.GetUIFont(), GetStringResource(IDS_TYPE_KEYWORD), RECT_WIDTH(rcChild) );
    rcChild.bottom = rcChild.top+HIWORD(dwExt) ;
    MoveWindow(m_hwndStaticKeyword, rcChild.left, rcChild.top,
               RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), FALSE );

    //--- Edit Control
    // Space out.
    RECT rcEdit; // Save so that we can use rcChild for the display button.
    CopyRect(&rcEdit, &rcChild) ;
    rcEdit.top = rcChild.bottom + c_StaticControlSpacing; // Add space between static and control.
    rcEdit.bottom = rcEdit.top + BOX_HEIGHT;

    // Create edit control.
    m_hwndEditBox = W_CreateWindowEx(WS_EX_CLIENTEDGE | g_RTL_Style, L"EDIT", L"",
        WS_CHILD | WS_BORDER | WS_TABSTOP | ES_AUTOHSCROLL, rcEdit.left, rcEdit.top,
        RECT_WIDTH(rcEdit), RECT_HEIGHT(rcEdit), hwndParent,
        (HMENU) IDEDIT_INDEX, _Module.GetModuleInstance(), NULL, &m_bUnicode);

    if (!m_hwndEditBox)
    {
        DestroyWindow(m_hwndStaticKeyword) ;
        return FALSE;
    }
    // Sub-class the edit box
    if (lpfnlEditWndProc == NULL)
        lpfnlEditWndProc = W_GetWndProc(m_hwndEditBox, m_bUnicode);
    W_SubClassWindow (m_hwndEditBox, (LONG_PTR) EditProc, m_bUnicode);

    //--- Display Button.
    // Align from the bottom.
    RECT rcDisplayBtn ;
    CopyRect(&rcDisplayBtn, &rcChild) ;
    rcDisplayBtn.bottom = rcParent.bottom ; //Changed from +2.
    rcDisplayBtn.top = rcParent.bottom - BOX_HEIGHT;

    // Create
    m_hwndDisplayButton = W_CreateWindow(L"button",
        (LPCWSTR)GetStringResourceW(IDS_ENGLISH_DISPLAY),
        WS_CHILD | WS_TABSTOP, rcDisplayBtn.left, rcDisplayBtn.top,
        RECT_WIDTH(rcDisplayBtn), RECT_HEIGHT(rcDisplayBtn), hwndParent,
        (HMENU) IDBTN_DISPLAY, _Module.GetModuleInstance(), NULL, &m_bUnicode);

    if (!m_hwndDisplayButton) {
        DestroyWindow(m_hwndEditBox);
        DestroyWindow(m_hwndStaticKeyword) ;
        return FALSE;
    }
    // Sub-class the "display" button ?
    //
    if ( m_phh )
    {
       if (lpfnlBtnWndProc == NULL)
          lpfnlBtnWndProc = W_GetWndProc(m_hwndDisplayButton, m_bUnicode);
       W_SubClassWindow(m_hwndDisplayButton, (LONG_PTR)ButtonProc, m_bUnicode);
       SETTHIS(m_hwndDisplayButton);
    }

    //--- ListView.
    // Space
    rcChild.top = rcEdit.bottom + c_ControlSpacing ;
    rcChild.bottom = rcDisplayBtn.top - c_ControlSpacing ;

    m_pVList = new CVirtualListCtrl(
        (m_phh && m_phh->m_phmData ? m_phh->m_phmData->m_sysflags.lcid : g_lcidSystem));
    if (! (m_hwndListBox = m_pVList->CreateVlistbox(hwndParent, &rcChild)) )
    {
       DestroyWindow(m_hwndDisplayButton);
       DestroyWindow(m_hwndEditBox);
       DestroyWindow(m_hwndStaticKeyword) ;
       return FALSE;
    }

    if (m_pszFont) {
        if (!m_fGlobal) {
            m_cFonts++;
            if (m_cFonts == 1)
                m_ahfonts = (HFONT*) lcMalloc(m_cFonts * sizeof(HFONT));
            else
                m_ahfonts = (HFONT*) lcReAlloc(m_ahfonts, m_cFonts * sizeof(HFONT));

            INT iCharset = -1;
            if ( m_phh )
               iCharset = m_phh->GetContentCharset();
            else if ( m_phhctrl )
               iCharset = m_phhctrl->GetCharset();
            m_ahfonts[m_cFonts - 1] = CreateUserFont(m_pszFont, NULL, NULL, iCharset);
        }
    }

    // Use a more readable font

    if ( m_phh && !m_ahfonts )
       SendMessage(m_hwndListBox, WM_SETFONT, (WPARAM) m_phh->GetAccessableContentFont(), FALSE);
    else
       SendMessage(m_hwndListBox, WM_SETFONT, (WPARAM) GetContentFont(), FALSE);
    SendMessage(m_hwndEditBox, WM_SETFONT, (WPARAM) GetContentFont(), FALSE);
    SendMessage(m_hwndDisplayButton, WM_SETFONT, (WPARAM) _Resource.GetUIFont(), FALSE);
    SendMessage(m_hwndStaticKeyword, WM_SETFONT, (WPARAM) _Resource.GetUIFont(), FALSE);

    //BUGBUG: Doesn't resize any of the other controls.
    dwExt = GetButtonDimensions(m_hwndDisplayButton, _Resource.GetUIFont(), GetStringResource(IDS_ENGLISH_DISPLAY));
    MoveWindow(m_hwndDisplayButton, rcDisplayBtn.right - LOWORD(dwExt), rcDisplayBtn.top,
        LOWORD(dwExt), HIWORD(dwExt), FALSE);

    m_listbox.m_hWnd = m_hwndListBox;
    FillListBox();

    if (!m_fGlobal)
       m_pVList->PaintParamsSetup(m_clrBackground, m_clrForeground, m_pszBackBitmap);

    // Initialize the array containing the dialog information.
    InitDlgItemArray() ;

    ShowWindow();

    return TRUE;
}
//////////////////////////////////////////////////////////////////////////
//
// ResizeWindow
//
void CIndex::ResizeWindow()
{
    ASSERT(::IsValidWindow(m_hwndEditBox)) ;

    // Resize to fit the client area of the parent.
    HWND hwndParent = m_hwndResizeToParent ;
    ASSERT(::IsValidWindow(hwndParent)) ;

    RECT rcParent, rcChild;
    GetParentSize(&rcParent, hwndParent, m_padding, m_NavTabPos);
    rcParent.top += GetSystemMetrics(SM_CYSIZEFRAME)*2 ; //HACK: Fudge the top since we are not parented to the tabctrl.

    CopyRect(&rcChild, &rcParent);

    //--- Keyword Static Control
    // Resize the Static above the combo control
    RECT rcStatic ;
    CopyRect(&rcStatic, &rcChild) ;
    DWORD dwExt = GetStaticDimensions( m_hwndStaticKeyword, _Resource.GetUIFont(), GetStringResource(IDS_TYPE_KEYWORD), RECT_WIDTH(rcChild) );
    rcStatic.bottom = rcChild.top+HIWORD(dwExt);
    MoveWindow(m_hwndStaticKeyword, rcStatic.left, rcStatic.top,
                RECT_WIDTH(rcStatic), RECT_HEIGHT(rcStatic), TRUE);

    //--- Edit Control
    RECT rcEdit ;
    CopyRect(&rcEdit, &rcChild) ;
    rcEdit.top = rcStatic.bottom + c_StaticControlSpacing; //space for the static

    dwExt = GetStaticDimensions( m_hwndEditBox, GetContentFont(), "Test", RECT_WIDTH(rcEdit) );
    rcEdit.bottom = rcEdit.top+HIWORD(dwExt) + GetSystemMetrics(SM_CYSIZEFRAME)*2 ;
    MoveWindow(m_hwndEditBox, rcEdit.left, rcEdit.top, RECT_WIDTH(rcEdit), RECT_HEIGHT(rcEdit), TRUE);

    //--- Display Button
    RECT rcDisplayBtn;
    CopyRect(&rcDisplayBtn, &rcChild) ;
    dwExt = GetButtonDimensions(m_hwndDisplayButton, _Resource.GetUIFont(), GetStringResource(IDS_ENGLISH_DISPLAY));
    rcDisplayBtn.bottom = rcParent.bottom ;
    rcDisplayBtn.top = rcParent.bottom - HIWORD(dwExt);
    MoveWindow(m_hwndDisplayButton, rcDisplayBtn.right - LOWORD(dwExt), rcDisplayBtn.top,
        LOWORD(dwExt), HIWORD(dwExt), TRUE);

    //--- List Control
    rcChild.top = rcEdit.bottom + c_ControlSpacing;
    rcChild.bottom = rcDisplayBtn.top - c_ControlSpacing;
    MoveWindow(m_hwndListBox, rcChild.left,
        rcChild.top, RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), TRUE);
}

///////////////////////////////////////////////////////////
//
// SeedEditCtrl - Places text into the edit control
//
void CIndex::Seed(WCHAR* pwszSeed)
{
   if (IsValidWindow(m_hwndEditBox))
   {
      if (pwszSeed == NULL)
         pwszSeed = L"";
      
      if ( GetVersion() < 0x80000000 )      // If NT...
         SetWindowTextW(m_hwndEditBox, pwszSeed);
      else
      {
         char szTmp[MAX_URL];

         WideCharToMultiByte(CP_ACP, 0, pwszSeed, -1, szTmp, MAX_URL, 0, 0);
         
         SetWindowText(m_hwndEditBox, szTmp);
      }
   }
}

//
// Narrow seed function is a fallback only. Callers are advised to use the wide version.
//
void CIndex::Seed(LPCSTR pszSeed)
{
   UINT uiCP;
   WCHAR  wszBuf[MAX_URL];

   if ( GetVersion() < 0x80000000 )      // If NT i.e. UNICODE OS
   {
      if ( m_phh )
         uiCP = m_phh->GetCodePage();
      else if ( m_phhctrl )
         uiCP = m_phhctrl->GetCodePage();
      else
         uiCP = CP_ACP;

      MultiByteToWideChar(uiCP, 0, pszSeed, -1, wszBuf, MAX_URL);
      Seed(wszBuf);
   }
   else
   {
      if (IsValidWindow(m_hwndEditBox))
      {
         if (pszSeed == NULL)
            pszSeed = "";
         SetWindowText(m_hwndEditBox, pszSeed);
      }
   }
}


/***************************************************************************

    FUNCTION:   CHtmlHelpControl::LoadIndexFile

    PURPOSE:

    PARAMETERS:
        pszMasterFile

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        12-Jul-1997 [ralphw]

***************************************************************************/

BOOL CHtmlHelpControl::LoadIndexFile(PCSTR pszMasterFile)
{
    TCHAR szPath[MAX_PATH+10];
    if (!ConvertToCacheFile(pszMasterFile, szPath)) {
        szPath[0] = '\0';
        if (!IsCompiledHtmlFile(pszMasterFile) && m_pWebBrowserApp) {
            CStr cszCurUrl;
            m_pWebBrowserApp->GetLocationURL(&cszCurUrl);
            PSTR pszChmSep = strstr(cszCurUrl, txtDoubleColonSep);
            if (pszChmSep) {    // this is a compiled HTML file
                strcpy(pszChmSep + 2, pszMasterFile);
                strcpy(szPath, cszCurUrl);
            }
        }
        if (!szPath[0]) {
            CStr cszMsg(IDS_CANT_FIND_FILE, pszMasterFile);
            MsgBox(cszMsg);
            return FALSE;
        }
    }

    m_pindex = new CIndex(this, m_pUnkOuter, NULL);

    UINT CodePage = 0;
    if( m_pindex && m_pindex->m_phh && m_pindex->m_phh->m_phmData ) {
      CodePage = m_pindex->m_phh->m_phmData->GetInfo()->GetCodePage();
    }

    if (!m_pindex->ReadFromFile(szPath, TRUE, this, CodePage))
        return FALSE;

    return TRUE;
}

BOOL CIndex::ReadIndexFile( PCSTR pszFile )
{
    UINT CodePage = 0;
    if( m_phh && m_phh->m_phmData ) {
      CodePage = m_phh->m_phmData->GetInfo()->GetCodePage();
    }

    // check for binary version of the keyword word wheel
    if (m_phh->m_phmData) {
        if (HashFromSz(FindFilePortion(pszFile)) != m_phh->m_phmData->m_hashBinaryIndexName) {
            return ReadFromFile(pszFile, TRUE, NULL, CodePage);
        }

        CExTitle* pTitle;
        CFileSystem* pFS;
        CSubFileSystem* pSFS;

        if ((pTitle = m_phh->m_phmData->m_pTitleCollection->GetFirstTitle())) {
            pFS = pTitle->GetTitleIdxFileSystem();
            pSFS = new CSubFileSystem(pFS);
            if (SUCCEEDED(pSFS->OpenSub("$WWKeywordLinks\\Property")))
                m_fBinary = TRUE;
            delete pSFS;
        }
    }
    if (m_fBinary)
        return m_fBinary;

    return ReadFromFile(pszFile, TRUE, NULL, CodePage);
}

void CIndex::FillListBox(BOOL fReset)
{
    ASSERT(IsValidWindow(m_hwndListBox));
    if (!IsValidWindow(m_hwndListBox))
        return;

    int iCount = 0;
    if (m_fBinary) {
        CWordWheel* pWordWheel;
        if (m_phh->m_phmData)
            pWordWheel = m_phh->m_phmData->m_pTitleCollection->m_pDatabase->GetKeywordLinks();
        else
            pWordWheel = NULL;
        if (pWordWheel)
            iCount = pWordWheel->GetCount();

#if 0   // subset test code

        // now loop thru each item in the list and if they exist (in the subset),
        // then add the wordwheel dword to the item data entry (entry map)
        DWORD dwStart = GetTickCount();
        int iCountSubset = 0;

        DWORD* pdwSubsetArray = new DWORD[iCount];
        CStructuralSubset* pSubset = NULL;
        CExTitle* pTitle = NULL;

        for( int iKeyword = 0; iKeyword < iCount; iKeyword++ ) {
          BOOL bAddItem = FALSE;

          // perf enhancement (cache all data for this keyword)
          pWordWheel->GetIndexData( iKeyword, TRUE );

          // if place holder add the item and continue
          if( pWordWheel->IsPlaceHolder( iKeyword ) ) {
            bAddItem = TRUE;
          }
          // scan the hits, if at least one is in the subset then add the item and continue
          else {
            DWORD dwHitCount = pWordWheel->GetHitCount( iKeyword );
            for( DWORD i = 0; i < dwHitCount; i++ ) {
              DWORD dwURLId = pWordWheel->GetHit( iKeyword, i, &pTitle);
              if( !pSubset && pTitle->m_pCollection->m_pSSList ) {
                pSubset = pTitle->m_pCollection->m_pSSList->GetF1();
                if( !pSubset )
                  break;
              }
              if( pTitle->m_pCollection && pTitle->m_pCollection->m_pSSList ) {
                if( pSubset && pSubset->IsTitleInSubset(pTitle) ) {
                  bAddItem = TRUE;
                  break;
                }
              }
            }
          }

          // add the item if found
          if( bAddItem ) {
            pdwSubsetArray[iCountSubset] = iKeyword;
            iCountSubset++;
          }

        }
        DWORD dwEnd = GetTickCount();
        char szTime[1024];
        sprintf( szTime, "Subset Filtering took:\n%d seconds\n%d original items\n%d final items",
          (dwEnd-dwStart)/1000, iCount, iCountSubset );
        MsgBox( szTime, MB_OK );

        delete [] pdwSubsetArray;

#endif   // end of subset test code

    }
    else {
        iCount = CountStrings();
    }
    m_pVList->SetItemCount(iCount);
    m_bInit = TRUE;
}

void CIndex::OnVKListNotify(NMHDR* pNMHdr)
{
   PVLC_ITEM pVlcItem = NULL;
   int pos;
   SITEMAP_ENTRY* pSiteMapEntry;
   WCHAR wszKeyword[HHWW_MAX_KEYWORD_LENGTH+1];
   CWordWheel* pWordWheel = NULL;

   switch(pNMHdr->code)
   {
      case NM_RDBLCLK:
         break;

      case NM_RCLICK:
         break;

      case NM_CLICK:
         break;

      case NM_KILLFOCUS:
         break;

      case NM_SETFOCUS:
         break;

      case VLN_TAB:
          if (GetKeyState(VK_SHIFT) < 0)
            SetFocus(m_hwndEditBox);
       else
            SetFocus(m_hwndDisplayButton);
         break;

      case VLN_GETITEM:
         pVlcItem = (PVLC_ITEM)pNMHdr;
         if (m_fBinary)
         {
             CWordWheel* pWordWheel;
             if (m_phh->m_phmData)
                 pWordWheel = m_phh->m_phmData->m_pTitleCollection->m_pDatabase->GetKeywordLinks();
             else
                 pWordWheel = NULL;
             if (pWordWheel) {
                 if (pWordWheel->GetString(pVlcItem->iItem, pVlcItem->lpwsz, pVlcItem->cchMax)) {
                     pVlcItem->iLevel = pWordWheel->GetLevel(pVlcItem->iItem) + 1;
                     BOOL bFound = FALSE;
                     CExTitle* pTitle = NULL;
                     WCHAR wszSeeAlso[1024];
                     if( pWordWheel->IsPlaceHolder(pVlcItem->iItem) )
                       bFound = TRUE;
                     else if( pWordWheel->GetSeeAlso(pVlcItem->iItem, wszSeeAlso, sizeof(wszSeeAlso) ) )
                       bFound = TRUE;
                     else {
                       DWORD dwHitCount = pWordWheel->GetHitCount(pVlcItem->iItem);
                       for (DWORD i = 0; i < dwHitCount; i++) {
                         DWORD dwURLId = pWordWheel->GetHit(pVlcItem->iItem, i, &pTitle);

                         // Structural subset filter ?
                         //
                         CStructuralSubset* pSubset;
                         if( pTitle->m_pCollection && pTitle->m_pCollection->m_pSSList &&
                             (pSubset = pTitle->m_pCollection->m_pSSList->GetF1()) && !pSubset->IsEntire() )
                         {
                            // Yes, filter using the current structural subset for F1.
                            //
                            if (! pSubset->IsTitleInSubset(pTitle) ) {
                               continue;
                            }
                         }
                         bFound = TRUE;
                         break;
                       }
                     }

                     if( !bFound )
                       pVlcItem->dwFlags = 0x1;
                     else
                       pVlcItem->dwFlags = 0;
                 }
             }
         }
         else
         {
             // +1 because Ctable is 1-based
             SITEMAP_ENTRY* pSiteMapEntry = GetSiteMapEntry(pVlcItem->iItem + 1);
             if (pSiteMapEntry) {
                pSiteMapEntry->GetKeyword(pVlcItem->lpwsz, pVlcItem->cchMax);
                if(pVlcItem->cchMax)
                    pVlcItem->lpwsz[pVlcItem->cchMax-1] = 0;     // null terminate the string
                pVlcItem->iLevel = pSiteMapEntry->GetLevel();
                pVlcItem->dwFlags = 0;
             }
         }
         break;

      case VLN_SELECT:
         if( m_fBinary )
         {
           if (m_phh->m_phmData)
             pWordWheel = m_phh->m_phmData->m_pTitleCollection->m_pDatabase->GetKeywordLinks();
         }
         pos = m_pVList->GetSelection();
         m_fSelectionChange = TRUE; // ignore EN_CHANGE

         if (m_fBinary) {
             if (pWordWheel) {
                 int iIndex = pos;
                 if( pWordWheel->GetString(iIndex, wszKeyword, (sizeof(wszKeyword)/2), TRUE) )
                     Seed(wszKeyword);
                 else
                     Seed((WCHAR*)NULL);
             }
         }
         else {
             pSiteMapEntry = GetSiteMapEntry(pos + 1);
             Seed(pSiteMapEntry->GetKeyword());
         }
         m_fSelectionChange = FALSE;   // ignore EN_CHANGE
         break;

      case NM_RETURN:
      case NM_DBLCLK:
         PostMessage(FindMessageParent(m_hwndListBox), WM_COMMAND, MAKELONG(IDBTN_DISPLAY, BN_CLICKED), 0);
         break;
   }
   return;
}

void CHtmlHelpControl::OnSizeIndex(LPRECT prc)
{
    RECT rc;
    GetClientRect(GetParent(m_hwnd), &rc);

    InflateRect(&rc,
        m_hpadding == -1 ? 0 : -m_hpadding,
        m_vpadding == -1 ? 0 : -m_vpadding);

    RECT rcButton;
    GetWindowRect(m_hwndDisplayButton, &rcButton);

    MoveWindow(m_hwndDisplayButton, rc.right - RECT_WIDTH(rcButton), rc.top, RECT_WIDTH(rcButton),
        RECT_HEIGHT(rcButton), TRUE);
}

// This function has the lookup code, so we want it as fast as possible

#ifndef _DEBUG
#pragma optimize("Ot", on)
#endif

LRESULT CIndex::OnCommand(HWND hwnd, UINT id, UINT uNotifiyCode, LPARAM /*lParam*/)
{
    CStr cszKeyword;
    int pos;
    SITEMAP_ENTRY* pSiteMapEntry;
    int i;
    WCHAR wszKeyword[HHWW_MAX_KEYWORD_LENGTH+1];
    CHAR szKeyword[HHWW_MAX_KEYWORD_LENGTH+1];
    CWordWheel* pWordWheel = NULL;
    CExCollection* pTitleCollection = NULL;

  // Sometimes the lame main wndproc will route messages here that do not belong
  // to the index and thus this can result in a re-entrant call to our
  // binary word wheel (because the call may occur during initialization).
  //
  // Thus to work around this we need to detect when the call is bogus and skip
  // the message.
  //
  // We can tell if the window associated with this index has been created
  // by checking the m_bInit value, since it will always be set once the list box
  // is filled.  If it is not set then bail out since these messages are not
  // for the index window.
  if( !m_bInit )
    return 0;

 if( m_fBinary )
   if (m_phh->m_phmData) {
     pTitleCollection = m_phh->m_phmData->m_pTitleCollection;
     pWordWheel = pTitleCollection->m_pDatabase->GetKeywordLinks();
   }

    switch (id) {
        case IDEDIT_INDEX:
        {
            if (uNotifiyCode != EN_CHANGE)
                return 0;
            if (m_fSelectionChange) {
                m_fSelectionChange = FALSE;
                return 0;
            }
            CStr cszKeyword(m_hwndEditBox);
            CWStr cwszKeyword(m_hwndEditBox);
            if (!*cszKeyword.psz)
                return 0;

            if (m_fBinary) {
                if (pWordWheel) {
                    DWORD dwIndex = 0;
                    if( m_bUnicode )
                      dwIndex = pWordWheel->GetIndex(cwszKeyword.pw);
                    else
                      dwIndex = pWordWheel->GetIndex(cszKeyword.psz);

                    if (dwIndex != HHWW_ERROR) {
                        m_pVList->SetTopIndex(dwIndex);
                        m_pVList->SetSelection(dwIndex, FALSE);
                    }
                }
            }
            else {

                /*
                 * REVIEW: This could be sped up by having a first character
                 * lookup, ala the RTF tokens in lex.cpp (hcrtf). Putting this
                 * in the thread would also improve user responsiveness.
                 */

                for (i = 1; i <= CountStrings(); i++) {
                    pSiteMapEntry = GetSiteMapEntry(i);
                    ASSERT_COMMENT(pSiteMapEntry->GetKeyword(), "Index entry added without a keyword");

                    /*
                     * Unless the user specifically requested it, we
                     * don't allow the keyboard to be used to get to
                     * anything other then first level entries.
                     */

                    if (!g_fNonFirstKey && pSiteMapEntry->GetLevel() > 1)
                        continue;

                    BOOL bFound = FALSE;
                    if( m_bUnicode ) {
                      pSiteMapEntry->GetKeyword( wszKeyword, sizeof(wszKeyword)/2 );
                      if( isSameString( wszKeyword, cwszKeyword) )
                        bFound = TRUE;
                    }
                    else {
                      // BUGBUG: isSameString is not lcid aware
                      if( isSameString(pSiteMapEntry->GetKeyword(), cszKeyword) )
                        bFound = TRUE;
                    }

                    if( bFound ) {
                       m_pVList->SetTopIndex(i - 1);
                       m_pVList->SetSelection(i - 1, FALSE);
                       break;
                    }
                }

            }
        }
        return 0;

        case IDBTN_DISPLAY:
            if (uNotifiyCode == BN_CLICKED) {
                pos = m_pVList->GetSelection();
                CStr cszKeyword(m_hwndEditBox);
                CWStr cwszKeyword(m_hwndEditBox);

                if (m_fBinary) {
                    if (pWordWheel) {
                        int iIndex = pos;
                        if( m_bUnicode )
                          pWordWheel->GetString(iIndex, wszKeyword, sizeof(wszKeyword)/2);
                        else
                          pWordWheel->GetString(iIndex, szKeyword, sizeof(szKeyword));
                    }
                }
                else {
                    pSiteMapEntry = GetSiteMapEntry(pos + 1);
                    if (!pSiteMapEntry)
                        break;  // happens with an empty index
                }

                if (m_fBinary) {
                    if (pWordWheel) {
                        int iIndex = pos;
                        if( pWordWheel->IsPlaceHolder(iIndex) ) {
                            MsgBox(IDS_HH_E_KEYWORD_IS_PLACEHOLDER, MB_OK | MB_ICONWARNING);
                            return 0;
                        }
                        if( m_bUnicode ) {
                          if( pWordWheel->GetSeeAlso(iIndex, wszKeyword, sizeof(wszKeyword)/2) ) {
                            Seed(wszKeyword);
                            return 0;
                          }
                        }
                        else {
                          if( pWordWheel->GetSeeAlso(iIndex, szKeyword, sizeof(szKeyword)/2) ) {
                            Seed(szKeyword);
                            return 0;
                          }
                        }
                    }
                }
                else {
                    if (pSiteMapEntry->fSeeAlso) {

                        /*
                         * A See Also entry simply jumps to another location
                         * in the Index.
                         */
                        Seed(GetUrlString(pSiteMapEntry->pUrls->urlPrimary));
                        return 0;
                    }
                }


                // If we have one or more titles, then give the user
                // a choice of what to jump to.

                if (m_fBinary) {
                    if( pWordWheel ) {
                        DWORD dwIndex = pos;
                        DWORD dwHitCount = pWordWheel->GetHitCount(dwIndex);
                        UINT CodePage = pTitleCollection->GetMasterTitle()->GetInfo()->GetCodePage();
                        CWTable tblTitles( CodePage );
                        CTable  tblURLs;
                        CWTable tblLocations( CodePage );
                        BOOL bExcludedBySubset = FALSE;
                        BOOL bExcludedByInfoType = FALSE;

                        if (dwHitCount != HHWW_ERROR) {
                            for (DWORD i = 0; i < dwHitCount; i++) {
                                CExTitle* pTitle = NULL;
                                DWORD dwURLId = pWordWheel->GetHit(dwIndex, i, &pTitle);
                                if (pTitle && dwURLId != HHWW_ERROR) {

                                 #if 0 // infotypes not supported
                                   CSubSet* pSS;
                                   const unsigned int *pdwITBits;
                                    // Filter it?
                                    if( pTitle->m_pCollection && pTitle->m_pCollection->m_pSubSets &&
                                        (pSS = pTitle->m_pCollection->m_pSubSets->GetIndexSubset()) &&
                                        !pSS->m_bIsEntireCollection ) {
                                      pdwITBits = pTitle->GetTopicITBits(dwURLId);
                                      if( !pTitle->m_pCollection->m_pSubSets->fIndexFilter(pdwITBits) ) {
                                        bExcludedByInfoType = TRUE;
                                        continue;
                                      }
                                    }
                                 #endif

                                    // Structural subset filter ?
                                    //
                                    CStructuralSubset* pSubset;
                                    if( pTitle->m_pCollection && pTitle->m_pCollection->m_pSSList &&
                                        (pSubset = pTitle->m_pCollection->m_pSSList->GetF1()) && !pSubset->IsEntire() )
                                    {
                                       // Yes, filter using the current structural subset for F1.
                                       //
                                       if (! pSubset->IsTitleInSubset(pTitle) ) {
                                          bExcludedBySubset = TRUE;
                                          continue;
                                       }
                                    }
                                    char szTitle[1024];
                                    szTitle[0] = 0;
                                    pTitle->GetTopicName( dwURLId, szTitle, sizeof(szTitle) );
                                    if( !szTitle[0] )
                                      strcpy( szTitle, GetStringResource( IDS_UNTITLED ) );

                                    char szLocation[INTERNET_MAX_PATH_LENGTH];
                                    szLocation[0] = 0;
                                    if( pTitle->GetTopicLocation(dwURLId, szLocation, INTERNET_MAX_PATH_LENGTH) != S_OK )
                                      strcpy( szLocation, GetStringResource( IDS_UNKNOWN ) );

                                    char szURL[INTERNET_MAX_URL_LENGTH];
                                    szURL[0] = 0;
                                    pTitle->GetTopicURL( dwURLId, szURL, sizeof(szURL) );

                                    if( szURL[0] )
                                    {
                                      if( !tblURLs.IsStringInTable(szURL) )
                                      {
                                          int iIndex = tblURLs.AddString(szURL);
                                          tblTitles.AddIntAndString(iIndex, szTitle[0]?szTitle:"");
                                          tblLocations.AddString( *szLocation?szLocation:"" );
                                      }
                                    }
                                }
                            }
                        }

                        // if we get no topics then display a message stating so
                        if (tblURLs.CountStrings() < 1) {
                          int iStr = 0;

                          if( bExcludedBySubset && bExcludedByInfoType )
                            iStr = IDS_HH_E_KEYWORD_EXCLUDED;
                          else if( bExcludedBySubset )
                            iStr = IDS_HH_E_KEYWORD_NOT_IN_SUBSET;
                          else if( bExcludedByInfoType )
                            iStr = IDS_HH_E_KEYWORD_NOT_IN_INFOTYPE;
                          else
                            iStr = IDS_HH_E_KEYWORD_NOT_FOUND;

                          MsgBox( iStr, MB_OK | MB_ICONWARNING );
                          return 0;
                        }

                        // if only one topic then jump to it
                        if( tblURLs.CountStrings() == 1 ) {
                            char szURL[INTERNET_MAX_URL_LENGTH];
                            tblURLs.GetString( szURL, 1 );
                            ChangeHtmlTopic( szURL, hwnd );
                            return 0;
                        }

                        // we can sort the title table since it contains the index value
                        // of the associated URL so just make sure to always fetch the
                        // URL index from the selected title string and use that to get the URL
                        if( /*bAlphaSortHits*/ TRUE ) {
                          tblTitles.SetSorting(GetSystemDefaultLCID());
                          tblTitles.SortTable(sizeof(HASH));
                        }

                        HWND hWnd = GetFocus();
                        CTopicList TopicList(hWnd, &tblTitles, GetContentFont(), &tblLocations);
                        if (TopicList.DoModal()) {
                            char szURL[INTERNET_MAX_URL_LENGTH];
                            int iIndex = tblTitles.GetInt(TopicList.m_pos);
                            tblURLs.GetString( szURL, iIndex );
                            ChangeHtmlTopic( szURL, hwnd );
                        }
                        SetFocus(hWnd);
                    }
                }
                else {
                    UINT CodePage = pSiteMapEntry->pSiteMap->GetCodePage();
                    CWTable tblTitles( CodePage );

                    if (pSiteMapEntry->cUrls > 1)
                    {
                        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
                        for (int i = 0; i < pSiteMapEntry->cUrls; i++)
                        {
                            strcpy(szURL, GetUrlTitle(pSiteMapEntry, i) );
                            tblTitles.AddIntAndString(i, szURL);
                        }

                        // we can sort the title table since it contains the index value
                        // of the associated URL so just make sure to always fetch the
                        // URL index from the selected title string and use that to get the URL
                        if( /*bAlphaSortHits*/ TRUE ) {
                          tblTitles.SetSorting(GetSystemDefaultLCID());
                          tblTitles.SortTable(sizeof(HASH));
                        }

//                        CTopicList TopicList(m_phhctrl ? m_phhctrl->m_hwnd : FindMessageParent(m_hwndEditBox),
//                                             &tblTitles, GetContentFont());

                        CTopicList* pTopicList;
                        if ( m_phhctrl )
                           pTopicList = new CTopicList(m_phhctrl, &tblTitles, GetContentFont());
                        else
                           pTopicList = new CTopicList(FindMessageParent(m_hwndEditBox), &tblTitles, GetContentFont());

                        if (m_phhctrl)
                            m_phhctrl->ModalDialog(TRUE);
                        int fResult = pTopicList->DoModal();
                        if (m_phhctrl)
                            m_phhctrl->ModalDialog(FALSE);
                        if (fResult)
                        {
                            int iIndex = tblTitles.GetInt( pTopicList->m_pos );
                            SITE_ENTRY_URL* pUrl = GetUrlEntry(pSiteMapEntry, iIndex);
                            JumpToUrl(m_pOuter, m_hwndListBox, pSiteMapEntry, pInfoType, this, pUrl);
                        }
                        SetFocus(m_hwndEditBox);
                        delete pTopicList;
                        return 0;
                    }
                    JumpToUrl(m_pOuter, m_hwndListBox, pSiteMapEntry, pInfoType, this, NULL);
                    SetFocus(m_hwndEditBox);
                }
            }
            return 0;

        case ID_VIEW_ENTRY:
            {
                pos = m_pVList->GetSelection();
                pSiteMapEntry = GetSiteMapEntry(pos + 1);
                if(pSiteMapEntry)
                    DisplayAuthorInfo(pInfoType, this, pSiteMapEntry, FindMessageParent(m_hwndListBox), m_phhctrl);
            }
            return 0;

#ifdef _DEBUG
        case ID_VIEW_MEMORY:
            OnReportMemoryUsage();
            return 0;
#endif

    }
    return 0;
}
#ifndef _DEBUG
#pragma optimize("", on)
#endif

LRESULT WINAPI EditProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
        case WM_CHAR:                                        //Process this message to avoid damn beeps.
            if ((wParam == VK_RETURN) || (wParam == VK_TAB))
               return 0;
            return W_DelegateWindowProc(lpfnlEditWndProc, hwnd, msg, wParam,lParam);

        case WM_KEYDOWN:
            switch (wParam)
            {
            case VK_RETURN:
                SendMessage(FindMessageParent(hwnd), WM_COMMAND, MAKELONG(IDBTN_DISPLAY, BN_CLICKED), 0);
                return 0;

            case VK_TAB:
                if (GetKeyState(VK_SHIFT) < 0)
                {
                    SetFocus(GetDlgItem(GetParent(hwnd), IDBTN_DISPLAY));
                    return 0;
                }
                SetFocus(GetDlgItem(GetParent(hwnd), IDC_KWD_VLIST));
                return 0;
            }

            // fall through

        case WM_KEYUP:
            if ( VK_UP    == wParam ||
                 VK_DOWN  == wParam ||
                 VK_PRIOR == wParam ||
                 VK_NEXT  == wParam )
            {
#ifdef _DEBUG
                HWND hwndListBox = GetDlgItem(GetParent(hwnd), IDC_KWD_VLIST);
                ASSERT(hwndListBox);
#endif
                SendMessage(GetDlgItem(GetParent(hwnd), IDC_KWD_VLIST), msg, wParam, lParam);
                // Move caret to the end of the edit control
                PostMessage(hwnd, msg, VK_END, lParam);
                return 0;
            }

            // fall through

        default:
            return W_DelegateWindowProc(lpfnlEditWndProc, hwnd, msg, wParam, lParam);
    }
}

static LRESULT WINAPI ButtonProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg) {
        case WM_KEYDOWN:
            // REVIEW: 17-Oct-1997  [ralphw] Why are we special-casing VK_RETURN?
            // lpfnlBtnWndProc should handle this automatically

            if (wParam == VK_RETURN) {
                SendMessage(FindMessageParent(hwnd), WM_COMMAND,MAKELONG(IDBTN_DISPLAY, BN_CLICKED), 0);
                return 0;
            }

            if (wParam == VK_TAB) {
                CIndex* pThis = (CIndex*) GetWindowLongPtr(hwnd, GWLP_USERDATA);
                if (GetKeyState(VK_SHIFT) < 0) {
                    SetFocus(pThis->m_hwndListBox);
                    return 0;
                }
                SetFocus(GetDlgItem(GetParent(hwnd), IDEDIT_INDEX));
                return 0;
//                PostMessage(pThis->m_phh->GetHwnd(), WMP_HH_TAB_KEY, 0, 0);
            }
            break;
    }
    return W_DelegateWindowProc(lpfnlBtnWndProc, hwnd, msg, wParam, lParam);
}

/***************************************************************************

    FUNCTION:   StrToken

    PURPOSE:    DBCS-enabed variant of strtok

    PARAMETERS:
        pszList
        chDelimiter

    RETURNS:

    COMMENTS:
        You can NOT specify a DBCS character to look for, but you can
        search a DBCS string for an ANSI character

    MODIFICATION DATES:
        06-Jan-1996 [ralphw]

***************************************************************************/

PSTR StrToken(PSTR pszList, PCSTR pszDelimeters)
{
    static PSTR pszSavedList = NULL;
    PSTR psz, pszTokens;

    if (pszList) {
        pszSavedList = pszList;

        // On the first call, remove any leading token matches

        for (psz = (PSTR) pszDelimeters; *psz; psz++) {
            if (*psz == *pszSavedList) {
                pszSavedList++;
                psz = (PSTR) pszDelimeters - 1;
            }
        }
    }

    if (g_fDBCSSystem) {
        psz = pszSavedList;

        while (*psz) {
            for (pszTokens = (PSTR) pszDelimeters; *pszTokens; pszTokens++) {
                if (*pszTokens == *psz)
                    break;
            }
            if (*pszTokens == *psz)
                break;
            psz = CharNext(psz);
        }
        if (!*psz)
            psz = NULL;
    }
    else {
        psz = strpbrk(pszSavedList, pszDelimeters);
    }

    if (!psz) {
        if (!*pszSavedList)
            return NULL;
        else {
            PSTR pszReturn = pszSavedList;
            pszSavedList = pszSavedList + strlen(pszSavedList);
            return pszReturn;
        }
    }
    *psz++ = '\0';
    PSTR pszReturn = pszSavedList;
    pszSavedList = psz;
    return pszReturn;
}

///////////////////////////////////////////////////////////
//
// INavUI as Implemented by CIndex
//
///////////////////////////////////////////////////////////
//
// ProcessMenuChar
//
bool
CIndex::ProcessMenuChar(HWND hwndParent, int ch)
{
    return ::ProcessMenuChar(this, hwndParent, m_aDlgItems, c_NumDlgItems, ch) ;
}


///////////////////////////////////////////////////////////
//
// SetDefaultFocus
//
void
CIndex::SetDefaultFocus()
{
    ASSERT(::IsValidWindow(m_hwndListBox));

    if (SendMessage(m_hwndListBox, LB_GETCURSEL, 0, NULL) == LB_ERR)
    {
        SendMessage(m_hwndListBox, LB_SETCURSEL, 0,0);
    }
    SetFocus(m_hwndEditBox);   // Set Focus to the Edit control
}

const int c_TopicColumn = 0;
const int c_LocationColumn = 1;

typedef struct tag_TOPICLISTSORTINFO
{
  CTopicList* pThis;       // The CTopicList object controlling the sort.
  int         iSubItem;    // column we are sorting.
  LCID        lcid;        // locale to sort by
  WCHAR*      pwszUntitled;
  WCHAR*      pwszUnknown;
} TOPICLISTSORTINFO;

///////////////////////////////////////////////////////////
//
// TopicListCompareProc - Used to sort columns in the Topics List.
//
int CALLBACK TopicListCompareProc( LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort )
{
    int iReturn = 0;

    int iItem1 = (int)lParam1;
    int iItem2 = (int)lParam2;

    TOPICLISTSORTINFO* pInfo = reinterpret_cast<TOPICLISTSORTINFO*>(lParamSort);
    CTopicList* pThis = pInfo->pThis;

    switch( pInfo->iSubItem )
    {

      case c_TopicColumn: // Topic String
        {
            WCHAR wsz1[4096];
            wsz1[0] = 0;
            const WCHAR* pwsz1 = wsz1;
            pThis->m_ptblTitles->GetHashStringW( iItem1, wsz1, 4096 );
            if( !(*pwsz1) )
              pwsz1 = pInfo->pwszUntitled;

            WCHAR wsz2[4096];
            wsz2[0] = 0;
            const WCHAR* pwsz2 = wsz2;
            pThis->m_ptblTitles->GetHashStringW( iItem2, wsz2, 4096 );
            if( !(*pwsz2) )
              pwsz2 = pInfo->pwszUntitled;

            iReturn = W_CompareString( pInfo->lcid, 0, pwsz1, -1, pwsz2, -1 ) - 2;
        }
        break;

      case c_LocationColumn: // Location String
        {
            WCHAR wsz1[4096];
            wsz1[0] = 0;
            const WCHAR* pwsz1 = wsz1;
            pThis->m_ptblLocations->GetStringW( pThis->m_ptblTitles->GetInt(iItem1), wsz1, 4096 );
            if( !(*pwsz1) )
              pwsz1 = pInfo->pwszUnknown;

            WCHAR wsz2[4096];
            wsz2[0] = 0;
            const WCHAR* pwsz2 = wsz2;
            pThis->m_ptblLocations->GetStringW( pThis->m_ptblTitles->GetInt(iItem2), wsz2, 4096 );
            if( !(*pwsz2) )
              pwsz2 = pInfo->pwszUnknown;

            iReturn = W_CompareString( pInfo->lcid, 0, pwsz1, -1, pwsz2, -1 ) - 2;
        }
        break;

      default:
        ASSERT(0);
        break;
    }

    return iReturn;
}

extern BOOL WINAPI EnumListViewFont(HWND hwnd, LPARAM lval);

BOOL CTopicList::OnBeginOrEnd(void)
{
    if (m_fInitializing)
    {
        m_fInitializing = FALSE;

#if 0
        // note, we assume that some other part of HH detects that we either do or do
        // not have ListView Unicode support and properly sets this bool
        extern BOOL g_fUnicodeListView;

        // if we can use a Unicode version of the control then all is well
        // otherwise we need to use List1 as a template to create a Unicode
        // version of the list view and hide the old ANSI version --
        // we only need to do this for Windows 95/98 since Windows NT works
        // just fine with Unicode
        //
        if( g_fSysWinNT || g_fUnicodeListView ) {
          m_hwndListView = ::GetDlgItem(m_hWnd, IDC_TOPICS);
        }
        else { // Windows 95/98 w/o the new ComCtl32
          HWND hWndList = ::GetDlgItem(m_hWnd, IDC_TOPICS);
          ::ShowWindow( hWndList, SW_HIDE );
          RECT ListRect = { 0,0,0,0 };
          ::MapDialogRect( m_hWnd, &ListRect );
          DWORD dwStyles = ::GetWindowLong( hWndList, GWL_STYLE );

          // get the size of the control from List1
          RECT rect;
          ::GetWindowRect( hWndList, &rect );
          POINT pt;
          pt.x = rect.left;
          pt.y = rect.top;
          ::ScreenToClient( m_hWnd, &pt );
          ListRect.top = pt.y;
          ListRect.bottom = ListRect.top + (rect.bottom - rect.top);
          ListRect.left = pt.x;
          ListRect.right = ListRect.left + (rect.right - rect.left);

          m_hwndListView = W_CreateControlWindow(
                g_RTL_Style | WS_EX_NOPARENTNOTIFY | WS_EX_CLIENTEDGE,
                dwStyles | WS_CHILD | WS_VISIBLE,
                W_ListView, L"List0",
                ListRect.left, ListRect.top, RECT_WIDTH(ListRect), RECT_HEIGHT(ListRect),
                m_hWnd, NULL, _Module.GetModuleInstance(), NULL);

          // force it to be the "active" window
          m_fFocusChanged = TRUE;
          ::SetFocus( m_hwndListView );
        }
#else
          m_hwndListView = ::GetDlgItem(m_hWnd, IDC_TOPICS);
#endif

        W_EnableUnicode(m_hwndListView, W_ListView);
//        ::SendMessage(m_hwndListView, WM_SETFONT, (WPARAM)_Resource.GetUIFont(), FALSE);

        // Add Column Headings to the List View Control
        LV_COLUMNW column;
        column.mask = LVCF_FMT | LVCF_TEXT;
        column.fmt =  LVCFMT_LEFT ;
        // Title Column
        column.pszText = (LPWSTR)GetStringResourceW(IDS_ADVSEARCH_HEADING_TITLE);
        int iCol = c_TopicColumn ;
        int iResult = W_ListView_InsertColumn(m_hwndListView, iCol++, &column);
        ASSERT(iResult != -1) ;
        // Location column
        ::SendMessage(m_hwndListView, WM_SETFONT, (WPARAM)m_hfont, FALSE);
        if ( m_ptblLocations != NULL )
        {
            column.pszText = (LPWSTR)GetStringResourceW(IDS_ADVSEARCH_HEADING_LOCATION);
            ListView_SetExtendedListViewStyle( m_hwndListView, LVS_EX_FULLROWSELECT );

            iResult = W_ListView_InsertColumn(m_hwndListView, iCol, &column);
        }
        ASSERT(iResult != -1) ;

        if(g_fBiDi)
            ::SetWindowLong(m_hwndListView, GWL_EXSTYLE, GetWindowLong(m_hwndListView, GWL_EXSTYLE) | WS_EX_RIGHT | WS_EX_RTLREADING);

        // Make sure the list header uses a normal font
        EnumChildWindows(m_hwndListView, (WNDENUMPROC) EnumListViewFont, 0);

        RECT rc;
        int col1;
        GetWindowRect(m_hwndListView, &rc);
        int nScrollBarWidth = GetSystemMetrics(SM_CXVSCROLL);
        if ( m_ptblLocations == NULL )
            col1 = RECT_WIDTH(rc)-nScrollBarWidth;
        else
            col1 = (RECT_WIDTH(rc)/2)-nScrollBarWidth;
        W_ListView_SetColumnWidth(m_hwndListView, c_TopicColumn, col1 );
        if ( m_ptblLocations != NULL )
            W_ListView_SetColumnWidth(m_hwndListView, c_LocationColumn, RECT_WIDTH(rc)-col1-nScrollBarWidth/*LVSCW_AUTOSIZE_USEHEADER*/ );

        AddItems();

    }
    else
    {
       if (m_pos <= 0 ) // nothing to do on end.
           m_pos = 1;
    }
    return TRUE;
}

void CTopicList::AddItems()
{
   ASSERT(m_cResultCount>0);
   LV_ITEMW item;        // To add to the list view.
   ListView_DeleteAllItems(m_hwndListView);
   ListView_SetItemCount( m_hwndListView, m_cResultCount );
   WCHAR wsz[1024];

   for ( int i=0; i< m_cResultCount; i++)
   {
      // need to get the topic string from the Topic Number
      // Add the Topic string to the List View.
      //
      WCHAR wsz[4096];
      WCHAR* pwsz = wsz;
      m_ptblTitles->GetHashStringW(i+1, wsz, 4096);
      item.pszText   = wsz;
      item.mask      = LVIF_TEXT|LVIF_PARAM;
      item.iImage    = 0;
      item.state     = 0;
      item.stateMask = 0;
      item.iItem     = i;
      item.iSubItem  = c_TopicColumn;
      item.lParam    = i+1;
      W_ListView_InsertItem( m_hwndListView, &item );
   }

   // Add Location Column (do this after the inserts since the list could be sorted)
   if( m_ptblLocations ) {
     for ( int i=0; i< m_cResultCount; i++)
     {
       item.iItem    = i;
       item.iSubItem = c_TopicColumn;
       item.mask     = LVIF_PARAM;
       W_ListView_GetItem( m_hwndListView, &item );
       m_ptblLocations->GetStringW( m_ptblTitles->GetInt((int)item.lParam), wsz, 1024 );
       item.pszText = wsz;
       W_ListView_SetItemText(m_hwndListView, i, c_LocationColumn, wsz);
     }
   }
   W_ListView_SetItemState( m_hwndListView, 0, LVIS_SELECTED |  LVIS_FOCUSED , LVIF_STATE | LVIS_SELECTED | LVIS_FOCUSED);
   m_pos = 1;
}


LRESULT CTopicList::OnDlgMsg(UINT msg, WPARAM wParam, LPARAM lParam)
{
    if ( msg == WM_NOTIFY )
    {
        if ( ListViewMsg( GetParent(*this), (NM_LISTVIEW*)lParam) )
//         EndDialog(TRUE);
           ::SendMessage(m_hWnd, WM_COMMAND, (WPARAM)1, (LPARAM)0);     // WPARAM == ((BN_CLICKED<16)|IDOK)

    }
    return FALSE;
}


LRESULT CTopicList::ListViewMsg(HWND hwnd, NM_LISTVIEW* lParam)
{
   switch(lParam->hdr.code)
   {
      case NM_DBLCLK:
      case NM_RETURN:
            if ( m_pos == -1 )
                return FALSE;
            else
                return TRUE;
      case LVN_ITEMCHANGING:
         if ( ((NM_LISTVIEW*)lParam)->uNewState & LVIS_SELECTED )
                m_pos = (int)((NM_LISTVIEW*)lParam)->lParam;
            else
                m_pos = -1 ;

            break;
      case LVN_GETDISPINFOA:   // the control wants to draw the items
      case LVN_GETDISPINFOW:   // the control wants to draw the items
         break;

      case LVN_COLUMNCLICK: {
        CHourGlass waitcur;
        NM_LISTVIEW *pNM = reinterpret_cast<NM_LISTVIEW*>(lParam);

        // Get the string for untitled things.
        CWStr wstrUntitled(IDS_UNTITLED);
        CWStr wstrUnknown(IDS_UNKNOWN);

        // Fill this structure to make the sorting quicker/more efficient.
        TOPICLISTSORTINFO Info;
        Info.pThis        = this;
        Info.iSubItem     = pNM->iSubItem;
        LCID lcid = 0;
        LCIDFromCodePage( m_ptblTitles->GetCodePage(), &lcid );
        Info.lcid         = lcid;
        Info.pwszUntitled = wstrUntitled;
        Info.pwszUnknown  = wstrUnknown;

        W_ListView_SortItems(pNM->hdr.hwndFrom,
                            TopicListCompareProc,
                            reinterpret_cast<LPARAM>(&Info));
        }
        // Fall through...

      default:
         ;
   }
   return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\index.h ===
// Copyright  1996-1997  Microsoft Corporation.  All Rights Reserved.

#ifndef _CDLG_H_
#include "cdlg.h"
#endif

class CTopicList : public CDlg
{
public:       // Constructors

  CTopicList( CHtmlHelpControl* phhCtrl, CWTable* ptblTitles, HFONT hfont, CWTable *ptblLocations = NULL )
                  : CDlg(phhCtrl, IDDLG_RELATED_TOPICS)
  {
    m_ptblTitles = ptblTitles;
    m_hfont = hfont;
    m_ptblLocations = ptblLocations;
    m_cResultCount = m_ptblTitles->CountStrings();
    SetUnicode(TRUE);
  }

  CTopicList( HWND hwndParent, CWTable* ptblTitles, HFONT hfont, CWTable *ptblLocations = NULL )
                  : CDlg(hwndParent, IDDLG_RELATED_TOPICS)
  {
    m_ptblTitles = ptblTitles;
    m_hfont = hfont;
    m_ptblLocations = ptblLocations;
    m_cResultCount = m_ptblTitles->CountStrings();
    SetUnicode(TRUE);
  }

  // Methods
  LRESULT ListViewMsg(HWND hwnd, NM_LISTVIEW* pnmhdr);
  BOOL OnBeginOrEnd(void);
  LRESULT OnDlgMsg(UINT msg, WPARAM wParam, LPARAM lParam);
  void AddItems();
  void OnDblClick() {
  PostMessage(m_hWnd, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0); }

  // Data Members
  CWTable*        m_ptblTitles;
  CWTable*        m_ptblLocations;
  HFONT           m_hfont;
  HWND            m_hwndListView;
  int             m_pos;   // position in ptblTitles
  int             m_cResultCount;
  SITE_ENTRY_URL* m_pUrl;
  SITEMAP_ENTRY*  m_pSiteMapChosen;

  enum { IDD = IDDLG_RELATED_TOPICS };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\idispids.h ===
//=--------------------------------------------------------------------------=
// IDispIds.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains dispids for the Framework controls.
//

#ifndef _IDISPIDS_H_

#define DISPID_READYSTATE               (-525)
#define DISPID_READYSTATECHANGE         (-609)
#define DISPID_AMBIENT_TRANSFERPRIORITY (-728)

#define _IDISPIDS_H_
#endif // _IDISPIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\htmlhelp_.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Wed Dec 17 15:51:21 1997
 */
/* Compiler settings for HTMLHelp.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __HTMLHelp__h__
#define __HTMLHelp__h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IHHWindowPane_FWD_DEFINED__
#define __IHHWindowPane_FWD_DEFINED__
typedef interface IHHWindowPane IHHWindowPane;
#endif 	/* __IHHWindowPane_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "servprov.h"
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IHHWindowPane_INTERFACE_DEFINED__
#define __IHHWindowPane_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHHWindowPane
 * at Wed Dec 17 15:51:21 1997
 * using MIDL 3.01.75
 ****************************************/
/* [version][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IHHWindowPane;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("60571de0-7735-11d1-92a6-006097c9a982")
    IHHWindowPane : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSite( 
            /* [in] */ IServiceProvider __RPC_FAR *pSP) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePaneWindow( 
            /* [in] */ HWND hwndParent,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [in] */ int cx,
            /* [in] */ int cy,
            /* [out] */ HWND __RPC_FAR *hwnd) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDefaultSize( 
            /* [out] */ SIZE __RPC_FAR *psize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClosePane( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoadViewState( 
            /* [in] */ IStream __RPC_FAR *pstream) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SaveViewState( 
            /* [in] */ IStream __RPC_FAR *pstream) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            LPMSG lpmsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHHWindowPaneVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHHWindowPane __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHHWindowPane __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHHWindowPane __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSite )( 
            IHHWindowPane __RPC_FAR * This,
            /* [in] */ IServiceProvider __RPC_FAR *pSP);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePaneWindow )( 
            IHHWindowPane __RPC_FAR * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [in] */ int cx,
            /* [in] */ int cy,
            /* [out] */ HWND __RPC_FAR *hwnd);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultSize )( 
            IHHWindowPane __RPC_FAR * This,
            /* [out] */ SIZE __RPC_FAR *psize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClosePane )( 
            IHHWindowPane __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadViewState )( 
            IHHWindowPane __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pstream);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveViewState )( 
            IHHWindowPane __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pstream);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TranslateAccelerator )( 
            IHHWindowPane __RPC_FAR * This,
            LPMSG lpmsg);
        
        END_INTERFACE
    } IHHWindowPaneVtbl;

    interface IHHWindowPane
    {
        CONST_VTBL struct IHHWindowPaneVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHHWindowPane_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHHWindowPane_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHHWindowPane_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHHWindowPane_SetSite(This,pSP)	\
    (This)->lpVtbl -> SetSite(This,pSP)

#define IHHWindowPane_CreatePaneWindow(This,hwndParent,x,y,cx,cy,hwnd)	\
    (This)->lpVtbl -> CreatePaneWindow(This,hwndParent,x,y,cx,cy,hwnd)

#define IHHWindowPane_GetDefaultSize(This,psize)	\
    (This)->lpVtbl -> GetDefaultSize(This,psize)

#define IHHWindowPane_ClosePane(This)	\
    (This)->lpVtbl -> ClosePane(This)

#define IHHWindowPane_LoadViewState(This,pstream)	\
    (This)->lpVtbl -> LoadViewState(This,pstream)

#define IHHWindowPane_SaveViewState(This,pstream)	\
    (This)->lpVtbl -> SaveViewState(This,pstream)

#define IHHWindowPane_TranslateAccelerator(This,lpmsg)	\
    (This)->lpVtbl -> TranslateAccelerator(This,lpmsg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHHWindowPane_SetSite_Proxy( 
    IHHWindowPane __RPC_FAR * This,
    /* [in] */ IServiceProvider __RPC_FAR *pSP);


void __RPC_STUB IHHWindowPane_SetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHHWindowPane_CreatePaneWindow_Proxy( 
    IHHWindowPane __RPC_FAR * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ int x,
    /* [in] */ int y,
    /* [in] */ int cx,
    /* [in] */ int cy,
    /* [out] */ HWND __RPC_FAR *hwnd);


void __RPC_STUB IHHWindowPane_CreatePaneWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHHWindowPane_GetDefaultSize_Proxy( 
    IHHWindowPane __RPC_FAR * This,
    /* [out] */ SIZE __RPC_FAR *psize);


void __RPC_STUB IHHWindowPane_GetDefaultSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHHWindowPane_ClosePane_Proxy( 
    IHHWindowPane __RPC_FAR * This);


void __RPC_STUB IHHWindowPane_ClosePane_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHHWindowPane_LoadViewState_Proxy( 
    IHHWindowPane __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pstream);


void __RPC_STUB IHHWindowPane_LoadViewState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHHWindowPane_SaveViewState_Proxy( 
    IHHWindowPane __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pstream);


void __RPC_STUB IHHWindowPane_SaveViewState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHHWindowPane_TranslateAccelerator_Proxy( 
    IHHWindowPane __RPC_FAR * This,
    LPMSG lpmsg);


void __RPC_STUB IHHWindowPane_TranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHHWindowPane_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\infowiz.cpp ===
// Copyright  1995-1997  Microsoft Corporation.  All Rights Reserved.

#include "header.h"
#include "..\hhctrl\infowiz.h"

BOOL CInfoTypePageContents::OnNotify(UINT code)
{
    switch (code) {
        case PSN_SETACTIVE:
            MakeCheckedList(IDLB_INFO_TYPES);
            SetWizButtons(PSWIZB_NEXT | PSWIZB_BACK);
            FillInfoTypeListBox();
            break;

        case PSN_WIZBACK:
            SaveInfoTypes();
            if (m_InfoParam.idPreviousPage > 0) {
                SetResult(m_InfoParam.idPreviousPage);
                return TRUE;
            }
            break;

        case PSN_WIZNEXT:
            SaveInfoTypes();
            if (m_InfoParam.idNextPage > 0) {
                SetResult(m_InfoParam.idNextPage);
                return TRUE;
            }
            break;
    }
    return FALSE;
}

void CInfoTypePageContents::SaveInfoTypes(void)
{
    int bitflag = 1;
    INFOTYPE* pInfoType = m_InfoParam.pInfoTypes;
    int type;

    if ( m_InfoParam.iCategory >= 0 )
    {       // Exclusive IT in category
        if ( m_InfoParam.fExclusive )
        {
            CStr csz;
            csz.ReSize(MAX_PATH);
            m_pCheckBox->GetText(csz.psz);
            type = m_InfoParam.pInfoType->GetFirstCategoryType( m_InfoParam.iCategory );
            while ( type != -1 )
            {
                if ((m_InfoParam.pInfoType->GetInfoType(csz.psz) == type) && 
                    !m_InfoParam.pInfoType->IsHidden(type))
                    AddIT( type, pInfoType );
                else
                    DeleteIT(type, pInfoType);
                type = m_InfoParam.pInfoType->GetNextITinCategory();
            }
        }
        else
        {   // Inclusive Category
            int ordinal_IT=0;
            type = m_InfoParam.pInfoType->GetFirstCategoryType( m_InfoParam.iCategory );
            while ( type != -1 )
            {
                if ( m_pCheckBox->GetItemData(ordinal_IT) && !m_InfoParam.pInfoType->IsHidden(type))
                    AddIT( type, pInfoType );
                else
                    DeleteIT( type, pInfoType );
                if (!m_InfoParam.pInfoType->IsHidden(type)) 
                    ordinal_IT++;
                type = m_InfoParam.pInfoType->GetNextITinCategory();
            }
        }
    }
    else
    {   // no category
        if ( m_InfoParam.fExclusive )
        {   // set of exclusive IT's
            CStr csz;
            csz.ReSize(MAX_PATH);
            m_pCheckBox->GetText(csz.psz);
            for (type=1; type <= m_InfoParam.pInfoType->HowManyInfoTypes(); type++ )
            {
                if ( (m_InfoParam.pInfoType->GetInfoType(csz.psz) == type) && 
                     !m_InfoParam.pInfoType->IsHidden(type) )
                    AddIT( type, pInfoType );
                else
                    DeleteIT( type, pInfoType );
            }
        }
        else
        {   // set of inclusive IT's
            for ( type=1; type <= m_InfoParam.pInfoType->HowManyInfoTypes(); type++ )
            {
                if ( m_pCheckBox->GetItemData(type-1) && !m_InfoParam.pInfoType->IsHidden(type) )
                    AddIT( type, pInfoType );
                else
                    DeleteIT( type, pInfoType );
            }
        }
    }
}

void CInfoTypePageContents::FillInfoTypeListBox(void)
{
    int bitflag = 1;
    INFOTYPE* pInfoType = m_InfoParam.pInfoTypes;
    int type;
    int lbpos;
    m_pCheckBox->Reset();

    if ( m_InfoParam.iCategory >= 0 )
    {
        type = m_InfoParam.pInfoType->GetFirstCategoryType( m_InfoParam.iCategory );
        while ( (type != -1) && !m_InfoParam.pInfoType->IsHidden(type) )
        {
            lbpos = (int)m_pCheckBox->AddString(m_InfoParam.pInfoType->m_itTables.m_ptblInfoTypes->GetPointer(type));
		    m_pCheckBox->SetItemData(lbpos, type);  
            type = m_InfoParam.pInfoType->GetNextITinCategory();
        }
        SetWindowText(IDTXT_DESCRIPTION,
            m_InfoParam.pInfoType->GetCategoryDescription(m_InfoParam.iCategory+1) );
    }else
    {
        for (type = 1; type <= m_InfoParam.pInfoType->HowManyInfoTypes(); type++)
        {
            if ( m_InfoParam.pInfoType->IsHidden(type) )
                continue;
            lbpos = (int)m_pCheckBox->AddString(m_InfoParam.pInfoType->m_itTables.m_ptblInfoTypes->GetPointer(type));
            m_pCheckBox->SetItemData(lbpos, type);
        }
    }
}

void CInfoTypePageContents::OnSelChange(UINT id)
{
    int posType;

    if (id == IDLB_INFO_TYPES) {
        m_pCheckBox->OnSelChange();
        int pos = (int)m_pCheckBox->GetCurSel();
        if (pos != LB_ERR)
        {
            ASSERT(m_InfoParam.pInfoType->m_itTables.m_ptblInfoTypeDescriptions);

			CStr cszItem;
			cszItem.ReSize(MAX_PATH);
			m_pCheckBox->GetText(cszItem, MAX_PATH, pos);

            posType = m_InfoParam.pInfoType->GetITIndex(cszItem.psz);
            SetWindowText(IDTXT_DESCRIPTION,
                m_InfoParam.pInfoType->GetInfoTypeDescription(posType));
        }
    }
}

BOOL CWizardIntro::OnNotify(UINT code)
{
    switch (code) {
        case PSN_SETACTIVE:
			SetWizButtons(PSWIZB_NEXT);
            if (m_pInfoParam->fCustom)
                SetCheck(IDRADIO_CUSTOM);
            else if (m_pInfoParam->fAll)
				SetCheck(IDRADIO_ALL);
			else
				SetCheck(IDRADIO_ALL ); //IDRADIO_TYPICAL);
            break;

        case PSN_WIZNEXT:
            if (GetCheck(IDRADIO_TYPICAL)) {
                m_pInfoParam->fTypical = TRUE;
                m_pInfoParam->fAll = FALSE;
                m_pInfoParam->fCustom = FALSE;
                if (m_pInfoParam->pInfoType->m_pTypicalInfoTypes) {
                    ASSERT(lcSize(m_pInfoParam->pInfoTypes) == lcSize(m_pInfoParam->pInfoType->m_pTypicalInfoTypes));
                    memcpy(m_pInfoParam->pInfoTypes, m_pInfoParam->pInfoType->m_pTypicalInfoTypes, lcSize(m_pInfoParam->pInfoTypes));
                }
                SetResult(IDWIZ_INFOTYPE_FINISH);
                return TRUE;
            }
            if (GetCheck(IDRADIO_ALL)) {
                m_pInfoParam->fTypical = FALSE;
                m_pInfoParam->fAll = TRUE;
                m_pInfoParam->fCustom = FALSE;
                memset(m_pInfoParam->pInfoTypes, 0xFF, lcSize(m_pInfoParam->pInfoTypes));
                SetResult(IDWIZ_INFOTYPE_FINISH);
                return TRUE;
            }
			else {
                m_pInfoParam->fTypical = FALSE;
                m_pInfoParam->fAll = FALSE;
                m_pInfoParam->fCustom = TRUE;
				memset(m_pInfoParam->pInfoTypes, 0xFF, lcSize(m_pInfoParam->pInfoTypes));
			}
            return FALSE;
    }
    return FALSE;
}

void CWizardIntro::OnButton(UINT id)
{
	if (GetCheck(id)) {
        SetCheck(IDRADIO_ALL, FALSE);
        SetCheck(IDRADIO_TYPICAL, FALSE);
        SetCheck(IDRADIO_CUSTOM, FALSE);
        SetCheck(id, TRUE);
    }
}

BOOL CInfoWizFinish::OnNotify(UINT code)
{
    switch (code) {
        case PSN_SETACTIVE:
			SetWizButtons(PSWIZB_BACK | PSWIZB_FINISH);
            break;

        case PSN_WIZBACK:
			if (m_pInfoParam->fAll || m_pInfoParam->fTypical) {
                SetResult(CWizardIntro::IDD);
                return TRUE;
            }
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\initguid.c ===
// INITGUID.CPP -- Code file where the DLL's guid structures are instantiated.

// Note: Do not use precompiled headers with this file! They can cause problems
// because we need to change the interpretation of DEFINE_GUID by defining the
// symbol INITGUID. In some cases using precompiled headers generates incorrect
// code for that case.

#define INITGUID

// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#define NOATOM
#define NOCOMM
#define NODEFERWINDOWPOS
#define NODRIVERS
#define NOEXTDEVMODEPROPSHEET
#define NOIME
#define NOKANJI
#define NOLOGERROR
#define NOMCX
#define NOPROFILER
#define NOSCALABLEFONT
#define NOSERVICE
#define NOSOUND

#include <windows.h>

// place all interfaces here that need their objects instantiated

// Tome
#include "MSITStg.h"

// Centaur
#include "itquery.h"
#include "itgroup.h"
#include "itpropl.h"
#include "itrs.h"
#include "itdb.h"
#include "itww.h"

// Centaur compiler
#include "itcc.h"

#include "iterror.h"
#include "itSort.h"

#include "itSortid.h"

#include <cguid.h>
#include "atlinc.h" // includes for ATL.
#include "hhsyssrt.h"

#include "hhfinder.h"

#include "htmlpriv.h"
#include "sampinit.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\infowiz.h ===
// Copyright  1995-1997  Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INFOTYPE_H_
#define _INFOTYPE_H_

#include "cprop.h"

#include "sitemap.h"
#include "cinfotyp.h"
#include "csubset.h"
#include "secwin.h"

#ifndef IDR_MAINFRAME
#include "resource.h"
#endif

typedef struct {
	CInfoType *pInfoType;
	CSiteMap* pSiteMap;
	INFOTYPE* pInfoTypes;
#if 0	// enable for subset filtering
    INFOTYPE* pExclusive;
#endif
	INFOTYPE* pTypicalInfoTypes;
	int  idDlgTemplate;
	BOOL fExclusive;
	int  idNextPage;
	int  idPreviousPage;
	int  iCategory;
    INFOTYPE * pagebits;    // the IT's included on a wizared page.
	BOOL fAll;
	BOOL fTypical;
	BOOL fCustom;
} INFO_PARAM;

class CInfoTypePageContents : public CPropPage
{
public:
	CInfoTypePageContents(
#if 0	// enable for subset filtering
#ifdef HHCTRL
		CExCollection* pTitleCol, INFO_PARAM* pInfoParam) : CPropPage(pInfoParam->idDlgTemplate)
#else
		INFO_PARAM* pInfoParam) : CPropPage(pInfoParam->idDlgTemplate)
#endif
    {
        memcpy(&m_InfoParam, pInfoParam, sizeof(INFO_PARAM));
#ifdef HHCTRL
        m_pTitleCollection = pTitleCol; 
#endif
    }
#else
#ifdef HHCTRL
		CHtmlHelpControl* phhCtrl, INFO_PARAM* pInfoParam) : CPropPage(pInfoParam->idDlgTemplate)
#else
		INFO_PARAM* pInfoParam) : CPropPage(pInfoParam->idDlgTemplate)
#endif
			{ memcpy(&m_InfoParam, pInfoParam, sizeof(INFO_PARAM)); }
#endif

	BOOL OnNotify(UINT code);
	void OnSelChange(UINT id);

protected:
#if 0	// enable for subset filtering
	void FillInfoTypeListBox(INFOTYPE *);
	void SaveInfoTypes(INFOTYPE *);
#else
	void FillInfoTypeListBox(void);
	void SaveInfoTypes(void);
#endif
    void flipBits( INFOTYPE * pInfoType );

	INFO_PARAM m_InfoParam;
#ifdef HHCTRL
    CExCollection *m_pTitleCollection;
#endif
};


class CWizardIntro : public CPropPage
{
public:

#if 0  // enable for subset filtering
#ifdef HHCTRL
	CWizardIntro(CExCollection* pTitleCol, INFO_PARAM* pInfoParam) : CPropPage(CWizardIntro::IDD)
#else
	CWizardIntro(INFO_PARAM* pInfoParam) : CPropPage(CWizardIntro::IDD)
#endif
		{ m_pInfoParam = pInfoParam;
#ifdef HHCTRL
          m_pTitleCollection = pTitleCol; 
#endif
    }
#else
#ifdef HHCTRL
	CWizardIntro(CHtmlHelpControl* phhCtrl, INFO_PARAM* pInfoParam) : CPropPage(CWizardIntro::IDD)
#else
	CWizardIntro(INFO_PARAM* pInfoParam) : CPropPage(CWizardIntro::IDD)
#endif
		{ m_pInfoParam = pInfoParam; }
#endif

	BOOL OnNotify(UINT code);
	void OnButton(UINT id);
#if 0	// enable for subset filtering
    void OnSelChange(UINT id); // for the subset combo box.
#endif

	enum { IDD = IDWIZ_INFOTYPE_INTRO };

	INFO_PARAM*     m_pInfoParam;
#ifdef HHCTRL
    CExCollection  *m_pTitleCollection;
#endif
};


class CInfoWizFinish : public CPropPage
{
public:

#if 0  // enable for subset filtering
#ifdef HHCTRL
	CInfoWizFinish(CHHWinType* phh, INFO_PARAM* pInfoParam) : CPropPage(CInfoWizFinish::IDD)
#else
	// Specify NULL to keep cprop.AddPage happy
	CInfoWizFinish(INFO_PARAM* pInfoParam) : CPropPage(CInfoWizFinish::IDD)
#endif
		{ m_pInfoParam = pInfoParam;
#ifdef HHCTRL
          m_phh = phh; 
#endif
    }
#else
#ifdef HHCTRL
	CInfoWizFinish(CHtmlHelpControl* phhCtrl, INFO_PARAM* pInfoParam) : CPropPage(CInfoWizFinish::IDD)
#else
	// Specify NULL to keep cprop.AddPage happy
	CInfoWizFinish(INFO_PARAM* pInfoParam) : CPropPage(CInfoWizFinish::IDD)
#endif
		{ m_pInfoParam = pInfoParam; }
#endif

#if 0	// enable for subset filtering
    void OnEditChange(UINT id);
    void OnButton(UINT id);
#endif
	BOOL OnNotify(UINT code);

	enum { IDD = IDWIZ_INFOTYPE_FINISH };

	INFO_PARAM*     m_pInfoParam;
#ifdef HHCTRL
    CHHWinType*     m_phh;
#endif
};

#endif //  _INFOTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\init.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"

#define INITOBJECTS 	// define the descriptions for our objects

#include "LocalSrv.H"

#include "LocalObj.H"
#include "olectl.h"
#include "hhifc.H"
#include "Resource.H"
#include "hhctrl.H"
#include "cathelp.H"

#include "CtrlObj.H"

#ifdef VSBLDENV
#include "hhifc.c"
#include "hhsort.c"
#include "hhfind.c"
#else
#include "hhifc_i.c"
#include "hhsort_i.c"
#include "hhfind_i.c"
#endif

#include "iterror.h"
#include "itSort.h"
#include "itSortid.h"

#include "atlinc.h" 	// includes for ATL.
#include "hhsyssrt.h"

#include "hhfinder.h"

//=--------------------------------------------------------------------------=
// our Libid.  This should be the LIBID from the Type library, or NULL if you
// don't have one.

const CLSID *g_pLibid = &LIBID_HHCTRLLib;

//=--------------------------------------------------------------------------=
// Set this up if you want to have a window proc for your parking window. This
// is really only interesting for Sub-classed controls that want, in design
// mode, certain messages that are sent only to the parent window.

WNDPROC g_ParkingWindowProc = NULL;

//=--------------------------------------------------------------------------=
// Localization Information
//
// We need the following two pieces of information:
//	  a. whether or not this DLL uses satellite DLLs for localization.	if
//		 not, then the lcidLocale is ignored, and we just always get resources
//		 from the server module file.
//	  b. the ambient LocaleID for this in-proc server.	Controls calling
//		 GetResourceHandle() will set this up automatically, but anybody
//		 else will need to be sure that it's set up properly.
//
const VARIANT_BOOL g_fSatelliteLocalization =  FALSE;
LCID			   g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);


//=--------------------------------------------------------------------------=
// This Table describes all the automatible objects in your automation server.
// See AutomationObject.H for a description of what goes in this structure
// and what it's used for.

OBJECTINFO g_ObjectInfo[] = {
	CONTROLOBJECT(HHCtrl),
	EMPTYOBJECT
};

//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed.
//
// basically, the CRTs define this to suck in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//

#if 0

extern "C" int __cdecl _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
  FAIL("Pure virtual function called.");
  return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\internet.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

// contains internet helper classes CDownloadSink and CInternetControl

#include "header.h"
#include "Internet.H"

static VARTYPE rgI4[] = { VT_I4 };

typedef enum {
	InternetEvent_Progress = 0,
	InternetEvent_ReadyStateChange = 1
} INTERNETEVENTS;

static EVENTINFO rgEvents [] = {
	{ DISPID_PROGRESS, 1, rgI4 },			// (long percentDone)
	{ DISPID_READYSTATECHANGE, 1, rgI4 },		// (OLE_READYSTATE newState)
};

// local class for doing async monitoring. It's not really all that
// general purpose, but it does the job...

// REVIEW: 06-Jul-1997	[ralphw] Why do we need this for HHCtrl?

class CDownloadSink : public IBindStatusCallback
{
public:
	CDownloadSink(IUnknown *punkOuter,CInternetControl *,DISPID );
	~CDownloadSink();

	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(OnStartBinding)(
		/* [in] */ DWORD grfBSCOption,
		/* [in] */ IBinding *pib);

	STDMETHOD(GetPriority)(
		/* [out] */ LONG *pnPriority);

	STDMETHOD(OnLowResource)(
		/* [in] */ DWORD reserved);

	STDMETHOD(OnProgress)(
		/* [in] */ ULONG ulProgress,
		/* [in] */ ULONG ulProgressMax,
		/* [in] */ ULONG ulStatusCode,
		/* [in] */ LPCWSTR szStatusText);

	STDMETHOD(OnStopBinding)(
		/* [in] */ HRESULT hresult,
		/* [in] */ LPCWSTR szError);

	STDMETHOD(GetBindInfo)(
		/* [out] */ DWORD *grfBINDINFOF,
		/* [unique][out][in] */ BINDINFO *pbindinfo);

	STDMETHOD(OnDataAvailable)(
		/* [in] */ DWORD grfBSCF,
		/* [in] */ DWORD dwSize,
		/* [in] */ FORMATETC *pformatetc,
		/* [in] */ STGMEDIUM *pstgmed);

	STDMETHOD(OnObjectAvailable)(
		/* [in] */ REFIID riid,
		/* [iid_is][in] */ IUnknown *punk);



	CDownloadSink * Next()					{ return(m_next); }
	void			Next(CDownloadSink *n)	{ m_next = n; }

	DISPID			DispId()  { return(m_propId); }
	IBinding *		Binding() { return(m_binding); }

private:

	CDownloadSink * 		m_next;
	CInternetControl *		m_control;
	DISPID					m_propId;
	IBinding *				m_binding;
	DWORD					m_ref;
	IStream *								m_stream;
};

CDownloadSink::CDownloadSink(IUnknown * punkOuter,
	CInternetControl * control, DISPID propId)
{
	m_control = control;
	m_control->AddRef();

	m_propId  = propId;
	m_next	  = 0;
	m_binding = 0;
	m_ref	  = 0;
	m_stream  = 0;

	DBWIN("CDownloadSink created.");
}

CDownloadSink::~CDownloadSink()
{
	if (m_control)
		m_control->Release();
	if (m_binding)
		m_binding->Release();
	if (m_stream)
		m_stream->Release();
}

STDMETHODIMP CDownloadSink::QueryInterface(const GUID &iid, void **ppv)
{
	if (IsEqualGUID(iid, IID_IUnknown) ||
			IsEqualGUID(iid, IID_IBindStatusCallback)) {
		*ppv = this;
		AddRef();
		return(NOERROR);
	}
	return(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CDownloadSink::AddRef()
{
	return(++m_ref);
}

STDMETHODIMP_(ULONG) CDownloadSink::Release()
{
	if (!--m_ref) {
		delete this;
		return(0);
	}
	return(m_ref);
}

STDMETHODIMP CDownloadSink::GetBindInfo(DWORD *grfBINDF, BINDINFO *pbindInfo)
{
	*grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_NOCOPYDATA;
	return(NOERROR);
}


STDMETHODIMP CDownloadSink::OnStartBinding(DWORD /*grfBSCOption*/,
	IBinding *pib)
{
	// BUGBUG: should check to see options are what we think they are
	m_binding = pib;
	pib->AddRef();
	return(NOERROR);
}


STDMETHODIMP CDownloadSink::GetPriority( LONG *pnPriority)
{
	return(E_NOTIMPL);
}

STDMETHODIMP CDownloadSink::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
	ULONG ulStatusCode, LPCWSTR pwzStatusText)
{
	return m_control->OnProgress(m_propId,ulProgress, ulProgressMax,
		ulStatusCode, pwzStatusText);
}

STDMETHODIMP CDownloadSink::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
	FORMATETC * pFmtetc, STGMEDIUM * pstgmed)
{
#ifdef DEBUG
	char msg[200];
	wsprintf(msg,"::OnDataAvailable(%0xd,%d,%s,%s)", grfBSCF, dwSize,
			pFmtetc ? "pFmtetc" : "NULL", pstgmed ? "pstgmed" : "NULL");
	DBWIN(msg);
#endif

	if (!m_stream)
		m_stream = pstgmed->pstm;

	return (m_control->OnData(m_propId, grfBSCF, m_stream, dwSize));
}

STDMETHODIMP CDownloadSink::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
	return(E_NOTIMPL);
}

STDMETHODIMP CDownloadSink::OnLowResource(DWORD reserved)
{
	m_binding->Abort();
	return(S_OK);
}

STDMETHODIMP CDownloadSink::OnStopBinding(HRESULT hrError, LPCWSTR szError)
{
	m_binding->Release();
	m_binding = 0;
	m_control->Release();
	m_control = 0;

	return(NOERROR);
}

// class CInternetControl

CInternetControl::CInternetControl(IUnknown * pUnkOuter,
	int iPrimaryDispatch, void * pMainInterface)
		: COleControl(pUnkOuter,iPrimaryDispatch,pMainInterface)
{
	m_host = 0;
	m_readyState = READYSTATE_LOADING;
}

CInternetControl::~CInternetControl()
{
	if (m_host)
		m_host->Release();
}

HRESULT CInternetControl::InternalQueryInterface(REFIID  riid,
	void **ppvObjOut)
{
	*ppvObjOut = NULL;
	 return COleControl::InternalQueryInterface(riid, ppvObjOut);
}

HRESULT CInternetControl::GetBindHost()
{
	if (m_host)
		return(NOERROR);

	// Try service provider first...

	IServiceProvider * serviceProvider = 0;

	HRESULT hr = m_pClientSite->QueryInterface(IID_IServiceProvider,
		(void**) &serviceProvider);

	if (SUCCEEDED(hr)) {
		hr = serviceProvider->QueryService(SID_IBindHost, IID_IBindHost,
			(void**) &m_host);
		serviceProvider->Release();
	}

	if (FAILED(hr)) {

		// Some containers put IBindHost directly on the client site

		hr = m_pClientSite->QueryInterface (IID_IBindHost, (void**) &m_host);
	}

	return(hr);
}

HRESULT CInternetControl::GetAMoniker(LPOLESTR url, IMoniker ** ppmkr)
{
#if 0
	11-Jun-1997    [ralphw] m_host->CreateMoniker generates a compiler
	error. Doesn't exist in any header file that I can find.

	HRESULT hr = GetBindHost();


		if( SUCCEEDED(hr) )
				hr = m_host->CreateMoniker(url,NULL, ppmkr,0);

		if( FAILED(hr) )
	{
		   // FUTURE: This really should be a call to MkParseDisplayNameEx!!!
	   hr = ::CreateURLMoniker(0,url,ppmkr);
	   // hr = ::MkParseDisplayNameEx(0, url, 0, ppmkr);
	}

		return( hr );
#else
	return ::CreateURLMoniker(0,url,ppmkr);
#endif
}

HRESULT CInternetControl::SetupDownload(LPOLESTR url, DISPID propId)
{
	CHECK_POINTER(url);

	IMoniker * pmkr;

	HRESULT hr = GetAMoniker(url, &pmkr);

	IBindCtx * pBindCtx = 0;

	if (SUCCEEDED(hr)) {
		hr = ::CreateBindCtx(0, &pBindCtx);
	}

	CDownloadSink * sink = 0;

	if (SUCCEEDED(hr)) {
		sink = new CDownloadSink(0, this, propId);
		if (sink)
			sink->AddRef();
	}

	if (SUCCEEDED(hr) && !sink)
		hr = E_OUTOFMEMORY;

	if (SUCCEEDED(hr)) {

		hr = ::RegisterBindStatusCallback(pBindCtx, sink, 0, 0);
	}

	IStream * strm = 0;

	if (SUCCEEDED(hr))
		hr = pmkr->BindToStorage(pBindCtx, 0, IID_IStream, (void**) &strm);

	if (strm)
		strm->Release();

	if (pBindCtx)
		pBindCtx->Release();

	if (FAILED(hr) && sink)
		sink->Release();

	return(hr);
}

HRESULT CInternetControl::OnProgress( DISPID, ULONG progress, ULONG themax, ULONG, LPCWSTR)
{
	return(NOERROR);
}

HRESULT CInternetControl::FireReadyStateChange(LONG newState)
{
	FireEvent(&::rgEvents[InternetEvent_ReadyStateChange], m_readyState = newState);
	return(S_OK);
}

HRESULT CInternetControl::FireProgress(ULONG dwAmount)
{
	FireEvent(&::rgEvents[InternetEvent_Progress], dwAmount);
	return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\internet.h ===
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INTERNET_H
#define _INTERNET_H

#define DISPID_PROGRESS 1958

#ifndef __MKTYPLIB__

#include <urlmon.H>

#include "CtrlObj.H"

class CInternetControl : public COleControl
{
public:
	CInternetControl(IUnknown * pUnkOuter,
					int 		iPrimaryDispatch,
					void *		pMainInterface);

	virtual ~CInternetControl();

	// IUnknown methods

	DECLARE_STANDARD_UNKNOWN();

	// Call this method to start the download of a URL. 'propId' will
	//	be passed back to your OnData below.

	HRESULT SetupDownload(LPOLESTR url, DISPID propId);

	//	Derived classes implement this method. It will be called when
	//	data has arrived for a given dispid.

	virtual HRESULT OnData(DISPID id, DWORD grfBSCF, IStream * bitstrm,
		DWORD amount) { return NOERROR; }

	//	Derived classes can implement this method. It will be
	//	called at various times during the download.

	virtual HRESULT OnProgress(DISPID id, ULONG ulProgress,
										ULONG ulProgressMax,
										ULONG ulStatusCode,
										LPCWSTR pwzStatusText);

	//	Call this method to turn a URL into a Moniker.
	HRESULT GetAMoniker(LPOLESTR url, IMoniker **);

	HRESULT FireReadyStateChange(long newState);
	HRESULT FireProgress(ULONG dwAmount);

		// Override base class implementation...

	virtual HRESULT InternalQueryInterface(REFIID, void **);

protected:
	HRESULT GetBindHost();

	IBindHost * 			m_host;
	long					m_readyState;

	// BUGBUG: We should track all the downloads
};

#endif __MKTYPLIB__

#endif _INTERNET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ipserver.h ===
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _IPSERVER_H_
#define _IPSERVER_H_

#include <windows.h>
//#include <basetyps.h>
#include <docobj.h> 				   // for offsetof()
#include <olectl.h>

//=--------------------------------------------------------------------------=
// we don't want to use the CRTs, and would like some memory tracking in the
// debug case, so we'll override these guys
//=--------------------------------------------------------------------------=

void * _cdecl operator new(size_t size);
void  _cdecl operator delete(void *ptr);

//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=

#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp
#define CLEARERRORINFORET(hr) { SetErrorInfo(0, NULL); return hr; }
#define CLEARERRORINFORET_ON_FAILURE(hr) if (FAILED(hr)) { SetErrorInfo(0, NULL); return hr; }

#define CLEANUP_ON_ERROR(l)    if (l != ERROR_SUCCESS) goto CleanUp

// conversions

#define BOOL_TO_VARIANTBOOL(f) (f) ? VARIANT_TRUE : VARIANT_FALSE

// Reference counting help.

#define RELEASE_OBJECT(ptr)    if (ptr) { IUnknown *pUnk = (ptr); (ptr) = NULL; pUnk->Release(); }
#define QUICK_RELEASE(ptr)	   if (ptr) ((IUnknown *)ptr)->Release();
#define ADDREF_OBJECT(ptr)	   if (ptr) (ptr)->AddRef()



//=--------------------------------------------------------------------------=
// QueryInterface Optimizations
//=--------------------------------------------------------------------------=
// for optimizing QI's
//
#define DO_GUIDS_MATCH(riid1, riid2) ((riid1.Data1 == riid2.Data1) && (riid1 == riid2))

// Data1_*
//
// the first dword of GUIDs for most of the interesting interfaces.  these are
// used by speed critical versions of QueryInterface

#define Data1_IAdviseSink				   0x0000010f
#define Data1_IAdviseSink2				   0x00000125
#define Data1_IAdviseSinkEx 			   0x3af24290
#define Data1_IBindCtx					   0x0000000e
#define Data1_ICDataDoc 				   0xF413E4C0
#define Data1_IClassFactory 			   0x00000001
#define Data1_IClassFactory2			   0xb196b28f
#define Data1_IConnectionPoint			   0xb196b286
#define Data1_IConnectionPointContainer    0xb196b284
#define Data1_IControl_95				   0x9a4bbfb5
#define Data1_IControl					   0xa7fddba0
#define Data1_ICreateErrorInfo			   0x22f03340
#define Data1_ICreateTypeInfo			   0x00020405
#define Data1_ICreateTypeLib			   0x00020406
#define Data1_IDataAdviseHolder 		   0x00000110
#define Data1_IDataFrame				   0x97F254E0
#define Data1_IDataFrameExpert			   0x73687490
#define Data1_IDataObject				   0x0000010e
#define Data1_IDispatch 				   0x00020400
#define Data1_IDropSource				   0x00000121
#define Data1_IDropTarget				   0x00000122
#define Data1_IEnumCallback 			   0x00000108
#define Data1_IEnumConnectionPoints 	   0xb196b285
#define Data1_IEnumConnections			   0xb196b287
#define Data1_IEnumFORMATETC			   0x00000103
#define Data1_IEnumGeneric				   0x00000106
#define Data1_IEnumHolder				   0x00000107
#define Data1_IEnumMoniker				   0x00000102
#define Data1_IEnumOLEVERB				   0x00000104
#define Data1_IEnumSTATDATA 			   0x00000105
#define Data1_IEnumSTATSTG				   0x0000000d
#define Data1_IEnumString				   0x00000101
#define Data1_IEnumOleUndoActions		   0xb3e7c340
#define Data1_IEnumUnknown				   0x00000100
#define Data1_IEnumVARIANT				   0x00020404
#define Data1_IErrorInfo				   0x1cf2b120
#define Data1_IExternalConnection		   0x00000019
#define Data1_IFont 					   0xbef6e002
#define Data1_IFontDisp 				   0xbef6e003
#define Data1_IFormExpert				   0x5aac7f70
#define Data1_IGangConnectWithDefault	   0x6d5140c0
#define Data1_IInternalMoniker			   0x00000011
#define Data1_ILockBytes				   0x0000000a
#define Data1_IMalloc					   0x00000002
#define Data1_IMarshal					   0x00000003
#define Data1_IMessageFilter			   0x00000016
#define Data1_IMoniker					   0x0000000f
#define Data1_IMsoCommandTarget 		   0xb722bccb
#define Data1_IMsoDocument				   0xb722bcc5
#define Data1_IOleInPlaceComponent		   0x5efc7970
#define Data1_IMsoView					   0xb722bcc6
#define Data1_IOleAdviseHolder			   0x00000111
#define Data1_IOleCache 				   0x0000011e
#define Data1_IOleCache2				   0x00000128
#define Data1_IOleCacheControl			   0x00000129
#define Data1_IOleClientSite			   0x00000118
#define Data1_IOleCompoundUndoAction	   0xa1faf330
#define Data1_IOleContainer 			   0x0000011b
#define Data1_IOleControl				   0xb196b288
#define Data1_IOleControlSite			   0xb196b289
#define Data1_IOleInPlaceActiveObject	   0x00000117
#define Data1_IOleInPlaceFrame			   0x00000116
#define Data1_IOleInPlaceObject 		   0x00000113
#define Data1_IOleInPlaceObjectWindowless  0x1c2056cc
#define Data1_IOleInPlaceSite			   0x00000119
#define Data1_IOleInPlaceSiteEx 		   0x9c2cad80
#define Data1_IOleInPlaceSiteWindowless    0x922eada0
#define Data1_IOleInPlaceUIWindow		   0x00000115
#define Data1_IOleItemContainer 		   0x0000011c
#define Data1_IOleLink					   0x0000011d
#define Data1_IOleManager				   0x0000011f
#define Data1_IOleObject				   0x00000112
#define Data1_IOlePresObj				   0x00000120
#define Data1_IOlePropertyFrame 		   0xb83bb801
#define Data1_IOleStandardTool			   0xd97877c4
#define Data1_IOleUndoAction			   0x894ad3b0
#define Data1_IOleUndoActionManager 	   0xd001f200
#define Data1_IOleWindow				   0x00000114
#define Data1_IPSFactory				   0x00000009
#define Data1_IPSFactoryBuffer			   0xd5f569d0
#define Data1_IParseDisplayName 		   0x0000011a
#define Data1_IPerPropertyBrowsing		   0x376bd3aa
#define Data1_IPersist					   0x0000010c
#define Data1_IPersistFile				   0x0000010b
#define Data1_IPersistPropertyBag		   0x37D84F60
#define Data1_IPersistStorage			   0x0000010a
#define Data1_IPersistStream			   0x00000109
#define Data1_IPersistStreamInit		   0x7fd52380
#define Data1_IPicture					   0x7bf80980
#define Data1_IPictureDisp				   0x7bf80981
#define Data1_IPointerInactive			   0x55980ba0
#define Data1_IPropertyNotifySink		   0x9bfbbc02
#define Data1_IPropertyPage 			   0xb196b28d
#define Data1_IPropertyPage2			   0x01e44665
#define Data1_IPropertyPage3			   0xb83bb803
#define Data1_IPropertyPageInPlace		   0xb83bb802
#define Data1_IPropertyPageSite 		   0xb196b28c
#define Data1_IPropertyPageSite2		   0xb83bb804
#define Data1_IProvideClassInfo 		   0xb196b283
#define Data1_IProvideDynamicClassInfo	   0x6d5140d1
#define Data1_IQuickActivate			   0xcf51ed10
#define Data1_IRequireClasses			   0x6d5140d0
#define Data1_IRootStorage				   0x00000012
#define Data1_IRunnableObject			   0x00000126
#define Data1_IRunningObjectTable		   0x00000010
#define Data1_ISelectionContainer		   0x6d5140c6
#define Data1_IServiceProvider			   0x6d5140c1
#define Data1_ISimpleFrameSite			   0x742b0e01
#define Data1_ISpecifyPropertyPages 	   0xb196b28b
#define Data1_IStdMarshalInfo			   0x00000018
#define Data1_IStorage					   0x0000000b
#define Data1_IStream					   0x0000000c
#define Data1_ISupportErrorInfo 		   0xdf0b3d60
#define Data1_ITypeComp 				   0x00020403
#define Data1_ITypeInfo 				   0x00020401
#define Data1_ITypeLib					   0x00020402
#define Data1_IUnknown					   0x00000000
#define Data1_IViewObject				   0x0000010d
#define Data1_IViewObject2				   0x00000127
#define Data1_IViewObjectEx 			   0x3af24292
#define Data1_IWeakRef					   0x0000001a
#define Data1_ICategorizeProperties 	   0x4d07fc10

#define QI_INHERITS(pObj, itf)				\
	case Data1_##itf:						\
	  if(DO_GUIDS_MATCH(riid, IID_##itf))	 \
	  { 									\
		*ppvObjOut = (void *)(itf *)pObj;	\
	  } 									\
	  break;

#endif // _IPSERVER_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itcat.h ===
// ITCAT.H:	IITCatalog interface declaration

#ifndef __ITCAT_H__
#define __ITCAT_H__

#include <comdef.h>

// {F21B1A31-A9F2-11d0-A871-00AA006C7D01}
DEFINE_GUID(IID_IITCatalog,
0xf21b1a31, 0xa9f2, 0x11d0, 0xa8, 0x71, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#ifdef ITPROXY

// {F21B1A32-A9F2-11d0-A871-00AA006C7D01}
DEFINE_GUID(CLSID_IITCatalog,
0xf21b1a32, 0xa9f2, 0x11d0, 0xa8, 0x71, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daaa-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITCatalogLocal,
0x4662daaa, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY


// Forward declarations
interface IITDatabase;
interface IITResultSet;

DECLARE_INTERFACE_(IITCatalog, IUnknown)
{
	STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszwName = NULL) PURE;
	STDMETHOD(Close)(void) PURE;
	STDMETHOD(Lookup)(IITResultSet* pRSIn, IITResultSet* pRSOut = NULL) PURE;
	STDMETHOD(GetColumns)(IITResultSet* pRS) PURE;
};

typedef IITCatalog* LPITCATALOG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\ipserver.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

//
// implements all exported DLL functions for the program, as well as a few
// others that will be used by same
//
#include "header.h"
#include "internet.h"

#include "AutoObj.H"
#include "ClassF.H"
#include "Unknown.H"
#include "strtable.h"
#include "hhifc.h"
#include "hhsort.h"

#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

#include "atlinc.h"     // includes for ATL.

#include "iterror.h"
#include "itSort.h"
#include "itSortid.h"
#include "hhsyssrt.h"
#include "hhfinder.h"

#include "msitstg.h"

// Only including for the pahwnd declaration.
#include "secwin.h"

// So we can cleanup the lasterror object.
#include "lasterr.h"

#include <atlimpl.cpp>

extern HMODULE  g_hmodMSI;      // msi.dll module handle

CHtmlHelpModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
  OBJECT_ENTRY(CLSID_HHSysSort, CHHSysSort)
  OBJECT_ENTRY(CLSID_HHFinder, CHHFinder)
END_OBJECT_MAP()

const IID IID_ICatRegister = {0x0002E012,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CATID_SafeForScripting      = {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const GUID CATID_SafeForInitializing   = {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

// In 1996-1997 alone, these two constants appeared and disappeared in 3 different
// header files. I got tired or finding out which !@$! header file they
// got moved to this time and just defined them here.

#define LANG_ARABIC                      0x01
#define LANG_HEBREW                      0x0d

static const char txtCplDesktop[] = "Control Panel\\Desktop\\ResourceLocale";
static const char txtShellOpenFmt[] = "%s\\shell\\open\\%s";
static const char txtCommand[] = "command";
static const char txtStdOpen[] = "[open(\"%1\")]";
static const char txtStdArg[] = " %1";
static const char txtChmFile[] = "chm.file";
static const char txtHhExe[] = "hh.exe";
static const char txtItssDll[] = "itss.dll";
static const char txtItirclDll[] = "itircl.dll";
static const char txtDllRegisterServer[] = "DllRegisterServer";
static const char txtDllUnRegisterServer[] = "DllUnregisterServer";
static const char txtIE4[] = "SOFTWARE\\Microsoft\\Internet Explorer";
static const char txtVersion[] = "version";
static const char txtMouseWheel[] = "MSWHEEL_ROLLMSG";

static const char txtStringGuid[] = "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}";
static const char txtInProc[] = "CLSID\\%s\\InprocServer32";

static void SetRegKey(LPCTSTR pszKey, LPCTSTR pszValue);
void RegisterHH(PCSTR pszHHPath);   // also called by hh.cpp
extern HANDLE g_hsemMemory;

//=--------------------------------------------------------------------------=

// private routines for this file.

int       IndexOfOleObject(REFCLSID);
HRESULT   RegisterAllObjects(void);
HRESULT   UnregisterAllObjects(void);

//=--------------------------------------------------------------------------=
// StringFromGuidA
//=--------------------------------------------------------------------------=
// returns an ANSI string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPSTR                - [in/out]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
int StringFromGuidA( CLSID riid, LPSTR pszBuf )
{
  return wsprintf( (char*) pszBuf,
    txtStringGuid,
    riid.Data1, riid.Data2, riid.Data3,
    riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3],
    riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);
}

#define GUID_STR_LEN  40

//=--------------------------------------------------------------------------=
// GetRegisteredLocation
//=--------------------------------------------------------------------------=
// Returns the registered location of an inproc server given the CLSID
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
//
// Parameters:
//    REFCLSID     - [in] CLSID of the object
//    LPTSTR       - [in/out] Pathname
//
// Output:
//    BOOL         - FALSE means couldn't find it

BOOL GetRegisteredLocation( CLSID riid, LPTSTR pszPathname )
{
  BOOL bReturn = FALSE;
  HKEY hKey = NULL;
  char szGuidStr[GUID_STR_LEN];
  char szScratch[MAX_PATH];

  if( !StringFromGuidA( riid, szGuidStr ) )
    return FALSE;

  wsprintf( szScratch, txtInProc, szGuidStr );
  if( RegOpenKeyEx( HKEY_CLASSES_ROOT, szScratch, 0, KEY_READ, &hKey ) == ERROR_SUCCESS ) {
    DWORD dwSize = MAX_PATH;
    if( RegQueryValueExA( hKey, "", 0, 0, (BYTE*) szScratch, &dwSize ) == ERROR_SUCCESS ) {
      strcpy( pszPathname, szScratch );
      bReturn = TRUE;
    }
  }

  if( hKey )
    RegCloseKey( hKey );

  return bReturn;
}

BOOL WINAPI DllMain(HANDLE hInstance, DWORD  dwReason, void  *pvReserved)
{
    int i;

    switch (dwReason) {
      // set up some global variables, and get some OS/Version information
      // set up.
      //
      case DLL_PROCESS_ATTACH:
        {
            //NOTE: Do not handle resources until after the _Module.Init call below.

            OSVERSIONINFO versionInfo;
	         versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

            GetVersionEx(&versionInfo);

		     g_bWinNT5   = ((versionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (versionInfo.dwMajorVersion >= 5));
			 g_bWin98 = (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && ((versionInfo.dwMajorVersion > 4)
				|| ((versionInfo.dwMajorVersion == 4) && (versionInfo.dwMinorVersion > 0)));

            // Check version
            DWORD dwVer = GetVersion();
            DWORD dwWinVer;

            //  swap the two lowest bytes of dwVer so that the major and minor version
            //  numbers are in a usable order.
            //  for dwWinVer: high byte = major version, low byte = minor version
            //     OS               Sys_WinVersion  (as of 5/2/95)
            //     =-------------=  =-------------=
            //     Win95            0x035F   (3.95)
            //     WinNT ProgMan    0x0333   (3.51)
            //     WinNT Win95 UI   0x0400   (4.00)
            //
            dwWinVer = (UINT)(((dwVer & 0xFF) << 8) | ((dwVer >> 8) & 0xFF));
            g_fSysWinNT = FALSE;
            g_fSysWin95 = FALSE;
            g_fSysWin95Shell = FALSE;

            if (dwVer < 0x80000000) {
                g_fSysWinNT = TRUE;
                g_fSysWin95Shell = (dwWinVer >= 0x0334);
            } else  {
                g_fSysWin95 = TRUE;
                g_fSysWin95Shell = TRUE;
            }
            if ( !g_fCoInitialized )
            {
                OleInitialize(NULL);
                g_fCoInitialized = TRUE;    // so that we call CoUninitialize() when dll is unloaded
            }

            // Initialize ATL's module information.
            _Module.Init(ObjectMap, (HINSTANCE) hInstance);
            DisableThreadLibraryCalls((HINSTANCE) hInstance);

            // Now it is okay to read the resources.
            g_fDBCSSystem = (BOOL) GetSystemMetrics(SM_DBCSENABLED);
            g_lcidSystem = GetUserDefaultLCID();

            // Determine if we are on a BiDi system

            g_langSystem = PRIMARYLANGID(LANGIDFROMLCID(g_lcidSystem));

            // Get the language of the UI (Satalite DLL)
			//
            LANGID lid = PRIMARYLANGID(_Module.m_Language.GetUiLanguage());

            // determine if we are running with a localized Hebrew or Arabic UI
			//
            if(lid == LANG_ARABIC || lid == LANG_HEBREW)
                g_bBiDiUi=TRUE;				
			else
                g_bBiDiUi=FALSE;				

            // determine if we are running with a localized Hebrew or Arabic UI
			//
            if(lid == LANG_ARABIC)
                g_bArabicUi=TRUE;				
			else
                g_bArabicUi=FALSE;				

            MSG_MOUSEWHEEL = RegisterWindowMessage(txtMouseWheel);

            // Find out if we are on IE 4 or later

            {
                HKEY hkey;
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, txtIE4, 0, KEY_READ, &hkey) ==
                        ERROR_SUCCESS) {
                    char szVersion[MAX_PATH];
                    DWORD cbPath = sizeof(szVersion);
                    if (RegQueryValueEx(hkey, txtVersion, NULL, NULL, (LPBYTE) szVersion, &cbPath) == ERROR_SUCCESS) {

                        // IE 3 didn't have a version key, so if this succeeds,
                        // we know we aren't on IE 3.

                        g_fIE3 = FALSE; // we're on IE 4, not IE 3
                        g_bMsItsMonikerSupport = FALSE; // Don't make this TRUE. See bug 6984 & 6876
                    }
                    RegCloseKey(hkey);
                }
            }


            // register our server if the pathname is not the same as the
            // one that is already registered
            TCHAR szHHCtrl[MAX_PATH];
            szHHCtrl[0] = 0;
            TCHAR szModulePathname[MAX_PATH];
            szModulePathname[0] = 0;
            BOOL bRegister = FALSE;
            bRegister = !GetRegisteredLocation( CLSID_HHCtrl, szHHCtrl );
            if( !bRegister ) {
              GetModuleFileName( _Module.GetModuleInstance(), szModulePathname, MAX_PATH );
              if( lstrcmpi( szHHCtrl, szModulePathname ) != 0 )
                bRegister = TRUE;
            }
            if( bRegister )
              DllRegisterServer();

            // TODO: pahwnd needs to be incapsulated into a class and allocated on demand.
            g_cWindowSlots = 5;
            pahwnd = (CHHWinType**) lcCalloc(g_cWindowSlots * sizeof(CHHWinType*));
            memset( pahwnd, 0, g_cWindowSlots * sizeof(CHHWinType*) );

            return TRUE;
        }

      case DLL_PROCESS_DETACH:
        // DBWIN("HHCtrl unloading");

        // DeleteCriticalSection(&g_CriticalSection);

        // unregister all the registered window classes.

        // Clean out the memory in the last error object, since the heap is screwed before the destructor is called.
        g_LastError.Finish() ;

        i = 0;

        while (!ISEMPTYOBJECT(i)) {
            if (g_ObjectInfo[i].usType == OI_CONTROL) {
#ifdef _DEBUG
CONTROLOBJECTINFO* pinfo = (CONTROLOBJECTINFO*) g_ObjectInfo[i].pInfo;
#endif
                if (CTLWNDCLASSREGISTERED(i))
                    UnregisterClass(WNDCLASSNAMEOFCONTROL(i), _Module.GetModuleInstance());
            }
            i++;
        }

        // clean up our parking window.

        if (g_hwndParking) {
            DestroyWindow(g_hwndParking);
            UnregisterClass("CtlFrameWork_Parking", _Module.GetModuleInstance());
            --g_cLocks;
        }

        // free our window types list
        for( int i = 0; i < g_cWindowSlots; i++ )
          if( pahwnd[i] ) {

            CHECK_AND_FREE( pahwnd[i]->pszType );
            CHECK_AND_FREE( pahwnd[i]->pszCaption );
            CHECK_AND_FREE( pahwnd[i]->pszToc );
            CHECK_AND_FREE( pahwnd[i]->pszIndex );
            CHECK_AND_FREE( pahwnd[i]->pszFile );
            CHECK_AND_FREE( pahwnd[i]->pszHome );
            CHECK_AND_FREE( pahwnd[i]->pszJump1 );
            CHECK_AND_FREE( pahwnd[i]->pszJump2 );
            CHECK_AND_FREE( pahwnd[i]->pszUrlJump1 );
            CHECK_AND_FREE( pahwnd[i]->pszUrlJump2 );
            CHECK_AND_FREE( pahwnd[i]->pszCustomTabs );

            pahwnd[i]->ProcessDetachSafeCleanup();
          }
        CHECK_AND_FREE( pahwnd );

        // free the CHmData
        CHECK_AND_FREE( g_phmData );

        // don't call DBWIN here since it will cause a GPF

        if (g_hmodMSI != NULL)
            FreeLibrary(g_hmodMSI);
        if (g_hpalSplash)
            DeleteObject(g_hpalSplash);
        _Module.Term();
        if (g_hsemMemory)
            CloseHandle(g_hsemMemory);

        if (g_hsemNavigate)
            CloseHandle(g_hsemNavigate);

        // DeleteAllHmData();
        if (g_hmodHHA != NULL)
        {
            FreeLibrary(g_hmodHHA);
            g_hmodHHA = NULL;
        }
        if (g_fCoInitialized)
        {
           OleUninitialize();
           g_fCoInitialized = FALSE;
        }
        return TRUE;
    }

    return TRUE;
}

#ifndef HHUTIL
//=--------------------------------------------------------------------------=
// DllRegisterServer
//=--------------------------------------------------------------------------=
// registers the Automation server

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    hr = RegisterAllObjects();
    ASSERT(SUCCEEDED(hr));
    RETURN_ON_FAILURE(hr);

    CreateComponentCategory(CATID_SafeForScripting, L"Controls that are safely scriptable");
    CreateComponentCategory(CATID_SafeForInitializing, L"Controls safely initializable from persistent data");
    RegisterCLSIDInCategory(CLSID_HHCtrl, CATID_SafeForScripting);
    RegisterCLSIDInCategory(CLSID_HHCtrl, CATID_SafeForInitializing);

    char szPath[MAX_PATH];
    GetRegWindowsDirectory(szPath);
    AddTrailingBackslash(szPath);
    strcat(szPath, txtHhExe);
    if (GetFileAttributes(szPath) != HFILE_ERROR)
        RegisterHH(szPath);

    GetSystemDirectory(szPath, sizeof(szPath));
    AddTrailingBackslash(szPath);
    PSTR pszEnd = szPath + strlen(szPath);
    strcpy(pszEnd, txtItssDll);

    // Register decompression DLL (for .CHM files)

    HMODULE hmod = LoadLibrary(szPath);
    if (hmod) {
        void (STDCALL *pDllRegisterServer)(void);
        (FARPROC&) pDllRegisterServer =
            GetProcAddress(hmod, txtDllRegisterServer);
        if (pDllRegisterServer)
            pDllRegisterServer();
        FreeLibrary(hmod);
    }

    // Register the full-text search module

   strcpy(pszEnd, txtItirclDll);
   hmod = LoadLibrary(szPath);
   if (hmod) {
      void (STDCALL *pDllRegisterServer)(void);
      (FARPROC&) pDllRegisterServer =
         GetProcAddress(hmod, txtDllRegisterServer);
      if (pDllRegisterServer)
         pDllRegisterServer();
      FreeLibrary(hmod);
   }

   // register our file extensions for Removable Media Support
   HKEY hKey;
   LPCTSTR szGUID = HHFINDER_GUID;
   LPCTSTR szExt  = HHFINDER_EXTENSION;
   RegCreateKeyEx( HKEY_LOCAL_MACHINE, ITSS_FINDER, 0, NULL,
     REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
   RegSetValueEx( hKey, szExt, 0, REG_SZ, (const unsigned char*) szGUID,
     (int)(strlen(szGUID) + 1) );
   RegCloseKey( hKey );

   _Module.RegisterServer(TRUE);
   return S_OK;
}
#endif

void RegisterHH(PCSTR pszHHPath)
{
    char szFullPath[MAX_PATH];

    SetRegKey(txtDefExtension, txtChmFile);

    LoadString(_Module.GetResourceInstance(),IDS_COMPILEDHTMLFILE,szFullPath,sizeof(szFullPath));

    SetRegKey(txtChmFile, szFullPath);

    // Put path in quotes, in case there are spaces in the folder name

    szFullPath[0] = '\042';
    strcpy(szFullPath + 1, pszHHPath);
    strcat(szFullPath, "\"");

    PSTR pszPathEnd = szFullPath + strlen(szFullPath);
    strcat(szFullPath, txtStdArg);     // "pathname %1"

    char szBuf[MAX_PATH * 2];
    wsprintf(szBuf, txtShellOpenFmt, txtChmFile, txtCommand);
    SetRegKey(szBuf, szFullPath);

    // Register the icon to use for .chm files

    *pszPathEnd = '\0'; // remove the arguments
    strcpy(szFullPath + strlen(szFullPath) - 1, ",0");  // remove the close quote
    SetRegKey("chm.file\\DefaultIcon", szFullPath + 1);
}

static void SetRegKey(LPCTSTR pszKey, LPCTSTR pszValue)
{
    RegSetValue(HKEY_CLASSES_ROOT, pszKey, REG_SZ, pszValue, (int)strlen(pszValue));
}

#ifndef HHUTIL
//=--------------------------------------------------------------------------=
// DllUnregisterServer
//=--------------------------------------------------------------------------=
// unregister's the Automation server

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = UnregisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user unregistration function

    hr = UnregisterData();

    // Remove registration for decompression DLL (for .CHM files)

    HMODULE hmod = LoadLibrary(txtItssDll);
    if (hmod) {
        void (STDCALL *pDllRegisterServer)(void);
        (FARPROC&) pDllRegisterServer =
            GetProcAddress(hmod, txtDllUnRegisterServer);
        if (pDllRegisterServer)
            pDllRegisterServer();
        FreeLibrary(hmod);
    }

    // Remove registration for the full-text search module

    hmod = LoadLibrary(txtItirclDll);
    if (hmod) {
        void (STDCALL *pDllRegisterServer)(void);
        (FARPROC&) pDllRegisterServer =
            GetProcAddress(hmod, txtDllUnRegisterServer);
        if (pDllRegisterServer)
            pDllRegisterServer();
        FreeLibrary(hmod);
    }

   // unregister our file extensions for Removable Media Support

   HKEY hKey;
   LPCTSTR szGUID = HHFINDER_GUID;
   LPCTSTR szExt  = HHFINDER_EXTENSION;
   RegCreateKeyEx( HKEY_LOCAL_MACHINE, ITSS_FINDER, 0, NULL,
     REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
   RegDeleteKey( hKey, szExt );
   RegCloseKey( hKey );

   _Module.UnregisterServer();

    // BUGBUG: remove association with .CHM files

    return hr;
}
#endif

#ifndef HHUTIL
//=--------------------------------------------------------------------------=
// DllCanUnloadNow
//=--------------------------------------------------------------------------=
// we are being asked whether or not it's okay to unload the DLL.  just check
// the lock counts on remaining objects ...
//
// Output:
//    HRESULT        - S_OK, can unload now, S_FALSE, can't.

STDAPI DllCanUnloadNow(void)
{
    // if there are any objects lying around, then we can't unload.  The
    // controlling CUnknownObject class that people should be inheriting from
    // takes care of this

    return (g_cLocks) ? S_FALSE : S_OK;
}
#endif

#ifndef HHUTIL
//=--------------------------------------------------------------------------=
// DllGetClassObject
//=--------------------------------------------------------------------------=
// creates a ClassFactory object, and returns it.
//
// Parameters:
//    REFCLSID        - CLSID for the class object
//    REFIID          - interface we want class object to be.
//    void **         - pointer to where we should ptr to new object.
//
// Output:
//    HRESULT         - S_OK, CLASS_E_CLASSNOTAVAILABLE, E_OUTOFMEMORY,
//                      E_INVALIDARG, E_UNEXPECTED

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObjOut)
{
    HRESULT hr;
    void   *pv;
    int     iIndex;

   if( IsEqualCLSID( rclsid, CLSID_HHSysSort ) || IsEqualCLSID( rclsid, CLSID_HHFinder ) )
     return _Module.GetClassObject( rclsid, riid, ppvObjOut );

    // arg checking

    if (!ppvObjOut)
        return E_INVALIDARG;

    // first of all, make sure they're asking for something we work with.

    iIndex = IndexOfOleObject(rclsid);
    if (iIndex == -1)
        return CLASS_E_CLASSNOTAVAILABLE;

    // create the blank object.

    pv = (void *)new CClassFactory(iIndex);
    if (!pv)
        return E_OUTOFMEMORY;

    // QI for whatever the user has asked for.
    //
    hr = ((IUnknown *)pv)->QueryInterface(riid, ppvObjOut);
    ((IUnknown *)pv)->Release();

    return hr;
}
#endif

//=--------------------------------------------------------------------------=
// IndexOfOleObject
//=--------------------------------------------------------------------------=
// returns the index in our global table of objects of the given CLSID.  if
// it's not a supported object, then we return -1
//
// Parameters:
//    REFCLSID     - [in] duh.
//
// Output:
//    int          - >= 0 is index into global table, -1 means not supported

int IndexOfOleObject(REFCLSID rclsid)
{
    int x = 0;

    // an object is creatable if it's CLSID is in the table of all allowable object
    // types.

    while (!ISEMPTYOBJECT(x)) {
#ifdef _DEBUG
CONTROLOBJECTINFO* pinfo = (CONTROLOBJECTINFO*) g_ObjectInfo[x].pInfo;
#endif

        if (OBJECTISCREATABLE(x)) {
            if (rclsid == CLSIDOFOBJECT(x))
                return x;
        }
        x++;
    }

    return -1;
}

//=--------------------------------------------------------------------------=
// RegisterAllObjects
//=--------------------------------------------------------------------------=
// registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HERSULT        - S_OK, E_FAIL
//
// Notes:
//

const char g_szLibName[] = "Internet";

HRESULT RegisterAllObjects(void)
{
    HRESULT hr;
    int     x = 0;

    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.

    while (!ISEMPTYOBJECT(x)) {
#ifdef _DEBUG
CONTROLOBJECTINFO* pinfo = (CONTROLOBJECTINFO*) g_ObjectInfo[x].pInfo;
#endif

        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }

        // depending on the object type, register different pieces of information

        switch (g_ObjectInfo[x].usType) {

          // for both simple co-creatable objects and proeprty pages, do the same
          // thing

          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:
            RegisterUnknownObject(NAMEOFOBJECT(x), CLSIDOFOBJECT(x));
            break;

          case OI_AUTOMATION:
            RegisterAutomationObject(g_szLibName, NAMEOFOBJECT(x),
                VERSIONOFOBJECT(x), *g_pLibid, CLSIDOFOBJECT(x));
            break;

          case OI_CONTROL:
            RegisterControlObject(g_szLibName, NAMEOFOBJECT(x),
                VERSIONOFOBJECT(x), *g_pLibid, CLSIDOFOBJECT(x),
                    OLEMISCFLAGSOFCONTROL(x), BITMAPIDOFCONTROL(x));
            break;

        }
        x++;
    }

    // Load and register our type library.

    if (g_fServerHasTypeLibrary) {
        char szTmp[MAX_PATH];
        DWORD dwPathLen = GetModuleFileName(_Module.GetModuleInstance(), szTmp, MAX_PATH);
        MAKE_WIDEPTR_FROMANSI(pwsz, szTmp);

        ITypeLib *pTypeLib;
        hr = LoadTypeLib(pwsz, &pTypeLib);
        RETURN_ON_FAILURE(hr);
        hr = RegisterTypeLib(pTypeLib, pwsz, NULL);
        pTypeLib->Release();
        RETURN_ON_FAILURE(hr);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// UnregisterAllObjects
//=--------------------------------------------------------------------------=
// un-registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HRESULT        - S_OK

HRESULT UnregisterAllObjects(void)
{
    int x = 0;

    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
#ifdef _DEBUG
CONTROLOBJECTINFO* pinfo = (CONTROLOBJECTINFO*) g_ObjectInfo[x].pInfo;
#endif

        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }

        switch (g_ObjectInfo[x].usType) {

            case OI_UNKNOWN:
            case OI_PROPERTYPAGE:
                UnregisterUnknownObject(CLSIDOFOBJECT(x));
                break;

            case OI_CONTROL:
                UnregisterControlObject(g_szLibName, NAMEOFOBJECT(x),
                    VERSIONOFOBJECT(x), CLSIDOFOBJECT(x));

            case OI_AUTOMATION:
                UnregisterAutomationObject(g_szLibName, NAMEOFOBJECT(x),
                    VERSIONOFOBJECT(x), CLSIDOFOBJECT(x));
                break;

        }
        x++;
    }

    /*
     * if we've got one, unregister our type library [this isn't an API
     * function -- we've implemented this ourselves]
     */

    if (g_pLibid)
        UnregisterTypeLibrary(*g_pLibid);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// UnregisterData
//=--------------------------------------------------------------------------=
// inproc server writers should unregister anything they registered in
// RegisterData() here.
//
// Output:
//    BOOL            - false means failure.

BOOL UnregisterData(void)
{
    HRESULT hr;

    hr = UnRegisterCLSIDInCategory(CLSID_HHCtrl, CATID_SafeForScripting);
    hr = UnRegisterCLSIDInCategory(CLSID_HHCtrl, CATID_SafeForInitializing);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itdb.h ===
// ITDB.H:	ITDatabase interface declaration

#ifndef __ITDB_H__
#define __ITDB_H__

// {8fa0d5a2-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITDatabase, 
0x8fa0d5a2, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {66673452-8C23-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITDatabase, 
0x66673452, 0x8c23, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daa9-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITDatabaseLocal, 
0x4662daa9, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY


// Guaranteed to be an invalid value for dwObjInstance params in IITDatabase
// methods.
#define	IITDB_OBJINST_NULL	((DWORD) 0xFFFFFFFF)


DECLARE_INTERFACE_(IITDatabase, IUnknown)
{
	STDMETHOD(Open)(LPCWSTR lpszHost, LPCWSTR lpszMoniker, DWORD dwFlags) PURE;
	STDMETHOD(Close)(void) PURE;

	// Creates an unnamed object that can be referenced in the future
	// by *pdwObjInstance.  Note that the value in *pdwObjInstance will be
	// persisted by the database when it is asked to save via
	// IPersistStorage::Save.
	STDMETHOD(CreateObject)(REFCLSID rclsid, DWORD *pdwObjInstance) PURE;

	// Retrieves a specified IUnknown-based interface on the object identified
	// by dwObjInstance.
	STDMETHOD(GetObject)(DWORD dwObjInstance, REFIID riid, LPVOID *ppvObj) PURE;

	// To obtain a pointer to a named object's persistence the object's full
	// name (including any object-specific type prefix) should be passed in
	// lpswszObject.  If *lpwszObject is NULL, then the database's own storage
	// will be returned.  If lpwszObject is NULL, then dwObjInstance will be
	// used to identify the object and locate its persistence.  On exit,
	// *ppvPersistence will be either an IStorage* or an IStream*, depending
	// on what the caller specified with the fStream param.  The caller should
	// assume that only read operations can be performed on *ppvPersistence.
	// If the specified object's persistence doesn't exist, or if it exists
	// but is of the wrong type, then STG_E_FILENOTFOUND will be returned. 
	STDMETHOD(GetObjectPersistence)(LPCWSTR lpwszObject, DWORD dwObjInstance,
									LPVOID *ppvPersistence, BOOL fStream) PURE;
};

typedef IITDatabase* LPITDB;

#endif		// __ITDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itcc.h ===
/************************************************************************
 *
 * ITCC.H
 *
 * Copyright (c) Microsoft Corporation 1993 - 1997
 * All rights reserved.
 *
 *************************************************************************
 *
 * Module intent:
 *
 * This module contains the API (Application Programming Interface)
 * for creating and updating ITIR objects and storages
 *
 *************************************************************************
 *
 * Current owner: JohnRush
 *
 ************************************************************************/

#ifndef _ITCC_H // {
#define _ITCC_H

#include "itpropl.h"
#include "itdb.h"

// Document property macros
#define STDPROP_UID         1
#define STDPROP_TITLE       2
#define STDPROP_USERDATA    3
#define STDPROP_KEY         4

#define STDPROP_SORTKEY		100
#define STDPROP_DISPLAYKEY	101
#define STDPROP_SORTORDINAL 102

#define STDPROP_INDEX_TEXT    200
#define STDPROP_INDEX_VFLD    201
#define STDPROP_INDEX_DTYPE   202
#define STDPROP_INDEX_LENGTH  203
#define STDPROP_INDEX_BREAK   204

#define STDPROP_INDEX_TERM              210
#define STDPROP_INDEX_TERM_RAW_LENGTH   211

#define STDPROP_USERPROP_BASE   0x00010000
#define STDPROP_USERPROP_MAX    0x7FFFFFFF

// Property destinations for word wheels
#define SZ_WWDEST_GLOBAL    L"GLOBAL"
#define SZ_WWDEST_KEY       L"KEY"
#define SZ_WWDEST_OCC       L"OCC"


// {4662daa2-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITCmdInt,
0x4662daa2, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa3-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITSvMgr,
0x4662daa3, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4CF34C30-9BF9-11d0-8764-00A0C913F764}
DEFINE_GUID(IID_IITCmdInt,
0x4cf34c30, 0x9bf9, 0x11d0, 0x87, 0x64, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);

// {4E7DA031-9C11-11d0-8764-00A0C913F764}
DEFINE_GUID(IID_IITSvMgr,
0x4e7da031, 0x9c11, 0x11d0, 0x87, 0x64, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);

// {4662daa5-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITWordWheelUpdate,
0x4662daa5, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);
    
// {8fa0d5a5-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITBuildCollect,
0x8fa0d5a5, 0xdedf, 0x11d0, 0x9a, 0x61, 0x0, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa4-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupUpdate,
0x4662daa4, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5aa-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITIndexBuild,
0x8fa0d5aa, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5ab-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITWWFilterBuild,
0x8fa0d5ab, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#pragma pack( push, SPECIAL_VARARG_1 )
#pragma pack(4)
struct VARARG
{
    DWORD   dwArgc;
    void    *Argv[20];
};
#pragma pack( pop, SPECIAL_VARARG_1 )

// Document class
class CSvDoc
{
public:
    virtual HRESULT WINAPI ResetDocTemplate (void) PURE;

    virtual HRESULT WINAPI AddObjectEntry(LPCWSTR lpObjName, IITPropList *pPL) PURE;
    virtual HRESULT WINAPI AddObjectEntry
        (LPCWSTR lpObjName, LPCWSTR szPropDest, IITPropList *pPL) PURE;
};

// Service manager class
DECLARE_INTERFACE_(IITSvMgr, IUnknown)
{
    STDMETHOD(Initiate)(IStorage *pistgStorage, IStream *piistmLog) PURE;
	STDMETHOD(Dispose)(void) PURE;
	STDMETHOD(Build)(void) PURE;
	STDMETHOD(SetPropDest)
        (LPCWSTR szObjectName, LPCWSTR szDestination, IITPropList *pPL) PURE;
	STDMETHOD(CreateBuildObject)(LPCWSTR pwstrObjectName, REFCLSID refclsid) PURE;
    STDMETHOD(GetBuildObject)
        (LPCWSTR pwstrObjectName, REFIID refiid, void **pInterface) PURE;

	STDMETHOD(CreateDocTemplate)(CSvDoc **ppDoc) PURE;
	STDMETHOD(FreeDocTemplate)(CSvDoc *pDoc) PURE;
	STDMETHOD(AddDocument)(CSvDoc *pDoc) PURE;

	STDMETHOD(HashString)(IN LPCWSTR lpwstr, OUT DWORD *pdwHash) PURE;
};

// Command Interpreter Interface
DECLARE_INTERFACE_(IITCmdInt, IUnknown)
{
	STDMETHOD(Initiate)(IITSvMgr *piitsv) PURE;
	STDMETHOD(Dispose)(void) PURE;
	STDMETHOD(LoadFromStream)(IStream *pMVPStream, IStream *pLogStream) PURE;
};

typedef struct tagHelperInfo
{
    UINT    CodePage;
    LCID    lcid;
    DWORD   argc1;
    DWORD   *argv1;
    DWORD   argc2;
    LPWSTR  *argv2;
} HelperInfo, *PHelperInfo;

// This structure is sent to IITBuildCollect::SetBuildStats
typedef struct tagIITBOCI
{
    DWORD dwSize;   // Must be set to size of this structure
    DWORD dwMaxUID; // The highest uid authored for this title
} ITBuildObjectControlInfo;

DECLARE_INTERFACE_(IITBuildCollect, IUnknown)
{
    STDMETHOD(SetConfigInfo)(IITDatabase *piitdb, VARARG vaParams) PURE;
	STDMETHOD(InitHelperInstance)(DWORD dwHelperObjInstance,
        IITDatabase *pITDatabase, DWORD dwCodePage,
        LCID lcid, VARARG vaDword, VARARG vaString) PURE;
	STDMETHOD(SetEntry)(LPCWSTR szDest, IITPropList *pPropList) PURE;
	STDMETHOD(Close)(void) PURE;
    STDMETHOD(GetTypeString)(LPWSTR wstrType, DWORD *pLength) PURE;
    STDMETHOD(SetBuildStats)(ITBuildObjectControlInfo &itboci) PURE;
};


#endif // _ITCC_H }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itgroup.h ===
// ITGROUP.H:  IITGroup interface declaration

#ifndef __ITGROUP_H__
#define __ITGROUP_H__

//#include <comdef.h>

// {B1A6CA91-A479-11d0-9741-00AA006117EB}
DEFINE_GUID(IID_IITGroup, 
0xb1a6ca91, 0xa479, 0x11d0, 0x97, 0x41, 0x0, 0xaa, 0x0, 0x61, 0x17, 0xeb);

// {98258914-B6AB-11d0-9D92-00A0C90F55A5}
DEFINE_GUID(IID_IITGroupArray, 
0x98258914, 0xb6ab, 0x11d0, 0x9d, 0x92, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xa5);

#ifdef ITPROXY

// {B1A6CA92-A479-11d0-9741-00AA006117EB}
DEFINE_GUID(CLSID_IITGroup, 
0xb1a6ca92, 0xa479, 0x11d0, 0x97, 0x41, 0x0, 0xaa, 0x0, 0x61, 0x17, 0xeb);

// {98258915-B6AB-11d0-9D92-00A0C90F55A5}
DEFINE_GUID(CLSID_IITGroupArray, 
0x98258915, 0xb6ab, 0x11d0, 0x9d, 0x92, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xa5);

#else

// {4662daab-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupLocal, 
0x4662daab, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daac-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupArrayLocal, 
0x4662daac, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// Forward declarations
interface IITDatabase;

DECLARE_INTERFACE_(IITGroup, IUnknown)
{

	STDMETHOD(Initiate)(DWORD lcGrpItem) PURE;
	STDMETHOD(CreateFromBitVector)(LPBYTE lpBits, DWORD dwSize, DWORD dwItems) PURE;
	STDMETHOD(CreateFromBuffer)(HANDLE h) PURE;
    STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker) PURE;
    STDMETHOD(Free)(void) PURE;
	STDMETHOD(CopyOutBitVector)(IITGroup* pIITGroup) PURE;
    STDMETHOD(AddItem)(DWORD dwGrpItem) PURE;
    STDMETHOD(RemoveItem)(DWORD dwGrpItem) PURE;
	STDMETHOD(FindTopicNum)(DWORD dwCount, LPDWORD lpdwOutputTopicNum) PURE;
	STDMETHOD(FindOffset)(DWORD dwTopicNum, LPDWORD lpdwOutputOffset) PURE;
    STDMETHOD(GetSize)(LPDWORD dwGrpSize) PURE;
	STDMETHOD(Trim)(void) PURE;
	STDMETHOD(And)(IITGroup* pIITGroup) PURE;
	STDMETHOD(And)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut) PURE;
	STDMETHOD(Or)(IITGroup* pIITGroup) PURE;
	STDMETHOD(Or)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut) PURE;
	STDMETHOD(Not)(void) PURE;
	STDMETHOD(Not)(IITGroup* pIITGroupOut) PURE;
	STDMETHOD(IsBitSet)(DWORD dwTopicNum) PURE;
	STDMETHOD(CountBitsOn)(LPDWORD lpdwTotalNumBitsOn) PURE;
	STDMETHOD(Clear)(void) PURE;
    STDMETHOD_(LPVOID, GetLocalImageOfGroup)(void) PURE;
    STDMETHOD(PutRemoteImageOfGroup)(LPVOID lpGroupIn) PURE;

};

typedef IITGroup* LPITGROUP;

#define ITGP_MAX_GROUPARRAY_ENTRIES 32   // maximum number of groups allowed in a collection
#define ITGP_ALL_ENTRIES (-1L)
#define ITGP_OPERATOR_OR   0
#define ITGP_OPERATOR_AND  1

DECLARE_INTERFACE_(IITGroupArray, IITGroup)
{
	// composite group interface
	STDMETHOD(InitEntry)(IITDatabase *piitDB, LPCWSTR lpwszName, LONG& lEntryNum) PURE;
	STDMETHOD(InitEntry)(IITGroup *piitGroup, LONG& lEntryNum) PURE;
	STDMETHOD(SetEntry)(LONG lEntryNum) PURE;
	STDMETHOD(ClearEntry)(LONG lEntryNum) PURE;
	STDMETHOD(SetDefaultOp)(LONG cDefaultOp) PURE;
	STDMETHOD(ToString)(LPWSTR *ppwBuffer) PURE;
};

typedef IITGroupArray* LPIITGroupArray;
#endif // __ITGROUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itquery.h ===
// ITQUERY.H:	IITIndex and IITQuery interface declarations

#ifndef __ITQUERY_H__
#define __ITQUERY_H__

#include "iterror.h"

// {8fa0d5a3-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITIndex, 
0x8fa0d5a3, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {A38D3483-8C49-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITIndex, 
0xa38d3483, 0x8c49, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daad-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITIndexLocal, 
0x4662daad, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// {8fa0d5ac-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITQuery, 
0x8fa0d5ac, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa6-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITQuery, 
0x4662daa6, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// Defines
#define IMPLICIT_AND            0x0000
#define IMPLICIT_OR             0x0001
#define COMPOUNDWORD_PHRASE     0x0010 // use PHRASE opr for compound words
#define QUERYRESULT_RANK        0x0100 // Ranked the result. If not highest hit 1st (topics in UID order)
#define QUERYRESULT_UIDSORT     0x0200 // Result topics are 1st in 1st out
#define QUERYRESULT_SKIPOCCINFO 0x8000 // Topic list only, no occurrence info

#define STEMMED_SEARCH	        0x00010000
#define RESULTSET_ASYNC			0x00020000
#define QUERY_GETTERMS			0x00080000	// Return with each set of occurrence
											// data a pointer to the term string
											// that the data is associated with.

// Standard properties
#define STDPROP_SEARCHBASE  500
#define STDPROP_FIELD			STDPROP_SEARCHBASE
#define STDPROP_LENGTH			(STDPROP_SEARCHBASE + 1)
#define STDPROP_COUNT			(STDPROP_SEARCHBASE + 2)
#define STDPROP_OFFSET			(STDPROP_SEARCHBASE + 3)
#define STDPROP_TERM_UNICODE_ST	(STDPROP_SEARCHBASE + 4)

// Don't know signature of callbacks yet
typedef void (*LPFNCBBREAK)(void);    
typedef void (*LPFNRESULTCB)(void);


// Forward declarations
interface IITResultSet;
interface IITQuery;
interface IITDatabase;
interface IITGroup;

DECLARE_INTERFACE_(IITIndex, IUnknown)
{

	STDMETHOD(Open)(IITDatabase* pITDB, LPCWSTR lpszIndexMoniker, BOOL fInsideDB) PURE;
	STDMETHOD(Close)(void) PURE;

	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;
	STDMETHOD(GetWordBreakerInstance)(DWORD *pdwObjInstance) PURE;

	STDMETHOD(CreateQueryInstance)(IITQuery** ppITQuery) PURE;
	STDMETHOD(Search)(IITQuery* pITQuery, IITResultSet* pITResult) PURE;
	STDMETHOD(Search)(IITQuery* pITQuery, IITGroup* pITGroup) PURE;
};

typedef IITIndex* PITINDEX;


DECLARE_INTERFACE_(IITQuery, IUnknown)
{
	STDMETHOD(SetResultCallback)(FCALLBACK_MSG *pfcbkmsg) PURE;
	STDMETHOD(SetCommand)(LPCWSTR lpszCommand) PURE;
	STDMETHOD(SetOptions)(DWORD dwFlags) PURE;
	STDMETHOD(SetProximity)(WORD wNear) PURE;
	STDMETHOD(SetGroup)(IITGroup* pITGroup) PURE;
	STDMETHOD(SetResultCount)(LONG cRows) PURE;

	STDMETHOD(GetResultCallback)(FCALLBACK_MSG *pfcbkmsg) PURE;
	STDMETHOD(GetCommand)(LPCWSTR& lpszCommand) PURE;
	STDMETHOD(GetOptions)(DWORD& dwFlags) PURE;
	STDMETHOD(GetProximity)(WORD& wNear) PURE;
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup) PURE;
	STDMETHOD(GetResultCount)(LONG& cRows) PURE;

	STDMETHOD(ReInit)() PURE;

};

typedef IITQuery* PITQUERY;


#endif		// __ITQUERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\iterror.h ===
#ifndef __ITERROR_H__
#define __ITERROR_H__


#ifdef __cplusplus
extern "C" {
#endif


// define the old error types in terms of HRESULTs
typedef HRESULT* PHRESULT;

#define ERR     HRESULT
#define ERRB    HRESULT
#define LPERRB  HRESULT*
#define RC      HRESULT


#define	SetErrCode(a,b)	SetErr(a, b)
#define	SetErrReturn(a)	SetErr(0, a)


HRESULT PASCAL SetErr (HRESULT* phr, HRESULT ErrCode);


/*************************************************************************
 *
 *                  CALLBACK FUNCTIONS PROTOTYPES
 *
 * User callback functions are needed in case:
 *  - The application needs to support interrupt
 *  - The application needs to display error messages its way
 *  - The application needs to know the status of the process
 *************************************************************************/
typedef ERR (FAR PASCAL *ERR_FUNC) (DWORD dwFlag, LPVOID pUserData, LPVOID pMessage);

/*************************************************************************
 * Call back structure
 *  Contains information about all callback functions
 *************************************************************************/ 

#define ERRFLAG_INTERRUPT      0x01 // The processes should be cancelled
#define ERRFLAG_STATUS         0x02 // High-level status messages
#define ERRFLAG_STATUS_VERBOSE 0x04 // Low-level status messages
#define ERRFLAG_ERROR          0x08 // Warning & Error messages
#define ERRFLAG_STRING         0x10 // Debug string messages

typedef struct fCallBack_msg
{
    ERR_FUNC MessageFunc;
    LPVOID pUserData;
    DWORD  dwFlags;
} FCALLBACK_MSG, FAR * PFCALLBACK_MSG;


// ***********************************************************************
// This structure should be filled out and passed back in the case of
// an error.
// ***********************************************************************
typedef WORD HCE;   // User errors
typedef WORD EP;    // Error Phase
typedef struct
{
    LPCSTR  pchFile;
    LONG    iLine;
    DWORD   iTopic;
    DWORD   fCustom; // If true then var1 is LPCSTR to custom error message
    DWORD   var1, var2, var3;   // Error parameters

    EP      ep;                 // Error Phase
    HCE     errCode;
} ERRC, FAR *PERRC;

#define CALLBACKKEY 0x524A4A44

typedef struct
{
    DWORD dwReserved;
    DWORD dwKey;
    FCALLBACK_MSG Callback;
} CUSTOMSTRUCT, FAR *PCUSTOMSTRUCT;

// Error Phase values
#define epNoFile       0
#define epLine         1
#define epTopic        2
#define epOffset       3
#define epMVBtopic	   4
#define epAliasLine	   5
#define epByteOffset   6


//
// The InfoTech error codes
//
#define E_NOTEXIST          _HRESULT_TYPEDEF_(0x80001000L)
#define E_DUPLICATE         _HRESULT_TYPEDEF_(0x80001001L)
#define E_BADVERSION        _HRESULT_TYPEDEF_(0x80001002L)
#define E_BADFILE           _HRESULT_TYPEDEF_(0x80001003L)
#define E_BADFORMAT         _HRESULT_TYPEDEF_(0x80001004L)
#define E_NOPERMISSION      _HRESULT_TYPEDEF_(0x80001005L)
#define E_ASSERT            _HRESULT_TYPEDEF_(0x80001006L)
#define E_INTERRUPT         _HRESULT_TYPEDEF_(0x80001007L)
#define E_NOTSUPPORTED      _HRESULT_TYPEDEF_(0x80001008L)
#define E_OUTOFRANGE        _HRESULT_TYPEDEF_(0x80001009L)                  
#define E_GROUPIDTOOBIG     _HRESULT_TYPEDEF_(0x8000100AL)
#define E_TOOMANYTITLES     _HRESULT_TYPEDEF_(0x8000100BL)
#define E_NOMERGEDDATA      _HRESULT_TYPEDEF_(0x8000100CL)
#define E_NOTFOUND          _HRESULT_TYPEDEF_(0x8000100DL)
#define E_CANTFINDDLL       _HRESULT_TYPEDEF_(0x8000100EL)
#define E_NOHANDLE          _HRESULT_TYPEDEF_(0x8000100FL) 
#define E_GETLASTERROR      _HRESULT_TYPEDEF_(0x80001010L)
#define E_BADPARAM			_HRESULT_TYPEDEF_(0x80001011L)
#define E_INVALIDSTATE		_HRESULT_TYPEDEF_(0x80001012L)
#define E_NOTOPEN           _HRESULT_TYPEDEF_(0x80001013L)
#define E_ALREADYOPEN       _HRESULT_TYPEDEF_(0x80001013L)
#define E_UNKNOWN_TRANSPORT _HRESULT_TYPEDEF_(0x80001016L)
#define E_UNSUPPORTED_TRANSPORT _HRESULT_TYPEDEF_(0x80001017L)
#define E_BADFILTERSIZE     _HRESULT_TYPEDEF_(0x80001018L)
#define E_TOOMANYOBJECTS    _HRESULT_TYPEDEF_(0x80001019L)
#define E_NAMETOOLONG       _HRESULT_TYPEDEF_(0x80001020L)

#define E_FILECREATE        _HRESULT_TYPEDEF_(0x80001030L) 
#define E_FILECLOSE         _HRESULT_TYPEDEF_(0x80001031L)
#define E_FILEREAD          _HRESULT_TYPEDEF_(0x80001032L)
#define E_FILESEEK          _HRESULT_TYPEDEF_(0x80001033L)
#define E_FILEWRITE         _HRESULT_TYPEDEF_(0x80001034L)
#define E_FILEDELETE        _HRESULT_TYPEDEF_(0x80001035L)
#define E_FILEINVALID       _HRESULT_TYPEDEF_(0x80001036L)
#define E_FILENOTFOUND      _HRESULT_TYPEDEF_(0x80001037L)
#define E_DISKFULL          _HRESULT_TYPEDEF_(0x80001038L)

#define E_TOOMANYTOPICS     _HRESULT_TYPEDEF_(0x80001050L)
#define E_TOOMANYDUPS       _HRESULT_TYPEDEF_(0x80001051L)
#define E_TREETOOBIG        _HRESULT_TYPEDEF_(0x80001052L)
#define E_BADBREAKER        _HRESULT_TYPEDEF_(0x80001053L)
#define E_BADVALUE          _HRESULT_TYPEDEF_(0x80001054L)
#define E_ALL_WILD          _HRESULT_TYPEDEF_(0x80001055L)
#define E_TOODEEP           _HRESULT_TYPEDEF_(0x80001056L)
#define E_EXPECTEDTERM      _HRESULT_TYPEDEF_(0x80001057L)
#define E_MISSLPAREN        _HRESULT_TYPEDEF_(0x80001058L)
#define E_MISSRPAREN        _HRESULT_TYPEDEF_(0x80001059L)
#define E_MISSQUOTE         _HRESULT_TYPEDEF_(0x8000105AL)
#define E_NULLQUERY         _HRESULT_TYPEDEF_(0x8000105BL)
#define E_STOPWORD          _HRESULT_TYPEDEF_(0x8000105CL)
#define E_BADRANGEOP        _HRESULT_TYPEDEF_(0x8000105DL)
#define E_UNMATCHEDTYPE     _HRESULT_TYPEDEF_(0x8000105EL)
#define E_WORDTOOLONG       _HRESULT_TYPEDEF_(0x8000105FL)
#define E_BADINDEXFLAGS     _HRESULT_TYPEDEF_(0x80001060L)
#define E_WILD_IN_DTYPE		_HRESULT_TYPEDEF_(0x80001061L)   
#define E_NOSTEMMER			_HRESULT_TYPEDEF_(0x80001062L)

// Property list and result set errors
#define E_MISSINGPROP		_HRESULT_TYPEDEF_(0x80001080L)
#define E_PROPLISTNOTEMPTY  _HRESULT_TYPEDEF_(0x80001081L)
#define E_PROPLISTEMPTY     _HRESULT_TYPEDEF_(0x80001082L)
#define E_ALREADYINIT       _HRESULT_TYPEDEF_(0x80001083L)
#define E_NOTINIT           _HRESULT_TYPEDEF_(0x80001084L)
#define E_RESULTSETEMPTY	_HRESULT_TYPEDEF_(0x80001085L)
#define E_TOOMANYCOLUMNS	_HRESULT_TYPEDEF_(0x80001086L)
#define E_NOKEYPROP			_HRESULT_TYPEDEF_(0x80001087L)

#ifdef __cplusplus
}
#endif

#endif  // __ITERROR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itpropl.h ===
// ITPROPL.H:	ITPropertyList interface declaration

#ifndef __ITPROPL_H__
#define __ITPROPL_H__

#include <ocidl.h>

// {1F403BB1-9997-11d0-A850-00AA006C7D01}
DEFINE_GUID(IID_IITPropList, 
0x1f403bb1, 0x9997, 0x11d0, 0xa8, 0x50, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

// {4662daae-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITPropList, 
0x4662daae, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

typedef DWORD PROPID;

// Operations you can do on a property
#define PROP_ADD    0x00000000
#define PROP_DELETE 0x00000001
#define PROP_UPDATE 0x00000002

// Type of data
#define TYPE_VALUE   0x00000000
#define TYPE_POINTER 0x00000001
#define TYPE_STRING  0x00000002

// Class definition of CProperty
class CProperty
{
public:
    PROPID dwPropID;        // property ID
    DWORD cbData;           // Amount of data
    DWORD dwType;           // What type this is
    union
    {
        LPCWSTR lpszwData;  // String
        LPVOID lpvData;     // Any kind of data
        DWORD  dwValue;     // Numerical data
    };
	BOOL fPersist;          // TRUE to persist this property

};

typedef CProperty* LPPROP;


// Interface def. for IITPropList
DECLARE_INTERFACE_(IITPropList, IPersistStreamInit)
{

    // dwOperation = operation (add, delete, update, etc.) to perform on property list
	STDMETHOD(Set)(PROPID PropID, DWORD dwData, DWORD dwOperation) PURE;
	STDMETHOD(Set)(PROPID PropID, LPVOID lpvData, DWORD cbData, DWORD dwOperation) PURE;
    STDMETHOD(Set)(PROPID PropID, LPCWSTR lpszwString, DWORD dwOperation) PURE;
    STDMETHOD(Add)(CProperty& Prop) PURE;

    STDMETHOD(Get)(PROPID PropID, CProperty& Property) PURE;
    STDMETHOD(Clear)() PURE;

    // set persistence state on property
    STDMETHOD(SetPersist)(PROPID PropID, BOOL fPersist) PURE;   // single property
    STDMETHOD(SetPersist)(BOOL fPersist) PURE;          // all properties in list

    // for enumerating properties
    STDMETHOD(GetFirst)(CProperty& Property) PURE;
    STDMETHOD(GetNext)(CProperty& Property) PURE;
    STDMETHOD(GetPropCount)(LONG &cProp) PURE;

	// persist header and data separately
	STDMETHOD(SaveHeader)(LPVOID lpvData, DWORD dwHdrSize) PURE;
	STDMETHOD(SaveData)(LPVOID lpvHeader, DWORD dwHdrSize, LPVOID lpvData, DWORD dwBufSize) PURE;
	STDMETHOD(GetHeaderSize)(DWORD& dwHdrSize) PURE;
	STDMETHOD(GetDataSize)(LPVOID lpvHeader, DWORD dwHdrSize, DWORD& dwDataSize) PURE;
	STDMETHOD(SaveDataToStream)(LPVOID lpvHeader, DWORD dwHdrSize, IStream* pStream) PURE;

    // persist to a memory buffer
    STDMETHOD(LoadFromMem)(LPVOID lpvData, DWORD dwBufSize) PURE;
    STDMETHOD(SaveToMem)(LPVOID lpvData, DWORD dwBufSize) PURE;

};

typedef IITPropList* LPITPROPLIST;

#endif		// __ITPROPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itrs.h ===
// ITRS.H:	ITResultSet interface declaration

#ifndef __ITRS_H__
#define __ITRS_H__


// {3BB91D41-998B-11d0-A850-00AA006C7D01}
DEFINE_GUID(IID_IITResultSet, 
0x3bb91d41, 0x998b, 0x11d0, 0xa8, 0x50, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

// {4662daa7-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITResultSet, 
0x4662daa7, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// maximum number of columns in a row set
#define MAX_COLUMNS  256

// Column priorities
typedef enum
{
    PRIORITY_LOW = 0,
    PRIORITY_NORMAL = 1,
    PRIORITY_HIGH = 2,

} PRIORITY;


// Forward declarations
class CProperty;

typedef struct tagROWSTATUS
{
    LONG lRowFirst;
    LONG cRows;
    LONG cProperties;
    LONG cRowsTotal;

} ROWSTATUS, *LPROWSTATUS;


typedef struct tagCOLUMNSTATUS
{
    LONG cPropCount;
    LONG cPropsLoaded;

} COLUMNSTATUS, *LPCOLUMNSTATUS;


// Used by IITResultSet::SetColumnHeap.
typedef SCODE (__stdcall *PFNCOLHEAPFREE)(LPVOID);


DECLARE_INTERFACE_(IITResultSet, IUnknown)
{
    // Initialization
    STDMETHOD(SetColumnPriority)(LONG lColumnIndex, PRIORITY ColumnPriority) PURE;
	STDMETHOD(SetColumnHeap)(LONG lColumnIndex, LPVOID lpvHeap,
										PFNCOLHEAPFREE pfnColHeapFree) PURE;
    STDMETHOD(SetKeyProp)(PROPID PropID) PURE;
    STDMETHOD(Add)(LPVOID lpvHdr) PURE;
    STDMETHOD(Add)(PROPID PropID, LPVOID lpvDefaultData, DWORD cbData, PRIORITY Priority) PURE;
    STDMETHOD(Add)(PROPID PropID, LPCWSTR lpszwDefault, PRIORITY Priority) PURE;
    STDMETHOD(Add)(PROPID PropID, DWORD dwDefaultData, PRIORITY Priority) PURE;

    // Build result set
	STDMETHOD(Append)(LPVOID lpvHdr, LPVOID lpvData) PURE;
	STDMETHOD(Set)(LONG lRowIndex, LPVOID lpvHdr, LPVOID lpvData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, DWORD dwData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPCWSTR lpwStr) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPVOID lpvData, DWORD cbData) PURE;
	STDMETHOD(Copy)(IITResultSet* pRSCopy) PURE;
	STDMETHOD(AppendRows)(IITResultSet* pResSrc, LONG lRowSrcFirst, LONG cSrcRows, 
									LONG& lRowFirstDest) PURE;


    // Obtain info about result set
    STDMETHOD(Get)(LONG lRowIndex, LONG lColumnIndex, CProperty& Prop) PURE;
    STDMETHOD(GetKeyProp)(PROPID& KeyPropID) PURE;
    STDMETHOD(GetColumnPriority)(LONG lColumnIndex, PRIORITY& ColumnPriority) PURE;
    STDMETHOD(GetRowCount)(LONG& lNumberOfRows) PURE;
	STDMETHOD(GetColumnCount)(LONG& lNumberOfColumns) PURE;
	STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID) PURE;
    STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID, DWORD& dwType, LPVOID& lpvDefaultValue,
		                 DWORD& cbSize, PRIORITY& ColumnPriority) PURE;

	STDMETHOD(GetColumnFromPropID)(PROPID PropID, LONG& lColumnIndex) PURE;

    // Clear result set
    STDMETHOD(Clear)() PURE;
    STDMETHOD(ClearRows)() PURE;
    STDMETHOD(Free)() PURE;

    // Asynchronous support
    STDMETHOD(IsCompleted)() PURE;      // returns S_OK or S_FALSE
    STDMETHOD(Cancel)() PURE;
    STDMETHOD(Pause)(BOOL fPause) PURE;

    STDMETHOD(GetRowStatus)(LONG lRowFirst, LONG cRows, LPROWSTATUS lpRowStatus) PURE;
    STDMETHOD(GetColumnStatus)(LPCOLUMNSTATUS lpColStatus) PURE;
};

typedef IITResultSet* LPITRS;


#endif		// __ITRS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itsort.h ===
// ITSORT.H:	IITSortKey, IITSortKeyConfig, and related definitions.

#ifndef __ITSORT_H__
#define __ITSORT_H__

#include <comdef.h>


// Some standard definitions for sort key types.  In general, key types (and
// their #defines) are specific to a particular implementation of a sort object.
// However, in the interest of making it easier to call a variety of sort object
// implementations, we define some standard key type definitions that can be
// used across different implementations.
// New sort objects should feel free to add arbitrary key formats, which could
// include a variety of custom binary formats tailored to specific applications
// (e.g. a binary key that provides indirection to a dictionary of strings).
// Note that the format of the key type must always allow its length to be
// determined without any other data than the key itself, as follows:
//		1) length is constant for the key type (e.g. DWORD is always 4 bytes)
//		2) key includes length information (e.g. a WORD prefix indicating
//			how many memory units (bytes, words, etc.) the key contains
//		3) key must contain an explicit terminator (e.g. null terminated strings).
#define IITSK_KEYTYPE_WORD			((DWORD) 18)	// Binary word
#define IITSK_KEYTYPE_DWORD			((DWORD) 19)	// Binary dword
#define IITSK_KEYTYPE_ANSI_SZ		((DWORD) 30)	// NULL-term. MBCS string
#define IITSK_KEYTYPE_UNICODE_SZ	((DWORD) 31)	// NULL-term. Unicode string


// Valid parameters that can be returned by IITSortKey::Compare in *pgrfReason.
#define IITSK_COMPREASON_UNKNOWN		((DWORD) 0x80000000)

// Valid parameters that can be passed to IITSortKey::IsRelated.
#define IITSK_KEYRELATION_PREFIX		((DWORD) 0)
#define IITSK_KEYRELATION_INFIX			((DWORD) 1)
#define IITSK_KEYRELATION_SUFFIX		((DWORD) 2)


DECLARE_INTERFACE_(IITSortKey, IUnknown)
{
	// Returns in *pcbSize the size of the key in bytes (including any
	// length information).
	STDMETHOD(GetSize)(LPCVOID lpcvKey, DWORD *pcbSize) PURE;

	// On exit, *plResult is set according to strcmp conventions:
	//	< 0, = 0, > 0, depending on whether lpcvKey1 is less than, equal to, or
	// greater than lpcvKey2.  If pgrfReason is not NULL, *pgrfReason may be
	// filled in on exit with one or more bit flags giving more information about
	// the result of the comparison if the result was affected by something other
	// than raw lexical comparison (e.g. special character mappings).  If
	// *pgrfReason contains 0 on exit, that means the comparison result
	// was purely lexical; if *pgrfReason contains IITSK_COMPREASON_UNKNOWN,
	// then the sort object implementation wasn't able to provide additional
	// information about the comparison result.
	STDMETHOD(Compare)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						LONG *plResult, DWORD *pgrfReason) PURE;

	// Returns S_OK if lpcvKey1 is related to lpcvKey2 according to
	// dwKeyRelation; else S_FALSE.  If the value specified for dwKeyRelation
	// is not supported, E_INVALIDARG will be returned.  If pgrfReason is not
	// NULL, *pgrfReason will be filled in just as it would be by
	// IITSortKey::Compare.
	STDMETHOD(IsRelated)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						 DWORD dwKeyRelation, DWORD *pgrfReason) PURE;

	// Converts a key of one type into a key of another type.  This is intended
	// mainly for converting an uncompressed key into a compressed key,
	// but a sort object is free to provide whatever conversion combinations
	// it wants to.  *pcbSizeOut should contain the size of the buffer pointed
	// to by lpvKeyOut.  The caller can obtain a guaranteed adequate buffer size
	// through *pcbSizeOut by passing 0 on entry.
	//
	// The following errors are returned:
	//		E_INVALIDARG:	the specified conversion is not supported, i.e.
	//						one or both of the REFGUID params is invalid.
	//		E_FAIL:			the buffer pointed to by lpvKeyOut was too small
	//						to hold the converted key.
	STDMETHOD(Convert)(DWORD dwKeyTypeIn, LPCVOID lpcvKeyIn,
						DWORD dwKeyTypeOut, LPVOID lpvKeyOut,
						DWORD *pcbSizeOut) PURE;

	STDMETHOD(ResolveDuplicates)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						LPCVOID lpvKeyOut, DWORD *pcbSizeOut) PURE;
};

typedef IITSortKey *PIITSKY;

// Sort flags that can be passed to IITSortKeyConfig::SetControlInfo.
#define IITSKC_SORT_STRINGSORT           0x00001000  /* use string sort method */
#define IITSKC_NORM_IGNORECASE           0x00000001  /* ignore case */
#define IITSKC_NORM_IGNORENONSPACE       0x00000002  /* ignore nonspacing chars */
#define IITSKC_NORM_IGNORESYMBOLS        0x00000004  /* ignore symbols */
#define IITSKC_NORM_IGNOREKANATYPE       0x00010000  /* ignore kanatype */
#define IITSKC_NORM_IGNOREWIDTH          0x00020000  /* ignore width */


// External data types that can be passed to
// IITSortKeyConfig::LoadExternalSortData.
#define IITWBC_EXTDATA_SORTTABLE	((DWORD) 2)		


DECLARE_INTERFACE_(IITSortKeyConfig, IUnknown)
{
	// Sets/gets locale info that will affect the comparison results
	// returned from all subsequent calls to IITSortKey::Compare.
	// Returns S_OK if locale described by params is supported
	// by the sort object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets the sort key type that the sort object will expect
	// to see in the following method calls that take keys as params:
	//		IITSortKey::GetSize, Compare, IsRelated
	// Returns S_OK if the sort key type is understood by the
	// sort object; E_INVALIDARG otherwise.
	STDMETHOD(SetKeyType)(DWORD dwKeyType) PURE;
	STDMETHOD(GetKeyType)(DWORD *pdwKeyType) PURE;

	// Sets/gets data that controls how sort key comparisons are made.
	// This method currently accepts only the following set of flags
	// in grfSortFlags:
	//
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfSortFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfSortFlags, DWORD *pdwReserved) PURE;

	// Will load external sort data, such as tables containing the relative
	// sort order of specific characters for a textual key type, from the
	// specified stream.  The format of the data is entirely implementation
	// specific, with the value passed in dwExtDataType providing a hint.
	STDMETHOD(LoadExternalSortData)(IStream *pStream, DWORD dwExtDataType) PURE;
};

typedef IITSortKeyConfig *PIITSKYC;


#endif		// __ITSORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itsortid.h ===
// ITSORTID.H:	IIDs and other GUIDs related to sorting.

#ifndef __ITSORTID_H__
#define __ITSORTID_H__

#include <comdef.h>

#if 0
// {8fa0d5a0-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITSortKey, 
0x8fa0d5a0, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);
#else
// {3FD68660-36CA-11d1-B767-00A0C913F764} // New to support ResolveDuplicates
DEFINE_GUID(IID_IITSortKey, 
0x3fd68660, 0x36ca, 0x11d1, 0xb7, 0x67, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);
#endif

// {8fa0d5a1-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITSortKeyConfig, 
0x8fa0d5a1, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662dab0-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_ITSysSort, 
0x4662dab0, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


#endif // __ITSORTID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itstem.h ===
// ITSTEM.H:	(from Tripoli) IStemmer, IStemSink
//				(from InfoTech) IStemmerConfig
//				(from Tripoli and InfoTech) Supporting definitions.

#ifndef __ITSTEM_H__
#define __ITSTEM_H__

#include <comdef.h>


#ifndef __IStemSink_FWD_DEFINED__
#define __IStemSink_FWD_DEFINED__
typedef interface IStemSink IStemSink;
#endif 	/* __IStemSink_FWD_DEFINED__ */


#ifndef __IStemmer_FWD_DEFINED__
#define __IStemmer_FWD_DEFINED__
typedef interface IStemmer IStemmer;
#endif 	/* __IStemmer_FWD_DEFINED__ */


#ifndef __IStemmerConfig_FWD_DEFINED__
#define __IStemmerConfig_FWD_DEFINED__
typedef interface IStemmerConfig IStemmerConfig;
#endif 	/* __IStemmerConfig_FWD_DEFINED__ */


DECLARE_INTERFACE_(IStemmer, IUnknown)
{
    STDMETHOD(Init)(ULONG ulMaxTokenSize, BOOL *pfLicense) PURE;
    STDMETHOD(GetLicenseToUse)(WCHAR const **ppwcsLicense) PURE;
    STDMETHOD(StemWord)(WCHAR const *pwcInBuf, ULONG cwc,
									IStemSink *pStemSink) PURE;   
};

typedef IStemmer *PISTEM;


DECLARE_INTERFACE_(IStemSink, IUnknown)
{
    STDMETHOD(PutAltWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
    STDMETHOD(PutWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
};

typedef IStemSink *PISTEMSNK;


DECLARE_INTERFACE_(IStemmerConfig, IUnknown)
{
	// Sets/gets locale info that will affect the stemming
	// behavior of IStemmer::StemWord.
	// Returns S_OK if locale described by params is supported
	// by the breaker object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets info that controls certain aspects of stemming.
	// This method currently accepts only the following set of flags
	// in grfStemFlags:
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfStemFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfStemFlags, DWORD *pdwReserved) PURE;

	// Will load external stemmer data, such as word part lists, etc.
	// The format of the data in the stream is entirely
	// implementation-specific.
	STDMETHOD(LoadExternalStemmerData)(IStream *pStream,
										DWORD dwExtDataType) PURE;
};

typedef IStemmerConfig *PISTEMC;



#endif	// __ITSTEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\julian.h ===
#define JULIAN_VER_STR        "7245"
#define JULIAN_VER_INT        7245
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itssini.h ===
// Copyright  1995-1997  Microsoft Corporation.  All Rights Reserved.

// itssini.h : INI file support for InfoTech Structured Storage files
//
// client side support ("read" functions only)

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __ITSSINI_H__
#define __ITSSINI_H__

LPCSTR CreateStorageFileBuffer( LPCTSTR lpFileName, IStorage* pStorage );
__inline void DestroyStorageFileBuffer( LPCSTR lpBuffer ) {
	if (lpBuffer)
		lcFree(lpBuffer);
}

DWORD GetStorageProfileString( LPCTSTR lpSectionName, LPCTSTR lpKeyName,
                               LPCTSTR lpDefault, LPSTR lpReturnedString,
                               INT nSize, LPCSTR lpFileName,
                               IStorage* pStorage );
UINT GetStorageProfileInt( LPCTSTR lpSectionName, LPCTSTR lpKeyName,
                           INT nDefault, LPCTSTR lpFileName,
                           IStorage* pStorage );
DWORD GetBufferProfileString( LPCTSTR lpSectionName, LPCTSTR lpKeyName,
                              LPCTSTR lpDefault, LPSTR lpReturnedString,
                              INT nSize, LPCSTR lpBuffer );
UINT GetBufferProfileInt( LPCTSTR lpSectionName, LPCTSTR lpKeyName,
						  INT nDefault, LPCSTR lpBuffer );

#endif // __ITSSINI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itwbrkid.h ===
// ITWBRKID.H:	IIDs and other GUIDs related to word breaking and stemming.

#ifndef __ITWBRKID_H__
#define __ITWBRKID_H__

#include <comdef.h>

//----------------------------------------------------------------------
//------			Word Breaking Definitions				------------
//----------------------------------------------------------------------

// {D53552C8-77E3-101A-B552-08002B33B0E6}
DEFINE_GUID(IID_IWordBreaker, 
0xD53552C8, 0x77E3, 0x101A, 0xB5, 0x52, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {CC907054-C058-101A-B554-08002B33B0E6}
DEFINE_GUID(IID_IWordSink, 
0xCC907054, 0xC058, 0x101A, 0xB5, 0x54, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {CC906FF0-C058-101A-B554-08002B33B0E6}
DEFINE_GUID(IID_IPhraseSink, 
0xCC906FF0, 0xC058, 0x101A, 0xB5, 0x54, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {8fa0d5a6-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IWordBreakerConfig, 
0x8fa0d5a6, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daaf-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_ITStdBreaker, 
0x4662daaf, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


//----------------------------------------------------------------------
//------			Stop Word List Definitions				------------
//----------------------------------------------------------------------

// {8fa0d5ad-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITStopWordList, 
0x8fa0d5ad, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


//----------------------------------------------------------------------
//------				Stemming Definitions				------------
//----------------------------------------------------------------------

// {efbaf140-7f42-11ce-be57-00aa0051fe20}
DEFINE_GUID(IID_IStemmer, 
0xefbaf140, 0x7f42, 0x11ce, 0xbe, 0x57, 0x00, 0xaa, 0x00, 0x51, 0xfe, 0x20);

// {fe77c330-7f42-11ce-be57-00aa0051fe20}
DEFINE_GUID(IID_IStemSink, 
0xfe77c330, 0x7f42, 0x11ce, 0xbe, 0x57, 0x00, 0xaa, 0x00, 0x51, 0xfe, 0x20);

// {8fa0d5a7-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IStemmerConfig, 
0x8fa0d5a7, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5a8-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_ITEngStemmer, 
0x8fa0d5a8, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


#endif // __ITWBRKID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itwbrk.h ===
// ITWBRK.H:	(from Tripoli) IWordBreaker, IWordSink, IPhraseSink, IStem
//				(from InfoTech) IWordBreakerConfig
//				(from Tripoli and InfoTech) Supporting definitions.

#ifndef __ITWBRK_H__
#define __ITWBRK_H__

#include <comdef.h>
#include <itstem.h>


#ifndef __IPhraseSink_FWD_DEFINED__
#define __IPhraseSink_FWD_DEFINED__
typedef interface IPhraseSink IPhraseSink;
#endif 	/* __IPhraseSink_FWD_DEFINED__ */


#ifndef __IWordSink_FWD_DEFINED__
#define __IWordSink_FWD_DEFINED__
typedef interface IWordSink IWordSink;
#endif 	/* __IWordSink_FWD_DEFINED__ */


#ifndef __IWordBreaker_FWD_DEFINED__
#define __IWordBreaker_FWD_DEFINED__
typedef interface IWordBreaker IWordBreaker;
#endif 	/* __IWordBreaker_FWD_DEFINED__ */


#ifndef __IWordBreakerConfig_FWD_DEFINED__
#define __IWordBreakerConfig_FWD_DEFINED__
typedef interface IWordBreakerConfig IWordBreakerConfig;
#endif 	/* __IWordBreakerConfig_FWD_DEFINED__ */


#ifndef __IITStopWordList_FWD_DEFINED__
#define __IITStopWordList_FWD_DEFINED__
typedef interface IITStopWordList IITStopWordList;
#endif 	/* __IITStopWordList_FWD_DEFINED__ */


// Supporting definitions for IWordBreaker.
typedef struct tagTEXT_SOURCE TEXT_SOURCE;
typedef SCODE (__stdcall *PFNFILLTEXTBUFFER)(TEXT_SOURCE *pTextSource);

typedef struct tagTEXT_SOURCE
{
    PFNFILLTEXTBUFFER pfnFillTextBuffer;
    WCHAR *awcBuffer;
    ULONG iEnd;
    ULONG iCur;
} TEXT_SOURCE;


DECLARE_INTERFACE_(IWordBreaker, IUnknown)
{
	STDMETHOD(Init)(BOOL fQuery, ULONG ulMaxTokenSize, BOOL *pfLicense) PURE;
	STDMETHOD(BreakText)(TEXT_SOURCE *pTextSource, IWordSink *pWordSink,
											IPhraseSink *pPhraseSink) PURE;
	STDMETHOD(ComposePhrase)(WCHAR const *pwcNoun, ULONG cwcNoun,
						WCHAR const *pwcModifier, ULONG cwcModifier,
						ULONG ulAttachmentType, WCHAR *pwcPhrase,
												ULONG *pcwcPhrase) PURE;
    STDMETHOD(GetLicenseToUse)(WCHAR const **ppwcsLicense) PURE;
};

typedef IWordBreaker *PIWBRK;


// Break word types that can be passed to
// IWordBreakerConfig::SetBreakWordType.
#define IITWBC_BREAKTYPE_TEXT		((DWORD) 0)
#define IITWBC_BREAKTYPE_NUMBER		((DWORD) 1)
#define IITWBC_BREAKTYPE_DATE		((DWORD) 2)
#define IITWBC_BREAKTYPE_TIME		((DWORD) 3)
#define IITWBC_BREAKTYPE_EPOCH		((DWORD) 4)


// Breaker control flags that can be passed to
// IWordBreakerConfig::SetControlInfo.
#define IITWBC_BREAK_ACCEPT_WILDCARDS	0x00000001  // Interpret wildcard chars
													// as such.
#define IITWBC_BREAK_AND_STEM           0x00000002  // Stem words after breaking
													// them.

// External data types that can be passed to
// IWordBreakerConfig::LoadExternalBreakerData.
#define IITWBC_EXTDATA_CHARTABLE		((DWORD) 0)		
#define IITWBC_EXTDATA_STOPWORDLIST		((DWORD) 1)


DECLARE_INTERFACE_(IWordBreakerConfig, IUnknown)
{
	// Sets/gets locale info that will affect the word breaking
	// behavior of IWordBreaker::BreakText.
	// Returns S_OK if locale described by params is supported
	// by the breaker object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets the type of words the breaker should expect
	// to see in all subsequent calls to IWordBreaker::BreakText.
	// Returns S_OK if the type is understood by the breaker
	//  object; E_INVALIDARG otherwise.
	STDMETHOD(SetBreakWordType)(DWORD dwBreakWordType) PURE;
	STDMETHOD(GetBreakWordType)(DWORD *pdwBreakWordType) PURE;

	// Sets/gets info that controls certain aspects of word breaking.
	// This method currently accepts only the following set of flags
	// in grfBreakFlags:
	//		IITWBC_BREAK_ACCEPT_WILDCARDS
	//		IITWBC_BREAK_AND_STEM
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfBreakFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfBreakFlags, DWORD *pdwReserved) PURE;

	// Will load external breaker data, such as a table containing
	// char-by-char break information or a list of stop words.
	// Although the format of the data in the stream is entirely
	// implementation-specific, this interface does define a couple
	// of general types for that data which can be passed in
	// dwStreamDataType:
	//		IITWBC_EXTDATA_CHARTABLE
	//		IITWBC_EXTDATA_STOPWORDLIST
	STDMETHOD(LoadExternalBreakerData)(IStream *pStream,
										DWORD dwExtDataType) PURE;

	// These methods allow a stemmer to be associated with the breaker.  The
	// breaker will take responsibility for calling
	// IPersistStreamInit::Load/Save when it is loaded/saved if the stemmer
	// supports that interface.
	STDMETHOD(SetWordStemmer)(REFCLSID rclsid, IStemmer *pStemmer) PURE;
	STDMETHOD(GetWordStemmer)(IStemmer **ppStemmer) PURE;
};

typedef IWordBreakerConfig *PIWBRKC;


// Supporting definitions for IWordSink.
typedef enum tagWORDREP_BREAK_TYPE
{
    WORDREP_BREAK_EOW = 0,
    WORDREP_BREAK_EOS = 1,
    WORDREP_BREAK_EOP = 2,
    WORDREP_BREAK_EOC = 3
} WORDREP_BREAK_TYPE;


DECLARE_INTERFACE_(IWordSink, IUnknown)
{
	STDMETHOD(PutWord)(WCHAR const *pwcInBuf, ULONG cwc,
						ULONG cwcSrcLen, ULONG cwcSrcPos) PURE;
	STDMETHOD(PutAltWord)(WCHAR const *pwcInBuf, ULONG cwc, 
						ULONG cwcSrcLen, ULONG cwcSrcPos) PURE;
	STDMETHOD(StartAltPhrase)(void) PURE;
	STDMETHOD(EndAltPhrase)(void) PURE;
	STDMETHOD(PutBreak)(WORDREP_BREAK_TYPE breakType) PURE;
};

typedef IWordSink *PIWRDSNK;


DECLARE_INTERFACE_(IPhraseSink, IUnknown)
{
	STDMETHOD(PutSmallPhrase)(WCHAR const *pwcNoun, ULONG cwcNoun,
								WCHAR const *pwcModifier, 
								ULONG cwcModifier,
								ULONG ulAttachmentType) PURE;
	STDMETHOD(PutPhrase)(WCHAR const *pwcPhrase, ULONG cwcPhrase) PURE;
};

typedef IPhraseSink *PIPHRSNK;


// Function or macro that can be used by a breaker implementation
// to pull characters from the caller's text source.
#ifdef __cplusplus

inline WCHAR WBreakGetWChar(TEXT_SOURCE *pTextSource )
{
    if ( pTextSource->iCur == pTextSource->iEnd )
    {
        if ( FAILED(pTextSource->pfnFillTextBuffer( pTextSource ) ) )
            return 0xFFFF;  // UniCode EOF
    }

    return pTextSource->awcBuffer[pTextSource->iCur++];
};

#else

#define WBreakGetWChar( pTextSource )\
    (pTextSource->iCur==pTextSource->iEnd)\
    ? (FAILED(pTextSource->pfnFillTextBuffer( pTextSource )) \
       ? 0xFFFF\
       : pTextSource->awcBuffer[pTextSource->iCur++])\
    : pTextSource->awcBuffer[pTextSource->iCur++]

#endif


DECLARE_INTERFACE_(IITStopWordList, IUnknown)
{
	STDMETHOD(AddWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
	STDMETHOD(LookupWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
};

typedef	IITStopWordList	*PIITSTWDL;


#endif		// __ITWBRK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itssini.cpp ===
// Copyright  1995-1997  Microsoft Corporation.  All Rights Reserved.

// itssini.cpp : INI file support for InfoTech Structured Storage files

// need for those pesky pre-compiled headers
#include "header.h"

#include "itssini.h"

// InfoTech Include Files
#include "fsclient.h"

// macros
#define upper(x) ( ((x) >= 'a' && (x) <= 'z') ? (x)-'a'+'A' : (x) )

/*****************************************************************************
 * CreateStorageFileBuffer()
 *
 * Function reads in the specified initialization file inside of an
 * InfoTech Structured Storage file and buffers it
 *
 * ENTRY:
 *   lpFileName       - Pointer to the file that contains the initialization
 *                      file.
 *   pStorage         - Pointer to InfoTech Structured Storage file.
 *
 * EXIT:
 *   LPCTSTR - The returned buffer.
 *
 ****************************************************************************/

LPCSTR CreateStorageFileBuffer( LPCTSTR lpFileName, IStorage* pStorage )
{
  LPCSTR lpBuffer = NULL;

  if( lpFileName && pStorage ) {
    IStream* pStream = NULL;
	CWStr cszw(lpFileName);
	HRESULT hr;
	if( (hr = pStorage->OpenStream(cszw, 0, STGM_READ, 0, &pStream )) == S_OK ) {
      STATSTG StatStg;
	  if ((hr = pStream->Stat(&StatStg, STATFLAG_NONAME)) == S_OK) {
		lpBuffer = (LPCSTR) lcMalloc(StatStg.cbSize.LowPart);
		ULONG cbRead;
		hr = pStream->Read((void*) lpBuffer, StatStg.cbSize.LowPart, &cbRead );
		if (FAILED(hr) || cbRead != StatStg.cbSize.LowPart) {
			lcFree(lpBuffer);
			return NULL;
		}
      }
    }
  }

  return lpBuffer;
}

/*****************************************************************************
 * GetStorageProfileString()
 *
 * Function reads a string from an initialization file inside of an
 * InfoTech Structured Storage file
 *
 * ENTRY:
 *   lpSectionName    - Identifies the section to search.
 *   lpKeyName        - Identifies the "Key" tp search for.
 *   lpDefault        - Default return string if the read fails.
 *   lpReturnedString - Destination buffer.
 *   nSize            - Specifies the size, in characters, of the buffer
 *                      pointed to by the lpReturnedString parameter.
 *   lpFileName       - Pointer to the file that contains the initialization
 *                      file.
 *   pStorage         - Pointer to InfoTech Structured Storage file.
 *
 * EXIT:
 *   DWORD - The return value is the number of characters copied to the
 *           buffer, not including the terminating null character.
 *
 ****************************************************************************/

DWORD GetStorageProfileString( LPCTSTR lpSectionName, LPCTSTR lpKeyName, LPCTSTR lpDefault,
                               LPSTR lpReturnedString, INT nSize, LPCSTR lpFileName,
                               IStorage* pStorage )
{
  // buffer the initialization file
  LPCSTR lpBuffer = CreateStorageFileBuffer( lpFileName, pStorage );
  if (!lpBuffer)
	return 0;

  // get the value of the specified key
  DWORD dwReturn = GetBufferProfileString( lpSectionName, lpKeyName, lpDefault,
               lpReturnedString, nSize, lpBuffer );

  // free the initialization file buffer
  DestroyStorageFileBuffer(lpBuffer);

  return dwReturn;
}

/*****************************************************************************
 * GetStorageProfileInt()
 *
 * Function reads an unsigned integer from an initialization file inside of an
 * InfoTech Structured Storage file
 *
 * ENTRY:
 *   lpSectionName - Identifies the section to search.
 *   lpKeyName     - Identifies the "Key" tp search for.
 *   lpDefault     - Default return value if read fails.
 *   lpFileName    - Pointer to the file that contains the initialization
 *                   file.
 *   pStorage      - Pointer to InfoTech Structured Storage file.
 *
 * EXIT:
 *   UINT - The return value is the integer equivalent of the string
 *          following the specified key name in the specified initialization
 *          file. If the key is not found, the return value is the specified
 *          default value. If the value of the key is less than zero, the
 *          return value is zero.
 *
 ****************************************************************************/

UINT GetStorageProfileInt( LPCTSTR lpSectionName, LPCTSTR lpKeyName,
                           INT nDefault, LPCTSTR lpFileName,
                           IStorage* pStorage )
{
  // buffer the initialization file
  LPCSTR lpBuffer = CreateStorageFileBuffer( lpFileName, pStorage );
  if (!lpBuffer)
	return 0;

  // get the value of the specified key
  DWORD dwReturn = GetBufferProfileInt( lpSectionName, lpKeyName, nDefault, lpBuffer );

  // free the initialization file buffer
  DestroyStorageFileBuffer( (LPCSTR) lpBuffer );

  return dwReturn;
}

/*****************************************************************************
 * GetBufferProfileString()
 *
 * Function reads a string from an initialization file buffer
 *
 * ENTRY:
 *   lpSectionName    - Identifies the section to search.
 *   lpKeyName        - Identifies the "Key" tp search for.
 *   lpDefault        - Default return string if the read fails.
 *   lpReturnedString - Destination buffer.
 *   nSize            - Specifies the size, in characters, of the buffer
 *                      pointed to by the lpReturnedString parameter.
 *   lpBuffer         - Pointer to the buffer that contains the initialization
 *                      file.
 *
 * EXIT:
 *   DWORD - The return value is the number of characters copied to the
 *           buffer, not including the terminating null character.
 *
 ****************************************************************************/

DWORD GetBufferProfileString( LPCTSTR lpSectionName, LPCTSTR lpKeyName,
                              LPCTSTR lpDefault, LPSTR lpReturnedString,
                              INT nSize, LPCSTR lpBuffer )
{
    INT count, i;
    LPCSTR lpS;
    LPCSTR lpT;

    if (!lpBuffer)
        goto getdef;

    for (lpS = lpBuffer; *lpS; lpS++)
    {
        while (*lpS && *lpS <= ' ')
            lpS++;

        if (*lpS == '[')
        {
            lpS++;
            while (*lpS == ' ' || *lpS == '\t')
                lpS++;

            for (lpT = lpSectionName; *lpT && upper(*lpT) == upper(*lpS); lpT++, lpS++)
                ;

            while (*lpS == ' ' || *lpS == '\t')
                lpS++;

            if (!*lpT && *lpS == ']')
                goto foundsec;
        }

        while (*lpS && *lpS != '\r' && *lpS != '\n')
            lpS++;

        // break out once we reach the end
        if( !*lpS )
          break;
    }
    goto getdef;

foundsec:
    while (*lpS && *lpS != '\r' && *lpS != '\n')
        lpS++;

    count = 0;
    while (*lpS)
    {
        while (*lpS && *lpS <= ' ')
            lpS++;
        if (*lpS == '[')
            break;

        if (*lpS != ';')
        {
            if (lpKeyName)
            {
                for (lpT = lpKeyName; *lpT && upper(*lpT) == upper(*lpS); lpT++, lpS++)
                    ;
                while (*lpS == ' ' || *lpS == '\t')
                    lpS++;

                if (!*lpT && *lpS == '=')
                {
                    lpS++;
                    while (*lpS == ' ' || *lpS == '\t')
                        lpS++;
                    while (count < nSize-1 && *lpS && *lpS != ';' && *lpS != '\r' && *lpS != '\n')
                    {
                        *lpReturnedString++ = *lpS++;
                        count++;
                    }
                    *lpReturnedString = 0;
                    return(count);
                }
            }
            else
            {
                while (*lpS && *lpS != '=' && *lpS != '\r' && *lpS != '\n')
                {
                    if (count >= nSize-3)
                    {
                        *lpReturnedString++ = 0;
                        *lpReturnedString++ = 0;
                        return(count);
                    }
                    *lpReturnedString++ = *lpS++;
                    count++;
                }
                *lpReturnedString++ = 0;
                count++;
            }
        }
        while (*lpS && *lpS != '\r' && *lpS != '\n')
            lpS++;
    }

    if (!lpKeyName)
    {
        *lpReturnedString++ = 0;
        return(count);
    }

getdef:
    count = lstrlen(lpDefault);
    if (nSize < count)
        count = nSize-1;

    for (i = 0; i < count; i++)
        lpReturnedString[i] = lpDefault[i];
    lpReturnedString[i] = 0;
    return(count);
}

/*****************************************************************************
 * GetBufferProfileInt()
 *
 * Function reads an unsigned integer from an initialization file buffer
 *
 * ENTRY:
 *   lpSectionName - Identifies the section to search.
 *   lpKeyName     - Identifies the "Key" tp search for.
 *   lpDefault     - Default return value if read fails.
 *   lpBuffer      - Pointer to the buffer that contains the initialization
 *                   file.
 *
 * EXIT:
 *   UINT - The return value is the integer equivalent of the string
 *          following the specified key name in the specified initialization
 *          file. If the key is not found, the return value is the specified
 *          default value. If the value of the key is less than zero, the
 *          return value is zero.
 *
 ****************************************************************************/

UINT GetBufferProfileInt( LPCTSTR lpSectionName, LPCTSTR lpKeyName,
                          INT nDefault, LPCTSTR lpBuffer )
{
    char sz[20];
    INT k = 0;
    LPSTR lpT;
    INT sign = 1;

    if (!GetBufferProfileString(lpSectionName,lpKeyName,"",sz,sizeof(sz),lpBuffer))
        return(nDefault);

    lpT = sz;

    while (*lpT && *lpT <= ' ')
        lpT++;

    if (*lpT == '-')
    {
        sign = -1;
        lpT++;
    }

    for (; *lpT >= '0' && *lpT <= '9'; lpT++)
        k *= 10, k += *lpT - '0';

    return(sign * k);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\itww.h ===
// ITWW.H:	IITWordWheel interface declaration

#ifndef __ITWW_H__
#define __ITWW_H__

// {8fa0d5a4-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITWordWheel, 
0x8fa0d5a4, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {D73725C2-8C12-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITWordWheel, 
0xd73725c2, 0x8c12, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daa8-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITWordWheelLocal, 
0x4662daa8, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// Word-wheel open flags
#define ITWW_OPEN_CONNECT	0x00000000    // connect to server on open (the default)
#define ITWW_OPEN_NOCONNECT	0x00000001    // don't connect to server on open

// Constants for IITWordWheel::Lookup.
#define ITWW_CBKEY_MAX		1024		// Max size of keys allowed in Word Wheels.

// Forward declarations
interface IITDatabase;
interface IITResultSet;
interface IITGroup;
interface IITPropList;
interface IITQuery;

DECLARE_INTERFACE_(IITWordWheel, IUnknown)
{

	STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker, DWORD dwFlags=0) PURE;
	STDMETHOD(Close)(void) PURE;

	// Returns the code page ID and locale ID that the word wheel was built and
	// sorted with.
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Returns in *pdwObjInstance the ID of the external sort instance being used by
	// this word wheel.  The instance ID can be passed to IITDatabase::GetObject to
	// to obtain an interface pointer on the instantiated instance.  If the word
	// wheel doesn't use external sorting, then IITDB_OBJINST_NULL.
	STDMETHOD(GetSorterInstance)(DWORD *pdwObjInstance) PURE;

	STDMETHOD(Count)(LONG *pcEntries) PURE;

	// To be safe, the length of lpvKeyBuf should always be at least ITWW_CBKEY_MAX. 
	STDMETHOD(Lookup)(LONG lEntry, LPVOID lpvKeyBuf, DWORD cbKeyBuf) PURE;
	STDMETHOD(Lookup)(LONG lEntry, IITResultSet* lpITResult, LONG cEntries) PURE;
	STDMETHOD(Lookup)(LPCVOID lpcvPrefix, BOOL fExactMatch, LONG *plEntry) PURE;

	STDMETHOD(SetGroup)(IITGroup* piitGroup) PURE;
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup) PURE;

	STDMETHOD(GetDataCount)(LONG lEntry, DWORD *pdwCount) PURE;
	STDMETHOD(GetData)(LONG lEntry, IITResultSet* lpITResult) PURE;
	STDMETHOD(GetDataColumns)(IITResultSet* pRS) PURE;
};

typedef IITWordWheel* LPITWORDWHEEL;

#endif		// __ITWW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\language.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//
//	language.cpp --- Implementation for language related classes.
//
//
/*
    This file contains classes related to managing the UI language of HHCTRL.

*/
//////////////////////////////////////////////////////////////////////////
//
// Includes
//
// Get the precompiled header file.
#include "header.h"

// Get our header
#include "language.h"

//////////////////////////////////////////////////////////////////////////
//
// Constants
//
const int c_NumBaseLangIds = 10 ; // The min. number of ids which we search.
const int c_NumSysLangIds = 7 ; //  The num of ids we check if we are only checking the system ids.
const char c_Suffix[] = "ui" ;
const char c_Ext[] = ".dll" ;
const char c_txtNlsModuleName[] = "kernel32.dll" ;
const char c_txtUserUILanguage[] = "GetUserDefaultUILanguage" ;
const char c_txtSystemUILanguage[] = "GetSystemDefaultUILanguage" ;
const char c_SatelliteSubDir[]  = "mui" ;

//////////////////////////////////////////////////////////////////////////
//
// CLanguageEnum
//
/*
    This class enumerates the langids to attempt. If you are trying to access
    some object using a langid and that object may not be in that particular langid,
    you should use this class to get an array of langids to try.

    NOTE: You should never use the CLanguageEnum class directly. It is meant to only
        be used via the CLanguage class below. The only exception is the CHtmlHelpModule
        class which uses it for initialization.
*/

//////////////////////////////////////////////////////////////////////////
//
// Construction
//
CLanguageEnum::CLanguageEnum(LANGID langid1, LANGID langid2, bool bSysOnly /*=false*/)
:   m_langids(NULL),
    m_index(0)
    
{
    int i = 0 ;
    LCID lcidUser       = GetUserDefaultLCID();
    LCID lcidSystem     = GetSystemDefaultLCID();
    LANGID os           = NULL ;

    //--- Count number of items.
    if (bSysOnly)
    {
        m_items = c_NumSysLangIds ;

    }
    else // The following are not included if we are only using the system LCID
    {
        m_items = c_NumBaseLangIds ;

        // This is an optionaly extra langid to search first. Mainly used by toc.cpp and collect.cpp to find random chms.
        if (langid1 != NULL)
        {
            m_items += 3 ;
        }

        // This is another optional langid. It is usually set to the langid of the UI.
        if (langid2 != NULL)
        {
            m_items += 3 ;
        }
    }

	// This is an optionaly extra langid to search first. Mainly used by toc.cpp and collect.cpp to find random chms.
	if (langid1 != NULL)
	{
		m_items += 3 ;
	}
	
    // If NT5 use the UI Language
    // The UI Language is included in both the sys count and the non-sys count.
    os = _Module.m_Language.GetUserOsUiLanguage() ;

    if (os) 
    {
        m_items += 3 ;
    }

    //--- Allocate memory for the array
    m_langids = new LANGID[m_items] ;

    if (langid1 != NULL)     // User defined langid
    {
        m_langids[i++] = langid1 ;
        m_langids[i++] = MAKELANGID(PRIMARYLANGID(langid1), SUBLANG_DEFAULT) ;
        m_langids[i++] = MAKELANGID(PRIMARYLANGID(langid1), SUBLANG_NEUTRAL) ;
    }

    //--- Fill in the memory.
    if (!bSysOnly) // The following are not included if we are only using the system LCID
    {
        if (langid2 != NULL)     // User defined langid
        {
            m_langids[i++] = langid2 ;
            m_langids[i++] = MAKELANGID(PRIMARYLANGID(langid2), SUBLANG_DEFAULT) ;
            m_langids[i++] = MAKELANGID(PRIMARYLANGID(langid2), SUBLANG_NEUTRAL) ;
        }

        // If NT5 use the UI Language
        if (os) 
        {
            m_langids[i++] = os;
            m_langids[i++] = MAKELANGID(PRIMARYLANGID(os), SUBLANG_DEFAULT) ;
            m_langids[i++] = MAKELANGID(PRIMARYLANGID(os), SUBLANG_NEUTRAL) ;
        }

        m_langids[i++] = LANGIDFROMLCID(lcidUser);
        m_langids[i++] = MAKELANGID(PRIMARYLANGID(lcidUser), SUBLANG_DEFAULT);
        m_langids[i++] = MAKELANGID(PRIMARYLANGID(lcidUser), SUBLANG_NEUTRAL);
    }
    else
    {
        // If NT5 use the UI Language 
        // This is placed here so that UI Language can be before lcidUser.
        if (os) 
        {
            m_langids[i++] = os;
            m_langids[i++] = MAKELANGID(PRIMARYLANGID(os), SUBLANG_DEFAULT) ;
            m_langids[i++] = MAKELANGID(PRIMARYLANGID(os), SUBLANG_NEUTRAL) ;
        }
    }

    m_langids[i++] = LANGIDFROMLCID(lcidSystem);
    m_langids[i++] = MAKELANGID(PRIMARYLANGID(lcidSystem), SUBLANG_DEFAULT);
    m_langids[i++] = MAKELANGID(PRIMARYLANGID(lcidSystem), SUBLANG_NEUTRAL);

    m_langids[i++] = LANGIDFROMLCID(0x0409); // Try English
    m_langids[i++] = MAKELANGID(PRIMARYLANGID(0x0409), SUBLANG_DEFAULT);
    m_langids[i++] = MAKELANGID(PRIMARYLANGID(0x0409), SUBLANG_NEUTRAL);

    m_langids[i++] = 0x0000; // Try to find anything which was installed.

    ASSERT(i == m_items) ;
}

//////////////////////////////////////////////////////////////////////////
//
// Destructor
//
CLanguageEnum::~CLanguageEnum()
{
    if (m_langids)
    {
        delete [] m_langids ;
    }
}

//////////////////////////////////////////////////////////////////////////
//
// Access
//
//////////////////////////////////////////////////////////////////////////
//
// start
//
LANGID 
CLanguageEnum::start()
{
    m_index = 0 ;
    return m_langids[0] ;
}

//////////////////////////////////////////////////////////////////////////
//
// next
//
LANGID 
CLanguageEnum::next()
{
    LANGID nextLangId = c_LANGID_ENUM_EOF ;
    if (m_index >= 0 )
    {
        while (++m_index < m_items)
        {
            // If not the first item, check if its the same as any LCID already checked, which is
            // very possible
            bool bAlreadyTried= false;
            for (int n = 0 ; n < m_index ; n++)
            {
                if (m_langids[n] == m_langids[m_index])
                {
                    bAlreadyTried = true; 
                    break; // Already done this one.
                }
            }

            // If we haven't already done it. return it.
            if (!bAlreadyTried)
            {
                nextLangId = m_langids[m_index] ;
                break;
            }
        }
    }
    return nextLangId ;

}

//////////////////////////////////////////////////////////////////////////
//
// CLanguage
//
//////////////////////////////////////////////////////////////////////////
//
// Construction
//////////////////////////////////////////////////////////////////////////
//
// Simple construction
//
CLanguage::CLanguage()
:   m_langid(NULL),
    m_hSatellite(NULL),
    m_hNlsModule(NULL),
    m_fpGetUserDefaultUILanguage(NULL),
    m_fpGetSystemDefaultUILanguage(NULL) 
{
}

//////////////////////////////////////////////////////////////////////////
//
// Destructor
//
CLanguage::~CLanguage()
{
}

//////////////////////////////////////////////////////////////////////////
//
// Member Access
//
//////////////////////////////////////////////////////////////////////////
//
// GetUiLanguage
//
LANGID 
CLanguage::GetUiLanguage()
{
    _Init() ; 
    return m_langid ; // If this is NULL, we should set it here.
}

//////////////////////////////////////////////////////////////////////////
//
// SetUiLanguage
//
LANGID 
CLanguage::SetUiLanguage(LANGID langid)
{
    if (m_langid)
    {
        ASSERT(0)
        return m_langid; // There can be only one! - Highlander.
    }
    else
    {
        m_langid = langid; // More validation?
        // Load the satellite dll. Will change the value of m_langid.
        _LoadSatellite() ;
        return m_langid ;
    }
}

//////////////////////////////////////////////////////////////////////////
//
// GetEnumerator
//
CLanguageEnum* 
CLanguage::_GetEnumerator(LANGID langidOther)
{
    return new CLanguageEnum(langidOther, m_langid) ; // What if m_langid is null?
}

//////////////////////////////////////////////////////////////////////////
//
// _GetSysEnumerator --- Enumerates just the system LCID and English LCID. Used by the satellite DLLs.
//
CLanguageEnum*
CLanguage::_GetSysEnumerator(LANGID landidOther)
{
    return new CLanguageEnum(landidOther, NULL, true) ;
}

//////////////////////////////////////////////////////////////////////////
//
// LoadSatellite ---    The purpose of this function is to set m_langid. 
//                      As a side affect, it will load a satellite if required.
//
void
CLanguage::_LoadSatellite()
{
    ASSERT(m_hSatellite == NULL) ;

    // Buffer for building satellite pathname
    char pathname[MAX_PATH] ;

    // Get Modulename
    char modulename[MAX_PATH] ;
    char drive[_MAX_DRIVE];
    char dir[_MAX_DIR];
    char fname[_MAX_FNAME];
    char ext[_MAX_EXT];

    GetModuleFileName(_Module.GetModuleInstance(), modulename, MAX_PATH) ;
    _splitpath(modulename, drive, dir, fname, ext );
 
	// This piece of code queries for the "install language" of the OS.  This LCID value
	// corresponds to the language of the resources used by the OS shell.  For example, on
	// an "enabled Hebrew Win98" system the language of the shell is 0x409 (English).
	//
	// The purpose of this code is to force the language of the satellite DLL to match the 
	// language of the OS shell. See bug #7860 and #7845 for more information.
	//
	LANGID langOther = NULL;
	HKEY hkey;

	if(!g_fSysWinNT && RegOpenKeyEx(HKEY_CURRENT_USER, "Control Panel\\Desktop\\ResourceLocale", 0, KEY_READ, &hkey) == ERROR_SUCCESS)
	{
       char szLanguage[20];
       DWORD cbLanguage = sizeof(szLanguage);
	   *szLanguage = 0;

       if((RegQueryValueEx(hkey, NULL, NULL, NULL, (LPBYTE) szLanguage, &cbLanguage) == ERROR_SUCCESS))
       {
			langOther = LOWORD(strtol(szLanguage, NULL, 16));
	   }
	}

    // Get the langid enumerator for the UI language, system LCID and the English LCID.
    // Currently, we don't support changing the UI language to anything but the system language.
    // To make it easy to change this support in the future, this function still uses GetSysEnumerator
    // To make it try more LCID types change the call below to _GetEnumerator...
    CLanguageEnum* pEnum = _GetSysEnumerator(langOther) ;
    ASSERT(pEnum) ;

    // Get first langid.
    LANGID langid = pEnum->start() ;
    while (langid != 0)
    {
        // Attempt to load satellite DLL in this language.
        if (PRIMARYLANGID(langid) == 0x0009) // English
        {
            // We do not need an English satellite DLL, so we are done.
            m_langid = langid ;
            break ;
        }

        // Convert the langid to a hex string without leading 0x.
        wsprintf(pathname, "%s%s%s\\%04x\\%s%s%s",drive,dir,c_SatelliteSubDir,langid,fname,c_Suffix,c_Ext) ;

        if (IsFile(pathname))
        {
            // Load the satellite.
            m_hSatellite = LoadLibrary(pathname) ;
            ASSERT(m_hSatellite) ;
            m_langid = langid ;
            break ;
        }

        // Get next langid to attempt.
        langid = pEnum->next() ;
    }

    // Cleanup.
    if (pEnum)
    {
        delete pEnum ;
    }

    ASSERT(m_langid != NULL) ;
    // m_hSatellite may be NULL. English has no satellite.
}

//////////////////////////////////////////////////////////////////////////
//
//  GetUserOsUiLanguage - Return the user's ui language.
// 
/*
    If this is a non-NT5 system, return 0x0.
    If the user's UI language is the same as the system's ui language, return 0x0.
    Otherwise, return GetUserDefaultUiLanguage
*/
LANGID 
CLanguage::GetUserOsUiLanguage() 
{
    if (!g_bWinNT5)
    {
        return NULL ;
    }

	if (m_fpGetUserDefaultUILanguage == NULL)
	{
		// Assume that if this is null then the module handle is null.
		ASSERT(m_hNlsModule== NULL) ;
	
        // Get a module handle.
        m_hNlsModule  = LoadLibrary(c_txtNlsModuleName);  

    	if (m_hNlsModule == NULL)
		{
			// Couldn't get the module handle. Fail!
			return NULL ;
		}

		// Get the function's address
		m_fpGetUserDefaultUILanguage = (FntPtr_GetDefaultUILanguage)::GetProcAddress(m_hNlsModule, c_txtUserUILanguage) ;
		if (m_fpGetUserDefaultUILanguage == NULL)
		{
			return NULL ;
		}		        
    }
	
    LANGID user = m_fpGetUserDefaultUILanguage() ;

    return user ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\lcmem.cpp ===
// Copyright (C) 1994-1997 Microsoft Corporation. All rights reserved.

#include "header.h"

// our lame workshop relies on the old exported memory functions
// so we have to keep exporting these but we will now implement these
// using the CRT heap
//

#ifdef HHA

#undef lcSize

int STDCALL lcSize(void* pv)
{
  return _msize(pv);
}

void* STDCALL rcalloc(int cb)
{
  void* pv = lcMalloc( cb );
  memset( pv, 0, cb );
  return pv;
}

void STDCALL rfree(void* pv)
{
  lcFree( pv );
}

void STDCALL rclearfree(void** pv)
{
  lcFree( *pv );
  *pv = NULL;
}

void STDCALL rheapcheck()
{
}

void* STDCALL rmalloc(int cb)
{
  return lcMalloc( cb );
}

void*   STDCALL rrealloc(void* pv, int cb)
{
  return lcReAlloc( pv, cb );
}

#define lcSize(pv) _msize(pv)

#endif


#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

PSTR lcStrDup(PCSTR psz)
{
    if (!psz)
        psz = "";
    PSTR pszDup = (PSTR) lcMalloc(strlen(psz) + 1);
    return strcpy(pszDup, psz);
}

PWSTR lcStrDupW(PCWSTR psz)
{
    if (!psz)
        psz = L"";
    int cb = (lstrlenW(psz)*sizeof(WCHAR)) + sizeof(WCHAR);
    PWSTR pszDup = (PWSTR) lcMalloc(cb);
    if (pszDup)
        CopyMemory(pszDup, psz, cb);
    return pszDup;
}


CMem::CMem(void)
{
  pb = NULL;
#ifndef HHCTRL
  psz = (PSTR) pb;
#endif
}

CMem::CMem(int size)
{
  _ASSERT(size > 0);
  pb = (PBYTE) lcMalloc(size);
#ifndef HHCTRL
  psz = (PSTR) pb;
#endif
  _ASSERT(pb);
};

#ifndef HHCTRL
int CMem::size(void) { return lcSize(pb); }
void CMem::resize(int cb) { ReAlloc(cb); }
#endif

#ifdef HHCTRL
#if _DEBUG
///////////////////////////////////////////////////////////
//
// The new heap status report...
//

// Following variables defined in CTable.cpp, _DEBUG only

extern int g_cbTableAllocated;
extern int g_cbTableReserved;
extern int g_cTables;

void OnReportMemoryUsage(void)
{
    // Get the current memory state.
    _CrtMemState NewMemState ;
    _CrtMemCheckpoint(&NewMemState) ;

    char buf[4096] ;
    wsprintf(buf,
            "\tBlocks\tBytes\r\n\t------\t-----\r\n"
            "Free:  \t%12ld\t%12ld\r\n"
            "Normal:\t%12ld\t%12ld\r\n"
            "CRT:   \t%12ld\t%12ld\r\n"
            "Ignore:\t%12ld\t%12ld\r\n"
            "Client: \t%12ld\t%12ld\r\n\r\n"
            "Largest Used: %ld\r\n"
            "Total Allocations: %ld\r\n\r\nTables (%u): %d bytes\r\n"
            "Reserved: %d megs",
            NewMemState.lCounts[0], NewMemState.lSizes[0],
            NewMemState.lCounts[1], NewMemState.lSizes[1],
            NewMemState.lCounts[2], NewMemState.lSizes[2],
            NewMemState.lCounts[3], NewMemState.lSizes[3],
            NewMemState.lCounts[4], NewMemState.lSizes[4],
            NewMemState.lHighWaterCount,
            NewMemState.lTotalCount,
            g_cTables, g_cbTableAllocated, g_cbTableReserved / (1024*1024)) ;
    MsgBox(buf);

    // Dump it to the debug output.
    _CrtMemDumpStatistics(&NewMemState);
}
///////////////////////////////////////////////////////////
//
// This class is used to initialize the CRT debug code.
//
class DebugAutoInitializer
{
public:

    //--- Place code to initialize the CRT debug code here.
    DebugAutoInitializer() 
    {
        // Turn own automatic leak checking.
        int f = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) ;
        f |= _CRTDBG_LEAK_CHECK_DF ;
        _CrtSetDbgFlag(f) ;

        //--- LineNumber to break on... (found in hhdebug.ini file)
        long BreakNumber = GetPrivateProfileInt( "CRT", "_CrtSetBreakAlloc", 0, "hhdebug.ini" );
        if (BreakNumber)
        {
            _CrtSetBreakAlloc(BreakNumber) ; 
        }

    }
};

DebugAutoInitializer s_DebugAutoInitializer; 

#endif // _DEBUG
#endif // HHCTRL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\listview.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "fts.h"

//#include <commctrl.h>
#include "cctlww.h"

#include "hhtypes.h"
#include "parserhh.h"
#include "collect.h"
#include "toc.h"
#include "system.h"
#include "listview.h"

#include "secwin.h" // for DEFAULT_NAV_WIDTH;

///////////////////////////////////////////////////////////
//
// Constants
//
const int c_TopicColumn = 0;
const int c_LocationColumn = 1;
const int c_RankColumn = 2;

///////////////////////////////////////////////////////////
//
// ListViewCompareProc - Used to sort columns in Advanced Search UI mode.
//
int CALLBACK ListViewCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

///////////////////////////////////////////////////////////
//
//
//
typedef struct tag_RESULTSSORTINFO 
{
  CFTSListView* pThis;       // The ListView object controlling the sort.
  int           iSubItem;    // column we are sorting.
  LCID          lcid;        // locale to sort by
  WCHAR*        pwszUntitled;
  WCHAR*        pwszUnknown;
} RESULTSSORTINFO;

///////////////////////////////////////////////////////////
//
// Constructor
//
CFTSListView::CFTSListView(CExCollection* pTitleCollection, HWND hwndListView, bool bAdvancedSearch)
{
    m_bSizeColumnsInit = false;
	m_pTitleCollection = pTitleCollection;
    m_bAdvancedSearch = bAdvancedSearch;

	if ( hwndListView != NULL )
	{

		m_hwndListView = hwndListView;
		m_fInitialized = TRUE;
        W_EnableUnicode(hwndListView, W_ListView);

		//---Set the column headings
        if (bAdvancedSearch)
        {
            // Add the columns
            LV_COLUMNW column;
            column.mask = LVCF_FMT | LVCF_TEXT;
			if(g_fBiDi)
                column.fmt =  LVCFMT_RIGHT;
			else
                column.fmt =  LVCFMT_LEFT;
            // Title Column
            column.pszText = (PWSTR)GetStringResourceW(IDS_ADVSEARCH_HEADING_TITLE);
            int iCol = c_TopicColumn;
            int iResult = W_ListView_InsertColumn(hwndListView, iCol++, &column);
            ASSERT(iResult != -1);

            // Bidi - this is necessary to get the LVCFMT_RIGHT formatting to stick
			if(g_fBiDi)
            {
                column.mask = LVCF_FMT;
                column.fmt =  LVCFMT_RIGHT;
                SendMessage(hwndListView,LVM_SETCOLUMN, (WPARAM) 0, (LPARAM) &column);
            }

            column.mask = LVCF_FMT | LVCF_TEXT;
                                    
            // Location column
            column.pszText = (PWSTR)GetStringResourceW(IDS_ADVSEARCH_HEADING_LOCATION);
            iResult = W_ListView_InsertColumn(hwndListView, iCol++, &column);
            ASSERT(iResult != -1);
            // Rank Column.
            column.pszText = (PWSTR)GetStringResourceW(IDS_ADVSEARCH_HEADING_RANK);
            iResult = W_ListView_InsertColumn(hwndListView, iCol++, &column);
            ASSERT(iResult != -1);

            // We want most of the space to be taken up by first column.

            // Set the columns up for autosizing.
            W_ListView_SetColumnWidth(hwndListView, c_RankColumn, LVSCW_AUTOSIZE);
            W_ListView_SetColumnWidth(hwndListView, c_LocationColumn, LVSCW_AUTOSIZE);
            W_ListView_SetColumnWidth(hwndListView, c_TopicColumn, LVSCW_AUTOSIZE_USEHEADER);

            // Get the default width of the client. Assumes that the dialog is the default size at startup.
            RECT client;
            GetClientRect(hwndListView, &client); 
            m_cxDefault = client.right - client.left;

        }
        else
        {
		    RECT rcTemp;
		    UINT TopicWidth;
		    if (GetWindowRect(m_hwndListView, &rcTemp))
			    TopicWidth = rcTemp.right - rcTemp.left;
		    else
			    TopicWidth = 122;

		    LV_COLUMNW column;
		    column.mask = LVCF_FMT | LVCF_WIDTH; 
		    column.cx = TopicWidth-5; 
			if(g_fBiDi)
                column.fmt =  LVCFMT_RIGHT;
			else
                column.fmt =  LVCFMT_LEFT;
		    W_ListView_InsertColumn( m_hwndListView, 0, &column );

            // Bidi - this is necessary to get the LVCFMT_RIGHT formatting to stick
			if(g_fBiDi)
			{
                column.mask = LVCF_FMT;
                column.fmt =  LVCFMT_RIGHT;
                SendMessage(m_hwndListView,LVM_SETCOLUMN, (WPARAM) 0, (LPARAM) &column);
			}

        }
	}
	else
		m_fInitialized = FALSE;

	m_pResults = NULL;
	m_ItemNumber = -1;
    m_cResultCount = 0;
}

///////////////////////////////////////////////////////////
//
// SetResults
//
void 
CFTSListView::SetResults(int cResultCount, SEARCH_RESULT * SearchResults )
{
    ASSERT(cResultCount >0);
    ASSERT(SearchResults);

    m_cResultCount = cResultCount;
    m_pResults = SearchResults;

}

///////////////////////////////////////////////////////////
//
// AddItem
//
void 
CFTSListView::AddItems()
{
    ASSERT(m_cResultCount >0);
    ASSERT(m_pResults);

	LV_ITEMW item;			// To add to the list view.
		
	int i;
    WCHAR szRank[6];

	W_ListView_DeleteAllItems(m_hwndListView);
    W_ListView_SetItemCount( m_hwndListView, m_cResultCount );

    int slot=0;    
	int rank = 1;
	for ( i=0; i< m_cResultCount; i++)
	{
		// need to get the topic string from the Topic Number
		// Add the Topic string to the List View. Actually using callbacks.
		//
        item.pszText    = LPSTR_TEXTCALLBACKW;
		item.mask		= LVIF_TEXT|LVIF_PARAM;
		item.iImage		= 0;
		item.state		= 0;
		item.stateMask	= 0;
		item.iItem		= slot;	
		item.iSubItem	= c_TopicColumn;	
		item.lParam		= i;
		W_ListView_InsertItem( m_hwndListView, &item );

        //--- Two more columns in Adv FTS mode.
        if (m_bAdvancedSearch)
        {
            //--- Add Location Column
            W_ListView_SetItemText(m_hwndListView, slot, c_LocationColumn, LPSTR_TEXTCALLBACKW); // Has an internal item struct.

            //--- Add Rank column 
            //wsprintf(szRank,"%d",rank++);
			if(g_langSystem == LANG_ARABIC || g_langSystem == LANG_HEBREW)
			{
			    szRank[0]=0x200E;
                _itow(rank++, szRank+1, 10);
            }				
			else
                _itow(rank++, szRank, 10);
            W_ListView_SetItemText(m_hwndListView, slot, c_RankColumn, szRank); // Has an internal item struct.
        }
        slot++;
	}

	// fix for 7024 which was a regression caused by AFTS, we must manually sort rather then using the sort bit
	if (!m_bAdvancedSearch)
	{
		// Get the string for untitled things.
        CWStr wstrUntitled(IDS_UNTITLED);
        CWStr wstrUnknown(IDS_UNKNOWN);

        // Fill this structure to make the sorting quicker/more efficient.
        RESULTSSORTINFO Info;
        Info.pThis        = this;
        Info.iSubItem     = 0;
        Info.lcid         = LOCALE_SYSTEM_DEFAULT;
        Info.pwszUntitled = wstrUntitled;
        Info.pwszUnknown  = wstrUnknown;
        W_ListView_SortItems(m_hwndListView, 
                             ListViewCompareProc,
                             reinterpret_cast<LPARAM>(&Info));
	}
    W_ListView_SetItemState( m_hwndListView, 0, LVIS_SELECTED, LVIF_STATE | LVIS_SELECTED );
}

void CFTSListView::ResetQuery(void)
{
	if(m_pResults != NULL )
	{
		// Free the results list
		//
		m_pTitleCollection->m_pFullTextSearch->FreeResults( m_pResults );
		m_pResults = NULL;
        m_cResultCount = 0;
		m_ItemNumber = -1;
		W_ListView_DeleteAllItems( m_hwndListView );
	}
}

///////////////////////////////////////////////////////////
//
// ListViewMsg - Message notification handler.
//
LRESULT CFTSListView::ListViewMsg(HWND hwnd, NM_LISTVIEW* lParam)
{
DWORD dwTemp;
CExTitle* pTitle;

	switch(lParam->hdr.code)
	{
		case NM_DBLCLK:
		case NM_RETURN:
			if ( m_ItemNumber == -1 )
				break;
			dwTemp = m_pResults[m_ItemNumber].dwTopicNumber;
			pTitle = m_pResults[m_ItemNumber].pTitle;

			if ( pTitle )
			{
				char szURL[MAX_URL];
				if ( (pTitle->GetTopicURL(dwTemp, szURL, sizeof(szURL)) == S_OK) )
					ChangeHtmlTopic(szURL, hwnd, 1);
			}
			break;

		case LVN_ITEMCHANGING:
			if ( ((NM_LISTVIEW*)lParam)->uNewState & LVIS_SELECTED )
			{
				// use the item number as an index into the search results array.
				// Then use the Topic number to get to the URL to display the Topic.
				if( m_pResults != NULL )
				{
					m_ItemNumber = (int)((NM_LISTVIEW*)lParam)->lParam;

				}
			}
      else 
      {
          // HHBUG 2208 - Need to unmark the item if its not selected.
          m_ItemNumber = -1;
      }
			break;

		case LVN_GETDISPINFOA:
            OnGetDispInfo((LV_DISPINFO*)lParam);
			break;

        case LVN_GETDISPINFOW:
            OnGetDispInfoW((LV_DISPINFOW*)lParam);
			break;

    case LVN_COLUMNCLICK:
        if (m_bAdvancedSearch)
        {
            CHourGlass waitcur;

            NM_LISTVIEW *pNM = reinterpret_cast<NM_LISTVIEW*>(lParam);

            // Get the string for untitled things.
            CWStr wstrUntitled(IDS_UNTITLED);
            CWStr wstrUnknown(IDS_UNKNOWN);

            // Fill this structure to make the sorting quicker/more efficient.
            RESULTSSORTINFO Info;
            Info.pThis        = this;
            Info.iSubItem     = pNM->iSubItem;
            Info.lcid         = LOCALE_SYSTEM_DEFAULT;
            Info.pwszUntitled = wstrUntitled;
            Info.pwszUnknown  = wstrUnknown;

            W_ListView_SortItems(pNM->hdr.hwndFrom, 
                                 ListViewCompareProc,
                                 reinterpret_cast<LPARAM>(&Info));
        }
        // Fall through...

		default:
			;
	}
	return 0;

}


///////////////////////////////////////////////////////////
//
// ListViewCompareProc - Used to sort columns in Advanced Search UI mode.
//
int
CALLBACK
ListViewCompareProc( LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort )
{
    WCHAR wsz1[MAX_TOPIC_NAME];
    WCHAR wsz2[MAX_TOPIC_NAME];
    int iReturn;
    int index1 = (int)lParam1;
    int index2 = (int)lParam2;

    RESULTSSORTINFO* pInfo = reinterpret_cast<RESULTSSORTINFO*>(lParamSort);
    SEARCH_RESULT* pResults = pInfo->pThis->m_pResults;

    switch( pInfo->iSubItem )
    {
    case c_TopicColumn: // Topic String
        pResults[index1].pTitle->GetTopicName( pResults[index1].dwTopicNumber, wsz1, MAX_TOPIC_NAME);
        if (0 == wsz1[0])
            _wcsncpy(wsz1, pInfo->pwszUntitled, MAX_TOPIC_NAME);

        pResults[index2].pTitle->GetTopicName( pResults[index2].dwTopicNumber, wsz2, MAX_TOPIC_NAME);
        if (0 == wsz2[0])
            _wcsncpy(wsz2, pInfo->pwszUntitled, MAX_TOPIC_NAME);
        
        iReturn = W_CompareString(pInfo->lcid, 0, wsz1, -1, wsz2, -1) - 2;
        break;

    case c_LocationColumn: // Location String
        pResults[index1].pTitle->GetTopicLocation( pResults[index1].dwTopicNumber, wsz1, MAX_TOPIC_NAME);
        if (0 == wsz1[0])
            _wcsncpy(wsz1, pInfo->pwszUnknown, MAX_TOPIC_NAME);

        pResults[index2].pTitle->GetTopicLocation( pResults[index2].dwTopicNumber, wsz2, MAX_TOPIC_NAME);
        if (0 == wsz2[0])
            _wcsncpy(wsz2, pInfo->pwszUnknown, MAX_TOPIC_NAME);

        iReturn = W_CompareString(pInfo->lcid, 0, wsz1, -1, wsz2, -1) - 2;
        break;

    case c_RankColumn: // Rank Number
        iReturn = index1 - index2;
        break;

    default:
        ASSERT(0);
        iReturn = index1 - index2;
        break;
    }

    return iReturn;
}

///////////////////////////////////////////////////////////
//
// SizeColumns
//
void
CFTSListView::SizeColumns()
{
    //--- Get the size of the client area
    RECT rcListView;
    ::GetClientRect(m_hwndListView, &rcListView);
    int width = (rcListView.right-rcListView.left);

    if(!m_bAdvancedSearch)
	{
        W_ListView_SetColumnWidth(m_hwndListView, 0, width);
		return;
    }

    //--- So some first time initialization
    if (!m_bSizeColumnsInit)
    {
        m_bSizeColumnsInit = true;

        // The following little hack should get us the minimun width for the location and rank column.
        W_ListView_SetColumnWidth(m_hwndListView, c_TopicColumn, width);
        W_ListView_SetColumnWidth(m_hwndListView, c_LocationColumn, LVSCW_AUTOSIZE_USEHEADER);
        W_ListView_SetColumnWidth(m_hwndListView, c_RankColumn, LVSCW_AUTOSIZE_USEHEADER);

        m_cxLocMin = W_ListView_GetColumnWidth(m_hwndListView, 1);
        m_cxRankMin = W_ListView_GetColumnWidth(m_hwndListView, 2);
    }

    //--- Calculate the column widths
    int cxTitle; // Width of the Title Column.
    int cxLoc; // Width of the location Column.
    int cxRank = m_cxRankMin; // Width of the Rank Column.
    if (width >= m_cxDefault)
    {
        // Everything is fully visible.
        cxTitle = width / 2;
        cxLoc = (width - cxTitle - cxRank);

    }
    else if ((width < m_cxDefault) /*&& (width > DEFAULT_NAV_WIDTH/2)*/)
    {
        // Only part of Rank column is shown and only the min loc size is used.
        cxTitle = width / 2;
        cxLoc = (width - cxTitle)* 3 /4;
        if (cxLoc > m_cxLocMin)
        {
            // Make sure that we use the min width for the location.
            cxTitle += cxLoc - m_cxLocMin; // Add the difference back to the Title column.
            cxLoc = m_cxLocMin;

        }
    }
/*
This branch isn't needed because the pane itself doesn't size below this medium.
    else if (width <= DEFAULT_NAV_WIDTH/2)
    {
      // No Rank is shown. Partial Location is shown.
      cxTitle = width * 3/4;
      cxLoc = m_cxLocMin;
    }
*/
    W_ListView_SetColumnWidth(m_hwndListView, c_RankColumn, cxRank);
    W_ListView_SetColumnWidth(m_hwndListView, c_LocationColumn, cxLoc);
    W_ListView_SetColumnWidth(m_hwndListView, c_TopicColumn, cxTitle);
}

///////////////////////////////////////////////////////////
//
// OnGetDispInfo
//
void
CFTSListView::OnGetDispInfo(LV_DISPINFOA* pDispInfo)
{
    static char szTemp[MAX_PATH*4]; // Holds strings.

    // Check to see if we have results.
    if ( m_pResults != NULL )
    {
        int i = (int)pDispInfo->item.lParam;
        switch(pDispInfo->item.iSubItem)
        {
        case c_TopicColumn: // Topic
            m_pResults[i].pTitle->GetTopicName( m_pResults[i].dwTopicNumber, pDispInfo->item.pszText, pDispInfo->item.cchTextMax );
            if (!pDispInfo->item.pszText[0])
            {
                strncpy(pDispInfo->item.pszText, GetStringResource(IDS_UNTITLED), pDispInfo->item.cchTextMax);
            }

            // Tell the ListView to store this string.
            pDispInfo->item.mask = pDispInfo->item.mask | LVIF_DI_SETITEM;
            break;

        case c_LocationColumn: // Location
            {
                ASSERT(m_bAdvancedSearch);
                HRESULT hr = m_pResults[i].pTitle->GetTopicLocation(m_pResults[i].dwTopicNumber, szTemp, MAX_PATH*4);
                if (FAILED(hr))
                {
                    strcpy(szTemp, GetStringResource(IDS_UNKNOWN));
                }
                strncpy(pDispInfo->item.pszText, szTemp, pDispInfo->item.cchTextMax);

                // Tell the ListView to store this string.
                pDispInfo->item.mask = pDispInfo->item.mask | LVIF_DI_SETITEM;
            }
            break;

#ifdef _DEBUG
        case c_RankColumn: // Rank 
            // shouldn't have a callback. So Fall on down.
        default:
            ASSERT(0);
            break;
#endif
        };
    }
}

///////////////////////////////////////////////////////////
//
// OnGetDispInfo
//
void
CFTSListView::OnGetDispInfoW(LV_DISPINFOW* pDispInfo)
{
    HRESULT hr;
    // Check to see if we have results.
    if ( m_pResults != NULL )
    {
        int i = (int)pDispInfo->item.lParam;
        switch(pDispInfo->item.iSubItem)
        {
        case c_TopicColumn: // Topic
            hr = m_pResults[i].pTitle->GetTopicName(m_pResults[i].dwTopicNumber, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
            if (FAILED(hr))
                _wcsncpy(pDispInfo->item.pszText, GetStringResourceW(IDS_UNTITLED), pDispInfo->item.cchTextMax);
            // Tell the ListView to store this string.
            pDispInfo->item.mask = pDispInfo->item.mask | LVIF_DI_SETITEM;
            break;

        case c_LocationColumn: // Location
            {
                ASSERT(m_bAdvancedSearch);
                hr = m_pResults[i].pTitle->GetTopicLocation(m_pResults[i].dwTopicNumber, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
                if (FAILED(hr))
                    _wcsncpy(pDispInfo->item.pszText, GetStringResourceW(IDS_UNKNOWN), pDispInfo->item.cchTextMax);
                // Tell the ListView to store this string.
                pDispInfo->item.mask = pDispInfo->item.mask | LVIF_DI_SETITEM;
            }
            break;

#ifdef _DEBUG
        case c_RankColumn: // Rank 
            // shouldn't have a callback. So Fall on down.
        default:
            ASSERT(0);
            break;
#endif
        };
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\lcmem.h ===
// Copyright (C) 1993-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef LCMEM_H
#define LCMEM_H

#define THIS_FILE __FILE__

#define CHECK_AND_FREE(x) if (x) { lcFree(x) ; x = NULL ; } 

// map all memory functions to CRT except for HHW which 
// uses the exported functions from HHA
#ifdef HHW

// exported by HHA
void* STDCALL rmalloc(int cb);             
void* STDCALL rcalloc(int cb);
void  STDCALL rfree(void* pv);             
void* STDCALL rrealloc(void* pv, int cb);  
void  STDCALL rclearfree(void** pv);
int   STDCALL lcSize(void* pv);           

// map the lc functions to those exported by HHA
#define lcMalloc(cb)      rmalloc(cb)
#define lcCalloc(cb)      rcalloc(cb)
#define lcFree(pv)        rfree((void*) (pv))
#define lcClearFree(pv)   rclearfree((void**) (pv))
#define lcReAlloc(pv, cb) rrealloc((void*) (pv), cb)

#else // HHA and HHCTRL

#include <malloc.h>
#include <crtdbg.h>

#define lcMalloc(cb)      malloc(cb)
__inline void* lcCalloc(int cb) { void* pv = lcMalloc(cb); ZeroMemory(pv, cb); return pv; }
#define lcFree(pv)        free((void*) pv)
#define lcClearFree(pv) { lcFree(*pv); *pv = NULL; }
#define lcReAlloc(pv, cb) realloc(pv, cb)

#define lcSize(pv)        _msize(pv)

#endif // HHW

// common to all
#define lcHeapCheck()

PSTR lcStrDup(PCSTR psz);
PWSTR lcStrDupW(PCWSTR psz);

#ifdef HHCTRL
void OnReportMemoryUsage();
#endif

class CMem
{
public:
    PBYTE pb;
#ifndef HHCTRL
    PSTR  psz; // identical to pb, used for casting convenience
#endif

    CMem(void);
    CMem(int size);
    ~CMem(void) {
        if(pb)
            lcFree(pb);
    }

#ifndef HHCTRL
    int size(void);
    void resize(int cb);
#endif

    void ReAlloc(int cbNewSize) {
        pb = (PBYTE) lcReAlloc(pb, cbNewSize);
#ifndef HHCTRL
        psz = (PSTR) pb;
#endif
    }
    void Malloc(int cb) {
        _ASSERT(!pb);
        pb = (PBYTE) lcMalloc(cb);
#ifndef HHCTRL
        psz = (PSTR) pb;
#endif
    }

    operator void*() { return (void*) pb; };
    operator PCSTR() { return (PCSTR) pb; };
    operator PSTR()  { return (PSTR) pb; };
    operator PBYTE() { return pb; };
    operator LPWSTR() { return (LPWSTR) pb; };
};

#endif // LCMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\lasterr.h ===
#ifndef __LASTERR_H__
#define __LASTERR_H__
///////////////////////////////////////////////////////////
//
// lasterr.h	- Class which supports the HH_GET_LAST_ERROR function.
//              - It supports a list of HR's indexed on idProcess.
//
//
/********************************************************************
            How to set and error messages for HH_GET_LAST_ERROR.

1. Look in HHERROR.H for the currently defined errors.
2. Look in strtable.rc2 to see the string corresponding to this error.
3. Include the header lasterr.h in your file.
4. Use the following line to set an error:
    g_LastError.Set(idProcess, HH_E_FILENOTFOUND) ;
5. Note, you may have to modify your function to get the process id.
6. Follow the execution path to see if someone will overwrite your error.


            How to add a new error message for HH_GET_LAST_ERROR.

1. Add the ID for the error message to the header file HHERROR.H.
2. Use the naming convention HH_E_*, for example HH_E_FILENOTFOUND. 
3. Add a define to strtable.h for this new error:
        #define IDS_HH_E_FILENOTFOUND 1301
   The name of the string is the name of the error with IDS_ prepended.
   Group it together with the other errors.
4. Add a string for this error to strtable.rc2.
        IDS_HH_E_FILENOTFOUND           "The help file could not be found."
5. Modify the function ErrorStringId function in lasterr.h to translate
   your HRESULT into its STRINGID.



*********************************************************************/

// Possible error codes.
#include "hherror.h"

///////////////////////////////////////////////////////////
//
// Forwards
//
class CProcessError ;
class CLastError ;

///////////////////////////////////////////////////////////
//
// Global Functions
//

// Implementes the HH_GET_LAST_ERROR command.
HRESULT hhGetLastError(HH_LAST_ERROR* dwData) ;

// Returns a BSTR pointer given 
HRESULT GetStringFromHr(HRESULT hr, BSTR* pDescription);

// returns the resource id for a HRESULT.
int ErrorStringId(HRESULT hr);

///////////////////////////////////////////////////////////
//
// Externally Allocate members.
//
extern CLastError g_LastError ;

///////////////////////////////////////////////////////////
//
// Constants
//
// Grow the array by 10 elements each time.
const int c_GrowBy = 5 ; 

///////////////////////////////////////////////////////////
//
//	CLastError 
//
class CLastError
{
public:
	// Constructor
	CLastError() ;

	// Destructor
	~CLastError() ;

    // Set the error
    void Set(HRESULT hr) ;

    // Get the error
    void Get(HRESULT* hr) ;

    // Reset the error
    void Reset() ; // Currently, this means that it defaults to E_FAIL.

    // Deletes all of the memory associated with the object.
    void Finish() ;

//--- Internal helper functions.
private:
    // Allocate the array.
    void AllocateArray() ;

    // Get error structure for the idProcess.
    CProcessError* FindProcess(DWORD idProcess) ;

    // Add New Process
    CProcessError* AddProcess();

    // Allocate Array
    CProcessError* AllocateArray(int elements) ;

    // Deallocate Array
    void DeallocateArray(CProcessError* p); 

//---Member variables
private:
    // Holds the last error.
    CProcessError* m_ProcessErrorArray;

    // The number of allocated elements in the array.
    int m_maxindex ;

    // The last used index
    int m_lastindex ;

};


#endif //__LASTERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\language.h ===
#ifndef __LANGUAGE_H__
#define __LANGUAGE_H__
//////////////////////////////////////////////////////////////////////////
//
//
//	language.h --- Header for language related classes.
//
//
/*
    This file contains classes related to managing the UI language of HHCTRL.

*/
//////////////////////////////////////////////////////////////////////////
//
// Forwards
//
class CLanguage ;

//////////////////////////////////////////////////////////////////////////
//
// Constants
//
const LANGID c_LANGID_ENUM_EOF= static_cast<LANGID>(-1) ;

//////////////////////////////////////////////////////////////////////////
//
// CLanguageEnum
//
/*
    This class enumerates the langids to attempt. If you are trying to access
    some object using a langid and that object may not be in that particular langid,
    you should use this class to get an array of langids to try.

    NOTE: This class should only be obtained from the CLanguage class below.
*/
class CLanguageEnum
{
//--- Relationships
    friend CLanguage ;

//--- Construction
private:
    // Will return the langid passed in first. This is the 
    CLanguageEnum(LANGID langid1 = NULL, LANGID langid2 = NULL, bool bSysOnly = false) ;

public:
    virtual ~CLanguageEnum() ;

//--- Access
public:
    LANGID start() ; 
    LANGID next() ; // The last LANGID is always 0 which can be used as a "search for anything" flag. After the 0, next returns c_LANGID_ENUM_EOF .

//--- Member variables
private:
    // Current index into array.
    int m_index ;

    // number of items in the array.
    int m_items ;

    // Number of LangIds to search
    LANGID* m_langids;
};

//////////////////////////////////////////////////////////////////////////
//
// CLanguage
//
class CLanguage
{
//--- Construction
public:
    CLanguage() ;
    virtual ~CLanguage() ;

//--- Access
public:
    // All of the access functions are self initializing.

    // Returns the language identifier of the ui/resources.
    LANGID GetUiLanguage() ;

    // Set the LangId for the resources you want to use --- Used by external clients. Loads the correct satellite dll.
    LANGID SetUiLanguage(LANGID langid) ; // Returns the actually langid the control is set to.

    // Returns an enumerator to enumerate the possible ui languages. Caller responsible for deleting.
    CLanguageEnum* GetEnumerator(LANGID langidOther = NULL) {_Init(); return _GetEnumerator(langidOther); }

    // Load the satellite dll --- Called by the module.cpp. 
    HINSTANCE LoadSatellite() {_Init(); return m_hSatellite ; } // This may appear wierd, but m_hSatellite is NULL if m_langid is 0x0409.

    // Return's the user's os ui language. 
    LANGID GetUserOsUiLanguage() ;  //REVIEW: Move to COsLanguage class?

//--- Private Member functions
private:
    void _Init() {if (!m_langid) _LoadSatellite(); }

    // Non-auto load.
    void _LoadSatellite() ;

    // Non-auto load.
    CLanguageEnum* _GetEnumerator(LANGID landidOther = NULL) ;

    // Enumerate only the sys lcids and english lcids. Used by satellite dlls.
    CLanguageEnum*  _GetSysEnumerator(LANGID landidOther = NULL) ; 
 

//--- Member variables
private:
    // Language ID of the user interface. This is either set by the client or by default when we load the satellite.
    LANGID m_langid ;

    // Satellite instance handle. If m_langid is 0x0409 (english) we don't have a satellite dll.
    HINSTANCE m_hSatellite ;

	// Function Pointer type for Get*DefaultUILanguage Functions
	typedef LANGID (WINAPI *FntPtr_GetDefaultUILanguage)();

	// Function pointer to the Get*DefaultUILanguage
	FntPtr_GetDefaultUILanguage m_fpGetUserDefaultUILanguage ;
    FntPtr_GetDefaultUILanguage m_fpGetSystemDefaultUILanguage ;

	// Pointer to the Module handle.
	HMODULE m_hNlsModule;

};


#endif //__LANGUAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\listview.h ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CLISTVIEW_H_
#define _CLISTVIEW_H_

class CFTSListView 
{
	// methods
public:
	CFTSListView(CExCollection* pTitleCollection, HWND m_hwndListView = NULL, bool bAdvancedSearch = FALSE);

    // Set the result set to use.
    void SetResults(int cResultCount, SEARCH_RESULT * SearchResults ) ;

    // Add the currently set results to the listview
	void AddItems();

	LRESULT ListViewMsg(HWND hwnd, NM_LISTVIEW* pnmhdr);
	void	ResetQuery(void);

    // The following is use to set the initial size of the columns for AdvFTS mode only.
    void SizeColumns() ;

    // Internal helper functions
public:
    // Handle TEXTCALLBACKS
    void OnGetDispInfo(LV_DISPINFOA* pDispInfo);
    void OnGetDispInfoW(LV_DISPINFOW* pDispInfo);

	// data members
public:
	SEARCH_RESULT *m_pResults;	  // returned from Full Text Search Query.
    int         m_cResultCount;
	int			m_ItemNumber;	// The item number of the selected item in the List View.
	HWND		m_hwndListView;    // HANDLE to the list veiw control

protected:
	BOOL m_fInitialized;
	int  m_cItems;			// item count
	int  m_cAllocItems;		// number of items before reallocation is necessary
	CExCollection* m_pTitleCollection;

    // If true, we will use the multicolumn adv. search ui.
    bool m_bAdvancedSearch ;

    // false if we haven't done a SizeColumns.
    bool m_bSizeColumnsInit;

    // Minimum width of the location column.
    int m_cxLocMin ;

    // Minimum width of the Rank column.
    int m_cxRankMin ;

    // The default width of the control.
    int m_cxDefault ;
};

#endif // _CLISTVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\lasterr.cpp ===
///////////////////////////////////////////////////////////
//
// lasterr.cpp  - Class which supports the HH_GET_LAST_ERROR function.
//              - Included here is the CProcessError class.
//
//

///////////////////////////////////////////////////////////
//
// Include files
//

// Global header
#include "header.h"
#include "hhctrl.h"

// Our header
#include "lasterr.h"

///////////////////////////////////////////////////////////
//
//                  Internal Classes
//
///////////////////////////////////////////////////////////
//
//  CProcessError
//
class CProcessError 
{
public:
    CProcessError() 
    :   m_processid(0),
        m_hr(E_FAIL) // Assumes failure, because we never set it...
    {}

    // Process Id
    DWORD m_processid ;

    // Last error for this process id.
    HRESULT m_hr ;
};

///////////////////////////////////////////////////////////
//
//	                CLastError 
//
///////////////////////////////////////////////////////////
//
// Constructor
//
CLastError::CLastError()
: m_ProcessErrorArray(NULL),
    m_maxindex(0),
    m_lastindex(0)
{
}

///////////////////////////////////////////////////////////
//
// Destructor
//
CLastError::~CLastError()
{
    // Delete the array.
    Finish() ;
}

///////////////////////////////////////////////////////////
//
// Set the error
//
void 
CLastError::Set(HRESULT hr)
{
    DWORD idProcess = 1 ; //TODO: REMOVE!!!
    if (idProcess) // The idProcess might be zero during the conversion process.
    {
        CProcessError* pProcessError = FindProcess(idProcess) ;
        ASSERT(pProcessError) ;

        // Set the fields.
        pProcessError->m_hr = hr ;
        pProcessError->m_processid = idProcess ;
    }
}

///////////////////////////////////////////////////////////
//
// Get the error
//
void
CLastError::Get(HRESULT* hr)
{
    DWORD idProcess = 1 ; //TODO: REMOVE!!!
    if (idProcess)
    {
        CProcessError* pProcessError = FindProcess(idProcess) ;
        ASSERT(pProcessError) ;

        *hr = pProcessError->m_hr; 
    }
}

///////////////////////////////////////////////////////////
//
// Reset the error
//
void 
CLastError::Reset()
{
    DWORD idProcess = 1 ; //TODO: REMOVE!!!
    if (idProcess)
    {
        CProcessError* pProcessError = FindProcess(idProcess) ;
        ASSERT(pProcessError) ;

        pProcessError->m_hr = E_FAIL ; // Only call if you have a NULL hwnd. S_OK ; 
    }
}


///////////////////////////////////////////////////////////
//
// Finish - The whole reason for this function is so we can clean
//          things up in DLL process detach.
//
void 
CLastError::Finish()
{
    // Delete the array.
    DeallocateArray(m_ProcessErrorArray) ;
    // Set pointer to NULL.
    m_ProcessErrorArray = NULL ;

    // Reset the other variables.
    m_maxindex = 0 ;
    m_lastindex = 0 ;

    // Just like starting all over.
}
///////////////////////////////////////////////////////////
//
// Internal Helpers
//
///////////////////////////////////////////////////////////
//
// FindProcess - Gets the index number for the process id ;
//
CProcessError* 
CLastError::FindProcess(DWORD idProcess)
{
    ASSERT( m_lastindex <= m_maxindex) ;

    CProcessError* p = m_ProcessErrorArray ;
    // Look for the process in the array.
    for (int i = 0 ; i < m_lastindex ; i++)
    {
        if (p->m_processid == idProcess) 
        {
            // Found it!
            return p ;
        }
        p++ ;
    }

    // Okay, we didn't find the process id.
    // Add it on to the end.
    return AddProcess() ;
}

///////////////////////////////////////////////////////////
//
// AddProcess - adds a process structure to the array.
//
CProcessError* 
CLastError::AddProcess()
{
    CProcessError* p = NULL ;
    if (m_lastindex < m_maxindex)
    {
        // Don't need to grow. Just add it to the existing array.
        p = &m_ProcessErrorArray[m_lastindex] ;
    }
    else
    {
        // We have used up our slots, so we need to allocate more.
        int newmaxindex = m_maxindex + c_GrowBy;

        // Allocate a new array.
        p = AllocateArray(newmaxindex) ;

        // Copy existing entries.
        for (int i = 0 ; i < m_maxindex ; i++)
        {
            // Copy the pointers
            p[i] = m_ProcessErrorArray[i] ;
        }

        // Delete the original array.
        DeallocateArray(m_ProcessErrorArray) ;

        // Use the new array.
        m_ProcessErrorArray = p;

        // get the pointer.
        p = &m_ProcessErrorArray[m_lastindex] ;

        // reset the endpoint.
        m_maxindex = newmaxindex ;
    }

    // Increment the index ;
    m_lastindex++ ;

    // Post condition.
    ASSERT(p) ;

    return p ;
}

///////////////////////////////////////////////////////////
//
// Allocate Array
//
CProcessError* 
CLastError::AllocateArray(int elements)
{
    return new CProcessError[elements] ;
}

///////////////////////////////////////////////////////////
//
// Deallocate Array
//
void 
CLastError::DeallocateArray(CProcessError* p)
{
    // For some reason the heap management code in hhctrl allows memory leaks,
    // but doesn't allow global class variables to call delete in their constructors.
    if (p)
    {
        delete [] p ;
    }
}

///////////////////////////////////////////////////////////
//
// Public globals.
//
CLastError g_LastError ;

///////////////////////////////////////////////////////////
//
// Global Functions
//
///////////////////////////////////////////////////////////
//
// hhGetLastError
//
HRESULT hhGetLastError(HH_LAST_ERROR* pError) 
{
    if (!pError && 
        IsBadReadPtr((void*) pError, sizeof(HH_LAST_ERRO