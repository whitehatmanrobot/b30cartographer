    CallParams -> UsagePage,
                                                           CallParams -> Ppd);

        CallParams -> List = malloc(CallParams -> ListLength * sizeof(USAGE));

        if (NULL != CallParams -> List)
        {
            status = HidP_GetUsages(CallParams -> ReportType,
                                    CallParams -> UsagePage,
                                    CallParams -> LinkCollection,
                                    CallParams -> List,
                                   &CallParams -> ListLength,
                                    CallParams -> Ppd,
                                    CallParams -> ReportBuffer,
                                    CallParams -> ReportLength);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
       }
       return (NULL != CallParams -> List);

    case HIDP_GET_USAGES_EX:
        CallParams -> ListLength = HidP_MaxUsageListLength(CallParams -> ReportType,
                                                           CallParams -> UsagePage,
                                                           CallParams -> Ppd);

        CallParams -> List = malloc(CallParams -> ListLength * sizeof(USAGE_AND_PAGE));

        if (NULL != CallParams -> List)
        {
            status = HidP_GetUsagesEx(CallParams -> ReportType,
                                      CallParams -> LinkCollection,
                                      CallParams -> List,
                                     &CallParams -> ListLength,
                                      CallParams -> Ppd,
                                      CallParams -> ReportBuffer,
                                      CallParams -> ReportLength);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
       }
       return (NULL != CallParams -> List);
         
    case HIDP_GET_USAGE_VALUE:
        status = HidP_GetUsageValue(CallParams -> ReportType,
                                    CallParams -> UsagePage,
                                    CallParams -> LinkCollection,
                                    CallParams -> Usage,
                                    &CallParams -> Value,
                                    CallParams -> Ppd,
                                    CallParams -> ReportBuffer,
                                    CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_GET_USAGE_VALUE_ARRAY:

        ValueCapsLength = 1;
        status = HidP_GetSpecificValueCaps(CallParams -> ReportType,
                                           CallParams -> UsagePage,
                                           CallParams -> LinkCollection,
                                           CallParams -> Usage,
                                           &ValueCaps,
                                           &ValueCapsLength,
                                           CallParams -> Ppd);

        if (HIDP_STATUS_SUCCESS != status) 
        {
            return (FALSE);
        }

        CallParams -> BitSize     = ValueCaps.BitSize;
        CallParams -> ReportCount = ValueCaps.ReportCount;
        CallParams -> ListLength
                 = ROUND_TO_NEAREST_BYTE(CallParams -> BitSize * CallParams -> ReportCount);

        CallParams -> List = malloc(CallParams -> ListLength);

        if (NULL != CallParams -> List) 
        {
            status = HidP_GetUsageValueArray(CallParams -> ReportType,
                                             CallParams -> UsagePage,
                                             CallParams -> LinkCollection,
                                             CallParams -> Usage,
                                             CallParams -> List,
                                             (USHORT) CallParams -> ListLength,
                                             CallParams -> Ppd,
                                             CallParams -> ReportBuffer,
                                             CallParams -> ReportLength);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
        }
        return (NULL != CallParams -> List);

    case HIDP_GET_VALUE_CAPS:
        CallParams -> List = malloc(CallParams -> ListLength * sizeof(HIDP_VALUE_CAPS));
        if (NULL != CallParams -> List) 
        {
            status = HidP_GetValueCaps(CallParams -> ReportType,
                                       CallParams -> List,
                                       (PUSHORT) &CallParams -> ListLength,
                                       CallParams -> Ppd);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
        }


    case HIDP_INITIALIZE_REPORT_FOR_ID:
        
        status = pfnHidP_InitializeReportForID(CallParams -> ReportType,
                                               CallParams -> ReportID,
                                               CallParams -> Ppd,
                                               CallParams -> ReportBuffer,
                                               CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_MAX_USAGE_LIST_LENGTH:

        CallParams -> Value = HidP_MaxUsageListLength(CallParams -> ReportType,
                                                      CallParams -> UsagePage,
                                                      CallParams -> Ppd);

        CallStatus -> IsHidError = FALSE;
        CallStatus -> HidErrorCode = HIDP_STATUS_SUCCESS;

        return (TRUE);

    case HIDP_MAX_DATA_LIST_LENGTH:

        CallParams -> Value = HidP_MaxDataListLength(CallParams -> ReportType,
                                                     CallParams -> Ppd);

        CallStatus -> IsHidError = FALSE;
        CallStatus -> HidErrorCode = HIDP_STATUS_SUCCESS;

        return (TRUE);

    case HIDP_SET_BUTTONS:

        status = HidP_SetButtons(CallParams -> ReportType,
                                 CallParams -> UsagePage,
                                 CallParams -> LinkCollection,
                                 CallParams -> List,
                                 &CallParams -> ListLength,
                                 CallParams -> Ppd,
                                 CallParams -> ReportBuffer,
                                 CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_SET_DATA:

        status = HidP_SetData(CallParams -> ReportType,
                              CallParams -> List,
                              &CallParams -> ListLength,
                              CallParams -> Ppd,
                              CallParams -> ReportBuffer,
                              CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_SET_SCALED_USAGE_VALUE:
        status = HidP_SetUsageValue(CallParams -> ReportType,
                                    CallParams -> UsagePage,
                                    CallParams -> LinkCollection,
                                    CallParams -> Usage,
                                    CallParams -> ScaledValue,
                                    CallParams -> Ppd,
                                    CallParams -> ReportBuffer,
                                    CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_SET_USAGES:
        status = HidP_SetUsages(CallParams -> ReportType,
                                CallParams -> UsagePage,
                                CallParams -> LinkCollection,
                                CallParams -> List,
                               &CallParams -> ListLength,
                                CallParams -> Ppd,
                                CallParams -> ReportBuffer,
                                CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_SET_USAGE_VALUE:
        status = HidP_SetUsageValue(CallParams -> ReportType,
                                    CallParams -> UsagePage,
                                    CallParams -> LinkCollection,
                                    CallParams -> Usage,
                                    CallParams -> Value,
                                    CallParams -> Ppd,
                                    CallParams -> ReportBuffer,
                                    CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_SET_USAGE_VALUE_ARRAY:

        ValueCapsLength = 1;
        status = HidP_GetSpecificValueCaps(CallParams -> ReportType,
                                           CallParams -> UsagePage,
                                           CallParams -> LinkCollection,
                                           CallParams -> Usage,
                                           &ValueCaps,
                                           &ValueCapsLength,
                                           CallParams -> Ppd);

        if (HIDP_STATUS_SUCCESS != status) 
        {
            return (FALSE);
        }
        
        CallParams -> BitSize     = ValueCaps.BitSize;
        CallParams -> ReportCount = ValueCaps.ReportCount;

        ValueList = CallParams -> List;
        ExecuteStatus = ECDisp_ConvertUlongListToValueList(ValueList,
                                                           CallParams -> ListLength,
                                                           CallParams -> BitSize,
                                                           CallParams -> ReportCount,
                                                           (PCHAR *) &CallParams -> List,
                                                           &CallParams -> ListLength);

        if (!ExecuteStatus) 
        {
            return (FALSE);
        }

        status = HidP_SetUsageValueArray(CallParams -> ReportType,
                                         CallParams -> UsagePage,
                                         CallParams -> LinkCollection,
                                         CallParams -> Usage,
                                         CallParams -> List,
                                         (USHORT) CallParams -> ListLength,
                                         CallParams -> Ppd,
                                         CallParams -> ReportBuffer,
                                         CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_UNSET_BUTTONS:
        status = HidP_UnsetButtons(CallParams -> ReportType,
                                   CallParams -> UsagePage,
                                   CallParams -> LinkCollection,
                                   CallParams -> List,
                                   &CallParams -> ListLength,
                                   CallParams -> Ppd,
                                   CallParams -> ReportBuffer,
                                   CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_UNSET_USAGES:
        status = HidP_UnsetUsages(CallParams -> ReportType,
                                  CallParams -> UsagePage,
                                  CallParams -> LinkCollection,
                                  CallParams -> List,
                                 &CallParams -> ListLength,
                                  CallParams -> Ppd,
                                  CallParams -> ReportBuffer,
                                  CallParams -> ReportLength);
                          
        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;
                          
        return (TRUE);    

    case HIDP_USAGE_LIST_DIFFERENCE:
        CallParams -> MakeList = (PUSAGE) malloc (sizeof(USAGE) * CallParams -> ListLength);

        if (NULL == CallParams -> MakeList)
        {
            return (FALSE);
        }

        CallParams -> BreakList = (PUSAGE) malloc (sizeof(USAGE) * CallParams -> ListLength);
        if (NULL == CallParams -> BreakList) 
        {
            free(CallParams -> MakeList);

            return (FALSE);
        }

        status = HidP_UsageListDifference(CallParams -> List,
                                          CallParams -> List2,
                                          CallParams -> BreakList,
                                          CallParams -> MakeList,
                                          CallParams -> ListLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);
    }
    return (FALSE);
}

VOID
ECDisp_DisplayOutput(
    IN HWND            hOutputWindow,
    IN INT             FuncCall,
    IN PEXTCALL_PARAMS Results
)
/*++
RoutineDescription:
    This routine is responsible for displaying the output from calls to HID.DLL
    functions.  It must extract and interpret the appropriate data from the 
    PEXTCALL_PARAMS structure. 
--*/
{
    PHIDP_LINK_COLLECTION_NODE NodeList;
    PHIDP_BUTTON_CAPS          ButtonCaps;
    PHIDP_VALUE_CAPS           ValueCaps;
    PHIDP_DATA                 DataList;
    PHIDP_EXTENDED_ATTRIBUTES  ExtAttrib;
    PUSAGE_AND_PAGE            UsageAndPageList;
    PUSAGE                     UsageList;
    PCHAR                      UsageValueArray;
    PBUFFER_DISPLAY            pDisplay;
    PCHAR                      PhysDescString;
    PCHAR                      GenreDescString;

    ULONG                      Index;

    switch (FuncCall) {
    case HIDD_GET_HID_GUID:

        strcpy(szTempBuffer, "HID Guid: ");
        ECDisp_MakeGUIDString(*((LPGUID) Results -> List),
                              &szTempBuffer[strlen(szTempBuffer)]);

        OUTSTRING(hOutputWindow, szTempBuffer);
        break;

    case HIDD_GET_ATTRIBUTES:
        vDisplayDeviceAttributes((PHIDD_ATTRIBUTES) Results -> List, 
                                 hOutputWindow);
        break;

    case HIDD_GET_NUM_INPUT_BUFFERS:
        wsprintf(szTempBuffer, "Number input buffers: %u", Results -> Value);

        OUTSTRING(hOutputWindow, szTempBuffer);
        break;

    case HIDD_GET_MS_GENRE_DESCRIPTOR:
        OUTSTRING(hOutputWindow, "MS Genre Descriptor");
        OUTSTRING(hOutputWindow, "===================");
    
            /*
        // To display a physical descriptor, the procedure currently just
        //   creates a string data buffer by bytes and displays that 
        //   in the results box.  It will display in rows of 16 bytes apiece.
        */
        
        Index = 0;
        while (Index < Results -> ListLength) 
        {
            Strings_CreateDataBufferString(((PCHAR) Results -> List) + Index,
                                           Results -> ListLength - Index,
                                           16,
                                           1,
                                           &GenreDescString);

            if (NULL != GenreDescString) 
            {
                OUTSTRING(hOutputWindow, GenreDescString);
                free(GenreDescString);
            }
            else 
            {
               OUTSTRING(hOutputWindow, "Error trying to display ms genre descriptor");
            }
            Index += 16;
        }
        break;

    case HIDD_GET_PHYSICAL_DESCRIPTOR: 
        OUTSTRING(hOutputWindow, "Physical Descriptor");
        OUTSTRING(hOutputWindow, "===================");

        /*
        // To display a physical descriptor, the procedure currently just
        //   creates a string data buffer by bytes and displays that 
        //   in the results box.  It will display in rows of 16 bytes apiece.
        */
        
        Index = 0;
        while (Index < Results -> ListLength) 
        {
            Strings_CreateDataBufferString(((PCHAR) Results -> List) + Index,
                                           Results -> ListLength - Index,
                                           16,
                                           1,
                                           &PhysDescString);

            if (NULL != PhysDescString) 
            {
                OUTSTRING(hOutputWindow, PhysDescString);
                free(PhysDescString);
            }
            else 
            {
               OUTSTRING(hOutputWindow, "Error trying to display physical descriptor");
            }
            Index += 16;
        }
        break;

    /*
    // For the string descriptor call routines, the returned string is stored
    //   in the Results -> List parameter.  It should be noted that the
    //   strings returned by these calls are wide-char strings and that these
    //   string are terminated with a NULL character if there was space withing
    //   the buffer to add such a character.  If the buffer was only big enough
    //   to hold the characters of the string, there will be no null terminator
    //   and the output string display mechanism may fail to properly display this
    //   type of string.  Fixing of this display mechanism is a future (low priority)
    //   workitem.
    */
    
    case HIDD_GET_PRODUCT_STRING:
        OUTSTRING(hOutputWindow, "Product String");
        OUTSTRING(hOutputWindow, "==============");
        OUTWSTRING(hOutputWindow, Results -> List);
        break;

    case HIDD_GET_MANUFACTURER_STRING:
        OUTSTRING(hOutputWindow, "Manufacturer String");
        OUTSTRING(hOutputWindow, "===================");
        OUTWSTRING(hOutputWindow, Results -> List);
        break;

    case HIDD_GET_INDEXED_STRING:
        wsprintf(szTempBuffer, "Indexed String #%u:", Results -> Index);

        OUTSTRING(hOutputWindow, szTempBuffer);
        OUTSTRING(hOutputWindow, "===================");
        OUTWSTRING(hOutputWindow, Results -> List);
        break;

    case HIDD_GET_SERIAL_NUMBER_STRING:
        OUTSTRING(hOutputWindow, "Serial Number String");
        OUTSTRING(hOutputWindow, "=====================");
        OUTWSTRING(hOutputWindow, Results -> List);
        break;
        
    case HIDP_GET_BUTTON_CAPS:
    case HIDP_GET_SPECIFIC_BUTTON_CAPS:

        ButtonCaps = (PHIDP_BUTTON_CAPS) (Results -> List);
        for (Index = 0; Index < Results -> ListLength; Index++, ButtonCaps++) 
        {
             OUTSTRING(hOutputWindow, "==========================");
             vDisplayButtonAttributes(ButtonCaps, hOutputWindow);
        }
        break;

    /*
    // HidP_GetButtons and HidP_GetUsages are in reality the same call.  
    //   HidP_GetButtons actually a macro which gets redefined into 
    //   HidP_GetUsages with the same parameter order.  That is why their
    //   display mechanisms are identical.  This call returns in the 
    //   List parameter a list of Usages.  The display mechanism converts
    //   these usages into a string of numbers.
    */
    
    case HIDP_GET_BUTTONS:
    case HIDP_GET_USAGES:

        OUTSTRING(hOutputWindow, "Usages Returned");
        OUTSTRING(hOutputWindow, "===============");

        UsageList = (PUSAGE) Results -> List;
        for (Index = 0; Index < Results -> ListLength; Index++) 
        {
            vCreateUsageString(UsageList + Index, szTempBuffer);

            OUTSTRING(hOutputWindow, szTempBuffer);
        }
        break;

    /*
    // Like get their siblings, the normal get functions, these routines are
    //   currently one in the same.  The difference between these routines 
    //   and their siblings is the return of a usage page along with each
    //   usage.  Therefore, both values must be displayed at the same time.
    */
    
    case HIDP_GET_BUTTONS_EX:
    case HIDP_GET_USAGES_EX:

        OUTSTRING(hOutputWindow, "Usages Returned");
        OUTSTRING(hOutputWindow, "===============");

        UsageAndPageList = (PUSAGE_AND_PAGE) Results -> List;
        for (Index = 0; Index < Results -> ListLength; Index++) 
        {
            vCreateUsageAndPageString(UsageAndPageList + Index,
                                      szTempBuffer);

            OUTSTRING(hOutputWindow, szTempBuffer);
        }
        break;

    case HIDP_GET_CAPS:
        vDisplayDeviceCaps((PHIDP_CAPS) Results -> List, hOutputWindow);
        break;

    case HIDP_GET_DATA:
        OUTSTRING(hOutputWindow, "Data Indices");
        OUTSTRING(hOutputWindow, "============");
        
        DataList = (PHIDP_DATA) Results -> List;
        for (Index = 0; Index < Results -> ListLength; Index++) 
        {
            vDisplayDataAttributes(DataList+Index,
                                   FALSE,
                                   hOutputWindow);
        }
        break;

    case HIDP_GET_EXTENDED_ATTRIBUTES:
        OUTSTRING(hOutputWindow, "Extended Attributes");
        OUTSTRING(hOutputWindow, "===================");
        
        ExtAttrib = (PHIDP_EXTENDED_ATTRIBUTES) Results -> List;

        DisplayExtendedAttributes(hOutputWindow,
                                  ExtAttrib -> GlobalUnknowns, 
                                  ExtAttrib -> NumGlobalUnknowns);
        break;
        
    case HIDP_GET_LINK_COLL_NODES:

        OUTSTRING(hOutputWindow, "Link Collection Nodes");
        OUTSTRING(hOutputWindow, "=====================");
        
        NodeList = (PHIDP_LINK_COLLECTION_NODE) Results -> List;
        for (Index = 0; Index < Results -> ListLength; Index++) 
        {
            OUTSTRING(hOutputWindow, "===========================");
            vDisplayLinkCollectionNode(NodeList+Index,
                                       Index,
                                       hOutputWindow);
        }
        break;

    case HIDP_GET_SCALED_USAGE_VALUE:
    
        wsprintf(szTempBuffer, "Scaled usage value: %ld", Results -> ScaledValue);
        OUTSTRING(hOutputWindow, szTempBuffer);

        break;

    case HIDP_GET_USAGE_VALUE:
        wsprintf(szTempBuffer, "Usage value: %lu", Results -> Value);
        OUTSTRING(hOutputWindow, szTempBuffer);
        break;

    /*
    // To display a usage value array, we must extract each of the values
    //   in the array based on the ReportSize.  The ReportSize is not necessarily
    //   an even byte size so we must use the special extraction routine to get
    //   each of the values in the array.
    */
    
    case HIDP_GET_USAGE_VALUE_ARRAY:

        UsageValueArray = (PCHAR) Results -> List;

        for (Index = 0; Index < Results -> ReportCount; Index++) 
        {
            vCreateUsageValueStringFromArray(UsageValueArray,
                                             Results -> BitSize,
                                             (USHORT) Index,
                                             szTempBuffer);
    
            OUTSTRING(hOutputWindow, szTempBuffer);
        }
        break;

    case HIDP_GET_VALUE_CAPS:
    case HIDP_GET_SPECIFIC_VALUE_CAPS:
        
        ValueCaps = (PHIDP_VALUE_CAPS) Results -> List;

        for (Index = 0; Index < (INT) Results -> ListLength; Index++) 
        {
            OUTSTRING(hOutputWindow, "==========================");
            vDisplayValueAttributes(ValueCaps + Index,
                                    hOutputWindow);
        }
        break;

    case HIDP_MAX_DATA_LIST_LENGTH:
        wsprintf(szTempBuffer, "MaxDataListLength: %u", Results -> Value);
        OUTSTRING(hOutputWindow, szTempBuffer);
        break;

    case HIDP_MAX_USAGE_LIST_LENGTH:
        wsprintf(szTempBuffer, "MaxUsageListLength: %u", Results -> Value);
        OUTSTRING(hOutputWindow, szTempBuffer);
        break;

    /*
    // For HidP_UsageListDifference, we need to display both of the make and
    //   break lists generated by the function.  Therefore, we end up creating
    //   two different usage list strings.
    */
    
    case HIDP_USAGE_LIST_DIFFERENCE:
        
        OUTSTRING(hOutputWindow, "Make List");
        OUTSTRING(hOutputWindow, "=========");

        UsageList = (PUSAGE) Results -> MakeList;
        Index = 0;

        while (0 != *(UsageList+Index) && Index < Results -> ListLength) 
        {
            vCreateUsageString(UsageList + Index,
                               szTempBuffer);

            OUTSTRING(hOutputWindow, szTempBuffer);
            Index++;
        }

        OUTSTRING(hOutputWindow, "Break List");
        OUTSTRING(hOutputWindow, "==========");

        UsageList = (PUSAGE) Results -> BreakList;
        Index = 0;

        while (0 != *(UsageList+Index) && Index < Results -> ListLength) 
        {
            vCreateUsageString(UsageList + Index,
                               szTempBuffer);

            OUTSTRING(hOutputWindow, szTempBuffer);
            Index++;
        }
        break;

    /*
    // These functions simply update the buffer that is specified as the 
    //   input parameter.  We must select the correct display buffer mechanism
    //   based on the ReportType for the call and then update the given report
    //   in that display mechanism.
    */
    
    case HID_READ_REPORT:
    case HIDD_GET_FEATURE:
    case HIDP_INITIALIZE_REPORT_FOR_ID:
    case HIDP_SET_BUTTONS:
    case HIDP_SET_DATA:
    case HIDP_SET_SCALED_USAGE_VALUE:
    case HIDP_SET_USAGES:
    case HIDP_SET_USAGE_VALUE:
    case HIDP_SET_USAGE_VALUE_ARRAY:
    case HIDP_UNSET_BUTTONS:
    case HIDP_UNSET_USAGES:
        SELECT_ON_REPORT_TYPE(Results -> ReportType,
                              pInputDisplay,
                              pOutputDisplay,
                              pFeatureDisplay,
                              pDisplay);

        BufferDisplay_UpdateBuffer(pDisplay,
                                   Results -> ReportBuffer);
        break;
    }
    return;
}

VOID 
vExecuteAndDisplayOutput(
    HWND              hOutputWindow,
    PHID_DEVICE       pDevice,
    INT               iFuncCall,
    PECDISPLAY_PARAMS params
)
/*++
RoutineDescription:
    This routine is a long function that is responsible for retrieving all the 
    paramter for a given function call, setting up the CallParameters structure
    and then call the execute routine to get the necessary results and status of 
    the operation.  It is then responsible for displaying the appropriate status
    and results if the function did not fail

    This routine is a fairly long, complex routine to do a simple task.  It may
    be broken down in future versions to simplify some of the complexity.
--*/
{
    EXTCALL_PARAMS    CallParameters;
    EXTCALL_STATUS    CallStatus;

    DLGBOX_STATUS     iDlgStatus;
    BOOL              ExecuteStatus;
    PBUFFER_DISPLAY   pBufferDisplay;
    PCHAR             pCopyBuffer;
    PCHAR             endp;
    UINT              DlgBoxNumber;
    BOOL              List2Alloc;
    BOOL              MakeListAlloc;
    BOOL              BreakListAlloc;

    HID_DEVICE        readDevice, writeDevice;
    BOOL              status;

    /*
    // ExecuteAndDisplayOutput needless to say, consists of two parts: 
    //    Executing and Displaying output.  The first section involves the
    //     execution phase where all parameters are filled in if necessary
    //     and ECDisp_Execute is called
    */

    if (IS_NOT_IMPLEMENTED(iFuncCall)) 
    {
        OUTSTRING(hOutputWindow, "Function not yet implemented");
        return;
    }

    /*
    // Check first to see if this is a HID_CLEAR_REPORT command.  If it is
    //    all we need to do is get the report buffer that is checked and
    //    then call the clear buffer command
    */

    if (HID_CLEAR_REPORT == iFuncCall) 
    {
        SELECT_ON_REPORT_TYPE(params -> ReportType,
                              pInputDisplay,
                              pOutputDisplay,
                              pFeatureDisplay,
                              pBufferDisplay);

        BufferDisplay_ClearBuffer(pBufferDisplay);
        return;
    }

    /*
    // Need to perform the following steps in order to get the parameters for
    //    our call and then execute the call:
    //      1) Get any additional parameters not supplied by the above dialog
    //           procedure.  This occurs for such functions as:
    //                  HIDP_SET_BUTTONS
    //                  HIDP_SET_DATA
    //                  HIDP_SET_USAGES
    //                  HIDP_SET_USAGE_VALUE
    //                  HIDP_SET_SCALED_USAGE_VALUE
    //                  HIDP_SET_USAGE_VALUE_ARRAY
    //                  HIDP_UNSET_BUTTONS
    //                  HIDP_UNSET_USAGES
    //          For these functions, a separate dialog box must be called
    //
    //      2) Fill in the common parameters from the passed in params struct
    //
    */

    /*
    // Step 1: We're storing the values retrieved by these additional dialog
    //          box in the params struct since we may actually be passed in
    //          these values in the future instead of getting them here.  Hence,
    //          we won't break any of the code that follows the switch statement
    */

    switch (iFuncCall) 
    {
    case HIDP_SET_BUTTONS:
    case HIDP_SET_USAGES:
    case HIDP_UNSET_BUTTONS:
    case HIDP_UNSET_USAGES:

        switch (iFuncCall) 
        {
        case HIDP_SET_BUTTONS:
            DlgBoxNumber = IDD_SET_BUTTONS;
            break;

        case HIDP_SET_USAGES:
            DlgBoxNumber = IDD_SET_USAGES;
            break;

        case HIDP_UNSET_BUTTONS:
            DlgBoxNumber = IDD_UNSET_BUTTONS;
            break;

        case HIDP_UNSET_USAGES:
            DlgBoxNumber = IDD_UNSET_USAGES;
            break;
        }

        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(DlgBoxNumber),
                                                    GetParent(hOutputWindow),
                                                    bSetUsagesDlgProc,
                                                    (LPARAM) params);
        /*                      
        // If the above call returns 1, then the dialog box routine
        //     successfully acquired a string from the user and put the
        //     pointer to it in params -> szListString.
        //     Now we need to convert the string to a usage list
        */

        if (DLGBOX_OK != iDlgStatus) 
            return;

        ExecuteStatus = ConvertStringToUsageList(params -> szListString,
                                                 &params -> UsageList,
                                                 &params -> ListLength);
        free(params -> szListString);

        if (!ExecuteStatus) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Error getting usage list");
            return;
        }
        break;

    case HIDP_GET_EXTENDED_ATTRIBUTES:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_GET_EXT_ATTRIB),
                                                    GetParent(hOutputWindow),
                                                    bGetIndexedDlgProc,
                                                    (LPARAM) params);

        if (DLGBOX_OK != iDlgStatus) 
            return;

        params -> Index = strtoul(params -> szListString, &endp, 10);
        
        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid index value");

            free(params -> szListString);
            free(params -> szListString2);                            
            return;
        }
        
        free(params -> szListString);
        params -> ListLength = strtoul(params -> szListString2, &endp, 10);

        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid buffer size");

            free(params -> szListString2);
            return;
        }
        free(params -> szListString2);
        break;

    case HIDD_GET_INDEXED_STRING:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_GET_INDEX_STRING),
                                                    GetParent(hOutputWindow),
                                                    bGetIndexedDlgProc,
                                                    (LPARAM) params);

        if (DLGBOX_OK != iDlgStatus) 
            return;

        params -> Index = strtoul(params -> szListString, &endp, 10);
        
        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid index value");

            free(params -> szListString);
            free(params -> szListString2);                            
            return;
        }
        
        free(params -> szListString);
        params -> ListLength = strtoul(params -> szListString2, &endp, 10);

        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid buffer size");
            free(params -> szListString2);
            return;
        }
        free(params -> szListString2);
        break;
        
    case HIDD_GET_MS_GENRE_DESCRIPTOR:
    case HIDD_GET_PHYSICAL_DESCRIPTOR:
    case HIDD_GET_MANUFACTURER_STRING:
    case HIDD_GET_PRODUCT_STRING:
    case HIDD_GET_SERIAL_NUMBER_STRING:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_SET_BUFFER_LENGTH),
                                                    GetParent(hOutputWindow),
                                                    bSetBufLenDlgProc,
                                                    (LPARAM) params);

        if (DLGBOX_OK != iDlgStatus) 
            return;

        params -> ListLength = strtoul(params -> szListString, &endp, 10);

        if ('\0' != *endp) 
        {
            free(params -> szListString);                
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid buffer length");
            return;
        }
        free(params -> szListString);
        break;

    case HIDD_SET_NUM_INPUT_BUFFERS:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_SET_INPUT_BUFFERS),
                                                    GetParent(hOutputWindow),
                                                    bSetInputBuffDlgProc,
                                                    (LPARAM) params);
        /*
        // If the above call returns 1, then the dialog box routine
        //     successfully acquired a string from the user and put the
        //     pointer to it in params -> szListString.
        //     Now we need to convert the string to a usage list
        */

        if (DLGBOX_OK != iDlgStatus) 
           return;

        params -> Value = strtoul(params -> szListString, &endp, 10);

        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid value specified");

            free(params -> szListString);
            return;
        }
        free(params -> szListString);
        break;

    case HIDP_SET_DATA:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_SET_DATA),
                                                    GetParent(hOutputWindow),
                                                    bSetDataDlgProc,
                                                    (LPARAM) params);

        if (DLGBOX_OK != iDlgStatus) 
            return;

        break;

    case HIDP_SET_SCALED_USAGE_VALUE:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_SET_SCALED_VALUE),
                                                    GetParent(hOutputWindow),
                                                    bSetValueDlgProc,
                                                    (LPARAM) params);
        /*
        // If the above call returns DLGBOX_OK, then the dialog box routine
        //     successfully acquired a string from the user and put the
        //     pointer to it in params -> szListString.
        //     Now we need to convert the string to a usage list
        */

        if (DLGBOX_OK != iDlgStatus) 
            return;

        params -> ScaledValue = strtol(params -> szListString, &endp, 10);

        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid scaled usage value");

            free(params -> szListString);
            return;
        }

        free(params -> szListString);
        break;

    case HIDP_SET_USAGE_VALUE:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_SET_USAGE_VALUE),
                                                    GetParent(hOutputWindow),
                                                    bSetValueDlgProc,
                                                    (LPARAM) params);
        /*
        // If the above call returns 1, then the dialog box routine
        //     successfully acquired a string from the user and put the
        //     pointer to it in params -> szListString.
        //     Now we need to convert the string to a usage list
        */

        if (DLGBOX_OK != iDlgStatus) 
           return;

        params -> Value = strtoul(params -> szListString, &endp, 10);
        
        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid usage value");

            free(params -> szListString);
            return;
        }
        free(params -> szListString);
        break;


    case HIDP_SET_USAGE_VALUE_ARRAY:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_SET_USAGE_VALUE_ARRAY),
                                                    GetParent(hOutputWindow),
                                                    bSetValueDlgProc,
                                                    (LPARAM) params);

        /*
        // If the above call returns 1, then the dialog box routine
        //     successfully acquired a string from the user and put the
        //     pointer to it in params -> szListString.
        //     Now we need to convert the string to a usage list
        */

        if (DLGBOX_OK != iDlgStatus) 
            return;

        ExecuteStatus = ConvertStringToUlongList(params -> szListString,
                                                 &params -> pValueList,
                                                 &params -> ListLength);
        free(params -> szListString);

        if (!ExecuteStatus) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Error getting list of values");
            return;
        }
        break;

    case HIDP_USAGE_LIST_DIFFERENCE:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_USAGE_LIST_DIFFERENCE),
                                                    GetParent(hOutputWindow),
                                                    bGetUsageDiffDlgProc,
                                                    (LPARAM) params);

        if (DLGBOX_OK != iDlgStatus) 
        {
            return;
        }

        ExecuteStatus = Strings_StringToUnsignedList(params -> szListString,
                                                     sizeof(USAGE),
                                                     16,
                                                     (PCHAR *) &params -> UsageList,
                                                     &params -> ListLength);

        if (!ExecuteStatus) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Error getting list of values");

            free(params -> szListString);
            free(params -> szListString2);
            return;
        }

        ExecuteStatus = Strings_StringToUnsignedList(params -> szListString2,
                                                     sizeof(USAGE),
                                                     16, 
                                                     (PCHAR *) &params -> UsageList2,
                                                     &params -> ListLength2);

        if (!ExecuteStatus) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Error getting list of values");

            free(params -> szListString);
            free(params -> szListString2);
            free(params -> UsageList);
            return;
        }

        free(params -> szListString);
        free(params -> szListString2);
        break;
    }

    /*
    // Step 2: Extract the common parameters.  It's probably easier
    //    to simply fill in the spots in call parameters whether they are used
    //    or not instead of filling in only those that are relevant to a given
    //    function.  The details of some function relevant parameters are 
    //    handled after this.
    */

    CallParameters.DeviceHandle   = pDevice -> HidDevice;
    CallParameters.ReportType     = params -> ReportType;
    CallParameters.Ppd            = pDevice -> Ppd;
    CallParameters.UsagePage      = params -> UsagePage;
    CallParameters.Usage          = params -> Usage;
    CallParameters.LinkCollection = params -> LinkCollection;
    CallParameters.ReportID       = params -> ReportID;
    CallParameters.List           = NULL;
    CallParameters.List2          = NULL;
    CallParameters.MakeList       = NULL;
    CallParameters.BreakList      = NULL;
    CallParameters.ListLength     = 0;

    List2Alloc     = FALSE;
    MakeListAlloc  = FALSE;
    BreakListAlloc = FALSE;

    /*
    // Step 3: Now we'll deal with those functions that require a report buffer of some kind
    //    which means we'll copy the current buffer of the selected reported
    //    type
    */

    switch (iFuncCall) 
    {
    case HID_READ_REPORT:

        memcpy(&readDevice, pDevice, sizeof(HID_DEVICE));

        status = OpenHidDevice(pDevice -> DevicePath,
                               TRUE,
                               FALSE,
                               FALSE,
                               FALSE,
                               FALSE,
                               &readDevice);
        
        if (!status) 
        {
            OUTSTRING(hOutputWindow, "Unable to open device for reading");
        }
        
        CallParameters.DeviceHandle  = readDevice.HidDevice;
        CallParameters.ReportType   = HidP_Input;
        CallParameters.ReportBuffer = readDevice.InputReportBuffer;
        CallParameters.ReportLength = readDevice.Caps.InputReportByteLength;
        break;

    case HID_WRITE_REPORT:
        memcpy(&writeDevice, pDevice, sizeof(HID_DEVICE));

        status = OpenHidDevice(pDevice -> DevicePath,
                               TRUE,
                               FALSE,
                               FALSE,
                               FALSE,
                               FALSE,
                               &writeDevice);
                               
        if (!status) 
        {
            OUTSTRING(hOutputWindow, "Unable to open device for writing");
        }
        
        BufferDisplay_CopyCurrentBuffer(pOutputDisplay,
                                        writeDevice.OutputReportBuffer);

        CallParameters.DeviceHandle  = writeDevice.HidDevice;
        CallParameters.ReportType    = HidP_Output;
        CallParameters.ReportBuffer  = writeDevice.OutputReportBuffer;
        CallParameters.ReportLength  = writeDevice.Caps.OutputReportByteLength;
        break;

    case HIDD_GET_INPUT_REPORT:
        CallParameters.ReportType   = HidP_Input;
        CallParameters.ReportBuffer = pDevice -> InputReportBuffer;
        CallParameters.ReportLength = pDevice -> Caps.InputReportByteLength;
        break;

    case HIDD_GET_FEATURE:
        CallParameters.ReportType   = HidP_Feature;
        CallParameters.ReportBuffer = pDevice -> FeatureReportBuffer;
        CallParameters.ReportLength = pDevice -> Caps.FeatureReportByteLength;
        break;

    case HIDD_GET_INDEXED_STRING:
    case HIDP_GET_EXTENDED_ATTRIBUTES:
        CallParameters.Index = params -> Index;
        CallParameters.ListLength  = params -> ListLength;
        break;

    case HIDD_SET_OUTPUT_REPORT:
        CallParameters.ReportType = HidP_Output;
        BufferDisplay_CopyCurrentBuffer(pOutputDisplay,
                                        pDevice -> OutputReportBuffer);
        CallParameters.ReportLength = BufferDisplay_GetBufferSize(pOutputDisplay);
        CallParameters.ReportBuffer = pDevice -> OutputReportBuffer;
        break;

    case HIDD_SET_FEATURE:
       CallParameters.ReportType = HidP_Feature;
       BufferDisplay_CopyCurrentBuffer(pFeatureDisplay,
                                       pDevice -> FeatureReportBuffer);
       CallParameters.ReportLength = BufferDisplay_GetBufferSize(pFeatureDisplay);
       CallParameters.ReportBuffer = pDevice -> FeatureReportBuffer;
       break;

    case HIDP_GET_BUTTONS:
    case HIDP_GET_BUTTONS_EX:
    case HIDP_GET_DATA:
    case HIDP_GET_SCALED_USAGE_VALUE:
    case HIDP_GET_USAGES:
    case HIDP_GET_USAGES_EX:
    case HIDP_GET_USAGE_VALUE:
    case HIDP_GET_USAGE_VALUE_ARRAY:
    case HIDP_INITIALIZE_REPORT_FOR_ID:
    case HIDP_SET_BUTTONS:
    case HIDP_SET_DATA:
    case HIDP_SET_SCALED_USAGE_VALUE:
    case HIDP_SET_USAGES:
    case HIDP_SET_USAGE_VALUE:
    case HIDP_SET_USAGE_VALUE_ARRAY:
    case HIDP_UNSET_BUTTONS:
    case HIDP_UNSET_USAGES:
        
        switch (CallParameters.ReportType) 
        {
        case HidP_Input:
            pBufferDisplay = pInputDisplay;
            pCopyBuffer    = pDevice -> InputReportBuffer;
            break;

        case HidP_Output:
            pBufferDisplay = pOutputDisplay;
            pCopyBuffer    = pDevice -> OutputReportBuffer;
            break;

        case HidP_Feature:
            pBufferDisplay = pFeatureDisplay;
            pCopyBuffer    = pDevice -> FeatureReportBuffer;
            break;

        }
        BufferDisplay_CopyCurrentBuffer(pBufferDisplay,
                                        pCopyBuffer);

        CallParameters.ReportLength = BufferDisplay_GetBufferSize(pBufferDisplay);
        CallParameters.ReportBuffer = pCopyBuffer;
        break;

    default:
        CallParameters.ReportLength = 0;
        CallParameters.ReportBuffer = NULL;
    }

    /*
    // Now, we need to deal with those functions which have a List that is 
    //   used for either retrieving or gathering data.  There are two different
    //   cases.  The first involves the user inputting a buffer and the system 
    //   performing some action on the buffer, such as SetButtons.  We'll also 
    //   the other functions that require one of the union fields to be set.
    //   
    */

    /*
    // The second case is where data is retrieved for the device.  In this case,
    //     all we do is specify either the number of elements need for the buffer,
    //     the execute routine will worry about allocating the correct amount of
    //     space for those elements.  Remember, however, that if the Execute routine
    //     allocates space, we need to free it up.
    */

    /*
    // Then there's the third case UsageListDifference which truly changes
    //   everything.  We've got to determine the size of the resulting lists
    //   is the MaxSize of the other two lists.  Plus, we need to insure that 
    //   our buffers are 00 terminated if they are less than the max size, ie
    //   there not the same size as the larger buffer.  This may require
    //   reallocation of the block.
    */

    switch (iFuncCall) 
    {
    /*
    // First Case functions
    */

    case HIDP_SET_DATA:
        CallParameters.List       = (PVOID) params -> pDataList;
        CallParameters.ListLength = params -> ListLength;
        break;

    case HIDP_SET_BUTTONS:
    case HIDP_UNSET_BUTTONS:
    case HIDP_SET_USAGES:
    case HIDP_UNSET_USAGES:
        CallParameters.List       = (PVOID) params -> UsageList;
        CallParameters.ListLength = params -> ListLength;
        break;

    case HIDP_SET_USAGE_VALUE_ARRAY:
        CallParameters.List       = (PVOID) params -> pValueList;
        CallParameters.ListLength = params -> ListLength;
        break;

    /*
    // Second Case functions
    */

    case HIDP_GET_BUTTON_CAPS:
    case HIDP_GET_SPECIFIC_BUTTON_CAPS:
        SELECT_ON_REPORT_TYPE(CallParameters.ReportType,
                              pDevice -> Caps.NumberInputButtonCaps,
                              pDevice -> Caps.NumberOutputButtonCaps,
                              pDevice -> Caps.NumberFeatureButtonCaps,
                              CallParameters.ListLength);
        break;

    case HIDP_GET_LINK_COLL_NODES:
        CallParameters.ListLength = pDevice -> Caps.NumberLinkCollectionNodes;
        break;

    case HIDD_GET_MS_GENRE_DESCRIPTOR:
    case HIDD_GET_PHYSICAL_DESCRIPTOR:
    case HIDD_GET_MANUFACTURER_STRING:
    case HIDD_GET_PRODUCT_STRING:
    case HIDD_GET_SERIAL_NUMBER_STRING:
        CallParameters.ListLength = params -> ListLength;
        break;

    case HIDP_GET_VALUE_CAPS:
    case HIDP_GET_SPECIFIC_VALUE_CAPS:
        SELECT_ON_REPORT_TYPE(CallParameters.ReportType,
                              pDevice -> Caps.NumberInputValueCaps,
                              pDevice -> Caps.NumberOutputValueCaps,
                              pDevice -> Caps.NumberFeatureValueCaps,
                              CallParameters.ListLength);

    case HIDD_GET_FREE_PREPARSED_DATA:
        CallParameters.ppPd = &CallParameters.Ppd;
        break;

    case HIDP_SET_SCALED_USAGE_VALUE:
        CallParameters.ScaledValue = params -> ScaledValue;
        break;

    case HIDP_SET_USAGE_VALUE:
    case HIDD_SET_NUM_INPUT_BUFFERS:
        CallParameters.Value = params -> Value;
        break;

    /*
    // That third case
    */

    case HIDP_USAGE_LIST_DIFFERENCE:
        CallParameters.ListLength = max(params -> ListLength,
                                        params -> ListLength2);

        CallParameters.List  = params -> UsageList;
        CallParameters.List2 = params -> UsageList2;

        if (CallParameters.ListLength > params -> ListLength) 
        {
            CallParameters.List = (PUSAGE) realloc(params -> UsageList,
                                                   (params -> ListLength+1) * sizeof(USAGE));

            if (NULL == CallParameters.List) 
            {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Error allocating memory");

                free(params -> UsageList);
                free(params -> UsageList2);

                return;
            }

            *(((PUSAGE) CallParameters.List) + CallParameters.ListLength - 1) = 0;
        }
        else if (CallParameters.ListLength > params -> ListLength2) 
        {
            CallParameters.List2 = (PUSAGE) realloc(params -> UsageList2,
                                                   (params -> ListLength+1) * sizeof(USAGE));

            if (NULL == CallParameters.List2) 
            {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Error allocating memory");

                free(params -> UsageList);
                free(params -> UsageList2);
                return;
            }

            *(((PUSAGE) CallParameters.List2) + CallParameters.ListLength - 1) = 0;
        }
        List2Alloc = TRUE;
        MakeListAlloc = TRUE;
        BreakListAlloc = TRUE;
        break;
    }

    /*
    // Params are now set up and ready to go, let's execute
    */

    if (HIDD_GET_FREE_PREPARSED_DATA == iFuncCall) 
    {
        ExecuteStatus = ECDisp_Execute(HIDD_GET_PREPARSED_DATA,
                                       &CallParameters,
                                       &CallStatus);

        if (!ExecuteStatus)
        {
            OUTSTRING(hOutputWindow, "Unknown error: Couldn't execute function");
            return;
        }

        DISPLAY_HIDD_STATUS(hOutputWindow, 
                            "HidD_GetPreparsedData",
                            CallStatus);

        if (!CallStatus.IsHidError)
        {
            ExecuteStatus = ECDisp_Execute(HIDD_FREE_PREPARSED_DATA,
                                           &CallParameters,
                                           &CallStatus);

            OUTSTRING(hOutputWindow, "=======================");
            
            if (!ExecuteStatus) 
            {
                OUTSTRING(hOutputWindow, "Unknown error: Couldn't execute function");
                return;
            }

            DISPLAY_HIDD_STATUS(hOutputWindow, 
                                "HidD_FreePreparsedData",
                                CallStatus);
        }
    }
    else
    {
        if ((HID_READ_REPORT == iFuncCall || HID_WRITE_REPORT == iFuncCall) &&
            (!status)) 
        {
            //
            // Indicate there was an error so we don't display anything further
            //
        
            CallStatus.IsHidError = TRUE;
        }
        else 
        {    
            ExecuteStatus = ECDisp_Execute(iFuncCall,
                                           &CallParameters,
                                           &CallStatus);

            if (!ExecuteStatus) 
            {
                OUTSTRING(hOutputWindow, "Unknown error: Couldn't execute function");
                return;
            }

            if (IS_HIDD_FUNCTION(iFuncCall) || IS_HID_FUNCTION(iFuncCall)) 
            {
                DISPLAY_HIDD_STATUS(hOutputWindow, 
                                    GET_FUNCTION_NAME(iFuncCall),
                                    CallStatus);

            }
            else 
            {
                DISPLAY_HIDP_STATUS(hOutputWindow,
                                    GET_FUNCTION_NAME(iFuncCall),
                                    CallStatus);
            }
        }            
    }

    /*
    // Display the other results only if there wasn't a HID error
    */

    if (!CallStatus.IsHidError || (HIDP_STATUS_NULL == CallStatus.HidErrorCode)) 
    {
        OUTSTRING(hOutputWindow, "=======================");

        /*
        // Now that general status information has been displayed, we need to
        //   display the info for the parts that are dependent on the function being
        //   called
        */
    
        ECDisp_DisplayOutput(hOutputWindow,
                            iFuncCall,
                            &CallParameters);
    }

    if (CallParameters.List != NULL) 
    {
        free(CallParameters.List);
    }

    if (List2Alloc && CallParameters.List2 != NULL) 
    {
        free(CallParameters.List2);
    }

    if (MakeListAlloc && CallParameters.MakeList != NULL) 
    {
        free(CallParameters.MakeList);
    }

    if (BreakListAlloc && CallParameters.BreakList != NULL)
    {
        free(CallParameters.BreakList);
    }

    return;
}

VOID
BuildReportIDList(
    IN  PHIDP_BUTTON_CAPS  phidButtonCaps,
    IN  USHORT             nButtonCaps,
    IN  PHIDP_VALUE_CAPS   phidValueCaps,
    IN  USHORT             nValueCaps,
    OUT PUCHAR            *ppReportIDList,
    OUT INT               *nReportIDs
)
/*++
RoutineDescription:
    This routine builds a list of report IDs that are listed in the passed in set
    of ButtonCaps and ValueCaps structure.  It allocates a buffer to store all
    the ReportIDs, if it can.  Otherwise the buffer is returned as NULL.

    Currently, this routine has no purpose in the HClient program. It was written
    for some purpose which never materialized but was left in because it might be
    useful in the future.
--*/
{    
    INT               nAllocatedIDs;
    INT               nFoundIDs;
    INT               nWalkCount;
    USHORT            usIndex;
    BOOL              fIDFound;
    UCHAR             *pucBuffer;
    UCHAR             *pucOldBuffer;
    UCHAR             *pucWalk;
    UCHAR             ucReportID;
    PHIDP_BUTTON_CAPS pButtonWalk;
    PHIDP_VALUE_CAPS  pValueWalk;

    /*
    // Initialize the output parameters in case there is some sort of failure
    */

    *nReportIDs = 0;
    *ppReportIDList = NULL;

    if (0 == nButtonCaps && 0 == nValueCaps)
        return;

    /*
    // Initialize the beginning array size to 2 report IDs and alloc space
    // for those IDs.  If we need to add more report IDs we allocate more
    // space
    */

    nAllocatedIDs = 2;
    nFoundIDs = 0;
    pButtonWalk = phidButtonCaps;
    pValueWalk = phidValueCaps;
                                              
    pucBuffer = (UCHAR *) malloc(sizeof(UCHAR) * nAllocatedIDs);
    if (NULL == pucBuffer) 
        return;

    /*
    // Beginning with the button caps and then going to the value caps do the
    // following
    //
    // 1) Take the report ID and search the array of report IDs looking for 
    //       an existing report ID and add to the array if not there.  
    //
    // 2) Add the report ID to the array in sorted order that way we sort the
    //      array at any time.  
    // 
    // 3) Must also realloc the array if we run out of array space
    */

    for (usIndex = 0; usIndex < nButtonCaps; usIndex++, pButtonWalk++) 
    {
        ucReportID = pButtonWalk -> ReportID;
        
        pucWalk = pucBuffer;
        nWalkCount = 0;
        fIDFound = FALSE;

        while (!fIDFound && nWalkCount < nFoundIDs) 
        {
            if (*pucWalk == ucReportID) 
            {
                fIDFound = TRUE;
            }
            else if (ucReportID > *pucWalk) 
            {
                pucWalk++;
                nWalkCount++;
            }
        }

        if (!fIDFound) 
        {
            if (nFoundIDs == nAllocatedIDs) 
            {
                nAllocatedIDs *= 2;
                pucOldBuffer = pucBuffer;

                pucBuffer = (UCHAR *) realloc(pucBuffer, sizeof(UCHAR) * nAllocatedIDs);

                if (NULL == pucBuffer) 
                {
                    free(pucOldBuffer);
                    return;
                }
                pucWalk = pucBuffer + nWalkCount;
            }

            /*
            // At this point, pucWalk points to the smallest ReportID in the
            //   buffer that is greater than the ReportID we want to insert.
            //   We need to bump all reportIDs beginning at pucWalk up one 
            //   spot and insert the new ReportID at pucWalk
            */

            memmove (pucWalk+1, pucWalk, (nFoundIDs - nWalkCount) * sizeof(UCHAR));
            *pucWalk = ucReportID;
            nFoundIDs++;
        }
    }

    *ppReportIDList = pucBuffer;
    *nReportIDs = nFoundIDs;
    
    return;
}

LRESULT CALLBACK
bSetUsagesDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    {
    case WM_INITDIALOG:
        
        pParams = (PECDISPLAY_PARAMS) lParam;

        SetDlgItemIntHex(hDlg, 
                         IDC_USAGE_PAGE, 
                         pParams -> UsagePage,
                         2);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:
            StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_USAGE_LIST));

            if (StringLength > 0) 
            {
                pParams -> szListString = (PCHAR) malloc(StringLength+1);
                if (NULL == pParams -> szListString) 
                {
                    ECDISP_ERROR(hDlg, "Error allocating memory");
                    RetValue = DLGBOX_ERROR;
                }
                else
                {
                    GetWindowText(GetDlgItem(hDlg, IDC_USAGE_LIST),
                                  pParams -> szListString,
                                  StringLength+1);

                    RetValue = DLGBOX_OK;
                }
            }
            else 
            {
                pParams -> szListString = NULL;
                RetValue = DLGBOX_CANCEL;
            }

            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bSetValueDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    {
    case WM_INITDIALOG:

        pParams = (PECDISPLAY_PARAMS) lParam;

        SetDlgItemIntHex(hDlg, 
                         IDC_USAGE_PAGE, 
                         pParams -> UsagePage,
                         sizeof(USAGE));

        SetDlgItemIntHex(hDlg,
                         IDC_USAGE,
                         pParams -> Usage,
                         sizeof(USAGE));
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:
            StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_VALUE));

            if (StringLength > 0) 
            {
                pParams -> szListString = (PCHAR) malloc(StringLength+1);
                if (NULL == pParams -> szListString) 
                {
                    ECDISP_ERROR(hDlg, "Error allocating memory");

                    RetValue = DLGBOX_ERROR;
                }
                else 
                {
                    GetWindowText(GetDlgItem(hDlg, IDC_VALUE),
                                  pParams -> szListString,
                                  StringLength+1);

                    RetValue = DLGBOX_OK;
                }
            }
            else
            {
                pParams -> szListString = NULL;
                RetValue = DLGBOX_CANCEL;
            }

            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bSetInputBuffDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    {
    case WM_INITDIALOG:
        pParams = (PECDISPLAY_PARAMS) lParam;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:
            StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_INPUT_BUFFERS));

            if (StringLength > 0) 
            {
                pParams -> szListString = (PCHAR) malloc(StringLength+1);

                if (NULL == pParams -> szListString) 
                {
                    ECDISP_ERROR(hDlg, "Error allocating memory");

                    RetValue = DLGBOX_ERROR;
                }
                else 
                {
                    GetWindowText(GetDlgItem(hDlg, IDC_INPUT_BUFFERS),
                                  pParams -> szListString,
                                  StringLength+1);

                    RetValue = DLGBOX_OK;
                }
            }
            else 
            {
                pParams -> szListString = NULL;
                RetValue = DLGBOX_CANCEL;
            }

            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}


LRESULT CALLBACK
bSetDataDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static CHAR               DataString[1024];
    static PECDISPLAY_PARAMS  pParams;
           UINT               IndexValue;
           ULONG              Value;
           BOOL               lpTranslated;
           DLGBOX_STATUS      RetValue;
           PCHAR              endp;
           INT                ListBoxStatus;
           PHIDP_DATA         DataList;
           PHIDP_DATA         CurrData;
           ULONG              DataListLength;
           ULONG              Index;

    switch (message)
    {
    case WM_INITDIALOG:

        pParams = (PECDISPLAY_PARAMS) lParam;
        SendMessage(GetDlgItem(hDlg, IDC_VALUE),
                    EM_SETLIMITTEXT,
                    (WPARAM) 1024,
                    0);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDC_ADD_DATA:
            IndexValue = GetDlgItemInt(hDlg,
                                       IDC_INDEX,
                                       &lpTranslated,
                                       FALSE);
            if (!lpTranslated) 
            {
                ECDISP_ERROR(hDlg,
                           "Invalid index value: must be unsigned integer");
                break;
            }
            
            if (0 == GetWindowText(GetDlgItem(hDlg, IDC_VALUE), 
                                   DataString, 1023)) 
            {                                          
                ECDISP_ERROR(hDlg, "Invalid data value");
                break;
            }

            CharUpperBuff(DataString, lstrlen(DataString));

            if (0 == lstrcmp(DataString, "TRUE"))
            {
                Value = 1;
            }
            else if (0 == lstrcmp(DataString, "FALSE")) 
            {
                Value = 0;
            }
            else 
            {
                Value = strtoul(DataString, &endp, 10);
                if (*endp != '\0') 
                {
                    ECDISP_ERROR(hDlg, "Invalid data value");
                    break;
                }
            }
            wsprintf(DataString, 
                     SETDATA_LISTBOX_FORMAT, 
                     IndexValue,
                     Value);

            ListBoxStatus = (INT) SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                              LB_ADDSTRING,
                                              0,
                                              (LPARAM) DataString);

            if (CB_ERR == ListBoxStatus || CB_ERRSPACE == ListBoxStatus) 
            {
                ECDISP_ERROR(hDlg, "Error adding string to data list");
                break;
            }
            break;

        case IDC_REMOVE_DATA:
            SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                        LB_DELETESTRING,
                        SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                    LB_GETCURSEL,
                                    0, 0),
                        0);
            break;

        case IDOK:
            DataListLength = (ULONG) SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                                 LB_GETCOUNT,
                                                 0, 0);

            if (0 != DataListLength)
            {
                DataList = malloc(DataListLength * sizeof(HIDP_DATA));
                if (NULL == DataList) 
                {
                    ECDISP_ERROR(hDlg, "Error allocating memory");

                    DataListLength = 0;
                    RetValue = DLGBOX_CANCEL;
                    break;
                }
                
                for (Index = 0, CurrData = DataList; Index < DataListLength; Index++, CurrData++) 
                {
                    SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                LB_GETTEXT,
                                Index,
                                (LPARAM) DataString);

                    sscanf(DataString, 
                           SETDATA_LISTBOX_FORMAT,
                           &IndexValue,
                           &Value);

                    CurrData -> DataIndex = (USHORT) IndexValue;
                    CurrData -> RawValue = Value;
                }
                RetValue = DLGBOX_OK;
            }
            else 
            {
                DataList = NULL;
                RetValue = DLGBOX_CANCEL;
            }

            pParams -> pDataList = DataList;
            pParams -> ListLength = DataListLength;
            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bSetBufLenDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    { 
   case WM_INITDIALOG:

        pParams = (PECDISPLAY_PARAMS) lParam;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:
            StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_BUFFER_LENGTH));

            if (StringLength > 0) 
            {
                pParams -> szListString = (PCHAR) malloc(StringLength+1);
                if (NULL == pParams -> szListString) 
                {
                    ECDISP_ERROR(hDlg, "Error allocating memory");

                    RetValue = DLGBOX_ERROR;

                }
                else 
                {
                    GetWindowText(GetDlgItem(hDlg, IDC_BUFFER_LENGTH),
                                  pParams -> szListString,
                                  StringLength+1);

                    RetValue = DLGBOX_OK;
                }
            }
            else
            {
                pParams -> szListString = NULL;
                RetValue = DLGBOX_CANCEL;
            }

            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bSetInputBuffersDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    {
    case WM_INITDIALOG:

        pParams = (PECDISPLAY_PARAMS) lParam;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:
            StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_INPUT_BUFFERS));

            if (StringLength > 0) 
            {
                pParams -> szListString = (PCHAR) malloc(StringLength+1);

                if (NULL == pParams -> szListString) 
                {
                    ECDISP_ERROR(hDlg, "Error allocating memory");
                    RetValue = DLGBOX_ERROR;
                }
                else 
                {
                    GetWindowText(GetDlgItem(hDlg, IDC_INPUT_BUFFERS),
                                  pParams -> szListString,
                                  StringLength+1
                                 );
                    RetValue = DLGBOX_OK;
                }
            }
            else
            {
                pParams -> szListString = NULL;
                RetValue = DLGBOX_CANCEL;
            }

            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bGetIndexedDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           INT                StringLength2;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    {
    case WM_INITDIALOG:

        pParams = (PECDISPLAY_PARAMS) lParam;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:       
            StringLength  = GetWindowTextLength(GetDlgItem(hDlg, IDC_INDEX));
            StringLength2 = GetWindowTextLength(GetDlgItem(hDlg, IDC_BUFFER_LENGTH));

            if (StringLength <= 0 || StringLength2 <= 0) 
            {
                pParams -> szListString = NULL;
                pParams -> szListString2 = NULL;
                RetValue = DLGBOX_CANCEL;
                EndDialog(hDlg, DLGBOX_CANCEL);
            }

            pParams -> szListString = (PCHAR) malloc(StringLength+1);
            pParams -> szListString2 = (PCHAR) malloc(StringLength2+1);

            if (NULL == pParams -> szListString || NULL == pParams -> szListString2) 
            {
                   ECDISP_ERROR(hDlg, "Error allocating memory");

                   if (NULL != pParams -> szListString) 
                       free(pParams -> szListString);

                   if (NULL != pParams -> szListString2) 
                       free(pParams -> szListString2);

                   RetValue = DLGBOX_ERROR;
            }
            else 
            {
                GetWindowText(GetDlgItem(hDlg, IDC_INDEX),
                              pParams -> szListString,
                              StringLength+1);

                GetWindowText(GetDlgItem(hDlg, IDC_BUFFER_LENGTH),
                              pParams -> szListString2,
                              StringLength2+1);

                RetValue = DLGBOX_OK;
            }
            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bGetUsageDiffDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           INT                StringLength2;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    {
    case WM_INITDIALOG:

        pParams = (PECDISPLAY_PARAMS) lParam;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:       
            StringLength  = GetWindowTextLength(GetDlgItem(hDlg, IDC_USAGE_LIST1));
            StringLength2 = GetWindowTextLength(GetDlgItem(hDlg, IDC_USAGE_LIST2));

            if (StringLength <= 0) 
            {
                pParams -> szListString = NULL;
            }
            else 
            {
                pParams -> szListString = (PCHAR) malloc(StringLength+1);
                if (NULL == pParams -> szListString) 
                {
                    ECDISP_ERROR(hDlg,
                                 "Error allocating memory");

                    EndDialog(hDlg, DLGBOX_ERROR);
                    break;
                }
            }

            if (StringLength2 <= 0) 
            {
                pParams -> szListString = NULL;
            }
            else 
            {
                pParams -> szListString2 = (PCHAR) malloc(StringLength2+1);
                if (NULL == pParams -> szListString2) 
                {
                    ECDISP_ERROR(hDlg,
                                 "Error allocating memory");

                    if (NULL != pParams -> szListString)
                    {
                        free(pParams -> szListString);
                    }
                    EndDialog(hDlg, DLGBOX_ERROR);
                    break;
                }
            }

            GetWindowText(GetDlgItem(hDlg, IDC_USAGE_LIST1),
                          pParams -> szListString,
                          StringLength+1);

            GetWindowText(GetDlgItem(hDlg, IDC_USAGE_LIST2),
                          pParams -> szListString2,
                          StringLength2+1);

            RetValue = DLGBOX_OK;

            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

BOOL
ConvertStringToUsageList(
    IN OUT PCHAR   InString,
    OUT    PUSAGE  *UsageList,
    OUT    PULONG  nUsages
)
/*++
RoutineDescription:
    This routine converts a string of values into a string of usages which are
    currently 2 byte values.  We use base 16 to specify that the usages should 
    be expressed as hexidecimal numbers.
--*/
{
    return (Strings_StringToUnsignedList(InString,
                                         sizeof(ULONG),
                                         16,
                                         (PCHAR *) UsageList,
                                         nUsages));
}

BOOL
ConvertStringToUlongList(
    IN OUT PCHAR   InString,
    OUT    PULONG  *UlongList,
    OUT    PULONG  nUlongs
)
/*++
RoutineDescription
    This routine converts a string of values into a string of ulongs which are
    currently 2 byte values.  It requires that the numbers in the string be in
    base 10
--*/
{
    return (Strings_StringToUnsignedList(InString,
                                         sizeof(ULONG),
                                         10,
                                         (PCHAR *) UlongList,
                                         nUlongs));
}

BOOL
SetDlgItemIntHex(
   HWND hDlg, 
   INT nIDDlgItem, 
   UINT uValue, 
   INT nBytes
)
{
    char szTempBuffer[] = "0x00000000";
    int  iEndIndex, iWidth;

    assert (1 == nBytes || 2 == nBytes || 4 == nBytes);

    /*
    // Determine the width necessary to store the value
    */

    iWidth = ((int) floor(log(uValue)/log(16))) + 1;
    
    assert (iWidth <= 2*nBytes);

    iEndIndex = 2+2*nBytes;

    wsprintf(&(szTempBuffer[iEndIndex-iWidth]), "%X", uValue);

    SetDlgItemText(hDlg, nIDDlgItem, szTempBuffer);

    return (TRUE);
}

VOID
ECDisp_MakeGUIDString(
    IN  GUID guid, 
    OUT CHAR szString[]
)
{
    char szCharString[18];
    int i;

    for (i = 0; i < 8; i++) 
    {
        wsprintf(&(szCharString[i]), "%x", guid.Data4[i]);
    }
    
    wsprintf(szString, "%x-%x%x-%s", guid.Data1, guid.Data2, guid.Data3, szCharString);
    return;
}

PCHAR
ECDisp_GetHidAppStatusString(
    NTSTATUS StatusCode
)
{
    static CHAR hidString[128];

    switch (StatusCode) 
    {
    case HIDP_STATUS_SUCCESS:
        return ("Success");

    case HIDP_STATUS_NULL:
        return ("Status NULL");

    case HIDP_STATUS_INVALID_PREPARSED_DATA:
        return ("Invalid Preparsed Data");

    case HIDP_STATUS_INVALID_REPORT_TYPE:
        return ("Invalid Report Type");

    case HIDP_STATUS_INVALID_REPORT_LENGTH:
        return ("Invalid Report Length");

    case HIDP_STATUS_USAGE_NOT_FOUND:
        return ("Usage not found");

    case HIDP_STATUS_VALUE_OUT_OF_RANGE:
        return ("Value out of range");

    case HIDP_STATUS_BAD_LOG_PHY_VALUES:
        return ("Bad logical physical values");

    case HIDP_STATUS_BUFFER_TOO_SMALL:
        return ("Buffer too small");

    case HIDP_STATUS_INTERNAL_ERROR:
        return ("Internal error");

    case HIDP_STATUS_I8242_TRANS_UNKNOWN:
        return ("I8242 Translation unknown");

    case HIDP_STATUS_INCOMPATIBLE_REPORT_ID:
        return ("Incompatible report ID");

    case HIDP_STATUS_NOT_VALUE_ARRAY:
        return ("Not value array");

    case HIDP_STATUS_IS_VALUE_ARRAY:
        return ("Is value array");

    case HIDP_STATUS_DATA_INDEX_NOT_FOUND:   
        return ("Data index not found");

    case HIDP_STATUS_DATA_INDEX_OUT_OF_RANGE:
        return ("Data index out of range");

    case HIDP_STATUS_BUTTON_NOT_PRESSED:     
        return ("Button not pressed");

    case HIDP_STATUS_REPORT_DOES_NOT_EXIST:
        return ("Report does not exist");

    case HIDP_STATUS_NOT_IMPLEMENTED:        
        return ("Not implemented");

    default:
        sprintf(hidString, "Unknown HID Status error: 0x%x", StatusCode);
        return (&hidString[0]);
    }
}             

BOOL
ECDisp_ConvertUlongListToValueList(
    IN  PULONG  UlongList,
    IN  ULONG   nUlongs,
    IN  USHORT  BitSize,
    IN  USHORT  ReportCount,
    OUT PCHAR   *ValueList,
    OUT PULONG  ValueListSize
)
/*++
RoutineDescription:
    This routine takes a list of ULong values and formats a value list that is 
    used as input to HidP_SetUsageValueArray.  Unfortunately, this HidP function
    requires the caller to format the input buffer which means taking each of
    the values in Ulong, truncating their values to meet bit size and then set 
    those bits at the appropriate spot in the buffer.  That is the purpose of
    this function

    The function will return TRUE if everything succeeded, FALSE otherwise.
--*/
{

    ULONG       ulMask;
    PCHAR       List;
    INT         iByteIndex;
    INT         iByteOffset;
    ULONG       UlongIndex;
    ULONG       ListSize;
    USHORT      BitsToAdd;
    USHORT      nBits;
    ULONG       ulValue;
    UCHAR       LowByte;

    *ValueList = NULL;
    *ValueListSize = 0;
    
    //
    // Do some parameter validation...ReportCount should never be zero.
    //

    if (0 == ReportCount)
    {
        SetLastError(ERROR_INVALID_PARAMETER);

        return (FALSE);
    }

    //
    // Check the number of ulongs passed in is actually less than or equal
    //  to the report count and if not, use only the first ReportCount
    //  number of ULongs.
    //

    if (nUlongs > ReportCount)
    {
        nUlongs = ReportCount;
    }

    /*
    // Allocate our buffer for the value list and return FALSE if it couldn't
    //   be done
    */

    ListSize = ROUND_TO_NEAREST_BYTE(BitSize * ReportCount);
    List = (PCHAR) malloc(ListSize);

    if (NULL == List) 
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (FALSE);
    }

    /*
    // Initialize the buffer to all zeroes
    */

    memset(List, 0x00, ListSize);

    /*
    // Buffer has been allocated let's convert those values
    */

    /*
    // Determine the mask that will be used to retrieve the cared about bits
    //   of our value
    */

    ulMask = (sizeof(ULONG)*8 == BitSize) ? ULONG_MAX : (1 << BitSize)-1;

    /*
    // Initialize the iByteIndex and iByteOffset fields before entering the
    //    conversion loop.
    */

    iByteIndex = 0;
    iByteOffset = 0;

    /*
    // This is the main conversion loop.  It performs the following steps on
    //    each Ulong in the ulong list
    //      1) Sets BitsToAdd = BitSize
    //      2) Gets the ulValue and the masks off the upper bits that we don't
    //           care about.
    //      3) Determines how many bits can fit at the current byte index based
    //          on the current byte offset and the number of bits left to add
    //      4) Retrieve those bits, shift them to the correct position and 
    //            use bitwise or to get the correct values in the buffer
    //      5) Increment the byte index and set our new byte offset
    //      6) Shift our Ulong value right to get rid of least significant bits
    //           that have already been added
    //      7) Repeat through step 3 until no more bits to add
    */

    for (UlongIndex = 0; UlongIndex < nUlongs; UlongIndex++) 
    {    
        BitsToAdd = BitSize;

        ulValue = *(UlongList + UlongIndex) & ulMask;

        while (BitsToAdd > 0) 
        {
            nBits = min (8 - iByteOffset, BitsToAdd);
            
            LowByte = (UCHAR) (ulValue & 0xFF);
            
            LowByte = LowByte << iByteOffset;

            *(List+iByteIndex) |= LowByte;

            iByteIndex = (iByteOffset+nBits) >= 8 ? iByteIndex+1 : iByteIndex;
            iByteOffset = (iByteOffset + nBits) % 8;

            BitsToAdd -= nBits;

            ulValue = ulValue >> nBits;
        }
    }
        
    *ValueList = List;
    *ValueListSize = ListSize;

    return (TRUE);
}

PCHAR
ResolveFunctionName(
    INT Index
)
{
    PCHAR   FuncName;

    if (IS_HIDD_FUNCTION(Index) || IS_HID_FUNCTION(Index))
    {
        FuncName = DeviceCalls[Index-1].szFunctionName;
    }
    else
    {
        FuncName = PpdCalls[Index-HID_DEVCALLS-1].szFunctionName;
    }

    return (FuncName);
}

VOID
DisplayExtendedAttributes(
    IN  HWND                OutputWindow,
    IN  PHIDP_UNKNOWN_TOKEN UnknownList,
    IN  ULONG               UnknownListLength
)
{
    PHIDP_UNKNOWN_TOKEN current;
    ULONG               index;

    wsprintf(szTempBuffer, "Number of attributes: %d", UnknownListLength);
    OUTSTRING(OutputWindow, szTempBuffer);
    
    current = UnknownList;
    for (index = 0; index < UnknownListLength; index++) 
    {
       wsprintf(szTempBuffer,
                 "Token %d: %d  BitField: 0x%X", 
                 current -> Token,
                 current -> BitField);
            
        OUTSTRING(OutputWindow, szTempBuffer);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\toshiba\zrnpch6.h ===
//***************************************************************************
//	Zoran download code header
//
//***************************************************************************

// ===========================================================================
//                  Dolby AC-3 Decod-Out
// ===========================================================================
UCHAR ZRN_AC3_DEC[] = {
	0x91, 0x3A, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x93, 0x0D, 0x03, 0xFB, 0x00, 0x00, 0x00, 0x01,
	0x3A, 0x65, 0x82, 0x89, 0x00, 0x00, 0x00, 0x90,
	0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x03, 0xB8,
	0x00, 0x00, 0x00, 0x01, 0x38, 0x00, 0x00, 0x01,
	0x32, 0x1D, 0x03, 0xD2, 0x00, 0x00, 0xB0, 0x3C,
	0x00, 0x00, 0xB8, 0x0C, 0x38, 0x0D, 0x00, 0x19,
	0x32, 0x10, 0x0F, 0xF5, 0x3B, 0x80, 0x00, 0x00,
	0x34, 0x3D, 0x03, 0xFB, 0x00, 0x03, 0xCD, 0x82,
	0x38, 0x8D, 0x00, 0x00, 0x3A, 0x80, 0x03, 0xB8,
	0x3A, 0xAD, 0x00, 0x0E, 0x00, 0x03, 0xF0, 0x85,
	0x1B, 0x5B, 0xCD, 0x86, 0x1B, 0x93, 0xF0, 0x85,
	0x3B, 0x80, 0x00, 0x01, 0x36, 0xDE, 0x00, 0x42,
	0x00, 0x03, 0xC0, 0xB6, 0x30, 0x3D, 0x03, 0xFB,
	0x2F, 0x2F, 0x00, 0x21, 0x00, 0x00, 0x00, 0x2F,
	0x00, 0x2F, 0x21, 0x00, 0x00, 0x03, 0x04, 0x01,
	0x09, 0x0A, 0x07, 0x0E, 0x0F, 0x10, 0x0D, 0x11,
	0x34, 0x20, 0x0F, 0xFA, 0x30, 0x2D, 0x03, 0xEE,
	0x00, 0x50, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0x6B,
	0x34, 0x00, 0x0D, 0xC6, 0x2C, 0x30, 0x00, 0x07,
	0x38, 0x00, 0x00, 0x02, 0x32, 0x1D, 0x03, 0xEE,
	0x34, 0x0D, 0x03, 0xD4, 0x2C, 0x10, 0x00, 0x40,
	0x30, 0x0D, 0x03, 0xD4, 0x2C, 0xB0, 0x00, 0x01,
	0x3C, 0x6D, 0x00, 0x32, 0x00, 0x00, 0xCC, 0x4B,
	0x00, 0x00, 0xCC, 0x0B, 0x3A, 0xDE, 0x16, 0x12,
	0x3A, 0xFD, 0x00, 0x2B, 0x00, 0x03, 0xEB, 0xC1,
	0x38, 0x00, 0x05, 0x40, 0x32, 0x1D, 0x03, 0xD4,
	0x38, 0xBD, 0x00, 0x13, 0x38, 0xCD, 0x03, 0xF0,
	0x3E, 0x00, 0x00, 0x03, 0x00, 0x06, 0x56, 0xE3,
	0x3A, 0xDD, 0x00, 0x36, 0x38, 0x00, 0x00, 0x02,
	0x32, 0x10, 0x0F, 0xFA, 0x2C, 0xB0, 0x00, 0x02,
	0x3C, 0x1D, 0x00, 0x6F, 0x34, 0x20, 0x0F, 0xC5,
	0x2C, 0x80, 0x00, 0x07, 0x2E, 0xB0, 0x00, 0x00,
	0x38, 0x8E, 0x2B, 0xE2, 0x00, 0x03, 0xC0, 0x98,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x60, 0x02,
	0x34, 0x00, 0x0F, 0xE5, 0x2C, 0x00, 0x03, 0x03,
	0x2E, 0x30, 0x00, 0x00, 0x18, 0x80, 0x00, 0x00,
	0x34, 0x20, 0x0F, 0xE5, 0x2C, 0x80, 0x0C, 0x00,
	0x2E, 0xB0, 0x00, 0x02, 0x18, 0x10, 0x00, 0x00,
	0x00, 0x00, 0xD0, 0x02, 0x3C, 0x1D, 0x00, 0x4D,
	0x38, 0x0D, 0x03, 0x63, 0x32, 0x10, 0x0F, 0xF9,
	0x38, 0x0D, 0x03, 0x67, 0x32, 0x10, 0x0F, 0xF9,
	0x00, 0x00, 0xC0, 0x02, 0x00, 0x00, 0xB0, 0x42,
	0x30, 0x20, 0x0D, 0xF1, 0x38, 0x3E, 0x2B, 0xD1,
	0x38, 0x4E, 0x2B, 0xA9, 0x3A, 0xDE, 0x16, 0x68,
	0x3A, 0xFD, 0x00, 0x53, 0x00, 0x03, 0xEB, 0xC1,
	0xB0, 0x00, 0x00, 0x00, 0x30, 0x0D, 0x03, 0xCC,
	0x30, 0x0D, 0x03, 0xC9, 0x30, 0x0D, 0x03, 0xCA,
	0x00, 0x03, 0xC8, 0x76, 0x32, 0x0D, 0x03, 0xF6,
	0x32, 0x1D, 0x03, 0xE5, 0x32, 0x1D, 0x03, 0xE6,
	0x34, 0x00, 0x0F, 0xC5, 0x2C, 0x00, 0x08, 0x00,
	0x3C, 0x1D, 0x00, 0x68, 0x38, 0x00, 0x00, 0x00,
	0x32, 0x10, 0x0F, 0x8D, 0x38, 0x0D, 0x03, 0x14,
	0x32, 0x1D, 0x03, 0xCF, 0x38, 0x0D, 0x02, 0xB9,
	0x32, 0x10, 0x0F, 0xF8, 0x00, 0x00, 0xB8, 0x0C,
	0x00, 0x00, 0xB0, 0x3C, 0x38, 0x00, 0x03, 0x80,
	0x32, 0x10, 0x0D, 0xCB, 0x3A, 0xDD, 0x01, 0x5D,
	0x38, 0x00, 0x00, 0x02, 0x32, 0x10, 0x0F, 0xFA,
	0x3C, 0x6D, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x00,
	0x38, 0x00, 0x00, 0x00, 0x32, 0x10, 0x0D, 0xCA,
	0x34, 0x00, 0x0D, 0xCA, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x6D, 0x00, 0xBA, 0x00, 0x00, 0xBC, 0x4B,
	0x00, 0x00, 0xBC, 0x0B, 0x38, 0x00, 0x00, 0x01,
	0x32, 0x10, 0x0D, 0xC4, 0x34, 0x2D, 0x03, 0xEE,
	0x2C, 0xB0, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0x7D,
	0x34, 0x7D, 0x03, 0xCC, 0x00, 0x00, 0xB3, 0x87,
	0x3A, 0xDD, 0x00, 0x81, 0x00, 0x00, 0xC3, 0x87,
	0x30, 0x7D, 0x03, 0xCC, 0x3A, 0xDD, 0x02, 0x26,
	0x3A, 0xFD, 0x00, 0x81, 0x00, 0x03, 0xEB, 0xC1,
	0x3A, 0xDE, 0x19, 0x7E, 0x3A, 0xFD, 0x00, 0x84,
	0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDE, 0x18, 0xE5,
	0x3A, 0xFD, 0x00, 0x87, 0x00, 0x03, 0xEB, 0xC1,
	0x3A, 0xDD, 0x01, 0xFB, 0x3A, 0xFD, 0x00, 0x8A,
	0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDD, 0x01, 0xE7,
	0x3A, 0xFD, 0x00, 0x8D, 0x00, 0x03, 0xEB, 0xC1,
	0x3A, 0xDD, 0x01, 0x60, 0x3A, 0xFD, 0x00, 0x90,
	0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDD, 0x01, 0x88,
	0x3A, 0xFD, 0x00, 0x93, 0x00, 0x03, 0xEB, 0xC1,
	0x3A, 0xDD, 0x01, 0x9C, 0x3A, 0xFD, 0x00, 0x96,
	0x00, 0x03, 0xEB, 0xC1, 0x34, 0x00, 0x0D, 0xC4,
	0x00, 0x40, 0x00, 0x00, 0x3C, 0x6D, 0x00, 0xF5,
	0x34, 0x10, 0x0D, 0xCB, 0x34, 0x00, 0x0D, 0xC9,
	0x34, 0x80, 0x0D, 0xC1, 0x35, 0x00, 0x0D, 0xFD,
	0x32, 0x10, 0x0D, 0xDA, 0xB0, 0x50, 0x60, 0x00,
	0x30, 0x80, 0x0D, 0xD6, 0x14, 0x90, 0x00, 0x00,
	0x00, 0x03, 0xC0, 0x18, 0x30, 0x20, 0x0D, 0xC9,
	0x00, 0x00, 0x80, 0x00, 0x30, 0x80, 0x0D, 0xC8,
	0x39, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x06,
	0x32, 0x10, 0x0D, 0xD5, 0x34, 0x00, 0x0F, 0x88,
	0x32, 0x10, 0x0D, 0xD7, 0x34, 0x00, 0x0D, 0xFD,
	0x32, 0x10, 0x0D, 0xD8, 0x34, 0x00, 0x0D, 0xF2,
	0x32, 0x10, 0x0D, 0xD9, 0xB0, 0x03, 0xD0, 0x81,
	0x38, 0x80, 0x0D, 0xD5, 0x36, 0xDE, 0x00, 0x41,
	0x3A, 0xFD, 0x00, 0xB3, 0x00, 0x03, 0xEB, 0xC1,
	0x00, 0x40, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0xF5,
	0x30, 0x00, 0x0D, 0xC7, 0x34, 0x20, 0x0D, 0xC4,
	0x3A, 0xDD, 0x00, 0xF5, 0x00, 0x00, 0xB0, 0x82,
	0x30, 0x20, 0x0D, 0xC4, 0x3A, 0xDE, 0x18, 0xE5,
	0x3A, 0xFD, 0x00, 0xBD, 0x00, 0x03, 0xEB, 0xC1,
	0x3A, 0xDD, 0x01, 0xE7, 0x3A, 0xFD, 0x00, 0xC0,
	0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDD, 0x01, 0x60,
	0x3A, 0xFD, 0x00, 0xC3, 0x00, 0x03, 0xEB, 0xC1,
	0x34, 0x00, 0x0D, 0xCA, 0x38, 0x10, 0x00, 0x02,
	0x04, 0x40, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0xE3,
	0x34, 0x00, 0x0D, 0xCA, 0x38, 0x10, 0x00, 0x05,
	0x04, 0x40, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0xF5,
	0x00, 0x00, 0x00, 0x00, 0x2C, 0x30, 0x00, 0x01,
	0x3C, 0x1D, 0x00, 0xD8, 0x38, 0x23, 0x00, 0x00,
	0x34, 0x3D, 0x03, 0xCC, 0x00, 0x00, 0xD4, 0x43,
	0x3C, 0x6D, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00,
	0x2C, 0x30, 0x00, 0x04, 0x3C, 0x1D, 0x00, 0xD8,
	0x00, 0x00, 0x00, 0x00, 0x38, 0x22, 0x55, 0x55,
	0x38, 0x22, 0xAA, 0xAB, 0x00, 0x00, 0xD3, 0x83,
	0x3C, 0x1D, 0x00, 0xF5, 0x34, 0x00, 0x0D, 0xCB,
	0x44, 0x00, 0x00, 0x00, 0x34, 0x10, 0x0F, 0x8D,
	0xA2, 0x00, 0x00, 0x00, 0x3C, 0x4D, 0x00, 0xF5,
	0x00, 0x00, 0x00, 0x00, 0x32, 0x10, 0x0F, 0x8D,
	0x3A, 0xDD, 0x00, 0xF5, 0x00, 0x00, 0xC0, 0x3C,
	0x34, 0x00, 0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x6D, 0x00, 0xF5, 0x34, 0x00, 0x0D, 0xC8,
	0x32, 0x10, 0x0D, 0xD6, 0x34, 0x00, 0x0D, 0xC9,
	0x32, 0x10, 0x0D, 0xDA, 0x34, 0x00, 0x0D, 0xC7,
	0x38, 0x10, 0x00, 0x02, 0x38, 0x80, 0x0D, 0xD5,
	0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 0x00, 0xF0,
	0x00, 0x03, 0xEB, 0xC1, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x1D, 0x00, 0xF5, 0x34, 0x20, 0x0D, 0xC4,
	0x00, 0x00, 0xB0, 0xC2, 0x30, 0x20, 0x0D, 0xC4,
	0x38, 0x00, 0x00, 0x0F, 0x32, 0x10, 0x0D, 0xDB,
	0x34, 0x00, 0x0D, 0xFD, 0x32, 0x10, 0x0D, 0xDE,
	0x34, 0x00, 0x0D, 0xF2, 0x32, 0x10, 0x0D, 0xDF,
	0x34, 0x00, 0x0D, 0xF3, 0x2C, 0x00, 0x00, 0x0F,
	0x32, 0x10, 0x0D, 0xE8, 0x38, 0x00, 0x00, 0x00,
	0x32, 0x10, 0x0D, 0xE9, 0x38, 0x00, 0x0D, 0xCF,
	0x32, 0x10, 0x0D, 0xE0, 0x34, 0x00, 0x0D, 0xFE,
	0x32, 0x10, 0x0D, 0xE1, 0x34, 0x00, 0x0D, 0xFF,
	0x32, 0x10, 0x0D, 0xE2, 0x34, 0x00, 0x0D, 0xF1,
	0x32, 0x10, 0x0D, 0xE3, 0x34, 0x00, 0x0F, 0x88,
	0x32, 0x10, 0x0D, 0xDD, 0x34, 0x00, 0x0D, 0xC1,
	0x32, 0x10, 0x0D, 0xDC, 0x34, 0x00, 0x0D, 0xF4,
	0x32, 0x10, 0x0D, 0xE7, 0x34, 0x00, 0x0D, 0xCA,
	0x32, 0x10, 0x0D, 0xE4, 0x34, 0x00, 0x0D, 0xCC,
	0x32, 0x10, 0x0D, 0xE5, 0x34, 0x00, 0x0D, 0xCD,
	0x32, 0x10, 0x0D, 0xE6, 0x34, 0x20, 0x0D, 0xF1,
	0x2C, 0x80, 0x3F, 0x02, 0x30, 0x20, 0x0D, 0xE3,
	0x38, 0x0E, 0x2B, 0xA9, 0x32, 0x10, 0x0D, 0xE0,
	0x38, 0x0E, 0x2B, 0xAF, 0x32, 0x10, 0x0D, 0xE1,
	0x38, 0x0E, 0x2B, 0xB5, 0x32, 0x10, 0x0D, 0xE2,
	0x34, 0x00, 0x0D, 0xE8, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x6D, 0x01, 0x23, 0x34, 0x00, 0x0D, 0xC4,
	0x38, 0x80, 0x0D, 0xDB, 0x06, 0x00, 0x00, 0x00,
	0x34, 0x7D, 0x03, 0xCC, 0x00, 0x00, 0xD3, 0x87,
	0x3C, 0x1D, 0x01, 0x2A, 0x34, 0x10, 0x0F, 0xFC,
	0x00, 0x48, 0x00, 0x00, 0x3C, 0x6D, 0x01, 0x2C,
	0x00, 0x00, 0x00, 0x00, 0x38, 0x10, 0x00, 0x03,
	0x38, 0x0F, 0xFF, 0xFF, 0x3A, 0xDD, 0x03, 0x77,
	0x3A, 0xFD, 0x01, 0x2F, 0x00, 0x03, 0xEB, 0xC1,
	0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 0x01, 0x32,
	0x00, 0x03, 0xEB, 0xC1, 0x30, 0x00, 0x0D, 0xC5,
	0x3A, 0xDE, 0x19, 0x40, 0x3A, 0xFD, 0x01, 0x36,
	0x00, 0x03, 0xEB, 0xC1, 0x34, 0x00, 0x0D, 0xCA,
	0x2C, 0x30, 0x00, 0x05, 0x3C, 0x5D, 0x01, 0x3C,
	0x12, 0x03, 0xD0, 0x01, 0x30, 0x00, 0x0D, 0xCA,
	0x30, 0x10, 0x0D, 0xCA, 0x38, 0x00, 0x00, 0x08,
	0x32, 0x1D, 0x03, 0xD3, 0x34, 0x0D, 0x03, 0xEE,
	0x2C, 0x30, 0x00, 0x00, 0x3C, 0x1D, 0x01, 0x44,
	0x34, 0x00, 0x0D, 0xC6, 0x2C, 0x10, 0x05, 0x00,
	0x2C, 0x10, 0x00, 0x40, 0x34, 0x20, 0x0D, 0xC5,
	0x34, 0x10, 0x0D, 0xC4, 0x00, 0x4B, 0xD0, 0xC1,
	0x3C, 0x1D, 0x01, 0x4B, 0x0C, 0x50, 0x00, 0x00,
	0x18, 0x80, 0x00, 0x00, 0x2C, 0x10, 0x40, 0x00,
	0x32, 0x1D, 0x03, 0xD4, 0x38, 0x0D, 0x03, 0xD3,
	0x32, 0x10, 0x0F, 0xFB, 0x34, 0x00, 0x0F, 0xC5,
	0x2C, 0x00, 0x10, 0x00, 0x3C, 0x1D, 0x01, 0x5D,
	0x34, 0x7D, 0x03, 0xCC, 0x00, 0x00, 0xD3, 0x47,
	0x3C, 0x1D, 0x01, 0x57, 0x00, 0x00, 0xC8, 0x4C,
	0x00, 0x00, 0xC0, 0xBC, 0x00, 0x00, 0xB0, 0xBC,
	0x34, 0x00, 0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x1D, 0x01, 0x5D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC0, 0xFC, 0x00, 0x00, 0xB0, 0xFC,
	0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00,
	0x3A, 0xDD, 0x01, 0x64, 0x34, 0x3D, 0x03, 0xD2,
	0x30, 0x0D, 0x03, 0xD2, 0x00, 0x58, 0x00, 0x00,
	0x3C, 0x1D, 0x01, 0x85, 0x34, 0x0D, 0x03, 0xCC,
	0x00, 0x00, 0xD3, 0xA1, 0x3C, 0x1D, 0x01, 0x85,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3B, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x36, 0x0D, 0x03, 0xF5, 0x00, 0x00, 0xD0, 0x20,
	0x00, 0x00, 0xB0, 0x20, 0x32, 0x0D, 0x03, 0xF5,
	0x3C, 0x6D, 0x01, 0x85, 0x3B, 0x80, 0x00, 0x01,
	0x00, 0x03, 0xCD, 0xA1, 0x00, 0x00, 0xD1, 0xE0,
	0x3C, 0x6D, 0x01, 0x79, 0x34, 0x5D, 0x03, 0xCC,
	0x00, 0x00, 0xC3, 0xC5, 0x00, 0x00, 0xB3, 0xC5,
	0x30, 0x5D, 0x03, 0xCC, 0x00, 0x00, 0xD1, 0xA0,
	0x3C, 0x6D, 0x01, 0x85, 0x2E, 0x2F, 0xFF, 0xFC,
	0x00, 0x03, 0xC8, 0x02, 0x2C, 0x8F, 0xFF, 0xF0,
	0x2E, 0xAF, 0xFF, 0xFC, 0x30, 0x2D, 0x03, 0xCE,
	0x3A, 0xDD, 0x01, 0x84, 0x36, 0x0D, 0x03, 0xF4,
	0x33, 0x6D, 0x03, 0xC9, 0x32, 0x0D, 0x03, 0xCA,
	0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x34, 0x5D, 0x03, 0xCC,
	0x00, 0x00, 0xD4, 0xC5, 0x3C, 0x1D, 0x01, 0x98,
	0x34, 0x0D, 0x03, 0xC7, 0x36, 0x0D, 0x03, 0xC8,
	0x2C, 0x00, 0xFF, 0xFF, 0x2E, 0x20, 0x00, 0x07,
	0x00, 0x03, 0xC8, 0x83, 0x2E, 0x20, 0x00, 0x01,
	0x00, 0x03, 0xC0, 0xE2, 0x2E, 0x2F, 0xFF, 0xFC,
	0x2E, 0x3F, 0xFF, 0xFF, 0x2E, 0x2F, 0xFF, 0xFA,
	0x3A, 0xDD, 0x01, 0x98, 0x00, 0x03, 0xC8, 0x76,
	0x32, 0x0D, 0x03, 0xF7, 0x00, 0x00, 0xC4, 0xC5,
	0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0xC4, 0x45,
	0x30, 0x5D, 0x03, 0xCC, 0xB0, 0x00, 0x00, 0x00,
	0x3A, 0xDD, 0x01, 0xA0, 0x36, 0x0D, 0x03, 0xF7,
	0x00, 0x03, 0xCD, 0xA1, 0x34, 0x1D, 0x03, 0xC9,
	0x36, 0x4D, 0x03, 0xCA, 0xB2, 0x00, 0x00, 0x00,
	0x34, 0x1D, 0x03, 0xCE, 0x2E, 0x6F, 0xFF, 0xEC,
	0xB2, 0x03, 0xD0, 0x42, 0x38, 0x38, 0x00, 0x00,
	0x3C, 0x5D, 0x01, 0xAC, 0x0A, 0x83, 0xC8, 0x02,
	0x2C, 0x2F, 0xFF, 0xFF, 0x2C, 0x2F, 0xFF, 0xFF,
	0x38, 0x37, 0xFF, 0xFF, 0x3C, 0x1D, 0x01, 0xB0,
	0x00, 0x00, 0x00, 0x00, 0x30, 0x2D, 0x03, 0xCD,
	0x30, 0x3D, 0x03, 0xCD, 0x34, 0x7D, 0x03, 0xCC,
	0x00, 0x00, 0xC3, 0x47, 0x30, 0x7D, 0x03, 0xCC,
	0x34, 0x30, 0x0F, 0xC5, 0x2C, 0xC0, 0x00, 0x40,
	0x3C, 0x1D, 0x01, 0xDE, 0x36, 0x4D, 0x03, 0xF7,
	0x00, 0x03, 0xCD, 0xA5, 0x00, 0x00, 0xD3, 0x87,
	0x3C, 0x1D, 0x01, 0xDE, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xD2, 0xC7, 0x3C, 0x1D, 0x01, 0xDE,
	0x34, 0x00, 0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x6D, 0x01, 0xDE, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xD3, 0xC7, 0x3C, 0x1D, 0x01, 0xDE,
	0x13, 0xFB, 0xD3, 0xC4, 0x2D, 0xCF, 0xFF, 0xEF,
	0x30, 0x7D, 0x03, 0xCC, 0x17, 0xE0, 0x00, 0x00,
	0x3C, 0x1D, 0x01, 0xDE, 0x34, 0x4D, 0x03, 0xCD,
	0x2D, 0x30, 0x01, 0xE0, 0x3C, 0x2D, 0x01, 0xD6,
	0x00, 0x00, 0x00, 0x00, 0x2D, 0x3F, 0xFB, 0x50,
	0x3C, 0x3D, 0x01, 0xDE, 0x34, 0x30, 0x0D, 0xCB,
	0x3A, 0x00, 0x05, 0xA0, 0x30, 0x3D, 0x03, 0xD1,
	0xA0, 0x48, 0x00, 0x00, 0x34, 0x5D, 0x03, 0xCC,
	0x3A, 0xDD, 0x01, 0xDC, 0x38, 0x0D, 0x03, 0x17,
	0x32, 0x1D, 0x03, 0xCF, 0x3A, 0x00, 0x05, 0xA0,
	0xB0, 0x48, 0x00, 0x00, 0x34, 0x00, 0x0D, 0xC1,
	0x32, 0x10, 0x0D, 0xC0, 0x34, 0x5D, 0x03, 0xCC,
	0x00, 0x00, 0xB4, 0x45, 0x00, 0x00, 0xB3, 0x45,
	0x30, 0x5D, 0x03, 0xCC, 0x34, 0x4D, 0x03, 0xCD,
	0x2F, 0x20, 0x00, 0x04, 0x2F, 0x3F, 0xFF, 0xFC,
	0xB6, 0xDB, 0xD0, 0x36, 0x30, 0x4D, 0x03, 0xD6,
	0x30, 0x3D, 0x03, 0xD5, 0x00, 0x03, 0xF0, 0x2D,
	0x00, 0x03, 0xC9, 0x76, 0x32, 0x4D, 0x03, 0xF7,
	0x34, 0x0D, 0x03, 0xCC, 0x00, 0x00, 0xD3, 0xA1,
	0x3C, 0x1D, 0x01, 0xED, 0x00, 0x00, 0x00, 0x00,
	0xB2, 0x48, 0x00, 0x00, 0x3A, 0x40, 0x00, 0xF0,
	0x34, 0x0D, 0x03, 0xC9, 0x36, 0x0D, 0x03, 0xCA,
	0xA2, 0x00, 0x00, 0x00, 0x32, 0x1D, 0x03, 0xC9,
	0x3B, 0x80, 0x00, 0x00, 0x32, 0x0D, 0x03, 0xCA,
	0x00, 0x03, 0xC8, 0x76, 0x32, 0x0D, 0x03, 0xF6,
	0x36, 0x0D, 0x03, 0xF7, 0x00, 0x03, 0xCD, 0xA1,
	0xA2, 0x03, 0xD0, 0x78, 0x00, 0x03, 0xF0, 0x2D,
	0x00, 0x03, 0xC8, 0x76, 0x32, 0x0D, 0x03, 0xF7,
	0x34, 0x00, 0x0F, 0xC5, 0x00, 0x00, 0xD1, 0x61,
	0x3C, 0x1D, 0x02, 0x23, 0x34, 0x7D, 0x03, 0xCC,
	0x00, 0x00, 0xD3, 0x87, 0x00, 0x00, 0xB3, 0x07,
	0x3C, 0x1D, 0x02, 0x0B, 0x34, 0x00, 0x0F, 0xFC,
	0x00, 0x00, 0xD0, 0x21, 0x3C, 0x1D, 0x02, 0x0B,
	0x34, 0x00, 0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x6D, 0x02, 0x0B, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x07,
	0x30, 0x7D, 0x03, 0xCC, 0x34, 0x0D, 0x03, 0xD8,
	0x2C, 0x00, 0x07, 0x00, 0x2E, 0x30, 0x00, 0x04,
	0x2C, 0x10, 0x00, 0x10, 0x32, 0x1D, 0x03, 0xE9,
	0x34, 0x00, 0x0D, 0xC1, 0x32, 0x1D, 0x03, 0xEC,
	0x34, 0x30, 0x0D, 0xCB, 0x30, 0x3D, 0x03, 0xEA,
	0x38, 0x20, 0x0B, 0xFC, 0xB6, 0x90, 0x00, 0x00,
	0x30, 0x2D, 0x03, 0xEB, 0x2E, 0xCF, 0xFA, 0x06,
	0x2E, 0xDA, 0xAA, 0xAB, 0x3B, 0x80, 0x00, 0x00,
	0x2C, 0xCF, 0xFF, 0xFE, 0x00, 0x00, 0xD0, 0x0F,
	0x3C, 0x1D, 0x02, 0x21, 0x38, 0x0D, 0x03, 0x7A,
	0x32, 0x10, 0x0F, 0xF9, 0x14, 0xD8, 0x00, 0x00,
	0x3B, 0x80, 0x00, 0x01, 0x30, 0x3D, 0x03, 0xED,
	0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x0F, 0x8D,
	0x00, 0x43, 0xC3, 0xC0, 0x3C, 0x4D, 0x02, 0x30,
	0x34, 0x10, 0x0D, 0xC2, 0x04, 0x08, 0x00, 0x00,
	0x3C, 0x6D, 0x02, 0x26, 0x38, 0x00, 0x00, 0x07,
	0x32, 0x10, 0x0D, 0xC6, 0x3A, 0xDD, 0x02, 0x91,
	0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x0D, 0xC0,
	0x3A, 0xDD, 0x02, 0xAE, 0x3A, 0xFD, 0x02, 0x34,
	0x00, 0x03, 0xEB, 0xC1, 0x2E, 0x0F, 0xFF, 0xF6,
	0x3C, 0x3D, 0x02, 0x3B, 0x38, 0x10, 0x00, 0x01,
	0x38, 0x20, 0x01, 0x18, 0x3A, 0xDD, 0x02, 0x91,
	0x30, 0x20, 0x0F, 0x8D, 0x00, 0x00, 0xC0, 0x3C,
	0x20, 0x40, 0x00, 0x00, 0x30, 0x00, 0x0D, 0xE1,
	0x34, 0x00, 0x0D, 0xC0, 0x32, 0x10, 0x0D, 0xDC,
	0x34, 0x00, 0x0F, 0x88, 0x32, 0x10, 0x0D, 0xDD,
	0x31, 0x60, 0x0D, 0xDE, 0x34, 0x00, 0x0D, 0xF2,
	0x32, 0x10, 0x0D, 0xDF, 0x38, 0x00, 0x00, 0x00,
	0x32, 0x10, 0x0D, 0xE0, 0x38, 0x80, 0x0D, 0xDB,
	0xB0, 0x03, 0xD2, 0x01, 0x3A, 0xDE, 0x19, 0x92,
	0x3A, 0xFD, 0x02, 0x4B, 0x00, 0x03, 0xEB, 0xC1,
	0x00, 0x43, 0xC5, 0x91, 0x34, 0x90, 0x0F, 0x87,
	0x3C, 0x6D, 0x02, 0x8E, 0x38, 0x00, 0x00, 0x01,
	0x32, 0x10, 0x0D, 0xC6, 0x30, 0x90, 0x0D, 0xC1,
	0x38, 0x00, 0x00, 0x05, 0x32, 0x10, 0x0D, 0xDB,
	0x30, 0x90, 0x0D, 0xDC, 0x34, 0x00, 0x0F, 0x88,
	0x32, 0x10, 0x0D, 0xDD, 0x31, 0x60, 0x0D, 0xDE,
	0x34, 0x00, 0x0D, 0xF2, 0x32, 0x10, 0x0D, 0xDF,
	0x38, 0x80, 0x0D, 0xDB, 0xB0, 0x03, 0xD0, 0x41,
	0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 0x02, 0x5E,
	0x00, 0x03, 0xEB, 0xC1, 0x39, 0x80, 0x00, 0x02,
	0x30, 0x00, 0x0D, 0xC6, 0x00, 0x43, 0x60, 0x02,
	0x3C, 0x6D, 0x02, 0x8B, 0x39, 0x80, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x60, 0x01,
	0x30, 0x20, 0x0D, 0xCB, 0x30, 0x10, 0x0D, 0xC9,
	0x39, 0x10, 0x00, 0x00, 0x39, 0x80, 0x00, 0x04,
	0x00, 0x02, 0xA0, 0x07, 0x30, 0x7D, 0x03, 0xD7,
	0x00, 0x00, 0x80, 0x00, 0x38, 0x9D, 0x03, 0xD8,
	0x3E, 0x00, 0x00, 0x04, 0x00, 0x06, 0x51, 0xCF,
	0x34, 0x00, 0x0D, 0xFD, 0x22, 0x13, 0xC5, 0x91,
	0x34, 0x90, 0x0D, 0xC1, 0x00, 0x03, 0xC0, 0x99,
	0x38, 0x15, 0x00, 0x00, 0x34, 0x20, 0x0D, 0xCB,
	0x42, 0x98, 0x80, 0x08, 0x2E, 0xC0, 0x00, 0x08,
	0x30, 0x90, 0x0D, 0xC0, 0x34, 0x00, 0x0D, 0xC1,
	0x3A, 0xDD, 0x02, 0xAE, 0x3A, 0xFD, 0x02, 0x7C,
	0x00, 0x03, 0xEB, 0xC1, 0xB0, 0xC0, 0x00, 0x00,
	0x2C, 0x30, 0x00, 0x04, 0x3C, 0x4D, 0x02, 0x84,
	0x30, 0x00, 0x0F, 0x8D, 0x38, 0x00, 0x00, 0x07,
	0x3A, 0xDD, 0x02, 0x91, 0x30, 0x00, 0x0D, 0xC6,
	0x00, 0x00, 0xC0, 0x3C, 0x3A, 0xDD, 0x02, 0x95,
	0x3A, 0xFD, 0x02, 0x87, 0x00, 0x03, 0xEB, 0xC1,
	0x39, 0x10, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x2D,
	0x31, 0x10, 0x0D, 0xC4, 0x30, 0xF0, 0x0D, 0xC3,
	0x3A, 0xDD, 0x02, 0x8F, 0x34, 0x00, 0x0D, 0xC1,
	0x32, 0x10, 0x0D, 0xC0, 0x30, 0x90, 0x0D, 0xC0,
	0x38, 0x00, 0x03, 0x80, 0x32, 0x10, 0x0D, 0xCB,
	0x39, 0x10, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x2D,
	0x38, 0x00, 0x00, 0x01, 0x32, 0x10, 0x0D, 0xC4,
	0x3A, 0xDD, 0x02, 0x98, 0x34, 0x3D, 0x03, 0xE3,
	0x34, 0x4D, 0x03, 0xE4, 0x2E, 0xF0, 0x00, 0x04,
	0x2C, 0xC0, 0xFF, 0x00, 0x2F, 0x3F, 0xFF, 0xF4,
	0x19, 0x18, 0x00, 0x00, 0x34, 0x4D, 0x03, 0xE5,
	0xA8, 0xD8, 0x00, 0x00, 0x14, 0xDB, 0xC5, 0x91,
	0x2E, 0xFF, 0xFF, 0xFF, 0x00, 0x03, 0xC0, 0xD9,
	0x34, 0x9D, 0x03, 0xCB, 0x34, 0x40, 0x0D, 0xC1,
	0x00, 0x00, 0x80, 0x08, 0x00, 0x03, 0xC2, 0x43,
	0x04, 0xE0, 0x00, 0x00, 0x3C, 0x6D, 0x02, 0xAB,
	0x34, 0x5D, 0x03, 0xCC, 0x00, 0x00, 0xC4, 0xC5,
	0x00, 0x00, 0xB4, 0xC5, 0x00, 0x00, 0xB2, 0xC5,
	0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00,
	0x30, 0x5D, 0x03, 0xCC, 0x00, 0x00, 0xCC, 0x4B,
	0x00, 0x03, 0xC3, 0x81, 0x34, 0x20, 0x0F, 0x8D,
	0xB0, 0x40, 0xBC, 0x4B, 0x3C, 0x2D, 0x02, 0xB6,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC5, 0x81,
	0xA2, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x2D,
	0xA0, 0x90, 0x00, 0x00, 0xB0, 0x48, 0x00, 0x00,
	0x00, 0x00, 0xD4, 0xFA, 0x3C, 0x1D, 0x03, 0x5F,
	0x38, 0x3D, 0x03, 0xE0, 0x30, 0x30, 0x0F, 0x8F,
	0x00, 0x03, 0xEB, 0x01, 0x3B, 0x50, 0x00, 0x00,
	0x3B, 0x70, 0x00, 0x00, 0x00, 0x03, 0xCC, 0x04,
	0x30, 0x4D, 0x03, 0xDF, 0x2F, 0x3F, 0xFF, 0xFC,
	0x2D, 0x00, 0x07, 0xFF, 0x3C, 0x1D, 0x03, 0x5E,
	0x30, 0x40, 0x0F, 0x8E, 0x00, 0x03, 0xF0, 0x2C,
	0x2F, 0x0F, 0xFF, 0xF7, 0x30, 0x4D, 0x03, 0xC6,
	0x3A, 0xDD, 0x03, 0x5E, 0x38, 0x3D, 0x02, 0xCC,
	0x30, 0x30, 0x0F, 0xF8, 0x00, 0x03, 0xCC, 0x03,
	0x2C, 0xCF, 0x00, 0x00, 0x2C, 0xF2, 0x00, 0x00,
	0x38, 0x3D, 0x02, 0xE5, 0x30, 0x30, 0x0F, 0xF8,
	0x38, 0x30, 0x00, 0x01, 0x30, 0x3D, 0x03, 0xE8,
	0x3C, 0x1D, 0x02, 0xE5, 0x34, 0x3D, 0x03, 0xE5,
	0x30, 0x3D, 0x03, 0xE7, 0x2C, 0xE0, 0x00, 0x01,
	0x30, 0x3D, 0x03, 0xE7, 0x34, 0x40, 0x0F, 0x8E,
	0x00, 0x00, 0xD0, 0x04, 0x3C, 0x1D, 0x02, 0xDE,
	0x2F, 0x0F, 0xFF, 0xFC, 0x33, 0x8D, 0x03, 0xE8,
	0x2F, 0x00, 0x00, 0x02, 0x30, 0x4D, 0x03, 0xC6,
	0x3A, 0xDD, 0x03, 0x5E, 0x38, 0x3D, 0x02, 0xE2,
	0x30, 0x30, 0x0F, 0xF8, 0x3A, 0xDD, 0x03, 0x5F,
	0x38, 0x3D, 0x03, 0x11, 0x30, 0x30, 0x0F, 0xF8,
	0x00, 0x03, 0xE2, 0xC1, 0x00, 0x03, 0xEB, 0x01,
	0x3B, 0x50, 0x00, 0x00, 0x3B, 0x70, 0x00, 0x00,
	0x00, 0x03, 0xCC, 0x04, 0x34, 0x30, 0x0F, 0x8F,
	0x2C, 0xFD, 0x03, 0xE4, 0x3C, 0x5D, 0x03, 0x0D,
	0x12, 0xDB, 0xC0, 0xCB, 0x30, 0x30, 0x0F, 0x8F,
	0x38, 0x3D, 0x03, 0x11, 0x30, 0x30, 0x0F, 0xF8,
	0x34, 0x3D, 0x03, 0xE5, 0x00, 0x5B, 0xFD, 0x03,
	0x3C, 0x1D, 0x03, 0x01, 0x00, 0x03, 0xEC, 0x34,
	0x30, 0xED, 0x03, 0xCB, 0x34, 0x4D, 0x03, 0xE6,
	0x0D, 0x1B, 0xCC, 0x04, 0x2C, 0xCF, 0xF0, 0x00,
	0x2D, 0x00, 0x0F, 0xF0, 0x18, 0xE0, 0x00, 0x00,
	0x34, 0x3D, 0x03, 0xCF, 0x2C, 0xFD, 0x03, 0x26,
	0x3C, 0x6D, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xE1, 0x32, 0x00, 0x00, 0x70, 0x30,
	0x34, 0x3D, 0x03, 0xE2, 0x2E, 0xFF, 0xFF, 0xF4,
	0x34, 0x4D, 0x03, 0xE1, 0x2F, 0x30, 0x00, 0x04,
	0x19, 0x18, 0x00, 0x00, 0x30, 0x3D, 0x03, 0xC8,
	0x34, 0x3D, 0x03, 0xE1, 0x2E, 0xFF, 0xFF, 0xF0,
	0x34, 0x4D, 0x03, 0xE0, 0x19, 0x1B, 0xCC, 0x04,
	0x30, 0x3D, 0x03, 0xC7, 0x2D, 0x0F, 0xF0, 0x00,
	0x00, 0x03, 0xE1, 0x1C, 0x3A, 0xDD, 0x03, 0x5E,
	0x00, 0x03, 0xF0, 0x2C, 0x00, 0x03, 0xF0, 0x0B,
	0x36, 0xDD, 0x03, 0xCF, 0x00, 0x03, 0xEB, 0x01,
	0xB6, 0xDB, 0xD0, 0x35, 0x3A, 0xDD, 0x03, 0x2E,
	0x38, 0x4D, 0x03, 0x2E, 0x30, 0x4D, 0x03, 0xCF,
	0x38, 0x4D, 0x03, 0x19, 0x30, 0x4D, 0x03, 0xCF,
	0x00, 0x03, 0xC3, 0x84, 0x34, 0x30, 0x0D, 0xC0,
	0x04, 0xE3, 0xD0, 0x37, 0x3C, 0x6D, 0x03, 0x2F,
	0x34, 0x3D, 0x03, 0xE7, 0x00, 0x5B, 0xFD, 0x04,
	0x3C, 0x1D, 0x03, 0x23, 0x38, 0x3D, 0x03, 0x26,
	0x2F, 0x30, 0x00, 0x08, 0x00, 0x03, 0xCC, 0x04,
	0x2D, 0x10, 0x0F, 0xF0, 0x00, 0x03, 0xE1, 0x32,
	0x30, 0x3D, 0x03, 0xCF, 0x34, 0x3D, 0x03, 0xD1,
	0x14, 0xD8, 0x00, 0x00, 0x3C, 0x3D, 0x03, 0x3F,
	0x30, 0x3D, 0x03, 0xD1, 0x00, 0x03, 0xEC, 0x34,
	0x3A, 0xDD, 0x03, 0x3F, 0x38, 0x3D, 0x03, 0x2E,
	0x30, 0x3D, 0x03, 0xCF, 0x3B, 0x70, 0x00, 0x00,
	0x34, 0x3D, 0x03, 0xE7, 0x00, 0x5B, 0xFD, 0x03,
	0x3C, 0x1D, 0x03, 0x36, 0x00, 0x03, 0xCC, 0x04,
	0x2F, 0x3F, 0xFF, 0xF8, 0x3A, 0xDD, 0x03, 0x39,
	0x00, 0x03, 0xEC, 0x32, 0x2E, 0xF0, 0x00, 0x08,
	0x19, 0x1B, 0xCC, 0x04, 0x00, 0x04, 0x4C, 0xF4,
	0x34, 0x30, 0x0F, 0x8D, 0x14, 0xD8, 0x00, 0x00,
	0x3C, 0x3D, 0x03, 0x3F, 0x00, 0x00, 0x00, 0x00,
	0x30, 0x30, 0x0F, 0x8D, 0x00, 0x00, 0xB0, 0x3C,
	0x34, 0x3D, 0x03, 0xC6, 0x2E, 0xCF, 0xFF, 0xFE,
	0x2C, 0xF0, 0x00, 0x01, 0x3C, 0x3D, 0x03, 0x5D,
	0x30, 0x3D, 0x03, 0xC6, 0x34, 0x4D, 0x03, 0xE5,
	0x1B, 0x1B, 0xE1, 0x41, 0x30, 0x3D, 0x03, 0xE5,
	0x3C, 0x1D, 0x03, 0x5C, 0x38, 0x3D, 0x02, 0xB9,
	0x30, 0x30, 0x0F, 0xF8, 0x34, 0x3D, 0x03, 0xE8,
	0x17, 0x1B, 0xC0, 0xC5, 0x19, 0x2B, 0xC0, 0xDE,
	0x3C, 0x6D, 0x03, 0x53, 0x2D, 0x20, 0x00, 0x01,
	0x00, 0x02, 0xEC, 0x33, 0x2E, 0xFF, 0xFF, 0xF8,
	0x00, 0x01, 0x5C, 0x33, 0x39, 0xE0, 0x00, 0x01,
	0x34, 0x3D, 0x03, 0xCF, 0x2C, 0xFD, 0x03, 0x26,
	0x3C, 0x6D, 0x03, 0x59, 0x34, 0x3D, 0x03, 0xD1,
	0xB8, 0xD8, 0x90, 0x30, 0x00, 0x00, 0x80, 0x30,
	0x30, 0x3D, 0x03, 0xD1, 0x2F, 0x30, 0x00, 0x03,
	0x30, 0x4D, 0x03, 0xE6, 0x00, 0x03, 0xF0, 0x05,
	0x00, 0x03, 0xF0, 0x2C, 0x34, 0x40, 0x0F, 0xCD,
	0x00, 0x03, 0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D,
	0x3B, 0x80, 0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC,
	0x00, 0x03, 0xEB, 0x01, 0x3A, 0xDD, 0x03, 0x6D,
	0xB6, 0xDB, 0xD0, 0x35, 0x00, 0x06, 0x1F, 0x3B,
	0x00, 0x03, 0xEB, 0x01, 0x3B, 0x50, 0x00, 0x00,
	0x00, 0x07, 0x6E, 0xFC, 0x2E, 0xEF, 0xFF, 0xFF,
	0x2F, 0x2F, 0xFF, 0xFF, 0xA7, 0x23, 0xED, 0x7A,
	0x34, 0x30, 0x0F, 0xC8, 0x0C, 0xE0, 0xD0, 0x7C,
	0x3C, 0x6D, 0x03, 0x5E, 0xB6, 0xDB, 0xC1, 0x31,
	0x12, 0xDB, 0xF0, 0x2C, 0x3A, 0xDD, 0x03, 0x5F,
	0x30, 0x3D, 0x03, 0xD2, 0x34, 0x40, 0x0F, 0xCD,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3A, 0xDD, 0x03, 0x7D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x3A, 0xDD, 0x03, 0x63,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x34, 0x30, 0x0D, 0xF3, 0x00, 0x00, 0xD1, 0x03,
	0x3C, 0x1D, 0x03, 0xB5, 0x34, 0x2D, 0x03, 0xD8,
	0x2C, 0x80, 0x07, 0x00, 0x2C, 0xB0, 0x07, 0x00,
	0x3C, 0x6D, 0x03, 0xB5, 0x34, 0x2D, 0x03, 0xD7,
	0x2C, 0x80, 0x00, 0x07, 0x2C, 0xB0, 0x00, 0x02,
	0x3C, 0x5D, 0x03, 0xB5, 0x34, 0x3D, 0x03, 0xF2,
	0x00, 0x00, 0xD0, 0x03, 0x3C, 0x6D, 0x03, 0x94,
	0x38, 0x20, 0x0F, 0x3B, 0x30, 0x20, 0x0D, 0xE9,
	0x00, 0x00, 0xB0, 0x03, 0x30, 0x3D, 0x03, 0xF2,
	0x30, 0x3D, 0x03, 0xDE, 0x34, 0x2D, 0x03, 0xF1,
	0x30, 0x2D, 0x03, 0xDD, 0x34, 0x2D, 0x03, 0xF0,
	0x30, 0x2D, 0x03, 0xDC, 0x00, 0x03, 0xE0, 0x01,
	0x38, 0xB0, 0x0F, 0x3B, 0x3A, 0x80, 0x00, 0x12,
	0x3A, 0xAD, 0x03, 0x9A, 0xB6, 0xDB, 0xE0, 0x41,
	0x00, 0x03, 0xE0, 0xDA, 0x00, 0x03, 0xE0, 0xDA,
	0x38, 0xAD, 0x03, 0xDC, 0x38, 0xCD, 0x00, 0x16,
	0x3A, 0x80, 0x00, 0x03, 0x3A, 0xAD, 0x03, 0xB1,
	0x38, 0xB0, 0x0F, 0x3B, 0x3A, 0xDD, 0x03, 0xA3,
	0x00, 0x03, 0xF8, 0xA4, 0x00, 0x03, 0xCD, 0xA5,
	0x3A, 0xDD, 0x03, 0xA6, 0x00, 0x03, 0xF4, 0xA0,
	0x00, 0x03, 0xCD, 0xA1, 0x3A, 0x80, 0x00, 0x04,
	0x3A, 0xAD, 0x03, 0xB0, 0x38, 0x4F, 0xF0, 0x00,
	0x38, 0x70, 0x00, 0x08, 0x0B, 0xC8, 0x00, 0x00,
	0x0B, 0xC3, 0xC9, 0x45, 0x17, 0x2B, 0xC8, 0x43,
	0x2F, 0x7F, 0xFF, 0xF4, 0xBB, 0x6B, 0xC1, 0x5B,
	0x17, 0x18, 0x00, 0x00, 0x00, 0x01, 0xD6, 0x1B,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xD6, 0x1D,
	0x00, 0x03, 0xF0, 0x01, 0x00, 0x03, 0xF0, 0x00,
	0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x03, 0xF4,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x91, 0xA2, 0xB3, 0xC5, 0x01, 0x45, 0x67, 0xC0,
	0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00,
};

// ===========================================================================
// 		Dolby	AC-3	SP/DIF-Out
// ===========================================================================

UCHAR ZRN_AC3_SPD[] = {
	0x93, 0x0D, 0x03, 0xFB, 0x00, 0x00, 0x00, 0x01,
	0xAC, 0x76, 0x64, 0x0C, 0x00, 0x00, 0x00, 0x93,
	0x0D, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x3A,
	0x80, 0x03, 0xC5, 0x00, 0x00, 0x00, 0x90, 0x00,
	0x0D, 0x03, 0x75, 0x00, 0x00, 0x00, 0x50, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x2D, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A,
	0xDD, 0x03, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x34, 0x3D, 0x03, 0xED, 0x2E,
	0xCF, 0xFF, 0xFF, 0x3C, 0x3D, 0x03, 0xC1, 0x30,
	0x3D, 0x03, 0xED, 0xB9, 0x20, 0x00, 0x00, 0x3A,
	0xDD, 0x03, 0xC1, 0x38, 0x3D, 0x03, 0x85, 0x30,
	0x30, 0x0F, 0xF9, 0x38, 0x4F, 0x87, 0x20, 0x3A,
	0xDD, 0x03, 0xC1, 0x38, 0x3D, 0x03, 0x89, 0x30,
	0x30, 0x0F, 0xF9, 0x38, 0x44, 0xE1, 0xF0, 0x3A,
	0xDD, 0x03, 0xC1, 0x38, 0x3D, 0x03, 0x8D, 0x30,
	0x30, 0x0F, 0xF9, 0x34, 0x4D, 0x03, 0xCC, 0x00,
	0x00, 0xD3, 0x04, 0x34, 0x4D, 0x03, 0xE9, 0x3C,
	0x1D, 0x03, 0xC1, 0x38, 0x3D, 0x03, 0x9D, 0x30,
	0x30, 0x0F, 0xF9, 0x38, 0x40, 0x10, 0x30, 0x3A,
	0xDD, 0x03, 0xC1, 0x38, 0x3D, 0x03, 0x97, 0x30,
	0x30, 0x0F, 0xF9, 0x38, 0x30, 0x0B, 0xFC, 0x30,
	0x3D, 0x03, 0xED, 0x38, 0x40, 0x02, 0x00, 0x3A,
	0xDD, 0x03, 0xC1, 0x38, 0x3D, 0x03, 0x7D, 0x30,
	0x30, 0x0F, 0xF9, 0x00, 0x03, 0xEB, 0x01, 0x34,
	0x30, 0x0F, 0x88, 0x00, 0x5B, 0xD0, 0x35, 0x38,
	0x3D, 0x03, 0xA8, 0x3C, 0x1D, 0x03, 0xA5, 0x34,
	0x4D, 0x03, 0xEA, 0x30, 0x4D, 0x03, 0xED, 0x38,
	0x3D, 0x03, 0xAF, 0x3A, 0xDD, 0x03, 0xC2, 0x30,
	0x30, 0x0F, 0xF9, 0x2F, 0x30, 0x00, 0x08, 0xB6,
	0xDB, 0xE3, 0x81, 0x34, 0xED, 0x03, 0xEC, 0x34,
	0x3D, 0x03, 0xED, 0x14, 0xDB, 0xFC, 0x84, 0x3A,
	0xDD, 0x03, 0xBB, 0x30, 0xED, 0x03, 0xEC, 0x00,
	0x03, 0xF0, 0x0E, 0x00, 0x03, 0xE3, 0x81, 0x34,
	0xED, 0x03, 0xEC, 0x00, 0x03, 0xEB, 0x01, 0xB6,
	0xDB, 0xD0, 0x35, 0x00, 0x07, 0x4C, 0xF4, 0x30,
	0xED, 0x03, 0xEC, 0x2E, 0xF0, 0x00, 0x08, 0x2C,
	0xCF, 0xF0, 0x00, 0x2F, 0x3F, 0xFF, 0xF8, 0x18,
	0xE3, 0xF0, 0x2C, 0x34, 0x3D, 0x03, 0xED, 0x14,
	0xDB, 0xF0, 0x0E, 0x3C, 0x3D, 0x03, 0xC1, 0x30,
	0x3D, 0x03, 0xED, 0x34, 0x3D, 0x03, 0xEB, 0x30,
	0x3D, 0x03, 0xED, 0x38, 0x3D, 0x03, 0x7D, 0x30,
	0x30, 0x0F, 0xF9, 0x00, 0x03, 0xEB, 0x01, 0x3A,
	0xDD, 0x03, 0x6D, 0x3B, 0x50, 0x00, 0x00, 0x00,
	0x00, 0x60, 0x38, 0x00, 0x0D, 0x03, 0xF4, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x91,
	0xA2, 0xB3, 0xC5, 0x01, 0x45, 0x67, 0xC0, 0x00,
	0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
	0x00, 0x00,
};

// ===========================================================================
// 		Linear	PCM	Out
// ===========================================================================

UCHAR ZRN_PCM[] = {
	0x91, 0x3A, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x93, 0x0D, 0x03, 0xFB, 0x00, 0x00, 0x00, 0x01,
	0x89, 0x0B, 0x67, 0x40, 0x00, 0x00, 0x00, 0x93,
	0x00, 0x0A, 0x00, 0x00, 0x00, 0x02, 0xC7, 0x00,
	0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00,
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x90, 0x00, 0x00, 0x00, 0x05, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xE0, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x30, 0x00, 0x00, 0x00, 0x07, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x00,
	0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0xC8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x01, 0x2C, 0x00, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x01, 0x90, 0x00,
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x04, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x01, 0xF4, 0x00, 0x00, 0x00, 0x05, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x02, 0x58, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x06, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x01, 0x68, 0x00, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x01, 0xE0, 0x00,
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x04, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x02, 0x58, 0x00, 0x00, 0x00, 0x05, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x0A, 0x00, 0x00,
	0x00, 0x0A, 0x0B, 0x00, 0x00, 0x0A, 0x16, 0x00,
	0x00, 0x0A, 0x21, 0x00, 0x00, 0x0A, 0x2C, 0x00,
	0x00, 0x0A, 0x37, 0x00, 0x00, 0x0A, 0x42, 0x00,
	0x00, 0x0A, 0x4D, 0x00, 0x00, 0x0A, 0x58, 0x00,
	0x00, 0x0A, 0x6B, 0x00, 0x00, 0x0A, 0x86, 0x00,
	0x00, 0x0A, 0xA9, 0x00, 0x00, 0x0A, 0xD4, 0x00,
	0x00, 0x0B, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x42, 0x00,
	0x00, 0x0B, 0x55, 0x00, 0x00, 0x0B, 0x70, 0x00,
	0x00, 0x0B, 0x93, 0x00, 0x00, 0x0B, 0xBE, 0x00,
	0x00, 0x0B, 0xF1, 0x00, 0x00, 0x0B, 0xF9, 0x00,
	0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x25, 0x00,
	0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x00,
	0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x12, 0x00,
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0C, 0x00,
	0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0C, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
	0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xCE, 0x00, 0x0F, 0xFE, 0xAC, 0x00,
	0x0F, 0xFC, 0xBE, 0x00, 0x0F, 0xFC, 0x8C, 0x00,
	0x00, 0x00, 0x8D, 0x00, 0x00, 0x05, 0x46, 0x00,
	0x00, 0x02, 0xC6, 0x00, 0x0F, 0xF9, 0x6F, 0x00,
	0x0F, 0xF7, 0x58, 0x00, 0x00, 0x04, 0xD9, 0x00,
	0x00, 0x10, 0x36, 0x00, 0x00, 0x02, 0x1E, 0x00,
	0x0F, 0xE9, 0x06, 0x00, 0x0F, 0xF0, 0x28, 0x00,
	0x00, 0x19, 0x04, 0x00, 0x00, 0x24, 0x66, 0x00,
	0x0F, 0xEE, 0xD9, 0x00, 0x0F, 0xC1, 0xF5, 0x00,
	0x0F, 0xF8, 0xDD, 0x00, 0x00, 0x59, 0x4E, 0x00,
	0x00, 0x3A, 0x78, 0x00, 0x0F, 0x8E, 0x61, 0x00,
	0x0F, 0x56, 0x9F, 0x00, 0x00, 0x82, 0x76, 0x00,
	0x02, 0x7B, 0x12, 0x00, 0x03, 0x77, 0x86, 0x00,
	0x02, 0x7B, 0x12, 0x00, 0x00, 0x82, 0x76, 0x00,
	0x0F, 0x56, 0x9F, 0x00, 0x0F, 0x8E, 0x61, 0x00,
	0x00, 0x3A, 0x78, 0x00, 0x00, 0x59, 0x4E, 0x00,
	0x0F, 0xF8, 0xDD, 0x00, 0x0F, 0xC1, 0xF5, 0x00,
	0x0F, 0xEE, 0xD9, 0x00, 0x00, 0x24, 0x66, 0x00,
	0x00, 0x19, 0x04, 0x00, 0x0F, 0xF0, 0x28, 0x00,
	0x0F, 0xE9, 0x06, 0x00, 0x00, 0x02, 0x1E, 0x00,
	0x00, 0x10, 0x36, 0x00, 0x00, 0x04, 0xD9, 0x00,
	0x0F, 0xF7, 0x58, 0x00, 0x0F, 0xF9, 0x6F, 0x00,
	0x00, 0x02, 0xC6, 0x00, 0x00, 0x05, 0x46, 0x00,
	0x00, 0x00, 0x8D, 0x00, 0x0F, 0xFC, 0x8C, 0x00,
	0x0F, 0xFC, 0xBE, 0x00, 0x0F, 0xFE, 0xAC, 0x00,
	0x0F, 0xFF, 0xCE, 0x00, 0x03, 0x96, 0x9F, 0x00,
	0x0F, 0x29, 0x5B, 0x00, 0x0A, 0xC0, 0x3F, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x08, 0x2B, 0xE2, 0x00,
	0x08, 0x56, 0xD4, 0x00, 0x08, 0x80, 0xDA, 0x00,
	0x08, 0xA9, 0xFA, 0x00, 0x08, 0xD2, 0x38, 0x00,
	0x08, 0xF9, 0x99, 0x00, 0x09, 0x20, 0x22, 0x00,
	0x09, 0x45, 0xD8, 0x00, 0x09, 0x6A, 0xBF, 0x00,
	0x09, 0x8E, 0xDC, 0x00, 0x09, 0xB2, 0x32, 0x00,
	0x09, 0xD4, 0xC7, 0x00, 0x09, 0xF6, 0x9E, 0x00,
	0x0A, 0x17, 0xBB, 0x00, 0x0A, 0x38, 0x23, 0x00,
	0x0A, 0x57, 0xD8, 0x00, 0x0A, 0x76, 0xE0, 0x00,
	0x0A, 0x95, 0x3E, 0x00, 0x0A, 0xB2, 0xF5, 0x00,
	0x0A, 0xD0, 0x09, 0x00, 0x0A, 0xEC, 0x7E, 0x00,
	0x0B, 0x08, 0x56, 0x00, 0x0B, 0x23, 0x96, 0x00,
	0x0B, 0x3E, 0x40, 0x00, 0x0B, 0x58, 0x59, 0x00,
	0x0B, 0x71, 0xE1, 0x00, 0x0B, 0x8A, 0xDE, 0x00,
	0x0B, 0xA3, 0x52, 0x00, 0x0B, 0xBB, 0x40, 0x00,
	0x0B, 0xD2, 0xAA, 0x00, 0x0B, 0xE9, 0x94, 0x00,
	0x0C, 0x00, 0x00, 0x00, 0x0A, 0x37, 0x00, 0x00,
	0x06, 0x0F, 0x30, 0x00, 0x0A, 0x02, 0x50, 0x00,
	0x04, 0x97, 0x80, 0x00, 0x0D, 0x9D, 0x50, 0x00,
	0x00, 0xFA, 0x20, 0x00, 0x0F, 0xEC, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xF8, 0x36, 0x00,
	0x00, 0x07, 0x96, 0x00, 0x0F, 0xFA, 0x4A, 0x00,
	0x00, 0x02, 0x5A, 0x00, 0x00, 0x00, 0x93, 0x0D,
	0x03, 0xEF, 0x00, 0x00, 0x00, 0x08, 0x7F, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x90, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00,
	0x03, 0xE9, 0x00, 0x00, 0x00, 0x01, 0xB4, 0x90,
	0xB8, 0x0C, 0x12, 0x90, 0xB0, 0x3C, 0x30, 0x20,
	0x05, 0xF7, 0x38, 0x0D, 0x01, 0xD2, 0x32, 0x10,
	0x0F, 0xF0, 0x3B, 0x80, 0x00, 0x00, 0x34, 0x3D,
	0x03, 0xFB, 0x00, 0x03, 0xCD, 0x82, 0x38, 0x8D,
	0x00, 0x00, 0x38, 0x40, 0x03, 0xE9, 0x3A, 0xDD,
	0x03, 0xE1, 0x3A, 0xFD, 0x00, 0x0D, 0x00, 0x03,
	0xEB, 0xC1, 0x38, 0x8D, 0x03, 0xEF, 0x38, 0x40,
	0x00, 0x08, 0x3A, 0xDD, 0x03, 0xE1, 0x3A, 0xFD,
	0x00, 0x12, 0x00, 0x03, 0xEB, 0xC1, 0x38, 0x80,
	0x0A, 0x00, 0x38, 0x40, 0x02, 0xC7, 0x3A, 0xDD,
	0x03, 0xE1, 0x3A, 0xFD, 0x00, 0x17, 0x00, 0x03,
	0xEB, 0xC1, 0x3B, 0x80, 0x00, 0x01, 0x36, 0xDE,
	0x00, 0x42, 0x00, 0x03, 0xC0, 0xB6, 0x30, 0x3D,
	0x03, 0xFB, 0x00, 0x00, 0xD4, 0xFA, 0x3C, 0x1D,
	0x00, 0x2B, 0x00, 0x03, 0xCC, 0x03, 0x00, 0x00,
	0xC4, 0xC3, 0x38, 0x40, 0x05, 0xBA, 0x30, 0x40,
	0x05, 0xB8, 0x00, 0x03, 0xEB, 0x01, 0x3B, 0x50,
	0x00, 0x00, 0x2E, 0xFF, 0xFF, 0xFC, 0x2E, 0xCF,
	0xFF, 0xF4, 0x30, 0x30, 0x05, 0xE9, 0x30, 0x30,
	0x05, 0xEA, 0x38, 0x3D, 0x00, 0x2F, 0x30, 0x30,
	0x0F, 0xF8, 0x00, 0x03, 0xF0, 0x2C, 0x34, 0x40,
	0x0F, 0xCD, 0x00, 0x03, 0xF0, 0x2B, 0x00, 0x03,
	0xF0, 0x2D, 0x3B, 0x80, 0x00, 0x01, 0x34, 0x30,
	0x0F, 0xCC, 0x00, 0x03, 0xCE, 0x83, 0x2C, 0xC4,
	0x04, 0x00, 0x3C, 0x1D, 0x00, 0x3A, 0x34, 0x30,
	0x05, 0xB8, 0x2C, 0xF0, 0x05, 0xBF, 0x38, 0x3D,
	0x00, 0x1B, 0x30, 0x30, 0x0F, 0xF8, 0x00, 0x03,
	0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80,
	0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x00, 0x03,
	0xE2, 0xC1, 0x3C, 0x5D, 0x00, 0x4A, 0x12, 0xDB,
	0xC0, 0xCB, 0x30, 0x30, 0x05, 0xB8, 0x38, 0x3D,
	0x00, 0x56, 0x30, 0x30, 0x0F, 0xF8, 0x30, 0xE0,
	0x05, 0xC0, 0x34, 0x30, 0x05, 0xF2, 0x00, 0x00,
	0xB4, 0xC3, 0x30, 0x30, 0x05, 0xF2, 0x00, 0x03,
	0xEC, 0x1C, 0x00, 0x03, 0xF0, 0x0B, 0x00, 0x03,
	0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80,
	0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x2C, 0xF0,
	0x05, 0xBB, 0x3C, 0x6D, 0x00, 0x45, 0x00, 0x03,
	0xEC, 0x1C, 0x00, 0x00, 0xD4, 0xF0, 0x3C, 0x1D,
	0x00, 0x52, 0x00, 0x03, 0xF0, 0x0B, 0x38, 0x3D,
	0x00, 0x1B, 0x30, 0x30, 0x0F, 0xF8, 0x00, 0x03,
	0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80,
	0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x36, 0xD0,
	0x05, 0xF6, 0x34, 0x30, 0x05, 0xE9, 0x2E, 0xCF,
	0xFF, 0xFE, 0x00, 0x03, 0xC3, 0x84, 0x34, 0x30,
	0x05, 0xEC, 0x04, 0xE0, 0x00, 0x00, 0x3C, 0x6D,
	0x00, 0x72, 0x34, 0x30, 0x05, 0xE9, 0x2E, 0xCF,
	0xFF, 0xFE, 0x38, 0x4D, 0x00, 0x61, 0x30, 0x40,
	0x05, 0xF6, 0x3C, 0x3D, 0x00, 0x66, 0x30, 0x30,
	0x05, 0xE9, 0x34, 0x30, 0x05, 0xEB, 0x38, 0x4D,
	0x00, 0x1B, 0x30, 0x40, 0x0F, 0xF8, 0x14, 0xD8,
	0x00, 0x00, 0x3C, 0x3D, 0x00, 0x6E, 0x30, 0x30,
	0x05, 0xEB, 0x34, 0x40, 0x0F, 0xCD, 0x00, 0x03,
	0xEC, 0x32, 0x00, 0x03, 0xEE, 0xB2, 0x38, 0x3D,
	0x00, 0x72, 0x30, 0x30, 0x05, 0xF6, 0x00, 0x03,
	0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80,
	0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x00, 0x03,
	0xEC, 0x32, 0x00, 0x03, 0xEE, 0xB2, 0x3C, 0x3D,
	0x00, 0x79, 0x30, 0x30, 0x05, 0xE9, 0x34, 0x30,
	0x05, 0xE8, 0x38, 0x4D, 0x00, 0x1B, 0x30, 0x40,
	0x0F, 0xF8, 0x14, 0xD8, 0x00, 0x00, 0x3C, 0x2D,
	0x00, 0x7E, 0x30, 0x30, 0x05, 0xE8, 0x34, 0x40,
	0x0F, 0xCD, 0x00, 0x00, 0xB0, 0x3C, 0x00, 0x03,
	0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80,
	0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x30, 0x40,
	0x05, 0xFE, 0x30, 0x30, 0x05, 0xFF, 0x00, 0x00,
	0xCB, 0xCB, 0x3B, 0x80, 0x00, 0x01, 0x00, 0x03,
	0xEB, 0x01, 0xB6, 0xD8, 0xD0, 0x7C, 0x3C, 0x6D,
	0x00, 0x8C, 0x12, 0xDB, 0xD0, 0x35, 0x34, 0x40,
	0x0F, 0xC8, 0x30, 0x30, 0x05, 0xF7, 0x00, 0x03,
	0xFF, 0x03, 0x00, 0x03, 0xED, 0x7A, 0x0D, 0x1B,
	0xF0, 0x2C, 0x00, 0x03, 0xC0, 0xF1, 0x34, 0x40,
	0x05, 0xFE, 0x00, 0x03, 0xF0, 0x2B, 0x00, 0x03,
	0xF0, 0x2D, 0x34, 0x30, 0x05, 0xFF, 0x00, 0x00,
	0xBB, 0xCB, 0x35, 0x00, 0x0C, 0x15, 0x35, 0x10,
	0x05, 0xD4, 0x35, 0x20, 0x05, 0xD6, 0x34, 0x80,
	0x0C, 0x14, 0x38, 0xD0, 0x08, 0xB4, 0x3A, 0xDD,
	0x00, 0xF0, 0x3A, 0xFD, 0x00, 0x9D, 0x00, 0x03,
	0xEB, 0xC1, 0x39, 0x00, 0x00, 0x00, 0x34, 0x40,
	0x05, 0xD2, 0x34, 0x50, 0x0C, 0x1E, 0x34, 0x90,
	0x05, 0xD3, 0x34, 0xB0, 0x07, 0x5D, 0x39, 0x30,
	0x00, 0xB4, 0x3A, 0xDD, 0x01, 0x40, 0x3A, 0xFD,
	0x00, 0xA6, 0x00, 0x03, 0xEB, 0xC1, 0x34, 0x50,
	0x0C, 0x1D, 0x34, 0x20, 0x05, 0xC9, 0x00, 0x68,
	0x00, 0x00, 0x3C, 0x1D, 0x00, 0xB3, 0x38, 0x78,
	0x00, 0x00, 0x38, 0x60, 0x00, 0x00, 0x2C, 0xB0,
	0x00, 0x80, 0x3C, 0x1D, 0x00, 0xB3, 0x00, 0x03,
	0xC0, 0x83, 0x2C, 0x80, 0x00, 0x1F, 0x3A, 0xDD,
	0x01, 0x7B, 0x3A, 0xFD, 0x00, 0xB3, 0x00, 0x03,
	0xEB, 0xC1, 0x34, 0x40, 0x05, 0xD7, 0x34, 0x30,
	0x05, 0xCF, 0x34, 0xA0, 0x05, 0xD5, 0x34, 0x20,
	0x05, 0xD8, 0x3A, 0xDD, 0x01, 0x8F, 0x3A, 0xFD,
	0x00, 0xBA, 0x00, 0x03, 0xEB, 0xC1, 0x34, 0x60,
	0x05, 0xD1, 0x34, 0xA0, 0x05, 0xD5, 0x34, 0x70,
	0x05, 0xD7, 0x35, 0x80, 0x0C, 0x1A, 0x39, 0xA0,
	0x00, 0x02, 0x00, 0x70, 0x00, 0x00, 0x3C, 0x4D,
	0x00, 0xC9, 0x38, 0xB0, 0x07, 0x5A, 0x38, 0xC0,
	0x0C, 0xBB, 0x3A, 0xDD, 0x01, 0xAE, 0x3A, 0xFD,
	0x00, 0xC6, 0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDD,
	0x00, 0xD2, 0x00, 0x00, 0x24, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0xC1, 0x85, 0x07, 0xB3,
	0xF4, 0x83, 0x00, 0x03, 0xC1, 0xE8, 0x3A, 0xAD,
	0x00, 0xD1, 0x0B, 0x5B, 0xF4, 0x82, 0x0B, 0x98,
	0x00, 0x00, 0x0B, 0x55, 0x50, 0xD3, 0x0B, 0x90,
	0x00, 0x00, 0x0B, 0x5D, 0x50, 0x92, 0x39, 0x00,
	0x00, 0x00, 0x34, 0x20, 0x05, 0xD0, 0x39, 0x30,
	0x00, 0xB4, 0x00, 0x50, 0x00, 0x00, 0x3C, 0x1D,
	0x00, 0xE0, 0x34, 0xA0, 0x05, 0xD5, 0x34, 0xB0,
	0x07, 0x5D, 0x38, 0xD0, 0x0C, 0x64, 0x3A, 0xDD,
	0x01, 0x59, 0x3A, 0xFD, 0x00, 0xDD, 0x00, 0x03,
	0xEB, 0xC1, 0x3A, 0xDD, 0x00, 0xE5, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0xC1, 0xE8, 0x3A, 0xAD, 0x00, 0xE4, 0x00, 0x00,
	0x26, 0x10, 0x00, 0x06, 0xA6, 0x10, 0x00, 0x06,
	0xA6, 0x10, 0x34, 0x30, 0x05, 0xCE, 0x00, 0x5B,
	0xD0, 0x13, 0x3C, 0x1D, 0x00, 0xED, 0x34, 0xA0,
	0x05, 0xD5, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xDD,
	0x01, 0x69, 0x3A, 0xFD, 0x00, 0xED, 0x00, 0x03,
	0xEB, 0xC1, 0x00, 0x03, 0xF0, 0x2D, 0x39, 0x10,
	0x00, 0x00, 0x39, 0x20, 0x00, 0x00, 0x3A, 0x80,
	0x00, 0x0A, 0x3A, 0xAD, 0x01, 0x1C, 0x34, 0x90,
	0x05, 0xD3, 0x3A, 0x80, 0x00, 0x02, 0x3A, 0xAD,
	0x01, 0x1B, 0x34, 0xC0, 0x07, 0x42, 0x38, 0x70,
	0x00, 0x04, 0x00, 0x03, 0xF8, 0x99, 0x00, 0x07,
	0x59, 0x25, 0x3A, 0x80, 0x00, 0x02, 0x3A, 0xAD,
	0x01, 0x08, 0x00, 0x03, 0xF8, 0x86, 0x00, 0x03,
	0xC6, 0x68, 0x3A, 0xAD, 0x01, 0x07, 0x00, 0x03,
	0xF0, 0x82, 0x0D, 0x13, 0xF0, 0x83, 0x0D, 0x1B,
	0xC0, 0x80, 0x0B, 0x43, 0xC0, 0xC1, 0x0B, 0x4B,
	0xF0, 0xA0, 0x0B, 0x83, 0xF1, 0x64, 0x0B, 0x8B,
	0xD0, 0x20, 0x0B, 0xC3, 0xD0, 0x24, 0x0B, 0xCB,
	0xF0, 0x82, 0x00, 0x04, 0x52, 0x29, 0x00, 0x00,
	0x70, 0x00, 0x00, 0x03, 0xF8, 0x82, 0x00, 0x50,
	0x00, 0x00, 0x3C, 0x1D, 0x01, 0x1B, 0x38, 0x60,
	0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x80,
	0x00, 0x02, 0x3A, 0xAD, 0x01, 0x1A, 0x00, 0x03,
	0xB2, 0x0B, 0x00, 0x03, 0xF8, 0x98, 0x00, 0x03,
	0xC6, 0x68, 0x3A, 0xAD, 0x01, 0x18, 0x00, 0x07,
	0xD0, 0xE4, 0x0D, 0x1B, 0xF3, 0x02, 0x17, 0x9B,
	0xF8, 0x98, 0x18, 0xD3, 0xF8, 0x84, 0x00, 0x05,
	0x72, 0x83, 0x00, 0x00, 0x28, 0x20, 0x00, 0x00,
	0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x38, 0xC0, 0x07, 0x52, 0x38, 0xB0,
	0x07, 0x4A, 0x38, 0xD0, 0x08, 0xB4, 0x34, 0x90,
	0x05, 0xD3, 0x34, 0x20, 0x0C, 0x16, 0x34, 0x60,
	0x0C, 0x17, 0x34, 0x40, 0x05, 0xC8, 0x13, 0x20,
	0x00, 0x00, 0x00, 0x03, 0xC1, 0x1D, 0x00, 0x03,
	0xC1, 0x28, 0x3A, 0xAD, 0x01, 0x3B, 0xB0, 0x03,
	0xC7, 0x59, 0x00, 0x03, 0xE3, 0x41, 0x00, 0x03,
	0xC0, 0xA8, 0x3A, 0xAD, 0x01, 0x38, 0x00, 0x07,
	0x07, 0x63, 0x00, 0x03, 0xFB, 0x87, 0x2D, 0xC4,
	0x04, 0x00, 0x3C, 0x1D, 0x01, 0x37, 0x05, 0x9B,
	0xF3, 0x04, 0x38, 0x30, 0x00, 0x00, 0x3C, 0x2D,
	0x01, 0x37, 0xB9, 0x23, 0xF9, 0x03, 0x00, 0x00,
	0x00, 0x00, 0x12, 0xDB, 0xD0, 0x07, 0x00, 0x03,
	0xC1, 0x44, 0x19, 0xC4, 0x38, 0xCC, 0x00, 0x03,
	0xC1, 0x05, 0x00, 0x03, 0xF0, 0x0D, 0x00, 0x04,
	0x57, 0x23, 0x00, 0x00, 0x12, 0x28, 0x32, 0x10,
	0x05, 0xD8, 0x00, 0x03, 0xF0, 0x2D, 0x34, 0x20,
	0x05, 0xC8, 0x34, 0x30, 0x0C, 0x16, 0x00, 0x68,
	0x00, 0x00, 0x3C, 0x6D, 0x01, 0x49, 0x39, 0xC0,
	0x00, 0x07, 0x2F, 0x20, 0x00, 0x04, 0x00, 0x50,
	0x00, 0x00, 0x3C, 0x1D, 0x01, 0x49, 0x38, 0x50,
	0x0C, 0x34, 0x00, 0x00, 0x00, 0x00, 0xA9, 0x68,
	0x00, 0x00, 0x00, 0x03, 0xC0, 0xE8, 0x3A, 0xAD,
	0x01, 0x54, 0x12, 0x90, 0x00, 0x00, 0x00, 0x03,
	0xC1, 0x4C, 0xB0, 0x03, 0xD0, 0x01, 0x00, 0x03,
	0xC0, 0xA8, 0x3A, 0xAD, 0x01, 0x52, 0x00, 0x07,
	0x52, 0xE4, 0x67, 0x03, 0x68, 0x24, 0x67, 0x0F,
	0x52, 0xE4, 0x00, 0x04, 0x56, 0x19, 0x00, 0x00,
	0x70, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0xF0, 0x2D, 0x30, 0xB0, 0x07, 0x5D, 0x39, 0x30,
	0x00, 0x00, 0x39, 0xB0, 0x00, 0x63, 0x00, 0x03,
	0xC1, 0xE8, 0x3A, 0xAD, 0x01, 0x65, 0x00, 0x00,
	0x80, 0x18, 0x00, 0x00, 0x90, 0x18, 0x38, 0xD0,
	0x0C, 0x64, 0xB0, 0x03, 0xD0, 0x01, 0x3A, 0x80,
	0x00, 0x33, 0x3A, 0xAD, 0x01, 0x64, 0x00, 0x07,
	0x5B, 0x1B, 0x67, 0x03, 0xF6, 0x83, 0x67, 0x0F,
	0x5B, 0x1B, 0x00, 0x04, 0x54, 0x11, 0x00, 0x03,
	0xF0, 0x2D, 0x00, 0x00, 0x60, 0x18, 0x30, 0xB0,
	0x07, 0x5D, 0x38, 0xB0, 0x0C, 0x97, 0x39, 0xBF,
	0xFF, 0xFE, 0x38, 0xC0, 0x07, 0x44, 0x00, 0x07,
	0x57, 0x1D, 0x00, 0x03, 0xC1, 0xE8, 0x3A, 0xAD,
	0x01, 0x77, 0x39, 0xCF, 0xFF, 0xFC, 0x3A, 0x80,
	0x00, 0x02, 0x3A, 0xAD, 0x01, 0x76, 0x00, 0x07,
	0x07, 0x97, 0x49, 0xCE, 0x18, 0xE7, 0x6A, 0xCA,
	0x84, 0x23, 0x7C, 0xCB, 0xF5, 0x47, 0x00, 0x04,
	0x58, 0x51, 0x00, 0x00, 0x80, 0x20, 0x00, 0x03,
	0xF0, 0x2D, 0x39, 0xB0, 0x00, 0x00, 0x00, 0x03,
	0xC6, 0xDC, 0x38, 0x60, 0x04, 0x00, 0xB4, 0xD8,
	0x00, 0x00, 0x2E, 0xF0, 0x00, 0x03, 0x2E, 0xB0,
	0x00, 0x04, 0x2E, 0x94, 0x44, 0x44, 0xB7, 0xB0,
	0x00, 0x00, 0xB5, 0xB0, 0x00, 0x00, 0x2D, 0x50,
	0x0F, 0xFF, 0x4B, 0xB0, 0x00, 0x00, 0x00, 0x03,
	0xC1, 0x87, 0x2F, 0x80, 0x00, 0xFF, 0x2D, 0x8F,
	0xFF, 0x00, 0xBF, 0xB8, 0x00, 0x00, 0x2F, 0xEF,
	0xFF, 0xFD, 0x38, 0x30, 0x0C, 0x9A, 0xA7, 0xF8,
	0x00, 0x00, 0x00, 0x03, 0xC1, 0xCC, 0x00, 0x03,
	0xF0, 0x2D, 0x2F, 0xAF, 0xFF, 0xF8, 0x00, 0x03,
	0xF9, 0x07, 0x34, 0x50, 0x07, 0x48, 0x18, 0x98,
	0x00, 0x00, 0x18, 0xE8, 0x00, 0x00, 0x30, 0x20,
	0x07, 0x48, 0x38, 0xB0, 0x07, 0x49, 0x00, 0x6B,
	0xD0, 0x01, 0x00, 0x03, 0xC1, 0x28, 0x3A, 0xAD,
	0x01, 0xAA, 0x34, 0x40, 0x07, 0x43, 0x3C, 0x6D,
	0x01, 0xA0, 0x38, 0x33, 0xFD, 0xF4, 0x00, 0x03,
	0xF7, 0x02, 0x00, 0x50, 0x00, 0x00, 0x3C, 0x6D,
	0x01, 0xA0, 0x38, 0x34, 0x02, 0x0C, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x10, 0x02, 0x0C, 0x64, 0xCB,
	0xD0, 0x43, 0x09, 0x23, 0xD0, 0x24, 0x0A, 0xCB,
	0xF4, 0x82, 0x23, 0x0B, 0xF5, 0x43, 0x4E, 0x83,
	0xE0, 0x5C, 0x0B, 0x80, 0x00, 0x00, 0x4E, 0xC3,
	0xC0, 0x02, 0x0B, 0x80, 0x00, 0x00, 0x42, 0x93,
	0xC0, 0x03, 0x42, 0xDB, 0xD0, 0x01, 0x00, 0x6C,
	0x54, 0x93, 0x00, 0x03, 0xF0, 0x2D, 0x34, 0x80,
	0x0C, 0x18, 0x35, 0x00, 0x0C, 0x19, 0x34, 0xD0,
	0x07, 0x5C, 0x3A, 0x80, 0x00, 0x02, 0x3A, 0xAD,
	0x01, 0xCD, 0x39, 0x50, 0x00, 0x18, 0x00, 0x03,
	0xE2, 0x01, 0x00, 0x03, 0xC1, 0xE8, 0x3A, 0xAD,
	0x01, 0xCA, 0x00, 0x07, 0x37, 0x10, 0x00, 0x43,
	0xD0, 0x9D, 0x3C, 0x1D, 0x01, 0xBB, 0x13, 0x23,
	0xD0, 0x45, 0x07, 0xB0, 0x00, 0x00, 0xB9, 0x20,
	0x00, 0x00, 0x3A, 0x80, 0x00, 0x06, 0x3A, 0xAD,
	0x01, 0xBF, 0x00, 0x07, 0x78, 0xAB, 0x64, 0xC7,
	0x78, 0xAB, 0x64, 0xC7, 0x78, 0xAB, 0x00, 0x03,
	0xC0, 0x02, 0x0B, 0x90, 0x90, 0x28, 0x07, 0xB0,
	0x00, 0x00, 0x0B, 0x90, 0x00, 0x00, 0xB0, 0x93,
	0xE0, 0x86, 0x2D, 0x30, 0x03, 0xE8, 0x3C, 0x5D,
	0x01, 0xCA, 0x38, 0xC0, 0x0C, 0xBB, 0x0B, 0x50,
	0x90, 0x28, 0xB4, 0x90, 0x00, 0x00, 0x00, 0x05,
	0x3A, 0x90, 0x00, 0x03, 0xF0, 0x08, 0x00, 0x07,
	0x6A, 0x92, 0x00, 0x05, 0x57, 0x02, 0x00, 0x00,
	0x2A, 0x28, 0x00, 0x03, 0xF0, 0x2D, 0x30, 0xD0,
	0x07, 0x5C, 0x39, 0x50, 0x00, 0x00, 0x34, 0x20,
	0x0F, 0xFA, 0x00, 0x50, 0x00, 0x00, 0x3C, 0x1D,
	0x02, 0x34, 0x38, 0x90, 0x0F, 0xE6, 0x2C, 0xB0,
	0x00, 0x02, 0x3C, 0x1D, 0x02, 0x2B, 0x38, 0xA0,
	0x0D, 0x00, 0x2C, 0xB0, 0x00, 0x03, 0x3C, 0x1D,
	0x01, 0xE6, 0x39, 0x60, 0x05, 0x00, 0x38, 0x30,
	0x00, 0x02, 0x3E, 0x00, 0x00, 0x06, 0x00, 0x06,
	0x53, 0x14, 0x34, 0x40, 0x0D, 0x05, 0x00, 0x00,
	0xD1, 0xC4, 0x3C, 0x1D, 0x01, 0xE5, 0x00, 0x00,
	0x00, 0x00, 0xB9, 0x20, 0x00, 0x00, 0x38, 0x40,
	0x0D, 0x06, 0x30, 0x40, 0x0C, 0x1E, 0x30, 0x30,
	0x0F, 0xFA, 0xB4, 0x90, 0xC4, 0x6C, 0x00, 0x00,
	0xC4, 0x2C, 0x38, 0x80, 0x00, 0x00, 0x3A, 0x80,
	0x02, 0x80, 0x3A, 0xAD, 0x01, 0xEE, 0x38, 0xE0,
	0x00, 0x00, 0x00, 0x04, 0x50, 0x82, 0x00, 0x04,
	0x50, 0x82, 0x39, 0x70, 0x00, 0xA0, 0x38, 0xF0,
	0x05, 0x00, 0x30, 0xF0, 0x05, 0xCC, 0x38, 0x00,
	0x04, 0x00, 0x32, 0x10, 0x0C, 0x20, 0x38, 0xA0,
	0x08, 0x00, 0x30, 0xA0, 0x07, 0x5D, 0x38, 0xC0,
	0x05, 0xA0, 0x30, 0xC0, 0x07, 0x5C, 0x38, 0x00,
	0x00, 0x04, 0x32, 0x10, 0x0F, 0xCB, 0x3A, 0xDE,
	0x15, 0xED, 0x3A, 0xFD, 0x01, 0xFD, 0x00, 0x03,
	0xEB, 0xC1, 0x38, 0x0D, 0x00, 0x72, 0x32, 0x10,
	0x05, 0xF6, 0x38, 0x0D, 0x00, 0x1B, 0x32, 0x10,
	0x0F, 0xF8, 0x38, 0x0D, 0x00, 0x82, 0x32, 0x10,
	0x0F, 0xF9, 0x38, 0x20, 0x00, 0x50, 0x30, 0x20,
	0x05, 0xE8, 0x34, 0x00, 0x0D, 0x03, 0x32, 0x10,
	0x0C, 0x17, 0x34, 0x30, 0x0D, 0x00, 0x2C, 0xC0,
	0x00, 0x80, 0x2E, 0xF0, 0x00, 0x08, 0x34, 0x20,
	0x0F, 0xC5, 0x2C, 0x80, 0xC0, 0x00, 0x2E, 0xBF,
	0xFF, 0xFE, 0x18, 0x98, 0xB4, 0x6C, 0x34, 0x20,
	0x0F, 0xC5, 0x2C, 0x80, 0x00, 0x06, 0x2E, 0xB0,
	0x00, 0x09, 0x18, 0x98, 0x00, 0x00, 0x34, 0x20,
	0x0D, 0x00, 0x2C, 0x80, 0x00, 0x40, 0x2E, 0xB0,
	0x00, 0x01, 0x18, 0x98, 0x00, 0x00, 0x34, 0x20,
	0x0D, 0x00, 0x2C, 0x80, 0x00, 0x07, 0x18, 0x98,
	0x00, 0x00, 0x30, 0x30, 0x0C, 0x1B, 0x34, 0x30,
	0x0D, 0x01, 0x2E, 0xF0, 0x00, 0x0C, 0x34, 0x20,
	0x0D, 0x02, 0x2E, 0xB0, 0x00, 0x04, 0x18, 0x9B,
	0xD0, 0x44, 0x30, 0x30, 0x0C, 0x1C, 0x34, 0x20,
	0x0D, 0x04, 0x2E, 0xB0, 0x00, 0x0C, 0x30, 0x20,
	0x0C, 0x1D, 0x3A, 0xDD, 0x03, 0xC9, 0x3A, 0xFD,
	0x02, 0x26, 0x00, 0x03, 0xEB, 0xC1, 0x34, 0x00,
	0x05, 0xFB, 0x32, 0x10, 0x05, 0xED, 0x3A, 0xDD,
	0x03, 0xC0, 0x30, 0x40, 0x05, 0xF8, 0x30, 0x40,
	0x05, 0xCB, 0x00, 0x00, 0xB0, 0x3C, 0xB4, 0x90,
	0xC4, 0x2C, 0x30, 0x20, 0x07, 0x49, 0x30, 0x20,
	0x07, 0x40, 0x30, 0x20, 0x07, 0x41, 0x34, 0x20,
	0x0C, 0x20, 0x3A, 0xDD, 0x03, 0xC0, 0x2C, 0x90,
	0x00, 0x40, 0x30, 0x20, 0x0C, 0x20, 0x34, 0x30,
	0x05, 0xE8, 0x00, 0x58, 0x00, 0x00, 0x3C, 0x4D,
	0x02, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB4, 0x2C, 0x00, 0x00, 0xC0, 0x3C, 0x3A, 0xDE,
	0x19, 0x7E, 0x3A, 0xFD, 0x02, 0x3D, 0x00, 0x03,
	0xEB, 0xC1, 0x34, 0x00, 0x05, 0xCC, 0x00, 0x03,
	0xC3, 0xC1, 0xB2, 0x00, 0x00, 0x00, 0x3C, 0x3D,
	0x02, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0xC5, 0xC1, 0xA2, 0x00, 0x00, 0x00, 0x34, 0x10,
	0x05, 0xFD, 0x04, 0x40, 0x00, 0x00, 0x3C, 0x3D,
	0x02, 0x3D, 0x34, 0x20, 0x05, 0xED, 0x14, 0x90,
	0x00, 0x00, 0x3C, 0x3D, 0x02, 0x4E, 0xB2, 0x48,
	0xC0, 0xBC, 0x36, 0x40, 0x05, 0xF9, 0x36, 0x40,
	0x05, 0xFA, 0x34, 0x20, 0x05, 0xFB, 0x30, 0x20,
	0x05, 0xED, 0x34, 0x00, 0x05, 0xF0, 0x36, 0x00,
	0x05, 0xF1, 0xA2, 0x00, 0x00, 0x00, 0x32, 0x10,
	0x05, 0xF0, 0x32, 0x00, 0x05, 0xF1, 0x3A, 0xDD,
	0x02, 0x57, 0x00, 0x03, 0xC8, 0x76, 0x32, 0x0D,
	0x03, 0xF6, 0xB0, 0x00, 0x00, 0x00, 0x3A, 0xDD,
	0x02, 0x5B, 0x34, 0x30, 0x05, 0xF7, 0x30, 0x00,
	0x05, 0xF7, 0x00, 0x58, 0x00, 0x00, 0x3C, 0x1D,
	0x02, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3B, 0x80, 0x00, 0x00, 0x36, 0x0D,
	0x03, 0xF5, 0x00, 0x00, 0xD0, 0x20, 0x00, 0x00,
	0xB0, 0x20, 0x32, 0x0D, 0x03, 0xF5, 0x3C, 0x6D,
	0x02, 0x71, 0x3B, 0x80, 0x00, 0x01, 0x00, 0x03,
	0xCD, 0xA1, 0x00, 0x00, 0xD1, 0xA0, 0x3C, 0x6D,
	0x02, 0x71, 0x2E, 0x2F, 0xFF, 0xFC, 0xB0, 0x03,
	0xC8, 0x02, 0x2E, 0xAF, 0xFF, 0xFC, 0x30, 0x20,
	0x05, 0xF5, 0x3A, 0xDD, 0x02, 0x70, 0x36, 0x0D,
	0x03, 0xF4, 0x33, 0x60, 0x05, 0xF0, 0x32, 0x00,
	0x05, 0xF1, 0x34, 0x00, 0x0F, 0xC5, 0x2C, 0x00,
	0x00, 0x40, 0x3C, 0x1D, 0x02, 0xA3, 0x34, 0x0D,
	0x03, 0xF5, 0x2C, 0x00, 0x00, 0x80, 0x3C, 0x6D,
	0x02, 0xA3, 0x34, 0x40, 0x05, 0xF4, 0x2D, 0x30,
	0x01, 0xC2, 0x3C, 0x2D, 0x02, 0x98, 0x38, 0x20,
	0x00, 0x2C, 0x2D, 0x3F, 0xFB, 0x50, 0x3C, 0x4D,
	0x02, 0x84, 0x38, 0x30, 0x00, 0x2C, 0x34, 0x20,
	0x07, 0x41, 0x14, 0x90, 0x00, 0x00, 0x3C, 0x2D,
	0x02, 0x98, 0x34, 0x30, 0x07, 0x40, 0x14, 0xD8,
	0x00, 0x00, 0x3C, 0x5D, 0x02, 0xA3, 0x34, 0x20,
	0x0F, 0xFA, 0x00, 0x00, 0xB0, 0x82, 0x30, 0x20,
	0x0F, 0xFA, 0x38, 0x2F, 0xFF, 0xFF, 0x30, 0x30,
	0x07, 0x40, 0x34, 0x30, 0x05, 0xCD, 0x3A, 0xDD,
	0x03, 0xC3, 0x3A, 0xFD, 0x02, 0x8D, 0x00, 0x03,
	0xEB, 0xC1, 0x0A, 0x98, 0x80, 0x00, 0x0A, 0x9B,
	0xC0, 0xD8, 0x30, 0x30, 0x05, 0xEB, 0x34, 0x30,
	0x05, 0xF9, 0x0C, 0x98, 0xB0, 0xBC, 0xA7, 0x20,
	0x80, 0x00, 0x30, 0x80, 0x05, 0xEC, 0x39, 0x00,
	0x00, 0x00, 0x3A, 0xDD, 0x02, 0xA2, 0x38, 0x0D,
	0x00, 0x59, 0x32, 0x10, 0x05, 0xF6, 0x30, 0x20,
	0x07, 0x41, 0x34, 0x30, 0x05, 0xF3, 0x2C, 0xE0,
	0x00, 0x01, 0x3C, 0x6D, 0x02, 0xA3, 0x30, 0x30,
	0x05, 0xF3, 0x34, 0x20, 0x05, 0xF9, 0xB5, 0x20,
	0xB0, 0xBC, 0x34, 0x50, 0x05, 0xF2, 0x00, 0x00,
	0xB4, 0x45, 0x30, 0x50, 0x05, 0xF2, 0x30, 0x40,
	0x05, 0xF4, 0x34, 0x30, 0x05, 0xF4, 0x2E, 0xE0,
	0x00, 0x04, 0x2E, 0xFF, 0xFF, 0xFC, 0x3A, 0xDD,
	0x02, 0xA9, 0x3B, 0x60, 0x00, 0x00, 0x30, 0x30,
	0x0C, 0x22, 0x34, 0x20, 0x05, 0xE8, 0x00, 0x50,
	0xC0, 0xFC, 0x3C, 0x4D, 0x02, 0xB8, 0xB4, 0x90,
	0x00, 0x00, 0x38, 0x00, 0x44, 0x00, 0x32, 0x10,
	0x0C, 0x20, 0x38, 0x00, 0x01, 0x00, 0x32, 0x10,
	0x0C, 0x21, 0x34, 0x20, 0x05, 0xF8, 0x00, 0x50,
	0xB0, 0xFC, 0x3C, 0x6D, 0x03, 0xB7, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xDD,
	0x03, 0x86, 0x38, 0x20, 0x00, 0x01, 0x30, 0x20,
	0x05, 0xF8, 0x34, 0x20, 0x05, 0xF2, 0x00, 0x00,
	0xD4, 0xC2, 0x3C, 0x1D, 0x03, 0x71, 0x00, 0x00,
	0xC4, 0xC2, 0x30, 0x20, 0x05, 0xF2, 0x34, 0x20,
	0x05, 0xBC, 0x2C, 0x80, 0x0F, 0x80, 0x2C, 0xB0,
	0x0A, 0x00, 0x3C, 0x1D, 0x02, 0xC8, 0x38, 0x30,
	0x00, 0x02, 0x38, 0x00, 0x44, 0x00, 0x32, 0x10,
	0x0C, 0x20, 0x3A, 0xDD, 0x03, 0x86, 0x30, 0x30,
	0x0F, 0xFA, 0x00, 0x00, 0xB0, 0xFC, 0x34, 0x30,
	0x05, 0xBC, 0x2E, 0xFF, 0xFF, 0xF4, 0x34, 0x40,
	0x05, 0xBB, 0x2F, 0x30, 0x00, 0x04, 0x19, 0x18,
	0x00, 0x00, 0x30, 0x30, 0x05, 0xEF, 0x34, 0x30,
	0x05, 0xBB, 0x2E, 0xFF, 0xFF, 0xF0, 0x34, 0x40,
	0x05, 0xBA, 0x19, 0x18, 0x00, 0x00, 0x30, 0x30,
	0x05, 0xEE, 0x38, 0x80, 0x05, 0xBC, 0x38, 0x90,
	0x05, 0xC1, 0x38, 0x6F, 0xFF, 0xF4, 0x38, 0x7F,
	0xFF, 0xFC, 0x00, 0x03, 0xF0, 0x82, 0x0D, 0xD3,
	0xDD, 0x85, 0x2C, 0x80, 0x00, 0xFF, 0x00, 0x05,
	0x42, 0x83, 0x0D, 0x9F, 0x40, 0x84, 0x2E, 0xB0,
	0x00, 0x04, 0x2C, 0x80, 0xFF, 0x00, 0x0D, 0xA3,
	0xE0, 0xCA, 0x18, 0xA3, 0xF1, 0x03, 0x0D, 0x5D,
	0x53, 0x02, 0x2C, 0xC0, 0x00, 0x03, 0x0D, 0xD3,
	0xE0, 0xCA, 0x2C, 0x80, 0x00, 0x1F, 0x00, 0x05,
	0x42, 0x83, 0x2E, 0xFF, 0xFF, 0xEE, 0x00, 0x05,
	0x42, 0xC2, 0x2E, 0xBF, 0xFF, 0xF0, 0x2C, 0x80,
	0x00, 0x03, 0x00, 0x05, 0x42, 0x83, 0x0D, 0x9B,
	0xF1, 0x02, 0x2C, 0xC0, 0x00, 0x07, 0x0D, 0xD3,
	0xE0, 0xCA, 0x2C, 0x80, 0x00, 0xFF, 0x00, 0x03,
	0xE0, 0x8A, 0x38, 0x80, 0x05, 0xCE, 0x38, 0x90,
	0x0C, 0x1B, 0x34, 0x30, 0x05, 0xC4, 0x00, 0x03,
	0xF3, 0x02, 0x2E, 0xBF, 0xFF, 0xF2, 0x00, 0x03,
	0xC0, 0x86, 0x16, 0xD0, 0x00, 0x00, 0x2C, 0x80,
	0x00, 0x02, 0x18, 0xF3, 0xE0, 0x82, 0x2D, 0x80,
	0x00, 0x01, 0xBD, 0xB6, 0x12, 0x86, 0x2C, 0x80,
	0x30, 0x00, 0x3C, 0x6D, 0x02, 0xFF, 0x38, 0x30,
	0x00, 0x00, 0x34, 0x70, 0x05, 0xC7, 0x00, 0x03,
	0xC1, 0xC3, 0x34, 0x00, 0x05, 0xC6, 0x00, 0x45,
	0x50, 0xCF, 0x3C, 0x1D, 0x03, 0x11, 0x2D, 0xC0,
	0x0C, 0x80, 0x2D, 0xF0, 0x08, 0x80, 0x3C, 0x1D,
	0x03, 0x11, 0x38, 0x60, 0x00, 0x04, 0x2D, 0xF0,
	0x04, 0x80, 0x3C, 0x1D, 0x03, 0x11, 0x38, 0x60,
	0x00, 0x02, 0x2D, 0xF0, 0x08, 0x00, 0x3C, 0x1D,
	0x03, 0x11, 0x38, 0x6F, 0xFF, 0xFC, 0x2D, 0xF0,
	0x04, 0x00, 0x3C, 0x1D, 0x03, 0x11, 0x38, 0x6F,
	0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x38, 0x60,
	0x00, 0x00, 0x00, 0x07, 0x82, 0x8F, 0x30, 0x20,
	0x07, 0x43, 0x2D, 0xC0, 0x00, 0x0F, 0x00, 0x04,
	0x51, 0x87, 0x38, 0x20, 0x06, 0x00, 0x34, 0x50,
	0x0C, 0x16, 0x34, 0x60, 0x05, 0xC8, 0x13, 0xB3,
	0xD0, 0x07, 0x00, 0xC3, 0xC1, 0xA7, 0xAB, 0xF8,
	0x00, 0x00, 0x00, 0x5B, 0xDF, 0xC6, 0x3C, 0x6D,
	0x03, 0x20, 0x00, 0x04, 0x50, 0x87, 0x38, 0x20,
	0x07, 0x80, 0x2F, 0x60, 0x00, 0x01, 0x0B, 0xAC,
	0x50, 0x85, 0x00, 0x03, 0xE1, 0x44, 0x3A, 0xDD,
	0x03, 0xC9, 0x3A, 0xFD, 0x03, 0x25, 0x00, 0x03,
	0xEB, 0xC1, 0x34, 0x20, 0x05, 0xBE, 0x2C, 0x80,
	0x0F, 0xF0, 0x2E, 0xB0, 0x00, 0x04, 0x34, 0x30,
	0x05, 0xBF, 0x2C, 0xCF, 0xF0, 0x00, 0x2E, 0xFF,
	0xFF, 0xF4, 0x18, 0x98, 0x00, 0x00, 0x30, 0x30,
	0x0C, 0x23, 0x34, 0x00, 0x05, 0xEE, 0x36, 0x00,
	0x05, 0xEF, 0x2C, 0x00, 0xFF, 0xFF, 0x2E, 0x20,
	0x00, 0x07, 0x00, 0x03, 0xC8, 0x83, 0x2E, 0x20,
	0x00, 0x01, 0x00, 0x03, 0xC0, 0xE2, 0x2E, 0x2F,
	0xFF, 0xFC, 0x2E, 0x3F, 0xFF, 0xFF, 0x2E, 0x2F,
	0xFF, 0xFA, 0x34, 0x10, 0x05, 0xF0, 0x36, 0x40,
	0x05, 0xF1, 0xB2, 0x03, 0xD1, 0x42, 0x34, 0x10,
	0x05, 0xF5, 0x2E, 0x6F, 0xFF, 0xEC, 0xB2, 0x03,
	0xD1, 0x42, 0x38, 0x38, 0x00, 0x00, 0x3C, 0x5D,
	0x03, 0x43, 0x0A, 0x83, 0xC8, 0x02, 0x2C, 0x2F,
	0xFF, 0xFF, 0x2C, 0x2F, 0xFF, 0xFF, 0x38, 0x37,
	0xFF, 0xFF, 0x3C, 0x1D, 0x03, 0x47, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0xC0, 0xC2, 0x30, 0x20, 0x05, 0xF4, 0x34, 0x40,
	0x05, 0xC3, 0x2F, 0x0F, 0xFF, 0xFC, 0x00, 0x03,
	0xC5, 0x90, 0x00, 0x03, 0xC1, 0x18, 0x34, 0x80,
	0x05, 0xC0, 0x34, 0x60, 0x05, 0xFC, 0xB4, 0x90,
	0x80, 0x00, 0x14, 0x93, 0xC2, 0x05, 0x3A, 0xDD,
	0x03, 0xC3, 0x3A, 0xFD, 0x03, 0x53, 0x00, 0x03,
	0xEB, 0xC1, 0x00, 0x03, 0xC6, 0x03, 0x0C, 0x98,
	0x00, 0x00, 0x00, 0x03, 0xC0, 0xD8, 0x00, 0x03,
	0xC2, 0x02, 0x04, 0xA8, 0x00, 0x00, 0x3C, 0x1D,
	0x03, 0x71, 0x00, 0x00, 0x80, 0x00, 0x15, 0xB0,
	0x00, 0x00, 0x3C, 0x3D, 0x03, 0x56, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x70, 0x00, 0x01, 0x30, 0x70,
	0x05, 0xF8, 0x35, 0x80, 0x05, 0xCD, 0x00, 0x03,
	0xC5, 0x90, 0x00, 0x03, 0xC1, 0x48, 0x34, 0x30,
	0x05, 0xCD, 0x00, 0x00, 0x90, 0x00, 0x30, 0x80,
	0x05, 0xCB, 0x34, 0x20, 0x05, 0xEA, 0xB4, 0xDB,
	0xD0, 0x10, 0x34, 0x20, 0x05, 0xC3, 0x2E, 0x8F,
	0xFF, 0xFC, 0xA4, 0xD8, 0xC4, 0x6C, 0x34, 0x20,
	0x05, 0xE9, 0xA4, 0xD8, 0x00, 0x00, 0x2E, 0xEF,
	0xFF, 0xFF, 0x30, 0x30, 0x05, 0xE8, 0x3A, 0xDD,
	0x03, 0xB7, 0x00, 0x00, 0xC0, 0x3C, 0x00, 0x00,
	0xB4, 0x6C, 0x39, 0x00, 0x00, 0x00, 0x34, 0x20,
	0x05, 0xF2, 0x00, 0x00, 0xD4, 0x42, 0x3C, 0x6D,
	0x03, 0x86, 0x00, 0x00, 0xC4, 0x42, 0x30, 0x20,
	0x05, 0xF2, 0x3A, 0xDD, 0x03, 0xC3, 0x3A, 0xFD,
	0x03, 0x7A, 0x00, 0x03, 0xEB, 0xC1, 0x30, 0x80,
	0x05, 0xCB, 0x34, 0x30, 0x05, 0xCD, 0x2E, 0xEF,
	0xFF, 0xFF, 0x00, 0x00, 0xC4, 0x6C, 0x34, 0x20,
	0x05, 0xE8, 0xA6, 0x93, 0xD0, 0x10, 0x30, 0x20,
	0x05, 0xE8, 0x00, 0x00, 0xC0, 0x3C, 0xB4, 0x90,
	0xB4, 0x6C, 0x30, 0x20, 0x0C, 0x21, 0x38, 0x00,
	0x04, 0x00, 0x32, 0x10, 0x0C, 0x20, 0x34, 0x20,
	0x0F, 0xFA, 0x00, 0x53, 0xD0, 0x02, 0x3C, 0x1D,
	0x03, 0x8D, 0x34, 0x30, 0x0C, 0x1B, 0x34, 0x00,
	0x0F, 0xFC, 0x3A, 0xDD, 0x03, 0xB7, 0x30, 0x20,
	0x07, 0x49, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x6D,
	0x03, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xC3, 0x83, 0x00, 0x00, 0xB3, 0x83, 0x30, 0x30,
	0x0C, 0x1B, 0x38, 0x8D, 0x03, 0xF3, 0x38, 0x9D,
	0x03, 0xFA, 0x34, 0x00, 0x05, 0xCB, 0x32, 0x10,
	0x0C, 0x14, 0x34, 0x00, 0x05, 0xCC, 0x32, 0x10,
	0x0C, 0x18, 0x00, 0x03, 0xF1, 0x02, 0x00, 0x00,
	0xD0, 0x02, 0x3C, 0x6D, 0x03, 0xB4, 0x00, 0x00,
	0xB0, 0x02, 0x00, 0x03, 0xE0, 0x85, 0x00, 0x06,
	0xA0, 0x8A, 0x00, 0x06, 0xA0, 0x8A, 0x00, 0x06,
	0xA0, 0x8A, 0x00, 0x06, 0x00, 0x8A, 0x38, 0x70,
	0x00, 0x08, 0x38, 0x6F, 0xF0, 0x00, 0x3A, 0x80,
	0x00, 0x04, 0x3A, 0xAD, 0x03, 0xB3, 0x38, 0x80,
	0x0D, 0x06, 0x3A, 0xDD, 0x03, 0xAA, 0x00, 0x03,
	0xF2, 0xA0, 0x00, 0x03, 0xCD, 0xA1, 0x3A, 0x80,
	0x00, 0x02, 0x3A, 0xAD, 0x03, 0xB2, 0x0B, 0xC0,
	0x00, 0x00, 0x0B, 0xC3, 0xC8, 0x42, 0x17, 0x93,
	0xC8, 0x43, 0x06, 0x90, 0x00, 0x00, 0x17, 0x9B,
	0xE0, 0x82, 0x06, 0xD8, 0x00, 0x00, 0x0B, 0xC3,
	0xE0, 0xC2, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xDD,
	0x00, 0x95, 0x3A, 0xFD, 0x03, 0xB7, 0x00, 0x03,
	0xEB, 0xC1, 0x34, 0x80, 0x05, 0xCC, 0x35, 0x80,
	0x05, 0xFD, 0x00, 0x03, 0xC5, 0xD0, 0x34, 0x20,
	0x0F, 0xFA, 0x00, 0x00, 0xC0, 0x82, 0x30, 0x20,
	0x0F, 0xFA, 0x00, 0x00, 0x80, 0x00, 0x30, 0x80,
	0x05, 0xCC, 0x39, 0x00, 0x00, 0x00, 0x00, 0x03,
	0xF0, 0x2D, 0x38, 0x00, 0x0C, 0x1F, 0x32, 0x10,
	0x0F, 0xFB, 0x35, 0x80, 0x05, 0xCD, 0x00, 0x03,
	0xC5, 0x90, 0x34, 0x80, 0x05, 0xCB, 0x00, 0x03,
	0xF0, 0x2D, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x34, 0x30, 0x05, 0xC6, 0x38, 0x20,
	0x0C, 0x06, 0xA6, 0x90, 0x00, 0x00, 0x00, 0x03,
	0xC0, 0x88, 0x34, 0x30, 0x05, 0xC8, 0x00, 0x03,
	0xF1, 0x02, 0xA6, 0x90, 0x00, 0x00, 0x00, 0x03,
	0xC0, 0x88, 0x34, 0x30, 0x05, 0xC7, 0x00, 0x03,
	0xF1, 0x02, 0x12, 0x93, 0xC0, 0x88, 0x30, 0x20,
	0x07, 0x42, 0x00, 0x03, 0xF1, 0x02, 0x30, 0x20,
	0x05, 0xCD, 0x2C, 0xF0, 0x00, 0x01, 0x3C, 0x6D,
	0x03, 0xDC, 0x38, 0x90, 0x05, 0xF9, 0x38, 0x80,
	0x0C, 0x09, 0x38, 0x80, 0x0C, 0x0E, 0x3E, 0x00,
	0x00, 0x03, 0x00, 0x06, 0x50, 0xCB, 0x00, 0x03,
	0xF0, 0x2D, 0x00, 0x06, 0x50, 0xCB, 0x00, 0x06,
	0x50, 0xCB, 0x00, 0x03, 0xC1, 0x28, 0x3A, 0xAD,
	0x03, 0xE5, 0x00, 0x03, 0xF0, 0x85, 0x1B, 0x5B,
	0xCD, 0x86, 0x1B, 0x93, 0xF0, 0x85, 0x00, 0x03,
	0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00, 0x3B, 0x60,
	0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0x00, 0x00, 0x00,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ecdisp.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    ecdisp.h

Abstract:

    This module contains the public declarations for the extended calls dialog
    box.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef _ECDISP_H_
#define _ECDISP_H_

typedef struct {
    HANDLE                    DeviceHandle;
    HIDP_REPORT_TYPE          ReportType;
    PHIDP_PREPARSED_DATA      Ppd;
    USAGE                     UsagePage;
    USAGE                     Usage;
    USHORT                    LinkCollection;
    UCHAR                     ReportID;
    PCHAR                     ReportBuffer;
    ULONG                     ReportLength;
    PVOID                     List;
    ULONG                     ListLength;
    ULONG                     Index;
    union {              
        struct {
            USHORT            ReportCount;
            USHORT            BitSize;
        };

        struct {
            PUSAGE            List2;
            PUSAGE            MakeList;
            PUSAGE            BreakList;
        };

        PHIDP_PREPARSED_DATA *ppPd;
        ULONG                 Value;
        LONG                  ScaledValue;
    };
} EXTCALL_PARAMS, *PEXTCALL_PARAMS;

typedef struct {
    BOOL                IsHidError;
    NTSTATUS            HidErrorCode;
    
} EXTCALL_STATUS, *PEXTCALL_STATUS;


/*****************************************************************************
/* Global Extended Call display function declarations
/*****************************************************************************/

LRESULT CALLBACK
bExtCallDlgProc(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam, 
    LPARAM lParam
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\hid.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    hid.h

Abstract:

    This module contains the declarations and definitions for use with the
    hid user mode client sample driver.

Environment:

    Kernel & user mode

@@BEGIN_DDKSPLIT

Revision History:

    Nov-96 : Created by Kenneth D. Ray

@@END_DDKSPLIT
--*/

#ifndef HID_H
#define HID_H

#include "hidsdi.h"
#include "setupapi.h"

typedef struct _SP_FNCLASS_DEVICE_DATA {
   DWORD cbSize;
   GUID  FunctionClassGuid;
   TCHAR DevicePath [ANYSIZE_ARRAY];
} SP_FNCLASS_DEVICE_DATA, *PSP_FNCLASS_DEVICE_DATA;

BOOLEAN
SetupDiGetFunctionClassDeviceInfo (
   IN    HDEVINFO                DeviceInfoSet,
   IN    PSP_DEVINFO_DATA        DeviceInfoData,
   OUT   PSP_FNCLASS_DEVICE_DATA FunctionClassDeviceData,
   IN    DWORD                   FunctionClassDeviceDataSize,
   OUT   PDWORD                  RequiredSize
   );

#define ASSERT(x)

//
// A structure to hold the steady state data received from the hid device.
// Each time a read packet is received we fill in this structure.
// Each time we wish to write to a hid device we fill in this structure.
// This structure is here only for convenience.  Most real applications will
// have a more efficient way of moving the hid data to the read, write, and
// feature routines.
//
typedef struct _HID_DATA {
   BOOLEAN     IsButtonData;
   UCHAR       Reserved;
   USAGE       UsagePage;   // The usage page for which we are looking.
   ULONG       Status;      // The last status returned from the accessor function
                            // when updating this field.
   ULONG       ReportID;    // ReportID for this given data structure
   BOOLEAN     IsDataSet;   // Variable to track whether a given data structure
                            //  has already been added to a report structure

   union {
      struct {
         ULONG       UsageMin;       // Variables to track the usage minimum and max
         ULONG       UsageMax;       // If equal, then only a single usage
         ULONG       MaxUsageLength; // Usages buffer length.
         PUSAGE      Usages;         // list of usages (buttons ``down'' on the device.

      } ButtonData;
      struct {
         USAGE       Usage; // The usage describing this value;
         USHORT      Reserved;

         ULONG       Value;
         LONG        ScaledValue;
      } ValueData;
   };
} HID_DATA, *PHID_DATA;

typedef struct _HID_DEVICE {   
    PCHAR                DevicePath;
    HANDLE               HidDevice; // A file handle to the hid device.
    BOOL                 OpenedForRead;
    BOOL                 OpenedForWrite;
    BOOL                 OpenedOverlapped;
    BOOL                 OpenedExclusive;
    
    PHIDP_PREPARSED_DATA Ppd; // The opaque parser info describing this device
    HIDP_CAPS            Caps; // The Capabilities of this hid device.
    HIDD_ATTRIBUTES      Attributes;

    PCHAR                InputReportBuffer;
    PHID_DATA            InputData; // array of hid data structures
    ULONG                InputDataLength; // Num elements in this array.
    PHIDP_BUTTON_CAPS    InputButtonCaps;
    PHIDP_VALUE_CAPS     InputValueCaps;

    PCHAR                OutputReportBuffer;
    PHID_DATA            OutputData;
    ULONG                OutputDataLength;
    PHIDP_BUTTON_CAPS    OutputButtonCaps;
    PHIDP_VALUE_CAPS     OutputValueCaps;

    PCHAR                FeatureReportBuffer;
    PHID_DATA            FeatureData;
    ULONG                FeatureDataLength;
    PHIDP_BUTTON_CAPS    FeatureButtonCaps;
    PHIDP_VALUE_CAPS     FeatureValueCaps;
} HID_DEVICE, *PHID_DEVICE;


BOOLEAN
OpenHidDevice (
    IN       PCHAR          DevicePath,
    IN       BOOL           HasReadAccess,
    IN       BOOL           HasWriteAccess,
    IN       BOOL           IsOverlapped,
    IN       BOOL           IsExclusive,
    IN       BOOL           GetDeviceInfo,
    IN OUT   PHID_DEVICE    HidDevice
);

BOOLEAN
FindKnownHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   );

BOOLEAN
FillDeviceInfo(
    IN  PHID_DEVICE HidDevice
);

VOID
CloseHidDevices (
   OUT PHID_DEVICE   HidDevices, // A array of struct _HID_DEVICE
   OUT ULONG         NumberDevices // the length of this array.
   );

VOID
CloseHidDevice (
    IN PHID_DEVICE   HidDevice,
    IN BOOL          FreeDeviceInfo
    );


BOOLEAN
Read (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
ReadOverlapped (
    PHID_DEVICE     HidDevice,
    HANDLE          CompletionEvent
   );
   
BOOLEAN
Write (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );

BOOLEAN
SetFeature (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
GetFeature (
   PHID_DEVICE    HidDevice
   );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\hclient.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    hclient.h

Abstract:

    This module contains the public declarations and definitions that are
    defined in hclient.c and available to other modules outside of it.
              
Environment:

    User mode

Revision History:

    Nov-97 : Created 

--*/

#ifndef __HCLIENT_H__
#define __HCLIENT_H__

#define WM_UNREGISTER_HANDLE    WM_USER+1
#define WM_DISPLAY_READ_DATA    WM_USER+2
#define WM_READ_DONE            WM_USER+3

#define READ_THREAD_TIMEOUT     1000

#define HCLIENT_ERROR           "HClient Error"

typedef struct _READ_THREAD_CONTEXT 
{
    PHID_DEVICE HidDevice;

    HWND        DisplayWindow;
    HANDLE      DisplayEvent;

    BOOL        DoOneRead;
    BOOL        TerminateThread;

} READ_THREAD_CONTEXT, *PREAD_THREAD_CONTEXT;


typedef NTSTATUS __stdcall GETEXTATTRIB (
    HIDP_REPORT_TYPE,
    USHORT,
    PHIDP_PREPARSED_DATA,
    PHIDP_EXTENDED_ATTRIBUTES,
    PULONG);

typedef GETEXTATTRIB *PGETEXTATTRIB;

typedef NTSTATUS __stdcall INITREPORT (
    HIDP_REPORT_TYPE,
    UCHAR,
    PHIDP_PREPARSED_DATA,
    PCHAR,
    ULONG);

typedef INITREPORT *PINITREPORT;


extern PGETEXTATTRIB pfnHidP_GetExtendedAttributes;

extern PINITREPORT   pfnHidP_InitializeReportForID;

VOID
vDisplayDeviceAttributes(
    IN PHIDD_ATTRIBUTES pAttrib,
    IN HWND             hControl
);

VOID
vDisplayButtonAttributes(
    IN PHIDP_BUTTON_CAPS pButton,
    IN HWND              hControl
);

VOID
vDisplayDataAttributes(
    PHIDP_DATA pData, 
    BOOL IsButton, 
    HWND hControl
);

VOID
vCreateUsageAndPageString(
    IN  PUSAGE_AND_PAGE   pUsageList,
    OUT CHAR              szString[]
);

VOID
vCreateUsageString(
    IN  PUSAGE   pUsageList,
    OUT CHAR     szString[]
);

VOID
vDisplayDeviceCaps(
    IN PHIDP_CAPS pCaps,
    IN HWND       hControl
);

VOID 
vDisplayValueAttributes(
    IN PHIDP_VALUE_CAPS pValue,
    IN HWND             hControl
);

VOID
vDisplayLinkCollectionNode(
    IN  PHIDP_LINK_COLLECTION_NODE  pLCNode,
    IN  ULONG                       ulLinkIndex,
    IN  HWND                        hControl
);

VOID
vCreateUsageValueStringFromArray(
    PCHAR       pBuffer,
    USHORT      BitSize,
    USHORT      UsageIndex,
    CHAR        szString[]
);

VOID 
vDisplayValueAttributes(
    IN PHIDP_VALUE_CAPS pValue,
    IN HWND hControl
);

DWORD WINAPI
AsynchReadThreadProc(
    PREAD_THREAD_CONTEXT    Context
);

DWORD WINAPI
SynchReadThreadProc(
    PREAD_THREAD_CONTEXT    Context
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\list.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    list.h

Abstract:

    This module contains the code for manipulating list structures.

Environment:

    User mode

Revision History:

    Nov-97 : Created 

--*/


#ifndef __LIST_H__
#define __LIST_H__

#include <windows.h>

typedef LIST_ENTRY      LIST_NODE_HDR, *PLIST_NODE_HDR;
typedef LIST_NODE_HDR   LIST, *PLIST;

typedef VOID PLIST_CALLBACK(PLIST_NODE_HDR);

VOID
InitializeList(
    IN  PLIST   NewList
);

VOID
InsertHead(
    IN  PLIST           List,
    IN  PLIST_NODE_HDR  ListNode
);

VOID
InsertTail(
    IN  PLIST           List,
    IN  PLIST_NODE_HDR  ListNode
);

VOID
RemoveNode(
    IN  PLIST_NODE_HDR  ListNode   
);

PLIST_NODE_HDR
RemoveHead(
    IN  PLIST   List
);

PLIST_NODE_HDR
RemoveTail(
    IN  PLIST   List
);

BOOL
IsListEmpty(
    IN  PLIST   List
);

PLIST_NODE_HDR
GetListHead(
    IN  PLIST   List
);

PLIST_NODE_HDR
GetListTail(
    IN  PLIST   List
);

PLIST_NODE_HDR
GetNextEntry(
    IN  PLIST_NODE_HDR  ListNode
);

PLIST_NODE_HDR
GetPrevEntry(
    IN  PLIST_NODE_HDR  ListNode
);

VOID
DestroyListNoCallback(
    IN  PLIST           List
);

VOID
DestroyListWithCallback(
    IN  PLIST           List,
    IN  PLIST_CALLBACK  Callback
);


/*****************************************************************************
/* Macro definitions of list functions
/*****************************************************************************/

    /*
    // VOID
    // InitializeList(
    //     IN  PLIST    NewList
    // );
    */
    
    #define InitializeList(nl) \
        { ((PLIST)(nl)) -> Flink = ((PLIST)(nl)) -> Blink = nl; }
    
    /* 
    // VOID
    // InsertHead(
     /     IN  PLIST            List,
    //     IN  PLIST_NODE_HDR   ListNode
    // );
    */
    
    #define InsertHead(List, Node) {                    \
        PLIST_NODE_HDR _EX_Flink;                       \
        PLIST_NODE_HDR _EX_List;                        \
                                                        \
        _EX_List = ((PLIST_NODE_HDR) (List));           \
        _EX_Flink = _EX_List -> Flink;                  \
        ((PLIST_NODE_HDR) (Node))->Blink = _EX_List;    \
        ((PLIST_NODE_HDR) (Node))->Flink = _EX_Flink;   \
        _EX_Flink->Blink = (((PLIST_NODE_HDR) (Node))); \
        _EX_List->Flink = ((PLIST_NODE_HDR) (Node));    \
    }
    
    
    /* 
    // VOID
    // InsertTail(
    //     IN  PLIST            List,
    //     IN  PLIST_NODE_HDR   ListNode
    // );
    */
    
    #define InsertTail(List, Node) {                    \
        PLIST_NODE_HDR _EX_Blink;                       \
        PLIST_NODE_HDR _EX_List;                        \
                                                        \
        _EX_List = ((PLIST_NODE_HDR) (List));           \
        _EX_Blink = _EX_List->Blink;                    \
        ((PLIST_NODE_HDR) (Node))->Flink = _EX_List;    \
        ((PLIST_NODE_HDR) (Node))->Blink = _EX_Blink;   \
        _EX_Blink->Flink = (((PLIST_NODE_HDR) (Node))); \
        _EX_List->Blink = ((PLIST_NODE_HDR) (Node));    \
    }
    
    /*
    //  VOID
    //  RemoveNode(
    //      IN  PLIST_NODE_HDR  ListNode   
    //  );
    */
    
    #define RemoveNode(node) {                          \
        PLIST_NODE_HDR _EX_Blink;                       \
        PLIST_NODE_HDR _EX_Flink;                       \
                                                        \
        _EX_Flink = ((PLIST_NODE_HDR) (node))->Flink;   \
        _EX_Blink = ((PLIST_NODE_HDR) (node))->Blink;   \
        _EX_Blink->Flink = _EX_Flink;                   \
        _EX_Flink->Blink = _EX_Blink;                   \
    }
    
    
    /* 
    // PLIST_NODE_HDR
    // RemoveHead(
    //     IN  PLIST    List
    // );               
    */                  
    
    #define RemoveHead(List)                            \
        GetListHead((List));                            \
        RemoveNode(((PLIST_NODE_HDR) (List))->Flink)  
                        
    /*                  
    // PLIST_NODE_HDR   
    // RemoveTail(      
    //     IN  PLIST    List
    // );               
    */                  
    
    #define RemoveTail(List)                            \
        GetListTail((List));                            \
        RemoveNode(((PLIST_NODE_HDR) (List))->Blink)    
    
    /*                  
    // BOOL             
    // IsListEmpty(     
    //     IN  PLIST    List
    // );               
    */                  
    
    #define IsListEmpty(List)                           \
        (((PLIST_NODE_HDR) (List))->Flink == ((PLIST_NODE_HDR) (List)))
                        
    /*                  
    // PLIST_NODE_HDR   
    // GetListHead(     
    //     IN  PLIST    List
    // );               
    */                  
    
    #define GetListHead(List)                           \
        (((PLIST_NODE_HDR) (List))->Flink)
    
    /*                  
    // PLIST_NODE_HDR   
    // GetListTail(     
    //     IN  PLIST    List
    // );               
    */                  
    
    #define GetListTail(List)                           \
        (((PLIST_NODE_HDR) (List))->Blink)
                        

    /*
    // PLIST_NODE_HDR
    // GetNextEntry(
    //    IN  PLIST_NODE_HDR  ListNode
    // );
    */

    #define GetNextEntry(ListNode)                      \
        (((PLIST_NODE_HDR) (ListNode)) -> Flink);

    /* 
    // PLIST_NODE_HDR
    // GetPrevEntry(
    //    IN  PLIST_NODE_HDR  ListNode
    // );
    */

    #define GetPrevEntry(ListNode)                      \
        (((PLIST_NODE_HDR) (ListNode)) -> Blink);

    /* 
    // VOID
    // DestroyListNoCallback(
    //     IN  PLIST           List,
    //     IN  PLIST_CALLBACK  Callback
    // );
    */ 
    
    #define DestroyListNoCallback(list)                 \
        PLIST_NODE_HDR  currNode;                       \
                                                        \
        while (!IsListEmpty((list))) {                  \
            currNode = RemoveHead((list));              \
        }                                               \
    }

    /* 
    // VOID
    // DestroyListWithCallback(
    //     IN  PLIST           List,
    //     IN  PLIST_CALLBACK  Callback
    // );
    */ 
    
    #define DestroyListWithCallback(list, cb) {         \
        PLIST_NODE_HDR  currNode;                       \
                                                        \
        while (!IsListEmpty((list))) {                  \
            currNode = RemoveHead((list));              \
            (cb)(currNode);                             \
        }                                               \
    }
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\hidtest.h ===
#ifndef __HIDTEST_H__
    #define __HIDTEST_H__

    /*****************************************************************************
    /* Exportable typedefs 
    /*****************************************************************************/
    
    typedef PTSTR   DEVICE_STRING;
    
    typedef struct  _HidTestStatus
    {
        ULONG   nOperationsPerformed;
        ULONG   nOperationsPassed;
        ULONG   nOperationsFailed;
    
    } HIDTEST_STATUS, *PHIDTEST_STATUS;
    
    typedef struct _HidDeviceInfo
    {
        HANDLE               HidDeviceHandle;
        DEVICE_STRING        HidDeviceString;
        PHIDP_PREPARSED_DATA HidDevicePpd;
        PHIDD_ATTRIBUTES     HidDeviceAttributes;
        PHIDP_CAPS           HidDeviceCaps;
    
        BOOL                 IsPhysicalDevice;
    
    } HIDTEST_DEVICEINFO, *PHIDTEST_DEVICEINFO;
    
    
    typedef VOID HIDTEST_API(PHIDTEST_DEVICEINFO, ULONG, PHIDTEST_STATUS);
    
    typedef HIDTEST_API *PHIDTEST_API;
    
    typedef BOOL (*PCREATE_PHYSICAL_DEVICE_INFO_PROC)(DEVICE_STRING,
                                                      BOOL,
                                                      PHIDTEST_DEVICEINFO
                                                     );
    
    typedef BOOL (*PCREATE_LOGICAL_DEVICE_INFO_PROC)(PCHAR,
                                                     ULONG,
                                                     PHIDTEST_DEVICEINFO
                                                    );
    
    typedef VOID (*PCREATE_FREE_DEVICE_INFO_PROC)(PHIDTEST_DEVICEINFO);
    
    typedef BOOL (*PCREATE_TEST_LOG_PROC)(PCHAR);
    
    typedef VOID (*PSET_LOG_ON_PROC)(BOOL);

    typedef VOID (*PCLOSE_TEST_LOG_PROC)(VOID);

    typedef struct _functions {

        PHIDTEST_API HIDTest_VerifyHidGuid;
        PHIDTEST_API HIDTest_VerifyStrings;
        PHIDTEST_API HIDTest_VerifyPreparsedData;
        PHIDTEST_API HIDTest_VerifyAttributes;
        PHIDTEST_API HIDTest_VerifyCapabilities;

        PCREATE_PHYSICAL_DEVICE_INFO_PROC  HIDTest_CreatePhysicalDeviceInfo;
        PCREATE_LOGICAL_DEVICE_INFO_PROC   HIDTest_CreateLogicalDeviceInfo;
        PCREATE_FREE_DEVICE_INFO_PROC      HIDTest_FreeDeviceInfo;
        PCREATE_TEST_LOG_PROC              HIDTest_CreateTestLog;
        PSET_LOG_ON_PROC                   HIDTest_SetLogOn;
        PCLOSE_TEST_LOG_PROC               HIDTest_CloseTestLog;

    } HIDTEST_FUNCTIONS, *PHIDTEST_FUNCTIONS;

    typedef VOID (*PINIT_PROC)(PHIDTEST_FUNCTIONS);

    #define HIDTest_AllocateDeviceString(nChars) ALLOC(((nChars)+1) * sizeof(TCHAR))
    #define HIDTest_FreeDeviceString(String)     FREE(String)

    /*
    // Declare the exportable function as normal function declarations when
    //    this file is include in HIDTEST.C.  Otherwise, we want to declare
    //    our pointers to these functions as external variables
    */

    #ifdef __HIDTEST_C__

        VOID
        HIDTest_InitExportAddress(
            PHIDTEST_FUNCTIONS  Exports
        );

        HIDTEST_API HIDTest_VerifyHidGuidA;
        HIDTEST_API HIDTest_VerifyStringsA;
        HIDTEST_API HIDTest_VerifyPreparsedDataA;
        HIDTEST_API HIDTest_VerifyAttributesA;
        HIDTEST_API HIDTest_VerifyCapabilitiesA;
        
        VOID
        HIDTest_VerifyPhysicalDesc(
            IN  HANDLE          HidDevice,
            IN  PCHAR           PhysDesc,
            IN  ULONG           PhysDescLength,
            IN  ULONG           nIterations,
            OUT PHIDTEST_STATUS Status
        );
        
        VOID
        HIDTest_VerifyFeatures(
            IN  HANDLE              HidDevice,
            IN  PHIDP_BUTTON_CAPS   FeatureButtonCaps,
            IN  PHIDP_VALUE_CAPS    FeatureValueCaps,
            IN  ULONG               nIterations,
            OUT PHIDTEST_STATUS     Status
            
        );
        
        VOID
        HIDTest_VerifyConfiguratons(
            IN  HANDLE          HidDevice,
            IN  ULONG           nConfigurations,
            IN  BOOL            RestoreCurrentConfig,
            IN  ULONG           nIterations,
            OUT PHIDTEST_STATUS Status
        
        );
        
        VOID
        HIDTest_VerifyInputButtons(
            IN  HANDLE          HidDevice,
            IN  ULONG           nBuffers,
            IN  BOOL            RestoreCurrentCount,
            IN  ULONG           nIterations,
            OUT PHIDTEST_STATUS Status
        );
        
        VOID
        HIDTest_VerifyDevices(
            IN  ULONG           nStrings,
            IN  DEVICE_STRING   DeviceStrings[],
            IN  ULONG           nIterations,
            OUT PHIDTEST_STATUS Status
        );
        
        VOID
        HIDTest_VerifyLinkCollections(
            IN  PHIDP_PREPARSED_DATA       Ppd,
            IN  PHIDP_LINK_COLLECTION_NODE CollectionList,
            IN  ULONG                      nCollections,
            IN  ULONG                      nIterations,
            OUT PHIDTEST_STATUS            Status
        );
        
        BOOL
        HIDTest_CreatePhysicalDeviceInfoA(
            IN  DEVICE_STRING       DeviceName,
            IN  BOOL                OpenOverlapped,
            OUT PHIDTEST_DEVICEINFO DeviceInfo
        );
        
        BOOL
        HIDTest_CreateLogicalDeviceInfoA(
            IN  PCHAR                 DevicePpd,
            IN  ULONG                 DevicePpdLength,
            OUT PHIDTEST_DEVICEINFO   DeviceInfo
        );
        
        VOID
        HIDTest_FreeDeviceInfoA(
            IN  PHIDTEST_DEVICEINFO DeviceInfo
        );
        
        BOOL
        HIDTest_CreateTestLogA(
            IN  PCHAR  LogFileName
        );
        
        VOID
        HIDTest_SetLogOnA(
            BOOL    TurnOn
        );

        VOID
        HIDTest_CloseTestLogA(
            VOID
        );
    
    #else

        /*
        // Declare this structure.  This structure will be mapped into an user
        //    space which might possibly use HIDTEST.DLL.  Any program that
        //    uses HIDTest needs to use the HIDTEST_INIT() macro before calling
        //    any of the functions.  This macro will take care of resolving all
        //    the function addresses. 
        */

        HIDTEST_FUNCTIONS   HIDTest_Exports;

        /*
        // This is the definition of the HIDTEST_INIT() macro which initializes
        //    all the function address that are exported by the DLL.
        */

        #define HIDTEST_INIT()  \
        { \
            PINIT_PROC INIT_PROC; \
            \
            INIT_PROC = (PINIT_PROC) GetProcAddress(GetModuleHandle("HIDTEST.DLL"), \
                                                    "HIDTest_InitExportAddress" \
                                                   ); \
            \
            INIT_PROC(&HIDTest_Exports); \
        }

        /*
        // These are the defines that are used by the HIDTest to access the
        //    exported testing functions.
        */

        #define HIDTest_VerifyHidGuid               HIDTest_Exports.HIDTest_VerifyHidGuid
        #define HIDTest_VerifyStrings               HIDTest_Exports.HIDTest_VerifyStrings
        #define HIDTest_VerifyPreparsedData         HIDTest_Exports.HIDTest_VerifyPreparsedData
        #define HIDTest_VerifyAttributes            HIDTest_Exports.HIDTest_VerifyAttributes
        #define HIDTest_VerifyCapabilities          HIDTest_Exports.HIDTest_VerifyCapabilities

        #define HIDTest_CreatePhysicalDeviceInfo    HIDTest_Exports.HIDTest_CreatePhysicalDeviceInfo
        #define HIDTest_CreateLogicalDeviceInfo     HIDTest_Exports.HIDTest_CreateLogicalDeviceInfo
        #define HIDTest_FreeDeviceInfo              HIDTest_Exports.HIDTest_FreeDeviceInfo
        #define HIDTest_CreateTestLog               HIDTest_Exports.HIDTest_CreateTestLog
        #define HIDTest_SetLogOn                    HIDTest_Exports.HIDTest_SetLogOn
        #define HIDTest_CloseTestLog                HIDTest_Exports.HIDTest_CloseTestLog
        
    #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\resource.h ===
#define IDC_STATIC                      -1

#define IDD_SET_BUTTONS                 108
#define IDD_SET_SCALED_VALUE            109
#define IDD_SET_USAGE_VALUE             110
#define IDD_AUTOTEST_PARAMS             111
#define IDD_SET_USAGE_VALUE_ARRAY       112
#define IDD_USAGE_LIST_DIFFERENCE       113
#define IDD_UNSET_BUTTONS               114
#define IDD_UNSET_USAGES                115
#define IDD_SET_DATA                    116
#define IDD_SET_BUFFER_LENGTH           117
#define IDD_SET_INPUT_BUFFERS           118
#define IDD_GET_INDEX_STRING            119
#define IDD_SET_USAGES                  120
#define IDD_AUTOTEST_RESULTS            121
#define IDD_AUTOTEST_NEW                122
#define IDD_GET_EXT_ATTRIB              123
#define IDC_DEVICES                     1001
#define IDC_TYPE                        1002
#define IDC_ITEMS                       1003
#define IDC_ATTRIBUTES                  1004
#define IDC_READ                        1005
#define IDC_ABOUT                       1006
#define IDC_WRITE                       1007
#define IDC_EXTCALLS                    1008
#define IDC_SEND                        1100
#define ID_SEND                         1100
#define IDC_OUTPUT                      1101
#define IDC_EDIT1                       1102
#define IDC_USAGEPAGE                   1102
#define IDC_USAGE_LIST                  1102
#define IDC_STRING_INDEX                1102
#define IDC_LOGFILE                     1102
#define IDC_REPORTID                    1103
#define IDC_USAGE_LIST2                 1103
#define box                             1111
#define IDC_SCROLLBAR1                  1121
#define IDC_SCROLLBAR                   1121
#define IDC_INPUT                       1122
#define IDC_FEATURE                     1124
#define IDC_USAGE                       1126
#define IDC_LINKCOLL                    1127
#define IDC_CALLOUTPUT                  1128
#define IDC_EXECUTE                     1129
#define IDC_CANCEL                      1130
#define IDC_FEATURES                    1131
#define IDC_SET_PARAMS                  1131
#define IDC_REPORT_BUFFER               1132
#define IDC_INPUT_BUFFER                1132
#define IDC_BUFFER_TYPE                 1133
#define IDC_BUFFER_SIZE                 1134
#define IDC_INPUT_SELECT                1135
#define IDC_FEATURE_BUFFER              1136
#define IDC_USAGE_PAGE                  1136
#define IDC_FEATURE_SELECT              1137
#define IDC_OUTPUT_BUFFER               1138
#define IDC_VALUE                       1138
#define IDC_OUTPUT_SELECT               1139
#define IDC_INDEX                       1142
#define IDC_ADD_DATA                    1143
#define IDC_REMOVE_DATA                 1144
#define IDC_DATA_LIST                   1145
#define IDC_INPUT_BUFFERS               1147
#define IDC_BUFFER_LENGTH               1149
#define IDC_USAGE_LIST1                 1150
#define IDC_START_TESTS                 1151
#define IDC_LOAD_LOGICAL_DEVICE         1152
#define IDC_USELOG                      1152
#define IDC_INFINITE                    1153
#define IDC_PPD_ITS                     1154
#define IDC_STRESSLOG                   1154
#define IDC_RUN_PPD                     1155
#define IDC_RUN_CAPS                    1156
#define IDC_RUN_ATTRIB                  1157
#define IDC_RUN_STRINGS                 1158
#define IDC_RUN_GUID                    1159
#define IDC_ITERATIONS                  1160
#define IDC_CAPS_ITS                    1161
#define IDC_ATT_ITS                     1162
#define IDC_STR_ITS                     1163
#define IDC_GUID_ITS                    1164
#define IDC_TEST_ITS                    1165
#define IDC_RUN_BUFFERS                 1165
#define IDC_BUFFER_ITS                  1166
#define IDC_STOP_TESTS                  1167
#define IDC_RUN_GETFEATURE              1167
#define IDC_GETFEA_ITS                  1168
#define IDC_GETFEAT_ITS                 1168
#define IDC_LOGFILENAME                 1169
#define IDC_RUN_SETFEATURE              1169
#define IDC_SETFEA_ITS                  1170
#define IDC_TEST_RESULTS                1172
#define IDC_DEVICE_LIST                 1174
#define IDC_END_TESTS                   1175
#define IDC_READ_SYNCH                  1176
#define IDC_READ_ASYNCH_ONCE            1177
#define IDC_READ_ASYNCH                 1177
#define IDC_READ_ASYNCH_CONT            1178
#define IDC_RUN_LIST                    1178
#define IDC_NRUN_LIST                   1179
#define IDC_REMOVE_TEST                 1180
#define IDC_ADD_TEST                    1181
#define IDC_DESELECT_RUN                1182
#define IDC_SELECT_RUN                  1183
#define IDC_DESELECT_NRUN               1184
#define IDC_SELECT_NRUN                 1185
#define IDC_SET_ITERATIONS              1186
#define IDC_OUT_LABEL1                  2000
#define IDC_OUT_LABEL2                  2001
#define IDC_OUT_LABEL3                  2002
#define IDC_OUT_LABEL4                  2003
#define IDC_OUT_LABEL5                  2004
#define IDC_OUT_LABEL6                  2005
#define IDC_OUT_LABEL7                  2006
#define IDC_OUT_LABEL8                  2007
#define IDC_OUT_LABEL9                  2008
#define IDC_OUT_EDIT1                   3000
#define IDC_OUT_EDIT2                   3001
#define IDC_OUT_EDIT3                   3002
#define IDC_OUT_EDIT4                   3003
#define IDC_OUT_EDIT5                   3004
#define IDC_OUT_EDIT6                   3005
#define IDC_OUT_EDIT7                   3006
#define IDC_OUT_EDIT8                   3007
#define IDC_OUT_EDIT9                   3008

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        122
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1188
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\strings.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    strings.c

Abstract:

    This module contains code for converting data buffers and integer values
    to and from string representation for display.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>
#include "strings.h"

#define ROUND_UP_ON_DIVIDE(d, n)    (0 == ((d) % (n)) ? ((d)/(n)) : ((d)/(n))+1)

VOID
Strings_CreateDataBufferString(
    IN  PCHAR    DataBuffer,
    IN  ULONG    DataBufferLength,
    IN  ULONG    NumBytesToDisplay,
    IN  ULONG    DisplayBlockSize,
    OUT PCHAR    *BufferString
)
/*++
Routine Description:
    This routine takes a DataBuffer of size DataBufferLength and creates a string
    in BufferString that contains a string representation of the bytes stored in
    data buffer.  

    The parameter NumBytesToDisplay tells the routine the maximum number of bytes
    from the buffer to display.  For instance, a caller may only want to convert
    the first four bytes of an eight byte buffer to a string

    The parameter DisplayBlockSize indicates how many bytes should be grouped 
    together in the display.  Valid values are 1, 2, 4 and would indicate whether
    the displayed bytes should be displayed as bytes, words, or dwords.

    The routine allocates a buffer big enough to store the data.  Callers of this
    routine are responsible for freeing this string buffer.  
--*/
{
    ULONG   BufferStringLength;
    ULONG   MaxDisplayedBytes;
    PUCHAR  NextByte;
    PUCHAR  String;
    PUCHAR  CurrentBufferOffset;
    INT     nFullIterations;
    INT     LeftOverBytes;
    INT     IterationIndex;
    INT     ByteOffset;

    /*
    // Determine the maximum number of bytes that will be displayed in 
    //    the string
    */
    
    MaxDisplayedBytes = (NumBytesToDisplay > DataBufferLength) ? DataBufferLength
                                                               : NumBytesToDisplay;

    /*
    // Determine the size of the string we'll need: This is based on the 
    //   maximum number of displayed bytes (MaxDisplayedBytes) and the 
    //   DisplayBlockSize
    */

    BufferStringLength = 2*MaxDisplayedBytes + ROUND_UP_ON_DIVIDE(MaxDisplayedBytes,
                                                                  DisplayBlockSize
                                                                 );

    /*
    // Now we need to allocate string space
    */

    String = (PCHAR) malloc(BufferStringLength * sizeof(CHAR));

    if (NULL != String) {

        /*
        // Determine how many iterations through the conversion routine must be made.
        */
        
        nFullIterations = MaxDisplayedBytes / DisplayBlockSize;

        /*
        // Initialize our variables which point to data in the buffer to convert
        //   and the byte in the string in which to put the converted data value. 
        //   Next byte is set to String-1 because it is incremented on entry into the
        //   loop.
        */
        
        CurrentBufferOffset = DataBuffer;
        NextByte = String-1;

        /*
        // Each iteration of the loop creates a block of DisplayBlockSize.  Any
        //   partial iterations are performed afterwards if the number of bytes
        //   to display is not a multiple of the display block size
        */
        
        for (IterationIndex = 0; IterationIndex < nFullIterations; IterationIndex++) 
        {
            NextByte++;

            /*
            // Output a block of data size.  Notice the bytes are accessed in
            //    reverse order to display the the MSB of a block as the first
            //    value in the string
            */
            
            for (ByteOffset = DisplayBlockSize-1; ByteOffset >= 0; ByteOffset--) 
            {
                wsprintf(NextByte, "%02X", *(CurrentBufferOffset+ByteOffset));

                NextByte += 2;
            }

            /*
            // Insert the space to separate blocks
            */
            
            *(NextByte) = ' ';

            CurrentBufferOffset += DisplayBlockSize;
        }

        /*
        // Resolve any other bytes that are left over
        */
        
        LeftOverBytes = (MaxDisplayedBytes % DisplayBlockSize);

        if (0 == LeftOverBytes) 
        {
            *(NextByte) = '\0';
        }

        for (ByteOffset = LeftOverBytes-1, NextByte++; ByteOffset >= 0; ByteOffset--) 
        {
            wsprintf(NextByte, "%02X", *(CurrentBufferOffset+ByteOffset));
            NextByte += 2;
        }
    }
    
    *BufferString = String;

    return;
}

BOOL
Strings_StringToUnsignedList(
    IN  PCHAR   InString,
    IN  ULONG   UnsignedSize,
    IN  ULONG   Base,
    OUT PCHAR   *UnsignedList,
    OUT PULONG  nUnsigneds
)
/*++
Routine Description:
    This routine takes an input string, InString, and creates a list of unsigned
    values of all the values that are in the list.  The caller can specify a
    base, Base, for all the numbers in the list or specify 0 to let the function
    determine the base depending on the format of the number in the string.

    The parameter UnsignedSize specifies the size of unsigneds to store in the list.
    
    The routine allocates a CHAR buffer to store the list of unsigned values.  

    On exit, nUnsigneds will report the number of unsigned values stored in 
    UnsignedList.
    
    The function will return TRUE if it could convert all of the numbers in the
    string into the unsigned list.  It will return FALSE if there was a problem
    with the string or if there was a problem allocating memory to store the 
    unsigned list.  
--*/
{
    CHAR    tokDelims[] = "\t,; ";
    PCHAR   strToken;
    PCHAR   endp;
    BOOL    fStatus;
    ULONG   ulValue;
    PCHAR   pList;
    PCHAR   pNewList;
    ULONG   nAllocUnsigneds;
    ULONG   nActualUnsigneds;
    ULONG   ulMaxValue;

    /*
    // Begin by initializing our unsigned list
    //      1) Start with initial allocation for 2 unsigneds, this will
    //          be expanded if necessary
    //      2) If initial allocation fails, return FALSE;
    */

    nAllocUnsigneds = 2;
    nActualUnsigneds = 0;

    pList = (PCHAR) malloc(nAllocUnsigneds * sizeof(ULONG));

    if (NULL == pList) 
    {
        return (FALSE);
    }

    /*
    // Calculate the maximum value that can be represented with the value for
    //   iBufferSize;
    */

    ulMaxValue = (sizeof(ULONG) == UnsignedSize) ? ULONG_MAX 
                                                 : (1 << (UnsignedSize*8)) - 1;

    /*
    // Begin our processing of the token string.
    //  1) Set fStatus to TRUE to get through loop the first time
    //  2) Try to get the first token -- if we can't get the first token
    //        then we pass through loop
    */

    fStatus = TRUE;

    strToken = strtok(InString, tokDelims);

    /*
    // Loop until there are no more tokens or we detect an error (fStatus == FALSE)
    */

    while (NULL != strToken && fStatus) 
    {
        /*
        // Set fStatus initially to false.  Only if nothing goes wrong in 
        //    the loop will this get set to TRUE
        */

        fStatus = FALSE;

        /*
        // Attempt to convert the token
        */

        ulValue = strtoul(strToken, &endp, Base);

        /*
        // To be a valid value, *endp must point to the NULL character
        */

        if ('\0' == *endp) 
        {
            /*
            // Check to see that the ulValue found is less than or equal to 
            //     the maximum allowed by UnsignedSize.
            */

            if (ulValue <= ulMaxValue) 
            {    
                /*
                // If we're set to overrun our buffer, attempt to allocate
                //    more space.  If we can't then release the old space
                //    and fail the loop.  
                */

                if (nAllocUnsigneds == nActualUnsigneds) 
                {
                    nAllocUnsigneds *= 2;

                    pNewList = (PCHAR) realloc(pList, UnsignedSize*nAllocUnsigneds);

                    if (NULL == pNewList)
                    {
                        break;
                    }
                    pList = pNewList;
                }

                /*
                // Add the token to the end of the list of unsigneds
                */

                memcpy(pList + (UnsignedSize * nActualUnsigneds),
                       &ulValue,
                       UnsignedSize);

                nActualUnsigneds++;

                /*
                // Prepare to reenter the loop.  Set fStatus = TRUE 
                //    Try to get another token
                */

                fStatus = TRUE;

                strToken = strtok(NULL, tokDelims);
            }
        }
    }

    /*
    // If the loop failed for some reason or we found no unsigneds
    //     release the list
    */

    if (!fStatus || 0 == nActualUnsigneds) 
    {
        free(pList);
        pList = NULL;
        nActualUnsigneds = 0;
    }

    *UnsignedList = pList;
    *nUnsigneds = nActualUnsigneds;
    
    return (fStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\logpnp.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    logpnp.h

Abstract:

    This module contains the public function declarations for finding, loading
    and creating logical HID device structures.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef __LOGPNP_H__
#define __LOGPNP_H__

BOOL
LogPnP_LoadLogicalDevice(
    IN     PCHAR        OptFileName,
    IN OUT PHID_DEVICE  HidDevice  
);

BOOL
LogPnP_LoadPpdFromFile(
    IN  PCHAR   FileName,
    OUT PHIDP_PREPARSED_DATA   *PpdBuffer,
    OUT PULONG  PpdBufferLength
);

VOID
LogPnP_CloseLogicalHIDDevices(
    IN  PHID_DEVICE LogicalDeviceList,
    IN  ULONG       NumLogicalDevices
);

BOOL
LogPnP_IsLogicalDevice(
    IN  PHID_DEVICE HidDevice
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\strings.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    strings.h

Abstract:

    This module contains the public function definitions for the routines
    in strings.c that handle conversion of integer/data buffer to/from 
    string represenation

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef __STRINGS_H__
#define __STRINGS_H__

VOID
Strings_CreateDataBufferString(
    IN  PCHAR    DataBuffer,
    IN  ULONG    DataBufferLength,
    IN  ULONG    NumBytesToDisplay,
    IN  ULONG    DisplayBlockSize,
    OUT PCHAR    *BufferString
);

VOID
Strings_StringToUnsigned(
    IN  PCHAR   InString,
    IN  ULONG   Base,
    OUT PCHAR   *endp,
    OUT PULONG  pValue
);

BOOL
Strings_StringToUnsignedList(
    IN  PCHAR   InString,
    IN  ULONG   UnsignedSize,
    IN  ULONG   Base,
    OUT PCHAR   *UnsignedList,
    OUT PULONG  nUnsigneds
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\logpnp.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    logpnp.c

Abstract:

    This module contains the code for finding, loading and building logical
    hid device structures to be used for extended client calls.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef __LOGPNP_C__
#define __LOGPNP_C__
#endif

#include <windows.h>
#include <wtypes.h>
#include <commdlg.h>
#include <stdlib.h>
#include "hid.h"
#include "logpnp.h"

#define  OPENFILE_FILTER    "Preparsed Data Files\0*.PPD\0"

CHAR     LogPnP_PpdFileName[MAX_PATH+1];

BOOL
LogPnP_BuildLogicalHIDDevice(
    IN     PHIDP_PREPARSED_DATA HidPpd,
    IN OUT PHID_DEVICE          HidDevice
);

VOID
LogPnP_CloseLogicalDevice(
    IN  PHID_DEVICE LogicalDevice
);

BOOL
LogPnP_LoadLogicalDevice(
    IN     PCHAR        OptFileName,
    IN OUT PHID_DEVICE  HidDevice  
)
/*++
RoutineDescription:
    This routine creates a HidDevice object that corresponds to a "logical" device
    A logical device is actually preparsed data that has been saved to disk.  The 
    most common method of saving preparsed data to disk is using that feature in a
    post 3.0 version of HIDView after retrieving/parsing with report descriptor with
    the OS provided parser.  Because the preparsed data structure is available, 
    all of the HidP_Xxx routines can be used.

    OptFileName is an optional file name to specify.  If it is NULL, an OPENFILE
    dialog box is displayed to allow the user to select which Ppd structure to
    load.

    Return value indicates the success or failure of the device load
--*/
{
    OPENFILENAME         OpenInfo;
    BOOL                 Result;
    PHIDP_PREPARSED_DATA PpdBuffer;
    ULONG                PpdLength;

    /*
    // LoadLogicalDevice consists of three steps. 
    //   First it builds the structure needed to get the filename and calls
    //    the standard LoadFile dialog box.
    //
    //   Then it uses that file name to get the Preparsed Data that is stored 
    //       on disk.
    //  
    //   Lastly, it fills in the the HidDevice Info block to create the logical
    //       device
    */

    if (NULL == HidDevice) 
    {
        return (FALSE);
    }

    if (NULL != OptFileName) 
    {
        strcpy(LogPnP_PpdFileName, OptFileName);
    }
    else 
    {
        /*
        // Initialize the OpenInfo structure
        */
        
        LogPnP_PpdFileName[0] = '\0';
        
        OpenInfo.lStructSize = sizeof(OPENFILENAME);
        OpenInfo.hwndOwner = GetTopWindow(NULL);
        OpenInfo.hInstance = NULL;
        OpenInfo.lpstrFilter = OPENFILE_FILTER;
        OpenInfo.lpstrCustomFilter = NULL;
        OpenInfo.nMaxCustFilter = 0;
        OpenInfo.nFilterIndex = 1;
        OpenInfo.lpstrFile = LogPnP_PpdFileName;
        OpenInfo.nMaxFile = MAX_PATH+1;
        OpenInfo.lpstrFileTitle = NULL;
        OpenInfo.nMaxFileTitle = 0;
        OpenInfo.lpstrInitialDir = NULL;
        OpenInfo.lpstrTitle = "Load Preparsed Data File";
        OpenInfo.Flags = OFN_PATHMUSTEXIST;
        OpenInfo.nFileOffset = 0;
        OpenInfo.nFileExtension = 0;
        OpenInfo.lpstrDefExt = "PPD";
        OpenInfo.lCustData = 0;
        OpenInfo.lpfnHook = NULL;
        OpenInfo.lpTemplateName = NULL;
        
        /*
        // Call the open dialog box routine
        */
        
        Result = GetOpenFileName(&OpenInfo);
        
        if (!Result) {
            return (FALSE);
        }
    }
    /*
    // At this point, we should have a valid path and filename stored in 
    //  LogPnP_PpdFileName.  Next step is to load the prepased data from 
    //  that file
    */

    Result = LogPnP_LoadPpdFromFile(LogPnP_PpdFileName,
                                    &PpdBuffer,
                                    &PpdLength);

    if (!Result) 
    {
        return (FALSE);
    }

    /*
    // Now, we've opened the file, got the preparsed data into our buffer and
    //   closed the file.  We probably want to verify the Preparsed Data
    //   somehow at this point.  Since I'm not sure exactly how I want to do
    //   this and time is of the essence, I'm skipping that for now (ISSUE);
    */

    Result = LogPnP_BuildLogicalHIDDevice(PpdBuffer, HidDevice);

    if (!Result) 
    {
        free(PpdBuffer);
        return (FALSE);
    }

    /*
    // Hey, we've gotten all the way to the end and have succeeded.  Return (TRUE);
    */

    return (TRUE);
}

BOOL
LogPnP_BuildLogicalHIDDevice(
    IN     PHIDP_PREPARSED_DATA HidPpd,
    IN OUT PHID_DEVICE          HidDevice
)
/*++
RoutineDescription:
    This routine fills in all the data fields of a HID_DEVICE structure that are
    related to logical devices.  In other words, everything but a file handle and
    the attributes structure.

    It returns FALSE if for some reason, it cannot accoomplish its assigned task.
--*/
{
    BOOLEAN bSuccess;

    HidDevice -> HidDevice = INVALID_HANDLE_VALUE;
    HidDevice -> Ppd = HidPpd;

    if (!HidP_GetCaps (HidDevice->Ppd, &HidDevice->Caps)) 
    {
        return FALSE;
    }
    
    FillMemory(&(HidDevice -> Attributes), sizeof(HIDD_ATTRIBUTES), 0x00 );

    bSuccess = FillDeviceInfo(HidDevice);
    if (FALSE == bSuccess)
    {
        return (FALSE);
    }

    return (TRUE);
}

BOOL
LogPnP_LoadPpdFromFile(
    IN  PCHAR       FileName,
    OUT PHIDP_PREPARSED_DATA   *PpdBuffer,
    OUT PULONG  PpdBufferLength
)
/*++
RoutineDescription:
    This routine takes the passed in filename, opens it for read, and reads the
    preparsed data structure from the file.  It determines the size of the
    parparsed data based on the size of the file so no extraneous bytes should
    be added to preparsed data blocks without modifying this routine.

    This routine will return TRUE if everything goes as planned, FALSE otherwise
--*/
{
    HANDLE  FileHandle;
    BOOL    ReadStatus;
    DWORD   FileSize;
    DWORD   BytesRead;

    *PpdBuffer = NULL;
    *PpdBufferLength = 0;

    FileHandle = CreateFile(FileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);

    if (INVALID_HANDLE_VALUE == FileHandle) 
    {
        return (FALSE);
    }

    /*
    // Call GetFileSize to get the size of the file so we know how many
    //   bytes we need to allocate for the preparsed data buffer.  
    //   GetFileSize returns 0xFFFFFFFF on error, so that gets checked as
    //   well after the call is made
    */

    FileSize = GetFileSize(FileHandle, NULL);
                                
    if (0xFFFFFFFF == FileSize) 
    {
        CloseHandle(FileHandle);
        return (FALSE);
    }

    /*
    // Now, let's allocate the buffer space needed to store the preparsed data
    //  in the file
    */

    *PpdBuffer = (PHIDP_PREPARSED_DATA) malloc(FileSize);

    if (NULL == *PpdBuffer) 
    {
        CloseHandle(FileHandle);

        return (FALSE);
    }

    /*
    // OK, the buffer has been allocated, let's read in our data from the file
    */

    ReadStatus = ReadFile(FileHandle,
                          *PpdBuffer,
                          FileSize,
                          &BytesRead,
                          NULL);

    /*
    // We are done with the file handle now, so let's close it before we 
    //   proceed any farther.
    */

    CloseHandle(FileHandle);

    if (BytesRead != FileSize || !ReadStatus) 
    {
        free(*PpdBuffer);

        *PpdBuffer = NULL;

        return (FALSE);
    }

    /*
    // If we got to this point, everything is perfect.  Close the file handle
    //   and set the size of the buffer and return TRUE.
    */

    *PpdBufferLength = FileSize;
    return (TRUE);
}

VOID
LogPnP_CloseLogicalHIDDevices(
    IN  PHID_DEVICE LogicalDeviceList,
    IN  ULONG       NumLogicalDevices
)
/*++
RoutineDescription:
    This routine takes a list of HID_DEVICE structures that are all logical 
    devices and frees up any resources that were associated with the given 
    logical device.
--*/
{
    ULONG Index;

    for (Index = 0; Index < NumLogicalDevices; Index++) 
    {
        LogPnP_CloseLogicalDevice(LogicalDeviceList+Index);
    }

    return;
}

VOID
LogPnP_CloseLogicalDevice(
    IN  PHID_DEVICE LogicalDevice
)
/*++
RoutineDescription:
    This routine performs the task of freeing up the resources of HID_DEVICE 
    structure for a given logical device.
--*/
{
    /*
    // To close the logical device, we need to undo all that was done by
    //    the FillDeviceInfo routine.  This can be accomplished by calling
    //    CloseHidDevice.  However, for this to succeed we need to free the 
    //    preparsed data itself because it was not allocated by HID.DLL.  
    //    Therefore, we cannot call HidD_FreePreparsedData.  Instead, we free
    //    it ourselves and set it to NULL so that won't attempt to free it 
    //    in the close routine
    */

    free(LogicalDevice -> Ppd);

    LogicalDevice -> Ppd = NULL;

    CloseHidDevice(LogicalDevice, TRUE);

    return;
}

BOOL
LogPnP_IsLogicalDevice(
    IN  PHID_DEVICE HidDevice
)
/*++
RoutineDescription:
    This routine returns TRUE if the passed in HID_DEVICE structure is a logical
    device and FALSE if it is a physical device.
--*/
{
    /*
    // In the current implementation, a HID_DEVICE block is marked as a logical
    //    device by setting the HidDevice field of the block to INVALID_HANDLE_VALUE
    */

    return (INVALID_HANDLE_VALUE == HidDevice -> HidDevice);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\report.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    report.c

Abstract:

    This module contains the code for reading/writing hid reports and 
    translating those HID reports into useful information. 

Environment:

    User mode

@@BEGIN_DDKSPLIT

Revision History:

    Nov-96 : Created by Kenneth D. Ray

@@END_DDKSPLIT
--*/

#include <stdlib.h>
#include <wtypes.h>
#include "hidsdi.h"
#include "hid.h"

BOOLEAN
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );

BOOLEAN
PackReport (
   OUT      PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );

BOOLEAN
Read (
   PHID_DEVICE    HidDevice
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, obtain a read report and unpack the values
   into the InputData array.
--*/
{
    DWORD    bytesRead;

    if (!ReadFile (HidDevice->HidDevice,
                  HidDevice->InputReportBuffer,
                  HidDevice->Caps.InputReportByteLength,
                  &bytesRead,
                  NULL)) 
    {
        return FALSE;
    }

    ASSERT (bytesRead == hidDevice->Caps.InputReportByteLength);

    return UnpackReport (HidDevice->InputReportBuffer,
                         HidDevice->Caps.InputReportByteLength,
                         HidP_Input,
                         HidDevice->InputData,
                         HidDevice->InputDataLength,
                         HidDevice->Ppd);
}

BOOLEAN
ReadOverlapped (
    PHID_DEVICE     HidDevice,
    HANDLE          CompletionEvent
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, obtain a read report and unpack the values
   into the InputData array.
--*/
{
    static OVERLAPPED  overlap;
    DWORD              bytesRead;
    BOOL               readStatus;

    /*
    // Setup the overlap structure using the completion event passed in to
    //  to use for signalling the completion of the Read
    */

    memset(&overlap, 0, sizeof(OVERLAPPED));
    
    overlap.hEvent = CompletionEvent;
    
    /*
    // Execute the read call saving the return code to determine how to 
    //  proceed (ie. the read completed synchronously or not).
    */

    readStatus = ReadFile ( HidDevice -> HidDevice,
                            HidDevice -> InputReportBuffer,
                            HidDevice -> Caps.InputReportByteLength,
                            &bytesRead,
                            &overlap);
                          
    /*
    // If the readStatus is FALSE, then one of two cases occurred.  
    //  1) ReadFile call succeeded but the Read is an overlapped one.  Here,
    //      we should return TRUE to indicate that the Read succeeded.  However,
    //      the calling thread should be blocked on the completion event
    //      which means it won't continue until the read actually completes
    //    
    //  2) The ReadFile call failed for some unknown reason...In this case,
    //      the return code will be FALSE
    */        

    if (!readStatus) 
    {
        return (ERROR_IO_PENDING == GetLastError());
    }

    /*
    // If readStatus is TRUE, then the ReadFile call completed synchronously,
    //   since the calling thread is probably going to wait on the completion
    //   event, signal the event so it knows it can continue.
    */

    else 
    {
        SetEvent(CompletionEvent);
        return (TRUE);
    }
}

BOOLEAN
Write (
   PHID_DEVICE    HidDevice
)
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, take the information in the HID_DATA array
   pack it into multiple write reports and send each report to the HID device
--*/
{
    DWORD     bytesWritten;
    PHID_DATA pData;
    ULONG     Index;
    BOOLEAN   Status;
    BOOLEAN   WriteStatus;

    /*
    // Begin by looping through the HID_DEVICE's HID_DATA structure and setting
    //   the IsDataSet field to FALSE to indicate that each structure has
    //   not yet been set for this Write call.
    */

    pData = HidDevice -> OutputData;

    for (Index = 0; Index < HidDevice -> OutputDataLength; Index++, pData++) 
    {
        pData -> IsDataSet = FALSE;
    }

    /*
    // In setting all the data in the reports, we need to pack a report buffer
    //   and call WriteFile for each report ID that is represented by the 
    //   device structure.  To do so, the IsDataSet field will be used to 
    //   determine if a given report field has already been set.
    */

    Status = TRUE;

    pData = HidDevice -> OutputData;
    for (Index = 0; Index < HidDevice -> OutputDataLength; Index++, pData++) 
    {

        if (!pData -> IsDataSet) 
        {
            /*
            // Package the report for this data structure.  PackReport will
            //    set the IsDataSet fields of this structure and any other 
            //    structures that it includes in the report with this structure
            */

            PackReport (HidDevice->OutputReportBuffer,
                     HidDevice->Caps.OutputReportByteLength,
                     HidP_Output,
                     pData,
                     HidDevice->OutputDataLength - Index,
                     HidDevice->Ppd);

            /*
            // Now a report has been packaged up...Send it down to the device
            */

            WriteStatus = WriteFile (HidDevice->HidDevice,
                                  HidDevice->OutputReportBuffer,
                                  HidDevice->Caps.OutputReportByteLength,
                                  &bytesWritten,
                                  NULL) && (bytesWritten == HidDevice -> Caps.OutputReportByteLength);

            Status = Status && WriteStatus;                         
        }
    }
    return (Status);
}

BOOLEAN
SetFeature (
    PHID_DEVICE    HidDevice
)
/*++
RoutineDescription:
Given a struct _HID_DEVICE, take the information in the HID_DATA array
pack it into multiple reports and send it to the hid device via HidD_SetFeature()
--*/
{
    PHID_DATA pData;
    ULONG     Index;
    BOOLEAN   Status;
    BOOLEAN   FeatureStatus;
    DWORD     ErrorCode;
    /*
    // Begin by looping through the HID_DEVICE's HID_DATA structure and setting
    //   the IsDataSet field to FALSE to indicate that each structure has
    //   not yet been set for this SetFeature() call.
    */

    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) 
    {
        pData -> IsDataSet = FALSE;
    }

    /*
    // In setting all the data in the reports, we need to pack a report buffer
    //   and call WriteFile for each report ID that is represented by the 
    //   device structure.  To do so, the IsDataSet field will be used to 
    //   determine if a given report field has already been set.
    */

    Status = TRUE;

    pData = HidDevice -> FeatureData;
    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) 
    {
        if (!pData -> IsDataSet) 
        {
            /*
            // Package the report for this data structure.  PackReport will
            //    set the IsDataSet fields of this structure and any other 
            //    structures that it includes in the report with this structure
            */

            PackReport (HidDevice->FeatureReportBuffer,
                     HidDevice->Caps.FeatureReportByteLength,
                     HidP_Feature,
                     pData,
                     HidDevice->FeatureDataLength - Index,
                     HidDevice->Ppd);

            /*
            // Now a report has been packaged up...Send it down to the device
            */

            FeatureStatus =(HidD_SetFeature (HidDevice->HidDevice,
                                          HidDevice->FeatureReportBuffer,
                                          HidDevice->Caps.FeatureReportByteLength));

            ErrorCode = GetLastError();

            Status = Status && FeatureStatus;
        }
    }
    return (Status);
}

BOOLEAN
GetFeature (
   PHID_DEVICE    HidDevice
)
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, fill in the feature data structures with
   all features on the device.  May issue multiple HidD_GetFeature() calls to
   deal with multiple report IDs.
--*/
{
    ULONG     Index;
    PHID_DATA pData;
    BOOLEAN   FeatureStatus;
    BOOLEAN   Status;

    /*
    // As with writing data, the IsDataSet value in all the structures should be
    //    set to FALSE to indicate that the value has yet to have been set
    */

    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) 
    {
        pData -> IsDataSet = FALSE;
    }

    /*
    // Next, each structure in the HID_DATA buffer is filled in with a value
    //   that is retrieved from one or more calls to HidD_GetFeature.  The 
    //   number of calls is equal to the number of reportIDs on the device
    */

    Status = TRUE; 
    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) 
    {
        /*
        // If a value has yet to have been set for this structure, build a report
        //    buffer with its report ID as the first byte of the buffer and pass
        //    it in the HidD_GetFeature call.  Specifying the report ID in the
        //    first specifies which report is actually retrieved from the device.
        //    The rest of the buffer should be zeroed before the call
        */

        if (!pData -> IsDataSet) 
        {
            memset(HidDevice -> FeatureReportBuffer, 0x00, HidDevice->Caps.FeatureReportByteLength);

            HidDevice -> FeatureReportBuffer[0] = (UCHAR) pData -> ReportID;

            FeatureStatus = HidD_GetFeature (HidDevice->HidDevice,
                                              HidDevice->FeatureReportBuffer,
                                              HidDevice->Caps.FeatureReportByteLength);

            /*
            // If the return value is TRUE, scan through the rest of the HID_DATA
            //    structures and fill whatever values we can from this report
            */


            if (FeatureStatus) 
            {
                FeatureStatus = UnpackReport ( HidDevice->FeatureReportBuffer,
                                           HidDevice->Caps.FeatureReportByteLength,
                                           HidP_Feature,
                                           HidDevice->FeatureData,
                                           HidDevice->FeatureDataLength,
                                           HidDevice->Ppd);
            }

            Status = Status && FeatureStatus;
        }
   }

   return (Status);
}


BOOLEAN
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
)
/*++
Routine Description:
   Given ReportBuffer representing a report from a HID device where the first
   byte of the buffer is the report ID for the report, extract all the HID_DATA
   in the Data list from the given report.
--*/
{
    ULONG       numUsages; // Number of usages returned from GetUsages.
    ULONG       i;
    UCHAR       reportID;
    ULONG       Index;
    ULONG       nextUsage;

    reportID = ReportBuffer[0];

    for (i = 0; i < DataLength; i++, Data++) 
    {
        if (reportID == Data->ReportID) 
        {
            if (Data->IsButtonData) 
            {
                numUsages = Data->ButtonData.MaxUsageLength;

                Data->Status = HidP_GetUsages (ReportType,
                                               Data->UsagePage,
                                               0, // All collections
                                               Data->ButtonData.Usages,
                                               &numUsages,
                                               Ppd,
                                               ReportBuffer,
                                               ReportBufferLength);


                //
                // Get usages writes the list of usages into the buffer
                // Data->ButtonData.Usages newUsage is set to the number of usages
                // written into this array.
                // A usage cannot not be defined as zero, so we'll mark a zero
                // following the list of usages to indicate the end of the list of
                // usages
                //
                // NOTE: One anomaly of the GetUsages function is the lack of ability
                //        to distinguish the data for one ButtonCaps from another
                //        if two different caps structures have the same UsagePage
                //        For instance:
                //          Caps1 has UsagePage 07 and UsageRange of 0x00 - 0x167
                //          Caps2 has UsagePage 07 and UsageRange of 0xe0 - 0xe7
                //
                //        However, calling GetUsages for each of the data structs
                //          will return the same list of usages.  It is the 
                //          responsibility of the caller to set in the HID_DEVICE
                //          structure which usages actually are valid for the
                //          that structure. 
                //      

                /*
                // Search through the usage list and remove those that 
                //    correspond to usages outside the define ranged for this
                //    data structure.
                */
                
                for (Index = 0, nextUsage = 0; Index < numUsages; Index++) 
                {
                    if (Data -> ButtonData.UsageMin <= Data -> ButtonData.Usages[Index] &&
                            Data -> ButtonData.Usages[Index] <= Data -> ButtonData.UsageMax) 
                    {
                        Data -> ButtonData.Usages[nextUsage++] = Data -> ButtonData.Usages[Index];
                        
                    }
                }

                if (nextUsage < Data -> ButtonData.MaxUsageLength) 
                {
                    Data->ButtonData.Usages[nextUsage] = 0;
                }
            }
            else 
            {
                Data->Status = HidP_GetUsageValue (
                                                ReportType,
                                                Data->UsagePage,
                                                0,               // All Collections.
                                                Data->ValueData.Usage,
                                                &Data->ValueData.Value,
                                                Ppd,
                                                ReportBuffer,
                                                ReportBufferLength);

                Data->Status = HidP_GetScaledUsageValue (
                                                       ReportType,
                                                       Data->UsagePage,
                                                       0, // All Collections.
                                                       Data->ValueData.Usage,
                                                       &Data->ValueData.ScaledValue,
                                                       Ppd,
                                                       ReportBuffer,
                                                       ReportBufferLength);
            } 
            Data -> IsDataSet = TRUE;
        }
    }
    return (TRUE);
}


BOOLEAN
PackReport (
   OUT PCHAR                ReportBuffer,
   IN  USHORT               ReportBufferLength,
   IN  HIDP_REPORT_TYPE     ReportType,
   IN  PHID_DATA            Data,
   IN  ULONG                DataLength,
   IN  PHIDP_PREPARSED_DATA Ppd
   )
/*++
Routine Description:
   This routine takes in a list of HID_DATA structures (DATA) and builds 
      in ReportBuffer the given report for all data values in the list that 
      correspond to the report ID of the first item in the list.  

   For every data structure in the list that has the same report ID as the first
      item in the list will be set in the report.  Every data item that is 
      set will also have it's IsDataSet field marked with TRUE.

   A return value of FALSE indicates an unexpected error occurred when setting
      a given data value.  The caller should expect that assume that no values
      within the given data structure were set.

   A return value of TRUE indicates that all data values for the given report
      ID were set without error.
--*/
{
    ULONG       numUsages; // Number of usages to set for a given report.
    ULONG       i;
    ULONG       CurrReportID;

    /*
    // All report buffers that are initially sent need to be zero'd out
    */

    memset (ReportBuffer, (UCHAR) 0, ReportBufferLength);

    /*
    // Go through the data structures and set all the values that correspond to
    //   the CurrReportID which is obtained from the first data structure 
    //   in the list
    */

    CurrReportID = Data -> ReportID;

    for (i = 0; i < DataLength; i++, Data++) 
    {
        /*
        // There are two different ways to determine if we set the current data
        //    structure: 
        //    1) Store the report ID were using and only attempt to set those
        //        data structures that correspond to the given report ID.  This
        //        example shows this implementation.
        //
        //    2) Attempt to set all of the data structures and look for the 
        //        returned status value of HIDP_STATUS_INVALID_REPORT_ID.  This 
        //        error code indicates that the given usage exists but has a 
        //        different report ID than the report ID in the current report 
        //        buffer
        */

        if (Data -> ReportID == CurrReportID) 
        {
            if (Data->IsButtonData) 
            {
                numUsages = Data->ButtonData.MaxUsageLength;
                Data->Status = HidP_SetUsages (ReportType,
                                               Data->UsagePage,
                                               0, // All collections
                                               Data->ButtonData.Usages,
                                               &numUsages,
                                               Ppd,
                                               ReportBuffer,
                                               ReportBufferLength);
            }
            else
            {
                Data->Status = HidP_SetUsageValue (ReportType,
                                                   Data->UsagePage,
                                                   0, // All Collections.
                                                   Data->ValueData.Usage,
                                                   Data->ValueData.Value,
                                                   Ppd,
                                                   ReportBuffer,
                                                   ReportBufferLength);
            }

            if (HIDP_STATUS_SUCCESS != Data->Status)
            {
                return FALSE;
            }
        }
    }   

    /*
    // At this point, all data structures that have the same ReportID as the
    //    first one will have been set in the given report.  Time to loop 
    //    through the structure again and mark all of those data structures as
    //    having been set.
    */

    for (i = 0; i < DataLength; i++, Data++) 
    {
        if (CurrReportID == Data -> ReportID)
        {
            Data -> IsDataSet = TRUE;
        }
    }
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\pnp.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains the code
    for finding, adding, removing, and identifying hid devices.

Environment:

    User mode

@@BEGIN_DDKSPLIT

Revision History:

    Nov-96 : Created by Kenneth D. Ray

@@END_DDKSPLIT
--*/

#include <basetyps.h>
#include <stdlib.h>
#include <wtypes.h>
#include <setupapi.h>
#include "hidsdi.h"
#include "hid.h"

BOOLEAN
FindKnownHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   )
/*++
Routine Description:
   Do the required PnP things in order to find all the HID devices in
   the system at this time.
--*/
{
    HDEVINFO                            hardwareDeviceInfo;
    SP_DEVICE_INTERFACE_DATA            deviceInfoData;
    ULONG                               i;
    BOOLEAN                             done;
    PHID_DEVICE                         hidDeviceInst;
    GUID                                hidGuid;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    functionClassDeviceData = NULL;
    ULONG                               predictedLength = 0;
    ULONG                               requiredLength = 0;


    HidD_GetHidGuid (&hidGuid);

    *HidDevices = NULL;
    *NumberDevices = 0;

    //
    // Open a handle to the plug and play dev node.
    //
    hardwareDeviceInfo = SetupDiGetClassDevs ( &hidGuid,
                                               NULL, // Define no enumerator (global)
                                               NULL, // Define no
                                               (DIGCF_PRESENT | // Only Devices present
                                                DIGCF_DEVICEINTERFACE)); // Function class devices.

    //
    // Take a wild guess to start
    //
    
    *NumberDevices = 4;
    done = FALSE;
    deviceInfoData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

    i=0;
    while (!done) 
    {
        *NumberDevices *= 2;

        if (*HidDevices) 
        {
            *HidDevices =
               realloc (*HidDevices, (*NumberDevices * sizeof (HID_DEVICE)));
               
        }
        else
        {
            *HidDevices = calloc (*NumberDevices, sizeof (HID_DEVICE));
        }

        if (NULL == *HidDevices) 
        {
            SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
            return FALSE;
        }

        hidDeviceInst = *HidDevices + i;

        for (; i < *NumberDevices; i++, hidDeviceInst++) 
        {
            if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                             0, // No care about specific PDOs
                                             &hidGuid,
                                             i,
                                             &deviceInfoData))
            {
                //
                // allocate a function class device data structure to receive the
                // goods about this particular device.
                //

                SetupDiGetDeviceInterfaceDetail (
                        hardwareDeviceInfo,
                        &deviceInfoData,
                        NULL, // probing so no output buffer yet
                        0, // probing so output buffer length of zero
                        &requiredLength,
                        NULL); // not interested in the specific dev-node


                predictedLength = requiredLength;

                functionClassDeviceData = malloc (predictedLength);
                if (functionClassDeviceData)
                {
                    functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);
                }
                else
                {
                    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
                    return FALSE;
                }

                //
                // Retrieve the information from Plug and Play.
                //

                if (! SetupDiGetDeviceInterfaceDetail (
                           hardwareDeviceInfo,
                           &deviceInfoData,
                           functionClassDeviceData,
                           predictedLength,
                           &requiredLength,
                           NULL)) 
                {
                    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
                    return FALSE;
                }

                //
                // Open device with just generic query abilities to begin with
                //
                
                if (! OpenHidDevice (functionClassDeviceData -> DevicePath, 
                               FALSE,      // ReadAccess - none
                               FALSE,      // WriteAccess - none
                               FALSE,       // Overlapped - no
                               FALSE,       // Exclusive - no
                               TRUE,        // GetDeviceInfo - yes
                               hidDeviceInst))
                {
                    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
                    return FALSE;
                }

            } 
            else
            {
                if (ERROR_NO_MORE_ITEMS == GetLastError()) 
                {
                    done = TRUE;
                    break;
                }
            }
        }
    }

    *NumberDevices = i;

    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
    return TRUE;
}

BOOLEAN
OpenHidDevice (
    IN       PCHAR          DevicePath,
    IN       BOOL           HasReadAccess,
    IN       BOOL           HasWriteAccess,
    IN       BOOL           IsOverlapped,
    IN       BOOL           IsExclusive,
    IN       BOOL           GetDeviceInfo,
    IN OUT   PHID_DEVICE    HidDevice
)
/*++
RoutineDescription:
    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific hid device,
    open that device and fill in all the relivant information in the given
    HID_DEVICE structure.

    return if the open and initialization was successfull or not.

--*/
{
    DWORD   accessFlags = 0;
    DWORD   sharingFlags = 0;
    BOOLEAN bSuccess;
    
    HidDevice -> DevicePath = malloc(strlen(DevicePath));

    if (NULL == HidDevice -> DevicePath) 
    {
        return (FALSE);
    }

    strcpy(HidDevice -> DevicePath, DevicePath);
    
    if (HasReadAccess)
    {
        accessFlags |= GENERIC_READ;
    }

    if (HasWriteAccess)
    {
        accessFlags |= GENERIC_WRITE;
    }

    if (!IsExclusive)
    {
        sharingFlags = FILE_SHARE_READ | FILE_SHARE_WRITE;
    }
    
    HidDevice->HidDevice = CreateFile (DevicePath,
                                       accessFlags,
                                       sharingFlags,
                                       NULL,        // no SECURITY_ATTRIBUTES structure
                                       OPEN_EXISTING, // No special create flags
                                       IsOverlapped ? FILE_FLAG_OVERLAPPED : 0, 
                                       NULL);       // No template file

    if (INVALID_HANDLE_VALUE == HidDevice->HidDevice) 
    {
        free(HidDevice -> DevicePath);
        return FALSE;
    }

    HidDevice -> OpenedForRead = HasReadAccess;
    HidDevice -> OpenedForWrite = HasWriteAccess;
    HidDevice -> OpenedOverlapped = IsOverlapped;
    HidDevice -> OpenedExclusive = IsExclusive;
    
    //
    // If the device was not opened as overlapped, then fill in the rest of the
    //  HidDevice structure.  However, if opened as overlapped, this handle cannot
    //  be used in the calls to the HidD_ exported functions since each of these
    //  functions does synchronous I/O.
    //
   
    if (GetDeviceInfo) 
    {
        if (!HidD_GetPreparsedData (HidDevice->HidDevice, &HidDevice->Ppd)) 
        {
            free(HidDevice -> DevicePath);
            CloseHandle(HidDevice -> HidDevice);
            return FALSE;
        }

        if (!HidD_GetAttributes (HidDevice->HidDevice, &HidDevice->Attributes)) 
        {
            free(HidDevice -> DevicePath);

            CloseHandle(HidDevice -> HidDevice);

            HidD_FreePreparsedData (HidDevice->Ppd);

            return FALSE;
        }

        if (!HidP_GetCaps (HidDevice->Ppd, &HidDevice->Caps))
        {
            free(HidDevice -> DevicePath);

            CloseHandle(HidDevice -> HidDevice);

            HidD_FreePreparsedData (HidDevice->Ppd);

            return FALSE;
        }


        //
        // At this point the client has a choice.  It may chose to look at the
        // Usage and Page of the top level collection found in the HIDP_CAPS
        // structure.  In this way it could just use the usages it knows about.
        // If either HidP_GetUsages or HidP_GetUsageValue return an error then
        // that particular usage does not exist in the report.
        // This is most likely the preferred method as the application can only
        // use usages of which it already knows.
        // In this case the app need not even call GetButtonCaps or GetValueCaps.
        //
        // In this example, however, we will call FillDeviceInfo to look for all
        //    of the usages in the device.
        //

        bSuccess = FillDeviceInfo(HidDevice);

        if (FALSE == bSuccess)
        {
            return (FALSE);
        }
    }
    
    return (TRUE);
}

BOOLEAN
FillDeviceInfo(
    IN  PHID_DEVICE HidDevice
)
{
    USHORT              numValues;
    USHORT              numCaps;
    PHIDP_BUTTON_CAPS   buttonCaps;
    PHIDP_VALUE_CAPS    valueCaps;
    PHID_DATA           data;
    ULONG               i;
    USAGE               usage;

    //
    // setup Input Data buffers.
    //

    //
    // Allocate memory to hold on input report
    //

    HidDevice->InputReportBuffer = (PCHAR) 
        calloc (HidDevice->Caps.InputReportByteLength, sizeof (CHAR));


    //
    // Allocate memory to hold the button and value capabilities.
    // NumberXXCaps is in terms of array elements.
    //
    
    HidDevice->InputButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberInputButtonCaps, sizeof (HIDP_BUTTON_CAPS));

    if (NULL == buttonCaps)
    {
        return (FALSE);
    }

    HidDevice->InputValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberInputValueCaps, sizeof (HIDP_VALUE_CAPS));

    if (NULL == valueCaps)
    {
        return(FALSE);
    }

    //
    // Have the HidP_X functions fill in the capability structure arrays.
    //

    numCaps = HidDevice->Caps.NumberInputButtonCaps;

    HidP_GetButtonCaps (HidP_Input,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberInputValueCaps;

    HidP_GetValueCaps (HidP_Input,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    //
    // Depending on the device, some value caps structures may represent more
    // than one value.  (A range).  In the interest of being verbose, over
    // efficient, we will expand these so that we have one and only one
    // struct _HID_DATA for each value.
    //
    // To do this we need to count up the total number of values are listed
    // in the value caps structure.  For each element in the array we test
    // for range if it is a range then UsageMax and UsageMin describe the
    // usages for this range INCLUSIVE.
    //
    
    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberInputValueCaps; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            numValues += valueCaps->Range.UsageMax - valueCaps->Range.UsageMin + 1;
        }
        else
        {
            numValues++;
        }
    }
    valueCaps = HidDevice->InputValueCaps;


    //
    // Allocate a buffer to hold the struct _HID_DATA structures.
    // One element for each set of buttons, and one element for each value
    // found.
    //

    HidDevice->InputDataLength = HidDevice->Caps.NumberInputButtonCaps
                               + numValues;

    HidDevice->InputData = data = (PHID_DATA)
        calloc (HidDevice->InputDataLength, sizeof (HID_DATA));

    if (NULL == data)
    {
        return (FALSE);
    }

    //
    // Fill in the button data
    //

    for (i = 0;
         i < HidDevice->Caps.NumberInputButtonCaps;
         i++, data++, buttonCaps++) 
    {
        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;
        if (buttonCaps->IsRange) 
        {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else
        {
            data -> ButtonData.UsageMin = data -> ButtonData.UsageMax = buttonCaps -> NotRange.Usage;
        }
        
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Input,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
            calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));

        data->ReportID = buttonCaps -> ReportID;
    }

    //
    // Fill in the value data
    //

    for (i = 0; i < numValues; i++, valueCaps++)
    {
        if (valueCaps->IsRange) 
        {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) 
            {
                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps -> ReportID;
                data++;
            }
        } 
        else
        {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    //
    // setup Output Data buffers.
    //

    HidDevice->OutputReportBuffer = (PCHAR)
        calloc (HidDevice->Caps.OutputReportByteLength, sizeof (CHAR));

    HidDevice->OutputButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberOutputButtonCaps, sizeof (HIDP_BUTTON_CAPS));

    if (NULL == buttonCaps)
    {
        return (FALSE);
    }    

    HidDevice->OutputValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberOutputValueCaps, sizeof (HIDP_VALUE_CAPS));

    if (NULL == valueCaps)
    {
        return (FALSE);
    }

    numCaps = HidDevice->Caps.NumberOutputButtonCaps;
    HidP_GetButtonCaps (HidP_Output,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberOutputValueCaps;
    HidP_GetValueCaps (HidP_Output,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);

    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberOutputValueCaps; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            numValues += valueCaps->Range.UsageMax
                       - valueCaps->Range.UsageMin + 1;
        } 
        else
        {
            numValues++;
        }
    }
    valueCaps = HidDevice->OutputValueCaps;

    HidDevice->OutputDataLength = HidDevice->Caps.NumberOutputButtonCaps
                                + numValues;

    HidDevice->OutputData = data = (PHID_DATA)
       calloc (HidDevice->OutputDataLength, sizeof (HID_DATA));

    if (NULL == data)
    {
        return (FALSE);
    }

    for (i = 0;
         i < HidDevice->Caps.NumberOutputButtonCaps;
         i++, data++, buttonCaps++) 
    {
        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;

        if (buttonCaps->IsRange)
        {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else
        {
            data -> ButtonData.UsageMin = data -> ButtonData.UsageMax = buttonCaps -> NotRange.Usage;
        }

        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                   HidP_Output,
                                                   buttonCaps->UsagePage,
                                                   HidDevice->Ppd);

        data->ButtonData.Usages = (PUSAGE)
            calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));

        data->ReportID = buttonCaps -> ReportID;
    }

    for (i = 0; i < numValues; i++, valueCaps++)
    {
        if (valueCaps->IsRange)
        {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) 
            {
                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps -> ReportID;
                data++;
            }
        }
        else
        {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    //
    // setup Feature Data buffers.
    //

    HidDevice->FeatureReportBuffer = (PCHAR)
           calloc (HidDevice->Caps.FeatureReportByteLength, sizeof (CHAR));

    HidDevice->FeatureButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberFeatureButtonCaps, sizeof (HIDP_BUTTON_CAPS));

    if (NULL == buttonCaps)
    {
        return (FALSE);
    }

    HidDevice->FeatureValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberFeatureValueCaps, sizeof (HIDP_VALUE_CAPS));

    if (NULL == valueCaps)
    {
        return (FALSE);
    }

    numCaps = HidDevice->Caps.NumberFeatureButtonCaps;
    HidP_GetButtonCaps (HidP_Feature,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberFeatureValueCaps;
    HidP_GetValueCaps (HidP_Feature,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);

    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberFeatureValueCaps; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            numValues += valueCaps->Range.UsageMax
                       - valueCaps->Range.UsageMin + 1;
        }
        else
        {
            numValues++;
        }
    }
    valueCaps = HidDevice->FeatureValueCaps;

    HidDevice->FeatureDataLength = HidDevice->Caps.NumberFeatureButtonCaps
                                 + numValues;

    HidDevice->FeatureData = data = (PHID_DATA)
        calloc (HidDevice->FeatureDataLength, sizeof (HID_DATA));

    if (NULL == data)
    {
        return (FALSE);
    }


    for (i = 0;
         i < HidDevice->Caps.NumberFeatureButtonCaps;
         i++, data++, buttonCaps++) 
    {
        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;

        if (buttonCaps->IsRange)
        {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else
        {
            data -> ButtonData.UsageMin = data -> ButtonData.UsageMax = buttonCaps -> NotRange.Usage;
        }
        
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Feature,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
             calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));

        data->ReportID = buttonCaps -> ReportID;
    }

    for (i = 0; i < numValues; i++, valueCaps++) 
    {
        if (valueCaps->IsRange)
        {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++)
            {
                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps -> ReportID;
                data++;
            }
        } 
        else
        {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    return (TRUE);
}

VOID
CloseHidDevices(
    IN  PHID_DEVICE HidDevices,
    IN  ULONG       NumberDevices
)
{
    ULONG   Index;

    for (Index = 0; Index < NumberDevices; Index++) 
    {
        CloseHidDevice(HidDevices+Index, TRUE);
    }

    return;
}

VOID
CloseHidDevice (
    IN PHID_DEVICE HidDevice,
    IN BOOL        FreeDeviceInfo
)
{
    free(HidDevice -> DevicePath);
    
    if (INVALID_HANDLE_VALUE != HidDevice -> HidDevice)
    {
        CloseHandle(HidDevice -> HidDevice);
    }

    //
    // Only free these structure, if have a handle to an non-overlapped device
    //
    
    if (FreeDeviceInfo) 
    {
        if (NULL != HidDevice -> Ppd)
        {
            HidD_FreePreparsedData(HidDevice -> Ppd);
        }

        if (NULL != HidDevice -> InputReportBuffer)
        {
            free(HidDevice -> InputReportBuffer);
        }

        if (NULL != HidDevice -> InputData)
        {
            free(HidDevice -> InputData);
        }

        if (NULL != HidDevice -> InputButtonCaps)
        {
            free(HidDevice -> InputButtonCaps);
        }

        if (NULL != HidDevice -> InputValueCaps)
        {
            free(HidDevice -> InputValueCaps);
        }

        if (NULL != HidDevice -> OutputReportBuffer)
        {
            free(HidDevice -> OutputReportBuffer);
        }

        if (NULL != HidDevice -> OutputData)
        {
            free(HidDevice -> OutputData);
        }

        if (NULL != HidDevice -> OutputButtonCaps) 
        {
            free(HidDevice -> OutputButtonCaps);
        }

        if (NULL != HidDevice -> OutputValueCaps)
        {
            free(HidDevice -> OutputValueCaps);
        }

        if (NULL != HidDevice -> FeatureReportBuffer)
        {
            free(HidDevice -> FeatureReportBuffer);
        }

        if (NULL != HidDevice -> FeatureData) 
        {
            free(HidDevice -> FeatureData);
        }

        if (NULL != HidDevice -> FeatureButtonCaps) 
        {
            free(HidDevice -> FeatureButtonCaps);
        }

        if (NULL != HidDevice -> FeatureValueCaps) 
        {
            free(HidDevice -> FeatureValueCaps);
        }
    }        
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\buffers.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    buffers.c

Abstract:

    This module contains the code for handling the display of HID report
    buffers for the extended calls dialog box.  

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#include <windows.h>
#include <malloc.h>
#include <setupapi.h>
#include "hidsdi.h"
#include "hidpi.h"
#include "buffers.h"
#include "strings.h"
#include "debug.h"

#define CURRENT_REPORT(pDisp)   (pDisp -> ReportBuffers + pDisp -> iCurrSelectionIndex)

BOOLEAN
BufferDisplay_Init(
    IN  HWND                hCB,
    IN  HWND                hEB,
    IN  INT                 nBuffers,
    IN  INT                 iBufferSize,
    IN  HIDP_REPORT_TYPE    RType,
    OUT PBUFFER_DISPLAY     *ppBufferDisplay
)
/*++
Routine Description:
    This routine initializes the buffer display mechanism for a given report type

    The display mechanism maintains a list of list of nBuffers, where is each
    is buffer is of iBufferSize and hCB and hEB are handles to the combo box and
    edit box for displaying the buffer. 

    The variable ppBufferDisplay is allocated block which is passed into other
    buffer routines and contains information about the buffer for the other 
    routines.

    This function will return FALSE if there was a problem allocating memory
--*/
{
    PBUFFER_DISPLAY pNewDisplay;
    CHAR            *pszBufferHeader;
    CHAR            szBufferName[24];
    INT             iIndex;
    INT             iCBIndex;

    pNewDisplay = (PBUFFER_DISPLAY) ALLOC(sizeof(BUFFER_DISPLAY));

    *ppBufferDisplay = NULL;

    if (NULL == pNewDisplay) {
        return (FALSE);
    }

    pNewDisplay -> ReportBuffers = (PREPORT_BUFFER) ALLOC(sizeof(REPORT_BUFFER) * nBuffers);
    if (NULL == pNewDisplay -> ReportBuffers) {
        FREE(pNewDisplay);
        return (FALSE);
    }
    
    memset(pNewDisplay -> ReportBuffers, 0x00, sizeof(REPORT_BUFFER) * nBuffers);

    pNewDisplay -> hBufferComboBox = hCB;
    pNewDisplay -> hBufferEditBox = hEB;
    pNewDisplay -> nReportBuffers = nBuffers;
    pNewDisplay -> iBufferSize = iBufferSize;
    pNewDisplay -> ReportType = RType;

    switch (pNewDisplay -> ReportType) {
        case HidP_Input:
            pszBufferHeader = "Input";
            break;

        case HidP_Output:
            pszBufferHeader = "Output";
            break;

        case HidP_Feature:
            pszBufferHeader = "Feature";
            break;

        default:
            pszBufferHeader = "Other";
            break;
    }

    for (iIndex = 0; iIndex < pNewDisplay -> nReportBuffers; iIndex++) {

        wsprintf(szBufferName, "%s Buffer #%d", pszBufferHeader, iIndex);
        iCBIndex = SendMessage(pNewDisplay -> hBufferComboBox,
                               CB_ADDSTRING,
                               0, 
                               (LPARAM) szBufferName
                              );

        if (CB_ERR == iCBIndex || CB_ERRSPACE == iCBIndex) {
            BufferDisplay_Destroy(pNewDisplay);
            return (FALSE);
        }

        iCBIndex = SendMessage(pNewDisplay -> hBufferComboBox,
                               CB_SETITEMDATA,
                               iCBIndex,
                               iIndex
                              );

        if (CB_ERR == iCBIndex || CB_ERRSPACE == iCBIndex) {
            BufferDisplay_Destroy(pNewDisplay);
            return (FALSE);
        }
    }

    SendMessage(pNewDisplay -> hBufferComboBox,
                CB_SETCURSEL,
                0,
                0
               );

    BufferDisplay_ChangeSelection(pNewDisplay);

    *ppBufferDisplay = pNewDisplay;
    return (TRUE);
}

VOID
BufferDisplay_Destroy(
    IN  PBUFFER_DISPLAY     pBufferDisplay
)
/*++
Routine Description:
    This routine cleans up the buffer display variable that was allocated by
    the initialize routine
--*/
{
    INT     iIndex;

    for (iIndex = 0; iIndex < pBufferDisplay -> nReportBuffers; iIndex++) {

        if (NULL != pBufferDisplay -> ReportBuffers[iIndex].pBuffer) 
            FREE(pBufferDisplay -> ReportBuffers[iIndex].pBuffer);

    }

    FREE(pBufferDisplay -> ReportBuffers);
    FREE(pBufferDisplay);
    return;
}

VOID
BufferDisplay_ChangeSelection(
    IN  PBUFFER_DISPLAY     pBufferDisplay
)
/*++
Routine Description:
    This routine has the selection of a buffer to display via the combo box
--*/
{
    INT     iNewIndex;

    iNewIndex = SendMessage(pBufferDisplay -> hBufferComboBox,
                            CB_GETCURSEL,
                            0,
                            0
                           );

    iNewIndex = SendMessage(pBufferDisplay -> hBufferComboBox,
                            CB_GETITEMDATA,
                            iNewIndex,
                            0
                           );

    pBufferDisplay -> iCurrSelectionIndex = iNewIndex;

    BufferDisplay_OutputBuffer(pBufferDisplay -> hBufferEditBox,
                               &(pBufferDisplay -> ReportBuffers[iNewIndex])
                              );

    return;
}

VOID
BufferDisplay_OutputBuffer(
    HWND            hEditBox,
    PREPORT_BUFFER  pReportBuffer
)
/*++
Routine Description:
    This routine outputs to hEditBox a byte representation of pReportBuffer
--*/
{
    PCHAR           BufferString;

    if (0 == pReportBuffer -> iBufferSize || NULL == pReportBuffer -> pBuffer) {
        SetWindowText(hEditBox, "");
    }
    else {

        /*
        // Create a buffer string the size of the buffer and display 
        //   as bytes
        */
        
        Strings_CreateDataBufferString(pReportBuffer -> pBuffer,
                                       pReportBuffer -> iBufferSize,
                                       pReportBuffer -> iBufferSize,
                                       1,
                                       &BufferString
                                      );

        if (NULL == BufferString) {
            SetWindowText(hEditBox, "");
        }
        else {
            SetWindowText(hEditBox, BufferString);
            FREE(BufferString);
        }
    }
    return;
}

BOOLEAN
BufferDisplay_UpdateBuffer(
    IN  PBUFFER_DISPLAY     pBufferDisplay,
    IN  PCHAR               pNewBuffer
)
/*++
Routine Description:
    This routine changes the data of the currently active report buffer for the
    given buffer display structure.  

    It returns FALSE if it needed to allocate a new buffer and the memory allocation
    failed.
--*/
{
    PREPORT_BUFFER          pCurrentReport;

    pCurrentReport = CURRENT_REPORT(pBufferDisplay);
    
    if (NULL == pCurrentReport -> pBuffer) {
        pCurrentReport -> pBuffer = ALLOC(pBufferDisplay -> iBufferSize);
        if (NULL == pCurrentReport) {
            return (FALSE);
        }

        pCurrentReport -> iBufferSize = pBufferDisplay -> iBufferSize;
    }
    memmove (pCurrentReport -> pBuffer, pNewBuffer, pCurrentReport -> iBufferSize);

    BufferDisplay_OutputBuffer(pBufferDisplay -> hBufferEditBox,
                               pCurrentReport
                              );

    return (TRUE);
}

INT
BufferDisplay_GetBufferSize(
    IN  PBUFFER_DISPLAY      pBufferDisplay
)
/*++
Routine Description:
    This routine simply returns the size of the given buffer
--*/
{
    return (pBufferDisplay -> iBufferSize);
}

VOID
BufferDisplay_CopyCurrentBuffer(
    IN  PBUFFER_DISPLAY     pBufferDisplay,
    OUT PCHAR               pCopyBuffer
)
/*++
Routine Description:
    This routine copies the currently active buffer for the given buffer display
    into the buffer passed in by the caller.

    It is the caller's responsibility to allocate a buffer of the appropriate size
    The appropriate size can be obtain by calling BufferDisplay_GetBufferSize
--*/
{
    PREPORT_BUFFER          pCurrentReport;

    pCurrentReport = CURRENT_REPORT(pBufferDisplay);

    if (NULL == pCurrentReport -> pBuffer) {
        memset(pCopyBuffer, 0x0, pBufferDisplay -> iBufferSize);
    }
    else {
        memcpy(pCopyBuffer, pCurrentReport -> pBuffer, pCurrentReport -> iBufferSize);
    }
    return;
}

INT
BufferDisplay_GetCurrentBufferNumber(
    IN  PBUFFER_DISPLAY      pBufferDisplay
)
/*++
Routine Description:
    This routine returns the buffer number of the current buffer selection
--*/
{
    return (pBufferDisplay -> iCurrSelectionIndex);
}

UCHAR
BufferDisplay_GetCurrentReportID(
    IN  PBUFFER_DISPLAY      pBufferDisplay
)
/*++
Routine Description:
    This routine returns the report ID of the current buffer selection
--*/
{
    PREPORT_BUFFER pCurrentReport;

    pCurrentReport = CURRENT_REPORT(pBufferDisplay);

    return (pCurrentReport -> ucReportID);
}

VOID
BufferDisplay_ClearBuffer(
    IN  PBUFFER_DISPLAY pBufferDisplay
)
/*++
Routine Description:
    This routine frees the current report buffer and set's it to NULL
--*/
{
    PREPORT_BUFFER pCurrentReport;

    pCurrentReport = CURRENT_REPORT(pBufferDisplay);

    if (NULL != pCurrentReport -> pBuffer) {
        FREE(pCurrentReport -> pBuffer);
        pCurrentReport -> iBufferSize = 0;
        pCurrentReport -> ucReportID = 0;
        pCurrentReport -> pBuffer = NULL;
    }

    BufferDisplay_OutputBuffer(pBufferDisplay -> hBufferEditBox,
                               pCurrentReport
                              );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\ecdisp.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    ecdisp.h

Abstract:

    This module contains the public declarations for the extended calls dialog
    box.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef _ECDISP_H_
#define _ECDISP_H_

/*****************************************************************************
/* Global Extended Call display function declarations
/*****************************************************************************/

LRESULT CALLBACK
bExtCallDlgProc(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam, 
    LPARAM lParam
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\ecdisp.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    ecdisp.c

Abstract:

    This module contains the code to handle the extended calls dialog box
    and the actions that can be performed in the dialog box.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

/*****************************************************************************
/* Extended call display include files
/*****************************************************************************/
#include <windows.h>
#include <limits.h>
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <setupapi.h>
#include <assert.h>
#include "hidusage.h"
#include "hidsdi.h"
#include "hid.h"
#include "hclient.h"
#include "resource.h"
#include "extcalls.h"
#include "buffers.h"
#include "ecdisp.h"
#include "strings.h"
#include "logpnp.h"
#include "debug.h"

/*****************************************************************************
/* Local macro definitions for the supported function calls
/*****************************************************************************/

#define HID_NUMCALLS                  44
#define HID_DEVCALLS                  17
#define HID_PPDCALLS                  27

#define HIDD_GET_HID_GUID              1
#define HIDD_GET_FREE_PREPARSED_DATA   2
#define HIDD_GET_CONFIGURATION         3
#define HIDD_SET_CONFIGURATION         4
#define HIDD_FLUSH_QUEUE               5
#define HIDD_GET_ATTRIBUTES            6
#define HIDD_SET_FEATURE               7
#define HIDD_GET_FEATURE               8
#define HIDD_GET_NUM_INPUT_BUFFERS     9
#define HIDD_SET_NUM_INPUT_BUFFERS    10
#define HIDD_GET_PHYSICAL_DESCRIPTOR  11
#define HIDD_GET_MANUFACTURER_STRING  12
#define HIDD_GET_PRODUCT_STRING       13
#define HIDD_GET_INDEXED_STRING       14
#define HIDD_GET_SERIAL_NUMBER_STRING 15
#define HID_READ_REPORT               16
#define HID_WRITE_REPORT              17
#define HIDP_GET_BUTTON_CAPS          18
#define HIDP_GET_BUTTONS              19
#define HIDP_GET_BUTTONS_EX           20
#define HIDP_GET_CAPS                 21 
#define HIDP_GET_DATA                 22
#define HIDP_GET_LINK_COLL_NODES      23
#define HIDP_GET_SCALED_USAGE_VALUE   24
#define HIDP_GET_SPECIFIC_BUTTON_CAPS 25
#define HIDP_GET_SPECIFIC_VALUE_CAPS  26
#define HIDP_GET_USAGES               27
#define HIDP_GET_USAGES_EX            28
#define HIDP_GET_USAGE_VALUE          29
#define HIDP_GET_USAGE_VALUE_ARRAY    30
#define HIDP_GET_VALUE_CAPS           31
#define HIDP_MAX_DATA_LIST_LENGTH     32
#define HIDP_MAX_USAGE_LIST_LENGTH    33
#define HIDP_SET_BUTTONS              34
#define HIDP_SET_DATA                 35
#define HIDP_SET_SCALED_USAGE_VALUE   36
#define HIDP_SET_USAGES               37
#define HIDP_SET_USAGE_VALUE          38
#define HIDP_SET_USAGE_VALUE_ARRAY    39
#define HIDP_TRANSLATE_USAGES         40
#define HIDP_UNSET_BUTTONS            41
#define HIDP_UNSET_USAGES             42
#define HIDP_USAGE_LIST_DIFFERENCE    43
#define HID_CLEAR_REPORT              44

/*
// These two definitions are not used by the display routines since 
//    the two functions were molded together into one for purpose of execution
*/

#define HIDD_GET_PREPARSED_DATA       45
#define HIDD_FREE_PREPARSED_DATA      46

#define IS_HIDD_FUNCTION(func)        (((func) >= HIDD_GET_HID_GUID) && \
                                       ((func) <= HIDD_GET_SERIAL_NUMBER_STRING))

#define IS_HIDP_FUNCTION(func)        (((func) >= HIDP_GET_BUTTON_CAPS) && \
                                       ((func) <= HIDP_USAGE_LIST_DIFFERENCE))

#define IS_HID_FUNCTION(func)         (((func) >= HID_READ_REPORT) && \
                                       ((func) <= HID_WRITE_REPORT))

#define IS_NOT_IMPLEMENTED(func)      (((func) == HIDD_GET_CONFIGURATION) || \
                                       ((func) == HIDD_SET_CONFIGURATION) || \
                                       ((func) == HIDP_TRANSLATE_USAGES)) 


/*****************************************************************************
/* Local macro definitions for buffer display sizes
/*****************************************************************************/
#define NUM_INPUT_BUFFERS       16
#define NUM_OUTPUT_BUFFERS      16
#define NUM_FEATURE_BUFFERS     16

/*****************************************************************************
/* Local macro definition for HidP_SetData dialog box
/*****************************************************************************/
#define SETDATA_LISTBOX_FORMAT  "Index: %u,  DataValue: %u"

/*****************************************************************************
/* Local macro definition for display output to output windows
/*****************************************************************************/
#define TEMP_BUFFER_SIZE 1024
#define STATUS_STRING(str, status)  wsprintf(str, "Status: %s", ECDisp_GetHidAppStatusString(status))
#define OUTSTRING(win, str)         SendMessage(win, LB_ADDSTRING, 0, (LPARAM) str)
#define OUTWSTRING(win, str) \
{ \
    size_t  nBytes; \
\
    nBytes = wcstombs(szTempBuffer, str, TEMP_BUFFER_SIZE-1); \
    if ((size_t) -1 == nBytes) { \
        OUTSTRING(win, "Cannot convert wide-character string"); \
    } \
    else { \
        szTempBuffer[nBytes] = '\0'; \
        OUTSTRING(win, szTempBuffer); \
    } \
}

#define DISPLAY_HIDD_STATUS(win, func, status) \
{ \
    wsprintf(szTempBuffer, \
             "%s returned: %s", \
             func, \
             (status).IsHidError ? "FALSE" : "TRUE" \
            ); \
\
    OUTSTRING(win, szTempBuffer); \
    DISPLAY_DEBUG_STATUS(win, func, status); \
}

#define DISPLAY_HIDP_STATUS(win, func, status) \
{ \
    wsprintf(szTempBuffer, \
             "%s returned: %s", \
             func, \
             ECDisp_GetHidAppStatusString(status.HidErrorCode) \
            ); \
\
    OUTSTRING(win, szTempBuffer); \
    DISPLAY_DEBUG_STATUS(win, func, status); \
}


#define DISPLAY_DEBUG_STATUS(win, func, status) \
{ \
    if (!status.IsHidDbgError) { \
        OUTSTRING(win, "No HID debug errors"); \
    } \
    else { \
        wsprintf(szTempBuffer, \
                 "HID debug error code %d returned", \
                 CallStatus.HidDbgErrorCode \
                ); \
        OUTSTRING(win, szTempBuffer); \
    } \
\
    if (!status.IsHidDbgWarning) { \
        OUTSTRING(win, "No HID debug warnings"); \
    } \
    else { \
        wsprintf(szTempBuffer, \
                 "HID debug warning code %d returned", \
                 CallStatus.HidDbgWarningCode \
                ); \
        OUTSTRING(win, szTempBuffer); \
    } \
}

#define ECDISP_ERROR(win, msg) \
{ \
    MessageBox(win, \
               msg, \
               "HClient Error", \
               MB_ICONEXCLAMATION \
              ); \
}

#define GET_FUNCTION_NAME(index)     ResolveFunctionName(index)


/*****************************************************************************
/* Local macro definition for retrieving data based on report type
/*****************************************************************************/
#define SELECT_ON_REPORT_TYPE(rt, ival, oval, fval, res) \
{ \
    switch ((rt)) { \
        case HidP_Input: \
            (res) = (ival); \
            break; \
\
        case HidP_Output: \
            (res) = (oval); \
            break; \
\
        case HidP_Feature: \
            (res) = (fval); \
            break; \
\
    } \
}

/*****************************************************************************
/* Local macro definition for calculating size of a usage value array buffer
/*****************************************************************************/
#define ROUND_TO_NEAREST_BYTE(val)  (((val) % 8) ? ((val) / 8) + 1 : ((val) / 8))

/*****************************************************************************
/* Local macro definition to find MIN and MAX two values
/*****************************************************************************/

#define MIN(x, y)                   ((x) < (y) ? (x) : (y))
#define MAX(x, y)                   ((x) > (y) ? (x) : (y))

/*****************************************************************************
/* Data types local to this module
/*****************************************************************************/

typedef struct {
    UINT uiIndex;
    char *szFunctionName;
} FUNCTION_NAMES;

typedef struct {
    BOOL fInputReport;
    BOOL fOutputReport;
    BOOL fFeatureReport;
    BOOL fReportID;
    BOOL fUsagePage;
    BOOL fUsage;
    BOOL fLinkCollection;
    BOOL fInputReportSelect;
    BOOL fOutputReportSelect;
    BOOL fFeatureReportSelect;
} PARAMETER_STATE;

typedef enum { DLGBOX_INIT_FAILED = -1, DLGBOX_ERROR, DLGBOX_CANCEL, DLGBOX_OK } DLGBOX_STATUS;

typedef struct {
    HIDP_REPORT_TYPE          ReportType;
    USAGE                     UsagePage;
    USAGE                     Usage;
    USHORT                    LinkCollection;
    UCHAR                     ReportID;
    PCHAR                     szListString;
    PCHAR                     szListString2;
    PUSAGE                    UsageList;
    PUSAGE                    UsageList2;
    ULONG                     ListLength;
    ULONG                     ListLength2;
    ULONG                     StringIndex;
    union {
        PHIDP_DATA            pDataList;
        PULONG                pValueList;
        LONG                  ScaledValue;
        ULONG                 Value;

    };
} ECDISPLAY_PARAMS, *PECDISPLAY_PARAMS;

/*****************************************************************************
/* Local data variables
/*****************************************************************************/

static CHAR             szTempBuffer[TEMP_BUFFER_SIZE];

static PBUFFER_DISPLAY  pInputDisplay;
static PBUFFER_DISPLAY  pOutputDisplay;
static PBUFFER_DISPLAY  pFeatureDisplay;

static FUNCTION_NAMES DeviceCalls[HID_DEVCALLS] = {
                             { HIDD_GET_HID_GUID,               "HidD_GetHidGuid" },
                             { HIDD_GET_FREE_PREPARSED_DATA,    "HidD_GetFreePreparsedData" },
                             { HIDD_GET_CONFIGURATION,          "HidD_GetConfiguration" },
                             { HIDD_SET_CONFIGURATION,          "HidD_SetConfiguration" },
                             { HIDD_FLUSH_QUEUE,                "HidD_FlushQueue" },
                             { HIDD_GET_ATTRIBUTES,             "HidD_GetAttributes" },
                             { HIDD_SET_FEATURE,                "HidD_SetFeature" },
                             { HIDD_GET_FEATURE,                "HidD_GetFeature" },
                             { HIDD_GET_NUM_INPUT_BUFFERS,      "HidD_GetNumInputBuffers" },
                             { HIDD_SET_NUM_INPUT_BUFFERS,      "HidD_SetNumInputBuffers" },
                             { HIDD_GET_PHYSICAL_DESCRIPTOR,    "HidD_GetPhysicalDescriptor" },
                             { HIDD_GET_MANUFACTURER_STRING,    "HidD_GetManufacturerString", },
                             { HIDD_GET_PRODUCT_STRING,         "HidD_GetProductString", },
                             { HIDD_GET_INDEXED_STRING,         "HidD_GetIndexedString", },
                             { HIDD_GET_SERIAL_NUMBER_STRING,   "HidD_GetSerialNumberString", },
                             { HID_READ_REPORT,                 "Read Input Report"        },
                             { HID_WRITE_REPORT,                "Write Report Buffer"      }

};

static FUNCTION_NAMES PpdCalls[HID_PPDCALLS] = {
                             { HIDP_GET_BUTTON_CAPS,            "HidP_GetButtonCaps" },
                             { HIDP_GET_BUTTONS,                "HidP_GetButtons" },
                             { HIDP_GET_BUTTONS_EX,             "HidP_GetButtonsEx" },
                             { HIDP_GET_CAPS,                   "HidP_GetCaps" },
                             { HIDP_GET_DATA,                   "HidP_GetData" },
                             { HIDP_GET_LINK_COLL_NODES,        "HidP_GetLinkCollectionNodes" },
                             { HIDP_GET_SCALED_USAGE_VALUE,     "HidP_GetScaledUsageValue" },
                             { HIDP_GET_SPECIFIC_BUTTON_CAPS,   "HidP_GetSpecificButtonCaps" },
                             { HIDP_GET_SPECIFIC_VALUE_CAPS,    "HidP_GetSpecificValueCaps" },
                             { HIDP_GET_USAGES,                 "HidP_GetUsages" },
                             { HIDP_GET_USAGES_EX,              "HidP_GetUsagesEx" },
                             { HIDP_GET_USAGE_VALUE,            "HidP_GetUsageValue" },
                             { HIDP_GET_USAGE_VALUE_ARRAY,      "HidP_GetUsageValueArray" },
                             { HIDP_GET_VALUE_CAPS,             "HidP_GetValueCaps" },
                             { HIDP_MAX_DATA_LIST_LENGTH,       "HidP_MaxDataListLength" },
                             { HIDP_MAX_USAGE_LIST_LENGTH,      "HidP_MaxUsageListLength" },
                             { HIDP_SET_BUTTONS,                "HidP_SetButtons" },
                             { HIDP_SET_DATA,                   "HidP_SetData" },
                             { HIDP_SET_SCALED_USAGE_VALUE,     "HidP_SetScaledUsageValue" },
                             { HIDP_SET_USAGES,                 "HidP_SetUsages" },
                             { HIDP_SET_USAGE_VALUE,            "HidP_SetUsageValue" },
                             { HIDP_SET_USAGE_VALUE_ARRAY,      "HidP_SetUsageValueArray" },
                             { HIDP_TRANSLATE_USAGES,           "HidP_TranslateUsagesToI8042ScanCodes" },
                             { HIDP_UNSET_BUTTONS,              "HidP_UnsetButtons" },
                             { HIDP_UNSET_USAGES,               "HidP_UnsetUsages" },
                             { HIDP_USAGE_LIST_DIFFERENCE,      "HidP_UsageListDifference" },
                             { HID_CLEAR_REPORT,                "Clear Report Buffer"      }
};

static PARAMETER_STATE pState[HID_NUMCALLS] = {
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_HID_GUID
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_FREE_PREPARSED_DATA
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_CONFIGURATION
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_SET_CONFIGURATION
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_FLUSH_QUEUE
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GETATTRIBUTES
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  TRUE }, // HIDD_SET_FEATURE
                                         { FALSE, FALSE, FALSE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE,  TRUE }, // HIDD_GET_FEATURE
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_NUM_INPUT_BUFFERS
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_SET_NUM_INPUT_BUFFERS
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_PHYSICAL_DESCRIPTOR
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_MANUFACTURER_STRING
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_PRODUCT_STRING
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_INDEXED_STRING
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_SERIAL_NUMBER_STRING
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  TRUE, FALSE, FALSE }, // HID_READ_REPORT
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  TRUE, FALSE }, // HID_WRITE_BUFFER
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_GET_BUTTON_CAPS
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_BUTTONS
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_BUTTONS_EX
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_GET_CAPS
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_DATA
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_GET_LINK_COLL_NODES
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_SCALED_USAGE_VALUE
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE }, // HIDP_GET_SPECIFIC_BUTTON_CAPS
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE }, // HIDP_GET_SPECIFIC_VALUE_CAPS
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_USAGES
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_USAGES_EX
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_USAGE_VALUE
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_USAGE_VALUE_ARRAY
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_GET_VALUE_CAPS
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_MAX_DATA_LIST_LENGTH
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_MAX_USAGE_LIST_LENGTH
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_SET_BUTTONS
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE,  TRUE,  TRUE,  TRUE }, // HIDP_SET_DATA
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_SET_SCALED_USAGE_VALUE
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_SET_USAGES                                        
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_SET_USAGE_VALUE
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_SET_USAGE_VALUE_ARRAY
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_TRANSLATE_USAGES
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_UNSET_BUTTONS
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_UNSET_USAGES
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_USAGE_LIST_DIFFERENCE
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE,  TRUE,  TRUE,  TRUE }, // HID_CLEAR_BUFFER
                                        }; 


/*****************************************************************************
/* Local function declarations
/*****************************************************************************/

VOID
vLoadExtCalls(
    HWND hExtCalls,
    BOOL IsLogicalDevice
);

VOID
vSetReportType(
    HWND hDlg, 
    LONG lId
);

VOID 
vInitEditText(
    HWND   hText, 
    INT    cbTextSize, 
    CHAR   *pchText
);

VOID vEnableParameters(
    HWND hDlg, 
    INT  iCallSelection
);

BOOL 
fGetAndVerifyParameters(
    HWND              hDlg, 
    PECDISPLAY_PARAMS pParams
);

BOOL
ECDisp_Execute(
    IN     INT             FuncCall,
    IN OUT PEXTCALL_PARAMS CallParams,
    OUT    PEXTCALL_STATUS CallStatus
);

VOID
ECDisp_DisplayOutput(
    IN HWND            hOutputWindow,
    IN INT             FuncCall,
    IN PEXTCALL_PARAMS Results
);

VOID 
vExecuteAndDisplayOutput(
    HWND              hOutputWindow, 
    PHID_DEVICE       pDevice, 
    INT               iFuncCall, 
    PECDISPLAY_PARAMS pParams
);              

CHAR *pchGetHidAppStatusString(
    NTSTATUS StatusCode
);


VOID
vInitECControls(
    HWND            hDlg,
    USHORT          InputReportByteLength,
    PBUFFER_DISPLAY *ppInputDisplay,
    USHORT          OutputReportByteLength,
    PBUFFER_DISPLAY *ppOutputDisplay,
    USHORT          FeatureReportByteLength,
    PBUFFER_DISPLAY *ppFeatureDisplay,
    BOOL            IsLogicalDevice
);

VOID
BuildReportIDList(
    IN  PHIDP_BUTTON_CAPS  phidButtonCaps,
    IN  USHORT             nButtonCaps,
    IN  PHIDP_VALUE_CAPS   phidValueCaps,
    IN  USHORT             nValueCaps,
    OUT UCHAR            **ppReportIDList,
    OUT INT               *nReportIDs
);

LRESULT CALLBACK
bSetUsagesDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bSetValueDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bSetInputBuffDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bSetDataDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bSetBufLenDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bSetInputBuffersDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bGetIndexedDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bGetUsageDiffDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

BOOL
ConvertStringToUnsignedList(
    IN     INT     iUnsignedSize,
    IN     INT     iBase,
    IN OUT PCHAR   InString,
    OUT    PCHAR   *UnsignedList,
    OUT    PULONG  nUnsigneds
); 

BOOL
ConvertStringToUlongList(
    IN OUT PCHAR   InString,
    OUT    PULONG  *UlongList,
    OUT    PULONG  nUlongs
);

BOOL
ConvertStringToUsageList(
    IN OUT PCHAR   InString,
    OUT    PUSAGE  *UsageList,
    OUT    PULONG  nUsages
);

VOID
ECDisp_MakeGUIDString(
    IN  GUID guid, 
    OUT CHAR szString[]
);

PCHAR
ECDisp_GetHidAppStatusString(
    NTSTATUS StatusCode
);

BOOL
ECDisp_ConvertUlongListToValueList(
    IN  PULONG  UlongList,
    IN  ULONG   nUlongs,
    IN  USHORT  BitSize,
    IN  USHORT  ReportCount,
    OUT PCHAR   *ValueList,
    OUT PULONG  ValueListSize
);

BOOL
SetDlgItemIntHex(
   HWND hDlg, 
   INT nIDDlgItem, 
   UINT uValue, 
   INT nBytes
);

PCHAR
ResolveFunctionName(
    INT Index
);

/*****************************************************************************
/* Global function definitions
/*****************************************************************************/

LRESULT CALLBACK
bExtCallDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PHID_DEVICE      pDevice;
    static CHAR             szTempBuff[1024]; 
    static CHAR             szLabel[512];
    static CHAR             szValue[512];
    static INT              iLBCounter;
    static UCHAR            *pucInputReportIDs;
    static UCHAR            *pucOutputReportIDs;
    static UCHAR            *pucFeatureReportIDs;
    static INT              nInputReportIDs;
    static INT              nOutputReportIDs;
    static INT              nFeatureReportIDs;

           INT              iIndex;
           ECDISPLAY_PARAMS params;

    switch(message) {
        case WM_INITDIALOG:
        
            /*
            // Initializing the dialog box involves the following steps:
            //  1) Determine from the parameter the pointer to the selected device
            //  2) Initializing the controls in the dialog box to their initial values
            //  3) Send a message that our list of routines has changed 
            */
        
            pDevice = (PHID_DEVICE) lParam;

            vInitECControls(hDlg,
                            pDevice -> Caps.InputReportByteLength,
                            &pInputDisplay,
                            pDevice -> Caps.OutputReportByteLength,
                            &pOutputDisplay,
                            pDevice -> Caps.FeatureReportByteLength,
                            &pFeatureDisplay,
                            LogPnP_IsLogicalDevice(pDevice)
                           );
  
            PostMessage(hDlg,
                        WM_COMMAND,
                        IDC_EXTCALLS + (CBN_SELCHANGE << 16),
                        (LPARAM) GetDlgItem(hDlg,IDC_EXTCALLS)
                       );
            break; 

        case WM_COMMAND:
            switch(LOWORD(wParam)) {

                case IDC_EXTCALLS:
                    switch (HIWORD(wParam)) {
                        case CBN_SELCHANGE:
                            iIndex = (INT) SendDlgItemMessage(hDlg, 
                                                              IDC_EXTCALLS,
                                                              CB_GETCURSEL,
                                                              0,
                                                              0
                                                             );
                            vEnableParameters(hDlg,
                                              SendDlgItemMessage(hDlg, 
                                                                 IDC_EXTCALLS,
                                                                 CB_GETITEMDATA,
                                                                 iIndex,
                                                                 0)
                                             );
                            break;
                    }
                    break;

                case IDC_INPUT_SELECT:
                    if (CBN_SELCHANGE == HIWORD(wParam)) {
                        BufferDisplay_ChangeSelection(pInputDisplay);
                    }
                    break;

                case IDC_OUTPUT_SELECT:
                    if (CBN_SELCHANGE == HIWORD(wParam)) {
                         BufferDisplay_ChangeSelection(pOutputDisplay);
                    }
                    break;

                case IDC_FEATURE_SELECT:
                    if (CBN_SELCHANGE == HIWORD(wParam)) {
                         BufferDisplay_ChangeSelection(pFeatureDisplay);
                    }
                    break;
                     
                case IDC_EXECUTE:
                    /*
                    // Get the parameters and verify that they are all correct
                    //   If there is an error, display an error message and
                    //   don't continue any further.
                    */

                    if ( !fGetAndVerifyParameters(hDlg, &params) ) {
                        ECDISP_ERROR(hDlg, "Error: One or more parameters are invalid");
                    }

                    /*
                    // Else the parameters are valid and we can execute the call
                    */
                      
                    else {
                        iIndex = SendDlgItemMessage(hDlg, IDC_EXTCALLS, CB_GETCURSEL, 0, 0);
                        iIndex = SendDlgItemMessage(hDlg, IDC_EXTCALLS, CB_GETITEMDATA, iIndex, 0);

                        /*
                        // Now that we know the function to execute we need to execute it
                        //    and output the data
                        */

                        SendDlgItemMessage(hDlg, IDC_CALLOUTPUT, LB_RESETCONTENT, 0, 0);
                        vExecuteAndDisplayOutput(GetDlgItem(hDlg, IDC_CALLOUTPUT), pDevice, iIndex, &params);
                    }
                    break;  /* end IDC_EXECUTE case */

                case IDC_CANCEL:
                    BufferDisplay_Destroy(pInputDisplay);
                    BufferDisplay_Destroy(pOutputDisplay);
                    BufferDisplay_Destroy(pFeatureDisplay);
                    EndDialog(hDlg, 0);
                    break;
            }
            break;

        case WM_CLOSE:
            PostMessage(hDlg, WM_COMMAND, IDC_CANCEL, 0);
            break;

    } 
    return FALSE;
}

VOID
vLoadExtCalls(
    HWND hExtCalls,
    BOOL IsLogicalDevice
)
{
    INT  iIndex;
    UINT uiIndex;

    /*
    // If we are a physical device, load the physical device specific calls as well
    */
    
    if (!IsLogicalDevice) {

        for (uiIndex = 0; uiIndex < HID_DEVCALLS; uiIndex++) {

            iIndex = SendMessage(hExtCalls, 
                                 CB_ADDSTRING, 
                                 0, 
                                 (LPARAM) DeviceCalls[uiIndex].szFunctionName
                                 );

            if (CB_ERR != iIndex || CB_ERRSPACE != iIndex) {
                SendMessage(hExtCalls,
                            CB_SETITEMDATA,
                            iIndex, 
                            DeviceCalls[uiIndex].uiIndex
                           );
            }
        }
    }

    /*
    // Load the other device calls no matter what
    */

    for (uiIndex = 0; uiIndex < HID_PPDCALLS; uiIndex++) {

        iIndex = SendMessage(hExtCalls, 
                             CB_ADDSTRING, 
                             0, 
                             (LPARAM) PpdCalls[uiIndex].szFunctionName
                             );

        if (CB_ERR != iIndex || CB_ERRSPACE != iIndex) {
            SendMessage(hExtCalls,
                        CB_SETITEMDATA,
                        iIndex, 
                        PpdCalls[uiIndex].uiIndex
                       );
        }
    }
    SendMessage(hExtCalls, CB_SETCURSEL, 0, 0);

    return;
}

VOID vSetReportType(
    HWND hDlg, 
    LONG lId
)
{
    CheckRadioButton(hDlg, IDC_INPUT, IDC_FEATURE, lId);
    return;
}

VOID 
vInitEditText(
    HWND hText, 
    INT  cbTextSize, 
    CHAR *pchText
)
{
    SendMessage(hText, EM_SETLIMITTEXT, (WPARAM) cbTextSize, 0); 
    SendMessage(hText, EM_REPLACESEL, 0, (LPARAM) pchText);
    return;
}

VOID vEnableParameters(
    HWND hDlg,
    INT  iCallSelection
)
{
    EnableWindow(GetDlgItem(hDlg, IDC_INPUT), pState[iCallSelection-1].fInputReport);
    EnableWindow(GetDlgItem(hDlg, IDC_OUTPUT), pState[iCallSelection-1].fOutputReport);
    EnableWindow(GetDlgItem(hDlg, IDC_FEATURE), pState[iCallSelection-1].fFeatureReport);
    EnableWindow(GetDlgItem(hDlg, IDC_REPORTID), pState[iCallSelection-1].fReportID);
    EnableWindow(GetDlgItem(hDlg, IDC_USAGEPAGE), pState[iCallSelection-1].fUsagePage);
    EnableWindow(GetDlgItem(hDlg, IDC_USAGE), pState[iCallSelection-1].fUsage);
    EnableWindow(GetDlgItem(hDlg, IDC_LINKCOLL), pState[iCallSelection-1].fLinkCollection);
    EnableWindow(GetDlgItem(hDlg, IDC_INPUT_SELECT), pState[iCallSelection-1].fInputReportSelect);
    EnableWindow(GetDlgItem(hDlg, IDC_OUTPUT_SELECT), pState[iCallSelection-1].fOutputReportSelect);
    EnableWindow(GetDlgItem(hDlg, IDC_FEATURE_SELECT), pState[iCallSelection-1].fFeatureReportSelect);
    return;
}
    
BOOL 
fGetAndVerifyParameters(
    HWND              hDlg, 
    PECDISPLAY_PARAMS pParams
)
{

    /*
    // Declare a text buffer of size 7 since the parameter limit is at most 6
    //   characters in the edit box.  
    */
    
    CHAR    WindowText[7];
    BOOL    fStatus = TRUE;
    PCHAR   nptr;
    
    if (IsDlgButtonChecked(hDlg, IDC_INPUT)) {
        pParams -> ReportType = HidP_Input;
    }
    else if (IsDlgButtonChecked(hDlg, IDC_OUTPUT)) {
        pParams -> ReportType = HidP_Output;
    }
    else {
        assert (IsDlgButtonChecked(hDlg, IDC_FEATURE));
        pParams -> ReportType = HidP_Feature;
    }

    /*
    // Get and verify the usage page window text;
    */
    
    GetWindowText(GetDlgItem(hDlg, IDC_USAGEPAGE), WindowText, 7);
    pParams -> UsagePage = (USAGE) strtol(WindowText, &nptr, 16);
    if (*nptr != '\0') {
        fStatus = FALSE;
        pParams -> UsagePage = 0;
    }

    /*
    // Get and verify the usage window text
    */

    GetWindowText(GetDlgItem(hDlg, IDC_USAGE), WindowText, 7);
    pParams -> Usage = (USAGE) strtol(WindowText, &nptr, 16);
    if (*nptr != '\0') {
        fStatus = FALSE;
        pParams -> Usage = 0;
    }
    
    /*
    // Get and verify the link collection window text
    */

    GetWindowText(GetDlgItem(hDlg, IDC_LINKCOLL), WindowText, 7);
    pParams -> LinkCollection = (USAGE) strtol(WindowText, &nptr, 16);
    if (*nptr != '\0') {
        fStatus = FALSE;
        pParams -> LinkCollection = 0;
    }
    
    GetWindowText(GetDlgItem(hDlg, IDC_REPORTID), WindowText, 7);
    pParams -> ReportID = (UCHAR) strtol(WindowText, &nptr, 10);
    if (*nptr != '\0') {
        fStatus = FALSE;
        pParams -> ReportID = 0;
    }
    return (fStatus);
}


VOID
vInitECControls(
    HWND                hDlg,
    USHORT              InputReportByteLength,
    PBUFFER_DISPLAY     *ppInputDisplay,
    USHORT              OutputReportByteLength,
    PBUFFER_DISPLAY     *ppOutputDisplay,
    USHORT              FeatureReportByteLength,
    PBUFFER_DISPLAY     *ppFeatureDisplay,
    BOOL                IsLogicalDevice
)
{
    BOOLEAN     fInitStatus;

    /*
    // Begin by initializing the combo box with the calls that can be executed
    */

    vLoadExtCalls(GetDlgItem(hDlg, IDC_EXTCALLS), IsLogicalDevice);

    /*
    // Set the radio buttons initially to the input report type
    */
    
    vSetReportType(hDlg, IDC_INPUT);
    
    /*
    // Initialize the edit controls text
    */

    vInitEditText(GetDlgItem(hDlg, IDC_USAGEPAGE), 6, "0x0000");
    vInitEditText(GetDlgItem(hDlg, IDC_USAGE), 6, "0x0000");
    vInitEditText(GetDlgItem(hDlg, IDC_LINKCOLL), 2, "0");
    vInitEditText(GetDlgItem(hDlg, IDC_REPORTID), 2, "0");

    /*
    // Initialize the report buffer boxes
    */

    fInitStatus = BufferDisplay_Init(GetDlgItem(hDlg, IDC_INPUT_SELECT),
                                     GetDlgItem(hDlg, IDC_INPUT_BUFFER),
                                     NUM_INPUT_BUFFERS,
                                     InputReportByteLength,
                                     HidP_Input,
                                     ppInputDisplay
                                    );

    if (!fInitStatus) 
        ECDISP_ERROR(hDlg, "Error initializing input buffer display");

    fInitStatus = BufferDisplay_Init(GetDlgItem(hDlg, IDC_OUTPUT_SELECT),
                                     GetDlgItem(hDlg, IDC_OUTPUT_BUFFER),
                                     NUM_OUTPUT_BUFFERS,
                                     OutputReportByteLength,
                                     HidP_Output,
                                     ppOutputDisplay
                                    );

    if (!fInitStatus) 
        ECDISP_ERROR(hDlg,  "Error initializing output buffer display");

    fInitStatus = BufferDisplay_Init(GetDlgItem(hDlg, IDC_FEATURE_SELECT),
                                     GetDlgItem(hDlg, IDC_FEATURE_BUFFER),
                                     NUM_FEATURE_BUFFERS,
                                     FeatureReportByteLength,
                                     HidP_Feature,
                                     ppFeatureDisplay
                                    );

    if (!fInitStatus) 
        ECDISP_ERROR(hDlg, "Error initializing feature buffer display");

    /*
    // Reset the output box content
    */
    
    SendMessage(GetDlgItem(hDlg, IDC_CALLOUTPUT), LB_RESETCONTENT, 0, 0);
    return;
}
    
BOOL
ECDisp_Execute(
    IN     INT             FuncCall,
    IN OUT PEXTCALL_PARAMS CallParams,
    OUT    PEXTCALL_STATUS CallStatus
)
/*++
RoutineDescription:
    This routine is a complex routine for executing all of the functions.  The
    routine was originally developed with consideration for future use that 
    never materialized.  

    It makes use of the calls in extcalls.c which basically execute the given
    function and does some verification on the buffers that are passed down to 
    HID.DLL.  

    The input parameters are specify the function call to execute, the 
    call parameters structures and the call status structure.

    If any further buffers are needed for the specific calls, they will be
    allocated here.  

    The CallStatus parameters is a structure set by the ExtCalls_ routines

    Future versions of the HClient sample may remove this routine and/or the
    ExtCalls_ routines to simply the code.
--*/
{
    BOOL                ExecuteStatus;
    EXTCALL_PARAMS      IntermediateParams;
    EXTCALL_STATUS      IntermediateStatus;
    PHIDP_VALUE_CAPS    ValueCaps;
    PULONG              ValueList;

    switch (FuncCall) {
        case HID_READ_REPORT:
            ExtCalls_ReadInputBuffer(CallParams, CallStatus);
            return (TRUE);
            break;

        case HID_WRITE_REPORT:
            ExtCalls_WriteOutputBuffer(CallParams, CallStatus);
            return (TRUE);
            break;

        case HIDD_FLUSH_QUEUE:
            ExtCalls_HidD_FlushQueue(CallParams, CallStatus);
            return (TRUE);
            break;

        case HIDD_GET_HID_GUID:
            CallParams -> List = ALLOC(sizeof(GUID));

            if (NULL != CallParams -> List) {
                CallParams -> ListLength = sizeof(GUID);
                ExtCalls_HidD_GetHidGuid(CallParams,
                                         CallStatus
                                        );
                return (TRUE);
            }
            return (FALSE);

        case HIDD_GET_PREPARSED_DATA:
            ExtCalls_HidD_GetPreparsedData(CallParams, CallStatus);
            return (TRUE);

        case HIDD_FREE_PREPARSED_DATA:
            ExtCalls_HidD_FreePreparsedData(CallParams, CallStatus);
            return (TRUE);

        case HIDD_GET_ATTRIBUTES:
            CallParams -> List = ALLOC(sizeof(HIDD_ATTRIBUTES));
            if (NULL != CallParams -> List) {
                CallParams -> ListLength = sizeof(HIDD_ATTRIBUTES);
                ExtCalls_HidD_GetAttributes(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);
            
        case HIDD_GET_FEATURE:
            *(CallParams -> ReportBuffer) = CallParams -> ReportID;
            ExtCalls_HidD_GetFeature(CallParams, CallStatus);
            return (TRUE);

        case HIDD_SET_FEATURE:
            ExtCalls_HidD_SetFeature(CallParams, CallStatus);
            return (TRUE);

        case HIDD_GET_NUM_INPUT_BUFFERS:
            ExtCalls_HidD_GetNumInputBuffers(CallParams, CallStatus);
            return (TRUE);

        case HIDD_SET_NUM_INPUT_BUFFERS:
            ExtCalls_HidD_SetNumInputBuffers(CallParams, CallStatus);
            return(TRUE);

        case HIDD_GET_PHYSICAL_DESCRIPTOR:
            
            CallParams -> List = (PCHAR) ALLOC (CallParams -> ListLength);
            if (NULL != CallParams -> List ) {
                ExtCalls_HidD_GetPhysicalDescriptor(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDD_GET_MANUFACTURER_STRING:
            
            CallParams -> List = (PWCHAR) ALLOC (CallParams -> ListLength);
            if (NULL != CallParams -> List ) {
                ExtCalls_HidD_GetManufacturerString(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDD_GET_PRODUCT_STRING:
            
            CallParams -> List = (PWCHAR) ALLOC (CallParams -> ListLength);
            if (NULL != CallParams -> List ) {
                ExtCalls_HidD_GetProductString(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDD_GET_INDEXED_STRING:
            
            CallParams -> List = (PWCHAR) ALLOC (CallParams -> ListLength);
            if (NULL != CallParams -> List ) {
                ExtCalls_HidD_GetIndexedString(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDD_GET_SERIAL_NUMBER_STRING:
            
            CallParams -> List = (PWCHAR) ALLOC (CallParams -> ListLength);
            if (NULL != CallParams -> List ) {
                ExtCalls_HidD_GetSerialNumberString(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDP_GET_BUTTON_CAPS:
            CallParams -> List = ALLOC(CallParams -> ListLength * sizeof(HIDP_BUTTON_CAPS));
            if (NULL != CallParams -> List) {
                ExtCalls_HidP_GetButtonCaps(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDP_GET_BUTTONS:

            CallParams -> ListLength = HidP_MaxUsageListLength(CallParams -> ReportType,
                                                               CallParams -> UsagePage,
                                                               CallParams -> Ppd
                                                              );

            CallParams -> List = ALLOC(CallParams -> ListLength * sizeof(USAGE));
            if (NULL != CallParams -> List) {
                ExtCalls_HidP_GetButtons(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDP_GET_BUTTONS_EX:

            CallParams -> ListLength = HidP_MaxUsageListLength(CallParams -> ReportType,
                                                               CallParams -> UsagePage,
                                                               CallParams -> Ppd
                                                              );
            CallParams -> List = ALLOC(CallParams -> ListLength * sizeof(USAGE_AND_PAGE));
            if (NULL != CallParams -> List) {
                ExtCalls_HidP_GetButtonsEx(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);
            
        case HIDP_GET_CAPS:
            CallParams -> List = ALLOC(sizeof(HIDP_CAPS));
            if (NULL != CallParams -> List) {
                CallParams -> ListLength = sizeof(HIDP_CAPS);
                ExtCalls_HidP_GetCaps(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDP_GET_DATA:

            CallParams -> ListLength = HidP_MaxDataListLength(CallParams -> ReportType,
                                                              CallParams -> Ppd
                                                             );

            CallParams -> List = ALLOC(CallParams -> ListLength * sizeof(HIDP_DATA));
            if (NULL != CallParams -> List) {
                ExtCalls_HidP_GetButtonsEx(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDP_GET_LINK_COLL_NODES:
            CallParams -> List = ALLOC(CallParams -> ListLength * sizeof(HIDP_LINK_COLLECTION_NODE));
            if (NULL != CallParams -> List) {
                ExtCalls_HidP_GetLinkCollectionNodes(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDP_GET_SCALED_USAGE_VALUE:
            ExtCalls_HidP_GetScaledUsageValue(CallParams, CallStatus);
            return (TRUE);

        case HIDP_GET_SPECIFIC_BUTTON_CAPS:
            CallParams -> List = ALLOC(CallParams -> ListLength * sizeof(HIDP_BUTTON_CAPS));
            if (NULL != CallParams -> List) {
                ExtCalls_HidP_GetSpecificButtonCaps(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);
            
        case HIDP_GET_SPECIFIC_VALUE_CAPS:
            CallParams -> List = ALLOC(CallParams -> ListLength * sizeof(HIDP_VALUE_CAPS));
            if (NULL != CallParams -> List) {
                ExtCalls_HidP_GetSpecificValueCaps(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);


        case HIDP_GET_USAGES:
            CallParams -> ListLength = HidP_MaxUsageListLength(CallParams -> ReportType,
                                                                    CallParams -> UsagePage,
                                                                    CallParams -> Ppd
                                                                   );

            CallParams -> List = ALLOC(CallParams -> ListLength * sizeof(USAGE));
            if (NULL != CallParams -> List) {
                ExtCalls_HidP_GetUsages(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDP_GET_USAGES_EX:
            CallParams -> ListLength = HidP_MaxUsageListLength(CallParams -> ReportType,
                                                                    CallParams -> UsagePage,
                                                                    CallParams -> Ppd
                                                                   );
            CallParams -> List = ALLOC(CallParams -> ListLength * sizeof(USAGE_AND_PAGE));
            if (NULL != CallParams -> List) {
                ExtCalls_HidP_GetUsagesEx(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);
             
        case HIDP_GET_USAGE_VALUE:
            ExtCalls_HidP_GetUsageValue(CallParams, CallStatus);
            return (TRUE);

        case HIDP_GET_USAGE_VALUE_ARRAY:
            IntermediateParams = *CallParams;
            IntermediateParams.ListLength = 1;
            ExecuteStatus = ECDisp_Execute(HIDP_GET_SPECIFIC_VALUE_CAPS,
                                           &IntermediateParams,
                                           &IntermediateStatus
                                          );

            if (!ExecuteStatus || IntermediateStatus.IsHidError ||
                    IntermediateStatus.IsHidDbgError || 0 == IntermediateParams.ListLength ) {

                if (IntermediateParams.List != NULL) {
                    FREE(IntermediateParams.List);
                }
                return (FALSE);
            }

            ValueCaps = (PHIDP_VALUE_CAPS) IntermediateParams.List;

            ASSERT (ValueCaps -> UsagePage == CallParams -> UsagePage);
            ASSERT (ValueCaps -> LinkCollection == CallParams -> LinkCollection || 
                       0 == CallParams -> LinkCollection);

            CallParams -> BitSize     = ValueCaps -> BitSize;
            CallParams -> ReportCount = ValueCaps -> ReportCount;
            CallParams -> ListLength
                     = ROUND_TO_NEAREST_BYTE(CallParams -> BitSize * CallParams -> ReportCount);

            FREE(ValueCaps);

            CallParams -> List = ALLOC(CallParams -> ListLength);
            if (NULL != CallParams -> List) {
                ExtCalls_HidP_GetUsageValueArray(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDP_GET_VALUE_CAPS:
            CallParams -> List = ALLOC(CallParams -> ListLength * sizeof(HIDP_VALUE_CAPS));
            if (NULL != CallParams -> List) {
                ExtCalls_HidP_GetValueCaps(CallParams, CallStatus);
                return (TRUE);
            }
            return (FALSE);

        case HIDP_MAX_USAGE_LIST_LENGTH:
            ExtCalls_HidP_MaxUsageListLength(CallParams, CallStatus);
            return (TRUE);

        case HIDP_MAX_DATA_LIST_LENGTH:
            ExtCalls_HidP_MaxDataListLength(CallParams, CallStatus);
            return (TRUE);

        case HIDP_SET_BUTTONS:
            ExtCalls_HidP_SetButtons(CallParams, CallStatus);
            return (TRUE);

        case HIDP_SET_DATA:
            ExtCalls_HidP_SetData(CallParams, CallStatus);
            return (TRUE);

        case HIDP_SET_SCALED_USAGE_VALUE:
            ExtCalls_HidP_SetScaledUsageValue(CallParams, CallStatus);
            return (TRUE);

        case HIDP_SET_USAGES:
            ExtCalls_HidP_SetUsages(CallParams, CallStatus);
            return (TRUE);

        case HIDP_SET_USAGE_VALUE:
            ExtCalls_HidP_SetUsageValue(CallParams, CallStatus);
            return (TRUE);

        case HIDP_SET_USAGE_VALUE_ARRAY:
            IntermediateParams = *CallParams;
            ExecuteStatus = ECDisp_Execute(HIDP_GET_SPECIFIC_VALUE_CAPS,
                                           &IntermediateParams,
                                           &IntermediateStatus
                                          );

            if (!ExecuteStatus && !IntermediateStatus.IsHidError &&
                    !IntermediateStatus.IsHidDbgError) {

                if (IntermediateParams.List != NULL) {
                    FREE(IntermediateParams.List);
                }
                return (FALSE);
            }

            ValueCaps = (PHIDP_VALUE_CAPS) IntermediateParams.List;

            ASSERT (ValueCaps -> UsagePage == CallParams -> UsagePage);
            ASSERT (ValueCaps -> LinkCollection == CallParams -> LinkCollection || 
                       0 == CallParams -> LinkCollection);

            CallParams -> BitSize     = ValueCaps -> BitSize;
            CallParams -> ReportCount = ValueCaps -> ReportCount;
 
            FREE(ValueCaps);
 
            ValueList = CallParams -> List;
            ExecuteStatus = ECDisp_ConvertUlongListToValueList(ValueList,
                                                               CallParams -> ListLength,
                                                               CallParams -> BitSize,
                                                               CallParams -> ReportCount,
                                                               (PCHAR *) &CallParams -> List,
                                                               &CallParams -> ListLength
                                                              );

            FREE(ValueList);

            if (!ExecuteStatus) 
                return (FALSE);

            ExtCalls_HidP_SetUsageValueArray(CallParams, CallStatus);
            return (TRUE);

        case HIDP_UNSET_BUTTONS:
            ExtCalls_HidP_UnsetButtons(CallParams, CallStatus);
            return (TRUE);

        case HIDP_UNSET_USAGES:
            ExtCalls_HidP_UnsetUsages(CallParams, CallStatus);
            return (TRUE);

        case HIDP_USAGE_LIST_DIFFERENCE:
            CallParams -> MakeList = (PUSAGE) ALLOC (sizeof(USAGE) * CallParams -> ListLength);
            if (NULL == CallParams -> MakeList) {
                return (FALSE);
            }

            CallParams -> BreakList = (PUSAGE) ALLOC (sizeof(USAGE) * CallParams -> ListLength);
            if (NULL == CallParams -> BreakList) {
                FREE(CallParams -> MakeList);
                return (FALSE);
            }

            ExtCalls_HidP_UsageListDifference(CallParams, CallStatus);
            return (TRUE);
    }
    return (FALSE);
}

VOID
ECDisp_DisplayOutput(
    IN HWND            hOutputWindow,
    IN INT             FuncCall,
    IN PEXTCALL_PARAMS Results
)
/*++
RoutineDescription:
    This routine is responsible for displaying the output from calls to HID.DLL
    functions.  It must extract and interpret the appropriate data from the 
    PEXTCALL_PARAMS structure. 
--*/
{
    PHIDP_LINK_COLLECTION_NODE NodeList;
    PHIDP_BUTTON_CAPS          ButtonCaps;
    PHIDP_VALUE_CAPS           ValueCaps;
    PHIDP_DATA                 DataList;
    PUSAGE_AND_PAGE            UsageAndPageList;
    PUSAGE                     UsageList;
    PCHAR                      UsageValueArray;
    PBUFFER_DISPLAY            pDisplay;
    PCHAR                      PhysDescString;

    ULONG                      Index;

    switch (FuncCall) {
        case HIDD_GET_HID_GUID:

            strcpy(szTempBuffer, "HID Guid: ");
            ECDisp_MakeGUIDString(*((LPGUID) Results -> List),
                                  &szTempBuffer[strlen(szTempBuffer)]
                                 );

            OUTSTRING(hOutputWindow, szTempBuffer);
            break;

        case HIDD_GET_ATTRIBUTES:
            vDisplayDeviceAttributes((PHIDD_ATTRIBUTES) Results -> List,
                                     hOutputWindow
                                    );
            break;

        case HIDD_GET_NUM_INPUT_BUFFERS:
            wsprintf(szTempBuffer,
                     "Number input buffers: %u", 
                     Results -> Value
                    );

            OUTSTRING(hOutputWindow, szTempBuffer);
            break;

        case HIDD_GET_PHYSICAL_DESCRIPTOR: 
            OUTSTRING(hOutputWindow, "Physical Descriptor");
            OUTSTRING(hOutputWindow, "===================");

            /*
            // To display a physical descriptor, the procedure currently just
            //   creates a string data buffer by bytes and displays that 
            //   in the results box.  It will display in rows of 16 bytes apiece.
            */
            
            Index = 0;
            while (Index < Results -> ListLength) {
                Strings_CreateDataBufferString(((PCHAR) Results -> List) + Index,
                                               Results -> ListLength - Index,
                                               16,
                                               1,
                                               &PhysDescString
                                              );

                if (NULL != PhysDescString) {
                    OUTSTRING(hOutputWindow, PhysDescString);
                    FREE(PhysDescString);
                }
                else {
                   OUTSTRING(hOutputWindow, "Error trying to display physical descriptor");
                }
                Index += 16;
            }
            break;

        /*
        // For the string descriptor call routines, the returned string is stored
        //   in the Results -> List parameter.  It should be noted that the
        //   strings returned by these calls are wide-char strings and that these
        //   string are terminated with a NULL character if there was space withing
        //   the buffer to add such a character.  If the buffer was only big enough
        //   to hold the characters of the string, there will be no null terminator
        //   and the output string display mechanism may fail to properly display this
        //   type of string.  Fixing of this display mechanism is a future (low priority)
        //   workitem.
        */
        
        case HIDD_GET_PRODUCT_STRING:
            OUTSTRING(hOutputWindow, "Product String");
            OUTSTRING(hOutputWindow, "==============");
            OUTWSTRING(hOutputWindow, Results -> List);
            break;

        case HIDD_GET_MANUFACTURER_STRING:
            OUTSTRING(hOutputWindow, "Manufacturer String");
            OUTSTRING(hOutputWindow, "===================");
            OUTWSTRING(hOutputWindow, Results -> List);
            break;

        case HIDD_GET_INDEXED_STRING:
            wsprintf(szTempBuffer,
                     "Indexed String #%u:",
                     Results -> StringIndex
                    );
            OUTSTRING(hOutputWindow, szTempBuffer);
            OUTSTRING(hOutputWindow, "===================");
            OUTWSTRING(hOutputWindow, Results -> List);
            break;

        case HIDD_GET_SERIAL_NUMBER_STRING:
            OUTSTRING(hOutputWindow, "Serial Number String");
            OUTSTRING(hOutputWindow, "=====================");
            OUTWSTRING(hOutputWindow, Results -> List);
            break;
            
        case HIDP_GET_BUTTON_CAPS:
        case HIDP_GET_SPECIFIC_BUTTON_CAPS:

            ButtonCaps = (PHIDP_BUTTON_CAPS) (Results -> List);
            for (Index = 0; Index < Results -> ListLength; Index++, ButtonCaps++) {

                 OUTSTRING(hOutputWindow, "==========================");
                 vDisplayButtonAttributes(ButtonCaps,
                                          hOutputWindow
                                         );
            }
            break;

        /*
        // HidP_GetButtons and HidP_GetUsages are in reality the same call.  
        //   HidP_GetButtons actually a macro which gets redefined into 
        //   HidP_GetUsages with the same parameter order.  That is why their
        //   display mechanisms are identical.  This call returns in the 
        //   List parameter a list of Usages.  The display mechanism converts
        //   these usages into a string of numbers.
        */
        
        case HIDP_GET_BUTTONS:
        case HIDP_GET_USAGES:

            OUTSTRING(hOutputWindow, "Usages Returned");
            OUTSTRING(hOutputWindow, "===============");

            UsageList = (PUSAGE) Results -> List;
            for (Index = 0; Index < Results -> ListLength; Index++) {

                vCreateUsageString(UsageList + Index,
                                   szTempBuffer
                                  );
                OUTSTRING(hOutputWindow, szTempBuffer);
            }
            break;

        /*
        // Like get their siblings, the normal get functions, these routines are
        //   currently one in the same.  The difference between these routines 
        //   and their siblings is the return of a usage page along with each
        //   usage.  Therefore, both values must be displayed at the same time.
        */
        
        case HIDP_GET_BUTTONS_EX:
        case HIDP_GET_USAGES_EX:

            OUTSTRING(hOutputWindow, "Usages Returned");
            OUTSTRING(hOutputWindow, "===============");

            UsageAndPageList = (PUSAGE_AND_PAGE) Results -> List;
            for (Index = 0; Index < Results -> ListLength; Index++) {

                vCreateUsageAndPageString(UsageAndPageList + Index,
                                          szTempBuffer
                                         );
                OUTSTRING(hOutputWindow, szTempBuffer);
            }
            break;

        case HIDP_GET_CAPS:
            vDisplayDeviceCaps((PHIDP_CAPS) Results -> List,
                               hOutputWindow
                              );

            break;

        case HIDP_GET_DATA:
            OUTSTRING(hOutputWindow, "Data Indices");
            OUTSTRING(hOutputWindow, "============");
            
            DataList = (PHIDP_DATA) Results -> List;
            for (Index = 0; Index < Results -> ListLength; Index++) {
                vDisplayDataAttributes(DataList+Index,
                                       FALSE,
                                       hOutputWindow
                                      );
            }
            break;

        case HIDP_GET_LINK_COLL_NODES:

            OUTSTRING(hOutputWindow, "Link Collection Nodes");
            OUTSTRING(hOutputWindow, "=====================");
            
            NodeList = (PHIDP_LINK_COLLECTION_NODE) Results -> List;
            for (Index = 0; Index < Results -> ListLength; Index++) {
    
                OUTSTRING(hOutputWindow, "===========================");
                vDisplayLinkCollectionNode(NodeList+Index,
                                           Index,
                                           hOutputWindow
                                          );
            }
            break;

        case HIDP_GET_SCALED_USAGE_VALUE:
        
            wsprintf(szTempBuffer, "Scaled usage value: %ld", Results -> ScaledValue);
            OUTSTRING(hOutputWindow, szTempBuffer);

            break;

        case HIDP_GET_USAGE_VALUE:
            wsprintf(szTempBuffer, "Usage value: %lu", Results -> Value);
            OUTSTRING(hOutputWindow, szTempBuffer);
            break;

        /*
        // To display a usage value array, we must extract each of the values
        //   in the array based on the ReportSize.  The ReportSize is not necessarily
        //   an even byte size so we must use the special extraction routine to get
        //   each of the values in the array.
        */
        
        case HIDP_GET_USAGE_VALUE_ARRAY:

            UsageValueArray = (PCHAR) Results -> List;

            for (Index = 0; Index < Results -> ReportCount; Index++) {
                vCreateUsageValueStringFromArray(UsageValueArray,
                                                 Results -> BitSize,
                                                 (USHORT) Index,
                                                 szTempBuffer
                                                );
        
                OUTSTRING(hOutputWindow, szTempBuffer);
            }
            break;

        case HIDP_GET_VALUE_CAPS:
        case HIDP_GET_SPECIFIC_VALUE_CAPS:
            
            ValueCaps = (PHIDP_VALUE_CAPS) Results -> List;
    
            for (Index = 0; Index < (INT) Results -> ListLength; Index++) {

                OUTSTRING(hOutputWindow, "==========================");
                vDisplayValueAttributes(ValueCaps + Index,
                                        hOutputWindow
                                       );
            }
            break;

        case HIDP_MAX_DATA_LIST_LENGTH:
            wsprintf(szTempBuffer, "MaxDataListLength: %u", Results -> Value);
            OUTSTRING(hOutputWindow, szTempBuffer);
            break;

        case HIDP_MAX_USAGE_LIST_LENGTH:
            wsprintf(szTempBuffer, "MaxUsageListLength: %u", Results -> Value);
            OUTSTRING(hOutputWindow, szTempBuffer);
            break;

        /*
        // For HidP_UsageListDifference, we need to display both of the make and
        //   break lists generated by the function.  Therefore, we end up creating
        //   two different usage list strings.
        */
        
        case HIDP_USAGE_LIST_DIFFERENCE:
            
            OUTSTRING(hOutputWindow, "Make List");
            OUTSTRING(hOutputWindow, "=========");

            UsageList = (PUSAGE) Results -> MakeList;
            Index = 0;

            while (0 != *(UsageList+Index) && Index < Results -> ListLength) {

                vCreateUsageString(UsageList + Index,
                                   szTempBuffer
                                  );

                OUTSTRING(hOutputWindow, szTempBuffer);
                Index++;
            }


            OUTSTRING(hOutputWindow, "Break List");
            OUTSTRING(hOutputWindow, "==========");

            UsageList = (PUSAGE) Results -> BreakList;
            Index = 0;

            while (0 != *(UsageList+Index) && Index < Results -> ListLength) {

                vCreateUsageString(UsageList + Index,
                                   szTempBuffer
                                  );

                OUTSTRING(hOutputWindow, szTempBuffer);
                Index++;
            }
            break;

        /*
        // These functions simply update the buffer that is specified as the 
        //   input parameter.  We must select the correct display buffer mechanism
        //   based on the ReportType for the call and then update the given report
        //   in that display mechanism.
        */
        
        case HID_READ_REPORT:
        case HIDD_GET_FEATURE:
        case HIDP_SET_BUTTONS:
        case HIDP_SET_DATA:
        case HIDP_SET_SCALED_USAGE_VALUE:
        case HIDP_SET_USAGES:
        case HIDP_SET_USAGE_VALUE:
        case HIDP_SET_USAGE_VALUE_ARRAY:
        case HIDP_UNSET_BUTTONS:
        case HIDP_UNSET_USAGES:
            SELECT_ON_REPORT_TYPE(Results -> ReportType,
                                  pInputDisplay,
                                  pOutputDisplay,
                                  pFeatureDisplay,
                                  pDisplay
                                 );

            BufferDisplay_UpdateBuffer(pDisplay,
                                       Results -> ReportBuffer
                                      );
            break;
    }
    return;
}

VOID 
vExecuteAndDisplayOutput(
    HWND              hOutputWindow,
    PHID_DEVICE       pDevice,
    INT               iFuncCall,
    PECDISPLAY_PARAMS params
)
/*++
RoutineDescription:
    This routine is a long function that is responsible for retrieving all the 
    paramter for a given function call, setting up the CallParameters structure
    and then call the execute routine to get the necessary results and status of 
    the operation.  It is then responsible for displaying the appropriate status
    and results if the function did not fail

    This routine is a fairly long, complex routine to do a simple task.  It may
    be broken down in future versions to simplify some of the complexity.
--*/
{
    EXTCALL_PARAMS    CallParameters;
    EXTCALL_STATUS    CallStatus;

    DLGBOX_STATUS     iDlgStatus;
    BOOL              ExecuteStatus;
    PBUFFER_DISPLAY   pBufferDisplay;
    PCHAR             pCopyBuffer;
    PCHAR             endp;
    UINT              DlgBoxNumber;
    BOOL              List2Alloc;
    BOOL              MakeListAlloc;
    BOOL              BreakListAlloc;

    /*
    // ExecuteAndDisplayOutput needless to say, consists of two parts: 
    //    Executing and Displaying output.  The first section involves the
    //     execution phase where all parameters are filled in if necessary
    //     and ECDisp_Execute is called
    */

    if (IS_NOT_IMPLEMENTED(iFuncCall)) {
        OUTSTRING(hOutputWindow, "Function not yet implemented");
        return;
    }

    /*
    // Check first to see if this is a HID_CLEAR_REPORT command.  If it is
    //    all we need to do is get the report buffer that is checked and
    //    then call the clear buffer command
    */

    if (HID_CLEAR_REPORT == iFuncCall) {
        SELECT_ON_REPORT_TYPE(params -> ReportType,
                              pInputDisplay,
                              pOutputDisplay,
                              pFeatureDisplay,
                              pBufferDisplay
                             );

        BufferDisplay_ClearBuffer(pBufferDisplay);
        return;
    }

    /*
    // Need to perform the following steps in order to get the parameters for
    //    our call and then execute the call:
    //      1) Get any additional parameters not supplied by the above dialog
    //           procedure.  This occurs for such functions as:
    //                  HIDP_SET_BUTTONS
    //                  HIDP_SET_DATA
    //                  HIDP_SET_USAGES
    //                  HIDP_SET_USAGE_VALUE
    //                  HIDP_SET_SCALED_USAGE_VALUE
    //                  HIDP_SET_USAGE_VALUE_ARRAY
    //                  HIDP_UNSET_BUTTONS
    //                  HIDP_UNSET_USAGES
    //          For these functions, a separate dialog box must be called
    //
    //      2) Fill in the common parameters from the passed in params struct
    //
    */

    /*
    // Step 1: We're storing the values retrieved by these additional dialog
    //          box in the params struct since we may actually be passed in
    //          these values in the future instead of getting them here.  Hence,
    //          we won't break any of the code that follows the switch statement
    */

    switch (iFuncCall) {
        case HIDP_SET_BUTTONS:
        case HIDP_SET_USAGES:
        case HIDP_UNSET_BUTTONS:
        case HIDP_UNSET_USAGES:

            switch (iFuncCall) {
                case HIDP_SET_BUTTONS:
                    DlgBoxNumber = IDD_SET_BUTTONS;
                    break;

                case HIDP_SET_USAGES:
                    DlgBoxNumber = IDD_SET_USAGES;
                    break;

                case HIDP_UNSET_BUTTONS:
                    DlgBoxNumber = IDD_UNSET_BUTTONS;
                    break;

                case HIDP_UNSET_USAGES:
                    DlgBoxNumber = IDD_UNSET_USAGES;
                    break;
            }

            iDlgStatus = DialogBoxParam(NULL,
                                        MAKEINTRESOURCE(DlgBoxNumber),
                                        GetParent(hOutputWindow),
                                        bSetUsagesDlgProc,
                                        (LPARAM) params
                                       );
            /*                      
            // If the above call returns 1, then the dialog box routine
            //     successfully acquired a string from the user and put the
            //     pointer to it in params -> szListString.
            //     Now we need to convert the string to a usage list
            */

            if (DLGBOX_OK != iDlgStatus) 
                return;
        

            ExecuteStatus = ConvertStringToUsageList(params -> szListString,
                                                     &params -> UsageList,
                                                     &params -> ListLength
                                                    );
            FREE(params -> szListString);

            if (!ExecuteStatus) {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Error getting usage list"
                            );

                FREE(&params -> UsageList);
                return;
            }
            break;

        case HIDD_GET_INDEXED_STRING:
            iDlgStatus = DialogBoxParam(NULL,
                                        MAKEINTRESOURCE(IDD_GET_INDEX_STRING),
                                        GetParent(hOutputWindow),
                                        bGetIndexedDlgProc,
                                        (LPARAM) params
                                       );

            if (DLGBOX_OK != iDlgStatus) 
                return;

            params -> StringIndex = strtoul(params -> szListString, &endp, 10);
            FREE(params -> szListString);
            
            if ('\0' != *endp) {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Invalid index value"
                            );

                FREE(params -> szListString2);                            
                return;
            }
            
            params -> ListLength = strtoul(params -> szListString2, &endp, 10);
            FREE(params -> szListString2);

            if ('\0' != *endp) {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Invalid buffer size"
                            );
                return;
            }
            break;
            
        case HIDD_GET_PHYSICAL_DESCRIPTOR:
        case HIDD_GET_MANUFACTURER_STRING:
        case HIDD_GET_PRODUCT_STRING:
        case HIDD_GET_SERIAL_NUMBER_STRING:
            iDlgStatus = DialogBoxParam(NULL,
                                        MAKEINTRESOURCE(IDD_SET_BUFFER_LENGTH),
                                        GetParent(hOutputWindow),
                                        bSetBufLenDlgProc,
                                        (LPARAM) params
                                       );

            if (DLGBOX_OK != iDlgStatus) 
                return;

            params -> ListLength = strtoul(params -> szListString, &endp, 10);
            FREE(params -> szListString);

            if ('\0' != *endp) {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Invalid buffer length"
                            );
                return;
            }
            break;

        case HIDD_SET_NUM_INPUT_BUFFERS:
            iDlgStatus = DialogBoxParam(NULL,
                                        MAKEINTRESOURCE(IDD_SET_INPUT_BUFFERS),
                                        GetParent(hOutputWindow),
                                        bSetInputBuffDlgProc,
                                        (LPARAM) params
                                       );
            /*
            // If the above call returns 1, then the dialog box routine
            //     successfully acquired a string from the user and put the
            //     pointer to it in params -> szListString.
            //     Now we need to convert the string to a usage list
            */

            if (DLGBOX_OK != iDlgStatus) 
               return;

            params -> Value = strtoul(params -> szListString, &endp, 10);

            FREE(params -> szListString);

            if ('\0' != *endp) {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Invalid value specified"
                            );
                return;
            }
            break;

        case HIDP_SET_DATA:
            iDlgStatus = DialogBoxParam(NULL,
                                        MAKEINTRESOURCE(IDD_SET_DATA),
                                        GetParent(hOutputWindow),
                                        bSetDataDlgProc,
                                        (LPARAM) params
                                       );

            if (DLGBOX_OK != iDlgStatus) 
                return;

            break;

        case HIDP_SET_SCALED_USAGE_VALUE:
            iDlgStatus = DialogBoxParam(NULL,
                                        MAKEINTRESOURCE(IDD_SET_SCALED_VALUE),
                                        GetParent(hOutputWindow),
                                        bSetValueDlgProc,
                                        (LPARAM) params
                                       );
            /*
            // If the above call returns DLGBOX_OK, then the dialog box routine
            //     successfully acquired a string from the user and put the
            //     pointer to it in params -> szListString.
            //     Now we need to convert the string to a usage list
            */

            if (DLGBOX_OK != iDlgStatus) 
                return;

            params -> ScaledValue = strtol(params -> szListString, &endp, 10);
            FREE(params -> szListString);

            if ('\0' != *endp) {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Invalid scaled usage value"
                            );
                return;
            }
            break;

        case HIDP_SET_USAGE_VALUE:
            iDlgStatus = DialogBoxParam(NULL,
                                        MAKEINTRESOURCE(IDD_SET_USAGE_VALUE),
                                        GetParent(hOutputWindow),
                                        bSetValueDlgProc,
                                        (LPARAM) params
                                       );
            /*
            // If the above call returns 1, then the dialog box routine
            //     successfully acquired a string from the user and put the
            //     pointer to it in params -> szListString.
            //     Now we need to convert the string to a usage list
            */

            if (DLGBOX_OK != iDlgStatus) 
               return;

            params -> Value = strtoul(params -> szListString, &endp, 10);
            FREE(params -> szListString);
            
            if ('\0' != *endp) {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Invalid usage value"
                            );
                return;
            }
            break;


        case HIDP_SET_USAGE_VALUE_ARRAY:
            iDlgStatus = DialogBoxParam(NULL,
                                        MAKEINTRESOURCE(IDD_SET_USAGE_VALUE_ARRAY),
                                        GetParent(hOutputWindow),
                                        bSetValueDlgProc,
                                        (LPARAM) params
                                       );

            /*
            // If the above call returns 1, then the dialog box routine
            //     successfully acquired a string from the user and put the
            //     pointer to it in params -> szListString.
            //     Now we need to convert the string to a usage list
            */

            if (DLGBOX_OK != iDlgStatus) 
                return;

            ExecuteStatus = ConvertStringToUlongList(params -> szListString,
                                                     &params -> pValueList,
                                                     &params -> ListLength
                                                    );
            FREE(params -> szListString);

            if (!ExecuteStatus) {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Error getting list of values"
                             );
                return;
            }
            break;

        case HIDP_USAGE_LIST_DIFFERENCE:
            iDlgStatus = DialogBoxParam(NULL,
                                        MAKEINTRESOURCE(IDD_USAGE_LIST_DIFFERENCE),
                                        GetParent(hOutputWindow),
                                        bGetUsageDiffDlgProc,
                                        (LPARAM) params
                                       );

            if (DLGBOX_OK != iDlgStatus) 
                return;

            ExecuteStatus = Strings_StringToUnsignedList(params -> szListString,
                                                         sizeof(USAGE),
                                                         16,
                                                         (PCHAR *) &params -> UsageList,
                                                         &params -> ListLength
                                                        );

            if (!ExecuteStatus) {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Error getting list of values"
                            );
                FREE(params -> szListString);
                FREE(params -> szListString2);
                return;
            }

            ExecuteStatus = Strings_StringToUnsignedList(params -> szListString2,
                                                         sizeof(USAGE),
                                                         16, 
                                                         (PCHAR *) &params -> UsageList2,
                                                         &params -> ListLength2
                                                        );

            if (!ExecuteStatus) {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Error getting list of values"
                            );

                FREE(params -> szListString);
                FREE(params -> szListString2);
                FREE(params -> UsageList);
                return;
            }
            FREE(params -> szListString);
            FREE(params -> szListString2);
            break;
    }

    /*
    // Step 2: Extract the common parameters.  It's probably easier
    //    to simply fill in the spots in call parameters whether they are used
    //    or not instead of filling in only those that are relevant to a given
    //    function.  The details of some function relevant parameters are 
    //    handled after this.
    */

    CallParameters.DeviceHandle   = pDevice -> HidDevice;
    CallParameters.ReportType     = params -> ReportType;
    CallParameters.Ppd            = pDevice -> Ppd;
    CallParameters.UsagePage      = params -> UsagePage;
    CallParameters.Usage          = params -> Usage;
    CallParameters.LinkCollection = params -> LinkCollection;
    CallParameters.ReportID       = params -> ReportID;
    CallParameters.List           = NULL;
    CallParameters.List2          = NULL;
    CallParameters.MakeList       = NULL;
    CallParameters.BreakList      = NULL;
    CallParameters.ListLength     = 0;

    List2Alloc     = FALSE;
    MakeListAlloc  = FALSE;
    BreakListAlloc = FALSE;

    /*
    // Step 3: Now we'll deal with those functions that require a report buffer of some kind
    //    which means we'll copy the current buffer of the selected reported
    //    type
    */

    switch (iFuncCall) {
        case HID_READ_REPORT:
            CallParameters.ReportType   = HidP_Input;
            CallParameters.ReportBuffer = pDevice -> InputReportBuffer;
            CallParameters.ReportLength = pDevice -> Caps.InputReportByteLength;
            break;

        case HID_WRITE_REPORT:
            BufferDisplay_CopyCurrentBuffer(pOutputDisplay,
                                            pDevice -> OutputReportBuffer
                                           );

            CallParameters.ReportType    = HidP_Output;
            CallParameters.ReportBuffer  = pDevice -> OutputReportBuffer;
            CallParameters.ReportLength  = pDevice -> Caps.OutputReportByteLength;
            break;

        case HIDD_GET_FEATURE:
            CallParameters.ReportType   = HidP_Feature;
            CallParameters.ReportBuffer = pDevice -> FeatureReportBuffer;
            CallParameters.ReportLength = pDevice -> Caps.FeatureReportByteLength;
            break;

        case HIDD_GET_INDEXED_STRING:
            CallParameters.StringIndex = params -> StringIndex;
            CallParameters.ListLength  = params -> ListLength;
            break;

        case HIDD_SET_FEATURE:
           CallParameters.ReportType = HidP_Output;

        case HIDP_GET_BUTTONS:
        case HIDP_GET_BUTTONS_EX:
        case HIDP_GET_DATA:
        case HIDP_GET_SCALED_USAGE_VALUE:
        case HIDP_GET_USAGES:
        case HIDP_GET_USAGES_EX:
        case HIDP_GET_USAGE_VALUE:
        case HIDP_GET_USAGE_VALUE_ARRAY:
        case HIDP_SET_BUTTONS:
        case HIDP_SET_DATA:
        case HIDP_SET_SCALED_USAGE_VALUE:
        case HIDP_SET_USAGES:
        case HIDP_SET_USAGE_VALUE:
        case HIDP_SET_USAGE_VALUE_ARRAY:
        case HIDP_UNSET_BUTTONS:
        case HIDP_UNSET_USAGES:
            
            switch (CallParameters.ReportType) {
                case HidP_Input:
                    pBufferDisplay = pInputDisplay;
                    pCopyBuffer    = pDevice -> InputReportBuffer;
                    break;

                case HidP_Output:
                    pBufferDisplay = pOutputDisplay;
                    pCopyBuffer    = pDevice -> OutputReportBuffer;
                    break;

                case HidP_Feature:
                    pBufferDisplay = pFeatureDisplay;
                    pCopyBuffer    = pDevice -> FeatureReportBuffer;
                    break;

                default:
                    ASSERT(0);

            }
            BufferDisplay_CopyCurrentBuffer(pBufferDisplay,
                                            pCopyBuffer
                                           );

            CallParameters.ReportLength = BufferDisplay_GetBufferSize(pBufferDisplay);
            CallParameters.ReportBuffer = pCopyBuffer;
            break;

        default:
            CallParameters.ReportLength = 0;
            CallParameters.ReportBuffer = NULL;
    }

    /*
    // Now, we need to deal with those functions which have a List that is 
    //   used for either retrieving or gathering data.  There are two different
    //   cases.  The first involves the user inputting a buffer and the system 
    //   performing some action on the buffer, such as SetButtons.  We'll also 
    //   the other functions that require one of the union fields to be set.
    //   
    */

    /*
    // The second case is where data is retrieved for the device.  In this case,
    //     all we do is specify either the number of elements need for the buffer,
    //     the execute routine will worry about allocating the correct amount of
    //     space for those elements.  Remember, however, that if the Execute routine
    //     allocates space, we need to free it up.
    */

    /*
    // Then there's the third case UsageListDifference which truly changes
    //   everything.  We've got to determine the size of the resulting lists
    //   is the MaxSize of the other two lists.  Plus, we need to insure that 
    //   our buffers are 00 terminated if they are less than the max size, ie
    //   there not the same size as the larger buffer.  This may require
    //   reallocation of the block.
    */

    switch (iFuncCall) {

        /*
        // First Case functions
        */

        case HIDP_SET_DATA:
            CallParameters.List       = (PVOID) params -> pDataList;
            CallParameters.ListLength = params -> ListLength;
            break;

        case HIDP_SET_BUTTONS:
        case HIDP_UNSET_BUTTONS:
        case HIDP_SET_USAGES:
        case HIDP_UNSET_USAGES:
            CallParameters.List       = (PVOID) params -> UsageList;
            CallParameters.ListLength = params -> ListLength;
            break;

        case HIDP_SET_USAGE_VALUE_ARRAY:
            CallParameters.List       = (PVOID) params -> pValueList;
            CallParameters.ListLength = params -> ListLength;
            break;

        /*
        // Second Case functions
        */

        case HIDP_GET_BUTTON_CAPS:
        case HIDP_GET_SPECIFIC_BUTTON_CAPS:
            SELECT_ON_REPORT_TYPE(CallParameters.ReportType,
                                  pDevice -> Caps.NumberInputButtonCaps,
                                  pDevice -> Caps.NumberOutputButtonCaps,
                                  pDevice -> Caps.NumberFeatureButtonCaps,
                                  CallParameters.ListLength
                                 );
            break;

        case HIDP_GET_LINK_COLL_NODES:
            CallParameters.ListLength = pDevice -> Caps.NumberLinkCollectionNodes;
            break;

        case HIDD_GET_PHYSICAL_DESCRIPTOR:
        case HIDD_GET_MANUFACTURER_STRING:
        case HIDD_GET_PRODUCT_STRING:
        case HIDD_GET_SERIAL_NUMBER_STRING:
            CallParameters.ListLength = params -> ListLength;
            break;

        case HIDP_GET_VALUE_CAPS:
        case HIDP_GET_SPECIFIC_VALUE_CAPS:
            SELECT_ON_REPORT_TYPE(CallParameters.ReportType,
                                  pDevice -> Caps.NumberInputValueCaps,
                                  pDevice -> Caps.NumberOutputValueCaps,
                                  pDevice -> Caps.NumberFeatureValueCaps,
                                  CallParameters.ListLength
                                 );

        case HIDD_GET_FREE_PREPARSED_DATA:
            CallParameters.ppPd = &CallParameters.Ppd;
            break;

        case HIDP_SET_SCALED_USAGE_VALUE:
            CallParameters.ScaledValue = params -> ScaledValue;
            break;

        case HIDP_SET_USAGE_VALUE:
        case HIDD_SET_NUM_INPUT_BUFFERS:
            CallParameters.Value = params -> Value;
            break;
                

        /*
        // That third case
        */

        case HIDP_USAGE_LIST_DIFFERENCE:
            CallParameters.ListLength = MAX(params -> ListLength,
                                            params -> ListLength2
                                           );

            CallParameters.List  = params -> UsageList;
            CallParameters.List2 = params -> UsageList2;

            if (CallParameters.ListLength > params -> ListLength) {
                CallParameters.List = (PUSAGE) REALLOC(params -> UsageList,
                                                       (params -> ListLength+1) * sizeof(USAGE)
                                                      );
                if (NULL == CallParameters.List) {
                    ECDISP_ERROR(GetParent(hOutputWindow),
                                 "Error allocating memory"
                                );
                    FREE(params -> UsageList);
                    FREE(params -> UsageList2);
                    return;
                }

                *(((PUSAGE) CallParameters.List) + CallParameters.ListLength - 1) = 0;
            }
            else if (CallParameters.ListLength > params -> ListLength2) {
                CallParameters.List2 = (PUSAGE) REALLOC(params -> UsageList2,
                                                       (params -> ListLength+1) * sizeof(USAGE)
                                                      );
                if (NULL == CallParameters.List2) {
                    ECDISP_ERROR(GetParent(hOutputWindow),
                                 "Error allocating memory"
                                );
                    FREE(params -> UsageList);
                    FREE(params -> UsageList2);
                    return;
                }

                *(((PUSAGE) CallParameters.List2) + CallParameters.ListLength - 1) = 0;
            }
            List2Alloc = TRUE;
            MakeListAlloc = TRUE;
            BreakListAlloc = TRUE;
            break;
    }

    /*
    // Params are now set up and ready to go, let's execute
    */

    if (HIDD_GET_FREE_PREPARSED_DATA == iFuncCall) {
        ExecuteStatus = ECDisp_Execute(HIDD_GET_PREPARSED_DATA,
                                       &CallParameters,
                                       &CallStatus
                                      );

        if (!ExecuteStatus) {
            OUTSTRING(hOutputWindow, "Unknown error: Couldn't execute function");
            return;
        }

        DISPLAY_HIDD_STATUS(hOutputWindow, 
                            "HidD_GetPreparsedData",
                            CallStatus
                           );

        if (!CallStatus.IsHidError || !CallStatus.IsHidDbgError) {
            ExecuteStatus = ECDisp_Execute(HIDD_FREE_PREPARSED_DATA,
                                           &CallParameters,
                                           &CallStatus
                                          );

            OUTSTRING(hOutputWindow, "=======================");
            
            if (!ExecuteStatus) {
                OUTSTRING(hOutputWindow, "Unknown error: Couldn't execute function");
                return;
            }

            DISPLAY_HIDD_STATUS(hOutputWindow, 
                                "HidD_FreePreparsedData",
                                CallStatus
                               );
        }
    }
    else {
        ExecuteStatus = ECDisp_Execute(iFuncCall,
                                       &CallParameters,
                                       &CallStatus
                                      );

        if (!ExecuteStatus) {
            OUTSTRING(hOutputWindow, "Unknown error: Couldn't execute function");
            return;
        }

        if (IS_HIDD_FUNCTION(iFuncCall) || IS_HID_FUNCTION(iFuncCall)) {
            DISPLAY_HIDD_STATUS(hOutputWindow, 
                                GET_FUNCTION_NAME(iFuncCall),
                                CallStatus
                               );

        }
        else {
            DISPLAY_HIDP_STATUS(hOutputWindow,
                                GET_FUNCTION_NAME(iFuncCall),
                                CallStatus
                               );
        }
    }

    /*
    // Display the other results only if there wasn't a HID error
    */

    if (!CallStatus.IsHidError || (HIDP_STATUS_NULL == CallStatus.HidErrorCode)) {
        OUTSTRING(hOutputWindow, "=======================");

        /*
        // Now that general status information has been displayed, we need to
        //   display the info for the parts that are dependent on the function being
        //   called
        */
    
        ECDisp_DisplayOutput(hOutputWindow,
                             iFuncCall,
                             &CallParameters
                            );
    }

    if (CallParameters.List != NULL) {
        FREE(CallParameters.List);
    }

    if (List2Alloc && CallParameters.List2 != NULL) {
        FREE(CallParameters.List2);
    }

    if (MakeListAlloc && CallParameters.MakeList != NULL) {
        FREE(CallParameters.MakeList);
    }

    if (BreakListAlloc && CallParameters.BreakList != NULL) {
        FREE(CallParameters.BreakList);
    }

    return;
}

VOID
BuildReportIDList(
    IN  PHIDP_BUTTON_CAPS  phidButtonCaps,
    IN  USHORT             nButtonCaps,
    IN  PHIDP_VALUE_CAPS   phidValueCaps,
    IN  USHORT             nValueCaps,
    OUT PUCHAR            *ppReportIDList,
    OUT INT               *nReportIDs
)
/*++
RoutineDescription:
    This routine builds a list of report IDs that are listed in the passed in set
    of ButtonCaps and ValueCaps structure.  It allocates a buffer to store all
    the ReportIDs, if it can.  Otherwise the buffer is returned as NULL.

    Currently, this routine has no purpose in the HClient program. It was written
    for some purpose which never materialized but was left in because it might be
    useful in the future.
--*/
{    
    INT               nAllocatedIDs;
    INT               nFoundIDs;
    INT               nWalkCount;
    USHORT            usIndex;
    BOOL              fIDFound;
    UCHAR             *pucBuffer;
    UCHAR             *pucOldBuffer;
    UCHAR             *pucWalk;
    UCHAR             ucReportID;
    PHIDP_BUTTON_CAPS pButtonWalk;
    PHIDP_VALUE_CAPS  pValueWalk;

    /*
    // Initialize the output parameters in case there is some sort of failure
    */

    *nReportIDs = 0;
    *ppReportIDList = NULL;

    if (0 == nButtonCaps && 0 == nValueCaps)
        return;

    /*
    // Initialize the beginning array size to 2 report IDs and alloc space
    // for those IDs.  If we need to add more report IDs we allocate more
    // space
    */

    nAllocatedIDs = 2;
    nFoundIDs = 0;
    pButtonWalk = phidButtonCaps;
    pValueWalk = phidValueCaps;
                                              
    pucBuffer = (UCHAR *) ALLOC(sizeof(UCHAR) * nAllocatedIDs);
    if (NULL == pucBuffer) 
        return;

    /*
    // Beginning with the button caps and then going to the value caps do the
    // following
    //
    // 1) Take the report ID and search the array of report IDs looking for 
    //       an existing report ID and add to the array if not there.  
    //
    // 2) Add the report ID to the array in sorted order that way we sort the
    //      array at any time.  
    // 
    // 3) Must also realloc the array if we run out of array space
    */

    for (usIndex = 0; usIndex < nButtonCaps; usIndex++, pButtonWalk++) {
        ucReportID = pButtonWalk -> ReportID;
        
        pucWalk = pucBuffer;
        nWalkCount = 0;
        fIDFound = FALSE;

        while (!fIDFound && nWalkCount < nFoundIDs) {
            if (*pucWalk == ucReportID) 
                fIDFound = TRUE;

            else if (ucReportID > *pucWalk) {
                pucWalk++;
                nWalkCount++;
            }
        }

        if (!fIDFound) {
            if (nFoundIDs == nAllocatedIDs) {
                nAllocatedIDs *= 2;
                pucOldBuffer = pucBuffer;

                pucBuffer = (UCHAR *) REALLOC(pucBuffer, sizeof(UCHAR) * nAllocatedIDs);
                if (NULL == pucBuffer) {
                    FREE(pucOldBuffer);
                    return;
                }
                pucWalk = pucBuffer + nWalkCount;
            }

            /*
            // At this point, pucWalk points to the smallest ReportID in the
            //   buffer that is greater than the ReportID we want to insert.
            //   We need to bump all reportIDs beginning at pucWalk up one 
            //   spot and insert the new ReportID at pucWalk
            */

            memmove (pucWalk+1, pucWalk, (nFoundIDs - nWalkCount) * sizeof(UCHAR));
            *pucWalk = ucReportID;
            nFoundIDs++;
        }
    }

    *ppReportIDList = pucBuffer;
    *nReportIDs = nFoundIDs;
    
    return;
}

LRESULT CALLBACK
bSetUsagesDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) {
        case WM_INITDIALOG:
            
            pParams = (PECDISPLAY_PARAMS) lParam;

            SetDlgItemIntHex(hDlg, 
                             IDC_USAGE_PAGE, 
                             pParams -> UsagePage,
                             2
                            );

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_USAGE_LIST));

                    if (StringLength > 0) {
                        pParams -> szListString = (PCHAR) ALLOC(StringLength+1);
                        if (NULL == pParams -> szListString) {

                            MessageBox(hDlg, 
                                       "Error allocating memory",
                                       "HClient Error",
                                       MB_ICONEXCLAMATION
                                      );
                            RetValue = DLGBOX_ERROR;

                        }
                        else {

                            GetWindowText(GetDlgItem(hDlg, IDC_USAGE_LIST),
                                          pParams -> szListString,
                                          StringLength+1
                                         );
                            RetValue = DLGBOX_OK;
                        }
                    }
                    else {
                        pParams -> szListString = NULL;
                        RetValue = DLGBOX_CANCEL;
                    }

                    EndDialog(hDlg, RetValue);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, DLGBOX_CANCEL);
                    break;
            }
            break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bSetValueDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) {
        case WM_INITDIALOG:

            pParams = (PECDISPLAY_PARAMS) lParam;

            SetDlgItemIntHex(hDlg, 
                             IDC_USAGE_PAGE, 
                             pParams -> UsagePage,
                             sizeof(USAGE)
                            );

            SetDlgItemIntHex(hDlg,
                             IDC_USAGE,
                             pParams -> Usage,
                             sizeof(USAGE)
                            );

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_VALUE));

                    if (StringLength > 0) {
                        pParams -> szListString = (PCHAR) ALLOC(StringLength+1);
                        if (NULL == pParams -> szListString) {

                            MessageBox(hDlg, 
                                       "Error allocating memory",
                                       "HClient Error",
                                       MB_ICONEXCLAMATION
                                      );
                            RetValue = DLGBOX_ERROR;

                        }
                        else {

                            GetWindowText(GetDlgItem(hDlg, IDC_VALUE),
                                          pParams -> szListString,
                                          StringLength+1
                                         );
                            RetValue = DLGBOX_OK;
                        }
                    }
                    else {
                        pParams -> szListString = NULL;
                        RetValue = DLGBOX_CANCEL;
                    }

                    EndDialog(hDlg, RetValue);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, DLGBOX_CANCEL);
                    break;
            }
            break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bSetInputBuffDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) {
        case WM_INITDIALOG:
            pParams = (PECDISPLAY_PARAMS) lParam;
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_INPUT_BUFFERS));

                    if (StringLength > 0) {
                        pParams -> szListString = (PCHAR) ALLOC(StringLength+1);
                        if (NULL == pParams -> szListString) {

                            MessageBox(hDlg, 
                                       "Error allocating memory",
                                       "HClient Error",
                                       MB_ICONEXCLAMATION
                                      );
                            RetValue = DLGBOX_ERROR;

                        }
                        else {

                            GetWindowText(GetDlgItem(hDlg, IDC_INPUT_BUFFERS),
                                          pParams -> szListString,
                                          StringLength+1
                                         );
                            RetValue = DLGBOX_OK;
                        }
                    }
                    else {
                        pParams -> szListString = NULL;
                        RetValue = DLGBOX_CANCEL;
                    }

                    EndDialog(hDlg, RetValue);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, DLGBOX_CANCEL);
                    break;
            }
            break;
    }
    return (FALSE);
}


LRESULT CALLBACK
bSetDataDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static CHAR               DataString[1024];
    static PECDISPLAY_PARAMS  pParams;
           UINT               IndexValue;
           ULONG              Value;
           BOOL               lpTranslated;
           DLGBOX_STATUS      RetValue;
           PCHAR              endp;
           INT                ListBoxStatus;
           PHIDP_DATA         DataList;
           PHIDP_DATA         CurrData;
           ULONG              DataListLength;
           ULONG              Index;

    switch (message) {
        case WM_INITDIALOG:

            pParams = (PECDISPLAY_PARAMS) lParam;
            SendMessage(GetDlgItem(hDlg, IDC_VALUE),
                        EM_SETLIMITTEXT,
                        (WPARAM) 1024,
                        0
                       );
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_ADD_DATA:
                    IndexValue = GetDlgItemInt(hDlg,
                                               IDC_INDEX,
                                               &lpTranslated,
                                               FALSE
                                              );
                    if (!lpTranslated) {
                        MessageBox(hDlg,
                                   "Invalid index value: must be unsigned integer",
                                   "HClient Error",
                                   MB_ICONEXCLAMATION
                                  );
                        break;
                    }
                    
                    if (0 == GetWindowText(GetDlgItem(hDlg, IDC_VALUE), 
                                           DataString,
                                           1023
                                          )) {
                        MessageBox(hDlg,
                                   "Invalid data value",
                                   "HClient Error",
                                   MB_ICONEXCLAMATION
                                  );

                        break;
                    }

                    CharUpperBuff(DataString, lstrlen(DataString));

                    if (0 == lstrcmp(DataString, "TRUE")) {
                        Value = 1;
                    }
                    else if (0 == lstrcmp(DataString, "FALSE")) {
                        Value = 0;
                    }
                    else {
                        Value = strtoul(DataString, &endp, 10);
                        if (*endp != '\0') {
                            MessageBox(hDlg,
                                       "Invalid data value",
                                       "HClient Error",
                                       MB_ICONEXCLAMATION
                                      );
                            break;
                        }
                    }
                    wsprintf(DataString, 
                             SETDATA_LISTBOX_FORMAT, 
                             IndexValue,
                             Value
                            );

                    ListBoxStatus = SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                                LB_ADDSTRING,
                                                0,
                                                (LPARAM) DataString
                                               );
                    if (CB_ERR == ListBoxStatus || CB_ERRSPACE == ListBoxStatus) {
                        MessageBox(hDlg,
                                   "Error adding string to data list",
                                   "HClient Error",
                                   MB_ICONEXCLAMATION
                                  );
                        break;
                    }
                    break;

                case IDC_REMOVE_DATA:
                    SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                LB_DELETESTRING,
                                SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                            LB_GETCURSEL,
                                            0,
                                            0
                                           ),
                                0
                               );
                    break;

                case IDOK:
                    DataListLength = SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                                 LB_GETCOUNT,
                                                 0,
                                                 0
                                                );
                    if (0 != DataListLength) {
                        DataList = ALLOC(DataListLength * sizeof(HIDP_DATA));
                        if (NULL == DataList) {
                            MessageBox(hDlg,
                                       "Error allocating memory",
                                       "HClient Error",
                                       MB_ICONEXCLAMATION
                                      );

                            DataListLength = 0;
                            RetValue = DLGBOX_CANCEL;
                            break;
                        }
                        
                        for (Index = 0, CurrData = DataList; Index < DataListLength; Index++, CurrData++) {
                            SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                        LB_GETTEXT,
                                        Index,
                                        (LPARAM) DataString
                                       );

                            sscanf(DataString, 
                                   SETDATA_LISTBOX_FORMAT,
                                   &IndexValue,
                                   &Value
                                  );

                            CurrData -> DataIndex = (USHORT) IndexValue;
                            CurrData -> RawValue = Value;
                        }
                        RetValue = DLGBOX_OK;
                    }
                    else {
                        DataList = NULL;
                        RetValue = DLGBOX_CANCEL;
                    }

                    pParams -> pDataList = DataList;
                    pParams -> ListLength = DataListLength;
                    EndDialog(hDlg, RetValue);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, DLGBOX_CANCEL);
                    break;
            }
            break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bSetBufLenDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) {
        case WM_INITDIALOG:

            pParams = (PECDISPLAY_PARAMS) lParam;
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_BUFFER_LENGTH));

                    if (StringLength > 0) {
                        pParams -> szListString = (PCHAR) ALLOC(StringLength+1);
                        if (NULL == pParams -> szListString) {

                            MessageBox(hDlg, 
                                       "Error allocating memory",
                                       "HClient Error",
                                       MB_ICONEXCLAMATION
                                      );
                            RetValue = DLGBOX_ERROR;

                        }
                        else {

                            GetWindowText(GetDlgItem(hDlg, IDC_BUFFER_LENGTH),
                                          pParams -> szListString,
                                          StringLength+1
                                         );
                            RetValue = DLGBOX_OK;
                        }
                    }
                    else {
                        pParams -> szListString = NULL;
                        RetValue = DLGBOX_CANCEL;
                    }

                    EndDialog(hDlg, RetValue);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, DLGBOX_CANCEL);
                    break;
            }
            break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bSetInputBuffersDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) {
        case WM_INITDIALOG:

            pParams = (PECDISPLAY_PARAMS) lParam;
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_INPUT_BUFFERS));

                    if (StringLength > 0) {
                        pParams -> szListString = (PCHAR) ALLOC(StringLength+1);
                        if (NULL == pParams -> szListString) {

                            MessageBox(hDlg, 
                                       "Error allocating memory",
                                       "HClient Error",
                                       MB_ICONEXCLAMATION
                                      );
                            RetValue = DLGBOX_ERROR;

                        }
                        else {

                            GetWindowText(GetDlgItem(hDlg, IDC_INPUT_BUFFERS),
                                          pParams -> szListString,
                                          StringLength+1
                                         );
                            RetValue = DLGBOX_OK;
                        }
                    }
                    else {
                        pParams -> szListString = NULL;
                        RetValue = DLGBOX_CANCEL;
                    }

                    EndDialog(hDlg, RetValue);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, DLGBOX_CANCEL);
                    break;
            }
            break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bGetIndexedDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           INT                StringLength2;
           DLGBOX_STATUS      RetValue;

    switch (message) {
        case WM_INITDIALOG:

            pParams = (PECDISPLAY_PARAMS) lParam;
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:       
                    StringLength  = GetWindowTextLength(GetDlgItem(hDlg, IDC_STRING_INDEX));
                    StringLength2 = GetWindowTextLength(GetDlgItem(hDlg, IDC_BUFFER_LENGTH));

                    if (StringLength <= 0 || StringLength2 <= 0) {
                        pParams -> szListString = NULL;
                        pParams -> szListString2 = NULL;
                        RetValue = DLGBOX_CANCEL;
                        EndDialog(hDlg, DLGBOX_CANCEL);
                    }

                    pParams -> szListString = (PCHAR) ALLOC(StringLength+1);
                    pParams -> szListString2 = (PCHAR) ALLOC(StringLength2+1);

                    if (NULL == pParams -> szListString || NULL == pParams -> szListString2) {

            
                           MessageBox(hDlg, 
                                     "Error allocating memory",
                                      "HClient Error",
                                       MB_ICONEXCLAMATION
                                      );

                           if (NULL != pParams -> szListString) 
                               FREE(pParams -> szListString);

                           if (NULL != pParams -> szListString2) 
                               FREE(pParams -> szListString2);

                           RetValue = DLGBOX_ERROR;

                    }
                    else {

                        GetWindowText(GetDlgItem(hDlg, IDC_STRING_INDEX),
                                      pParams -> szListString,
                                      StringLength+1
                                     );

                        GetWindowText(GetDlgItem(hDlg, IDC_BUFFER_LENGTH),
                                      pParams -> szListString2,
                                      StringLength2+1
                                     );

                        RetValue = DLGBOX_OK;
                    }
                    EndDialog(hDlg, RetValue);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, DLGBOX_CANCEL);
                    break;
            }
            break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bGetUsageDiffDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           INT                StringLength2;
           DLGBOX_STATUS      RetValue;

    switch (message) {
        case WM_INITDIALOG:

            pParams = (PECDISPLAY_PARAMS) lParam;
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:       
                    StringLength  = GetWindowTextLength(GetDlgItem(hDlg, IDC_USAGE_LIST1));
                    StringLength2 = GetWindowTextLength(GetDlgItem(hDlg, IDC_USAGE_LIST2));

                    if (StringLength <= 0) {
                        pParams -> szListString = NULL;
                    }
                    else {
                        pParams -> szListString = (PCHAR) ALLOC(StringLength+1);
                        if (NULL == pParams -> szListString) {
                            ECDISP_ERROR(hDlg,
                                         "Error allocating memory"
                                        );
                            EndDialog(hDlg, DLGBOX_ERROR);
                        }
                    }

                    if (StringLength2 <= 0) {
                        pParams -> szListString = NULL;
                    }
                    else {
                        pParams -> szListString2 = (PCHAR) ALLOC(StringLength2+1);
                        if (NULL == pParams -> szListString2) {
                            ECDISP_ERROR(hDlg,
                                         "Error allocating memory"
                                        );
                            if (NULL != pParams -> szListString) {
                                FREE(pParams -> szListString);
                            }
                            EndDialog(hDlg, DLGBOX_ERROR);
                        }
                    }

                    GetWindowText(GetDlgItem(hDlg, IDC_USAGE_LIST1),
                                  pParams -> szListString,
                                  StringLength+1
                                 );

                    GetWindowText(GetDlgItem(hDlg, IDC_USAGE_LIST2),
                                  pParams -> szListString2,
                                  StringLength2+1
                                 );

                    RetValue = DLGBOX_OK;

                    EndDialog(hDlg, RetValue);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, DLGBOX_CANCEL);
                    break;
            }
            break;
    }
    return (FALSE);
}


BOOL
ConvertStringToUsageList(
    IN OUT PCHAR   InString,
    OUT    PUSAGE  *UsageList,
    OUT    PULONG  nUsages
)
/*++
RoutineDescription:
    This routine converts a string of values into a string of usages which are
    currently 2 byte values.  We use base 16 to specify that the usages should 
    be expressed as hexidecimal numbers.
--*/
{
    return (Strings_StringToUnsignedList(InString,
                                         sizeof(ULONG),
                                         10,
                                         (PCHAR *) UsageList,
                                         nUsages
                                        ));
}

BOOL
ConvertStringToUlongList(
    IN OUT PCHAR   InString,
    OUT    PULONG  *UlongList,
    OUT    PULONG  nUlongs
)
/*++
RoutineDescription
    This routine converts a string of values into a string of ulongs which are
    currently 2 byte values.  It requires that the numbers in the string be in
    base 10
--*/
{
    return (Strings_StringToUnsignedList(InString,
                                         sizeof(ULONG),
                                         10,
                                         (PCHAR *) UlongList,
                                         nUlongs
                                        ));
}

BOOL
SetDlgItemIntHex(
   HWND hDlg, 
   INT nIDDlgItem, 
   UINT uValue, 
   INT nBytes
)
{
    char szTempBuffer[] = "0x00000000";
    int  iEndIndex, iWidth;

    assert (1 == nBytes || 2 == nBytes || 4 == nBytes);

    /*
    // Determine the width necessary to store the value
    */

    iWidth = ((int) floor(log(uValue)/log(16))) + 1;
    
    assert (iWidth <= 2*nBytes);

    iEndIndex = 2+2*nBytes;

    wsprintf(&(szTempBuffer[iEndIndex-iWidth]), "%X", uValue);

    SetDlgItemText(hDlg, nIDDlgItem, szTempBuffer);
    return (TRUE);
}

VOID
ECDisp_MakeGUIDString(
    IN  GUID guid, 
    OUT CHAR szString[]
)
{
    char szCharString[18];
    int i;

    for (i = 0; i < 8; i++)
        wsprintf(&(szCharString[i]), "%x", guid.Data4[i]);
        
    wsprintf(szString, "%x-%x%x-%s", guid.Data1, guid.Data2, guid.Data3, szCharString);
    return;
}

PCHAR
ECDisp_GetHidAppStatusString(
    NTSTATUS StatusCode
)
{
    switch (StatusCode) {
        case HIDP_STATUS_SUCCESS:
            return ("Success");


        case HIDP_STATUS_NULL:
            return ("Status NULL");

        case HIDP_STATUS_INVALID_PREPARSED_DATA:
            return ("Invalid Preparsed Data");

        case HIDP_STATUS_INVALID_REPORT_TYPE:
            return ("Invalid Report Type");

        case HIDP_STATUS_INVALID_REPORT_LENGTH:
            return ("Invalid Report Length");

        case HIDP_STATUS_USAGE_NOT_FOUND:
            return ("Usage not found");

        case HIDP_STATUS_VALUE_OUT_OF_RANGE:
            return ("Value out of range");

        case HIDP_STATUS_BAD_LOG_PHY_VALUES:
            return ("Bad logical physical values");

        case HIDP_STATUS_BUFFER_TOO_SMALL:
            return ("Buffer too small");

        case HIDP_STATUS_INTERNAL_ERROR:
            return ("Internal error");

        case HIDP_STATUS_I8242_TRANS_UNKNOWN:
            return ("I8242 Translation unknown");

        case HIDP_STATUS_INCOMPATIBLE_REPORT_ID:
            return ("Incompatible report ID");

        case HIDP_STATUS_NOT_VALUE_ARRAY:
            return ("Not value array");

        case HIDP_STATUS_IS_VALUE_ARRAY:
            return ("Is value array");

        case HIDP_STATUS_DATA_INDEX_NOT_FOUND:   
            return ("Data index not found");

        case HIDP_STATUS_DATA_INDEX_OUT_OF_RANGE:
            return ("Data index out of range");

        case HIDP_STATUS_BUTTON_NOT_PRESSED:     
            return ("Button not pressed");

        case HIDP_STATUS_REPORT_DOES_NOT_EXIST:
            return ("Report does not exist");

        case HIDP_STATUS_NOT_IMPLEMENTED:        
            return ("Not implemented");

        default:
            return ("Unknown HID Status error");
    }
}             

BOOL
ECDisp_ConvertUlongListToValueList(
    IN  PULONG  UlongList,
    IN  ULONG   nUlongs,
    IN  USHORT  BitSize,
    IN  USHORT  ReportCount,
    OUT PCHAR   *ValueList,
    OUT PULONG  ValueListSize
)
/*++
RoutineDescription:
    This routine takes a list of ULong values and formats a value list that is 
    used as input to HidP_SetUsageValueArray.  Unfortunately, this HidP function
    requires the caller to format the input buffer which means taking each of
    the values in Ulong, truncating their values to meet bit size and then set 
    those bits at the appropriate spot in the buffer.  That is the purpose of
    this function

    The function will return TRUE if everything succeeded, FALSE otherwise.
--*/
{

    ULONG       ulMask;
    PCHAR       List;
    INT         iByteIndex;
    INT         iByteOffset;
    ULONG       UlongIndex;
    ULONG       ListSize;
    USHORT      BitsToAdd;
    USHORT      nBits;
    ULONG       ulValue;
    UCHAR       LowByte;

    /*
    // Allocate our buffer for the value list and return FALSE if it couldn't
    //   be done
    */

    ListSize = ROUND_TO_NEAREST_BYTE(BitSize * ReportCount);
    List = (PCHAR) malloc(ListSize);

    if (NULL == List) {
        *ValueList = NULL;
        *ValueListSize = 0;
        return (FALSE);
    }

    /*
    // Initialize the buffer to all zeroes
    */

    memset(List, 0x00, ListSize);

    /*
    // Buffer has been allocated let's convert those values
    */

    /*
    // Determine the mask that will be used to retrieve the cared about bits
    //   of our value
    */

    ulMask = (sizeof(ULONG)*8 == BitSize) ? ULONG_MAX : (1 << BitSize)-1;

    /*
    // Initialize the iByteIndex and iByteOffset fields before entering the
    //    conversion loop.
    */

    iByteIndex = 0;
    iByteOffset = 0;

    /*
    // This is the main conversion loop.  It performs the following steps on
    //    each Ulong in the ulong list
    //      1) Sets BitsToAdd = BitSize
    //      2) Gets the ulValue and the masks off the upper bits that we don't
    //           care about.
    //      3) Determines how many bits can fit at the current byte index based
    //          on the current byte offset and the number of bits left to add
    //      4) Retrieve those bits, shift them to the correct position and 
    //            use bitwise or to get the correct values in the buffer
    //      5) Increment the byte index and set our new byte offset
    //      6) Shift our Ulong value right to get rid of least significant bits
    //           that have already been added
    //      7) Repeat through step 3 until no more bits to add
    */

    for (UlongIndex = 0; UlongIndex < nUlongs; UlongIndex++) {
        
        BitsToAdd = BitSize;

        ulValue = *(UlongList + UlongIndex) & ulMask;

        while (BitsToAdd > 0) {
            nBits = MIN (8 - iByteOffset, BitsToAdd);
            
            LowByte = (UCHAR) (ulValue & 0xFF);
            
            LowByte = LowByte << iByteOffset;

            *(List+iByteIndex) |= LowByte;

            iByteIndex = (iByteOffset+nBits) >= 8 ? iByteIndex+1 : iByteIndex;
            iByteOffset = (iByteOffset + nBits) % 8;

            BitsToAdd -= nBits;

            ulValue = ulValue >> nBits;

        }
    }
        
    *ValueList = List;
    *ValueListSize = ListSize;

    return (TRUE);
}

PCHAR
ResolveFunctionName(
    INT Index
)
{
    PCHAR   FuncName;

    if (IS_HIDD_FUNCTION(Index) || IS_HID_FUNCTION(Index)) {
        FuncName = DeviceCalls[Index-1].szFunctionName;
    }
    else {
        FuncName = PpdCalls[Index-HID_DEVCALLS-1].szFunctionName;
    }

    return (FuncName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\extcalls.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    extcalls.c

Abstract:

    This module contains the function definitions for the extended call 
    functions that are available.  See comment below for further explanation
    of the purpose of these functions.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

/*
// This file contains code used for executing different HID.DLL functions.  It
//   is a debug only mechanism which uses the DEBUG memory allocation/verification
//   routines in debug.c.  
//
// These functions begin by allocating debug buffers for any input or output buffers
//    that are passed to the corresponding HID.DLL functions.  It then calls the
//    the HidX_Xxx function.  Upon return, it validates any of the report buffers
//    that were setup by before the call and copies the results back to the 
//    buffers if necessary.  The functions also attempt to detect any other errors
//    that may be specific to the given HID.DLL function.  
//
// When examining this implementation along with the routines that use these calls 
//    in the Hclient, it is obvious that sometimes debug buffers are allocated more
//    than once.  This can lead to some confusion as to why this occurs.  The original
//    goal of these ExtCall_ routines was to be able to extract them for debug versions
//    of other client code.  The redundancy in buffer validation is not necessary but
//    does provide another layer of protection.
*/

#ifndef DEBUG
   #define DEBUG
#endif

/*****************************************************************************
/* ExtCalls include files
/*****************************************************************************/
#include <windows.h>
#include <string.h>
#include <limits.h>
#include <setupapi.h>
#include <assert.h>
#include "hid.h"
#include "hidsdi.h"
#include "extcalls.h"
#include "debug.h"


/*****************************************************************************
/* ExtCalls macro definitions for misc. features
/*****************************************************************************/
#define OUTSTRING(win, str)         SendMessage(win, LB_ADDSTRING, 0, (LPARAM) str)
#define STATUS_STRING(str, status)  wsprintf(str, "Status: %s", ExtCalls_GetHidAppStatusString(status))
#define ROUND_TO_NEAREST_BYTE(val)  (((val) % 8) ? ((val) / 8) + 1 : ((val) / 8))

/*****************************************************************************
/* ExtCalls macro definitions setting up and validating buffers
/*****************************************************************************/
#define SETUP_INPUT_BUFFER(tbuf, rbuf, len, funcname, status) \
       { \
            (PCHAR) (tbuf) = (PCHAR) ALLOC((len)); \
            if (NULL == (tbuf)) { \
                wsprintf(szTempBuffer, \
                         "EXTCALLS.C: Memory alloc error - cannot verify %s call", \
                         (funcname) \
                        ); \
                DEBUG_OUT(szTempBuffer); \
                (PCHAR) (tbuf) = (PCHAR) (rbuf); \
           } \
           status = TRUE; \
       }

#define SETUP_OUTPUT_BUFFER(tbuf, rbuf, len, funcname, status) \
       { \
            (PCHAR) (tbuf) = (PCHAR) ALLOC((len)); \
            if (NULL == (tbuf)) { \
                wsprintf(szTempBuffer, \
                         "EXTCALLS.C: Memory alloc error - cannot verify %s call", \
                         (funcname) \
                        ); \
                DEBUG_OUT(szTempBuffer); \
                (PCHAR) (tbuf) = (PCHAR) (rbuf); \
            } \
            else { \
                memcpy((tbuf), (rbuf), (len)); \
            } \
            status = TRUE; \
       }
         
#define VERIFY_INPUT_BUFFER(tbuf, rbuf, len, status) \
       { \
           if ((PCHAR) (tbuf) != (PCHAR) (rbuf)) { \
               status = (status) && (VALIDATEMEM((tbuf))); \
               memcpy((rbuf), (tbuf), (len));  \
               FREE((tbuf)); \
           } \
       } 

#define VERIFY_OUTPUT_BUFFER(tbuf, rbuf, len, status) \
       { \
           if ((PCHAR) (tbuf) != (PCHAR) (rbuf)) { \
               status = (status) && (VALIDATEMEM((tbuf))); \
               FREE((tbuf)); \
           } \
       } 


/*****************************************************************************
/* ExtCalls macro definitions for setting up the status structures
/*****************************************************************************/
#define SET_HIDD_STATUS(pStatusStruct, IsError, AllocStatus) \
       { \
           pStatusStruct -> IsHidError      = IsError; \
           pStatusStruct -> IsHidDbgWarning = FALSE; \
           pStatusStruct -> IsHidDbgError   = !AllocStatus; \
         \
           if (!AllocStatus) { \
               pStatus -> HidDbgErrorCode = HID_DBG_ERROR_CORRUPTED_BUFFER; \
           } \
      }
       
#define SET_HIDP_STATUS(pStatusStruct, CallStatus, AllocStatus) \
       { \
           pStatusStruct -> IsHidError = (HIDP_STATUS_SUCCESS != CallStatus); \
           pStatusStruct -> HidErrorCode = CallStatus; \
         \
           pStatusStruct -> IsHidDbgError   = !AllocStatus; \
         \
           if (!AllocStatus) { \
               pStatus -> HidDbgErrorCode = HID_DBG_ERROR_CORRUPTED_BUFFER; \
           } \
           pStatusStruct -> IsHidDbgWarning = FALSE; \
      }
            

#define TEMP_BUFFER_SIZE 1024

static CHAR             szTempBuffer[TEMP_BUFFER_SIZE];

VOID 
ExtCalls_HidD_FlushQueue(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    pStatus -> IsHidError      = !HidD_FlushQueue(pParams -> DeviceHandle);
    pStatus -> IsHidDbgError   = FALSE;
    pStatus -> IsHidDbgWarning = FALSE;

    return;
}

VOID
ExtCalls_HidD_GetHidGuid(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    LPGUID  pGuid;
    BOOL    AllocStatus;

    SETUP_INPUT_BUFFER(pGuid,
                       pParams -> List,
                       sizeof(GUID),
                       "HidD_GetHidGuid",
                       AllocStatus
                      );
                       
    HidD_GetHidGuid(pGuid);

    VERIFY_INPUT_BUFFER(pGuid,
                        pParams -> List,
                        sizeof(GUID),
                        AllocStatus
                       );
    
    SET_HIDD_STATUS(pStatus, 
                    FALSE,
                    AllocStatus
                   );

    return;
}
    
VOID
ExtCalls_HidD_GetPreparsedData(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    BOOL                       IsHidError;

    IsHidError = !HidD_GetPreparsedData(pParams -> DeviceHandle,
                                        pParams -> ppPd                  
                                       );

    SET_HIDD_STATUS(pStatus,
                    IsHidError,
                    TRUE
                   );
    return;
}

VOID
ExtCalls_HidD_FreePreparsedData(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    BOOL                       IsHidError;

    ASSERT(NULL != pParams -> Ppd);
    
    IsHidError = !HidD_FreePreparsedData(pParams -> Ppd);

    SET_HIDD_STATUS(pStatus,
                    IsHidError,
                    TRUE
                   );

    return;
}

VOID
ExtCalls_HidD_GetAttributes(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    BOOL             IsHidError;
    BOOL             AllocStatus;
    PCHAR            pHidAttrib;   

    SETUP_INPUT_BUFFER(pHidAttrib, 
                       pParams -> List,
                       sizeof(HIDD_ATTRIBUTES),
                       "HidD_GetAttributes",
                       AllocStatus
                      );

    IsHidError = !HidD_GetAttributes(pParams -> DeviceHandle,
                                     (PHIDD_ATTRIBUTES) pHidAttrib
                                    );

    VERIFY_INPUT_BUFFER(pHidAttrib,
                        pParams -> List,
                        sizeof(HIDD_ATTRIBUTES),
                        AllocStatus
                       );

    SET_HIDD_STATUS(pStatus,
                    IsHidError,
                    AllocStatus
                   );
    return;
}

VOID
ExtCalls_HidD_GetFeature(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    BOOL   IsHidError;
    PCHAR  TestBuffer;
    BOOL   AllocStatus;

    SETUP_OUTPUT_BUFFER(TestBuffer,
                       pParams -> ReportBuffer, 
                       pParams -> ReportLength,
                       "HidD_GetFeature",
                       AllocStatus
                      );

    IsHidError = !HidD_GetFeature(pParams -> DeviceHandle,
                                  TestBuffer,
                                  pParams -> ReportLength
                                 );

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> ReportBuffer, 
                        pParams -> ReportLength,
                        AllocStatus
                       );

    SET_HIDD_STATUS(pStatus,
                    IsHidError,
                    AllocStatus
                   );
    return;
}

VOID
ExtCalls_HidD_SetFeature(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    BOOL   IsHidError;
    PCHAR  TestBuffer;
    BOOL   AllocStatus;

    SETUP_OUTPUT_BUFFER(TestBuffer,
                        pParams -> ReportBuffer, 
                        pParams -> ReportLength,
                        "HidD_SetFeature",
                        AllocStatus
                       );

    IsHidError = !HidD_SetFeature(pParams -> DeviceHandle,
                                  TestBuffer,
                                  pParams -> ReportLength
                                 );

    VERIFY_OUTPUT_BUFFER(TestBuffer,
                         pParams -> ReportBuffer, 
                         pParams -> ReportLength,
                         AllocStatus
                        );

    SET_HIDD_STATUS(pStatus,
                    IsHidError,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidD_GetNumInputBuffers(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    BOOL     IsHidError;

    IsHidError = !HidD_GetNumInputBuffers(pParams -> DeviceHandle,
                                          &pParams -> Value
                                         );
    SET_HIDD_STATUS(pStatus,
                    IsHidError,
                    TRUE
                   );
    return;
}

VOID
ExtCalls_HidD_SetNumInputBuffers(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    BOOL     IsHidError;

    IsHidError = !HidD_SetNumInputBuffers(pParams -> DeviceHandle,
                                          pParams -> Value
                                         );
    SET_HIDD_STATUS(pStatus,
                    IsHidError,
                    TRUE
                   );
    return;
}

VOID
ExtCalls_HidD_GetPhysicalDescriptor(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    BOOL    IsHidError;
    BOOL    AllocStatus;
    PCHAR   TestDataBuffer;

    SETUP_INPUT_BUFFER(TestDataBuffer,
                       pParams -> List,
                       pParams -> ListLength,
                       "HidD_GetPhysicalDescriptor",
                       AllocStatus
                      );

    IsHidError = !HidD_GetPhysicalDescriptor(pParams -> DeviceHandle,
                                             TestDataBuffer,
                                             pParams -> ListLength
                                            );

    VERIFY_INPUT_BUFFER(TestDataBuffer,
                        pParams -> List,
                        pParams -> ListLength,
                        AllocStatus
                       );

    SET_HIDD_STATUS(pStatus,
                    IsHidError,
                    AllocStatus
                   );

    return;
}


VOID
ExtCalls_HidD_GetManufacturerString(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    BOOL    IsHidError;
    BOOL    AllocStatus;
    PCHAR   TestDataBuffer;

    SETUP_INPUT_BUFFER(TestDataBuffer,
                       pParams -> List,
                       pParams -> ListLength,
                       "HidD_GetManufacturerString",
                       AllocStatus
                      );

    IsHidError = !HidD_GetManufacturerString(pParams -> DeviceHandle,
                                             TestDataBuffer,
                                             pParams -> ListLength
                                            );

    VERIFY_INPUT_BUFFER(TestDataBuffer,
                        pParams -> List,
                        pParams -> ListLength,
                        AllocStatus
                       );

    SET_HIDD_STATUS(pStatus,
                    IsHidError,
                    AllocStatus
                   );

    return;
}


VOID
ExtCalls_HidD_GetProductString(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    BOOL    IsHidError;
    BOOL    AllocStatus;
    PCHAR   TestDataBuffer;

    SETUP_INPUT_BUFFER(TestDataBuffer,
                       pParams -> List,
                       pParams -> ListLength,
                       "HidD_GetProductString",
                       AllocStatus
                      );

    IsHidError = !HidD_GetProductString(pParams -> DeviceHandle,
                                        TestDataBuffer,
                                        pParams -> ListLength
                                       );

    VERIFY_INPUT_BUFFER(TestDataBuffer,
                        pParams -> List,
                        pParams -> ListLength,
                        AllocStatus
                       );

    SET_HIDD_STATUS(pStatus,
                    IsHidError,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidD_GetIndexedString(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    BOOL    IsHidError;
    BOOL    AllocStatus;
    PCHAR   TestDataBuffer;

    SETUP_INPUT_BUFFER(TestDataBuffer,
                       pParams -> List,
                       pParams -> ListLength,
                       "HidD_GetIndexString",
                       AllocStatus
                      );

    IsHidError = !HidD_GetIndexedString(pParams -> DeviceHandle,
                                        pParams -> StringIndex,
                                        TestDataBuffer,
                                        pParams -> ListLength
                                       );

    VERIFY_INPUT_BUFFER(TestDataBuffer,
                        pParams -> List,
                        pParams -> ListLength,
                        AllocStatus
                       );

    SET_HIDD_STATUS(pStatus,
                    IsHidError,
                    AllocStatus
                   );

    return;
}


VOID
ExtCalls_HidD_GetSerialNumberString(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    BOOL    IsHidError;
    BOOL    AllocStatus;
    PCHAR   TestDataBuffer;

    SETUP_INPUT_BUFFER(TestDataBuffer,
                       pParams -> List,
                       pParams -> ListLength,
                       "HidD_GetSerialNumberString",
                       AllocStatus
                      );

    IsHidError = !HidD_GetSerialNumberString(pParams -> DeviceHandle,
                                                   TestDataBuffer,
                                                   pParams -> ListLength
                                                  );

    VERIFY_INPUT_BUFFER(TestDataBuffer,
                        pParams -> List,
                        pParams -> ListLength,
                        AllocStatus
                       );

    SET_HIDD_STATUS(pStatus,
                    IsHidError,
                    AllocStatus
                   );

    return;
}


VOID
ExtCalls_HidP_GetButtonCaps(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PHIDP_BUTTON_CAPS pTestButtonCaps;
    NTSTATUS          Status;
    BOOL              AllocStatus;
    ULONG             Caps;

    Caps = pParams -> ListLength;

    SETUP_INPUT_BUFFER(pTestButtonCaps,
                       pParams -> List,
                       Caps * sizeof(HIDP_BUTTON_CAPS),
                       "HidP_GetButtonCaps",
                       AllocStatus
                      );

    Status = HidP_GetButtonCaps(pParams -> ReportType,
                                pTestButtonCaps,
                                (PUSHORT) &pParams -> ListLength,
                                pParams -> Ppd,
                               );

    VERIFY_INPUT_BUFFER(pTestButtonCaps,
                        pParams -> List,
                        Caps * sizeof(HIDP_BUTTON_CAPS),
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    Status,
                    AllocStatus
                   );
    return;
}

VOID
ExtCalls_HidP_GetButtons(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    NTSTATUS   status;
    PUSAGE     TestBuffer;
    ULONG      UsageLength;
    BOOL       AllocStatus;

    UsageLength = pParams -> ListLength;
    SETUP_INPUT_BUFFER(TestBuffer,
                       pParams -> List,
                       UsageLength * sizeof(USAGE),
                       "HidP_GetButtons",
                       AllocStatus
                      );

    status = HidP_GetButtons(pParams -> ReportType,
                             pParams -> UsagePage,
                             pParams -> LinkCollection,
                             TestBuffer,
                             &pParams -> ListLength,
                             pParams -> Ppd,
                             pParams -> ReportBuffer,
                             pParams -> ReportLength
                            );

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> List,
                        UsageLength * sizeof(USAGE),
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidP_GetButtonsEx(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PUSAGE_AND_PAGE TestBuffer;
    NTSTATUS        status;
    ULONG           UsageLength;
    BOOL            AllocStatus;

    UsageLength = pParams -> ListLength;
    SETUP_INPUT_BUFFER(TestBuffer,
                       pParams -> List,
                       UsageLength * sizeof(USAGE_AND_PAGE),
                       "HidP_GetButtonsEx",
                       AllocStatus
                      );

    status = HidP_GetButtonsEx(pParams -> ReportType,
                               pParams -> LinkCollection,
                               TestBuffer,
                               &pParams -> ListLength,
                               pParams -> Ppd,
                               pParams -> ReportBuffer,
                               pParams -> ReportLength
                              );

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> List,
                        UsageLength * sizeof(USAGE_AND_PAGE),
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidP_GetData(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PHIDP_DATA      TestBuffer;
    NTSTATUS        status;
    ULONG           DataLength;
    BOOL       AllocStatus;

    DataLength = pParams -> ListLength;
    SETUP_INPUT_BUFFER(TestBuffer,
                       pParams -> List,
                       DataLength * sizeof(HIDP_DATA),
                      "HidP_GetData",
                       AllocStatus
                      );

    status = HidP_GetData(pParams -> ReportType,
                          TestBuffer,
                          &pParams -> ListLength,
                          pParams -> Ppd,
                          pParams -> ReportBuffer,
                          pParams -> ReportLength
                         );

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> List,
                        DataLength * sizeof(HIDP_DATA),
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidP_GetCaps(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PHIDP_CAPS TestBuffer;
    NTSTATUS   status;
    BOOL       AllocStatus;
    
    SETUP_INPUT_BUFFER(TestBuffer,
                       pParams -> List,
                       sizeof(HIDP_CAPS),
                       "HidP_GetCaps",
                       AllocStatus
                      );

    status = HidP_GetCaps(pParams -> Ppd, TestBuffer);

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> List,
                        sizeof(HIDP_CAPS),
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidP_MaxDataListLength(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
) 
{
    pParams -> Value  = HidP_MaxDataListLength(pParams -> ReportType,
                                               pParams -> Ppd
                                              );

    pStatus -> IsHidError      = FALSE;
    pStatus -> IsHidDbgError   = FALSE;
    pStatus -> IsHidDbgWarning = FALSE;
    
    pStatus -> HidErrorCode = HIDP_STATUS_SUCCESS;
    return;
}

VOID
ExtCalls_HidP_MaxUsageListLength(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
) 
{
    pParams -> Value  = HidP_MaxUsageListLength(pParams -> ReportType,
                                                pParams -> UsagePage,
                                                pParams -> Ppd
                                               );

    pStatus -> IsHidError      = FALSE;
    pStatus -> IsHidDbgError   = FALSE;
    pStatus -> IsHidDbgWarning = FALSE;
    pStatus -> HidErrorCode    = HIDP_STATUS_SUCCESS;

    return;
}

VOID ExtCalls_HidP_GetSpecificButtonCaps(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    ULONG             Caps;
    PHIDP_BUTTON_CAPS TestBuffer;
    NTSTATUS          status;
    BOOL              AllocStatus;

    Caps = pParams -> ListLength;
    SETUP_INPUT_BUFFER(TestBuffer,
                       pParams -> List,
                       Caps * sizeof(HIDP_BUTTON_CAPS),
                       "HidP_GetSpecificButtonCaps",
                       AllocStatus
                      );

    status = HidP_GetSpecificButtonCaps(pParams -> ReportType,
                                        pParams -> UsagePage,
                                        pParams -> LinkCollection,
                                        pParams -> Usage,
                                        TestBuffer,
                                        (PUSHORT) &pParams -> ListLength,
                                        pParams -> Ppd
                                       );

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> List,
                        Caps * sizeof(HIDP_BUTTON_CAPS),
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );


    return;
}

VOID
ExtCalls_HidP_GetSpecificValueCaps(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    ULONG            Caps;
    PHIDP_VALUE_CAPS TestBuffer;
    NTSTATUS         status;
    BOOL             AllocStatus;

    Caps = pParams -> ListLength;
    SETUP_INPUT_BUFFER(TestBuffer,
                       pParams -> List,
                       Caps * sizeof(HIDP_VALUE_CAPS),
                       "HidP_GetSpecificValueCaps",
                       AllocStatus
                      );
               
    status = HidP_GetSpecificValueCaps(pParams -> ReportType,
                                       pParams -> UsagePage,
                                       pParams -> LinkCollection,
                                       pParams -> Usage,
                                       TestBuffer,
                                       (PUSHORT) &pParams -> ListLength,
                                       pParams -> Ppd
                                      );

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> List,
                        Caps * sizeof(HIDP_VALUE_CAPS),
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );
    return;
}    

PCHAR ExtCalls_GetHidAppStatusString(NTSTATUS StatusCode)
{
    switch (StatusCode) {
        case HIDP_STATUS_SUCCESS:
            return ("Success");


        case HIDP_STATUS_NULL:
            return ("Status NULL");

        case HIDP_STATUS_INVALID_PREPARSED_DATA:
            return ("Invalid Preparsed Data");

        case HIDP_STATUS_INVALID_REPORT_TYPE:
            return ("Invalid Report Type");

        case HIDP_STATUS_INVALID_REPORT_LENGTH:
            return ("Invalid Report Length");

        case HIDP_STATUS_USAGE_NOT_FOUND:
            return ("Usage not found");

        case HIDP_STATUS_VALUE_OUT_OF_RANGE:
            return ("Value out of range");

        case HIDP_STATUS_BAD_LOG_PHY_VALUES:
            return ("Bad logical physical values");

        case HIDP_STATUS_BUFFER_TOO_SMALL:
            return ("Buffer too small");

        case HIDP_STATUS_INTERNAL_ERROR:
            return ("Internal error");

        case HIDP_STATUS_I8242_TRANS_UNKNOWN:
            return ("I8242 Translation unknown");

        case HIDP_STATUS_INCOMPATIBLE_REPORT_ID:
            return ("Incompatible report ID");

        case HIDP_STATUS_NOT_VALUE_ARRAY:
            return ("Not value array");

        case HIDP_STATUS_IS_VALUE_ARRAY:
            return ("Is value array");

        case HIDP_STATUS_DATA_INDEX_NOT_FOUND:   
            return ("Data index not found");

        case HIDP_STATUS_DATA_INDEX_OUT_OF_RANGE:
            return ("Data index out of range");

        case HIDP_STATUS_BUTTON_NOT_PRESSED:     
            return ("Button not pressed");

        case HIDP_STATUS_NOT_IMPLEMENTED:        
            return ("Not implemented");

        default:
            return ("Unknown HID Status error");
    }
}             

VOID
ExtCalls_HidP_GetLinkCollectionNodes(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PHIDP_LINK_COLLECTION_NODE  TestBuffer;
    NTSTATUS                    status;
    ULONG                       LinkNodes;
    BOOL                        AllocStatus;

    LinkNodes = pParams -> ListLength;
    SETUP_INPUT_BUFFER(TestBuffer,
                       pParams -> List,
                       LinkNodes * sizeof(HIDP_LINK_COLLECTION_NODE),
                       "HidP_GetLinkCollectionNodes",
                       AllocStatus
                      );

    status = HidP_GetLinkCollectionNodes(TestBuffer,
                                         &pParams -> ListLength,
                                         pParams -> Ppd
                                        );

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> List,
                        LinkNodes * sizeof(HIDP_LINK_COLLECTION_NODE),
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidP_GetScaledUsageValue(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    NTSTATUS status;

    status = HidP_GetScaledUsageValue(pParams -> ReportType,
                                      pParams -> UsagePage,
                                      pParams -> LinkCollection,
                                      pParams -> Usage,
                                      &pParams -> ScaledValue,
                                      pParams -> Ppd,
                                      pParams -> ReportBuffer,
                                      pParams -> ReportLength
                                     );

    SET_HIDP_STATUS(pStatus,
                    status,
                    TRUE
                   );

    return;
}

VOID
ExtCalls_HidP_GetUsages(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PUSAGE     TestBuffer;
    ULONG      Usages;
    NTSTATUS   status;
    BOOL       AllocStatus;

    Usages = pParams -> ListLength;
    SETUP_INPUT_BUFFER(TestBuffer,
                       pParams -> List,
                       Usages * sizeof(USAGE),
                       "HidP_GetUsages",
                       AllocStatus
                      );

    status = HidP_GetUsages(pParams -> ReportType,
                            pParams -> UsagePage,
                            pParams -> LinkCollection,
                            TestBuffer,
                            &pParams -> ListLength,
                            pParams -> Ppd,
                            pParams -> ReportBuffer,
                            pParams -> ReportLength
                           );

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> List,
                        Usages * sizeof(USAGE),
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidP_GetUsagesEx(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PUSAGE_AND_PAGE TestBuffer;
    ULONG           Usages;
    NTSTATUS        status;
    BOOL            AllocStatus;


    Usages = pParams -> ListLength;
    SETUP_INPUT_BUFFER(TestBuffer,
                       pParams -> List,
                       Usages * sizeof(USAGE_AND_PAGE),
                       "HidP_GetUsagesEx",
                       AllocStatus
                      );

    status = HidP_GetUsagesEx(pParams -> ReportType,
                              pParams -> LinkCollection,
                              TestBuffer,
                              &pParams -> ListLength,
                              pParams -> Ppd,
                              pParams -> ReportBuffer,
                              pParams -> ReportLength
                             );

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> List,
                        Usages * sizeof(USAGE_AND_PAGE),
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidP_GetUsageValue(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    NTSTATUS status;
    PCHAR            TestBuffer;
    BOOL             AllocStatus;

    SETUP_INPUT_BUFFER(TestBuffer,
                       pParams -> List,
                       pParams -> ListLength,
                       "HidP_GetUsageValueArray",
                       AllocStatus
                      );

    status = HidP_GetUsageValue(pParams -> ReportType,
                                pParams -> UsagePage,
                                pParams -> LinkCollection,
                                pParams -> Usage,
                                &pParams -> Value,
                                pParams -> Ppd,
                                pParams -> ReportBuffer,
                                pParams -> ReportLength
                               );

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> List,
                        pParams -> ListLength,
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidP_GetUsageValueArray(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    NTSTATUS         status;
    PCHAR            TestBuffer;
    BOOL             AllocStatus;

    SETUP_INPUT_BUFFER(TestBuffer,
                       pParams -> List,
                       pParams -> ListLength,
                       "HidP_GetUsageValueArray",
                       AllocStatus
                      );

    status = HidP_GetUsageValueArray(pParams -> ReportType,
                                     pParams -> UsagePage,
                                     pParams -> LinkCollection,
                                     pParams -> Usage,
                                     TestBuffer,
                                     (USHORT) pParams -> ListLength,
                                     pParams -> Ppd,
                                     pParams -> ReportBuffer,
                                     pParams -> ReportLength
                                    );

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> List,
                        pParams -> ListLength,
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidP_GetValueCaps(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    ULONG               Caps;
    NTSTATUS            status;
    PHIDP_VALUE_CAPS    TestBuffer;
    BOOL                AllocStatus;

    Caps = pParams -> ListLength;
    SETUP_INPUT_BUFFER(TestBuffer,
                       pParams -> List,
                       Caps * sizeof(HIDP_VALUE_CAPS),
                       "HidP_GetValueCaps",
                       AllocStatus
                      );

    status = HidP_GetValueCaps(pParams -> ReportType,
                               TestBuffer,
                               (PUSHORT) &pParams -> ListLength,
                               pParams -> Ppd
                              );

    VERIFY_INPUT_BUFFER(TestBuffer,
                        pParams -> List,
                        Caps * sizeof(HIDP_VALUE_CAPS),
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;
}    

VOID
ExtCalls_HidP_SetButtons(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PUSAGE   TestDataBuffer;
    PCHAR    TestReportBuffer;
    ULONG    Buttons;
    NTSTATUS status;
    BOOL     AllocStatus;

    Buttons = pParams -> ListLength;
    SETUP_OUTPUT_BUFFER(TestDataBuffer,
                        pParams -> List,
                        Buttons * sizeof(USAGE),
                        "HidP_SetButtons",
                        AllocStatus
                      );

    SETUP_OUTPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        "HidP_SetButtons",
                        AllocStatus
                       );

    status = HidP_SetButtons(pParams -> ReportType,
                             pParams -> UsagePage,
                             pParams -> LinkCollection,
                             TestDataBuffer, 
                             &pParams -> ListLength,
                             pParams -> Ppd,
                             TestReportBuffer,
                             pParams -> ReportLength
                            );

    VERIFY_OUTPUT_BUFFER(TestDataBuffer,
                         pParams -> List,
                         Buttons * sizeof(USAGE),
                         AllocStatus
                        );

    /*
    // VERIFY_INPUT_BUFFER is called instead of OUTPUT_BUFFER even though it
    //    was set up as an OUTPUT_BUFFER.  This is because we need to copy
    //    the data that was returned back to the output buffer.  In essence,
    //    out ReportBuffer acted as an IN/OUT Buffer
    */

    VERIFY_INPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidP_SetData(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PHIDP_DATA TestDataBuffer;
    PCHAR      TestReportBuffer;
    ULONG      DataLength;
    NTSTATUS   status;
    BOOL       AllocStatus;

    DataLength = pParams -> ListLength;
    SETUP_OUTPUT_BUFFER(TestDataBuffer,
                        pParams -> List,
                        DataLength * sizeof(HIDP_DATA),
                        "HidP_SetData",
                        AllocStatus
                      );

    SETUP_OUTPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        "HidP_SetData",
                        AllocStatus
                      );


    status = HidP_SetData(pParams -> ReportType,
                          TestDataBuffer, 
                          &pParams -> ListLength,
                          pParams -> Ppd,
                          TestReportBuffer,
                          pParams -> ReportLength
                         );

    VERIFY_OUTPUT_BUFFER(TestDataBuffer,
                         pParams -> List,
                         DataLength * sizeof(HIDP_DATA),
                         AllocStatus
                        );

    VERIFY_INPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );
    return;
}
    
VOID
ExtCalls_HidP_SetScaledUsageValue(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PCHAR    TestReportBuffer;
    NTSTATUS status;
    BOOL     AllocStatus;

    SETUP_OUTPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        "HidP_SetScaledUsageValue",
                        AllocStatus
                      );

    status = HidP_SetScaledUsageValue(pParams -> ReportType,
                                      pParams -> UsagePage,
                                      pParams -> LinkCollection,
                                      pParams -> Usage,
                                      pParams -> ScaledValue,
                                      pParams -> Ppd,
                                      TestReportBuffer,
                                      pParams -> ReportLength
                                     );

    VERIFY_INPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    TRUE
                   );
    return;
}

VOID
ExtCalls_HidP_SetUsages(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PUSAGE   TestDataBuffer;
    PCHAR    TestReportBuffer;
    ULONG    Usages;
    NTSTATUS status;
    BOOL     AllocStatus;

    Usages = pParams -> ListLength;
    SETUP_OUTPUT_BUFFER(TestDataBuffer,
                        pParams -> List,
                        Usages * sizeof(USAGE),
                        "HidP_SetUsages",
                        AllocStatus
                       );

    SETUP_OUTPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        "HidP_SetUsages",
                        AllocStatus
                       );


    status = HidP_SetUsages(pParams -> ReportType,
                            pParams -> UsagePage,
                            pParams -> LinkCollection,
                            TestDataBuffer,
                            &pParams -> ListLength,
                            pParams -> Ppd,
                            TestReportBuffer,
                            pParams -> ReportLength
                           );

    VERIFY_OUTPUT_BUFFER(TestDataBuffer,
                         pParams -> List,
                         Usages * sizeof(USAGE),
                         AllocStatus
                        );

    VERIFY_INPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );
    return;
}

VOID
ExtCalls_HidP_SetUsageValue(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PCHAR    TestReportBuffer;
    NTSTATUS status;
    BOOL     AllocStatus;

    SETUP_OUTPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        "HidP_SetUsageValue",
                        AllocStatus
                       );

    status = HidP_SetUsageValue(pParams -> ReportType,
                                pParams -> UsagePage,
                                pParams -> LinkCollection,
                                pParams -> Usage,
                                pParams -> Value,
                                pParams -> Ppd,
                                TestReportBuffer,
                                pParams -> ReportLength
                               );

    VERIFY_INPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    TRUE
                   );
    return;
}

VOID
ExtCalls_HidP_SetUsageValueArray(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PCHAR    TestDataBuffer;
    PCHAR    TestReportBuffer;
    NTSTATUS status;
    BOOL     AllocStatus;

    SETUP_OUTPUT_BUFFER(TestDataBuffer,
                        pParams -> List,
                        pParams -> ListLength,
                        "HidP_SetUsageValueArray",
                        AllocStatus
                       );
   
    SETUP_OUTPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        "HidP_SetUsageValueArray",
                        AllocStatus
                       );

    status = HidP_SetUsageValueArray(pParams -> ReportType,
                                     pParams -> UsagePage,
                                     pParams -> LinkCollection,
                                     pParams -> Usage,
                                     TestDataBuffer,
                                     (USHORT) pParams -> ListLength,
                                     pParams -> Ppd,
                                     TestReportBuffer,
                                     pParams -> ReportLength
                                    );

    VERIFY_OUTPUT_BUFFER(TestDataBuffer,
                         pParams -> List,
                         pParams -> ListLength,
                         AllocStatus
                        );

    VERIFY_INPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;
}

VOID
ExtCalls_HidP_UnsetButtons(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PUSAGE   TestDataBuffer;
    PCHAR    TestReportBuffer;
    ULONG    Buttons;
    NTSTATUS status;
    BOOL     AllocStatus;

    Buttons = pParams -> ListLength;
    SETUP_OUTPUT_BUFFER(TestDataBuffer,
                        pParams -> List,
                        Buttons * sizeof(USAGE),
                        "HidP_UnsetButtons",
                        AllocStatus
                       );

    SETUP_OUTPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        "HidP_UnsetButtons",
                        AllocStatus
                       );
    
    status = HidP_UnsetButtons(pParams -> ReportType,
                               pParams -> UsagePage,
                               pParams -> LinkCollection,
                               TestDataBuffer,
                               &pParams -> ListLength,
                               pParams -> Ppd,
                               TestReportBuffer,
                               pParams -> ReportLength
                              );

    VERIFY_OUTPUT_BUFFER(TestDataBuffer,
                         pParams -> List,
                         Buttons * sizeof(USAGE),
                         AllocStatus
                        );

    VERIFY_INPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );

    return;

}

VOID
ExtCalls_HidP_UnsetUsages(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PUSAGE   TestDataBuffer;
    PCHAR    TestReportBuffer;
    ULONG    Usages;
    NTSTATUS status;
    BOOL     AllocStatus;

    Usages = pParams -> ListLength;
    SETUP_OUTPUT_BUFFER(TestDataBuffer,
                        pParams -> List,
                        Usages * sizeof(USAGE),
                        "HidP_UnsetUsages",
                        AllocStatus
                      );

    SETUP_OUTPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        "HidP_UnsetUsages",
                        AllocStatus
                      );

    status = HidP_UnsetUsages(pParams -> ReportType,
                              pParams -> UsagePage,
                              pParams -> LinkCollection,
                              TestDataBuffer,
                              &pParams -> ListLength,
                              pParams -> Ppd,
                              TestReportBuffer,
                              pParams -> ReportLength
                             );

    VERIFY_OUTPUT_BUFFER(TestDataBuffer,
                         pParams -> List,
                         Usages * sizeof(USAGE),
                         AllocStatus
                        );

    VERIFY_INPUT_BUFFER(TestReportBuffer,
                        pParams -> ReportBuffer,
                        pParams -> ReportLength,
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );
    return;
}

VOID
ExtCalls_HidP_UsageListDifference(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    PUSAGE      PreviousList;
    PUSAGE      CurrentList;
    PUSAGE      BreakList;
    PUSAGE      MakeList;
    NTSTATUS    status;
    BOOL        AllocStatus;

    SETUP_OUTPUT_BUFFER(PreviousList,
                       pParams -> List,
                       pParams -> ListLength * sizeof(USAGE),
                       "HidP_UsageListDifference",
                       AllocStatus
                      );

    SETUP_OUTPUT_BUFFER(CurrentList,
                        pParams -> List2,
                        pParams -> ListLength * sizeof(USAGE),
                        "HidP_UsageListDifference",
                        AllocStatus
                       );


    SETUP_INPUT_BUFFER(BreakList,
                       pParams -> BreakList,
                       pParams -> ListLength * sizeof(USAGE),
                       "HidP_UsageListDifference",
                       AllocStatus
                      );

    SETUP_INPUT_BUFFER(MakeList,
                       pParams -> MakeList,
                       pParams -> ListLength * sizeof(USAGE),
                       "HidP_UsageListDifference",
                       AllocStatus
                      );

    status = HidP_UsageListDifference(PreviousList,
                                      CurrentList,
                                      BreakList,
                                      MakeList,
                                      pParams -> ListLength
                                     );
                            
    VERIFY_OUTPUT_BUFFER(PreviousList,
                         pParams -> List,
                         pParams -> ListLength * sizeof(USAGE),
                         AllocStatus
                        );

    VERIFY_OUTPUT_BUFFER(CurrentList,
                         pParams -> List,
                         pParams -> ListLength * sizeof(USAGE),
                         AllocStatus
                        );

    VERIFY_INPUT_BUFFER(BreakList,
                        pParams -> BreakList,
                        pParams -> ListLength * sizeof(USAGE),
                        AllocStatus
                       );

    VERIFY_INPUT_BUFFER(MakeList,
                        pParams -> MakeList,
                        pParams -> ListLength * sizeof(USAGE),
                        AllocStatus
                       );

    SET_HIDP_STATUS(pStatus,
                    status,
                    AllocStatus
                   );
    return;
}


VOID
ExtCalls_ReadInputBuffer(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    DWORD    bytesRead;
    BOOL     fReadStatus;

    fReadStatus = ReadFile (pParams -> DeviceHandle,
                            pParams -> ReportBuffer,
                            pParams -> ReportLength,
                            &bytesRead,
                            NULL
                           );

    pStatus -> IsHidError = !fReadStatus;
    pStatus -> IsHidDbgError = FALSE;
    pStatus -> IsHidDbgWarning = FALSE;

    return;
}

VOID
ExtCalls_WriteOutputBuffer(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
)
{
    DWORD    bytesWritten;
    BOOL     WriteStatus;

    WriteStatus = WriteFile(pParams -> DeviceHandle,
                            pParams -> ReportBuffer,
                            pParams -> ReportLength,
                            &bytesWritten,
                            NULL
                           );

    pStatus -> IsHidError = !WriteStatus;
    pStatus -> IsHidDbgError = FALSE;
    pStatus -> IsHidDbgWarning = FALSE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\buffers.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    buffers.h

Abstract:

    This module declares the functions that and structures that are visible
    to other modules.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef _BUFFERS_H_
#define _BUFFERS_H_

typedef struct {
    PUCHAR      pBuffer;
    INT         iBufferSize;
    UCHAR       ucReportID;
} REPORT_BUFFER, *PREPORT_BUFFER;
    
typedef struct {
    HWND                hBufferComboBox;
    HWND                hBufferEditBox;
    INT                 iBufferSize;
    INT                 iCurrSelectionIndex;
    INT                 nReportBuffers;
    PREPORT_BUFFER      ReportBuffers;
    HIDP_REPORT_TYPE    ReportType;
} BUFFER_DISPLAY, *PBUFFER_DISPLAY;

BOOLEAN
BufferDisplay_Init(
    IN  HWND                hCB,
    IN  HWND                hEB,
    IN  INT                 nBuffers,
    IN  INT                 iBufferSize,
    IN  HIDP_REPORT_TYPE    RType,
    OUT PBUFFER_DISPLAY     *ppBufferDisplay
);

VOID
BufferDisplay_Destroy(
    IN  PBUFFER_DISPLAY     pBufferDisplay
);

VOID
BufferDisplay_ChangeSelection(
    IN  PBUFFER_DISPLAY     pBufferDisplay
);

BOOLEAN
BufferDisplay_UpdateBuffer(
    IN  PBUFFER_DISPLAY     pBufferDisplay,
    IN  PCHAR               pNewBuffer
);

INT
BufferDisplay_GetBufferSize(
    IN  PBUFFER_DISPLAY      pBufferDisplay
);

VOID
BufferDisplay_CopyCurrentBuffer(
    IN  PBUFFER_DISPLAY     pBufferDisplay,
    OUT PCHAR               pCopyBuffer
);

INT
BufferDisplay_GetCurrentBufferNumber(
    IN  PBUFFER_DISPLAY      pBufferDisplay
);

UCHAR
BufferDisplay_GetCurrentReportID(
    IN  PBUFFER_DISPLAY      pBufferDisplay
);

VOID
BufferDisplay_OutputBuffer(
    HWND            hEditBox,
    PREPORT_BUFFER  pReportBuffer
);

VOID
BufferDisplay_ClearBuffer(
    IN  PBUFFER_DISPLAY pBufferDisplay
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\extcalls.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    extcalls.h

Abstract:

    This module contains the declarations for the routines and structures
    publically available to outside routines.  These extended call functions
    execute standard HID.DLL functions with special debug checking included.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef __EXTCALLS_H__
#define __EXTCALLS_H__

#define HID_DBG_ERROR_NONE              0x00000000
#define HID_DBG_ERROR_CORRUPTED_BUFFER  0x00000001

#define HID_DBG_WRNG_NONE    0x00000000

typedef ULONG  HID_DBG_STATUS;

typedef struct {
    HANDLE                    DeviceHandle;
    HIDP_REPORT_TYPE          ReportType;
    PHIDP_PREPARSED_DATA      Ppd;
    USAGE                     UsagePage;
    USAGE                     Usage;
    USHORT                    LinkCollection;
    UCHAR                     ReportID;
    PCHAR                     ReportBuffer;
    ULONG                     ReportLength;
    PVOID                     List;
    ULONG                     ListLength;
    ULONG                     StringIndex;
    union {              
        struct {
            USHORT            ReportCount;
            USHORT            BitSize;
        };

        struct {
            PUSAGE            List2;
            PUSAGE            MakeList;
            PUSAGE            BreakList;
        };

        PHIDP_PREPARSED_DATA *ppPd;
        ULONG                 Value;
        LONG                  ScaledValue;
    };
} EXTCALL_PARAMS, *PEXTCALL_PARAMS;

typedef struct {
    BOOL                IsHidError;
    BOOL                IsHidDbgError;
    BOOL                IsHidDbgWarning;

    NTSTATUS            HidErrorCode;
    HID_DBG_STATUS      HidDbgErrorCode;
    HID_DBG_STATUS      HidDbgWarningCode;
    
} EXTCALL_STATUS, *PEXTCALL_STATUS;

typedef enum {
               TRAP_ON_HID_ERROR,   TRAP_ON_DBG_ERROR,
               TRAP_ON_DBG_WARNING, TRAP_NEVER

             } TRAP_LEVEL;

#ifdef DEBUG

    #define TRAP()      ExtCalls_DbgTrap();

#else

    #define TRAP()      

#endif


VOID
ExtCalls_DbgTrap();

VOID 
ExtCalls_HidD_GetHidGuid(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID 
ExtCalls_HidD_FlushQueue(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidD_GetAttributes(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidD_GetPreparsedData(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidD_FreePreparsedData(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidD_GetFeature(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidD_SetFeature(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidD_GetNumInputBuffers(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidD_SetNumInputBuffers(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidD_GetPhysicalDescriptor(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidD_GetManufacturerString(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidD_GetProductString(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidD_GetIndexedString(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidD_GetSerialNumberString(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_GetSpecificButtonCaps(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_GetSpecificValueCaps(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID 
ExtCalls_HidP_GetCaps(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

PCHAR ExtCalls_GetHidAppStatusString(NTSTATUS StatusCode);

VOID
ExtCalls_HidP_GetButtonCaps(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_GetButtons(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_GetData(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_GetButtonsEx(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_GetLinkCollectionNodes(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_GetScaledUsageValue(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID                   
ExtCalls_HidP_GetUsages(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);                     
                       
VOID                   
ExtCalls_HidP_GetUsagesEx(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);                     

VOID
ExtCalls_HidP_GetUsageValue(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_GetUsageValueArray(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);


VOID
ExtCalls_HidP_GetValueCaps(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_MaxDataListLength(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_MaxUsageListLength(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
); 

VOID
ExtCalls_HidP_SetButtons(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_SetData(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_SetScaledUsageValue(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_SetUsages(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_SetUsageValue(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_SetUsageValueArray(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_UnsetButtons(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_UnsetUsages(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_HidP_UsageListDifference(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_ReadInputBuffer(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

VOID
ExtCalls_WriteOutputBuffer(
    IN OUT PEXTCALL_PARAMS     pParams,
    OUT    PEXTCALL_STATUS     pStatus
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\debug.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    debug.c

Abstract:

    This module contains the function definitions for debug 
       memory allocation tracking

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#define __DEBUG_C__

#ifndef DEBUG
    #define DEBUG
#endif

/*****************************************************************************
/* Debug include files
/*****************************************************************************/
#include <stdio.h>
#include "debug.h"

/*****************************************************************************
/* Local debug macro definitions
/*****************************************************************************/

#define SIGNATURE_SIZE    2
#define HEADER_SIGNATURE  'rdHM'
#define FOOTER_SIGNATURE  'rtFM'
#define MEMFILL_VALUE     0xCC
#define MEMORY_TRAP(msg)  TRAP(TRAP_LEVEL_4, msg)

/*****************************************************************************
/* Data types local to debug
/*****************************************************************************/

typedef struct {

    LIST_ENTRY  ListEntry;
    PCHAR       FileName;
    ULONG       LineNumber;
    BOOL        IsValid;
    ULONG       BufferSize;
    ULONG       Signature[SIGNATURE_SIZE];

} ALLOCHEADER, *PALLOCHEADER;

typedef struct {

    ULONG       Signature[SIGNATURE_SIZE];

} ALLOCFOOTER, *PALLOCFOOTER;


typedef enum {
               MEM_ALLOC_NO_ERROR,       MEM_ALLOC_HEADER_OVERFLOW,
               MEM_ALLOC_INVALID_HEADER, MEM_ALLOC_ALREADY_FREED,
               MEM_ALLOC_FOOTER_OVERFLOW
             
             } MEM_ALLOC_STATUS, *PMEM_ALLOC_STATUS;


/*****************************************************************************
/* Global debug data variables
/*****************************************************************************/

INT     Debug_TrapLevel = TRAP_LEVEL_1;
BOOL    Debug_TrapOn    = FALSE;
static  INT Debug_ListCount = 0;


/*****************************************************************************
/* Local debug data variables
/*****************************************************************************/

static LIST_ENTRY Debug_AllocList = { &Debug_AllocList, &Debug_AllocList };


/*****************************************************************************
/* Local debug function declarations
/*****************************************************************************/

BOOL 
Debug_IsEmptyList( 
    IN PLIST_ENTRY  ListHead
);

VOID 
Debug_InsertIntoListAtTail(
    IN OUT PLIST_ENTRY  ListHead,
    IN OUT PLIST_ENTRY  NewEntry
);

PLIST_ENTRY 
Debug_RemoveHeadOfList(
    IN PLIST_ENTRY ListHead
);

VOID 
Debug_RemoveListEntry(
    IN PLIST_ENTRY     OldEntry
);

/*****************************************************************************
/* Global debug function definitions
/*****************************************************************************/

HGLOBAL __cdecl
Debug_Alloc(
    IN PCHAR    FileName,
    IN ULONG    LineNumber,
    IN DWORD    AllocSize
)
{
    INT          Index;
    DWORD        BytesToAllocate;
    PALLOCHEADER NewBuffer;
    PALLOCFOOTER BufferFooter;

    BytesToAllocate = sizeof(ALLOCHEADER) + sizeof(ALLOCFOOTER) + AllocSize;

    NewBuffer = (PALLOCHEADER) GlobalAlloc(GPTR, BytesToAllocate);

    if (NULL != NewBuffer) {

        /*
        // Initialize the header structure
        */

        NewBuffer -> FileName = FileName;
        NewBuffer -> LineNumber = LineNumber;
        NewBuffer -> IsValid = TRUE;
        NewBuffer -> BufferSize = AllocSize;
        
        for (Index = 0; Index < SIGNATURE_SIZE; Index++) 
            NewBuffer -> Signature[Index] = HEADER_SIGNATURE;

        /*
        // Insert the new allocation block into the list of allocation blocks
        */

        Debug_InsertIntoListAtTail(&Debug_AllocList, 
                                   &(NewBuffer -> ListEntry)
                                  );

        /*
        // Increment to the pointer that will get returned to the user and
        //   initialize that to the fill value
        */

        NewBuffer++;

        FillMemory(NewBuffer, AllocSize, MEMFILL_VALUE);

        /*
        // Initialize the footer on the memory block
        */

        BufferFooter = (PALLOCFOOTER) (((PCHAR) NewBuffer) + AllocSize);

        for (Index = 0; Index < SIGNATURE_SIZE; Index++) 
            BufferFooter -> Signature[Index] = FOOTER_SIGNATURE;

    }

    return (NewBuffer);
}

HGLOBAL __cdecl
Debug_Realloc(
    IN PCHAR        FileName,
    IN ULONG        LineNumber,
    IN PALLOCHEADER MemoryBlock,
    IN DWORD        AllocSize
)
{
    MEM_ALLOC_STATUS AllocStatus;
    PALLOCHEADER     OldBuffer;
    PALLOCHEADER     NewBuffer;

    ASSERT(NULL != MemoryBlock);

    OldBuffer = MemoryBlock-1;
    Debug_ValidateMemoryAlloc(MemoryBlock,
                              &AllocStatus
                             );

    NewBuffer = (PALLOCHEADER) Debug_Alloc(FileName,
                                           LineNumber,
                                           AllocSize
                                          );

    if (NULL != NewBuffer) {
        CopyMemory(NewBuffer, MemoryBlock, OldBuffer -> BufferSize);
        Debug_Free(MemoryBlock);
    }
    return (NewBuffer);
}



HGLOBAL __cdecl
Debug_Free(
    IN PALLOCHEADER  Buffer
)
{
    PALLOCHEADER     Header;
    MEM_ALLOC_STATUS AllocStatus;

    Header = Buffer-1;

    Debug_ValidateMemoryAlloc(Buffer, &AllocStatus);

    /*
    // If the block has already been freed, we will simply return NULL.
    */

    if (MEM_ALLOC_ALREADY_FREED == AllocStatus) 
        return (NULL);
    
    /*
    // If we at least have an valid header, we can remove the header entry
    //    from our list of allocated blocks
    */

    if (MEM_ALLOC_INVALID_HEADER != AllocStatus) {
 
        Debug_RemoveListEntry(&(Header -> ListEntry));
        Header -> IsValid = FALSE;

    }

    /*
    // Free the block of memory
    */

    return (GlobalFree(Header));
}

BOOL __cdecl
Debug_ValidateMemoryAlloc(
    IN  PALLOCHEADER      Header,
    OUT PMEM_ALLOC_STATUS AllocStatus
)
{
    INT              Index;
    BOOL             IsBadSignature;
    PALLOCFOOTER     Footer;
    MEM_ALLOC_STATUS Status;

    /*
    // Begin by validating the header signature.  If this is messed up there's
    //     nothing else that can be done.  Check each SIGNATURE entry
    //     starting from the end to verify it is correct.  If any of them are
    //     not equal to HEADER_SIGNATURE then something went wrong.  However,
    //     if the first element in the array.  Index 0 is valid, then we can
    //     reasonably assume that the rest of the header is correct and we can
    //     extract the appropriate info and display a more meaningful error 
    //     message.  If that signature is not valid, however, there's no way
    //     to insure that any of the other values are valid and therefore we
    //     can't extract the valid info from the header.
    */

    
    Status = MEM_ALLOC_NO_ERROR;
    Header--;

    IsBadSignature = FALSE;
    for (Index = SIGNATURE_SIZE-1; Index >= 0; Index--) {

        if (Header -> Signature[Index] != HEADER_SIGNATURE) {
            IsBadSignature = TRUE;
            break;
        }

    }

    if (IsBadSignature) {
        if (HEADER_SIGNATURE == Header -> Signature[0]) {
            
            static CHAR     msg[1024];

            sprintf(msg,
                    "Header overflow in block: %p\nAllocated by %s on line %u\n",
                    Header,
                    Header -> FileName,
                    Header -> LineNumber
                   );

            MEMORY_TRAP(msg);

            Status = MEM_ALLOC_HEADER_OVERFLOW;
        }
        else {
            
            static CHAR     msg[1024];

            sprintf(msg,
                    "Corrupted allocation header in block: %p\nCannot extract allocation info",
                    Header
                   );

            MEMORY_TRAP(msg);

            Status = MEM_ALLOC_INVALID_HEADER;
        }
    }

    /*
    // We passed the signature phase, let's validate the rest of the memory
    //    allocation beginning with the header where we'll check the IsValid 
    //    flag to see if this chunk of memory has previously been freed.
    */

    else if (!Header -> IsValid) {

        static CHAR     msg[1024];

        sprintf(msg,
                "Allocated block already been freed: %p\nAllocated by %s on line %u\n",
                Header,
                Header -> FileName,
                Header -> LineNumber
               );

        MEMORY_TRAP(msg);

        Status = MEM_ALLOC_ALREADY_FREED;
    }

    else {

        /*
        // Next step is to verify that the footer is still correct and we did not
        //     overflow our buffer on the other end.
        */
        
        Footer = (PALLOCFOOTER) (((PCHAR) (Header+1)) + Header -> BufferSize);
        
        IsBadSignature = FALSE;
        for (Index = 0; Index < SIGNATURE_SIZE; Index++) {
            
            if (FOOTER_SIGNATURE != Footer -> Signature[Index]) {
                IsBadSignature = TRUE;
                break;
            }
        }
        
        if (IsBadSignature) {
        
            static CHAR     msg[1024];
    
            sprintf(msg,
                    "Footer overflow in block: %p\nAllocated by %s on line %u\n",
                    Header,
                    Header -> FileName,
                    Header -> LineNumber
                   );
    
            MEMORY_TRAP(msg);
        
            Status = MEM_ALLOC_FOOTER_OVERFLOW;
            return (FALSE);
        
        }
    }

    if (NULL != AllocStatus) 
        *AllocStatus = Status;

    return (MEM_ALLOC_NO_ERROR == Status);
}

VOID __cdecl
Debug_CheckForMemoryLeaks(
)
{
    static CHAR          msg[1024];
           PALLOCHEADER  Header;

    while (!Debug_IsEmptyList(&Debug_AllocList)) {

        Header = (PALLOCHEADER) Debug_RemoveHeadOfList(&Debug_AllocList);
          
        sprintf(msg,
                "Memory leak block: %p\nAllocated by %s on line %u\n",
                Header,
                Header -> FileName,
                Header -> LineNumber
               );

        MEMORY_TRAP(msg);
    }
    return;
}
            
/*****************************************************************************
/* Local debug function definitions
/*****************************************************************************/

BOOL
Debug_IsEmptyList( 
    IN PLIST_ENTRY  ListHead
)
{
    return (ListHead -> Flink == ListHead);
}

VOID
Debug_InsertIntoListAtTail(
    IN OUT PLIST_ENTRY  ListHead,
    IN OUT PLIST_ENTRY  NewEntry
)
{
    PLIST_ENTRY         OldTail;

    OldTail = ListHead -> Blink;

    NewEntry -> Flink = ListHead;
    NewEntry -> Blink = OldTail;

    OldTail -> Flink = NewEntry;
    ListHead -> Blink = NewEntry;

    Debug_ListCount++;
    return;
}

VOID
Debug_RemoveListEntry(
    IN PLIST_ENTRY     OldEntry
)
{
    PLIST_ENTRY  Flink;
    PLIST_ENTRY  Blink;

    Flink = OldEntry -> Flink;
    Blink = OldEntry -> Blink;

    Blink -> Flink = OldEntry -> Flink;
    Flink -> Blink = OldEntry -> Blink;

    Debug_ListCount--;
    return;
}

PLIST_ENTRY
Debug_RemoveHeadOfList(
    IN PLIST_ENTRY ListHead
)
{
    PLIST_ENTRY OldHead;

    OldHead = ListHead -> Flink;
    ListHead -> Flink = OldHead -> Flink;
    OldHead -> Flink -> Blink = ListHead;

    Debug_ListCount--;
    return (OldHead);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\debug.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    debug.h

Abstract:

    This module contains the function definitions and function declarations
        for the debugging routines to deal with asserts, traps, and 
        memory allocations.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef DEBUG

    #ifndef _DEBUG
        #define _DEBUG
    #endif

#endif

#ifdef _DEBUG

    /*
    // Put in include files to insure that necessary files have been included 
    //    to get all function prototypes and structure defined before use
    */

    #include <windows.h>

    /*
    // Need a macro to output messages to the debugger
    */

    #define DEBUG_OUT(str)  OutputDebugString(str)

    /*
    // Define our trapping related debugging stuff
    //    Define 4 levels of trap to allow us to break only in certain
    //     conditions
    */

    #define TRAP_LEVEL_1    1
    #define TRAP_LEVEL_2    2
    #define TRAP_LEVEL_3    3
    #define TRAP_LEVEL_4    4

    #ifndef __DEBUG_C__

        extern  INT     Debug_TrapLevel;
        extern  BOOL    Debug_TrapOn;

    #endif

    #define TRAP_ON()             Debug_TrapOn = TRUE
    #define TRAP_OFF()            Debug_TrapOn = FALSE
    #define GET_TRAP_STATE()      Debug_TrapOn
    #define SET_TRAP_LEVEL(lvl)   Debug_TrapLevel = lvl

    /*
    // Define the trap macro which will break only when the trap levels
    //    are matching and also displays an optional message
    */

    #undef  TRAP
    #define TRAP(lvl, msg) \
    { \
        if (Debug_TrapOn && ((lvl) >= Debug_TrapLevel)) { \
            if (NULL != (msg))  \
                DEBUG_OUT((msg)); \
            \
            DebugBreak(); \
        } \
    }
    
    /*
    // Define the ASSERT macro to test the string.  Current it will trap
    //    whenever is on and the expression fails
    */

    #undef  ASSERT
    #define ASSERT(exp) \
    { \
        if ((!(exp))) { \
            static CHAR TempStr[1024]; \
            \
            wsprintf(TempStr, \
                     "Assertion Failed: %s, file: %s, line %s", \
                     #exp, __FILE__, __LINE__); \
            \
            DEBUG_OUT(TempStr); \
            TRAP(TRAP_LEVEL_1, NULL); \
        } \
    }

    /*
    // Memory allocation routines
    */

    /*
    // Function definitions
    */

    HGLOBAL __cdecl
    Debug_Alloc(
        IN PCHAR    FileName,
        IN ULONG    LineNumber,
        IN DWORD    AllocSize
    );

    HGLOBAL __cdecl
    Debug_Realloc(
        IN PCHAR        FileName,
        IN ULONG        LineNumber,
        IN PVOID        MemoryBlock,
        IN DWORD        AllocSize
    );

    HGLOBAL __cdecl
    Debug_Free(
        IN PVOID  Buffer
    );

    BOOL __cdecl
    Debug_ValidateMemoryAlloc(
        IN  PVOID             Header,
        OUT PVOID             AllocStatus
    );

    VOID __cdecl
    Debug_CheckForMemoryLeaks();

    /*
    // Wrapper macros
    */

    #define ALLOC(siz)          Debug_Alloc(__FILE__, __LINE__, siz)
    #define REALLOC(blk, siz)   Debug_Realloc(__FILE__, __LINE__, blk, siz)
    #define FREE(ptr)           Debug_Free(ptr)
    #define VALIDATEMEM(ptr)    Debug_ValidateMemoryAlloc(ptr, NULL)
    #define CHECKFORLEAKS()     Debug_CheckForMemoryLeaks()

#else

    /*
    // Non-debug versions of the above routines
    */

    #define DEBUG_OUT(str)

    #define TRAP_ON()  
    #define TRAP_OFF() 
    #define GET_TRAP_STATE()
    #define SET_TRAP_LEVEL(lvl)

    #undef  TRAP
    #define TRAP(lvl, msg)

    #undef  ASSERT
    #define ASSERT(exp)


    #define ALLOC(siz)          GlobalAlloc(GPTR, siz)
    #define REALLOC(blk, siz)   GlobalReAlloc(blk, siz, GMEM_ZEROINIT)
    #define FREE(ptr)           GlobalFree(ptr)
    #define VALIDATEMEM(ptr)    TRUE
    #define CHECKFORLEAKS()

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\logpnp.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    logpnp.h

Abstract:

    This module contains the public function declarations for finding, loading
    and creating logical HID device structures.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef __LOGPNP_H__
#define __LOGPNP_H__

BOOL
LogPnP_LoadLogicalDevice(
    IN     PCHAR        OptFileName,
    IN OUT PHID_DEVICE  HidDevice  
);

BOOL
LogPnP_LoadPpdFromFile(
    IN  PCHAR   FileName,
    OUT PHIDP_PREPARSED_DATA   *PpdBuffer,
    OUT PULONG  PpdBufferLength
);

VOID
LogPnP_CloseLogicalHIDDevices(
    IN  PHID_DEVICE LogicalDeviceList,
    IN  ULONG       NumLogicalDevices
);

BOOL
LogPnP_IsLogicalDevice(
    IN  PHID_DEVICE HidDevice
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\hclient.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    hclient.c

Abstract:

    This module contains the code for handling HClient's main dialog box and 
    for performing/calling the appropriate other routines.

Environment:

    User mode

Revision History:

    Nov-97 : Created 

--*/

#define __HCLIENT_C__
#define LOG_FILE_NAME   NULL

/*****************************************************************************
/* HClient include files
/*****************************************************************************/
#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>
#include <math.h>
#include <assert.h>
#include <dbt.h>
#include "hidsdi.h"
#include "hid.h"
#include "resource.h"
#include "hclient.h"
#include "extcalls.h"
#include "buffers.h"
#include "ecdisp.h"
#include "debug.h"
#include "logpnp.h"

#define USE_MACROS
#include "list.h"

/*****************************************************************************
/* Local display macro definitions
/*****************************************************************************/

#define INPUT_BUTTON    1
#define INPUT_VALUE     2
#define OUTPUT_BUTTON   3
#define OUTPUT_VALUE    4
#define FEATURE_BUTTON  5
#define FEATURE_VALUE   6
#define HID_CAPS        7
#define DEVICE_ATTRIBUTES 8
                           
#define MAX_LB_ITEMS 200

#define MAX_WRITE_ELEMENTS 100
#define MAX_OUTPUT_ELEMENTS 50

#define CONTROL_COUNT 9
#define MAX_LABEL 128
#define MAX_VALUE 128

#define WM_UNREGISTER_HANDLE    WM_USER+1

/*****************************************************************************
/* Macro definition to get device block from the main dialog box procedure
/*****************************************************************************/

#define GET_CURRENT_DEVICE(hDlg, pDevice)   \
{ \
    pDevice = NULL; \
    iIndex = (INT) SendDlgItemMessage(hDlg, \
                                      IDC_DEVICES, \
                                      CB_GETCURSEL, \
                                      0, \
                                      0); \
    if (CB_ERR != iIndex) { \
        pDevice = (PHID_DEVICE) SendDlgItemMessage(hDlg, \
                                                   IDC_DEVICES, \
                                                   CB_GETITEMDATA, \
                                                   iIndex, \
                                                   0); \
    } \
}

/*****************************************************************************
/* Data types local to the HClient display routines
/*****************************************************************************/

typedef struct rWriteDataStruct_type
{

    char szLabel[MAX_LABEL];
    char szValue[MAX_VALUE];

} rWriteDataStruct, *prWriteDataStruct;

typedef struct rGetWriteDataParams_type
{
        prWriteDataStruct   prItems;
        int                 iCount;
        
} rGetWriteDataParams, *prGetWriteDataParams;

typedef struct {

    LIST_NODE_HDR   Hdr;
    HDEVNOTIFY      NotificationHandle;
    HID_DEVICE      HidDeviceInfo;

} DEVICE_LIST_NODE, *PDEVICE_LIST_NODE;

/*****************************************************************************
/* Global module variables
/*****************************************************************************/

static HINSTANCE          hGInstance; //global application instance handle
static BOOL               IsHIDTestLoaded;
static HANDLE             DLLModuleHandle;

/*
// Variables for handling the two different types of devices that can be loaded
//   into the system.  PhysicalDeviceList contains all the actual HID devices
//   attached via the USB bus.  LogicalDeviceList contains those preparsed
//   data structures which were obtained through report descriptors and saved
//   via the latest version of HidView.
*/

static LIST               PhysicalDeviceList;
static LIST               LogicalDeviceList;
                                    
/*****************************************************************************
/* Local data routine declarations
/*****************************************************************************/

VOID 
vReadDataFromControls(
    HWND hDlg,
    prWriteDataStruct prData,
    int iOffset,
    int iCount
);

BOOL CALLBACK 
bGetDataDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
);

BOOL CALLBACK 
bMainDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
);

BOOL CALLBACK 
bFeatureDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
);

BOOL CALLBACK 
bReadDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
);

VOID 
vLoadItemTypes(
    HWND hItemTypes
);

BOOL 
bGetData(
    prWriteDataStruct,
    int iCount,
    HWND hParent, 
    char *pszDialogName
);

VOID 
vLoadDevices(
    HWND hDeviceCombo
);

VOID 
vFreeDeviceList(
    PHID_DEVICE  DeviceList,
    ULONG nDevices
);

VOID 
vDisplayInputButtons(
    PHID_DEVICE pDevice,
    HWND hControl
);

VOID 
vDisplayInputValues(
    PHID_DEVICE pDevice,
    HWND hControl
);

VOID 
vDisplayOutputButtons(
    PHID_DEVICE pDevice,
    HWND hControl
);

VOID 
vDisplayOutputValues(
    PHID_DEVICE pDevice,
    HWND hControl
);

VOID 
vDisplayFeatureButtons(
    PHID_DEVICE pDevice,
    HWND hControl
);

VOID 
vDisplayFeatureValues(
    PHID_DEVICE pDevice,
    HWND hControl
);

VOID 
vWriteDataToControls(
    HWND hDlg,
    prWriteDataStruct prData,
    int iOffset,
    int iCount
);

int 
iPrepareDataFields(
    PHID_DATA pData, 
    ULONG ulDataLength, 
    rWriteDataStruct rWriteData[],
    int iMaxElements
);

BOOL 
bParseData(
    PHID_DATA pData,
    rWriteDataStruct rWriteData[],
    INT iCount,
    INT *piErrorLine
);

BOOL 
bSetButtonUsages(
    PHID_DATA pCap,
    PCHAR     pszInputString
);

VOID
BuildReportIDList(
    IN  PHIDP_BUTTON_CAPS  phidButtonCaps,
    IN  USHORT             nButtonCaps,
    IN  PHIDP_VALUE_CAPS   phidValueCaps,
    IN  USHORT             nValueCaps,
    OUT UCHAR            **ppReportIDList,
    OUT INT               *nReportIDs
);

VOID
ReportToString(
   PHID_DATA    pData,
   PCHAR        szBuff
);

BOOL
RegisterHidDevice(
    IN  HWND                WindowHandle,
    IN  PDEVICE_LIST_NODE   DeviceNode
);

VOID
DestroyDeviceListCallback(
    IN  PLIST_NODE_HDR   ListNode
);


/*****************************************************************************
/* Function Definitions
/*****************************************************************************/

/*******************************
*WinMain: Windows Entry point  *
********************************/
int PASCAL 
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow
)
{
    /*
    // Save instance of the application for further reference
    */

    hGInstance = hInstance;

    /*
    // Set the debug trapping mechanism on if DEBUG is defined.  We will
    //   break into the debugger now on assertion failures and so forth
    */

    TRAP_ON();
    
    /*
    // Attempt to load HIDTest.DLL.  If the DLL exists and can be loaded, then
    //     we can show the START_TEST button in the main dialog box.  Otherwise,
    //     the button is hidden.
    */

    DLLModuleHandle = LoadLibrary("HIDTEST.DLL");

    IsHIDTestLoaded = (NULL != DLLModuleHandle);

    /*
    // Try to create the main dialog box.  Cannot do much else if it fails
    //   so we'll throw up a message box and then exit the app
    */

    if (-1 == DialogBox(hInstance, "MAIN_DIALOG", NULL, (DLGPROC)bMainDlgProc)) {

        MessageBox(NULL,
                   "Unable to create root dialog!",
                   "DialogBox failure",
                   MB_ICONSTOP);
    }

    /*
    // Unloaded HIDTest.DLL if it is loaded
    */

    if (IsHIDTestLoaded) {
        FreeLibrary(DLLModuleHandle);
    }

    /*
    // Call the DEBUG functions to check for memory leaks in the DEBUG version of
    //   HClient
    */
    
    CHECKFORLEAKS();

    return 0;
}

/**************************************************
 * Main Dialog proc                               *
 **************************************************/

/*
// This the dialog box procedure for the main dialog display.
*/

BOOL CALLBACK 
bMainDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    static HWND              hComboCtrl;
    static rWriteDataStruct  rWriteData[MAX_OUTPUT_ELEMENTS];
    static HDEVNOTIFY        diNotifyHandle;
           INT               iIndex;
           INT               iCount;
           CHAR              szTempBuff[128];
           PHID_DEVICE       pDevice;
           PHIDP_BUTTON_CAPS pButtonCaps;
           PHIDP_VALUE_CAPS  pValueCaps;
           INT               iErrorLine;
           INT               iItemType;
           PHID_DEVICE       tempDeviceList;
           ULONG             numberDevices;
           PDEVICE_LIST_NODE listNode;
           DEV_BROADCAST_DEVICEINTERFACE broadcastInterface;

    switch (message) {

        case WM_INITDIALOG:

            /*
            // Initialize the two device lists
            */
            
            InitializeList(&PhysicalDeviceList);
            InitializeList(&LogicalDeviceList);
            
            /*
            // Begin by finding all the HID devices currently attached to the
            //  system.  If that fails, we exit the dialog box
            */
            
            if (!FindKnownHidDevices(&tempDeviceList,
                                     &numberDevices
                                    )) {
                EndDialog(hDlg, 0);
            }
          
            pDevice = tempDeviceList;
            for (iIndex = 0; (ULONG) iIndex < numberDevices; iIndex++, pDevice++) {

                listNode = malloc(sizeof(DEVICE_LIST_NODE));

                if (NULL == listNode) {

                    /*
                    // When freeing up the device list, we need to kill those
                    //  already in the Physical Device List and close
                    //  that have not been added yet in the enumerated list
                    */
                    
                    DestroyListWithCallback(&PhysicalDeviceList, DestroyDeviceListCallback);
                    CloseHidDevices(pDevice, numberDevices - iIndex);
                    free(tempDeviceList);
                    
                    EndDialog(hDlg, 0);
                }

                listNode -> HidDeviceInfo = *pDevice;

                if (!RegisterHidDevice(hDlg, listNode)) {
                
                    DestroyListWithCallback(&PhysicalDeviceList, DestroyDeviceListCallback);

                    CloseHidDevices(pDevice, numberDevices - iIndex);

                    free(tempDeviceList);
                    free(listNode);
                    
                    EndDialog(hDlg, 0);

                }                    

                InsertTail(&PhysicalDeviceList, listNode);
            }

            /*
            // Free the temporary device list...It is no longer needed
            */
            
            free(tempDeviceList);
            
            /*
            // Register for notification from the HidDevice class
            */

            broadcastInterface.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
            broadcastInterface.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;

            HidD_GetHidGuid(&broadcastInterface.dbcc_classguid);

            diNotifyHandle = RegisterDeviceNotification(hDlg,
                                                        &broadcastInterface,
                                                        DEVICE_NOTIFY_WINDOW_HANDLE
                                                       );
            if (NULL == diNotifyHandle) {

                DestroyListWithCallback(&PhysicalDeviceList, DestroyDeviceListCallback);
                           
                EndDialog(hDlg, 0);
            }
                    
            /*
            // Update the device list box...
            // 
            */

            vLoadDevices(GetDlgItem(hDlg,IDC_DEVICES));

            /*
            // Load the types box
            */
            vLoadItemTypes(GetDlgItem(hDlg,IDC_TYPE));
                          
            ShowWindow(GetDlgItem(hDlg, IDC_START_TESTS), IsHIDTestLoaded);

            /*
            // Post a message that the device changed so the appropriate
            //   data for the first device in the system can be displayed
            */

            PostMessage(hDlg,
                        WM_COMMAND,
                        IDC_DEVICES + (CBN_SELCHANGE<<16),
                        (LONG) GetDlgItem(hDlg, IDC_DEVICES)
                       );

            break; /*end WM_INITDIALOG case*/

        case WM_COMMAND:

            switch(LOWORD(wParam)) {

                /*
                // For a read, simply get the current device instance
                //   from the DEVICES combo box and call the read procedure
                //   with the HID_DEVICE block 
                */

                case IDC_READ:
                    GET_CURRENT_DEVICE(hDlg, pDevice);

                    if (NULL != pDevice) {
                        iIndex = DialogBoxParam(hGInstance,
                                                "READDATA",
                                                hDlg,
                                                bReadDlgProc,
                                                (LPARAM) pDevice
                                               );
                    } 
                    break;

                /*
                // For a write, the following steps are performed:
                //   1) Get the current device data from the combo box
                //   2) Prepare the data fields for display based on the data
                //       output data stored in the device data
                //   3) Retrieve the data the from the user that is to be sent
                //       to the device
                //   4) If all goes well and the data parses correctly, send the
                //        the new data values to the device
                */

                case IDC_WRITE:

                    GET_CURRENT_DEVICE(hDlg, pDevice);

                    if (NULL != pDevice) {
                        iCount = iPrepareDataFields(pDevice -> OutputData,
                                                    pDevice -> OutputDataLength,
                                                    rWriteData,
                                                    MAX_OUTPUT_ELEMENTS
                                                   );

                        if (bGetData(rWriteData, iCount, hDlg, "WRITEDATA")) {

                            if (bParseData(pDevice -> OutputData, rWriteData, iCount, &iErrorLine)) {
                                Write(pDevice);
                            }
                            else {
                                wsprintf(szTempBuff,
                                         "Unable to parse line %x of output data",
                                         iErrorLine);

                                MessageBox(hDlg,
                                           szTempBuff,
                                           "Data Error",
                                           MB_ICONEXCLAMATION
                                          );
                            }
                        } 
                    } 
                    break; /*end case IDC_WRITE*/
                    
                /*
                // For processing features, get the current device data and call
                //   the Features dialog box,  This dialog box will deal with 
                //   sending and retrieving the features.
                */

                case IDC_FEATURES:
                    GET_CURRENT_DEVICE(hDlg, pDevice);

                    if (NULL != pDevice) {
                        iIndex = DialogBoxParam(hGInstance, 
                                                "FEATURES", 
                                                hDlg, 
                                                bFeatureDlgProc, 
                                                (LPARAM) pDevice
                                               );
                    }
                    break;
                    
                /*
                // Likewise with extended calls dialog box.  This procedure
                //   passes the address to the device data structure and lets
                //   the dialog box procedure manipulate the data however it 
                //   wants to.
                */

                case IDC_EXTCALLS:
                    GET_CURRENT_DEVICE(hDlg, pDevice);

                    if (NULL != pDevice) {
                        iIndex = DialogBoxParam(hGInstance,
                                                "EXTCALLS",
                                                hDlg,
                                                bExtCallDlgProc,
                                                (LPARAM) pDevice
                                               );
                    }
                    break;
                      
                /*
                // START_TESTS occurs only when HIDTEST.DLL is loaded.  This
                //    DLL is for internal test purposes and is not provided
                //    in the DDK sample.
                */
                
                case IDC_START_TESTS:
                    break;
                    
                /*
                // If there was a device change, we simply issue an IDC_TYPE
                //   change to insure that the currently displayed types are
                //    updated to reflect the values of the device that has
                //    been selected
                */

                case IDC_DEVICES:
                    switch (HIWORD(wParam)) {

                        case CBN_SELCHANGE:
                            PostMessage(hDlg,
                                        WM_COMMAND,
                                        IDC_TYPE + (CBN_SELCHANGE<<16),
                                        (LPARAM) GetDlgItem(hDlg,IDC_TYPE)
                                       );
                            break;

                    } 
                    break;

                /*
                // On a type change, we retrieve the currently active device
                //   from the IDC_DEVICES box and display the data that 
                //   corresponds to the item just selected
                */
                
                case IDC_TYPE:
                    switch (HIWORD(wParam)) {
                        case CBN_SELCHANGE:
                            GET_CURRENT_DEVICE(hDlg, pDevice);

                            
                            SendDlgItemMessage(hDlg,
                                               IDC_ITEMS,
                                               LB_RESETCONTENT,
                                               0,
                                               0);

                            SendDlgItemMessage(hDlg,
                                               IDC_ATTRIBUTES,
                                               LB_RESETCONTENT,
                                               0,
                                               0);
                            
                            if (NULL != pDevice) {                            
                                iIndex = SendDlgItemMessage(hDlg,
                                                            IDC_TYPE,
                                                            CB_GETCURSEL,
                                                            0,
                                                            0);

                                iItemType = SendDlgItemMessage(hDlg,
                                                               IDC_TYPE,
                                                               CB_GETITEMDATA,
                                                               iIndex,
                                                               0);

                                switch(iItemType) {
                                    case INPUT_BUTTON:
                                        vDisplayInputButtons(pDevice,GetDlgItem(hDlg,IDC_ITEMS));
                                        break;

                                    case INPUT_VALUE:
                                         vDisplayInputValues(pDevice,GetDlgItem(hDlg,IDC_ITEMS));
                                         break;

                                    case OUTPUT_BUTTON:
                                        vDisplayOutputButtons(pDevice,GetDlgItem(hDlg,IDC_ITEMS));
                                        break;

                                    case OUTPUT_VALUE:
                                        vDisplayOutputValues(pDevice,GetDlgItem(hDlg,IDC_ITEMS));
                                        break;

                                    case FEATURE_BUTTON:
                                        vDisplayFeatureButtons(pDevice,GetDlgItem(hDlg,IDC_ITEMS));
                                        break;

                                    case FEATURE_VALUE:
                                        vDisplayFeatureValues(pDevice,GetDlgItem(hDlg,IDC_ITEMS));
                                        break;
                                } 

                                PostMessage(hDlg,
                                            WM_COMMAND,
                                            IDC_ITEMS + (LBN_SELCHANGE << 16),
                                            (LPARAM) GetDlgItem(hDlg,IDC_ITEMS)
                                           );
                            } 
                            break; // case CBN_SELCHANGE

                    } //end switch HIWORD wParam
                    break; //case IDC_TYPE control

                case IDC_ITEMS:
                    switch(HIWORD(wParam)) {
                        case LBN_SELCHANGE:
                            iItemType = 0;
                            iIndex = SendDlgItemMessage(hDlg,
                                                        IDC_TYPE,
                                                        CB_GETCURSEL,
                                                        0,
                                                        0);

                            if (-1 != iIndex) {
                                iItemType = (INT) SendDlgItemMessage(hDlg,
                                                                     IDC_TYPE,
                                                                     CB_GETITEMDATA,
                                                                     iIndex,
                                                                     0
                                                                    );
                            }

                            iIndex = SendDlgItemMessage(hDlg,
                                                        IDC_ITEMS,
                                                        LB_GETCURSEL,
                                                        0,
                                                        0
                                                       );

                            switch (iItemType) {
                                case INPUT_BUTTON:
                                case OUTPUT_BUTTON:
                                case FEATURE_BUTTON:
                                    pButtonCaps = NULL;
                                    if (-1 != iIndex){
                                        pButtonCaps = (PHIDP_BUTTON_CAPS) SendDlgItemMessage(hDlg,
                                                                                             IDC_ITEMS,
                                                                                             LB_GETITEMDATA,
                                                                                             iIndex,
                                                                                             0);
                                    }

                                    SendDlgItemMessage(hDlg, IDC_ATTRIBUTES, LB_RESETCONTENT, 0, 0);
                                    if (NULL != pButtonCaps) {
                                        vDisplayButtonAttributes(pButtonCaps, GetDlgItem(hDlg,IDC_ATTRIBUTES));
                                    }
                                    break;


                                case INPUT_VALUE:
                                case OUTPUT_VALUE:
                                case FEATURE_VALUE:
                                    pValueCaps = NULL;
                                    if (-1 != iIndex) {
                                        pValueCaps = (PHIDP_VALUE_CAPS) SendDlgItemMessage(hDlg,
                                                                                             IDC_ITEMS,
                                                                                             LB_GETITEMDATA,
                                                                                             iIndex,
                                                                                             0);
                                    }

                                    SendDlgItemMessage(hDlg, IDC_ATTRIBUTES, LB_RESETCONTENT, 0, 0);
                                    if (NULL != pValueCaps) {                                                           
                                        vDisplayValueAttributes(pValueCaps,GetDlgItem(hDlg,IDC_ATTRIBUTES));
                                    }
                                    break;

                                case HID_CAPS:
                                    GET_CURRENT_DEVICE(hDlg, pDevice);

                                    if (NULL != pDevice) {
                                        vDisplayDeviceCaps(&(pDevice -> Caps),GetDlgItem(hDlg,IDC_ATTRIBUTES));
                                    }
                                    break;

                                case DEVICE_ATTRIBUTES:
                                    GET_CURRENT_DEVICE(hDlg, pDevice);

                                    if (NULL != pDevice) {
                                        SendDlgItemMessage(hDlg, IDC_ATTRIBUTES, LB_RESETCONTENT, 0, 0);
                                        vDisplayDeviceAttributes(&(pDevice -> Attributes) ,GetDlgItem(hDlg,IDC_ATTRIBUTES));
                                    }
                                    break;

                            } /*end switch iItemType*/
                            break; /*end case LBN_SELCHANGE in IDC_ITEMS*/

                    } /*end switch HIWORD wParam*/
                    break; /*case IDC_ITEMS*/

                /*
                // To load a logical device, we first have insure that
                //      we have space left in the list of logical devices
                //      If there isn't space, we have to realloc more space
                //      or print an error message saying the limit has
                //      been reached.  Once we've allocated space for the
                //      logical device, the next step is to pass the HID_DEVICE
                //      structure to our load logical device routine to get
                //      the data for that device.
                */

                case IDC_LOAD_LOGICAL_DEVICE:
                    listNode = malloc(sizeof(DEVICE_LIST_NODE));

                    if (NULL == listNode) {

                        MessageBox(hDlg,
                               "Error -- Couldn't allocate memory for device list node",
                               "HClient Error",
                               MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL
                              );
                        return (FALSE);                      
                    
                    }

                                      
                    /*
                    // Now call the LogPnp_LoadLogicalDevice to load all the data for
                    //   the logical device
                    */
                
                    if (LogPnP_LoadLogicalDevice(LOG_FILE_NAME, &(listNode -> HidDeviceInfo))) {

                        listNode -> NotificationHandle = NULL;
                        
                        InsertTail(&LogicalDeviceList, listNode);
                        
                        vLoadDevices(GetDlgItem(hDlg, IDC_DEVICES));
                    }
                    break;

                case IDC_ABOUT:
                    MessageBox(hDlg,
                               "Sample HID client Application.  Microsoft Corp \nCopyright (C) 1997",
                               "About HClient",
                               MB_ICONINFORMATION
                              );
                    break;

                case IDOK:
                case IDCANCEL:
                    DestroyListWithCallback(&PhysicalDeviceList, DestroyDeviceListCallback);
                    DestroyListWithCallback(&LogicalDeviceList, DestroyDeviceListCallback);
                    EndDialog(hDlg,0);
                    break;

            } /*end switch wParam*/
            break;

        /*
        // For a device change message, we are only concerned about the 
        //    DBT_DEVICEREMOVECOMPLETE and DBT_DEVICEARRIVAL events. I have
        //    yet to determine how to process the device change message
        //    only for HID devices.  Therefore, there are two problems
        //    with the below implementation.  First of all, we must reload
        //    the device list any time a device is added to the system.  
        //    Secondly, at least two DEVICEARRIVAL messages are received 
        //    per HID.  One corresponds to the physical device.  The second
        //    change and any more correspond to each collection on the 
        //    physical device so a system that has one HID device with
        //    two top level collections (a keyboard and a mouse) will receive
        //    three DEVICEARRIVAL/REMOVALs causing the program to reload it's
        //    device list more than once.
        */

        /*
        // To handle dynamic changing of devices, we have already registered
        //    notification for both HID class changes and for notification 
        //    for our open file objects.  Since we are only concerned about
        //    arrival/removal of devices, we only need to process those wParam.
        //    lParam points to some sort of DEV_BROADCAST_HDR struct.  For device
        //    arrival, we only deal with the message if that struct is a 
        //    DEV_BROADCAST_DEVICEINTERFACE structure.  For device removal, we're
        //    only concerned if the struct is a DEV_BROADCAST_HANDLE structure.
        */

        case WM_DEVICECHANGE:
            switch (wParam) {
                PDEV_BROADCAST_HDR broadcastHdr;

           
                case DBT_DEVICEARRIVAL:
                    broadcastHdr = (PDEV_BROADCAST_HDR) lParam;

                    if (DBT_DEVTYP_DEVICEINTERFACE == broadcastHdr -> dbch_devicetype) {

                        PDEV_BROADCAST_DEVICEINTERFACE broadcastInterface;
                        
                        broadcastInterface = (PDEV_BROADCAST_DEVICEINTERFACE) lParam;

                        /*
                        // In this structure, we are given the name of the device
                        //    to open.  So all that needs to be done is open 
                        //    a new hid device with the string
                        */

                        listNode = (PDEVICE_LIST_NODE) malloc(sizeof(DEVICE_LIST_NODE));

                        if (NULL == listNode) {

                            MessageBox(hDlg,
                               "Error -- Couldn't allocate memory for new device list node",
                               "HClient Error",
                               MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL
                            );
                            break;

                        }
                       
                        /*
                        // Open the hid device
                        */
                        
                        OpenHidDevice (broadcastInterface -> dbcc_name,
                                       &(listNode -> HidDeviceInfo)
                                      );

                        if (!RegisterHidDevice(hDlg, listNode)) {
                        
                            MessageBox(hDlg,
                               "Error -- Couldn't register handle notification",
                               "HClient Error",
                               MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL
                            );

                            CloseHidDevice(&(listNode -> HidDeviceInfo));
                            free(listNode);
                            break;

                        }                         

                        InsertTail(&PhysicalDeviceList, listNode);

                        vLoadDevices(GetDlgItem(hDlg,IDC_DEVICES));
                        PostMessage(hDlg,
                                   WM_COMMAND,
                                   IDC_DEVICES + (CBN_SELCHANGE << 16),
                                   (LPARAM) GetDlgItem(hDlg,IDC_DEVICES));
                                   
                    }
                    break;

                case DBT_DEVICEREMOVECOMPLETE:
                    broadcastHdr = (PDEV_BROADCAST_HDR) lParam;

                    if (DBT_DEVTYP_HANDLE == broadcastHdr -> dbch_devicetype) {

                        PDEV_BROADCAST_HANDLE broadcastHandle;
                        PDEVICE_LIST_NODE     currNode;
                        HANDLE                deviceHandle;
                        
                        broadcastHandle = (PDEV_BROADCAST_HANDLE) lParam;

                        /*
                        // Get the file handle of the device that was removed
                        //  from the system
                        */
                        
                        deviceHandle = (HANDLE) broadcastHandle -> dbch_handle;


                        /*
                        // Search the physical device list for the handle that
                        //  was removed...
                        */

                        currNode = (PDEVICE_LIST_NODE) GetListHead(&PhysicalDeviceList);

                        /*
                        // This loop should always terminate since the device 
                        //  handle should be somewhere in the physical device list
                        */
                        
                        while (currNode -> HidDeviceInfo.HidDevice != deviceHandle) {
                            currNode = (PDEVICE_LIST_NODE) GetNextEntry(currNode);
                        }

                        /*
                        // Node in PhysicalDeviceList has been found, do:
                        //  1) Unregister notification
                        //  2) Close the hid device
                        //  3) Remove the entry from the list
                        //  4) Free the memory for the entry
                        // 
                        */

                        PostMessage(hDlg, 
                                    WM_UNREGISTER_HANDLE, 
                                    0, 
                                    (LPARAM) currNode -> NotificationHandle
                                   );

                        CloseHidDevice(&(currNode -> HidDeviceInfo));

                        RemoveNode(currNode);

                        free(currNode);
                
                        /*
                        // Reload the device list
                        */
                        
                        vLoadDevices(GetDlgItem(hDlg,IDC_DEVICES));
                        PostMessage(hDlg,
                                   WM_COMMAND,
                                   IDC_DEVICES + (CBN_SELCHANGE << 16),
                                   (LPARAM) GetDlgItem(hDlg,IDC_DEVICES));
                    }
                    break;
    
                default:
                    break;
            }
            break;

        /*
        // Application specific message used to defer the unregistering of a 
        //  file object for device change notification.  This separte message
        //  is sent when a WM_DEVICECHANGE (DBT_DEVICEREMOVECOMPLETE) has been
        //  received.  The Unregistering of the notification must be deferred
        //  until after the WM_DEVICECHANGE message has been processed or the 
        //  system will deadlock.  The handle that is to be freed will be passed
        //  in as lParam for this message
        */
        
        case WM_UNREGISTER_HANDLE:
            UnregisterDeviceNotification ( (HDEVNOTIFY) lParam ); 
            break;

   } /*end switch message*/
   return FALSE;
} /*end MainDlgProc*/


BOOL 
bParseData(
    PHID_DATA           pData,
    rWriteDataStruct    rWriteData[],
    int                 iCount,
    int                 *piErrorLine
)
{  
    INT       iCap;
    PHID_DATA pWalk;
    BOOL      bNoError = TRUE;

    pWalk = pData;
    for (iCap = 0; (iCap < iCount) && bNoError; iCap++) {

        /*
        // Check to see if our data is a value cap or not
        */

        if (!pWalk->IsButtonData) {

            pWalk -> ValueData.Value = atol(rWriteData[iCap].szValue);

        } 
        else
        {
            if (!bSetButtonUsages(pWalk, rWriteData[iCap].szValue) ) {

               *piErrorLine = iCap;
               bNoError = FALSE;
            } 
        } 
        pWalk++;
    }
    return bNoError;
}

BOOL 
bSetButtonUsages(
    PHID_DATA pCap,
    PCHAR     pszInputString
)
{
    CHAR   szTempString[128];
    PCHAR  pszDelimiter=" ";
    PCHAR  pszToken;
    INT    iLoop;
    PUSAGE pUsageWalk;
    BOOL   bNoError=TRUE;


    strcpy(szTempString, pszInputString);
    pszToken = strtok(szTempString, pszDelimiter);
    
    pUsageWalk = pCap -> ButtonData.Usages;
    memset(pUsageWalk, 0, pCap->ButtonData.MaxUsageLength * sizeof(USAGE));

    for (iLoop = 0; ((ULONG) iLoop < pCap->ButtonData.MaxUsageLength) && (pszToken != NULL) && bNoError; iLoop++)
    {
        *pUsageWalk = atoi(pszToken);

        pszToken = strtok(NULL, pszDelimiter);
        pUsageWalk++;
    } 

     return bNoError;
} /*end function bSetButtonUsages*/


INT 
iPrepareDataFields(
    PHID_DATA           pData,
    ULONG               ulDataLength, 
    rWriteDataStruct    rWriteData[],
    int                 iMaxElements
)
{
    INT i;
    PHID_DATA pWalk;

    pWalk = pData;

    for (i = 0; (i < iMaxElements) && ((unsigned) i < ulDataLength); i++)
    {
        if (!pWalk->IsButtonData) { 

            wsprintf(rWriteData[i].szLabel,
                     "ValueCap; ReportID: 0x%x, UsagePage=0x%x, Usage=0x%x",
                     pWalk->ReportID,
                     pWalk->UsagePage,
                     pWalk->ValueData.Usage);
        }
        else {
            wsprintf(rWriteData[i].szLabel,
                     "Button; ReportID: 0x%x, UsagePage=0x%x, UsageMin: 0x%x, UsageMax: 0x%x",
                     pWalk->ReportID,
                     pWalk->UsagePage,
                     pWalk->ButtonData.UsageMin,
                     pWalk->ButtonData.UsageMax
                   );
        }
        pWalk++;
     } 
     return i;
}  /*end function iPrepareDataFields*/


BOOL CALLBACK 
bReadDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    static PHID_DEVICE pDevice;
    static INT         iLbCounter;
    static CHAR        szTempBuff[1024];
           INT         iIndex;
           PHID_DATA   pData;
           UINT        uLoop;

    switch(message) {
        case WM_INITDIALOG:
            iLbCounter = 0;
            pDevice = (PHID_DEVICE) lParam;
            break; 

        case WM_COMMAND:
            switch(LOWORD(wParam)) {
                case IDC_READ:
                    Read(pDevice);
                    pData = pDevice -> InputData;
                    SendDlgItemMessage(hDlg,
                                       IDC_OUTPUT,
                                       LB_ADDSTRING,
                                       0,
                                       (LPARAM)"-------------------------------------------");
                                       
                    iLbCounter++;
                    if (iLbCounter > MAX_LB_ITEMS) {
                        SendDlgItemMessage(hDlg,
                                           IDC_OUTPUT,
                                           LB_DELETESTRING,
                                           0,
                                           0);
                    }

                    for (uLoop = 0; uLoop < pDevice->InputDataLength; uLoop++) {

                        ReportToString(pData, szTempBuff);
                        iIndex = SendDlgItemMessage(hDlg,
                                                    IDC_OUTPUT,
                                                    LB_ADDSTRING,
                                                    0,
                                                    (LPARAM) szTempBuff
                                                   );

                        SendDlgItemMessage(hDlg,
                                           IDC_OUTPUT,
                                           LB_SETCURSEL,
                                           iIndex,
                                           0
                                          );

                        iLbCounter++;
                        if (iLbCounter > MAX_LB_ITEMS) {
                            SendDlgItemMessage(hDlg,
                                               IDC_OUTPUT,
                                               LB_DELETESTRING,
                                               0,
                                               0
                                              );
                        }
                        pData++;
                    }
                    break;

                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg,0);
                    break;
            }
            break;
     } /*end switch message*/
     return FALSE;
} /*end bReadDlgProc*/

VOID
ReportToString(
   PHID_DATA pData,
   PCHAR szBuff
)
{
    PCHAR   pszWalk;
    PUSAGE  pUsage;
    ULONG   i;

    /*
    // For button data, all the usages in the usage list are to be displayed
    */
    
    if (pData -> IsButtonData) {
         wsprintf (szBuff, 
                   "Usage Page: 0x%x, Usages: ",
                   pData -> UsagePage
                  );

         pszWalk = szBuff + strlen(szBuff);
         *pszWalk = '\0';

         for (i = 0, pUsage = pData -> ButtonData.Usages;
                     i < pData -> ButtonData.MaxUsageLength;
                         i++, pUsage++) {

             if (0 == *pUsage) {
                 break; // A usage of zero is a non button.
             }
             pszWalk += wsprintf (pszWalk, " 0x%x", *pUsage);
         }
    }
    else {

        wsprintf (szBuff,
                  "Usage Page: 0x%x, Usage: 0x%x, Scaled: %d Value: %d",
                  pData->UsagePage,
                  pData->ValueData.Usage,
                  pData->ValueData.ScaledValue,
                  pData->ValueData.Value
                 );

    }
}

BOOL CALLBACK 
bFeatureDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    static PHID_DEVICE       pDevice;
    static INT               iLbCounter;
    static rWriteDataStruct  rWriteData[50];
    static CHAR              szTempBuff[1024];
           INT               iIndex;
           INT               iCount;
           INT               iErrorLine;
           PHID_DATA         pData;
           UINT              uLoop;

    switch(message) {
        case WM_INITDIALOG:
            iLbCounter = 0;
            pDevice = (PHID_DEVICE) lParam;
            break; 

        case WM_COMMAND:
            switch(LOWORD(wParam)) {
                case IDC_READ:
                    GetFeature(pDevice);
                    pData = pDevice -> FeatureData;
                    SendDlgItemMessage(hDlg,
                                       IDC_OUTPUT,
                                       LB_ADDSTRING,
                                       0,
                                       (LONG)"------------ Read Features ---------------");
                    iLbCounter++;

                    if (iLbCounter > MAX_LB_ITEMS) {
                        SendDlgItemMessage(hDlg,
                                           IDC_OUTPUT,
                                           LB_DELETESTRING,
                                           0,
                                           0);
                    }

                    for (uLoop = 0; uLoop < pDevice -> FeatureDataLength; uLoop++) {

                        ReportToString(pData, szTempBuff);
                        iIndex = SendDlgItemMessage(hDlg,
                                                    IDC_OUTPUT,
                                                    LB_ADDSTRING,
                                                    0,
                                                    (LPARAM) szTempBuff
                                                   );
                                                   
                        SendDlgItemMessage(hDlg,
                                           IDC_OUTPUT,
                                           LB_SETCURSEL,
                                           iIndex,
                                           (LPARAM) 0
                                          );

                        iLbCounter++;
                        if (iLbCounter > MAX_LB_ITEMS) {
                            SendDlgItemMessage(hDlg,
                                               IDC_OUTPUT,
                                               LB_DELETESTRING,
                                               0,
                                               0);
                        }
                        pData++;
                    } 
                    break;

                case IDC_WRITE:
                     iCount = iPrepareDataFields(pDevice -> FeatureData, 
                                                 pDevice -> FeatureDataLength,
                                                 rWriteData,
                                                 MAX_OUTPUT_ELEMENTS
                                                );

                     if (bGetData(rWriteData, iCount, hDlg, "WRITEFEATURE")) {
             
                         if (!bParseData(pDevice -> FeatureData, rWriteData,iCount, &iErrorLine)) {
                             wsprintf(szTempBuff,
                                     "Unable to parse line %x of output data",
                                     iErrorLine
                             );
                             
                             MessageBox(hDlg,
                                         szTempBuff,
                                         "Data Error",
                                         MB_ICONEXCLAMATION
                                        );
                         }
                         else {
                             if ( SetFeature(pDevice) ) {
                                 SendDlgItemMessage(hDlg,
                                                    IDC_OUTPUT,
                                                    LB_ADDSTRING,
                                                    0,
                                                    (LPARAM)"------------ Write Feature ---------------");                                             
                             }
                             else {
                                 SendDlgItemMessage(hDlg,
                                                    IDC_OUTPUT,
                                                    LB_ADDSTRING,
                                                    0,
                                                    (LPARAM)"------------ Write Feature Error ---------------");                                             
                             }                                                             
                         }
                     }
                     break;
                      
                      
                 case IDOK:
                 case IDCANCEL:
                     EndDialog(hDlg,0);
                     break;
            }
            break;
   } /*end switch message*/
   return FALSE;
} /*end bReadDlgProc*/

VOID 
vDisplayDeviceCaps(
    IN PHIDP_CAPS pCaps,
    IN HWND hControl
)
{
    static CHAR szTempBuff[128];

    SendMessage(hControl, LB_RESETCONTENT, 0, 0);

    wsprintf(szTempBuff, "Usage Page: 0x%x", pCaps -> UsagePage);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff,"Usage: 0x%x",pCaps -> Usage);
    SendMessage(hControl,LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff,"Input report byte length: %d",pCaps -> InputReportByteLength);
    SendMessage(hControl,LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff,"Output report byte length: %d",pCaps -> OutputReportByteLength);
    SendMessage(hControl,LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff,"Feature report byte length: %d",pCaps -> FeatureReportByteLength);
    SendMessage(hControl,LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff,"Number of collection nodes %d: ", pCaps -> NumberLinkCollectionNodes);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    return;
}

VOID
vDisplayDeviceAttributes(
    PHIDD_ATTRIBUTES pAttrib,
    HWND hControl
)
{
    static CHAR szTempBuff[128];

    wsprintf(szTempBuff, "Vendor ID: 0x%x", pAttrib -> VendorID);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff, "Product ID: 0x%x", pAttrib -> ProductID);
    SendMessage(hControl, LB_ADDSTRING, 0,(LPARAM) szTempBuff);

    wsprintf(szTempBuff, "Version Number  0x%x", pAttrib -> VersionNumber);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    return;
}

VOID
vDisplayDataAttributes(
    PHIDP_DATA pData, 
    BOOL IsButton, 
    HWND hControl
)
{
    static CHAR szTempBuff[128];

    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) "================");

    wsprintf(szTempBuff, "Index: 0x%x", pData -> DataIndex);
    SendMessage(hControl,LB_ADDSTRING, 0, (LONG)szTempBuff);
    
    wsprintf(szTempBuff, "IsButton: %s", IsButton ? "TRUE" : "FALSE");
    SendMessage(hControl, LB_ADDSTRING, 0, (LONG)szTempBuff);

    if (IsButton) {
        wsprintf(szTempBuff, "Button pressed: %s", pData -> On ? "TRUE" : "FALSE");
        SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
    }
    else {
        wsprintf(szTempBuff, "Data value: 0x%x", pData -> RawValue);
        SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
    }
}

VOID 
vDisplayButtonAttributes(
    IN PHIDP_BUTTON_CAPS pButton,
    IN HWND hControl
)
{
    static CHAR szTempBuff[128];
   
    wsprintf(szTempBuff, "Report ID: 0x%x", pButton->ReportID);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
     
    wsprintf(szTempBuff, "Usage Page: 0x%x", pButton->UsagePage);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
        
    wsprintf(szTempBuff, 
             "Alias: %s",
             pButton -> IsAlias ? "TRUE" : "FALSE"
            );
    
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
   
    wsprintf(szTempBuff,
             "Link Collection: %hu", 
             pButton -> LinkCollection
            );
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
   
    wsprintf(szTempBuff,
             "Link Usage Page: 0x%x",
             pButton -> LinkUsagePage
            );
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);        
   
    wsprintf(szTempBuff,
             "Link Usage: 0x%x",
             pButton -> LinkUsage
            );
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (pButton->IsRange) {
        wsprintf(szTempBuff,
                 "Usage Min: 0x%x, Usage Max: 0x%x",
                 pButton->Range.UsageMin, 
                 pButton->Range.UsageMax
                );
               
     } 
     else {
         wsprintf(szTempBuff,"Usage: 0x%x",pButton->NotRange.Usage);

     } 
     SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

     if (pButton->IsRange) {
         wsprintf(szTempBuff,
                  "Data Index Min: 0x%x, Data Index Max: 0x%x",
                  pButton->Range.DataIndexMin, 
                  pButton->Range.DataIndexMax);

     } 
     else {
         wsprintf(szTempBuff,"DataIndex: 0x%x",pButton->NotRange.DataIndex);
     } 
     SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

     if (pButton->IsStringRange) {

         wsprintf(szTempBuff,
                  "String Min: 0x%x, String Max: 0x%x",
                  pButton->Range.StringMin, 
                  pButton->Range.StringMax);

     } 
     else {
         wsprintf(szTempBuff,"String Index: 0x%x",pButton->NotRange.StringIndex);
     } 
     SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

     if (pButton->IsDesignatorRange) {
         wsprintf(szTempBuff,
                  "Designator Min: 0x%x, Designator Max: 0x%x",
                  pButton->Range.DesignatorMin, 
                  pButton->Range.DesignatorMax);

     } 
     else {
         wsprintf(szTempBuff,
                  "Designator Index: 0x%x",
                  pButton->NotRange.DesignatorIndex);
    } 
    SendMessage(hControl, LB_ADDSTRING, 0,(LPARAM) szTempBuff);

    if (pButton->IsAbsolute) {
        SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) "Absolute: Yes");
    }
    else {
        SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) "Absolute: No");
    }
    return;
} 

VOID
vDisplayValueAttributes(
    IN PHIDP_VALUE_CAPS pValue,
    HWND hControl
)
{
    static CHAR szTempBuff[128];

    wsprintf(szTempBuff, "Report ID 0x%x", pValue->ReportID);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
 
    wsprintf(szTempBuff, "Usage Page: 0x%x", pValue->UsagePage);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff, "Bit size: 0x%x", pValue->BitSize);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff, "Report Count: 0x%x", pValue->ReportCount);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff, "Unit Exponent: 0x%x", pValue->UnitsExp);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

 
   if (pValue->IsAlias) {
        wsprintf(szTempBuff, "Alias");
    }
    else {
        wsprintf(szTempBuff, "=====");
    }
    SendMessage(hControl,LB_ADDSTRING,0,(LONG)szTempBuff);

    if (pValue->IsRange) {

        wsprintf(szTempBuff,
                 "Usage Min: 0x%x, Usage Max 0x%x",
                 pValue->Range.UsageMin, 
                 pValue->Range.UsageMax);

    } 
    else {
        wsprintf(szTempBuff, "Usage: 0x%x", pValue -> NotRange.Usage);

    } 
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (pValue->IsRange) {
        wsprintf(szTempBuff,
                 "Data Index Min: 0x%x, Data Index Max: 0x%x",
                 pValue->Range.DataIndexMin, 
                 pValue->Range.DataIndexMax);


    } 
    else {  
        wsprintf(szTempBuff, "DataIndex: 0x%x", pValue->NotRange.DataIndex);
    } 
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff,
            "Physical Minimum: %d, Physical Maximum: %d",
            pValue->PhysicalMin, 
            pValue->PhysicalMax);

    SendMessage(hControl, LB_ADDSTRING, 0,(LPARAM) szTempBuff);

    wsprintf(szTempBuff,
            "Logical Minimum: 0x%x, Logical Maximum: 0x%x",
            pValue->LogicalMin,
            pValue->LogicalMax);

    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (pValue->IsStringRange) {

       wsprintf(szTempBuff,
                "String  Min: 0x%x String Max 0x%x",
                pValue->Range.StringMin,
                pValue->Range.StringMax);


    } 
    else {
        wsprintf(szTempBuff,"String Index: 0x%x",pValue->NotRange.StringIndex);
    } 
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (pValue->IsDesignatorRange) {

        wsprintf(szTempBuff,
                 "Designator Minimum: 0x%x, Max: 0x%x",
                 pValue->Range.DesignatorMin, 
                 pValue->Range.DesignatorMax);
    } 
    else {
        wsprintf(szTempBuff,"Designator Index: 0x%x",pValue->NotRange.DesignatorIndex);
    } 
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
 
    if (pValue->IsAbsolute) {
        SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) "Absolute: Yes");
    }
    else {
        SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) "Absolute: No");
    }
    return;
}

VOID 
vDisplayInputButtons(
    IN PHID_DEVICE pDevice,
    IN HWND hControl
)
{
    INT               iLoop;
    PHIDP_BUTTON_CAPS pButtonCaps;
    static CHAR       szTempBuff[128];
    INT               iIndex;

    SendMessage(hControl, LB_RESETCONTENT, 0, (LPARAM) 0);

    pButtonCaps = pDevice->InputButtonCaps;
    for (iLoop = 0; iLoop < pDevice->Caps.NumberInputButtonCaps; iLoop++) {

        wsprintf(szTempBuff, "Input button cap # %d", iLoop);

        iIndex = SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

        if (iIndex!=-1) {
            SendMessage(hControl, LB_SETITEMDATA, iIndex,(LPARAM) pButtonCaps);
        }

        pButtonCaps++;
    } 
    SendMessage(hControl, LB_SETCURSEL, 0, 0 );
}

VOID 
vDisplayOutputButtons(
   IN PHID_DEVICE pDevice,
   IN HWND hControl
)
{
    INT               iLoop;
    static CHAR       szTempBuff[128];
    INT               iIndex;
    PHIDP_BUTTON_CAPS pButtonCaps;

    SendMessage(hControl, LB_RESETCONTENT, 0, (LPARAM) 0);
    pButtonCaps = pDevice -> OutputButtonCaps;

    for (iLoop = 0; iLoop < pDevice->Caps.NumberOutputButtonCaps; iLoop++) {

         wsprintf(szTempBuff, "Output button cap # %d", iLoop);
         iIndex = SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

         if (-1 != iIndex) {
             SendMessage(hControl, LB_SETITEMDATA, iIndex, (LPARAM) pButtonCaps);
         }
         pButtonCaps++;
    }

    SendMessage(hControl, LB_SETCURSEL, 0, 0);
    return;
}

VOID 
vDisplayInputValues(
    IN PHID_DEVICE pDevice,
    IN HWND hControl
)
{
    INT              iLoop;
    static CHAR      szTempBuff[128];
    INT              iIndex;
    PHIDP_VALUE_CAPS pValueCaps;

    SendMessage(hControl, LB_RESETCONTENT, 0, 0);

    pValueCaps = pDevice -> InputValueCaps;
    for (iLoop=0; iLoop < pDevice->Caps.NumberInputValueCaps; iLoop++) {

        wsprintf(szTempBuff,"Input value cap # %d",iLoop);
        iIndex = SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

        if (-1 != iIndex) {
           SendMessage(hControl, LB_SETITEMDATA, iIndex,(LPARAM) pValueCaps);
        }
        pValueCaps++;
 
    }

    SendMessage(hControl, LB_SETCURSEL, 0, 0);
    return;
}

VOID
vDisplayOutputValues(
    IN PHID_DEVICE pDevice,
    IN HWND hControl)
{
    INT              iLoop;
    static CHAR      szTempBuff[128];
    INT              iIndex;
    PHIDP_VALUE_CAPS pValueCaps;
   
    SendMessage(hControl, LB_RESETCONTENT, 0, 0);
    pValueCaps = pDevice -> OutputValueCaps;
   
    for (iLoop = 0; iLoop < pDevice->Caps.NumberOutputValueCaps; iLoop++) {

        wsprintf(szTempBuff, "Output value cap # %d", iLoop);
        iIndex=SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
       
        if (-1 != iIndex) {
            SendMessage(hControl, LB_SETITEMDATA, iIndex, (LPARAM) pValueCaps);
        }
        pValueCaps++;
    }
    SendMessage(hControl,LB_SETCURSEL,0,0);
    return;
}

VOID
vDisplayFeatureButtons(
    IN PHID_DEVICE pDevice,
    IN HWND hControl
)
{
    INT               iLoop;
    static CHAR       szTempBuff[128];
    INT               iIndex;
    PHIDP_BUTTON_CAPS pButtonCaps;

    SendMessage(hControl, LB_RESETCONTENT, 0, 0);
    pButtonCaps = pDevice -> FeatureButtonCaps;

    for (iLoop = 0; iLoop < pDevice->Caps.NumberFeatureButtonCaps; iLoop++) {

        wsprintf(szTempBuff, "Feature button cap # %d", iLoop);
        iIndex = SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

        if (-1 != iIndex) {
            SendMessage(hControl, LB_SETITEMDATA, iIndex, (LPARAM) pButtonCaps);
        }
        pButtonCaps++;
    } 
    SendMessage(hControl, LB_SETCURSEL, 0, 0);
    return;
}

VOID
vDisplayFeatureValues(
    IN PHID_DEVICE pDevice,
    IN HWND hControl
)
{
    INT              iLoop;
    static CHAR      szTempBuff[128];
    INT              iIndex;
    PHIDP_VALUE_CAPS pValueCaps;

    SendMessage(hControl, LB_RESETCONTENT, 0, 0);
    pValueCaps = pDevice ->FeatureValueCaps;

    for (iLoop = 0; iLoop < pDevice->Caps.NumberFeatureValueCaps; iLoop++) {

        wsprintf(szTempBuff, "Feature value cap # %d", iLoop);
        iIndex = SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

        if (-1 != iIndex) {
            SendMessage(hControl, LB_SETITEMDATA, iIndex, (LPARAM) pValueCaps);
        }

        pValueCaps++;
    } 
    SendMessage(hControl, LB_SETCURSEL, 0, 0);
    return;
}

VOID
vLoadItemTypes(
    IN HWND hItemTypes
)
{
    INT iIndex;

    iIndex = SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "INPUT BUTTON");
    if (-1 != iIndex) {
    
        SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, INPUT_BUTTON);

        iIndex = SendMessage(hItemTypes, CB_ADDSTRING, 0 ,(LPARAM) "INPUT VALUE");
        if (-1 != iIndex) {
            SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, INPUT_VALUE);
        }

        iIndex = SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "OUTPUT BUTTON");
        if (-1 != iIndex) {
           SendMessage(hItemTypes,CB_SETITEMDATA,iIndex,OUTPUT_BUTTON);
        }

        iIndex = SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "OUTPUT VALUE");
        if (-1 != iIndex) {
            SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, OUTPUT_VALUE);
        }

        iIndex = SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "FEATURE BUTTON");
        if (-1 != iIndex) {
            SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, FEATURE_BUTTON);
        }

        iIndex = SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "FEATURE VALUE");
        if (-1 != iIndex) {
            SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, FEATURE_VALUE);
        }

        iIndex=SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "HID CAPS");
        if (-1 != iIndex ) {
            SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, HID_CAPS);
        }

        iIndex = SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "DEVICE ATTRIBUTES");
        if (-1 != iIndex) {
            SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, DEVICE_ATTRIBUTES);
        }

        SendMessage(hItemTypes, CB_SETCURSEL, 0, 0);
    }
} 

VOID vLoadDevices(
    HWND    hDeviceCombo
)
{
    PDEVICE_LIST_NODE   currNode;
    
    static CHAR szTempBuff[128];
    INT         iIndex;

    /*
    // Reset the content of the device list box.
    */

    SendMessage(hDeviceCombo, CB_RESETCONTENT, 0, 0);


    if (!IsListEmpty(&PhysicalDeviceList)) {

        currNode = (PDEVICE_LIST_NODE) GetListHead(&PhysicalDeviceList);
        
        do {

            wsprintf(szTempBuff,
                     "Device %d, UsagePage 0%x, Usage 0%x",
                     currNode -> HidDeviceInfo.HidDevice,
                     currNode -> HidDeviceInfo.Caps.UsagePage,
                     currNode -> HidDeviceInfo.Caps.Usage);

            iIndex = SendMessage(hDeviceCombo, CB_ADDSTRING, 0, (LPARAM) szTempBuff);

            if (CB_ERR != iIndex) {
                SendMessage(hDeviceCombo, CB_SETITEMDATA, iIndex, (LPARAM) &(currNode -> HidDeviceInfo));
            }

            currNode = (PDEVICE_LIST_NODE) GetNextEntry(currNode);
            
        } while ((PLIST) currNode != &PhysicalDeviceList);
       
    } 

    /*
    // Now we need to load any logical devices that might currently be in our
    //   logical device list 
    */

    if (!IsListEmpty(&LogicalDeviceList)) {

        currNode = (PDEVICE_LIST_NODE) GetListHead(&LogicalDeviceList) ;
        
        do {
                        
            wsprintf(szTempBuff,
                     "Device: Logical, UsagePage 0%x, Usage 0%x",
                     currNode -> HidDeviceInfo.Caps.UsagePage,
                     currNode -> HidDeviceInfo.Caps.Usage);

            iIndex = SendMessage(hDeviceCombo, CB_ADDSTRING, 0, (LPARAM) szTempBuff);

            if (CB_ERR != iIndex) {
                SendMessage(hDeviceCombo, CB_SETITEMDATA, iIndex, (LPARAM) &(currNode -> HidDeviceInfo));
            }

            currNode = (PDEVICE_LIST_NODE) GetNextEntry(currNode);
            
        } while ((PLIST) currNode != &LogicalDeviceList);
       
    }
   
    SendMessage(hDeviceCombo, CB_SETCURSEL, 0, 0);
  
    return;
}


BOOL
bGetData(
    prWriteDataStruct pItems,
    INT               iCount,
    HWND              hParent, 
    PCHAR             pszDialogName
)
{
    rGetWriteDataParams rParams;
    rWriteDataStruct    arTempItems[MAX_WRITE_ELEMENTS];
    INT                 iResult;


    if (iCount > MAX_WRITE_ELEMENTS) {
        iCount = MAX_WRITE_ELEMENTS;
    }

    memcpy( &(arTempItems[0]), pItems, sizeof(rWriteDataStruct)*iCount);

    rParams.iCount = iCount;
    rParams.prItems = &(arTempItems[0]);
    iResult = DialogBoxParam(hGInstance,
                             pszDialogName,
                             hParent,
                             bGetDataDlgProc,
                             (LPARAM) &rParams);
    if (iResult) {
        memcpy(pItems, arTempItems, sizeof(rWriteDataStruct)*iCount);
    }
    return iResult;
} 

BOOL CALLBACK 
bGetDataDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    static prWriteDataStruct    prData;
    static prGetWriteDataParams pParams;
    static INT                  iDisplayCount;
    static INT                  iScrollRange;
    static INT                  iCurrentScrollPos=0;
    static HWND                 hScrollBar;
           INT                  iTemp;
           SCROLLINFO           rScrollInfo;
           INT                  iReturn;

    switch(message) {
        case WM_INITDIALOG:
            pParams = (prGetWriteDataParams) lParam;
            prData = pParams -> prItems;
            hScrollBar = GetDlgItem(hDlg, IDC_SCROLLBAR);

            if (pParams -> iCount > CONTROL_COUNT) {
                iDisplayCount = CONTROL_COUNT;
                iScrollRange = pParams -> iCount - CONTROL_COUNT;
                rScrollInfo.fMask = SIF_RANGE | SIF_POS;
                rScrollInfo.nPos = 0;
                rScrollInfo.nMin = 0;
                rScrollInfo.nMax = iScrollRange;
                rScrollInfo.cbSize = sizeof(rScrollInfo);
                rScrollInfo.nPage = CONTROL_COUNT;
                iReturn = SetScrollInfo(hScrollBar,SB_CTL,&rScrollInfo,TRUE);
            }
            else {
                iDisplayCount=pParams->iCount;
                EnableWindow(hScrollBar,FALSE);
            }
            vWriteDataToControls(hDlg, prData, 0, pParams->iCount);
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam)) {
                case IDOK:
                case ID_SEND:
                    vReadDataFromControls(hDlg, prData, iCurrentScrollPos, iDisplayCount);
                    EndDialog(hDlg,1);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg,0);
                    break;
             } 
             break;

        case WM_VSCROLL:
            vReadDataFromControls(hDlg, prData, iCurrentScrollPos, iDisplayCount);

            switch(LOWORD(wParam)) {
                case SB_LINEDOWN:
                    ++iCurrentScrollPos;
                    break;

                case SB_LINEUP:
                    --iCurrentScrollPos;
                    break;

                case SB_THUMBPOSITION:
                    iCurrentScrollPos = HIWORD(wParam);

                case SB_PAGEUP:
                    iCurrentScrollPos -= CONTROL_COUNT;
                    break;

                case SB_PAGEDOWN:
                    iCurrentScrollPos += CONTROL_COUNT;
                    break;
            }

            if (iCurrentScrollPos < 0) {
                iCurrentScrollPos = 0;
            }
             
            if (iCurrentScrollPos > iScrollRange) {
                iCurrentScrollPos = iScrollRange; 
            }

            SendMessage(hScrollBar, SBM_SETPOS, iCurrentScrollPos, TRUE);
            iTemp = LOWORD(wParam);

            if ( (iTemp == SB_LINEDOWN) || (iTemp == SB_LINEUP) || (iTemp == SB_THUMBPOSITION)|| (iTemp == SB_PAGEUP) || (iTemp==SB_PAGEDOWN) ) {
                vWriteDataToControls(hDlg, prData, iCurrentScrollPos, iDisplayCount);
            }
            break; 
    } 
    return FALSE;
} /*end function bGetDataDlgProc*/

VOID
vReadDataFromControls(
    HWND hDlg,
    prWriteDataStruct prData,
    INT iOffset,
    INT iCount
)
{
    INT               iLoop;
    INT               iValueControlID = IDC_OUT_EDIT1;
    prWriteDataStruct pDataWalk;
    HWND              hValueWnd;

    pDataWalk = prData + iOffset;
    for (iLoop = 0; (iLoop < iCount) && (iLoop < CONTROL_COUNT); iLoop++) {

        hValueWnd = GetDlgItem(hDlg, iValueControlID);
        GetWindowText(hValueWnd, pDataWalk -> szValue, MAX_VALUE);
        iValueControlID++;
        pDataWalk++;

    } 

    return;
} 

VOID
vWriteDataToControls(
    HWND                hDlg,
    prWriteDataStruct   prData,
    INT                 iOffset,
    INT                 iCount
)
{
    INT               iLoop;
    INT               iLabelControlID = IDC_OUT_LABEL1;
    INT               iValueControlID = IDC_OUT_EDIT1;
    HWND              hLabelWnd, hValueWnd;
    prWriteDataStruct pDataWalk;

    pDataWalk = prData + iOffset;

    for (iLoop = 0; (iLoop < iCount) && (iLoop < CONTROL_COUNT); iLoop++) {

         hLabelWnd = GetDlgItem(hDlg, iLabelControlID);
         hValueWnd = GetDlgItem(hDlg, iValueControlID);
         
         ShowWindow(hLabelWnd, SW_SHOW);
         ShowWindow(hValueWnd, SW_SHOW);
         
         SetWindowText(hLabelWnd, pDataWalk -> szLabel);
         SetWindowText(hValueWnd, pDataWalk -> szValue);
         
         iLabelControlID++;
         iValueControlID++;
         pDataWalk++;
         
    } 
     
    /*
    // Hide the controls
    */

    for (; iLoop < CONTROL_COUNT; iLoop++) {
    
        hLabelWnd = GetDlgItem(hDlg,iLabelControlID);
        hValueWnd = GetDlgItem(hDlg,iValueControlID);
        
        ShowWindow(hLabelWnd,SW_HIDE);
        ShowWindow(hValueWnd,SW_HIDE);
        
        iLabelControlID++;
        iValueControlID++;
     } 
} 

VOID
vCreateUsageString(
    IN  PUSAGE   pUsageList,
    OUT CHAR     szString[]
)
{
    wsprintf(szString,
             "Usage: %#04x",
             *pUsageList
            );
    return;
}


VOID
vCreateUsageAndPageString(
    IN  PUSAGE_AND_PAGE pUsageList,
    OUT CHAR            szString[]
)
{
    wsprintf(szString,
             "Usage Page: %#04x  Usage: %#04x", 
             pUsageList -> UsagePage,
             pUsageList -> Usage
            );
    return;
}

VOID
vDisplayLinkCollectionNode(
    IN  PHIDP_LINK_COLLECTION_NODE  pLCNode,
    IN  ULONG                       ulLinkIndex,
    IN  HWND                        hControl
)
{
    static CHAR szTempBuff[128];

    wsprintf(szTempBuff, "Index: 0x%x", ulLinkIndex);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
    
    wsprintf(szTempBuff, "Usage Page: 0x%x", pLCNode -> LinkUsagePage);
    SendMessage(hControl, LB_ADDSTRING,0, (LPARAM)szTempBuff);

    wsprintf(szTempBuff, "Usage: 0x%x", pLCNode -> LinkUsage);
    SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff, "Parent Index: 0x%x", pLCNode -> Parent);
    SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff, "Number of Children: 0x%x", pLCNode -> NumberOfChildren);
    SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff, "Next Sibling: 0x%x", pLCNode -> NextSibling);
    SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) szTempBuff);

    wsprintf(szTempBuff, "First Child: 0x%x", pLCNode -> FirstChild);
    SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) szTempBuff);

    return;
}

VOID
vCreateUsageValueStringFromArray(
    PCHAR       pBuffer,
    USHORT      BitSize,
    USHORT      UsageIndex,
    CHAR        szString[]
)
/*++
Routine Description:
    Given a report buffer, pBuffer, this routine extracts the given usage
    at UsageIndex from the array and outputs to szString the string
    representation of that value.  The input parameter BitSize specifies
    the number of bits representing that value in the array.  This is
    useful for extracting individual members of a UsageValueArray.
--*/
{
    INT         iByteIndex;
    INT         iByteOffset;
    UCHAR       ucLeftoverBits;
    ULONG       ulMask;
    ULONG       ulValue;

    /*
    // Calculate the byte and byte offset into the buffer for the given
    //   index value
    */
    
    iByteIndex = (UsageIndex * BitSize) >> 3;
    iByteOffset = (UsageIndex * BitSize) & 7;

    /*
    // Extract the 32-bit value beginning at ByteIndex.  This value
    //   will contain some or all of the value we are attempting to retrieve
    */
    
    ulValue = *(PULONG) (pBuffer + iByteIndex);

    /*
    // Shift that value to the right by our byte offset..
    */
    
    ulValue = ulValue >> iByteOffset;

    /*
    // At this point, ulValue contains the first 32-iByteOffset bits beginning
    //    the appropriate offset in the buffer.  There are now two cases to 
    //    look at:
    //      
    //    1) BitSize > 32-iByteOffset -- In which case, we need to extract
    //                                   iByteOffset bits from the next
    //                                   byte in the array and OR them as
    //                                   the MSBs of ulValue
    //
    //    2) BitSize < 32-iByteOffset -- Need to get only the BitSize LSBs
    //                                   
    */

    /*
    // Case #1
    */
    
    if (BitSize > sizeof(ULONG)*8 - iByteOffset) {

        /*
        // Get the next byte of the report following the four bytes we
        //   retrieved earlier for ulValue
        */
        
        ucLeftoverBits =  *(pBuffer+iByteIndex+4);

        /*
        // Shift those bits to the left for anding to our previous value
        */
        
        ulMask = ucLeftoverBits << (24 + (8 - iByteOffset));
        ulValue |= ulMask;

    }
    else if (BitSize < sizeof(ULONG)*8 - iByteOffset) {

        /*
        // Need to mask the most significant bits that are part of another
        //    value(s), not the one we are currently working with.
        */
        
        ulMask = (1 << BitSize) - 1;
        ulValue &= ulMask;
    }
    
    /*
    // We've now got the correct value, now output to the string
    */

    wsprintf(szString, "Usage value: %lu", ulValue);

    return;
}

BOOL
RegisterHidDevice(
    IN  HWND                WindowHandle,
    IN  PDEVICE_LIST_NODE   DeviceNode
)
{
    DEV_BROADCAST_HANDLE broadcastHandle;
    
    broadcastHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
    broadcastHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
    broadcastHandle.dbch_handle =  DeviceNode -> HidDeviceInfo.HidDevice;

    DeviceNode -> NotificationHandle = RegisterDeviceNotification( 
                                                WindowHandle,
                                                &broadcastHandle,
                                                DEVICE_NOTIFY_WINDOW_HANDLE
                                              );

    return (DeviceNode != NULL);
}   

VOID
DestroyDeviceListCallback(
    PLIST_NODE_HDR   ListNode
)
{
    PDEVICE_LIST_NODE   deviceNode;
    

    deviceNode = (PDEVICE_LIST_NODE) ListNode;
    
    /*
    // The callback function needs to do the following steps...
    //   1) Close the HidDevice
    //   2) Unregister device notification (if registered)
    //   3) Free the allocated memory block
    */

    CloseHidDevice(&(deviceNode -> HidDeviceInfo));

    if (NULL != deviceNode -> NotificationHandle) 
        UnregisterDeviceNotification(deviceNode -> NotificationHandle);

    free (deviceNode);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\list.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    list.h

Abstract:

    This module contains public macro definitions for creating and
    manipulating doubly-linked lists.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef __LIST_H__
#define __LIST_H__

#include <windows.h>

typedef LIST_ENTRY      LIST_NODE_HDR, *PLIST_NODE_HDR;
typedef LIST_NODE_HDR   LIST, *PLIST;

typedef VOID PLIST_CALLBACK(PLIST_NODE_HDR);

VOID
InitializeList(
    IN  PLIST   NewList
);

VOID
InsertHead(
    IN  PLIST           List,
    IN  PLIST_NODE_HDR  ListNode
);

VOID
InsertTail(
    IN  PLIST           List,
    IN  PLIST_NODE_HDR  ListNode
);

VOID
RemoveNode(
    IN  PLIST_NODE_HDR  ListNode   
);

PLIST_NODE_HDR
RemoveHead(
    IN  PLIST   List
);

PLIST_NODE_HDR
RemoveTail(
    IN  PLIST   List
);

BOOL
IsListEmpty(
    IN  PLIST   List
);

PLIST_NODE_HDR
GetListHead(
    IN  PLIST   List
);

PLIST_NODE_HDR
GetListTail(
    IN  PLIST   List
);

PLIST_NODE_HDR
GetNextEntry(
    IN  PLIST_NODE_HDR  ListNode
);

PLIST_NODE_HDR
GetPrevEntry(
    IN  PLIST_NODE_HDR  ListNode
);

VOID
DestroyListNoCallback(
    IN  PLIST           List
);

VOID
DestroyListWithCallback(
    IN  PLIST           List,
    IN  PLIST_CALLBACK  Callback
);


/*****************************************************************************
/* Macro definitions of list functions
/*****************************************************************************/

#ifdef USE_MACROS

    /*
    // VOID
    // InitializeList(
    //     IN  PLIST    NewList
    // );
    */
    
    #define InitializeList(nl) \
        { ((PLIST)(nl)) -> Flink = ((PLIST)(nl)) -> Blink = nl; }
    
    /* 
    // VOID
    // InsertHead(
    //     IN  PLIST            List,
    //     IN  PLIST_NODE_HDR   ListNode
    // );
    */
    
    #define InsertHead(List, Node) {                    \
        PLIST_NODE_HDR _EX_Flink;                       \
        PLIST_NODE_HDR _EX_List;                        \
                                                        \
        _EX_List = ((PLIST_NODE_HDR) (List));           \
        _EX_Flink = _EX_List -> Flink;                  \
        ((PLIST_NODE_HDR) (Node))->Blink = _EX_List;    \
        ((PLIST_NODE_HDR) (Node))->Flink = _EX_Flink;   \
        _EX_Flink->Blink = (((PLIST_NODE_HDR) (Node))); \
        _EX_List->Flink = ((PLIST_NODE_HDR) (Node));    \
    }
    
    
    /* 
    // VOID
    // InsertTail(
    //     IN  PLIST            List,
    //     IN  PLIST_NODE_HDR   ListNode
    // );
    */
    
    #define InsertTail(List, Node) {                    \
        PLIST_NODE_HDR _EX_Blink;                       \
        PLIST_NODE_HDR _EX_List;                        \
                                                        \
        _EX_List = ((PLIST_NODE_HDR) (List));           \
        _EX_Blink = _EX_List->Blink;                    \
        ((PLIST_NODE_HDR) (Node))->Flink = _EX_List;    \
        ((PLIST_NODE_HDR) (Node))->Blink = _EX_Blink;   \
        _EX_Blink->Flink = (((PLIST_NODE_HDR) (Node))); \
        _EX_List->Blink = ((PLIST_NODE_HDR) (Node));    \
    }
    
    /*
    //  VOID
    //  RemoveNode(
    //      IN  PLIST_NODE_HDR  ListNode   
    //  );
    */
    
    #define RemoveNode(node) {                          \
        PLIST_NODE_HDR _EX_Blink;                       \
        PLIST_NODE_HDR _EX_Flink;                       \
                                                        \
        _EX_Flink = ((PLIST_NODE_HDR) (node))->Flink;   \
        _EX_Blink = ((PLIST_NODE_HDR) (node))->Blink;   \
        _EX_Blink->Flink = _EX_Flink;                   \
        _EX_Flink->Blink = _EX_Blink;                   \
    }
    
    
    /* 
    // PLIST_NODE_HDR
    // RemoveHead(
    //     IN  PLIST    List
    // );               
    */                  
    
    #define RemoveHead(List)                            \
        GetListHead((List));                            \
        RemoveNode(((PLIST_NODE_HDR) (List))->Flink)  
                        
    /*                  
    // PLIST_NODE_HDR   
    // RemoveTail(      
    //     IN  PLIST    List
    // );               
    */                  
    
    #define RemoveTail(List)                            \
        GetListTail((List));                            \
        RemoveNode(((PLIST_NODE_HDR) (List))->Blink)    
    
    /*                  
    // BOOL             
    // IsListEmpty(     
    //     IN  PLIST    List
    // );               
    */                  
    
    #define IsListEmpty(List)                           \
        (((PLIST_NODE_HDR) (List))->Flink == ((PLIST_NODE_HDR) (List)))
                        
    /*                  
    // PLIST_NODE_HDR   
    // GetListHead(     
    //     IN  PLIST    List
    // );               
    */                  
    
    #define GetListHead(List)                           \
        (((PLIST_NODE_HDR) (List))->Flink);
    
    /*                  
    // PLIST_NODE_HDR   
    // GetListTail(     
    //     IN  PLIST    List
    // );               
    */                  
    
    #define GetListTail(List)                           \
        (((PLIST_NODE_HDR)) (List))->Blink;
                        

    /*
    // PLIST_NODE_HDR
    // GetNextEntry(
    //    IN  PLIST_NODE_HDR  ListNode
    // );
    */

    #define GetNextEntry(ListNode)                      \
        (((PLIST_NODE_HDR) (ListNode)) -> Flink);

    /* 
    // PLIST_NODE_HDR
    // GetPrevEntry(
    //    IN  PLIST_NODE_HDR  ListNode
    // );
    */

    #define GetPrevEntry(ListNode)                      \
        (((PLIST_NODE_HDR) (ListNode)) -> Blink);

    /* 
    // VOID
    // DestroyListNoCallback(
    //     IN  PLIST           List,
    //     IN  PLIST_CALLBACK  Callback
    // );
    */ 
    
    #define DestroyListNoCallback(list)                 \
        PLIST_NODE_HDR  currNode;                       \
                                                        \
        while (!IsListEmpty((list))) {                  \
            currNode = RemoveHead((list));              \
        }                                               \
    }

    /* 
    // VOID
    // DestroyListWithCallback(
    //     IN  PLIST           List,
    //     IN  PLIST_CALLBACK  Callback
    // );
    */ 
    
    #define DestroyListWithCallback(list, cb) {         \
        PLIST_NODE_HDR  currNode;                       \
                                                        \
        while (!IsListEmpty((list))) {                  \
            currNode = RemoveHead((list));              \
            (cb)(currNode);                             \
        }                                               \
    }
    
    #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\logpnp.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    logpnp.c

Abstract:

    This module contains the code for finding, loading and building logical
    hid device structures to be used for extended client calls.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef __LOGPNP_C__
#define __LOGPNP_C__
#endif

#include <windows.h>
#include <wtypes.h>
#include <commdlg.h>
#include "hid.h"
#include "debug.h"
#include "logpnp.h"

#define  OPENFILE_FILTER    "Preparsed Data Files\0*.PPD\0"

CHAR     LogPnP_PpdFileName[MAX_PATH+1];

BOOL
LogPnP_BuildLogicalHIDDevice(
    IN     PHIDP_PREPARSED_DATA HidPpd,
    IN OUT PHID_DEVICE          HidDevice
);

VOID
LogPnP_CloseLogicalDevice(
    IN  PHID_DEVICE LogicalDevice
);

BOOL
LogPnP_LoadLogicalDevice(
    IN     PCHAR        OptFileName,
    IN OUT PHID_DEVICE  HidDevice  
)
/*++
RoutineDescription:
    This routine creates a HidDevice object that corresponds to a "logical" device
    A logical device is actually preparsed data that has been saved to disk.  The 
    most common method of saving preparsed data to disk is using that feature in a
    post 3.0 version of HIDView after retrieving/parsing with report descriptor with
    the OS provided parser.  Because the preparsed data structure is available, 
    all of the HidP_Xxx routines can be used.

    OptFileName is an optional file name to specify.  If it is NULL, an OPENFILE
    dialog box is displayed to allow the user to select which Ppd structure to
    load.

    Return value indicates the success or failure of the device load
--*/
{
    OPENFILENAME         OpenInfo;
    BOOL                 Result;
    PHIDP_PREPARSED_DATA PpdBuffer;
    ULONG                PpdLength;

    /*
    // LoadLogicalDevice consists of three steps. 
    //   First it builds the structure needed to get the filename and calls
    //    the standard LoadFile dialog box.
    //
    //   Then it uses that file name to get the Preparsed Data that is stored 
    //       on disk.
    //  
    //   Lastly, it fills in the the HidDevice Info block to create the logical
    //       device
    */

    if (NULL == HidDevice) {
        return (FALSE);
    }

    if (NULL != OptFileName) {
        strcpy(LogPnP_PpdFileName, OptFileName);
    }

    else {
        /*
        // Initialize the OpenInfo structure
        */
        
        LogPnP_PpdFileName[0] = '\0';
        
        OpenInfo.lStructSize = sizeof(OPENFILENAME);
        OpenInfo.hwndOwner = GetTopWindow(NULL);
        OpenInfo.hInstance = NULL;
        OpenInfo.lpstrFilter = OPENFILE_FILTER;
        OpenInfo.lpstrCustomFilter = NULL;
        OpenInfo.nMaxCustFilter = 0;
        OpenInfo.nFilterIndex = 1;
        OpenInfo.lpstrFile = LogPnP_PpdFileName;
        OpenInfo.nMaxFile = MAX_PATH+1;
        OpenInfo.lpstrFileTitle = NULL;
        OpenInfo.nMaxFileTitle = 0;
        OpenInfo.lpstrInitialDir = NULL;
        OpenInfo.lpstrTitle = "Load Preparsed Data File";
        OpenInfo.Flags = OFN_PATHMUSTEXIST;
        OpenInfo.nFileOffset = 0;
        OpenInfo.nFileExtension = 0;
        OpenInfo.lpstrDefExt = "PPD";
        OpenInfo.lCustData = 0;
        OpenInfo.lpfnHook = NULL;
        OpenInfo.lpTemplateName = NULL;
        
        /*
        // Call the open dialog box routine
        */
        
        Result = GetOpenFileName(&OpenInfo);
        
        if (!Result) {
            return (FALSE);
        }
    }
    /*
    // At this point, we should have a valid path and filename stored in 
    //  LogPnP_PpdFileName.  Next step is to load the prepased data from 
    //  that file
    */

    Result = LogPnP_LoadPpdFromFile(LogPnP_PpdFileName,
                                    &PpdBuffer,
                                    &PpdLength
                                   );

    if (!Result) {
        return (FALSE);
    }

    /*
    // Now, we've opened the file, got the preparsed data into our buffer and
    //   closed the file.  We probably want to verify the Preparsed Data
    //   somehow at this point.  Since I'm not sure exactly how I want to do
    //   this and time is of the essence, I'm skipping that for now.
    */

    Result = LogPnP_BuildLogicalHIDDevice(PpdBuffer,
                                          HidDevice
                                         );

    if (!Result) {
        FREE(PpdBuffer);
        return (FALSE);
    }

    /*
    // Hey, we've gotten all the way to the end and have succeeded.  Return (TRUE);
    */

    return (TRUE);
}

BOOL
LogPnP_BuildLogicalHIDDevice(
    IN     PHIDP_PREPARSED_DATA HidPpd,
    IN OUT PHID_DEVICE          HidDevice
)
/*++
RoutineDescription:
    This routine fills in all the data fields of a HID_DEVICE structure that are
    related to logical devices.  In other words, everything but a file handle and
    the attributes structure.

    It returns FALSE if for some reason, it cannot accoomplish its assigned task.
--*/
{
    HidDevice -> HidDevice = INVALID_HANDLE_VALUE;
    HidDevice -> Ppd = HidPpd;

    if (!HidP_GetCaps (HidDevice->Ppd, &HidDevice->Caps)) {
        return FALSE;
    }
    
    FillMemory(&(HidDevice -> Attributes), sizeof(HIDD_ATTRIBUTES), 0x00 );

    FillDeviceInfo(HidDevice);
    return (TRUE);
}

BOOL
LogPnP_LoadPpdFromFile(
    IN  PCHAR       FileName,
    OUT PHIDP_PREPARSED_DATA   *PpdBuffer,
    OUT PULONG  PpdBufferLength
)
/*++
RoutineDescription:
    This routine takes the passed in filename, opens it for read, and reads the
    preparsed data structure from the file.  It determines the size of the
    parparsed data based on the size of the file so no extraneous bytes should
    be added to preparsed data blocks without modifying this routine.

    This routine will return TRUE if everything goes as planned, FALSE otherwise
--*/
{
    HANDLE  FileHandle;
    BOOL    ReadStatus;
    DWORD   FileSize;
    DWORD   BytesRead;

    *PpdBuffer = NULL;
    *PpdBufferLength = 0;

    FileHandle = CreateFile(FileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL
                           );

    if (INVALID_HANDLE_VALUE == FileHandle) {
        return (FALSE);
    }

    /*
    // Call GetFileSize to get the size of the file so we know how many
    //   bytes we need to allocate for the preparsed data buffer.  
    //   GetFileSize returns 0xFFFFFFFF on error, so that gets checked as
    //   well after the call is made
    */

    FileSize = GetFileSize(FileHandle, NULL);
                                
    if (0xFFFFFFFF == FileSize) {
        CloseHandle(FileHandle);
        return (FALSE);
    }

    /*
    // Now, let's allocate the buffer space needed to store the preparsed data
    //  in the file
    */

    *PpdBuffer = (PHIDP_PREPARSED_DATA) ALLOC(FileSize);

    if (NULL == *PpdBuffer) {
        CloseHandle(FileHandle);
        return (FALSE);
    }

    /*
    // OK, the buffer has been allocated, let's read in our data from the file
    */

    ReadStatus = ReadFile(FileHandle,
                          *PpdBuffer,
                          FileSize,
                          &BytesRead,
                          NULL
                         );

    /*
    // We are done with the file handle now, so let's close it before we 
    //   proceed any farther.
    */

    CloseHandle(FileHandle);

    if (BytesRead != FileSize || !ReadStatus) {
        FREE(*PpdBuffer);
        *PpdBuffer = NULL;
        return (FALSE);
    }

    /*
    // If we got to this point, everything is perfect.  Close the file handle
    //   and set the size of the buffer and return TRUE.
    */

    *PpdBufferLength = FileSize;
    return (TRUE);
}

VOID
LogPnP_CloseLogicalHIDDevices(
    IN  PHID_DEVICE LogicalDeviceList,
    IN  ULONG       NumLogicalDevices
)
/*++
RoutineDescription:
    This routine takes a list of HID_DEVICE structures that are all logical 
    devices and frees up any resources that were associated with the given 
    logical device.
--*/
{
    ULONG Index;

    for (Index = 0; Index < NumLogicalDevices; Index++) {
        LogPnP_CloseLogicalDevice(LogicalDeviceList+Index);
    }

    return;
}

VOID
LogPnP_CloseLogicalDevice(
    IN  PHID_DEVICE LogicalDevice
)
/*++
RoutineDescription:
    This routine performs the task of freeing up the resources of HID_DEVICE 
    structure for a given logical device.
--*/
{
    /*
    // To close the logical device, we need to undo all that was done by
    //    the FillDeviceInfo routine.  This can be accomplished by calling
    //    CloseHidDevice.  However, for this to succeed we need to free the 
    //    preparsed data itself because it was not allocated by HID.DLL.  
    //    Therefore, we cannot call HidD_FreePreparsedData.  Instead, we free
    //    it ourselves and set it to NULL so that won't attempt to free it 
    //    in the close routine
    */

    FREE(LogicalDevice -> Ppd);
    LogicalDevice -> Ppd = NULL;

    CloseHidDevice(LogicalDevice);
    return;
}

BOOL
LogPnP_IsLogicalDevice(
    IN  PHID_DEVICE HidDevice
)
/*++
RoutineDescription:
    This routine returns TRUE if the passed in HID_DEVICE structure is a logical
    device and FALSE if it is a physical device.
--*/
{
    /*
    // In the current implementation, a HID_DEVICE block is marked as a logical
    //    device by setting the HidDevice field of the block to INVALID_HANDLE_VALUE
    */

    return (INVALID_HANDLE_VALUE == HidDevice -> HidDevice);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\hclient.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    hclient.h

Abstract:

    This module contains the public declarations and definitions that are
    defined in hclient.c and available to other modules outside of it.
              
Environment:

    User mode

Revision History:

    Nov-97 : Created 

--*/

#ifndef __HCLIENT_H__
#define __HCLIENT_H__

VOID
vDisplayDeviceAttributes(
    IN PHIDD_ATTRIBUTES pAttrib,
    IN HWND             hControl
);

VOID
vDisplayButtonAttributes(
    IN PHIDP_BUTTON_CAPS pButton,
    IN HWND              hControl
);

VOID
vDisplayDataAttributes(
    PHIDP_DATA pData, 
    BOOL IsButton, 
    HWND hControl
);

VOID
vCreateUsageAndPageString(
    IN  PUSAGE_AND_PAGE   pUsageList,
    OUT CHAR              szString[]
);

VOID
vCreateUsageString(
    IN  PUSAGE   pUsageList,
    OUT CHAR     szString[]
);

VOID
vDisplayDeviceCaps(
    IN PHIDP_CAPS pCaps,
    IN HWND       hControl
);

VOID 
vDisplayValueAttributes(
    IN PHIDP_VALUE_CAPS pValue,
    IN HWND             hControl
);

VOID
vDisplayLinkCollectionNode(
    IN  PHIDP_LINK_COLLECTION_NODE  pLCNode,
    IN  ULONG                       ulLinkIndex,
    IN  HWND                        hControl
);

VOID
vCreateUsageValueStringFromArray(
    PCHAR       pBuffer,
    USHORT      BitSize,
    USHORT      UsageIndex,
    CHAR        szString[]
);

VOID 
vDisplayValueAttributes(
    IN PHIDP_VALUE_CAPS pValue,
    IN HWND hControl
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\report.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    report.c

Abstract:

    This module contains the code for reading/writing hid reports and 
    translating those HID reports into useful information. 

Environment:

    User mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    report.c

Abstract:

    This module contains the code for translating HID reports to something
    useful.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#include <stdlib.h>
#include <wtypes.h>
#include "hidsdi.h"
#include "hid.h"

BOOLEAN
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );

BOOLEAN
PackReport (
   OUT      PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );

BOOLEAN
Read (
   PHID_DEVICE    HidDevice
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, obtain a read report and unpack the values
   into the InputData array.
--*/
{
    DWORD    bytesRead;

    if (!ReadFile (HidDevice->HidDevice,
                  HidDevice->InputReportBuffer,
                  HidDevice->Caps.InputReportByteLength,
                  &bytesRead,
                  NULL)) { // No overlapped structure.  HidClass buffers for us.
        return FALSE;
    }

    ASSERT (bytesRead == hidDevice->Caps.InputReportByteLength);

    return UnpackReport (HidDevice->InputReportBuffer,
                         HidDevice->Caps.InputReportByteLength,
                         HidP_Input,
                         HidDevice->InputData,
                         HidDevice->InputDataLength,
                         HidDevice->Ppd);
}

BOOLEAN
Write (
   PHID_DEVICE    HidDevice
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, take the information in the HID_DATA array
   pack it into multiple write reports and send each report to the HID device
--*/
{
    DWORD     bytesWritten;
    PHID_DATA pData;
    ULONG     Index;
    BOOLEAN   Status;
    BOOLEAN   WriteStatus;

    /*
    // Begin by looping through the HID_DEVICE's HID_DATA structure and setting
    //   the IsDataSet field to FALSE to indicate that each structure has
    //   not yet been set for this Write call.
    */

    pData = HidDevice -> OutputData;

    for (Index = 0; Index < HidDevice -> OutputDataLength; Index++, pData++) {
        pData -> IsDataSet = FALSE;
    }

    /*
    // In setting all the data in the reports, we need to pack a report buffer
    //   and call WriteFile for each report ID that is represented by the 
    //   device structure.  To do so, the IsDataSet field will be used to 
    //   determine if a given report field has already been set.
    */

    Status = TRUE;

    pData = HidDevice -> OutputData;
    for (Index = 0; Index < HidDevice -> OutputDataLength; Index++, pData++) {

        if (!pData -> IsDataSet) {

            /*
            // Package the report for this data structure.  PackReport will
            //    set the IsDataSet fields of this structure and any other 
            //    structures that it includes in the report with this structure
            */

            PackReport (HidDevice->OutputReportBuffer,
                     HidDevice->Caps.OutputReportByteLength,
                     HidP_Output,
                     pData,
                     HidDevice->OutputDataLength - Index,
                     HidDevice->Ppd);

            /*
            // Now a report has been packaged up...Send it down to the device
            */

            WriteStatus = WriteFile (HidDevice->HidDevice,
                                  HidDevice->OutputReportBuffer,
                                  HidDevice->Caps.OutputReportByteLength,
                                  &bytesWritten,
                                  NULL) && (bytesWritten == HidDevice -> Caps.OutputReportByteLength);

            Status = Status && WriteStatus;                         
        }
    }
    return (Status);
}

BOOLEAN
SetFeature (
    PHID_DEVICE    HidDevice
    )
/*++
RoutineDescription:
Given a struct _HID_DEVICE, take the information in the HID_DATA array
pack it into multiple reports and send it to the hid device via HidD_SetFeature()
--*/
{
    PHID_DATA pData;
    ULONG     Index;
    BOOLEAN   Status;
    BOOLEAN   FeatureStatus;
    DWORD     ErrorCode;
    /*
    // Begin by looping through the HID_DEVICE's HID_DATA structure and setting
    //   the IsDataSet field to FALSE to indicate that each structure has
    //   not yet been set for this SetFeature() call.
    */

    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) {
        pData -> IsDataSet = FALSE;
    }

    /*
    // In setting all the data in the reports, we need to pack a report buffer
    //   and call WriteFile for each report ID that is represented by the 
    //   device structure.  To do so, the IsDataSet field will be used to 
    //   determine if a given report field has already been set.
    */

    Status = TRUE;

    pData = HidDevice -> FeatureData;
    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) {

        if (!pData -> IsDataSet) {

            /*
            // Package the report for this data structure.  PackReport will
            //    set the IsDataSet fields of this structure and any other 
            //    structures that it includes in the report with this structure
            */

            PackReport (HidDevice->FeatureReportBuffer,
                     HidDevice->Caps.FeatureReportByteLength,
                     HidP_Feature,
                     pData,
                     HidDevice->FeatureDataLength - Index,
                     HidDevice->Ppd);

            /*
            // Now a report has been packaged up...Send it down to the device
            */

            FeatureStatus =(HidD_SetFeature (HidDevice->HidDevice,
                                          HidDevice->FeatureReportBuffer,
                                          HidDevice->Caps.FeatureReportByteLength));

            ErrorCode = GetLastError();

            Status = Status && FeatureStatus;
        }
    }
    return (Status);
}

BOOLEAN
GetFeature (
   PHID_DEVICE    HidDevice
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, fill in the feature data structures with
   all features on the device.  May issue multiple HidD_GetFeature() calls to
   deal with multiple report IDs.
--*/
{
    ULONG     Index;
    PHID_DATA pData;
    BOOL      FeatureStatus;
    BOOL      Status;

    /*
    // As with writing data, the IsDataSet value in all the structures should be
    //    set to FALSE to indicate that the value has yet to have been set
    */

    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) {

      pData -> IsDataSet = FALSE;

    }

    /*
    // Next, each structure in the HID_DATA buffer is filled in with a value
    //   that is retrieved from one or more calls to HidD_GetFeature.  The 
    //   number of calls is equal to the number of reportIDs on the device
    */

    Status = TRUE; 
    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) {
       
        /*
        // If a value has yet to have been set for this structure, build a report
        //    buffer with its report ID as the first byte of the buffer and pass
        //    it in the HidD_GetFeature call.  Specifying the report ID in the
        //    first specifies which report is actually retrieved from the device.
        //    The rest of the buffer should be zeroed before the call
        */

        if (!pData -> IsDataSet) {

            memset(HidDevice -> FeatureReportBuffer, 0x00, HidDevice->Caps.FeatureReportByteLength);

            HidDevice -> FeatureReportBuffer[0] = (UCHAR) pData -> ReportID;

            FeatureStatus = HidD_GetFeature (HidDevice->HidDevice,
                                              HidDevice->FeatureReportBuffer,
                                              HidDevice->Caps.FeatureReportByteLength);

            /*
            // If the return value is TRUE, scan through the rest of the HID_DATA
            //    structures and fill whatever values we can from this report
            */


            if (FeatureStatus) {

                FeatureStatus = UnpackReport ( HidDevice->FeatureReportBuffer,
                                           HidDevice->Caps.FeatureReportByteLength,
                                           HidP_Feature,
                                           HidDevice->FeatureData,
                                           HidDevice->FeatureDataLength,
                                           HidDevice->Ppd
                                         );

            }

            Status = Status && FeatureStatus;
        }
   }

   return Status;
}


BOOLEAN
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   )
/*++
Routine Description:
   Given ReportBuffer representing a report from a HID device where the first
   byte of the buffer is the report ID for the report, extract all the HID_DATA
   in the Data list from the given report.
--*/
{
    ULONG       numUsages; // Number of usages returned from GetUsages.
    ULONG       i;
    UCHAR       reportID;
    ULONG       Index;
    ULONG       nextUsage;

    reportID = ReportBuffer[0];

    for (i = 0; i < DataLength; i++, Data++) {

        if (reportID == Data->ReportID) {

            if (Data->IsButtonData) {
                numUsages = Data->ButtonData.MaxUsageLength;
                Data->Status = HidP_GetUsages (
                                               ReportType,
                                               Data->UsagePage,
                                               0, // All collections
                                               Data->ButtonData.Usages,
                                               &numUsages,
                                               Ppd,
                                               ReportBuffer,
                                               ReportBufferLength);


                //
                // Get usages writes the list of usages into the buffer
                // Data->ButtonData.Usages newUsage is set to the number of usages
                // written into this array.
                // A usage cannot not be defined as zero, so we'll mark a zero
                // following the list of usages to indicate the end of the list of
                // usages
                //
                // NOTE: One anomaly of the GetUsages function is the lack of ability
                //        to distinguish the data for one ButtonCaps from another
                //        if two different caps structures have the same UsagePage
                //        For instance:
                //          Caps1 has UsagePage 07 and UsageRange of 0x00 - 0x167
                //          Caps2 has UsagePage 07 and UsageRange of 0xe0 - 0xe7
                //
                //        However, calling GetUsages for each of the data structs
                //          will return the same list of usages.  It is the 
                //          responsibility of the caller to set in the HID_DEVICE
                //          structure which usages actually are valid for the
                //          that structure. 
                //      

                /*
                // Search through the usage list and remove those that 
                //    correspond to usages outside the define ranged for this
                //    data structure.
                */
                
                for (Index = 0, nextUsage = 0; Index < numUsages; Index++) {

                    if (Data -> ButtonData.UsageMin <= Data -> ButtonData.Usages[Index] && 
                            Data -> ButtonData.Usages[Index] <= Data -> ButtonData.UsageMax) {

                        Data -> ButtonData.Usages[nextUsage++] = Data -> ButtonData.Usages[Index];
                        
                    }
                }

                if (nextUsage < Data -> ButtonData.MaxUsageLength) {
                    Data->ButtonData.Usages[nextUsage] = 0;
                }
            }
            else {
                Data->Status = HidP_GetUsageValue (
                                                ReportType,
                                                Data->UsagePage,
                                                0,               // All Collections.
                                                Data->ValueData.Usage,
                                                &Data->ValueData.Value,
                                                Ppd,
                                                ReportBuffer,
                                                ReportBufferLength);

                Data->Status = HidP_GetScaledUsageValue (
                                                       ReportType,
                                                       Data->UsagePage,
                                                       0, // All Collections.
                                                       Data->ValueData.Usage,
                                                       &Data->ValueData.ScaledValue,
                                                       Ppd,
                                                       ReportBuffer,
                                                       ReportBufferLength);
            } 
            Data -> IsDataSet = TRUE;
        }
    }
    return (TRUE);
}


BOOLEAN
PackReport (
   OUT      PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   )
/*++
Routine Description:
   This routine takes in a list of HID_DATA structures (DATA) and builds 
      in ReportBuffer the given report for all data values in the list that 
      correspond to the report ID of the first item in the list.  

   For every data structure in the list that has the same report ID as the first
      item in the list will be set in the report.  Every data item that is 
      set will also have it's IsDataSet field marked with TRUE.

   A return value of FALSE indicates an unexpected error occurred when setting
      a given data value.  The caller should expect that assume that no values
      within the given data structure were set.

   A return value of TRUE indicates that all data values for the given report
      ID were set without error.
--*/
{
    ULONG       numUsages; // Number of usages to set for a given report.
    ULONG       i;
    ULONG       CurrReportID;

    /*
    // All report buffers that are initially sent need to be zero'd out
    */

    memset (ReportBuffer, (UCHAR) 0, ReportBufferLength);

    /*
    // Go through the data structures and set all the values that correspond to
    //   the CurrReportID which is obtained from the first data structure 
    //   in the list
    */

    CurrReportID = Data -> ReportID;

    for (i = 0; i < DataLength; i++, Data++) {

        /*
        // There are two different ways to determine if we set the current data
        //    structure: 
        //    1) Store the report ID were using and only attempt to set those
        //        data structures that correspond to the given report ID.  This
        //        example shows this implementation.
        //
        //    2) Attempt to set all of the data structures and look for the 
        //        returned status value of HIDP_STATUS_INVALID_REPORT_ID.  This 
        //        error code indicates that the given usage exists but has a 
        //        different report ID than the report ID in the current report 
        //        buffer
        */

        if (Data -> ReportID == CurrReportID) {

            if (Data->IsButtonData) {
             numUsages = Data->ButtonData.MaxUsageLength;
             Data->Status = HidP_SetUsages (
                              ReportType,
                              Data->UsagePage,
                              0, // All collections
                              Data->ButtonData.Usages,
                              &numUsages,
                              Ppd,
                              ReportBuffer,
                              ReportBufferLength);
            } else {
             Data->Status = HidP_SetUsageValue (
                                 ReportType,
                                 Data->UsagePage,
                                 0, // All Collections.
                                 Data->ValueData.Usage,
                                 Data->ValueData.Value,
                                 Ppd,
                                 ReportBuffer,
                                 ReportBufferLength);
            }

            if (HIDP_STATUS_SUCCESS != Data->Status)
            {
              return FALSE;
            }
        }
    }   

    /*
    // At this point, all data structures that have the same ReportID as the
    //    first one will have been set in the given report.  Time to loop 
    //    through the structure again and mark all of those data structures as
    //    having been set.
    */

    for (i = 0; i < DataLength; i++, Data++) {

        if (CurrReportID == Data -> ReportID) {

            Data -> IsDataSet = TRUE;

        }
   }
   return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\strings.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    strings.h

Abstract:

    This module contains the public function definitions for the routines
    in strings.c that handle conversion of integer/data buffer to/from 
    string represenation

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef __STRINGS_H__
#define __STRINGS_H__

VOID
Strings_CreateDataBufferString(
    IN  PCHAR    DataBuffer,
    IN  ULONG    DataBufferLength,
    IN  ULONG    NumBytesToDisplay,
    IN  ULONG    DisplayBlockSize,
    OUT PCHAR    *BufferString
);

VOID
Strings_StringToUnsigned(
    IN  PCHAR   InString,
    IN  ULONG   Base,
    OUT PCHAR   *endp,
    OUT PULONG  pValue
);

BOOL
Strings_StringToUnsignedList(
    IN  PCHAR   InString,
    IN  ULONG   UnsignedSize,
    IN  ULONG   Base,
    OUT PCHAR   *UnsignedList,
    OUT PULONG  nUnsigneds
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\hid.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    hid.h

Abstract:

    This module contains the declarations and definitions for use with the
    hid user mode client sample driver.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#ifndef HID_H
#define HID_H

#include "hidsdi.h"
#include "setupapi.h"

#define ASSERT(x)

//
// A structure to hold the steady state data received from the hid device.
// Each time a read packet is received we fill in this structure.
// Each time we wish to write to a hid device we fill in this structure.
// This structure is here only for convenience.  Most real applications will
// have a more efficient way of moving the hid data to the read, write, and
// feature routines.
//
typedef struct _HID_DATA {
   BOOLEAN     IsButtonData;
   UCHAR       Reserved;
   USAGE       UsagePage;   // The usage page for which we are looking.
   ULONG       Status;      // The last status returned from the accessor function
                            // when updating this field.
   ULONG       ReportID;    // ReportID for this given data structure
   BOOLEAN     IsDataSet;   // Variable to track whether a given data structure
                            //  has already been added to a report structure

   union {
      struct {
         ULONG       UsageMin;       // Variables to track the usage minimum and max
         ULONG       UsageMax;       // If equal, then only a single usage
         ULONG       MaxUsageLength; // Usages buffer length.
         PUSAGE      Usages;         // list of usages (buttons ``down'' on the device.

      } ButtonData;
      struct {
         USAGE       Usage; // The usage describing this value;
         USHORT      Reserved;

         ULONG       Value;
         LONG        ScaledValue;
      } ValueData;
   };
} HID_DATA, *PHID_DATA;

typedef struct _HID_DEVICE {   
    HANDLE               HidDevice; // A file handle to the hid device.
    PHIDP_PREPARSED_DATA Ppd; // The opaque parser info describing this device
    HIDP_CAPS            Caps; // The Capabilities of this hid device.
    HIDD_ATTRIBUTES      Attributes;

    PCHAR                InputReportBuffer;
    PHID_DATA            InputData; // array of hid data structures
    ULONG                InputDataLength; // Num elements in this array.
    PHIDP_BUTTON_CAPS    InputButtonCaps;
    PHIDP_VALUE_CAPS     InputValueCaps;

    PCHAR                OutputReportBuffer;
    PHID_DATA            OutputData;
    ULONG                OutputDataLength;
    PHIDP_BUTTON_CAPS    OutputButtonCaps;
    PHIDP_VALUE_CAPS     OutputValueCaps;

    PCHAR                FeatureReportBuffer;
    PHID_DATA            FeatureData;
    ULONG                FeatureDataLength;
    PHIDP_BUTTON_CAPS    FeatureButtonCaps;
    PHIDP_VALUE_CAPS     FeatureValueCaps;

} HID_DEVICE, *PHID_DEVICE;

BOOLEAN
OpenHidDevice (
    IN       PCHAR          DevicePath,
    IN OUT   PHID_DEVICE    HidDevice
    );

BOOLEAN
FindKnownHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   );

VOID
FillDeviceInfo(
    IN  PHID_DEVICE HidDevice
);

VOID
CloseHidDevices (
   OUT PHID_DEVICE   HidDevices, // A array of struct _HID_DEVICE
   OUT ULONG         NumberDevices // the length of this array.
   );

VOID
CloseHidDevice (
    IN OUT PHID_DEVICE   HidDevice
    );


BOOLEAN
Read (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
Write (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
SetFeature (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
GetFeature (
   PHID_DEVICE    HidDevice
   );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\strings.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    strings.c

Abstract:

    This module contains code for converting data buffers and integer values
    to and from string representation for display.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>
#include "strings.h"
#include "debug.h"

#define ROUND_UP_ON_DIVIDE(d, n)    (0 == ((d) % (n)) ? ((d)/(n)) : ((d)/(n))+1)

VOID
Strings_CreateDataBufferString(
    IN  PCHAR    DataBuffer,
    IN  ULONG    DataBufferLength,
    IN  ULONG    NumBytesToDisplay,
    IN  ULONG    DisplayBlockSize,
    OUT PCHAR    *BufferString
)
/*++
Routine Description:
    This routine takes a DataBuffer of size DataBufferLength and creates a string
    in BufferString that contains a string representation of the bytes stored in
    data buffer.  

    The parameter NumBytesToDisplay tells the routine the maximum number of bytes
    from the buffer to display.  For instance, a caller may only want to convert
    the first four bytes of an eight byte buffer to a string

    The parameter DisplayBlockSize indicates how many bytes should be grouped 
    together in the display.  Valid values are 1, 2, 4 and would indicate whether
    the displayed bytes should be displayed as bytes, words, or dwords.

    The routine allocates a buffer big enough to store the data.  Callers of this
    routine are responsible for freeing this string buffer.  Callers must use the
    same version of debug.h (debug vs. retail) FREE so that the whole buffer is
    properly deallocated.
--*/
{
    ULONG   BufferStringLength;
    ULONG   MaxDisplayedBytes;
    PUCHAR  NextByte;
    PUCHAR  String;
    PUCHAR  CurrentBufferOffset;
    INT     nFullIterations;
    INT     LeftOverBytes;
    INT     IterationIndex;
    INT     ByteOffset;

    ASSERT (1 == DisplayBlockSize || 
            2 == DisplayBlockSize ||
            4 == DisplayBlockSize
           );

    /*
    // Determine the maximum number of bytes that will be displayed in 
    //    the string
    */
    
    MaxDisplayedBytes = (NumBytesToDisplay > DataBufferLength) ? DataBufferLength : NumBytesToDisplay;

    /*
    // Determine the size of the string we'll need: This is based on the 
    //   maximum number of displayed bytes (MaxDisplayedBytes) and the 
    //   DisplayBlockSize
    */

    BufferStringLength = 2*MaxDisplayedBytes + ROUND_UP_ON_DIVIDE(MaxDisplayedBytes,
                                                                  DisplayBlockSize
                                                                 );

    /*
    // Now we need to allocate string space
    */

    String = (PCHAR) ALLOC(BufferStringLength*sizeof(CHAR));

    if (NULL != String) {

        /*
        // Determine how many iterations through the conversion routine must be made.
        */
        
        nFullIterations = MaxDisplayedBytes / DisplayBlockSize;

        /*
        // Initialize our variables which point to data in the buffer to convert
        //   and the byte in the string in which to put the converted data value. 
        //   Next byte is set to String-1 because it is incremented on entry into the
        //   loop.
        */
        
        CurrentBufferOffset = DataBuffer;
        NextByte = String-1;

        /*
        // Each iteration of the loop creates a block of DisplayBlockSize.  Any
        //   partial iterations are performed afterwards if the number of bytes
        //   to display is not a multiple of the display block size
        */
        
        for (IterationIndex = 0; IterationIndex < nFullIterations; IterationIndex++) {

            NextByte++;

            /*
            // Output a block of data size.  Notice the bytes are accessed in
            //    reverse order to display the the MSB of a block as the first
            //    value in the string
            */
            
            for (ByteOffset = DisplayBlockSize-1; ByteOffset >= 0; ByteOffset--) {

                wsprintf(NextByte, "%02X", *(CurrentBufferOffset+ByteOffset));
                NextByte += 2;
                
            }

            /*
            // Insert the space to separate blocks
            */
            
            *(NextByte) = ' ';
            CurrentBufferOffset += DisplayBlockSize;

        }

        /*
        // Resolve any other bytes that are left over
        */
        
        LeftOverBytes = (MaxDisplayedBytes % DisplayBlockSize);
        if (0 == LeftOverBytes) 
            *(NextByte) = '\0';
        
        for (ByteOffset = LeftOverBytes-1, NextByte++; ByteOffset >= 0; ByteOffset--) { 

            wsprintf(NextByte, "%02X", *(CurrentBufferOffset+ByteOffset));
            NextByte += 2;
        }


    }
    
    *BufferString = String;
    return;
}

VOID
Strings_StringToUnsigned(
    IN  PCHAR   InString,
    IN  ULONG   Base,
    OUT PCHAR   *endp,
    OUT PULONG  pValue
)
/*++
Routine Description:
    This routine takes an input string, InString, and converts the value in the 
    string to a corresponding ULONG value, pValue.  

    endp is a pointer to the character that caused the conversion to stop. If 
    the user specifies a Base of 0, then the conversion is dependent on the format
    of the string.  0x -- specifies hex number, 0nnn specifies nnn as octal. Otherwise,
    decimal is assumed.
--*/
{
    INT     ConversionBase;
    PCHAR   ConvertString;
                         
    ASSERT (NULL != InString);
    ASSERT (NULL != endp);
    ASSERT (NULL != pValue);

    *endp = InString;

    /*
    // If base is not zero, we use the specified base
    */
    if (0 != Base) {

        ConversionBase = Base;
        ConvertString = InString;
        
    }

    /*
    // If no base was specified, we determine the base from the first couple 
    //   characters in the string
    */
    
    else { 
        if ('0' == *InString) {
            if (('X' == *(InString+1)) || ('x' == *(InString+1))) {
                ConversionBase = 16;
                ConvertString = InString+2;
            }
            else {
                ConversionBase = 8;
                ConvertString = InString+1;
            }
        }
        else {
            ConvertString = InString;
            ConversionBase = 10;
        }
    }

    /*
    // Call the C run-time library routine to perform the actual conversion
    */
    
    *pValue = strtoul(ConvertString, endp, ConversionBase);
    return;
}

BOOL
Strings_StringToUnsignedList(
    IN  PCHAR   InString,
    IN  ULONG   UnsignedSize,
    IN  ULONG   Base,
    OUT PCHAR   *UnsignedList,
    OUT PULONG  nUnsigneds
)
/*++
Routine Description:
    This routine takes an input string, InString, and creates a list of unsigned
    values of all the values that are in the list.  The caller can specify a
    base, Base, for all the numbers in the list or specify 0 to let the function
    determine the base depending on the format of the number in the string.

    The parameter UnsignedSize specifies the size of unsigneds to store in the list.
    
    The routine allocates a CHAR buffer to store the list of unsigned values.  Callers
    of this routine need to use the same version of debug.h (debug vs. retail) FREE
    to insure proper deallocation of the allocated buffer.  

    On exit, nUnsigneds will report the number of unsigned values stored in 
    UnsignedList.
    
    The function will return TRUE if it could convert all of the numbers in the
    string into the unsigned list.  It will return FALSE if there was a problem
    with the string or if there was a problem allocating memory to store the 
    unsigned list.  
--*/
{
    CHAR    tokDelims[] = "\t,; ";
    PCHAR   strToken;
    PCHAR   endp;
    BOOL    fStatus;
    ULONG   ulValue;
    PCHAR   pList;
    PCHAR   pNewList;
    ULONG   nAllocUnsigneds;
    ULONG   nActualUnsigneds;
    ULONG   ulMaxValue;

    /*
    // Begin by initializing our unsigned list
    //      1) Start with initial allocation for 2 unsigneds, this will
    //          be expanded if necessary
    //      2) If initial allocation fails, return FALSE;
    */

    nAllocUnsigneds = 2;
    nActualUnsigneds = 0;
    pList = (PCHAR) ALLOC (nAllocUnsigneds * sizeof(ULONG));

    if (NULL == pList) 
        return (FALSE);

    /*
    // Calculate the maximum value that can be represented with the value for
    //   iBufferSize;
    */

    ulMaxValue = (sizeof(ULONG) == UnsignedSize) ? ULONG_MAX : (1 << (UnsignedSize*8)) - 1;

    /*
    // Begin our processing of the token string.
    //  1) Set fStatus to TRUE to get through loop the first time
    //  2) Try to get the first token -- if we can't get the first token
    //        then we pass through loop
    */

    fStatus = TRUE;
    strToken = strtok(InString, tokDelims);

    /*
    // Loop until there are no more tokens or we detect an error (fStatus == FALSE)
    */

    while (NULL != strToken && fStatus) {

        /*
        // Set fStatus initially to false.  Only if nothing goes wrong in 
        //    the loop will this get set to TRUE
        */

        fStatus = FALSE;

        /*
        // Attempt to convert the token
        */

        Strings_StringToUnsigned(strToken, Base, &endp, &ulValue);

        /*
        // To be a valid value, *endp must point to the NULL character
        */

        if ('\0' == *endp) {

            /*
            // Check to see that the ulValue found is less than or equal to 
            //     the maximum allowed by UnsignedSize.
            */

            if (ulValue <= ulMaxValue) {
                
                /*
                // If we're set to overrun our buffer, attempt to allocate
                //    more space.  If we can't then release the old space
                //    and fail the loop.  
                */

                if (nAllocUnsigneds == nActualUnsigneds) {

                    nAllocUnsigneds *= 2;
                    pNewList = (PCHAR) REALLOC(pList, UnsignedSize*nAllocUnsigneds);

                    if (NULL == pNewList)
                        break;

                    pList = pNewList;
                }

                /*
                // Add the token to the end of the list of unsigneds
                */

                memcpy(pList + (UnsignedSize * nActualUnsigneds),
                       &ulValue,
                       UnsignedSize
                      );

                nActualUnsigneds++;

                /*
                // Prepare to reenter the loop.  Set fStatus = TRUE 
                //    Try to get another token
                */

                fStatus = TRUE;
                strToken = strtok(NULL, tokDelims);
            }
        }
    }

    /*
    // If the loop failed for some reason or we found no unsigneds
    //     release the list
    */

    if (!fStatus || 0 == nActualUnsigneds) {
        FREE(pList);
        pList = NULL;
        nActualUnsigneds = 0;
    }

    *UnsignedList = pList;
    *nUnsigneds = nActualUnsigneds;
    
    return (fStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\pnp.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    pnp.c

Abstract:

    This module contains the code
    for finding, adding, removing, and identifying hid devices.

Environment:

    User mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#include <basetyps.h>
#include <stdlib.h>
#include <wtypes.h>
#include <setupapi.h>
#include "hidsdi.h"
#include "hid.h"

VOID
CloseHidDevice (
    IN OUT   PHID_DEVICE                 HidDevice
    );


BOOLEAN
FindKnownHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   )
/*++
Routine Description:
   Do the required PnP things in order to find all the HID devices in
   the system at this time.
--*/
{
    HDEVINFO                 hardwareDeviceInfo;
    SP_INTERFACE_DEVICE_DATA deviceInfoData;
    ULONG                    i;
    BOOLEAN                  done;
    PHID_DEVICE              hidDeviceInst;
    GUID                     hidGuid;
    PSP_INTERFACE_DEVICE_DETAIL_DATA     functionClassDeviceData = NULL;
    ULONG                                predictedLength = 0;
    ULONG                                requiredLength = 0;


    HidD_GetHidGuid (&hidGuid);

    *HidDevices = NULL;
    *NumberDevices = 0;

    //
    // Open a handle to the plug and play dev node.
    //
    hardwareDeviceInfo = SetupDiGetClassDevs (
                                               &hidGuid,
                                               NULL, // Define no enumerator (global)
                                               NULL, // Define no
                                               (DIGCF_PRESENT | // Only Devices present
                                                DIGCF_INTERFACEDEVICE)); // Function class devices.

    //
    // Take a wild guess to start
    //
    
    *NumberDevices = 4;
    done = FALSE;
    deviceInfoData.cbSize = sizeof (SP_INTERFACE_DEVICE_DATA);

    i=0;
    while (!done) {
        *NumberDevices *= 2;

        if (*HidDevices) {
        
            *HidDevices =
               realloc (*HidDevices, (*NumberDevices * sizeof (HID_DEVICE)));
               
        } else {
            *HidDevices = calloc (*NumberDevices, sizeof (HID_DEVICE));
        }

        if (NULL == *HidDevices) {
            SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
            return FALSE;
        }

        hidDeviceInst = *HidDevices + i;

        for (; i < *NumberDevices; i++, hidDeviceInst++) {
            if (SetupDiEnumInterfaceDevice (hardwareDeviceInfo,
                                            0, // No care about specific PDOs
                                            &hidGuid,
                                            i,
                                            &deviceInfoData)) {

                //
                // allocate a function class device data structure to receive the
                // goods about this particular device.
                //
                SetupDiGetInterfaceDeviceDetail (
                        hardwareDeviceInfo,
                        &deviceInfoData,
                        NULL, // probing so no output buffer yet
                        0, // probing so output buffer length of zero
                        &requiredLength,
                        NULL); // not interested in the specific dev-node


                predictedLength = requiredLength;
                // sizeof (SP_FNCLASS_DEVICE_DATA) + 512;

                functionClassDeviceData = malloc (predictedLength);
                functionClassDeviceData->cbSize = sizeof (SP_INTERFACE_DEVICE_DETAIL_DATA);

                //
                // Retrieve the information from Plug and Play.
                //
                if (! SetupDiGetInterfaceDeviceDetail (
                           hardwareDeviceInfo,
                           &deviceInfoData,
                           functionClassDeviceData,
                           predictedLength,
                           &requiredLength,
                           NULL)) {
                    return FALSE;
                }

                OpenHidDevice (functionClassDeviceData -> DevicePath, hidDeviceInst);

            } else {
                if (ERROR_NO_MORE_ITEMS == GetLastError()) {
                    done = TRUE;
                    break;
                }
            }
        }
    }

    *NumberDevices = i;

    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
    return TRUE;
}

BOOLEAN
OpenHidDevice (
    IN       PCHAR          DevicePath,
    IN OUT   PHID_DEVICE    HidDevice
    )
/*++
RoutineDescription:
    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific hid device,
    open that device and fill in all the relivant information in the given
    HID_DEVICE structure.

    return if the open and initialization was successfull or not.

--*/
{




    HidDevice->HidDevice = CreateFile (
                              DevicePath,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL, // no SECURITY_ATTRIBUTES structure
                              OPEN_EXISTING, // No special create flags
                              0, // No special attributes
                              NULL); // No template file

    if (INVALID_HANDLE_VALUE == HidDevice->HidDevice) {
        return FALSE;
    }

    if (!HidD_GetPreparsedData (HidDevice->HidDevice, &HidDevice->Ppd)) {
        return FALSE;
    }

    if (!HidD_GetAttributes (HidDevice->HidDevice, &HidDevice->Attributes)) {
        HidD_FreePreparsedData (HidDevice->Ppd);
        return FALSE;
    }

    if (!HidP_GetCaps (HidDevice->Ppd, &HidDevice->Caps)) {
        HidD_FreePreparsedData (HidDevice->Ppd);
        return FALSE;
    }


    //
    // At this point the client has a choise.  It may chose to look at the
    // Usage and Page of the top level collection found in the HIDP_CAPS
    // structure.  In this way it could just use the usages it knows about.
    // If either HidP_GetUsages or HidP_GetUsageValue return an error then
    // that particular usage does not exist in the report.
    // This is most likely the preferred method as the application can only
    // use usages of which it already knows.
    // In this case the app need not even call GetButtonCaps or GetValueCaps.
    //
    // In this example, however, we will call FillDeviceInfo to look for all
    //    of the usages in the device.
    //

    FillDeviceInfo(HidDevice);

    return (TRUE);
}

VOID
FillDeviceInfo(
    IN  PHID_DEVICE HidDevice
)
{
    USHORT                               numValues;
    USHORT                               numCaps;
    PHIDP_BUTTON_CAPS                    buttonCaps;
    PHIDP_VALUE_CAPS                     valueCaps;
    PHID_DATA                            data;
    ULONG                                i;
    USAGE                                usage;

    //
    // setup Input Data buffers.
    //

    //
    // Allocate memory to hold on input report
    //

    HidDevice->InputReportBuffer = (PCHAR)
        calloc (HidDevice->Caps.InputReportByteLength, sizeof (CHAR));


    //
    // Allocate memory to hold the button and value capabilities.
    // NumberXXCaps is in terms of array elements.
    //
    HidDevice->InputButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberInputButtonCaps, sizeof (HIDP_BUTTON_CAPS));
    HidDevice->InputValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberInputValueCaps, sizeof (HIDP_VALUE_CAPS));

    //
    // Have the HidP_X functions fill in the capability structure arrays.
    //
    numCaps = HidDevice->Caps.NumberInputButtonCaps;
    HidP_GetButtonCaps (HidP_Input,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberInputValueCaps;
    HidP_GetValueCaps (HidP_Input,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    //
    // Depending on the device, some value caps structures may represent more
    // than one value.  (A range).  In the interest of being verbose, over
    // efficient, we will expand these so that we have one and only one
    // struct _HID_DATA for each value.
    //
    // To do this we need to count up the total number of values are listed
    // in the value caps structure.  For each element in the array we test
    // for range if it is a range then UsageMax and UsageMin describe the
    // usages for this range INCLUSIVE.
    //
    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberInputValueCaps; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            numValues += valueCaps->Range.UsageMax - valueCaps->Range.UsageMin + 1;
        } else {
            numValues++;
        }
    }
    valueCaps = HidDevice->InputValueCaps;


    //
    // Allocate a buffer to hold the struct _HID_DATA structures.
    // One element for each set of buttons, and one element for each value
    // found.
    //
    HidDevice->InputDataLength = HidDevice->Caps.NumberInputButtonCaps
                               + numValues;
    HidDevice->InputData = data = (PHID_DATA)
        calloc (HidDevice->InputDataLength, sizeof (HID_DATA));


    //
    // Fill in the button data
    //
    for (i = 0;
         i < HidDevice->Caps.NumberInputButtonCaps;
         i++, data++, buttonCaps++) {

        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;
        if (buttonCaps->IsRange) {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else {
            data -> ButtonData.UsageMin = data -> ButtonData.UsageMax = buttonCaps -> NotRange.Usage;
        }
        
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Input,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
            calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));
        data->ReportID = buttonCaps -> ReportID;

    }

    //
    // Fill in the value data
    //
    for (i = 0; i < numValues; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) {

                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps -> ReportID;
                data++;
            }
        } else {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    //
    // setup Output Data buffers.
    //
    HidDevice->OutputReportBuffer = (PCHAR)
        calloc (HidDevice->Caps.OutputReportByteLength, sizeof (CHAR));

    HidDevice->OutputButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberOutputButtonCaps, sizeof (HIDP_BUTTON_CAPS));
    HidDevice->OutputValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberOutputValueCaps, sizeof (HIDP_VALUE_CAPS));

    numCaps = HidDevice->Caps.NumberOutputButtonCaps;
    HidP_GetButtonCaps (HidP_Output,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberOutputValueCaps;
    HidP_GetValueCaps (HidP_Output,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberOutputValueCaps; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            numValues += valueCaps->Range.UsageMax
                       - valueCaps->Range.UsageMin + 1;
        } else {
            numValues++;
        }
    }
    valueCaps = HidDevice->OutputValueCaps;

    HidDevice->OutputDataLength = HidDevice->Caps.NumberOutputButtonCaps
                                + numValues;
    HidDevice->OutputData = data = (PHID_DATA)
       calloc (HidDevice->OutputDataLength, sizeof (HID_DATA));

    for (i = 0;
         i < HidDevice->Caps.NumberOutputButtonCaps;
         i++, data++, buttonCaps++) {

        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;
         if (buttonCaps->IsRange) {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else {
            data -> ButtonData.UsageMin = data -> ButtonData.UsageMax = buttonCaps -> NotRange.Usage;
        }

        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                   HidP_Output,
                                                   buttonCaps->UsagePage,
                                                   HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
            calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));
        data->ReportID = buttonCaps -> ReportID;

    }

    for (i = 0; i < numValues; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) {

                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps -> ReportID;
                data++;
            }
        } else {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    //
    // setup Feature Data buffers.
    //

    HidDevice->FeatureReportBuffer = (PCHAR)
           calloc (HidDevice->Caps.FeatureReportByteLength, sizeof (CHAR));

    HidDevice->FeatureButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberFeatureButtonCaps, sizeof (HIDP_BUTTON_CAPS));
    HidDevice->FeatureValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberFeatureValueCaps, sizeof (HIDP_VALUE_CAPS));

    numCaps = HidDevice->Caps.NumberFeatureButtonCaps;
    HidP_GetButtonCaps (HidP_Feature,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberFeatureValueCaps;
    HidP_GetValueCaps (HidP_Feature,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberFeatureValueCaps; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            numValues += valueCaps->Range.UsageMax
                       - valueCaps->Range.UsageMin + 1;
        } else {
            numValues++;
        }
    }
    valueCaps = HidDevice->FeatureValueCaps;

    HidDevice->FeatureDataLength = HidDevice->Caps.NumberFeatureButtonCaps
                                 + numValues;
    HidDevice->FeatureData = data = (PHID_DATA)
        calloc (HidDevice->FeatureDataLength, sizeof (HID_DATA));

    for (i = 0;
         i < HidDevice->Caps.NumberFeatureButtonCaps;
         i++, data++, buttonCaps++) {

        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;

        if (buttonCaps->IsRange) {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else {
            data -> ButtonData.UsageMin = data -> ButtonData.UsageMax = buttonCaps -> NotRange.Usage;
        }
        
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Feature,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
             calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));
        data->ReportID = buttonCaps -> ReportID;
    }

    for (i = 0; i < numValues; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) {

                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps -> ReportID;
                data++;
            }
        } else {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    return;
}

VOID
CloseHidDevices(
    IN  PHID_DEVICE HidDevices,
    IN  ULONG       NumberDevices
)
{
    ULONG   Index;

    for (Index = 0; Index < NumberDevices; Index++) {
        CloseHidDevice(HidDevices+Index);
    }

    return;
}

VOID
CloseHidDevice (
    IN PHID_DEVICE HidDevice
)
{
    if (INVALID_HANDLE_VALUE != HidDevice -> HidDevice) {
        CloseHandle(HidDevice -> HidDevice);
    }

    if (NULL != HidDevice -> Ppd) {
        HidD_FreePreparsedData(HidDevice -> Ppd);
    }

    if (NULL != HidDevice -> InputReportBuffer) {
        free(HidDevice -> InputReportBuffer);
    }

    if (NULL != HidDevice -> InputData) {
        free(HidDevice -> InputData);
    }

    if (NULL != HidDevice -> InputButtonCaps) {
        free(HidDevice -> InputButtonCaps);
    }

    if (NULL != HidDevice -> InputValueCaps) {
        free(HidDevice -> InputValueCaps);
    }

    if (NULL != HidDevice -> OutputReportBuffer) {
        free(HidDevice -> OutputReportBuffer);
    }

    if (NULL != HidDevice -> OutputData) {
        free(HidDevice -> OutputData);
    }

    if (NULL != HidDevice -> OutputButtonCaps) {
        free(HidDevice -> OutputButtonCaps);
    }

    if (NULL != HidDevice -> OutputValueCaps) {
        free(HidDevice -> OutputValueCaps);
    }

    if (NULL != HidDevice -> FeatureReportBuffer) {
        free(HidDevice -> FeatureReportBuffer);
    }

    if (NULL != HidDevice -> FeatureData) {
        free(HidDevice -> FeatureData);
    }

    if (NULL != HidDevice -> FeatureButtonCaps) {
        free(HidDevice -> FeatureButtonCaps);
    }

    if (NULL != HidDevice -> FeatureValueCaps) {
        free(HidDevice -> FeatureValueCaps);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hclient\ddksrc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hclient.rc
//
#define IDD_SET_BUTTONS                 108
#define IDD_SET_SCALED_VALUE            109
#define IDD_SET_USAGE_VALUE             110
#define IDD_AUTOTEST_PARAMS             111
#define IDD_SET_USAGE_VALUE_ARRAY       112
#define IDD_USAGE_LIST_DIFFERENCE       113
#define IDD_UNSET_BUTTONS               114
#define IDD_UNSET_USAGES                115
#define IDD_SET_DATA                    116
#define IDD_SET_BUFFER_LENGTH           117
#define IDD_SET_INPUT_BUFFERS           118
#define IDD_GET_INDEX_STRING            119
#define IDD_SET_USAGES                  120
#define IDD_AUTOTEST_RESULTS            121
#define IDC_DEVICES                     1001
#define IDC_TYPE                        1002
#define IDC_ITEMS                       1003
#define IDC_ATTRIBUTES                  1004
#define IDC_READ                        1005
#define IDC_ABOUT                       1006
#define IDC_WRITE                       1007
#define IDC_EXTCALLS                    1008
#define IDC_SEND                        1100
#define ID_SEND                         1100
#define IDC_OUTPUT                      1101
#define IDC_EDIT1                       1102
#define IDC_USAGEPAGE                   1102
#define IDC_USAGE_LIST                  1102
#define IDC_STRING_INDEX                1102
#define IDC_LOGFILE                     1102
#define IDC_REPORTID                    1103
#define IDC_USAGE_LIST2                 1103
#define box                             1111
#define IDC_SCROLLBAR1                  1121
#define IDC_SCROLLBAR                   1121
#define IDC_INPUT                       1122
#define IDC_FEATURE                     1124
#define IDC_USAGE                       1126
#define IDC_LINKCOLL                    1127
#define IDC_CALLOUTPUT                  1128
#define IDC_EXECUTE                     1129
#define IDC_CANCEL                      1130
#define IDC_FEATURES                    1131
#define IDC_SET_PARAMS                  1131
#define IDC_REPORT_BUFFER               1132
#define IDC_INPUT_BUFFER                1132
#define IDC_BUFFER_TYPE                 1133
#define IDC_BUFFER_SIZE                 1134
#define IDC_INPUT_SELECT                1135
#define IDC_FEATURE_BUFFER              1136
#define IDC_USAGE_PAGE                  1136
#define IDC_FEATURE_SELECT              1137
#define IDC_OUTPUT_BUFFER               1138
#define IDC_VALUE                       1138
#define IDC_OUTPUT_SELECT               1139
#define IDC_INDEX                       1142
#define IDC_ADD_DATA                    1143
#define IDC_REMOVE_DATA                 1144
#define IDC_DATA_LIST                   1145
#define IDC_INPUT_BUFFERS               1147
#define IDC_BUFFER_LENGTH               1149
#define IDC_USAGE_LIST1                 1150
#define IDC_START_TESTS                 1151
#define IDC_LOAD_LOGICAL_DEVICE         1152
#define IDC_USELOG                      1152
#define IDC_INFINITE                    1153
#define IDC_PPD_ITS                     1154
#define IDC_RUN_PPD                     1155
#define IDC_RUN_CAPS                    1156
#define IDC_RUN_ATTRIB                  1157
#define IDC_RUN_STRINGS                 1158
#define IDC_RUN_GUID                    1159
#define IDC_ITERATIONS                  1160
#define IDC_CAPS_ITS                    1161
#define IDC_ATT_ITS                     1162
#define IDC_STR_ITS                     1163
#define IDC_GUID_ITS                    1164
#define IDC_TEST_ITS                    1165
#define IDC_STOP_TESTS                  1167
#define IDC_END_TESTS                   1168
#define IDC_LOGFILENAME                 1169
#define IDC_TEST_RESULTS                1172
#define IDC_DEVICE_LIST                 1174
#define IDC_OUT_LABEL1                  2000
#define IDC_OUT_LABEL2                  2001
#define IDC_OUT_LABEL3                  2002
#define IDC_OUT_LABEL4                  2003
#define IDC_OUT_LABEL5                  2004
#define IDC_OUT_LABEL6                  2005
#define IDC_OUT_LABEL7                  2006
#define IDC_OUT_LABEL8                  2007
#define IDC_OUT_LABEL9                  2008
#define IDC_OUT_EDIT1                   3000
#define IDC_OUT_EDIT2                   3001
#define IDC_OUT_EDIT3                   3002
#define IDC_OUT_EDIT4                   3003
#define IDC_OUT_EDIT5                   3004
#define IDC_OUT_EDIT6                   3005
#define IDC_OUT_EDIT7                   3006
#define IDC_OUT_EDIT8                   3007
#define IDC_OUT_EDIT9                   3008

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        122
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1175
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidserv\dbg.h ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       dbg.h
 *  Purpose:    Ascii char debug macros.
 * 
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#ifndef _DBG_H_
#define _DBG_H_

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#define DBG_NAME "HidServ"

#ifdef DBG



#define TL_ALL          0
#define TL_DUMP         1
#define TL_TRACE        2
#define TL_INFO         3
#define TL_WARN         4
#define TL_ERROR        5

GLOBALS DWORD   G_TraceLevel EQU TL_WARN;

static void _dprint( IN PCHAR format, IN ... )
{
        char    buf[1024];
        va_list ap;

        va_start(ap, format);

        wvsprintfA( buf, format, ap );

        OutputDebugStringA(buf);

        va_end(ap);
}

#define DPRINTF _dprint
#define HPRINTF _dprint

#define VPRINTF _dprint

#define DUMP(strings) { \
    if(TL_DUMP >= G_TraceLevel){ \
        VPRINTF(DBG_NAME " DUMP: "); \
        VPRINTF##strings; \
        VPRINTF("\n"); \
    } \
}

#define TRACE(strings) { \
    if(TL_TRACE >= G_TraceLevel){ \
        VPRINTF(DBG_NAME " TRACE: "); \
        VPRINTF##strings; \
        VPRINTF("\n"); \
    } \
}

#define INFO(strings) { \
    if(TL_INFO >= G_TraceLevel){ \
        HPRINTF(DBG_NAME " INFO: "); \
        HPRINTF##strings; \
        HPRINTF("\n"); \
    } \
}

#define WARN(strings) {\
    if(TL_WARN >= G_TraceLevel){ \
        HPRINTF(DBG_NAME " WARNS: "); \
        HPRINTF##strings; \
        HPRINTF("\n"); \
    } \
}

#define TERROR(strings) 
        
#else //DBG

#define DPRINTF
#define HPRINTF
#define VPRINTF

#define DUMP(strings) 
#define TRACE(strings) 
#define INFO(strings) 
#define WARN(strings)
#define TERROR(strings)
#define ASSERT(exp)

#endif //DBG


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif //_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidserv\hid.h ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       hid.h
 *  Purpose:    header to support hid client capability.
 * 
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#ifndef HIDEXE_H
#define HIDEXE_H

#include <hidsdi.h>
#include <setupapi.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// A structure to hold the steady state data received from the hid device.
// Each time a read packet is received we fill in this structure.
// Each time we wish to write to a hid device we fill in this structure.
// This structure is here only for convenience.  Most real applications will
// have a more efficient way of moving the hid data to the read, write, and
// feature routines.
//
typedef struct _HID_DATA {
   BOOLEAN     IsButtonData;
   UCHAR       Reserved;
   USAGE       UsagePage;       // The usage page for which we are looking.
   USHORT      LinkCollection;  // hidparse internal index
   USAGE       LinkUsage;       // the actual logical collection usage
   ULONG       Status; // The last status returned from the accessor function
                       // when updating this field.
   union {
      struct {
         ULONG              MaxUsageLength; // Usages buffer length.
         PUSAGE_AND_PAGE    Usages; // list of usages (buttons ``down'' on the device.
         PUSAGE_AND_PAGE    PrevUsages; // list of usages previously ``down'' on the device.
      } ButtonData;
      struct {
         USAGE       Usage; // The usage describing this value;
         USHORT      Reserved;

         ULONG       Value;
         LONG        ScaledValue;
         ULONG       LogicalRange;
      } ValueData;
   };
} HID_DATA, *PHID_DATA;

typedef struct _HID_DEVICE {
   struct _HID_DEVICE * pNext;
   HANDLE               HidDevice; // A file handle to the hid device.
   PHIDP_PREPARSED_DATA Ppd; // The opaque parser info describing this device
   HIDP_CAPS            Caps; // The Capabilities of this hid device.
   HIDD_ATTRIBUTES      Attributes;
   
   // PnP info
   DWORD                DevInst;    // the devnode
   BOOL                 Active;     // Dead or alive?
   HDEVNOTIFY           hNotify;    // Device notification handle
    
   OVERLAPPED           Overlap;    // used for overlapped read.
   HANDLE               ReadEvent;  // when io pending occurs
   HANDLE               CompletionEvent;  // signals read completion.
   BOOL                 fThreadEnabled;
   DWORD                ThreadId;
   HANDLE               ThreadHandle;

   PCHAR                InputReportBuffer;
   PHID_DATA            InputData; // array of hid data structures
   ULONG                InputDataLength; // Num elements in this array.

   BOOLEAN              Speakers;
} HID_DEVICE, *PHID_DEVICE;


// pnp.c
BOOL
RebuildHidDeviceList (void);

BOOL
StartHidDevice(
    PHID_DEVICE      pHidDevice);

BOOL
StopHidDevice(
    PHID_DEVICE     pHidDevice);

BOOL
DestroyHidDeviceList(
    void);

BOOL
DestroyDeviceByHandle(
    HANDLE hDevice
    );

// report.c
BOOL
Read (
   PHID_DEVICE    HidDevice
   );

BOOL
ParseReadReport (
   PHID_DEVICE    HidDevice
   );

BOOL
Write (
   PHID_DEVICE    HidDevice
   );

BOOL
SetFeature (
   PHID_DEVICE    HidDevice
   );

BOOL
GetFeature (
   PHID_DEVICE    HidDevice
   );


#ifdef __cplusplus
}
#endif  /* __cplusplus */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidserv\appcmd.c ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       appcmd.c
 *  Purpose:    routines to run the HID Audio server.
 *
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#define GLOBALS
#include "hidserv.h"

#define HIDSERV_FROM_SPEAKER 0x8000

/*++
 * IMPORTANT - All work within this service is synchronized by the
 * message procedure HidServProc() except the per device work thread
 * HidThreadProc(). All concurrent access to shared data is within the
 * message procedure thread and therefore is serialized. For example,
 * HidThreadProc() posts messages to the message thread when it needs
 * to perform a serialized action. Any deviation from this scheme must
 * be protected by critical section.
--*/

DWORD
WINAPI
HidServMain(
    HANDLE InitDoneEvent
    )
/*++
Routine Description:
    Creates the main message loop and executes the
    Hid Audio server.
--*/
{
    MSG msg;

    // Some controls have Auto Repeat timers. This mutex prevents
    // concurrent access to data by these async timers.
    hMutexOOC = CreateMutex(NULL, FALSE, TEXT("OOC State Mutex"));

    // Use CreateMutex to detect previous instances of the app.
    if (GetLastError() == ERROR_ALREADY_EXISTS){
        WARN(("Exiting multiple HidAudio instance."));
        CloseHandle(hMutexOOC);
        return 0;
    }

    hInputEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    hInputDoneEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    hDesktopSwitch = OpenEvent(SYNCHRONIZE, FALSE, TEXT("WinSta0_DesktopSwitch"));
    InputThreadEnabled = TRUE;

    // Register the window class
    {
        WNDCLASSEX wce;
        wce.cbSize = sizeof(WNDCLASSEX);
        wce.style = 0;
        wce.lpfnWndProc = (WNDPROC) HidServProc;
        wce.cbClsExtra = 0;
        wce.cbWndExtra = 0;
        wce.hInstance = hInstance;
        wce.hIcon = NULL;
        wce.hIconSm = NULL;
        wce.hCursor = NULL;
        wce.hbrBackground = NULL;
        wce.lpszMenuName = NULL;
        wce.lpszClassName = TEXT("HidServClass");

        if (!RegisterClassEx(&wce)){
            WARN(("Cannot register thread window class: 0x%.8x\n", GetLastError()));
            SET_SERVICE_STATE(SERVICE_STOPPED);
            return 0;
        }
    }

    // Create the app window.
    // Most events will be processed through this hidden window. Look at HidServProc() to see
    // what work this window message loop does.
    hWndHidServ = CreateWindow(TEXT("HidServClass"),
                            TEXT("HID Input Service"),
                            WS_OVERLAPPEDWINDOW,
                            0,
                            0,
                            0,
                            0,
                            (HWND) NULL,
                            (HMENU) NULL,
                            hInstance,
                            (LPVOID) NULL);

    TRACE(("hWndHidServ == %x", hWndHidServ));
    // If the window cannot be created, terminate
    if (!hWndHidServ){
        WARN(("Window creation failed."));
        CloseHandle(hMutexOOC);
        CloseHandle(hInputEvent);
        CloseHandle(hInputDoneEvent);
        CloseHandle(hDesktopSwitch);

        SET_SERVICE_STATE(SERVICE_STOPPED);
        return 0;
    }

    // Register for selective device nofication
    // This only required for NT5
    {
    DEV_BROADCAST_DEVICEINTERFACE DevHdr;
        ZeroMemory(&DevHdr, sizeof(DevHdr));
        DevHdr.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
        DevHdr.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        HidD_GetHidGuid (&DevHdr.dbcc_classguid);

        hNotifyArrival =
        RegisterDeviceNotification( hWndHidServ,
                                    &DevHdr,
                                    DEVICE_NOTIFY_WINDOW_HANDLE);

        if (!hNotifyArrival){
            WARN(("RegisterDeviceNotification failure (%x).", GetLastError()));
        }
    }

    // We do this here, not in WM_CREATE handler, because the init routines need
    // to know the new window handle.
    HidServInit();

    InputSessionId = 0;
    InputSessionLocked = FALSE;
    WinStaDll = NULL;
    WinStaDll = LoadLibrary(TEXT("winsta.dll"));
    if (WinStaDll) {
        WinStaProc = (WINSTATIONSENDWINDOWMESSAGE)
            GetProcAddress(WinStaDll, "WinStationSendWindowMessage");
    }

    CreateThread(
                NULL, // pointer to thread security attributes
                0, // initial thread stack size, in bytes (0 = default)
                HidThreadInputProc, // pointer to thread function
                NULL, // argument for new thread
                0, // creation flags
                &InputThreadId // pointer to returned thread identifier
                );

    if (InitDoneEvent) {
        SetEvent(InitDoneEvent);
    }

    // Start the message loop. This is terminated by system shutdown
    // or End Task. There is no UI to close the app.
    while (GetMessage(&msg, (HWND) NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // To terminate, we only need to destroy the window. MmHidExit() was
    // already called on WM_CLOSE.
    DestroyWindow(hWndHidServ);
    INFO(("UnRegistering window class"));
    UnregisterClass(TEXT("HidServClass"),
                    hInstance);


    // Don't let this process go until all HidThreadProc() threads are complete.
    while (cThreadRef) SleepEx(1000, FALSE);

    return 0;
}

void
HidservSetPnP(
    BOOL Enable
    )
{
    if (Enable) {
        if (!PnpEnabled){
            // Enable device refresh.
            PnpEnabled = TRUE;

            PostMessage(hWndHidServ, WM_HIDSERV_PNP_HID, 0, 0);
        }
    } else {
        // Prevent any device refresh.
        PnpEnabled = FALSE;

        DestroyHidDeviceList();
    }
}

void
HidServStart(
    void
    )
/*++
Routine Description:
    Restart the Hid Audio server if it has been stopped.
--*/
{
    HidservSetPnP(TRUE);

    SET_SERVICE_STATE(SERVICE_RUNNING);
}


void
HidServStop(
    void
    )
/*++
Routine Description:
    Stop all activity, but keep static data, and keep
    the message queue running.
--*/
{

    // Prevent any device refresh.
    HidservSetPnP(FALSE);

    SET_SERVICE_STATE(SERVICE_STOPPED);
}


BOOL
HidServInit(
    void
    )
/*++
Routine Description:
    Setup all data structures and open system handles.
--*/
{

    HidServStart();

    return TRUE;
}

void
HidServExit(
    void
    )
/*++
Routine Description:
    Close all system handles.
--*/
{
    if (WinStaDll) {
        FreeLibrary(WinStaDll);
    }
    UnregisterDeviceNotification(hNotifyArrival);
    HidServStop();
    CloseHandle(hMutexOOC);

    if (InputThreadEnabled) {
        InputThreadEnabled = FALSE;
        SetEvent(hInputEvent);
    }
}

VOID
HidThreadChangeDesktop (
    )
{
    HDESK hDesk, hPrevDesk;
    BOOL result;
    HWINSTA prevWinSta, winSta = NULL;

    hPrevDesk = GetThreadDesktop(GetCurrentThreadId());
    prevWinSta = GetProcessWindowStation();

    INFO(("Setting the input thread's desktop"));
    winSta = OpenWindowStation(TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);

    if (!winSta) {
        WARN(("Couldn't get the window station! Error: 0x%x", GetLastError()));
        goto HidThreadChangeDesktopError;
    }

    if (!SetProcessWindowStation(winSta)) {
        WARN(("Couldn't set the window station! Error: 0x%x", GetLastError()));
        goto HidThreadChangeDesktopError;
    }

    hDesk = OpenInputDesktop(0,
                             FALSE,
                             MAXIMUM_ALLOWED);

    if (!hDesk) {
        WARN(("Couldn't get the input desktop! Error: 0x%x", GetLastError()));
        goto HidThreadChangeDesktopError;
    }

    if (!SetThreadDesktop(hDesk)) {
        WARN(("Couldn't set the thread's desktop to the input desktop! Error: 0x%x", GetLastError()));
    }

HidThreadChangeDesktopError:
    if (hPrevDesk) {
        CloseDesktop(hPrevDesk);
    }
    if (prevWinSta) {
        CloseWindowStation(prevWinSta);
    }
}

DWORD
WINAPI
HidThreadInputProc(
    PVOID Ignore
    )
{
    GUITHREADINFO threadInfo;
    HWND hWndForeground;
    INPUT input;
    HANDLE events[2];
    DWORD ret;
    DWORD nEvents = 0;

    InterlockedIncrement(&cThreadRef);

    events[nEvents++] = hDesktopSwitch;
    events[nEvents++] = hInputEvent;

    //
    // This thread needs to run on the input desktop.
    //
    HidThreadChangeDesktop();

    while (TRUE) {

        ret = WaitForMultipleObjects(nEvents, events, FALSE, INFINITE);
        if (!InputThreadEnabled) {
            break;
        }
        if (0 == (ret - WAIT_OBJECT_0)) {
            HidThreadChangeDesktop();
            continue;
        }
        if (InputIsAppCommand) {
            threadInfo.cbSize = sizeof(GUITHREADINFO);
            if (GetGUIThreadInfo(0, &threadInfo)) {
                hWndForeground = threadInfo.hwndFocus ? threadInfo.hwndFocus : threadInfo.hwndActive;
                if (hWndForeground) {
                    INFO(("Sending app command 0x%x", InputAppCommand));
                    SendNotifyMessage(hWndForeground,
                                      WM_APPCOMMAND,
                                      (WPARAM)hWndForeground,
                                      ((InputAppCommand | FAPPCOMMAND_OEM)<<16));
                } else {
                    WARN(("No window available to send to, error %x", GetLastError()));
                }
            } else {
                WARN(("Unable to get the focus window, error %x", GetLastError()));
            }
        } else {

            ZeroMemory(&input, sizeof(INPUT));

            input.type = INPUT_KEYBOARD;
            input.ki.dwFlags = InputDown ? 0 : KEYEVENTF_KEYUP;

            if (InputIsChar) {
                input.ki.wScan = InputVKey;
                input.ki.dwFlags |= KEYEVENTF_UNICODE;
                INFO(("Sending character %c %s", InputVKey, InputDown ? "down" : "up"));
            } else {
                input.ki.wVk = InputVKey;
                input.ki.dwFlags |= KEYEVENTF_EXTENDEDKEY;
                INFO(("Sending VK 0x%x %s", InputVKey, InputDown ? "down" : "up"));
            }

            SendInput(1, &input, sizeof(INPUT));
        }
        SetEvent(hInputDoneEvent);
    }

    CloseHandle(hDesktopSwitch);
    CloseHandle(hInputEvent);
    CloseHandle(hInputDoneEvent);

    InterlockedDecrement(&cThreadRef);

    return 0;
}


DWORD
WINAPI
HidThreadProc(
   PHID_DEVICE    HidDevice
   )
/*++
Routine Description:
    Create this I/O thread for each Consumer Collection we have
    open. The thread dies when we close our handle on the HID device.
--*/
{
    DWORD Ret;
    DWORD bytesRead;
    BOOL bRet;
    DWORD dwError;
    USAGE_AND_PAGE *pPrevious;
    PHID_DATA data = HidDevice->InputData;

    TRACE(("Entering HidThreadProc. Device(%x)", HidDevice));

    InterlockedIncrement(&cThreadRef);

    // wait for an async read
    INFO(("HidThreadProc waiting for read event..."));
    WaitForSingleObject(HidDevice->ReadEvent, INFINITE);

    while (HidDevice->fThreadEnabled){

        TRACE(("Reading from Handle(%x)", HidDevice->HidDevice));
        bRet = ReadFile (HidDevice->HidDevice,
                       HidDevice->InputReportBuffer,
                       HidDevice->Caps.InputReportByteLength,
                       &bytesRead,
                       &HidDevice->Overlap);
        dwError = GetLastError();

        // wait for read to complete
        TRACE(("HidThreadProc waiting for completion."));

        if(bRet){
            TRACE(("Read completed synchronous."));
        }else{
            if (dwError == ERROR_IO_PENDING) {
                TRACE(("Read pending."));

                // work thread waits for completion
                while (TRUE) {
                    Ret = WaitForSingleObject(HidDevice->CompletionEvent, 5000);
                    if (Ret == WAIT_OBJECT_0) {
                        TRACE(("Read completed on device (%x).", HidDevice));
                        break;
                    }
                    if (!HidDevice->fThreadEnabled) {
                        if (CancelIo(HidDevice->HidDevice)) {
                            TRACE(("CancelIo succeeded for device (%x).", HidDevice));
                            break;
                        }
                    }
                }
                TRACE(("Read complete async."));

            } else {
                WARN(("Read Failed with error %x. device = %x, handle = %x", dwError, HidDevice, HidDevice->HidDevice));
                INFO(("Device may no longer be connected. Waiting for device notification from pnp..."));
                // Just wait for the device notification to come thru from PnP.
                // Then we'll remove the device.
                WaitForSingleObject(HidDevice->ReadEvent, INFINITE);
                break;
            }
        }

        // don't parse data if we are exiting.
        if (!HidDevice->fThreadEnabled) {
            WaitForSingleObject(HidDevice->ReadEvent, INFINITE);
            break;
        }

        // parse the hid report
        ParseReadReport(HidDevice);

        // post message to dispatch this report
        HidServReportDispatch(HidDevice);
    }

    // Exit Thread means completely clean up this device instance
    TRACE(("HidThreadProc (%x) Exiting...", HidDevice));

    //
    // Send any leftover button up events
    //
    if (data->IsButtonData) {
        pPrevious = data->ButtonData.PrevUsages;
        while (pPrevious->Usage){
        int j;
            // find the client that handled the button down.
            for(j=0; j<MAX_PENDING_BUTTONS; j++){
                if ( PendingButtonList[j].Collection == data->LinkUsage &&
                    PendingButtonList[j].Page == pPrevious->UsagePage &&
                    PendingButtonList[j].Usage == pPrevious->Usage){
                    PendingButtonList[j].Collection = 0;
                    PendingButtonList[j].Page = 0;
                    PendingButtonList[j].Usage = 0;
                    break;
                }
            }

            PostMessage(hWndHidServ,
                        WM_CI_USAGE,
                        (WPARAM)MakeLongUsage(data->LinkUsage,pPrevious->Usage),
                        (LPARAM)MakeLongUsage(pPrevious->UsagePage, 0));
            pPrevious++;
        }
    }

    CloseHandle(HidDevice->HidDevice);
    CloseHandle(HidDevice->ReadEvent);
    CloseHandle(HidDevice->CompletionEvent);

    INFO(("Free device data. (%x)", HidDevice));

    HidFreeDevice (HidDevice);

    InterlockedDecrement(&cThreadRef);
    TRACE(("HidThreadProc Exit complete."));
    return 0;
}

BOOL
UsageInList(
    PUSAGE_AND_PAGE   pUsage,
    PUSAGE_AND_PAGE   pUsageList
    )
/*++
Routine Description:
    This utility function returns TRUE if the usage is found in the array.
--*/
{
    while (pUsageList->Usage){
        if ( (pUsage->Usage == pUsageList->Usage) &&
            (pUsage->UsagePage == pUsageList->UsagePage))
            return TRUE;
        pUsageList++;
    }
    return FALSE;
}

void
HidServReportDispatch(
    PHID_DEVICE     HidDevice
    )
/*++
Routine Description:
    Look at the HID input structure and determine what button down,
    button up, or value data events have occurred. We send info about these events
    to the most appropriate client.
--*/
{
    USAGE_AND_PAGE *     pUsage;
    USAGE_AND_PAGE *     pPrevious;
    DWORD       i;
    PHID_DATA   data = HidDevice->InputData;

    TRACE(("Input data length = %d", HidDevice->InputDataLength));
    TRACE(("Input data -> %.8x", HidDevice->InputData));

    for (i = 0;
         i < HidDevice->InputDataLength;
         i++, data++) {

        // If Collection is 0, then make it default
        if (!data->LinkUsage)
            data->LinkUsage = CInputCollection_Consumer_Control;

        if (data->Status != HIDP_STATUS_SUCCESS){
            // never try to process errored data
            //TRACE(("Input data is invalid. Status = %x", data->Status));

        }else if (data->IsButtonData){
            TRACE(("Input data is button data:"));
            TRACE(("    Input Usage Page = %x, Collection = %x", data->UsagePage, data->LinkUsage));

            pUsage = data->ButtonData.Usages;
            pPrevious = data->ButtonData.PrevUsages;

            /// Notify clients of any button down events
            //
            while (pUsage->Usage){
            int j;
                TRACE(("    Button Usage Page = %x", pUsage->UsagePage));
                TRACE(("    Button Usage      = %x", pUsage->Usage));

                if (HidDevice->Speakers) {
                    pUsage->Usage |= HIDSERV_FROM_SPEAKER;
                }

                // is this button already down?
                for(j=0; j<MAX_PENDING_BUTTONS; j++)
                    // The Pending Button List is used to keep state for all
                    // currently pressed buttons.
                    if ( PendingButtonList[j].Collection == data->LinkUsage &&
                        PendingButtonList[j].Page == pUsage->UsagePage &&
                        PendingButtonList[j].Usage == pUsage->Usage)
                            break;
                // discard successive button downs
                if (j<MAX_PENDING_BUTTONS){
                    pUsage++;
                    continue;
                }

                // post the message
                PostMessage(hWndHidServ,
                            WM_CI_USAGE,
                            (WPARAM)MakeLongUsage(data->LinkUsage,pUsage->Usage),
                            (LPARAM)MakeLongUsage(pUsage->UsagePage, 1)
                            );

                // Add to the pending button list
                for(j=0; j<MAX_PENDING_BUTTONS; j++){
                    if (!PendingButtonList[j].Collection &&
                        !PendingButtonList[j].Page &&
                        !PendingButtonList[j].Usage){
                        PendingButtonList[j].Collection = data->LinkUsage;
                        PendingButtonList[j].Page = pUsage->UsagePage;
                        PendingButtonList[j].Usage = pUsage->Usage;
                        break;
                    }
                }

                // if it didn't make the list, send button up now.
                if (j==MAX_PENDING_BUTTONS){
                    PostMessage(    hWndHidServ,
                                    WM_CI_USAGE,
                                    (WPARAM)MakeLongUsage(data->LinkUsage,pUsage->Usage),
                                    (LPARAM)MakeLongUsage(pUsage->UsagePage, 0)
                                    );
                    WARN(("Emitting immediate button up (C=%.2x,U=%.2x,P=%.2x)", data->LinkUsage, pUsage->Usage, pUsage->UsagePage));
                }

            pUsage++;
            }

            /// Notify clients of any button up events
            //
            while (pPrevious->Usage){
            int j;
                if (!UsageInList(pPrevious, pUsage)){

                    // we have a button up.
                    //
                    TRACE(("    Button Up  (C=%.2x,U=%.2x,P=%.2x)", data->LinkUsage, pPrevious->Usage, pPrevious->UsagePage));

                    // find the client that handled the button down.
                    for(j=0; j<MAX_PENDING_BUTTONS; j++){
                        if ( PendingButtonList[j].Collection == data->LinkUsage &&
                            PendingButtonList[j].Page == pPrevious->UsagePage &&
                            PendingButtonList[j].Usage == pPrevious->Usage){
                            PendingButtonList[j].Collection = 0;
                            PendingButtonList[j].Page = 0;
                            PendingButtonList[j].Usage = 0;
                            break;
                        }
                    }

                    // post the message if client found
                    if (j<MAX_PENDING_BUTTONS){
                        PostMessage(    hWndHidServ,
                                        WM_CI_USAGE,
                                        (WPARAM)MakeLongUsage(data->LinkUsage,pPrevious->Usage),
                                        (LPARAM)MakeLongUsage(pPrevious->UsagePage, 0)
                                        );
                    } else {
                        WARN(("Button Up client not found (C=%.2x,U=%.2x,P=%.2x)", data->LinkUsage, pPrevious->Usage, pPrevious->UsagePage));
                    }
                }
                pPrevious++;
            }

            // Remember what buttons were down, so next time we can
            // detect if they come up.
            pPrevious = data->ButtonData.Usages;
            data->ButtonData.Usages = data->ButtonData.PrevUsages;
            data->ButtonData.PrevUsages = pPrevious;

         } else {
            TRACE(("Input data is value data:"));
            TRACE(("    Input Usage Page = %x, Collection = %x", data->UsagePage, data->LinkUsage));
            TRACE(("    Input Usage      = %x", data->ValueData.Usage));

            // don't send zeroes or invalid range.
            if ( data->ValueData.ScaledValue &&
                data->ValueData.LogicalRange){

                // post the message
                // rescale the data to a standard range
                PostMessage(hWndHidServ,
                            WM_CI_USAGE,
                            (WPARAM)MakeLongUsage(data->LinkUsage,data->ValueData.Usage),
                            (LPARAM)MakeLongUsage(data->UsagePage,(USHORT)(((double)data->ValueData.ScaledValue/data->ValueData.LogicalRange)*65536)));
            }
         }
    }


}

void
SendVK(
    UCHAR VKey,
    SHORT Down
    )
{
    if (InputThreadEnabled && !InputSessionLocked) {
        if (InputSessionId == 0) {
            InputVKey = VKey;
            InputDown = Down;
            InputIsAppCommand = FALSE;
            InputIsChar = FALSE;
            SetEvent(hInputEvent);
            WaitForSingleObject(hInputDoneEvent, INFINITE);
        } else {
            CrossSessionWindowMessage(Down ? WM_KEYDOWN : WM_KEYUP, VKey, 0);
        }
    }
}

void
SendChar(
    UCHAR wScan,
    SHORT Down
    )
{
    if (InputThreadEnabled && !InputSessionLocked) {
        if (InputSessionId == 0) {
            InputVKey = wScan;
            InputDown = Down;
            InputIsAppCommand = FALSE;
            InputIsChar = TRUE;
            SetEvent(hInputEvent);
            WaitForSingleObject(hInputDoneEvent, INFINITE);
        } else {
            CrossSessionWindowMessage(Down ? WM_KEYDOWN : WM_KEYUP, 0, wScan);
        }
    }
}

void
SendAppCommand(
    USHORT AppCommand
    )
{
    if (InputThreadEnabled && !InputSessionLocked) {
        if (InputSessionId == 0) {
            InputAppCommand = AppCommand;
            InputIsAppCommand = TRUE;
            InputIsChar = FALSE;
            SetEvent(hInputEvent);
            WaitForSingleObject(hInputDoneEvent, INFINITE);
        } else {
            CrossSessionWindowMessage(WM_APPCOMMAND, AppCommand, 0);
        }
    }
}

VOID
VolumeTimerHandler(
    WPARAM   TimerID
    )
/*++
Routine Description:
    This timer handler routine is called for all timeouts on auto-repeat capable
    contols.
--*/
{
    INFO(("Timer triggered, TimerId = %d", TimerID));
    WaitForSingleObject(hMutexOOC, INFINITE);

    switch (TimerID){
    case TIMERID_VOLUMEUP_VK:
        if (OOC(TIMERID_VOLUMEUP_VK)){
            SendVK(VK_VOLUME_UP, 0x1);
            OOC(TIMERID_VOLUMEUP_VK) = SetTimer(hWndHidServ, TIMERID_VOLUMEUP_VK, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_VOLUMEDN_VK:
        if (OOC(TIMERID_VOLUMEDN_VK)){
            SendVK(VK_VOLUME_DOWN, 0x1);
            OOC(TIMERID_VOLUMEDN_VK) = SetTimer(hWndHidServ, TIMERID_VOLUMEDN_VK, REPEAT_INTERVAL, NULL);
        }
        break;                              
    case TIMERID_CHANNELUP:
        if (OOC(TIMERID_CHANNELUP)){
            SendAppCommand(APPCOMMAND_MEDIA_CHANNEL_UP);
            OOC(TIMERID_CHANNELUP) = SetTimer(hWndHidServ, TIMERID_CHANNELUP, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_CHANNELDOWN:
        if (OOC(TIMERID_CHANNELDOWN)){
            SendAppCommand(APPCOMMAND_MEDIA_CHANNEL_DOWN);
            OOC(TIMERID_CHANNELDOWN) = SetTimer(hWndHidServ, TIMERID_CHANNELDOWN, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_RW:
        if (OOC(TIMERID_RW)){
            SendAppCommand(APPCOMMAND_MEDIA_REWIND);
            OOC(TIMERID_RW) = SetTimer(hWndHidServ, TIMERID_RW, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_FF:
        if (OOC(TIMERID_FF)){
            SendAppCommand(APPCOMMAND_MEDIA_FAST_FORWARD);
            OOC(TIMERID_FF) = SetTimer(hWndHidServ, TIMERID_FF, REPEAT_INTERVAL, NULL);
        }
        break;                              
    case TIMERID_VOLUMEUP:
        if (OOC(TIMERID_VOLUMEUP)){
            SendAppCommand(APPCOMMAND_VOLUME_UP);
            OOC(TIMERID_VOLUMEUP) = SetTimer(hWndHidServ, TIMERID_VOLUMEUP, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_VOLUMEDN:
        if (OOC(TIMERID_VOLUMEDN)){
            SendAppCommand(APPCOMMAND_VOLUME_DOWN);
            OOC(TIMERID_VOLUMEDN) = SetTimer(hWndHidServ, TIMERID_VOLUMEDN, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_BASSUP:
        if (OOC(TIMERID_BASSUP)){
            SendAppCommand(APPCOMMAND_BASS_UP);
            OOC(TIMERID_BASSUP) = SetTimer(hWndHidServ, TIMERID_BASSUP, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_BASSDN:
        if (OOC(TIMERID_BASSDN)){
            SendAppCommand(APPCOMMAND_BASS_DOWN);
            OOC(TIMERID_BASSDN) = SetTimer(hWndHidServ, TIMERID_BASSDN, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_TREBLEUP:
        if (OOC(TIMERID_TREBLEUP)){
            SendAppCommand(APPCOMMAND_TREBLE_UP);
            OOC(TIMERID_TREBLEUP) = SetTimer(hWndHidServ, TIMERID_TREBLEUP, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_TREBLEDN:
        if (OOC(TIMERID_TREBLEDN)){
            SendAppCommand(APPCOMMAND_TREBLE_DOWN);
            OOC(TIMERID_TREBLEDN) = SetTimer(hWndHidServ, TIMERID_TREBLEDN, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_APPBACK:
        if (OOC(TIMERID_APPBACK)){
            SendVK(VK_BROWSER_BACK, 0x1);
            OOC(TIMERID_APPBACK) = SetTimer(hWndHidServ, TIMERID_APPBACK, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_APPFORWARD:
        if (OOC(TIMERID_APPFORWARD)){
            SendVK(VK_BROWSER_FORWARD, 0x1);
            OOC(TIMERID_APPFORWARD) = SetTimer(hWndHidServ, TIMERID_APPFORWARD, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_PREVTRACK:
        if (OOC(TIMERID_PREVTRACK)){
            SendVK(VK_MEDIA_PREV_TRACK, 0x1);
            OOC(TIMERID_PREVTRACK) = SetTimer(hWndHidServ, TIMERID_PREVTRACK, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_NEXTTRACK:
        if (OOC(TIMERID_NEXTTRACK)){
            SendVK(VK_MEDIA_NEXT_TRACK, 0x1);
            OOC(TIMERID_NEXTTRACK) = SetTimer(hWndHidServ, TIMERID_NEXTTRACK, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_KEYPAD_LPAREN:
        if (OOC(TIMERID_KEYPAD_LPAREN)) {
            SendChar(L'(', 0x1);
            OOC(TIMERID_KEYPAD_LPAREN) = SetTimer(hWndHidServ, TIMERID_KEYPAD_LPAREN, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_KEYPAD_RPAREN:
        if (OOC(TIMERID_KEYPAD_RPAREN)) {
            SendChar(L')', 0x1);
            OOC(TIMERID_KEYPAD_RPAREN) = SetTimer(hWndHidServ, TIMERID_KEYPAD_RPAREN, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_KEYPAD_AT:
        if (OOC(TIMERID_KEYPAD_AT)) {
            SendChar(L'@', 0x1);
            OOC(TIMERID_KEYPAD_AT) = SetTimer(hWndHidServ, TIMERID_KEYPAD_AT, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_KEYPAD_EQUAL:
        if (OOC(TIMERID_KEYPAD_EQUAL)) {
            SendChar(L'=', 0x1);
            OOC(TIMERID_KEYPAD_EQUAL) = SetTimer(hWndHidServ, TIMERID_KEYPAD_EQUAL, REPEAT_INTERVAL, NULL);
        }
        break;
    }

    ReleaseMutex(hMutexOOC);
}

void
HidRepeaterCharButtonDown(
    UINT TimerId,
    SHORT Value,
    UCHAR WScan
    )
{
   INFO(("Received update char,value = %d, TimerId = %d", Value, TimerId));
   WaitForSingleObject(hMutexOOC, INFINITE);
   if (Value){
       if (!OOC(TimerId)){
           SendChar(WScan, 0x1);
           OOC(TimerId) = SetTimer(hWndHidServ, TimerId, INITIAL_WAIT, NULL);
       }
   } else {
       KillTimer(hWndHidServ, TimerId);
       OOC(TimerId) = 0;
       SendChar(WScan, 0x0);
   }
   ReleaseMutex(hMutexOOC);

}


void
HidRepeaterVKButtonDown(
    UINT TimerId,
    SHORT Value,
    UCHAR VKey
    )
{
    INFO(("Received update vk,value = %d, TimerId = %d", Value, TimerId));
    WaitForSingleObject(hMutexOOC, INFINITE);
    if (Value){
        if (!OOC(TimerId)){
            SendVK(VKey, 0x1);
            OOC(TimerId) = SetTimer(hWndHidServ, TimerId, INITIAL_WAIT, NULL);
        }
    } else {
        KillTimer(hWndHidServ, TimerId);
        OOC(TimerId) = 0;
        SendVK(VKey, 0x0);
    }
    ReleaseMutex(hMutexOOC);
}

void
HidServUpdate(
    DWORD   LongUsage,
    DWORD   LongValue
    )
/*++
Routine Description:
    This is the client routine for the default handler. This client attempts to satisfy
    input events by injecting appcommands or keypresses to the current input window.
--*/
{
    USAGE Collection = (USAGE)HIWORD(LongUsage);
    USAGE Usage = (USAGE)LOWORD(LongUsage);
    USAGE Page = (USAGE)HIWORD(LongValue);
    SHORT Value = (SHORT)LOWORD(LongValue);
    BOOLEAN fromSpeaker = ((Usage & HIDSERV_FROM_SPEAKER) == HIDSERV_FROM_SPEAKER);

    Usage &= ~HIDSERV_FROM_SPEAKER;

    INFO(("Update collection = %x", Collection));
    INFO(("Update page  = %x", Page));
    INFO(("Update usage = %x", Usage));
    INFO(("Update data  = %d", Value));

    if (Collection == CInputCollection_Consumer_Control){

        // NOTE: If we ever choose to support this page thing, keep in mind
        // that the Altec Lansing ADA 70s report page zero. Should take out
        // the consumer page and make it the default.
        switch (Page) {
        case HID_USAGE_PAGE_UNDEFINED:
        case HID_USAGE_PAGE_CONSUMER:
            switch (Usage){
            /// Button Usages
            //

            //
            // These buttons have auto repeat capability...
            // delay for .5 sec before auto repeat kicks in.
            //
            case CInputUsage_Volume_Increment:
                INFO(("Volume increment."));
                if (fromSpeaker) {
                    INFO(("From speaker."));
                    WaitForSingleObject(hMutexOOC, INFINITE);
                    if (Value){
                        if (!OOC(TIMERID_VOLUMEUP)){
                            SendAppCommand(APPCOMMAND_VOLUME_UP);
                            OOC(TIMERID_VOLUMEUP) = SetTimer(hWndHidServ, TIMERID_VOLUMEUP, INITIAL_WAIT, NULL);
                        }
                    } else {
                        KillTimer(hWndHidServ, TIMERID_VOLUMEUP);
                        OOC(TIMERID_VOLUMEUP) = 0;
                    }
                    ReleaseMutex(hMutexOOC);
                } else {
                    INFO(("From keyboard."));
                    HidRepeaterVKButtonDown(TIMERID_VOLUMEUP_VK, Value, VK_VOLUME_UP);
                }
                break;
            case CInputUsage_Volume_Decrement:
                INFO(("Volume decrement."));
                if (fromSpeaker) {
                    INFO(("From speaker."));
                    WaitForSingleObject(hMutexOOC, INFINITE);
                    if (Value){
                        if (!OOC(TIMERID_VOLUMEDN)){
                            SendAppCommand(APPCOMMAND_VOLUME_DOWN);
                            OOC(TIMERID_VOLUMEDN) = SetTimer(hWndHidServ, TIMERID_VOLUMEDN, INITIAL_WAIT, NULL);
                        }
                    } else {
                        KillTimer(hWndHidServ, TIMERID_VOLUMEDN);
                        OOC(TIMERID_VOLUMEDN) = 0;
                    }
                    ReleaseMutex(hMutexOOC);
                } else {
                    INFO(("From keyboard."));
                    HidRepeaterVKButtonDown(TIMERID_VOLUMEDN_VK, Value, VK_VOLUME_DOWN);
                }
                break;
            case CInputUsage_App_Back:
                INFO(("App Back."));
                HidRepeaterVKButtonDown(TIMERID_APPBACK, Value, VK_BROWSER_BACK);
                break;
            case CInputUsage_App_Forward:
                INFO(("App Forward."));
                HidRepeaterVKButtonDown(TIMERID_APPFORWARD, Value, VK_BROWSER_FORWARD);
                break;
            case CInputUsage_Scan_Previous_Track:
                INFO(("Media Previous Track."));
                HidRepeaterVKButtonDown(TIMERID_PREVTRACK, Value, VK_MEDIA_PREV_TRACK);
                break;
            case CInputUsage_Scan_Next_Track:
                INFO(("Media Next Track."));
                HidRepeaterVKButtonDown(TIMERID_NEXTTRACK, Value, VK_MEDIA_NEXT_TRACK);
                break;

            case CInputUsage_Bass_Increment:
                INFO(("Bass increment."));
                WaitForSingleObject(hMutexOOC, INFINITE);
                if (Value){
                    if (!OOC(TIMERID_BASSUP)){
                        SendAppCommand(APPCOMMAND_BASS_UP);
                        OOC(TIMERID_BASSUP) = SetTimer(hWndHidServ, TIMERID_BASSUP, INITIAL_WAIT, NULL);
                    }
                } else {
                    KillTimer(hWndHidServ, TIMERID_BASSUP);
                    OOC(TIMERID_BASSUP) = 0;
                }
                ReleaseMutex(hMutexOOC);
                break;
            case CInputUsage_Bass_Decrement:
                INFO(("Bass decrement."));
                WaitForSingleObject(hMutexOOC, INFINITE);
                if (Value){
                    if (!OOC(TIMERID_BASSDN)){
                        SendAppCommand(APPCOMMAND_BASS_DOWN);
                        OOC(TIMERID_BASSDN) = SetTimer(hWndHidServ, TIMERID_BASSDN, INITIAL_WAIT, NULL);
                    }
                } else {
                    KillTimer(hWndHidServ, TIMERID_BASSDN);
                    OOC(TIMERID_BASSDN) = 0;
                }
                ReleaseMutex(hMutexOOC);
                break;

            case CInputUsage_Treble_Increment:
                INFO(("Treble increment."));
                WaitForSingleObject(hMutexOOC, INFINITE);
                if (Value){
                    if (!OOC(TIMERID_TREBLEUP)){
                        SendAppCommand(APPCOMMAND_TREBLE_UP);
                        OOC(TIMERID_TREBLEUP) = SetTimer(hWndHidServ, TIMERID_TREBLEUP, INITIAL_WAIT, NULL);
                    }
                } else {
                    KillTimer(hWndHidServ, TIMERID_TREBLEUP);
                    OOC(TIMERID_TREBLEUP) = 0;
                }
                ReleaseMutex(hMutexOOC);
                break;
            case CInputUsage_Treble_Decrement:
                INFO(("Treble decrement."));
                WaitForSingleObject(hMutexOOC, INFINITE);
                if (Value){
                    if (!OOC(TIMERID_TREBLEDN)){
                        SendAppCommand(APPCOMMAND_TREBLE_DOWN);
                        OOC(TIMERID_TREBLEDN) = SetTimer(hWndHidServ, TIMERID_TREBLEDN, INITIAL_WAIT, NULL);
                    }
                } else {
                    KillTimer(hWndHidServ, TIMERID_TREBLEDN);
                    OOC(TIMERID_TREBLEDN) = 0;
                }
                ReleaseMutex(hMutexOOC);
                break;

            // eHome remote control buttons
            case CInputUsage_Fast_Forward:
                INFO(("Fast Forward."));
                WaitForSingleObject(hMutexOOC, INFINITE);
                if (Value){
                    if (!OOC(TIMERID_FF)){
                        SendAppCommand(APPCOMMAND_MEDIA_FAST_FORWARD);
                        OOC(TIMERID_FF) = SetTimer(hWndHidServ, TIMERID_FF, INITIAL_WAIT, NULL);
                    }
                } else {
                    KillTimer(hWndHidServ, TIMERID_FF);
                    OOC(TIMERID_FF) = 0;
                }
                ReleaseMutex(hMutexOOC);
                break;
            case CInputUsage_Rewind:
                INFO(("Fast Forward."));
                WaitForSingleObject(hMutexOOC, INFINITE);
                if (Value){
                    if (!OOC(TIMERID_RW)){
                        SendAppCommand(APPCOMMAND_MEDIA_REWIND);
                        OOC(TIMERID_RW) = SetTimer(hWndHidServ, TIMERID_RW, INITIAL_WAIT, NULL);
                    }
                } else {
                    KillTimer(hWndHidServ, TIMERID_RW);
                    OOC(TIMERID_RW) = 0;
                }
                ReleaseMutex(hMutexOOC);
                break;
            case CInputUsage_Channel_Increment:
                INFO(("Fast Forward."));
                WaitForSingleObject(hMutexOOC, INFINITE);
                if (Value){
                    if (!OOC(TIMERID_CHANNELUP)){
                        SendAppCommand(APPCOMMAND_MEDIA_CHANNEL_UP);
                        OOC(TIMERID_CHANNELUP) = SetTimer(hWndHidServ, TIMERID_CHANNELUP, INITIAL_WAIT, NULL);
                    }
                } else {
                    KillTimer(hWndHidServ, TIMERID_CHANNELUP);
                    OOC(TIMERID_CHANNELUP) = 0;
                }
                ReleaseMutex(hMutexOOC);
                break;
            case CInputUsage_Channel_Decrement:
                INFO(("Fast Forward."));
                WaitForSingleObject(hMutexOOC, INFINITE);
                if (Value){
                    if (!OOC(TIMERID_CHANNELDOWN)){
                        SendAppCommand(APPCOMMAND_MEDIA_CHANNEL_DOWN);
                        OOC(TIMERID_CHANNELDOWN) = SetTimer(hWndHidServ, TIMERID_CHANNELDOWN, INITIAL_WAIT, NULL);
                    }
                } else {
                    KillTimer(hWndHidServ, TIMERID_CHANNELDOWN);
                    OOC(TIMERID_CHANNELDOWN) = 0;
                }
                ReleaseMutex(hMutexOOC);
                break;


            // These buttons do not auto repeat...
            
            // eHome remote control buttons
            case CInputUsage_Play:
                if (Value){
                    INFO(("Play."));
                    SendAppCommand(APPCOMMAND_MEDIA_PLAY);
                }
                break;
            case CInputUsage_Pause:
                if (Value){
                    INFO(("Pause."));
                    SendAppCommand(APPCOMMAND_MEDIA_PAUSE);
                }
                break;
            case CInputUsage_Record:
                if (Value){
                    INFO(("Record."));
                    SendAppCommand(APPCOMMAND_MEDIA_RECORD);
                }
                break;                              
            
            // regular
            case CInputUsage_Loudness:
                if (Value){
                    INFO(("Toggle Loudness."));
                    //SendAppCommandEx(??);
                }
                break;
            case CInputUsage_Bass_Boost:
                if (Value) {
                    INFO(("Toggle BassBoost."));
                    SendAppCommand(APPCOMMAND_BASS_BOOST);
                }
                break;
            case CInputUsage_Mute:
                INFO(("Toggle Mute."));
                if (fromSpeaker) {
                    INFO(("From speaker."));
                    if (Value) {
                        SendAppCommand(APPCOMMAND_VOLUME_MUTE);
                    }
                } else {
                    INFO(("From keyboard."));
                    SendVK(VK_VOLUME_MUTE, Value);
                }
                break;
            case CInputUsage_Play_Pause:
                INFO(("Media Play/Pause."));
                SendVK(VK_MEDIA_PLAY_PAUSE, Value);
                break;
            case CInputUsage_Stop:
                INFO(("Media Stop."));
                SendVK(VK_MEDIA_STOP, Value);
                break;
            case CInputUsage_Launch_Configuration:
                INFO(("Launch Configuration."));
                SendVK(VK_LAUNCH_MEDIA_SELECT, Value);
                break;
            case CInputUsage_Launch_Email:
                INFO(("Launch Email."));
                SendVK(VK_LAUNCH_MAIL, Value);
                break;
            case CInputUsage_Launch_Calculator:
                INFO(("Launch Calculator."));
                SendVK(VK_LAUNCH_APP2, Value);
                break;
            case CInputUsage_Launch_Browser:
                INFO(("Launch Browser."));
                SendVK(VK_LAUNCH_APP1, Value);
                break;
            case CInputUsage_App_Search:
                INFO(("App Search."));
                SendVK(VK_BROWSER_SEARCH, Value);
                break;
            case CInputUsage_App_Home:
                INFO(("App Home."));
                SendVK(VK_BROWSER_HOME, Value);
                break;
            case CInputUsage_App_Stop:
                INFO(("App Stop."));
                SendVK(VK_BROWSER_STOP, Value);
                break;
            case CInputUsage_App_Refresh:
                INFO(("App Refresh."));
                SendVK(VK_BROWSER_REFRESH, Value);
                break;
            case CInputUsage_App_Bookmarks:
                INFO(("App Bookmarks."));
                SendVK(VK_BROWSER_FAVORITES, Value);
                break;

            case CInputUsage_App_Previous:
                if (Value){
                    INFO(("App Previous."));
                    //SendAppCommand(??);
                }
                break;

            case CInputUsage_App_Next:
                if (Value){
                    INFO(("App Next."));
                    //SendAppCommand(??);
                }
                break;
#if(0)
            // New buttons
            case CInputUsage_App_Help:
                if (Value) {
                    INFO(("App Help"));
                    SendAppCommand(APPCOMMAND_HELP);
                }
                break;

            case CInputUsage_App_Find:
                if (Value) {
                    INFO(("App Find"));
                    SendAppCommand(APPCOMMAND_FIND);
                }
                break;

            case CInputUsage_App_New:
                if (Value) {
                    INFO(("App New"));
                    SendAppCommand(APPCOMMAND_NEW);
                }
                break;

            case CInputUsage_App_Open:
                if (Value) {
                    INFO(("App Open"));
                    SendAppCommand(APPCOMMAND_OPEN);
                }
                break;

            case CInputUsage_App_Close:
                if (Value) {
                    INFO(("App Close"));
                    SendAppCommand(APPCOMMAND_CLOSE);
                }
                break;

            case CInputUsage_App_Save:
                if (Value) {
                    INFO(("App Save"));
                    SendAppCommand(APPCOMMAND_SAVE);
                }
                break;

            case CInputUsage_App_Print:
                if (Value) {
                    INFO(("App Print"));
                    SendAppCommand(APPCOMMAND_PRINT);
                }
                break;

            case CInputUsage_App_Undo:
                if (Value) {
                    INFO(("App Undo"));
                    SendAppCommand(APPCOMMAND_UNDO);
                }
                break;

            case CInputUsage_App_Redo:
                if (Value) {
                    INFO(("App Redo"));
                    SendAppCommand(APPCOMMAND_REDO);
                }
                break;

            case CInputUsage_App_Copy:
                if (Value) {
                    INFO(("App Copy"));
                    SendAppCommand(APPCOMMAND_COPY);
                }
                break;

            case CInputUsage_App_Cut:
                if (Value) {
                    INFO(("App Cut"));
                    SendAppCommand(APPCOMMAND_CUT);
                }
                break;

            case CInputUsage_App_Paste:
                if (Value) {
                    INFO(("App Paste"));
                    SendAppCommand(APPCOMMAND_PASTE);
                }
                break;

            case CInputUsage_App_Reply_To_Mail:
                if (Value) {
                    INFO(("App Reply To Mail"));
                    SendAppCommand(APPCOMMAND_REPLY_TO_MAIL);
                }
                break;

            case CInputUsage_App_Forward_Mail:
                if (Value) {
                    INFO(("App Forward Mail"));
                    SendAppCommand(APPCOMMAND_FORWARD_MAIL);
                }
                break;

            case CInputUsage_App_Send_Mail:
                if (Value) {
                    INFO(("App Send Mail"));
                    SendAppCommand(APPCOMMAND_SEND_MAIL);
                }
                break;

            case CInputUsage_App_Spell_Check:
                if (Value) {
                    INFO(("App Spell Check"));
                    SendAppCommand(APPCOMMAND_SPELL_CHECK);
                }
                break;
#endif

            /// Value Usages
            //  These are not buttons, but are "value" events and do not have
            //  a corresponding button up event. Also, these never have an
            //  auto repeat function.
            case CInputUsage_Volume:
                INFO(("Volume dial"));
                if (Value>0) SendAppCommand(APPCOMMAND_VOLUME_UP);
                else if (Value<0)SendAppCommand(APPCOMMAND_VOLUME_DOWN);
                break;
            case CInputUsage_Bass:
                INFO(("Bass dial"));
                if (Value>0) SendAppCommand(APPCOMMAND_BASS_UP);
                else if (Value<0)SendAppCommand(APPCOMMAND_BASS_DOWN);
                break;
            case CInputUsage_Treble:
                INFO(("Treble dial"));
                if (Value>0) SendAppCommand(APPCOMMAND_TREBLE_UP);
                else if (Value<0)SendAppCommand(APPCOMMAND_TREBLE_DOWN);
                break;

            ////
            /// Media Select usages are not handled in this sample.
            //

            default:
                INFO(("Unhandled Usage (%x)", Usage));
                break;
            }
            break;
#if(0)
        case HID_USAGE_PAGE_KEYBOARD:

           switch (Usage) {
           case CInputUsage_Keypad_Equals:
              INFO(("Keypad ="));
              HidRepeaterCharButtonDown(TIMERID_KEYPAD_EQUAL, Value, L'=');
              break;
           case CInputUsage_Keypad_LParen:
              INFO(("Keypad ("));
              HidRepeaterCharButtonDown(TIMERID_KEYPAD_LPAREN, Value, L'(');
              break;
           case CInputUsage_Keypad_RParen:
              INFO(("Keypad )"));
              HidRepeaterCharButtonDown(TIMERID_KEYPAD_RPAREN, Value, L')');
              break;
           case CInputUsage_Keypad_At:
              INFO(("Keypad @"));
              HidRepeaterCharButtonDown(TIMERID_KEYPAD_AT, Value, L'@');
              break;
           }
           break;
#endif
        default:
           INFO(("Unhandled Page (%x)", Page));
           break;
        }

    } else {
        INFO(("Unhandled Collection (%x), usage = %x", Collection, Usage));
    }

}

BOOL
DeviceChangeHandler(
    WPARAM wParam,
    LPARAM lParam
    )
/*++
Routine Description:
    This is the handler for WM_DEVICECHANGE messages and is called
    whenever a device node is added or removed in the system. This
    event will cause us to refrsh our device information.
--*/
{
    struct _DEV_BROADCAST_HEADER    *pdbhHeader;
    pdbhHeader = (struct _DEV_BROADCAST_HEADER *)lParam;

    switch (wParam) {
    case DBT_DEVICEQUERYREMOVE :
        TRACE(("DBT_DEVICEQUERYREMOVE, fall through to..."));

        //
        // Fall thru.
        //

    case DBT_DEVICEREMOVECOMPLETE:
        TRACE(("DBT_DEVICEREMOVECOMPLETE"));

        TRACE(("dbcd_devicetype %x", pdbhHeader->dbcd_devicetype));
        if (pdbhHeader->dbcd_devicetype==DBT_DEVTYP_HANDLE)
        {
        PDEV_BROADCAST_HANDLE pdbHandle = (PDEV_BROADCAST_HANDLE)lParam;
            INFO(("Closing HID device (%x).", pdbHandle->dbch_handle));
            DestroyDeviceByHandle(pdbHandle->dbch_handle);
            break;
        }
        break;
    case DBT_DEVICEQUERYREMOVEFAILED:
        TRACE(("DBT_DEVICEQUERYREMOVEFAILED, fall through to..."));
        // The notification handle has already been closed
        // so we should never actually get this message. If we do,
        // falling through to device arrival is the correct thing to do.

        //
        // Fall thru.
        //

    case DBT_DEVICEARRIVAL:
        TRACE(("DBT_DEVICEARRIVAL: reenumerate"));
        TRACE(("dbcd_devicetype %x", pdbhHeader->dbcd_devicetype));
        if (pdbhHeader->dbcd_devicetype==DBT_DEVTYP_DEVICEINTERFACE)
        {
            // We will refresh our device info for any devnode arrival or removal.
            INFO(("HID device refresh."));
            PostMessage(hWndHidServ, WM_HIDSERV_PNP_HID, 0, 0);
            break;
        }
    }

    return TRUE;
}

VOID
HidKeyboardSettingsChange(WPARAM WParam)
{
    if (WParam == SPI_SETKEYBOARDSPEED ||
        WParam == SPI_SETKEYBOARDDELAY) {
        DWORD dwV;
        int v;
        //
        // The repeat rate has changed. Adjust the timer interval.
        // The keyboard delay has changed. Adjust the timer interval.
        //
        INFO(("Getting keyboard repeat rate."));
        SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, &dwV, 0);
        REPEAT_INTERVAL = 400 - (12*dwV);

        INFO(("Getting keyboard delay."));
        SystemParametersInfo(SPI_GETKEYBOARDDELAY, 0, &v, 0);
        INITIAL_WAIT = (1+v)*250;
    }
}

LRESULT
CALLBACK
HidServProc(
    HWND            hWnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
    )
/*++
Routine Description:
    The primary message queue for the app.
--*/
{

    TRACE(("HidServProc uMsg=%x", uMsg));


    switch (uMsg)
    {

    // init
    case WM_CREATE :
        TRACE(("WM_CREATE"));
        //
        // Find out the default key values
        //
        HidKeyboardSettingsChange(SPI_SETKEYBOARDSPEED);
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
        break;

    // start
    case WM_HIDSERV_START :
        TRACE(("WM_HIDSERV_START"));
        HidServStart();
        break;

    // stop
    case WM_HIDSERV_STOP :
        TRACE(("WM_HIDSERV_STOP"));
        HidServStop();
        break;

    // configuration change
    case WM_DEVICECHANGE:
        TRACE(("WM_DEVICECHANGE"));
        DeviceChangeHandler(wParam, lParam);
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
        break;

    // Process Consumer Input usage
    case WM_CI_USAGE:
        TRACE(("WM_CI_USAGE"));
        HidServUpdate((DWORD)wParam, (DWORD)lParam);
        break;

    // HID device list refresh.
    case WM_HIDSERV_PNP_HID:
        TRACE(("WM_HIDSERV_PNP_HID"));
        if (PnpEnabled){
            INFO(("HID DeviceChange rebuild."));
            RebuildHidDeviceList();
            TRACE(("DeviceChange rebuild done."));
        }
        break;

#if WIN95_BUILD
    // Stop the specified hid device that has already been removed from
    // the global list.
    case WM_HIDSERV_STOP_DEVICE:
        StopHidDevice((PHID_DEVICE) lParam);
        break;
#endif // WIN95_BUILD

    // Process Timer
    case WM_TIMER:
        TRACE(("WM_TIMER"));

        // All auto-repeat controls handled here.
        VolumeTimerHandler(wParam); // wParam is Timer ID.
        break;

    // Usually an app need not respond to suspend/resume events, but there
    // have been problems with keeping some system handles open. So on
    // suspend, we close everything down except this message loop. On resume,
    // we bring it all back.
    case WM_POWERBROADCAST:
        TRACE(("WM_POWERBROADCAST"));
        switch ( (DWORD)wParam )
        {
        case PBT_APMQUERYSUSPEND:
            TRACE(("\tPBT_APMQUERYSUSPEND"));
            HidservSetPnP(FALSE);
            break;

        case PBT_APMQUERYSUSPENDFAILED:
            TRACE(("\tPBT_APMQUERYSUSPENDFAILED"));
            HidservSetPnP(TRUE);
            break;

        case PBT_APMSUSPEND:
            TRACE(("\tPBT_APMSUSPEND"));

            // Handle forced suspend
            if(PnpEnabled) {
                // Prevent any device refresh.
                HidservSetPnP(FALSE);
            }
            break;

        case PBT_APMRESUMESUSPEND:
            TRACE(("\tPBT_APMRESUMESUSPEND"));
            HidservSetPnP(TRUE);
            break;

        case PBT_APMRESUMEAUTOMATIC:
            TRACE(("\tPBT_APMRESUMEAUTOMATIC"));
            HidservSetPnP(TRUE);
            break;

        }
        break;

    // close
    case WM_CLOSE :
        TRACE(("WM_CLOSE"));
        HidServExit();
        PostMessage(hWndHidServ, WM_QUIT, 0, 0);
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
        break;

    case WM_WTSSESSION_CHANGE:
        WARN(("WM_WTSSESSION_CHANGE type %x, session %d", wParam, lParam));
        switch (wParam) {
        case WTS_CONSOLE_CONNECT:
            InputSessionId = (ULONG)lParam;
            InputSessionLocked = FALSE;
            break;
        case WTS_CONSOLE_DISCONNECT:
            if (InputSessionId == (ULONG)lParam) {
                InputSessionId = 0;
            }
            break;
        case WTS_SESSION_LOCK:
            if (InputSessionId == (ULONG)lParam) {
                InputSessionLocked = TRUE;
            }
            break;
        case WTS_SESSION_UNLOCK:
            if (InputSessionId == (ULONG)lParam) {
                InputSessionLocked = FALSE;
            }
            break;
        }
        break;

    case WM_SETTINGCHANGE:
        HidKeyboardSettingsChange(wParam);
        TRACE(("WM_SETTINGCHANGE"));

    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidserv\hidserv.h ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       hidaudio.h
 *  Purpose:    main application header
 *
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#ifndef _HIDSERV_H_
#define _HIDSERV_H_

////
///  Defines
//

#define STRICT

#ifndef GLOBALS
#define GLOBALS extern
#define  EQU  ; / ## /
#else
#define  EQU  =
#endif //GLOBALS

#define HIDSERV_USAGE_PAGE   0x0c

// default step size is 4% of max volume.
#define DEFAULT_STEP        ((int)(65535/25))
#define MAX_BUTTON_LIST     10

// APP messages
#define WM_HIDSERV_START                         (WM_APP+301)
#define WM_HIDSERV_STOP                          (WM_APP+302)
#define WM_HIDSERV_REPORT_DISPATCH               (WM_APP+304)
#define WM_HIDSERV_SERVICE_REQUEST               (WM_APP+305)
#define WM_HIDSERV_INPUT_CLIENT                  (WM_APP+306)
#define WM_HIDSERV_MEDIAFOCUS_CLIENT             (WM_APP+307)
#define WM_HIDSERV_SETMEDIAFOCUS                 (WM_APP+308)
#define WM_HIDSERV_MEDIAFOCUS_NOTIFY             (WM_APP+309)
#define WM_HIDSERV_PNP_HID                       (WM_APP+310)
#if WIN95_BUILD
#define WM_HIDSERV_STOP_DEVICE                   (WM_APP+311)
#endif // WIN95_BUILD

#define WM_CUSTOM_USAGE                        (WM_APP+313)

// CInput Messages
//
#define WM_CI_USAGE                        (WM_APP+314)
#define WM_CI_MEDIA_FOCUS                  (WM_APP+315)
#define WM_CI_DEVICE_CHANGE                (WM_APP+316)


#define TIMERID_BASE            3
#define TIMERID_TOP             22

#define TIMERID_VOLUMEUP        3
#define TIMERID_VOLUMEDN        4
#define TIMERID_BASSUP          5
#define TIMERID_BASSDN          6
#define TIMERID_TREBLEUP        7
#define TIMERID_TREBLEDN        8
#define TIMERID_APPBACK         9
#define TIMERID_APPFORWARD      10
#define TIMERID_PREVTRACK       11
#define TIMERID_NEXTTRACK       12
#define TIMERID_VOLUMEUP_VK     13
#define TIMERID_VOLUMEDN_VK     14
#define TIMERID_KEYPAD_LPAREN   15
#define TIMERID_KEYPAD_RPAREN   16
#define TIMERID_KEYPAD_AT       17
#define TIMERID_KEYPAD_EQUAL    18

#define TIMERID_CHANNELUP       19
#define TIMERID_CHANNELDOWN     20
#define TIMERID_FF              21
#define TIMERID_RW              22


#define MAX_MEDIA_TYPES         33
#define MAX_CLIENTS             16
#define MAX_USAGE_LIST          32
#define MAX_PENDING_BUTTONS     16

#define MakeLongUsage(c,u)  ((ULONG)(c<<16) | (u))

#define SET_SERVICE_STATE(Status) if(hService){ ServiceStatus.dwCurrentState = Status; \
                                    SetServiceStatus(hService, &ServiceStatus);}

////
///  Includes
//
#include <windows.h>
#include <windowsx.h>
#include <winuser.h>
#include <shellapi.h>
#include <mmsystem.h>
#include <math.h>

#include <basetyps.h>
#include <wtypes.h>
#include <setupapi.h>
#include <hidsdi.h>
#include <dbt.h>
#include <regstr.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

// Local includes
#include "hid.h"
#include "list.h"
#include "dbg.h"

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define ContainingRecord(address, type, field) ((type *)( \
                          (PCHAR)(address) - \
                          (PCHAR)(&((type *)0)->field)))


// Data Types
//
typedef unsigned long CI_CLIENT_ID;

typedef UINT_PTR OOC_STATE;

typedef struct _Pending_Button{
    USAGE    Collection;
    USAGE    Page;
    USAGE    Usage;
} PENDING_BUTTON, *PPENDING_BUTTON;

typedef LONG (WINAPI *WINSTATIONSENDWINDOWMESSAGE)
       (HANDLE  hServer,
        ULONG   sessionID,
        ULONG   timeOut,
        ULONG   hWnd,
        ULONG   Msg,
        WPARAM  wParam,
        LPARAM  lParam,
        LONG    *pResponse);

////
///  Globals
//

// Linked list of current hid devices
GLOBALS LIST_NODE       HidDeviceList;

GLOBALS BOOL            PnpEnabled      EQU FALSE;
GLOBALS HDEVNOTIFY      hNotifyArrival  EQU 0;

// This timeout (150ms) is selected to allow the control to cover the range
// (25 steps) in about 5 sec..
GLOBALS UINT            INITIAL_WAIT    EQU 500;
GLOBALS UINT            REPEAT_INTERVAL EQU 150;

// The instance and hwnd for the main thread.
GLOBALS HANDLE          hInstance       EQU 0;
GLOBALS HWND            hWndHidServ     EQU 0;

// how many threads are active?
GLOBALS ULONG           cThreadRef      EQU 0;

// Access to OOC state data is mutex protected.
GLOBALS OOC_STATE       OOC_State[TIMERID_TOP-TIMERID_BASE+1];
GLOBALS HANDLE          hMutexOOC       EQU 0;

GLOBALS PENDING_BUTTON          PendingButtonList[MAX_PENDING_BUTTONS];

// NT Service data
GLOBALS SERVICE_STATUS_HANDLE  hService EQU 0;
GLOBALS TCHAR HidservServiceName[]      EQU TEXT("HidServ");
GLOBALS SERVICE_STATUS ServiceStatus;

// The event signalling that there is input to send.
GLOBALS HANDLE hInputEvent;
GLOBALS HANDLE hDesktopSwitch;
GLOBALS HANDLE hInputDoneEvent;
GLOBALS BOOLEAN InputIsAppCommand;
GLOBALS BOOLEAN InputIsChar;
GLOBALS UCHAR InputVKey;
GLOBALS SHORT InputDown;
GLOBALS USHORT InputAppCommand;
GLOBALS BOOL InputThreadEnabled;
GLOBALS DWORD InputThreadId;
GLOBALS DWORD MessagePumpThreadId;
GLOBALS ULONG InputSessionId;
GLOBALS BOOLEAN InputSessionLocked;
GLOBALS HINSTANCE WinStaDll;
GLOBALS WINSTATIONSENDWINDOWMESSAGE WinStaProc;

/*
            WinStationSendWindowMessage(
                SERVERNAME_CURRENT,        // global server handle
                InputSessionId,            // session id
                5,                         // wait in seconds
                NULL,                      // handle of destination window
                Down ? WM_KEYDOWN : WM_KEYUP,
                Vkey,                      // wParam
                1,                         // lParam - input is char
                NULL);                     // No response
*/
#define CrossSessionWindowMessage(m, w, l) \
    if (WinStaProc) { LONG response; \
    WinStaProc (NULL, InputSessionId, 5, HandleToUlong(hWndHidServ), (m), (w), (l), &response); }

#define OOC(_x_) OOC_State[_x_ - TIMERID_BASE]

////
/// Prototypes
//

//hidaudio.c

DWORD
WINAPI
HidServMain(
    HANDLE InitDoneEvent
    );

DWORD
WINAPI
ThreadMain(
    HWND hwnd,
    HINSTANCE hInst,
    LPSTR szCmd,
    int nShow
    );

BOOL
HidServInit(
    void
    );

void
HidServExit(
    void
    );

DWORD
WINAPI
HidThreadProc(
   PHID_DEVICE    HidDevice
   );

DWORD
WINAPI
HidThreadInputProc(
    PVOID Ignore
    );

DWORD
WINAPI
HidMessagePump(
    PVOID Ignore
    );

VOID
HidFreeDevice(PHID_DEVICE HidDevice);

BOOL
UsageInList(
    PUSAGE_AND_PAGE   pUsage,
    PUSAGE_AND_PAGE   pUsageList
    );

void
CustomUsageDispatch(
    USAGE   Collection,
    USAGE   Usage,
    LONG    Data
    );

void
HidServReportDispatch(
    PHID_DEVICE     HidDevice
    );

VOID
VolumeTimerHandler(
    WPARAM  TimerID
    );

void
HidServUpdate(
    DWORD   LongUsage,
    DWORD   Value
    );

BOOL
DeviceChangeHandler(
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK HidServProc(
    HWND            hwnd,
    UINT            msg,
    WPARAM          wparam,
    LPARAM          lparam
    );


//
// Media Types
#define CInput_MediaType_None           (0x00000000)      // actually ALL media types, but with low priority
#define CInput_MediaType_Software       (0x00000001)      // Virtual, or software devices (player does not use a hrdware medium)
#define CInput_MediaType_System         (0x00000002)      // The "system" device, Windows itself is a media type
#define CInput_MediaType_CD             (0x00000004)
#define CInput_MediaType_DVD            (0x00000008)
#define CInput_MediaType_TV             (0x00000010)
#define CInput_MediaType_WWW            (0x00000020)
#define CInput_MediaType_Telephone      (0x00000040)
#define CInput_MediaType_ProgramGuide   (0x00000080)
#define CInput_MediaType_VideoPhone     (0x00000100)
#define CInput_MediaType_Games          (0x00000200)
#define CInput_MediaType_Messages       (0x00000400)
#define CInput_MediaType_VCR            (0x00000800)
#define CInput_MediaType_Tuner          (0x00001000)
#define CInput_MediaType_Tape           (0x00002000)
#define CInput_MediaType_Cable          (0x00004000)
#define CInput_MediaType_Satellite      (0x00008000)
#define CInput_MediaType_Security       (0x00010000)
#define CInput_MediaType_Home           (0x00020000)
#define CInput_MediaType_Call           (0x00040000)
#define CInput_MediaType_Speakers       (0x00080000)
#define CInput_MediaType_All            (0xffffffff)

#define CInputUsage_NULL                ((USAGE) 0x0000)
#define CInputUsage_RANGE               ((USAGE) 0xFFFF)

//
// Collections
#define CInputCollection_Consumer_Control       ((USAGE) 0x0001)
#define CInputCollection_Numeric_Key_Pad        ((USAGE) 0x0002)
#define CInputCollection_Function_Buttons       ((USAGE) 0x0036)
#define CInputCollection_Selection              ((USAGE) 0x0080)
#define CInputCollection_Media_Selection        ((USAGE) 0x0087)
#define CInputCollection_Select_Disc            ((USAGE) 0x00BA)
#define CInputCollection_Playback_Speed         ((USAGE) 0x00F1)

//
// Media Selection
#define CInput_Media_Select_Computer       ((USAGE) 0x0088)
#define CInput_Media_Select_TV             ((USAGE) 0x0089)
#define CInput_Media_Select_WWW            ((USAGE) 0x008A)
#define CInput_Media_Select_DVD            ((USAGE) 0x008B)
#define CInput_Media_Select_Telephone      ((USAGE) 0x008C)
#define CInput_Media_Select_Program_Guide  ((USAGE) 0x008D)
#define CInput_Media_Select_Video_Phone    ((USAGE) 0x008E)
#define CInput_Media_Select_Games          ((USAGE) 0x008F)
#define CInput_Media_Select_Messages       ((USAGE) 0x0090)
#define CInput_Media_Select_CD             ((USAGE) 0x0091)
#define CInput_Media_Select_VCR            ((USAGE) 0x0092)
#define CInput_Media_Select_Tuner          ((USAGE) 0x0093)
#define CInput_Media_Select_Tape           ((USAGE) 0x0096)
#define CInput_Media_Select_Cable          ((USAGE) 0x0097)
#define CInput_Media_Select_Satellite      ((USAGE) 0x0098)
#define CInput_Media_Select_Security       ((USAGE) 0x0099)
#define CInput_Media_Select_Home           ((USAGE) 0x009A)
#define CInput_Media_Select_Call           ((USAGE) 0x009B)


////////////////////////////////////
// General Usages
//

#define CInputUsage_Plus_10                 ((USAGE) 0x0020)
#define CInputUsage_Plus_100                ((USAGE) 0x0021)
#define CInputUsage_AM_PM                   ((USAGE) 0x0022)

// device control
#define CInputUsage_Power                   ((USAGE) 0x0030)
#define CInputUsage_Reset                   ((USAGE) 0x0031)
#define CInputUsage_Sleep                   ((USAGE) 0x0032)
#define CInputUsage_Sleep_After             ((USAGE) 0x0033)
#define CInputUsage_Sleep_Mode              ((USAGE) 0x0034)
#define CInputUsage_Illumination            ((USAGE) 0x0035)

// menu
#define CInputUsage_Menu                    ((USAGE) 0x0040)
#define CInputUsage_Menu_Pick               ((USAGE) 0x0041)
#define CInputUsage_Menu_Up                 ((USAGE) 0x0042)
#define CInputUsage_Menu_Down               ((USAGE) 0x0043)
#define CInputUsage_Menu_Left               ((USAGE) 0x0044)
#define CInputUsage_Menu_Right              ((USAGE) 0x0045)
#define CInputUsage_Menu_Escape             ((USAGE) 0x0046)
#define CInputUsage_Menu_Value_Increase     ((USAGE) 0x0047)
#define CInputUsage_Menu_Value_Decrease     ((USAGE) 0x0048)

// video display
#define CInputUsage_Data_On_Screen          ((USAGE) 0x0060)
#define CInputUsage_Closed_Caption          ((USAGE) 0x0061)
#define CInputUsage_Closed_Caption_Select   ((USAGE) 0x0062)
#define CInputUsage_VCR_TV                  ((USAGE) 0x0063)
#define CInputUsage_Broadcast_Mode          ((USAGE) 0x0064)
#define CInputUsage_Snapshot                ((USAGE) 0x0065)
#define CInputUsage_Still                   ((USAGE) 0x0066)

// broadcast/cable
#define CInputUsage_Assign_Selection        ((USAGE) 0x0081)
#define CInputUsage_Mode_Step               ((USAGE) 0x0082)
#define CInputUsage_Recall_Last             ((USAGE) 0x0083)
#define CInputUsage_Enter_Channel           ((USAGE) 0x0084)
#define CInputUsage_Order_Movie             ((USAGE) 0x0085)
#define CInputUsage_Channel                 ((USAGE) 0x0086)

// app control
#define CInputUsage_Quit                    ((USAGE) 0x0094)
#define CInputUsage_Help                    ((USAGE) 0x0095)

// channel
#define CInputUsage_Channel_Increment       ((USAGE) 0x009C)
#define CInputUsage_Channel_Decrement       ((USAGE) 0x009D)

// vcr control
#define CInputUsage_VCR_Plus                ((USAGE) 0x00A0)
#define CInputUsage_Once                    ((USAGE) 0x00A1)
#define CInputUsage_Daily                   ((USAGE) 0x00A2)
#define CInputUsage_Weekly                  ((USAGE) 0x00A3)
#define CInputUsage_Monthly                 ((USAGE) 0x00A4)

// transport control
#define CInputUsage_Play                    ((USAGE) 0x00B0)
#define CInputUsage_Pause                   ((USAGE) 0x00B1)
#define CInputUsage_Record                  ((USAGE) 0x00B2)
#define CInputUsage_Fast_Forward            ((USAGE) 0x00B3)
#define CInputUsage_Rewind                  ((USAGE) 0x00B4)
#define CInputUsage_Scan_Next_Track         ((USAGE) 0x00B5)
#define CInputUsage_Scan_Previous_Track     ((USAGE) 0x00B6)
#define CInputUsage_Stop                    ((USAGE) 0x00B7)
#define CInputUsage_Eject                   ((USAGE) 0x00B8)
#define CInputUsage_Random_Play             ((USAGE) 0x00B9)

// advanced transport control
#define CInputUsage_Enter_Disc              ((USAGE) 0x00BB)
#define CInputUsage_Repeat                  ((USAGE) 0x00BC)
#define CInputUsage_Tracking                ((USAGE) 0x00BD)
#define CInputUsage_Track_Normal            ((USAGE) 0x00BE)
#define CInputUsage_Slow_Tracking           ((USAGE) 0x00BF)
#define CInputUsage_Frame_Forward           ((USAGE) 0x00C0)
#define CInputUsage_Frame_Back              ((USAGE) 0x00C1)
#define CInputUsage_Mark                    ((USAGE) 0x00C2)
#define CInputUsage_Clear_Mark              ((USAGE) 0x00C3)
#define CInputUsage_Repeat_From_Mark        ((USAGE) 0x00C4)
#define CInputUsage_Return_To_Mark          ((USAGE) 0x00C5)
#define CInputUsage_Search_Mark_Forward     ((USAGE) 0x00C6)
#define CInputUsage_Search_Mark_Backwards   ((USAGE) 0x00C7)
#define CInputUsage_Counter_Reset           ((USAGE) 0x00C8)
#define CInputUsage_Show_Counter            ((USAGE) 0x00C9)
#define CInputUsage_Tracking_Increment      ((USAGE) 0x00CA)
#define CInputUsage_Tracking_Decrement      ((USAGE) 0x00CB)
#define CInputUsage_Stop_Eject              ((USAGE) 0x00CC)
#define CInputUsage_Play_Pause              ((USAGE) 0x00CD)
#define CInputUsage_Play_Skip               ((USAGE) 0x00CE)

// audio
#define CInputUsage_Volume                  ((USAGE) 0x00E0)
#define CInputUsage_Balance                 ((USAGE) 0x00E1)
#define CInputUsage_Mute                    ((USAGE) 0x00E2)
#define CInputUsage_Bass                    ((USAGE) 0x00E3)
#define CInputUsage_Treble                  ((USAGE) 0x00E4)
#define CInputUsage_Bass_Boost              ((USAGE) 0x00E5)
#define CInputUsage_Surround_Mode           ((USAGE) 0x00E6)
#define CInputUsage_Loudness                ((USAGE) 0x00E7)
#define CInputUsage_MPX                     ((USAGE) 0x00E8)
#define CInputUsage_Volume_Increment        ((USAGE) 0x00E9)
#define CInputUsage_Volume_Decrement        ((USAGE) 0x00EA)

// advanced vcr control
#define CInputUsage_Speed_Select            ((USAGE) 0x00F0)

#define CInputUsage_Standard_Play           ((USAGE) 0x00F2)
#define CInputUsage_Long_Play               ((USAGE) 0x00F3)
#define CInputUsage_Extended_Play           ((USAGE) 0x00F4)
#define CInputUsage_Slow                    ((USAGE) 0x00F5)

// advanced device control
#define CInputUsage_Fan_Enable              ((USAGE) 0x0100)
#define CInputUsage_Fan_Speed               ((USAGE) 0x0101)
#define CInputUsage_Light_Enable            ((USAGE) 0x0102)
#define CInputUsage_Illumination_Level      ((USAGE) 0x0103)
#define CInputUsage_Climate_Control_Enable  ((USAGE) 0x0104)
#define CInputUsage_Room_Temperature        ((USAGE) 0x0105)
#define CInputUsage_Security_Enable         ((USAGE) 0x0106)
#define CInputUsage_Fire_Alarm              ((USAGE) 0x0107)
#define CInputUsage_Police_Alarm            ((USAGE) 0x0108)

// suppl. audio
#define CInputUsage_Balance_Right           ((USAGE) 0x0150)
#define CInputUsage_Balance_Left            ((USAGE) 0x0151)
#define CInputUsage_Bass_Increment          ((USAGE) 0x0152)
#define CInputUsage_Bass_Decrement          ((USAGE) 0x0153)
#define CInputUsage_Treble_Increment        ((USAGE) 0x0154)
#define CInputUsage_Treble_Decrement        ((USAGE) 0x0155)

#define CInputUsage_MS_Bass_Up              ((USAGE) 0x0169)
#define CInputUsage_MS_Bass_Down            ((USAGE) 0x0169)
#define CInputUsage_MS_Bass_Page            ((USAGE) 0xff00)

// App Launch
#define CInputUsage_Launch_Configuration    ((USAGE) 0x0183)
#define CInputUsage_Launch_Email            ((USAGE) 0x018A)
#define CInputUsage_Launch_Calculator       ((USAGE) 0x0192)
#define CInputUsage_Launch_Browser          ((USAGE) 0x0194)

// App Commands
#define CInputUsage_App_Help                ((USAGE) 0x0095)
#define CInputUsage_App_Spell_Check         ((USAGE) 0x01AB)
#define CInputUsage_App_New                 ((USAGE) 0x0201)
#define CInputUsage_App_Open                ((USAGE) 0x0202)
#define CInputUsage_App_Close               ((USAGE) 0x0203)
#define CInputUsage_App_Save                ((USAGE) 0x0207)
#define CInputUsage_App_Print               ((USAGE) 0x0208)
#define CInputUsage_App_Undo                ((USAGE) 0x021A)
#define CInputUsage_App_Copy                ((USAGE) 0x021B)
#define CInputUsage_App_Cut                 ((USAGE) 0x021C)
#define CInputUsage_App_Paste               ((USAGE) 0x021D)
#define CInputUsage_App_Find                ((USAGE) 0x021F)
#define CInputUsage_App_Search              ((USAGE) 0x0221)
#define CInputUsage_App_Home                ((USAGE) 0x0223)
#define CInputUsage_App_Back                ((USAGE) 0x0224)
#define CInputUsage_App_Forward             ((USAGE) 0x0225)
#define CInputUsage_App_Stop                ((USAGE) 0x0226)
#define CInputUsage_App_Refresh             ((USAGE) 0x0227)
#define CInputUsage_App_Previous            ((USAGE) 0x0228)
#define CInputUsage_App_Next                ((USAGE) 0x0229)
#define CInputUsage_App_Bookmarks           ((USAGE) 0x022A)
#define CInputUsage_App_Redo                ((USAGE) 0x0279)
#define CInputUsage_App_Reply_To_Mail       ((USAGE) 0x0289)
#define CInputUsage_App_Forward_Mail        ((USAGE) 0x028B)
#define CInputUsage_App_Send_Mail           ((USAGE) 0x028C)

// Keyboard/Keypad
#define CInputUsage_Keypad_Equals           ((USAGE) 0x0067)
#define CInputUsage_Keypad_LParen           ((USAGE) 0x00B6)
#define CInputUsage_Keypad_RParen           ((USAGE) 0x00B7)
#define CInputUsage_Keypad_At               ((USAGE) 0x00CE)



#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _HIDSERV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidserv\list.h ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       list.h
 *  Purpose:    Generic singly linked list.
 * 
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#ifndef _LIST_H_
#define _LIST_H_


typedef struct _ListEntry{
    struct _ListEntry * pNext;
} LIST_NODE, *PLIST_NODE;

void 
InsertTailList(
    PLIST_NODE head, 
    PLIST_NODE entry);

BOOL 
RemoveEntryList(
    PLIST_NODE head, 
    PLIST_NODE entry);

void 
InsertHeadList(
    PLIST_NODE head, 
    PLIST_NODE entry);

BOOL
IsNodeOnList(
    PLIST_NODE head, 
    PLIST_NODE entry);


#endif // _LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidserv\pnp.c ===
/*++
 *
 *  Component:  hidserv.exe
 *  File:       pnp.c
 *  Purpose:    routines to support pnp hid devices.
 * 
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#include "hidserv.h"
#include <cfgmgr32.h>
#include <tchar.h>

BOOL
OpenHidDevice (
              IN       HDEVINFO                    HardwareDeviceInfo,
              IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
              IN OUT   PHID_DEVICE                 *HidDevice
              );

BOOL
RebuildHidDeviceList (
                     void
                     )
/*++
Routine Description:
   Do the required PnP things in order to find, the all the HID devices in
   the system at this time.
--*/
{
    HDEVINFO                 hardwareDeviceInfo;
    SP_DEVICE_INTERFACE_DATA deviceInfoData;
    PHID_DEVICE              hidDeviceInst;
    GUID                     hidGuid;
    DWORD                    i=0;
    PHID_DEVICE              pCurrent, pTemp;

    HidD_GetHidGuid (&hidGuid);

    TRACE(("Getting class devices"));

    //
    // Open a handle to the plug and play dev node.
    //
    hardwareDeviceInfo = SetupDiGetClassDevs (
                                             &hidGuid,
                                             NULL,    // Define no enumerator (global)
                                             NULL,    // Define no
                                             (DIGCF_PRESENT |    // Only Devices present
                                              DIGCF_DEVICEINTERFACE));    // Function class devices.

    if (!hardwareDeviceInfo) {
        TRACE(("Get class devices failed"));
        return FALSE;
    }

    //
    // Take a wild guess to start
    //
    deviceInfoData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

    TRACE(("Marking existing devnodes"));
    // Unmark all existing nodes. They will be remarked if the device still exists.
    pCurrent = (PHID_DEVICE)HidDeviceList.pNext;
    while (pCurrent) {
        pCurrent->Active = FALSE;
        pCurrent = pCurrent->pNext;
    }

    TRACE(("Entering loop"));
    while (TRUE) {

        TRACE(("Enumerating device interfaces"));
        if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,    //HDEVINFO
                                         0,    // No care about specific PDOs //PSP_DEVINFO_DATA
                                         &hidGuid,    // LPGUID
                                         i,    //DWORD MemberIndex
                                         &deviceInfoData)) {    //PSP_DEVICE_INTERFACE_DATA

            TRACE(("Got an item"));
            if (!OpenHidDevice (hardwareDeviceInfo, &deviceInfoData, &hidDeviceInst)) {
                TRACE(("Open hid device failed"));
            } else {
                if (StartHidDevice(hidDeviceInst)) {
                    TRACE(("Start hid device succeeded."));
                    InsertTailList((PLIST_NODE)&HidDeviceList, (PLIST_NODE)hidDeviceInst);
                } else {
                    WARN(("Failed to start hid device. (%x)", hidDeviceInst));
                    HidFreeDevice(hidDeviceInst);
                }
            }
        } else {
            DWORD error = GetLastError();
            if (ERROR_NO_MORE_ITEMS == error) {
                TRACE(("No more items. Exitting"));
                break;
            } else {
                WARN(("Unexpected error getting device interface: 0x%xh", error));
            }
            break;
        }
        i++;
    }

    TRACE(("Removing unmarked device nodes"));
    // RemoveUnmarkedNodes();
    pCurrent = (PHID_DEVICE)HidDeviceList.pNext;
    while (pCurrent) {
        pTemp = pCurrent->pNext;
        if (!pCurrent->Active) {
            INFO(("Device (DevInst = %x) is gone.", pCurrent->DevInst));
            RemoveEntryList((PLIST_NODE)&HidDeviceList, (PLIST_NODE)pCurrent);
            StopHidDevice(pCurrent);    // this frees pCurrent
        }
        pCurrent = pTemp;
    }

    TRACE(("Destroying device info list"));
    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
    return TRUE;
}

VOID
HidFreeDevice(PHID_DEVICE HidDevice)
{
    PHID_DATA data;
    UCHAR j;

    HidD_FreePreparsedData (HidDevice->Ppd);

    data = HidDevice->InputData;

    //
    // Release the button data
    //
    for (j = 0; j < HidDevice->Caps.NumberLinkCollectionNodes; j++, data++) {
        LocalFree(data->ButtonData.PrevUsages);
        LocalFree(data->ButtonData.Usages);
    }

    LocalFree(HidDevice->InputData);
    LocalFree(HidDevice->InputReportBuffer);
    LocalFree(HidDevice);
}

BOOL
OpenHidDevice (
              IN       HDEVINFO                    HardwareDeviceInfo,
              IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
              IN OUT   PHID_DEVICE                 *HidDevice
              )
/*++
RoutineDescription:
    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific hid device,
    open that device and fill in all the relivant information in the given
    HID_DEVICE structure.

    return if the open and initialization was successfull or not.

--*/
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA    functionClassDeviceData = NULL;
    SP_DEVINFO_DATA                     DevInfoData;
    ULONG                               predictedLength = 0;
    ULONG                               requiredLength = 0;
    UCHAR                               i = 0;
    PHID_DATA                           data = NULL;
    PHIDP_BUTTON_CAPS                   pButtonCaps = NULL;
    PHIDP_VALUE_CAPS                    pValueCaps = NULL;
    USHORT                              numCaps;
    PHIDP_LINK_COLLECTION_NODE          LinkCollectionNodes = NULL;
    PHID_DEVICE                         hidDevice = NULL;

    WCHAR buf[512];
    CONFIGRET cr = CR_SUCCESS;
    DEVINST devInst, parentDevInst;
    DWORD len = 0;

    if (!(hidDevice = LocalAlloc (LPTR, sizeof (HID_DEVICE)))) {
        //
        // Alloc failed. Drop out of the loop and let the device list
        // get deleted.
        //
        WARN(("Alloc HID_DEVICE struct failed."));
        return FALSE;
    }

    TRACE(("Creating Device Node (%x)", hidDevice));
    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //
    SetupDiGetDeviceInterfaceDetail (
                                    HardwareDeviceInfo,
                                    DeviceInfoData,
                                    NULL,    // probing so no output buffer yet
                                    0,    // probing so output buffer length of zero
                                    &requiredLength,
                                    NULL);    // get the specific dev-node


    predictedLength = requiredLength;
    // sizeof (SP_FNCLASS_DEVICE_DATA) + 512;

    if (!(functionClassDeviceData = LocalAlloc (LPTR, predictedLength))) {
        WARN(("Allocation failed, our of resources!"));
        goto OpenHidDeviceError;
    }
    functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);
    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    DevInfoData.DevInst = 0;

    //
    // Retrieve the information from Plug and Play.
    //
    if (! SetupDiGetDeviceInterfaceDetail (
                                          HardwareDeviceInfo,
                                          DeviceInfoData,    // PSP_DEVICE_INTERFACE_DATA
                                          functionClassDeviceData,    // PSP_DEVICE_INTERFACE_DETAIL_DATA
                                          predictedLength,
                                          &requiredLength,
                                          &DevInfoData)) {    //PSP_DEVINFO_DATA
        WARN(("SetupDiGetDeviceInterfaceDetail failed"));
        goto OpenHidDeviceError;
    }
    INFO(("Just got interface detail for %S", functionClassDeviceData->DevicePath));
    hidDevice->DevInst = DevInfoData.DevInst;

    //
    // <HACK>
    //
    // Find out it this is a set of speakers with buttons on it. This is for 
    // but 136800. We want to only emit WM_APPCOMMANDs for speakers, not the
    // VK. This is because certain games leave the opening movie scene when
    // you press any key, so if someone presses volume down on their speakers
    // it will leave the scene. They just want that to affect volume.
    // 
    cr = CM_Get_Parent(&parentDevInst,
                       DevInfoData.DevInst,
                       0);
    //
    // We need to get the grandparent, then get the child, to make sure that
    // we get the first child in the set. From there, if the child we've got
    // is the same parent of the devnode that we started with, we want to
    // look at its sibling. But if the devnode we've got is different from 
    // the parent, then we've got the right one to look at!
    //
    if (cr == CR_SUCCESS) {
        cr = CM_Get_Parent(&devInst,
                           parentDevInst,
                           0);
    }
    if (cr == CR_SUCCESS) {
        cr = CM_Get_Child(&devInst,
                          devInst,
                          0);
    }

    if (cr == CR_SUCCESS) {
        if (devInst == parentDevInst) {
            //
            // Only look at the first sibling, because this covers all sets
            // of speakers currently on the market.
            //
            cr = CM_Get_Sibling(&devInst,
                                devInst,
                                0);
        }

        if (cr == CR_SUCCESS) {
            len = sizeof(buf);
            cr = CM_Get_DevNode_Registry_Property(devInst,
                                                  CM_DRP_CLASS,
                                                  NULL,
                                                  buf,
                                                  &len,
                                                  0);
            if (cr == CR_SUCCESS) {
                if (lstrcmpi(TEXT("MEDIA"), buf) == 0) {
                    hidDevice->Speakers = TRUE;
                }
            }
        }    // else - definitely not speakers
    }
    //
    // </HACK>
    //

    // Do we already have this device open?
    {
        PHID_DEVICE pCurrent = (PHID_DEVICE)HidDeviceList.pNext;

        while (pCurrent) {
            if (pCurrent->DevInst == hidDevice->DevInst) break;
            pCurrent = pCurrent->pNext;
        }
        if (pCurrent) {
            // Yes. Mark it and bail on the new node.
            pCurrent->Active = TRUE;
            INFO(("Device (DevInst = %x) already open.", DevInfoData.DevInst));
            goto OpenHidDeviceError;
        } else {
            // No. Mark the new node and continue.
            INFO(("Device (DevInst = %x) is new.", DevInfoData.DevInst));
            hidDevice->Active = TRUE;
        }
    }

    hidDevice->HidDevice = CreateFile (
                                      functionClassDeviceData->DevicePath,
                                      GENERIC_READ,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL,    // no SECURITY_ATTRIBUTES structure
                                      OPEN_EXISTING,    // No special create flags
                                      FILE_FLAG_OVERLAPPED,    // Do overlapped read/write
                                      NULL);    // No template file

    if (INVALID_HANDLE_VALUE == hidDevice->HidDevice) {
        INFO(("CreateFile failed - %x (%S)", GetLastError(), functionClassDeviceData->DevicePath));
        goto OpenHidDeviceError;
    } else {
       INFO(("CreateFile succeeded Handle(%x) - %S", hidDevice->HidDevice, functionClassDeviceData->DevicePath));
    }

    if (!HidD_GetPreparsedData (hidDevice->HidDevice, &hidDevice->Ppd)) {
        WARN(("HidD_GetPreparsedData failed"));
        goto OpenHidDeviceError;
    }

    if (!HidD_GetAttributes (hidDevice->HidDevice, &hidDevice->Attributes)) {
        WARN(("HidD_GetAttributes failed"));
        goto OpenHidDeviceError;
    }

    if (!HidP_GetCaps (hidDevice->Ppd, &hidDevice->Caps)) {
        WARN(("HidP_GetCaps failed"));
        goto OpenHidDeviceError;
    }

    // ***Instructive comment from KenRay:
    // At this point the client has a choice.  It may chose to look at the
    // Usage and Page of the top level collection found in the HIDP_CAPS
    // structure.  In this way it could just use the usages it knows about.
    // If either HidP_GetUsages or HidP_GetUsageValue return an error then
    // that particular usage does not exist in the report.
    // This is most likely the preferred method as the application can only
    // use usages of which it already knows.
    // In this case the app need not even call GetButtonCaps or GetValueCaps.


    // If this is a collection we care about, continue. Else, we get out now.
    if (hidDevice->Caps.UsagePage != HIDSERV_USAGE_PAGE) {
        TRACE(("This device is not for us (%x)", hidDevice));
        goto OpenHidDeviceError;
    }

    //
    // setup Input Data buffers.
    //
    TRACE(("NumberLinkCollectionNodes = %d", hidDevice->Caps.NumberLinkCollectionNodes));
    {
        ULONG   numNodes = hidDevice->Caps.NumberLinkCollectionNodes;

        if (!(LinkCollectionNodes = LocalAlloc(LPTR, hidDevice->Caps.NumberLinkCollectionNodes*sizeof(HIDP_LINK_COLLECTION_NODE)))) {
            WARN(("LinkCollectionNodes alloc failed."));
            goto OpenHidDeviceError;
        }
        HidP_GetLinkCollectionNodes(LinkCollectionNodes,
                                    &numNodes,
                                    hidDevice->Ppd);
        for (i=0; i<hidDevice->Caps.NumberLinkCollectionNodes; i++) {
            INFO(("Link Collection [%d] Type = %x, Alias = %x", i, LinkCollectionNodes[i].CollectionType, LinkCollectionNodes[i].IsAlias));
            INFO(("Link Collection [%d] Page = %x, Usage = %x", i, LinkCollectionNodes[i].LinkUsagePage, LinkCollectionNodes[i].LinkUsage));
        }
    }

    //
    // Allocate memory to hold on input report
    //

    if (!(hidDevice->InputReportBuffer = (PCHAR)
          LocalAlloc (LPTR, hidDevice->Caps.InputReportByteLength * sizeof (CHAR)))) {
        WARN(("InputReportBuffer alloc failed."));
        goto OpenHidDeviceError;
    }

    //
    // Allocate memory to hold the button and value capabilities.
    // NumberXXCaps is in terms of array elements.
    //
    if (!(pButtonCaps = (PHIDP_BUTTON_CAPS)
          LocalAlloc (LPTR, hidDevice->Caps.NumberInputButtonCaps*sizeof (HIDP_BUTTON_CAPS)))) {
        WARN(("buttoncaps alloc failed."));
        goto OpenHidDeviceError;
    }
    if (!(pValueCaps = (PHIDP_VALUE_CAPS)
          LocalAlloc (LPTR, hidDevice->Caps.NumberInputValueCaps*sizeof (HIDP_VALUE_CAPS)))) {
        WARN(("valuecaps alloc failed."));
        goto OpenHidDeviceError;
    }

    //
    // Have the HidP_X functions fill in the capability structure arrays.
    //
    numCaps = hidDevice->Caps.NumberInputButtonCaps;
    TRACE(("NumberInputButtonCaps = %d", numCaps));
    HidP_GetButtonCaps (HidP_Input,
                        pButtonCaps,
                        &numCaps,
                        hidDevice->Ppd);

    numCaps = hidDevice->Caps.NumberInputValueCaps;
    TRACE(("NumberInputValueCaps = %d", numCaps));
    HidP_GetValueCaps (HidP_Input,
                       pValueCaps,
                       &numCaps,
                       hidDevice->Ppd);

    TRACE(("Buttons:"));
    for (i=0; i<hidDevice->Caps.NumberInputButtonCaps; i++) {
        TRACE(("UsagePage = 0x%x", pButtonCaps[i].UsagePage));
        TRACE(("LinkUsage = 0x%x", pButtonCaps[i].LinkUsage));
        TRACE(("LinkUsagePage = 0x%x\n", pButtonCaps[i].LinkUsagePage));
    }

    //
    // Allocate a buffer to hold the struct _HID_DATA structures.
    //
    hidDevice->InputDataLength = hidDevice->Caps.NumberLinkCollectionNodes + 
    hidDevice->Caps.NumberInputValueCaps;
    if (!(hidDevice->InputData = data = (PHID_DATA)
          LocalAlloc (LPTR, hidDevice->InputDataLength * sizeof (HID_DATA)))) {
        WARN(("InputData alloc failed."));
        goto OpenHidDeviceError;
    }

    TRACE(("InputDataLength = %d", hidDevice->InputDataLength));

    //
    // Fill in the button data
    // Group button sets by link collection.
    //
    for (i = 0; i < hidDevice->Caps.NumberLinkCollectionNodes; i++, data++) {
        data->IsButtonData = TRUE;
        data->LinkUsage = LinkCollectionNodes[i].LinkUsage;
        data->UsagePage = LinkCollectionNodes[i].LinkUsagePage;
        if (i)
            data->LinkCollection = i;
        else
            data->LinkCollection = HIDP_LINK_COLLECTION_ROOT;
        INFO(("Button Link Usage = %x", data->LinkUsage));
        INFO(("Button Link Usage Page = %x", data->UsagePage));
        INFO(("Button Link Collection = %x", data->LinkCollection));
        data->Status = HIDP_STATUS_SUCCESS;
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                                  HidP_Input,
                                                                  hidDevice->Caps.UsagePage,
                                                                  hidDevice->Ppd);
        //make room for the terminator
        data->ButtonData.MaxUsageLength++;
        if (!(data->ButtonData.Usages = (PUSAGE_AND_PAGE)
              LocalAlloc (LPTR, data->ButtonData.MaxUsageLength * sizeof (USAGE_AND_PAGE)))) {
            WARN(("Usages alloc failed."));
            goto OpenHidDeviceError;
        }
        if (!(data->ButtonData.PrevUsages = (PUSAGE_AND_PAGE)
              LocalAlloc (LPTR, data->ButtonData.MaxUsageLength * sizeof (USAGE_AND_PAGE)))) {
            WARN(("PrevUsages alloc failed."));
            goto OpenHidDeviceError;
        }
    }

    //
    // Fill in the value data
    // 
    for (i = 0; i < hidDevice->Caps.NumberInputValueCaps; i++, data++) {
        if (pValueCaps[i].IsRange) {
            WARN(("Can't handle value ranges!!"));
        }
        data->IsButtonData = FALSE;
        data->LinkUsage = pValueCaps[i].LinkUsage;
        data->UsagePage = pValueCaps[i].LinkUsagePage;
        if (pValueCaps[i].LinkCollection)
            data->LinkCollection = pValueCaps[i].LinkCollection;
        else
            data->LinkCollection = HIDP_LINK_COLLECTION_ROOT;
        INFO(("Value Link Usage = %x", data->LinkUsage));
        INFO(("Value Link Usage Page = %x", data->UsagePage));
        INFO(("Value Link Collection = %x", data->LinkCollection));
        INFO(("Value LogicalMin = %x", pValueCaps[i].LogicalMin));
        INFO(("Value LogicalMax = %x", pValueCaps[i].LogicalMax));
        data->ValueData.LogicalRange = pValueCaps[i].LogicalMax - pValueCaps[i].LogicalMin;
        data->Status = HIDP_STATUS_SUCCESS;
        data->ValueData.Usage = pValueCaps[i].NotRange.Usage;
    }

    LocalFree(pButtonCaps);
    LocalFree(pValueCaps);
    LocalFree(LinkCollectionNodes);
    LocalFree(functionClassDeviceData);

    *HidDevice = hidDevice;
    return TRUE;
OpenHidDeviceError:
    if (data) {
        for (i = 0; i < hidDevice->Caps.NumberLinkCollectionNodes; i++, data++) {
            if (data->ButtonData.Usages) {
                LocalFree(data->ButtonData.Usages);
            }
            if (data->ButtonData.PrevUsages) {
                LocalFree(data->ButtonData.PrevUsages);
            }
        }
        LocalFree(data);
    }

    if (pValueCaps) {
        LocalFree(pValueCaps);
    }
    if (pButtonCaps) {
        LocalFree (pButtonCaps);
    }
    if (hidDevice->InputReportBuffer) {
        LocalFree (hidDevice->InputReportBuffer);
    }
    if (LinkCollectionNodes) {
        LocalFree (LinkCollectionNodes);
    }
    if (hidDevice->Ppd) {
        HidD_FreePreparsedData (hidDevice->Ppd);
    }
    if (hidDevice->HidDevice &&
        hidDevice->HidDevice != INVALID_HANDLE_VALUE) {
        CloseHandle (hidDevice->HidDevice);
    }
    if (functionClassDeviceData) {
        LocalFree (functionClassDeviceData);
    }
    LocalFree (hidDevice);
    return FALSE;
}


BOOL
StartHidDevice(
              PHID_DEVICE      pHidDevice
              )
/*++
RoutineDescription:
    Create a work thread to go with the new hid device. This thread lives
    as long as the associated hid device is open.
--*/
{
    //
    // Init read sync objects
    //
    pHidDevice->ReadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!pHidDevice->ReadEvent) {
        WARN(("Failed creating read event."));
        return FALSE;
    }

    pHidDevice->CompletionEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (!pHidDevice->CompletionEvent) {
        CloseHandle(pHidDevice->ReadEvent);

        WARN(("Failed creating read event."));
        return FALSE;
    }

    // event handle for overlap.
    pHidDevice->Overlap.hEvent = pHidDevice->CompletionEvent;

    //
    // Create hid work thread
    //
    pHidDevice->fThreadEnabled = TRUE;

    pHidDevice->ThreadHandle =
    CreateThread(
                NULL,    // pointer to thread security attributes 
                0,    // initial thread stack size, in bytes (0 = default)
                HidThreadProc,    // pointer to thread function 
                pHidDevice,    // argument for new thread 
                0,    // creation flags 
                &pHidDevice->ThreadId    // pointer to returned thread identifier 
                );  

    if (!pHidDevice->ThreadHandle) {
        CloseHandle(pHidDevice->ReadEvent);
        CloseHandle(pHidDevice->CompletionEvent);

        WARN(("Failed creating hid work thread."));
        return FALSE;
    }

    // Register device nofication for this file handle
    // This only required for NT5
    {
        DEV_BROADCAST_HANDLE  DevHdr;
        ZeroMemory(&DevHdr, sizeof(DevHdr));
        DevHdr.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
        DevHdr.dbch_devicetype = DBT_DEVTYP_HANDLE;
        DevHdr.dbch_handle = pHidDevice->HidDevice;

        pHidDevice->hNotify = 
        RegisterDeviceNotification( hWndHidServ,
                                    &DevHdr,
                                    DEVICE_NOTIFY_WINDOW_HANDLE);

        if (!pHidDevice->hNotify) {
            WARN(("RegisterDeviceNotification failure (%x).", GetLastError()));
        }
    }

    // 
    // Start the read
    //
    SetEvent(pHidDevice->ReadEvent);

    return TRUE;
}

BOOL
StopHidDevice(
             PHID_DEVICE     pHidDevice
             )
/*++
RoutineDescription:
    Eaxh device has a thread that needs to be cleaned up when the device
    is "stopped". Here we signal the thread to exit and clean up.
--*/
{
    HANDLE  hThreadHandle;
    DWORD   dwResult;
    
    TRACE(("StopHidDevice (%x)", pHidDevice));
    // without a device, nothing can be done.
    if (!pHidDevice) return FALSE;

    // Doing this here prevents us from seeing
    // DBT_DEVICEQUERYREMOVEFAILED since the notify handle
    // is gone. However, this is acceptable since there is
    // nothing useful we will do in response to that event
    // anyway.
    UnregisterDeviceNotification(pHidDevice->hNotify);
    hThreadHandle = pHidDevice->ThreadHandle;
    
    //
    // Allow the hid work thread to exit.
    //
    pHidDevice->fThreadEnabled = FALSE;

    // Signal the read event, in case thread is waiting there
    INFO(("Set Read Event."));
    SetEvent(pHidDevice->ReadEvent);
    INFO(("Waiting for work thread to exit..."));
    WaitForSingleObject(hThreadHandle, INFINITE);

    TRACE(("StopHidDevice (%x) done.", pHidDevice));

    return TRUE;
}


BOOL
DestroyHidDeviceList(
                    void
                    )
/*++
RoutineDescription:
    Unlike a rebuild, all devices here are closed so the process can
    exit.
--*/
{
    PHID_DEVICE pNext, pCurrent = (PHID_DEVICE)HidDeviceList.pNext;
    while (pCurrent) {

        RemoveEntryList((PLIST_NODE)&HidDeviceList, (PLIST_NODE)pCurrent);
        pNext = pCurrent->pNext;
        StopHidDevice(pCurrent);

        pCurrent = pNext;
    }

    return TRUE;
}

BOOL
DestroyDeviceByHandle(
                     HANDLE hDevice
                     )
/*++
RoutineDescription:
    Here we need to remove a specific device.
--*/
{
    PHID_DEVICE pCurrent = (PHID_DEVICE)HidDeviceList.pNext;

    while (pCurrent) {

        if (hDevice == pCurrent->HidDevice) {
            RemoveEntryList((PLIST_NODE)&HidDeviceList, (PLIST_NODE)pCurrent);
#if WIN95_BUILD
            //
            // Can't do the UnregisterDeviceNotification in the same context
            // as when we receive the WM_DEVICECHANGE DBT_REMOVEDEVICECOMPLETE 
            // for a DBT_DEVTYP_HANDLE
            //
            PostMessage(hWndHidServ, WM_HIDSERV_STOP_DEVICE, 0, (LPARAM)pCurrent);
#else
            StopHidDevice(pCurrent);
#endif // WIN95_BUILD
            break;
        }
        pCurrent = pCurrent->pNext;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidserv\hidserv.c ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       hidserv.c
 *  Purpose:    main entry and NT service routines.
 *
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#include "hidserv.h"

TCHAR HidservDisplayName[] = TEXT("HID Input Service");

VOID
InitializeGlobals()
/*++
Routine Description:
   Since .dll might be unloaded/loaded into the same process, so must reinitialize global vars
--*/
{
   PnpEnabled = FALSE;
   hNotifyArrival = 0;
   INITIAL_WAIT = 500;
   REPEAT_INTERVAL = 150;
   hInstance = 0;
   hWndHidServ = 0;
   cThreadRef = 0;
   hMutexOOC = 0;
   hService = 0;
}


void
StartHidserv(
    void
    )
/*++
Routine Description:
    Cal the SCM to start the NT service.
--*/
{
    SC_HANDLE hSCM;
    SC_HANDLE hService;
    BOOL Ret;

    INFO(("Start HidServ Service."));

    // Open the SCM on this machine.
    hSCM = OpenSCManager(   NULL,
                            NULL,
                            SC_MANAGER_CONNECT);

    if (hSCM) {
        // Open this service for DELETE access
        hService = OpenService( hSCM,
                                HidservServiceName,
                                SERVICE_START);

        if(hService) {
            // Start this service.
            Ret = StartService( hService,
                                0,
                                NULL);

            // Close the service and the SCM
            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hSCM);
    }
}

void
StopHidserv(
    void
    )
/*++
Routine Description:
    Cal the SCM to stop the NT service.
--*/
{
    SC_HANDLE hSCM;
    SC_HANDLE hService;
    SERVICE_STATUS Status;
    BOOL Ret;

    INFO(("Stop HidServ Service."));

    // Open the SCM on this machine.
    hSCM = OpenSCManager(   NULL,
                            NULL,
                            SC_MANAGER_CONNECT);

    if (hSCM) {
        // Open this service for DELETE access
        hService = OpenService( hSCM,
                                HidservServiceName,
                                SERVICE_STOP);

        if(hService) {
            // Stop this service.
            Ret = ControlService(   hService,
                                    SERVICE_CONTROL_STOP,
                                    &Status);
            CloseServiceHandle(hService);
        }
        CloseServiceHandle(hSCM);
    }
}


void
InstallHidserv(
    void
    )
/*++
Routine Description:
    Install the NT service to Auto-start with no dependencies.
--*/
{
    SC_HANDLE hService;
    SC_HANDLE hSCM;
    TCHAR szModulePathname[] = TEXT("%SystemRoot%\\system32\\hidserv.exe");
    BOOL stop = FALSE;

    INFO(("Install HidServ Service."));

    // Open the SCM on this machine.
    hSCM = OpenSCManager(   NULL,
                            NULL,
                            SC_MANAGER_ALL_ACCESS);

    if (hSCM) {
        // Add this service to the SCM's database.
        hService = CreateService(   hSCM,
                                    HidservServiceName,
                                    HidservDisplayName,
                                    SERVICE_ALL_ACCESS,
                                    SERVICE_WIN32_OWN_PROCESS,
                                    SERVICE_AUTO_START,
                                    SERVICE_ERROR_NORMAL,
                                    szModulePathname,
                                    NULL, NULL, NULL,
                                    NULL, NULL);

        if(hService) {
            CloseServiceHandle(hService);
        } else {
            if (GetLastError() == ERROR_SERVICE_EXISTS) {
                hService = OpenService(hSCM,
                                       HidservServiceName,
                                       SERVICE_ALL_ACCESS);
                if (hService) {
                    QUERY_SERVICE_CONFIG config;
                    DWORD junk;
                    if (QueryServiceConfig(hService,
                                           &config,
                                           sizeof(QUERY_SERVICE_CONFIG),
                                           &junk)) {
                        if (config.dwServiceType & SERVICE_INTERACTIVE_PROCESS) {
                            ChangeServiceConfig(hService,
                                                SERVICE_WIN32_OWN_PROCESS,
                                                SERVICE_AUTO_START,
                                                SERVICE_ERROR_NORMAL,
                                                szModulePathname,
                                                NULL, NULL, NULL,
                                                NULL, NULL,
                                                HidservDisplayName);
                            stop = TRUE;
                        }
                    }
                }
            }
        }
        CloseServiceHandle(hSCM);

        if (stop) {
            StopHidserv();
        }
    }

    // Go ahead and start the service for no-reboot install.
    StartHidserv();
}


void
RemoveHidserv(
    void
    )
/*++
Routine Description:
    Remove the NT service from the registry database.
--*/
{
    SC_HANDLE hSCM;
    SC_HANDLE hService;

    INFO(("Remove HidServ Service."));

    // Stop the service first
    StopHidserv();

    // Open the SCM on this machine.
    hSCM = OpenSCManager(   NULL,
                            NULL,
                            SC_MANAGER_CONNECT);

    if (hSCM) {
        // Open this service for DELETE access
        hService = OpenService( hSCM,
                                HidservServiceName,
                                DELETE);

        if(hService) {
            // Remove this service from the SCM's database.
            DeleteService(hService);
            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hSCM);
    }
}

DWORD
WINAPI
ServiceHandlerEx(
    DWORD fdwControl,     // requested control code
    DWORD dwEventType,   // event type
    LPVOID lpEventData,  // event data
    LPVOID lpContext     // user-defined context data
    )
/*++
Routine Description:
    Handle the service handler requests as required by the app.
    This should virtually always be an async PostMessage. Do not
    block this thread.
--*/
{
    PWTSSESSION_NOTIFICATION sessionNotification;

    switch (fdwControl)
    {
    case SERVICE_CONTROL_INTERROGATE:
        INFO(("ServiceHandler Request SERVICE_CONTROL_INTERROGATE (%x)", fdwControl));
        SetServiceStatus(hService, &ServiceStatus);
        return NO_ERROR;
    case SERVICE_CONTROL_CONTINUE:
        INFO(("ServiceHandler Request SERVICE_CONTROL_CONTINUE (%x)", fdwControl));
        //SET_SERVICE_STATE(SERVICE_START_PENDING);
        //PostMessage(hWndMmHid, WM_MMHID_START, 0, 0);
        return NO_ERROR;
    case SERVICE_CONTROL_PAUSE:
        INFO(("ServiceHandler Request SERVICE_CONTROL_PAUSE (%x)", fdwControl));
        //SET_SERVICE_STATE(SERVICE_PAUSE_PENDING);
        //PostMessage(hWndMmHid, WM_MMHID_STOP, 0, 0);
        return NO_ERROR;
    case SERVICE_CONTROL_STOP:
        INFO(("ServiceHandler Request SERVICE_CONTROL_STOP (%x)", fdwControl));
        SET_SERVICE_STATE(SERVICE_STOP_PENDING);
        PostMessage(hWndHidServ, WM_CLOSE, 0, 0);
        return NO_ERROR;
    case SERVICE_CONTROL_SHUTDOWN:
        INFO(("ServiceHandler Request SERVICE_CONTROL_SHUTDOWN (%x)", fdwControl));
        SET_SERVICE_STATE(SERVICE_STOP_PENDING);
        PostMessage(hWndHidServ, WM_CLOSE, 0, 0);
        return NO_ERROR;
    case SERVICE_CONTROL_SESSIONCHANGE:
        INFO(("ServiceHandler Request SERVICE_CONTROL_SESSIONCHANGE (%x)", fdwControl));
        sessionNotification = (PWTSSESSION_NOTIFICATION)lpEventData;
        PostMessage(hWndHidServ, WM_WTSSESSION_CHANGE, dwEventType, (LPARAM)sessionNotification->dwSessionId);
        return NO_ERROR;
    default:
        WARN(("Unhandled ServiceHandler code, (%x)", fdwControl));
    }
    return ERROR_CALL_NOT_IMPLEMENTED;
}

VOID
WINAPI
ServiceMain(
    DWORD dwArgc,
    LPWSTR * lpszArgv
    )
/*++
Routine Description:
    The main thread for the Hid Audio service.
--*/
{
    HANDLE initDoneEvent;

    InitializeGlobals();

    initDoneEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    ServiceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_SESSIONCHANGE;
    ServiceStatus.dwWin32ExitCode = NO_ERROR;
    ServiceStatus.dwServiceSpecificExitCode = NO_ERROR;
    ServiceStatus.dwCheckPoint = 0;
    ServiceStatus.dwWaitHint = 0;

    hService =
    RegisterServiceCtrlHandlerEx(HidservServiceName,
                                 ServiceHandlerEx,
                                 NULL);

    SET_SERVICE_STATE(SERVICE_START_PENDING);

    CreateThread(
                NULL, // pointer to thread security attributes
                0, // initial thread stack size, in bytes (0 = default)
                HidServMain, // pointer to thread function
                initDoneEvent, // argument for new thread
                0, // creation flags
                &MessagePumpThreadId // pointer to returned thread identifier
                );

    if (initDoneEvent) {
        WaitForSingleObject(initDoneEvent, INFINITE);
        CloseHandle(initDoneEvent);
    }

    SET_SERVICE_STATE(SERVICE_RUNNING);
}


int
WINAPI
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    PSTR        szCmdLine,
    int         iCmdShow
    )
/*++
Routine Description:
    HidServ starts as an NT Service (started by the SCM) unless
    a command line param is passed in. Command line params may be
    used to start HidServ as a free-standing app, or to control
    the NT service.

    If compiled non-unicode, we bypass all the NT stuff.
--*/
{
    int nArgc = __argc;
    int i;
 #ifdef UNICODE
    LPCTSTR *ppArgv = (LPCTSTR*) CommandLineToArgvW(GetCommandLine(), &nArgc);
 #else
    LPCTSTR *ppArgv = NULL;
 #endif

    TRACE(("HidServ Service process WinMain."));

    if(ppArgv){
        for (i = 1; i < nArgc; i++) {
           if ((ppArgv[i][0] == TEXT('-')) || (ppArgv[i][0] == TEXT('/'))) {
              // Command line switch
              if (lstrcmpi(&ppArgv[i][1], TEXT("install")) == 0)
                 InstallHidserv();

              if (lstrcmpi(&ppArgv[i][1], TEXT("remove"))  == 0)
                 RemoveHidserv();

              if (lstrcmpi(&ppArgv[i][1], TEXT("start"))  == 0)
                 StartHidserv();

              if (lstrcmpi(&ppArgv[i][1], TEXT("stop"))  == 0)
                 StopHidserv();
           }
        }
 #ifdef UNICODE
    HeapFree(GetProcessHeap(), 0, (PVOID) ppArgv);
 #endif
    }

    if (nArgc < 2) {
        // No command line params, so this is the SCM...
        SERVICE_TABLE_ENTRY ServiceTable[] = {
           { HidservServiceName, ServiceMain },
           { NULL,        NULL }   // End of list
        };

        INFO(("Start HidServ Service Control Dispatcher."));
        StartServiceCtrlDispatcher(ServiceTable);
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidserv\list.c ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       list.c
 *  Purpose:    Generic singly linked list.
 *  
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#include "hidserv.h"


void 
InsertTailList(
    PLIST_NODE head, 
    PLIST_NODE entry
    )
/*++
Routine Description:

--*/
{
    PLIST_NODE pCurrent = head;

    entry->pNext = 0;
    while(pCurrent->pNext)
        pCurrent = pCurrent->pNext;
    pCurrent->pNext = entry;

}

BOOL 
RemoveEntryList(
    PLIST_NODE head, 
    PLIST_NODE entry
    )
/*++
Routine Description:

--*/
{
    PLIST_NODE pCurrent = head;

    while(pCurrent->pNext != entry){
        pCurrent = pCurrent->pNext;
        if(pCurrent == 0) return FALSE;
    }
    pCurrent->pNext = entry->pNext;
    return TRUE;
}
    
void 
InsertHeadList(
    PLIST_NODE head, 
    PLIST_NODE entry
    )
/*++
Routine Description:

--*/
{
    entry->pNext = head->pNext;
    head->pNext = entry;
}

BOOL 
IsNodeOnList(
    PLIST_NODE head, 
    PLIST_NODE entry
    )
/*++
Routine Description:

--*/
{
    PLIST_NODE pCurrent = head;

    while(pCurrent->pNext != entry){
        pCurrent = pCurrent->pNext;
        if(pCurrent == 0) return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidtest\buffer.c ===
#define __BUFFER_C__

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>
#include "hidsdi.h"
#include "list.h"
#include "hidtest.h"
#include "buffer.h"

/*
// Make sure when we include debug.h we are using the debug routines no matter
//  what since for this buffer allocation stuff we will use the built in memory
//  allocation routines
*/

#ifndef DEBUG
    #define DEBUG
    #include "debug.h"
    #undef DEBUG
#else
    #include "debug.h"
#endif

/*****************************************************************************
/* External function definitions
/*****************************************************************************/

PVOID 
AllocateTestBuffer(
    IN  ULONG   BufferSize
)
{
    PVOID   newBuffer;
    BOOL    wasTrapping;
    

    wasTrapping = GET_TRAP_STATE();
    
    TRAP_OFF();

    newBuffer = ALLOC(BufferSize);

    if (wasTrapping) 
        TRAP_ON();
        
    return (newBuffer);
}

VOID 
FillTestBuffer(
    IN  PVOID   Buffer,
    IN  BYTE    FillValue,
    IN  ULONG   NumBytes
)
{
    FillMemory(Buffer, NumBytes, FillValue);

    return;
}

VOID
FreeTestBuffer(
    IN  PVOID   Buffer
)
{
    BOOL    wasTrapping;
    
    wasTrapping = GET_TRAP_STATE();
    
    TRAP_OFF();
    
    FREE(Buffer);

    if (wasTrapping) 
        TRAP_ON();

    return;
}  

BOOL
ValidateTestBuffer(
    IN  PVOID   Buffer
)
{
    BOOL    wasTrapping;
    BOOL    isValidMemory;
    
    wasTrapping = GET_TRAP_STATE();
    
    TRAP_OFF();

    isValidMemory = VALIDATEMEM(Buffer);
    
    if (wasTrapping) 
        TRAP_ON();
        
    return (isValidMemory);
}   

VOID
CompareTestBuffers(
    IN  PUCHAR  Buffer1,
    IN  PUCHAR  Buffer2,
    IN  ULONG   BufferLength,
    OUT PULONG  BytesChanged,
    OUT PULONG  BitsChanged
)
{
    ULONG       bytesChanged;
    ULONG       bitsChanged;
    BYTE        xorResult;

    bytesChanged = 0;
    bitsChanged = 0;
       
    while (BufferLength--) {

        xorResult = (*Buffer1) ^ (*Buffer2);

        if (xorResult) {
            bytesChanged++;
            
            /*
            // Algorithm to count the number of bits that changed...
            //    Don't know the details of this...Found it somewhere
            //    and it works...So I'm using it.
            */

            // Count pairs of bits
            xorResult = ( xorResult & 0x55 ) + ( ( xorResult >> 1 ) & 0x55 );

            // Count nybbles
            xorResult = ( xorResult & 0x33 ) + ( ( xorResult >> 2 ) & 0x33 );

            // etc (some optimizations now that the count can be represented
            // in fewer bits than the original number)

            xorResult = ( xorResult + ( xorResult >> 4 ) ) & 0x0F;

            bitsChanged += (xorResult & 0x3F);
        }

        Buffer1++;
        Buffer2++;
    }

    if (NULL != BytesChanged) {
        *BytesChanged = bytesChanged;
    }

    if (NULL != BitsChanged) {
        *BitsChanged = bitsChanged;
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidserv\report.c ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       hid.h
 *  Purpose:    routines to send and receive hid reports.
 * 
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#include "hidserv.h"

BOOL
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   )
/*++
Routine Description:

--*/
{
   ULONG       numUsages; // Number of usages returned from GetUsages.
   ULONG       i;

    for (i = 0; i < DataLength; i++, Data++) {
        if (Data->IsButtonData) {
            numUsages = Data->ButtonData.MaxUsageLength;
            TRACE(("MaxUsageListLength (%d)", Data->ButtonData.MaxUsageLength));
            Data->Status = HidP_GetUsages (
                           ReportType,
                           Data->UsagePage,
                           Data->LinkCollection, 
                           (PUSAGE) Data->ButtonData.Usages,
                           &numUsages,
                           Ppd,
                           ReportBuffer,
                           ReportBufferLength);
            if (HIDP_STATUS_SUCCESS != Data->Status){
                TRACE(("HidP_GetUsages failed (%x)", Data->Status));
            }

             //
             // Get usages writes the list of usages into the buffer
             // Data->ButtonData.Usages newUsage is set to the number of usages
             // written into this array.
             // We assume that there will not be a usage of zero.
             // (None have been defined to date.)
             // So lets assume that a zero indicates an end of the list of usages.
             //

            TRACE(("numUsages (%d)", numUsages));
            if (numUsages < Data->ButtonData.MaxUsageLength) {
                Data->ButtonData.Usages[numUsages].Usage = 0;
                Data->ButtonData.Usages[numUsages].UsagePage = 0;
            }

        } else {
            Data->Status = HidP_GetUsageValue (
                              ReportType,
                              Data->UsagePage,
                              Data->LinkCollection, 
                              Data->ValueData.Usage,
                              &Data->ValueData.Value,
                              Ppd,
                              ReportBuffer,
                              ReportBufferLength);
            if (HIDP_STATUS_SUCCESS != Data->Status){
                TRACE(("HidP_GetUsageValue failed (%x)", Data->Status));
                TRACE(("Usage = %x", Data->ValueData.Usage));
            }
            
            Data->Status = HidP_GetScaledUsageValue (
                              ReportType,
                              Data->UsagePage,
                              Data->LinkCollection, 
                              Data->ValueData.Usage,
                              &Data->ValueData.ScaledValue,
                              Ppd,
                              ReportBuffer,
                              ReportBufferLength);
            if (HIDP_STATUS_SUCCESS != Data->Status){
                TRACE(("HidP_GetScaledUsageValue failed (%x)", Data->Status));
                TRACE(("Usage = %x", Data->ValueData.Usage));
            }

        }
    }
    return (HIDP_STATUS_SUCCESS);
}


BOOL
ParseReadReport (
   PHID_DEVICE    HidDevice
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, unpack the read report values
   into to InputData array.
--*/
{

   return UnpackReport (HidDevice->InputReportBuffer,
                        HidDevice->Caps.InputReportByteLength,
                        HidP_Input,
                        HidDevice->InputData,
                        HidDevice->InputDataLength,
                        HidDevice->Ppd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidtest\buffer.h ===
#ifndef __BUFFER_H__
#define __BUFFER_H__

/*****************************************************************************
/* External function declarations
/*****************************************************************************/

PVOID 
AllocateTestBuffer(
    IN  ULONG   BufferSize
);

VOID 
FillTestBuffer(
    IN  PVOID   Buffer,
    IN  BYTE    FillValue,
    IN  ULONG   NumBytes
);

VOID
FreeTestBuffer(
    IN  PVOID   Buffer
);

BOOL
ValidateTestBuffer(
    IN  PVOID   Buffer
);

VOID
CompareTestBuffers(
    IN  PUCHAR  Buffer1,
    IN  PUCHAR  Buffer2,
    IN  ULONG   BufferLength,
    OUT PULONG  BytesChanged,
    OUT PULONG  BitsChanged
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidtest\debug.c ===
#define __DEBUG_C__

#ifndef DEBUG
    #define DEBUG
#endif

/*****************************************************************************
/* Debug include files
/*****************************************************************************/
#include <stdio.h>
#include "debug.h"

/*****************************************************************************
/* Local debug macro definitions
/*****************************************************************************/

#define SIGNATURE_SIZE    2
#define HEADER_SIGNATURE  'rdHM'
#define FOOTER_SIGNATURE  'rtFM'
#define MEMFILL_VALUE     0xCC
#define MEMORY_TRAP(msg)  TRAP(TRAP_LEVEL_4, msg)

/*****************************************************************************
/* Data types local to debug
/*****************************************************************************/

typedef struct {

    LIST_ENTRY  ListEntry;
    PCHAR       FileName;
    ULONG       LineNumber;
    BOOL        IsValid;
    ULONG       BufferSize;
    ULONG       Signature[SIGNATURE_SIZE];

} ALLOCHEADER, *PALLOCHEADER;

typedef struct {

    ULONG       Signature[SIGNATURE_SIZE];

} ALLOCFOOTER, *PALLOCFOOTER;


typedef enum {
               MEM_ALLOC_NO_ERROR,       MEM_ALLOC_HEADER_OVERFLOW,
               MEM_ALLOC_INVALID_HEADER, MEM_ALLOC_ALREADY_FREED,
               MEM_ALLOC_FOOTER_OVERFLOW
             
             } MEM_ALLOC_STATUS, *PMEM_ALLOC_STATUS;


/*****************************************************************************
/* Global debug data variables
/*****************************************************************************/

INT     Debug_TrapLevel = TRAP_LEVEL_1;
BOOL    Debug_TrapOn    = FALSE;
static  INT Debug_ListCount = 0;


/*****************************************************************************
/* Local debug data variables
/*****************************************************************************/

static LIST_ENTRY Debug_AllocList = { &Debug_AllocList, &Debug_AllocList };


/*****************************************************************************
/* Local debug function declarations
/*****************************************************************************/

BOOL 
Debug_IsEmptyList( 
    IN PLIST_ENTRY  ListHead
);

VOID 
Debug_InsertIntoListAtTail(
    IN OUT PLIST_ENTRY  ListHead,
    IN OUT PLIST_ENTRY  NewEntry
);

PLIST_ENTRY 
Debug_RemoveHeadOfList(
    IN PLIST_ENTRY ListHead
);

VOID 
Debug_RemoveListEntry(
    IN PLIST_ENTRY     OldEntry
);

/*****************************************************************************
/* Global debug function definitions
/*****************************************************************************/

HGLOBAL __cdecl
Debug_Alloc(
    IN PCHAR    FileName,
    IN ULONG    LineNumber,
    IN DWORD    AllocSize
)
{
    INT          Index;
    DWORD        BytesToAllocate;
    PALLOCHEADER NewBuffer;
    PALLOCFOOTER BufferFooter;

    BytesToAllocate = sizeof(ALLOCHEADER) + sizeof(ALLOCFOOTER) + AllocSize;

    NewBuffer = (PALLOCHEADER) GlobalAlloc(GPTR, BytesToAllocate);

    if (NULL != NewBuffer) {

        /*
        // Initialize the header structure
        */

        NewBuffer -> FileName = FileName;
        NewBuffer -> LineNumber = LineNumber;
        NewBuffer -> IsValid = TRUE;
        NewBuffer -> BufferSize = AllocSize;
        
        for (Index = 0; Index < SIGNATURE_SIZE; Index++) 
            NewBuffer -> Signature[Index] = HEADER_SIGNATURE;

        /*
        // Insert the new allocation block into the list of allocation blocks
        */

        Debug_InsertIntoListAtTail(&Debug_AllocList, 
                                   &(NewBuffer -> ListEntry)
                                  );

        /*
        // Increment to the pointer that will get returned to the user and
        //   initialize that to the fill value
        */

        NewBuffer++;

        FillMemory(NewBuffer, AllocSize, MEMFILL_VALUE);

        /*
        // Initialize the footer on the memory block
        */

        BufferFooter = (PALLOCFOOTER) (((PCHAR) NewBuffer) + AllocSize);

        for (Index = 0; Index < SIGNATURE_SIZE; Index++) 
            BufferFooter -> Signature[Index] = FOOTER_SIGNATURE;

    }

    return (NewBuffer);
}

HGLOBAL __cdecl
Debug_Realloc(
    IN PCHAR        FileName,
    IN ULONG        LineNumber,
    IN PALLOCHEADER MemoryBlock,
    IN DWORD        AllocSize
)
{
    MEM_ALLOC_STATUS AllocStatus;
    PALLOCHEADER     OldBuffer;
    PALLOCHEADER     NewBuffer;

    ASSERT(NULL != MemoryBlock);

    OldBuffer = MemoryBlock-1;
    Debug_ValidateMemoryAlloc(MemoryBlock,
                              &AllocStatus
                             );

    NewBuffer = (PALLOCHEADER) Debug_Alloc(FileName,
                                           LineNumber,
                                           AllocSize
                                          );

    if (NULL != NewBuffer) {
        CopyMemory(NewBuffer, MemoryBlock, OldBuffer -> BufferSize);
        Debug_Free(MemoryBlock);
    }
    return (NewBuffer);
}



HGLOBAL __cdecl
Debug_Free(
    IN PALLOCHEADER  Buffer
)
{
    PALLOCHEADER     Header;
    MEM_ALLOC_STATUS AllocStatus;

    Header = Buffer-1;

    Debug_ValidateMemoryAlloc(Buffer, &AllocStatus);

    /*
    // If the block has already been freed, we will simply return NULL.
    */

    if (MEM_ALLOC_ALREADY_FREED == AllocStatus) 
        return (NULL);
    
    /*
    // If we at least have an valid header, we can remove the header entry
    //    from our list of allocated blocks
    */

    if (MEM_ALLOC_INVALID_HEADER != AllocStatus) {
 
        Debug_RemoveListEntry(&(Header -> ListEntry));
        Header -> IsValid = FALSE;

    }

    /*
    // Free the block of memory
    */

    return (GlobalFree(Header));
}

BOOL __cdecl
Debug_ValidateMemoryAlloc(
    IN  PALLOCHEADER      Header,
    OUT PMEM_ALLOC_STATUS AllocStatus
)
{
    INT              Index;
    BOOL             IsBadSignature;
    PALLOCFOOTER     Footer;
    MEM_ALLOC_STATUS Status;

    /*
    // Begin by validating the header signature.  If this is messed up there's
    //     nothing else that can be done.  Check each SIGNATURE entry
    //     starting from the end to verify it is correct.  If any of them are
    //     not equal to HEADER_SIGNATURE then something went wrong.  However,
    //     if the first element in the array.  Index 0 is valid, then we can
    //     reasonably assume that the rest of the header is correct and we can
    //     extract the appropriate info and display a more meaningful error 
    //     message.  If that signature is not valid, however, there's no way
    //     to insure that any of the other values are valid and therefore we
    //     can't extract the valid info from the header.
    */

    
    Status = MEM_ALLOC_NO_ERROR;
    Header--;

    IsBadSignature = FALSE;
    for (Index = SIGNATURE_SIZE-1; Index >= 0; Index--) {

        if (Header -> Signature[Index] != HEADER_SIGNATURE) {
            IsBadSignature = TRUE;
            break;
        }

    }

    if (IsBadSignature) {
        if (HEADER_SIGNATURE == Header -> Signature[0]) {
            
            static CHAR     msg[1024];

            sprintf(msg,
                    "Header overflow in block: %p\nAllocated by %s on line %u\n",
                    Header,
                    Header -> FileName,
                    Header -> LineNumber
                   );

            MEMORY_TRAP(msg);

            Status = MEM_ALLOC_HEADER_OVERFLOW;
        }
        else {
            
            static CHAR     msg[1024];

            sprintf(msg,
                    "Corrupted allocation header in block: %p\nCannot extract allocation info",
                    Header
                   );

            MEMORY_TRAP(msg);

            Status = MEM_ALLOC_INVALID_HEADER;
        }
    }

    /*
    // We passed the signature phase, let's validate the rest of the memory
    //    allocation beginning with the header where we'll check the IsValid 
    //    flag to see if this chunk of memory has previously been freed.
    */

    else if (!Header -> IsValid) {

        static CHAR     msg[1024];

        sprintf(msg,
                "Allocated block already been freed: %p\nAllocated by %s on line %u\n",
                Header,
                Header -> FileName,
                Header -> LineNumber
               );

        MEMORY_TRAP(msg);

        Status = MEM_ALLOC_ALREADY_FREED;
    }

    else {

        /*
        // Next step is to verify that the footer is still correct and we did not
        //     overflow our buffer on the other end.
        */
        
        Footer = (PALLOCFOOTER) (((PCHAR) (Header+1)) + Header -> BufferSize);
        
        IsBadSignature = FALSE;
        for (Index = 0; Index < SIGNATURE_SIZE; Index++) {
            
            if (FOOTER_SIGNATURE != Footer -> Signature[Index]) {
                IsBadSignature = TRUE;
                break;
            }
        }
        
        if (IsBadSignature) {
        
            static CHAR     msg[1024];
    
            sprintf(msg,
                    "Footer overflow in block: %p\nAllocated by %s on line %u\n",
                    Header,
                    Header -> FileName,
                    Header -> LineNumber
                   );
    
            MEMORY_TRAP(msg);
        
            Status = MEM_ALLOC_FOOTER_OVERFLOW;
            return (FALSE);
        
        }
    }

    if (NULL != AllocStatus) 
        *AllocStatus = Status;

    return (MEM_ALLOC_NO_ERROR == Status);
}

VOID __cdecl
Debug_CheckForMemoryLeaks(
)
{
    static CHAR          msg[1024];
           PALLOCHEADER  Header;

    while (!Debug_IsEmptyList(&Debug_AllocList)) {

        Header = (PALLOCHEADER) Debug_RemoveHeadOfList(&Debug_AllocList);
          
        sprintf(msg,
                "Memory leak block: %p\nAllocated by %s on line %u\n",
                Header,
                Header -> FileName,
                Header -> LineNumber
               );

        MEMORY_TRAP(msg);
    }
    return;
}
            
/*****************************************************************************
/* Local debug function definitions
/*****************************************************************************/

BOOL
Debug_IsEmptyList( 
    IN PLIST_ENTRY  ListHead
)
{
    return (ListHead -> Flink == ListHead);
}

VOID
Debug_InsertIntoListAtTail(
    IN OUT PLIST_ENTRY  ListHead,
    IN OUT PLIST_ENTRY  NewEntry
)
{
    PLIST_ENTRY         OldTail;

    OldTail = ListHead -> Blink;

    NewEntry -> Flink = ListHead;
    NewEntry -> Blink = OldTail;

    OldTail -> Flink = NewEntry;
    ListHead -> Blink = NewEntry;

    Debug_ListCount++;
    return;
}

VOID
Debug_RemoveListEntry(
    IN PLIST_ENTRY     OldEntry
)
{
    PLIST_ENTRY  Flink;
    PLIST_ENTRY  Blink;

    Flink = OldEntry -> Flink;
    Blink = OldEntry -> Blink;

    Blink -> Flink = OldEntry -> Flink;
    Flink -> Blink = OldEntry -> Blink;

    Debug_ListCount--;
    return;
}

PLIST_ENTRY
Debug_RemoveHeadOfList(
    IN PLIST_ENTRY ListHead
)
{
    PLIST_ENTRY OldHead;

    OldHead = ListHead -> Flink;
    ListHead -> Flink = OldHead -> Flink;
    OldHead -> Flink -> Blink = ListHead;

    Debug_ListCount--;
    return (OldHead);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidtest\debug.h ===
#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef DEBUG

    #ifndef _DEBUG
        #define _DEBUG
    #endif

#endif

#ifdef _DEBUG

    /*
    // Put in include files to insure that necessary files have been included 
    //    to get all function prototypes and structure defined before use
    */

    #include <windows.h>

    /*
    // Need a macro to output messages to the debugger
    */

    #define DEBUG_OUT(str)  OutputDebugString(str)

    /*
    // Define our trapping related debugging stuff
    //    Define 4 levels of trap to allow us to break only in certain
    //     conditions
    */

    #define TRAP_LEVEL_1    1
    #define TRAP_LEVEL_2    2
    #define TRAP_LEVEL_3    3
    #define TRAP_LEVEL_4    4

    #ifndef __DEBUG_C__

        extern  INT     Debug_TrapLevel;
        extern  BOOL    Debug_TrapOn;

    #endif

    #define TRAP_ON()             Debug_TrapOn = TRUE
    #define TRAP_OFF()            Debug_TrapOn = FALSE
    #define GET_TRAP_STATE()      Debug_TrapOn
    #define SET_TRAP_LEVEL(lvl)   Debug_TrapLevel = lvl

    /*
    // Define the trap macro which will break only when the trap levels
    //    are matching and also displays an optional message
    */

    #undef  TRAP
    #define TRAP(lvl, msg) \
    { \
        if (Debug_TrapOn && ((lvl) >= Debug_TrapLevel)) { \
            if (NULL != (msg))  \
                DEBUG_OUT((msg)); \
            \
            DebugBreak(); \
        } \
    }
    
    /*
    // Define the ASSERT macro to test the string.  Current it will trap
    //    whenever is on and the expression fails
    */

    #undef  ASSERT
    #define ASSERT(exp) \
    { \
        if ((!(exp))) { \
            static CHAR TempStr[1024]; \
            \
            wsprintf(TempStr, \
                     "Assertion Failed: %s, file: %s, line %s", \
                     #exp, __FILE__, __LINE__); \
            \
            DEBUG_OUT(TempStr); \
            TRAP(TRAP_LEVEL_1, NULL); \
        } \
    }

    /*
    // Memory allocation routines
    */

    /*
    // Function definitions
    */

    HGLOBAL __cdecl
    Debug_Alloc(
        IN PCHAR    FileName,
        IN ULONG    LineNumber,
        IN DWORD    AllocSize
    );

    HGLOBAL __cdecl
    Debug_Realloc(
        IN PCHAR        FileName,
        IN ULONG        LineNumber,
        IN PVOID        MemoryBlock,
        IN DWORD        AllocSize
    );

    HGLOBAL __cdecl
    Debug_Free(
        IN PVOID  Buffer
    );

    BOOL __cdecl
    Debug_ValidateMemoryAlloc(
        IN  PVOID             Header,
        OUT PVOID             AllocStatus
    );

    VOID __cdecl
    Debug_CheckForMemoryLeaks();

    /*
    // Wrapper macros
    */

    #define ALLOC(siz)          Debug_Alloc(__FILE__, __LINE__, siz)
    #define REALLOC(blk, siz)   Debug_Realloc(__FILE__, __LINE__, blk, siz)
    #define FREE(ptr)           Debug_Free(ptr)
    #define VALIDATEMEM(ptr)    Debug_ValidateMemoryAlloc(ptr, NULL)
    #define CHECKFORLEAKS()     Debug_CheckForMemoryLeaks()

#else

    /*
    // Non-debug versions of the above routines
    */

    #define DEBUG_OUT(str)

    #define TRAP_ON()  
    #define TRAP_OFF() 
    #define GET_TRAP_STATE()
    #define SET_TRAP_LEVEL(lvl)

    #undef  TRAP
    #define TRAP(lvl, msg)

    #undef  ASSERT
    #define ASSERT(exp)


    #define ALLOC(siz)          GlobalAlloc(GPTR, siz)
    #define REALLOC(blk, siz)   GlobalReAlloc(blk, siz, GMEM_ZEROINIT)
    #define FREE(ptr)           GlobalFree(ptr)
    #define VALIDATEMEM(ptr)    TRUE
    #define CHECKFORLEAKS()

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidtest\handle.h ===
#ifndef __HANDLE_H__
#define __HANDLE_H__

/*****************************************************************************
/* External macro definitions
/*****************************************************************************/

#define IS_VALID_DEVICE_HANDLE(handle)       ((INVALID_HANDLE_VALUE != (handle)) && \
                                               (NULL != (handle)))

#define MAX_NUM_HANDLES 16


/*****************************************************************************
/* External function declarations
/*****************************************************************************/

VOID
HIDTest_InitDeviceHandles(
    IN  DEVICE_STRING   DeviceName,
    IN  ULONG           nAddlHandles,
    IN  ULONG           nCallerHandles,
    IN  HANDLE          *HandleList
);   
    
VOID 
HIDTest_ResetDeviceHandles(
    VOID
);   
    
BOOL
HIDTest_GetDeviceHandle(
    HANDLE  *Handle,
    BOOL    *IsLegal
);   

VOID
HIDTest_CloseDeviceHandles(
    VOID
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidtest\handle.c ===
#define __HANDLE_C__

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>
#include "hidsdi.h"
#include "list.h"
#include "hidtest.h"
#include "handle.h"
#include "debug.h"

/*****************************************************************************
/* Miscellaneous definitions
/*****************************************************************************/
#define MIN(x, y)                   ((x) < (y) ? (x) : (y))

/*****************************************************************************
/* Macro definitions for creating additional device handles
/*****************************************************************************/
#define NUM_ILLEGAL_HANDLES 2

/*****************************************************************************
/* Module specific typedefs
/*****************************************************************************/
typedef enum  { HANDLE_STATE_CALLER, HANDLE_STATE_ADDL, HANDLE_STATE_ILLEGAL } HANDLE_STATES;

/*****************************************************************************
/* Module global variable declarations for device handle generation
/*****************************************************************************/

static CHAR             String[1024];
static DEVICE_STRING    CurrentDeviceName;
static ULONG            NumCallerHandles;
static ULONG            NumAddlHandles;
static HANDLE           CallerHandleArray[MAX_NUM_HANDLES];
static HANDLE           AddlHandleArray[MAX_NUM_HANDLES];
static ULONG            NextHandleIndex;
static ULONG            NextIllegalHandle;
static HANDLE_STATES    CurrentHandleState;
static HANDLE           IllegalHandleArray[NUM_ILLEGAL_HANDLES] = {
                                                                    INVALID_HANDLE_VALUE,
                                                                    NULL
                                                                  };


/*****************************************************************************
/* External function definitions
/*****************************************************************************/
VOID
HIDTest_InitDeviceHandles(
    IN  DEVICE_STRING   DeviceName,
    IN  ULONG           nAddlHandles,
    IN  ULONG           nCallerHandles,
    IN  HANDLE          *HandleList
)   
{   
    ULONG   Index;
    
    /*
    // Store all the caller passed in handles
    */
    
    NumCallerHandles = MIN(MAX_NUM_HANDLES, nCallerHandles);
    
    for (Index = 0; Index < NumCallerHandles; Index++) {
        CallerHandleArray[Index] = *(HandleList+Index);
    }
    
    /*
    // Open up the number of additional handles that the caller specifies,
    //    Currently, we will open every other one for OVERLAPPED I/O,
    */
    
    NumAddlHandles = MIN(MAX_NUM_HANDLES, nAddlHandles);
    
    for (Index = 0; Index < NumAddlHandles; Index++) {
        AddlHandleArray[Index] = CreateFile(DeviceName,
                                            GENERIC_READ | GENERIC_WRITE,
                                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            NULL, 
                                            OPEN_EXISTING, 
                                            (Index % 2) ? FILE_FLAG_OVERLAPPED : 0,
                                            NULL); 
 
       if (INVALID_HANDLE_VALUE == AddlHandleArray[Index]) {
            ASSERT (0);
            NumAddlHandles = Index;
            break;
        }
    }
    
    HIDTest_ResetDeviceHandles();
    return;
}   
    
VOID 
HIDTest_ResetDeviceHandles(
    VOID
)   
{   
    CurrentHandleState = HANDLE_STATE_CALLER;
    
    if (0 == NumCallerHandles) {
        if (0 == NumAddlHandles) {
            CurrentHandleState = HANDLE_STATE_ILLEGAL;
        }
        else {
            CurrentHandleState = HANDLE_STATE_ADDL;
        }
    }
    
    NextHandleIndex = 0;
    
    return;
}   
    
BOOL
HIDTest_GetDeviceHandle(
    HANDLE  *Handle,
    BOOL    *IsLegal
)   
{   
    BOOL    RetVal = TRUE;
    
    switch (CurrentHandleState) {
        case HANDLE_STATE_CALLER:
            ASSERT (NextHandleIndex < NumCallerHandles);
    
            *Handle  = CallerHandleArray[NextHandleIndex++];
            *IsLegal = TRUE;
    
            if (NextHandleIndex >= NumCallerHandles) {
                NextHandleIndex = 0; 
                CurrentHandleState = (NumAddlHandles > 0) ? HANDLE_STATE_ADDL :
                                                           HANDLE_STATE_ILLEGAL;
            }    
            break;
    
        case HANDLE_STATE_ADDL:
            ASSERT (NextHandleIndex < NumAddlHandles);
    
            *Handle  =  AddlHandleArray[NextHandleIndex++];
            *IsLegal = TRUE;
    
            if (NextHandleIndex >= NumAddlHandles) {
                NextHandleIndex = 0;
                CurrentHandleState = HANDLE_STATE_ILLEGAL;
            }
            break;
    
        case HANDLE_STATE_ILLEGAL:
            if (NextHandleIndex >= NUM_ILLEGAL_HANDLES) {
                RetVal = FALSE;
            }
            else {
                *Handle = IllegalHandleArray[NextHandleIndex++];
                *IsLegal = FALSE;
            }
            break;
    
        default:
            ASSERT(0);
    
    }
    return (RetVal);
}   

VOID
HIDTest_CloseDeviceHandles(
    VOID
)
{
    ULONG   Index;

    for (Index = 0; Index < NumAddlHandles; Index++) {
        CloseHandle(AddlHandleArray[Index]);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidtest\list.h ===
#ifndef __LIST_H__
#define __LIST_H__

#include <windows.h>

typedef LIST_ENTRY      LIST_NODE_HDR, *PLIST_NODE_HDR;
typedef LIST_NODE_HDR   LIST, *PLIST;

typedef VOID PLIST_CALLBACK(PLIST_NODE_HDR);

VOID
InitializeList(
    IN  PLIST   NewList
);

VOID
InsertHead(
    IN  PLIST           List,
    IN  PLIST_NODE_HDR  ListNode
);

VOID
InsertTail(
    IN  PLIST           List,
    IN  PLIST_NODE_HDR  ListNode
);

VOID
RemoveNode(
    IN  PLIST_NODE_HDR  ListNode   
);

PLIST_NODE_HDR
RemoveHead(
    IN  PLIST   List
);

PLIST_NODE_HDR
RemoveTail(
    IN  PLIST   List
);

BOOL
IsListEmpty(
    IN  PLIST   List
);

PLIST_NODE_HDR
GetListHead(
    IN  PLIST   List
);

PLIST_NODE_HDR
GetListTail(
    IN  PLIST   List
);

PLIST_NODE_HDR
GetNextEntry(
    IN  PLIST_NODE_HDR  ListNode
);

PLIST_NODE_HDR
GetPrevEntry(
    IN  PLIST_NODE_HDR  ListNode
);

VOID
DestroyListNoCallback(
    IN  PLIST           List
);

VOID
DestroyListWithCallback(
    IN  PLIST           List,
    IN  PLIST_CALLBACK  Callback
);


/*****************************************************************************
/* Macro definitions of list functions
/*****************************************************************************/

#ifdef USE_MACROS

    /*
    // VOID
    // InitializeList(
    //     IN  PLIST    NewList
    // );
    */
    
    #define InitializeList(nl) \
        { ((PLIST)(nl)) -> Flink = ((PLIST)(nl)) -> Blink = nl; }
    
    /* 
    // VOID
    // InsertHead(
    //     IN  PLIST            List,
    //     IN  PLIST_NODE_HDR   ListNode
    // );
    */
    
    #define InsertHead(List, Node) {                    \
        PLIST_NODE_HDR _EX_Flink;                       \
        PLIST_NODE_HDR _EX_List;                        \
                                                        \
        _EX_List = ((PLIST_NODE_HDR) (List));           \
        _EX_Flink = _EX_List -> Flink;                  \
        ((PLIST_NODE_HDR) (Node))->Blink = _EX_List;    \
        ((PLIST_NODE_HDR) (Node))->Flink = _EX_Flink;   \
        _EX_Flink->Blink = (((PLIST_NODE_HDR) (Node))); \
        _EX_List->Flink = ((PLIST_NODE_HDR) (Node));    \
    }
    
    
    /* 
    // VOID
    // InsertTail(
    //     IN  PLIST            List,
    //     IN  PLIST_NODE_HDR   ListNode
    // );
    */
    
    #define InsertTail(List, Node) {                    \
        PLIST_NODE_HDR _EX_Blink;                       \
        PLIST_NODE_HDR _EX_List;                        \
                                                        \
        _EX_List = ((PLIST_NODE_HDR) (List));           \
        _EX_Blink = _EX_List->Blink;                    \
        ((PLIST_NODE_HDR) (Node))->Flink = _EX_List;    \
        ((PLIST_NODE_HDR) (Node))->Blink = _EX_Blink;   \
        _EX_Blink->Flink = (((PLIST_NODE_HDR) (Node))); \
        _EX_List->Blink = ((PLIST_NODE_HDR) (Node));    \
    }
    
    /*
    //  VOID
    //  RemoveNode(
    //      IN  PLIST_NODE_HDR  ListNode   
    //  );
    */
    
    #define RemoveNode(node) {                          \
        PLIST_NODE_HDR _EX_Blink;                       \
        PLIST_NODE_HDR _EX_Flink;                       \
                                                        \
        _EX_Flink = ((PLIST_NODE_HDR) (node))->Flink;   \
        _EX_Blink = ((PLIST_NODE_HDR) (node))->Blink;   \
        _EX_Blink->Flink = _EX_Flink;                   \
        _EX_Flink->Blink = _EX_Blink;                   \
    }
    
    
    /* 
    // PLIST_NODE_HDR
    // RemoveHead(
    //     IN  PLIST    List
    // );               
    */                  
    
    #define RemoveHead(List)                            \
        GetListHead((List));                            \
        RemoveNode(((PLIST_NODE_HDR) (List))->Flink)  
                        
    /*                  
    // PLIST_NODE_HDR   
    // RemoveTail(      
    //     IN  PLIST    List
    // );               
    */                  
    
    #define RemoveTail(List)                            \
        GetListTail((List));                            \
        RemoveNode(((PLIST_NODE_HDR) (List))->Blink)    
    
    /*                  
    // BOOL             
    // IsListEmpty(     
    //     IN  PLIST    List
    // );               
    */                  
    
    #define IsListEmpty(List)                           \
        (((PLIST_NODE_HDR) (List))->Flink == ((PLIST_NODE_HDR) (List)))
                        
    /*                  
    // PLIST_NODE_HDR   
    // GetListHead(     
    //     IN  PLIST    List
    // );               
    */                  
    
    #define GetListHead(List)                           \
        (((PLIST_NODE_HDR) (List))->Flink);
    
    /*                  
    // PLIST_NODE_HDR   
    // GetListTail(     
    //     IN  PLIST    List
    // );               
    */                  
    
    #define GetListTail(List)                           \
        (((PLIST_NODE_HDR)) (List))->Blink;
                        

    /*
    // PLIST_NODE_HDR
    // GetNextEntry(
    //    IN  PLIST_NODE_HDR  ListNode
    // );
    */

    #define GetNextEntry(ListNode)                      \
        (((PLIST_NODE_HDR) (ListNode)) -> Flink);

    /* 
    // PLIST_NODE_HDR
    // GetPrevEntry(
    //    IN  PLIST_NODE_HDR  ListNode
    // );
    */

    #define GetPrevEntry(ListNode)                      \
        (((PLIST_NODE_HDR) (ListNode)) -> Blink);

    /* 
    // VOID
    // DestroyListNoCallback(
    //     IN  PLIST           List,
    //     IN  PLIST_CALLBACK  Callback
    // );
    */ 
    
    #define DestroyListNoCallback(list)                 \
        PLIST_NODE_HDR  currNode;                       \
                                                        \
        while (!IsListEmpty((list))) {                  \
            currNode = RemoveHead((list));              \
        }                                               \
    }

    /* 
    // VOID
    // DestroyListWithCallback(
    //     IN  PLIST           List,
    //     IN  PLIST_CALLBACK  Callback
    // );
    */ 
    
    #define DestroyListWithCallback(list, cb) {         \
        PLIST_NODE_HDR  currNode;                       \
                                                        \
        while (!IsListEmpty((list))) {                  \
            currNode = RemoveHead((list));              \
            (cb)(currNode);                             \
        }                                               \
    }
    
    #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidtest\log.c ===
#define __LOG_C__

/*****************************************************************************
/* Log include files
/*****************************************************************************/
#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>
#include <limits.h>
#include "log.h"
#include "hidsdi.h"

#define USE_MACROS
#include "list.h"

#include "hidtest.h"
#include "debug.h"

/*****************************************************************************
/* Local macro definitions
/*****************************************************************************/

#define IS_LOGGING_ON                        ((NULL != hTestLog) && (IsLogOn))

/*****************************************************************************
/* Module global variable declarations for logging
/*****************************************************************************/

static HANDLE   hTestLog = NULL;
static BOOL     IsLogOn  = FALSE;

static CHAR     String[1024];

/*****************************************************************************
/* Exportable logging function definitions
/*****************************************************************************/

BOOL
HIDTest_CreateTestLogA(
    IN  PCHAR  LogName
)
{
    hTestLog = tlCreateLog(LogName, TLS_REFRESH | TLS_LOGALL);
    if (NULL != hTestLog) {
        tlAddParticipant(hTestLog, 0, 1);
    }

    IsLogOn = (NULL != hTestLog);
    return (IsLogOn);
}

VOID
HIDTest_CloseTestLogA(
    VOID
)
{
    if (NULL != hTestLog) {
        tlRemoveParticipant(hTestLog);
        tlDestroyLog(hTestLog);
    }
    return;
}

VOID
HIDTest_SetLogOnA(
    BOOL    TurnOn
)
{
    IsLogOn = TurnOn;
    return;
}

/*****************************************************************************
/* Local functions to deal with NT based logging
/****************************************************************************/
VOID
HIDTest_LogStartTest(
    PCHAR   TestName
)
{ 
    if (IS_LOGGING_ON) { 
        tlLog(hTestLog, TL_INFO, TestName); 
        tlClearTestStats(hTestLog); 
    }
    return;
}

VOID
HIDTest_LogStartTestIteration(
    ULONG   IterationNumber
)
{
    if (IS_LOGGING_ON) {
        wsprintf(String, "Iteration number: %u", IterationNumber);
        tlLog(hTestLog, TL_INFO, String);
    }
    return;
}

VOID
HIDTest_LogStartVariationWithDeviceHandle(
    HANDLE DeviceHandle,
    BOOL   IsLegal,
    PCHAR  Description
)
{ 
    wsprintf(String,  
             "DeviceHandle = %u, IsLegalDeviceHandle = %s, Test Desc: %s", 
             (DeviceHandle), 
             (IsLegal) ? "TRUE" : "FALSE",
             Description
            ); 
    
    LOG_INTERMEDIATE_VARIATION_RESULT(String);

    return;
}

VOID
HIDTest_LogStartVariation(
    PCHAR Variation
)
{ 
    if (IS_LOGGING_ON) { 
        tlStartVariation(hTestLog); 
        tlLog(hTestLog, TL_INFO, Variation); 
    } 
    return;
}

VOID
HIDTest_LogVariationResult(
    INT   Level,
    PCHAR VarString
)
{ 
    if (IS_LOGGING_ON) { 
        tlLog(hTestLog, Level | TL_VARIATION, VarString); 
    } 
    return;
}

VOID
HIDTest_LogEndVariation(
    VOID
)
{ 
    DWORD dwVariationResult; 

    if (IS_LOGGING_ON) { 
        dwVariationResult = tlEndVariation(hTestLog); 
        tlLog(hTestLog, dwVariationResult | TL_VARIATION, "End variation"); 
    } 
    return;
}

VOID
HIDTest_LogEndTest(
    VOID
)
{
    if (IS_LOGGING_ON) { 
        tlLog(hTestLog, TL_TEST, ""); 
    } 
    return;
}

VOID
HIDTest_LogIntermediateVariationResult(
    IN  PCHAR   VarResult
)
{
    if (IS_LOGGING_ON) {
        tlLog(hTestLog, TL_INFO, VarResult);
    }
    return;
}

VOID
HIDTest_LogTestWarning(
    IN  PCHAR   WarningMsg
)
{
    if (IS_LOGGING_ON) {
        tlLog(hTestLog, TL_WARN, WarningMsg);
    }
    return;
}

VOID
HIDTest_LogTestError(
    IN  PCHAR   ErrMsg
)
{
    if (IS_LOGGING_ON) {
        wsprintf(String, 
                 "Critical test error: %s, cannot proceed",
                 ErrMsg
                );
        tlLog(hTestLog, TL_SEV1, String);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\filter\hidvalid\read.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidtest\log.h ===
#ifndef __LOG_H__
#define __LOG_H__

#include "ntlog.h"

/*****************************************************************************
/* Macro definitions for logging test results
/*****************************************************************************/

#define LOG_ON()                   HIDTest_SetLogOnA(TRUE)
#define LOG_OFF()                  HIDTest_SetLogOnA(FALSE)

#define START_TEST(testname)       HIDTest_LogStartTest(testname)
#define START_TEST_ITERATION(iNum) HIDTest_LogStartTestIteration(iNum)

#define START_VARIATION_ON_DEVICE_HANDLE(handle, legal) \
                                HIDTest_LogStartVariationWithDeviceHandle((handle), \
                                                        (legal), "")    
#define START_VARIATION_WITH_DEVICE_HANDLE(handle, legal, desc) \
                                HIDTest_LogStartVariationWithDeviceHandle((handle), \
                                                        (legal), (desc))                              

#define START_VARIATION(variation)           HIDTest_LogStartVariation(variation)

#define LOG_VARIATION_RESULT(level, string)  HIDTest_LogVariationResult(level, string)

#define LOG_VARIATION_PASS()                 LOG_VARIATION_RESULT(TLS_PASS, "")
#define LOG_VARIATION_FAIL()                 LOG_VARIATION_RESULT(TLS_SEV3, "")
#define LOG_BUFFER_VALIDATION_FAIL()         LOG_INTERMEDIATE_VARIATION_RESULT("Buffer validation failure");
#define LOG_INVALID_RETURN_STATUS()          LOG_INTERMEDIATE_VARIATION_RESULT("Invalid return status");
#define LOG_INVALID_ERROR_CODE()             LOG_INTERMEDIATE_VARIATION_RESULT("Invalid error code returned")

#define LOG_INTERMEDIATE_VARIATION_RESULT(string)  HIDTest_LogIntermediateVariationResult(string)
#define LOG_TEST_ERROR(errmsg)                     HIDTest_LogTestError(errmsg)
#define LOG_WARNING(warnmsg)                       HIDTest_LogTestWarning(warnmsg)

#define END_VARIATION()                            HIDTest_LogEndVariation()
#define END_TEST_ITERATION()
#define END_TEST()                                 HIDTest_LogEndTest()

#define LOG_UNEXPECTED_STATUS_WARNING(funcname, status) \
{                                                       \
    static CHAR wrnString[128];                         \
                                                        \
    wsprintf(wrnString,                                 \
             "%s returned unexpected status: 0x%X",     \
             funcname,                                  \
             status                                     \
            );                                          \
                                                        \
    LOG_WARNING(wrnString);                             \
}    

VOID
HIDTest_LogStartTest(
    PCHAR   TestName
);

VOID
HIDTest_LogStartTestIteration(
    ULONG   IterationNumber
);

VOID
HIDTest_LogStartVariationWithDeviceHandle(
    HANDLE DeviceHandle,
    BOOL   IsLegal,
    PCHAR  Description
    
);

VOID
HIDTest_LogStartVariation(
    PCHAR Variation
);

VOID
HIDTest_LogVariationResult(
    INT   Level,
    PCHAR VarString
);

VOID
HIDTest_LogEndVariation(
    VOID
);

VOID
HIDTest_LogEndTest(
    VOID
);

VOID
HIDTest_LogIntermediateVariationResult(
    IN  PCHAR   VarResult
);

VOID
HIDTest_LogTestWarning(
    IN  PCHAR   WarningMsg
);

VOID
HIDTest_LogTestError(
    IN  PCHAR   ErrMsg
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidtest\hidtest.c ===
#define __HIDTEST_C__

/*
// This file contains the code used for performing different tests on the Hid
//   Devices.  A Hid Device can be either a physical or logical device where 
//   a physical device is considered a tangible object like a mouse or keyboard.
//   A logical device is simply Preparsed Data that has been generated from a
//   report descriptor (either manually created or captured from a physical
//   device.  Therefore, the test APIs that apply to logical devices are more 
//   limited since you cannot open a file object up for them.  
//
//  Since I've had problems trying to decide what my test structure will be for
//   using the NT logging functions, I will enumerate it here to hopefully avoid
//   confusion and/or refresh my own memory and a later time. 
//
//   TEST -- test api function -- for it to pass there must be no failures during
//                                the test, beginning of api should have START_TEST()
//
//      TEST ITERATION         -- one iteration of the full test, one of API
//                                user parameters is the # of iterations to perform
//                                Beginning of each iteration loop should have
//                                START_TEST_ITERATION() call
//
//          VARIATION          -- test is made up of a series of variations, a
//                                  variation is considered to be one check 
//                                  of the validity of a test.  This usually 
//                                  tweaking one major parameter to the tested 
//                                  function (ie. a different file object, or
//                                  invalid Preparsed data)  These are the 
//                                  most common variations that will be used
//
//            INT_VAR_RESULT   -- Abbreviated for INTERMEDIATE_VARIATION_RESULT
//                                  This is some sort of information that gets
//                                  logged about the current state of the variation
//                                  being performed.  It uses the NT logging 
//                                  type of TL_INFO.  It's mainly used to generate
//                                  a little more information for a debugging case
//
//            VARIATION_RESULT -- Actual result of a variation -- This is where
//                                  the variation is logged as either pass or 
//                                  fail.  A variation may fail due to a reason
//                                  that is specified by INT_VAR_RESULT but 
//                                  the actual error code is set here.
//
//         END_VARIATION       -- Macro called to indicate the end of a variation
//      
//      END_TEST_ITERATION     -- Macro called to signify the end of one particular
//                                  iteration of the test -- Another iteration should
//                                  perform the exact same variations with the
//                                  exact same conditions.
//
//   END_TEST                  -- Macro called to indicate the end of the test
//                                  API -- No other information should be logged
//                                  at this point
//
//  There are two other macros that do some sort of logging and have some sort
//      of meaning to the test suite.  However, they do not relate to the general
//      test structure above although they may effect the operation of a test.
//
//      WARNING                -- Warning is used to indicate that something was
//                                found that may be incorrect but is not something
//                                that is the focus of the test API and therefore
//                                is not flagged as a variation failure.  An example
//                                of a warning is a HID API returning the wrong
//                                error code.  Since the HID API that returned the
//                                code was not the one that was being directly tested
//                                but being used to validate the APIs currently
//                                under test.  
//
//      TEST_ERROR             -- Test error is something beyond our control which
//                                will not let the test continue but is not due
//                                to a variation failure.  An example of a test
//                                error is the failure of a memory allocation
//
// Hopefully, that will provide a little more info and add a tad more understanding
//   to the implementation below.  Hopefully, I'll be able to go back to it
//   and keep me from getting confused.
*/

/*****************************************************************************
/* HidTest include files
/*****************************************************************************/
#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>
#include <limits.h>
#include "hidsdi.h"

#define USE_MACROS
#include "list.h"

#include "hidtest.h"
#include "log.h"
#include "handle.h"
#include "buffer.h"
#include "debug.h"

 /*
// Include hidclass.h so we can get the HID_CLASS GUID value
*/

#define INITGUID
#include "hidclass.h"               

/*****************************************************************************
/* Local macro definitions
/*****************************************************************************/
#define HIDTest_CompareAttributes(pa1, pa2) (((pa1) -> Size == (pa2) -> Size) && \
                                             ((pa1) -> VendorID == (pa2) -> VendorID) && \
                                             ((pa1) -> ProductID == (pa2) -> ProductID) && \
                                             ((pa1) -> VersionNumber == (pa2) -> VersionNumber))


#define HIDTest_CompareStrings(s1, s1len, s2, s2len) (((s1len) == (s2len)) && \
                                                      (0 == memcmp((s1), (s2), (s1len))))


/*****************************************************************************
/* Miscellaneous other definitions
/*****************************************************************************/

#define STRINGS_TO_TEST 0x100
#define INIT_STR_LIST_SIZE 4
#define STRING_INDEX_MANUFACTURER  0xFFFFFFFC
#define STRING_INDEX_PRODUCT       0xFFFFFFFD
#define STRING_INDEX_SERIAL_NUMBER 0xFFFFFFFE

#define COMPARE_GUIDS(guid1, guid2) ((0 == memcmp(&(guid1), &(guid2), sizeof(GUID))))
#define MIN(x, y)                   ((x) < (y) ? (x) : (y))

#define CURRENT_BUFFER_MIN  2
#define RANDOM_BUFFER_VALUE 10

/*****************************************************************************
/* Module specific typedefs
/*****************************************************************************/
typedef struct _DataIndexList {

    ULONG   MaxDataIndex;
    BOOL    *List;

} DATA_INDEX_LIST, *PDATA_INDEX_LIST;


/*****************************************************************************
/* DLL exportable variables with exportable function address
/*****************************************************************************/

PHIDTEST_API HIDTest_VerifyHidGuid;
PHIDTEST_API HIDTest_VerifyStrings;
PHIDTEST_API HIDTest_VerifyPreparsedData;
PHIDTEST_API HIDTest_VerifyAttributes;
PHIDTEST_API HIDTest_VerifyCapabilities;

PCREATE_PHYSICAL_DEVICE_INFO_PROC  HIDTest_CreatePhysicalDeviceInfo;
PCREATE_LOGICAL_DEVICE_INFO_PROC   HIDTest_CreateLogicalDeviceInfo;
PCREATE_FREE_DEVICE_INFO_PROC      HIDTest_FreeDeviceInfo;
PCREATE_TEST_LOG_PROC              HIDTest_CreateTestLog;
PSET_LOG_ON_PROC                   HIDTest_SetLogOn;
PCLOSE_TEST_LOG_PROC               HIDTest_CloseTestLog;

/*****************************************************************************
/* Local function declarations
/*****************************************************************************/

BOOL
HIDTest_FillCommonDeviceInfo(
    OUT PHIDTEST_DEVICEINFO DeviceInfo
);


BOOL
HIDTest_FillValueCaps(
    IN  HIDP_REPORT_TYPE        ReportType,
    IN  PHIDP_VALUE_CAPS        *CapsBuffer,
    IN  ULONG                   NumCaps,
    IN  PHIDP_PREPARSED_DATA    Ppd
);


BOOL
HIDTest_FillButtonCaps(
    IN  HIDP_REPORT_TYPE        ReportType,
    IN  PHIDP_BUTTON_CAPS        *CapsBuffer,
    IN  ULONG                   NumCaps,
    IN  PHIDP_PREPARSED_DATA    Ppd
);

BOOL
HIDTest_DoGetFreePpd(
    IN  HANDLE  HidDevice
);

BOOL
HIDTest_ValidateAttributes(
    IN  HANDLE            HidDevice,
    IN  PHIDD_ATTRIBUTES  Attrib
);

BOOL
HIDTest_ValidateCaps(
    IN  PHIDP_PREPARSED_DATA    HidPpd,
    IN  PHIDP_CAPS              HidCaps
);

BOOL
HIDTest_ValidateBufferValues(
    IN HIDP_REPORT_TYPE     ReportType,
    IN USHORT               NumButtonCaps,
    IN USHORT               NumValueCaps,
    IN USHORT               NumDataIndices,
    IN PHIDP_PREPARSED_DATA Ppd
);

BOOL
HIDTest_ValidateNumInputBuffers(    
    IN  HANDLE  HandleToTest,
    IN  HANDLE  SecondHandle,
    IN  BOOL    IsFirstHandleLegal,
    IN  PULONG  TestBuffer
);

BOOL
HIDTest_GetBufferCount(
    IN  HANDLE  DeviceHandle,
    IN  PULONG  TestBuffer
);

BOOL
HIDTest_ValidateStrings(
    HANDLE          DeviceHandle,
    PLIST           MasterList,
    IN  ULONG       ManufacturerStringIndex,
    IN  ULONG       ProductStringIndex,
    IN  ULONG       SerialNumberStringIndex
);

BOOL
HIDTest_ValidateStdStrings(
    IN  HANDLE      DeviceHandle,
    IN  PLIST       CurrentStringList,
    IN  ULONG       ManufacturerStringIndex,
    IN  ULONG       ProductStringIndex,
    IN  ULONG       SerialNumberStringIndex    
);

BOOL
HIDTest_ValidateStringParams(
    IN  HANDLE      HidDevice,
    IN  PLIST       StringList,
    IN  ULONG       ManufacturerStringIndex,
    IN  ULONG       ProductStringIndex,
    IN  ULONG       SerialNumberStringIndex
);

BOOL
HIDTest_ValidateStringIndexParams(
    IN  HANDLE      HidDevice,
    IN  ULONG       StringIndex,
    IN  ULONG       StringLength,
    IN  PCHAR       StringTypeDesc
);

BOOL
HIDTest_CompareCaps(
    IN  PHIDP_CAPS  Caps1, 
    IN  PHIDP_CAPS  Caps2 
);

BOOL
HIDTest_InitDataIndexList(
    IN  ULONG             MaxDataIndex,
    OUT PDATA_INDEX_LIST  IndexList
);

VOID
HIDTest_FreeDataIndexList(
    IN  PDATA_INDEX_LIST    IndexList
);

BOOL
HIDTest_MarkDataIndex(
    IN  PDATA_INDEX_LIST    IndexList,
    IN  ULONG               IndexValue
);

BOOL
HIDTest_GetDataIndexStatus(
    IN  PDATA_INDEX_LIST    IndexList,
    IN  ULONG               IndexValue
);

BOOL
HIDTest_AreAllIndicesUsed(
    IN  PDATA_INDEX_LIST    IndexList
);

BOOL
HIDTest_DoesStringExist(
    HANDLE  DeviceHandle,
    ULONG   StringIndex,
    PWCHAR  *String,
    PULONG  StringLength,
    BOOL    *StringExists
);

BOOL
HIDTest_GetWideStringLength(
    PWCHAR  String,
    ULONG   StringSize,
    PULONG  StringLength
);

BOOL
HIDTest_GetString(
    HANDLE  DeviceHandle,
    ULONG   StringIndex,
    PWCHAR  StringBuffer,
    ULONG   BufferLength,
    PULONG  ErrorCode
);

BOOL
HIDTest_BuildStringList(
    HANDLE          DeviceHandle,
    PLIST       StringList
);

VOID
HIDTest_FreeStringList(
    PLIST        StringList
);

VOID
HIDTest_FreeStringNodeCallback(
    PLIST_NODE_HDR  ListNode
);

BOOL 
HIDTest_AddStringToStringList(
    PLIST           StringList,
    ULONG           StringIndex,
    PWCHAR          String,
    ULONG           StringLength
);

BOOL
HIDTest_IsStrIndexInStrList(
    PLIST               StringList,
    ULONG               StringIndex,
    PSTRING_LIST_NODE   StringNode
);

BOOL
HIDTest_IsStringInStrList(
    PLIST               StringList,
    PWCHAR              String,
    ULONG               StringLength,
    PSTRING_LIST_NODE   StringNode
);

BOOL
HIDTest_CompareStringLists(
    PLIST    StringList1,
    PLIST    StringList2
);

VOID
HIDTest_CallGetFeature(
    IN  HANDLE  DeviceHandle,
    IN  UCHAR   ReportID,
    IN  PUCHAR  ReportBuffer,
    IN  ULONG   ReportBufferLength,
    OUT PBOOL   ReturnStatus,
    OUT PULONG  ErrorCode,
    OUT PBOOL   BufferStatus
);

VOID
HIDTest_CallSetFeature(
    IN  HANDLE  DeviceHandle,
    IN  UCHAR   ReportID,
    IN  PUCHAR  ReportBuffer,
    IN  ULONG   ReportBufferLength,
    OUT PBOOL   ReturnStatus,
    OUT PULONG  ErrorCode,
    OUT PBOOL   BufferStatus
);

BOOL
HIDTest_BuildReportIDList(
    IN  PHIDP_VALUE_CAPS    VCaps,
    IN  ULONG               NumVCaps,
    IN  PHIDP_BUTTON_CAPS   BCaps,
    IN  ULONG               NumBCaps,
    IN  PUCHAR              *ReportIDs,
    IN  PULONG              ReportIDCount
);

VOID
HIDTest_InsertIDIntoList(
    IN  PUCHAR  ReportIDs,
    IN  PULONG  ReportIDCount,
    IN  UCHAR   NewID
);

BOOL 
HIDTest_IsIDInList(
    IN  UCHAR   ReportID,
    IN  PUCHAR  ReportIDList,
    IN  ULONG   ReportIDListCount
);

/*****************************************************************************
/* Exportable function definitions
/*****************************************************************************/

BOOLEAN __stdcall
DllMain(
    HINSTANCE hinst, 
    DWORD dwReason, 
    LPVOID lpReserved
)
{
    switch (dwReason) {
        default: return TRUE;
   }
}

VOID
HIDTest_InitExportAddress(
    PHIDTEST_FUNCTIONS  Exports
)
{
    Exports -> HIDTest_VerifyHidGuid            = &HIDTest_VerifyHidGuidA;
    Exports -> HIDTest_VerifyStrings            = &HIDTest_VerifyStringsA;
    Exports -> HIDTest_VerifyPreparsedData      = &HIDTest_VerifyPreparsedDataA;
    Exports -> HIDTest_VerifyAttributes         = &HIDTest_VerifyAttributesA;
    Exports -> HIDTest_VerifyNumBuffers         = &HIDTest_VerifyNumBuffersA;
    Exports -> HIDTest_VerifyCapabilities       = &HIDTest_VerifyCapabilitiesA;
    Exports -> HIDTest_VerifyGetFeature         = &HIDTest_VerifyGetFeatureA;
    Exports -> HIDTest_VerifySetFeature         = &HIDTest_VerifySetFeatureA;

    Exports -> HIDTest_CreatePhysicalDeviceInfo = &HIDTest_CreatePhysicalDeviceInfoA;
    Exports -> HIDTest_CreateLogicalDeviceInfo  = &HIDTest_CreateLogicalDeviceInfoA;
    Exports -> HIDTest_FreeDeviceInfo           = &HIDTest_FreeDeviceInfoA;
    Exports -> HIDTest_CreateTestLog            = &HIDTest_CreateTestLogA;
    Exports -> HIDTest_SetLogOn                 = &HIDTest_SetLogOnA;
    Exports -> HIDTest_CloseTestLog             = &HIDTest_CloseTestLogA;

    return;
}

VOID
HIDTest_VerifyHidGuidA(
    IN  PHIDTEST_DEVICEINFO HidDevice,
    IN  ULONG               nIterations,
    OUT PHIDTEST_STATUS     Status
)
{
    ULONG                   OperationCount;
    ULONG                   IterationCount;
    ULONG                   FailedCount;
    GUID                    *CallGuid;
    
    /*
    // Testing the HidD_GetHidGuid function is relatively simple.  It consists of
    //    one variation which calls HidD_GetHidGuid nIterations times and compares
    //    the received guid with the standard hidclass guid. 
    */

    OperationCount = 0;
    FailedCount = 0;             

    START_TEST("HIDTest_HidD_GetHidGuid");

    CallGuid = (GUID *) AllocateTestBuffer(sizeof(GUID));

    if (NULL == CallGuid) {

        LOG_TEST_ERROR("Couldn't allocate memory");
        return;

    }

    for (IterationCount = 1; IterationCount <= nIterations; IterationCount++) {

        START_TEST_ITERATION(IterationCount);

        START_VARIATION("Validating the HID Class GUID");

        HidD_GetHidGuid(CallGuid);

        if (!ValidateTestBuffer(CallGuid)) {

            LOG_VARIATION_RESULT(TLS_SEV3, "Buffer violation");
            FailedCount++;

        }
        else if (!COMPARE_GUIDS(GUID_CLASS_INPUT, *CallGuid)) {
            LOG_VARIATION_FAIL();
            FailedCount++;
        }
        else {
            LOG_VARIATION_PASS();
        }
        OperationCount++;

        END_VARIATION();

        END_TEST_ITERATION();
    }

    END_TEST();

    FreeTestBuffer(CallGuid);

    Status -> nOperationsPerformed = OperationCount;
    Status -> nOperationsFailed    = FailedCount;
    Status -> nOperationsPassed    = OperationCount - FailedCount;
    
    return;
}


VOID
HIDTest_VerifyPreparsedDataA(
    IN  PHIDTEST_DEVICEINFO HidDevice,
    IN  ULONG               nIterations,
    OUT PHIDTEST_STATUS     Status
)
{
    ULONG                   OperationCount;
    ULONG                   IterationCount;
    ULONG                   FailedCount;
    BOOL                    CallStatus;
    HANDLE                  CurrDeviceHandle;
    BOOL                    IsLegalDeviceHandle;
    static HANDLE           HandleList[MAX_NUM_HANDLES];

    /*
    // This test is made up of a number of different variations depending on
    //    the number of handles that will be used but the basic concept is the
    //    following.
    //    
    //    1) For each handle that we get from the handle generator
    //         attempt to get preparsed data for that handle and compare
    //         the results of the Get/Free status with what we should expect
    //         to receive depending on the validity of the handle.  The results
    //         we expect to see is what we have stored for PreparsedData in the 
    //         HidDevice struct.
    //    
    //    2) Also, if during the above iterations we encounter a legal handle
    //          value, we will try to GetPreparsed data with a NULL value
    //          passed in as the second paramters.  The call should simply
    //          fail.
    //
    //    3) After all is said and done, we attempt to free bogus buffers,
    //         both NULL and the HandleList buffer.  See comments below for
    //         the reason, HandleList is to be freed.
    //
    //    The above steps are all variations of the test, and the variations
    //          must pass for nIterations in order for the variation to pass.
    //          Each separate handle is also a variation.  Basically,
    //          there will be 2N + 1 variations where N is the number
    //          of handles being tested.
    */

    START_TEST("HIDTest_VerifyPreparsedData");

    /*
    // Initialize the test statistics variables
    */

    FailedCount    = 0;
    OperationCount = 0;

    /*
    // This test is made up of three variations, each of which is performs
    //    the same operation nIterations number of times.  To pass a variation
    //    all iterations must pass.
    */


    /*
    // Begin by initializing the device handles that will be used for the test
    //    A device handle list is built and passed into InitDeviceHandles.  
    //    Subsequent calls to GetDeviceHandle will return either one of the
    //    handles that is specified in this list or another handle that the 
    //    "Handle Manager" has decided should be tested as well.
    */

    if (IS_VALID_DEVICE_HANDLE(HidDevice -> HidDeviceHandle)) {
        HandleList[0] = HidDevice -> HidDeviceHandle;

        ASSERT (NULL != HidDevice -> HidDeviceString);

        HIDTest_InitDeviceHandles(HidDevice -> HidDeviceString,
                                  2,
                                  1,
                                  HandleList
                                 );

    }
    else {

        LOG_TEST_ERROR("HidDevice Handle is invalid -- cannot perform test");
        goto VERIFY_PPD_END;

    }

    /*
    // The testing of the preparsed data function involves attempting to get
    //    and set the free preparsed data nIterations number of times for a
    //    given device handle.  If the device handle is not a legal one, 
    //    then the CallStatus should be FALSE instead of TRUE
    //
    */

    /*
    // Start the iteration loop
    */

    for (IterationCount = 1; IterationCount <= nIterations; IterationCount++) {

        START_TEST_ITERATION( IterationCount );

        HIDTest_ResetDeviceHandles();

        while (HIDTest_GetDeviceHandle(&CurrDeviceHandle, &IsLegalDeviceHandle)) {

            START_VARIATION_ON_DEVICE_HANDLE(CurrDeviceHandle,
                                             IsLegalDeviceHandle
                                            );
  
            /*
            // If the handle that is being tested is a valid one, then the 
            //  below call should return TRUE and FALSE otherwise.  Therefore
            //  we need only compare the return value with the IsLegalDeviceHandle
            //  variable to determine if the call really failed or not.
            */
            
            CallStatus = HIDTest_DoGetFreePpd(CurrDeviceHandle);
        
            if (CallStatus != IsLegalDeviceHandle) {

                LOG_VARIATION_FAIL();
                FailedCount++;
 
            }
            else {
                LOG_VARIATION_PASS();
            }

            OperationCount++;

            END_VARIATION();
        }

        /*
        // Start another variation, this time, we attempt to free a block of 
        //   PREPARSED_DATA which is not actually a block of preparsed data
        */
    
        START_VARIATION("Attempting to free non-preparsed data block\n");

        /*
        // We'll pass in the address of the HandleList for three reasons 
        //  1) If the function touches any part of this memory, it had better
        //       be a valid address so we don't page fault
        //  2) If the function touches the memory, it should be big enough
        //        for the same reason -- there's a good chance this will be
        //        big enough.
        //  3) If he garbles any of the data, it's not going to kill our app
        //       The list is defined static so that the procedure doesn't try
        //       to free stack space either.  Basically, if it does try to free
        //       this memory block, we at least should be able to determine
        //       that he freed the block instead of possibly having the OS go off
        //       into la-la land and not knowing what happened.
        */

        CallStatus = HidD_FreePreparsedData((PHIDP_PREPARSED_DATA) (&HandleList));

        if (CallStatus) {
            FailedCount++;
            LOG_VARIATION_FAIL();
        }
        else {
            LOG_VARIATION_PASS();
        }
        OperationCount++;

        END_VARIATION();

        END_TEST_ITERATION();

    }
    HIDTest_CloseDeviceHandles();

VERIFY_PPD_END:

    END_TEST();

    Status -> nOperationsPerformed = OperationCount;
    Status -> nOperationsPassed    = OperationCount - FailedCount;
    Status -> nOperationsFailed    = FailedCount;

    return;
}

VOID 
HIDTest_VerifyAttributesA(
    IN  PHIDTEST_DEVICEINFO  HidDevice,
    IN  ULONG                nIterations,
    OUT PHIDTEST_STATUS      Status
)
{
    ULONG                   OperationCount;
    ULONG                   IterationCount;
    ULONG                   FailedCount;
    BOOL                    CallStatus;
    HANDLE                  HandleList[MAX_NUM_HANDLES];
    HANDLE                  CurrDeviceHandle;
    BOOL                    IsLegalDeviceHandle;

    FailedCount    = 0;
    OperationCount = 0;

    START_TEST("HIDTest_VerifyAttributes");

    /*
    // Setup our device handle list but only if our initial device
    //    handle is legitimate and we have HidDeviceAttributes.  This should
    //    weed out those danged logical devices that I'm currently hallucinating
    //    we'll be implemented.
    */

    if ((IS_VALID_DEVICE_HANDLE(HidDevice -> HidDeviceHandle)) && 
        (NULL != HidDevice -> HidDeviceAttributes)) {
 
        HandleList[0] = HidDevice -> HidDeviceHandle;

        ASSERT (NULL != HidDevice -> HidDeviceString);

        HIDTest_InitDeviceHandles(HidDevice -> HidDeviceString,
                                  2,
                                  1,
                                  HandleList
                                 );

    }
    else {

        LOG_TEST_ERROR("HidDevice Handle is invalid -- cannot perform test");
        goto VERIFY_ATTRIB_END;

    }

    /*
    // This test involves a variation for each of the different device handles
    //   that is generated by our device handle generator.  We will not test
    //    with a NULL pointer to the attributes structure since the expected
    //    behavior with such a pointer is to terminate the app.
    */
   
    for (IterationCount = 1; IterationCount <= nIterations; IterationCount++) {

        START_TEST_ITERATION( IterationCount );

        HIDTest_ResetDeviceHandles();

        while ( HIDTest_GetDeviceHandle( &CurrDeviceHandle, &IsLegalDeviceHandle )) {

            START_VARIATION_ON_DEVICE_HANDLE( CurrDeviceHandle,
                                              IsLegalDeviceHandle
                                            );
      
            CallStatus = HIDTest_ValidateAttributes( CurrDeviceHandle,
                                                     HidDevice -> HidDeviceAttributes
                                                   );
    
            if (CallStatus != IsLegalDeviceHandle) {
    
                LOG_VARIATION_FAIL();
                FailedCount++;
    
            }
            else {
    
                LOG_VARIATION_PASS();
    
            }
            OperationCount++;
            
            END_VARIATION();

        }

        END_TEST_ITERATION();

    }

    HIDTest_CloseDeviceHandles();

VERIFY_ATTRIB_END:

    END_TEST();

    Status -> nOperationsPerformed = OperationCount;
    Status -> nOperationsPassed    = OperationCount - FailedCount;
    Status -> nOperationsFailed    = FailedCount;
   
    return;
}

VOID 
HIDTest_VerifyCapabilitiesA(
    IN  PHIDTEST_DEVICEINFO  HidDevice,
    IN  ULONG                nIterations,
    OUT PHIDTEST_STATUS      Status
)
{
    HIDP_CAPS   HidCaps;
    NTSTATUS    CapsStatus;
    ULONG       IterationCount;
    ULONG       OperationCount;
    ULONG       FailedCount;
    BOOL        CallStatus;
    ULONG       BadPpd[16];


    /*
    // This is a more straight forward piece of code.  We're not going to 
    //    build a device list because we're not going to use the device handles.  
    //    In fact, we're just going to use the Ppd data structure to verify
    //    everything.  However, we will pass at least one bad Ppd structure
    //    to verify that the signature checking works.
    */

    /*
    // What we need to do is call the verify routine with the preparsed data
    //    for nIterations to verify that this stuff works all the time.  Therefore
    //    there exist only two varitions for this test.  One with good preparsed 
    //    data on nIterations and another with bogus Ppd for nIterations
    */

    START_TEST("HIDTest_VerifyCapabilities");

    OperationCount = 0;
    FailedCount = 0;
    
    for (IterationCount = 0; IterationCount < nIterations; IterationCount++) {

        START_TEST_ITERATION(IterationCount);

        START_VARIATION("Validating Capabilities -- Good Ppd");

        CallStatus = HIDTest_ValidateCaps(HidDevice -> HidDevicePpd,
                                          HidDevice -> HidDeviceCaps
                                         );
        if (!CallStatus) {
            LOG_VARIATION_FAIL();
            FailedCount++;
        }
        else {
            LOG_VARIATION_PASS();
        }
        OperationCount++;

        END_VARIATION();


        /*
        // Let's do the same thing, only this time with bogus Ppd.  To insure
        //      that the correct error code is returned, we won't call
        //      ValidateCaps but instead just call Hidp_GetCaps from here
        //      to insure INVALID_PREPARSED_DATA is returned.
        */

        START_VARIATION("Validating Capabilities -- Bad Ppd");
   
        CapsStatus = HidP_GetCaps((PHIDP_PREPARSED_DATA) &BadPpd[0],
                                  &HidCaps
                                 );

        if (HIDP_STATUS_INVALID_PREPARSED_DATA != CapsStatus) {
            
            LOG_INTERMEDIATE_VARIATION_RESULT("Unexpected error code returned");
            LOG_VARIATION_FAIL();
            FailedCount++;

        }
        else {
            LOG_VARIATION_PASS();
        }
        OperationCount++;


        END_VARIATION();

        END_TEST_ITERATION();

    }

    END_TEST();

    Status -> nOperationsPerformed = OperationCount;
    Status -> nOperationsPassed    = OperationCount - FailedCount;
    Status -> nOperationsFailed    = FailedCount;
   
    return;
}

VOID
HIDTest_VerifyStringsA(
    IN  PHIDTEST_DEVICEINFO  HidDevice,
    IN  ULONG                nIterations,
    OUT PHIDTEST_STATUS      Status
)
{
    ULONG       IterationCount;
    ULONG       OperationCount;
    ULONG       FailedCount;
    HANDLE      HandleList[MAX_NUM_HANDLES];
    HANDLE      CurrDeviceHandle;
    BOOL        IsLegalDeviceHandle;
    BOOL        CallStatus;


    START_TEST("HIDTest_VerifyStrings");

    OperationCount = 0;
    FailedCount = 0;

    /*
    // Attempt to setup the device handle list,  if the current 
    //    HidDeviceHandle is not valid than we cannot proceed any farther
    */

    if (IS_VALID_DEVICE_HANDLE(HidDevice -> HidDeviceHandle)) {
        HandleList[0] = HidDevice -> HidDeviceHandle;

        ASSERT (NULL != HidDevice -> HidDeviceString);

        HIDTest_InitDeviceHandles(HidDevice -> HidDeviceString,
                                  2,
                                  1,
                                  HandleList
                                 );

    }
    else {

        LOG_TEST_ERROR("HidDevice Handle is invalid -- cannot perform test");
        goto VERIFY_STRINGS_END;

    }

    /*
    // Start the iterations of the string test
    */

    for (IterationCount = 1; IterationCount <= nIterations; IterationCount++) {

        START_TEST_ITERATION(IterationCount);

        HIDTest_ResetDeviceHandles();

        while ( HIDTest_GetDeviceHandle( &CurrDeviceHandle, &IsLegalDeviceHandle )) {

            START_VARIATION_ON_DEVICE_HANDLE( CurrDeviceHandle,
                                              IsLegalDeviceHandle
                                            );

            CallStatus = HIDTest_ValidateStrings( CurrDeviceHandle,
                                                  &HidDevice -> StringList,
                                                  HidDevice -> ManufacturerStringIndex,
                                                  HidDevice -> ProductStringIndex,
                                                  HidDevice -> SerialNumberStringIndex
                                                );

            if (CallStatus != IsLegalDeviceHandle) {

                LOG_VARIATION_FAIL();
                FailedCount++;
            }
            else {

                LOG_VARIATION_PASS();

            }
            OperationCount++;

            END_VARIATION();
        }

        START_VARIATION("Testing the HidD_ string parameter validation");

        CallStatus = HIDTest_ValidateStringParams( HidDevice -> HidDeviceHandle,
                                                  &HidDevice -> StringList,
                                                  HidDevice -> ManufacturerStringIndex,
                                                  HidDevice -> ProductStringIndex,
                                                  HidDevice -> SerialNumberStringIndex
                                                 );
   
        if (!CallStatus) {

            LOG_VARIATION_FAIL();
            FailedCount++;

        }
        else {

            LOG_VARIATION_PASS();

        }
        OperationCount++;
        
        END_TEST_ITERATION();
    }

    HIDTest_CloseDeviceHandles();

VERIFY_STRINGS_END:    
 
    END_TEST();

    Status -> nOperationsPerformed = OperationCount;
    Status -> nOperationsPassed    = OperationCount - FailedCount;
    Status -> nOperationsFailed    = FailedCount;
   
    return;
    
}


VOID
HIDTest_VerifyNumBuffersA(
    IN  PHIDTEST_DEVICEINFO  HidDevice,
    IN  ULONG                nIterations,
    OUT PHIDTEST_STATUS      Status
)
{
    ULONG       iterationCount;
    ULONG       operationCount;
    ULONG       failedCount;
    PULONG      bufCount;
    HANDLE      secondHandle;
    HANDLE      handleList[MAX_NUM_HANDLES];
    HANDLE      currDeviceHandle;
    BOOL        isLegalDeviceHandle;
    BOOL        callStatus;
    
    START_TEST("HIDTest_VerifyNumInputBuffers");

    operationCount = 0;
    failedCount = 0;
    bufCount = NULL;
    
    secondHandle = CreateFile(  HidDevice -> HidDeviceString,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL, 
                                OPEN_EXISTING, 
                                0,
                                NULL
                             );

    if (INVALID_HANDLE_VALUE == secondHandle) {

        LOG_TEST_ERROR("Couldn't open second handle to HID device");
        goto VERIFY_NUMBUFFERS_END;
        
    }

    bufCount = (PULONG) AllocateTestBuffer(sizeof(ULONG));
    
    if (NULL == bufCount) {

        LOG_TEST_ERROR( "Couldn't allocate memory" );
        goto VERIFY_NUMBUFFERS_END;

    }

    /*
    // Attempt to setup the device handle list,  if the current 
    //    HidDeviceHandle is not valid than we cannot proceed any farther
    */

    if (IS_VALID_DEVICE_HANDLE(HidDevice -> HidDeviceHandle)) {
        handleList[0] = HidDevice -> HidDeviceHandle;

        ASSERT (NULL != HidDevice -> HidDeviceString);

        HIDTest_InitDeviceHandles(HidDevice -> HidDeviceString,
                                  2,
                                  1,
                                  handleList
                                 );

    }
    else {

        LOG_TEST_ERROR("HidDevice Handle is invalid -- cannot perform test");
        goto VERIFY_NUMBUFFERS_END;

    }
    
    for (iterationCount = 1; iterationCount <= nIterations; iterationCount++) {

        START_TEST_ITERATION(iterationCount);

        HIDTest_ResetDeviceHandles();

        while ( HIDTest_GetDeviceHandle( &currDeviceHandle, &isLegalDeviceHandle )) {

            START_VARIATION_ON_DEVICE_HANDLE( currDeviceHandle,
                                              isLegalDeviceHandle
                                            );

            callStatus = HIDTest_ValidateNumInputBuffers( currDeviceHandle,
                                                          secondHandle,
                                                          isLegalDeviceHandle,
                                                          bufCount
                                                        );

            if (!callStatus) {

                LOG_VARIATION_FAIL();
                failedCount++;
            }
            else {

                LOG_VARIATION_PASS();

            }
            operationCount++;

            END_VARIATION();
        }
    }

VERIFY_NUMBUFFERS_END:    

    END_TEST();

    if (NULL != bufCount) {
        FreeTestBuffer(bufCount);
    }

    if (INVALID_HANDLE_VALUE != secondHandle) {
        CloseHandle(secondHandle);
    }
        
    Status -> nOperationsPerformed = operationCount;
    Status -> nOperationsPassed    = operationCount - failedCount;
    Status -> nOperationsFailed    = failedCount;
   
    return;
}

VOID
HIDTest_VerifyGetFeatureA(
    IN  PHIDTEST_DEVICEINFO  HidDevice,
    IN  ULONG                nIterations,
    OUT PHIDTEST_STATUS      Status
)
{
    ULONG       iterationCount;
    ULONG       operationCount;
    ULONG       failedCount;
    PCHAR       featureBuffer;
    ULONG       featureBufferLength;
    HANDLE      handleList[MAX_NUM_HANDLES];
    HANDLE      currDeviceHandle;
    BOOL        isLegalDeviceHandle;
    BOOL        returnStatus;
    BOOL        bufferStatus;
    ULONG       errorCode;
    PUCHAR      reportIDList;
    ULONG       reportIDListCount;
    ULONG       idIndex;
    UCHAR       reportID;
    BOOL        variationStatus;
    ULONG       reportBufferSize;
    static CHAR varString[128];
    
    START_TEST("HIDTest_VerifyGetFeature");

    operationCount = 0;
    failedCount = 0;
    
    /*
    // If we have no features on the device, we still want to allocate
    //    a buffer of two bytes just to verify that FALSE and the correct
    //    error code is returned when we call HidD_GetFeature;
    */
    
    if (0 == HidDevice -> HidDeviceCaps -> FeatureReportByteLength) {
         featureBufferLength = 2;
    }
    else {
        featureBufferLength = HidDevice -> HidDeviceCaps -> FeatureReportByteLength;
    }

    featureBuffer = (PCHAR) AllocateTestBuffer(featureBufferLength);

    if (NULL == featureBuffer) {

        LOG_TEST_ERROR( "Couldn't allocate memory" );
        goto VERIFY_GETFEATURE_END;

    }

    /*
    // Build the list or reportIDs that are supported
    */

    returnStatus = HIDTest_BuildReportIDList( HidDevice -> HidFeatureValueCaps,
                                              HidDevice -> HidDeviceCaps -> NumberFeatureValueCaps,
                                              HidDevice -> HidFeatureButtonCaps,
                                              HidDevice -> HidDeviceCaps -> NumberFeatureButtonCaps,
                                              &reportIDList,
                                              &reportIDListCount
                                            );
    
    if (!returnStatus) {
        LOG_TEST_ERROR("Error building report ID list");
        goto VERIFY_GETFEATURE_END;
    }
    
    /*
    // Attempt to setup the device handle list,  if the current 
    //    HidDeviceHandle is not valid than we cannot proceed any farther
    */

    if (IS_VALID_DEVICE_HANDLE(HidDevice -> HidDeviceHandle)) {
        handleList[0] = HidDevice -> HidDeviceHandle;

        ASSERT (NULL != HidDevice -> HidDeviceString);

        HIDTest_InitDeviceHandles(HidDevice -> HidDeviceString,
                                  2,
                                  1,
                                  handleList
                                 );

    }
    else {

        LOG_TEST_ERROR("HidDevice Handle is invalid -- cannot perform test");
        goto VERIFY_GETFEATURE_END;

    }
    
    for (iterationCount = 1; iterationCount <= nIterations; iterationCount++) {

        START_TEST_ITERATION(iterationCount);

        HIDTest_ResetDeviceHandles();

        while ( HIDTest_GetDeviceHandle( &currDeviceHandle, &isLegalDeviceHandle )) {


            
            /*
            // Begin by testing that we can retrieve feature reports for
            //  all the IDs supported on the device. For this part to 
            //  pass:
            //  
            //  1) returnStatus should be TRUE
            //  2) errorCode should be ERROR_SUCCESS
            //  3) bufferStatus should be TRUE (ie. no buffer overrun problems
            //
            //
            //  Of course, that would only happen if currDeviceHandle were
            //    actually a legal handle...If current device handle is not
            //    a legal handle, we would need to look for the following:
            //  
            //  1) returnStatus = FALSE
            //  2) errorCode = ERROR_INVALID_HANDLE (?)
            //  3) bufferStatus = TRUE
            */
            
            START_VARIATION_WITH_DEVICE_HANDLE( currDeviceHandle,
                                                isLegalDeviceHandle,
                                                "Getting all feature reports"
                                              );

            variationStatus = TRUE;
            
            for (idIndex = 0; idIndex < reportIDListCount; idIndex++) {

                                                  
                HIDTest_CallGetFeature( currDeviceHandle,
                                        *(reportIDList + idIndex),
                                        featureBuffer,
                                        featureBufferLength,
                                        &returnStatus,
                                        &errorCode,
                                        &bufferStatus
                                      );

                if (!bufferStatus) {
                    LOG_BUFFER_VALIDATION_FAIL();
                    variationStatus = FALSE;
                }
                else if (isLegalDeviceHandle) {
    
                    if (!returnStatus) {
                        LOG_INVALID_RETURN_STATUS();
                        variationStatus = FALSE;                       
                    }
                    else {
                        if (ERROR_SUCCESS != errorCode) {
                            LOG_INVALID_ERROR_CODE();
                            variationStatus = FALSE;
                        }
                    }
                }
                else {
                    if (returnStatus) {
                        LOG_INVALID_RETURN_STATUS();
                        variationStatus = FALSE;
                    }
                    else {
                        if (ERROR_INVALID_HANDLE != errorCode) {
                            LOG_INVALID_ERROR_CODE();
                            variationStatus = FALSE;
                        }
                    }
                }
            }    
            
            if (variationStatus) {
                LOG_VARIATION_PASS();
            }
            else {
                LOG_VARIATION_FAIL();
                failedCount++;
            }
            operationCount++;

            END_VARIATION();
            
            /*
            // Now let's choose some report IDs that aren't in the list
            //  and make sure the appropriate results come back to us from
            //  ValidateGetFeature.  Appropriate results are:
            //
            //  if IsLegalDeviceHandle
            //      1) returnStatus = FALSE
            //      2) errorCode = ERROR_CRC
            //      3) bufferStatus = TRUE;
            //
            //  otherwise,
            //      1) returnStatus = FALSE
            //      2) errorCode = ERROR_INVALID_HANDLE
            //      3) bufferStatus = TRUE;
            //
            // We will use the following report IDs as possible ReportID values
            //  to try.  If any one of these report IDs is already in the list
            //  we'll skip it and move on to the next one.
            //
            //     0, 1, 2, 127, 128, 129, 254, 255
            //
            */
            
            #define BAD_REPORT_ID_LIST_COUNT    8
            
            START_VARIATION_WITH_DEVICE_HANDLE( currDeviceHandle,
                                                isLegalDeviceHandle,
                                                "Attempting to retrieve non-existent report"
                                              );
        
            variationStatus = TRUE;
            
            for (idIndex = 0; idIndex < BAD_REPORT_ID_LIST_COUNT; idIndex++) {

                UCHAR BadReportIDList[BAD_REPORT_ID_LIST_COUNT] = { 0, 1, 127, 128, 129, 254, 255 };
                                                                    
                if (!HIDTest_IsIDInList(BadReportIDList[idIndex],
                                        reportIDList,
                                        reportIDListCount
                                       )) {

                                             
                    HIDTest_CallGetFeature( currDeviceHandle,
                                            BadReportIDList[idIndex],
                                            featureBuffer,
                                            featureBufferLength,
                                            &returnStatus,
                                            &errorCode,
                                            &bufferStatus
                                          );

                    if (!bufferStatus) {
                        LOG_BUFFER_VALIDATION_FAIL();
                        variationStatus = FALSE;
                    }
                    else if (isLegalDeviceHandle) {

                        if (returnStatus) {
                            LOG_INVALID_RETURN_STATUS();
                            variationStatus = FALSE;
                        }
                        else {
                            if (ERROR_CRC != errorCode && 
								ERROR_INVALID_FUNCTION != errorCode) {
                                LOG_INVALID_ERROR_CODE();
                                variationStatus = FALSE;
                            }
                        }
                    }
                    else {
                        if (returnStatus) {
                            LOG_INVALID_RETURN_STATUS();
                            variationStatus = FALSE;
                        }
                        else {
                            if (ERROR_INVALID_HANDLE != errorCode) {
                                LOG_INVALID_ERROR_CODE();
                                variationStatus = FALSE;
                            }
                        }
                    }
                }
            }

            if (variationStatus) {
                LOG_VARIATION_PASS();
            }
            else {
                LOG_VARIATION_FAIL();
                failedCount++;
            }
            operationCount++;

            END_VARIATION();
            
            /*
            // The next step in the validation process is to pass in buffers
            //  that are too small to hold an entire feature report.  The same
            //  feature buffer will be used but we'll pass in a different size
            //  to the ValidateFeature routine.  The appropriate response to
            //  this call should be:
            //
            //  1) returnStatus = FALSE;
            //  2) errorCode = ERROR_INVALID_PARAMETER (?)
            //  3) bufferStatus = TRUE
            //
            // As above, we'll do this with two different report IDs, one
            //  valid one and one invalid one (if the invalid one exists) to
            //  make sure we hit as many possible code paths.
            // Also three different lengths of buffers will be used, 1, 2, 
            //  and featurelength-1
            */

            START_VARIATION("Passing in buffers that are too small");
            variationStatus = TRUE;    
        
            reportID = 0;
            do {

                if (!HIDTest_IsIDInList(reportID,
                                        reportIDList,
                                        reportIDListCount
                                       )) {

                    /*
                    // Perform the validation steps here for each of the report
                    //  buffer sizes
                    */
                    
                    reportBufferSize = 1;

                    while (1) {
                    
                        wsprintf(varString, "ReportBufferSize = %d", reportBufferSize);
                        LOG_INTERMEDIATE_VARIATION_RESULT(varString);

                        HIDTest_CallGetFeature( currDeviceHandle,
                                                reportID,
                                                featureBuffer,
                                                reportBufferSize,
                                                &returnStatus,
                                                &errorCode,
                                                &bufferStatus
                                               );

                        if (!bufferStatus) {
                            LOG_BUFFER_VALIDATION_FAIL();
                            variationStatus = FALSE;
                        }
                        else if (returnStatus) {
                            LOG_INVALID_RETURN_STATUS();
                            variationStatus = FALSE;
                        }
                        else if (isLegalDeviceHandle) {
                            if (ERROR_CRC != errorCode && ERROR_INVALID_FUNCTION != errorCode) {
                                LOG_INVALID_ERROR_CODE();
                                variationStatus = FALSE;
                            }
                        }
                        else if (ERROR_INVALID_HANDLE != errorCode) {
                                LOG_INVALID_ERROR_CODE();
                                variationStatus = FALSE;                                                            
                        }

                        /*
                        // Determine the next buffer length...The buffer lengths
                        //  that are to be used are 1,2, and featureBufferLength-1
                        //  unless some of those happen to be the same size
                        */

                        reportBufferSize++;
                        if (reportBufferSize == featureBufferLength) {
                            break;
                        }
                        else if (reportBufferSize > 2) {
                            reportBufferSize = featureBufferLength-1;
                        }
                    }                    
                                            
                    if (0 != reportID) {
                        break;
                    }    
                }
            } while (reportID++ != 255);
        }            

        if (variationStatus) {
            LOG_VARIATION_PASS();
        }
        else {
            LOG_VARIATION_FAIL();
            failedCount++;
        }
        operationCount++;
            
        END_VARIATION();
    }

    /*
    // Do parameter validation now...Pass in the following three cases and
    //  verify correct operation
    //
    //  1) NULL buffer -- Length of 0,
    //  2) NULL buffer -- Length != 0
    //  3) non-NULL buffer -- length of 0
    //
    // Since we're verifying parameters, the actual reportID we use shouldn't
    //  matter, so we'll just use 1.  Since we're not actually using test buffers
    //  we may not do any checking there either.
    */

    START_VARIATION("Parameter validation of GetFeature");
    variationStatus = TRUE;

    LOG_INTERMEDIATE_VARIATION_RESULT("Using NULL buffer with 0 length");
    
    HIDTest_CallGetFeature( HidDevice -> HidDeviceHandle,
                            1,
                            NULL,
                            0,
                            &returnStatus,
                            &errorCode,
                            NULL
                          );

    if (returnStatus) {
        LOG_INVALID_RETURN_STATUS();
        variationStatus = FALSE;
        failedCount++;
    }
    else if (ERROR_INVALID_USER_BUFFER != errorCode && ERROR_INVALID_FUNCTION != errorCode) {
        LOG_INVALID_ERROR_CODE();
        variationStatus = FALSE;        
    }
    
    LOG_INTERMEDIATE_VARIATION_RESULT("Using NULL buffer with non-zero length");
    HIDTest_CallGetFeature (HidDevice -> HidDeviceHandle,
                            1, 
                            NULL,
                            3,
                            &returnStatus,
                            &errorCode,
                            NULL
                           );

    if (returnStatus) {
        LOG_INVALID_RETURN_STATUS();
        variationStatus = FALSE;
    }
    else if (ERROR_NOACCESS != errorCode) {
        LOG_INVALID_RETURN_STATUS();
        variationStatus = FALSE;
    }
    
    LOG_INTERMEDIATE_VARIATION_RESULT("Using non-NULL buffer with zero length");
    HIDTest_CallGetFeature (HidDevice -> HidDeviceHandle,
                            1, 
                            featureBuffer,
                            0,
                            &returnStatus,
                            &errorCode,
                            &bufferStatus
                           );

    if (!bufferStatus) {
        LOG_BUFFER_VALIDATION_FAIL();
        variationStatus = FALSE;
    }
    else if (returnStatus) {
        LOG_INVALID_RETURN_STATUS();
        variationStatus = FALSE;

    }
    else if (ERROR_INVALID_USER_BUFFER != errorCode && ERROR_INVALID_FUNCTION != errorCode) {
        LOG_INVALID_ERROR_CODE();
        variationStatus = FALSE;
    }

    if (variationStatus) {
        LOG_VARIATION_PASS();
    }
    else {
        LOG_VARIATION_FAIL();
        failedCount++;
    }
    operationCount++;
    
    END_VARIATION();
    
VERIFY_GETFEATURE_END:    

    END_TEST();

    if (NULL != featureBuffer) {
        FreeTestBuffer(featureBuffer);
    }
        
    Status -> nOperationsPerformed = operationCount;
    Status -> nOperationsPassed    = operationCount - failedCount;
    Status -> nOperationsFailed    = failedCount;
   
    return;
}



VOID
HIDTest_CallGetFeature(
    IN  HANDLE  DeviceHandle,
    IN  UCHAR   ReportID,
    IN  PUCHAR  ReportBuffer,
    IN  ULONG   ReportBufferLength,
    OUT PBOOL   ReturnStatus,
    OUT PULONG  ErrorCode,
    OUT PBOOL   BufferStatus
)
{
    /*
    // If we have a non-null buffer of > 0 length, then allocate the
    //      zero the memory and add the reportID as the first byte.
    */
    
    if (NULL != ReportBuffer && ReportBufferLength > 0) {
        ZeroMemory (ReportBuffer, ReportBufferLength);
        *ReportBuffer = ReportID;
    }
    
    /*
    // Call GetFeature
    */

    *ReturnStatus = HidD_GetFeature(DeviceHandle,
                                    ReportBuffer,
                                    ReportBufferLength
                                   );

    /*
    // Get the error code returned 
    */

    *ErrorCode = GetLastError();

    /*
    // Do a buffer validation check
    */

    if (NULL != BufferStatus) {
        *BufferStatus = ValidateTestBuffer(ReportBuffer);
    }
    
    return;
}
    

VOID
HIDTest_VerifySetFeatureA(
    IN  PHIDTEST_DEVICEINFO  HidDevice,
    IN  ULONG                nIterations,
    OUT PHIDTEST_STATUS      Status
)
{
    ULONG       iterationCount;
    ULONG       operationCount;
    ULONG       failedCount;
    PCHAR       featureBuffer;
    ULONG       featureBufferLength;
    HANDLE      handleList[MAX_NUM_HANDLES];
    HANDLE      currDeviceHandle;
    BOOL        isLegalDeviceHandle;
    BOOL        returnStatus;
    BOOL        bufferStatus;
    ULONG       errorCode;
    PUCHAR      reportIDList;
    ULONG       reportIDListCount;
    ULONG       idIndex;
    UCHAR       reportID;
    BOOL        variationStatus;
    ULONG       reportBufferSize;
    static CHAR varString[128];
    
    START_TEST("HIDTest_VerifySetFeature");

    operationCount = 0;
    failedCount = 0;
    
    /*
    // If we have no features on the device, we still want to allocate
    //    a buffer of two bytes just to verify that FALSE and the correct
    //    error code is returned when we call HidD_GetFeature;
    */
    
    if (0 == HidDevice -> HidDeviceCaps -> FeatureReportByteLength) {
         featureBufferLength = 2;
    }
    else {
        featureBufferLength = HidDevice -> HidDeviceCaps -> FeatureReportByteLength;
    }

    featureBuffer = (PCHAR) AllocateTestBuffer(featureBufferLength);

    if (NULL == featureBuffer) {

        LOG_TEST_ERROR( "Couldn't allocate memory" );
        goto VERIFY_SETFEATURE_END;

    }

    /*
    // Build the list or reportIDs that are supported
    */

    returnStatus = HIDTest_BuildReportIDList( HidDevice -> HidFeatureValueCaps,
                                              HidDevice -> HidDeviceCaps -> NumberFeatureValueCaps,
                                              HidDevice -> HidFeatureButtonCaps,
                                              HidDevice -> HidDeviceCaps -> NumberFeatureButtonCaps,
                                              &reportIDList,
                                              &reportIDListCount
                                            );
    
    if (!returnStatus) {
        LOG_TEST_ERROR("Error building report ID list");
        goto VERIFY_SETFEATURE_END;
    }
    
    /*
    // Attempt to setup the device handle list,  if the current 
    //    HidDeviceHandle is not valid than we cannot proceed any farther
    */

    if (IS_VALID_DEVICE_HANDLE(HidDevice -> HidDeviceHandle)) {
        handleList[0] = HidDevice -> HidDeviceHandle;

        ASSERT (NULL != HidDevice -> HidDeviceString);

        HIDTest_InitDeviceHandles(HidDevice -> HidDeviceString,
                                  2,
                                  1,
                                  handleList
                                 );

    }
    else {

        LOG_TEST_ERROR("HidDevice Handle is invalid -- cannot perform test");
        goto VERIFY_SETFEATURE_END;

    }
    
    for (iterationCount = 1; iterationCount <= nIterations; iterationCount++) {

        START_TEST_ITERATION(iterationCount);

        HIDTest_ResetDeviceHandles();

        while ( HIDTest_GetDeviceHandle( &currDeviceHandle, &isLegalDeviceHandle )) {


            
            /*
            // Begin by testing that we can set feature reports for
            //  all the IDs supported on the device. For this part to 
            //  pass:
            //  
            //  1) returnStatus should be TRUE
            //  2) errorCode should be ERROR_SUCCESS
            //  3) bufferStatus should be TRUE (ie. no buffer overrun problems
            //
            //
            //  Of course, that would only happen if currDeviceHandle were
            //    actually a legal handle...If current device handle is not
            //    a legal handle, we would need to look for the following:
            //  
            //  1) returnStatus = FALSE
            //  2) errorCode = ERROR_INVALID_HANDLE (?)
            //  3) bufferStatus = TRUE
            */
            
            START_VARIATION_WITH_DEVICE_HANDLE( currDeviceHandle,
                                                isLegalDeviceHandle,
                                                "Setting all feature reports"
                                              );

            variationStatus = TRUE;
            
            for (idIndex = 0; idIndex < reportIDListCount; idIndex++) {

                                                  
                HIDTest_CallSetFeature( currDeviceHandle,
                                        *(reportIDList + idIndex),
                                        featureBuffer,
                                        featureBufferLength,
                                        &returnStatus,
                                        &errorCode,
                                        &bufferStatus
                                      );

                if (!bufferStatus) {
                    LOG_BUFFER_VALIDATION_FAIL();
                    variationStatus = FALSE;
                }
                else if (isLegalDeviceHandle) {
    
                    if (!returnStatus) {
                        LOG_INVALID_RETURN_STATUS();
                        variationStatus = FALSE;                       
                    }
                    else {
                        if (ERROR_SUCCESS != errorCode) {
                            LOG_INVALID_ERROR_CODE();
                            variationStatus = FALSE;
                        }
                    }
                }
                else {
                    if (returnStatus) {
                        LOG_INVALID_RETURN_STATUS();
                        variationStatus = FALSE;
                    }
                    else {
                        if (ERROR_INVALID_HANDLE != errorCode) {
                            LOG_INVALID_ERROR_CODE();
                            variationStatus = FALSE;
                        }
                    }
                }
            }    
            
            if (variationStatus) {
                LOG_VARIATION_PASS();
            }
            else {
                LOG_VARIATION_FAIL();
                failedCount++;
            }
            operationCount++;

            END_VARIATION();
            
            /*
            // Now let's choose some report IDs that aren't in the list
            //  and make sure the appropriate results come back to us from
            //  CallSetFeature.  Appropriate results are:
            //
            //  if IsLegalDeviceHandle
            //      1) returnStatus = FALSE
            //      2) errorCode = ERROR_CRC
            //      3) bufferStatus = TRUE;
            //
            //  otherwise,
            //      1) returnStatus = FALSE
            //      2) errorCode = ERROR_INVALID_HANDLE
            //      3) bufferStatus = TRUE;
            //
            // We will use the following report IDs as possible ReportID values
            //  to try.  If any one of these report IDs is already in the list
            //  we'll skip it and move on to the next one.
            //
            //     0, 1, 2, 127, 128, 129, 254, 255
            //
            */
            
            #define BAD_REPORT_ID_LIST_COUNT    8
            
            START_VARIATION_WITH_DEVICE_HANDLE( currDeviceHandle,
                                                isLegalDeviceHandle,
                                                "Attempting to set non-existent report"
                                              );
        
            variationStatus = TRUE;
            
            for (idIndex = 0; idIndex < BAD_REPORT_ID_LIST_COUNT; idIndex++) {

                UCHAR BadReportIDList[BAD_REPORT_ID_LIST_COUNT] = { 0, 1, 127, 128, 129, 254, 255 };
                                                                    
                if (!HIDTest_IsIDInList(BadReportIDList[idIndex],
                                        reportIDList,
                                        reportIDListCount
                                       )) {

                                             
                    HIDTest_CallSetFeature( currDeviceHandle,
                                            BadReportIDList[idIndex],
                                            featureBuffer,
                                            featureBufferLength,
                                            &returnStatus,
                                            &errorCode,
                                            &bufferStatus
                                          );

                    if (!bufferStatus) {
                        LOG_BUFFER_VALIDATION_FAIL();
                        variationStatus = FALSE;
                    }
                    else if (isLegalDeviceHandle) {

                        if (returnStatus) {
                            LOG_INVALID_RETURN_STATUS();
                            variationStatus = FALSE;
                        }
                        else {
                            if (ERROR_CRC != errorCode && ERROR_INVALID_FUNCTION != errorCode) {
                                LOG_INVALID_ERROR_CODE();
                                variationStatus = FALSE;
                            }
                        }
                    }
                    else {
                        if (returnStatus) {
                            LOG_INVALID_RETURN_STATUS();
                            variationStatus = FALSE;
                        }
                        else {
                            if (ERROR_INVALID_HANDLE != errorCode) {
                                LOG_INVALID_ERROR_CODE();
                                variationStatus = FALSE;
                            }
                        }
                    }
                }
            }

            if (variationStatus) {
                LOG_VARIATION_PASS();
            }
            else {
                LOG_VARIATION_FAIL();
                failedCount++;
            }
            operationCount++;

            END_VARIATION();
            
            /*
            // The next step in the validation process is to pass in buffers
            //  that are too small to hold an entire feature report.  The same
            //  feature buffer will be used but we'll pass in a different size
            //  to the CallSetFeature routine.  The appropriate response to
            //  this call should be:
            //
            //  1) returnStatus = FALSE;
            //  2) errorCode = ERROR_CRC
            //  3) bufferStatus = TRUE
            //
            // As above, we'll do this with two different report IDs, one
            //  valid one and one invalid one (if the invalid one exists) to
            //  make sure we hit as many possible code paths.
            // Also three different lengths of buffers will be used, 1, 2, 
            //  and featurelength-1
            */

            START_VARIATION("Passing in buffers that are too small");
            variationStatus = TRUE;    
        
            reportID = 0;
            do {

                if (!HIDTest_IsIDInList(reportID,
                                        reportIDList,
                                        reportIDListCount
                                       )) {

                    /*
                    // Perform the validation steps here for each of the report
                    //  buffer sizes
                    */
                    
                    reportBufferSize = 1;

                    while (1) {
                    
                        wsprintf(varString, "ReportBufferSize = %d", reportBufferSize);
                        LOG_INTERMEDIATE_VARIATION_RESULT(varString);

                        HIDTest_CallSetFeature( currDeviceHandle,
                                                reportID,
                                                featureBuffer,
                                                reportBufferSize,
                                                &returnStatus,
                                                &errorCode,
                                                &bufferStatus
                                               );

                        if (!bufferStatus) {
                            LOG_BUFFER_VALIDATION_FAIL();
                            variationStatus = FALSE;
                        }
                        else if (returnStatus) {
                            LOG_INVALID_RETURN_STATUS();
                            variationStatus = FALSE;
                        }
                        else if (isLegalDeviceHandle) {
                            if (ERROR_CRC != errorCode) {
                                LOG_INVALID_ERROR_CODE();
                                variationStatus = FALSE;
                            }
                        }
                        else if (ERROR_INVALID_HANDLE != errorCode) {
                                LOG_INVALID_ERROR_CODE();
                                variationStatus = FALSE;                                                            
                        }
                        
                        /*
                        // Determine the next buffer length...The buffer lengths
                        //  that are to be used are 1,2, and featureBufferLength-1
                        //  unless some of those happen to be the same size
                        */

                        reportBufferSize++;
                        if (reportBufferSize == featureBufferLength) {
                            break;
                        }
                        else if (reportBufferSize > 2) {
                            reportBufferSize = featureBufferLength-1;
                        }
                    }                    
                                            
                    if (0 != reportID) {
                        break;
                    }    
                }
            } while (reportID++ != 255);
        }            

        if (variationStatus) {
            LOG_VARIATION_PASS();
        }
        else {
            LOG_VARIATION_FAIL();
            failedCount++;
        }
        operationCount++;
            
        END_VARIATION();
    }

    /*
    // Do parameter validation now...Pass in the following three cases and
    //  verify correct operation
    //
    //  1) NULL buffer -- Length of 0,
    //  2) NULL buffer -- Length != 0
    //  3) non-NULL buffer -- length of 0
    //
    // Since we're verifying parameters, the actual reportID we use shouldn't
    //  matter, so we'll just use 1.  Since we're not actually using test buffers
    //  we may not do any checking there either.
    */

    START_VARIATION("Parameter validation of SetFeature");
    variationStatus = TRUE;

    LOG_INTERMEDIATE_VARIATION_RESULT("Using NULL buffer with 0 length");
    
    HIDTest_CallSetFeature( HidDevice -> HidDeviceHandle,
                            1,
                            NULL,
                            0,
                            &returnStatus,
                            &errorCode,
                            NULL
                          );

    if (returnStatus) {
        LOG_INVALID_RETURN_STATUS();
        variationStatus = FALSE;
        failedCount++;
    }
    else if (ERROR_INVALID_USER_BUFFER != errorCode && ERROR_INVALID_FUNCTION != errorCode) {
        LOG_INVALID_ERROR_CODE();
        variationStatus = FALSE;        
    }
    
    LOG_INTERMEDIATE_VARIATION_RESULT("Using NULL buffer with non-zero length");
    HIDTest_CallSetFeature (HidDevice -> HidDeviceHandle,
                            1, 
                            NULL,
                            3,
                            &returnStatus,
                            &errorCode,
                            NULL
                           );

    if (returnStatus) {
        LOG_INVALID_RETURN_STATUS();
        variationStatus = FALSE;
    }
    else if (ERROR_INVALID_USER_BUFFER != errorCode && ERROR_INVALID_FUNCTION != errorCode) {
        LOG_INVALID_RETURN_STATUS();
        variationStatus = FALSE;
    }
    
    LOG_INTERMEDIATE_VARIATION_RESULT("Using non-NULL buffer with zero length");
    HIDTest_CallSetFeature (HidDevice -> HidDeviceHandle,
                            1, 
                            featureBuffer,
                            0,
                            &returnStatus,
                            &errorCode,
                            &bufferStatus
                           );

    if (!bufferStatus) {
        LOG_BUFFER_VALIDATION_FAIL();
        variationStatus = FALSE;
    }
    else if (returnStatus) {
        LOG_INVALID_RETURN_STATUS();
        variationStatus = FALSE;

    }
    else if (ERROR_INVALID_USER_BUFFER != errorCode && ERROR_INVALID_FUNCTION != errorCode) {
        LOG_INVALID_ERROR_CODE();
        variationStatus = FALSE;
    }

    if (variationStatus) {
        LOG_VARIATION_PASS();
    }
    else {
        LOG_VARIATION_FAIL();
        failedCount++;
    }
    operationCount++;
    
    END_VARIATION();
    
VERIFY_SETFEATURE_END:    

    END_TEST();

    if (NULL != featureBuffer) {
        FreeTestBuffer(featureBuffer);
    }
        
    Status -> nOperationsPerformed = operationCount;
    Status -> nOperationsPassed    = operationCount - failedCount;
    Status -> nOperationsFailed    = failedCount;
   
    return;
}
    
VOID
HIDTest_CallSetFeature(
    IN  HANDLE  DeviceHandle,
    IN  UCHAR   ReportID,
    IN  PUCHAR  ReportBuffer,
    IN  ULONG   ReportBufferLength,
    OUT PBOOL   ReturnStatus,
    OUT PULONG  ErrorCode,
    OUT PBOOL   BufferStatus
)
{
    /*
    // If we have a non-null buffer of > 0 length, then allocate the
    //      zero the memory and add the reportID as the first byte.
    */
    
    if (NULL != ReportBuffer && ReportBufferLength > 0) {
        ZeroMemory (ReportBuffer, ReportBufferLength);
        *ReportBuffer = ReportID;
    }
    
    /*
    // Call SetFeature
    */

    *ReturnStatus = HidD_SetFeature(DeviceHandle,
                                    ReportBuffer,
                                    ReportBufferLength
                                   );

    /*
    // Get the error code returned 
    */

    *ErrorCode = GetLastError();

    /*
    // Do a buffer validation check
    */

    if (NULL != BufferStatus) {
        *BufferStatus = ValidateTestBuffer(ReportBuffer);
    }
    
    return;
}


BOOL
HIDTest_ValidateNumInputBuffers(    
    IN  HANDLE  HandleToTest,
    IN  HANDLE  SecondHandle,
    IN  BOOL    IsFirstHandleLegal,
    IN  PULONG  TestBuffer
)
{
    BOOL    testStatus;
    BOOL    callStatus;
    BOOL    prevStatus;
    BOOL    isLegalNewCount;
    BOOL    done;
    ULONG   firstHandleCount;
    ULONG   secondHandleCount;
    ULONG   newCount;
    
    /*
    // For each iteration of this test, we need to do the following steps
    //  1) Open a second handle to the hid device
    //  2) Call HidD_GetNumInputBuffers on both handles and verify > 0 if
    //     the first handle is legal
    //  3) Verify that the buffer is not overrun
    //  4) On first handle, call HidD_SetNumInputBuffers with 0, 1, 
    //      CURRENT_BUFFER_MIN-1, CURRENT_BUFFER_MIN and a random value
    //      - If return value is FALSE and legal handle, insure the 
    //          value was an expected illegal one...Verify that previous
    //          value hasn't changed
    //      - If return value is FALSE and illegal handle, good!
    //      - If return value is TRUE and illegal handle, bad news.
    //      - If return value is TRUE and a legal handle, make sure
    //          HidD_GetNumInputBuffers returns the value we just set
    //      - Verify that the second handle's original value has not changed
    //
    */
        
    LOG_INTERMEDIATE_VARIATION_RESULT("Retrieving current number of buffers");
        
    /*
    // Get the current number of buffers as reported for each device
    */
    
    callStatus = HIDTest_GetBufferCount(HandleToTest,
                                        TestBuffer
                                       );
                                       
    if (!callStatus && IsFirstHandleLegal) {

        LOG_INTERMEDIATE_VARIATION_RESULT("HidD_GetNumInputBuffers unexpectedly returned FALSE");
        return (FALSE);
    }

    if (callStatus && !IsFirstHandleLegal) {

        LOG_INTERMEDIATE_VARIATION_RESULT("HidD_GetNumInputBuffers unexpectedly returned TRUE");
        return (FALSE);
    }

    firstHandleCount = *TestBuffer;
    
    callStatus = HIDTest_GetBufferCount(SecondHandle,
                                        TestBuffer
                                       );

    if (!callStatus) {

        LOG_INTERMEDIATE_VARIATION_RESULT("HidD_GetNumInputBuffers unexpectedly returned FALSE on second handle");
        return (FALSE);
    }
    
    secondHandleCount = *TestBuffer;

    /*
    // Verify that each of the counts is greater than or equal to the minimum
    //   number of buffers
    */

    LOG_INTERMEDIATE_VARIATION_RESULT("Verifying the buffer count for both handles");

    if (firstHandleCount < CURRENT_BUFFER_MIN || secondHandleCount < CURRENT_BUFFER_MIN) {

        LOG_INTERMEDIATE_VARIATION_RESULT("One of the buffer counts is less than the supposed minimum");
        return (FALSE);

    }

    /*
    // Begin looping and setting the buffer values for the first handle and
    //  verifying proper functionality.  On each loop, also make sure that 
    //  the second handle's value doesn't change.
    */

    newCount = 0;
    testStatus = TRUE;
    done = FALSE;
    
    while (!done) {

        isLegalNewCount = (newCount >= CURRENT_BUFFER_MIN);
        
        callStatus = HidD_SetNumInputBuffers(HandleToTest, newCount);

        if (!callStatus) {

            if (IsFirstHandleLegal && isLegalNewCount) {

                    LOG_INTERMEDIATE_VARIATION_RESULT("Could not set legal buffer value");
                    testStatus = FALSE;

            }
            else {

                LOG_INTERMEDIATE_VARIATION_RESULT("HidD_SetNumInputBuffers properly returned FALSE");

            }
        }                
        else {

            if (!IsFirstHandleLegal) {

                LOG_INTERMEDIATE_VARIATION_RESULT("HidD_SetNumInputBuffers improperly returned TRUE");
                testStatus = FALSE;

            }
            else if (!isLegalNewCount) {

                LOG_INTERMEDIATE_VARIATION_RESULT("HidD_SetNumInputBuffers set invalid value");
                testStatus = FALSE;

            }
        }

        /*
        // Now that we have attempted to set the first handle to a new value,
        //  we need to do some verification...There are four cases to look
        //  at:
        //  1) callStatus = FALSE, isLegalNewCount = TRUE
        //      -- old value should be retained
        //
        //  2) callStatus = FALSE, isLegalNewCount = FALSE
        //      -- old value should be retained
        //          
        //  3) callStatus = TRUE,  isLegalNewCount = TRUE
        //      -- new value should be set
        //
        //  4) callStatus = TRUE,  isLegalNewCount = FALSE
        //      -- new value should be set
        //
        // One other case occurred if the handle we tested wasn't even legal...
        //  in this case, just need to bolt.
        */

        if (IsFirstHandleLegal) {

            prevStatus = callStatus;
            callStatus = HIDTest_GetBufferCount(HandleToTest, TestBuffer);
            if (!callStatus) {

                LOG_INTERMEDIATE_VARIATION_RESULT("HidD_GetNumInputBuffers unexpectedly returned FALSE");
                testStatus = FALSE;

            }

            if (prevStatus) {

                if (*TestBuffer != newCount) {
                    LOG_INTERMEDIATE_VARIATION_RESULT("New buffer value not actually set");
                    testStatus = FALSE;
                    firstHandleCount = *TestBuffer;

                }
                else {
                    LOG_INTERMEDIATE_VARIATION_RESULT("New buffer value properly set");
                    firstHandleCount = newCount;
                    
                }

            }
            else {
                if (*TestBuffer != firstHandleCount) {
                    LOG_INTERMEDIATE_VARIATION_RESULT("Old buffer value not preserved on test handle");
                    testStatus = FALSE;
                    firstHandleCount = *TestBuffer;
                }
                else {
                    LOG_INTERMEDIATE_VARIATION_RESULT("Old buffer value properly retained on test handle");
                }
            }
        }
        
        /*
        // Verify that the second handle's buffer value didn't change
        */

        callStatus = HIDTest_GetBufferCount(SecondHandle, TestBuffer);

        if (!callStatus) {

            LOG_INTERMEDIATE_VARIATION_RESULT("Could not get second handle value");
            testStatus = FALSE;

        }
        else {

            if (secondHandleCount != *TestBuffer) {

                LOG_INTERMEDIATE_VARIATION_RESULT("Second handle buffer count not properly retained");
                testStatus = FALSE;
                secondHandleCount = *TestBuffer;
                
            }
            else {

                LOG_INTERMEDIATE_VARIATION_RESULT("Second handle buffer count properly retained");

            }
        }

        /*
        // Determine what the next test value is 
        */

        newCount++;
        switch (newCount) {

            case 2:
                if (2 < CURRENT_BUFFER_MIN-1) {
                    newCount = CURRENT_BUFFER_MIN-1;
                }
                break;

            case CURRENT_BUFFER_MIN+1:
                newCount = RANDOM_BUFFER_VALUE;
                break;
            
            case RANDOM_BUFFER_VALUE+1:
                done = TRUE;
                break;
        }
        
    } // while loop

    return (testStatus);
}
                
BOOL
HIDTest_GetBufferCount(
    IN  HANDLE  DeviceHandle,
    IN  PULONG  TestBuffer
)
{
    BOOL    callStatus;

    callStatus = HidD_GetNumInputBuffers(DeviceHandle, TestBuffer);

    if (!ValidateTestBuffer(TestBuffer)) {

        LOG_BUFFER_VALIDATION_FAIL();
        callStatus = FALSE;

    }
    return (callStatus);
}    
       

BOOL
HIDTest_ValidateStrings(
    HANDLE          DeviceHandle,
    PLIST           MasterList,
    ULONG           ManufacturerStringIndex,
    ULONG           ProductStringIndex,
    ULONG           SerialNumberStringIndex
)
{

    BOOL    CallStatus;
    LIST    StringList;
    
    /*
    // To validate the strings, we need to perform the following operations on 
    //     the current device handle
    //
    //      1) Build a list of all the strings
    //      2) Compare the passed in list with the 
    //      2) Retrieve the standard strings and if they exist, need to verify
    //          that they actually in the previously built list
    //      3) If the the PreviousList list pointer is not NULL, compare the 
    //          string list that was just built with the previous one.  They
    //          should be the same.
    */


    CallStatus = HIDTest_BuildStringList( DeviceHandle,
                                          &StringList
                                        );


    if (!CallStatus) {
         
        LOG_INTERMEDIATE_VARIATION_RESULT("Could not build string list");

        return (FALSE);

    }

    /*
    // Compare the string list just built with the master list that was 
    //  passed in as a parameter.  They should be the same
    */

    if (!HIDTest_CompareStringLists(&StringList, MasterList)) {

        LOG_INTERMEDIATE_VARIATION_RESULT("String lists not equal");

        return (FALSE);
        
    }

    /*
    // Validate the standard strings (manufacturer, product, and serial number).
    //  checking that if a string is returned for these values, it is the same
    //  string as marked in the master list
    */

    CallStatus = HIDTest_ValidateStdStrings(DeviceHandle, 
                                            MasterList,
                                            ManufacturerStringIndex,
                                            ProductStringIndex,
                                            SerialNumberStringIndex
                                           );

    if (!CallStatus) {

        LOG_INTERMEDIATE_VARIATION_RESULT("Could not validate the standard strings");

        return (FALSE);

    }

    return (TRUE);
}

BOOL
HIDTest_ValidateStringParams(
    IN  HANDLE      HidDevice,
    IN  PLIST       StringList,
    IN  ULONG       ManufacturerStringIndex,
    IN  ULONG       ProductStringIndex,
    IN  ULONG       SerialNumberStringIndex
)
{
    /*
    // This function will perform parameter validation for each of the following
    //  calls:
    //
    //  HidD_GetIndexedString();
    //  HidD_GetManufacturerString();
    //  HidD_GetProductString();
    //  HidD_GetSerialNumberString();
    //
    // It performs the following steps if the string in question actually exists
    //  for the passed in device:
    //
    //  1) Allocates a buffer of size 1 and verifies that FALSE is returned for
    //      the call, ERROR_INVALID_USER_BUFFER has been set and there is
    //      no trashing of the buffer
    //  2) Allocats a buffer of size 2 and does the above check
    //  3) Allocates a buffer of stringLength * sizeof(WCHAR) - 1 to verify 
    //      the same check
    //  4) Passes in a NULL buffer with a defined length of 0
    //  5) Passes in a NULL buffer with a defined length != 0
    */
    
    ULONG               stringIndex;
    ULONG               indexValue;
    PCHAR               stringTypeDesc;
    BOOL                testStatus;
    BOOL                callStatus;
    STRING_LIST_NODE    stringNode;
    PSTRING_LIST_NODE   ptrStringNode;
    static  CHAR        ErrorString[128];

    ASSERT(STRING_INDEX_MANUFACTURER+1 == STRING_INDEX_PRODUCT);
    ASSERT(STRING_INDEX_PRODUCT+1 == STRING_INDEX_SERIAL_NUMBER);
    
    testStatus = TRUE;

    for (stringIndex = STRING_INDEX_MANUFACTURER; stringIndex <= STRING_INDEX_SERIAL_NUMBER; stringIndex++) {

        switch (stringIndex) {
            case STRING_INDEX_MANUFACTURER:
                indexValue = ManufacturerStringIndex;
                stringTypeDesc = "Manufacturer";
                break;

            case STRING_INDEX_PRODUCT:
                indexValue = ProductStringIndex;
                stringTypeDesc = "Product";
                break;

            case STRING_INDEX_SERIAL_NUMBER:
                indexValue = SerialNumberStringIndex;
                stringTypeDesc = "Serial number";
                break;
        }

        if (NO_STRING_INDEX == indexValue) {

            wsprintf(ErrorString,
                     "%s string does not exist -- no parameter checks",
                     stringTypeDesc
                    );

            LOG_INTERMEDIATE_VARIATION_RESULT( ErrorString );

        }
        else {

            if (!HIDTest_IsStrIndexInStrList(StringList,
                                             indexValue,
                                             &stringNode)) {

                wsprintf(ErrorString,
                         "%s string not in string list",
                         stringTypeDesc
                        );

                LOG_INTERMEDIATE_VARIATION_RESULT( ErrorString );

                continue;

            }

            callStatus = HIDTest_ValidateStringIndexParams(HidDevice,
                                                          indexValue,
                                                          stringNode.StringLength,
                                                          stringTypeDesc
                                                         );
            testStatus = testStatus && callStatus;
        }            
    }

    /*
    // Perform the above tests now but this time using HidD_GetIndexedString using
    //  the first index in the string list
    */

#ifdef O
    if (IsListEmpty(StringList)) {

        LOG_INTERMEDIATE_VARIATION_RESULT( "No strings in string list" );

    }
    else {

        ptrStringNode = (PSTRING_LIST_NODE) GetListHead(StringList);

        wsprintf(ErrorString,
                 "String index: %d", 
                 ptrStringNode -> StringIndex
                );
                 
        callStatus = HIDTest_ValidateStringIndexParams(HidDevice,
                                                       ptrStringNode -> StringIndex,
                                                       ptrStringNode -> StringLength,
                                                       ErrorString
                                                      );
                  
        testStatus = testStatus && callStatus;
    }
#endif    
	return (testStatus);
}    

BOOL
HIDTest_ValidateStringIndexParams(
    IN  HANDLE      HidDevice,
    IN  ULONG       StringIndex,
    IN  ULONG       StringLength,
    IN  PCHAR       StringTypeDesc
)
{
    ULONG   bufferLength;
    BOOL    done;
    BOOL    callStatus;
    BOOL    testStatus;
    PWCHAR  deviceString;
    ULONG   errorCode;
    static CHAR ErrorString[128];
    
    bufferLength = 1;
    done = FALSE;
    testStatus = FALSE;
       
    while (!done) {

        deviceString = (PWCHAR) AllocateTestBuffer(bufferLength*sizeof(WCHAR));

        if (NULL == deviceString) {

            wsprintf( ErrorString, 
                      "Could not allocate space for %s string",
                      StringTypeDesc
                    );

            LOG_TEST_ERROR ( ErrorString );
            continue;

        }

        callStatus = HIDTest_GetString( HidDevice,
                                        StringIndex,
                                        deviceString,
                                        bufferLength,
                                        &errorCode
                                      );

        if (!ValidateTestBuffer(deviceString)) {

            LOG_BUFFER_VALIDATION_FAIL();

            testStatus = FALSE;
        }

        if (!callStatus) {

            if (bufferLength == StringLength*sizeof(WCHAR)) {

                wsprintf( ErrorString,
                          "Couldn't retrieve %s string with proper buffer",
                          StringTypeDesc
                        );

                LOG_INTERMEDIATE_VARIATION_RESULT( ErrorString );

                testStatus = FALSE;

            }
           
            else if (ERROR_INVALID_USER_BUFFER != GetLastError()) {

                wsprintf( ErrorString,
                          "Invalid error value returned for %s string",
                          StringTypeDesc
                        );

                LOG_INTERMEDIATE_VARIATION_RESULT(ErrorString);

                testStatus = FALSE;
            }    
        }
        else {

            if (bufferLength != StringLength*sizeof(WCHAR)) {

                wsprintf( ErrorString,
                          "Retrieved %s string with buffer too small",
                          StringTypeDesc
                        );

                LOG_INTERMEDIATE_VARIATION_RESULT(ErrorString);

                testStatus = FALSE;

            }
        }

        FreeTestBuffer( deviceString );

        /*
        // Increment the buffer length and try again
        */

        switch (bufferLength) {

            case 1:
                bufferLength = 2;
                break;

            case 2:
                bufferLength = StringLength*sizeof(WCHAR)-1;
                break;

            default:
                if (bufferLength >= StringLength*sizeof(WCHAR)) {
                    done = TRUE;
                }
                else {
                    bufferLength = StringLength*sizeof(WCHAR);
                }
        }
    }
    
    for (bufferLength = 0; 
         bufferLength <= StringLength*sizeof(WCHAR); 
         bufferLength += StringLength*sizeof(WCHAR)) {

        /*     
        // Pass in a NULL buffer with length 0 and NULL buffer 
        //    with the appropriate size.  Verify that
        //    FALSE/ERROR_INVALID_USER_BUFFER is returned
        */

        callStatus = HIDTest_GetString(HidDevice,
                                       StringIndex,                                            
                                       NULL,
                                       bufferLength,
                                       &errorCode
                                      );

        if (callStatus) {

            wsprintf( ErrorString,
                      "%s string retrieved into NULL buffer with size: %d",
                      StringTypeDesc,
                      bufferLength
                    );

            LOG_INTERMEDIATE_VARIATION_RESULT(ErrorString);
            
            testStatus = FALSE;
        }
        else {
            if (ERROR_INVALID_USER_BUFFER != GetLastError()) {

                wsprintf( ErrorString,
                          "%s string expected ERROR_INVALID_USER_BUFFER error",
                          StringTypeDesc
                        );

                LOG_INTERMEDIATE_VARIATION_RESULT( ErrorString );

                testStatus = FALSE;
            }
            else {

                wsprintf( ErrorString,
                          "%s string returned correctly with invalid buffer and size: %d",
                          StringTypeDesc,
                          bufferLength
                        );

                LOG_INTERMEDIATE_VARIATION_RESULT( ErrorString );
            }
        }
    }
    return (testStatus);
}
    

BOOL
HIDTest_CreatePhysicalDeviceInfoA(
    IN  DEVICE_STRING       DeviceName,
    IN  BOOL                OpenOverlapped,
    OUT PHIDTEST_DEVICEINFO DeviceInfo
)
{
        PWCHAR                          tempString;
        ULONG                           tempStringLength;
        BOOL                            stringExists;
        STRING_LIST_NODE        stringNode;
        
    /*
    // First, fill our device info block so that we can easily determine 
    //    what needs to be freed and what doesn't when we call
    //    HIDTest_FreeDeviceStructures
    */

    ZeroMemory(DeviceInfo, sizeof(HIDTEST_DEVICEINFO));

    /*
    // If no device name exists, simply return false but at least we've
    //    fill our memory buffer so if the caller later tries to destroy this
    //    block we won't attempt to free nonexistant memory
    */

    if (NULL == DeviceName) {
        return (FALSE);
    }

    DeviceInfo -> IsPhysicalDevice = TRUE;

    /*
    // First thing to do is initialize the string list, so we can properly
    //  free it if need be.
    */

    InitializeList(&DeviceInfo -> StringList);

    /*
    // Begin by creating space for the DEVICE_STRING
    */

    DeviceInfo -> HidDeviceString = (DEVICE_STRING) HIDTest_AllocateDeviceString(lstrlen(DeviceName));
    
    if (NULL == DeviceInfo -> HidDeviceString) {
        return (FALSE);
    }

    CopyMemory(DeviceInfo -> HidDeviceString,
               DeviceName,
               (1+lstrlen(DeviceName)) * sizeof(TCHAR));

    /*
    // Next, we need to try to open the device handle
    */

    DeviceInfo -> HidDeviceHandle = CreateFile(DeviceInfo -> HidDeviceString,
                                               GENERIC_READ | GENERIC_WRITE,
                                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                                               NULL, 
                                               OPEN_EXISTING, 
                                               OpenOverlapped ? FILE_FLAG_OVERLAPPED : 0, 
                                               NULL); 

    if (!(IS_VALID_DEVICE_HANDLE(DeviceInfo -> HidDeviceHandle))) {
        HIDTest_FreeDeviceInfoA(DeviceInfo);
        return (FALSE);
    }

    /*
    // Next, we need to try to obtain the preparsed data for the device
    */

    if (!HidD_GetPreparsedData(DeviceInfo -> HidDeviceHandle, &DeviceInfo -> HidDevicePpd)) {
        HIDTest_FreeDeviceInfoA(DeviceInfo);
        return (FALSE);
    }

    DeviceInfo -> HidDeviceAttributes = (PHIDD_ATTRIBUTES) ALLOC(sizeof(HIDD_ATTRIBUTES));

    if (NULL == DeviceInfo -> HidDeviceAttributes) {
        HIDTest_FreeDeviceInfoA(DeviceInfo);
        return (FALSE);
    }

    if (!HidD_GetAttributes(DeviceInfo -> HidDeviceHandle, DeviceInfo -> HidDeviceAttributes)) {
        HIDTest_FreeDeviceInfoA(DeviceInfo);
        return (FALSE);
    }

    if (!HIDTest_FillCommonDeviceInfo(DeviceInfo)) {
        HIDTest_FreeDeviceInfoA(DeviceInfo);
        return (FALSE);
    }

    /*
    // Create the string list for the physical device
    */

    if (!HIDTest_BuildStringList( DeviceInfo -> HidDeviceHandle, 
                                  &DeviceInfo -> StringList
                                     )) {

        HIDTest_FreeDeviceInfoA(DeviceInfo);
        return (FALSE);
    }

    /*
    // String list has been built, let's determine what the
    //  the different other strings are.
    */

    /*
    // Begin by turning off logging for this function...Odds
    //  are its not on yet, but will do so just to make sure
    */

    LOG_OFF();
                    
        /*
        // Initialize the indices
        */
        
    DeviceInfo -> ManufacturerStringIndex = NO_STRING_INDEX;
    DeviceInfo -> ProductStringIndex = NO_STRING_INDEX;
    DeviceInfo -> SerialNumberStringIndex = NO_STRING_INDEX;
 
        /*
        // Get the manufacturer string
        */

    /*
    // The retrieval of the strings is broken in NT5 so this part is commented out for
    //   now
    */

#ifdef O
        if (!HIDTest_DoesStringExist(DeviceInfo -> HidDeviceHandle,
                                                                 STRING_INDEX_MANUFACTURER,
                                                                 &tempString,
                                                                 &tempStringLength,
                                                                 &stringExists)) {
                HIDTest_FreeDeviceInfoA(DeviceInfo);
                LOG_ON();
                return (FALSE);
        }

        if (stringExists) {

                if (!HIDTest_IsStringInStrList(&DeviceInfo -> StringList,
                                                                        tempString,
                                                                        tempStringLength,
                                                                        &stringNode
                                                                   )) {
                        FreeTestBuffer(tempString);
                        HIDTest_FreeDeviceInfoA(DeviceInfo);
                        LOG_ON();
                        return (FALSE);

                }

                DeviceInfo -> ManufacturerStringIndex = stringNode.StringIndex;
                FreeTestBuffer(tempString);
        }

        /*
        // Get the product string
        */

        if (!HIDTest_DoesStringExist(DeviceInfo -> HidDeviceHandle,
                                                                 STRING_INDEX_PRODUCT,
                                                                 &tempString,
                                                                 &tempStringLength,
                                                                 &stringExists)) {
                HIDTest_FreeDeviceInfoA(DeviceInfo);
                LOG_ON();
                return (FALSE);
        }

        if (stringExists) {

                if (!HIDTest_IsStringInStrList(&DeviceInfo -> StringList,
                                                                        tempString,
                                                                        tempStringLength,
                                                                        &stringNode
                                                                   )) {
                        FreeTestBuffer(tempString);
                        HIDTest_FreeDeviceInfoA(DeviceInfo);
                        LOG_ON();
                        return (FALSE);

                }

                DeviceInfo -> ProductStringIndex = stringNode.StringIndex;
                FreeTestBuffer(tempString);
        }

        /*
        // Get the serial number string
        */

        if (!HIDTest_DoesStringExist(DeviceInfo -> HidDeviceHandle,
                                                                 STRING_INDEX_SERIAL_NUMBER,
                                                                 &tempString,
                                                                 &tempStringLength,
                                                                 &stringExists)) {
                HIDTest_FreeDeviceInfoA(DeviceInfo);
                LOG_ON();
                return (FALSE);
        }

        if (stringExists) {

                if (!HIDTest_IsStringInStrList(&DeviceInfo -> StringList,
                                                                        tempString,
                                                                        tempStringLength,
                                                                        &stringNode
                                                                   )) {
                        FreeTestBuffer(tempString);
                        HIDTest_FreeDeviceInfoA(DeviceInfo);
                        LOG_ON();
                        return (FALSE);

                }

                DeviceInfo -> SerialNumberStringIndex = stringNode.StringIndex;
                FreeTestBuffer(tempString);
        }
#endif

    return (TRUE);
}

BOOL
HIDTest_CreateLogicalDeviceInfoA(
    IN  PCHAR                 DevicePpd,
    IN  ULONG                 DevicePpdLength,
    OUT PHIDTEST_DEVICEINFO   DeviceInfo
)
{
    /*
    // Declare the HidD_Hello function to satisfy the compiler needing
    //   the declaration
    */

    PULONG HidD_Hello;

    /*
    // First, fill our device info block so that we can easily determine 
    //    what needs to be freed and what doesn't when we call
    //    HIDTest_FreeDeviceStructures
    */

    ZeroMemory(DeviceInfo, sizeof(HIDTEST_DEVICEINFO));

    DeviceInfo -> IsPhysicalDevice = FALSE;

    /*
    // A logical device has no string associated with it.
    */

    DeviceInfo -> HidDeviceString = NULL;

    /*
    // A logical device also has no object handle, so we invalidate that
    //   as well.
    */

    DeviceInfo -> HidDeviceHandle = INVALID_HANDLE_VALUE;

    /*
    // Allocate memory for our preparsed data structure.  Since the input
    //   pointer points to a structure that is obtained at the driver level
    //   we need to allocate a little more space for the signature that 
    //   is attached to driver supplied info by HID.DLL.  
    //
    //   WARNING: This is buggy as the signature prepended to the structure
    //             may someday changed and blow this routine to pieces. The
    //             following prepended header is derived from the current
    //             HID.DLL implementation and header files (which could change).
    */
 
    /*
    // First, let's attempt to get the address to HidD_Hello
    */

    HidD_Hello = (PULONG) GetProcAddress(GetModuleHandle("HID.DLL"),
                                         "HidD_Hello"
                                        );

    if (NULL == HidD_Hello) {
        return (FALSE);
    }

    DeviceInfo -> HidDevicePpd = (PHIDP_PREPARSED_DATA) ALLOC((4*sizeof(ULONG)) + DevicePpdLength);

    
    if (NULL == DeviceInfo -> HidDevicePpd) {
        HIDTest_FreeDeviceInfoA(DeviceInfo);
        return (FALSE);
    }

    /*
    // Setup the signature on the Ppd, copy over the real Ppd struct and set
    //   the address of the Ppd to past the signature.  Now, it's just like
    //    we got the data directly from the device.
    */

    *((PULONG) DeviceInfo -> HidDevicePpd) = (ULONG) &HidD_Hello;

    (PULONG) DeviceInfo -> HidDevicePpd = ((PULONG) DeviceInfo -> HidDevicePpd) + 4;
    CopyMemory(DeviceInfo -> HidDevicePpd, DevicePpd, DevicePpdLength);

    /*
    // Also, a logical device has no attributes so we NULL that field as well.
    */

    DeviceInfo -> HidDeviceAttributes = NULL;

    if (!HIDTest_FillCommonDeviceInfo(DeviceInfo)) {
        HIDTest_FreeDeviceInfoA(DeviceInfo);
        return (FALSE);
    }

    return (TRUE);
}

VOID
HIDTest_FreeDeviceInfoA(
    IN  PHIDTEST_DEVICEINFO DeviceInfo
)
{
    if (IS_VALID_DEVICE_HANDLE(DeviceInfo -> HidDeviceHandle)) {
        CloseHandle(DeviceInfo -> HidDeviceHandle);
    }

    if (NULL != DeviceInfo -> HidDeviceString) {
        HIDTest_FreeDeviceString(DeviceInfo -> HidDeviceString);
    }

    if (NULL != DeviceInfo -> HidDevicePpd) {

        if (DeviceInfo -> IsPhysicalDevice) {
            HidD_FreePreparsedData(DeviceInfo -> HidDevicePpd);
        }
        else {
            (PULONG) DeviceInfo -> HidDevicePpd = ((PULONG) DeviceInfo -> HidDevicePpd) - 4;
            FREE(DeviceInfo -> HidDevicePpd);
        }
    }

    if (NULL != DeviceInfo -> HidDeviceAttributes) {
        FREE(DeviceInfo -> HidDeviceAttributes);
    }

    if (NULL != DeviceInfo -> HidDeviceCaps) {
        FREE(DeviceInfo -> HidDeviceCaps);
    }

    return;
}

/*****************************************************************************
/* Local function definitions
/*****************************************************************************/

BOOL
HIDTest_FillCommonDeviceInfo(
    OUT PHIDTEST_DEVICEINFO DeviceInfo
)
{
    BOOL        isError;

    isError = FALSE;
    
    DeviceInfo -> HidDeviceCaps = (PHIDP_CAPS) ALLOC(sizeof(HIDP_CAPS));

    if (NULL == DeviceInfo -> HidDeviceCaps) {
        isError = TRUE;
        goto FILL_INFO_END;
    }

    if (!HidP_GetCaps(DeviceInfo -> HidDevicePpd,
                      DeviceInfo -> HidDeviceCaps)) {
        isError = TRUE;
        goto FILL_INFO_END;
    }

    isError = !HIDTest_FillValueCaps( HidP_Input, 
                                      &DeviceInfo -> HidInputValueCaps,
                                      DeviceInfo -> HidDeviceCaps -> NumberInputValueCaps,
                                      DeviceInfo -> HidDevicePpd
                                    );

    isError = !HIDTest_FillValueCaps( HidP_Output, 
                                      &DeviceInfo -> HidOutputValueCaps,
                                      DeviceInfo -> HidDeviceCaps -> NumberOutputValueCaps,
                                      DeviceInfo -> HidDevicePpd) || isError;
                    
    isError = !HIDTest_FillValueCaps( HidP_Feature,
                                      &DeviceInfo -> HidFeatureValueCaps,
                                      DeviceInfo -> HidDeviceCaps -> NumberFeatureValueCaps,
                                      DeviceInfo -> HidDevicePpd) || isError;
                                                      
    isError = !HIDTest_FillButtonCaps(HidP_Input, 
                                      &DeviceInfo -> HidInputButtonCaps,
                                      DeviceInfo -> HidDeviceCaps -> NumberInputButtonCaps,
                                      DeviceInfo -> HidDevicePpd
                                     ) || isError;

    isError = !HIDTest_FillButtonCaps(HidP_Output, 
                                      &DeviceInfo -> HidOutputButtonCaps,
                                      DeviceInfo -> HidDeviceCaps -> NumberOutputButtonCaps,
                                      DeviceInfo -> HidDevicePpd) || isError;
                    
    isError = !HIDTest_FillButtonCaps(HidP_Feature,
                                      &DeviceInfo -> HidFeatureButtonCaps,
                                      DeviceInfo -> HidDeviceCaps -> NumberFeatureButtonCaps,
                                      DeviceInfo -> HidDevicePpd) || isError;

FILL_INFO_END:
    return (!isError);
}

BOOL
HIDTest_FillValueCaps(
    IN  HIDP_REPORT_TYPE        ReportType,
    IN  PHIDP_VALUE_CAPS        *CapsBuffer,
    IN  ULONG                   NumCaps,
    IN  PHIDP_PREPARSED_DATA    Ppd
)
{
    BOOL    callStatus;
    BOOL    isError;
    USHORT  numCaps;

    isError = FALSE;
    
    if (0 != NumCaps) {

        *CapsBuffer = (PHIDP_VALUE_CAPS) ALLOC(NumCaps * sizeof(HIDP_VALUE_CAPS));

        if (NULL != *CapsBuffer) {

            numCaps = (USHORT) NumCaps;

            callStatus = HidP_GetValueCaps( ReportType,
                                            *CapsBuffer,
                                            &numCaps,
                                            Ppd
                                          );

            if (HIDP_STATUS_SUCCESS != callStatus || numCaps != NumCaps) {
                isError = TRUE;
            }
        }
        else {
            isError = TRUE;
        }
    }
    else {
        *CapsBuffer = NULL;
    }

    return (!isError);
}

BOOL
HIDTest_FillButtonCaps(
    IN  HIDP_REPORT_TYPE        ReportType,
    IN  PHIDP_BUTTON_CAPS       *CapsBuffer,
    IN  ULONG                   NumCaps,
    IN  PHIDP_PREPARSED_DATA    Ppd
)
{
    BOOL    callStatus;
    BOOL    isError;
    USHORT  numCaps;

    isError = FALSE;
    
    if (0 != NumCaps) {

        *CapsBuffer = (PHIDP_BUTTON_CAPS) ALLOC(NumCaps * sizeof(HIDP_BUTTON_CAPS));

        if (NULL != *CapsBuffer) {

            numCaps = (USHORT) NumCaps;

            callStatus = HidP_GetButtonCaps( ReportType,
                                             *CapsBuffer,
                                             &numCaps,
                                             Ppd
                                           );

            if (HIDP_STATUS_SUCCESS != callStatus || numCaps != NumCaps) {
                isError = TRUE;
            }
        }
        else {
            isError = TRUE;
        }
    }
    else {
        *CapsBuffer = NULL;
    }

    return (!isError);
}
                
BOOL
HIDTest_DoGetFreePpd(
    IN  HANDLE  HidDevice
)
{
    PHIDP_PREPARSED_DATA HidDevicePpd;
    BOOL                 CallStatus;

    CallStatus = HidD_GetPreparsedData(HidDevice, &HidDevicePpd);

    if (CallStatus) {
        CallStatus = HidD_FreePreparsedData(HidDevicePpd);
    }

    return (CallStatus);
}

BOOL
HIDTest_ValidateAttributes(
    IN  HANDLE            HidDevice,
    IN  PHIDD_ATTRIBUTES  Attrib
)
{
    PHIDD_ATTRIBUTES     HidDeviceAttrib;
    BOOL                 CallStatus;


    /*
    // Allocate a test buffer to ensure that there are no problems with the 
    //  memory filling done by HidD_GetAttributes
    */
    
    HidDeviceAttrib = (PHIDD_ATTRIBUTES) AllocateTestBuffer(sizeof(HIDD_ATTRIBUTES));

    if (NULL == HidDeviceAttrib) {

        LOG_TEST_ERROR("Couldn't allocate memory");
        return (FALSE);

    }
        
    /*
    // Attempt to get the attributes 
    */
    
    CallStatus = HidD_GetAttributes(HidDevice, HidDeviceAttrib);

    /*
    // Check the buffer to make sure it wasn't improperly touched
    */

    if (!ValidateTestBuffer(HidDeviceAttrib)) {

        LOG_BUFFER_VALIDATION_FAIL();
        CallStatus = FALSE;

    }
    
    /*
    // Make sure the attribute fields are correct as expected.
    */
    
    if (CallStatus) {
        CallStatus = (HidDeviceAttrib -> Size == sizeof(HIDD_ATTRIBUTES)) &&
                      HIDTest_CompareAttributes(HidDeviceAttrib, Attrib);
    }

    FreeTestBuffer(HidDeviceAttrib);
    
    return (CallStatus);
}

BOOL
HIDTest_ValidateCaps(
    IN     PHIDP_PREPARSED_DATA    HidPpd,
    IN     PHIDP_CAPS              HidCaps
)
{
    HIDP_CAPS               Caps;
    NTSTATUS                CallStatus;
    BOOL                    BoolStatus;
    BOOL                    TestStatus;
    ULONG                   NumberLinkCollectionNodes;
    PHIDP_LINK_COLLECTION_NODE    LinkCollectionNodeList;


    CallStatus = HidP_GetCaps(HidPpd, &Caps);
    TestStatus = (HIDP_STATUS_SUCCESS == CallStatus) && (HIDTest_CompareCaps(HidCaps, &Caps));

    /*
    // We won't even bother proceeding any farther.  This will catch the case where
    //   we pass in invalid ppd.
    */

    if (!TestStatus) 
        return (TestStatus);

    /*
    // Now come the real complicated part, we need to retrieve the following
    //    pieces of information concerning the current device
    //      1) LinkCollectionNodes
    //      2) ValueCaps for each report type
    //      3) Button caps for each report type
    //      4) Number of data indices for each report type
    //
    // From this information, we will verify each of the fields for its
    //  correctness.  A comment on how each is performed will be included
    //  each test.  These "tests" are actually variations.
    */

    /*
    // Check that the number of link collection nodes from 
    //     HidP_GetLinkCollectionNodes is the same as the number
    //     reported in the caps structure.
    */

    NumberLinkCollectionNodes = 0;
    CallStatus = HidP_GetLinkCollectionNodes(NULL,
                                             &NumberLinkCollectionNodes,
                                             HidPpd
                                            );

    if (HIDP_STATUS_BUFFER_TOO_SMALL != CallStatus) {
        LOG_UNEXPECTED_STATUS_WARNING("HidP_GetLinkCollectionNodes", CallStatus);
    }

    if (NumberLinkCollectionNodes != HidCaps -> NumberLinkCollectionNodes) {
        LOG_INTERMEDIATE_VARIATION_RESULT("LinkCollectionNode counts don't match");
        TestStatus = FALSE;
    }

    LinkCollectionNodeList = (PHIDP_LINK_COLLECTION_NODE) ALLOC(NumberLinkCollectionNodes * sizeof(HIDP_LINK_COLLECTION_NODE));

    if (NULL == LinkCollectionNodeList) {
        LOG_TEST_ERROR("Couldn't allocate memory");
        return (FALSE);
    }

    CallStatus = HidP_GetLinkCollectionNodes(LinkCollectionNodeList,
                                             &NumberLinkCollectionNodes,
                                             HidPpd
                                            );

    if (HIDP_STATUS_SUCCESS != CallStatus) {
        LOG_TEST_ERROR("Couldn't retrieve LinkCollectionNode info");
        FREE(LinkCollectionNodeList);
        return (FALSE);
    }

    /*
    // Find the representative top-level collection in our
    //     LinkCollectionNodeList and verify that the UsagePage and
    //     Usage for the top-level collection match the same fields
    //     of the Caps structure.  The top-level collection should
    //     be at index 0.  We'll test this fact in the test that verifies
    //     the link collection node call
    */

    if ((LinkCollectionNodeList -> LinkUsagePage != HidCaps -> UsagePage) && 
              (LinkCollectionNodeList -> LinkUsage != HidCaps -> Usage)) {

        LOG_INTERMEDIATE_VARIATION_RESULT("Top level UsagePage/Usage don't match");
        TestStatus = FALSE;
    }

    FREE(LinkCollectionNodeList);

    /*
    // Add code here to validate the buffer sizes.  I'm not sure actual
    //    validation is possible.  Why?  Because the size of the buffer is
    //    dependent on how the report descriptor defines the buffer and
    //    unfortunately, two four bit wide fields can either be in separate
    //    bytes with padding in between or squeezed into one byte with no
    //    padding.  At Ring3 and the calls available, the app cannot differentiate
    //    these cases.
    */

    /*
    // Need to validate the number of button caps, value caps, and data indices
    //    for Input, Output and Feature Reports.
    */

    LOG_INTERMEDIATE_VARIATION_RESULT("Validating input buffer caps");
    
    BoolStatus = HIDTest_ValidateBufferValues(HidP_Input,
                                              HidCaps -> NumberInputButtonCaps,
                                              HidCaps -> NumberInputValueCaps,
                                              HidCaps -> NumberInputDataIndices,
                                              HidPpd
                                             );
    if (!BoolStatus) {
        LOG_INTERMEDIATE_VARIATION_RESULT("Failed Input Buffer Validation");
        TestStatus = FALSE;
    }

    LOG_INTERMEDIATE_VARIATION_RESULT("Validating output buffer caps");
      
    BoolStatus = HIDTest_ValidateBufferValues(HidP_Output,     
                                              HidCaps -> NumberOutputButtonCaps,
                                              HidCaps -> NumberOutputValueCaps,
                                              HidCaps -> NumberOutputDataIndices,
                                              HidPpd
                                             );                
    if (!BoolStatus) {
        LOG_INTERMEDIATE_VARIATION_RESULT("Failed Output Buffer Validation");
        TestStatus = FALSE;
    }

    LOG_INTERMEDIATE_VARIATION_RESULT("Validating feature buffer caps");
    
    BoolStatus = HIDTest_ValidateBufferValues(HidP_Feature,     
                                              HidCaps -> NumberFeatureButtonCaps,
                                              HidCaps -> NumberFeatureValueCaps,
                                              HidCaps -> NumberFeatureDataIndices,
                                              HidPpd
                                             );                
    if (!BoolStatus) {
        LOG_INTERMEDIATE_VARIATION_RESULT("Failed Feature Buffer Validation");
        TestStatus = FALSE;
    }
    return (TestStatus);
}

BOOL
HIDTest_ValidateBufferValues(
    IN HIDP_REPORT_TYPE     ReportType,
    IN USHORT               NumButtonCaps,
    IN USHORT               NumValueCaps,
    IN USHORT               NumDataIndices,
    IN PHIDP_PREPARSED_DATA Ppd
)
{
    USHORT              ReportedButtonCaps;
    USHORT              ReportedValueCaps;
    ULONG               MaxDataIndex;
    ULONG               Index;
    ULONG               RangeIndex;
    NTSTATUS            CallStatus;
    BOOL                BoolStatus;
    BOOL                TestStatus;
    PHIDP_BUTTON_CAPS   ButtonCapsList;
    PHIDP_BUTTON_CAPS   ButtonCapsWalk;
    PHIDP_VALUE_CAPS    ValueCapsList;
    PHIDP_VALUE_CAPS    ValueCapsWalk;
    DATA_INDEX_LIST     DataIndexList;

    /*
    // In order to verify the buffer values, we need to perform the following
    //     things
    //
    //  1) Call GetButtonCaps to see how many button caps structures are reported
    //  2) Call GetValueCaps to see how many value caps structures are reported
    //  3) Retrieve the list of both the value caps and the button caps for
    //        the report type
    //  4) Loop through the list and verifying that there are 0..NumDataIndices-1
    //      indices and no more and no less and that the data index values are
    //      also in that range.
    */

    TestStatus = TRUE;

    ReportedButtonCaps = 0;
    CallStatus = HidP_GetButtonCaps(ReportType,
                                    NULL,
                                    &ReportedButtonCaps,
                                    Ppd
                                   );

    /*
    // There are two error conditions that we should expect here...
    //  1) HIDP_STATUS_BUFFER_TOO_SMALL -- If button caps do exist
    //  2) HIDP_STATUS_SUCCESS -- If no button caps exist for the report
    //
    // If one of these two cases doesn't arise, we need to log the warning msg.
    */
    
    if ((ReportedButtonCaps > 0 && HIDP_STATUS_BUFFER_TOO_SMALL != CallStatus) ||
        (0 == ReportedButtonCaps && HIDP_STATUS_SUCCESS != CallStatus)) {

        LOG_UNEXPECTED_STATUS_WARNING("HidP_GetButtonCaps", CallStatus);
    }

    if (ReportedButtonCaps != NumButtonCaps) {
        LOG_INTERMEDIATE_VARIATION_RESULT("ButtonCaps values don't match");
        TestStatus = FALSE;
    }

    /*
    // There are two error conditions that we should expect here...
    //  1) HIDP_STATUS_BUFFER_TOO_SMALL -- If value caps do exist
    //  2) HIDP_STATUS_SUCCESS -- If no value exist for the report
    //
    // If one of these two cases doesn't arise, we need to log the warning msg.
    */
    
    ReportedValueCaps = 0;
    CallStatus = HidP_GetValueCaps(ReportType,
                                   NULL,
                                   &ReportedValueCaps,
                                   Ppd
                                  );

    if ((ReportedButtonCaps > 0 && HIDP_STATUS_BUFFER_TOO_SMALL != CallStatus) ||
        (0 == ReportedButtonCaps && HIDP_STATUS_SUCCESS != CallStatus)) {
        
        LOG_UNEXPECTED_STATUS_WARNING("HidP_GetValueCaps", CallStatus);
    }

    if (ReportedValueCaps != NumValueCaps) {
        LOG_INTERMEDIATE_VARIATION_RESULT("ValueCaps values don't match");
        TestStatus = FALSE;
    }

    /*
    // Now we've got some debug only checks...This arises do to the fact that 
    //     we will still allocate memory even if buffer size is 0, but only in
    //     the debug version...If there is an error due to a retail version of
    //     the build we don't want to scare out the user...However, we would
    //     like to verify in debug that HIDPARSE ain't trashing memory
    */
    
    ButtonCapsList = NULL;
    ValueCapsList = NULL;
    
    if (0 != ReportedButtonCaps) {

    /*
    // Allocate space for a button caps list
    */
    
        ButtonCapsList = (PHIDP_BUTTON_CAPS) malloc(ReportedButtonCaps * sizeof(HIDP_BUTTON_CAPS));

        if (NULL == ButtonCapsList) {
            LOG_TEST_ERROR("Couldn't allocate memory");
            return (FALSE);
        }

        /*
        // Now that the lists have been allocated, let's try to retrieve those puppies
        //   once again.   We should only get a return value of HIDP_STATUS_SUCCESS,
        //   any thing else would be an error.
        */
        
        CallStatus = HidP_GetButtonCaps(ReportType,
                                        ButtonCapsList,
                                        &ReportedButtonCaps,
                                        Ppd
                                       );

        if (HIDP_STATUS_SUCCESS != CallStatus) {
            LOG_UNEXPECTED_STATUS_WARNING("HidP_GetButtonCaps", CallStatus);
            TestStatus = FALSE;
        }
    }

    /*
    // Build the value caps list if one exists
    */
    
    if (0 != ReportedValueCaps) {
    
        /*
        // Allocate space for a value caps list
        */
    
        ValueCapsList = (PHIDP_VALUE_CAPS) malloc(ReportedValueCaps * sizeof(HIDP_VALUE_CAPS));

        if (NULL == ValueCapsList) {
            LOG_TEST_ERROR("Couldn't allocate memory");
            FREE(ButtonCapsList);
            return (FALSE);
        }

        /*
        // Ditto the above comment for ValueCaps
        */
        
        CallStatus = HidP_GetValueCaps(ReportType,
                                       ValueCapsList,
                                       &ReportedValueCaps,
                                       Ppd
                                      );

        if (HIDP_STATUS_SUCCESS != CallStatus) {
            LOG_UNEXPECTED_STATUS_WARNING("HidP_GetValueCaps", CallStatus);
            TestStatus = FALSE;
        }
    }
    
    /*
    // Time to verify the number of data indices for the buffer.  To do so,
    //  we pass through both the button caps list and the value caps list and
    //  mark each one of the data indices report in that list.  If all the
    //  all the data indices that are report is equivalent to the number of data 
    //  indices reported in the caps structure and the appropriate data indices
    //  we marked, then we consider this to have passed.
    */

    if (0 == NumDataIndices) {

        if (ReportedButtonCaps + ReportedValueCaps > 0) {
            LOG_INTERMEDIATE_VARIATION_RESULT("No data indices although Button/Value Caps exist");
            TestStatus = FALSE;
        }
        else {
            LOG_INTERMEDIATE_VARIATION_RESULT("No data indices to verify");
        }
    }
    else {

        /*
        // The maximum data index value should be one less than the number
        //  of report data indices since the data index range is 0 --> Number-1
        */
        
        MaxDataIndex = NumDataIndices - 1;
        
        BoolStatus = HIDTest_InitDataIndexList(MaxDataIndex,
                                               &DataIndexList
                                              );
        
        if (!BoolStatus) {
            LOG_TEST_ERROR("Couldn't initialize data index list");

            if (NULL != ButtonCapsList) {
                free(ButtonCapsList);
            }

            if (NULL != ValueCapsList) {
                free(ValueCapsList);
            }
            
            return (FALSE);
        }
        
        /*
        // Begin by walking the button caps list and marking all the data indices
        //  reported in that list.
        */

        ButtonCapsWalk = ButtonCapsList;
        for (Index = 0; Index < ReportedButtonCaps; Index++, ButtonCapsWalk++) {
              
             if (ButtonCapsWalk -> IsRange) {
                 for (RangeIndex = ButtonCapsWalk -> Range.DataIndexMin;
                         RangeIndex <= ButtonCapsWalk -> Range.DataIndexMax;
                              RangeIndex++) {
        
                     BoolStatus = HIDTest_MarkDataIndex(&DataIndexList,
                                                        RangeIndex
                                                       );
                     if (!BoolStatus) {
                         LOG_INTERMEDIATE_VARIATION_RESULT("Bad button data index");
                         TestStatus = FALSE;
                     }
                 }
             }
             else {
                BoolStatus = HIDTest_MarkDataIndex(&DataIndexList,
                                                   ButtonCapsWalk -> NotRange.DataIndex
                                                  );
        
                if (!BoolStatus) {
                    LOG_INTERMEDIATE_VARIATION_RESULT("Bad button data index");
                    TestStatus = FALSE;
                }
            }
        }
        
        /*
        // Walk the value caps list and mark all the data indices report there
        //  as well.
        */
        
        ValueCapsWalk = ValueCapsList;
        for (Index = 0; Index < ReportedValueCaps; Index++, ValueCapsWalk++) {
              
            if (ValueCapsWalk -> IsRange) {
                for (RangeIndex = ValueCapsWalk -> Range.DataIndexMin;
                        RangeIndex <= ValueCapsWalk -> Range.DataIndexMax;
                             RangeIndex++) {
           
                    BoolStatus = HIDTest_MarkDataIndex(&DataIndexList,
                                                      RangeIndex
                                                      );
                    if (!BoolStatus) {
                        LOG_INTERMEDIATE_VARIATION_RESULT("Bad value data index");
                        TestStatus = FALSE;
                    }
                } 
            }
            else {
                BoolStatus = HIDTest_MarkDataIndex(&DataIndexList,
                                                   ValueCapsWalk -> NotRange.DataIndex
                                                  );
        
                if (!BoolStatus) {
                    LOG_INTERMEDIATE_VARIATION_RESULT("Bad value data index");
                    TestStatus = FALSE;
                }
            }
        }

        /*
        // Check that all the data indices have been properly used.
        */
        
        if (!HIDTest_AreAllIndicesUsed(&DataIndexList)) {
            LOG_INTERMEDIATE_VARIATION_RESULT("Unused data indices in data index list");
            TestStatus = FALSE;
        }
        
        HIDTest_FreeDataIndexList(&DataIndexList);
    }

    if (NULL != ButtonCapsList) {
        free(ButtonCapsList);
    }

    if (NULL != ValueCapsList) {
        free(ValueCapsList);
    }        

    return (TestStatus);
}


BOOL
HIDTest_CompareCaps(
    IN  PHIDP_CAPS  Caps1, 
    IN  PHIDP_CAPS  Caps2 
)
{
    /*
    // This could very well be implemented as a macro like CompareAttributes
    //   was, however, there are a lot of fields to compare so easier to define
    //   as function
    */

    return ((Caps1 -> UsagePage == Caps2 -> UsagePage) && 
            (Caps1 -> Usage     == Caps2 -> Usage)     &&
            (Caps1 -> InputReportByteLength == Caps2 -> InputReportByteLength) &&
            (Caps1 -> OutputReportByteLength == Caps2 -> OutputReportByteLength) &&
            (Caps1 -> FeatureReportByteLength == Caps2 -> FeatureReportByteLength) &&
            (Caps1 -> NumberLinkCollectionNodes == Caps2 -> NumberLinkCollectionNodes) &&
            (Caps1 -> NumberInputButtonCaps == Caps2 -> NumberInputButtonCaps) &&
            (Caps1 -> NumberInputValueCaps == Caps2 -> NumberInputValueCaps) &&
            (Caps1 -> NumberInputDataIndices == Caps2 -> NumberInputDataIndices) &&
            (Caps1 -> NumberOutputButtonCaps == Caps2 -> NumberOutputButtonCaps) &&
            (Caps1 -> NumberOutputValueCaps == Caps2 -> NumberOutputValueCaps) &&
            (Caps1 -> NumberOutputDataIndices == Caps2 -> NumberOutputDataIndices) &&
            (Caps1 -> NumberFeatureButtonCaps == Caps2 -> NumberFeatureButtonCaps) &&
            (Caps1 -> NumberFeatureValueCaps == Caps2 -> NumberFeatureValueCaps) &&
            (Caps1 -> NumberFeatureDataIndices == Caps2 -> NumberFeatureDataIndices)
           );
}

/*****************************************************************************
/* Functions related to tracking data indices
/*****************************************************************************/
BOOL
HIDTest_InitDataIndexList(
    IN  ULONG             MaxDataIndex,
    OUT PDATA_INDEX_LIST  IndexList
)
{
    ULONG   Index;

    IndexList -> List = (BOOL *) ALLOC((MaxDataIndex+1) * sizeof(BOOL));
    IndexList -> MaxDataIndex = MaxDataIndex;

    if (NULL != IndexList -> List) {
        for (Index = 0; Index <= MaxDataIndex; Index++) {
            IndexList -> List[Index] = FALSE;
        }
    }
    return (NULL != IndexList -> List);
}

VOID
HIDTest_FreeDataIndexList(
    IN  PDATA_INDEX_LIST    IndexList
)
{
    ASSERT (NULL != IndexList -> List);

    FREE(IndexList -> List);
    
    IndexList -> List = NULL;

    return;
}

BOOL
HIDTest_MarkDataIndex(
    IN  PDATA_INDEX_LIST    IndexList,
    IN  ULONG               IndexValue
)
{
    BOOL    OldValue;

    if (IndexValue > IndexList -> MaxDataIndex) {
        return (FALSE);
    }

    OldValue = IndexList -> List[IndexValue];

    IndexList -> List[IndexValue] = TRUE;

    return (!OldValue);
}

BOOL
HIDTest_GetDataIndexStatus(
    IN  PDATA_INDEX_LIST    IndexList,
    IN  ULONG               IndexValue
)
{
    ASSERT (NULL != IndexList -> List);
    ASSERT (IndexValue <= IndexList -> MaxDataIndex);

    return (IndexList -> List[IndexValue]);
}

BOOL
HIDTest_AreAllIndicesUsed(
    IN  PDATA_INDEX_LIST    IndexList
)
{
    ULONG   Index;

    ASSERT (NULL != IndexList -> List);

    for (Index = 0; Index <= IndexList -> MaxDataIndex; Index++) {
        if (!(IndexList -> List[Index])) {
            return (FALSE);
        }
    }
    return (TRUE);
}


/*****************************************************************************
/* Functions to track the availibility of strings for a device
/****************************************************************************/
BOOL
HIDTest_DoesStringExist(
    HANDLE  DeviceHandle,
    ULONG   StringIndex,
    PWCHAR  *String,
    PULONG  StringLength,
    BOOL    *StringExists
)
{
    WCHAR   TempChar;
    ULONG   StringSize;
    BOOL    CallStatus;
    BOOL    TestStatus;
    ULONG   ErrorCode;

    /*
    // We will use the TempChar variable first, just to determine if the 
    //    string exists.  If it HidD_GetIndexedString returns TRUE, then
    //    the string exists and we'll try to figure out it's actual length
    //    and create a buffer for it
    */

    *String = NULL;
    *StringLength = 0;
    TestStatus = TRUE;

    CallStatus = HIDTest_GetString(DeviceHandle,
                                   StringIndex,
                                   &TempChar,
                                   sizeof(TempChar),
                                   &ErrorCode
                                  );

    /*
    // If the GetString call returned FALSE, we need to examine the error code
    //     that was returned using GetLastError().  A return of FALSE can mean
    //     one of the following two things.
    //         1) String index not supported by the device (ERROR_GEN_FAILURE)
    //         2) String index is supported by the device but a big
    //             enough buffer wasn't passed down (ERROR_INVALID_USER_BUFFER)
    */

    if (!CallStatus) {

        switch (ErrorCode) {
            case ERROR_GEN_FAILURE:

            /*
            // This case is added here since NT5 string getting is currently
            //  busted
            */
            
            case ERROR_NOACCESS:
                *StringExists = FALSE;
                 break;

            case ERROR_INVALID_USER_BUFFER:
                *StringExists = TRUE;
                break;

            default:
                LOG_INTERMEDIATE_VARIATION_RESULT("Unknown HidD_GetIndexedString error code returned");
                TestStatus = FALSE;
                *StringExists = FALSE;
        }                                         
    }

    if (!*StringExists) {
        return (TestStatus);
    }

    /*
    // OK, so the string actually exists.  Now, let's try to create a buffer
    //    to get the string length.  Will start with 8 chararcters and double that
    //    size until we find a buffer which can hold the whole string
    */

    StringSize = 8;

    while (NULL != (*String = (PWCHAR) AllocateTestBuffer(StringSize*sizeof(WCHAR)))) {

        CallStatus = HIDTest_GetString(DeviceHandle,
                                       StringIndex,
                                       *String,
                                       StringSize*sizeof(WCHAR),
                                       &ErrorCode
                                      );

        if (!ValidateTestBuffer(*String)) {

            LOG_BUFFER_VALIDATION_FAIL();
            FreeTestBuffer(*String);
            return (FALSE);

        }
            
        if (!CallStatus) {

            switch (ErrorCode) {
                    
                /*
                // We simply do nothing, since the loop will end up being 
                //   repeated and a new buffer will be allocated
                */
                
                case ERROR_INVALID_USER_BUFFER:
                    break;
             
                /*
                // This error message is bad because it means a call to 
                //    GetString passed before but now fails for some
                //    reason.
                */
                
                case ERROR_GEN_FAILURE:

                /*
                // Ditto the above about NT5 not properly handling error status
                */

                case ERROR_NOACCESS:
                    LOG_INTERMEDIATE_VARIATION_RESULT("Unexpected failure of string call");
                    TestStatus = FALSE;
                    break;
                
                default:                                
                    LOG_INTERMEDIATE_VARIATION_RESULT("Unknown String error code returned");
                    TestStatus = FALSE;
            }
        }

        /*
        // We got the correct string now, however, it's still possible
        //   that we don't have the terminating zero.  We'll call GetWideStringLength
        //   to determine that for us.
        */
        
        else {

            CallStatus = HIDTest_GetWideStringLength(*String, StringSize, StringLength);

            /*
            // If CallStatus is TRUE, then the correct string length was found
            //    and we can break from this loop
            */

            if (CallStatus) {
                break;
            }
        }
             
        /*
        // Otherwise, we need to free the previous buffer and allocate another
        //   larger buffer
        */

        FreeTestBuffer(*String);
        StringSize *= 2;
    }

    if (NULL == *String) {
        
        LOG_TEST_ERROR("Test Error - Memory allocation failed");
        TestStatus = FALSE;

    }

    return (TestStatus);
}

BOOL
HIDTest_GetWideStringLength(
    PWCHAR  String,
    ULONG   StringSize,
    PULONG  StringLength
)
{
    ULONG     StringIndex;

    for (StringIndex = 0; StringIndex < StringSize; StringIndex++) {

        if ((WCHAR) '\0' ==  *(String+StringIndex)) {

            *StringLength = StringIndex;
            return (TRUE);
        }
    }
    return (FALSE);
}

BOOL
HIDTest_BuildStringList(
    HANDLE          DeviceHandle,
    PLIST           StringList
)
{
    ULONG           StringIndex;
    BOOL            CallStatus;
    PWCHAR          DeviceString;
    ULONG           StringLength;
    BOOL            StringExist;
    static CHAR     ErrorString[128];

    InitializeList(StringList);
    
    for (StringIndex = 0; StringIndex < STRINGS_TO_TEST; StringIndex++) {

        CallStatus = HIDTest_DoesStringExist(DeviceHandle, 
                                             StringIndex,
                                             &DeviceString,
                                             &StringLength,
                                             &StringExist
                                            );

        if (!CallStatus) {
            
            wsprintf(ErrorString, 
                     "Test Error: Error determining if string %u exists",
                     StringIndex
                    );

            LOG_TEST_ERROR(ErrorString);

            HIDTest_FreeStringList(StringList);

            return (FALSE);

        }
        else if (StringExist) {
            
            CallStatus = HIDTest_AddStringToStringList(StringList,
                                                       StringIndex,
                                                       DeviceString,
                                                       StringLength
                                                      );

            if (!CallStatus) {

                wsprintf(ErrorString,
                         "Test Error: Error adding string %u to list",
                         StringIndex
                        );

                LOG_TEST_ERROR(ErrorString); 

                FreeTestBuffer(DeviceString);
                
                HIDTest_FreeStringList(StringList);

                return (FALSE);

            }
        }    
    }
    return (TRUE);
}

VOID
HIDTest_FreeStringList(
    PLIST    StringList
)
{
    DestroyListWithCallback(StringList,
                            HIDTest_FreeStringNodeCallback
                           );
    return;
}

VOID
HIDTest_FreeStringNodeCallback(
    PLIST_NODE_HDR  ListNode
)
{
    PSTRING_LIST_NODE currNode;

    currNode = (PSTRING_LIST_NODE) ListNode;

    FreeTestBuffer(currNode -> String);

    FREE(currNode);

    return;
}

BOOL 
HIDTest_AddStringToStringList(
    PLIST           StringList,
    ULONG           StringIndex,
    PWCHAR          String,
    ULONG           StringLength
)
{
    PSTRING_LIST_NODE   listNode;

    /*
    // To add a string to the string list, we need to do the following steps
    //  1) If the string list is at it's maximum size or is NULL, need to
    //     alloc a new block
    //  2) Find the end of the list and add the appropriate information there
    //  3) Increment the number of strings in the list
    //
    // This function will assume that string indices will be added in increasing
    //   numerical order so that no sorting routine will have to be implemented
    //   This is a legitimate assumption since the BuildStringList begins with 
    //   string zero and searchs through it's maximum for strings.  Since this
    //   is the only caller of the AddStringToStringList, it will only add 
    //   string indices in increasing order.  If this assumption needs to change,
    //   it will require a little more computation to keep the list sorted
    */

    listNode = (PSTRING_LIST_NODE) ALLOC(sizeof(STRING_LIST_NODE));
    if (NULL == listNode) {
        return (FALSE);
    }

    listNode -> StringIndex = StringIndex;
    listNode -> String = String;
    listNode -> StringLength = StringLength;

    InsertTail(StringList, listNode);

    return (TRUE);

}

BOOL
HIDTest_IsStringInStrList(
    PLIST               StringList,
    PWCHAR              String,
    ULONG               StringLength,
    PSTRING_LIST_NODE   StringNode
)
{
    /*
    // Searching the string list for a given string is not as easy as searching
    //   the string list for a given string index since the strings are stored in
    //   in index order not alphabetical order.  Therefore, we cannot perform
    //   any sort of binary search to deal with this case and must linearly
    //   search the list before we can determine that a given string does
    //   not exist in the list
    */

    PSTRING_LIST_NODE   currNode;

    currNode = (PSTRING_LIST_NODE) GetListHead(StringList);

    while (currNode != (PSTRING_LIST_NODE) StringList) {

        if (HIDTest_CompareStrings(currNode -> String,
                                   currNode -> StringLength,
                                   String,
                                   StringLength
                                  )) {
            *StringNode = *currNode;
            return (TRUE);

        }

        currNode = (PSTRING_LIST_NODE) GetNextEntry(currNode);
    }
   
    return (FALSE);
}

BOOL
HIDTest_IsStrIndexInStrList(
    PLIST               StringList,
    ULONG               StringIndex,
    PSTRING_LIST_NODE   StringNode
)
{
    PSTRING_LIST_NODE   currNode;

    currNode = (PSTRING_LIST_NODE) GetListHead(StringList);

    while (currNode != (PSTRING_LIST_NODE) StringList) {

        if (currNode -> StringIndex == StringIndex) {

            *StringNode = *currNode;
            return (TRUE);

        }
        else if (currNode -> StringIndex > StringIndex) {
            return (FALSE);
        }

        currNode = (PSTRING_LIST_NODE) GetNextEntry(currNode);

    }
    return (FALSE);
}

BOOL
HIDTest_CompareStringLists(
    PLIST    StringList1,
    PLIST    StringList2
)
{
    PSTRING_LIST_NODE   node1;
    PSTRING_LIST_NODE   node2;

    /*
    // Comparing two string lists is a relatively simple process since we
    //   are only looking for whether they are equal and not where they differ.
    //   Plus, our string lists should both be in index string order. 
    //
    //   To do the comparison, all that needs to be done is traverse both
    //      lists from the beginning.  If at any point, either the indices 
    //      or the string values don't match, we can return FALSE
    */

    node1 = (PSTRING_LIST_NODE) GetListHead(StringList1);
    node2 = (PSTRING_LIST_NODE) GetListHead(StringList2);
           
    while (node1 != (PSTRING_LIST_NODE) StringList1 && node2 != (PSTRING_LIST_NODE) StringList2) {

        if ((node1 -> StringIndex != node2 -> StringIndex) ||
            (!HIDTest_CompareStrings(node1 -> String, 
                                    node1 -> StringLength,
                                    node2 -> String, 
                                    node2 -> StringLength
                                   ))) {
            return (FALSE);

        }

        node1 = (PSTRING_LIST_NODE) GetNextEntry(node1);
        node2 = (PSTRING_LIST_NODE) GetNextEntry(node2);

    }
    return (TRUE);
}


BOOL
HIDTest_ValidateStdStrings(
    HANDLE          DeviceHandle,
    PLIST           CurrentStringList,
    ULONG           ManufacturerStringIndex,
    ULONG           ProductStringIndex,
    ULONG           SerialNumberStringIndex
)
{
    PWCHAR              DeviceString;
    ULONG               StringLength;
    BOOL                TestStatus;
    BOOL                CallStatus;
    PCHAR               StringTypeDesc;
    ULONG               StringIndex;
    BOOL                StringExist;
    ULONG               indexValue;
    static CHAR         ErrorString[128];
    STRING_LIST_NODE    stringNode;

    /*
    // To verify the standard strings, we need to the following steps
    //     for each of the strings (manufacturer, product, serial number)
    //
    //      1) Attempt to retrieve the string...
    //      2) If the string doesn't exist, need to verify that the passed
    //          in StringIndex is == NO_STRING_INDEX
    //      3) If the string exists, need to search the current string list
    //          to get the index and then compare that index value with the
    //          index value for the given string
    */

    /*
    // Begin with the manufacturer string and work our way up from there
    //  The following asserts verify that the macros that have been defined
    //  above are still in numerical order
    */

    ASSERT(STRING_INDEX_MANUFACTURER+1 == STRING_INDEX_PRODUCT);
    ASSERT(STRING_INDEX_PRODUCT+1 == STRING_INDEX_SERIAL_NUMBER);
    
    TestStatus = TRUE;
    for (StringIndex = STRING_INDEX_MANUFACTURER; StringIndex <= STRING_INDEX_SERIAL_NUMBER; StringIndex++) {

        CallStatus = HIDTest_DoesStringExist(DeviceHandle,
                                             StringIndex,
                                             &DeviceString,
                                             &StringLength,
                                             &StringExist
                                            );
        switch (StringIndex) {
            case STRING_INDEX_MANUFACTURER:
                indexValue = ManufacturerStringIndex;
                StringTypeDesc = "Manufacturer";
                break;

            case STRING_INDEX_PRODUCT:
                indexValue = ProductStringIndex;
                StringTypeDesc = "Product";
                break;

            case STRING_INDEX_SERIAL_NUMBER:
                indexValue = SerialNumberStringIndex;
                StringTypeDesc = "Serial number";
                break;
        }

        if (!CallStatus) {
          
            wsprintf(ErrorString, 
                     "Test Error: Error determining if string %u exists",
                     StringIndex
                    );

            LOG_TEST_ERROR(ErrorString);

            return (FALSE);
        }
        else if (!StringExist) {

            if (indexValue != NO_STRING_INDEX) {

                wsprintf(ErrorString, "Mismatch: %s string not returned", StringTypeDesc);

                TestStatus = FALSE;

            }
            else {

                wsprintf(ErrorString, "%s string not found", StringTypeDesc);
            }
            
            LOG_INTERMEDIATE_VARIATION_RESULT(ErrorString);

        }
        else {

            CallStatus = HIDTest_IsStringInStrList(CurrentStringList,
                                                   DeviceString,
                                                   StringLength,
                                                   &stringNode
                                                  );

            if (!CallStatus) {

                wsprintf(ErrorString, "%s string could not be found in string list", StringTypeDesc);
                
                LOG_INTERMEDIATE_VARIATION_RESULT(ErrorString);
                
                TestStatus = FALSE;

            }

            else {

                if (indexValue != stringNode.StringIndex) {

                    wsprintf(ErrorString, "Mismatched index: %s string", StringTypeDesc);

                    TestStatus = FALSE;

                }
                else {
                
                    wsprintf(ErrorString, "%s string found in the string list", StringTypeDesc);

                }
                LOG_INTERMEDIATE_VARIATION_RESULT(ErrorString);
            }
            FreeTestBuffer(DeviceString);
        }


        
    }
    return (TestStatus);
}    
   
    
BOOL
HIDTest_GetString(
    HANDLE  DeviceHandle,
    ULONG   StringIndex,
    PWCHAR  StringBuffer,
    ULONG   BufferLength,
    PULONG  ErrorCode
)
{
    BOOL    CallStatus;
    
    switch (StringIndex) {
        case STRING_INDEX_MANUFACTURER:
            CallStatus = HidD_GetManufacturerString(DeviceHandle,
                                                    StringBuffer,
                                                    BufferLength
                                                   );

        break;

        case STRING_INDEX_PRODUCT:
            CallStatus = HidD_GetProductString(DeviceHandle,
                                               StringBuffer,
                                               BufferLength
                                              );

            break;

        case STRING_INDEX_SERIAL_NUMBER:
            CallStatus = HidD_GetSerialNumberString(DeviceHandle,
                                                    StringBuffer,
                                                    BufferLength
                                                   );
            break;

        default:
            CallStatus = HidD_GetIndexedString(DeviceHandle,
                                               StringIndex,
                                               StringBuffer,
                                               BufferLength
                                              );
    }

    *ErrorCode = GetLastError();
    return (CallStatus);
}

BOOL
HIDTest_BuildReportIDList(
    IN  PHIDP_VALUE_CAPS    VCaps,
    IN  ULONG               NumVCaps,
    IN  PHIDP_BUTTON_CAPS   BCaps,
    IN  ULONG               NumBCaps,
    IN  PUCHAR              *ReportIDs,
    IN  PULONG              ReportIDCount
)
{
    BOOL    usingReportIDs;
    ULONG   maxReportIDs;

    usingReportIDs = FALSE;
    *ReportIDCount = 0;

    if (0 != NumVCaps) {
        usingReportIDs = VCaps -> ReportID != 0;
    }
    else if (0 != NumBCaps) {
        usingReportIDs = BCaps -> ReportID != 0;
    }
    else {

        /*
        // We're not actually using report IDs in the is case, but it will
        //  get set to TRUE anyway because both lists are empty.  Doing so,
        //  will cause us to dump out of the routine early.
        */

        usingReportIDs = TRUE;

    }
        

    /*
    // We'll allocate a buffer that can hold the maximum number of report
    //  IDs that can possible exist for these values.  Most likely, we'll
    //  allocate a buffer that is too big.  This can be optimized later if
    //  necessary.
    */
    
    if (usingReportIDs) {
        maxReportIDs = NumVCaps + NumBCaps;
    }
    else {
        maxReportIDs = 1;
    }
    
    if (0 == maxReportIDs) {

        *ReportIDs = NULL;
        return (TRUE);
        
    }
        
    *ReportIDs = (PUCHAR) malloc (maxReportIDs * sizeof(UCHAR));

    if (NULL == *ReportIDs) {
        return (FALSE);
    }

    /*
    // We've allocated the buffer, now let's fill it.
    //   To do so, we need to trace through each of the lists, get the 
    //   report ID, search the current list.  If found in the current list of
    //   IDs, we ignore and proceed to the next.  Otherwise, we need to bump
    //   all the other IDs that are greater than this one down one spot in the
    //   buffer and add this new ID.  Doing so will guarantee that the buffer 
    //   we are creating will be in sorted order.
    */

    while (NumVCaps--) {

        HIDTest_InsertIDIntoList(*ReportIDs, ReportIDCount, VCaps -> ReportID);
        VCaps++;

    }
    

    while (NumBCaps--) {

        HIDTest_InsertIDIntoList(*ReportIDs, ReportIDCount, BCaps -> ReportID);
        BCaps++;
    }                
                
    return (TRUE);
}

VOID
HIDTest_InsertIDIntoList(
    IN  PUCHAR  ReportIDs,
    IN  PULONG  ReportIDCount,
    IN  UCHAR   NewID
)
{
    UCHAR   listReportID;
    ULONG   listIndex;
    BOOL    insertIntoList;

    for (listIndex = 0, insertIntoList = TRUE; listIndex < *ReportIDCount; listIndex++) {

        listReportID = *(ReportIDs + listIndex);
        
        if (listReportID == NewID) {
            insertIntoList = FALSE;
            break;
        }
        else if (listReportID > NewID) {
            memmove(ReportIDs + listIndex + 1, 
                    ReportIDs + listIndex,
                    (*ReportIDCount) - listIndex * sizeof(UCHAR)
                   );
            break;
        }
    }

    if (insertIntoList) {

        *(ReportIDs + listIndex) = NewID;
        (*ReportIDCount)++;
      
    }    
            
    return;
}    


BOOL 
HIDTest_IsIDInList(
    IN  UCHAR   ReportID,
    IN  PUCHAR  ReportIDList,
    IN  ULONG   ReportIDListCount
)
{
    ULONG   idIndex;
    BOOL    found;

    found = FALSE;    
    for (idIndex = 0; idIndex < ReportIDListCount; idIndex++) {

        if (ReportID == *(ReportIDList+idIndex)) {
            found = TRUE;
            break;
        }
        else if (ReportID < *(ReportIDList+idIndex)) {
            break;
        }
    }        
        
    return (found);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\filter\hidvalid\write.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidtest\inc\hidtest.h ===
#ifndef __HIDTEST_H__
    #define __HIDTEST_H__


    #define NO_STRING_INDEX 0xFFFFFFFF
    
    #include "list.h"

    /*****************************************************************************
    /* Exportable typedefs 
    /*****************************************************************************/
    
    typedef PTSTR   DEVICE_STRING;
    
    typedef struct  _HidTestStatus {

        ULONG   nOperationsPerformed;
        ULONG   nOperationsPassed;
        ULONG   nOperationsFailed;
    
    } HIDTEST_STATUS, *PHIDTEST_STATUS;
    
    typedef struct _StringListNode {

        LIST_NODE_HDR   Hdr;

        PWCHAR          String;
        ULONG           StringLength;
        ULONG           StringIndex;

    } STRING_LIST_NODE, *PSTRING_LIST_NODE;        

    typedef struct _HidDeviceInfo {

        HANDLE                      HidDeviceHandle;
        DEVICE_STRING               HidDeviceString;
        PHIDP_PREPARSED_DATA        HidDevicePpd;
        PHIDD_ATTRIBUTES            HidDeviceAttributes;
        PHIDP_CAPS                  HidDeviceCaps;

        PHIDP_VALUE_CAPS            HidInputValueCaps;
        PHIDP_BUTTON_CAPS           HidInputButtonCaps;

        PHIDP_VALUE_CAPS            HidOutputValueCaps;
        PHIDP_BUTTON_CAPS           HidOutputButtonCaps;

        PHIDP_VALUE_CAPS            HidFeatureValueCaps;
        PHIDP_BUTTON_CAPS           HidFeatureButtonCaps;

        PHIDP_LINK_COLLECTION_NODE  HidLinkNodes;

        BOOL                        IsPhysicalDevice;
        LIST                        StringList;
        ULONG                       ManufacturerStringIndex;
        ULONG                       ProductStringIndex;
        ULONG                       SerialNumberStringIndex;
    
    } HIDTEST_DEVICEINFO, *PHIDTEST_DEVICEINFO;
    
    
    typedef VOID HIDTEST_API(PHIDTEST_DEVICEINFO, ULONG, PHIDTEST_STATUS);
    
    typedef HIDTEST_API *PHIDTEST_API;
    
    typedef BOOL (*PCREATE_PHYSICAL_DEVICE_INFO_PROC)(DEVICE_STRING,
                                                      BOOL,
                                                      PHIDTEST_DEVICEINFO
                                                     );
    
    typedef BOOL (*PCREATE_LOGICAL_DEVICE_INFO_PROC)(PCHAR,
                                                     ULONG,
                                                     PHIDTEST_DEVICEINFO
                                                    );
    
    typedef VOID (*PCREATE_FREE_DEVICE_INFO_PROC)(PHIDTEST_DEVICEINFO);
    
    typedef BOOL (*PCREATE_TEST_LOG_PROC)(PCHAR);
    
    typedef VOID (*PSET_LOG_ON_PROC)(BOOL);

    typedef VOID (*PCLOSE_TEST_LOG_PROC)(VOID);

    typedef struct _functions {

        PHIDTEST_API HIDTest_VerifyHidGuid;
        PHIDTEST_API HIDTest_VerifyStrings;
        PHIDTEST_API HIDTest_VerifyPreparsedData;
        PHIDTEST_API HIDTest_VerifyAttributes;
        PHIDTEST_API HIDTest_VerifyNumBuffers;
        PHIDTEST_API HIDTest_VerifyCapabilities;
        PHIDTEST_API HIDTest_VerifyGetFeature;
        PHIDTEST_API HIDTest_VerifySetFeature;

        PCREATE_PHYSICAL_DEVICE_INFO_PROC  HIDTest_CreatePhysicalDeviceInfo;
        PCREATE_LOGICAL_DEVICE_INFO_PROC   HIDTest_CreateLogicalDeviceInfo;
        PCREATE_FREE_DEVICE_INFO_PROC      HIDTest_FreeDeviceInfo;
        PCREATE_TEST_LOG_PROC              HIDTest_CreateTestLog;
        PSET_LOG_ON_PROC                   HIDTest_SetLogOn;
        PCLOSE_TEST_LOG_PROC               HIDTest_CloseTestLog;

    } HIDTEST_FUNCTIONS, *PHIDTEST_FUNCTIONS;

    typedef VOID (*PINIT_PROC)(PHIDTEST_FUNCTIONS);

    #define HIDTest_AllocateDeviceString(nChars) ALLOC(((nChars)+1) * sizeof(TCHAR))
    #define HIDTest_FreeDeviceString(String)     FREE(String)

    /*
    // Declare the exportable function as normal function declarations when
    //    this file is include in HIDTEST.C.  Otherwise, we want to declare
    //    our pointers to these functions as external variables
    */

    #ifdef __HIDTEST_C__

        VOID
        HIDTest_InitExportAddress(
            PHIDTEST_FUNCTIONS  Exports
        );

        HIDTEST_API HIDTest_VerifyHidGuidA;
        HIDTEST_API HIDTest_VerifyStringsA;
        HIDTEST_API HIDTest_VerifyPreparsedDataA;
        HIDTEST_API HIDTest_VerifyAttributesA;
        HIDTEST_API HIDTest_VerifyNumBuffersA;
        HIDTEST_API HIDTest_VerifyCapabilitiesA;
        HIDTEST_API HIDTest_VerifyGetFeatureA;
        HIDTEST_API HIDTest_VerifySetFeatureA;
        
        VOID
        HIDTest_VerifyPhysicalDesc(
            IN  HANDLE          HidDevice,
            IN  PCHAR           PhysDesc,
            IN  ULONG           PhysDescLength,
            IN  ULONG           nIterations,
            OUT PHIDTEST_STATUS Status
        );
        
       
        VOID
        HIDTest_VerifyConfiguratons(
            IN  HANDLE          HidDevice,
            IN  ULONG           nConfigurations,
            IN  BOOL            RestoreCurrentConfig,
            IN  ULONG           nIterations,
            OUT PHIDTEST_STATUS Status
        
        );
        
        VOID
        HIDTest_VerifyDevices(
            IN  ULONG           nStrings,
            IN  DEVICE_STRING   DeviceStrings[],
            IN  ULONG           nIterations,
            OUT PHIDTEST_STATUS Status
        );
        
        VOID
        HIDTest_VerifyLinkCollections(
            IN  PHIDP_PREPARSED_DATA       Ppd,
            IN  PHIDP_LINK_COLLECTION_NODE CollectionList,
            IN  ULONG                      nCollections,
            IN  ULONG                      nIterations,
            OUT PHIDTEST_STATUS            Status
        );
        
        BOOL
        HIDTest_CreatePhysicalDeviceInfoA(
            IN  DEVICE_STRING       DeviceName,
            IN  BOOL                OpenOverlapped,
            OUT PHIDTEST_DEVICEINFO DeviceInfo
        );
        
        BOOL
        HIDTest_CreateLogicalDeviceInfoA(
            IN  PCHAR                 DevicePpd,
            IN  ULONG                 DevicePpdLength,
            OUT PHIDTEST_DEVICEINFO   DeviceInfo
        );
        
        VOID
        HIDTest_FreeDeviceInfoA(
            IN  PHIDTEST_DEVICEINFO DeviceInfo
        );
        
        BOOL
        HIDTest_CreateTestLogA(
            IN  PCHAR  LogFileName
        );
        
        VOID
        HIDTest_SetLogOnA(
            BOOL    TurnOn
        );

        VOID
        HIDTest_CloseTestLogA(
            VOID
        );
    
    #else

        /*
        // Declare this structure.  This structure will be mapped into an user
        //    space which might possibly use HIDTEST.DLL.  Any program that
        //    uses HIDTest needs to use the HIDTEST_INIT() macro before calling
        //    any of the functions.  This macro will take care of resolving all
        //    the function addresses. 
        */

        HIDTEST_FUNCTIONS   HIDTest_Exports;

        /*
        // This is the definition of the HIDTEST_INIT() macro which initializes
        //    all the function address that are exported by the DLL.
        */

        #define HIDTEST_INIT()  \
        { \
            PINIT_PROC INIT_PROC; \
            \
            INIT_PROC = (PINIT_PROC) GetProcAddress(GetModuleHandle("HIDTEST.DLL"), \
                                                    "HIDTest_InitExportAddress" \
                                                   ); \
            \
            INIT_PROC(&HIDTest_Exports); \
        }

        /*
        // These are the defines that are used by the HIDTest to access the
        //    exported testing functions.
        */

        #define HIDTest_VerifyHidGuid               HIDTest_Exports.HIDTest_VerifyHidGuid
        #define HIDTest_VerifyStrings               HIDTest_Exports.HIDTest_VerifyStrings
        #define HIDTest_VerifyPreparsedData         HIDTest_Exports.HIDTest_VerifyPreparsedData
        #define HIDTest_VerifyAttributes            HIDTest_Exports.HIDTest_VerifyAttributes
        #define HIDTest_VerifyNumBuffers            HIDTest_Exports.HIDTest_VerifyNumBuffers          
        #define HIDTest_VerifyCapabilities          HIDTest_Exports.HIDTest_VerifyCapabilities
        #define HIDTest_VerifyGetFeature            HIDTest_Exports.HIDTest_VerifyGetFeature
        #define HIDTest_VerifySetFeature            HIDTest_Exports.HIDTest_VerifySetFeature
                            
        #define HIDTest_CreatePhysicalDeviceInfo    HIDTest_Exports.HIDTest_CreatePhysicalDeviceInfo
        #define HIDTest_CreateLogicalDeviceInfo     HIDTest_Exports.HIDTest_CreateLogicalDeviceInfo
        #define HIDTest_FreeDeviceInfo              HIDTest_Exports.HIDTest_FreeDeviceInfo
        #define HIDTest_CreateTestLog               HIDTest_Exports.HIDTest_CreateTestLog
        #define HIDTest_SetLogOn                    HIDTest_Exports.HIDTest_SetLogOn
        #define HIDTest_CloseTestLog                HIDTest_Exports.HIDTest_CloseTestLog
        
    #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\hidtest\ntlog.h ===
/*---------------------------------------------------------------------------*\
| NTLOG OBJECT
|   This module defines the NTLOG object.  This header must be include in all
|   modules which make NTLOG calls, or utilizes the definitions.
|
|
| Copyright (C) 1990-1994 Microsoft Corp.
|
| created: 01-Oct-90
| history: 01-Oct-90 <chriswil> created.
|          05-Feb-91 <chriswil> added NOPROLOG style.
|          23-Feb-91 <chriswil> expanded log-flags to DWORD.
|          28-May-91 <chriswil> added per-thread variation tracking.
|          19-Mar-92 <chriswil> redefined struct for shared memory.
|          10-Oct-92 <martys>   added thread macros
|          05-Oct-93 <chriswil> unicode enabled.
|		   10-Oct-96 (darrenf)  fixed _FILE_ for unicode, added _NTLOG_LOGPATH handling	
|
\*---------------------------------------------------------------------------*/

// If doing C++ stuff, this needs to be here to
// prevent decorating of symbols.
//
#ifdef __cplusplus
extern "C" {
#endif

// **NEW** 10/26/96 Log path environment variable **NEW**
// if the environment variable _NTLOG_LOGPATH is set to a non-empty string 
// the value of this variable will be prepended to the log name
// The path should NOT include a trailing backslash.

// No validation is performed on the path, however, if the value is invalid,
// the call to tlCreateLog will fail because CreateFile will fail.

// Basically should be used to force logfiles to a location other than the current directory
// without changing the source file.

// **NEW** 1/20/97 environment variable to force diffable files **NEW**
// if the environment variable _NTLOG_DIFFABLE is set, then log files
// will not contain process and thread specific data, and time and date data.
//


// NTLOG STYLES
//  The folowing are logging levels in which the Log Object can prejudice
//  itself.  These are used by the tlLogCreate() in initializing the
//  Log Object information.  A combination of characteristics is obtained
//  by bitwise OR'ing these identifiers together.
//
#define LOG_LEVELS    0x0000FFFFL    // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L    // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_ABORT     0x00000001L    // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_SEV2      0x00000004L    // Log at Severity 2 level
#define TLS_SEV3      0x00000008L    // Log at Severity 3 level
#define TLS_WARN      0x00000010L    // Log at Warn level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_BLOCK     0x00000400L    // Block the variation.
#define TLS_BREAK     0x00000800L    // Debugger break;
#define TLS_CALLTREE  0x00000040L    // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L    // Log System debug.
#define TLS_TESTDEBUG 0x00001000L    // Debug level.
#define TLS_TEST      0x00000100L    // Log Test information (user).
#define TLS_VARIATION 0x00000200L    // Log testcase level.

#define TLS_REFRESH   0x00010000L    // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L    // Sort file output by instance.
#define TLS_DEBUG     0x00040000L    // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L    // Output to 2nd screen.
#define TLS_PROLOG    0x00200000L    // Prolog line information.
#define TLS_WINDOW    0x00400000L    // Log to windows.
#define TLS_ACCESSON  0x00800000L    // Keep log-file open.
#define TLS_DIFFABLE  0x01000000L    // make log file windiff'able (no dates..)
#define TLS_NOHEADER  0x02000000L    // suppress headers so it is more diffable



// NTLOG tlLogOut() PARAMETERS
//   The following defines are used in the tlLogOut() function to output the
//   filename and line numbers associated with the caller.  This uses the
//   preprocessors capabilities for obtaining the file/line.
//
#define TL_LOG       TLS_LOG      ,TEXT(__FILE__),(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,TEXT(__FILE__),(int)__LINE__
#define TL_WARN      TLS_WARN     ,TEXT(__FILE__),(int)__LINE__
#define TL_PASS      TLS_PASS     ,TEXT(__FILE__),(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,TEXT(__FILE__),(int)__LINE__
#define TL_INFO      TLS_INFO     ,TEXT(__FILE__),(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,TEXT(__FILE__),(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,TEXT(__FILE__),(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,TEXT(__FILE__),(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,TEXT(__FILE__),(int)__LINE__
#define TL_TEST      TLS_TEST     ,TEXT(__FILE__),(int)__LINE__
#define TL_VARIATION TLS_VARIATION,TEXT(__FILE__),(int)__LINE__



// NTLOG API (EXPORT METHODS)
//   These routines are exported from the library.  These should be the only
//   interface with the NTLOG object.
//
HANDLE APIENTRY  tlCreateLog_W(LPCWSTR,DWORD);
HANDLE APIENTRY  tlCreateLog_A(LPCSTR,DWORD);
BOOL   APIENTRY  tlDestroyLog(HANDLE);
BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);
BOOL   APIENTRY  tlRemoveParticipant(HANDLE);
DWORD  APIENTRY  tlParseCmdLine_W(LPCWSTR);
DWORD  APIENTRY  tlParseCmdLine_A(LPCSTR);
int    APIENTRY  tlGetLogFileName_W(HANDLE,LPWSTR);
int    APIENTRY  tlGetLogFileName_A(HANDLE,LPSTR);
BOOL   APIENTRY  tlSetLogFileName_W(HANDLE,LPCWSTR);
BOOL   APIENTRY  tlSetLogFileName_A(HANDLE,LPCSTR);
DWORD  APIENTRY  tlGetLogInfo(HANDLE);
DWORD  APIENTRY  tlSetLogInfo(HANDLE,DWORD);
HANDLE APIENTRY  tlPromptLog(HWND,HANDLE);
int    APIENTRY  tlGetTestStat(HANDLE,DWORD);
int    APIENTRY  tlGetVariationStat(HANDLE,DWORD);
VOID   APIENTRY  tlClearTestStats(HANDLE);
VOID   APIENTRY  tlClearVariationStats(HANDLE);
BOOL   APIENTRY  tlStartVariation(HANDLE);
DWORD  APIENTRY  tlEndVariation(HANDLE);
VOID   APIENTRY  tlReportStats(HANDLE);
BOOL   APIENTRY  tlLogX_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR);
BOOL   APIENTRY  tlLogX_A(HANDLE,DWORD,LPCSTR,int,LPCSTR);
BOOL   FAR cdecl tlLog_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR,...);
BOOL   FAR cdecl tlLog_A(HANDLE,DWORD,LPCSTR,int,LPCSTR,...);

#ifdef UNICODE
#define tlCreateLog         tlCreateLog_W
#define tlParseCmdLine      tlParseCmdLine_W
#define tlGetLogFileName    tlGetLogFileName_W
#define tlSetLogFileName    tlSetLogFileName_W
#define tlLogX              tlLogX_W
#define tlLog               tlLog_W
#else
#define tlCreateLog         tlCreateLog_A
#define tlParseCmdLine      tlParseCmdLine_A
#define tlGetLogFileName    tlGetLogFileName_A
#define tlSetLogFileName    tlSetLogFileName_A
#define tlLogX              tlLogX_A
#define tlLog               tlLog_A
#endif



// RATS MACROS
//   These macros are provided as a common logging interface which is
//   compatible with the RATS logging-macros.
//
#define TESTDATA                 HANDLE        hLog;
#define TESTOTHERDATA            extern HANDLE hLog;


//  These must be useless.  TL_* macros do not include TLS_TEST or
//  TLS_VARIATION, so they DO NOT count in the stats.  Leaving them around
//  for 'backwards compatibility, if anyone was actually using them...
//
#define L_PASS                   hLog,TL_PASS
#define L_WARN                   hLog,TL_WARN
#define L_DEBUG                  hLog,TL_TESTDEBUG
#define L_TRACE                  hLog,TL_SYSTEM
#define L_FAIL                   hLog,TL_SEV1
#define L_FAIL2                  hLog,TL_SEV2
#define L_FAIL3                  hLog,TL_SEV3
#define L_BLOCK                  hLog,TL_BLOCK


//  macros for incrementing test/variation counts for various log levels
//
#define L_TESTPASS                   hLog,TLS_TEST | TL_PASS
#define L_TESTWARN                   hLog,TLS_TEST | TL_WARN
#define L_TESTDEBUG                  hLog,TLS_TEST | TL_TESTDEBUG
#define L_TESTTRACE                  hLog,TLS_TEST | TL_SYSTEM
#define L_TESTFAIL                   hLog,TLS_TEST | TL_SEV1
#define L_TESTFAIL2                  hLog,TLS_TEST | TL_SEV2
#define L_TESTFAIL3                  hLog,TLS_TEST | TL_SEV3
#define L_TESTBLOCK                  hLog,TLS_TEST | TL_BLOCK
#define L_TESTABORT                  hLog,TLS_TEST | TL_ABORT

#define L_VARPASS                   hLog,TLS_VARIATION | TL_PASS
#define L_VARWARN                   hLog,TLS_VARIATION | TL_WARN
#define L_VARDEBUG                  hLog,TLS_VARIATION | TL_TESTDEBUG
#define L_VARTRACE                  hLog,TLS_VARIATION | TL_SYSTEM
#define L_VARFAIL                   hLog,TLS_VARIATION | TL_SEV1
#define L_VARFAIL2                  hLog,TLS_VARIATION | TL_SEV2
#define L_VARFAIL3                  hLog,TLS_VARIATION | TL_SEV3
#define L_VARBLOCK                  hLog,TLS_VARIATION | TL_BLOCK
#define L_VARABORT                  hLog,TLS_VARIATION | TL_ABORT


#define TESTBEGIN(cmd,logfilename){                                                       \
                                      DWORD __tlFlags;                                    \
                                      __tlFlags = tlParseCmdLine(cmd);                    \
                                      hLog      = tlCreateLog(logfilename,__tlFlags);     \
                                      tlAddParticipant(hLog,0l,0);

#define TESTEND                       tlRemoveParticipant(hLog);                          \
                                      tlDestroyLog(hLog);                                 \
                                  }

#define VARIATION(name,flags)    if(tlStartVariation(hLog))                                                  \
                                 {                                                                           \
                                     DWORD __dwResult;                                                       \
                                     tlLog(hLog,TL_VARIATION,TEXT("%s"),(LPTSTR)name);

#define ENDVARIATION                 __dwResult = tlEndVariation(hLog);                                      \
                                     tlLog(hLog,__dwResult | TL_VARIATION,TEXT("End Variation reported"));   \
                                 }


#define ENTERTHREAD(_hLG,_szNM)  {                                                                           \
                                    LPTSTR _lpFN = _szNM;                                                    \
                                    tlAddParticipant(_hLG,0,0);                                              \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVETHREAD(_hLG,_ret)                                                                               \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);             \
                                    tlRemoveParticipant(_hLG);                                               \
                                    return(_ret);                                                            \
                                 }

#define LEAVETHREADVOID(_hLG)                                                                                \
                                     tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);            \
                                     tlRemoveParticipant(_hLG);                                              \
                                     return;                                                                 \
                                 }


// Macro to report variation PASS/FAIL statistic (based on an expression)
//
#define THPRINTF                tlLog
#define TESTRESULT(expr,msg)    (expr) ? tlLog(L_TESTPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg)
#define TESTFAIL(msg)           TESTSEV2(msg)
#define TESTSEV1(msg)           tlLog(L_TESTFAIL ,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV2(msg)           tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV3(msg)           tlLog(L_TESTFAIL3,TEXT("%s"),(LPTSTR)msg);
#define TESTPASS(msg)           tlLog(L_TESTPASS ,TEXT("%s"),(LPTSTR)msg);
#define TESTABORT(msg)          tlLog(L_TESTABORT,TEXT("%s"),(LPTSTR)msg);
#define TESTWARN(expr,msg)      if(expr) tlLog(L_TESTWARN,TEXT("%s"),(LPTSTR)msg);
#define TESTBLOCK(expr,msg)     if(expr) tlLog(L_TESTBLOCK,TEXT("%s"),(LPTSTR)msg);

#define VARRESULT(expr,msg)    (expr) ? tlLog(L_VARPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg)
#define VARFAIL(msg)           VARSEV2(msg)
#define VARSEV1(msg)           tlLog(L_VARFAIL ,TEXT("%s"),(LPTSTR)msg);
#define VARSEV2(msg)           tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg);
#define VARSEV3(msg)           tlLog(L_VARFAIL3,TEXT("%s"),(LPTSTR)msg);
#define VARPASS(msg)           tlLog(L_VARPASS ,TEXT("%s"),(LPTSTR)msg);
#define VARABORT(msg)          tlLog(L_VARABORT,TEXT("%s"),(LPTSTR)msg);
#define VARWARN(expr,msg)      if(expr) tlLog(L_VARWARN,TEXT("%s"),(LPTSTR)msg);
#define VARBLOCK(expr,msg)     if(expr) tlLog(L_VARBLOCK,TEXT("%s"),(LPTSTR)msg);


#define VAR_SI          0x01                                 // Ship Issue
#define VAR_NSI         0x02                                 // Non-ship Issue
#define VAR_LI          0x03                                 // Less Important
#define VAR_ISSUE_MASK  0x03                                 // To get ship-issue bits only
#define VAR_TIMEABLE    0x04                                 // Var. used in timing suites
#define CORE_API        0x08                                 // API is in most used list
#define CORE_SI         (CORE_API | VAR_TIMEABLE | VAR_SI )  //
#define CORE_NSI        (CORE_API | VAR_TIMEABLE | VAR_NSI)  //
#define NONCORE_SI      (VAR_TIMEABLE | VAR_SI )             //
#define NONCORE_NSI     (VAR_TIMEABLE | VAR_NSI)             //



// CALLTREE Macros
//   These macros are useful for bracketing function-calls.
//
#define ENTER(_hLG,_szNM) {                                                                 \
                              LPTSTR _lpFN = _szNM;                                         \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVE(_hLG,_ret)                                                                    \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return(_ret);                                                 \
                          }

#define LEAVEVOID(_hLG)                                                                     \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return;                                                       \
                          }

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\readhid\readhid.c ===
#include <stdio.h>
#include <windows.h>
#include <basetyps.h>
#include <stdlib.h>
#include <string.h>
#include <wtypes.h>
#include <wtypes.h>
#include "hidsdi.h"
#include  "hid.h"

#define INSTRUCTIONS "\nCommands:\n" \
"\t?,h Display this message\n" \
"\t<N> Enter device number \n" \
"\tL LOOP read \n" \
"\tx exit\n"

#define PROMPT "Command!>"
void PrintDeviceinfo(PHID_DEVICE HidDevices, LONG ulCount);

int __cdecl main(int argc, char **argv)
{
    PHID_DEVICE HidDevices, pWalk;
    LONG ulCount;
    BOOL bReturn, bDone, bOK;
    int uiLoop;
    PHID_DEVICE pDevice;
    PHID_DATA pData;
    unsigned  uLoop;
    char sz[256], cCode;
    int i;
    DWORD dwDelay=100;
    
    bDone = FALSE;
    bReturn=FindKnownHidDevices(&HidDevices,&ulCount);
    printf("\n");
    if(argc > 1)
        dwDelay = atoi(argv[1]);
    if(!bReturn)
    {
      printf("Error FindKnownHidDevices returned FALSE\n");
      exit(0);
    }
    
    pDevice = HidDevices;
    if(!pDevice){
        printf("Hid Devices are not availabel\n");
        exit(0);
    }
    PrintDeviceinfo(HidDevices, ulCount);

    printf (INSTRUCTIONS);

    while (!bDone) {
        printf (PROMPT);
        if (gets (sz) == NULL) {
            sz[0] = 'x';
            sz[1] = '\0';
        }
        cCode = sz[0];    // if user types a blank before the command, too bad

        switch (cCode) {
        case 'h':
        case '?':
            printf (INSTRUCTIONS);
            break;
        case '0': case '1': case '2': case '3': 
        case '4': case '5': case '6' : case '7': 
        case '8': case '9':{
            if( cCode - '0' >= ulCount ) {
                printf("Error invalid input try again\n");
                continue;
            }
            pDevice = HidDevices + cCode - '0' ;
            Read(pDevice); 
            pData=pDevice->InputData;

            for(uLoop=0;uLoop<pDevice->InputDataLength;uLoop++)
            {
                ReportToString(pData);
                pData++;
            } /*end for*/

            break;
       }
       case 'L': // loop read 
            printf ("Loop read device %d\n", pDevice->HidDevice);
            Sleep(1000);
			for (i = 0; i < 1000; i++) {
                if(!Read(pDevice))
                    // printf("Read returned false\n");
                pData=pDevice->InputData;
                printf("-------------------------------------------\n");
                for(uLoop=0;uLoop<pDevice->InputDataLength;uLoop++)
                {
                    ReportToString(pData);
                    pData++;
                } /*end for*/
				Sleep(dwDelay);
			}
			break;

        case 'x': // done
            bDone = TRUE;
            break;

        default:
            printf ("Huh? >%s<\n", sz);
            printf (INSTRUCTIONS);
            break;
        }
    } // end of while
    pWalk= HidDevices;
    for(uiLoop=0;uiLoop<ulCount;uiLoop++,pWalk++)
        CloseHandle(pWalk->HidDevice);
    return 0;
}

void
PrintDeviceinfo(
    PHID_DEVICE HidDevices, 
    LONG ulCount
    )
{
    PHID_DEVICE pWalk;
    LONG uiLoop, i, num;
    PHIDP_VALUE_CAPS pValue;
    PHIDP_BUTTON_CAPS pButton;

    pWalk=HidDevices;
    for(uiLoop=0;uiLoop<ulCount;uiLoop++, pWalk++)
    {
        if(pWalk->Caps.UsagePage == HID_USAGE_PAGE_GENERIC) {
            switch(pWalk->Caps.Usage){
            case HID_USAGE_GENERIC_POINTER:
                printf("Device (%d) Pointer", uiLoop);break;
            case HID_USAGE_GENERIC_MOUSE:
                printf("Device (%d) Mouse", uiLoop);break;
            case HID_USAGE_GENERIC_PEN:
                printf("Device (%d) PEN", uiLoop);break;
            case HID_USAGE_GENERIC_JOYSTICK:
                printf("Device (%d) Joystick", uiLoop);break;
            case HID_USAGE_GENERIC_GAMEPAD:
                printf("Device (%d) GamePad", uiLoop);break;
            case HID_USAGE_GENERIC_KEYBOARD :
                printf("Device (%d) Keyboard", uiLoop);break;
            case HID_USAGE_GENERIC_KEYPAD :
                printf("Device (%d) Keypad", uiLoop);break;
            case HID_USAGE_GENERIC_STYLUS2:
                printf("Device (%d) Stylus2", uiLoop);break;
            case HID_USAGE_GENERIC_PUCK :
                printf("Device (%d) Pointer", uiLoop);break;
            case HID_USAGE_GENERIC_SYSTEM_CTL :
                printf("Device (%d) System Control", uiLoop);break;
            default: goto PRN; 
            }// end of switch
        }
        else {
        PRN:        printf("Device (%d) UsagePage:0%x  Usage:0%x",
    	        uiLoop,pWalk->Caps.UsagePage,pWalk->Caps.Usage);
        }
        //pValue = pWalk->InputValueCaps;

        if(pWalk->Caps.NumberInputButtonCaps){
            pButton = pWalk->InputButtonCaps;
            for(num=0,i=0;i<pWalk->Caps.NumberInputButtonCaps;i++,pButton++)
            {
                num += (pButton->Range.UsageMax - 
                                        pButton->Range.UsageMin + 1);
            }
            printf("\tNumInpBut(%d):%d",pWalk->Caps.NumberInputButtonCaps, num);
        }
        if(pWalk->Caps.NumberInputValueCaps){
            printf("\tInpValCaps:%d",pWalk->Caps.NumberInputValueCaps);
        }

        if(pWalk->Caps.NumberOutputButtonCaps){
            pButton = pWalk->OutputButtonCaps;
            for(num=0,i=0;i<pWalk->Caps.NumberOutputButtonCaps;i++,pButton++)
            {
                num += (pButton->Range.UsageMax - 
                                        pButton->Range.UsageMin + 1);
            }
            printf("\tNumOutBut(%d):%d",pWalk->Caps.NumberOutputButtonCaps, num);
        }
        if(pWalk->Caps.NumberOutputValueCaps){
            printf("\tOutButCaps:%d\n",pWalk->Caps.NumberOutputValueCaps);
        }

        if(pWalk->Caps.NumberFeatureButtonCaps){
            pButton = pWalk->FeatureButtonCaps;
            for(num=0,i=0;i<pWalk->Caps.NumberFeatureButtonCaps;i++,pButton++)
            {
                num += (pButton->Range.UsageMax - 
                                        pButton->Range.UsageMin + 1);
            }
            printf("\tNumFeatBut(%d):%d",pWalk->Caps.NumberFeatureButtonCaps, num);
        }
        if(pWalk->Caps.NumberFeatureValueCaps){
            printf("\tFeatButCaps:%d\n",pWalk->Caps.NumberFeatureValueCaps);
        }
        printf("\n");
    } /*end for*/

} 


BOOLEAN
FindKnownHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   )
/*++
Routine Description:
   Do the required PnP things in order to find, the all the HID devices in
   the system at this time.
--*/
{
   HDEVINFO                 hardwareDeviceInfo;
   SP_DEVICE_INTERFACE_DATA deviceInfoData;
   ULONG                    i;
   BOOL                  done;
   PHID_DEVICE              hidDeviceInst;
   GUID                     hidGuid;

   HidD_GetHidGuid (&hidGuid);

   *HidDevices = NULL;
   *NumberDevices = 0;

   //
   // Open a handle to the plug and play dev node.
   //
   hardwareDeviceInfo = SetupDiGetClassDevs (
                           &hidGuid,
                           NULL, // Define no enumerator (global)
                           NULL, // Define no
                           (DIGCF_PRESENT | // Only Devices present
                            DIGCF_DEVICEINTERFACE)); // Function class devices.

   //
   // Take a wild guess to start
   //
   *NumberDevices = 4;
   done = FALSE;
   deviceInfoData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

   i=0;
   while (!done) {
      *NumberDevices *= 2;

      if (*HidDevices) {
         *HidDevices =
               realloc (*HidDevices, (*NumberDevices * sizeof (HID_DEVICE)));
      } else {
         *HidDevices = calloc (*NumberDevices, sizeof (HID_DEVICE));
      }

      if (NULL == *HidDevices) {
         SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
         return FALSE;
      }

      hidDeviceInst = *HidDevices + i;

      for (; i < *NumberDevices; i++, hidDeviceInst++) {
         if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                          0, // No care about specific PDOs
                                          &hidGuid,
                                          i,
                                          &deviceInfoData)) {

            OpenHidDevice (hardwareDeviceInfo, &deviceInfoData, hidDeviceInst);

         } else {
            if (ERROR_NO_MORE_ITEMS == GetLastError()) {
               done = TRUE;
               break;
            }
         }
      }
   }

   *NumberDevices = i;

   SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
   return TRUE;
}


VOID
ReportToString(
   PHID_DATA pData
   )
{
        PUSAGE  pUsage;
        ULONG   i;

        if (pData->IsButtonData && pData->UsagePage == HID_USAGE_PAGE_BUTTON )
        {
                            printf (" Buttons        :");
                for (i=0, pUsage = pData->ButtonData.Usages;
                     i < pData->ButtonData.MaxUsageLength;
                         i++, pUsage++) {
                        if (0 == *pUsage) {
                                break; // A usage of zero is a non button.
                        }
                        printf (" 0x%x", *pUsage);
                }
                printf("\n");
        }
        else
        {       
            switch(pData->UsagePage) {
                case HID_USAGE_PAGE_GENERIC :
                case HID_USAGE_PAGE_VEHICLE :
                    switch(pData->ValueData.Usage) {
                        case HID_USAGE_VEHICLE_THROTTLE:
                            printf(" THROTTLE(%4d) :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        case HID_USAGE_VEHICLE_RUDDER:
                            printf(" RUDDER(%4d)   :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        case HID_USAGE_GENERIC_X:
                            printf(" X(%4d)        :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        case HID_USAGE_GENERIC_Y:
                            printf(" Y(%4d)        :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        case HID_USAGE_GENERIC_Z:
                            printf(" Z(%4d)        :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        case HID_USAGE_GENERIC_RX:
                            printf(" RX(%4d)       :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        case HID_USAGE_GENERIC_RY:
                            printf(" RY(%4d)       :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        case HID_USAGE_GENERIC_RZ:
                            printf(" RZ(%4d)       :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        case HID_USAGE_GENERIC_SLIDER:
                            printf(" SLIDDER(%4d)  :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        case HID_USAGE_GENERIC_DIAL:
                            printf(" DIAL(%4d)     :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        case HID_USAGE_GENERIC_WHEEL:
                            printf(" WHEEL(%4d)    :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;

                        case HID_USAGE_GENERIC_HATSWITCH:
                            printf(" HATSWITCH(%4d):%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        default:
                                goto END;
                                break;
                    }// end of switch
                    break;
                case HID_USAGE_PAGE_KEYBOARD:
                    switch(pData->ValueData.Usage) {
                        case HID_USAGE_GENERIC_KEYBOARD:
                            printf(" KEYBOARD(%4d) :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        case HID_USAGE_GENERIC_KEYPAD:
                            printf(" KEYPAD(%4d)   :%4d\n",
                                    pData->ValueData.ScaledValue,
                                    pData->ValueData.Value);
                            break;
                        default:
                                goto END;
                                break;
                    }// end of switch

                default:
END:                     printf ("Usage Page: 0x%x, Usage: 0x%x, Scaled: %d Value:%d\n",
                              pData->UsagePage,
                              pData->ValueData.Usage,
                              pData->ValueData.ScaledValue,
                              pData->ValueData.Value);
            }//end of switch
    }
}


BOOLEAN
Read (
   PHID_DEVICE    HidDevice
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, obtain a read report and unpack the values
   into to InputData array.
--*/
{
   DWORD    bytesRead;

   if (!ReadFile (HidDevice->HidDevice,
                  HidDevice->InputReportBuffer,
                  HidDevice->Caps.InputReportByteLength,
                  &bytesRead,
                  NULL)) { // No overlapped structure.  HidClass buffers for us.
      return FALSE;
   }

   ASSERT (bytesRead == hidDevice->Caps.InputReportByteLength);

   return UnpackReport (HidDevice->InputReportBuffer,
                        HidDevice->Caps.InputReportByteLength,
                        HidP_Input,
                        HidDevice->InputData,
                        HidDevice->InputDataLength,
                        HidDevice->Ppd);
}

BOOL
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   )
/*++
Routine Description:

--*/
{
   ULONG       numUsages; // Number of usages returned from GetUsages.
   ULONG       i;

   for (i = 0; i < DataLength; i++, Data++) {
      if (Data->IsButtonData) {
         numUsages = Data->ButtonData.MaxUsageLength;
         Data->Status = HidP_GetUsages (
                           ReportType,
                           Data->UsagePage,
                           0, // All collections
                           Data->ButtonData.Usages,
                           &numUsages,
                           Ppd,
                           ReportBuffer,
                           ReportBufferLength);
         //
         // Get usages writes the list of usages into the buffer
         // Data->ButtonData.Usages newUsage is set to the number of usages
         // written into this array.
         // We assume that there will not be a usage of zero.
         // (None have been defined to date.)
         // So lets assume that a zero indicates an end of the list of usages.
         //

         if (numUsages < Data->ButtonData.MaxUsageLength) {
            Data->ButtonData.Usages[numUsages] = 0;
         }

      } else {
         Data->Status = HidP_GetUsageValue (
                              ReportType,
                              Data->UsagePage,
                              0, // All Collections.
                              Data->ValueData.Usage,
                              &Data->ValueData.Value,
                              Ppd,
                              ReportBuffer,
                              ReportBufferLength);

         Data->Status = HidP_GetScaledUsageValue (
                              ReportType,
                              Data->UsagePage,
                              0, // All Collections.
                              Data->ValueData.Usage,
                              &Data->ValueData.ScaledValue,
                              Ppd,
                              ReportBuffer,
                              ReportBufferLength);
      }
   }
   return (HIDP_STATUS_SUCCESS == Data->Status);
}



BOOLEAN
OpenHidDevice (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
    IN OUT   PHID_DEVICE                 HidDevice
    )
/*++
RoutineDescription:
    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific hid device,
    open that device and fill in all the relivant information in the given
    HID_DEVICE structure.

    return if the open and initialization was successfull or not.

--*/
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA     functionClassDeviceData = NULL;
    ULONG                                predictedLength = 0;
    ULONG                                requiredLength = 0;
    ULONG                                i;
    ULONG                                numValues;
    USHORT                               numCaps;
    PHIDP_BUTTON_CAPS                    buttonCaps;
    PHIDP_VALUE_CAPS                     valueCaps;
    PHID_DATA                            data;
    USAGE                                usage;
    static ULONG                         NumberDevices = 0;

    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //
    SetupDiGetDeviceInterfaceDetail (
            HardwareDeviceInfo,
            DeviceInfoData,
            NULL, // probing so no output buffer yet
            0, // probing so output buffer length of zero
            &requiredLength,
            NULL); // not interested in the specific dev-node


    predictedLength = requiredLength;

    functionClassDeviceData = malloc (predictedLength);
    functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);

    //
    // Retrieve the information from Plug and Play.
    //
    if (! SetupDiGetDeviceInterfaceDetail (
               HardwareDeviceInfo,
               DeviceInfoData,
               functionClassDeviceData,
               predictedLength,
               &requiredLength,
               NULL)) {
        return FALSE;
    }
    
    //printf("\nDevicePath of %d HID device: %s\n", NumberDevices, 
    //                    functionClassDeviceData->DevicePath);
    HidDevice->HidDevice = CreateFile (
                              functionClassDeviceData->DevicePath,
                              GENERIC_READ | GENERIC_WRITE,
                              0, // FILE_SHARE_READ | FILE_SHARE_WRITE
                              NULL, // no SECURITY_ATTRIBUTES structure
                              OPEN_EXISTING, // No special create flags
                              0, // No special attributes
                              NULL); // No template file

    if (INVALID_HANDLE_VALUE == HidDevice->HidDevice) {
        return FALSE;
    }
    
    if (!HidD_GetPreparsedData (HidDevice->HidDevice, &HidDevice->Ppd)) {
        return FALSE;
    }

    if (!HidP_GetCaps (HidDevice->Ppd, &HidDevice->Caps)) {
        HidD_FreePreparsedData (HidDevice->Ppd);
        return FALSE;
    }

    NumberDevices++;
    //
    // At this point the client has a choise.  It may chose to look at the
    // Usage and Page of the top level collection found in the HIDP_CAPS
    // structure.  In this way it could just use the usages it knows about.
    // If either HidP_GetUsages or HidP_GetUsageValue return an error then
    // that particular usage does not exist in the report.
    // This is most likely the preferred method as the application can only
    // use usages of which it already knows.
    // In this case the app need not even call GetButtonCaps or GetValueCaps.
    //
    // In this example, however, we look for all of the usages in the device.
    //



    


    //
    // setup Input Data buffers.
    //

    //
    // Allocate memory to hold on input report
    //

    HidDevice->InputReportBuffer = (PCHAR)
        calloc (HidDevice->Caps.InputReportByteLength, sizeof (CHAR));


    //
    // Allocate memory to hold the button and value capabilities.
    // NumberXXCaps is in terms of array elements.
    //
    HidDevice->InputButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberInputButtonCaps, sizeof (HIDP_BUTTON_CAPS));
    HidDevice->InputValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberInputValueCaps, sizeof (HIDP_VALUE_CAPS));

    //
    // Have the HidP_X functions fill in the capability structure arrays.
    //
    numCaps = HidDevice->Caps.NumberInputButtonCaps;
    HidP_GetButtonCaps (HidP_Input,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberInputValueCaps;
    HidP_GetValueCaps (HidP_Input,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    //
    // Depending on the device, some value caps structures may represent more
    // than one value.  (A range).  In the interest of being verbose, over
    // efficient we will expand these so that we have one and only one
    // struct _HID_DATA for each value.
    //
    // To do this we need to count up the total number of values are listed
    // in the value caps structure.  For each element in the array we test
    // for range if it is a range then UsageMax and UsageMin describe the
    // usages for this range INCLUSIVE.
    //
    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberInputValueCaps; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            numValues += valueCaps->Range.UsageMax - valueCaps->Range.UsageMin + 1;
        } else {
            numValues++;
        }
    }
    valueCaps = HidDevice->InputValueCaps;


    //
    // Allocate a buffer to hold the struct _HID_DATA structures.
    // One element for each set of buttons, and one element for each value
    // found.
    //
    HidDevice->InputDataLength = HidDevice->Caps.NumberInputButtonCaps
                               + numValues;
    HidDevice->InputData = data = (PHID_DATA)
        calloc (HidDevice->InputDataLength, sizeof (HID_DATA));


    //
    // Fill in the button data
    //
    for (i = 0;
         i < HidDevice->Caps.NumberInputButtonCaps;
         i++, data++, buttonCaps++) {

        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Input,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
            calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));
    }

    //
    // Fill in the value data
    //
    for (i = 0; i < numValues; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) {

                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data++;
            }
        } else {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data++;
        }
    }
    //return TRUE; // no need to get other info
    //
    // setup Output Data buffers.
    //
    HidDevice->OutputReportBuffer = (PCHAR)
        calloc (HidDevice->Caps.OutputReportByteLength, sizeof (CHAR));

    HidDevice->OutputButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberOutputButtonCaps, sizeof (HIDP_BUTTON_CAPS));
    HidDevice->OutputValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberOutputValueCaps, sizeof (HIDP_VALUE_CAPS));

    numCaps = HidDevice->Caps.NumberOutputButtonCaps;
    HidP_GetButtonCaps (HidP_Output,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberOutputValueCaps;
    HidP_GetValueCaps (HidP_Output,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberOutputValueCaps; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            numValues += valueCaps->Range.UsageMax
                       - valueCaps->Range.UsageMin + 1;
        } else {
            numValues++;
        }
    }
    valueCaps = HidDevice->OutputValueCaps;

    HidDevice->OutputDataLength = HidDevice->Caps.NumberOutputButtonCaps
                                + numValues;
    HidDevice->OutputData = data = (PHID_DATA)
       calloc (HidDevice->OutputDataLength, sizeof (HID_DATA));

    for (i = 0;
         i < HidDevice->Caps.NumberOutputButtonCaps;
         i++, data++, buttonCaps++) {

        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                   HidP_Output,
                                                   buttonCaps->UsagePage,
                                                   HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
            calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));
    }

    for (i = 0; i < numValues; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) {

                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data++;
            }
        } else {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data++;
        }
    }

    //
    // setup Feature Data buffers.
    //

    HidDevice->FeatureReportBuffer = (PCHAR)
           calloc (HidDevice->Caps.FeatureReportByteLength, sizeof (CHAR));

    HidDevice->FeatureButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberFeatureButtonCaps, sizeof (HIDP_BUTTON_CAPS));
    HidDevice->FeatureValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberFeatureValueCaps, sizeof (HIDP_VALUE_CAPS));

    numCaps = HidDevice->Caps.NumberFeatureButtonCaps;
    HidP_GetButtonCaps (HidP_Feature,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberFeatureValueCaps;
    HidP_GetValueCaps (HidP_Feature,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberFeatureValueCaps; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            numValues += valueCaps->Range.UsageMax
                       - valueCaps->Range.UsageMin + 1;
        } else {
            numValues++;
        }
    }
    valueCaps = HidDevice->FeatureValueCaps;

    HidDevice->FeatureDataLength = HidDevice->Caps.NumberFeatureButtonCaps
                                 + numValues;
    HidDevice->FeatureData = data = (PHID_DATA)
        calloc (HidDevice->FeatureDataLength, sizeof (HID_DATA));

    for (i = 0;
         i < HidDevice->Caps.NumberFeatureButtonCaps;
         i++, data++, buttonCaps++) {

        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Feature,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
             calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));
    }

    for (i = 0; i < numValues; i++, valueCaps++) {
        if (valueCaps->IsRange) {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) {

                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data++;
            }
        } else {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data++;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hid1394\debug.c ===
/*
 *************************************************************************
 *  File:       DEBUG.C
 *
 *  Module:     HID1394.SYS
 *              HID (Human Input Device) minidriver for IEEE 1394 devices.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <hidport.h>
#include <1394.h>

#include "hid1394.h"
#include "debug.h"


#if DBG
    BOOLEAN dbgVerbose = FALSE;
    BOOLEAN dbgTrapOnWarn = FALSE;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\filter\hidvalid\validate.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    VALIDATE.H

Abstract:

    This module contains the PRIVATE (driver-only) definitions for the
    code that implements the validate lower level filter driver.

Environment:

    Kernel mode

Revision History:

    Feb-97 : created by Kenneth Ray

--*/


#ifndef _VALIDATE_H
#define _VALIDATE_H

#define HIDV_POOL_TAG (ULONG) 'FdiH'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, HIDV_POOL_TAG);
// ExAllocatePool is only called in the descript.c and hidparse.c code.
// all other modules are linked into the user DLL.  They cannot allocate any
// memory.


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect



#if DBG
#define HidV_KdPrint(_x_) \
               DbgPrint ("HidValidate.SYS: "); \
               DbgPrint _x_;

#define TRAP() DbgBreakPoint()

#else
#define HidV_KdPrint(_x_)
#define TRAP()

#endif

#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#define MAX(a,b) (((a) < (b)) ? (b) : (a))

//
// A device extension for the controling device object
//
typedef struct _HIDV_CONTROL_DATA
{
    LIST_ENTRY          HidDevices; // A list of the Device device extensions
    ULONG               NumHidDevices;
    KSPIN_LOCK          Spin; // a sync spin lock for this data.
} HIDV_CONTROL_DATA, *PHIDV_CONTROL_DATA;


//
// A device extension for the device object placed into the attachment
// chain.
//

typedef struct _HIDV_HID_DATA
{
    BOOLEAN                 Started; // This device has been started
    BOOLEAN                 Removed; // This device has been removed
    UCHAR                   Reseved2[2];

    PDEVICE_OBJECT          Self; // a back pointer to the actual DeviceObject
    PDEVICE_OBJECT          PDO; // The PDO to which this filter is attached.
    PDEVICE_OBJECT          TopOfStack; // The top of the device stack just
                                    // beneath this filter device object.
    LIST_ENTRY              List; // A link point for a list of hid device extensions

    KEVENT                  StartEvent; // an event to sync the start IRP.
    KEVENT                  RemoveEvent; // an event to synch outstandIO to zero
    ULONG                   OutstandingIO; // 1 biased count of reasons why
                                           // this object should stick around

    PHIDP_PREPARSED_DATA    Ppd;
    HIDP_CAPS               Caps;   // The capabilities of this hid device
    PHIDP_BUTTON_CAPS       InputButtonCaps; // the array of button caps
    PHIDP_VALUE_CAPS        InputValueCaps;  // the array of value caps
    PHIDP_BUTTON_CAPS       OutputButtonCaps; // the array of button caps
    PHIDP_VALUE_CAPS        OutputValueCaps;  // the array of value caps
    PHIDP_BUTTON_CAPS       FeatureButtonCaps; // the array of button caps
    PHIDP_VALUE_CAPS        FeatureValueCaps;  // the array of value caps

}  HIDV_HID_DATA, *PHIDV_HID_DATA;

struct _HIDV_GLOBALS {
    PDEVICE_OBJECT          ControlObject;
};

extern struct _HIDV_GLOBALS Global;


NTSTATUS
HidV_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_Pass (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_Ioctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_Read (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_Write (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );


VOID
HidV_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
HidV_StartDevice (
    IN PHIDV_HID_DATA   HidDevice
    );


NTSTATUS
HidV_StopDevice (
    IN PHIDV_HID_DATA HidDevice
    );


NTSTATUS
HidV_CallHidClass(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      ULONG           Ioctl,
    IN OUT  PVOID           InputBuffer,
    IN      ULONG           InputBufferLength,
    IN OUT  PVOID           OutputBuffer,
    IN      ULONG           OutputBufferLength
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\client\readhid\hid.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    hidexe.h

Abstract:

    This module contains the declarations and definitions for use with the
    hid user more client sample driver.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#ifndef HIDEXE_H
#define HIDEXE_H

#include "hidsdi.h"
#include "setupapi.h"

#define ASSERT(x)

//
// A structure to hold the steady state data received from the hid device.
// Each time a read packet is received we fill in this structure.
// Each time we wish to write to a hid device we fill in this structure.
// This structure is here only for convenience.  Most real applications will
// have a more efficient way of moving the hid data to the read, write, and
// feature routines.
//
typedef struct _HID_DATA {
   BOOLEAN     IsButtonData;
   UCHAR       Reserved;
   USAGE       UsagePage; // The usage page for which we are looking.
   ULONG       Status; // The last status returned from the accessor function
                       // when updating this field.
   union {
      struct {
         ULONG       MaxUsageLength; // Usages buffer length.
         PUSAGE      Usages; // list of usages (buttons ``down'' on the device.

      } ButtonData;
      struct {
         USAGE       Usage; // The usage describing this value;
         USHORT      Reserved;

         ULONG       Value;
         LONG        ScaledValue;
      } ValueData;
   };
} HID_DATA, *PHID_DATA;

typedef struct _HID_DEVICE {
   HANDLE               HidDevice; // A file handle to the hid device.
   PHIDP_PREPARSED_DATA Ppd; // The opaque parser info describing this device
   HIDP_CAPS            Caps; // The Capabilities of this hid device.

   PCHAR                InputReportBuffer;
   PHID_DATA            InputData; // array of hid data structures
   ULONG                InputDataLength; // Num elements in this array.
   PHIDP_BUTTON_CAPS    InputButtonCaps;
   PHIDP_VALUE_CAPS     InputValueCaps;

   PCHAR                OutputReportBuffer;
   PHID_DATA            OutputData;
   ULONG                OutputDataLength;
   PHIDP_BUTTON_CAPS    OutputButtonCaps;
   PHIDP_VALUE_CAPS     OutputValueCaps;

   PCHAR                FeatureReportBuffer;
   PHID_DATA            FeatureData;
   ULONG                FeatureDataLength;
   PHIDP_BUTTON_CAPS    FeatureButtonCaps;
   PHIDP_VALUE_CAPS     FeatureValueCaps;
} HID_DEVICE, *PHID_DEVICE;



BOOLEAN
FindKnownHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   );

BOOLEAN
CloseHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   );

BOOLEAN
Read (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
Write (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
SetFeature (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
GetFeature (
   PHID_DEVICE    HidDevice
   );


BOOLEAN
OpenHidDevice (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
    IN OUT   PHID_DEVICE                 HidDevice
    );

VOID
ReportToString(
   PHID_DATA pData
   );

BOOL
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hid1394\debug.h ===
/*
 *************************************************************************
 *  File:       DEBUG.H
 *
 *  Module:     HID1394.SYS
 *              HID (Human Input Device) minidriver for IEEE 1394 devices.
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */


#define BAD_POINTER ((PVOID)0xFFFFFF00)

#if DBG
    extern BOOLEAN dbgVerbose;
    extern BOOLEAN dbgTrapOnWarn;

    #define DBGBREAK                                        \
        {                                               \
            DbgPrint("'HID1394> Code coverage trap: file %s, line %d \n",  __FILE__, __LINE__ ); \
            DbgBreakPoint();                            \
        }
    #define DBGWARN(args_in_parens)                                \
        {                                               \
            DbgPrint("'HID1394> *** WARNING *** (file %s, line %d)\n", __FILE__, __LINE__ ); \
            DbgPrint("'    > "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            if (dbgTrapOnWarn){ \
                DbgBreakPoint();                            \
            } \
        }
    #define DBGERR(args_in_parens)                                \
        {                                               \
            DbgPrint("'HID1394> *** ERROR *** (file %s, line %d)\n", __FILE__, __LINE__ ); \
            DbgPrint("'    > "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            DbgBreakPoint();                            \
        }
    #define DBGOUT(args_in_parens)                                \
        {                                               \
            DbgPrint("'HID1394> "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
        }
#else
    #define DBGBREAK
    #define DBGWARN(args_in_parens)                                
    #define DBGERR(args_in_parens)                                
    #define DBGOUT(args_in_parens)                                
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\filter\hidvalid\validate.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    validate.c

Abstract: Human Input Device (HID) lower filter driver

Author:

    Kenneth D. Ray

Environment:

    Kernel mode

Revision History:


--*/
#include <WDM.H>
#include "hidusage.h"
#include "hidpi.h"
#include "hidclass.h"
#include "validate.H"
#include "validio.h"

struct _HIDV_GLOBALS Global;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    registryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_OBJECT      deviceObject;
    UNICODE_STRING      uniNtNameString;
    UNICODE_STRING      uniWin32NameString;
    PHIDV_CONTROL_DATA  deviceData;
    ULONG               i;
    PDRIVER_DISPATCH  * dispatch;

    UNREFERENCED_PARAMETER (RegistryPath);
    TRAP ();

    HidV_KdPrint (("Entered the Driver Entry\n"));
    RtlInitUnicodeString (&uniNtNameString, HIDV_FILTER_NTNAME);

    //
    // Create a controling device object.  All control commands to the
    // filter driver come via IOCTL's to this device object.  It lives
    // for the lifetime of the filter driver.
    //

    status = IoCreateDevice (
                 DriverObject,
                 sizeof (HIDV_CONTROL_DATA),
                 &uniNtNameString,
                 FILE_DEVICE_UNKNOWN,
                 0,                     // No standard device characteristics
                 FALSE,                 // This isn't an exclusive device
                 &deviceObject
                 );


    if(!NT_SUCCESS (status)) {
        HidV_KdPrint (("Couldn't create the device\n"));
        return status;
    }
    //
    // Create W32 symbolic link name
    //
    RtlInitUnicodeString (&uniWin32NameString, HIDV_FILTER_SYMNAME);
    status = IoCreateSymbolicLink (&uniWin32NameString, &uniNtNameString);

    if (!NT_SUCCESS(status)) {
        HidV_KdPrint (("Couldn't create the symbolic link\n"));
        IoDeleteDevice (DriverObject->DeviceObject);
        return status;
    }

    HidV_KdPrint (("Initializing\n"));

    deviceData = (PHIDV_CONTROL_DATA) deviceObject->DeviceExtension;
    InitializeListHead (&deviceData->HidDevices);
    KeInitializeSpinLock (&deviceData->Spin);
    deviceData->NumHidDevices = 0;

    Global.ControlObject = deviceObject;

    //
    // Create dispatch points
    //

    for (i=0, dispatch = DriverObject->MajorFunction;
         i <= IRP_MJ_MAXIMUM_FUNCTION;
         i++, dispatch++) {

        *dispatch = HidV_Pass;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = HidV_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = HidV_CreateClose;
//    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = HidV_Ioctl;
//    DriverObject->MajorFunction[IRP_MJ_READ]           = HidV_Read;
//    DriverObject->MajorFunction[IRP_MJ_WRITE]          = HidV_Write;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = HidV_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = HidV_Power;
    DriverObject->DriverExtension->AddDevice           = HidV_AddDevice;
    DriverObject->DriverUnload                         = HidV_Unload;

    return status;
}


NTSTATUS
HidV_Pass (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The default dispatch routine.  If this filter does not recognize the
    IRP, then it should send it down, unmodified.
    No completion routine is required.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PHIDV_HID_DATA  hidData;
    NTSTATUS        status;

    hidData = (PHIDV_HID_DATA) DeviceObject->DeviceExtension;

    TRAP();

    if(DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }

    //
    // This IRP was sent to the filter driver.
    // Since we do not know what to do with the IRP, we should pass
    // it on along down the stack.
    //

    HidV_KdPrint (("Passing unknown irp 0x%x, 0x%x",
                   IoGetCurrentIrpStackLocation(Irp)->MajorFunction,
                   IoGetCurrentIrpStackLocation(Irp)->MinorFunction));

    InterlockedIncrement (&hidData->OutstandingIO);
    if (hidData->Removed) {
        status = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else {
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (hidData->TopOfStack, Irp);
    }

    if (0 == InterlockedDecrement (&hidData->OutstandingIO)) {
        KeSetEvent (&hidData->RemoveEvent, 0, FALSE);
    }
    return status;
}

NTSTATUS
HidV_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Process the Create and close IRPs sent to this device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status = STATUS_SUCCESS;
    PHIDV_HID_DATA      hidData;

    HidV_KdPrint (("Create\n"));

    TRAP();

    stack = IoGetCurrentIrpStackLocation (Irp);
    hidData = (PHIDV_HID_DATA) DeviceObject->DeviceExtension;

    if (DeviceObject == Global.ControlObject) {
        //
        // We allow people to blindly access our control object.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    }
    //
    // Call the next driver in the routine.  We have no value add
    // for start and stop.
    //
    InterlockedIncrement (&hidData->OutstandingIO);

    if (hidData->Removed) {
        status = (IRP_MJ_CREATE == stack->MajorFunction) ?
                    STATUS_DELETE_PENDING:
                    STATUS_SUCCESS; // aka a close

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else {
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (hidData->TopOfStack, Irp);
    }

    if (0 == InterlockedDecrement (&hidData->OutstandingIO)) {
        KeSetEvent (&hidData->RemoveEvent, 0, FALSE);
    }
    return status;
}

NTSTATUS
HidV_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new PDO, for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY IRPS to the given driver stack,
    UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    DeviceObject - pointer to a device object.

    PhysicalDeviceObject -  pointer to a device object pointer created by the
                            underlying bus driver.

Return Value:

    NT status code.

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_OBJECT          deviceObject = NULL;
    PHIDV_HID_DATA          hidData;
    PHIDV_CONTROL_DATA      controlData;
    KIRQL                   oldIrql;

#define IS_THIS_OUR_DEVICE(DO) TRUE

    TRAP();
    HidV_KdPrint (("AddDevice\n"));

    controlData = (PHIDV_CONTROL_DATA) Global.ControlObject->DeviceExtension;

    //
    // Inquire about this device to see if we really want to filter.
    // Usually this test will not be performed by filter drivers since
    // they will not have registered via INF to load unless they wanted
    // to actually filter the PDO.
    //
    // Remember that you CANNOT send an IRP to the PDO because it has not
    // been started as of yet, but you can make PlugPlay queries to find
    // out things like hardware, compatible ID's, etc.
    // (IoGetDeviceProperty)
    //
    if (!IS_THIS_OUR_DEVICE(deviceObject)) {
        //
        // This is not a device we want to filter.  (Maybe we placed a general
        // entry in the inf file and we are more picky here.)
        //
        // In this case we do not create a device object,
        // and we do not attach.
        //
        // We DO still return status success, otherwise the device node will
        // fail and the device being attached will not function.
        //
        // We must return STATUS_SUCCESS, otherwise this particular device
        // cannot be used by the system
        //

        return STATUS_SUCCESS;
    }

    //
    // Create a filter device object.
    //

    status = IoCreateDevice (DriverObject,
                             sizeof (HIDV_HID_DATA),
                             NULL, // No Name
                             FILE_DEVICE_UNKNOWN,
                             0,
                             FALSE,
                             &deviceObject);

    if (!NT_SUCCESS (status)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //
        return status;
    }

    //
    // Initialize the the device extension.
    //
    hidData = (PHIDV_HID_DATA) deviceObject->DeviceExtension;

    hidData->Started = hidData->Removed = FALSE;
    hidData->Self = deviceObject;
    hidData->PDO = PhysicalDeviceObject;
    hidData->TopOfStack = NULL;
    ExInterlockedInsertHeadList (&controlData->HidDevices,
                                 &hidData->List,
                                 &controlData->Spin);

    KeInitializeEvent(&hidData->RemoveEvent, SynchronizationEvent, FALSE);
    hidData->OutstandingIO = 1; // biassed to 1.  Transition to zero during
                                // remove device means IO is finished.

    hidData->Ppd = NULL;
    hidData->InputButtonCaps = NULL;
    hidData->InputValueCaps = NULL;
    hidData->OutputButtonCaps = NULL;
    hidData->OutputValueCaps = NULL;
    hidData->FeatureButtonCaps = NULL;
    hidData->FeatureValueCaps = NULL;

    //
    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
    //
    hidData->TopOfStack = IoAttachDeviceToDeviceStack (deviceObject,
                                                       PhysicalDeviceObject);
    //
    // if this attachment fails then top of stack will be null.
    // failure for attachment is an indication of a broken plug play system.
    //
    ASSERT (NULL != hidData->TopOfStack);

    return STATUS_SUCCESS;

#undef IS_THIS_OUR_DEVICE
}



VOID
HidV_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PHIDV_CONTROL_DATA  controlData;
    UNICODE_STRING      uniWin32NameString;

    //
    // We should not be unloaded until all the PDOs have been removed from
    // our queue.  The control device object should be the only thing left.
    //
    ASSERT (Global.ControlObject == DriverObject->DeviceObject);
    ASSERT (NULL == Global.ControlObject->NextDevice);
    HidV_KdPrint (("unload\n"));

    //
    // Get rid of our control device object.
    //
    RtlInitUnicodeString (&uniWin32NameString, HIDV_FILTER_SYMNAME);
    IoDeleteSymbolicLink (&uniWin32NameString);
    IoDeleteDevice (DriverObject->DeviceObject);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hid1394\hid.c ===
/*
 *************************************************************************
 *  File:       HID.C
 *
 *  Module:     HID1394.SYS
 *              HID (Human Input Device) minidriver for IEEE 1394 devices.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <hidport.h>
#include <1394.h>

#include "hid1394.h"
#include "debug.h"


#ifdef ALLOC_PRAGMA
	#pragma alloc_text(PAGE, HIDT_GetHidDescriptor)
	#pragma alloc_text(PAGE, HIDT_GetReportDescriptor)
	#pragma alloc_text(PAGE, HIDT_GetStringDescriptor)
	#pragma alloc_text(PAGE, HIDT_GetPhysicalDescriptor)
	#pragma alloc_text(PAGE, HIDT_GetFeature)
	#pragma alloc_text(PAGE, HIDT_SetFeature)
	#pragma alloc_text(PAGE, HIDT_GetDeviceAttributes)
#endif


resetWorkItemContext *resetWorkItemsList = NULL;
KSPIN_LOCK resetWorkItemsListSpinLock;


/*
 ************************************************************
 *  EnqueueResetWorkItem
 ************************************************************
 *
 *  This function must be called with resetWorkItemsListSpinLock held.
 */
VOID EnqueueResetWorkItem(resetWorkItemContext *workItem)
{
    workItem->next = resetWorkItemsList;
    resetWorkItemsList = workItem;
}


/*
 ************************************************************
 *  DequeueResetWorkItemWithIrp
 ************************************************************
 *
 *  Dequeue the workItem with the given IRP
 *  AND mark it as cancelled in case the work item didn't fire yet.
 *
 *
 */
BOOLEAN DequeueResetWorkItemWithIrp(PIRP Irp, BOOLEAN irpWasCancelled)
{
    BOOLEAN didDequeue = FALSE;
    
    if (resetWorkItemsList){
        resetWorkItemContext *removedItem = NULL;

        if (resetWorkItemsList->irpToComplete == Irp){
            removedItem = resetWorkItemsList;
            resetWorkItemsList = resetWorkItemsList->next;
        }
        else {
            resetWorkItemContext *thisWorkItem = resetWorkItemsList;
            while (thisWorkItem->next && (thisWorkItem->next->irpToComplete != Irp)){
                thisWorkItem = thisWorkItem->next;   
            }
            removedItem = thisWorkItem->next;
            if (removedItem){
                thisWorkItem->next = removedItem->next;
            }
        }

        if (removedItem){
            removedItem->next = BAD_POINTER;

            /*
             *  Mark this workItem as cancelled so we won't touch
             *  it's cancelled IRP when the workItem fires.
             */
            if (irpWasCancelled){
                removedItem->irpWasCancelled = TRUE;
                removedItem->irpToComplete = BAD_POINTER;
            }

            didDequeue = TRUE;
        }
    }

    return didDequeue;
}




/*
 ********************************************************************************
 *  HIDT_GetHidDescriptor
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       Free all the allocated resources, etc.
 *
 *   Arguments:
 *
 *       DeviceObject - pointer to a device object.
 *
 *   Return Value:
 *
 *       NT status code.
 *
 */
NTSTATUS HIDT_GetHidDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;

	PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    // BUGBUG FINISH
    ntStatus = STATUS_UNSUCCESSFUL;

    ASSERT(NT_SUCCESS(ntStatus));
    return ntStatus;
}


/*
 ********************************************************************************
 *  HIDT_GetDeviceAttributes
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       Fill in the given struct _HID_DEVICE_ATTRIBUTES
 *
 *   Arguments:
 *
 *       DeviceObject - pointer to a device object.
 *
 *   Return Value:
 *
 *       NT status code.
 *
 */
NTSTATUS HIDT_GetDeviceAttributes(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion)
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PHID_DEVICE_ATTRIBUTES deviceAttributes;

	PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    deviceAttributes = (PHID_DEVICE_ATTRIBUTES) Irp->UserBuffer;

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength >= 
        sizeof (HID_DEVICE_ATTRIBUTES)){ 

        //
        // Report how many bytes were copied
        //
        Irp->IoStatus.Information = sizeof (HID_DEVICE_ATTRIBUTES);

        deviceAttributes->Size = sizeof (HID_DEVICE_ATTRIBUTES);

        // BUGBUG FINISH
        // deviceAttributes->VendorID = deviceExtension->DeviceDescriptor->idVendor;
        // deviceAttributes->ProductID = deviceExtension->DeviceDescriptor->idProduct;
        // deviceAttributes->VersionNumber = deviceExtension->DeviceDescriptor->bcdDevice;

        ntStatus = STATUS_SUCCESS;
    }
    else {
        ntStatus = STATUS_INVALID_BUFFER_SIZE;
    }

    ASSERT(NT_SUCCESS(ntStatus));
    return ntStatus;
}

/*
 ********************************************************************************
 *  HIDT_GetReportDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HIDT_GetReportDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    // BUGBUG FINISH

    return ntStatus;
}


/*
 ********************************************************************************
 *  HIDT_IncrementPendingRequestCount
 ********************************************************************************
 *
 *
 */
NTSTATUS HIDT_IncrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension)
{
    LONG newRequestCount;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    newRequestCount = InterlockedIncrement(&DeviceExtension->NumPendingRequests);

    //
    // Make sure that the device is capable of receiving new requests.
    //
    if (DeviceExtension->DeviceState != DEVICE_STATE_RUNNING) {

        //
        // Device cannot receive any more IOs, decrement back, fail the increment
        //
        HIDT_DecrementPendingRequestCount(DeviceExtension);
        ntStatus = STATUS_NO_SUCH_DEVICE;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HIDT_DecrementPendingRequestCount
 ********************************************************************************
 *
 *
 */
VOID HIDT_DecrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension)
{
    LONG PendingCount;

    ASSERT(DeviceExtension->NumPendingRequests >= 0);

    PendingCount = InterlockedDecrement(&DeviceExtension->NumPendingRequests);
    if (PendingCount < 0){
        
        ASSERT(DeviceExtension->DeviceState != DEVICE_STATE_RUNNING);

        /*
         *  The device state is stopping, and the last outstanding request
         *  has just completed.
         *
         *  Note: RemoveDevice does an extra decrement, so we complete 
         *        the REMOVE IRP on the transition to -1, whether this 
         *        happens in RemoveDevice itself or subsequently while
         *        RemoveDevice is waiting for this event to fire.
         */

        KeSetEvent(&DeviceExtension->AllRequestsCompleteEvent, 0, FALSE);
    }
}




/*
 ********************************************************************************
 *  HIDT_GetPortStatus
 ********************************************************************************
 *
 *
 */
NTSTATUS HIDT_GetPortStatus(IN PDEVICE_OBJECT DeviceObject, IN PULONG PortStatus)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    // BUGBUG FINISH

    return ntStatus;
}



/*
 ********************************************************************************
 *  HIDT_EnableParentPort
 ********************************************************************************
 *
 *
 */
NTSTATUS HIDT_EnableParentPort(IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    // BUGBUG FINISH

    return ntStatus;
}


/*
 ********************************************************************************
 *  HIDT_ResetWorkItem
 ********************************************************************************
 *
 *  Resets the interrupt pipe after a read error is encountered.
 *
 */
NTSTATUS HIDT_ResetWorkItem(IN PVOID Context)
{
    resetWorkItemContext *resetWorkItemObj;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS ntStatus;
    ULONG portStatus;
    BOOLEAN didDequeue;
    KIRQL oldIrql;

    /*
     *  Get the information out of the resetWorkItemContext and free it.
     */
    resetWorkItemObj = (resetWorkItemContext *)Context;
    ASSERT(resetWorkItemObj);
    ASSERT(resetWorkItemObj->sig == RESET_WORK_ITEM_CONTEXT_SIG);

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(resetWorkItemObj->deviceObject);

    if (DEVICE_STATE_RUNNING == DeviceExtension->DeviceState) {
    
        //
        // Check the port state, if it is disabled we will need 
        // to re-enable it
        //
        ntStatus = HIDT_GetPortStatus(resetWorkItemObj->deviceObject, &portStatus);

        if (NT_SUCCESS(ntStatus)) {

            //
            // port is disabled, attempt reset
            //
            HIDT_AbortPendingRequests(resetWorkItemObj->deviceObject);
            
            HIDT_EnableParentPort(resetWorkItemObj->deviceObject);
        }

        //
        // now attempt to reset the stalled pipe, this will clear the stall 
        // on the device as well.
        //

        if (NT_SUCCESS(ntStatus)) {
            // BUGBUG ntStatus = HIDT_ResetInterruptPipe(resetWorkItemObj->deviceObject);
        }        

    }

    /*
     *  Clear the ResetWorkItem ptr in the device extension
     *  AFTER resetting the pipe so we don't end up with
     *  two threads resetting the same pipe at the same time.
     */
    (VOID)InterlockedExchange ((PVOID) &DeviceExtension->ResetWorkItem, 0);

    /*
     *  The IRP that returned the error which prompted us to do this reset
     *  is still owned by this driver because we returned 
     *  STATUS_MORE_PROCESSING_REQUIRED in the completion routine.
     *  Now that the hub is reset, complete this failed IRP.
     *
     *  Note: we check the irpWasCancelled as well as checking
     *        if the IRP is in the queue to deal with the pathological
     *        case of the IRP being cancelled, re-allocated, and
     *        re-queued.
     */
    KeAcquireSpinLock(&resetWorkItemsListSpinLock, &oldIrql);
    if (resetWorkItemObj->irpWasCancelled){
        didDequeue = FALSE;
    }
    else {
        IoSetCancelRoutine(resetWorkItemObj->irpToComplete, NULL);
        didDequeue = DequeueResetWorkItemWithIrp(resetWorkItemObj->irpToComplete, FALSE);
    }
    KeReleaseSpinLock(&resetWorkItemsListSpinLock, oldIrql);

    /*
     *  If we found a waiting IRP, complete it _after_ releasing the spinlock.
     */
    if (didDequeue){
        IoCompleteRequest(resetWorkItemObj->irpToComplete, IO_NO_INCREMENT);
    }
    
    ExFreePool(resetWorkItemObj);

    HIDT_DecrementPendingRequestCount(DeviceExtension);

    return ntStatus;
}



/*
 ********************************************************************************
 *  ResetCancelRoutine
 ********************************************************************************
 *
 *
 */
VOID ResetCancelRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    BOOLEAN didDequeue;
    KIRQL oldIrql;

    KeAcquireSpinLock(&resetWorkItemsListSpinLock, &oldIrql);
    didDequeue = DequeueResetWorkItemWithIrp(Irp, TRUE);
    KeReleaseSpinLock(&resetWorkItemsListSpinLock, oldIrql);

    /*
     *  We must release the CancelSpinLock whether or not
     *  we are completing the IRP here.
     */
    IoReleaseCancelSpinLock(Irp->CancelIrql);

	/*
	 *  Complete this Irp only if we found it in our queue.
	 */
    if (didDequeue){
	    Irp->IoStatus.Status = STATUS_CANCELLED;
	    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
}



/*
 ********************************************************************************
 *  HIDT_GetPhysicalDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HIDT_GetPhysicalDescriptor(  IN PDEVICE_OBJECT DeviceObject,
                                    IN PIRP Irp,
                                    BOOLEAN *NeedsCompletion)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    // BUGBUG FINISH ?  REMOVE ?
    return status;
}


/*
 ********************************************************************************
 *  HIDT_GetStringDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HIDT_GetStringDescriptor(	IN PDEVICE_OBJECT DeviceObject,
                                    IN PIRP Irp)
{
    NTSTATUS ntStatus = STATUS_PENDING;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack;
    PVOID buffer;
    ULONG bufferSize;
    BOOLEAN isIndexedString;

	PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode){
        case IOCTL_HID_GET_INDEXED_STRING:
            /*
             *  IOCTL_HID_GET_INDEXED_STRING uses buffering method
             *  METHOD_OUT_DIRECT, which passes the buffer in the MDL.
             */
            buffer = MmGetSystemAddressForMdl(Irp->MdlAddress);
            isIndexedString = TRUE;
            break;

        case IOCTL_HID_GET_STRING:
            /*
             *  IOCTL_HID_GET_STRING uses buffering method
             *  METHOD_NEITHER, which passes the buffer in Irp->UserBuffer.
             */
            buffer = Irp->UserBuffer;
            isIndexedString = FALSE;
            break;

        default:
            ASSERT(0);
            buffer = NULL;
            break;
    }

    bufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (buffer && bufferSize){

		/*
		 *  BUGBUG - hack
		 *  String id and language id are in Type3InputBuffer field
		 *  of IRP stack location.
		 *
		 *  Note: the string ID should be identical to the string's
		 *        field offset given in Chapter 9 of the USB spec.
		 */
		ULONG languageId = ((ULONG)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer) >> 16;
		ULONG stringIndex;

        if (isIndexedString){
		    stringIndex = ((ULONG)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer) & 0x0ffff;
        }
        else {
    		ULONG stringId = ((ULONG)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer) & 0x0ffff;

		    switch (stringId){
			    case HID_STRING_ID_IMANUFACTURER: 
				    // BUGBUG FINISH  stringIndex = DeviceExtension->DeviceDescriptor->iManufacturer;
				    break;
			    case HID_STRING_ID_IPRODUCT: 
				    // BUGBUG FINISH  stringIndex = DeviceExtension->DeviceDescriptor->iProduct;
				    break;
			    case HID_STRING_ID_ISERIALNUMBER: 
				    // BUGBUG FINISH  stringIndex = DeviceExtension->DeviceDescriptor->iSerialNumber;
				    break;
			    default:
				    stringIndex = -1;
				    break;
		    }
        }

		if (stringIndex == -1){
			ntStatus = STATUS_INVALID_PARAMETER;
		}
		else {

            // BUGBUG FINISH
            ntStatus = STATUS_UNSUCCESSFUL;
		}
    }
    else {
        ntStatus = STATUS_INVALID_USER_BUFFER;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HIDT_GetFeatureCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HIDT_GetFeatureCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    HIDT_DecrementPendingRequestCount(deviceExtension);

    if (NT_SUCCESS(Irp->IoStatus.Status)){
        /*
         *  Record the number of bytes written.
         */
        // BUGBUG FINISH   Irp->IoStatus.Information = 
    }


    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }

    return STATUS_SUCCESS;
}


/*
 ********************************************************************************
 *  HIDT_GetFeature
 ********************************************************************************
 *
 *
 */
NTSTATUS HIDT_GetFeature(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    // BUGBUG FINISH

    return ntStatus;
}



/*
 ********************************************************************************
 *  HIDT_SetFeatureCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HIDT_SetFeatureCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    HIDT_DecrementPendingRequestCount(deviceExtension);

    if (NT_SUCCESS(Irp->IoStatus.Status)){
        /*
         *  Record the number of bytes written.
         */
        // BUGBUG FINISH  Irp->IoStatus.Information = 
    }


    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }

    return STATUS_SUCCESS;
}



/*
 ********************************************************************************
 *  HIDT_SetFeature
 ********************************************************************************
 *
 *
 */
NTSTATUS HIDT_SetFeature(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    // BUGBUG FINISH

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\filter\hidvalid\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pnp.c

Abstract: Human Input Device (HID) lower filter driver
    This module contains the plug and play dispatch entries needed for this
    filter.

Author:

    Kenneth D. Ray

Environment:

    Kernel mode

Revision History:


--*/
#include <WDM.H>
#include "hidusage.h"
#include "hidpi.h"
#include "hidclass.h"
#include "validate.H"
#include "validio.h"

NTSTATUS
HidV_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The power dispatch routine.
    This filter does not recognize power IRPS.  It merely sends them down,
    unmodified to the next device on the attachment stack.

    As this is a POWER irp, and therefore a special irp, special power irp
    handling is required.

    No completion routine is required.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PHIDV_HID_DATA  hidData;
    NTSTATUS        status;
    TRAP();

    hidData = (PHIDV_HID_DATA) DeviceObject->DeviceExtension;

    if (DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }
    //
    // This IRP was sent to the filter driver.
    // Since we do not know what to do with the IRP, we should pass
    // it on along down the stack.
    //

    InterlockedIncrement (&hidData->OutstandingIO);

    HidV_KdPrint (("Passing unknown Power irp 0x%x",
                   IoGetCurrentIrpStackLocation(Irp)->MinorFunction));


    if (hidData->Removed) {
        status = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    } else {
        IoSkipCurrentIrpStackLocation (Irp);

        //
        // Power IRPS come synchronously; drivers must call
        // PoStartNextPowerIrp, when they are ready for the next power irp.
        // This can be called here, or in the completetion routine.
        //
        PoStartNextPowerIrp (Irp);

        //
        // NOTE!!! PoCallDriver NOT IoCallDriver.
        //
        status =  PoCallDriver (hidData->TopOfStack, Irp);
    }

    if (0 == InterlockedDecrement (&hidData->OutstandingIO)) {
        KeSetEvent (&hidData->RemoveEvent, 0, FALSE);
    }
    return status;
}



NTSTATUS
HidV_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );



NTSTATUS
HidV_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these this filter driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PHIDV_HID_DATA      hidData;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    TRAP ();

    hidData = (PHIDV_HID_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);

    if(DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }

    HidV_KdPrint (("PlugPlay Irp irp 0x%x",
                   IoGetCurrentIrpStackLocation(Irp)->MinorFunction));

    InterlockedIncrement (&hidData->OutstandingIO);
    if (hidData->Removed) {

        //
        // Someone sent us another plug and play IRP after the remove IRP.
        // This should never happen.
        //
        ASSERT (FALSE);

        if (0 == InterlockedDecrement (&hidData->OutstandingIO)) {
            KeSetEvent (&hidData->RemoveEvent, 0, FALSE);
        }
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);
        KeInitializeEvent(&hidData->StartEvent, NotificationEvent, FALSE);
        IoSetCompletionRoutine (Irp,
                                HidV_PnPComplete,
                                hidData,
                                TRUE,
                                FALSE,  // No need for Error
                                FALSE); // No need for Cancel
        status = IoCallDriver (hidData->TopOfStack, Irp);
        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &hidData->StartEvent,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout
        } else if (!NT_SUCCESS (status)) {
            break; // In this case our completion routine did not fire.
        }

        //
        // As we are now back from our start device we can do work.
        //

        //
        // Remember, the resources can be found at
        // stack->Parameters.StartDevice.AllocatedResources.
        //

        status = HidV_StartDevice (hidData);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    case IRP_MN_STOP_DEVICE:
        status = HidV_StopDevice (hidData);
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (hidData->TopOfStack, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // The PlugPlay system has dictacted the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!hidData->Removed);

        //
        // We will no longer receive requests for this device as it has been
        // removed.
        //
        hidData->Removed = TRUE;

        if (hidData->Started) {
            ASSERT (NT_SUCCESS (status = HidV_StopDevice(hidData)));
        }

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //

        //
        // Send on the remove IRP
        //

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (hidData->TopOfStack, Irp);

        if (0 < InterlockedDecrement (&hidData->OutstandingIO)) {
            KeWaitForSingleObject (
                &hidData->RemoveEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
        }

        IoDetachDevice (hidData->TopOfStack);

        //
        // Clean up memory
        //

        if (hidData->Ppd) {
            // The device could be removed without ever having been started.
            ExFreePool (hidData->Ppd);
            ExFreePool (hidData->InputButtonCaps);
            ExFreePool (hidData->InputValueCaps);
            ExFreePool (hidData->OutputButtonCaps);
            ExFreePool (hidData->OutputValueCaps);
            ExFreePool (hidData->FeatureButtonCaps);
            ExFreePool (hidData->FeatureValueCaps);
        }

        IoDeleteDevice (hidData->Self);
        return STATUS_SUCCESS;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_SET_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (hidData->TopOfStack, Irp);
        break;
    }


    if (0 == InterlockedDecrement (&hidData->OutstandingIO)) {
        KeSetEvent (&hidData->RemoveEvent, 0, FALSE);
    }

    return status;
}


NTSTATUS
HidV_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;
    PHIDV_HID_DATA      hidData;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (DeviceObject);

    status = STATUS_SUCCESS;
    hidData = (PHIDV_HID_DATA) Context;
    stack = IoGetCurrentIrpStackLocation (Irp);

    switch (stack->MajorFunction) {
    case IRP_MJ_PNP:

        switch (stack->MinorFunction) {
        case IRP_MN_START_DEVICE:

            KeSetEvent (&hidData->StartEvent, 0, FALSE);
            return STATUS_MORE_PROCESSING_REQUIRED;

        default:
            break;
        }
        break;

    case IRP_MJ_POWER:
    default:
        break;
    }
    return status;
}

NTSTATUS
HidV_StartDevice (
    IN PHIDV_HID_DATA   HidData
    )
/*++

Routine Description:

Arguments:


--*/
{
    NTSTATUS                    status;
    HID_COLLECTION_INFORMATION  collectionInfo;

    ASSERT (!HidData->Removed);
    //
    // The PlugPlay system should not have started a removed device!
    //

    HidData->Ppd = NULL;
    HidData->InputButtonCaps = NULL;
    HidData->InputValueCaps = NULL;
    HidData->OutputButtonCaps = NULL;
    HidData->OutputValueCaps = NULL;
    HidData->FeatureButtonCaps = NULL;
    HidData->FeatureValueCaps = NULL;

    if (HidData->Started) {
        return STATUS_SUCCESS;
    }

    //
    // Find out about this HID device.
    //

    //
    // Retrieve the caps for this device.
    //
    status = HidV_CallHidClass (HidData->TopOfStack,
                                IOCTL_HID_GET_COLLECTION_INFORMATION,
                                &collectionInfo,
                                sizeof (collectionInfo),
                                NULL,
                                0);

    if (!NT_SUCCESS (status)) {
        goto HIDV_START_DEVICE_REJECT;
    }

    HidData->Ppd = ExAllocatePool (NonPagedPool,
                                   collectionInfo.DescriptorSize);
    if (NULL == HidData->Ppd) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto HIDV_START_DEVICE_REJECT;
    }

    //
    // Retrieve the Preparsed Data
    //
    status = HidV_CallHidClass (HidData->TopOfStack,
                                IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                                HidData->Ppd,
                                collectionInfo.DescriptorSize,
                                NULL,
                                0);

    if (!NT_SUCCESS (status)) {
        goto HIDV_START_DEVICE_REJECT;
    }

    //
    // Retrieve the Caps for the device.
    //
    status = HidP_GetCaps (HidData->Ppd, &HidData->Caps);
    if (!NT_SUCCESS (status)) {
        goto HIDV_START_DEVICE_REJECT;
    }

    //
    // Get all of the caps for the device.
    //

#define Alloc(type) HidData-> ## type = ExAllocatePool (                    \
                                            NonPagedPool,                   \
                                            HidData->Caps.Number ## type ); \
                    if (NULL == HidData-> ## type) {                        \
                        status = STATUS_INSUFFICIENT_RESOURCES;             \
                        goto HIDV_START_DEVICE_REJECT;                      \
                    }
    Alloc (InputButtonCaps);
    Alloc (InputValueCaps);
    Alloc (OutputButtonCaps);
    Alloc (OutputValueCaps);
    Alloc (FeatureButtonCaps);
    Alloc (FeatureValueCaps);
#undef Alloc

    HidP_GetButtonCaps (HidP_Input,
                        HidData->InputButtonCaps,
                        &HidData->Caps.NumberInputButtonCaps,
                        HidData->Ppd);
    HidP_GetButtonCaps (HidP_Output,
                        HidData->OutputButtonCaps,
                        &HidData->Caps.NumberOutputButtonCaps,
                        HidData->Ppd);
    HidP_GetButtonCaps (HidP_Feature,
                        HidData->FeatureButtonCaps,
                        &HidData->Caps.NumberFeatureButtonCaps,
                        HidData->Ppd);
    HidP_GetValueCaps  (HidP_Input,
                        HidData->InputValueCaps,
                        &HidData->Caps.NumberInputValueCaps,
                        HidData->Ppd);
    HidP_GetValueCaps  (HidP_Output,
                        HidData->OutputValueCaps,
                        &HidData->Caps.NumberOutputValueCaps,
                        HidData->Ppd);
    HidP_GetValueCaps  (HidP_Feature,
                        HidData->FeatureValueCaps,
                        &HidData->Caps.NumberFeatureValueCaps,
                        HidData->Ppd);


    HidData->Started = TRUE;
    status = STATUS_SUCCESS;

    return status;

HIDV_START_DEVICE_REJECT:

#define CondFree(addr) if ((addr)) ExFreePool ((addr))
    CondFree(HidData->Ppd);
    CondFree(HidData->InputButtonCaps);
    CondFree(HidData->InputValueCaps);
    CondFree(HidData->OutputButtonCaps);
    CondFree(HidData->OutputValueCaps);
    CondFree(HidData->FeatureButtonCaps);
    CondFree(HidData->FeatureValueCaps);
#undef CondFree

    return status;
}


NTSTATUS
HidV_StopDevice (
    IN PHIDV_HID_DATA HidData
    )
/*++

Routine Description:
    The PlugPlay system has dictacted the removal of this device.  We have
    no choise but to detach and delete the device objecct.
    (If we wanted to express and interest in preventing this removal,
    we should have filtered the query remove and query stop routines.)

    Note! we might receive a remove WITHOUT first receiving a stop.

Arguments:
    The HidDevice being started.

--*/
{
    NTSTATUS    status;

    ASSERT (!HidData->Removed);
    //
    // The PlugPlay system should not have started a removed device!
    //


    if (!HidData->Started) {
        return STATUS_SUCCESS;
    }

    //
    // Find out about this HID device.
    //


    HidData->Started = FALSE;
    status = STATUS_SUCCESS;

    return status;
}


NTSTATUS
HidV_CallHidClass(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      ULONG           Ioctl,
    IN OUT  PVOID           InputBuffer,
    IN      ULONG           InputBufferLength,
    IN OUT  PVOID           OutputBuffer,
    IN      ULONG           OutputBufferLength
    )
/*++

Routine Description:

    Makes a synchronous request to the HIDCLASS driver below.

Arguments:

    DeviceObject       - Device Object to send the Ioctl.

    Ioctl              - Value of the IOCTL request.

    InputBuffer        - Buffer to be sent to the HID class driver.

    InputBufferLength  - Size of buffer to be sent to the HID class driver.

    OutputBuffer       - Buffer for received data from the HID class driver.

    OutputBufferLength - Size of receive buffer from the HID class.

Return Value:

    NTSTATUS result code.

--*/
{
    KEVENT             event;
    IO_STATUS_BLOCK    ioStatus;
    PIRP               irp;
    PIO_STACK_LOCATION nextStack;
    NTSTATUS           status = STATUS_SUCCESS;

    HidV_KdPrint(("PNP-CallHidClass: Enter."));

    //
    // Prepare to issue a synchronous request.
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build an IRP.
    //
    irp = IoBuildDeviceIoControlRequest (
                            Ioctl,
                            DeviceObject,
                            InputBuffer,
                            InputBufferLength,
                            OutputBuffer,
                            OutputBufferLength,
                            FALSE,              // external IOCTL
                            &event,
                            &ioStatus);

    if (irp == NULL) {
       return STATUS_UNSUCCESSFUL;
    }

    nextStack = IoGetNextIrpStackLocation(irp);

    ASSERT(nextStack != NULL);

    //
    // Submit the request to the HID class driver.
    //
    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING) {

       //
       // Request to HID class driver is still pending.  Wait for the request
       // to complete.
       //
       status = KeWaitForSingleObject(
                     &event,
                     Executive,    // wait reason
                     KernelMode,
                     FALSE,        // not alertable
                     NULL);        // no time out
    }

    status = ioStatus.Status;

    HidV_KdPrint(("PNP-CallHidClass: Exit (%x).", status ));

    //
    // We are done.  Return our status to the caller.
    //
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hid1394\hid1394.c ===
/*
 *************************************************************************
 *  File:       HID1394.C
 *
 *  Module:     HID1394.SYS
 *              HID (Human Input Device) minidriver for IEEE 1394 devices.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <hidport.h>
#include <1394.h>

#include "hid1394.h"
#include "debug.h"


NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING registryPath)
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    registryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    HID_MINIDRIVER_REGISTRATION hidMinidriverRegistration;

   
    //
    // Create dispatch points
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                  =
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = HIDT_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = HIDT_InternalIoctl;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = HIDT_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = HIDT_Power;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = HIDT_SystemControl;
    DriverObject->DriverExtension->AddDevice                    = HIDT_AddDevice;
    DriverObject->DriverUnload                                  = HIDT_Unload;


    //
    // Register USB layer with HID.SYS module
    //

    hidMinidriverRegistration.Revision              = HID_REVISION;
    hidMinidriverRegistration.DriverObject          = DriverObject;
    hidMinidriverRegistration.RegistryPath          = registryPath;
    hidMinidriverRegistration.DeviceExtensionSize   = sizeof(DEVICE_EXTENSION);

    /*
     *  HIDUSB is a minidriver for USB devices, which do not need to be polled.
     */
    hidMinidriverRegistration.DevicesArePolled      = FALSE;

    ntStatus = HidRegisterMinidriver(&hidMinidriverRegistration);

    KeInitializeSpinLock(&resetWorkItemsListSpinLock);

    return ntStatus;
}


NTSTATUS HIDT_CreateClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

   Process the Create and close IRPs sent to this device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION   IrpStack;
    NTSTATUS             ntStatus = STATUS_SUCCESS;

    DBGBREAK;

    //
    // Get a pointer to the current location in the Irp.
    //
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    switch(IrpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            Irp->IoStatus.Information = 0;
            break;

        case IRP_MJ_CLOSE:
            Irp->IoStatus.Information = 0;
            break;

        default:
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Save Status for return and complete Irp
    //

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return ntStatus;
}


NTSTATUS HIDT_AddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT FunctionalDeviceObject)
/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object.

    PhysicalDeviceObject - pointer to a device object pointer created by the bus

Return Value:

    NT status code.

--*/
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          DeviceObject = NULL;
    PDEVICE_EXTENSION       deviceExtension;

    DeviceObject = FunctionalDeviceObject;

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION( DeviceObject );

    deviceExtension->DeviceFlags = 0;
    
    deviceExtension->ResetWorkItem = NULL;
    
    return ntStatus;
}



VOID HIDT_Unload(IN PDRIVER_OBJECT DriverObject)
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    ASSERT (!DriverObject->DeviceObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hid1394\ioctl.c ===
/*
 *************************************************************************
 *  File:       IOCTL.C
 *
 *  Module:     HID1394.SYS
 *              HID (Human Input Device) minidriver for IEEE 1394 devices.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <hidport.h>
#include <1394.h>

#include "hid1394.h"
#include "debug.h"


/*
 ************************************************************
 *  HIDT_InternalIoctl
 ************************************************************
 *
 *
 *  Note: this function cannot be pageable because reads/writes
 *        can be made at dispatch-level.
 *
 *  Note:  this is an INTERNAL IOCTL handler, so no buffer
 *         validation is required.
 */
NTSTATUS HIDT_InternalIoctl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  irpSp;
    BOOLEAN             NeedsCompletion = TRUE;

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode){

        case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
            /*
             *  This IOCTL uses buffering method METHOD_NEITHER,
             *  so the buffer is Irp->UserBuffer.
             */
            ntStatus = HIDT_GetHidDescriptor(DeviceObject, Irp);
            break;

        case IOCTL_HID_GET_REPORT_DESCRIPTOR:
            /*
             *  This IOCTL uses buffering method METHOD_NEITHER,
             *  so the buffer is Irp->UserBuffer.
             */
            ntStatus = HIDT_GetReportDescriptor(DeviceObject, Irp);
            break;

        case IOCTL_HID_READ_REPORT:
            /*
             *  This IOCTL uses buffering method METHOD_NEITHER,
             *  so the buffer is Irp->UserBuffer.
             */
            ntStatus = HIDT_ReadReport(DeviceObject, Irp, &NeedsCompletion);
            break;

        case IOCTL_HID_WRITE_REPORT:
            /*
             *  This IOCTL uses buffering method METHOD_NEITHER,
             *  so the buffer is Irp->UserBuffer.
             */
            ntStatus = HIDT_WriteReport (DeviceObject, Irp, &NeedsCompletion);
            break;

        case IOCTL_HID_GET_STRING:
            /*
             *  Get the friendly name for the device.
             *
             *  This IOCTL uses buffering method METHOD_NEITHER,
             *  so the buffer is Irp->UserBuffer.
             */
            ntStatus = HIDT_GetStringDescriptor(DeviceObject, Irp);
            break;

        case IOCTL_HID_GET_INDEXED_STRING:
            ntStatus = HIDT_GetStringDescriptor(DeviceObject, Irp);
            break;

        case IOCTL_HID_GET_FEATURE:
            ntStatus = HIDT_GetFeature(DeviceObject, Irp, &NeedsCompletion);
            break;

        case IOCTL_HID_SET_FEATURE:
            ntStatus = HIDT_SetFeature(DeviceObject, Irp, &NeedsCompletion);
            break;

        case IOCTL_HID_ACTIVATE_DEVICE:
        case IOCTL_HID_DEACTIVATE_DEVICE:
            /*
             *  We don't do anything for these IOCTLs but some minidrivers might.
             */
            ntStatus = STATUS_SUCCESS;
            break;

        case IOCTL_GET_PHYSICAL_DESCRIPTOR:
            /*
             *  This IOCTL gets information related to the human body part used
             *  to control a device control.
             */
            ntStatus = HIDT_GetPhysicalDescriptor(DeviceObject, Irp, &NeedsCompletion);
            break;

        case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
            /*
             *  This IOCTL uses buffering method METHOD_NEITHER,
             *  so the buffer is Irp->UserBuffer.
             *  If the IRP is coming to us from user space,
             *  we must validate the buffer.
             */
            ntStatus = HIDT_GetDeviceAttributes(DeviceObject, Irp, &NeedsCompletion);
            break;

        default:
			/*
			 *  Note: do not return STATUS_NOT_SUPPORTED;
			 *  Just keep the default status (this allows filter drivers to work).
			 */
            ntStatus = Irp->IoStatus.Status;
            break;
    }

	/* 
	 *  Complete the IRP only if we did not pass it to a lower driver.
	 */
    if (NeedsCompletion) {
		ASSERT(ntStatus != STATUS_PENDING);
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hid1394\pnp.c ===
/*
 *************************************************************************
 *  File:       PNP.C
 *
 *  Module:     HID1394.SYS
 *              HID (Human Input Device) minidriver for IEEE 1394 devices.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <hidport.h>
#include <1394.h>

#include "hid1394.h"
#include "debug.h"



#ifdef ALLOC_PRAGMA
	#pragma alloc_text(PAGE, HIDT_PnP)
	#pragma alloc_text(PAGE, HIDT_StartDevice)
	#pragma alloc_text(PAGE, HIDT_StopDevice)
	#pragma alloc_text(PAGE, HIDT_RemoveDevice)
	#pragma alloc_text(PAGE, HIDT_AbortPendingRequests)
#endif


/*
 ************************************************************
 *  HIDT_PnP
 ************************************************************
 *
 *  Process PnP IRPs sent to this device.
 *
 */
NTSTATUS HIDT_PnP(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION DeviceExtension;

	PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    irpSp = IoGetCurrentIrpStackLocation (Irp);

    switch(irpSp->MinorFunction){

        case IRP_MN_START_DEVICE:
            ntStatus = HIDT_StartDevice(DeviceObject);
            break;

        case IRP_MN_STOP_DEVICE:
            ntStatus = HIDT_StopDevice(DeviceObject);
            break;

        case IRP_MN_REMOVE_DEVICE:
            ntStatus = HIDT_RemoveDevice(DeviceObject);
            break;
    }
    

    if (NT_SUCCESS(ntStatus)){
        /*
         *  Our processing has succeeded.
         *  So pass this IRP down to the next driver.
         */

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                            HIDT_PnpCompletion,
                            DeviceExtension,    // context
                            TRUE,                       
                            TRUE,                       
                            TRUE );                     
        ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
    } 
    else {
        ASSERT(NT_SUCCESS(ntStatus));
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return ntStatus;
}



/*
 ************************************************************
 *  HIDT_Power 
 ************************************************************
 *
 *  Process Power IRPs sent to this device.
 *
 */
NTSTATUS HIDT_Power(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS status;

    IoCopyCurrentIrpStackLocationToNext(Irp);
    status = PoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
    return status;
}


/*
 ************************************************************
 *  HIDT_StartDevice
 ************************************************************
 *
 *
 */
NTSTATUS HIDT_StartDevice(IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_EXTENSION DeviceExtension;

	PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    DeviceExtension->DeviceState = DEVICE_STATE_STARTING;
    DeviceExtension->NumPendingRequests = 0;

    KeInitializeEvent( &DeviceExtension->AllRequestsCompleteEvent,
                       NotificationEvent,
                       FALSE);

    return STATUS_SUCCESS;
}




/*
 ************************************************************
 *  HIDT_InitDevice 
 ************************************************************
 *
 *   Get the device information and attempt to initialize a configuration
 *   for a device.  If we cannot identify this as a valid HID device or
 *   configure the device, our start device function is failed.
 *
 *   Note:  This function is called from the PnP completion routine,
 *          so it cannot be pageable.
 */
NTSTATUS HIDT_InitDevice(IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    // BUGBUG FINISH

    return ntStatus;
}


/*
 ************************************************************
 *  HIDT_StopDevice
 ************************************************************
 *
 *
 */
NTSTATUS HIDT_StopDevice(IN PDEVICE_OBJECT DeviceObject)
{
    ULONG       Size;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension;

	PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    DeviceExtension->DeviceState = DEVICE_STATE_STOPPING;

	/*
	 *  Abort all pending IO on the device.
	 *  We do an extra decrement here, which causes the
	 *  NumPendingRequests to eventually go to -1, which causes
	 *  AllRequestsCompleteEvent to get set.
	 *  NumPendingRequests will get reset to 0 when we re-start.
	 */
    HIDT_AbortPendingRequests(DeviceObject);
    HIDT_DecrementPendingRequestCount(DeviceExtension);
    KeWaitForSingleObject( &DeviceExtension->AllRequestsCompleteEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );


    // BUGBUG FINISH - select NULL configuration


    if (!NT_SUCCESS(ntStatus)){
        /*
         *  We will not pass this IRP down, 
         *  so our completion routine will not set the device's
         *  state to DEVICE_STATE_STOPPED; so set it here.
         */
        ASSERT(NT_SUCCESS(ntStatus));
        DeviceExtension->DeviceState = DEVICE_STATE_STOPPED;
    }

    return ntStatus;
}



/*
 ************************************************************
 *  HIDT_AbortPendingRequests
 ************************************************************
 *
 *
 */
NTSTATUS HIDT_AbortPendingRequests(IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

	PAGED_CODE();

    // BUGBUG FINISH

    ASSERT(NT_SUCCESS(status));
    return status;
}


/*
 ************************************************************
 *  HIDT_PnpCompletion
 ************************************************************
 *
 */
NTSTATUS HIDT_PnpCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    status = Irp->IoStatus.Status;

    switch(irpSp->MinorFunction){

        case IRP_MN_START_DEVICE:
            if (NT_SUCCESS(status)) {
                DeviceExtension->DeviceState = DEVICE_STATE_RUNNING;

                status = HIDT_InitDevice(DeviceObject);

                if (!NT_SUCCESS(status)) {
                    DBGWARN(("HIDT_InitDevice failed; failing IRP_MN_START_DEVICE."));
                    DeviceExtension->DeviceState = DEVICE_STATE_START_FAILED;
                    Irp->IoStatus.Status = status;
                }
            }
            else {
                ASSERT(NT_SUCCESS(status));
                DeviceExtension->DeviceState = DEVICE_STATE_START_FAILED;
            }
            break;

        case IRP_MN_STOP_DEVICE:

            DeviceExtension->DeviceState = DEVICE_STATE_STOPPED;

            /*
             *  Release resources
             */
            // BUGBUG FINISH
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            /*
             *  The lower driver set the capabilities flags for this device.
             *  Since all 1394 devices are hot-unpluggable,
             *  add the SurpriseRemovalOK bit.
             */
            if (NT_SUCCESS(status)){
                irpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;
            }
            break;

    }

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }

    return status;
}


/*
 ************************************************************
 *  HIDT_RemoveDevice
 ************************************************************
 *
 *
 */
NTSTATUS HIDT_RemoveDevice(IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension;
    ULONG oldDeviceState;

	PAGED_CODE();

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    //
    //  Set device state, this prevents new IOs from starting
    //

    oldDeviceState = DeviceExtension->DeviceState;
    DeviceExtension->DeviceState = DEVICE_STATE_REMOVING;

    //
    // Cancel any outstanding IRPs if the device was running
    //

    if (oldDeviceState == DEVICE_STATE_RUNNING){
        ntStatus = HIDT_AbortPendingRequests( DeviceObject );


        /*
         *  Note: RemoveDevice does an extra decrement, so we complete 
         *        the REMOVE IRP on the transition to -1, whether this 
         *        happens in RemoveDevice itself or subsequently while
         *        RemoveDevice is waiting for this event to fire.
         */
        HIDT_DecrementPendingRequestCount(DeviceExtension);
        KeWaitForSingleObject( &DeviceExtension->AllRequestsCompleteEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    } 
    else if (oldDeviceState == DEVICE_STATE_STOPPING){
        ASSERT(!(PVOID)"PnP IRPs are not synchronized! -- got REMOVE_DEVICE before STOP_DEVICE completed!");
    }
    else {
        ASSERT(DeviceExtension->NumPendingRequests == -1);
    }

    //
    //  Release any resources
    //

    // BUGBUG FINISH

    ntStatus = STATUS_SUCCESS;

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hid1394\sysctrl.c ===
/*
 *************************************************************************
 *  File:       SYSCTRL.C
 *
 *  Module:     HID1394.SYS
 *              HID (Human Input Device) minidriver for IEEE 1394 devices.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <hidport.h>
#include <1394.h>

#include "hid1394.h"
#include "debug.h"


#ifdef ALLOC_PRAGMA
	#pragma alloc_text(PAGE, HIDT_SystemControl)
#endif


/*
 ************************************************************
 *	HIDTSystemControl
 ************************************************************
 *
 */
NTSTATUS HIDT_SystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  thisStackLoc;

	PAGED_CODE();

	// BUGBUG Complete this function
	ASSERT(0); // BUGBUG Code coverage


    thisStackLoc = IoGetCurrentIrpStackLocation(Irp);

    switch(thisStackLoc->Parameters.DeviceIoControl.IoControlCode){

		default:
			/*
			 *  Note: do not return STATUS_NOT_SUPPORTED;
			 *  If completing the IRP here,
			 *  just keep the default status 
			 *  (this allows filter drivers to work).
			 */
            status = Irp->IoStatus.Status;
            break;
	}


	IoCopyCurrentIrpStackLocationToNext(Irp);

    status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hid1394\hid1394.h ===
/*
 *************************************************************************
 *  File:       HID1394.H
 *
 *  Module:     HID1394.SYS
 *              HID (Human Input Device) minidriver for IEEE 1394 devices.
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

//
// Device Class Constants for HID
//
#define HID_GET_REPORT      0x01
#define HID_GET_IDLE        0x02
#define HID_GET_PROTOCOL    0x03

#define HID_SET_REPORT      0x09
#define HID_SET_IDLE        0x0A
#define HID_SET_PROTOCOL    0x0B


/* 
 *  This device extension resides in memory immediately after
 *  HIDCLASS' extension.
 */
typedef struct _DEVICE_EXTENSION
{
    ULONG                           DeviceState;

    // BUGBUG PUSB_DEVICE_DESCRIPTOR          DeviceDescriptor;

    // BUGBUG PUSBD_INTERFACE_INFORMATION     Interface;
    // BUGBUG USBD_CONFIGURATION_HANDLE       ConfigurationHandle;

    CONFIG_ROM                      configROM;

    ULONG                           NumPendingRequests;
    KEVENT                          AllRequestsCompleteEvent;

    ULONG                           DeviceFlags;

    PWORK_QUEUE_ITEM                ResetWorkItem;
    // BUGBUG  USB_HID_DESCRIPTOR              HidDescriptor;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


/*
 *  This structure is used to pass information to the 
 *  resetWorkItem callback.
 */
typedef struct tag_resetWorkItemContext {
                    WORK_QUEUE_ITEM workItem;
                    PDEVICE_OBJECT deviceObject;
                    PIRP irpToComplete;
                    BOOLEAN irpWasCancelled;

                    struct tag_resetWorkItemContext *next;

                    #if DBG
                        #define RESET_WORK_ITEM_CONTEXT_SIG 'IWSR'
                        ULONG sig;
                    #endif
                    
} resetWorkItemContext;

#define DEVICE_STATE_NONE           0
#define DEVICE_STATE_STARTING       1
#define DEVICE_STATE_RUNNING        2
#define DEVICE_STATE_STOPPING       3
#define DEVICE_STATE_STOPPED        4
#define DEVICE_STATE_REMOVING       5
#define DEVICE_STATE_START_FAILED   6

#define DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE   0x00000001

//
// Interface slection options
//
#define HUM_SELECT_DEFAULT_INTERFACE    0
#define HUM_SELECT_SPECIFIED_INTERFACE  1

//
// Device Extension Macros
//

#define GET_MINIDRIVER_DEVICE_EXTENSION(DO) ((PDEVICE_EXTENSION) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->MiniDeviceExtension))

#define GET_HIDCLASS_DEVICE_EXTENSION(DO) ((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)

#define GET_NEXT_DEVICE_OBJECT(DO) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->NextDeviceObject)







/*
 *  HID1394 signature tag for memory allocations
 */
#define HID1394_TAG (ULONG)'TdiH'

//
// Function prototypes
//

NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING registryPath);
NTSTATUS    HIDT_AbortPendingRequests(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HIDT_CreateClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HIDT_InternalIoctl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HIDT_PnP(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HIDT_Power(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HIDT_CreateDevice(IN PDRIVER_OBJECT DriverObject, IN OUT PDEVICE_OBJECT *DeviceObject);
NTSTATUS    HIDT_AddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT FunctionalDeviceObject);
NTSTATUS    HIDT_StartDevice(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HIDT_PnpCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS    HIDT_InitDevice(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HIDT_StopDevice(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HIDT_RemoveDevice(IN PDEVICE_OBJECT DeviceObject);
VOID        HIDT_Unload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS    HIDT_GetHidDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HIDT_GetReportDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HIDT_ReadReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HIDT_ReadCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS    HIDT_WriteReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HIDT_GetFeature(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HIDT_SetFeature(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HIDT_WriteCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS    HIDT_GetString(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HIDT_GetDeviceAttributes(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HIDT_GetDescriptorRequest(IN PDEVICE_OBJECT DeviceObject, IN ULONG DescriptorType, IN OUT PVOID *Descriptor, IN OUT ULONG *DescSize, IN ULONG TypeSize, IN ULONG Index, IN ULONG LangID, IN ULONG ShortTransferOk);
NTSTATUS    HIDT_GetDescriptorEndpoint(IN PDEVICE_OBJECT DeviceObject, IN ULONG DescriptorType, IN OUT PVOID *Descriptor, IN OUT ULONG *DescSize, IN ULONG TypeSize, IN ULONG Index, IN ULONG LangID);
NTSTATUS    HIDT_GetDescriptorInterface(IN PDEVICE_OBJECT DeviceObject, IN ULONG DescriptorType, IN OUT PVOID *Descriptor, IN OUT ULONG *DescSize, IN ULONG TypeSize, IN ULONG Index, IN ULONG LangID);
NTSTATUS    HIDT_SetIdle(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HIDT_SelectConfiguration(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HIDT_ParseHidInterface(IN PDEVICE_EXTENSION DeviceExtension, IN ULONG InterfaceLength);
NTSTATUS    HIDT_GetDeviceDescriptor(IN PDEVICE_OBJECT, IN PDEVICE_EXTENSION);
NTSTATUS    HIDT_GetConfigDescriptor(IN PDEVICE_OBJECT DeviceObject, OUT PULONG ConfigurationDescLength);
NTSTATUS    HIDT_GetHidInfo(IN PDEVICE_OBJECT DeviceObject, IN ULONG DescriptorLength);
NTSTATUS    DumpConfigDescriptor(IN ULONG DescriptorLength);
VOID        HIDT_DecrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension);
NTSTATUS    HIDT_IncrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension);
NTSTATUS    HIDT_ResetWorkItem(IN PVOID Context);
NTSTATUS    HIDT_EnableParentPort(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HIDT_GetPortStatus(IN PDEVICE_OBJECT DeviceObject, IN PULONG PortStatus);
NTSTATUS    HIDT_ResetInterruptPipe(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HIDT_SystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HIDT_GetStringDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HIDT_GetPhysicalDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion);

extern KSPIN_LOCK resetWorkItemsListSpinLock;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hid1394\i1394.c ===
/*
 *************************************************************************
 *  File:       I1394.C
 *
 *  Module:     HID1394.SYS
 *              HID (Human Input Device) minidriver for IEEE 1394 devices.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <hidport.h>
#include <1394.h>

#include "hid1394.h"
#include "debug.h"



ULONG resetGeneration = 0;

/*
 ********************************************************************************
 *  HIDT_SubmitIRB
 ********************************************************************************
 *
 *
 *  Submit an IRB (IO Request Block) to the IEEE 1394 bus
 *  by sending the bus an IRP with IoControlCode==IOCTL_1394_CLASS. 
 *
 */
NTSTATUS HIDT_SubmitIRB(PDEVICE_OBJECT devObj, PIRB irb)
{
    NTSTATUS status;
    PDEVICE_EXTENSION devExt;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;

    devExt = GET_MINIDRIVER_DEVICE_EXTENSION(devObj);

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_1394_CLASS,
                                        GET_NEXT_DEVICE_OBJECT(devObj),
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE, /* INTERNAL */
                                        &event,
                                        &ioStatus);

    if (irp){
        PIO_STACK_LOCATION nextSp;

        nextSp = IoGetNextIrpStackLocation(irp);
        nextSp->Parameters.Others.Argument1 = irb;

        status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(devObj), irp);

        if (status == STATUS_PENDING) {
            NTSTATUS waitStatus;

            /*
             *  Specify a timeout of 5 seconds for this call to complete.
             *  Negative timeout indicates time relative to now (in 100ns units).
             *
             *  BUGBUG - timeout happens rarely for HumGetReportDescriptor
             *           when you plug in and out repeatedly very fast.
             *           Figure out why this call never completes.
             */
            static LARGE_INTEGER timeout = {(ULONG) -50000000, 0xFFFFFFFF };

            waitStatus = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, &timeout);
            if (waitStatus == STATUS_TIMEOUT){
                /*
                 *  Note - Return STATUS_IO_TIMEOUT, not STATUS_TIMEOUT.
                 *  STATUS_IO_TIMEOUT is an NT error status, STATUS_TIMEOUT is not.
                 */
                ioStatus.Status = STATUS_IO_TIMEOUT;

                // BUGBUG - test timeout with faulty nack-ing device from glens
                // BUGBUG - also need to cancel read irps at HIDCLASS level

                //
                //  Cancel the Irp we just sent.
                //
                IoCancelIrp(irp);

                //
                //  Now wait for the Irp to be cancelled/completed below
                //
                waitStatus = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);
            }

            status = ioStatus.Status;
        }

    }
    else {
        status = STATUS_DATA_ERROR;
    }

    return status;
}


NTSTATUS BuildIRB_GetAddrFromDevObj(PIRB irb)
{
    NTSTATUS status;

    irb->FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;
    irb->Flags = 0;
    irb->u.Get1394AddressFromDeviceObject.fulFlags = 0; // BUGBUG ?
    status = STATUS_SUCCESS;

    return status;
}

NTSTATUS BuildIRB_BusReset(PIRB irb)
{
    NTSTATUS status;

    irb->FunctionNumber = REQUEST_BUS_RESET;
    irb->Flags = 0;
    irb->u.BusReset.fulFlags = 0;
    status = STATUS_SUCCESS;

    return status;
}

NTSTATUS BuildIRB_AsyncRead(    PIRB irb, 
                                PIO_ADDRESS addr, 
                                PMDL bufferMdl,
                                ULONG bufLen,
                                ULONG resetGeneration)
{
    NTSTATUS status;

    irb->FunctionNumber = REQUEST_ASYNC_READ;
    irb->Flags = 0;
    irb->u.AsyncRead.DestinationAddress = *addr;
    irb->u.AsyncRead.nNumberOfBytesToRead = bufLen;
    irb->u.AsyncRead.nBlockSize = 0;
    irb->u.AsyncRead.fulFlags = 0;
    irb->u.AsyncRead.Mdl = bufferMdl;
    irb->u.AsyncRead.ulGeneration = resetGeneration;
    // BUGBUG FINISH    irb->u.AsyncRead.chPriority = ;
    //                  irb->u.AsyncRead.nSpeed = ;
    //                  irb->u.AsyncRead.tCode = ;
    irb->u.AsyncRead.Reserved = 0;

    status = STATUS_SUCCESS;

    return status;
}


NTSTATUS BuildIRB_AsyncWrite(   PIRB irb, 
                                PIO_ADDRESS addr, 
                                PMDL bufferMdl,
                                ULONG bufLen,
                                ULONG resetGeneration)
{
    NTSTATUS status;

    irb->FunctionNumber = REQUEST_ASYNC_WRITE;
    irb->Flags = 0;
    irb->u.AsyncRead.DestinationAddress = *addr;
    irb->u.AsyncRead.nNumberOfBytesToRead = bufLen;
    irb->u.AsyncRead.nBlockSize = 0;
    irb->u.AsyncRead.fulFlags = 0;
    irb->u.AsyncRead.Mdl = bufferMdl;
    irb->u.AsyncRead.ulGeneration = resetGeneration;
    // BUGBUG FINISH    irb->u.AsyncRead.chPriority = ;
    //                  irb->u.AsyncRead.nSpeed = ;
    //                  irb->u.AsyncRead.tCode = ;
    irb->u.AsyncRead.Reserved = 0;

    status = STATUS_SUCCESS;

    return status;
}


NTSTATUS BuildIRB_IsochAllocateChannel(PIRB irb, ULONG requestedChannel)
{
    NTSTATUS status;

    irb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_CHANNEL;
    irb->Flags = 0;
    irb->u.IsochAllocateChannel.nRequestedChannel = requestedChannel; 

                        // BUGBUG is there a reserved HID channel ?
                           
    status = STATUS_SUCCESS;

    return status;
}

NTSTATUS BuildIRB_IsochFreeChannel(PIRB irb, ULONG channel)
{
    NTSTATUS status;

    irb->FunctionNumber = REQUEST_ISOCH_FREE_CHANNEL;
    irb->Flags = 0;
    irb->u.IsochFreeChannel.nChannel = channel; 

    status = STATUS_SUCCESS;

    return status;
}


NTSTATUS BuildIRB_GetLocalHostInfo(PIRB irb, ULONG level, PVOID infoPtr)
{
    NTSTATUS status;

    irb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    irb->Flags = 0;
    irb->u.GetLocalHostInformation.nLevel = level; 
    irb->u.GetLocalHostInformation.Information = infoPtr; 

    status = STATUS_SUCCESS;

    return status;
}

NTSTATUS BuildIRB_GetNodeAddress(PIRB irb)
{
    NTSTATUS status;

    irb->FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;
    irb->Flags = 0;
    irb->u.Get1394AddressFromDeviceObject.fulFlags = 0; 

    status = STATUS_SUCCESS;

    return status;
}

NTSTATUS BuildIRB_Control(PIRB irb,
                          ULONG controlCode,
                          PMDL inBuffer,
                          ULONG inBufferLen,
                          PMDL outBuffer,
                          ULONG outBufferLen)
{
    NTSTATUS status;

    irb->FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;
    irb->Flags = 0;
    irb->u.Control.ulIoControlCode = controlCode; 
    irb->u.Control.pInBuffer = inBuffer; 
    irb->u.Control.ulInBufferLength = inBufferLen; 
    irb->u.Control.pOutBuffer = outBuffer; 
    irb->u.Control.ulOutBufferLength = outBufferLen; 
    irb->u.Control.BytesReturned = 0; 

    status = STATUS_SUCCESS;

    return status;
}




/*
 ********************************************************************************
 *  HIDT_ReadCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HIDT_ReadCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
    NTSTATUS status;
    NTSTATUS result = STATUS_SUCCESS;
    PIRB irb;
    ULONG bytesRead;
    PDEVICE_EXTENSION devExt;

    devExt = GET_MINIDRIVER_DEVICE_EXTENSION(devObj);

    //
    // We passed a pointer to the IRB as our context, get it now.
    //
    irb = (PIRB)context;

    status = irp->IoStatus.Status;

    // BUGBUG FINISH


    /* 
     *  Free the IRB we allocated in HIDT_ReadReport.
     */
    ExFreePool(irb);

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (irp->PendingReturned){
        IoMarkIrpPending(irp);
    }

    return status;
}


/* 
 *  HIDT_ReadReport
 *
 *
 *
 */
NTSTATUS HIDT_ReadReport(PDEVICE_OBJECT devObj, PIRP irp, OUT BOOLEAN *needsCompletion)
{
    PIRB irb;
    NTSTATUS status;

    ASSERT(irp->UserBuffer);

    irb = ExAllocatePoolWithTag( NonPagedPool, sizeof(IRB), HID1394_TAG);
    if (irb){
        BOOLEAN sentIrb = FALSE;
        PIO_STACK_LOCATION irpSp, nextSp;
        ULONG bufLen;
        PMDL bufferMdl = NULL;  // BUGBUG 
        IO_ADDRESS addr;        // BUGBUG

        irpSp = IoGetCurrentIrpStackLocation(irp);
        nextSp = IoGetCurrentIrpStackLocation(irp);

        bufLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
        ASSERT(bufLen);

            
        // BUGBUG init bufferMdl, addr
        if (BuildIRB_AsyncRead(irb, &addr, bufferMdl, bufLen, resetGeneration)){

            nextSp->Parameters.Others.Argument1 = irb;
            nextSp->MajorFunction = irpSp->MajorFunction;
            // BUGBUG ? nextSp->Parameters.DeviceIoControl.IoControlCode = xxx;
            nextSp->DeviceObject = GET_NEXT_DEVICE_OBJECT(devObj); // BUGBUG ?

            IoSetCompletionRoutine( irp,  
                                    HIDT_ReadCompletion,
                                    irb,    // context
                                    TRUE,
                                    TRUE,
                                    TRUE);
            
            status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(devObj), irp);

            *needsCompletion = FALSE;
            sentIrb = TRUE;    
        }
        else {
            status = STATUS_DEVICE_DATA_ERROR;
        }

        if (!sentIrb){
            ExFreePool(irb);
        }
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


/*
 ********************************************************************************
 *  HIDT_ReadCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HIDT_WriteCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
    NTSTATUS status;
    NTSTATUS result = STATUS_SUCCESS;
    PIRB irb;
    ULONG bytesRead;
    PDEVICE_EXTENSION devExt;

    devExt = GET_MINIDRIVER_DEVICE_EXTENSION(devObj);

    //
    // We passed a pointer to the IRB as our context, get it now.
    //
    irb = (PIRB)context;

    status = irp->IoStatus.Status;

    // BUGBUG FINISH


    /* 
     *  Free the IRB we allocated in HIDT_ReadReport.
     */
    ExFreePool(irb);

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (irp->PendingReturned){
        IoMarkIrpPending(irp);
    }

    return status;
}


/* 
 *  HIDT_ReadReport
 *
 *
 *
 */
NTSTATUS HIDT_WriteReport(PDEVICE_OBJECT devObj, PIRP irp, OUT BOOLEAN *needsCompletion)
{
    PIRB irb;
    NTSTATUS status;

    ASSERT(irp->UserBuffer);

    irb = ExAllocatePoolWithTag( NonPagedPool, sizeof(IRB), HID1394_TAG);
    if (irb){
        BOOLEAN sentIrb = FALSE;
        PIO_STACK_LOCATION irpSp, nextSp;
        ULONG bufLen;
        PMDL bufferMdl = NULL;  // BUGBUG 
        IO_ADDRESS addr;        // BUGBUG

        irpSp = IoGetCurrentIrpStackLocation(irp);
        nextSp = IoGetCurrentIrpStackLocation(irp);

        bufLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
        ASSERT(bufLen);

            
        // BUGBUG init bufferMdl, addr
        if (BuildIRB_AsyncWrite(irb, &addr, bufferMdl, bufLen, resetGeneration)){

            nextSp->Parameters.Others.Argument1 = irb;
            nextSp->MajorFunction = irpSp->MajorFunction;
            // BUGBUG ? nextSp->Parameters.DeviceIoControl.IoControlCode = xxx;
            nextSp->DeviceObject = GET_NEXT_DEVICE_OBJECT(devObj); // BUGBUG ?

            IoSetCompletionRoutine( irp,  
                                    HIDT_WriteCompletion,
                                    irb,    // context
                                    TRUE,
                                    TRUE,
                                    TRUE);
            
            status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(devObj), irp);

            *needsCompletion = FALSE;
            sentIrb = TRUE;    
        }
        else {
            status = STATUS_DEVICE_DATA_ERROR;
        }

        if (!sentIrb){
            ExFreePool(irb);
        }
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


#if 0
    // BUGBUG:  george says using host config rom is wrong;
    //          use GetConfigurationInfo
    /* 
     *  GetConfigROM
     *
     *
     */
    NTSTATUS GetConfigROM(PDEVICE_OBJECT devObj)
    {
        PDEVICE_EXTENSION devExt;
        IRB irb;
        GET_LOCAL_HOST_INFO5 configRomInfo;
        NTSTATUS status;

        devExt = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

        BuildIRB_GetLocalHostInfo(&irb, GET_HOST_CONFIG_ROM, &configRomInfo);

        /*
         *  Make one call just to get the required length.
         */
        configRomInfo.ConfigRom = NULL;
        configRomInfo.ConfigRomLength = 0;
        status = HIDT_SubmitIRB(devObj, &irb);
        if (NT_SUCCESS(status)){
            if (configRomInfo.ConfigRomLength > 0){
                configRomInfo.ConfigRom = ExAllocatePoolWithTag(NonPagedPool, configRomInfo.ConfigRomLength, HID1394_TAG);
                if (configRomInfo.ConfigRom){
                    status = HIDT_SubmitIRB(devObj, &irb);
                    if (NT_SUCCESS(status)){
                        devExt->configROM = configRomInfo.ConfigRom;
                        devExt->configROMlength = configRomInfo.ConfigRomLength; 
                    }
                    else {
                        ExFreePool(configRomInfo.ConfigRom);
                    }
                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            else {
                ASSERT(configRomInfo.ConfigRomLength > 0);
                status = STATUS_DEVICE_DATA_ERROR;
            }
        }

        ASSERT(NT_SUCCESS(status));
        return status;
    }
#endif


NTSTATUS GetConfigInfo(PDEVICE_OBJECT devObj)
{
    PDEVICE_EXTENSION devExt;
    IRB irb;
    NTSTATUS status;

    devExt = GET_MINIDRIVER_DEVICE_EXTENSION(devObj);

    irb.FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
    irb.Flags = 0;

    /*
     *  Make one call just to get the required buffer lengths.
     */
    irb.u.GetConfigurationInformation.UnitDirectory = NULL; 
    irb.u.GetConfigurationInformation.UnitDirectoryBufferSize = 0; 
    irb.u.GetConfigurationInformation.UnitDependentDirectory = NULL; 
    irb.u.GetConfigurationInformation.UnitDependentDirectoryBufferSize = 0; 
    irb.u.GetConfigurationInformation.VendorLeaf = NULL; 
    irb.u.GetConfigurationInformation.VendorLeafBufferSize = 0; 
    irb.u.GetConfigurationInformation.ModelLeaf = NULL; 
    irb.u.GetConfigurationInformation.ModelLeafBufferSize = 0; 

    status = HIDT_SubmitIRB(devObj, &irb);
    if (NT_SUCCESS(status)){
        if (irb.u.GetConfigurationInformation.UnitDirectoryBufferSize           &&
            irb.u.GetConfigurationInformation.UnitDependentDirectoryBufferSize  &&
            irb.u.GetConfigurationInformation.VendorLeafBufferSize              &&
            irb.u.GetConfigurationInformation.ModelLeafBufferSize){

            /*
             *  Allocate the required buffers
             */
             
            irb.u.GetConfigurationInformation.UnitDirectory = 
                ExAllocatePoolWithTag(NonPagedPool, irb.u.GetConfigurationInformation.UnitDirectoryBufferSize, HID1394_TAG);
            irb.u.GetConfigurationInformation.UnitDependentDirectory = 
                ExAllocatePoolWithTag(NonPagedPool, irb.u.GetConfigurationInformation.UnitDependentDirectoryBufferSize, HID1394_TAG); 
            irb.u.GetConfigurationInformation.VendorLeaf =  
                ExAllocatePoolWithTag(NonPagedPool, irb.u.GetConfigurationInformation.VendorLeafBufferSize, HID1394_TAG);
            irb.u.GetConfigurationInformation.ModelLeaf =  
                ExAllocatePoolWithTag(NonPagedPool, irb.u.GetConfigurationInformation.ModelLeafBufferSize, HID1394_TAG);
        
            
            if (irb.u.GetConfigurationInformation.UnitDirectory             &&
                irb.u.GetConfigurationInformation.UnitDependentDirectory    &&
                irb.u.GetConfigurationInformation.VendorLeaf                &&
                irb.u.GetConfigurationInformation.ModelLeaf){

                irb.u.GetConfigurationInformation.ConfigRom = &devExt->configROM;

                status = HIDT_SubmitIRB(devObj, &irb);

                // BUGBUG FINISH
                // UnitDirectory contains sequence of keys.
                //    look for HID key ?

            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (!NT_SUCCESS(status)){
                /*
                 *  Free any of the buffers which we were able to allocate
                 */
                if (irb.u.GetConfigurationInformation.UnitDirectory){
                    ExFreePool(irb.u.GetConfigurationInformation.UnitDirectory);
                }
                if (irb.u.GetConfigurationInformation.UnitDependentDirectory){
                    ExFreePool(irb.u.GetConfigurationInformation.UnitDependentDirectory);
                }
                if (irb.u.GetConfigurationInformation.VendorLeaf){
                    ExFreePool(irb.u.GetConfigurationInformation.VendorLeaf);
                }
                if (irb.u.GetConfigurationInformation.ModelLeaf){
                    ExFreePool(irb.u.GetConfigurationInformation.ModelLeaf);
                }
            }
        }
        else {
            status = STATUS_BAD_DEVICE_TYPE;
        }
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\complete.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    complete.c

Abstract

    Completion routines for the major IRP functions.

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"



/*
 ********************************************************************************
 *  HidpSetMaxReportSize
 ********************************************************************************
 *
 *  Set the maxReportSize field in the HID device extension
 *
 */
ULONG HidpSetMaxReportSize(IN FDO_EXTENSION *fdoExtension)
{
    PHIDP_DEVICE_DESC deviceDesc = &fdoExtension->deviceDesc;
    ULONG i;

    /*
     *  For all reports (of all collections) for this device,
     *  find the length of the longest one.
     */
    fdoExtension->maxReportSize = 0;
    for (i = 0; i < deviceDesc->ReportIDsLength; i++){
        PHIDP_REPORT_IDS reportIdent = &deviceDesc->ReportIDs[i];
        PHIDCLASS_COLLECTION collection = GetHidclassCollection(fdoExtension, reportIdent->CollectionNumber);

        if (collection){
            if (reportIdent->InputLength > fdoExtension->maxReportSize){
                fdoExtension->maxReportSize = reportIdent->InputLength;
            }
        }
    }

    DBGASSERT(fdoExtension->maxReportSize, 
              ("Input length is zero for fdo %x.", fdoExtension->fdo), 
              FALSE)

    return fdoExtension->maxReportSize;
}



/*
 ********************************************************************************
 *  CompleteAllPendingReadsForFileExtension
 ********************************************************************************
 *
 *
 */
VOID CompleteAllPendingReadsForFileExtension(
                    PHIDCLASS_COLLECTION Collection,
                    PHIDCLASS_FILE_EXTENSION fileExtension)
{
    LIST_ENTRY irpsToComplete;
    PIRP irp;
    KIRQL oldIrql;

    ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);

    /*
     *  Move the IRPs to a private queue before completing so they don't
     *  get requeued on the completion thread, causing us to spin forever.
     */
    InitializeListHead(&irpsToComplete);
    LockFileExtension(fileExtension, &oldIrql);
    while (irp = DequeueInterruptReadIrp(Collection, fileExtension)){
        //
        // Irps are created from nonpaged pool, 
        // so this is ok to call at Dispatch level.
        //
        InsertTailList(&irpsToComplete, &irp->Tail.Overlay.ListEntry);
    }
    UnlockFileExtension(fileExtension, oldIrql);

    /*
     *  Complete all the dequeued read IRPs.
     */
    while (!IsListEmpty(&irpsToComplete)){
        PLIST_ENTRY listEntry = RemoveHeadList(&irpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        DBGVERBOSE(("Aborting pending read with status=%xh.", irp->IoStatus.Status))
        DBG_RECORD_READ(irp, 0, 0, TRUE)
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

}




/*
 ********************************************************************************
 *  CompleteAllPendingReadsForCollection
 ********************************************************************************
 *
 *
 */
VOID CompleteAllPendingReadsForCollection(PHIDCLASS_COLLECTION Collection)
{
    LIST_ENTRY tmpList;
    PLIST_ENTRY listEntry;
    KIRQL oldIrql;

    InitializeListHead(&tmpList);

    KeAcquireSpinLock(&Collection->FileExtensionListSpinLock, &oldIrql);

    /*
     *  We want to process each fileExtension in the list once.
     *  But we can't keep track of where to stop by just remembering
     *  the first item because fileExtensions can get closed while
     *  we're completing the reads.  So copy all the file extensions
     *  to a temporary list first.
     *
     *  This can all probably get removed, since this only gets called
     *  on a remove, when a create can not be received. In addition, 
     *  we would have received all close irps since remove only gets
     *  sent when all closes have come through.
     *
     */
    while (!IsListEmpty(&Collection->FileExtensionList)){
        listEntry = RemoveHeadList(&Collection->FileExtensionList);
        InsertTailList(&tmpList, listEntry);
    }


    /*
     *  Now put the fileExtensions back in the list 
     *  and cancel the reads on each file extension.
     */
    while (!IsListEmpty(&tmpList)){
        PHIDCLASS_FILE_EXTENSION fileExtension;

        listEntry = RemoveHeadList(&tmpList);

        /*
         *  Put the fileExtension back in FileExtensionList first
         *  so that it's there in case we get the close while
         *  completing the pending irps.
         */
        InsertTailList(&Collection->FileExtensionList, listEntry);

        fileExtension = CONTAINING_RECORD(listEntry, HIDCLASS_FILE_EXTENSION, FileList);

        /*
         *  We will be completing IRPs for this fileExtension.
         *  Always release all spinlocks before calling outside the driver.
         */
        KeReleaseSpinLock(&Collection->FileExtensionListSpinLock, oldIrql);
        CompleteAllPendingReadsForFileExtension(Collection, fileExtension);
        KeAcquireSpinLock(&Collection->FileExtensionListSpinLock, &oldIrql);
    }

    KeReleaseSpinLock(&Collection->FileExtensionListSpinLock, oldIrql);
}

/*
 ********************************************************************************
 *  CompleteAllPendingReadsForDevice
 ********************************************************************************
 *
 *
 */
VOID CompleteAllPendingReadsForDevice(FDO_EXTENSION *fdoExt)
{
    PHIDP_DEVICE_DESC deviceDesc = &fdoExt->deviceDesc;
    ULONG i;

    for (i = 0; i < deviceDesc->CollectionDescLength; i++){
        PHIDCLASS_COLLECTION collection = &fdoExt->classCollectionArray[i];
        CompleteAllPendingReadsForCollection(collection);
    }

}

/*
 ********************************************************************************
 *  HidpFreePowerEvent
 ********************************************************************************
 *
 *
 */
VOID
HidpFreePowerEventIrp(
    PHIDCLASS_COLLECTION Collection
    )
{
    PIRP powerEventIrpToComplete = NULL;
    KIRQL oldIrql;

    /*
     *  If a power event IRP is queued for this collection,
     *  fail it now.
     */
    KeAcquireSpinLock(&Collection->powerEventSpinLock, &oldIrql);
    if (ISPTR(Collection->powerEventIrp)){
        PDRIVER_CANCEL oldCancelRoutine;

        powerEventIrpToComplete = Collection->powerEventIrp;
        oldCancelRoutine = IoSetCancelRoutine(powerEventIrpToComplete, NULL);
        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == PowerEventCancelRoutine);
        }
        else {
            /*
             *  The IRP was cancelled and the cancel routine WAS called.
             *  The cancel routine will complete the IRP as soon as we drop the spinlock,
             *  so don't touch the IRP.
             */
            ASSERT(powerEventIrpToComplete->Cancel);
            powerEventIrpToComplete = NULL;
        }
        Collection->powerEventIrp = BAD_POINTER;
    }
    KeReleaseSpinLock(&Collection->powerEventSpinLock, oldIrql);
    if (powerEventIrpToComplete){
        powerEventIrpToComplete->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        *(PULONG)powerEventIrpToComplete->AssociatedIrp.SystemBuffer = 0;
        powerEventIrpToComplete->IoStatus.Information = 0;
        IoCompleteRequest(powerEventIrpToComplete, IO_NO_INCREMENT);
    }
}

/*
 ********************************************************************************
 *  HidpDestroyCollection
 ********************************************************************************
 *
 *
 */
VOID HidpDestroyCollection(FDO_EXTENSION *fdoExt, PHIDCLASS_COLLECTION Collection)
{
    #if DBG
        static int reentrancyCounter = 0;
        if (reentrancyCounter++ != 0) TRAP;
        
        ASSERT(Collection->Signature == HIDCLASS_COLLECTION_SIG);
    #endif
    
    CompleteAllPendingReadsForCollection(Collection);

    if (Collection->hidCollectionInfo.Polled){
        StopPollingLoop(Collection, TRUE);
    }


    HidpFreePowerEventIrp(Collection);

    #if DBG
        Collection->Signature = ~HIDCLASS_COLLECTION_SIG;
        reentrancyCounter--;
    #endif
}






/*
 ********************************************************************************
 *  HidpQueryCapsCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpQueryCapsCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PKEVENT event = Context;

    DBG_COMMON_ENTRY()

    KeSetEvent(event, 1, FALSE);

    DBG_COMMON_EXIT()

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\debug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: 

    debug.c

Abstract

                        Debug/performance routines

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

#if DBG

    // can poke this in the debugger to trap for warnings
    BOOLEAN dbgTrapOnWarn = FALSE;      

    BOOLEAN dbgTrapOnSS = FALSE;

    BOOLEAN dbgVerbose = FALSE;  

    BOOLEAN dbgInfo = TRUE;

    BOOLEAN dbgSkipSecurity = FALSE;

    BOOLEAN dbgTrapOnHiccup = FALSE;

    ULONG dbgLastEntry = 0;
    ULONG dbgInHidclass = 0;
    VOID DbgCommonEntryExit(BOOLEAN isEntering)
    {
        if (isEntering){
            dbgInHidclass++;
            #ifdef _X86_
                _asm nop
                _asm mov eax, [ebp+4]   /*  <- set breakpt here */
                _asm mov dbgLastEntry, eax
            #endif
        }
        else {
            dbgInHidclass--;
        }
    }

    VOID InitFdoExtDebugInfo(PHIDCLASS_DEVICE_EXTENSION hidclassExt)
    {
        FDO_EXTENSION *fdoExt = &hidclassExt->fdoExt;
        NTSTATUS status;
        ULONG actualLen;

        status = IoGetDeviceProperty(   hidclassExt->hidExt.PhysicalDeviceObject,
                                        DevicePropertyDriverKeyName,
                                        sizeof(fdoExt->dbgDriverKeyName),
                                        fdoExt->dbgDriverKeyName,
                                        &actualLen);

        if (!NT_SUCCESS(status)) {
            //
            // We couldn't get the driver key name.  This will happen during
            // textmode setup on NT, for example, when we're loaded as part of
            // bootstrapping the system (long before the device installer/class
            // installer have run).
            //
            // Simply initialize the driver key name field to an empty string.
            //
            *(fdoExt->dbgDriverKeyName) = L'\0';
        }
    }


        ULONG dbgMinInterruptDelta = 0x0fffffff;
        ULONG dbgMaxInterruptsPerSecond = 0;
        ULONG dbgShortestInt = 0x0fffffff;
        ULONG dbgLongestInt = 0;
        LARGE_INTEGER dbgLastIntStart = {0};
        ULONG dbgAveIntTime = 0;

        VOID DbgLogIntStart()
        {
                static ULONG dbgInterruptsThisSecond = 0;
                static ULONG dbgThisSecondStartTime = 0;

                LARGE_INTEGER timeNow;
                ULONG lastTimeMilliSec, timeNowMilliSec;

                KeQuerySystemTime(&timeNow);

                // convert from usec to millisec
                timeNowMilliSec = timeNow.LowPart/10000;
                lastTimeMilliSec = dbgLastIntStart.LowPart/10000;

                if (timeNow.HighPart == dbgLastIntStart.HighPart){
                        ULONG delta = timeNowMilliSec - lastTimeMilliSec;

                        if (delta < dbgMinInterruptDelta){
                                dbgMinInterruptDelta = delta;
                        }

                        if (timeNowMilliSec - dbgThisSecondStartTime < 1000){
                                dbgInterruptsThisSecond++;
                                if (dbgInterruptsThisSecond > dbgMaxInterruptsPerSecond){
                                        dbgMaxInterruptsPerSecond = dbgInterruptsThisSecond;
                                }
                        }
                        else {
                                dbgThisSecondStartTime = timeNowMilliSec;
                                dbgInterruptsThisSecond = 0;
                        }
                }
                else {
                        // this case is harder so skip it
                        dbgThisSecondStartTime = timeNowMilliSec;
                        dbgInterruptsThisSecond = 0;
                }

                dbgLastIntStart = timeNow;
        }

        VOID DbgLogIntEnd()
        {
            LARGE_INTEGER timeNow;

            KeQuerySystemTime(&timeNow);

            if (timeNow.HighPart == dbgLastIntStart.HighPart){ 
                    ULONG timeNowMilliSec = timeNow.LowPart/10000;
                    ULONG intStartTimeMilliSec = dbgLastIntStart.LowPart/10000;
                    ULONG delta = timeNowMilliSec - intStartTimeMilliSec;

                    if (delta < dbgShortestInt){
                        dbgShortestInt = delta;
                    }
                    else if (delta > dbgLongestInt){
                        dbgLongestInt = delta;
                    }

                    {
                        static ULONG dbgIntCount = 0;
                        static ULONG dbgTimeLast1000Ints = 0;

                        if (dbgIntCount < 1000){
                                dbgIntCount++;
                                dbgTimeLast1000Ints += delta;
                        }
                        else {
                                dbgAveIntTime = dbgTimeLast1000Ints/1000;
                                dbgTimeLast1000Ints = 0;
                                dbgIntCount = 0;
                        }
                    }

            }
            else {
                // This is harder so we just skip it
            }

        }


        NTSTATUS DbgTestGetDeviceStringCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
        {
        ASSERT(NT_SUCCESS(Irp->IoStatus.Status));
                ExFreePool(Irp->UserBuffer);
                IoFreeIrp(Irp);
                return STATUS_MORE_PROCESSING_REQUIRED;
        }


        VOID DbgTestGetDeviceString(PFDO_EXTENSION fdoExt)
        {
            PIRP Irp;
            const ULONG inputLen = 200;

            Irp = IoAllocateIrp(fdoExt->fdo->StackSize, FALSE);
            if (Irp){
                Irp->UserBuffer = ALLOCATEPOOL(NonPagedPool, inputLen); 
                if (Irp->UserBuffer){
                    ULONG stringId = HID_STRING_ID_IMANUFACTURER;
                    ULONG languageId = 0x0409;      // English
                    PIO_STACK_LOCATION currentIrpSp = IoGetCurrentIrpStackLocation(Irp);

                    Irp->MdlAddress->MappedSystemVa = Irp->UserBuffer;
                    Irp->MdlAddress->MdlFlags |= MDL_SOURCE_IS_NONPAGED_POOL;
                    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

                    currentIrpSp->Parameters.DeviceIoControl.OutputBufferLength = inputLen;

                    IoSetCompletionRoutine( Irp, 
                                            DbgTestGetDeviceStringCompletion, 
                                            (PVOID)NULL, 
                                            TRUE, 
                                            TRUE, 
                                            TRUE);

                    HidpGetDeviceString(fdoExt, Irp, stringId, languageId);
                }
            }
        }

        VOID DbgTestGetIndexedString(PFDO_EXTENSION fdoExt)
        {
            PIRP Irp;
            const ULONG inputLen = 200;

            Irp = IoAllocateIrp(fdoExt->fdo->StackSize, FALSE);
            if (Irp){
                Irp->UserBuffer = ALLOCATEPOOL(NonPagedPool, inputLen); 
                if (Irp->UserBuffer){
                    ULONG stringIndex = 1;      // ???
                    ULONG languageId = 0x0409;      // English
                    PIO_STACK_LOCATION currentIrpSp = IoGetCurrentIrpStackLocation(Irp);

                    Irp->MdlAddress->MappedSystemVa = Irp->UserBuffer;
                    Irp->MdlAddress->MdlFlags |= MDL_SOURCE_IS_NONPAGED_POOL;

                    currentIrpSp->Parameters.DeviceIoControl.InputBufferLength = inputLen;

                    IoSetCompletionRoutine( Irp, 
                                                                    DbgTestGetDeviceStringCompletion, 
                                                                    (PVOID)NULL, 
                                                                    TRUE, 
                                                                    TRUE, 
                                                                    TRUE);

                    HidpGetIndexedString(fdoExt, Irp, stringIndex, languageId);
                }
            }
        }

    #define DBG_MAX_DEVOBJ_RECORDS 100
    dbgDevObjRecord dbgDevObjs[DBG_MAX_DEVOBJ_RECORDS] = {0};

    VOID DbgRecordDevObj(PDEVICE_OBJECT devObj, PCHAR str)
    {
        ULONG i;   

        for (i = 0; i < DBG_MAX_DEVOBJ_RECORDS; i++){
            if (!ISPTR(dbgDevObjs[i].devObj)){
                break;
            }
            else if (dbgDevObjs[i].devObj == devObj){
                // already there
                break;
            }
        }       

        if ((i < DBG_MAX_DEVOBJ_RECORDS) && !dbgDevObjs[i].devObj){
            ULONG j;
            dbgDevObjs[i].devObj = devObj;
            for (j = 0; str[j] && (j < dbgDevObjRecord_STRINGSIZE); j++){
                dbgDevObjs[i].str[j] = str[j];
            }
        }
    }

    #define DBG_MAX_FEATURE_RECORDS 0x1000
    dbgFeatureRecord dbgFeatures[DBG_MAX_FEATURE_RECORDS] = {0};
    ULONG dbgFeatureFirstFreeIndex = 0;
    VOID DbgRecordReport(ULONG reportId, ULONG controlCode, BOOLEAN isComplete)
    {
        ULONG typeId;
        
        switch (controlCode){
        case IOCTL_HID_GET_FEATURE: typeId = (ULONG)'fteG'; break;
        case IOCTL_HID_SET_FEATURE: typeId = (ULONG)'fteS'; break;
        case IOCTL_HID_GET_INPUT_REPORT: typeId = (ULONG)'iteG'; break;
        case IOCTL_HID_SET_OUTPUT_REPORT: typeId = (ULONG)'oteS'; break;
            default:                    typeId = (ULONG)'xxxx'; TRAP; break;
        }

        if (isComplete){
            LONG i;
            // step back to find the report that got completed
            // assumes no overlapped calls to same feature
            ASSERT(dbgFeatureFirstFreeIndex > 0);
            i = dbgFeatureFirstFreeIndex-1;
            while ((i >= 0) && 
                   ((dbgFeatures[i].reportId != reportId) ||
                    (dbgFeatures[i].type != typeId)       ||
                    dbgFeatures[i].completed)){
                i--;
            }
            ASSERT(i >= 0);
            if (i >= 0){
                dbgFeatures[i].completed = 1;
            }
        }
        else {
            if (dbgFeatureFirstFreeIndex >= DBG_MAX_FEATURE_RECORDS){
                RtlZeroMemory(dbgFeatures, sizeof(dbgFeatures));
                dbgFeatureFirstFreeIndex = 0;
            }

            dbgFeatures[dbgFeatureFirstFreeIndex].marker = (ULONG)'taeF';
            dbgFeatures[dbgFeatureFirstFreeIndex].reportId = reportId;
            dbgFeatures[dbgFeatureFirstFreeIndex].type = typeId;
            dbgFeatures[dbgFeatureFirstFreeIndex].completed = 0;
            dbgFeatureFirstFreeIndex++;
        }

    }


    #define DBG_MAX_READ_RECORDS 0x1000
    dbgReadRecord dbgReads[DBG_MAX_READ_RECORDS] = {0};
    VOID DbgRecordRead(PIRP irp, ULONG length, ULONG reportId, ULONG completed)
    {
        LONG i;

        for (i = 0; 
            (i < DBG_MAX_READ_RECORDS) && 
            dbgReads[i].irpPtr && 
            ((dbgReads[i].irpPtr != (ULONG_PTR)irp) || dbgReads[i].completed);
             i++){
        }

        if (i < DBG_MAX_READ_RECORDS){
            if (dbgReads[i].irpPtr){
                ASSERT(dbgReads[i].irpPtr == (ULONG_PTR)irp);
                ASSERT(!dbgReads[i].completed);
                ASSERT(completed);
                dbgReads[i].length = length;
                dbgReads[i].reportId = reportId;
                dbgReads[i].completed = completed;
            }
            else {
                dbgReads[i].irpPtr = (ULONG_PTR)irp;
                dbgReads[i].length = length;
                dbgReads[i].reportId = reportId;
                dbgReads[i].completed = completed;
            }
        }

    }


    VOID DbgLogIrpMajor(ULONG_PTR irpPtr, ULONG majorFunc, ULONG isForCollectionPdo, ULONG isComplete, ULONG status)
    {

        if (dbgVerbose){
            char *funcName;

            switch (majorFunc){
                #undef MAKE_CASE
                #define MAKE_CASE(fnc) case fnc: funcName = #fnc; break;

                MAKE_CASE(IRP_MJ_CREATE)
                MAKE_CASE(IRP_MJ_CREATE_NAMED_PIPE)
                MAKE_CASE(IRP_MJ_CLOSE)
                MAKE_CASE(IRP_MJ_READ)
                MAKE_CASE(IRP_MJ_WRITE)
                MAKE_CASE(IRP_MJ_QUERY_INFORMATION)
                MAKE_CASE(IRP_MJ_SET_INFORMATION)
                MAKE_CASE(IRP_MJ_QUERY_EA)
                MAKE_CASE(IRP_MJ_SET_EA)
                MAKE_CASE(IRP_MJ_FLUSH_BUFFERS)
                MAKE_CASE(IRP_MJ_QUERY_VOLUME_INFORMATION)
                MAKE_CASE(IRP_MJ_SET_VOLUME_INFORMATION)
                MAKE_CASE(IRP_MJ_DIRECTORY_CONTROL)
                MAKE_CASE(IRP_MJ_FILE_SYSTEM_CONTROL)
                MAKE_CASE(IRP_MJ_DEVICE_CONTROL)
                MAKE_CASE(IRP_MJ_INTERNAL_DEVICE_CONTROL)
                MAKE_CASE(IRP_MJ_SHUTDOWN)
                MAKE_CASE(IRP_MJ_LOCK_CONTROL)
                MAKE_CASE(IRP_MJ_CLEANUP)
                MAKE_CASE(IRP_MJ_CREATE_MAILSLOT)
                MAKE_CASE(IRP_MJ_QUERY_SECURITY)
                MAKE_CASE(IRP_MJ_SET_SECURITY)
                MAKE_CASE(IRP_MJ_POWER)
                MAKE_CASE(IRP_MJ_SYSTEM_CONTROL)
                MAKE_CASE(IRP_MJ_DEVICE_CHANGE)
                MAKE_CASE(IRP_MJ_QUERY_QUOTA)
                MAKE_CASE(IRP_MJ_SET_QUOTA)
                MAKE_CASE(IRP_MJ_PNP)

                default: funcName = NULL;    break;
            }

            if (isComplete){
                if (funcName){
                    DBGOUT(("< %s for %s status=%xh (irp=%ph)",
                            funcName,
                            isForCollectionPdo ? "collection" : "device",
                            status,
                            irpPtr));
                }
                else {
                    DBGOUT(("< ????<majorFunc=%xh> for %s status=%xh (irp=%ph)",
                            majorFunc,
                            isForCollectionPdo ? "collection" : "device",
                            status,
                            irpPtr));
                }
            }
            else {
                if (funcName){
                    DBGOUT(("> %s (irp=%xh)", funcName, irpPtr));
                }
                else {
                    DBGOUT(("> ????<majorFunc=%xh> (irp=%xh)", majorFunc, irpPtr));
                }
            }
        }

    }



    #define DBG_MAX_PNP_IRP_RECORDS 0x1000
    dbgPnPIrpRecord dbgPnPIrps[DBG_MAX_PNP_IRP_RECORDS] = {0};

    VOID DbgLogPnpIrp(ULONG_PTR irpPtr, ULONG minorFunc, ULONG isForCollectionPdo, ULONG isComplete, ULONG status)
    {
        char *funcName;
        ULONG funcShortName;
        int i;

        switch (minorFunc){
            #undef MAKE_CASE
            #define MAKE_CASE(fnc) case fnc: funcName = #fnc; funcShortName = *(ULONG *)(funcName+7); break;

            MAKE_CASE(IRP_MN_START_DEVICE)
            MAKE_CASE(IRP_MN_QUERY_REMOVE_DEVICE)
            MAKE_CASE(IRP_MN_REMOVE_DEVICE)
            MAKE_CASE(IRP_MN_CANCEL_REMOVE_DEVICE)
            MAKE_CASE(IRP_MN_STOP_DEVICE)
            MAKE_CASE(IRP_MN_QUERY_STOP_DEVICE)
            MAKE_CASE(IRP_MN_CANCEL_STOP_DEVICE)
            MAKE_CASE(IRP_MN_QUERY_DEVICE_RELATIONS)
            MAKE_CASE(IRP_MN_QUERY_INTERFACE)
            MAKE_CASE(IRP_MN_QUERY_CAPABILITIES)
            MAKE_CASE(IRP_MN_QUERY_RESOURCES)
            MAKE_CASE(IRP_MN_QUERY_RESOURCE_REQUIREMENTS)
            MAKE_CASE(IRP_MN_QUERY_DEVICE_TEXT)
            MAKE_CASE(IRP_MN_READ_CONFIG)
            MAKE_CASE(IRP_MN_WRITE_CONFIG)
            MAKE_CASE(IRP_MN_EJECT)
            MAKE_CASE(IRP_MN_SET_LOCK)
            MAKE_CASE(IRP_MN_QUERY_ID)
            MAKE_CASE(IRP_MN_QUERY_PNP_DEVICE_STATE)
            MAKE_CASE(IRP_MN_QUERY_BUS_INFORMATION)
            MAKE_CASE(IRP_MN_DEVICE_USAGE_NOTIFICATION)
            MAKE_CASE(IRP_MN_SURPRISE_REMOVAL)

#ifndef IRP_MN_QUERY_LEGACY_BUS_INFORMATION
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
#endif // IRP_MN_QUERY_LEGACY_BUS_INFORMATION
            MAKE_CASE(IRP_MN_QUERY_LEGACY_BUS_INFORMATION)

            default: funcName = NULL; funcShortName = (ULONG)'\?\?\?\?'; break;
        }

        if (dbgVerbose){
            if (isComplete){
                if (funcName){
                    DBGOUT((" < %s for %s status=%xh (irp=%ph)", 
                            funcName, 
                            isForCollectionPdo ? "collection" : "device",
                            status,
                            irpPtr));
                }
                else {
                    DBGOUT((" < ?? <minorFunc=%xh> for %s status=%xh (irp=%ph)", 
                            minorFunc, 
                            isForCollectionPdo ? "collection" : "device",
                            status,
                            irpPtr));
                }
            }
            else {
                if (funcName){
                    DBGOUT((" > %s for %s (irp=%xh)", 
                            funcName, 
                            isForCollectionPdo ? "collection" : "device",
                            irpPtr));
                }
                else {
                    DBGOUT((" > ?? <minorFunc=%xh> for %s (irp=%xh)", 
                            minorFunc, 
                            isForCollectionPdo ? "collection" : "device",
                            irpPtr));
                }
            }
        }

        if (isComplete){
            for (i = 0; (i < DBG_MAX_PNP_IRP_RECORDS) && dbgPnPIrps[i].irpPtr; i++){
                if ((dbgPnPIrps[i].irpPtr == irpPtr) &&
                    ((dbgPnPIrps[i].status == 0xFFFFFFFF) || (dbgPnPIrps[i].status == STATUS_PENDING))){
                    dbgPnPIrps[i].status = status;
                    break;
                }

            }        
        }
        else {
            for (i = 0; i < DBG_MAX_PNP_IRP_RECORDS; i++){
                if (!dbgPnPIrps[i].irpPtr){
                    dbgPnPIrps[i].irpPtr = irpPtr;
                    dbgPnPIrps[i].func = funcShortName;
                    dbgPnPIrps[i].isForCollectionPdo = isForCollectionPdo;
                    dbgPnPIrps[i].status = 0xFFFFFFFF;
                    break;                  
                }
            }
        }


    }


    VOID DbgLogPowerIrp(PVOID devExt, UCHAR minorFunc, ULONG isClientPdo, ULONG isComplete, PCHAR type, ULONG powerState, ULONG status)
    {
        char *funcName;

        switch (minorFunc){
            #undef MAKE_CASE
            #define MAKE_CASE(fnc) case fnc: funcName = #fnc; break;

            MAKE_CASE(IRP_MN_WAIT_WAKE)
            MAKE_CASE(IRP_MN_POWER_SEQUENCE)
            MAKE_CASE(IRP_MN_SET_POWER)
            MAKE_CASE(IRP_MN_QUERY_POWER)

            default: funcName = "????"; break;
        }
        
        
        if (dbgVerbose){
            if (isComplete){
                DBGOUT((" < %s for %s(ext=%ph) status=%xh ", 
                        funcName, 
                        isClientPdo ? "collection" : "device",
                        devExt,
                        status));
            }
            else if (minorFunc == IRP_MN_SET_POWER){
                DBGOUT((" > %s for %s(ext=%ph) type=%s, powerState=%ph", 
                        funcName, 
                        isClientPdo ? "collection" : "device",
                        devExt,
                        type,
                        powerState));
            }
            else {
                DBGOUT((" > %s for %s(ext=%ph) ", 
                        funcName, 
                        isClientPdo ? "collection" : "device",
                        devExt));
            }
        }


    }



    #define DBG_MAX_REPORT_RECORDS 0x100
    dbgReportRecord dbgReportRecords[DBG_MAX_REPORT_RECORDS] = { 0 };
    ULONG dbgCurrentReportRecord = 0;

    VOID DbgLogReport(ULONG collectionNumber, ULONG numRecipients, ULONG numPending, ULONG numFailed, PUCHAR report, ULONG reportLength)
    {
        ASSERT(dbgCurrentReportRecord <= DBG_MAX_REPORT_RECORDS);
        
        if (dbgCurrentReportRecord == DBG_MAX_REPORT_RECORDS){
            RtlZeroMemory(dbgReportRecords, DBG_MAX_REPORT_RECORDS*sizeof(dbgReportRecord)); 
            dbgCurrentReportRecord = 0;
        }

        dbgReportRecords[dbgCurrentReportRecord].collectionNumber = (UCHAR)collectionNumber;
        dbgReportRecords[dbgCurrentReportRecord].numRecipients = (UCHAR)numRecipients;
        if (reportLength > sizeof(dbgReportRecords[dbgCurrentReportRecord].reportBytes)){
            reportLength = sizeof(dbgReportRecords[dbgCurrentReportRecord].reportBytes);
        }
        RtlCopyMemory((PUCHAR)dbgReportRecords[dbgCurrentReportRecord].reportBytes, report, reportLength);

        dbgCurrentReportRecord++;

        if (dbgVerbose){
            ULONG i;

            DBGOUT(("Report (cltn #%d, %d recipients; %d pending, %d failed):", collectionNumber, numRecipients, numPending, numFailed));
            DbgPrint("'\t report bytes: \t");
            for (i = 0; i < reportLength; i++){
                DbgPrint("%02x ", report[i]);
            }
            DbgPrint("\n");
        }
    }


    VOID DbgLogIoctl(ULONG_PTR fdo, ULONG ioControlCode, ULONG status)
    {
        if (dbgVerbose){
            PCHAR ioctlStr;

            switch (ioControlCode){
                #undef MAKE_CASE
                #define MAKE_CASE(ioctl) case ioctl: ioctlStr = #ioctl; break;

                MAKE_CASE(IOCTL_HID_GET_DRIVER_CONFIG)
                MAKE_CASE(IOCTL_HID_SET_DRIVER_CONFIG)
                MAKE_CASE(IOCTL_HID_GET_POLL_FREQUENCY_MSEC)
                MAKE_CASE(IOCTL_HID_SET_POLL_FREQUENCY_MSEC)
                MAKE_CASE(IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS)
                MAKE_CASE(IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS)
                MAKE_CASE(IOCTL_HID_GET_COLLECTION_INFORMATION)
                MAKE_CASE(IOCTL_HID_GET_COLLECTION_DESCRIPTOR)
                MAKE_CASE(IOCTL_HID_FLUSH_QUEUE)
                MAKE_CASE(IOCTL_HID_SET_FEATURE)
                MAKE_CASE(IOCTL_HID_GET_FEATURE)
                MAKE_CASE(IOCTL_GET_PHYSICAL_DESCRIPTOR)
                MAKE_CASE(IOCTL_HID_GET_HARDWARE_ID)
                MAKE_CASE(IOCTL_HID_GET_MANUFACTURER_STRING)
                MAKE_CASE(IOCTL_HID_GET_PRODUCT_STRING)
                MAKE_CASE(IOCTL_HID_GET_SERIALNUMBER_STRING)
                MAKE_CASE(IOCTL_HID_GET_INDEXED_STRING)
                MAKE_CASE(IOCTL_INTERNAL_HID_SET_BLUESCREEN)

                default: ioctlStr = "???"; break;
            }

            DBGOUT(("IOCTL %s (%xh) status=%xh (fdo=%ph)", 
                    ioctlStr, ioControlCode, status, fdo));
        }
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\driverex.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    driverex.c

Abstract

    Driver extension list management.

Authors:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

/*
 *  Including initguid.h defines the INITGUID symbol, which causes
 *  GUID_CLASS_INPUT (in hidclass.h and poclass.h) 
 *  and GUID_DEVICE_SYS_BUTTON (in poclass.h) to get defined.
 */
#include <initguid.h>
#include <hidclass.h>   // hidclass.h only defines GUID_CLASS_INPUT 
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, DllInitialize)
    #pragma alloc_text(PAGE, DllUnload)
    #pragma alloc_text(PAGE, DriverEntry)
#endif


LIST_ENTRY driverExtList;
FAST_MUTEX driverExtListMutex;

//
// Global counter of HID FDOs used for device object naming, destined to go
// away once the device object naming issues are ironed out
//

ULONG HidpNextHidNumber = 0;

#define MAKEULONG(low, high)     ((ULONG)(((USHORT)(low)) | (((ULONG)((USHORT)(high))) << 16)))

/*
 ********************************************************************************
 *  EnqueueDriverExt
 ********************************************************************************
 *
 *
 */
BOOLEAN EnqueueDriverExt(PHIDCLASS_DRIVER_EXTENSION driverExt)
{
    PLIST_ENTRY listEntry;
    BOOLEAN result = TRUE;

    DBGVERBOSE(("Enqueue driver extension..."));
    ExAcquireFastMutex(&driverExtListMutex);

    /*
     *  Make sure this driver entry is not already in our list.
     */
    listEntry = &driverExtList;
    while ((listEntry = listEntry->Flink) != &driverExtList){
        PHIDCLASS_DRIVER_EXTENSION thisDriverExt;

        thisDriverExt = CONTAINING_RECORD(  listEntry,
                                            HIDCLASS_DRIVER_EXTENSION,
                                            ListEntry);
        if (thisDriverExt == driverExt){
            /*
             *  This driver extension is already in our list!
             */
            ASSERT(thisDriverExt != driverExt);
            result = FALSE;
            break;
        }
    }

    if (result){
        InsertHeadList(&driverExtList, &driverExt->ListEntry);
    }

    ExReleaseFastMutex(&driverExtListMutex);

    return result;
}

/*
 ********************************************************************************
 *  RefDriverExt
 ********************************************************************************
 *
 *
 */
PHIDCLASS_DRIVER_EXTENSION RefDriverExt(IN PDRIVER_OBJECT MinidriverObject)
{
    PLIST_ENTRY listEntry;
    PHIDCLASS_DRIVER_EXTENSION hidDriverExtension, result = NULL;

    DBGVERBOSE(("Ref driver extension..."));
    ExAcquireFastMutex(&driverExtListMutex);

    listEntry = &driverExtList;
    while ((listEntry = listEntry->Flink) != &driverExtList){

        hidDriverExtension = CONTAINING_RECORD( listEntry,
                                                HIDCLASS_DRIVER_EXTENSION,
                                                ListEntry );
        ASSERT(ISPTR(hidDriverExtension));
        if (hidDriverExtension->MinidriverObject == MinidriverObject){
            hidDriverExtension->ReferenceCount++;
            result = hidDriverExtension;
            break;
        }
    }

    ExReleaseFastMutex(&driverExtListMutex);

    ASSERT(result);
    return result;
}


/*
 ********************************************************************************
 *  DerefDriverExt
 ********************************************************************************
 *
 */
PHIDCLASS_DRIVER_EXTENSION DerefDriverExt(IN PDRIVER_OBJECT MinidriverObject)
{
    PLIST_ENTRY listEntry;
    PHIDCLASS_DRIVER_EXTENSION result = NULL;

    DBGVERBOSE(("Deref driver extension..."));
    ExAcquireFastMutex(&driverExtListMutex);

    listEntry = &driverExtList;
    while ((listEntry = listEntry->Flink) != &driverExtList){

        PHIDCLASS_DRIVER_EXTENSION hidDriverExtension = 
                CONTAINING_RECORD(  listEntry,
                                    HIDCLASS_DRIVER_EXTENSION,
                                    ListEntry);
        ASSERT(ISPTR(hidDriverExtension));

        if (hidDriverExtension->MinidriverObject == MinidriverObject){

            hidDriverExtension->ReferenceCount--;
            
            /*
             *  The extra dereference in HidpDriverUnload should
             *  cause this ReferenceCount to eventually go to -1;
             *  at that time, we can dequeue it.
             */
            if (hidDriverExtension->ReferenceCount < 0){
                /*
                 *  No need to free hidDriverExtension;
                 *  it gets freed when the driver object is freed.
                 */
                ASSERT(hidDriverExtension->ReferenceCount == -1);
                RemoveEntryList(listEntry);
                if (hidDriverExtension->RegistryPath.Buffer) {
                    ExFreePool(hidDriverExtension->RegistryPath.Buffer);
                }
            }

            result = hidDriverExtension; 
            break;
        }
    }

    ExReleaseFastMutex(&driverExtListMutex);

    ASSERT(result);
    return result;
}

/*
 ********************************************************************************
 *  DllUnload
 ********************************************************************************
 *
 *  We need this routine so that the driver can get unloaded when all 
 *  references have been dropped by the minidriver.
 *
 */
NTSTATUS 
DllUnload (VOID)
{
    PAGED_CODE();
    DBGVERBOSE(("Unloading..."));
    return STATUS_SUCCESS;
}

/*
 ********************************************************************************
 *  DllInitialize
 ********************************************************************************
 *
 *  This routine called instead of DriverEntry since we're loaded as a DLL. 
 *
 */
NTSTATUS 
DllInitialize (PUNICODE_STRING RegistryPath)
{
    PAGED_CODE();
    DBGVERBOSE(("Initializing hidclass dll..."));
    InitializeListHead(&driverExtList);
    ExInitializeFastMutex(&driverExtListMutex);

    HidpNextHidNumber = 0;
    
    return STATUS_SUCCESS;
}

/*
 ********************************************************************************
 *  DriverEntry
 ********************************************************************************
 *
 *  This routine is required by the linker, 
 *  but SHOULD NEVER BE CALLED since we're loaded as a DLL. 
 *
 */
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    PAGED_CODE();
    ASSERT(!(PVOID)"DriverEntry should never get called!");

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\debug.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains definitions related to debugging.

Author:

    Forrest Foltz (forrestf)
    Ervin P.

Revision History:

--*/


#define BAD_POINTER ((PVOID) (ULONG_PTR)-0x50)
#define ISPTR(ptr) ((ptr) && ((ptr) != BAD_POINTER))

#if DBG

    #if WIN95_BUILD
        #define DBG_LEADCHAR ' '
    #else
        #define DBG_LEADCHAR '\''   // required for kd debugger routing on NT
    #endif

    #define TRAP                                        \
        {                                               \
            DbgPrint("%cHIDCLASS> Code coverage trap: file %s, line %d \n",  DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgBreakPoint();                            \
        }

    #define SS_TRAP                                        \
        {   \
            if (dbgTrapOnSS) {                                         \
                DbgPrint("%cHIDCLASS> Selective suspend trap: file %s, line %d \n",  DBG_LEADCHAR, __FILE__, __LINE__ ); \
                DbgBreakPoint();                            \
            }\
        }
    extern BOOLEAN dbgTrapOnWarn;
    extern BOOLEAN dbgTrapOnSS;
    extern BOOLEAN dbgInfo;
    extern BOOLEAN dbgVerbose;
    extern BOOLEAN dbgSkipSecurity;
    extern BOOLEAN dbgTrapOnHiccup;

    #define DBGWARN(args_in_parens)                                \
        {                                               \
            DbgPrint("%cHIDCLASS> *** WARNING *** (file %s, line %d)\n", DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgPrint("%c    > ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            if (dbgTrapOnWarn){ \
                DbgBreakPoint();                            \
            } \
        }
    #define DBGERR(args_in_parens)                                \
        {                                               \
            DbgPrint("%cHIDCLASS> *** ERROR *** (file %s, line %d)\n", DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgPrint("%c    > ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            DbgBreakPoint();                            \
        }
    #define DBGASSERT(check, args_in_parens, trap) \
        { \
            if (!(check)) { \
                if (trap) { \
                    DBGERR(args_in_parens); \
                } else { \
                    DBGWARN(args_in_parens); \
                } \
            } \
        }

    #define DBGSTATE(current, expected, trap) \
        DBGASSERT(current == expected, \
                  ("Expected state %d, got state %d", expected, current), \
                  trap) 
    
    #define DBGSUCCESS(status, trap) \
        DBGASSERT(NT_SUCCESS(status), \
                  ("Not STATUS_SUCCESS, actual status = %x", status), \
                  trap)
    #define DBGOUT(args_in_parens)                                \
        {                                               \
            DbgPrint("%cHIDCLASS> ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
        }
    #define DBGVERBOSE(args_in_parens) if (dbgVerbose){ DBGOUT(args_in_parens); }
    #define DBGINFO(args_in_parens) if (dbgInfo){ DBGOUT(args_in_parens); }

    typedef struct {
            // exactly 16 bytes long for easy debugger viewing
            PDEVICE_OBJECT devObj;

            #define dbgDevObjRecord_STRINGSIZE 12
            CHAR str[dbgDevObjRecord_STRINGSIZE];
        } dbgDevObjRecord;

    typedef struct {
            // exactly 16 bytes long for easy debugger viewing
            ULONG marker;
            ULONG reportId;
            ULONG type;
            ULONG completed;
        } dbgFeatureRecord;

    typedef struct {
            // exactly 16 bytes long for easy debugger viewing
            ULONG_PTR irpPtr;
            ULONG length;
            ULONG reportId;
            ULONG completed;
        } dbgReadRecord;

    typedef struct {
            // exactly 16 bytes long for easy debugger viewing
            ULONG_PTR irpPtr;
            ULONG func;
            ULONG isForCollectionPdo;
            ULONG status;
        } dbgPnPIrpRecord;

    typedef struct {
            // exactly 16 bytes long for easy debugger viewing
        UCHAR collectionNumber;
        UCHAR numRecipients;
        UCHAR reportBytes[14];
    } dbgReportRecord;

    extern ULONG dbgLastEntry;
    VOID DbgCommonEntryExit(BOOLEAN isEntering);
    VOID DbgRecordDevObj(PDEVICE_OBJECT devObj, PCHAR str);
    VOID DbgRecordReport(ULONG reportId, ULONG controlCode, BOOLEAN isComplete);
    VOID DbgRecordRead(PIRP irp, ULONG length, ULONG reportId, ULONG completed);
    VOID DbgLogIrpMajor(ULONG_PTR irpPtr, ULONG majorFunc, ULONG isForCollectionPdo, ULONG isComplete, ULONG status);
    VOID DbgLogPnpIrp(ULONG_PTR irpPtr, ULONG minorFunc, ULONG isForCollectionPdo, ULONG isComplete, ULONG status);
    VOID DbgLogPowerIrp(PVOID devExt, UCHAR minorFunc, ULONG isClientPdo, ULONG isComplete, PCHAR type, ULONG powerState, ULONG status);
    VOID DbgLogReport(ULONG collectionNumber, ULONG numRecipients, ULONG numPending, ULONG numFailed, PUCHAR report, ULONG reportLength);
    VOID DbgLogIoctl(ULONG_PTR fdo, ULONG ioControlCode, ULONG status);

    #define DBG_COMMON_ENTRY() DbgCommonEntryExit(TRUE);
    #define DBG_COMMON_EXIT() DbgCommonEntryExit(FALSE);
    #define DBG_RECORD_DEVOBJ(devObj, str) DbgRecordDevObj(devObj, str);
    #define DBG_RECORD_REPORT(reportId, controlCode, isComplete) \
                DbgRecordReport(reportId, controlCode, isComplete);
    #define DBG_RECORD_READ(irp, length, reportId, completed) \
                DbgRecordRead(irp, length, reportId, completed);
    #define DBG_LOG_IRP_MAJOR(irp, majorFunc, isForCollectionPdo, isComplete, status) \
                DbgLogIrpMajor((ULONG_PTR)(irp), (ULONG)(majorFunc), (ULONG)(isForCollectionPdo), (ULONG)(isComplete), (ULONG)(status));
    #define DBG_LOG_PNP_IRP(irp, minorFunc, isForCollectionPdo, isComplete, status) \
                DbgLogPnpIrp((ULONG_PTR)(irp), (ULONG)(minorFunc), (ULONG)(isForCollectionPdo), (ULONG)(isComplete), (ULONG)(status));
    #define DBG_LOG_POWER_IRP(devExt, minorFunc, isClientPdo, isComplete, type, powerState, status) \
                DbgLogPowerIrp(devExt, minorFunc, isClientPdo, isComplete, type, powerState, status);
    #define DBG_LOG_REPORT(collectionNumber, numRecipients, numPending, numFailed, report, reportLength) \
                DbgLogReport(collectionNumber, numRecipients, numPending, numFailed, report, reportLength);
    #define DBG_LOG_IOCTL(fdo, ioControlCode, status) \
                DbgLogIoctl((ULONG_PTR)fdo, ioControlCode, status);
    #define RUNNING_DISPATCH() \
        if (KeGetCurrentIrql() != DISPATCH_LEVEL) { \
        KdPrint(( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
            ASSERT(FALSE); \
            }
#else
    #define DBGSTATE(current, expected, trap)
    #define DBGSUCCESS(status, trap)
    #define DBGASSERT(check, args_in_parens, trap)
    #define DBGWARN(args_in_parens)                               
    #define DBGERR(args_in_parens)                               
    #define DBGOUT(args_in_parens)                               
    #define DBGVERBOSE(args_in_parens) 
    #define DBGINFO(args_in_parens) 
    #define TRAP
    #define SS_TRAP
    #define DBG_COMMON_ENTRY() 
    #define DBG_COMMON_EXIT() 
    #define DBG_RECORD_DEVOBJ(devObj, str)
    #define DBG_RECORD_REPORT(reportId, controlCode, isComplete) 
    #define DBG_RECORD_READ(irp, length, reportId, completed)
    #define DBG_LOG_IRP_MAJOR(irp, majorFunc, isForCollectionPdo, isComplete, status)
    #define DBG_LOG_PNP_IRP(irp, minorFunc, isForCollectionPdo, isComplete, status)
    #define DBG_LOG_POWER_IRP(devExt, minorFunc, isClientPdo, isComplete, type, powerState, status)
    #define DBG_LOG_REPORT(collectionNumber, numRecipients, numPending, numFailed, report, reportLength) 
    #define DBG_LOG_IOCTL(fdo, ioControlCode, status)
    #define RUNNING_DISPATCH()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\fdoext.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fdoext.c

Abstract

   
Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

FDO_EXTENSION *allFdoExtensions = NULL;
KSPIN_LOCK allFdoExtensionsSpinLock;


/*
 ********************************************************************************
 *  EnqueueFdoExt
 ********************************************************************************
 *
 *  Note: this function cannot be pageable because it
 *        acquires a spinlock.
 */
VOID EnqueueFdoExt(FDO_EXTENSION *fdoExt)
{
    KIRQL oldIrql;
    static BOOLEAN firstCall = TRUE;

    if (firstCall){
        KeInitializeSpinLock(&allFdoExtensionsSpinLock);
        firstCall = FALSE;
    }

    KeAcquireSpinLock(&allFdoExtensionsSpinLock, &oldIrql);

    ASSERT(!fdoExt->nextFdoExt);
    fdoExt->nextFdoExt = allFdoExtensions;
    allFdoExtensions = fdoExt;

    KeReleaseSpinLock(&allFdoExtensionsSpinLock, oldIrql);
}


/*
 ********************************************************************************
 *  DequeueFdoExt
 ********************************************************************************
 *
 *  Note: this function cannot be pageable because it
 *        acquires a spinlock.
 *
 */
VOID DequeueFdoExt(FDO_EXTENSION *fdoExt)
{
    FDO_EXTENSION *thisFdoExt;
    KIRQL oldIrql;

    KeAcquireSpinLock(&allFdoExtensionsSpinLock, &oldIrql);

    if (fdoExt == allFdoExtensions){
        allFdoExtensions = fdoExt->nextFdoExt;
    }
    else {
        for (thisFdoExt = allFdoExtensions; thisFdoExt; thisFdoExt = thisFdoExt->nextFdoExt){
            if (thisFdoExt->nextFdoExt == fdoExt){
                thisFdoExt->nextFdoExt = fdoExt->nextFdoExt;
                break;
            }
        }
    }

    fdoExt->nextFdoExt = NULL;

    KeReleaseSpinLock(&allFdoExtensionsSpinLock, oldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\dispatch.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dispatch.c

Abstract

    Dispatch routines for the HID class driver.

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"
#include <poclass.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, HidpCallDriverSynchronous)
        #pragma alloc_text(PAGE, HidpIrpMajorPnp)
        #pragma alloc_text(PAGE, HidpFdoPnp)
        #pragma alloc_text(PAGE, HidpPdoPnp)
#endif



/*
 ********************************************************************************
 *  HidpCallDriver
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpCallDriver(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp)
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension;
    PHIDCLASS_DRIVER_EXTENSION hidDriverExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    #if DBG
        KIRQL saveIrql;
    #endif

    DBGASSERT((Irp->Type == IO_TYPE_IRP),
              ("Irp->Type != IO_TYPE_IRP, Irp->Type == %x", Irp->Type),
              TRUE)

    /*
     *  Update the IRP stack to point to the next location.
     */
    Irp->CurrentLocation--;

    if (Irp->CurrentLocation <= 0) {
        KeBugCheckEx( NO_MORE_IRP_STACK_LOCATIONS, (ULONG_PTR) Irp, 0, 0, 0 );
    }

    irpSp = IoGetNextIrpStackLocation( Irp );
    Irp->Tail.Overlay.CurrentStackLocation = irpSp;

    //
    // Save a pointer to the device object for this request so that it can
    // be used later in completion.
    //

    irpSp->DeviceObject = DeviceObject;

    //
    // Get a pointer to the class extension and verify it.
    //
    hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT(hidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(!hidDeviceExtension->isClientPdo);

    //
    // Ditto for the driver extension
    //

    hidDriverExtension = hidDeviceExtension->fdoExt.driverExt;
    ASSERT( hidDriverExtension->Signature == HID_DRIVER_EXTENSION_SIG );

    //
    // Invoke the driver at its dispatch routine entry point.
    //

    #if DBG
        saveIrql = KeGetCurrentIrql();
    #endif

    /*
     *  Call down to the minidriver
     */
    status = hidDriverExtension->MajorFunction[irpSp->MajorFunction](DeviceObject, Irp);

    #if DBG
        if (saveIrql != KeGetCurrentIrql()) {
            DbgPrint( "IO: HidpCallDriver( Driver ext: %x  Device object: %x  Irp: %x )\n",
                      hidDriverExtension,
                      DeviceObject,
                      Irp
                    );
            DbgPrint( "    Irql before: %x  != After: %x\n", saveIrql, KeGetCurrentIrql() );
            DbgBreakPoint();
        }
    #endif

    return status;
}



/*
 ********************************************************************************
 *  HidpSynchronousCallCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpSynchronousCallCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PKEVENT event = Context;

    DBG_COMMON_ENTRY()

    KeSetEvent(event, 0, FALSE);

    DBG_COMMON_EXIT()
    return STATUS_MORE_PROCESSING_REQUIRED;
}



/*
 ********************************************************************************
 *  HidpCallDriverSynchronous
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpCallDriverSynchronous(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp)
{
    KEVENT event;
    NTSTATUS status;
    static LARGE_INTEGER timeout = {(ULONG) -50000000, 0xFFFFFFFF };

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, HidpSynchronousCallCompletion, &event, TRUE, TRUE, TRUE);

    status = HidpCallDriver(DeviceObject, Irp);

    if (STATUS_PENDING == status) {
        //
        // Wait for 5 seconds. If we don't get a response within said amount
        // of time, the device is being unresponsive (happens with some UPS').
        // At that point, cancel the irp and return STATUS_IO_TIMEOUT.
        //
        status = KeWaitForSingleObject(&event,
                                       Executive,      // wait reason
                                       KernelMode,
                                       FALSE,          // not alertable
                                       &timeout );     // 5 second timeout
    
        if (status == STATUS_TIMEOUT) {
            #if DBG
                LARGE_INTEGER li;
                KeQueryTickCount(&li);
                DBGWARN(("Could not cancel irp. Will have to wait. Time %x.",Irp,li))
            #endif
            DBGWARN(("Device didn't respond for 5 seconds. Cancelling request. Irp %x",Irp))
            IoCancelIrp(Irp);
            KeWaitForSingleObject(&event,
                                  Executive,      // wait reason
                                  KernelMode,
                                  FALSE,          // not alertable
                                  NULL );         // no timeout
            #if DBG
                KeQueryTickCount(&li);
                DBGWARN(("Irp conpleted. Time %x.",li))
            #endif
            //
            // If we successfully cancelled the irp, then set the status to 
            // STATUS_IO_TIMEOUT, otherwise, leave the status alone.
            //
            status = Irp->IoStatus.Status = 
                (Irp->IoStatus.Status == STATUS_CANCELLED) ? STATUS_IO_TIMEOUT : Irp->IoStatus.Status;
        } else {
            //
            // The minidriver must always return STATUS_PENDING or STATUS_SUCCESS
            // (depending on async or sync completion) and set the real status
            // in the status block.  We're not expecting anything but success from
            // KeWaitForSingleObject, either.
            //
            status = Irp->IoStatus.Status;
        }
    }

    DBGSUCCESS(status, FALSE)

    return status;
}



/*
 ********************************************************************************
 *  HidpMajorHandler
 ********************************************************************************
 *
 *  Note: this function should not be pageable because
 *        reads can come in at dispatch level.
 *
 */
NTSTATUS HidpMajorHandler(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PHIDCLASS_DEVICE_EXTENSION hidClassExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS result;
    UCHAR majorFunction;
    BOOLEAN isClientPdo;

    DBG_COMMON_ENTRY()

    hidClassExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT(hidClassExtension->Signature == HID_DEVICE_EXTENSION_SIG);

    //
    // Get a pointer to the current stack location and dispatch to the
    // appropriate routine.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Keep these privately so we still have it after the IRP completes
     *  or after the device extension is freed on a REMOVE_DEVICE
     */
    majorFunction = irpSp->MajorFunction;
    isClientPdo = hidClassExtension->isClientPdo;

    DBG_LOG_IRP_MAJOR(Irp, majorFunction, isClientPdo, FALSE, 0)

    switch (majorFunction){

    case IRP_MJ_CLOSE:
        result = HidpIrpMajorClose( hidClassExtension, Irp );
        break;

    case IRP_MJ_CREATE:
        result = HidpIrpMajorCreate( hidClassExtension, Irp );
        break;

    case IRP_MJ_DEVICE_CONTROL:
        result = HidpIrpMajorDeviceControl( hidClassExtension, Irp );
        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        result = HidpIrpMajorINTERNALDeviceControl( hidClassExtension, Irp );
        break;

    case IRP_MJ_PNP:
        result = HidpIrpMajorPnp( hidClassExtension, Irp );
        break;

    case IRP_MJ_POWER:
        result = HidpIrpMajorPower( hidClassExtension, Irp );
        break;

    case IRP_MJ_READ:
        result = HidpIrpMajorRead( hidClassExtension, Irp );
        break;

    case IRP_MJ_WRITE:
        result = HidpIrpMajorWrite( hidClassExtension, Irp );
        break;

    case IRP_MJ_SYSTEM_CONTROL:
        result = HidpIrpMajorSystemControl( hidClassExtension, Irp );
        break;

    default:
        result = HidpIrpMajorDefault( hidClassExtension, Irp );
        break;
    }

    DBG_LOG_IRP_MAJOR(Irp, majorFunction, isClientPdo, TRUE, result)

    DBG_COMMON_EXIT()
    
    return result;
}


/*
 ********************************************************************************
 *  HidpIrpMajorDefault
 ********************************************************************************
 *
 *  Handle IRPs with un-handled MAJOR function codes
 *
 */
NTSTATUS HidpIrpMajorDefault(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    DBGVERBOSE(("Unhandled IRP, MJ function: %x", irpSp->MajorFunction))

    if (HidDeviceExtension->isClientPdo){
        /*
         *  This IRP is bound for the collection-PDO.
         *  Return the default status.
         */
        status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {
        /*
         *  This IRP is bound for the lower device.
         *  Pass it down the stack.
         */
        FDO_EXTENSION *fdoExt = &HidDeviceExtension->fdoExt;
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = HidpCallDriver(fdoExt->fdo, Irp);
    }

    DBGSUCCESS(status, FALSE)
    return status;
}


/*
 ********************************************************************************
 *  HidpIrpMajorClose
 ********************************************************************************
 *
 *  Note: this function cannot be pageable because it
 *        acquires a spinlock.
 *
 */
NTSTATUS HidpIrpMajorClose(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS                    result;

    ASSERT(HidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);

    if (HidDeviceExtension->isClientPdo){ 

        PIO_STACK_LOCATION          irpSp;
        PHIDCLASS_FILE_EXTENSION    fileExtension;
        PFILE_OBJECT                fileObject;
        KIRQL                       oldIrql;
        PDO_EXTENSION               *pdoExt;
        FDO_EXTENSION               *fdoExt;
        ULONG                       openCount;

        pdoExt = &HidDeviceExtension->pdoExt;
        fdoExt = &pdoExt->deviceFdoExt->fdoExt;

        ASSERT(fdoExt->openCount > 0);

        Irp->IoStatus.Information = 0;

        irpSp = IoGetCurrentIrpStackLocation( Irp );
        fileObject = irpSp->FileObject;
        fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;

        fdoExt->openCount--;
        openCount = fdoExt->openCount;

        if (fileExtension){
            PHIDCLASS_COLLECTION classCollection;

            ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);

            /*
             *  Get a pointer to the collection that our file extension is queued on.
             */
            classCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
            if (classCollection){

                DBGVERBOSE(("  HidpIrpMajorClose: closing collection w/ usagePage=%xh, usage=%xh.", fdoExt->deviceDesc.CollectionDesc[pdoExt->collectionIndex].UsagePage, fdoExt->deviceDesc.CollectionDesc[pdoExt->collectionIndex].Usage))

                if (fdoExt->state == DEVICE_STATE_REMOVED){

                    KeAcquireSpinLock( &classCollection->FileExtensionListSpinLock, &oldIrql );
                    RemoveEntryList(&fileExtension->FileList);
                    KeReleaseSpinLock( &classCollection->FileExtensionListSpinLock, oldIrql );

                    if (fileExtension->isSecureOpen) {
                        
                        KeAcquireSpinLock(&classCollection->secureReadLock,
                                          &oldIrql);

                        while(fileExtension->SecureReadMode--) {

                            classCollection->secureReadMode--;

                        }

                        KeReleaseSpinLock(&classCollection->secureReadLock,
                                          oldIrql);

                    }

                    HidpDestroyFileExtension(classCollection, fileExtension);

                    classCollection = BAD_POINTER;

                    /*
                     *  Delete the device-FDO and all collection-PDOs
                     *  Don't touch fdoExt after this.
                     */
                    HidpCleanUpFdo(fdoExt);

                    result = STATUS_SUCCESS;
                }
                else {
                    //
                    // Destroy the file object and everything on it
                    //
                    KeAcquireSpinLock(&classCollection->FileExtensionListSpinLock, &oldIrql);

                    /*
                     *  Update sharing information:
                     *  Decrement open counts and clear any exclusive holds of this file extension
                     *  on the device extension.
                     */
                    ASSERT(pdoExt->openCount > 0);
                    pdoExt->openCount--;
                    if (fileExtension->accessMask & FILE_READ_DATA){
                        ASSERT(pdoExt->opensForRead > 0);
                        pdoExt->opensForRead--;
                    }
                    if (fileExtension->accessMask & FILE_WRITE_DATA){
                        ASSERT(pdoExt->opensForWrite > 0);
                        pdoExt->opensForWrite--;
                    }
                    if (!(fileExtension->shareMask & FILE_SHARE_READ)){
                        ASSERT(pdoExt->restrictionsForRead > 0);
                        pdoExt->restrictionsForRead--;
                    }
                    if (!(fileExtension->shareMask & FILE_SHARE_WRITE)){
                        ASSERT(pdoExt->restrictionsForWrite > 0);
                        pdoExt->restrictionsForWrite--;
                    }
                    if (fileExtension->shareMask == 0){
                        ASSERT(pdoExt->restrictionsForAnyOpen > 0);
                        pdoExt->restrictionsForAnyOpen--;
                    }

                    RemoveEntryList(&fileExtension->FileList);

                    KeReleaseSpinLock(&classCollection->FileExtensionListSpinLock, oldIrql);
                    
                    if (fileExtension->isSecureOpen) {
                        
                        KeAcquireSpinLock(&classCollection->secureReadLock,
                                          &oldIrql);

                        while(fileExtension->SecureReadMode--) {

                            classCollection->secureReadMode--;

                        }

                        KeReleaseSpinLock(&classCollection->secureReadLock,
                                          oldIrql);

                    }
                    
                    HidpDestroyFileExtension(classCollection, fileExtension);

                    result = STATUS_SUCCESS;
                }
            }
            else {
                result = STATUS_DATA_ERROR;
            }
        }
        else {
            TRAP;
            result = STATUS_DEVICE_NOT_CONNECTED;
        }

        DBGVERBOSE(("  HidpIrpMajorClose: openCount decremented to %xh/%xh (pdo/fdo).", openCount, fdoExt->openCount))
    }
    else {
        DBGERR(("IRP_MJ_CLOSE was sent with a device-FDO extension for which an open never succeeded.  The OBJDIR test tool does this sometimes.  Hit 'g'."))
        result = STATUS_INVALID_PARAMETER_1;
    }

    Irp->IoStatus.Status = result;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGSUCCESS(result, FALSE)
    return result;
}



/*
 ********************************************************************************
 *  HidpIrpMajorCreate
 ********************************************************************************
 *
 *
 *   Routine Description:
 *
 *       We connect up to the interrupt for the create/open and initialize
 *       the structures needed to maintain an open for a device.
 *
 *  Arguments:
 *
 *       DeviceObject - Pointer to the device object for this device
 *
 *       Irp - Pointer to the IRP for the current request
 *
 *   Return Value:
 *
 *       The function value is the final status of the call
 *
 */
NTSTATUS HidpIrpMajorCreate(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT(HidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);

    if (HidDeviceExtension->isClientPdo){
        PDO_EXTENSION *pdoExt = &HidDeviceExtension->pdoExt;
        FDO_EXTENSION *fdoExt = &pdoExt->deviceFdoExt->fdoExt;
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
        PHIDCLASS_COLLECTION classCollection;
        BOOLEAN secureOpen = FALSE;

        secureOpen = MyPrivilegeCheck(Irp);

        Irp->IoStatus.Information = 0;

        classCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
        if (classCollection){
            BOOLEAN sharingOk = TRUE, allowReadPrivilege = TRUE;
            KIRQL oldIrql;

            // This is now taken care of by the fact that we don't 
            // enumerate mouse and keyboard collections as RAW.
#if 0
            /*
             *  Do security check 
             *  (must be at passive level, so don't hold any spinlocks during this call)
             */
            if (pdoExt->MouseOrKeyboard &&
                !MyPrivilegeCheck(Irp)){
                /*
                 *  This is a user-level open on a keyboard or mouse.
                 *  Disallow reads even if we do allow the open.
                 */
                allowReadPrivilege = FALSE;
            }
#endif

            KeAcquireSpinLock(&classCollection->FileExtensionListSpinLock, &oldIrql);

            /*
             *  Enforce exclusive-open independently for exclusive-read and exclusive-write.
             */
            ASSERT(irpSp->Parameters.Create.SecurityContext);
            DBGVERBOSE(("  HidpIrpMajorCreate: DesiredAccess = %xh, ShareAccess = %xh.", (ULONG)irpSp->Parameters.Create.SecurityContext->DesiredAccess, (ULONG)irpSp->Parameters.Create.ShareAccess))
            
            DBGASSERT((irpSp->Parameters.Create.SecurityContext->DesiredAccess & (FILE_READ_DATA|FILE_WRITE_DATA)), 
                      ("Neither FILE_READ_DATA|FILE_WRITE_DATA requested in HidpIrpMajorCreate. DesiredAccess = %xh.", (ULONG)irpSp->Parameters.Create.SecurityContext->DesiredAccess),
                      FALSE)
            if (pdoExt->restrictionsForAnyOpen){
                /*
                 *  Oops.  A previous open requested exclusive access.
                 *         Not even a client that requests only ioctl access
                 *         (does not request read nor write acess) is
                 *         allowed.
                 */
                DBGWARN(("HidpIrpMajorCreate failing open: previous open is non-shared (ShareAccess==0)."))
                sharingOk = FALSE;
            }
            else if (pdoExt->openCount &&
                     (irpSp->Parameters.Create.ShareAccess == 0)){
                /*
                 *  Oops.  This open does not allow any sharing
                 *         (not even with a client that has neither read nor write access),
                 *         but there exists a previous open.
                 */
                DBGWARN(("HidpIrpMajorCreate failing open: requesting non-shared (ShareAccess==0) while previous open exists."))
                sharingOk = FALSE;
            }
            else if ((irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_READ_DATA) &&
                pdoExt->restrictionsForRead){
                /*
                 *  Oops. A previous open requested exclusive-read access.
                 */
                DBGWARN(("HidpIrpMajorCreate failing open: requesting read access while previous open does not share read access."))
                sharingOk = FALSE;
            }
            else if ((irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_WRITE_DATA) &&
                pdoExt->restrictionsForWrite){
                /*
                 *  Oops. A previous open requested exclusive-write access.
                 */
                DBGWARN(("HidpIrpMajorCreate failing open: requesting write access while previous open does not share write access."))
                sharingOk = FALSE;
            }
            else if ((pdoExt->opensForRead > 0) &&
                !(irpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ)){

                /*
                 *  Oops. The caller is requesting exclusive read access, but the device
                 *        is already open for read.
                 */
                DBGWARN(("HidpIrpMajorCreate failing open: this open request does not share read access; but collection already open for read."))
                sharingOk = FALSE;
            }
            else if ((pdoExt->opensForWrite > 0) &&
                !(irpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)){

                /*
                 *  Oops. The caller is requesting exclusive write access, but the device
                 *        is already open for write.
                 */
                DBGWARN(("HidpIrpMajorCreate failing open: this open request does not share write access; but collection already open for write."))
                sharingOk = FALSE;
            }


            if (!sharingOk){
                DBGWARN(("HidpIrpMajorCreate failing IRP_MJ_CREATE with STATUS_SHARING_VIOLATION."))
                status = STATUS_SHARING_VIOLATION;
            }
            else if (!allowReadPrivilege && 
                     (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_READ_DATA)){
                DBGWARN(("HidpIrpMajorCreate failing open: user-mode client requesting read privilege on kb/mouse."))
                status = STATUS_ACCESS_DENIED;
            }
            else {
                if (irpSp->Parameters.Create.Options & FILE_DIRECTORY_FILE){
                    /*
                     *  Attempt to open this device as a directory
                     */
                    status = STATUS_NOT_A_DIRECTORY;
                } else {

                    /*
                     *  Make sure the device is started.
                     *  If it is temporarily stopped, we also succeed because a stop
                     *  is supposed to be transparent to the client.
                     */
                    if (((fdoExt->state == DEVICE_STATE_START_SUCCESS) ||
                         (fdoExt->state == DEVICE_STATE_STOPPING) ||
                         (fdoExt->state == DEVICE_STATE_STOPPED))
                                                                        &&
                        ((pdoExt->state == COLLECTION_STATE_RUNNING) ||
                         (pdoExt->state == COLLECTION_STATE_STOPPING) ||
                         (pdoExt->state == COLLECTION_STATE_STOPPED))){

                        PHIDCLASS_FILE_EXTENSION fileExtension;

                        /*
                         *  We have a valid collection.
                         *  Allocate a file object extension (which encapsulates an 'open' on the device).
                         */
                        fileExtension = ALLOCATEPOOL(NonPagedPool, sizeof(HIDCLASS_FILE_EXTENSION));
                        if (fileExtension){
                            PHIDP_COLLECTION_DESC   hidCollectionDesc;

                            RtlZeroMemory(fileExtension, sizeof(HIDCLASS_FILE_EXTENSION));

                            fileExtension->CollectionNumber = pdoExt->collectionNum;
                            fileExtension->fdoExt = fdoExt;
                            fileExtension->FileObject = irpSp->FileObject;

                            fileExtension->isOpportunisticPolledDeviceReader = FALSE;
                            fileExtension->nowCompletingIrpForOpportunisticReader = 0;

                            fileExtension->BlueScreenData.BluescreenFunction = NULL;

                            InitializeListHead( &fileExtension->ReportList );
                            InitializeListHead( &fileExtension->PendingIrpList );
                            KeInitializeSpinLock( &fileExtension->ListSpinLock );
                            fileExtension->Closing = FALSE;

                            //
                            // Right now we'll set a default maximum input report queue size.
                            // This can be changed later with an IOCTL.
                            //

                            fileExtension->CurrentInputReportQueueSize = 0;
                            fileExtension->MaximumInputReportQueueSize = DEFAULT_INPUT_REPORT_QUEUE_SIZE;
                            fileExtension->insideReadCompleteCount = 0;

                            //
                            // Add this file extension to the list of file extensions for this
                            // collection.
                            //

                            InsertHeadList(&classCollection->FileExtensionList, &fileExtension->FileList);

                            #if DBG
                                fileExtension->Signature = HIDCLASS_FILE_EXTENSION_SIG;
                            #endif

                            /*
                             *  Store the file-open attribute flags.
                             */
                            fileExtension->FileAttributes = irpSp->Parameters.Create.FileAttributes;
                            fileExtension->accessMask = irpSp->Parameters.Create.SecurityContext->DesiredAccess;
                            fileExtension->shareMask = irpSp->Parameters.Create.ShareAccess;


                            // 
                            // Set up secure read mode
                            //
                            fileExtension->SecureReadMode = 0;
                            fileExtension->isSecureOpen = secureOpen;
                                                            

                            /*
                             *  Store a pointer to our file extension in the file object.
                             */
                            irpSp->FileObject->FsContext = fileExtension;

                            //
                            // KENRAY
                            // Only drivers can set the FsContext of file
                            // objects so this is not a security problem.
                            // However, there is only one file object for the entire
                            // PDO stack.  This means we have to share.  You cannot
                            // have both context pointers.  I need one for the
                            // keyboard and mouse class drivers.
                            //
                            // This information need go into the fileExtension.
                            //
                            fileExtension->SecurityCheck = TRUE;

                            //
                            // If this is a user-level open on a keyboard or 
                            // mouse, then we will let the client do anything 
                            // except read the device.
                            //
                            DBGASSERT(allowReadPrivilege, 
                                      ("User-level open on keyboard or mouse.  Reads will be disallowed."),
                                      FALSE)

                            fileExtension->haveReadPrivilege = allowReadPrivilege;

                            /*
                             *  Increment the device extension's open counts,
                             *  and set the exclusive-access fields.
                             */
                            fdoExt->openCount++;
                            pdoExt->openCount++;
                            if (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_READ_DATA){
                                pdoExt->opensForRead++;
                            }
                            if (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_WRITE_DATA){
                                pdoExt->opensForWrite++;
                            }

                            /*
                             *  NOTE:  Restrictions are independent of desired access.
                             *         For example, a client can do an open-for-read-only
                             *         AND prevent other clients from doing an open-for-write
                             *         (by not setting the FILE_SHARE_WRITE flag). 
                             */
                            if (!(irpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ)){
                                pdoExt->restrictionsForRead++;
                            }
                            if (!(irpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)){
                                pdoExt->restrictionsForWrite++;
                            }
                            if (irpSp->Parameters.Create.ShareAccess == 0){
                                /*
                                 *  ShareAccess==0 means that no other opens of any kind
                                 *  are allowed.
                                 */
                                pdoExt->restrictionsForAnyOpen++;
                            }

                            DBGVERBOSE(("  HidpIrpMajorCreate: opened collection w/ usagePage=%xh, usage=%xh.  openCount incremented to %xh/%xh (pdo/fdo).", fdoExt->deviceDesc.CollectionDesc[pdoExt->collectionIndex].UsagePage, fdoExt->deviceDesc.CollectionDesc[pdoExt->collectionIndex].Usage, pdoExt->openCount, fdoExt->openCount))
                        } else {
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    } else {
                        status = STATUS_DEVICE_NOT_CONNECTED;
                    }
                }
            }

            KeReleaseSpinLock(&classCollection->FileExtensionListSpinLock, oldIrql);
        }
        else {
            DBGERR(("HidpIrpMajorCreate failing -- couldn't find collection"))
            status = STATUS_DEVICE_NOT_CONNECTED;
        }
    }
    else {
        /*
         *  We don't support opens on the device itself,
         *  only on the collections.
         */
        DBGWARN(("HidpIrpMajorCreate failing -- we don't support opens on the device itself; only on collections."))
        status = STATUS_UNSUCCESSFUL;
    }


    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    DBGSUCCESS(status, FALSE)
    return status;
}



/*
 ********************************************************************************
 *  HidpIrpMajorDeviceControl
 ********************************************************************************
 *
 *  Note:  This function cannot be pageable because IOCTLs
 *         can get sent at DISPATCH_LEVEL.
 *
 */
NTSTATUS HidpIrpMajorDeviceControl(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS        status;
    BOOLEAN         completeIrpHere = TRUE;
    PDO_EXTENSION   *pdoExt;
    FDO_EXTENSION   *fdoExt;
    ULONG           ioControlCode;

    PIO_STACK_LOCATION irpSp;

    PHIDCLASS_COLLECTION        hidCollection;
    PHIDCLASS_FILE_EXTENSION    fileExtension;
    PFILE_OBJECT                fileObject;
    KIRQL                       irql;

    if (!HidDeviceExtension->isClientPdo){ 
        ASSERT(HidDeviceExtension->isClientPdo);
        status = STATUS_INVALID_PARAMETER_1;
        goto HidpIrpMajorDeviceControlDone;
    }

    pdoExt = &HidDeviceExtension->pdoExt;
    fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    if (fdoExt->state != DEVICE_STATE_START_SUCCESS ||
        pdoExt->state != COLLECTION_STATE_RUNNING) { 
        DBGSTATE (pdoExt->state, COLLECTION_STATE_RUNNING, FALSE)
        status = STATUS_DEVICE_NOT_CONNECTED;
        goto HidpIrpMajorDeviceControlDone;
    }
    
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    // Keep this privately so we still have it after the IRP is completed.
    ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
    Irp->IoStatus.Information = 0;

    status = HidpCheckIdleState(HidDeviceExtension, Irp);
    if (status != STATUS_SUCCESS) {
        completeIrpHere = (status != STATUS_PENDING);
        goto HidpIrpMajorDeviceControlDone;
    } 

    switch (ioControlCode){

    case IOCTL_HID_GET_DRIVER_CONFIG:
        TRAP;
        status = STATUS_NOT_IMPLEMENTED;
        break;

    case IOCTL_HID_SET_DRIVER_CONFIG:
        TRAP;
        status = STATUS_NOT_IMPLEMENTED;
        break;

    case IOCTL_HID_GET_COLLECTION_INFORMATION:
        /*
         *  This IRP is METHOD_BUFFERED, so the buffer
         *  is in the AssociatedIrp.
         */
        DBGASSERT((Irp->Flags & IRP_BUFFERED_IO),
                  ("Irp->Flags & IRP_BUFFERED_IO Irp->Type != IO_TYPE_IRP, Irp->Type == %x", Irp->Type),
                  FALSE)
        if (Irp->AssociatedIrp.SystemBuffer){
            ULONG bufLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
            status = HidpGetCollectionInformation(
                        fdoExt,
                        pdoExt->collectionNum,
                        Irp->AssociatedIrp.SystemBuffer,
                        &bufLen);
            Irp->IoStatus.Information = bufLen;
        }
        else {
            ASSERT(Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_HID_GET_COLLECTION_DESCRIPTOR:
        /*
         *  This IOCTL is METHOD_NEITHER, so the buffer is in UserBuffer.
         */
        if (Irp->UserBuffer){
            __try {
                ULONG bufLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

                if (Irp->RequestorMode != KernelMode){
                    /*
                     *  Ensure user-mode buffer is legal.
                     */
                    ProbeForWrite(Irp->UserBuffer, bufLen, sizeof(UCHAR));
                }

                status = HidpGetCollectionDescriptor(
                            fdoExt,
                            pdoExt->collectionNum,
                            Irp->UserBuffer,
                            &bufLen);
                Irp->IoStatus.Information = bufLen;
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                TRAP;
                status = GetExceptionCode();
            }
        }
        else {
            ASSERT(Irp->UserBuffer);
            status = STATUS_INVALID_BUFFER_SIZE;
        }
        break;

    case IOCTL_HID_FLUSH_QUEUE:

        //
        // Run the list of report descriptors hanging off of this
        // file object and free them all.
        //

        fileObject = irpSp->FileObject;
        fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
        if(!fileExtension) {
            DBGWARN(("Attempted to flush queue with no file extension"))
            status = STATUS_PRIVILEGE_NOT_HELD;
            break;
        }
        ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);
        HidpFlushReportQueue(fileExtension);
        status = STATUS_SUCCESS;
        break;

    case IOCTL_HID_GET_POLL_FREQUENCY_MSEC:
        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
        if (hidCollection && hidCollection->hidCollectionInfo.Polled){
            /*
             *  Get the current poll frequency.
             *  This IOCTL is METHOD_BUFFERED, so the result goes in the AssociatedIrp.
             */
            DBGASSERT((Irp->Flags & IRP_BUFFERED_IO),
                      ("Irp->Flags & IRP_BUFFERED_IO Irp->Type != IO_TYPE_IRP, Irp->Type == %x", Irp->Type),
                      FALSE)
            if (Irp->AssociatedIrp.SystemBuffer &&
                (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(ULONG))){

                *(ULONG *)Irp->AssociatedIrp.SystemBuffer = hidCollection->PollInterval_msec;
                Irp->IoStatus.Information = sizeof (ULONG);
                status = STATUS_SUCCESS;
            }
            else {
                ASSERT(!"Bad SystemBuffer for IOCTL_HID_GET_POLL_FREQUENCY_MSEC.");
                status = STATUS_INVALID_BUFFER_SIZE;
            }
        }
        else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;

    case IOCTL_HID_SET_POLL_FREQUENCY_MSEC:
        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
        if (hidCollection && hidCollection->hidCollectionInfo.Polled){

            if (Irp->AssociatedIrp.SystemBuffer &&
                (irpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(ULONG))){

                ULONG newPollInterval = *(ULONG *)Irp->AssociatedIrp.SystemBuffer;

                fileObject = irpSp->FileObject;
                fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
                if(!fileExtension) {
                    DBGWARN(("Attempted to set poll frequency with no file extension"))
                    status = STATUS_PRIVILEGE_NOT_HELD;
                    break;
                }
                ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);

                if (newPollInterval == 0){
                    /*
                     *  Poll interval zero means that this client will
                     *  be doing irregular, opportunistic reads on the
                     *  polled device.  We will not change the polling
                     *  frequency of the device.  But when this client
                     *  does a read, we will immediately complete that read
                     *  with either the last report for this collection
                     *  (if the data is not stale) or by immediately issuing
                     *  a new read.
                     */
                    fileExtension->isOpportunisticPolledDeviceReader = TRUE;
                }
                else {
                    /*
                     *  Set the poll frequency AND tell the user what we really set it to
                     *  in case it's out of range.
                     */
                    if (newPollInterval < MIN_POLL_INTERVAL_MSEC){
                        newPollInterval = MIN_POLL_INTERVAL_MSEC;
                    }
                    else if (newPollInterval > MAX_POLL_INTERVAL_MSEC){
                        newPollInterval = MAX_POLL_INTERVAL_MSEC;
                    }
                    hidCollection->PollInterval_msec = newPollInterval;

                    /*
                     *  If this client was an 'opportunistic' reader before,
                     *  he's not anymore.
                     */
                    fileExtension->isOpportunisticPolledDeviceReader = FALSE;

                    /*
                     *  Stop and re-start the polling loop so that
                     *  the new polling interval takes effect right away.
                     */
                    StopPollingLoop(hidCollection, FALSE);
                    StartPollingLoop(fdoExt, hidCollection, FALSE);
                }

                status = STATUS_SUCCESS;
            }
            else {
                ASSERT(!"Bad SystemBuffer for IOCTL_HID_SET_POLL_FREQUENCY_MSEC.");
                status = STATUS_INVALID_BUFFER_SIZE;
            }
        }
        else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;

    case IOCTL_HID_GET_FEATURE:
    case IOCTL_HID_SET_FEATURE:
#if 0                
        {
            BOOLEAN sentIrpToMinidriver;
            status = HidpGetSetFeature( HidDeviceExtension,
                                        Irp,
                                        irpSp->Parameters.DeviceIoControl.IoControlCode,
                                        &sentIrpToMinidriver);
            /*
             *  If we just passed this Irp to the minidriver, we don't want to
             *  complete the Irp; we're not even allowed to touch it since it may
             *  have already completed.
             */
            completeIrpHere = !sentIrpToMinidriver;
        }
        break;
#endif
    case IOCTL_HID_GET_INPUT_REPORT:
    case IOCTL_HID_SET_OUTPUT_REPORT:
        {
            BOOLEAN sentIrpToMinidriver;
            status = HidpGetSetReport ( HidDeviceExtension,
                                        Irp,
                                        irpSp->Parameters.DeviceIoControl.IoControlCode,
                                        &sentIrpToMinidriver);
            /*
             *  If we just passed this Irp to the minidriver, we don't want to
             *  complete the Irp; we're not even allowed to touch it since it may
             *  have already completed.
             */
            completeIrpHere = !sentIrpToMinidriver;
        }
        break;

    // NOTE - we currently only support English (langId=0x0409).
    //        route all collection-PDO string requests to device-FDO.
    case IOCTL_HID_GET_MANUFACTURER_STRING:
        status = HidpGetDeviceString(fdoExt, Irp, HID_STRING_ID_IMANUFACTURER, 0x0409);
        completeIrpHere = FALSE;
        break;

    case IOCTL_HID_GET_PRODUCT_STRING:
        status = HidpGetDeviceString(fdoExt, Irp, HID_STRING_ID_IPRODUCT, 0x0409);
        completeIrpHere = FALSE;
        break;

    case IOCTL_HID_GET_SERIALNUMBER_STRING:
        status = HidpGetDeviceString(fdoExt, Irp, HID_STRING_ID_ISERIALNUMBER, 0x0409);
        completeIrpHere = FALSE;
        break;
         
    case IOCTL_HID_GET_INDEXED_STRING:
        /*
         *  This IRP is METHOD_OUT_DIRECT, so the buffer is in the MDL.
         *  The second argument (string index) is in the AssociatedIrp;
         *  the InputBufferLength is the length of this second buffer.
         */
        if (Irp->AssociatedIrp.SystemBuffer &&
            (irpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(ULONG))){

            ULONG stringIndex = *(ULONG *)Irp->AssociatedIrp.SystemBuffer;
            status = HidpGetIndexedString(fdoExt, Irp, stringIndex, 0x409);
            completeIrpHere = FALSE;
        }
        else {
            ASSERT(Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_HID_GET_MS_GENRE_DESCRIPTOR:
        /*
         *  This IRP is METHOD_OUT_DIRECT, so the buffer is in the MDL.
         */
        status = HidpGetMsGenreDescriptor(fdoExt, Irp);
        completeIrpHere = FALSE;
        break;

    case IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS:

        /*
         *  This IRP is METHOD_BUFFERED, so the buffer
         *  is in the AssociatedIrp.SystemBuffer field.
         */
        DBGASSERT((Irp->Flags & IRP_BUFFERED_IO),
                  ("Irp->Flags & IRP_BUFFERED_IO Irp->Type != IO_TYPE_IRP, Irp->Type == %x", Irp->Type),
                  FALSE)
        if (Irp->AssociatedIrp.SystemBuffer &&
            (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(ULONG))){

            fileObject = irpSp->FileObject;
            fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
            if(!fileExtension) {
                DBGWARN(("Attempted to get number of input buffers with no file extension"))
                status = STATUS_PRIVILEGE_NOT_HELD;
                break;
            }
            ASSERT( fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG );

            *(ULONG *)Irp->AssociatedIrp.SystemBuffer =
                fileExtension->MaximumInputReportQueueSize;
            Irp->IoStatus.Information = sizeof(ULONG);
            status = STATUS_SUCCESS;
        }
        else {
            ASSERT(Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS:

        /*
         *  This IRP is METHOD_BUFFERED, so the buffer
         *  is in the AssociatedIrp.SystemBuffer field.
         */
        DBGASSERT((Irp->Flags & IRP_BUFFERED_IO),
                  ("Irp->Flags & IRP_BUFFERED_IO Irp->Type != IO_TYPE_IRP, Irp->Type == %x", Irp->Type),
                  FALSE)
        if (Irp->AssociatedIrp.SystemBuffer &&
            (irpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(ULONG))){
            
            ULONG newValue = *(ULONG *)Irp->AssociatedIrp.SystemBuffer;

            fileObject = irpSp->FileObject;
            fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
            if(!fileExtension) {
                DBGWARN(("Attempted to set number of input buffers with no file extension"))
                status = STATUS_PRIVILEGE_NOT_HELD;
                break;
            }
            ASSERT( fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG );

            if ((newValue >= MIN_INPUT_REPORT_QUEUE_SIZE) &&
                (newValue <= MAX_INPUT_REPORT_QUEUE_SIZE)){

                fileExtension->MaximumInputReportQueueSize = newValue;
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        else {
            ASSERT(Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_GET_PHYSICAL_DESCRIPTOR:
        status = HidpGetPhysicalDescriptor(HidDeviceExtension, Irp);
        completeIrpHere = FALSE;
        break;

    case IOCTL_HID_GET_HARDWARE_ID:
        {
            PDEVICE_OBJECT pdo = pdoExt->deviceFdoExt->hidExt.PhysicalDeviceObject;
            ULONG bufLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
            PWSTR hwIdBuf;

            hwIdBuf = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);

            if (hwIdBuf && bufLen){
                ULONG actualLen;

                status = IoGetDeviceProperty(   pdo,
                                                DevicePropertyHardwareID,
                                                bufLen,
                                                hwIdBuf,
                                                &actualLen);
                if (NT_SUCCESS(status)){
                    Irp->IoStatus.Information = (ULONG)actualLen;
                }
            }
            else {
                status = STATUS_INVALID_USER_BUFFER;
            }
        }
        break;

    case IOCTL_GET_SYS_BUTTON_CAPS:
        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
        if (hidCollection){
            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(ULONG)){
                ULONG buttonCaps;

                status = HidP_SysPowerCaps(hidCollection->phidDescriptor, &buttonCaps);
                if (NT_SUCCESS(status)){
                    *(PULONG)Irp->AssociatedIrp.SystemBuffer = buttonCaps;
                    Irp->IoStatus.Information = sizeof(ULONG);
                }
            }
            else {
                status = STATUS_INVALID_BUFFER_SIZE;
                Irp->IoStatus.Information = sizeof(ULONG);
            }
        }
        else {
            status = STATUS_DEVICE_NOT_CONNECTED;
        }
        break;

    case IOCTL_GET_SYS_BUTTON_EVENT:

        /*
         *  Hold onto this IRP and complete it when a power event occurs.
         */
        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
        if (hidCollection){
            status = QueuePowerEventIrp(hidCollection, Irp);
            if (status == STATUS_PENDING){
                completeIrpHere = FALSE;
            }
        }
        else {
            status = STATUS_DEVICE_NOT_CONNECTED;
        }
        break;

    case IOCTL_HID_ENABLE_SECURE_READ:
        fileObject = irpSp->FileObject;
        fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
        if(!fileExtension) {
            DBGWARN(("Attempted to get number of input buffers with no file extension"))
            status = STATUS_PRIVILEGE_NOT_HELD;
            break;
        }
        ASSERT( fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG );

        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);

        if (!fileExtension->isSecureOpen) {

            status = STATUS_PRIVILEGE_NOT_HELD;
            break;

        }

        KeAcquireSpinLock(&hidCollection->secureReadLock,
                          &irql);
        fileExtension->SecureReadMode++;
        hidCollection->secureReadMode++;

        KeReleaseSpinLock(&hidCollection->secureReadLock,
                          irql);



        break;
    case IOCTL_HID_DISABLE_SECURE_READ:
        
        fileObject = irpSp->FileObject;
        fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
        if(!fileExtension) {
            DBGWARN(("Attempted to get number of input buffers with no file extension"))
            status = STATUS_PRIVILEGE_NOT_HELD;
            break;
        }
        ASSERT( fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG );

        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);

        if (!fileExtension->isSecureOpen) {

            status = STATUS_PRIVILEGE_NOT_HELD;
            break;

        }

        KeAcquireSpinLock(&hidCollection->secureReadLock,
                          &irql);
        if (fileExtension->SecureReadMode > 0) {
            fileExtension->SecureReadMode--;
            hidCollection->secureReadMode--;
        }

        KeReleaseSpinLock(&hidCollection->secureReadLock,
                          irql);

        break;

    default:
        /*
         *  'Fail' the Irp by returning the default status.
         */
        TRAP;
        status = Irp->IoStatus.Status;
        break;
    }

    DBG_LOG_IOCTL(fdoExt->fdo, ioControlCode, status)

HidpIrpMajorDeviceControlDone:

    /*
     *  If we did not pass the Irp down to a lower driver, complete it here.
     */
    if (completeIrpHere){
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    
    DBGSUCCESS(status, FALSE)

    return status;
}


/*
 ********************************************************************************
 *  HidpIrpMajorINTERNALDeviceControl
 ********************************************************************************
 *
 *  Note:  This function cannot be pageable because IOCTLs
 *         can get sent at DISPATCH_LEVEL.
 *
 */
NTSTATUS HidpIrpMajorINTERNALDeviceControl(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS        status;

    if (HidDeviceExtension->isClientPdo){ 
        PDO_EXTENSION *pdoExt = &HidDeviceExtension->pdoExt;
        FDO_EXTENSION *fdoExt = &pdoExt->deviceFdoExt->fdoExt;

        Irp->IoStatus.Information = 0;

        //
        // If we ever support any other internal IOCTLs that are real and 
        // require touching the hardware, then we need to break out the check 
        // for fdoExt->devicePowerState and enqueue the irp until we get to full
        // power
        //
        if (fdoExt->state == DEVICE_STATE_START_SUCCESS) {
            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

            switch (irpSp->Parameters.DeviceIoControl.IoControlCode){

            case IOCTL_INTERNAL_HID_SET_BLUESCREEN:

                /*
                 *  Memphis code to handle keyboards during blue screen event
                 */
                if (Irp->AssociatedIrp.SystemBuffer){
                    PFILE_OBJECT fileObject = irpSp->FileObject;
                    PHIDCLASS_FILE_EXTENSION fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
                    if(!fileExtension) {
                        DBGWARN(("Attempted to set blue screen data with no file extension"))
                        status = STATUS_PRIVILEGE_NOT_HELD;
                    } else {
                        ASSERT( fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG );
                        ASSERT(irpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof(BLUESCREEN));

                        fileExtension->BlueScreenData = *((PBLUESCREEN)Irp->AssociatedIrp.SystemBuffer);

                        status = STATUS_SUCCESS;
                    }
                }
                else {
                    ASSERT(Irp->AssociatedIrp.SystemBuffer);
                    status = STATUS_INVALID_PARAMETER;
                }
                break;

            default:
                /*
                 *  'Fail' the Irp by returning the default status.
                 */
                DBGWARN(("HidpIrpMajorINTERNALDeviceControl - unsupported IOCTL %xh ", (ULONG)irpSp->Parameters.DeviceIoControl.IoControlCode))
                status = Irp->IoStatus.Status;
                break;
            }
        }
        else {
            status = STATUS_DEVICE_NOT_CONNECTED;
        }
    }
    else {
        ASSERT(HidDeviceExtension->isClientPdo);
        status = STATUS_INVALID_PARAMETER_1;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGSUCCESS(status, FALSE)
    return status;
}

/*
 ********************************************************************************
 *  HidpIrpMajorPnp
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpIrpMajorPnp(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp;
    BOOLEAN             completeIrpHere;
    BOOLEAN             isClientPdo;
    UCHAR               minorFunction;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Keep these fields privately so that we have them
     *  after the IRP is completed and in case we delete
     *  the device extension on a REMOVE_DEVICE.
     */
    isClientPdo = HidDeviceExtension->isClientPdo;
    minorFunction = irpSp->MinorFunction;

    DBG_LOG_PNP_IRP(Irp, minorFunction, isClientPdo, FALSE, 0)

    if (isClientPdo) {
        status = HidpPdoPnp(HidDeviceExtension, Irp);
    } else {
        status = HidpFdoPnp(HidDeviceExtension, Irp);
    }

    DBG_LOG_PNP_IRP(Irp, minorFunction, isClientPdo, TRUE, status)

    return status;
}


NTSTATUS HidpPdoPnp(
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, 
    IN OUT PIRP Irp
    )
{
    NTSTATUS            status = NO_STATUS;
    PIO_STACK_LOCATION  irpSp;
    FDO_EXTENSION       *fdoExt;
    PDO_EXTENSION       *pdoExt;
    UCHAR               minorFunction;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Keep these fields privately so that we have them
     *  after the IRP is completed and in case we delete
     *  the device extension on a REMOVE_DEVICE.
     */
    minorFunction = irpSp->MinorFunction;


    DBG_LOG_PNP_IRP(Irp, minorFunction, TRUE, FALSE, 0)

    pdoExt = &HidDeviceExtension->pdoExt;
    fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    switch (minorFunction){

    case IRP_MN_START_DEVICE:
        status = HidpStartCollectionPDO(fdoExt, pdoExt, Irp);
        if (NT_SUCCESS(status) &&
            ISPTR(pdoExt->StatusChangeFn)) {
            pdoExt->StatusChangeFn(pdoExt->StatusChangeContext, 
                                   DeviceObjectStarted);
        }
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        DBGSTATE(pdoExt->state, COLLECTION_STATE_RUNNING, FALSE)
        pdoExt->prevState = pdoExt->state;
        pdoExt->state = COLLECTION_STATE_STOPPING;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
        DBGSTATE(pdoExt->state, COLLECTION_STATE_STOPPING, TRUE)
        pdoExt->state = pdoExt->prevState;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:
        DBGSTATE(pdoExt->state, COLLECTION_STATE_STOPPING, TRUE)
        if (pdoExt->prevState != COLLECTION_STATE_UNINITIALIZED){
            /*
             *  Destroy the symbolic link for this collection.
             */
            HidpCreateSymbolicLink(pdoExt, pdoExt->collectionNum, FALSE, pdoExt->pdo);
            HidpFreePowerEventIrp(&fdoExt->classCollectionArray[pdoExt->collectionIndex]);

            pdoExt->state = COLLECTION_STATE_STOPPED;
            if (ISPTR(pdoExt->StatusChangeFn)) {
                pdoExt->StatusChangeFn(pdoExt->StatusChangeContext, 
                                       DeviceObjectStopped);
            }
        }

        status = STATUS_SUCCESS;
        break;

    case IRP_MN_SURPRISE_REMOVAL:
    case IRP_MN_QUERY_REMOVE_DEVICE:
        DBGASSERT(((pdoExt->state == COLLECTION_STATE_RUNNING) ||
                  (pdoExt->state == COLLECTION_STATE_STOPPED)),
                  ("Pdo is neither stopped nor started, but is getting removed, state=%d",pdoExt->state), 
                  FALSE)
        
        pdoExt->prevState = pdoExt->state;
        pdoExt->state = COLLECTION_STATE_REMOVING;
        
        if ((pdoExt->prevState == COLLECTION_STATE_RUNNING)) {

            /*
             *  Remove the symbolic link for this collection-PDO.
             *
             *  NOTE:  Do this BEFORE destroying the collection, because
             *         HidpDestroyCollection() may cause a client driver,
             *         whose pending read IRPs get cancelled when the collection
             *         is destroyed, to try to re-open the device.
             *         Deleting the symbolic link first eliminates this possibility.
             */
            HidpCreateSymbolicLink(pdoExt, pdoExt->collectionNum, FALSE, pdoExt->pdo);
        }

        if ((pdoExt->prevState == COLLECTION_STATE_RUNNING) ||
            (pdoExt->prevState == COLLECTION_STATE_STOPPED)){

            /*
             *  Flush all pending IO and deny any future io by setting 
             *  the collection state to removing.
             *  Note: on NT, clients will receive the query remove 
             *  first, but surprise removal must deny access to the 
             *  device.
             *
             *  NOTE: There is a hole here that results in a read being
             *  queued even though we've blocked everything.
             *  1) Get read, check to see that our state is running 
             *     or stopped in HidpIrpMajorRead.
             *  2) Set state to COLLECTION_STATE_REMOVING and complete 
             *     all reads here.
             *  3) Enqueue read in HidpIrpMajorRead.
             *
             */
            ULONG ctnIndx = pdoExt->collectionIndex;
            PHIDCLASS_COLLECTION collection = &fdoExt->classCollectionArray[ctnIndx];
            LIST_ENTRY dequeue, *entry;
            PIRP irp;

            DBGVERBOSE(("Got QUERY/SURPRISE REMOVE for collection; completing all pending reads.  openCount=%d, pendingReads=%d.", pdoExt->openCount, collection->numPendingReads))

            CompleteAllPendingReadsForCollection(collection);
        
            DequeueAllPdoPowerDelayedIrps(pdoExt, &dequeue);
            while (!IsListEmpty(&dequeue)) {
                entry = RemoveHeadList(&dequeue);
                irp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
                IoCompleteRequest(irp, IO_NO_INCREMENT);
            }
        }
        
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        status = STATUS_SUCCESS;

        DBGSTATE(pdoExt->state, COLLECTION_STATE_REMOVING, TRUE)
        pdoExt->state = pdoExt->prevState;
        if (pdoExt->state == COLLECTION_STATE_RUNNING) {
            // Re-create the symbolic link, since we're no longer 
            // deleting the device.
            HidpCreateSymbolicLink(pdoExt, pdoExt->collectionNum, TRUE, pdoExt->pdo);
        }
        break;

    case IRP_MN_REMOVE_DEVICE:

        /*
         *  REMOVE_DEVICE for the device-FDO should come after REMOVE_DEVICE for each
         *  of the collection-PDOs.
         */
        DBGASSERT((pdoExt->state == COLLECTION_STATE_UNINITIALIZED ||
                   pdoExt->state == COLLECTION_STATE_REMOVING), 
                  ("On pnp remove, collection state is incorrect. Actual: %x", pdoExt->state),
                  TRUE)
        
        HidpRemoveCollection(fdoExt, pdoExt, Irp);
        if (ISPTR(pdoExt->StatusChangeFn)) {
            pdoExt->StatusChangeFn(pdoExt->StatusChangeContext, 
                                   DeviceObjectRemoved);
        }
        status = STATUS_SUCCESS; // Can't fail IRP_MN_REMOVE
        break;

    case IRP_MN_QUERY_CAPABILITIES:
        status = HidpQueryCollectionCapabilities(pdoExt, Irp);
        break;


    case IRP_MN_QUERY_DEVICE_RELATIONS:
        if (irpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation){
            /*
             *  Return a reference to this PDO
             */
            PDEVICE_RELATIONS devRel = ALLOCATEPOOL(PagedPool, sizeof(DEVICE_RELATIONS));
            if (devRel){
                /*
                 *  Add a reference to the PDO, since CONFIGMG will free it.
                 */
                ObReferenceObject(pdoExt->pdo);
                devRel->Objects[0] = pdoExt->pdo;
                devRel->Count = 1;
                Irp->IoStatus.Information = (ULONG_PTR)devRel;
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            /*
             *  Fail this Irp by returning the default
             *  status (typically STATUS_NOT_SUPPORTED).
             */
            status = Irp->IoStatus.Status;
        }
        break;

    case IRP_MN_QUERY_ID:
        status = HidpQueryIdForClientPdo(HidDeviceExtension, Irp);
        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        //
        // Do not clear any flags that may have been set by drivers above
        // the PDO
        //
        // Irp->IoStatus.Information = 0;

        switch (pdoExt->state){
        case DEVICE_STATE_START_FAILURE:
            Irp->IoStatus.Information |= PNP_DEVICE_FAILED;
            break;
        case DEVICE_STATE_STOPPED:
            Irp->IoStatus.Information |= PNP_DEVICE_DISABLED;
            break;
        case DEVICE_STATE_REMOVING:
        case DEVICE_STATE_REMOVED:
            Irp->IoStatus.Information |= PNP_DEVICE_REMOVED;
            break;
        }
        status = STATUS_SUCCESS;
        break;
    case IRP_MN_QUERY_INTERFACE:
        status = HidpQueryInterface(HidDeviceExtension, Irp);
        break;

    case IRP_MN_QUERY_BUS_INFORMATION:
        {
        PPNP_BUS_INFORMATION busInfo = (PPNP_BUS_INFORMATION) ALLOCATEPOOL(NonPagedPool, sizeof(PNP_BUS_INFORMATION));
        if (busInfo) {
            busInfo->BusTypeGuid = GUID_BUS_TYPE_HID;
            busInfo->LegacyBusType = PNPBus;
            busInfo->BusNumber = fdoExt->BusNumber;
            Irp->IoStatus.Information = (ULONG_PTR) busInfo;
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;
        }
        }
        break;

    default:
        /*
         *  In the default case for the collection-PDOs we complete the IRP
         *  without changing IoStatus.Status; we also return the preset IoStatus.Status.
         *  This allows an upper filter driver to set IoStatus.Status
         *  on the way down.  In the absence of a filter driver,
         *  IoStatus.Status will be STATUS_NOT_SUPPORTED.
         *
         *  In the default case for the FDO we send the Irp on and let
         *  the other drivers in the stack do their thing.
         */
        status = Irp->IoStatus.Status;
        break;
    }


    /*
     *  If this is a call for a collection-PDO, we complete it ourselves here.
     *  Otherwise, we pass it to the minidriver stack for more processing.
     */
    ASSERT(status != NO_STATUS);
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBG_LOG_PNP_IRP(Irp, minorFunction, TRUE, TRUE, status)

    return status;
}


NTSTATUS HidpFdoPnp(
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, 
    IN OUT PIRP Irp
    )
{
    NTSTATUS            status = NO_STATUS;
    PIO_STACK_LOCATION  irpSp;
    FDO_EXTENSION       *fdoExt;
    BOOLEAN             completeIrpHere = FALSE; // general rule
    UCHAR               minorFunction;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Keep these fields privately so that we have them
     *  after the IRP is completed and in case we delete
     *  the device extension on a REMOVE_DEVICE.
     */
    minorFunction = irpSp->MinorFunction;


    DBG_LOG_PNP_IRP(Irp, minorFunction, FALSE, FALSE, 0)

    fdoExt = &HidDeviceExtension->fdoExt;

    switch (minorFunction){

    case IRP_MN_START_DEVICE:

        status = HidpStartDevice(HidDeviceExtension, Irp);
        completeIrpHere = TRUE;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        Irp->IoStatus.Status = STATUS_SUCCESS;

        DBGSTATE(fdoExt->state, DEVICE_STATE_START_SUCCESS, FALSE)
        fdoExt->prevState = fdoExt->state;
        fdoExt->state = DEVICE_STATE_STOPPING;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        Irp->IoStatus.Status = STATUS_SUCCESS;

        DBGSTATE(fdoExt->state, DEVICE_STATE_STOPPING, TRUE)
        fdoExt->state = fdoExt->prevState;
        break;

    case IRP_MN_STOP_DEVICE:
        DBGSTATE(fdoExt->state, DEVICE_STATE_STOPPING, TRUE)
        if (fdoExt->prevState == DEVICE_STATE_START_SUCCESS){

            /*
             *  While it is stopped, the host controller may not be able
             *  to complete IRPs.  So cancel them before sending down the stop.
             */
            CancelAllPingPongIrps(fdoExt);
        }
        fdoExt->state = DEVICE_STATE_STOPPED;

        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = HidpCallDriverSynchronous(fdoExt->fdo, Irp);

        completeIrpHere = TRUE;
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        //
        // On surprise removal, we should stop accessing the device.
        // We do the same steps on IRP_MN_REMOVE_DEVICE for the query
        // removal case. Don't bother doing it during query remove,
        // itself, because we don't want to have to handle the
        // cancel case. NOTE: We only get away with this because all
        // of these steps can be repeated without dire consequences.
        //
        if (ISPTR(fdoExt->waitWakeIrp)){
            IoCancelIrp(fdoExt->waitWakeIrp);
            fdoExt->waitWakeIrp = BAD_POINTER;
        }

        HidpCancelIdleNotification(fdoExt, TRUE);

        if (ISPTR(fdoExt->idleNotificationRequest)) {
            IoFreeIrp(fdoExt->idleNotificationRequest);
            fdoExt->idleNotificationRequest = BAD_POINTER;
        }
        
        DestroyPingPongs(fdoExt);

        // fall thru to IRP_MN_QUERY_REMOVE_DEVICE
        
    case IRP_MN_QUERY_REMOVE_DEVICE:
        {
        PIRP idleIrp;

        while (idleIrp = DequeuePowerDelayedIrp(fdoExt)) {
            idleIrp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
            IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
        }
        }
        
        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        Irp->IoStatus.Status = STATUS_SUCCESS;

        DBGSTATE(fdoExt->state, DEVICE_STATE_START_SUCCESS, FALSE)
        DBGASSERT((fdoExt->state == DEVICE_STATE_START_SUCCESS ||
                   fdoExt->state == DEVICE_STATE_STOPPED), 
                  ("Fdo is neither stopped nor started, but is getting removed, state=%d",fdoExt->state), 
                  FALSE)
        fdoExt->prevState = fdoExt->state;
        fdoExt->state = DEVICE_STATE_REMOVING;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        Irp->IoStatus.Status = STATUS_SUCCESS;

        DBGSTATE(fdoExt->state, DEVICE_STATE_REMOVING, TRUE)
        fdoExt->state = fdoExt->prevState;
        break;

    case IRP_MN_REMOVE_DEVICE:

        /*
         *  REMOVE_DEVICE for the device-FDO should come after REMOVE_DEVICE 
         *  for each of the collection-PDOs.
         *  Don't touch the device extension after this call.
         */
        DBGASSERT((fdoExt->state == DEVICE_STATE_REMOVING ||
                   fdoExt->state == DEVICE_STATE_START_FAILURE ||
                   fdoExt->state == DEVICE_STATE_INITIALIZED),
                  ("Incorrect device state: %x", fdoExt->state),
                 TRUE)
        status = HidpRemoveDevice(fdoExt, Irp);
        goto HidpFdoPnpDone;
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        if (irpSp->Parameters.QueryDeviceRelations.Type == BusRelations){
            status = HidpQueryDeviceRelations(HidDeviceExtension, Irp);
            if (NT_SUCCESS(status)){
                /*
                 *  Although we have satisfied this PnP IRP, 
                 *  we will still pass it down the stack.
                 *  First change the default status to our status.
                 */
                Irp->IoStatus.Status = status;
            }
            else {
                completeIrpHere = TRUE;
            }
        }
        break;

    default:
        /*
         *  In the default case for the collection-PDOs we complete the IRP
         *  without changing IoStatus.Status; we also return the preset IoStatus.Status.
         *  This allows an upper filter driver to set IoStatus.Status
         *  on the way down.  In the absence of a filter driver,
         *  IoStatus.Status will be STATUS_NOT_SUPPORTED.
         *
         *  In the default case for the FDO we send the Irp on and let
         *  the other drivers in the stack do their thing.
         */
        if (completeIrpHere){
            status = Irp->IoStatus.Status;
        }
        break;
    }


    /*
     *  If this is a call for a collection-PDO, we complete it ourselves here.
     *  Otherwise, we pass it to the minidriver stack for more processing.
     */
    if (completeIrpHere){
        ASSERT(status != NO_STATUS);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {
        /*
         *  Call the minidriver with this Irp.
         *  The rest of our processing will be done in our completion routine.
         *
         *  Note:  Don't touch the Irp after sending it down, since it may
         *         be completed immediately.
         */
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = HidpCallDriver(fdoExt->fdo, Irp);
    }

HidpFdoPnpDone:
    DBG_LOG_PNP_IRP(Irp, minorFunction, FALSE, TRUE, status)

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\feature.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    feature.c

Abstract

    Feature handling routines

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"



#if 0
    /*
     ********************************************************************************
     *  HidpGetSetFeatureComplete
     ********************************************************************************
     *
     *
     */
    NTSTATUS HidpGetSetFeatureComplete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
    {
        PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)Context;
        PHID_XFER_PACKET featurePacket = Irp->UserBuffer;
        NTSTATUS status = Irp->IoStatus.Status;

        DBG_COMMON_ENTRY()

        ASSERT(hidDeviceExtension->isClientPdo);

        if (featurePacket){

            DBG_RECORD_FEATURE(featurePacket->reportId, IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.IoControlCode, TRUE)

            /*
             *  Free the feature packet.
             */
            ExFreePool(featurePacket);
            Irp->UserBuffer = NULL;
        }

        if (NT_SUCCESS(status)){
            FDO_EXTENSION *fdoExt = &hidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;
            if (fdoExt->deviceDesc.ReportIDs[0].ReportID == 0){
                /*
                 *  Since this collection only has one report,
                 *  we deleted the report id (which is known implicitly)
                 *  on the way down.  We now have to bump the return
                 *  value to indicate that one more byte was sent or received.
                 */
                (ULONG)Irp->IoStatus.Information++;
            }
        }

        /*
         *  If the lower driver returned PENDING, mark our stack location as pending also.
         */
        if (Irp->PendingReturned){
            IoMarkIrpPending(Irp);
        }

        DBG_COMMON_EXIT()
        return status;
    }


/*
 ********************************************************************************
 *  HidpGetSetFeature
 ********************************************************************************
 *
 *  There are not many differences between reading and writing a feature at this level,
 *  so we have one function do both.
 *
 *  controlCode is either IOCTL_HID_GET_FEATURE or IOCTL_HID_SET_FEATURE.
 *
 *  Note:  This function cannot be pageable because it is called
 *         from the IOCTL dispatch routine, which can get called
 *         at DISPATCH_LEVEL.
 *
 */
NTSTATUS HidpGetSetFeature( IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
                            IN OUT PIRP Irp,
                            IN ULONG controlCode,
                            OUT BOOLEAN *sentIrp)
{
    FDO_EXTENSION   *fdoExt;
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION          currentIrpSp, nextIrpSp;
    PFILE_OBJECT                fileObject;
    PHIDCLASS_FILE_EXTENSION    fileExtension;

    DBG_COMMON_ENTRY()

    ASSERT(HidDeviceExtension->isClientPdo);
    fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;
    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);

    *sentIrp = FALSE;

    /*
     *  Get the file extension.
     */
    ASSERT(currentIrpSp->FileObject);
    fileObject = currentIrpSp->FileObject;
    
    if(!fileObject->FsContext) {
        DBGWARN(("Attempted to get/set feature with no file extension"))
        return STATUS_PRIVILEGE_NOT_HELD;
    }
    fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
    ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);

    /*
     *  Check security.
     */
    if (fileExtension->SecurityCheck){
        PHIDP_COLLECTION_DESC       collectionDesc;


        /*
         *  Get our collection  description.
         */
        collectionDesc = GetCollectionDesc(fdoExt, fileExtension->CollectionNumber);
        if (collectionDesc){

            /*
             *  Make sure that there is a feature report on this collection
             *  (or that we allow feature reads on a non-feature ctn for this device).
             */
            if ((collectionDesc->FeatureLength > 0) ||
                (fdoExt->deviceSpecificFlags & DEVICE_FLAG_ALLOW_FEATURE_ON_NON_FEATURE_COLLECTION)){

                PUCHAR featureBuf;
                ULONG featureBufLen;

                switch (controlCode){
                    case IOCTL_HID_GET_FEATURE:
                        featureBufLen = currentIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                        featureBuf = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);
                        break;
                    case IOCTL_HID_SET_FEATURE:
                        featureBuf = Irp->AssociatedIrp.SystemBuffer;
                        featureBufLen = currentIrpSp->Parameters.DeviceIoControl.InputBufferLength;
                        break;
                    default:
                        TRAP;
                        status = STATUS_INVALID_PARAMETER;
                        featureBuf = NULL;
                        featureBufLen = 0;
                }

                if (featureBuf && featureBufLen){
                    PHIDP_REPORT_IDS reportIdent;
                    UCHAR reportId;

                    /*
                     *  The client includes the report id as the first byte of the report.
                     *  We send down the report byte only if the device has multiple
                     *  report IDs (i.e. the report id is not implicit).
                     */
                    reportId = featureBuf[0];
                    if (fdoExt->deviceDesc.ReportIDs[0].ReportID == 0){
                        DBGASSERT((reportId == 0),
                                  ("Report Id should be zero, acutal id = %d", reportId),
                                  FALSE)
                        featureBuf++;
                        featureBufLen--;
                    }

                    /*
                     *  Try to find a matching feature report for this device.
                     */
                    reportIdent = GetReportIdentifier(fdoExt, reportId);

    
                    /*
                     *  Check the buffer length against the
                     *  feature length in the report identifier.
                     */
                    if (reportIdent){
                        if (reportIdent->FeatureLength){
                            switch (controlCode){
                                case IOCTL_HID_GET_FEATURE:
                                    /*
                                     *  The buffer must be big enough for the report.
                                     */
                                    if (featureBufLen < reportIdent->FeatureLength){
                                        ASSERT(!(PVOID)"feature buf must be at least feature size for get-feature.");
                                        reportIdent = NULL;
                                    }
                                    break;
                                case IOCTL_HID_SET_FEATURE:
                                    /*
                                     *  The buffer must be big enough for the report.
                                     *  It CAN be larger, and it is up to us to use
                                     *  the correct report size from the report identifier.
                                     */
                                    if (featureBufLen < reportIdent->FeatureLength){
                                        ASSERT(!(PVOID)"feature buf must be exact size for set-feature.");
                                        reportIdent = NULL;
                                    }
                                    else {
                                        featureBufLen = reportIdent->FeatureLength;
                                    }
                                    break;
                            }
                        }
                        else {
                            /*
                             *  This report id is not for a feature report.
                             */
                            reportIdent = NULL;
                        }
                    }

                    if (reportIdent ||
                        (fdoExt->deviceSpecificFlags & DEVICE_FLAG_ALLOW_FEATURE_ON_NON_FEATURE_COLLECTION)){

                        PHID_XFER_PACKET featurePacket = ALLOCATEPOOL(NonPagedPool, sizeof(HID_XFER_PACKET));

                        if (featurePacket){

                            featurePacket->reportBuffer = featureBuf;
                            featurePacket->reportBufferLen = featureBufLen;
                            featurePacket->reportId = reportId;

                            Irp->UserBuffer = featurePacket;

                            /*
                             *  Prepare the next (lower) IRP stack location.
                             *  This will be HIDUSB's "current" stack location.
                             */
                            nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                            nextIrpSp->Parameters.DeviceIoControl.IoControlCode = controlCode;

                            /*
                             *  Note - input/output is relative to IOCTL servicer
                             */
                            switch (controlCode){
                                case IOCTL_HID_GET_FEATURE:
                                    nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(HID_XFER_PACKET);
                                    break;
                                case IOCTL_HID_SET_FEATURE:
                                    nextIrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(HID_XFER_PACKET);
                                    break;
                                default:
                                    TRAP;
                            }

                            DBG_RECORD_FEATURE(reportId, controlCode, FALSE)

                            status = HidpCallDriverSynchronous(fdoExt->fdo, Irp);
                            if (!NT_SUCCESS(status)){
                                DBGWARN(("HidpGetSetFeature: usb returned status %xh.", status))
                            }
                            DBG_RECORD_FEATURE(reportId, controlCode, TRUE)
                            ExFreePool(featurePacket);
                            *sentIrp = FALSE; // needs to be completed again

                        } 
                        else {
                            ASSERT(featurePacket);
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    } 
                    else {
                        DBGASSERT(reportIdent, ("Some yahoo sent invalid data in ioctl %x", controlCode), FALSE)
                        status = STATUS_DATA_ERROR;
                    }
                } 
                else if (NT_SUCCESS(status)) {
                    DBGASSERT(featureBuf, ("Feature buffer is invalid"), FALSE)
                    DBGASSERT(featureBufLen, ("Feature buffer length is invalid"), FALSE)
                    status = STATUS_INVALID_BUFFER_SIZE;
                }
            } 
            else {
                ASSERT(collectionDesc->FeatureLength);
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
        } 
        else {
            ASSERT(collectionDesc);
            status = STATUS_DEVICE_NOT_CONNECTED;
        }
    } 
    else {
        ASSERT(fileExtension->SecurityCheck);
        status = STATUS_PRIVILEGE_NOT_HELD;
    }

    DBGSUCCESS(status, FALSE)
    
    DBG_COMMON_EXIT()

    return status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\device.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    device.c

Abstract

        Resource management routines for devices and collections

Author:

    ervinp

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, HidpStartDevice)
        #pragma alloc_text(PAGE, HidpStartCollectionPDO)
        #pragma alloc_text(PAGE, AllocDeviceResources)
        #pragma alloc_text(PAGE, FreeDeviceResources)
        #pragma alloc_text(PAGE, AllocCollectionResources)
        #pragma alloc_text(PAGE, FreeCollectionResources)
        #pragma alloc_text(PAGE, InitializeCollection)
        #pragma alloc_text(PAGE, HidpCleanUpFdo)
        #pragma alloc_text(PAGE, HidpRemoveDevice)
        #pragma alloc_text(PAGE, HidpRemoveCollection)
#endif

/*
 ********************************************************************************
 *  AllocDeviceResources
 ********************************************************************************
 *
 *
 */
NTSTATUS AllocDeviceResources(FDO_EXTENSION *fdoExt)
{
    ULONG numCollections;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    /*
     *  This will allocate fdoExt->rawReportDescription
     */
    status = HidpGetDeviceDescriptor(fdoExt);
    if (NT_SUCCESS(status)){

        /*
         *  Ask HIDPARSE to fill in the HIDP_DEVICE_DESC for this device.
         */
        status = HidP_GetCollectionDescription(
                                fdoExt->rawReportDescription,
                                fdoExt->rawReportDescriptionLength,
                                NonPagedPool,
                                &fdoExt->deviceDesc);

        if (NT_SUCCESS(status)){
            fdoExt->devDescInitialized = TRUE;

            numCollections = fdoExt->deviceDesc.CollectionDescLength;
            ASSERT(numCollections);

            fdoExt->classCollectionArray = ALLOCATEPOOL(NonPagedPool, numCollections*sizeof(HIDCLASS_COLLECTION));
            if (!fdoExt->classCollectionArray){
                fdoExt->classCollectionArray = BAD_POINTER;
                status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RtlZeroMemory(fdoExt->classCollectionArray, numCollections*sizeof(HIDCLASS_COLLECTION));
            }
        }
    }
    else {
        fdoExt->rawReportDescription = BAD_POINTER;
    }

    DBGSUCCESS(status, FALSE)
    return status;
}


/*
 ********************************************************************************
 *  FreeDeviceResources
 ********************************************************************************
 *
 *
 */
VOID FreeDeviceResources(FDO_EXTENSION *fdoExt)
{
    ULONG i;

    PAGED_CODE();

    for (i = 0; i < fdoExt->deviceDesc.CollectionDescLength; i++) {
        FreeCollectionResources(fdoExt, fdoExt->classCollectionArray[i].CollectionNumber);
    }

    /*
     *  Free the stuff returned by HIDPARSE's HidP_GetCollectionDescription.
     */
    if (fdoExt->devDescInitialized){
        HidP_FreeCollectionDescription(&fdoExt->deviceDesc);
        #if DBG
            fdoExt->deviceDesc.CollectionDesc = BAD_POINTER;
            fdoExt->deviceDesc.ReportIDs = BAD_POINTER;
        #endif
    }
    fdoExt->deviceDesc.CollectionDescLength = 0;

    /*
     *  Free the raw report descriptor allocated during START_DEVICE by HidpGetDeviceDescriptor().
     */
    if (ISPTR(fdoExt->rawReportDescription)){
        ExFreePool(fdoExt->rawReportDescription);
    }
    fdoExt->rawReportDescription = BAD_POINTER;

    if (ISPTR(fdoExt->classCollectionArray)){
        ExFreePool(fdoExt->classCollectionArray);
    }
    fdoExt->classCollectionArray = BAD_POINTER;

}


/*
 ********************************************************************************
 *  AllocCollectionResources
 ********************************************************************************
 *
 *
 */
NTSTATUS AllocCollectionResources(FDO_EXTENSION *fdoExt, ULONG collectionNum)
{
    PHIDCLASS_COLLECTION collection;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    collection = GetHidclassCollection(fdoExt, collectionNum);
    if (collection){
        ULONG descriptorLen;

        descriptorLen = collection->hidCollectionInfo.DescriptorSize;
        if (descriptorLen){
            collection->phidDescriptor = ALLOCATEPOOL(NonPagedPool, descriptorLen);
            if (collection->phidDescriptor){
                status = HidpGetCollectionDescriptor(
                                        fdoExt,
                                        collection->CollectionNumber,
                                        collection->phidDescriptor,
                                        &descriptorLen);
            }
            else {
                collection->phidDescriptor = BAD_POINTER;
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (NT_SUCCESS(status)){
                ULONG i = collection->CollectionIndex;
                ULONG inputLength;

                ASSERT(fdoExt->devDescInitialized);
                inputLength = fdoExt->deviceDesc.CollectionDesc[i].InputLength;
                if (inputLength){
                    if (collection->hidCollectionInfo.Polled){
                        collection->cookedInterruptReportBuf = BAD_POINTER;
                    }
                    else {
                        collection->cookedInterruptReportBuf = ALLOCATEPOOL(NonPagedPool, inputLength);
                        if (!collection->cookedInterruptReportBuf){
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }
                    fdoExt->isOutputOnlyDevice = FALSE;
                }
                else {
                    /*
                     *  This is an output-only device (e.g. USB monitor)
                     */
                    DBGWARN(("Zero input length -> output-only device."))
                    collection->cookedInterruptReportBuf = BAD_POINTER;
                }
            }
        }
        else {
            ASSERT(descriptorLen > 0);
            status = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
    }
    else {
        status = STATUS_DEVICE_DATA_ERROR;
    }

    DBGSUCCESS(status, TRUE)
    return status;
}


/*
 ********************************************************************************
 *  FreeCollectionResources
 ********************************************************************************
 *
 *
 */
VOID FreeCollectionResources(FDO_EXTENSION *fdoExt, ULONG collectionNum)
{
    PHIDCLASS_COLLECTION collection;

    PAGED_CODE();

    collection = GetHidclassCollection(fdoExt, collectionNum);
    if (collection){
        if (collection->hidCollectionInfo.Polled){
            if (ISPTR(collection->savedPolledReportBuf)){
                ExFreePool(collection->savedPolledReportBuf);
            }
            collection->savedPolledReportBuf = BAD_POINTER;
        }
        else {
            if (ISPTR(collection->cookedInterruptReportBuf)){
                ExFreePool(collection->cookedInterruptReportBuf);
            }
            else {
                // this is an output-only collection
            }
        }
        collection->cookedInterruptReportBuf = BAD_POINTER;

        if (ISPTR(collection->phidDescriptor)){
            ExFreePool(collection->phidDescriptor);
        }
        collection->phidDescriptor = BAD_POINTER;
    }
    else {
        TRAP;
    }
}


/*
 ********************************************************************************
 *  InitializeCollection
 ********************************************************************************
 *
 *
 */
NTSTATUS InitializeCollection(FDO_EXTENSION *fdoExt, ULONG collectionIndex)
{
    PHIDCLASS_COLLECTION collection;
    ULONG descriptorBufLen;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(ISPTR(fdoExt->classCollectionArray));

    collection = &fdoExt->classCollectionArray[collectionIndex];
    RtlZeroMemory(collection, sizeof(HIDCLASS_COLLECTION));

    ASSERT(fdoExt->devDescInitialized);
    collection->CollectionNumber = fdoExt->deviceDesc.CollectionDesc[collectionIndex].CollectionNumber;
    collection->CollectionIndex = collectionIndex;
    InitializeListHead(&collection->FileExtensionList);
    KeInitializeSpinLock(&collection->FileExtensionListSpinLock);
    KeInitializeSpinLock(&collection->powerEventSpinLock);
    KeInitializeSpinLock(&collection->secureReadLock);
    collection->secureReadMode = 0;

    descriptorBufLen = sizeof(HID_COLLECTION_INFORMATION);
    status = HidpGetCollectionInformation(  fdoExt,
                                            collection->CollectionNumber,
                                            &collection->hidCollectionInfo,
                                            &descriptorBufLen);

    DBGSUCCESS(status, TRUE)
    return status;
}


void
HidpGetRemoteWakeEnableState(
    PDO_EXTENSION *pdoExt
    )
{
    HANDLE hKey;
    NTSTATUS status;
    ULONG tmp;
    BOOLEAN wwEnableFound;

    hKey = NULL;
    wwEnableFound = FALSE;

    status = IoOpenDeviceRegistryKey (pdoExt->pdo,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      STANDARD_RIGHTS_ALL,
                                      &hKey);

    if (NT_SUCCESS (status)) {
        UNICODE_STRING  valueName;
        ULONG           length;
        ULONG           value;
        PKEY_VALUE_FULL_INFORMATION fullInfo;

        PAGED_CODE();

        RtlInitUnicodeString (&valueName, HIDCLASS_REMOTE_WAKE_ENABLE);

        length = sizeof (KEY_VALUE_FULL_INFORMATION)
               + valueName.MaximumLength
               + sizeof(value);

        fullInfo = ExAllocatePool (PagedPool, length);

        if (fullInfo) {
            status = ZwQueryValueKey (hKey,
                                      &valueName,
                                      KeyValueFullInformation,
                                      fullInfo,
                                      length,
                                      &length);

            if (NT_SUCCESS (status)) {
                DBGASSERT (sizeof(value) == fullInfo->DataLength,
                           ("Value data wrong length for REmote wake reg value."),
                           TRUE);
                RtlCopyMemory (&value,
                               ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                               fullInfo->DataLength);
                pdoExt->remoteWakeEnabled = (value ? TRUE : FALSE);
            }

            ExFreePool (fullInfo);
        }

        ZwClose (hKey);
        hKey = NULL;
    }
}

WMIGUIDREGINFO HidClassWmiGuidList =
{
    &GUID_POWER_DEVICE_WAKE_ENABLE,
    1,
    0 // wait wake
};

WMIGUIDREGINFO HidClassFdoWmiGuidList = 
{
    &GUID_POWER_DEVICE_ENABLE,
    1,
    0
};


/*
 ********************************************************************************
 *  HidpStartCollectionPDO
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpStartCollectionPDO(FDO_EXTENSION *fdoExt, PDO_EXTENSION *pdoExt, PIRP Irp)
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    /*
     *  Initialize the collection only if it's not already initialized.
     *  This is so we don't destroy the FileExtensionList after a STOP/START.
     */
    if (pdoExt->state == COLLECTION_STATE_UNINITIALIZED){
        pdoExt->state = COLLECTION_STATE_INITIALIZED;
    }

    if (NT_SUCCESS(status)){

        PHIDCLASS_COLLECTION collection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
        if (collection){

            /*
             *  If all collection PDOs for this device FDO are initialized,
             *  figure out the maximum report size and finish starting the device.
             */
            if (AnyClientPDOsInitialized(fdoExt, TRUE)){

                DBGSTATE(fdoExt->state, DEVICE_STATE_START_SUCCESS, FALSE)

                /*
                 *  If this is a polled collection,
                 *  start the background polling loop FOR EACH COLLECTION.
                 *  Otherwise, if it's an ordinary interrupt collection,
                 *  start the ping-pong IRPs for it.
                 */
                if (collection->hidCollectionInfo.Polled){

                    if (HidpSetMaxReportSize(fdoExt)){

                        ULONG i;
                        for (i = 0; i < fdoExt->deviceDesc.CollectionDescLength; i++){
                            PHIDCLASS_COLLECTION ctn;
                            ctn = &fdoExt->classCollectionArray[i];

                            /*
                             *  If one of the collections is polled, they
                             *  should ALL be polled.
                             */
                            ASSERT(ctn->hidCollectionInfo.Polled);

                            ctn->PollInterval_msec = DEFAULT_POLL_INTERVAL_MSEC;

                            /*
                             *  Allocate the buffer for saving the polled device's
                             *  last report.  Allocate one more byte than the max
                             *  report size for the device in case we have to
                             *  prepend a report id byte.
                             */
                            ctn->savedPolledReportBuf = ALLOCATEPOOL(NonPagedPool, fdoExt->maxReportSize+1);
                            if (ctn->savedPolledReportBuf){
                                ctn->polledDataIsStale = TRUE;
                                StartPollingLoop(fdoExt, ctn, TRUE);
                                status = STATUS_SUCCESS;
                            }
                            else {
                                ASSERT(ctn->savedPolledReportBuf);
                                status = STATUS_INSUFFICIENT_RESOURCES;
                            }
                        }
                    }
                }
                else if (fdoExt->isOutputOnlyDevice){
                    /*
                     *  Don't start ping-pong IRPs.
                     */
                }
                else {
                    status = HidpStartAllPingPongs(fdoExt);
                }
            }

            if (NT_SUCCESS(status)) {
                pdoExt->state = COLLECTION_STATE_RUNNING;
                #if DBG
                    collection->Signature = HIDCLASS_COLLECTION_SIG;
                #endif

                /*
                 *  Create the 'file-name' used by clients to open this device.
                 */
                HidpCreateSymbolicLink(pdoExt, pdoExt->collectionNum, TRUE, pdoExt->pdo);

                if (!pdoExt->MouseOrKeyboard &&
                    WAITWAKE_SUPPORTED(fdoExt)) {
                    //
                    // register for the wait wake guid as well
                    //
                    pdoExt->WmiLibInfo.GuidCount = sizeof (HidClassWmiGuidList) /
                                                 sizeof (WMIGUIDREGINFO);
                    ASSERT (1 == pdoExt->WmiLibInfo.GuidCount);

                    //
                    // See if the user has enabled remote wake for the device
                    // PRIOR to registering with WMI.
                    //
                    HidpGetRemoteWakeEnableState(pdoExt);

                    pdoExt->WmiLibInfo.GuidList = &HidClassWmiGuidList;
                    pdoExt->WmiLibInfo.QueryWmiRegInfo = HidpQueryWmiRegInfo;
                    pdoExt->WmiLibInfo.QueryWmiDataBlock = HidpQueryWmiDataBlock;
                    pdoExt->WmiLibInfo.SetWmiDataBlock = HidpSetWmiDataBlock;
                    pdoExt->WmiLibInfo.SetWmiDataItem = HidpSetWmiDataItem;
                    pdoExt->WmiLibInfo.ExecuteWmiMethod = NULL;
                    pdoExt->WmiLibInfo.WmiFunctionControl = NULL;

                    IoWMIRegistrationControl(pdoExt->pdo, WMIREG_ACTION_REGISTER);

                    if (SHOULD_SEND_WAITWAKE(pdoExt)) {
                        HidpCreateRemoteWakeIrp(pdoExt);
                    }
                }

                if (AllClientPDOsInitialized(fdoExt, TRUE)){
                    HidpStartIdleTimeout(fdoExt, TRUE);
                }
            }
        }
        else {
            status = STATUS_DEVICE_DATA_ERROR;
        }
    }

    DBGSUCCESS(status, FALSE)
    return status;
}





/*
 ********************************************************************************
 *  HidpStartDevice
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpStartDevice(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, PIRP Irp)
{
    FDO_EXTENSION *fdoExt;
    enum deviceState previousState;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    ASSERT(!HidDeviceExtension->isClientPdo);
    fdoExt = &HidDeviceExtension->fdoExt;

    previousState = fdoExt->state;
    fdoExt->state = DEVICE_STATE_STARTING;

    /*
     *  Get the power-state conversion table
     */
    status = HidpQueryDeviceCapabilities(
                        HidDeviceExtension->hidExt.PhysicalDeviceObject,
                        &fdoExt->deviceCapabilities);
    if (NT_SUCCESS(status)){

        /*
         *  Alert the rest of the driver stack that the device is starting.
         */
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = HidpCallDriverSynchronous(fdoExt->fdo, Irp);

        if (NT_SUCCESS(status)){

            /*
             *  If we're just resuming from STOP,
             *  there's nothing else to do;
             *  otherwise, need to call down the USB stack
             *  for some info and allocate some resources.
             */
            if (previousState == DEVICE_STATE_INITIALIZED){

                status = AllocDeviceResources(fdoExt);
                if (NT_SUCCESS(status)){
                    /*
                     *  Assume this is an output-only device until we start
                     *  a collection-pdo which handles inputs.
                     *  Only set fdoExt->isOutputOnlyDevice on the first start
                     *  not on a subsequent start following a stop.
                     */
                    fdoExt->isOutputOnlyDevice = TRUE;

                    /*  
                     *  Initialize WMI stuff
                     */

                    fdoExt->WmiLibInfo.GuidCount = sizeof(HidClassFdoWmiGuidList) /
                                                   sizeof (WMIGUIDREGINFO);

                    fdoExt->WmiLibInfo.GuidList = &HidClassFdoWmiGuidList;
                    fdoExt->WmiLibInfo.QueryWmiRegInfo = HidpQueryWmiRegInfo;
                    fdoExt->WmiLibInfo.QueryWmiDataBlock = HidpQueryWmiDataBlock;
                    fdoExt->WmiLibInfo.SetWmiDataBlock = HidpSetWmiDataBlock;
                    fdoExt->WmiLibInfo.SetWmiDataItem = HidpSetWmiDataItem;
                    fdoExt->WmiLibInfo.ExecuteWmiMethod = NULL;
                    fdoExt->WmiLibInfo.WmiFunctionControl = NULL;



                    /*
                     *  Allocate all the collection resources before allocating
                     *  the pingpong irps, so that we can set a maximum report
                     *  size.
                     */
                    for (i = 0; i < fdoExt->deviceDesc.CollectionDescLength; i++) {

                        // If one of these fails, we will clean up properly
                        // in the remove routine, so there's no need to
                        // bother cleaning up here.

                        status = InitializeCollection(fdoExt, i);
                        if (!NT_SUCCESS(status)){
                            break;
                        }

                        status = AllocCollectionResources(fdoExt, fdoExt->deviceDesc.CollectionDesc[i].CollectionNumber);
                        if (!NT_SUCCESS(status)){
                            break;
                        }
                    }

                    /*
                     *  We need ot allocate the pingpongs in the fdo start
                     *  routine due to race conditions introduced by selective
                     *  suspend.
                     */
                    if (!fdoExt->isOutputOnlyDevice &&
                        !fdoExt->driverExt->DevicesArePolled) {
                        status = HidpReallocPingPongIrps(fdoExt, MIN_PINGPONG_IRPS);
                    }
                    if (NT_SUCCESS(status)){
                        /*
                         *  We will have to create an array of PDOs, one for each device class.
                         *  The following call will cause NTKERN to call us back with
                         *  IRP_MN_QUERY_DEVICE_RELATIONS and initialize its collection-PDOs.
                         */
                        IoInvalidateDeviceRelations(HidDeviceExtension->hidExt.PhysicalDeviceObject, BusRelations);
                    }
                }
            }
            else if (previousState == DEVICE_STATE_STOPPED){
                //
                // Any request that comes in when we are in low power will be
                // dealt with at that time
                //
                DBGSTATE(fdoExt->prevState, DEVICE_STATE_START_SUCCESS, TRUE)
            }
            else {
                TRAP;
                status = STATUS_DEVICE_CONFIGURATION_ERROR;
            }
        }
    }

    if (NT_SUCCESS(status)){
        fdoExt->state = DEVICE_STATE_START_SUCCESS;
        #if WIN95_BUILD
            /*
             *  Send down the WaitWake IRP.
             *  This allows the device to wake up the system.
             *
             *  Note:   On Win98 there is no way for a client to
             *          send a WaitWake IRP.  Therefore we initiate
             *          a WaitWake IRP for every device, not just
             *          if a client sends us a WaitWake IRP, like on NT.
             */
            /*
             * We could have been suspended, stopped, then started again.  In
             * this case, we need to not send a WW irp because we already have
             * on pending.
             */
            if (fdoExt->deviceCapabilities.SystemWake > PowerSystemWorking) {
                SubmitWaitWakeIrp(HidDeviceExtension);
            }
        #endif

        #if DBG
            {
                ULONG i;

                // Win98 doesn't have good debug extensions
                DBGVERBOSE(("Started fdoExt %ph with %d collections: ", fdoExt, fdoExt->deviceDesc.CollectionDescLength))
                for (i = 0; i < fdoExt->deviceDesc.CollectionDescLength; i++){
                    DBGVERBOSE(("   - collection #%d: (in=%xh,out=%xh,feature=%xh) usagePage %xh, usage %xh ",
                            fdoExt->deviceDesc.CollectionDesc[i].CollectionNumber,
                            fdoExt->deviceDesc.CollectionDesc[i].InputLength,
                            fdoExt->deviceDesc.CollectionDesc[i].OutputLength,
                            fdoExt->deviceDesc.CollectionDesc[i].FeatureLength,
                            fdoExt->deviceDesc.CollectionDesc[i].UsagePage,
                            fdoExt->deviceDesc.CollectionDesc[i].Usage))
                }
            }
        #endif

    }
    else {
        fdoExt->state = DEVICE_STATE_START_FAILURE;
    }

    DBGSUCCESS(status, FALSE)
    return status;
}


VOID
HidpCleanUpFdo(FDO_EXTENSION *fdoExt)
{
    PAGED_CODE();

    if (fdoExt->openCount == 0){
        /*
         *  This is the last CLOSE on an alreay-removed device.
         *
         *  Free resources and the FDO name
         *  (wPdoName that was allocated in HidpAddDevice);
         *
         */
        DequeueFdoExt(fdoExt);
        FreeDeviceResources(fdoExt);
        RtlFreeUnicodeString(&fdoExt->name);
        IoWMIRegistrationControl(fdoExt->fdo, WMIREG_ACTION_DEREGISTER);

        /*
         *  Delete the device-FDO and all collection-PDOs
         *  Don't touch fdoExt after this.
         */
        HidpDeleteDeviceObjects(fdoExt);
    }
}

/*
 ********************************************************************************
 *  HidpRemoveDevice
 ********************************************************************************
 *
 */
NTSTATUS HidpRemoveDevice(FDO_EXTENSION *fdoExt, IN PIRP Irp)
{
    BOOLEAN proceedWithRemove;
    NTSTATUS status;
    PIRP IdleIrp;

    PAGED_CODE();

    /*
     *  All collection-PDOs should have been removed by now,
     *  but we want to verify this.
     *  Only allow removal of this device-FDO if all the
     *  collection-PDOs are removed
     *  (or if they never got created in the first place).
     */
    if (fdoExt->prevState == DEVICE_STATE_START_FAILURE){
        proceedWithRemove = TRUE;
    }
    else if (fdoExt->prevState == DEVICE_STATE_STOPPED){
        /*
         *  If a device fails to initialize, it may get
         *  STOP_DEVICE before being removed, so we want to
         *  go ahead and remove it without calling
         *  AllClientPDOsInitialized, which accesses some
         *  data which may not have been initialized.
         *  In this case we're never checking for the
         *  case that the device was initialized successfully,
         *  then stopped, and then removed without its
         *  collection-PDOs being removed; but this is an
         *  illegal case, so we'll just punt on it.
         */
        proceedWithRemove = TRUE;
    }
    else if (AllClientPDOsInitialized(fdoExt, FALSE)){
        proceedWithRemove = TRUE;
    }
    else {
        /*
         *  This shouldn't happen -- all the collection-PDOs
         *  should have been removed before the device-FDO.
         */
        DBGERR(("State of fdo %x state is %d",fdoExt->fdo,fdoExt->state))
        TRAP;
        proceedWithRemove = FALSE;
    }

    if (proceedWithRemove){
        PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension =
            CONTAINING_RECORD(fdoExt, HIDCLASS_DEVICE_EXTENSION, fdoExt);

        DBGASSERT((fdoExt->state == DEVICE_STATE_REMOVING ||
                   fdoExt->state == DEVICE_STATE_INITIALIZED ||
                   fdoExt->state == DEVICE_STATE_START_FAILURE),
                  ("Device is in incorrect state: %x", fdoExt->state),
                  TRUE)

        if (ISPTR(fdoExt->waitWakeIrp)){
            IoCancelIrp(fdoExt->waitWakeIrp);
            fdoExt->waitWakeIrp = BAD_POINTER;
        }

        HidpCancelIdleNotification(fdoExt, TRUE);

        if (ISPTR(fdoExt->idleNotificationRequest)) {
            IoFreeIrp(fdoExt->idleNotificationRequest);
            fdoExt->idleNotificationRequest = BAD_POINTER;
        }

        while (IdleIrp = DequeuePowerDelayedIrp(fdoExt)) {
            IdleIrp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
            IoCompleteRequest(IdleIrp, IO_NO_INCREMENT);
        }

        DestroyPingPongs(fdoExt);

        /*
         *  Note: THE ORDER OF THESE ACTIONS IS VERY CRITICAL
         */

        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = HidpCallDriver(fdoExt->fdo, Irp);

        fdoExt->state = DEVICE_STATE_REMOVED;

        DerefDriverExt(fdoExt->driverExt->MinidriverObject);
        fdoExt->driverExt = BAD_POINTER;

        /*
         *  After Detach we can no longer send IRPS to this device
         *  object as it will be GONE!
         */
        IoDetachDevice(HidDeviceExtension->hidExt.NextDeviceObject);

        /*
         *  If all client handles on this device have been closed,
         *  destroy the objects and our context for it;
         *  otherwise, we'll do this when the last client closes
         *  their handle.
         *
         * On NT we can only get here if all our creates have been closed, so
         * this is unnecessary, but on Win9x, a remove can be sent with valid
         * opens against the stack.
         *
         *  Don't touch fdoExt after this.
         */
        HidpCleanUpFdo(fdoExt);
    }
    else {
        status = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    DBGSUCCESS(status, FALSE)
    return status;
}


/*
 ********************************************************************************
 *  HidpRemoveCollection
 ********************************************************************************
 *
 */
VOID HidpRemoveCollection(FDO_EXTENSION *fdoExt, PDO_EXTENSION *pdoExt, IN PIRP Irp)
{

    PAGED_CODE();

    //
    // This pdo is no longer available as it has been removed.
    // It should still be returned for each Query Device Relations
    // IRPS to the HID bus, but it itself should respond to all
    // IRPS with STATUS_DELETE_PENDING.
    //
    if (pdoExt->prevState == COLLECTION_STATE_UNINITIALIZED ||  // for started pdos
        pdoExt->state == COLLECTION_STATE_UNINITIALIZED){       // For unstarted pdos
        pdoExt->state = COLLECTION_STATE_UNINITIALIZED;
        DBGVERBOSE(("HidpRemoveCollection: collection uninitialized."))
    }
    else {
        ULONG ctnIndx = pdoExt->collectionIndex;
        PHIDCLASS_COLLECTION collection = &fdoExt->classCollectionArray[ctnIndx];
        ULONG numReportIDs = fdoExt->deviceDesc.ReportIDsLength;
        PIRP remoteWakeIrp;

        if (!pdoExt->MouseOrKeyboard &&
            WAITWAKE_SUPPORTED(fdoExt)) {
            //
            // Unregister for remote wakeup.
            //
            IoWMIRegistrationControl (pdoExt->pdo, WMIREG_ACTION_DEREGISTER);
        }

        remoteWakeIrp = (PIRP)
            InterlockedExchangePointer(&pdoExt->remoteWakeIrp, NULL);

        if (remoteWakeIrp) {
            IoCancelIrp(remoteWakeIrp);
        }

        pdoExt->state = COLLECTION_STATE_UNINITIALIZED;

         /*
         *  Destroy this collection.
         *  This will also abort all pending reads on this collection-PDO.
         */
        HidpDestroyCollection(fdoExt, collection);
    }

    DBGVERBOSE(("HidpRemoveCollection: removed pdo %ph (refCount=%xh)", pdoExt->pdo, (ULONG)(*(((PUCHAR)pdoExt->pdo)-0x18))))
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract


Author:

    Forrest Foltz
    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/



#include <wdm.h>
#include <stdio.h>
#include <hidpddi.h>
#include <hidport.h>
#include <wmilib.h>
#include <wdmguid.h>
#include <wmistr.h>
#include "..\inc\bluescrn.h"
#include "local.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\local.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    local.h

Abstract

    Definitions that are private to the hid class driver code appear here.

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/


typedef struct _HID_DESCRIPTOR            *PHID_DESCRIPTOR;
typedef struct _HIDCLASS_COLLECTION       *PHIDCLASS_COLLECTION;
typedef struct _HIDCLASS_DEVICE_EXTENSION *PHIDCLASS_DEVICE_EXTENSION;
typedef struct _HIDCLASS_DRIVER_EXTENSION *PHIDCLASS_DRIVER_EXTENSION;
typedef struct _HIDCLASS_FILE_EXTENSION   *PHIDCLASS_FILE_EXTENSION;
typedef struct _HIDCLASS_PINGPONG         *PHIDCLASS_PINGPONG;
typedef struct _HIDCLASS_REPORT           *PHIDCLASS_REPORT;
typedef struct _FDO_EXTENSION             *PFDO_EXTENSION;
typedef struct _PDO_EXTENSION             *PPDO_EXTENSION;


#if DBG
    #define LockFileExtension( f, i )                               \
        {                                                           \
            KeAcquireSpinLock( &(f)->ListSpinLock, (i) );           \
            (f)->ListSpinLockTaken = TRUE;                          \
        }

    #define UnlockFileExtension(f, i)                               \
        {                                                           \
            (f)->ListSpinLockTaken = FALSE;                         \
            KeReleaseSpinLock( &(f)->ListSpinLock, (i) );           \
        }

        VOID DbgLogIntStart();
        VOID DbgLogIntEnd();
        #define DBGLOG_INTSTART() DbgLogIntStart();
        #define DBGLOG_INTEND() DbgLogIntEnd();

        VOID DbgTestGetDeviceString(PFDO_EXTENSION fdoExt);
        VOID DbgTestGetIndexedString(PFDO_EXTENSION fdoExt);

#else
    #define LockFileExtension(f, i) KeAcquireSpinLock(&(f)->ListSpinLock, (i));
    #define UnlockFileExtension(f, i) KeReleaseSpinLock(&(f)->ListSpinLock, (i));

        #define DBGLOG_INTSTART()
        #define DBGLOG_INTEND()
#endif

#define HIDCLASS_POOL_TAG 'CdiH'
#define ALLOCATEPOOL(poolType, size) ExAllocatePoolWithTag((poolType), (size), HIDCLASS_POOL_TAG)

//
// On some busses, we can power down the bus, but not the system, in this case
// we still need to allow the device to wake said bus, therefore
// waitwake-supported should not rely on systemstate.
//
#define WAITWAKE_SUPPORTED(fdoExt) ((fdoExt)->deviceCapabilities.DeviceWake > PowerDeviceD0 && \
                                    (fdoExt)->deviceCapabilities.SystemWake > PowerSystemWorking)

// #define WAITWAKE_ON(port)        ((port)->WaitWakeIrp != 0)
#define REMOTEWAKE_ON(port) \
       (InterlockedCompareExchangePointer(&(port)->remoteWakeIrp, NULL, NULL) != NULL)

BOOLEAN
HidpCheckRemoteWakeEnabled(
    IN PPDO_EXTENSION PdoExt
    );

#define SHOULD_SEND_WAITWAKE(pdoExt) (!(pdoExt)->MouseOrKeyboard && \
                                    WAITWAKE_SUPPORTED(&(pdoExt)->deviceFdoExt->fdoExt) && \
                                    !REMOTEWAKE_ON(pdoExt)       && \
                                    HidpCheckRemoteWakeEnabled(pdoExt))

/*
 *  String constants for use in compatible-id multi-string.
 */
//                                             0123456789 123456789 1234
#define HIDCLASS_COMPATIBLE_ID_STANDARD_NAME L"HID_DEVICE\0"
#define HIDCLASS_COMPATIBLE_ID_GENERIC_NAME  L"HID_DEVICE_UP:%04x_U:%04x\0"
#define HIDCLASS_COMPATIBLE_ID_PAGE_OFFSET  14
#define HIDCLASS_COMPATIBLE_ID_USAGE_OFFSET 21
#define HIDCLASS_COMPATIBLE_ID_STANDARD_LENGTH 11
#define HIDCLASS_COMPATIBLE_ID_GENERIC_LENGTH 26
//                                        0123456789 123456789 123456
#define HIDCLASS_SYSTEM_KEYBOARD        L"HID_DEVICE_SYSTEM_KEYBOARD\0"
#define HIDCLASS_SYSTEM_MOUSE           L"HID_DEVICE_SYSTEM_MOUSE\0"
#define HIDCLASS_SYSTEM_GAMING_DEVICE   L"HID_DEVICE_SYSTEM_GAME\0"
#define HIDCLASS_SYSTEM_CONTROL         L"HID_DEVICE_SYSTEM_CONTROL\0"
#define HIDCLASS_SYSTEM_CONSUMER_DEVICE L"HID_DEVICE_SYSTEM_CONSUMER\0"

//
// String constant used to find out if selective suspend
// is supported on this device.
//
#define HIDCLASS_SELECTIVE_SUSPEND_ENABLED L"SelectiveSuspendEnabled\0"
#define HIDCLASS_SELECTIVE_SUSPEND_ON L"SelectiveSuspendOn\0"
#define HIDCLASS_REMOTE_WAKE_ENABLE L"RemoteWakeEnabled"

#define NO_STATUS 0x80000000    // this will never be a STATUS_xxx constant in NTSTATUS.H

#define HID_DEFAULT_IDLE_TIME       5 // in seconds

//
// Valid values for HIDCLASS_DEVICE_EXTENSION.state
//
enum deviceState {
                    DEVICE_STATE_INITIALIZED = 1,
                    DEVICE_STATE_STARTING,
                    DEVICE_STATE_START_SUCCESS,
                    DEVICE_STATE_START_FAILURE,
                    DEVICE_STATE_STOPPING,
                    DEVICE_STATE_STOPPED,
                    DEVICE_STATE_REMOVING,
                    DEVICE_STATE_REMOVED
};

enum collectionState {
                        COLLECTION_STATE_UNINITIALIZED = 1,
                        COLLECTION_STATE_INITIALIZED,
                        COLLECTION_STATE_RUNNING,
                        COLLECTION_STATE_STOPPING,
                        COLLECTION_STATE_STOPPED,
                        COLLECTION_STATE_REMOVING
};


//
// _HIDCLASS_DRIVER_EXTENSION contains per-minidriver extension information
// for the class driver.  It is created upon a HidRegisterMinidriver() call.
//

typedef struct _HIDCLASS_DRIVER_EXTENSION {

    //
    // Pointer to the minidriver's driver object.
    //

    PDRIVER_OBJECT      MinidriverObject;

    //
    // RegistryPath is a copy of the minidriver's RegistryPath that it
    // received as a DriverEntry() parameter.
    //

    UNICODE_STRING      RegistryPath;

    //
    // DeviceExtensionSize is the size of the minidriver's per-device
    // extension.
    //

    ULONG               DeviceExtensionSize;

    //
    // Dispatch routines for the minidriver.  These are the only dispatch
    // routines that the minidriver should ever care about, no others will
    // be forwarded.
    //

    PDRIVER_DISPATCH    MajorFunction[ IRP_MJ_MAXIMUM_FUNCTION + 1 ];

    /*
     *  These are the minidriver's original entrypoints,
     *  to which we chain.
     */
    PDRIVER_ADD_DEVICE  AddDevice;
    PDRIVER_UNLOAD      DriverUnload;

    //
    // Number of pointers to this structure that we've handed out
    //

    LONG                ReferenceCount;

    //
    // Linkage onto our global list of driver extensions
    //

    LIST_ENTRY          ListEntry;


    /*
     *  Either all or none of the devices driven by a given minidriver are polled.
     */
    BOOLEAN             DevicesArePolled;


#if DBG

    ULONG               Signature;

#endif

} HIDCLASS_DRIVER_EXTENSION;

#if DBG
#define HID_DRIVER_EXTENSION_SIG 'EdiH'
#endif



#define MIN_POLL_INTERVAL_MSEC      1
#define MAX_POLL_INTERVAL_MSEC      10000
#define DEFAULT_POLL_INTERVAL_MSEC  5


/*
 *  Device-specific flags
 */
        //  Nanao depends on a Win98G bug that allows GetFeature on input collection
#define DEVICE_FLAG_ALLOW_FEATURE_ON_NON_FEATURE_COLLECTION  (1 << 0)


//
// HIDCLASS_COLLECTION is where we keep our per-collection information.
//

typedef struct _HIDCLASS_COLLECTION {


    ULONG                       CollectionNumber;
    ULONG                       CollectionIndex;

    //
    // NumOpens is a count of open handles against this collection.
    //

    ULONG                       NumOpens;

    // Number of pending reads for all clients on this collection.
    ULONG                       numPendingReads;

    //
    // FileExtensionList is the head of a list of file extensions, i.e.
    // open instances against this collection.
    //

    LIST_ENTRY                  FileExtensionList;
    KSPIN_LOCK                  FileExtensionListSpinLock;

    /*
     *  For polled devices, we only read from the device
     *  once every poll interval.  We queue read IRPs
     *  here until the poll timer expiration.
     *
     *  Note:  for a polled device, we keep a separate background
     *         loop for each collection.  This way, queued-up read IRPs
     *         remain associated with the right collection.
     *         Also, this will keep the number of reads we do on each
     *         timer period roughly equal to the number of collections.
     */
    ULONG                       PollInterval_msec;
    KTIMER                      polledDeviceTimer;
    KDPC                        polledDeviceTimerDPC;
    LIST_ENTRY                  polledDeviceReadQueue;
    KSPIN_LOCK                  polledDeviceReadQueueSpinLock;

    /*
     *  We save old reports on polled devices for
     *  "opportunistic" readers who want to get a result right away.
     *  The polledDataIsStale flag indicates that the saved report
     *  is at least one poll interval old (so we should not use it).
     */
    PUCHAR                      savedPolledReportBuf;
    ULONG                       savedPolledReportLen;
    BOOLEAN                     polledDataIsStale;

    UNICODE_STRING              SymbolicLinkName;
    UNICODE_STRING              SymbolicLinkName_SystemControl;

    /*
     *  HID collection information descriptor for this collection.
     */
    HID_COLLECTION_INFORMATION  hidCollectionInfo;
    PHIDP_PREPARSED_DATA        phidDescriptor;

    /*
     *  This buffer is used to "cook" a raw report when it's been received.
     *  This is only used for non-polled (interrupt) devices.
     */
    PUCHAR                      cookedInterruptReportBuf;

    /*
     *  This is an IRP that we queue and complete
     *  when a read report contains a power event.
     *
     *  The powerEventIrp field retains an IRP
     *  so it needs a spinlock to synchronize cancellation.
     */
    PIRP                        powerEventIrp;
    KSPIN_LOCK                  powerEventSpinLock;

    ULONG                       secureReadMode;
    KSPIN_LOCK                  secureReadLock;

    #if DBG
        ULONG                   Signature;
    #endif

} HIDCLASS_COLLECTION;

#if DBG
#define HIDCLASS_COLLECTION_SIG 'EccH'
#endif

//
// For HID devices that have at least one interrupt-style collection, we
// try to keep a set of "ping-pong" report-read IRPs pending in the minidriver
// in the event we get a report.
//
// HIDCLASS_PINGPONG contains a pointer to an IRP as well as an event
// and status block.  Each device has a pointer to an array of these structures,
// the array size depending on the number of such IRPs we want to keep in
// motion.
//
// Right now the default number is 2.
//

#define MIN_PINGPONG_IRPS   2

//
// Flags to indicate whether read completed synchronously or asynchronously
//
#define PINGPONG_START_READ     0x01
#define PINGPONG_END_READ       0x02
#define PINGPONG_IMMEDIATE_READ 0x03

typedef struct _HIDCLASS_PINGPONG {

    #define PINGPONG_SIG (ULONG)'gnoP'
    ULONG           sig;

    //
    // Read interlock value to protect us from running out of stack space
    //
    ULONG               ReadInterlock;

    PIRP    irp;
    PUCHAR  reportBuffer;
    LONG    weAreCancelling;

    KEVENT sentEvent;       // When a read has been sent.
    KEVENT pumpDoneEvent;   // When the read loop is finally exitting.

    PFDO_EXTENSION   myFdoExt;

    /*
     *  Timeout context for back-off algorithm applied to broken devices.
     */
    KTIMER          backoffTimer;
    KDPC            backoffTimerDPC;
    LARGE_INTEGER   backoffTimerPeriod; // in negative 100-nsec units

} HIDCLASS_PINGPONG;

#if DBG
    #define HIDCLASS_REPORT_BUFFER_GUARD    'draG'
#endif

//
// All possible idle states.
//
#define IdleUninitialized       0x0
#define IdleDisabled            0x1
#define IdleWaiting             0x2
#define IdleIrpSent             0x3
#define IdleCallbackReceived    0x4
#define IdleComplete            0x5

/*
 *  Stores information about a Functional Device Object (FDO) which HIDCLASS attaches
 *  to the top of the Physical Device Object (PDO) that it get from the minidriver below.
 */
typedef struct _FDO_EXTENSION {

    //
    // Back pointer to the functional device object
    //
    PDEVICE_OBJECT          fdo;

    //
    // HidDriverExtension is a pointer to our driver extension for the
    // minidriver that gave us the PDO.
    //

    PHIDCLASS_DRIVER_EXTENSION driverExt;

    //
    // Hid descriptor that we get from the device.
    //

    HID_DESCRIPTOR          hidDescriptor;  // 9 bytes

    //
    // The attributes of this hid device.
    //

    HID_DEVICE_ATTRIBUTES   hidDeviceAttributes;  // 0x20 bytes

    //
    // Pointer to and length of the raw report descriptor.
    //

    PUCHAR                  rawReportDescription;
    ULONG                   rawReportDescriptionLength;

    //
    // This device has one or more collections.  We store the count and
    // pointer to an array of our HIDCLASS_COLLECTION structures (one per
    // collection) here.
    //

    PHIDCLASS_COLLECTION    classCollectionArray;

    /*
     *  This is initialized for us by HIDPARSE's HidP_GetCollectionDescription().
     *  It includes an array of HIDP_COLLECTION_DESC structs corresponding
     *  the classCollectionArray declared above.
     */
    HIDP_DEVICE_DESC        deviceDesc;     // 0x30 bytes
    BOOLEAN                 devDescInitialized;

    //
    // The maximum input size amongst ALL report types.
    //
    ULONG                   maxReportSize;

    //
    // For devices that have at least one interrupt collection, we keep
    // a couple of ping-pong IRPs and associated structures.
    // The ping-pong IRPs ferry data up from the USB hub.
    //
    ULONG                   numPingPongs;
    PHIDCLASS_PINGPONG      pingPongs;

    //
    // OpenCount represents the number of file objects aimed at this device
    //
    ULONG                   openCount;


    /*
     *  This is the number of IRPs still outstanding in the minidriver.
     */

    ULONG                   outstandingRequests;

    enum deviceState        prevState;
    enum deviceState        state;

    UNICODE_STRING          name;

    /*
     *  deviceRelations contains an array of client PDO pointers.
     *
     *  As the HID bus driver, HIDCLASS produces this data structure to report
     *  collection-PDOs to the system.
     */
    PDEVICE_RELATIONS       deviceRelations;

    /*
     *  This is an array of device extensions for the collection-PDOs of this
     *  device-FDO.
     */
    PHIDCLASS_DEVICE_EXTENSION   *collectionPdoExtensions;


    /*
     *  This includes a
     *  table mapping system power states to device power states.
     */
    DEVICE_CAPABILITIES deviceCapabilities;

    /*
     *  Track both current system and device power state
     */
    SYSTEM_POWER_STATE  systemPowerState;
    DEVICE_POWER_STATE  devicePowerState;

    /*
     *  Wait Wake Irp sent to parent PDO
     */
    PIRP        waitWakeIrp;
    KSPIN_LOCK  waitWakeSpinLock;
    BOOLEAN isWaitWakePending;

    /*
     * Queue of delayed requests due to the stack being in low power
     */
    KSPIN_LOCK collectionPowerDelayedIrpQueueSpinLock;
    LIST_ENTRY collectionPowerDelayedIrpQueue;
    ULONG numPendingPowerDelayedIrps;

    BOOLEAN isOutputOnlyDevice;

    //
    // Selective suspend idling context.
    //
    HID_SUBMIT_IDLE_NOTIFICATION_CALLBACK_INFO idleCallbackInfo;

    LONG        idleState;
    PULONG      idleTimeoutValue;
    KSPIN_LOCK  idleNotificationSpinLock;
    PIRP        idleNotificationRequest;
    BOOLEAN     idleCancelling;
    BOOLEAN     idleEnabledInRegistry;
    BOOLEAN     idleEnabled;
    KSPIN_LOCK  idleSpinLock;

    KEVENT idleDoneEvent;   // When the idle notification irp has been cancelled successfully.

    LONG numIdlePdos;

    /*
     *  This is a list of WaitWake IRPs sent to the collection-PDOs
     *  on this device, which we just save and complete when the
     *  base device's WaitWake IRP completes.
     */
    LIST_ENTRY  collectionWaitWakeIrpQueue;
    KSPIN_LOCK  collectionWaitWakeIrpQueueSpinLock;

    struct _FDO_EXTENSION       *nextFdoExt;

    /*
     *  Device-specific flags (DEVICE_FLAG_xxx).
     */
    ULONG deviceSpecificFlags;

        /*
         *  This is our storage space for the systemState IRP that we need to hold
         *  on to and complete in DevicePowerRequestCompletion.
         */
        PIRP currentSystemStateIrp;

    /*
     *  Unique number assigned to identify this HID bus.
     */
    ULONG BusNumber;

    //
    // WMI Information
    //
    WMILIB_CONTEXT WmiLibInfo;



    #if DBG
        WCHAR dbgDriverKeyName[64];
    #endif


} FDO_EXTENSION;


/*
 *  Stores information about a Physical Device Object (PDO) which HIDCLASS creates
 *  for each HID device-collection.
 */
typedef struct _PDO_EXTENSION {

    enum collectionState        prevState;
    enum collectionState        state;

    ULONG                       collectionNum;
    ULONG                       collectionIndex;

    //
    // A remove lock to keep track of outstanding I/Os to prevent the device
    // object from leaving before such time as all I/O has been completed.
    //
    IO_REMOVE_LOCK              removeLock;

    // represents a collection on the HID "bus"
    PDEVICE_OBJECT              pdo;
    PUNICODE_STRING             name;

    /*
     *  This is a back-pointer to the original FDO's extension.
     */
    PHIDCLASS_DEVICE_EXTENSION  deviceFdoExt;

    /*
     *  Track both current system and device power state
     */
    SYSTEM_POWER_STATE          systemPowerState;
    DEVICE_POWER_STATE          devicePowerState;
    BOOLEAN                     remoteWakeEnabled;
    KSPIN_LOCK                  remoteWakeSpinLock;
    PIRP                        remoteWakeIrp;
    PIRP                        waitWakeIrp;

    /*
     *  The status change function that was registered thru query interface
     *  NOTE: Can currently only register one.
     */
    PHID_STATUS_CHANGE          StatusChangeFn;
    PVOID                       StatusChangeContext;

    /*
     *  Access protection information.
     *  We count the number of opens for read and write on the collection.
     *  We also count the number of opens which RESTRICT future
     *  read/write opens on the collection.
     *
     *  Note that desired access is independent of restriction.
     *  A client may, for example, do an open-for-read-only but
     *  (by not setting the FILE_SHARE_WRITE bit)
     *  restrict other clients from doing an open-for-write.
     */
    ULONG                       openCount;
    ULONG                       opensForRead;
    ULONG                       opensForWrite;
    ULONG                       restrictionsForRead;
    ULONG                       restrictionsForWrite;
    ULONG                       restrictionsForAnyOpen;
    BOOLEAN                     MouseOrKeyboard;

    //
    // WMI Information
    //
    WMILIB_CONTEXT WmiLibInfo;

} PDO_EXTENSION;


/*
 *  This contains info about either a device FDO or a device-collection PDO.
 *  Some of the same functions process both, so we need one structure.
 */
typedef struct _HIDCLASS_DEVICE_EXTENSION {

    /*
     *  This is the public part of a HID FDO device extension, and
     *  must be the first entry in this structure.
     */
    HID_DEVICE_EXTENSION    hidExt;     // size== 0x0C.

    /*
     *  Determines whether this is a device extension for a device-FDO or a
     *  device-collection-PDO; this resolves the following union.
     */
    BOOLEAN                 isClientPdo;

    /*
     *  Include this signature for both debug and retail --
     *  kenray's debug extensions look for this.
     */
    #define             HID_DEVICE_EXTENSION_SIG 'EddH'
    ULONG               Signature;

    union {
        FDO_EXTENSION       fdoExt;
        PDO_EXTENSION       pdoExt;
    };


} HIDCLASS_DEVICE_EXTENSION;



//
// HIDCLASS_FILE_EXTENSION is private data we keep per file object.
//

typedef struct _HIDCLASS_FILE_EXTENSION {

    //
    // CollectionNumber is the ordinal of the collection in the device
    //

    ULONG                       CollectionNumber;


    PFDO_EXTENSION              fdoExt;

    //
    // PendingIrpList is a list of READ IRPs currently waiting to be satisfied.
    //

    LIST_ENTRY                  PendingIrpList;

    //
    // ReportList is a list of reports waiting to be read on this handle.
    //

    LIST_ENTRY                  ReportList;

    //
    // FileList provides a way to link all of a collection's
    // file extensions together.
    //

    LIST_ENTRY                  FileList;

    //
    // Both PendingIrpList and ReportList are protected by the same spinlock,
    // ListSpinLock.
    //
    KSPIN_LOCK                  ListSpinLock;

    //
    // MaximumInputReportAge is only applicable for polled collections.
    // It represents the maximum acceptable input report age for this handle.
    // There is a value in the HIDCLASS_COLLECTION,
    // CurrentMaximumInputReportAge, that represents the current minimum value
    // of all of the file extensions open against the collection.
    //

    LARGE_INTEGER               MaximumInputReportAge;

    //
    // CurrentInputReportQueueSize is the current size of the report input
    // queue.
    //

    ULONG                       CurrentInputReportQueueSize;

    /*
     *  This is the maximum number of reports that will be queued for the file extension.
     *  This starts at a default value and can be adjusted (within a fixed range) by an IOCTL.
     */
    ULONG                       MaximumInputReportQueueSize;
    #define MIN_INPUT_REPORT_QUEUE_SIZE MIN_PINGPONG_IRPS
    #define MAX_INPUT_REPORT_QUEUE_SIZE (MIN_INPUT_REPORT_QUEUE_SIZE*256)
    #define DEFAULT_INPUT_REPORT_QUEUE_SIZE (MIN_INPUT_REPORT_QUEUE_SIZE*16)

    //
    // Back pointer to the file object that this extension is for
    //

    PFILE_OBJECT                FileObject;


    /*
     *  File-attributes passed in irpSp->Parameters.Create.FileAttributes
     *  when this open was made.
     */
    USHORT                      FileAttributes;
    ACCESS_MASK                 accessMask;
    USHORT                      shareMask;

    //
    // Closing is set when this file object is closing and will be removed
    // shortly.  Don't queue any more reports or IRPs to this object
    // when this flag is set.
    //

    BOOLEAN                     Closing;

    //
    // Security has been checked.
    //

    BOOLEAN                     SecurityCheck;

    //
    // DWORD allignment
    //
    BOOLEAN                     Reserved [2];

    /*
     *  This flag indicates that this client does irregular, opportunistic
     *  reads on the device, which is a polled device.
     *  Instead of waiting for the background timer-driven read loop,
     *  this client should have his reads completed immediately.
     */
    BOOLEAN                     isOpportunisticPolledDeviceReader;
    ULONG                       nowCompletingIrpForOpportunisticReader;


    /*
     *  haveReadPrivilege TRUE indicates that the client has full
     *  permissions on the device, including read.
     */
    BOOLEAN                     haveReadPrivilege;

    //
    // Memphis Blue Screen info
    //
    BLUESCREEN                  BlueScreenData;

    BOOLEAN                     isSecureOpen;
    ULONG                       SecureReadMode;

        /*
         *  If a read fails, some clients reissue the read on the same thread.
         *  If this happens repeatedly, we can run out of stack space.
         *  So we keep track of the depth
         */
        #define INSIDE_READCOMPLETE_MAX 4
        ULONG                                           insideReadCompleteCount;

    #if DBG
        BOOLEAN                     ListSpinLockTaken;
        ULONG                       dbgNumReportsDroppedSinceLastRead;
        ULONG                       Signature;
    #endif

} HIDCLASS_FILE_EXTENSION;

#if DBG
        #define HIDCLASS_FILE_EXTENSION_SIG 'efcH'
#endif


typedef struct {

        #define ASYNC_COMPLETE_CONTEXT_SIG 'cnsA'
        ULONG sig;

        WORK_QUEUE_ITEM workItem;
        PIRP irp;
        PDEVICE_OBJECT devObj;
} ASYNC_COMPLETE_CONTEXT;


//
// HIDCLASS_REPORT is the structure we use to track a report returned from
// the minidriver.
//

typedef struct _HIDCLASS_REPORT {

    //
    // ListEntry queues this report onto a file extension.
    //

    LIST_ENTRY  ListEntry;

    ULONG reportLength;
    //
    // UnparsedReport is a data area for the unparsed report data as returned
    // from the minidriver.  The lengths of all input reports for a given
    // class are the same, so we don't need to store the length in each
    // report.
    //

    UCHAR       UnparsedReport[];

} HIDCLASS_REPORT;

typedef struct _HIDCLASS_WORK_ITEM_DATA {
    PIRP                Irp;
    PDO_EXTENSION       *PdoExt;
    PIO_WORKITEM        Item;
    BOOLEAN             RemoteWakeState;
} HIDCLASS_WORK_ITEM_DATA, *PHIDCLASS_WORK_ITEM_DATA;

//
// Internal shared function prototypes
//
NTSTATUS                    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS                    HidpAddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PhysicalDeviceObject);
VOID                        HidpDriverUnload(IN struct _DRIVER_OBJECT *minidriverObject);
NTSTATUS                    HidpCallDriver(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp);
NTSTATUS                    HidpCallDriverSynchronous(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp);
NTSTATUS                    HidpCopyInputReportToUser(IN PHIDCLASS_FILE_EXTENSION fdoExtension, IN PUCHAR ReportData, IN OUT PULONG UserBufferLen, OUT PUCHAR UserBuffer);
NTSTATUS                    HidpCreateSymbolicLink(IN PDO_EXTENSION *pdoExtension, IN ULONG collectionNum, IN BOOLEAN Create, IN PDEVICE_OBJECT Pdo);
NTSTATUS                    HidpCreateClientPDOs(PHIDCLASS_DEVICE_EXTENSION hidClassExtension);
ULONG                       HidpSetMaxReportSize(IN FDO_EXTENSION *fdoExtension);
VOID                        EnqueueInterruptReport(PHIDCLASS_FILE_EXTENSION fileExtension, PHIDCLASS_REPORT report);
PHIDCLASS_REPORT            DequeueInterruptReport(PHIDCLASS_FILE_EXTENSION fileExtension, LONG maxLen);
VOID                        HidpDestroyFileExtension(PHIDCLASS_COLLECTION collection, PHIDCLASS_FILE_EXTENSION FileExtension);
VOID                        HidpFlushReportQueue(IN PHIDCLASS_FILE_EXTENSION FileExtension);
NTSTATUS                    HidpGetCollectionDescriptor(IN FDO_EXTENSION *fdoExtension, IN ULONG collectionId, IN PVOID Buffer, IN OUT PULONG BufferSize);
NTSTATUS                    HidpGetCollectionInformation(IN FDO_EXTENSION *fdoExtension, IN ULONG collectionNumber, IN PVOID Buffer, IN OUT PULONG BufferSize);
NTSTATUS                    HidpGetDeviceDescriptor(FDO_EXTENSION *fdoExtension);
BOOLEAN                     HidpStartIdleTimeout(FDO_EXTENSION *fdoExt, BOOLEAN DeviceStart);
VOID                        HidpCancelIdleNotification(FDO_EXTENSION *fdoExt, BOOLEAN removing);
VOID                        HidpIdleTimeWorker(PDEVICE_OBJECT DeviceObject, PIO_WORKITEM Item);
VOID                        HidpIdleNotificationCallback(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension);
NTSTATUS                    HidpRegisterDeviceForIdleDetection(PDEVICE_OBJECT DeviceObject, ULONG IdleTime, PULONG *);
VOID                        HidpSetDeviceBusy(FDO_EXTENSION *fdoExt);
NTSTATUS                    HidpCheckIdleState(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,PIRP Irp);
NTSTATUS                    HidpGetRawDeviceDescriptor(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, OUT PULONG RawDeviceDescriptorLength, OUT PUCHAR *RawDeviceDescriptor);
NTSTATUS                    HidpInitializePingPongIrps(FDO_EXTENSION *fdoExtension);
NTSTATUS                    HidpReallocPingPongIrps(FDO_EXTENSION *fdoExtension, ULONG newNumBufs);
NTSTATUS                    HidpIrpMajorPnpComplete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS                    HidpMajorHandler(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS                    HidpParseAndBuildLinks(FDO_EXTENSION *fdoExtension);
NTSTATUS                    HidpFdoPowerCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
BOOLEAN                     EnqueueDriverExt(PHIDCLASS_DRIVER_EXTENSION driverExt);
PHIDCLASS_DRIVER_EXTENSION  RefDriverExt(IN PDRIVER_OBJECT MinidriverObject);
PHIDCLASS_DRIVER_EXTENSION  DerefDriverExt(IN PDRIVER_OBJECT MinidriverObject);
NTSTATUS                    HidpStartAllPingPongs(FDO_EXTENSION *fdoExtension);
ULONG                       HidiGetClassCollectionOrdinal(IN PHIDCLASS_COLLECTION ClassCollection);
PHIDP_COLLECTION_DESC       HidiGetHidCollectionByClassCollection(IN PHIDCLASS_COLLECTION ClassCollection);
PHIDP_REPORT_IDS            GetReportIdentifier(FDO_EXTENSION *fdoExtension, ULONG reportId);
PHIDP_COLLECTION_DESC       GetCollectionDesc(FDO_EXTENSION *fdoExtension, ULONG collectionId);
PHIDCLASS_COLLECTION        GetHidclassCollection(FDO_EXTENSION *fdoExtension, ULONG collectionId);
//NTSTATUS                    HidpGetSetFeature(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp, IN ULONG controlCode, OUT BOOLEAN *sentIrp);
NTSTATUS                    HidpGetSetReport(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp, IN ULONG controlCode, OUT BOOLEAN *sentIrp);
NTSTATUS                    HidpGetDeviceString(IN FDO_EXTENSION *fdoExt, IN OUT PIRP Irp, IN ULONG stringId, IN ULONG languageId);
NTSTATUS                    HidpGetPhysicalDescriptor(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorRead(IN PHIDCLASS_DEVICE_EXTENSION, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorCreate(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorWrite(IN PHIDCLASS_DEVICE_EXTENSION, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorPnp(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpPdoPnp(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpFdoPnp(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorPower(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorClose(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorDeviceControl(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorINTERNALDeviceControl(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorClose(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorDefault(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpInterruptReadComplete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS                    HidpQueryDeviceRelations(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpQueryCollectionCapabilities(PDO_EXTENSION *pdoExt, IN OUT PIRP Irp);
NTSTATUS                    HidpQueryIdForClientPdo(IN PHIDCLASS_DEVICE_EXTENSION hidClassExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpQueryInterface(IN PHIDCLASS_DEVICE_EXTENSION hidClassExtension, IN OUT PIRP Irp);
PVOID                       MemDup(POOL_TYPE PoolType, PVOID dataPtr, ULONG length);
BOOLEAN                     AllClientPDOsInitialized(FDO_EXTENSION *fdoExtension, BOOLEAN initialized);
BOOLEAN                     AnyClientPDOsInitialized(FDO_EXTENSION *fdoExtension, BOOLEAN initialized);
NTSTATUS                    ClientPdoCompletion(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, PIRP Irp);
BOOLEAN                     HidpDeleteDeviceObjects(FDO_EXTENSION *fdoExt);
VOID                        HidpCancelReadIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp);
VOID                        CancelAllPingPongIrps(FDO_EXTENSION *fdoExt);
VOID                        HidpCleanUpFdo(FDO_EXTENSION *fdoExt);
NTSTATUS                    HidpRemoveDevice(FDO_EXTENSION *fdoExt, IN PIRP Irp);
VOID                        HidpRemoveCollection(FDO_EXTENSION *fdoExt, PDO_EXTENSION *pdoExt, IN PIRP Irp);
VOID                        HidpDestroyCollection(FDO_EXTENSION *fdoExt, PHIDCLASS_COLLECTION Collection);
VOID                        CollectionPowerRequestCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction, IN POWER_STATE PowerState, IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus);
VOID                        DevicePowerRequestCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction, IN POWER_STATE PowerState, IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus);
NTSTATUS                    HidpQueryCapsCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS                    HidpQueryDeviceCapabilities(IN PDEVICE_OBJECT PdoDeviceObject, IN PDEVICE_CAPABILITIES DeviceCapabilities);
VOID                        DestroyPingPongs(FDO_EXTENSION *fdoExt);
VOID                        CheckReportPowerEvent(FDO_EXTENSION *fdoExt, PHIDCLASS_COLLECTION collection, PUCHAR report, ULONG reportLen);
BOOLEAN                     StartPollingLoop(FDO_EXTENSION *fdoExt, PHIDCLASS_COLLECTION hidCollection, BOOLEAN freshQueue);
VOID                        StopPollingLoop(PHIDCLASS_COLLECTION hidCollection, BOOLEAN flushQueue);
BOOLEAN                     ReadPolledDevice(PDO_EXTENSION *pdoExt, BOOLEAN isTimerDrivenRead);
VOID                        PolledReadCancelRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
VOID                        EnqueueFdoExt(FDO_EXTENSION *fdoExt);
VOID                        DequeueFdoExt(FDO_EXTENSION *fdoExt);
NTSTATUS                    AllocDeviceResources(FDO_EXTENSION *fdoExt);
VOID                        FreeDeviceResources(FDO_EXTENSION *fdoExt);
NTSTATUS                    AllocCollectionResources(FDO_EXTENSION *fdoExt, ULONG collectionNum);
VOID                        FreeCollectionResources(FDO_EXTENSION *fdoExt, ULONG collectionNum);
NTSTATUS                    InitializeCollection(FDO_EXTENSION *fdoExt, ULONG collectionIndex);
NTSTATUS                    HidpStartCollectionPDO(FDO_EXTENSION *fdoExt, PDO_EXTENSION *pdoExt, PIRP Irp);
NTSTATUS                    HidpStartDevice(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, PIRP Irp);
PWCHAR                      SubstituteBusNames(PWCHAR oldIDs, FDO_EXTENSION *fdoExt, PDO_EXTENSION *pdoExt);
PWSTR                       BuildCompatibleID(PHIDCLASS_DEVICE_EXTENSION hidClassExtension);
PUNICODE_STRING             MakeClientPDOName(PUNICODE_STRING fdoName, ULONG collectionId);
VOID                        HidpPingpongBackoffTimerDpc(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemArgument1, IN PVOID SystemArgument2);
BOOLEAN                     WStrCompareN(PWCHAR str1, PWCHAR str2, ULONG maxChars);
NTSTATUS                    SubmitWaitWakeIrp(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension);
BOOLEAN                     HidpIsWaitWakePending(FDO_EXTENSION *fdoExt, BOOLEAN setIfNotPending);
NTSTATUS                    HidpWaitWakeComplete(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction, IN POWER_STATE PowerState, IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus);
NTSTATUS                    HidpGetIndexedString(IN FDO_EXTENSION *fdoExt, IN OUT PIRP Irp, IN ULONG stringIndex, IN ULONG languageId);
VOID                        CompleteAllPendingReadsForCollection(PHIDCLASS_COLLECTION Collection);
VOID                        CompleteAllPendingReadsForFileExtension(PHIDCLASS_COLLECTION Collection, PHIDCLASS_FILE_EXTENSION fileExtension);
VOID                        CompleteAllPendingReadsForDevice(FDO_EXTENSION *fdoExt);
BOOLEAN                     MyPrivilegeCheck(PIRP Irp);
NTSTATUS                    QueuePowerEventIrp(PHIDCLASS_COLLECTION hidCollection, PIRP Irp);
VOID                        PowerEventCancelRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS                    HidpPolledReadComplete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS                    HidpPolledReadComplete_TimerDriven(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
VOID                        CollectionWaitWakeIrpCancelRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
VOID                        CompleteAllCollectionWaitWakeIrps(FDO_EXTENSION *fdoExt, NTSTATUS status);
VOID                        PowerDelayedCancelRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS                    EnqueuePowerDelayedIrp(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, PIRP Irp);
PIRP                        DequeuePowerDelayedIrp(FDO_EXTENSION *fdoExt);
ULONG                       DequeueAllPdoPowerDelayedIrps(PDO_EXTENSION *pdoExt, PLIST_ENTRY dequeue);
VOID                        ReadDeviceFlagsFromRegistry(FDO_EXTENSION *fdoExt, PDEVICE_OBJECT pdo);
LONG                        WStrNCmpI(PWCHAR s1, PWCHAR s2, ULONG n);
ULONG                       LAtoX(PWCHAR wHexString);
ULONG                       WStrNCpy(PWCHAR dest, PWCHAR src, ULONG n);
NTSTATUS                    OpenSubkey(OUT PHANDLE Handle, IN HANDLE BaseHandle, IN PUNICODE_STRING KeyName, IN ACCESS_MASK DesiredAccess);
void                        HidpNumberToString(PWCHAR String, USHORT Number, USHORT stringLen);
NTSTATUS                                        GetHIDRawReportDescriptor(FDO_EXTENSION *fdoExt, PIRP irp, ULONG descriptorLen);
VOID                                            WorkItemCallback_CompleteIrpAsynchronously(PVOID context);
NTSTATUS                    EnqueueInterruptReadIrp(PHIDCLASS_COLLECTION collection, PHIDCLASS_FILE_EXTENSION fileExtension, PIRP Irp);
PIRP                        DequeueInterruptReadIrp(PHIDCLASS_COLLECTION collection, PHIDCLASS_FILE_EXTENSION fileExtension);
NTSTATUS                    EnqueuePolledReadIrp(PHIDCLASS_COLLECTION collection, PIRP Irp);
PIRP                        DequeuePolledReadSystemIrp(PHIDCLASS_COLLECTION collection);
PIRP                        DequeuePolledReadIrp(PHIDCLASS_COLLECTION collection);
NTSTATUS                    HidpProcessInterruptReport(PHIDCLASS_COLLECTION collection, PHIDCLASS_FILE_EXTENSION FileExtension, PUCHAR Report, ULONG ReportLength, PIRP *irpToComplete);
VOID                        HidpFreePowerEventIrp(PHIDCLASS_COLLECTION Collection);
NTSTATUS                    HidpGetMsGenreDescriptor(IN FDO_EXTENSION *fdoExt, IN OUT PIRP Irp);
NTSTATUS                    DllUnload(VOID);
NTSTATUS                    DllInitialize (PUNICODE_STRING RegistryPath);
VOID                        HidpPowerUpPdos(IN PFDO_EXTENSION fdoExt);
NTSTATUS                    HidpDelayedPowerPoRequestComplete(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction, IN POWER_STATE PowerState, IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus);
NTSTATUS                    HidpIrpMajorSystemControl(PHIDCLASS_DEVICE_EXTENSION DeviceObject, PIRP Irp);
NTSTATUS                    HidpSetWmiDataItem(PDEVICE_OBJECT DeviceObject, PIRP Irp, ULONG GuidIndex, ULONG InstanceIndex, ULONG DataItemId, ULONG BufferSize, PUCHAR Buffer);
NTSTATUS                    HidpSetWmiDataBlock(PDEVICE_OBJECT DeviceObject, PIRP Irp, ULONG GuidIndex, ULONG InstanceIndex, ULONG BufferSize, PUCHAR Buffer);
NTSTATUS                    HidpQueryWmiDataBlock( PDEVICE_OBJECT DeviceObject, PIRP Irp, ULONG GuidIndex, ULONG InstanceIndex, ULONG InstanceCount, OUT PULONG InstanceLengthArray, ULONG BufferAvail, PUCHAR Buffer);
NTSTATUS                    HidpQueryWmiRegInfo( PDEVICE_OBJECT DeviceObject, ULONG *RegFlags, PUNICODE_STRING InstanceName, PUNICODE_STRING *RegistryPath, PUNICODE_STRING MofResourceName, PDEVICE_OBJECT  *Pdo);
BOOLEAN                     HidpCreateRemoteWakeIrp (PDO_EXTENSION *PdoExt);
void                        HidpCreateRemoteWakeIrpWorker (PDEVICE_OBJECT DeviceObject, PHIDCLASS_WORK_ITEM_DATA  ItemData);
NTSTATUS                    HidpToggleRemoteWake(PDO_EXTENSION *PdoExt, BOOLEAN RemoteWakeState);

#if DBG
    VOID InitFdoExtDebugInfo(PHIDCLASS_DEVICE_EXTENSION hidclassExt);
#endif


extern ULONG HidpNextHidNumber;
extern FDO_EXTENSION *allFdoExtensions;
extern KSPIN_LOCK allFdoExtensionsSpinLock;

PVOID
HidpGetSystemAddressForMdlSafe(PMDL MdlAddress);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\name.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: 

    name.c

Abstract

    Get-friendly-name handling routines

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"



/*
 ********************************************************************************
 *  HidpGetDeviceString
 ********************************************************************************
 *
 *  Note:  This function cannot be pageable because it is called
 *         from the IOCTL dispatch routine, which can get called
 *         at DISPATCH_LEVEL.
 *
 */
NTSTATUS HidpGetDeviceString(IN FDO_EXTENSION *fdoExt, 
                             IN OUT PIRP Irp, 
                             IN ULONG stringId,
                             IN ULONG languageId)
{
    BOOLEAN completeIrpHere = TRUE;
    NTSTATUS status;

    PIO_STACK_LOCATION          currentIrpSp, nextIrpSp;

    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);

    /*
     *  The Irp we got uses buffering type METHOD_OUT_DIRECT,
     *  which passes the buffer in the MDL.
     *  IOCTL_HID_GET_STRING uses buffering type METHOD_NEITHER, 
     *  which passes the buffer in Irp->UserBuffer.
     *  So we have to copy the pointer.
     */
    Irp->UserBuffer = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);

    if (Irp->UserBuffer){

        /*
         *  Prepare the next (lower) IRP stack location.
         *  This will be the minidriver's (e.g. HIDUSB's) "current" stack location.
         */
        nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL; 
        nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_GET_STRING;
        nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = 
            currentIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        // Type3InputBuffer has string/lang IDs
        nextIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = 
            ULongToPtr((ULONG)(stringId + (languageId << 16)));

        status = HidpCallDriver(fdoExt->fdo, Irp);

        /*
         *  Irp will be completed by lower driver
         */
        completeIrpHere = FALSE;
    } 
    else {
        status = STATUS_INVALID_USER_BUFFER;
    }

    if (completeIrpHere){
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGSUCCESS(status, FALSE)
    return status;
}


/*
 ********************************************************************************
 *  HidpGetIndexedString
 ********************************************************************************
 *
 *
 *
 */
NTSTATUS HidpGetIndexedString(  IN FDO_EXTENSION *fdoExt, 
                                IN OUT PIRP Irp,
                                IN ULONG stringIndex,
                                IN ULONG languageId)
{
    NTSTATUS status;
    PIO_STACK_LOCATION currentIrpSp, nextIrpSp;

    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);

    /*
     *  The Irp we got uses buffering type METHOD_OUT_DIRECT,
     *  which passes the buffer in the MDL.
     *  The Irp we're sending down uses the same buffering method,
     *  so just let the lower driver derive the system address
     *  from the MDL.
     */

    /*
     *  Prepare the next (lower) IRP stack location.
     *  This will be the minidriver's (e.g. HIDUSB's) "current" stack location.
     */
    nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL; 
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_GET_INDEXED_STRING;
    nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = currentIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    // Type3InputBuffer has string index/lang IDs
    nextIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = 
        ULongToPtr((ULONG)(stringIndex + (languageId << 16)));

    status = HidpCallDriver(fdoExt->fdo, Irp);

    DBGSUCCESS(status, FALSE)
    return status;
}


/*
 ********************************************************************************
 *  HidpGetMsGenreDescriptor
 ********************************************************************************
 *
 *
 *
 */
NTSTATUS HidpGetMsGenreDescriptor(
    IN FDO_EXTENSION *fdoExt, 
    IN OUT PIRP Irp)
{
    NTSTATUS status;
    PIO_STACK_LOCATION currentIrpSp, nextIrpSp;

    DBGOUT(("Received request for genre descriptor in hidclass"))
    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);

    /*
     *  The Irp we got uses buffering type METHOD_OUT_DIRECT,
     *  which passes the buffer in the MDL.
     *  The Irp we're sending down uses the same buffering method,
     *  so just let the lower driver derive the system address
     *  from the MDL.
     */

    /*
     *  Prepare the next (lower) IRP stack location.
     *  This will be the minidriver's (e.g. HIDUSB's) "current" stack location.
     */
    nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL; 
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_GET_MS_GENRE_DESCRIPTOR;
    nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = currentIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    status = HidpCallDriver(fdoExt->fdo, Irp);

    DBGSUCCESS(status, FALSE)
    return status;
}

/*
 ********************************************************************************
 *  HidpGetSetReport
 ********************************************************************************
 *
 *  There are not many differences between reading and writing a
 *  report at this level, whether it be an input, output or feature
 *  report, so we have one function do all six.
 *
 *  controlCode is one of:
 *      IOCTL_HID_GET_INPUT_REPORT, IOCTL_HID_SET_INPUT_REPORT
 *      IOCTL_HID_GET_OUTPUT_REPORT, IOCTL_HID_SET_OUTPUT_REPORT
 *      IOCTL_HID_GET_FEATURE, IOCTL_HID_SET_FEATURE
 *
 *  Note:  This function cannot be pageable because it is called
 *         from the IOCTL dispatch routine, which can get called
 *         at DISPATCH_LEVEL.
 *
 */
NTSTATUS HidpGetSetReport ( IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
                            IN OUT PIRP Irp,
                            IN ULONG controlCode,
                            OUT BOOLEAN *sentIrp)
{
    FDO_EXTENSION   *fdoExt;
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION          currentIrpSp, nextIrpSp;
    PFILE_OBJECT                fileObject;
    PHIDCLASS_FILE_EXTENSION    fileExtension;

    DBG_COMMON_ENTRY()

    ASSERT(HidDeviceExtension->isClientPdo);
    fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;
    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);

    *sentIrp = FALSE;

    /*
     *  Get the file extension.
     */
    ASSERT(currentIrpSp->FileObject);
    fileObject = currentIrpSp->FileObject;
    
    if(!fileObject->FsContext) {
        DBGWARN(("Attempted to get/set report with no file extension"))
        return STATUS_PRIVILEGE_NOT_HELD;
    }

    fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
    ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);

    /*
     *  Check security.
     */
    if (fileExtension->SecurityCheck){
        PHIDP_COLLECTION_DESC       collectionDesc;

        /*
         *  Get our collection  description.
         */
        collectionDesc = GetCollectionDesc(fdoExt, fileExtension->CollectionNumber);
        if (collectionDesc){
            
            PUCHAR reportBuf;
            ULONG reportBufLen;
            BOOLEAN featureRequest = FALSE;

            switch (controlCode){
            case IOCTL_HID_GET_INPUT_REPORT:
                // Make sure that there is an input report on this collection.
                if (collectionDesc->InputLength == 0) {
                    DBGWARN(("No input report on collection %x", 
                             fileExtension->CollectionNumber))
                    status = STATUS_INVALID_DEVICE_REQUEST;
                }
                break;
            
            case IOCTL_HID_SET_OUTPUT_REPORT:
                // Make sure that there is an output report on this collection.
                if (collectionDesc->OutputLength == 0){
                    DBGWARN(("No output report on collection %x", 
                             fileExtension->CollectionNumber))
                    status = STATUS_INVALID_DEVICE_REQUEST;
                }
                break;
            
            case IOCTL_HID_GET_FEATURE:
            case IOCTL_HID_SET_FEATURE:
                featureRequest = TRUE;
                // Make sure that there is a feature report on this collection.
                if ((collectionDesc->FeatureLength == 0) &&
                    !(fdoExt->deviceSpecificFlags & DEVICE_FLAG_ALLOW_FEATURE_ON_NON_FEATURE_COLLECTION)){
                    DBGWARN(("No feature report on collection %x", 
                             fileExtension->CollectionNumber))
                    status = STATUS_INVALID_DEVICE_REQUEST;
                }
                break;

            default:
                TRAP;
                status = STATUS_INVALID_DEVICE_REQUEST;
            }

            switch (controlCode){
            case IOCTL_HID_GET_INPUT_REPORT:
            case IOCTL_HID_GET_FEATURE:
                reportBufLen = currentIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                reportBuf = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);
                break;
            
            case IOCTL_HID_SET_OUTPUT_REPORT:
            case IOCTL_HID_SET_FEATURE:
                reportBuf = Irp->AssociatedIrp.SystemBuffer;
                reportBufLen = currentIrpSp->Parameters.DeviceIoControl.InputBufferLength;
                break;

            default:
                TRAP;
                status = STATUS_INVALID_PARAMETER;
                reportBuf = NULL;
                reportBufLen = 0;
            }
            
            if (reportBuf && reportBufLen && NT_SUCCESS(status)){
                PHIDP_REPORT_IDS reportIdent;
                UCHAR reportId;

                /*
                 *  The client includes the report id as the first byte of the report.
                 *  We send down the report byte only if the device has multiple
                 *  report IDs (i.e. the report id is not implicit).
                 */
                reportId = reportBuf[0];
                if (fdoExt->deviceDesc.ReportIDs[0].ReportID == 0){
                    DBGASSERT((reportId == 0),
                              ("Report Id should be zero, acutal id = %d", reportId),
                              FALSE)
                    reportBuf++;
                    reportBufLen--;
                }

                /*
                 *  Find a matching report identifier.
                 */
                reportIdent = GetReportIdentifier(fdoExt, reportId);

                /*
                 *  Check the buffer length against the
                 *  report length in the report identifier.
                 */
                if (reportIdent){
                    switch (controlCode){
                    case IOCTL_HID_GET_INPUT_REPORT:
                        /*
                         *  The buffer must be big enough for the report.
                         */
                        if (!reportIdent->InputLength ||
                            reportBufLen < reportIdent->InputLength){
                            ASSERT(!(PVOID)"report buf must be at least report size for get-report.");
                            reportIdent = NULL;
                        }
                        break;
                    case IOCTL_HID_GET_FEATURE:
                        /*
                         *  The buffer must be big enough for the report.
                         */
                        if (!reportIdent->FeatureLength ||
                            reportBufLen < reportIdent->FeatureLength){
                            ASSERT(!(PVOID)"report buf must be at least report size for get-report.");
                            reportIdent = NULL;
                        }
                        break;
                    case IOCTL_HID_SET_OUTPUT_REPORT:
                        /*
                         *  The buffer must be big enough for the report.
                         *  It CAN be larger, and it is up to us to use
                         *  the correct report size from the report identifier.
                         */
                        if (!reportIdent->OutputLength ||
                            reportBufLen < reportIdent->OutputLength){
                            ASSERT(!(PVOID)"report buf must be exact size for set-report.");
                            reportIdent = NULL;
                        } else {
                            reportBufLen = reportIdent->OutputLength;
                        }
                        break;
                    case IOCTL_HID_SET_FEATURE:
                        if (!reportIdent->FeatureLength ||
                            reportBufLen < reportIdent->FeatureLength){
                            ASSERT(!(PVOID)"report buf must be exact size for set-report.");
                            reportIdent = NULL;
                        } else {
                            reportBufLen = reportIdent->FeatureLength;
                        }
                        break;
                    default:
                        TRAP;
                    }
                }

                if (reportIdent || 
                    (featureRequest &&
                     (fdoExt->deviceSpecificFlags & 
                      DEVICE_FLAG_ALLOW_FEATURE_ON_NON_FEATURE_COLLECTION))){

                    PHID_XFER_PACKET reportPacket = ALLOCATEPOOL(NonPagedPool, sizeof(HID_XFER_PACKET));

                    if (reportPacket){

                        reportPacket->reportBuffer = reportBuf;
                        reportPacket->reportBufferLen = reportBufLen;
                        reportPacket->reportId = reportId;

                        Irp->UserBuffer = reportPacket;

                        /*
                         *  Prepare the next (lower) IRP stack location.
                         *  This will be HIDUSB's "current" stack location.
                         */
                        nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                        nextIrpSp->Parameters.DeviceIoControl.IoControlCode = controlCode;

                        /*
                         *  Note - input/output is relative to IOCTL servicer
                         */
                        switch (controlCode){
                        case IOCTL_HID_GET_INPUT_REPORT:
                        case IOCTL_HID_GET_FEATURE:
                            nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(HID_XFER_PACKET);
                            break;
                        case IOCTL_HID_SET_OUTPUT_REPORT:
                        case IOCTL_HID_SET_FEATURE:
                            nextIrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(HID_XFER_PACKET);
                            break;
                        default:
                            TRAP;
                        }

                        DBG_RECORD_REPORT(reportId, controlCode, FALSE)

                        status = HidpCallDriverSynchronous(fdoExt->fdo, Irp);
                        if (!NT_SUCCESS(status)){
                            DBGWARN(("HidpGetSetFeature: usb returned status %xh.", status))
                        }
                        DBG_RECORD_REPORT(reportId, controlCode, TRUE)
                        ExFreePool(reportPacket);
                        *sentIrp = FALSE; // needs to be completed again

                    } 
                    else {
                        ASSERT(reportPacket);
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                } 
                else {
                    DBGASSERT(reportIdent, ("Some yahoo sent invalid data in ioctl %x", controlCode), FALSE)
                    status = STATUS_DATA_ERROR;
                }
            } 
            else if (NT_SUCCESS(status)) {
                DBGASSERT(reportBuf, ("Feature buffer is invalid"), FALSE)
                DBGASSERT(reportBufLen, ("Feature buffer length is invalid"), FALSE)
                status = STATUS_INVALID_BUFFER_SIZE;
            }
        } 
        else {
            ASSERT(collectionDesc);
            status = STATUS_DEVICE_NOT_CONNECTED;
        }
    } 
    else {
        ASSERT(fileExtension->SecurityCheck);
        status = STATUS_PRIVILEGE_NOT_HELD;
    }

    DBGSUCCESS(status, FALSE)
    
    DBG_COMMON_EXIT()

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\idle.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    idle.c

Abstract

   
Author:

    Doron H.

Environment:

    Kernel mode only

Revision History:


--*/

#ifdef ALLOC_PRAGMA
#endif

#include "pch.h"

KSPIN_LOCK idleDeviceListSpinLock;
LIST_ENTRY idleDeviceList;
KTIMER idleTimer;
KDPC idleTimerDpc;
LONG numIdleDevices = 0;

#define HID_IDLE_SCAN_INTERVAL 1

typedef struct _HID_IDLE_DEVICE_INFO {
    LIST_ENTRY entry;
    ULONG idleCount;
    ULONG idleTime;
    PDEVICE_OBJECT device;
    BOOLEAN tryAgain;
} HID_IDLE_DEVICE_INFO, *PHID_IDLE_DEVICE_INFO;

VOID
HidpIdleTimerDpcProc(
                    IN PKDPC Dpc,
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PVOID Context1,
                    IN PVOID Context2
                    );

NTSTATUS
HidpRegisterDeviceForIdleDetection(
                                  PDEVICE_OBJECT DeviceObject,
                                  ULONG IdleTime,
                                  PULONG *IdleTimeout
                                  )
{
    PHID_IDLE_DEVICE_INFO info = NULL;
    KIRQL irql;
    PLIST_ENTRY entry = NULL;
    static BOOLEAN firstCall = TRUE;
    BOOLEAN freeInfo = FALSE;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    if (firstCall) {
        KeInitializeSpinLock(&idleDeviceListSpinLock);
        InitializeListHead(&idleDeviceList);
        KeInitializeTimerEx(&idleTimer, NotificationTimer);
        KeInitializeDpc(&idleTimerDpc, HidpIdleTimerDpcProc, NULL);
        firstCall = FALSE;
    }

    KeAcquireSpinLock(&idleDeviceListSpinLock, &irql);
    if (IdleTime == 0) {
        ASSERT(numIdleDevices >= 0);

        //
        // Remove the device from the list
        //
        for (entry = idleDeviceList.Flink;
            entry != &idleDeviceList;
            entry = entry->Flink) {

            info = CONTAINING_RECORD(entry, HID_IDLE_DEVICE_INFO, entry);
            if (info->device == DeviceObject) {
                DBGINFO(("Remove device idle on fdo 0x%x", DeviceObject));
                numIdleDevices--;
                ObDereferenceObject(DeviceObject);
                RemoveEntryList(entry);
                status = STATUS_SUCCESS;
                ExFreePool(info);
                *IdleTimeout = BAD_POINTER;
                break;
            }
        }

        if (NT_SUCCESS(status)) {
            //
            // If there are no more idle devices we can stop the timer
            //
            if (IsListEmpty(&idleDeviceList)) {
                ASSERT(numIdleDevices == 0);
                DBGINFO(("Idle detection list empty. Stopping timer."));
                KeCancelTimer(&idleTimer);
            }
        }
    } else {
        LARGE_INTEGER scanTime;
        BOOLEAN empty = FALSE;

        DBGINFO(("Register for device idle on fdo 0x%x", DeviceObject));
        
        //
        // Check if we've already started this.
        //
        status = STATUS_SUCCESS;
        for (entry = idleDeviceList.Flink;
            entry != &idleDeviceList;
            entry = entry->Flink) {

            info = CONTAINING_RECORD(entry, HID_IDLE_DEVICE_INFO, entry);
            if (info->device == DeviceObject) {
                DBGWARN(("Device already registered for idle detection. Ignoring."));
                ASSERT(*IdleTimeout == &(info->idleCount));
                status = STATUS_UNSUCCESSFUL;
            }
        }

        if (NT_SUCCESS(status)) {
            info = (PHID_IDLE_DEVICE_INFO)
            ALLOCATEPOOL(NonPagedPool, sizeof(HID_IDLE_DEVICE_INFO));

            if (info != NULL) {
                ObReferenceObject(DeviceObject);

                RtlZeroMemory(info, sizeof(HID_IDLE_DEVICE_INFO));
                info->device = DeviceObject;
                info->idleTime = IdleTime;

                if (IsListEmpty(&idleDeviceList)) {
                    empty = TRUE;
                }
                InsertTailList(&idleDeviceList, &info->entry);

                *IdleTimeout = &(info->idleCount);

                numIdleDevices++;

                if (empty) {
                    DBGINFO(("Starting idle detection timer for first time."));
                    //
                    // Turn on idle detection
                    //
                    scanTime = RtlConvertLongToLargeInteger(-10*1000*1000 * HID_IDLE_SCAN_INTERVAL);

                    KeSetTimerEx(&idleTimer,
                                 scanTime,
                                 HID_IDLE_SCAN_INTERVAL*1000,    // call wants milliseconds
                                 &idleTimerDpc);
                }
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }
    
    KeReleaseSpinLock(&idleDeviceListSpinLock, irql);

    return status; 
}

VOID
HidpIdleTimerDpcProc(
                    IN PKDPC Dpc,
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PVOID Context1,
                    IN PVOID Context2
                    )
{
    PLIST_ENTRY entry;
    PHID_IDLE_DEVICE_INFO info;
    ULONG oldCount;
    KIRQL irql1, irql2;
    BOOLEAN ok = FALSE;
    PFDO_EXTENSION fdoExt;
    LONG idleState;

    UNREFERENCED_PARAMETER(Context1);
    UNREFERENCED_PARAMETER(Context2);

    KeAcquireSpinLock(&idleDeviceListSpinLock, &irql1);

    entry = idleDeviceList.Flink;
    while (entry != &idleDeviceList) {
        info = CONTAINING_RECORD(entry, HID_IDLE_DEVICE_INFO, entry);
        fdoExt = &((PHIDCLASS_DEVICE_EXTENSION) info->device->DeviceExtension)->fdoExt;
        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql2);
        
        oldCount = InterlockedIncrement(&info->idleCount); 

        if (info->tryAgain || ((oldCount+1) == info->idleTime)) {
            PIO_WORKITEM item = IoAllocateWorkItem(info->device);
            
            if (item) {
                info->tryAgain = FALSE;
                
                SS_TRAP;
                KeResetEvent(&fdoExt->idleDoneEvent);
                
                ASSERT(fdoExt->idleState != IdleIrpSent);
                ASSERT(fdoExt->idleState != IdleCallbackReceived);
                ASSERT(fdoExt->idleState != IdleComplete);
                idleState = InterlockedCompareExchange(&fdoExt->idleState, 
                                                       IdleIrpSent,
                                                       IdleWaiting);
                if (fdoExt->idleState == IdleIrpSent) {
                    ok = TRUE;
                } else {
                    // We shouldn't get here if we're disabled.
                    ASSERT(idleState != IdleDisabled);
                    DBGWARN(("Resetting timer to zero for fdo %x in state %x",
                             info->device,fdoExt->idleState));
                    info->idleCount = 0;
                }
                
                if (ok) {
                    IoQueueWorkItem(item,
                                    HidpIdleTimeWorker,
                                    DelayedWorkQueue,
                                    item);
                } else {
                    IoFreeWorkItem(item);
                }
            } else {
                info->tryAgain = TRUE;
            }
        }
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql2);

        entry = entry->Flink;
    }

    KeReleaseSpinLock(&idleDeviceListSpinLock, irql1);
}

NTSTATUS
HidpIdleNotificationRequestComplete(
                                   PDEVICE_OBJECT DeviceObject,
                                   PIRP Irp,
                                   PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension
                                   )
{
    FDO_EXTENSION *fdoExt;
    PDO_EXTENSION *pdoExt;
    KIRQL irql;
    LONG prevIdleState = IdleWaiting;
    POWER_STATE powerState;
    NTSTATUS status = Irp->IoStatus.Status;
    ULONG count, i;
    PIRP delayedIrp;
    LIST_ENTRY dequeue, *entry;
    PIO_STACK_LOCATION stack;

    //
    // DeviceObject is NULL because we sent the irp
    //
    UNREFERENCED_PARAMETER(DeviceObject);

    fdoExt = &HidDeviceExtension->fdoExt;
    
    DBGVERBOSE(("Idle irp completed status 0x%x for fdo 0x%x",
                status, fdoExt->fdo)); 
    
    //
    // Cancel any outstanding WW irp we queued up for the exclusive purpose
    // of selective suspend.
    //
    KeAcquireSpinLock(&fdoExt->collectionWaitWakeIrpQueueSpinLock, &irql);
    if (IsListEmpty(&fdoExt->collectionWaitWakeIrpQueue) &&
        HidpIsWaitWakePending(fdoExt, FALSE)) {
        if (ISPTR(fdoExt->waitWakeIrp)) {
            DBGINFO(("Cancelling the WW irp that was queued for idle."))
            IoCancelIrp(fdoExt->waitWakeIrp);
        } else {
            TRAP;
        }
    }
    KeReleaseSpinLock(&fdoExt->collectionWaitWakeIrpQueueSpinLock, irql);
    
    switch (status) {
    case STATUS_SUCCESS:
        // we successfully idled the device we are either now back in D0, 
        // or will be very soon.
        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);
        if (fdoExt->devicePowerState == PowerDeviceD0) {
            prevIdleState = InterlockedCompareExchange(&fdoExt->idleState,
                                                       IdleWaiting,
                                                       IdleComplete);
            DBGASSERT(fdoExt->idleState == IdleWaiting,
                      ("IdleCompletion, prev state not IdleWaiting, actually %x",prevIdleState),
                      TRUE);
            if (ISPTR(fdoExt->idleTimeoutValue)) {
                InterlockedExchange(fdoExt->idleTimeoutValue, 0);
            }
        }
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);
        break;

    case STATUS_INVALID_DEVICE_REQUEST:
    case STATUS_NOT_SUPPORTED:
        // the bus below does not support idle timeouts, forget about it
        DBGINFO(("Bus does not support idle. Removing for fdo %x",
                 fdoExt->fdo));

        //
        // Call to cancel idle notification. 
        //
        ASSERT(fdoExt->idleState == IdleIrpSent);
        ASSERT(fdoExt->devicePowerState == PowerDeviceD0);
        fdoExt->idleState = IdleWaiting;
        HidpCancelIdleNotification(fdoExt, TRUE);
        KeSetEvent(&fdoExt->idleDoneEvent, 0, FALSE);

        break;

        // we cancelled the request
    case STATUS_CANCELLED:
        DBGINFO(("Idle Irp completed cancelled"));

        // transitioned into a power state where we could not idle out
    case STATUS_POWER_STATE_INVALID:

        // oops, there was already a request in the bus below us
    case STATUS_DEVICE_BUSY:

    default:
        //
        // We must reset ourselves.
        //
        
        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);
        
        DBGASSERT((fdoExt->idleState != IdleWaiting),
                  ("Idle completion, previous state was already waiting."),
                  FALSE);
        
        prevIdleState = fdoExt->idleState;
        
        if (prevIdleState == IdleIrpSent) {
            ASSERT(fdoExt->devicePowerState == PowerDeviceD0);
            fdoExt->idleCancelling = FALSE;
            if (ISPTR(fdoExt->idleTimeoutValue) &&
                prevIdleState != IdleComplete) {
                InterlockedExchange(fdoExt->idleTimeoutValue, 0);
            }
            InterlockedExchange(&fdoExt->idleState, IdleWaiting);
        }
        
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

        if (prevIdleState == IdleComplete) {
            //
            // We now have to power up the stack.
            //
            DBGINFO(("Fully idled. Must power up stack."))
            powerState.DeviceState = PowerDeviceD0;
            PoRequestPowerIrp(((PHIDCLASS_DEVICE_EXTENSION) fdoExt->fdo->DeviceExtension)->hidExt.PhysicalDeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              HidpDelayedPowerPoRequestComplete,
                              fdoExt,
                              NULL);
        } else if (prevIdleState == IdleIrpSent) {
            //
            // Dequeue any enqueued irps and send them on their way.
            // This is for the case where we didn't make it to suspend, but 
            // enqueued irps anyways. I.e. using mouse, set caps lock on 
            // ps/2 keybd causing write to be sent to usb kbd.
            //
            if (fdoExt->devicePowerState == PowerDeviceD0) {
                for (i = 0; i < fdoExt->deviceRelations->Count; i++) {
                    pdoExt = &((PHIDCLASS_DEVICE_EXTENSION) fdoExt->deviceRelations->Objects[i]->DeviceExtension)->pdoExt;
                    //
                    // Resend all power delayed IRPs
                    //
                    count = DequeueAllPdoPowerDelayedIrps(pdoExt, &dequeue);
                    DBGVERBOSE(("dequeued %d requests\n", count));

                    while (!IsListEmpty(&dequeue)) {
                        entry = RemoveHeadList(&dequeue);
                        delayedIrp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);
                        stack = IoGetCurrentIrpStackLocation(delayedIrp);

                        DBGINFO(("resending %x to pdo %x in idle completion.\n", delayedIrp, pdoExt->pdo));

                        pdoExt->pdo->DriverObject->
                            MajorFunction[stack->MajorFunction]
                                (pdoExt->pdo, delayedIrp);
                    }
                }
            }
            /*
             *  We cancelled this IRP.
             *  REGARDLESS of whether this IRP was actually completed by
             *  the cancel routine or not
             *  (i.e. regardless of the completion status)
             *  set this event so that stuff can exit.
             *  Don't touch the irp again.
             */
            DBGINFO(("Set done event."))
            KeSetEvent(&fdoExt->idleDoneEvent, 0, FALSE);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        
        break;
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
HidpIdleTimeWorker(
                  PDEVICE_OBJECT DeviceObject,
                  PIO_WORKITEM Item
                  )
{
    FDO_EXTENSION *fdoExt;
    PIO_STACK_LOCATION stack;
    PIRP irp = NULL, irpToCancel = NULL;
    NTSTATUS status;
    KIRQL irql;

    fdoExt = &((PHIDCLASS_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->fdoExt;

    DBGINFO(("fdo 0x%x can idle out", fdoExt->fdo));

    irp = fdoExt->idleNotificationRequest;
    ASSERT(ISPTR(irp));

    if (ISPTR(irp)) {
        USHORT  PacketSize;
        CCHAR   StackSize;
        UCHAR   AllocationFlags;

        // Did anyone forget to pull their cancel routine?
        ASSERT(irp->CancelRoutine == NULL) ;

        AllocationFlags = irp->AllocationFlags;
        StackSize = irp->StackCount;
        PacketSize =  IoSizeOfIrp(StackSize);
        IoInitializeIrp(irp, PacketSize, StackSize);
        irp->AllocationFlags = AllocationFlags;
        
        irp->Cancel = FALSE;
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        
        stack = IoGetNextIrpStackLocation(irp);
        stack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        stack->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_SEND_IDLE_NOTIFICATION_REQUEST;
        stack->Parameters.DeviceIoControl.InputBufferLength = sizeof(fdoExt->idleCallbackInfo);
        stack->Parameters.DeviceIoControl.Type3InputBuffer = (PVOID) &(fdoExt->idleCallbackInfo); 

        //
        // Hook a completion routine for when the device completes.
        //
        IoSetCompletionRoutine(irp,
                               HidpIdleNotificationRequestComplete,
                               DeviceObject->DeviceExtension,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // The hub will fail this request if the hub doesn't support selective
        // suspend.  By returning FALSE we remove ourselves from the 
        //
        status = HidpCallDriver(fdoExt->fdo, irp);
        
        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);

        if (status == STATUS_PENDING &&
            fdoExt->idleCancelling) {
            irpToCancel = irp;
        }

        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

        if (irpToCancel) {
            IoCancelIrp(irpToCancel);
        }

    }

    IoFreeWorkItem(Item);
}

BOOLEAN HidpStartIdleTimeout(
    FDO_EXTENSION   *fdoExt,
    BOOLEAN         DeviceStart
    )
{
    DEVICE_POWER_STATE deviceWakeableState = PowerDeviceUnspecified;
    USHORT deviceUsagePage, deviceUsage;
    USHORT usagePage, usage;
    ULONG iList, iDesc, iPdo;
    HANDLE hKey;
    NTSTATUS status;
    ULONG enabled;
    ULONG length;
    UNICODE_STRING s;
    KEY_VALUE_PARTIAL_INFORMATION partial;
    PHID_IDLE_DEVICE_INFO info;
    PLIST_ENTRY entry = NULL;
    PULONG idleTimeoutAddress;

    if (fdoExt->idleState != IdleDisabled) {
        //
        // We're already registered for idle detection.
        //
        return TRUE;
    }
    
    //
    // If we can't wake the machine, forget about it
    //
    if (fdoExt->deviceCapabilities.SystemWake == PowerSystemUnspecified) {
        DBGVERBOSE(("Can't wake the system with these caps! Disabling SS."));
        return FALSE;
    }

    //
    // If D1Latency, D2Latency, D3Latency are ever filled in, perhaps we should
    // let these values help us determine which low power state to go to
    //
    deviceWakeableState = fdoExt->deviceCapabilities.DeviceWake;
    DBGVERBOSE(("DeviceWakeableState is D%d", deviceWakeableState-1));

    if (deviceWakeableState == PowerDeviceUnspecified) {
        DBGVERBOSE(("Due to devcaps, can't idle wake from any state! Disabling SS."));
        return FALSE;  
    }

    if (DeviceStart) {
        //
        // Open the registry and make sure that the 
        // SelectiveSuspendEnabled value is set to 1.
        //
        
        // predispose to failure.
        fdoExt->idleEnabledInRegistry = FALSE;
        if (!NT_SUCCESS(IoOpenDeviceRegistryKey(fdoExt->collectionPdoExtensions[0]->hidExt.PhysicalDeviceObject,
                                                PLUGPLAY_REGKEY_DEVICE,
                                                STANDARD_RIGHTS_READ,
                                                &hKey))) {
            DBGVERBOSE(("Couldn't open device key to check for idle timeout value. Disabling SS."));
            return FALSE;
        }

        RtlInitUnicodeString(&s, HIDCLASS_SELECTIVE_SUSPEND_ON);
        status = ZwQueryValueKey(hKey, 
                                 &s, 
                                 KeyValuePartialInformation,
                                 &partial,
                                 sizeof(KEY_VALUE_PARTIAL_INFORMATION),
                                 &length);
        if (!NT_SUCCESS(status)) {
            DBGVERBOSE(("ZwQueryValueKey failed for fdo %x. Default to SS turned on if enabled.", fdoExt->fdo));
            fdoExt->idleEnabled = TRUE;
            
        } else if (!partial.Data[0]) {
            DBGINFO(("Selective suspend is not turned on for this device."));
            fdoExt->idleEnabled = FALSE;
        } else {
            fdoExt->idleEnabled = TRUE;
        }


        RtlInitUnicodeString(&s, HIDCLASS_SELECTIVE_SUSPEND_ENABLED);
        status = ZwQueryValueKey(hKey, 
                                 &s, 
                                 KeyValuePartialInformation,
                                 &partial,
                                 sizeof(KEY_VALUE_PARTIAL_INFORMATION),
                                 &length);

        ZwClose(hKey);

        if (!NT_SUCCESS(status)) {
            DBGVERBOSE(("ZwQueryValueKey failed for fdo %x. Disabling SS.", fdoExt->fdo));
            return FALSE;
        }

        DBGASSERT(partial.Type == REG_BINARY, ("Registry key wrong type"), FALSE);

        if (!partial.Data[0]) {
            DBGINFO(("Selective suspend is not enabled for this device in the hive. Disabling SS."));
            return FALSE;
        }
        fdoExt->idleEnabledInRegistry = TRUE;

        status = IoWMIRegistrationControl(fdoExt->fdo,
                                          WMIREG_ACTION_REGISTER);                                                       
        
        ASSERT(NT_SUCCESS(status));

    }

    if (!fdoExt->idleEnabledInRegistry || !fdoExt->idleEnabled) {
        return FALSE;
    }

    DBGVERBOSE(("There are %d PDOs on FDO 0x%x",
                fdoExt->deviceDesc.CollectionDescLength,
                fdoExt));

    ASSERT(ISPTR(fdoExt->deviceRelations));
      
    //
    // OK, we can selectively suspend this device. 
    // Allocate and initialize everything, then register.
    //
    fdoExt->idleNotificationRequest = IoAllocateIrp(fdoExt->fdo->StackSize, FALSE);
    if (fdoExt->idleNotificationRequest == NULL) {
        DBGWARN(("Failed to allocate idle notification irp"))
        return FALSE;
    }

    status = HidpRegisterDeviceForIdleDetection(fdoExt->fdo, 
                                                HID_DEFAULT_IDLE_TIME,
                                                &fdoExt->idleTimeoutValue);
    if (STATUS_SUCCESS == status) {
        //
        // We have successfully registered all device for idle detection,
        // send a WW irp down the FDO stack
        //
        fdoExt->idleState = IdleWaiting;
        return TRUE;
    } else {
        //
        // We're already registered? Or did the alloc fail?
        //
        DBGSUCCESS(status, TRUE);
        return FALSE;
    }
}

NTSTATUS
HidpCheckIdleState(
    PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    PIRP Irp
    )
{
    KIRQL irql;
    LONG idleState;
    PFDO_EXTENSION fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN cancelIdleIrp = FALSE;
    
    ASSERT(HidDeviceExtension->isClientPdo);
    KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);

    if (fdoExt->idleState == IdleWaiting ||
        fdoExt->idleState == IdleDisabled) {
        //
        // Done.
        //
        if (ISPTR(fdoExt->idleTimeoutValue) &&
            fdoExt->idleState == IdleWaiting) {
            InterlockedExchange(fdoExt->idleTimeoutValue, 0);
        }
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);
        return STATUS_SUCCESS;
    }

    DBGINFO(("CheckIdleState on fdo %x", fdoExt->fdo))

    status = EnqueuePowerDelayedIrp(HidDeviceExtension, Irp);
    
    if (STATUS_PENDING != status) {
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);
        return status;
    }
    
    fdoExt->idleCancelling = TRUE;

    idleState = fdoExt->idleState;
    
    switch (idleState) {
    case IdleWaiting:
        // bugbug.
        // How'd this happen? We already tried this...
        TRAP;
        break;
    case IdleIrpSent:
    case IdleCallbackReceived:
    case IdleComplete:
        cancelIdleIrp = TRUE;
        break;

    case IdleDisabled:
        //
        // Shouldn't get here.
        //
        DBGERR(("Already disabled."));
    }

    KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

    if (cancelIdleIrp) {
        IoCancelIrp(fdoExt->idleNotificationRequest);
    }

    return status;
}

VOID
HidpSetDeviceBusy(PFDO_EXTENSION fdoExt)
{
    KIRQL irql;
    BOOLEAN cancelIdleIrp = FALSE;
    LONG idleState;

    KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);

    if (fdoExt->idleState == IdleWaiting ||
        fdoExt->idleState == IdleDisabled ||
        fdoExt->idleCancelling) {
        if (ISPTR(fdoExt->idleTimeoutValue) &&
            fdoExt->idleState == IdleWaiting) {
            InterlockedExchange(fdoExt->idleTimeoutValue, 0);
            fdoExt->idleCancelling = FALSE;
        }
        //
        // Done.
        //
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);
        return;
    }

    fdoExt->idleCancelling = TRUE;

    DBGVERBOSE(("HidpSetDeviceBusy on fdo %x", fdoExt->fdo))
    
    idleState = fdoExt->idleState;
    
    switch (idleState) {
    case IdleWaiting:
        // bugbug.
        // How'd this happen? We already tried this...
        TRAP;
        break;
    case IdleIrpSent:
    case IdleCallbackReceived:
    case IdleComplete:
        cancelIdleIrp = TRUE;
        break;

    case IdleDisabled:
        //
        // Shouldn't get here.
        //
        DBGERR(("Already disabled."));
    }

    KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

    if (cancelIdleIrp) {
        IoCancelIrp(fdoExt->idleNotificationRequest);
    }
}

VOID
HidpCancelIdleNotification(
    PFDO_EXTENSION fdoExt,
    BOOLEAN removing            // Whether this is happening on a remove device
    )
{
    KIRQL irql;
    BOOLEAN cancelIdleIrp = FALSE;
    LONG idleState;
    NTSTATUS status;
    
    DBGVERBOSE(("Cancelling idle notification for fdo 0x%x", fdoExt->fdo));
    
    status = HidpRegisterDeviceForIdleDetection(fdoExt->fdo, 0, &fdoExt->idleTimeoutValue);
    
    KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);
    
    InterlockedCompareExchange(&fdoExt->idleState, 
                               IdleDisabled,
                               IdleWaiting);
    if (fdoExt->idleState == IdleDisabled) {
        DBGVERBOSE(("Was waiting or already disabled. Exitting."))
        //
        // Done.
        //
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);
        return;
    }

    fdoExt->idleCancelling = TRUE;
    
    idleState = fdoExt->idleState;

    DBGINFO(("Wait routine..."))
    switch (idleState) {
    case IdleWaiting:
        // How'd this happen? We already tried this...
        TRAP;
        break;
    case IdleIrpSent:
    case IdleCallbackReceived:
        // FUlly idled.
    case IdleComplete:
        cancelIdleIrp = TRUE;
        break;

    case IdleDisabled:
        //
        // Shouldn't get here.
        //
        TRAP;
    }

    KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);
    
    if (cancelIdleIrp) {
        
        // Don't need to check the return status of IoCancel, since we'll 
        // be waiting for the idleDoneEvent.
        IoCancelIrp(fdoExt->idleNotificationRequest);
    }
    
    if (removing) {
        DBGINFO(("Removing fdo %x. Must wait", fdoExt->fdo))
        /*
         *  Cancelling the IRP causes a lower driver to
         *  complete it (either in a cancel routine or when
         *  the driver checks Irp->Cancel just before queueing it).
         *  Wait for the IRP to actually get cancelled.
         */
        KeWaitForSingleObject(  &fdoExt->idleDoneEvent,
                                Executive,      // wait reason
                                KernelMode,
                                FALSE,          // not alertable
                                NULL );         // no timeout
    }
    
    DBGINFO(("Done cancelling idle notification on fdo %x", fdoExt->fdo))
    idleState = InterlockedExchange(&fdoExt->idleState, IdleDisabled);
    ASSERT(fdoExt->idleState == IdleDisabled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\pingpong.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: 

    pingpong.c

Abstract

    Interrupt style collections like to always have a read pending in case
    something happens.  This file contains routines to keep IRPs down
    in the miniport, and to complete client reads (if a client read IRP is
    pending) or queue them (if not).

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, HidpInitializePingPongIrps)
    #pragma alloc_text(PAGE, HidpReallocPingPongIrps)
#endif



/*
 ********************************************************************************
 *  HidpInitializePingPongIrps
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpInitializePingPongIrps(FDO_EXTENSION *fdoExtension)
{
    NTSTATUS result = STATUS_SUCCESS;
    ULONG i;
    CCHAR numIrpStackLocations;

    PAGED_CODE();

    /*
     *  Note that our functional device object normally requires FDO->StackSize stack
     *  locations; but these IRPs will only be sent to the minidriver, so we need one less.
     *
     *  THIS MEANS THAT WE SHOULD NEVER TOUCH OUR OWN STACK LOCATION (we don't have one!)
     */
    numIrpStackLocations = fdoExtension->fdo->StackSize - 1;


    //
    // Next determine the size of each input HID report.  There
    // must be at least one collection of type interrupt, or we wouldn't
    // need the ping-pong stuff at all and therefore wouldn't be here.
    //
    
    ASSERT(fdoExtension->maxReportSize > 0);
    ASSERT(fdoExtension->numPingPongs > 0);

    fdoExtension->pingPongs = ALLOCATEPOOL(NonPagedPool, fdoExtension->numPingPongs*sizeof(HIDCLASS_PINGPONG));
    if (fdoExtension->pingPongs){
        ULONG reportBufferSize = fdoExtension->maxReportSize;

        RtlZeroMemory(fdoExtension->pingPongs, fdoExtension->numPingPongs*sizeof(HIDCLASS_PINGPONG));

        #if DBG
            // reserve space for guard word
            reportBufferSize += sizeof(ULONG);
        #endif


        for (i = 0; i < fdoExtension->numPingPongs; i++){

            fdoExtension->pingPongs[i].myFdoExt = fdoExtension;
            fdoExtension->pingPongs[i].weAreCancelling = 0;
            fdoExtension->pingPongs[i].sig = PINGPONG_SIG;

            /*
             *  Initialize backoff timeout to 1 second (in neg 100-nsec units)
             */
            fdoExtension->pingPongs[i].backoffTimerPeriod.HighPart = -1;
            fdoExtension->pingPongs[i].backoffTimerPeriod.LowPart = -10000000;
            KeInitializeTimer(&fdoExtension->pingPongs[i].backoffTimer);
            KeInitializeDpc(&fdoExtension->pingPongs[i].backoffTimerDPC,
                            HidpPingpongBackoffTimerDpc,
                            &fdoExtension->pingPongs[i]);

            fdoExtension->pingPongs[i].reportBuffer = ALLOCATEPOOL(NonPagedPool, reportBufferSize);
            if (fdoExtension->pingPongs[i].reportBuffer){
                PIRP irp;

                #if DBG
                    #ifdef _X86_
                        // this sets off alignment problems on Alpha
                        // place guard word
                        *(PULONG)(&fdoExtension->pingPongs[i].reportBuffer[fdoExtension->maxReportSize]) = HIDCLASS_REPORT_BUFFER_GUARD;
                    #endif
                #endif

                irp = IoAllocateIrp(numIrpStackLocations, FALSE);
                if (irp){
                    /*
                     *  Point the ping-pong IRP's UserBuffer to the corresponding
                     *  ping-pong object's report buffer.
                     */
                    irp->UserBuffer = fdoExtension->pingPongs[i].reportBuffer;
                    fdoExtension->pingPongs[i].irp = irp;
                    KeInitializeEvent(&fdoExtension->pingPongs[i].sentEvent,
                                      NotificationEvent,
                                      TRUE);    // Set to signaled
                    KeInitializeEvent(&fdoExtension->pingPongs[i].pumpDoneEvent, 
                                      NotificationEvent, 
                                      TRUE);    // Set to signaled
                }
                else {
                    result = STATUS_INSUFFICIENT_RESOURCES;
                    break;        
                }
            }
            else {
                result = STATUS_INSUFFICIENT_RESOURCES;
                break;        
            }
        }
    }
    else {
        result = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGSUCCESS(result, TRUE)
    return result;
}


/*
 ********************************************************************************
 *  HidpReallocPingPongIrps
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpReallocPingPongIrps(FDO_EXTENSION *fdoExtension, ULONG newNumBufs)
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    if (fdoExtension->driverExt->DevicesArePolled){
        /*
         * Polled devices don't _HAVE_ ping-pong IRPs.
         */
        DBGERR(("Minidriver devices polled fdo %x.", fdoExtension))
        fdoExtension->numPingPongs = 0;
        fdoExtension->pingPongs = BAD_POINTER;
        status = STATUS_SUCCESS;
    }
    else if (newNumBufs < MIN_PINGPONG_IRPS){
        DBGERR(("newNumBufs < MIN_PINGPONG_IRPS!"))
        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    else {

        DestroyPingPongs(fdoExtension);

        if (HidpSetMaxReportSize(fdoExtension)){

            /*
             *  Initialize and restart the new ping-pong IRPs.
             *  If we can't allocate the desired number of buffers, 
             *  keep reducing until we get some.
             */
            do {
                fdoExtension->numPingPongs = newNumBufs;
                status = HidpInitializePingPongIrps(fdoExtension);
                newNumBufs /= 2;
            } while (!NT_SUCCESS(status) && (newNumBufs >= MIN_PINGPONG_IRPS));

            if (!NT_SUCCESS(status)) {
                /*
                 * The device will no longer function !!!
                 */
                TRAP;
                fdoExtension->numPingPongs = 0;
            }
        }
    }

    DBGSUCCESS(status, TRUE)
    return status;
}



/*
 ********************************************************************************
 *  HidpSubmitInterruptRead
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpSubmitInterruptRead(
    IN FDO_EXTENSION *fdoExt, 
    HIDCLASS_PINGPONG *pingPong, 
    BOOLEAN *irpSent)
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    KIRQL oldIrql;
    BOOLEAN proceed;
    LONG oldInterlock;
    PIRP irp = pingPong->irp;

    ASSERT(irp);

    *irpSent = FALSE;

    while (1) {
        if (NT_SUCCESS(status)) {
            HidpSetDeviceBusy(fdoExt);
            
            oldInterlock = InterlockedExchange(&pingPong->ReadInterlock,
                                               PINGPONG_START_READ);
            ASSERT(oldInterlock == PINGPONG_END_READ);

            irp->Cancel = FALSE;
            irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

            irpSp = IoGetNextIrpStackLocation(irp);
            irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_READ_REPORT;
            irpSp->Parameters.DeviceIoControl.OutputBufferLength = fdoExt->maxReportSize;

            /*
             *  Indicate interrupt collection (default).
             *  We use .InputBufferLength for this
             */
            irpSp->Parameters.DeviceIoControl.InputBufferLength = 0;

            ASSERT(irp->UserBuffer == pingPong->reportBuffer);
            #ifdef _X86_
                // this sets off alignment problems on Alpha
                ASSERT(*(PULONG)(&pingPong->reportBuffer[fdoExt->maxReportSize]) == HIDCLASS_REPORT_BUFFER_GUARD);
            #endif

            /*
             *  Set the completion, passing the FDO extension as context.
             */
            IoSetCompletionRoutine( irp,
                                    HidpInterruptReadComplete,
                                    (PVOID)fdoExt,
                                    TRUE,
                                    TRUE,
                                    TRUE );


            /*
             *  Send down the read IRP.
             */
            KeResetEvent(&pingPong->sentEvent);
            if (pingPong->weAreCancelling) {
                InterlockedDecrement(&pingPong->weAreCancelling);
                //
                // Ordering of the next two instructions is crucial, since
                // CancelPingPongs will exit after pumpDoneEvent is set, and the
                // pingPongs could be deleted after that.
                //
                DBGVERBOSE(("Pingpong %x cancelled in submit before sending\n", pingPong))
                KeSetEvent (&pingPong->sentEvent, 0, FALSE);
                KeSetEvent(&pingPong->pumpDoneEvent, 0, FALSE);
                status = STATUS_CANCELLED;
                break;
            } else {
                fdoExt->outstandingRequests++;
                DBGVERBOSE(("Sending pingpong %x from Submit\n", pingPong))
                status = HidpCallDriver(fdoExt->fdo, irp);
                KeSetEvent (&pingPong->sentEvent, 0, FALSE);
                *irpSent = TRUE;
            }

            if (PINGPONG_IMMEDIATE_READ != InterlockedExchange(&pingPong->ReadInterlock,
                                                               PINGPONG_END_READ)) {
                //
                // The read is asynch, will call SubmitInterruptRead from the
                // completion routine
                //
                DBGVERBOSE(("read is pending\n"))
                break;
            } else {
                //
                // The read was synchronous (probably bytes in the buffer).  The
                // completion routine will not call SubmitInterruptRead, so we 
                // just loop here.  This is to prevent us from running out of stack
                // space if always call StartRead from the completion routine
                //
                status = irp->IoStatus.Status;
                DBGVERBOSE(("read is looping with status %x\n", status))
            }
        } else {
            if (pingPong->weAreCancelling ){
                 
                // We are stopping the read pump.
                // set this event and stop resending the pingpong IRP.
                DBGVERBOSE(("We are cancelling bit set for pingpong %x\n", pingPong))
                InterlockedDecrement(&pingPong->weAreCancelling);
                KeSetEvent(&pingPong->pumpDoneEvent, 0, FALSE);
            } else {
                /*
                 *  The device returned error.
                 *  In order to support slightly-broken devices which
                 *  "hiccup" occasionally, we implement a back-off timer
                 *  algorithm; this way, the device gets a second chance,
                 *  but if it spits back error each time, this doesn't 
                 *  eat up all the available CPU.
                 */
                DBGVERBOSE(("Queuing backoff timer on pingpong %x\n", pingPong))
                ASSERT((LONG)pingPong->backoffTimerPeriod.HighPart == -1);
                ASSERT((LONG)pingPong->backoffTimerPeriod.LowPart < 0);
                KeSetTimer( &pingPong->backoffTimer,
                            pingPong->backoffTimerPeriod,
                            &pingPong->backoffTimerDPC);
            }
            break;
        }
    }

    DBGSUCCESS(status, FALSE)
    return status;
}



/*
 ********************************************************************************
 *  HidpProcessInterruptReport
 ********************************************************************************
 *
 *  Take the new interrupt read report and either:
 *      1.  If there is a pending read IRP, use it to satisfy that read IRP
 *          and complete the read IRP
 *
 *              or
 *
 *      2.  If there is no pending read IRP, 
 *          queue the report for a future read.
 *          
 */
NTSTATUS HidpProcessInterruptReport(    
    PHIDCLASS_COLLECTION collection,
    PHIDCLASS_FILE_EXTENSION FileExtension, 
    PUCHAR Report, 
    ULONG ReportLength,
    PIRP *irpToComplete
    )
{
    KIRQL oldIrql;
    NTSTATUS result;
    PIRP readIrpToSatisfy;
    BOOLEAN calledBlueScreenFunc = FALSE;


    LockFileExtension(FileExtension, &oldIrql);

    if (FileExtension->BlueScreenData.BluescreenFunction && 
            *(FileExtension->BlueScreenData.IsBluescreenTime) ) {

        (*FileExtension->BlueScreenData.BluescreenFunction)(
                                    FileExtension->BlueScreenData.Context, 
                                    Report
                                    );
        calledBlueScreenFunc = TRUE;

        readIrpToSatisfy = NULL;
        result = STATUS_SUCCESS;
    } 
    
    if (!calledBlueScreenFunc){
    
        /*
         *  Dequeue the next interrupt read.
         */
        readIrpToSatisfy = DequeueInterruptReadIrp(collection, FileExtension);

        if (readIrpToSatisfy){
            /*
             *  We have dequeued a pended read IRP
             *  which we will complete with this report.
             */
            ULONG userReportLength;
            PCHAR pDest;
            PIO_STACK_LOCATION irpSp;
            NTSTATUS status;

            ASSERT(IsListEmpty(&FileExtension->ReportList));

            irpSp = IoGetCurrentIrpStackLocation(readIrpToSatisfy);
            pDest = HidpGetSystemAddressForMdlSafe(readIrpToSatisfy->MdlAddress);
            if(pDest) {
                userReportLength = irpSp->Parameters.Read.Length;
    
                status = HidpCopyInputReportToUser( FileExtension,
                                                    Report,
                                                    &userReportLength,
                                                    pDest);
                DBGASSERT(NT_SUCCESS(status),
                          ("HidpCopyInputReportToUser returned status = %x", status),
                          TRUE)
    
                readIrpToSatisfy->IoStatus.Status = status;
                readIrpToSatisfy->IoStatus.Information = userReportLength;
    
                DBG_RECORD_READ(readIrpToSatisfy, userReportLength, (ULONG)Report[0], TRUE)
    
                result = status;
            } 
            else {
                result = STATUS_INVALID_USER_BUFFER;
            }
        } 
        else {
            /*
             *  We don't have any pending read IRPs.
             *  So queue this report for the next read.
             */

            PHIDCLASS_REPORT report;
            ULONG reportSize;

            reportSize = FIELD_OFFSET(HIDCLASS_REPORT, UnparsedReport) + ReportLength;
            report = ALLOCATEPOOL(NonPagedPool, reportSize);
            if (report){
                report->reportLength = ReportLength;
                RtlCopyMemory(report->UnparsedReport, Report, ReportLength);
                EnqueueInterruptReport(FileExtension, report);
                result = STATUS_PENDING;
            }
            else {
                result = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    UnlockFileExtension(FileExtension, oldIrql);

    /*
     *  This function is called with the fileExtensionsList spinlock held.
     *  So we can't complete the IRP here.  Pass it back to the caller and it'll
     *  be completed as soon as we drop all the spinlocks.
     */
    *irpToComplete = readIrpToSatisfy;

    DBGSUCCESS(result, TRUE)
    return result;
}


/*
 ********************************************************************************
 *  HidpDistributeInterruptReport
 ********************************************************************************
 *
 *
 */
VOID HidpDistributeInterruptReport(
    IN PHIDCLASS_COLLECTION hidclassCollection,
    PUCHAR Report,
    ULONG ReportLength
    )
{
    PLIST_ENTRY listEntry;
    KIRQL oldIrql;
    LIST_ENTRY irpsToComplete;
    ULONG secureReadMode;

    #if DBG
        ULONG numRecipients = 0;
        ULONG numPending = 0;
        ULONG numFailed = 0;
    #endif

    InitializeListHead(&irpsToComplete);

    KeAcquireSpinLock(&hidclassCollection->FileExtensionListSpinLock, &oldIrql);

    listEntry = &hidclassCollection->FileExtensionList;
    secureReadMode = hidclassCollection->secureReadMode;

    while ((listEntry = listEntry->Flink) != &hidclassCollection->FileExtensionList){
        PIRP irpToComplete;
        PHIDCLASS_FILE_EXTENSION fileExtension = CONTAINING_RECORD(listEntry, HIDCLASS_FILE_EXTENSION, FileList);

        NTSTATUS status;
        
        //
        //  This is to enforce security for devices such as a digitizer on a 
        //  tablet PC at the logon screen
        //
        if (secureReadMode && !fileExtension->isSecureOpen) {
            continue;
        }        

        #if DBG
            status = 
        #endif
        
        HidpProcessInterruptReport(hidclassCollection, fileExtension, Report, ReportLength, &irpToComplete);

        if (irpToComplete){
           InsertTailList(&irpsToComplete, &irpToComplete->Tail.Overlay.ListEntry);
        }

        #if DBG
            if (status == STATUS_SUCCESS){
            }
            else if (status == STATUS_PENDING){
                numPending++;
            }
            else {
                DBGSUCCESS(status, FALSE)
                numFailed++;
            }
            numRecipients++;
        #endif
    }

    DBG_LOG_REPORT(hidclassCollection->CollectionNumber, numRecipients, numPending, numFailed, Report, ReportLength)
    
    KeReleaseSpinLock(&hidclassCollection->FileExtensionListSpinLock, oldIrql);

    /*
     *  Now that we've dropped all the spinlocks, complete all the dequeued read IRPs.
     */
    while (!IsListEmpty(&irpsToComplete)){
        PIRP irp;
        PLIST_ENTRY listEntry = RemoveHeadList(&irpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        IoCompleteRequest(irp, IO_KEYBOARD_INCREMENT);
    }
}


/*
 ********************************************************************************
 *  GetPingPongFromIrp
 ********************************************************************************
 *
 *
 */
HIDCLASS_PINGPONG *GetPingPongFromIrp(FDO_EXTENSION *fdoExt, PIRP irp)
{
    HIDCLASS_PINGPONG *pingPong = NULL;
    ULONG i;

    for (i = 0; i < fdoExt->numPingPongs; i++){
        if (fdoExt->pingPongs[i].irp == irp){
            pingPong = &fdoExt->pingPongs[i];
            break;
        }
    }

    ASSERT(pingPong);
    return pingPong;
}


/*
 ********************************************************************************
 *  HidpInterruptReadComplete
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpInterruptReadComplete(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context
    )
{
    FDO_EXTENSION *fdoExt = (FDO_EXTENSION *)Context;
    HIDCLASS_PINGPONG *pingPong;
    KIRQL oldIrql;
    BOOLEAN startRead;

    DBG_COMMON_ENTRY()

    DBGLOG_INTSTART()

    //
    // Track the number of outstanding requests to this device.
    //
    ASSERT(fdoExt->outstandingRequests > 0 );
    fdoExt->outstandingRequests--;

    pingPong = GetPingPongFromIrp(fdoExt, Irp);
    
    if (!pingPong) {
        //
        // Something is terribly wrong, but do nothing. Hopefully 
        // just exiting will clear up this pimple.
        //
        DBGERR(("A pingPong structure could not be found!!! Have this looked at!"))
        goto InterruptReadCompleteExit;
    }

    //
    // If ReadInterlock is == START_READ, this func has been completed
    // synchronously.  Place IMMEDIATE_READ into the interlock to signify this
    // situation; this will notify StartRead to loop when IoCallDriver returns.
    // Otherwise, we have been completed async and it is safe to call StartRead()
    //
    startRead =
       (PINGPONG_START_READ !=
        InterlockedCompareExchange(&pingPong->ReadInterlock,
                                   PINGPONG_IMMEDIATE_READ,
                                   PINGPONG_START_READ));


    /*
     *  Take appropriate action based on the completion code of this pingpong irp.
     */ 
    if (Irp->IoStatus.Status == STATUS_SUCCESS){
    
        /*
         *  We've read one or more input reports.
         *  They are sitting consecutively in Irp->UserBuffer.  
         */
        PUCHAR reportStart = Irp->UserBuffer;
        LONG bytesRemaining = (LONG)Irp->IoStatus.Information;

        DBGASSERT(bytesRemaining > 0, ("BAD HARDWARE. Device returned zero bytes. If this happens repeatedly, remove device."), FALSE);
    
        /*
         *  Deliver each report separately.
         */
        while (bytesRemaining > 0){
            UCHAR reportId;
            PHIDP_REPORT_IDS reportIdentifier;

            /*
             *  If the first report ID is 0, then there is only one report id
             *  and it is known implicitly by the device, so it is not included
             *  in the reports sent to or from the device.
             *  Otherwise, there are multiple report ids and the report id is the
             *  first byte of the report.
             */
            if (fdoExt->deviceDesc.ReportIDs[0].ReportID == 0){
                /*
                 *  This device has only a single input report ID, so call it report id 0;
                 */
                reportId = 0;
            } 
            else {
                /*
                 *  This device has multiple input report IDs, so each report
                 *  begins with a UCHAR report ID.
                 */
                reportId = *reportStart;
                DBGASSERT(reportId, 
                          ("Bad Hardware. Not returning a report id although it has multiple ids."),
                          FALSE) // Bad hardware, bug 354829.
                reportStart += sizeof(UCHAR);
                bytesRemaining--;  
            }


            /*
             *  Extract the report identifier with the given id from the HID device extension.
             */
            reportIdentifier = GetReportIdentifier(fdoExt, reportId);

            if (reportIdentifier){
                LONG reportDataLen =    (reportId ? 
                                         reportIdentifier->InputLength-1 :
                                         reportIdentifier->InputLength);

                if ((reportDataLen > 0) && (reportDataLen <= bytesRemaining)){

                    PHIDCLASS_COLLECTION    collection;
                    PHIDP_COLLECTION_DESC   hidCollectionDesc;

                    /*
                     *  This report represents the state of some collection on the device.
                     *  Find that collection.
                     */
                    collection = GetHidclassCollection( fdoExt, 
                                                        reportIdentifier->CollectionNumber); 
                    hidCollectionDesc = GetCollectionDesc(  fdoExt, 
                                                            reportIdentifier->CollectionNumber);
                    if (collection && hidCollectionDesc){
                        PDO_EXTENSION *pdoExt;

                        /*
                         *  The collection's inputLength is the size of the
                         *  largest report (including report id); so it should
                         *  be at least as big as this one.
                         */
                        ASSERT(hidCollectionDesc->InputLength >= reportDataLen+1);

                        /*
                         *  Make sure that the PDO for this collection has gotten
                         *  START_DEVICE before returning anything for it.
                         *  (collection-PDOs can get REMOVE_DEVICE/START_DEVICE intermittently).
                         */
                        pdoExt = &fdoExt->collectionPdoExtensions[collection->CollectionIndex]->pdoExt;
                        ASSERT(ISPTR(pdoExt));
                        if (pdoExt->state == COLLECTION_STATE_RUNNING){
                            /*
                             *  "Cook" the report
                             *  (if it doesn't already have a report id byte, add one).
                             */
                            ASSERT(ISPTR(collection->cookedInterruptReportBuf));
                            collection->cookedInterruptReportBuf[0] = reportId;
                            RtlCopyMemory(  collection->cookedInterruptReportBuf+1,
                                            reportStart,
                                            reportDataLen);

                            /*
                             *  If this report contains a power-button event, alert this system.
                             */
                            CheckReportPowerEvent(  fdoExt, 
                                                    collection,
                                                    collection->cookedInterruptReportBuf,
                                                    hidCollectionDesc->InputLength); 

                            /*
                             *  Distribute the report to all of the open file objects on this collection.
                             */ 
                            HidpDistributeInterruptReport(collection,
                                                          collection->cookedInterruptReportBuf,
                                                          hidCollectionDesc->InputLength);
                        }
                        else {
                            DBGVERBOSE(("Report dropped because collection-PDO not started (pdoExt->state = %d).", pdoExt->state))
                        }
                    }
                    else {
                        // PDO hasn't been initialized yet.  Throw away data.
                        DBGVERBOSE(("Report dropped because collection-PDO not initialized."))

//                        TRAP;
                        break;
                    }
                }
                else {
                    DBGASSERT(reportDataLen > 0, ("Device returning report id with zero-length input report as part of input data."), FALSE)
                    if (reportDataLen > bytesRemaining) {
                        DBGVERBOSE(("Device has corrupt input report"));
                    }
                    break;
                }

                /*
                 *  Move to the next report in the buffer.
                 */ 
                bytesRemaining -= reportDataLen;
                reportStart += reportDataLen;
            } 
            else {
                // 
                // We have thrown away data because we couldn't find a report 
                // identifier corresponding to this data that we've been
                // returned. Bad hardware, bug 354829.
                //
                break;
            }
        }

        /*
         *  The read succeeded.  
         *  Reset the backoff timer stuff (for when reads fail)
         *  and re-submit this ping-pong IRP.
         */
        pingPong->backoffTimerPeriod.HighPart = -1;
        pingPong->backoffTimerPeriod.LowPart = -10000000;
    }

    //
    // Business as usual.
    //
    if (startRead) {
        if (pingPong->weAreCancelling ){
            
            // We are stopping the read pump.
            // Set this event and stop resending the pingpong IRP.
            DBGVERBOSE(("We are cancelling bit set for pingpong %x\n", pingPong))
            InterlockedDecrement(&pingPong->weAreCancelling);
            KeSetEvent(&pingPong->pumpDoneEvent, 0, FALSE);
        } else {
            if (Irp->IoStatus.Status == STATUS_SUCCESS){
                BOOLEAN irpSent;
                DBGVERBOSE(("Submitting pingpong %x from completion routine\n", pingPong))
                HidpSubmitInterruptRead(fdoExt, pingPong, &irpSent);
            } else {
                /*
                 *  The device returned error.
                 *  In order to support slightly-broken devices which
                 *  "hiccup" occasionally, we implement a back-off timer
                 *  algorithm; this way, the device gets a second chance,
                 *  but if it spits back error each time, this doesn't 
                 *  eat up all the available CPU.
                 */
                #if DBG
                    if (dbgTrapOnHiccup){
                        DBGERR(("Device 'hiccuped' (status=%xh); setting backoff timer (fdoExt=%ph)...", Irp->IoStatus.Status, fdoExt))
                    }
                #endif
                DBGVERBOSE(("Device returned error %x on pingpong %x\n", Irp->IoStatus.Status, pingPong))
                ASSERT((LONG)pingPong->backoffTimerPeriod.HighPart == -1);
                ASSERT((LONG)pingPong->backoffTimerPeriod.LowPart < 0);
                KeSetTimer( &pingPong->backoffTimer,
                            pingPong->backoffTimerPeriod,
                            &pingPong->backoffTimerDPC);
            }
        }
    }

InterruptReadCompleteExit:
    DBGLOG_INTEND()
    DBG_COMMON_EXIT()

    /*
    *  ALWAYS return STATUS_MORE_PROCESSING_REQUIRED; 
    *  otherwise, the irp is required to have a thread.
    */
    return STATUS_MORE_PROCESSING_REQUIRED;
}



/*
 ********************************************************************************
 *  HidpStartAllPingPongs
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpStartAllPingPongs(FDO_EXTENSION *fdoExt)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG i;

    ASSERT(fdoExt->numPingPongs > 0);

    for (i = 0; i < fdoExt->numPingPongs; i++){
        BOOLEAN irpSent;

        // Different threads may be trying to start this pump at the 
        // same time due to idle notification. Must only start once.
        if (fdoExt->pingPongs[i].pumpDoneEvent.Header.SignalState) {
            fdoExt->pingPongs[i].ReadInterlock = PINGPONG_END_READ;
            KeResetEvent(&fdoExt->pingPongs[i].pumpDoneEvent);
            DBGVERBOSE(("Starting pingpong %x from HidpStartAllPingPongs\n", &fdoExt->pingPongs[i]))
            status = HidpSubmitInterruptRead(fdoExt, &fdoExt->pingPongs[i], &irpSent);
            if (!NT_SUCCESS(status)){
                if (irpSent){
                    DBGWARN(("Initial read failed with status %xh.", status))
                    #if DBG
                        if (dbgTrapOnHiccup){
                            DBGERR(("Device 'hiccuped' ?? (fdoExt=%ph).", fdoExt))
                        }
                    #endif

                    /*
                     *  We'll let the back-off logic in the completion
                     *  routine deal with this.
                     */
                    status = STATUS_SUCCESS;
                }
                else {
                    DBGERR(("Initial read failed, irp not sent, status = %xh.", status))
                    break;
                }
            }
        }
    }

    if (status == STATUS_PENDING){
        status = STATUS_SUCCESS;
    }

    DBGSUCCESS(status, TRUE)
    return status;
}


/*
 ********************************************************************************
 *  CancelAllPingPongIrps
 ********************************************************************************
 *
 *
 */
VOID CancelAllPingPongIrps(FDO_EXTENSION *fdoExt)
{
    ULONG i;

    for (i = 0; i < fdoExt->numPingPongs; i++){
        HIDCLASS_PINGPONG *pingPong = &fdoExt->pingPongs[i]; 

        DBGVERBOSE(("Cancelling pingpong %x\n", pingPong))
        ASSERT(pingPong->sig == PINGPONG_SIG);
        ASSERT(!pingPong->weAreCancelling);

        //
        // The order of the following instructions is crucial. We must set
        // the weAreCancelling bit before waiting on the sentEvent, and the 
        // last thing that we should wait on is the pumpDoneEvent, which 
        // indicates that the read loop has finished all reads and will never 
        // run again.
        //
        // Note that we don't need spinlocks to guard since we only have two
        // threads touching pingpong structures; the read pump thread and the 
        // pnp thread. PNP irps are synchronous, so those are safe. Using the 
        // weAreCancelling bit and the two events, sentEvent and pumpDoneEvent,
        // the pnp irps are synchronized with the pnp routines. This insures
        // that this cancel routine doesn't exit until the read pump has
        // signalled the pumpDoneEvent and exited, hence the pingpong 
        // structures aren't ripped out from underneath it.
        // 
        // If we have a backoff timer queued, it will eventually fire and 
        // call the submitinterruptread routine to restart reads. This will 
        // exit eventually, because we have set the weAreCancelling bit.
        //
        InterlockedIncrement(&pingPong->weAreCancelling);
        
        {
        /*
         *  Synchronize with the irp's completion routine.
         */
        #if DBG
            UCHAR beforeIrql = KeGetCurrentIrql();
            UCHAR afterIrql;
            PVOID cancelRoutine = (PVOID)pingPong->irp->CancelRoutine;
        #endif

        KeWaitForSingleObject(&pingPong->sentEvent,
                              Executive,      // wait reason
                              KernelMode,
                              FALSE,          // not alertable
                              NULL );         // no timeout
        DBGVERBOSE(("Pingpong sent event set for pingpong %x\n", pingPong))
        IoCancelIrp(pingPong->irp);
        
        #if DBG
            afterIrql = KeGetCurrentIrql();
            if (afterIrql != beforeIrql){
                DBGERR(("CancelAllPingPongIrps: cancel routine at %ph changed irql from %d to %d.", cancelRoutine, beforeIrql, afterIrql))
            }
        #endif
        }

        /*
         *  Cancelling the IRP causes a lower driver to
         *  complete it (either in a cancel routine or when
         *  the driver checks Irp->Cancel just before queueing it).
         *  Wait for the IRP to actually get cancelled.
         */
        KeWaitForSingleObject(  &pingPong->pumpDoneEvent,
                                Executive,      // wait reason
                                KernelMode,
                                FALSE,          // not alertable
                                NULL );         // no timeout
        DBGVERBOSE(("Pingpong pump done event set for %x\n", pingPong))
    }
}


/*
 ********************************************************************************
 *  DestroyPingPongs
 ********************************************************************************
 *
 *
 */
VOID DestroyPingPongs(FDO_EXTENSION *fdoExt)
{
    if (ISPTR(fdoExt->pingPongs)){
        ULONG i;

        CancelAllPingPongIrps(fdoExt);

        for (i = 0; i < fdoExt->numPingPongs; i++){
            IoFreeIrp(fdoExt->pingPongs[i].irp);
            ExFreePool(fdoExt->pingPongs[i].reportBuffer);
            #if DBG
                fdoExt->pingPongs[i].sig = 0xDEADBEEF;
            #endif
        }

        ExFreePool(fdoExt->pingPongs);
        fdoExt->pingPongs = BAD_POINTER;
    }
}


/*
 ********************************************************************************
 *  HidpPingpongBackoffTimerDpc
 ********************************************************************************
 *
 *
 *
 */
VOID HidpPingpongBackoffTimerDpc(    
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    HIDCLASS_PINGPONG *pingPong = (HIDCLASS_PINGPONG *)DeferredContext;
    BOOLEAN irpSent;
    
    ASSERT(pingPong->sig == PINGPONG_SIG);

    /*
     *  Increase the back-off time by 1 second, up to a max of 5 secs
     *  (in negative 100-nanosecond units).
     */
    ASSERT((LONG)pingPong->backoffTimerPeriod.HighPart == -1);
    ASSERT((LONG)pingPong->backoffTimerPeriod.LowPart < 0);

    if ((LONG)pingPong->backoffTimerPeriod.LowPart > -50000000){ 
        (LONG)pingPong->backoffTimerPeriod.LowPart -= 10000000;  
    }

    DBGVERBOSE(("Submitting Pingpong %x from backoff\n", pingPong))
    //
    // If we are being removed, or the CancelAllPingPongIrps has been called,
    // this call will take care of things.
    //
    HidpSubmitInterruptRead(pingPong->myFdoExt, pingPong, &irpSent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\power.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    power.c

Abstract

    Power handling

Author:

    ervinp

Environment:

    Kernel mode only

Revision History:


--*/


#include "pch.h"


BOOLEAN HidpIsWaitWakePending(FDO_EXTENSION *fdoExt, BOOLEAN setIfNotPending)
{
    KIRQL irql;
    BOOLEAN isWaitWakePending;

    KeAcquireSpinLock(&fdoExt->waitWakeSpinLock, &irql);
    isWaitWakePending = fdoExt->isWaitWakePending;
    if (fdoExt->isWaitWakePending == FALSE) {
        if (setIfNotPending) {
            fdoExt->isWaitWakePending = TRUE;
        }
    }
    KeReleaseSpinLock(&fdoExt->waitWakeSpinLock, irql);

    return isWaitWakePending;
}

VOID
HidpPowerDownFdo(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension)
        {
    POWER_STATE powerState;
    FDO_EXTENSION *fdoExt;

    DBGVERBOSE(("powering down fdo 0x%x\n", HidDeviceExtension));

    fdoExt = &HidDeviceExtension->fdoExt;

    powerState.DeviceState = fdoExt->deviceCapabilities.DeviceWake;

    PoRequestPowerIrp(HidDeviceExtension->hidExt.PhysicalDeviceObject,
                      IRP_MN_SET_POWER,
                      powerState,
                      NULL,    // completion routine
                      NULL,    // completion routine context
                      NULL);
}

VOID HidpPowerUpPdos(IN PFDO_EXTENSION fdoExt)
{
    PDEVICE_OBJECT pdo;
    PDO_EXTENSION *pdoExt;
    POWER_STATE powerState;
    ULONG iPdo;

    iPdo = 0;

    powerState.DeviceState = PowerDeviceD0;

    for (iPdo = 0; iPdo < fdoExt->deviceRelations->Count; iPdo++) {
        pdoExt = &fdoExt->collectionPdoExtensions[iPdo]->pdoExt;
        pdo = pdoExt->pdo;

        DBGVERBOSE(("power up pdos, requesting D0 on pdo #%d %x\n", iPdo, pdo));

        //
        // We could check // pdoExt->devicePowerState != PowerDeviceD0
        // but, if the stack gets 2 D0 irps in a row, nothing bad should happen
        //
        PoRequestPowerIrp(pdo,
                          IRP_MN_SET_POWER,
                          powerState,
                          NULL,        // completion routine
                          NULL,        // context
                          NULL);
    }
    HidpSetDeviceBusy(fdoExt);
    KeSetEvent(&fdoExt->idleDoneEvent, 0, FALSE);
}

VOID
HidpPdoIdleOutComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    FDO_EXTENSION *fdoExt = &HidDeviceExtension->fdoExt;
    LONG prevIdleState;
    BOOLEAN idleCancelling = FALSE;
    KIRQL irql;

    DBGSUCCESS(IoStatus->Status, TRUE)

    if (InterlockedDecrement(&fdoExt->numIdlePdos) == 0) {
        HidpPowerDownFdo(HidDeviceExtension);

        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);

        prevIdleState = InterlockedCompareExchange(&fdoExt->idleState,
                                                   IdleComplete,
                                                   IdleCallbackReceived);
        if (fdoExt->idleCancelling) {
            DBGINFO(("Cancelling idle in pdoidleoutcomplete on 0x%x\n", HidDeviceExtension));
            idleCancelling = TRUE;
        }

        DBGASSERT (prevIdleState == IdleCallbackReceived,
                   ("Race condition in HidpPdoIdleOutComplete. Prev state = %x",
                    prevIdleState),
                   TRUE);

        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

        KeResetEvent(&fdoExt->idleDoneEvent);
        if (idleCancelling) {
            POWER_STATE powerState;
            powerState.DeviceState = PowerDeviceD0;
            DBGINFO(("Cancelling idle. Send power irp from pdo idle complete."))
            PoRequestPowerIrp(((PHIDCLASS_DEVICE_EXTENSION) fdoExt->fdo->DeviceExtension)->hidExt.PhysicalDeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              HidpDelayedPowerPoRequestComplete,
                              fdoExt,
                              NULL);
        }
    }
}

VOID HidpIdleNotificationCallback(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension)
{
    PDEVICE_OBJECT pdo;
    FDO_EXTENSION *fdoExt;
    POWER_STATE powerState;
    ULONG iPdo;
    BOOLEAN ok = TRUE;
    KIRQL irql;
    LONG idleState, prevIdleState;

    iPdo = 0;
    fdoExt = &HidDeviceExtension->fdoExt;

    DBGINFO(("------ IDLE NOTIFICATION on fdo 0x%x\n", fdoExt->fdo));

    KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);

    if (fdoExt->idleCancelling) {
        DBGINFO(("We are cancelling idle on fdo 0x%x", fdoExt->fdo));
        fdoExt->idleState = IdleWaiting;
        if (ISPTR(fdoExt->idleTimeoutValue)) {
            InterlockedExchange(fdoExt->idleTimeoutValue, 0);
        }
        fdoExt->idleCancelling = FALSE;
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

        IoCancelIrp(fdoExt->idleNotificationRequest);
        return;
    }
    prevIdleState = InterlockedCompareExchange(&fdoExt->idleState,
                                           IdleCallbackReceived,
                                           IdleIrpSent);
    DBGASSERT(prevIdleState == IdleIrpSent,
              ("Idle callback in wrong state %x for fdo %x. Exitting.",
               prevIdleState, fdoExt->fdo),
              FALSE);

    KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

    if (prevIdleState != IdleIrpSent) {
        return;
    }

    if (HidpIsWaitWakePending(fdoExt, TRUE) == FALSE) {
        SubmitWaitWakeIrp((HIDCLASS_DEVICE_EXTENSION *) fdoExt->fdo->DeviceExtension);
    }

    powerState.DeviceState = fdoExt->deviceCapabilities.DeviceWake;

    fdoExt->numIdlePdos = fdoExt->deviceRelations->Count+1;

    for (iPdo = 0; iPdo < fdoExt->deviceRelations->Count; iPdo++) {
        pdo = fdoExt->collectionPdoExtensions[iPdo]->pdoExt.pdo;

        DBGVERBOSE(("power down pdos, requesting D%d on pdo #%d %x\n",
                 powerState.DeviceState-1, iPdo, pdo));

        //
        // We could check // pdoExt->devicePowerState != PowerDeviceD0
        // but, if the stack gets 2 D0 irps in a row, nothing bad should happen
        //
        PoRequestPowerIrp(pdo,
                          IRP_MN_SET_POWER,
                          powerState,
                          HidpPdoIdleOutComplete,
                          HidDeviceExtension,
                          NULL);
    }

    if (InterlockedDecrement(&fdoExt->numIdlePdos) == 0) {
        BOOLEAN idleCancelling = FALSE;
        HidpPowerDownFdo(HidDeviceExtension);
        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);

        prevIdleState = InterlockedCompareExchange(&fdoExt->idleState,
                                                   IdleComplete,
                                                   IdleCallbackReceived);
        idleCancelling = fdoExt->idleCancelling;

        DBGASSERT (prevIdleState == IdleCallbackReceived,
                   ("Race condition in HidpPdoIdleOutComplete. Prev state = %x",
                    prevIdleState),
                   FALSE);

        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

        KeResetEvent(&fdoExt->idleDoneEvent);
        if (idleCancelling) {
            POWER_STATE powerState;
            powerState.DeviceState = PowerDeviceD0;
            DBGINFO(("Cancelling idle. Send power irp from idle callback."))
            PoRequestPowerIrp(((PHIDCLASS_DEVICE_EXTENSION) fdoExt->fdo->DeviceExtension)->hidExt.PhysicalDeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              HidpDelayedPowerPoRequestComplete,
                              fdoExt,
                              NULL);
        }
    }
}

/*
 ********************************************************************************
 *  EnqueueCollectionWaitWakeIrp
 ********************************************************************************
 *
 */
NTSTATUS
EnqueueCollectionWaitWakeIrp(
    IN FDO_EXTENSION *FdoExt,
    IN PDO_EXTENSION *PdoExt,
    IN PIRP WaitWakeIrp)
{
    PDRIVER_CANCEL oldCancelRoutine;
    KIRQL oldIrql;
    NTSTATUS status;
    PHIDCLASS_DEVICE_EXTENSION devExt = (PHIDCLASS_DEVICE_EXTENSION)FdoExt->fdo->DeviceExtension;

    KeAcquireSpinLock(&FdoExt->collectionWaitWakeIrpQueueSpinLock, &oldIrql);

    if (InterlockedCompareExchangePointer(&PdoExt->waitWakeIrp,
                                          WaitWakeIrp,
                                          NULL) != NULL) {
        //
        // More than one WW irp?  Unthinkable!
        //
        DBGWARN(("Another WW irp was already queued on pdoExt %x", PdoExt))
        status = STATUS_INVALID_DEVICE_STATE;
    } else {
        /*
         *  Must set a cancel routine before checking the Cancel flag
         *  (this makes the cancel code path for the IRP have to contend
         *  for our local spinlock).
         */
        oldCancelRoutine = IoSetCancelRoutine(WaitWakeIrp, CollectionWaitWakeIrpCancelRoutine);
        ASSERT(!oldCancelRoutine);

        if (WaitWakeIrp->Cancel){
            /*
             *  This IRP has already been cancelled.
             */
            oldCancelRoutine = IoSetCancelRoutine(WaitWakeIrp, NULL);
            if (oldCancelRoutine){
                /*
                 *  Cancel routine was NOT called, so complete the IRP here
                 *  (caller will do this when we return error).
                 */
                ASSERT(oldCancelRoutine == CollectionWaitWakeIrpCancelRoutine);
                status = STATUS_CANCELLED;
            }
            else {
                /*
                 *  Cancel routine was called, and it will dequeue and complete the IRP
                 *  as soon as we drop the spinlock.
                 *  Initialize the IRP's listEntry so the dequeue doesn't corrupt the list.
                 *  Then return STATUS_PENDING so we don't touch the IRP
                 */
                InitializeListHead(&WaitWakeIrp->Tail.Overlay.ListEntry);

                IoMarkIrpPending(WaitWakeIrp);
                status = STATUS_PENDING;
            }
        }
        else {
            /*
             *  IoMarkIrpPending sets a bit in the current stack location
             *  to indicate that the Irp may complete on a different thread.
             */
            InsertTailList(&FdoExt->collectionWaitWakeIrpQueue, &WaitWakeIrp->Tail.Overlay.ListEntry);

            IoMarkIrpPending(WaitWakeIrp);
            status = STATUS_PENDING;
        }
    }

    if (status != STATUS_PENDING) {
        //
        // The irp was cancelled. Remove it from the extension.
        //
        InterlockedExchangePointer(&PdoExt->waitWakeIrp, NULL);
    }

    KeReleaseSpinLock(&FdoExt->collectionWaitWakeIrpQueueSpinLock, oldIrql);

    if (status == STATUS_PENDING){
        #if WIN95_BUILD
            DBGERR(("WaitWake IRP sent by client on Win98 ???"))
        #else
            if (!HidpIsWaitWakePending(FdoExt, TRUE)){
                DBGVERBOSE(("WW 5 %x\n", devExt))
                SubmitWaitWakeIrp(devExt);
            }
        #endif
    }

    return status;
}

NTSTATUS
HidpPdoPower(
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status = NO_STATUS;
    PIO_STACK_LOCATION irpSp;
    FDO_EXTENSION *fdoExt;
    PDO_EXTENSION *pdoExt;
    KIRQL oldIrql;
    UCHAR minorFunction;
    LIST_ENTRY dequeue, *entry;
    PIO_STACK_LOCATION stack;
    PIRP irp;
    ULONG count;
    POWER_STATE powerState;
    SYSTEM_POWER_STATE systemState;
    BOOLEAN justReturnPending = FALSE;
    BOOLEAN runPowerCode;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Keep these privately so we still have it after the IRP completes
     *  or after the device extension is freed on a REMOVE_DEVICE
     */
    minorFunction = irpSp->MinorFunction;

    pdoExt = &HidDeviceExtension->pdoExt;
    fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    runPowerCode =
        (pdoExt->state == COLLECTION_STATE_RUNNING) ||
        (pdoExt->state == COLLECTION_STATE_STOPPED) ||
        (pdoExt->state == COLLECTION_STATE_STOPPING);

    if (runPowerCode) {
        switch (minorFunction){

        case IRP_MN_SET_POWER:
            PoSetPowerState(pdoExt->pdo,
                            irpSp->Parameters.Power.Type,
                            irpSp->Parameters.Power.State);

            switch (irpSp->Parameters.Power.Type) {

            case SystemPowerState:
                systemState = irpSp->Parameters.Power.State.SystemState;

                pdoExt->systemPowerState = systemState;

                if (systemState == PowerSystemWorking){
                    powerState.DeviceState = PowerDeviceD0;
                }
                else {
                    powerState.DeviceState = PowerDeviceD3;
                }

                DBGVERBOSE(("S irp, requesting D%d on pdo %x\n",
                         powerState.DeviceState-1, pdoExt->pdo));

                IoMarkIrpPending(Irp);
                PoRequestPowerIrp(pdoExt->pdo,
                                  IRP_MN_SET_POWER,
                                  powerState,
                                  CollectionPowerRequestCompletion,
                                  Irp,    // context
                                  NULL);

                /*
                 *  We want to complete the system-state power Irp
                 *  with the result of the device-state power Irp.
                 *  We'll complete the system-state power Irp when
                 *  the device-state power Irp completes.
                 *
                 *  Note: this may have ALREADY happened, so don't
                 *        touch the original Irp anymore.
                 */
                status = STATUS_PENDING;
                justReturnPending = TRUE;

                break;

            case DevicePowerState:
                switch (irpSp->Parameters.Power.State.DeviceState) {

                case PowerDeviceD0:
                    /*
                     *  Resume from APM Suspend
                     *
                     *  Do nothing here; Send down the read IRPs in the
                     *  completion routine for this (the power) IRP.
                     */
                    DBGVERBOSE(("pdo %x on fdo %x going to D0\n", pdoExt->pdo,
                             fdoExt->fdo));

                    pdoExt->devicePowerState =
                        irpSp->Parameters.Power.State.DeviceState;
                    status = STATUS_SUCCESS;

                    //
                    // Resend all power delayed IRPs
                    //
                    count = DequeueAllPdoPowerDelayedIrps(pdoExt, &dequeue);
                    DBGVERBOSE(("dequeued %d requests\n", count));

                    while (!IsListEmpty(&dequeue)) {
                        entry = RemoveHeadList(&dequeue);
                        irp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);
                        stack = IoGetCurrentIrpStackLocation(irp);

                        DBGINFO(("resending %x to pdo %x in set D0 for pdo.\n", irp, pdoExt->pdo));

                        pdoExt->pdo->DriverObject->
                            MajorFunction[stack->MajorFunction]
                                (pdoExt->pdo, irp);
                    }
                    break;

                case PowerDeviceD1:
                case PowerDeviceD2:
                case PowerDeviceD3:
                    /*
                     *  Suspend
                     */

                    DBGVERBOSE(("pdo %x on fdo %x going to D%d\n", pdoExt->pdo,
                             fdoExt->fdo,
                             irpSp->Parameters.Power.State.DeviceState-1));

                    pdoExt->devicePowerState =
                        irpSp->Parameters.Power.State.DeviceState;
                    status = STATUS_SUCCESS;

                    //
                    // Only manually power down the PDO if the
                    // machine is not going into low power,
                    // the PDO is going into a D state we can
                    // wake out of, and we have idle time out
                    // enabled.
                    //
                    if (pdoExt->systemPowerState == PowerSystemWorking &&
                        pdoExt->devicePowerState <= fdoExt->deviceCapabilities.DeviceWake &&
                        fdoExt->idleState != IdleDisabled) {
                        DBGVERBOSE(("maybe powering down fdo\n"));

                        HidpPowerDownFdo(HidDeviceExtension->pdoExt.deviceFdoExt);
                    }

                    break;

                default:
                    /*
                     *  Do not return STATUS_NOT_SUPPORTED;
                     *  keep the default status
                     *  (this allows filter drivers to work).
                     */
                    status = Irp->IoStatus.Status;
                    break;
                }
                break;

            default:
                /*
                 *  Do not return STATUS_NOT_SUPPORTED;
                 *  keep the default status
                 *  (this allows filter drivers to work).
                 */
                status = Irp->IoStatus.Status;
                break;
            }
            break;

        case IRP_MN_WAIT_WAKE:
            /*
             *  WaitWake IRPs to the collection-PDO's
             *  just get queued in the base device's extension;
             *  when the base device's WaitWake IRP gets
             *  completed, we'll also complete these collection
             *  WaitWake IRPs.
             */

            if (fdoExt->systemPowerState > fdoExt->deviceCapabilities.SystemWake) {
                status = STATUS_POWER_STATE_INVALID;
            } else {
                status = EnqueueCollectionWaitWakeIrp(fdoExt, pdoExt, Irp);
                if (status == STATUS_PENDING){
                    justReturnPending = TRUE;
                }
            }

            break;

        case IRP_MN_POWER_SEQUENCE:
            TRAP;  // client-PDO should never get this
            status = Irp->IoStatus.Status;
            break;

        case IRP_MN_QUERY_POWER:
            /*
             *  We allow all power transitions.
             *  But make sure that there's no WW down that shouldn't be.
             */
            DBGVERBOSE(("Query power"));
            status = HidpCheckIdleState(HidDeviceExtension, Irp);
            if (status != STATUS_SUCCESS) {
                justReturnPending = TRUE;
            }
            break;

        default:
            /*
             *  'fail' the Irp by returning the default status.
             *  Do not return STATUS_NOT_SUPPORTED;
             *  keep the default status
             *  (this allows filter drivers to work).
             */
            status = Irp->IoStatus.Status;
            break;
        }
    } else {
        switch (minorFunction){
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:
            status = STATUS_SUCCESS;
            break;
        default:
            status = Irp->IoStatus.Status;
            break;
        }
    }

    if (!justReturnPending) {
        /*
         *  Whether we are completing or relaying this power IRP,
         *  we must call PoStartNextPowerIrp on Windows NT.
         */
        PoStartNextPowerIrp(Irp);

        ASSERT(status != NO_STATUS);
        Irp->IoStatus.Status = status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGSUCCESS(status, FALSE)
    return status;
}

NTSTATUS
HidpFdoPower(
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status = NO_STATUS;
    PIO_STACK_LOCATION irpSp;
    FDO_EXTENSION *fdoExt;
    KIRQL oldIrql;
    BOOLEAN completeIrpHere = FALSE;
    BOOLEAN returnPending = FALSE;
    UCHAR minorFunction;
    SYSTEM_POWER_STATE systemState;
    BOOLEAN runPowerCode;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Keep these privately so we still have it after the IRP completes
     *  or after the device extension is freed on a REMOVE_DEVICE
     */
    minorFunction = irpSp->MinorFunction;

    fdoExt = &HidDeviceExtension->fdoExt;

    runPowerCode =
        (fdoExt->state == DEVICE_STATE_START_SUCCESS) ||
        (fdoExt->state == DEVICE_STATE_STOPPING) ||
        (fdoExt->state == DEVICE_STATE_STOPPED);

    if (runPowerCode) {
        switch (minorFunction){

        case IRP_MN_SET_POWER:
            PoSetPowerState(fdoExt->fdo,
                            irpSp->Parameters.Power.Type,
                            irpSp->Parameters.Power.State);

            switch (irpSp->Parameters.Power.Type) {

            case SystemPowerState:

                systemState = irpSp->Parameters.Power.State.SystemState;

                if (systemState < PowerSystemMaximum) {
                    /*
                     *  For the 'regular' system power states,
                     *  we convert to a device power state
                     *  and request a callback with the device power state.
                     */
                    PDEVICE_OBJECT pdo = HidDeviceExtension->hidExt.PhysicalDeviceObject;
                    POWER_STATE powerState;
                    KIRQL oldIrql;
                    BOOLEAN isWaitWakePending;

                    if (systemState != PowerSystemWorking) {
                        //
                        // We don't want to be idling during regular system
                        // power stuff.
                        //
                        HidpCancelIdleNotification(fdoExt, FALSE);
                    }

                    fdoExt->systemPowerState = systemState;
                    isWaitWakePending = HidpIsWaitWakePending(fdoExt, FALSE);

                    if (isWaitWakePending &&
                        systemState > fdoExt->deviceCapabilities.SystemWake){
                        /*
                         *  We're transitioning to a system state from which
                         *  this device cannot perform a wake-up.
                         *  So fail all the WaitWake IRPs.
                         */
                        CompleteAllCollectionWaitWakeIrps(fdoExt, STATUS_POWER_STATE_INVALID);
                    }
                    returnPending = TRUE;
                }
                else {
                    TRAP;
                    /*
                     *  For the remaining system power states,
                     *  just pass down the IRP.
                     */
                    runPowerCode = FALSE;
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                }

                break;

            case DevicePowerState:
                switch (irpSp->Parameters.Power.State.DeviceState) {

                case PowerDeviceD0:
                    /*
                     *  Resume from APM Suspend
                     *
                     *  Do nothing here; Send down the read IRPs in the
                     *  completion routine for this (the power) IRP.
                     */
                    DBGVERBOSE(("fdo powering up to D0\n"));
                    break;

                case PowerDeviceD1:
                case PowerDeviceD2:
                case PowerDeviceD3:
                    /*
                     *  Suspend
                     */

                    DBGVERBOSE(("fdo going down to D%d\n", fdoExt->devicePowerState-1));

                    if (fdoExt->state == DEVICE_STATE_START_SUCCESS &&
                        fdoExt->devicePowerState == PowerDeviceD0){
                        CancelAllPingPongIrps(fdoExt);
                    }
                    fdoExt->devicePowerState =
                        irpSp->Parameters.Power.State.DeviceState;

                    break;
                }
                break;
            }
            break;

        case IRP_MN_WAIT_WAKE:
            KeAcquireSpinLock(&fdoExt->waitWakeSpinLock, &oldIrql);
            if (fdoExt->waitWakeIrp == BAD_POINTER) {
                DBGVERBOSE(("new wait wake irp 0x%x\n", Irp));
                fdoExt->waitWakeIrp = Irp;
            } else {
                DBGVERBOSE(("1+ wait wake irps 0x%x\n", Irp));
                completeIrpHere = TRUE;
                status = STATUS_POWER_STATE_INVALID;
            }
            KeReleaseSpinLock(&fdoExt->waitWakeSpinLock, oldIrql);

            break;
        }
    } else {
        switch (minorFunction){
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        default:
            // nothing
            break;
        }
    }

    /*
     *  Whether we are completing or relaying this power IRP,
     *  we must call PoStartNextPowerIrp on Windows NT.
     */
    PoStartNextPowerIrp(Irp);

    /*
     *  If this is a call for a collection-PDO, we complete it ourselves here.
     *  Otherwise, we pass it to the minidriver stack for more processing.
     */
    if (completeIrpHere){

        /*
         *  Note:  Don't touch the Irp after completing it.
         */
        ASSERT(status != NO_STATUS);
        Irp->IoStatus.Status = status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {
        /*
         *  Call the minidriver with this Irp.
         *  The rest of our processing will be done in our completion routine.
         *
         *  Note:  Don't touch the Irp after sending it down, since it may
         *         be completed immediately.
         */

        if (runPowerCode) {
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, HidpFdoPowerCompletion, (PVOID)HidDeviceExtension, TRUE, TRUE, TRUE);
        } else {
            IoSkipCurrentIrpStackLocation(Irp);
        }

        /*
         *
         *  Want to use PoCallDriver here, but PoCallDriver
         *  uses IoCallDriver,
         *  which uses the driverObject->MajorFunction[] array
         *  instead of the hidDriverExtension->MajorFunction[] functions.
         *  SHOULD FIX THIS FOR NT -- should use PoCallDriver
         *
         */
        // status = PoCallDriver(HidDeviceExtension->hidExt.NextDeviceObject, Irp);
        // status = PoCallDriver(fdoExt->fdo, Irp);
        if (returnPending) {
            DBGASSERT(runPowerCode, ("We are returning pending, but not running completion routine.\n"), TRUE)
            IoMarkIrpPending(Irp);
            HidpCallDriver(fdoExt->fdo, Irp);
            status = STATUS_PENDING;
        } else {
            status = HidpCallDriver(fdoExt->fdo, Irp);
        }
    }

    DBGSUCCESS(status, FALSE)
    return status;
}

/*
 ********************************************************************************
 *  HidpIrpMajorPower
 ********************************************************************************
 *
 *
 *  Note:  This function cannot be pageable because (on Win98 anyway)
 *         NTKERN calls it back on the thread of the completion routine
 *         that returns the "Cntrl-Alt-Del" keystrokes.
 *         Also, we may or may not have set the DO_POWER_PAGABLE;
 *         so power IRPs may or may not come in at DISPATCH_LEVEL.
 *         So we must keep this code locked.
 */
NTSTATUS HidpIrpMajorPower(
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION irpSp;
    BOOLEAN isClientPdo;
    NTSTATUS status;
    UCHAR minorFunction;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    minorFunction = irpSp->MinorFunction;

    isClientPdo = HidDeviceExtension->isClientPdo;

    if (minorFunction != IRP_MN_SET_POWER){
        DBG_LOG_POWER_IRP(HidDeviceExtension, minorFunction, isClientPdo, FALSE, "", -1, -1)
    } else {
        switch (irpSp->Parameters.Power.Type) {
        case SystemPowerState:
            DBG_LOG_POWER_IRP(HidDeviceExtension, minorFunction, isClientPdo, FALSE, "SystemState", irpSp->Parameters.Power.State.SystemState, 0xffffffff);
        case DevicePowerState:
            DBG_LOG_POWER_IRP(HidDeviceExtension, minorFunction, isClientPdo, FALSE, "DeviceState", irpSp->Parameters.Power.State.DeviceState, 0xffffffff);
        }
    }

    if (isClientPdo){
        status = HidpPdoPower(HidDeviceExtension, Irp);
    } else {
        status = HidpFdoPower(HidDeviceExtension, Irp);
    }

    DBG_LOG_POWER_IRP(HidDeviceExtension, minorFunction, isClientPdo, TRUE, "", -1, status)

    return status;
}


/*
 ********************************************************************************
 *  SubmitWaitWakeIrp
 ********************************************************************************
 *
 *
 */
NTSTATUS SubmitWaitWakeIrp(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension)
{
    NTSTATUS status;
    POWER_STATE powerState;
    FDO_EXTENSION *fdoExt;

    ASSERT(!HidDeviceExtension->isClientPdo);
    fdoExt = &HidDeviceExtension->fdoExt;

    powerState.SystemState = fdoExt->deviceCapabilities.SystemWake;

    DBGVERBOSE(("SystemWake=%x, submitting waitwake irp.", fdoExt->deviceCapabilities.SystemWake))

    status = PoRequestPowerIrp( HidDeviceExtension->hidExt.PhysicalDeviceObject,
                                IRP_MN_WAIT_WAKE,
                                powerState,
                                HidpWaitWakeComplete,
                                HidDeviceExtension, // context
                                NULL);

    // if (status != STATUS_PENDING){
    //     fdoExt->waitWakeIrp = BAD_POINTER;
    // }

    DBGASSERT((status == STATUS_PENDING),
              ("Expected STATUS_PENDING when submitting WW, got %x", status),
              TRUE)
    return status;
}




/*
 ********************************************************************************
 *  HidpFdoPowerCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpFdoPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_STACK_LOCATION irpSp;
    FDO_EXTENSION *fdoExt;
    NTSTATUS status = Irp->IoStatus.Status;
    PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)Context;
    SYSTEM_POWER_STATE systemState;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    ASSERT(ISPTR(HidDeviceExtension));

    if (HidDeviceExtension->isClientPdo){
        fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;
    }
    else {
        fdoExt = &HidDeviceExtension->fdoExt;
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp->MajorFunction == IRP_MJ_POWER);

    if (NT_SUCCESS(status)) {
        switch (irpSp->MinorFunction) {

        case IRP_MN_SET_POWER:
            switch (irpSp->Parameters.Power.Type) {
            case DevicePowerState:
                switch (irpSp->Parameters.Power.State.DeviceState){
                case PowerDeviceD0:

                    if (fdoExt->devicePowerState != PowerDeviceD0) {
                        KIRQL irql;
                        LONG prevIdleState;

                        fdoExt->devicePowerState = irpSp->Parameters.Power.State.DeviceState;

                        ASSERT(!HidDeviceExtension->isClientPdo);

                        //
                        // Reset the idle stuff if it's not disabled.
                        //
                        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);
                        if (fdoExt->idleState != IdleDisabled) {
                            prevIdleState = InterlockedExchange(&fdoExt->idleState, IdleWaiting);
                            DBGASSERT(prevIdleState == IdleComplete,
                                      ("Previous idle state while completing actually %x",
                                       prevIdleState),
                                      TRUE);
                            fdoExt->idleCancelling = FALSE;
                        }
                        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

                        /*
                         *  On APM resume, restart the ping-pong IRPs
                         *  for interrupt devices.
                         */
                        if (!fdoExt->driverExt->DevicesArePolled &&
                            !fdoExt->isOutputOnlyDevice) {
                            NTSTATUS ntStatus = HidpStartAllPingPongs(fdoExt);
                            if (!NT_SUCCESS(ntStatus)) {
                                fdoExt->state = DEVICE_STATE_START_FAILURE;
                            }
                        }
                    }
                    break;
                }
                break;
            case SystemPowerState:
                ASSERT (!HidDeviceExtension->isClientPdo);

                systemState = irpSp->Parameters.Power.State.SystemState;

                ASSERT((ULONG)systemState < PowerSystemMaximum);

                if (systemState < PowerSystemMaximum){
                    /*
                     *  For the 'regular' system power states,
                     *  we convert to a device power state
                     *  and request a callback with the device power state.
                     */
                    PDEVICE_OBJECT pdo = HidDeviceExtension->hidExt.PhysicalDeviceObject;
                    POWER_STATE powerState;
                    KIRQL oldIrql;
                    BOOLEAN isWaitWakePending;

                    fdoExt->systemPowerState = systemState;
                    isWaitWakePending = HidpIsWaitWakePending(fdoExt, FALSE);

                    if (isWaitWakePending){
                        if (systemState == PowerSystemWorking){
                            powerState.DeviceState = PowerDeviceD0;
                        }
                        else {
                            powerState.DeviceState = fdoExt->deviceCapabilities.DeviceState[systemState];

                            /*
                             *  If the bus does not map the system state to
                             *  a defined device state, request PowerDeviceD3
                             *  and cancel the WaitWake IRP.
                             */
                            if (powerState.DeviceState == PowerDeviceUnspecified){
                                DBGERR(("IRP_MN_SET_POWER: systemState %d mapped not mapped so using device state PowerDeviceD3.", systemState))
                                powerState.DeviceState = PowerDeviceD3;
                            }
                        }
                    }
                    else {
                        /*
                         *  If we don't have a WaitWake IRP pending,
                         *  then every reduced-power system state
                         *  should get mapped to D3.
                         */
                        if (systemState == PowerSystemWorking){
                            powerState.DeviceState = PowerDeviceD0;
                        }
                        else {
                            DBGVERBOSE(("IRP_MN_SET_POWER: no waitWake IRP, so requesting PowerDeviceD3."))
                            powerState.DeviceState = PowerDeviceD3;
                        }
                    }

                    DBGVERBOSE(("IRP_MN_SET_POWER: mapped systemState %d to device state %d.", systemState, powerState.DeviceState))

                    IoMarkIrpPending(Irp);
                    fdoExt->currentSystemStateIrp = Irp;
                    PoRequestPowerIrp(  pdo,
                                        IRP_MN_SET_POWER,
                                        powerState,
                                        DevicePowerRequestCompletion,
                                        fdoExt,    // context
                                        NULL);

                    status = STATUS_MORE_PROCESSING_REQUIRED;
                }
                else {
                    TRAP;
                    /*
                     *  For the remaining system power states,
                     *  just pass down the IRP.
                     */
                }
                break;
            }
            break;
        }
    }
    else if (status == STATUS_CANCELLED){
        /*
         *  Client cancelled the power IRP, probably getting removed.
         */
    }
    else {
        DBGWARN(("HidpPowerCompletion: Power IRP %ph (minor function %xh) failed with status %xh.", Irp, irpSp->MinorFunction, Irp->IoStatus.Status))
    }

    return status;
}



/*
 ********************************************************************************
 *  DevicePowerRequestCompletion
 ********************************************************************************
 *
 *  Note: the DeviceObject here is the PDO (e.g. usbhub's PDO), not our FDO,
 *        so we cannot use its device context.
 */
VOID DevicePowerRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    FDO_EXTENSION *fdoExt = (FDO_EXTENSION *)Context;
    PIRP systemStateIrp;

    DBG_COMMON_ENTRY()

    systemStateIrp = fdoExt->currentSystemStateIrp;
    fdoExt->currentSystemStateIrp = BAD_POINTER;
    ASSERT(systemStateIrp);

    DBGSUCCESS(IoStatus->Status, TRUE)
//  systemStateIrp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp(systemStateIrp);

    /*
     *  Complete the system-state IRP.
     */
    IoCompleteRequest(systemStateIrp, IO_NO_INCREMENT);

    if (PowerState.DeviceState == PowerDeviceD0) {
        //
        // Powering up. Restart the idling.
        //
        HidpStartIdleTimeout(fdoExt, FALSE);
    }

    DBG_COMMON_EXIT()
}



/*
 ********************************************************************************
 *  CollectionPowerRequestCompletion
 ********************************************************************************
 *
 *
 */
VOID CollectionPowerRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PIRP systemStateIrp = (PIRP)Context;
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension;
    PDO_EXTENSION *pdoExt;
    IO_STACK_LOCATION *irpSp;
    SYSTEM_POWER_STATE systemState;

    DBG_COMMON_ENTRY()

    hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    pdoExt = &hidDeviceExtension->pdoExt;

    ASSERT(systemStateIrp);

    /*
     *  This is the completion routine for the device-state power
     *  Irp which we've requested.  Complete the original system-state
     *  power Irp with the result of the device-state power Irp.
     */

    irpSp = IoGetCurrentIrpStackLocation(systemStateIrp);
    systemState = irpSp->Parameters.Power.State.SystemState;

    systemStateIrp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp(systemStateIrp);

    IoCompleteRequest(systemStateIrp, IO_NO_INCREMENT);

    //
    // If we're powering up, check if we should have a WW irp pending.
    //
    if (systemState == PowerSystemWorking &&
        SHOULD_SEND_WAITWAKE(pdoExt)) {
        HidpCreateRemoteWakeIrp(pdoExt);
    }

    DBG_COMMON_EXIT()
}


/*
 ********************************************************************************
 *  HidpWaitWakePoRequestComplete
 ********************************************************************************
 *
 */
NTSTATUS HidpWaitWakePoRequestComplete(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    PHIDCLASS_DEVICE_EXTENSION hidDevExt = (PHIDCLASS_DEVICE_EXTENSION)Context;
    FDO_EXTENSION *fdoExt;

    ASSERT(!hidDevExt->isClientPdo);
    fdoExt = &hidDevExt->fdoExt;

    DBGVERBOSE(("HidpWaitWakePoRequestComplete!, status == %xh", IoStatus->Status))

    #if WIN95_BUILD
        if (NT_SUCCESS(IoStatus->Status)) {
            //
            // Resubmit the wait wake irp
            //
            HidpPowerUpPdos(fdoExt);
            SubmitWaitWakeIrp(hidDevExt);
        }
    #else

        /*
         *  Complete all the collections' WaitWake IRPs with this same status.
         */
        CompleteAllCollectionWaitWakeIrps(fdoExt, IoStatus->Status);

        if (NT_SUCCESS(IoStatus->Status) && fdoExt->idleState != IdleDisabled) {
            HidpPowerUpPdos(fdoExt);
        }
    #endif
    return STATUS_SUCCESS;
}


/*
 ********************************************************************************
 *  HidpWaitWakeComplete
 ********************************************************************************
 *
 */
NTSTATUS HidpWaitWakeComplete(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    PHIDCLASS_DEVICE_EXTENSION hidDevExt = (PHIDCLASS_DEVICE_EXTENSION)Context;
    FDO_EXTENSION *fdoExt;
    PDO_EXTENSION *pdoExt;
    NTSTATUS status;
    KIRQL oldIrql;

    ASSERT(!hidDevExt->isClientPdo);
    fdoExt = &hidDevExt->fdoExt;

    status = IoStatus->Status;
    DBGVERBOSE(("HidpWaitWakeComplete!, status == %xh", status))

    KeAcquireSpinLock(&fdoExt->waitWakeSpinLock, &oldIrql);
    fdoExt->waitWakeIrp = BAD_POINTER;
    fdoExt->isWaitWakePending = FALSE;
    KeReleaseSpinLock(&fdoExt->waitWakeSpinLock, oldIrql);

    /*
     *  Call HidpWaitWakePoRequestComplete (either directly or
     *  as a completion routine to the power IRP that we request
     *  to wake up the machine); it will complete the clients'
     *  WaitWake IRPs with the same status as this device WaitWake IRP.
     */
    PowerState.DeviceState = PowerDeviceD0;

    if (NT_SUCCESS(status)){
        /*
         *  Our device is waking up the machine.
         *  So request the D0 (working) power state.
         */
        // PowerState is undefined when a wait wake irp is completing
        // ASSERT(PowerState.DeviceState == PowerDeviceD0);

        DBGVERBOSE(("ww irp, requesting D0 on pdo %x\n", DeviceObject))

        PoRequestPowerIrp(  DeviceObject,
                            IRP_MN_SET_POWER,
                            PowerState,
                            HidpWaitWakePoRequestComplete,
                            Context,
                            NULL);
    } else if (status != STATUS_CANCELLED) {

        //
        // If the wait wake failed, then there is no way for us to wake the
        // device when we are in S0.  Turn off idle detection.
        //
        // This doesn't need to be guarded by a spin lock because the only
        // places we look at these values is in the power dispatch routine
        // and when an interrupt read completes...
        //
        // 1)  no interrupt read will be completing b/c the pingpong engine has
        //      been suspended and will not start until we power up the stack
        // 2)  I think we are still considered to be handling a power irp.  If
        //      not, then we need to guard the isIdleTimeoutEnabled field
        //
        // ISSUE! we should also only turn off idle detection if the WW fails in
        //        S0.  If we hiber, then the WW will fail, but we should not turn off
        //        idle detection in this case.  I think that checking
        //        systemPowerState is not PowerSystemWorking will do the trick,
        //        BUT THIS MUST BE CONFIRMED!!!!
        //
        if (fdoExt->idleState != IdleDisabled &&
            fdoExt->systemPowerState == PowerSystemWorking) {
            DBGWARN(("Turning off idle detection due to WW failure, status = %x\n", status))

            ASSERT(ISPTR(fdoExt->idleTimeoutValue));

            //
            // Don't set any state before calling because we may have to power
            // stuff up.
            //
            HidpCancelIdleNotification(fdoExt, FALSE);
        }

        HidpWaitWakePoRequestComplete(  DeviceObject,
                                        MinorFunction,
                                        PowerState,
                                        Context,
                                        IoStatus);
    }

    return STATUS_SUCCESS;
}




/*
 ********************************************************************************
 *  QueuePowerEventIrp
 ********************************************************************************
 *
 */
NTSTATUS QueuePowerEventIrp(
    IN PHIDCLASS_COLLECTION hidCollection,
    IN PIRP Irp
    )
{
    NTSTATUS status;
    KIRQL oldIrql;
    PDRIVER_CANCEL oldCancelRoutine;

    KeAcquireSpinLock(&hidCollection->powerEventSpinLock, &oldIrql);

    /*
     *  Must set a cancel routine before checking the Cancel flag.
     */
    oldCancelRoutine = IoSetCancelRoutine(Irp, PowerEventCancelRoutine);
    ASSERT(!oldCancelRoutine);

    if (Irp->Cancel){
        /*
         *  This IRP was cancelled.  Do not queue it.
         *  The calling function will complete the IRP with error.
         */
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine){
            /*
             *  Cancel routine was NOT called.
             *  Complete the IRP here.
             */
            ASSERT(oldCancelRoutine == PowerEventCancelRoutine);
            status = STATUS_CANCELLED;
        }
        else {
            /*
             *  The cancel routine was called,
             *  and it will complete this IRP as soon as we drop the spinlock.
             *  Return PENDING so the caller doesn't touch this IRP.
             */
            status = STATUS_PENDING;
        }
    }
    else if (ISPTR(hidCollection->powerEventIrp)){
        /*
         *  We already have a power event IRP queued.
         *  This shouldn't happen, but we'll handle it.
         */
        DBGWARN(("Already have a power event irp queued."));
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine){
            /*
             *  Cancel routine was NOT called.
             *  Complete the IRP here.
             */
            ASSERT(oldCancelRoutine == PowerEventCancelRoutine);
            status = STATUS_UNSUCCESSFUL;
        }
        else {
            /*
             *  The irp was cancelled and the cancel routine was called;
             *  it will complete this IRP as soon as we drop the spinlock.
             *  Return PENDING so the caller doesn't touch this IRP.
             */
            ASSERT(Irp->Cancel);
            status = STATUS_PENDING;
        }
    }
    else {
        /*
         *  Save a pointer to this power event IRP and return PENDING.
         *  This qualifies as "queuing" the IRP, so we must have
         *  a cancel routine.
         */
        hidCollection->powerEventIrp = Irp;
        IoMarkIrpPending(Irp);
        status = STATUS_PENDING;
    }

    KeReleaseSpinLock(&hidCollection->powerEventSpinLock, oldIrql);

    return status;
}


/*
 ********************************************************************************
 *  PowerEventCancelRoutine
 ********************************************************************************
 *
 */
VOID PowerEventCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    FDO_EXTENSION *fdoExt;
    PHIDCLASS_COLLECTION hidCollection;
    ULONG collectionIndex;
    KIRQL oldIrql;

    ASSERT(hidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(hidDeviceExtension->isClientPdo);
    fdoExt = &hidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;
    collectionIndex = hidDeviceExtension->pdoExt.collectionIndex;
    hidCollection = &fdoExt->classCollectionArray[collectionIndex];

    KeAcquireSpinLock(&hidCollection->powerEventSpinLock, &oldIrql);

    ASSERT(Irp == hidCollection->powerEventIrp);
    hidCollection->powerEventIrp = BAD_POINTER;

    KeReleaseSpinLock(&hidCollection->powerEventSpinLock, oldIrql);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


/*
 ********************************************************************************
 *  CollectionWaitWakeIrpCancelRoutine
 ********************************************************************************
 *
 */
VOID CollectionWaitWakeIrpCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    KIRQL oldIrql, oldIrql2;
    PIRP deviceWaitWakeIrpToCancel = NULL;
    FDO_EXTENSION *fdoExt;
    PDO_EXTENSION *pdoExt;

    ASSERT(hidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(hidDeviceExtension->isClientPdo);
    pdoExt = &hidDeviceExtension->pdoExt;
    fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    KeAcquireSpinLock(&fdoExt->collectionWaitWakeIrpQueueSpinLock, &oldIrql);

    /*
     *  Dequeue the client's WaitWake IRP.
     */
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    InterlockedExchangePointer(&pdoExt->waitWakeIrp, NULL);

    /*
     *  If the last collection WaitWake IRP just got cancelled,
     *  cancel our WaitWake IRP as well.
     *
     *  NOTE:  we only cancel the FDO wait wake irp if we are not doing idle
     *         detection, otherwise, there would be no way for the device to
     *         wake up when we put it into low power
     *
     */
    KeAcquireSpinLock(&fdoExt->waitWakeSpinLock, &oldIrql2);
    if (IsListEmpty(&fdoExt->collectionWaitWakeIrpQueue) &&
        fdoExt->isWaitWakePending                        &&
        fdoExt->idleState == IdleDisabled){
        ASSERT(ISPTR(fdoExt->waitWakeIrp));
        deviceWaitWakeIrpToCancel = fdoExt->waitWakeIrp;
        fdoExt->waitWakeIrp = BAD_POINTER;
        fdoExt->isWaitWakePending = FALSE;
    }
    KeReleaseSpinLock(&fdoExt->waitWakeSpinLock, oldIrql2);

    KeReleaseSpinLock(&fdoExt->collectionWaitWakeIrpQueueSpinLock, oldIrql);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    /*
     *  Complete the cancelled IRP only if it was in the list.
     */
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    if (ISPTR(deviceWaitWakeIrpToCancel)){
        IoCancelIrp(deviceWaitWakeIrpToCancel);
    }
}


/*
 ********************************************************************************
 *  CompleteAllCollectionWaitWakeIrps
 ********************************************************************************
 *
 *  Note:   this function cannot be pageable because it is called
 *          from a completion routine.
 */
VOID CompleteAllCollectionWaitWakeIrps(
    IN FDO_EXTENSION *fdoExt,
    IN NTSTATUS status
    )
{
    LIST_ENTRY irpsToComplete;
    KIRQL oldIrql;
    PLIST_ENTRY listEntry;
    PIRP irp;
    PDO_EXTENSION *pdoExt;
    PIO_STACK_LOCATION irpSp;

    InitializeListHead(&irpsToComplete);

    KeAcquireSpinLock(&fdoExt->collectionWaitWakeIrpQueueSpinLock, &oldIrql);

    while (!IsListEmpty(&fdoExt->collectionWaitWakeIrpQueue)){
        PDRIVER_CANCEL oldCancelRoutine;

        listEntry = RemoveHeadList(&fdoExt->collectionWaitWakeIrpQueue);
        InitializeListHead(listEntry);  // in case cancel routine tries to dequeue again

        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == CollectionWaitWakeIrpCancelRoutine);

            /*
             *  We can't complete an IRP while holding a spinlock.
             *  Also, we don't want to complete a WaitWake IRP while
             *  still processing collectionWaitWakeIrpQueue because a driver
             *  may resend an IRP on the same thread, causing us to loop forever.
             *  So just move the IRPs to a private queue and we'll complete them later.
             */
            InsertTailList(&irpsToComplete, listEntry);
            irpSp = IoGetCurrentIrpStackLocation(irp);
            pdoExt = &((PHIDCLASS_DEVICE_EXTENSION)irpSp->DeviceObject->DeviceExtension)->pdoExt;
            InterlockedExchangePointer(&pdoExt->waitWakeIrp, NULL);
        }
        else {
            /*
             *  This IRP was cancelled and the cancel routine WAS called.
             *  The cancel routine will complete the IRP as soon as we drop the spinlock.
             *  So don't touch the IRP.
             */
            ASSERT(irp->Cancel);
        }
    }

    KeReleaseSpinLock(&fdoExt->collectionWaitWakeIrpQueueSpinLock, oldIrql);

    while (!IsListEmpty(&irpsToComplete)){
        listEntry = RemoveHeadList(&irpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}

VOID PowerDelayedCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    FDO_EXTENSION *fdoExt;
    KIRQL oldIrql;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    ASSERT(hidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(hidDeviceExtension->isClientPdo);
    fdoExt = &hidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    KeAcquireSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, &oldIrql);

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    ASSERT(Irp->Tail.Overlay.DriverContext[0] == (PVOID) hidDeviceExtension);
    Irp->Tail.Overlay.DriverContext[0] = NULL;

    ASSERT(fdoExt->numPendingPowerDelayedIrps > 0);
    fdoExt->numPendingPowerDelayedIrps--;

    KeReleaseSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, oldIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


NTSTATUS HidpDelayedPowerPoRequestComplete(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus)
{
    KIRQL irql;
    LONG prevIdleState;
    PFDO_EXTENSION fdoExt = (PFDO_EXTENSION) Context;

    DBGINFO(("powering up all pdos due to delayed request, 0x%x\n", IoStatus->Status))

    DBGVERBOSE(("HidpDelayedPowerPoRequestComplete!, status == %xh", IoStatus->Status))

    if (NT_SUCCESS(IoStatus->Status)) {
        HidpPowerUpPdos(fdoExt);
    } else {
        //
        // All bets are off.
        //
        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);
        prevIdleState = InterlockedExchange(&fdoExt->idleState, IdleDisabled);
        fdoExt->idleCancelling = FALSE;
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

        KeSetEvent(&fdoExt->idleDoneEvent, 0, FALSE);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
EnqueuePowerDelayedIrp(
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    IN PIRP Irp
    )
{
    FDO_EXTENSION *fdoExt;
    NTSTATUS status;
    KIRQL oldIrql;
    PDRIVER_CANCEL oldCancelRoutine;

    ASSERT(HidDeviceExtension->isClientPdo);
    fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    DBGINFO(("enqueuing irp %x (mj %x, mn %x)\n", Irp,
             (ULONG) IoGetCurrentIrpStackLocation(Irp)->MajorFunction,
             (ULONG) IoGetCurrentIrpStackLocation(Irp)->MinorFunction))

    KeAcquireSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, &oldIrql);

    /*
     *  Must set a cancel routine before
     *  checking the Cancel flag.
     */
    oldCancelRoutine = IoSetCancelRoutine(Irp, PowerDelayedCancelRoutine);
    ASSERT(!oldCancelRoutine);

    /*
     *  Make sure this Irp wasn't just cancelled.
     *  Note that there is NO RACE CONDITION here
     *  because we are holding the fileExtension lock.
     */
    if (Irp->Cancel){
        /*
         *  This IRP was cancelled.
         */
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine){
            /*
             *  The cancel routine was NOT called.
             *  Return error so that caller completes the IRP.
             */
            ASSERT(oldCancelRoutine == PowerDelayedCancelRoutine);
            status = STATUS_CANCELLED;
        }
        else {
            /*
             *  The cancel routine was called.
             *  As soon as we drop the spinlock it will dequeue
             *  and complete the IRP.
             *  Initialize the IRP's listEntry so that the dequeue
             *  doesn't cause corruption.
             *  Then don't touch the irp.
             */
            InitializeListHead(&Irp->Tail.Overlay.ListEntry);
            fdoExt->numPendingPowerDelayedIrps++;  // because cancel routine will decrement

            //
            // We assert that this value is set in the cancel routine
            //
            Irp->Tail.Overlay.DriverContext[0] = (PVOID) HidDeviceExtension;

            IoMarkIrpPending(Irp);
            status = Irp->IoStatus.Status = STATUS_PENDING;
        }
    }
    else {
        /*
         *  Queue this irp onto the fdo's power delayed queue
         */
        InsertTailList(&fdoExt->collectionPowerDelayedIrpQueue,
                       &Irp->Tail.Overlay.ListEntry);
        fdoExt->numPendingPowerDelayedIrps++;

        Irp->Tail.Overlay.DriverContext[0] = (PVOID) HidDeviceExtension;

        IoMarkIrpPending(Irp);
        status = Irp->IoStatus.Status = STATUS_PENDING;
    }

    KeReleaseSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, oldIrql);

    return status;
}

PIRP DequeuePowerDelayedIrp(FDO_EXTENSION *fdoExt)
{
    KIRQL oldIrql;
    PIRP irp = NULL;

    KeAcquireSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, &oldIrql);

    while (!irp && !IsListEmpty(&fdoExt->collectionPowerDelayedIrpQueue)){
        PDRIVER_CANCEL oldCancelRoutine;
        PLIST_ENTRY listEntry = RemoveHeadList(&fdoExt->collectionPowerDelayedIrpQueue);

        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);

        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == PowerDelayedCancelRoutine);
            ASSERT(fdoExt->numPendingPowerDelayedIrps > 0);
            fdoExt->numPendingPowerDelayedIrps--;
        }
        else {
            /*
             *  IRP was cancelled and cancel routine was called.
             *  As soon as we drop the spinlock,
             *  the cancel routine will dequeue and complete this IRP.
             *  Initialize the IRP's listEntry so that the dequeue doesn't cause corruption.
             *  Then, don't touch the IRP.
             */
            ASSERT(irp->Cancel);
            InitializeListHead(&irp->Tail.Overlay.ListEntry);
            irp = NULL;
        }
    }

    KeReleaseSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, oldIrql);

    return irp;
}

ULONG DequeueAllPdoPowerDelayedIrps(
    PDO_EXTENSION *pdoExt,
    PLIST_ENTRY dequeue
    )

{
    PDRIVER_CANCEL oldCancelRoutine;
    FDO_EXTENSION *fdoExt;
    PDO_EXTENSION *irpPdoExt;
    PLIST_ENTRY entry;
    KIRQL oldIrql;
    PIRP irp;
    ULONG count = 0;

    InitializeListHead(dequeue);

    fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    KeAcquireSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, &oldIrql);

    for (entry = fdoExt->collectionPowerDelayedIrpQueue.Flink;
         entry != &fdoExt->collectionPowerDelayedIrpQueue;
          ) {

        irp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

        irpPdoExt =
            &((PHIDCLASS_DEVICE_EXTENSION) irp->Tail.Overlay.DriverContext[0])->pdoExt;

        entry = entry->Flink;

        if (irpPdoExt == pdoExt) {

            //
            // Remove the entry from the linked list and then either queue it
            // in the dequeue or init the entry so it is valid for the cancel
            // routine
            //
            RemoveEntryList(&irp->Tail.Overlay.ListEntry);

            oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
            if (oldCancelRoutine != NULL) {
                InsertTailList(dequeue, &irp->Tail.Overlay.ListEntry);
                fdoExt->numPendingPowerDelayedIrps--;
                count++;
            }
            else {
                /*
                 *  This IRP was cancelled and the cancel routine WAS called.
                 *  The cancel routine will complete the IRP as soon as we drop the spinlock.
                 *  So don't touch the IRP.
                 */
                ASSERT(irp->Cancel);
                InitializeListHead(&irp->Tail.Overlay.ListEntry);  // in case cancel routine tries to dequeue again
            }
        }
    }

    KeReleaseSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, oldIrql);

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\physdesc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: 

    physdesc.c

Abstract

    Get-friendly-name handling routines

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"



/*
 ********************************************************************************
 *  HidpGetPhysicalDescriptor
 ********************************************************************************
 *
 *  Note:  This function cannot be pageable because it is called
 *         from the IOCTL dispatch routine, which can get called
 *         at DISPATCH_LEVEL.
 *
 */
NTSTATUS HidpGetPhysicalDescriptor(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    FDO_EXTENSION *fdoExt;
    NTSTATUS status;
    PIO_STACK_LOCATION  currentIrpSp, nextIrpSp;


    ASSERT(HidDeviceExtension->isClientPdo);
    fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    /*
     *  IOCTL_GET_PHYSICAL_DESCRIPTOR uses buffering method
     *  METHOD_OUT_DIRECT, meaning that the buffer is in
     *  the MDL specified by Irp->MdlAddress.  We'll just
     *  pass this down and let the lower driver extract the 
     *  system address.
     */
    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);
    nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_GET_PHYSICAL_DESCRIPTOR;
    nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = currentIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    status = HidpCallDriver(fdoExt->fdo, Irp);

    DBGSUCCESS(status, FALSE)
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\polled.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    polled.c

Abstract

    Read handling routines

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/


#include "pch.h"



/*
 ********************************************************************************
 *  CompleteQueuedIrpsForPolled
 ********************************************************************************
 *
 *  Complete all waiting client reads with the given report value.
 *
 *  Note: report is a 'cooked' report (i.e. it already has the report id added).
 *
 */
VOID CompleteQueuedIrpsForPolled(   FDO_EXTENSION *fdoExt,
                                    ULONG collectionNum,
                                    PUCHAR report,
                                    ULONG reportLen,
                                    NTSTATUS status)
{
    PHIDCLASS_COLLECTION hidCollection;

    hidCollection = GetHidclassCollection(fdoExt, collectionNum);

    if (hidCollection){
        PLIST_ENTRY listEntry;
        LIST_ENTRY irpsToComplete;
        PIRP irp;
        ULONG actualLen;

        /*
         *  Note: In order to avoid an infinite loop with a client that
         *        resubmits the read each in his completion routine,
         *        we must build a separate list of IRPs to be completed
         *        while holding the spinlock continuously.
         */
        InitializeListHead(&irpsToComplete);

        if (hidCollection->secureReadMode) {
            while (irp = DequeuePolledReadSystemIrp(hidCollection)){
                InsertTailList(&irpsToComplete, &irp->Tail.Overlay.ListEntry);
            }

        } else {
        
            while (irp = DequeuePolledReadIrp(hidCollection)){
                InsertTailList(&irpsToComplete, &irp->Tail.Overlay.ListEntry);             
            }
        
        }

        while (!IsListEmpty(&irpsToComplete)){
            PIO_STACK_LOCATION stackPtr;
            PHIDCLASS_FILE_EXTENSION fileExtension;

            listEntry = RemoveHeadList(&irpsToComplete);
            irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

            stackPtr = IoGetCurrentIrpStackLocation(irp);
            ASSERT(stackPtr);
            fileExtension = (PHIDCLASS_FILE_EXTENSION)stackPtr->FileObject->FsContext;
            ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);

            actualLen = 0;
            if (NT_SUCCESS(status)){
                PUCHAR callerBuf;

                callerBuf = HidpGetSystemAddressForMdlSafe(irp->MdlAddress);

                if (callerBuf && (stackPtr->Parameters.Read.Length >= reportLen)){
                    RtlCopyMemory(callerBuf, report, reportLen);
                    irp->IoStatus.Information = actualLen = reportLen;
                } else {
                    status = STATUS_INVALID_USER_BUFFER;
                }
            }

            DBG_RECORD_READ(irp, actualLen, (ULONG)report[0], TRUE)
            irp->IoStatus.Status = status;
            fileExtension->nowCompletingIrpForOpportunisticReader++;
            IoCompleteRequest(irp, IO_KEYBOARD_INCREMENT);
            fileExtension->nowCompletingIrpForOpportunisticReader--;
        }
    }
    else {
        TRAP;
    }
}

/*
 ********************************************************************************
 *  HidpPolledReadComplete
 ********************************************************************************
 *
 *  Note: the context passed to this callback is the PDO extension for
 *        the collection which initiated this read; however, the returned
 *        report may be for another collection.
 */
NTSTATUS HidpPolledReadComplete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PDO_EXTENSION *pdoExt = (PDO_EXTENSION *)Context;
    FDO_EXTENSION *fdoExt = &pdoExt->deviceFdoExt->fdoExt;
    PIO_STACK_LOCATION nextStack = IoGetNextIrpStackLocation(Irp);
    ULONG reportId;
    PHIDP_REPORT_IDS reportIdent;

    DBG_COMMON_ENTRY()

    ASSERT(pdoExt->deviceFdoExt->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(ISPTR(Irp->UserBuffer));

    fdoExt->outstandingRequests--;

    if (fdoExt->deviceDesc.ReportIDs[0].ReportID == 0) {
        /*
         *  We previously incremented the UserBuffer to knock off the report id,
         *  so restore it now and set the default report id.
         */
        *(PUCHAR)(--(PUCHAR)Irp->UserBuffer) = (UCHAR)0;
        if (NT_SUCCESS(Irp->IoStatus.Status)){
            Irp->IoStatus.Information++;
        }
    }

    /*
     *  WHETHER OR NOT THE CALL SUCCEEDED,
     *  we'll complete the waiting client read IRPs with
     *  the result of this read.
     */
    reportId = (ULONG)(*(PUCHAR)Irp->UserBuffer);
    reportIdent = GetReportIdentifier(fdoExt, reportId);
    if (reportIdent){
        ULONG collectionNum = reportIdent->CollectionNumber;
        PHIDCLASS_COLLECTION hidpCollection = GetHidclassCollection(fdoExt, collectionNum);
        PHIDP_COLLECTION_DESC hidCollectionDesc = GetCollectionDesc(fdoExt, collectionNum);

        if (hidpCollection && hidCollectionDesc){
            ULONG reportLen = (ULONG)Irp->IoStatus.Information;

            ASSERT((reportLen == hidCollectionDesc->InputLength) || !NT_SUCCESS(Irp->IoStatus.Status));

            if (NT_SUCCESS(Irp->IoStatus.Status)){
                KIRQL oldIrql;

                /*
                 *  If this report contains a power-button event, alert the system.
                 */
                CheckReportPowerEvent(  fdoExt,
                                        hidpCollection,
                                        Irp->UserBuffer,
                                        reportLen);

                /*
                 *  Save this report for "opportunistic" polled device
                 *  readers who want a result right away.
                 *  Use the polledDeviceReadQueueSpinLock to protect
                 *  the savedPolledReportBuf.
                 */

                if (hidpCollection->secureReadMode) {

                    hidpCollection->polledDataIsStale = TRUE;

                } else {

                    KeAcquireSpinLock(&hidpCollection->polledDeviceReadQueueSpinLock, &oldIrql);
                    ASSERT(reportLen <= fdoExt->maxReportSize+1);
                    RtlCopyMemory(hidpCollection->savedPolledReportBuf, Irp->UserBuffer, reportLen);
                    hidpCollection->savedPolledReportLen = reportLen;
                    hidpCollection->polledDataIsStale = FALSE;
                    KeReleaseSpinLock(&hidpCollection->polledDeviceReadQueueSpinLock, oldIrql);

                }
            }

            /*
             *  Copy this report for all queued read IRPs on this polled device.
             *  Do this AFTER updating the savedPolledReport information
             *  because many clients will issue a read again immediately
             *  from the completion routine.
             */
            CompleteQueuedIrpsForPolled(    fdoExt,
                                            collectionNum,
                                            Irp->UserBuffer,
                                            reportLen,
                                            Irp->IoStatus.Status);

        }
        else {
            TRAP;
        }
    }
    else {
        TRAP;
    }


    /*
     *  This is an IRP we created to poll the device.
     *  Free the buffer we allocated for the read.
     */
    ExFreePool(Irp->UserBuffer);
    IoFreeIrp(Irp);

    /*
     *  MUST return STATUS_MORE_PROCESSING_REQUIRED here or
     *  NTKERN will touch the IRP.
     */
    DBG_COMMON_EXIT()
    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*
 ********************************************************************************
 *  HidpPolledReadComplete_TimerDriven
 ********************************************************************************
 *
 */
NTSTATUS HidpPolledReadComplete_TimerDriven(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PDO_EXTENSION *pdoExt = (PDO_EXTENSION *)Context;
    FDO_EXTENSION *fdoExt = &pdoExt->deviceFdoExt->fdoExt;
    NTSTATUS status;

    /*
     *  Call the actual completion routine.
     */
    status = HidpPolledReadComplete(DeviceObject, Irp, Context);

    /*
     *  Reset the timer of the collection which initiated this read,
     *  (which may be different than the collection that returned the report).
     */
    if (pdoExt->state == COLLECTION_STATE_RUNNING){
        PHIDCLASS_COLLECTION originatorCollection =
            GetHidclassCollection(fdoExt, pdoExt->collectionNum);

        if (originatorCollection){
            LARGE_INTEGER timeout;
            timeout.HighPart = -1;
            timeout.LowPart = -(LONG)(originatorCollection->PollInterval_msec*10000);
            KeSetTimer( &originatorCollection->polledDeviceTimer,
                        timeout,
                        &originatorCollection->polledDeviceTimerDPC);
        }
        else {
            TRAP;
        }
    }

    return status;
}



/*
 *  ReadPolledDevice
 *
 *      Issue a read to the polled device on behalf of the
 *  top-level collection indicated by pdoExt.
 *  (Note that because we keep separate polling loops for
 *   each collection, we do reads on behalf of specific collections).
 *
 */
BOOLEAN ReadPolledDevice(PDO_EXTENSION *pdoExt, BOOLEAN isTimerDrivenRead)
{
    BOOLEAN didPollDevice = FALSE;
    FDO_EXTENSION *fdoExt;
    PHIDP_COLLECTION_DESC hidCollectionDesc;

    fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    hidCollectionDesc = GetCollectionDesc(fdoExt, pdoExt->collectionNum);
    if (hidCollectionDesc){

        PIRP irp = IoAllocateIrp(fdoExt->fdo->StackSize, FALSE);
        if (irp){
            /*
             *  We cannot issue a read on a specific collection.
             *  But we'll allocate a buffer just large enough for a report
             *  on the collection we want.
             *  Note that hidCollectionDesc->InputLength includes
             *  the report id byte, which we may have to prepend ourselves.
             */
            ULONG reportLen = hidCollectionDesc->InputLength;

            irp->UserBuffer = ALLOCATEPOOL(NonPagedPool, reportLen);
            if (irp->UserBuffer){
                PIO_COMPLETION_ROUTINE completionRoutine;
                PIO_STACK_LOCATION nextStack = IoGetNextIrpStackLocation(irp);
                ASSERT(nextStack);

                if (fdoExt->deviceDesc.ReportIDs[0].ReportID == 0) {
                    /*
                     *  This device has only one report type,
                     *  so the minidriver will not include the 1-byte report id
                     *  (which is implicitly zero).
                     *  However, we still need to return a 'cooked' report,
                     *  with the report id, to the user; so bump the buffer
                     *  we pass down to make room for the report id.
                     */
                    *(((PUCHAR)irp->UserBuffer)++) = (UCHAR)0;
                    reportLen--;
                }

                nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_READ_REPORT;
                nextStack->Parameters.DeviceIoControl.OutputBufferLength = reportLen;
                irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

                completionRoutine = (isTimerDrivenRead) ?
                                    HidpPolledReadComplete_TimerDriven :
                                    HidpPolledReadComplete;

                IoSetCompletionRoutine( irp,
                                        completionRoutine,
                                        (PVOID)pdoExt,  // context
                                        TRUE,
                                        TRUE,
                                        TRUE );
                fdoExt->outstandingRequests++;
                HidpCallDriver(fdoExt->fdo, irp);
                didPollDevice = TRUE;
            }
        }
    }
    else {
        ASSERT(hidCollectionDesc);
    }

    return didPollDevice;
}


/*
 ********************************************************************************
 *  HidpPolledTimerDpc
 ********************************************************************************
 *
 *
 *
 */
VOID HidpPolledTimerDpc(    IN PKDPC Dpc,
                            IN PVOID DeferredContext,
                            IN PVOID SystemArgument1,
                            IN PVOID SystemArgument2
                        )
{
    PDO_EXTENSION *pdoExt = (PDO_EXTENSION *)DeferredContext;
    FDO_EXTENSION *fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    ASSERT(pdoExt->deviceFdoExt->Signature == HID_DEVICE_EXTENSION_SIG);

    if (pdoExt->state == COLLECTION_STATE_RUNNING){
        PHIDCLASS_COLLECTION hidCollection;

        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);

        if (hidCollection){
            KIRQL oldIrql;
            BOOLEAN haveReadIrpsQueued;
            BOOLEAN didPollDevice = FALSE;

            /*
             *  If there are reads pending on this collection,
             *  issue a read to the device.
             *
             *  Note:  we have no control over which collection we are reading.
             *         This read may end up returning a report for a different
             *         collection!  That's ok, since a report for this collection
             *         will eventually be returned.
             */
            KeAcquireSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, &oldIrql);
            haveReadIrpsQueued = !IsListEmpty(&hidCollection->polledDeviceReadQueue);
            KeReleaseSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, oldIrql);

            if (haveReadIrpsQueued){
                didPollDevice = ReadPolledDevice(pdoExt, TRUE);
            }
            else {
                /*
                 *  The timer period has expired, so any saved reports
                 *  are now stale.
                 */
                hidCollection->polledDataIsStale = TRUE;
            }

            /*
             *  If we actually polled the device, we'll reset the timer in the
             *  completion routine; otherwise, we do it here.
             */
            if (!didPollDevice){
                LARGE_INTEGER timeout;
                timeout.HighPart = -1;
                timeout.LowPart = -(LONG)(hidCollection->PollInterval_msec*10000);
                KeSetTimer( &hidCollection->polledDeviceTimer,
                            timeout,
                            &hidCollection->polledDeviceTimerDPC);
            }
        }
        else {
            TRAP;
        }
    }

}


/*
 ********************************************************************************
 *  StartPollingLoop
 ********************************************************************************
 *
 *  Start a polling loop for a particular collection.
 *
 */
BOOLEAN StartPollingLoop(   FDO_EXTENSION *fdoExt,
                            PHIDCLASS_COLLECTION hidCollection,
                            BOOLEAN freshQueue)
{
    ULONG ctnIndex = hidCollection->CollectionIndex;
    LARGE_INTEGER timeout;
    KIRQL oldIrql;

    if (freshQueue){
        InitializeListHead(&hidCollection->polledDeviceReadQueue);
        KeInitializeSpinLock(&hidCollection->polledDeviceReadQueueSpinLock);
        KeInitializeTimer(&hidCollection->polledDeviceTimer);
    }

    /*
     *  Use polledDeviceReadQueueSpinLock to protect the timer structures as well
     *  as the queue.
     */
    KeAcquireSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, &oldIrql);

    KeInitializeDpc(    &hidCollection->polledDeviceTimerDPC,
                        HidpPolledTimerDpc,
                        &fdoExt->collectionPdoExtensions[ctnIndex]->pdoExt);

    KeReleaseSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, oldIrql);

    timeout.HighPart = -1;
    timeout.LowPart = -(LONG)(hidCollection->PollInterval_msec*10000);
    KeSetTimer( &hidCollection->polledDeviceTimer,
                timeout,
                &hidCollection->polledDeviceTimerDPC);

    return TRUE;
}


/*
 ********************************************************************************
 *  StopPollingLoop
 ********************************************************************************
 *
 *
 *
 */
VOID StopPollingLoop(PHIDCLASS_COLLECTION hidCollection, BOOLEAN flushQueue)
{
    KIRQL oldIrql;

    /*
     *  Use polledDeviceReadQueueSpinLock to protect the timer structures as well
     *  as the queue.
     */
    KeAcquireSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, &oldIrql);

    KeCancelTimer(&hidCollection->polledDeviceTimer);
    KeInitializeTimer(&hidCollection->polledDeviceTimer);

    KeReleaseSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, oldIrql);

    /*
     *  Fail all the queued IRPs.
     */
    if (flushQueue){
        PIRP irp;
        LIST_ENTRY irpsToComplete;

        /*
         *  Move the IRPs to a temporary queue first so they don't get requeued
         *  on the completion thread and cause us to loop forever.
         */
        InitializeListHead(&irpsToComplete);
        while (irp = DequeuePolledReadIrp(hidCollection)){
            InsertTailList(&irpsToComplete, &irp->Tail.Overlay.ListEntry);
        }

        while (!IsListEmpty(&irpsToComplete)){
            PLIST_ENTRY listEntry = RemoveHeadList(&irpsToComplete);
            irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
            DBG_RECORD_READ(irp, 0, 0, TRUE)
            irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
            irp->IoStatus.Information = 0;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
        }
    }

}


/*
 ********************************************************************************
 *  PolledReadCancelRoutine
 ********************************************************************************
 *
 *  We need to set an IRP's cancel routine to non-NULL before
 *  we queue it; so just use a pointer this NULL function.
 *
 */
VOID PolledReadCancelRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    FDO_EXTENSION *fdoExt;
    PHIDCLASS_COLLECTION hidCollection;
    ULONG collectionIndex;
    KIRQL oldIrql;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    ASSERT(hidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(hidDeviceExtension->isClientPdo);
    fdoExt = &hidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    collectionIndex = hidDeviceExtension->pdoExt.collectionIndex;
    hidCollection = &fdoExt->classCollectionArray[collectionIndex];

    KeAcquireSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, &oldIrql);

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    ASSERT(hidCollection->numPendingReads > 0);
    hidCollection->numPendingReads--;

    KeReleaseSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, oldIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    DBG_RECORD_READ(Irp, 0, 0, TRUE)
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


NTSTATUS EnqueuePolledReadIrp(PHIDCLASS_COLLECTION collection, PIRP Irp)
{
    NTSTATUS status;
    KIRQL oldIrql;
    PDRIVER_CANCEL oldCancelRoutine;

    KeAcquireSpinLock(&collection->polledDeviceReadQueueSpinLock, &oldIrql);

    /*
     *  Must set a cancel routine before
     *  checking the Cancel flag.
     */
    oldCancelRoutine = IoSetCancelRoutine(Irp, PolledReadCancelRoutine);
    ASSERT(!oldCancelRoutine);

    /*
     *  Make sure this Irp wasn't just cancelled.
     *  Note that there is NO RACE CONDITION here
     *  because we are holding the fileExtension lock.
     */
    if (Irp->Cancel){
        /*
         *  This IRP was cancelled.
         */
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine){
            /*
             *  The cancel routine was NOT called.
             *  Return error so that caller completes the IRP.
             */
            DBG_RECORD_READ(Irp, IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length, 0, TRUE)
            ASSERT(oldCancelRoutine == PolledReadCancelRoutine);
            status = STATUS_CANCELLED;
        }
        else {
            /*
             *  The cancel routine was called.
             *  As soon as we drop the spinlock it will dequeue
             *  and complete the IRP.
             *  Initialize the IRP's listEntry so that the dequeue
             *  doesn't cause corruption.
             *  Then don't touch the irp.
             */
            InitializeListHead(&Irp->Tail.Overlay.ListEntry);
            collection->numPendingReads++;  // because cancel routine will decrement

            IoMarkIrpPending(Irp);
            status = Irp->IoStatus.Status = STATUS_PENDING;
        }
    }
    else {
        DBG_RECORD_READ(Irp, IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length, 0, FALSE)

        /*
         *  There are no reports waiting.
         *  Queue this irp onto the file extension's list of pending irps.
         */
        InsertTailList(&collection->polledDeviceReadQueue, &Irp->Tail.Overlay.ListEntry);
        collection->numPendingReads++;

        IoMarkIrpPending(Irp);
        status = Irp->IoStatus.Status = STATUS_PENDING;
    }

    KeReleaseSpinLock(&collection->polledDeviceReadQueueSpinLock, oldIrql);

    DBGSUCCESS(status, TRUE)
    return status;
}

PIRP DequeuePolledReadSystemIrp(PHIDCLASS_COLLECTION collection)
{
    KIRQL oldIrql;
    PIRP irp = NULL;
    PLIST_ENTRY listEntry;
    PHIDCLASS_FILE_EXTENSION    fileExtension;
    PFILE_OBJECT                fileObject;
    PIO_STACK_LOCATION irpSp;




    KeAcquireSpinLock(&collection->polledDeviceReadQueueSpinLock, &oldIrql);

    listEntry = &collection->polledDeviceReadQueue;

    while (!irp && ((listEntry = listEntry->Flink) != &collection->polledDeviceReadQueue)) {
        PDRIVER_CANCEL oldCancelRoutine;

        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        irpSp = IoGetCurrentIrpStackLocation(irp);

        fileObject = irpSp->FileObject;
        fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;

        if (!fileExtension->isSecureOpen) {
            irp = NULL;
            continue;
        }


        RemoveEntryList(listEntry);
        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);

        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == PolledReadCancelRoutine);
            ASSERT(collection->numPendingReads > 0);
            collection->numPendingReads--;
        }
        else {
            /*
             *  IRP was cancelled and cancel routine was called.
             *  As soon as we drop the spinlock,
             *  the cancel routine will dequeue and complete this IRP.
             *  Initialize the IRP's listEntry so that the dequeue doesn't cause corruption.
             *  Then, don't touch the IRP.
             */
            ASSERT(irp->Cancel);
            InitializeListHead(&irp->Tail.Overlay.ListEntry);
            irp = NULL;
        }
    }

    KeReleaseSpinLock(&collection->polledDeviceReadQueueSpinLock, oldIrql);

    return irp;
}

PIRP DequeuePolledReadIrp(PHIDCLASS_COLLECTION collection)
{
    KIRQL oldIrql;
    PIRP irp = NULL;

    KeAcquireSpinLock(&collection->polledDeviceReadQueueSpinLock, &oldIrql);

    while (!irp && !IsListEmpty(&collection->polledDeviceReadQueue)){
        PDRIVER_CANCEL oldCancelRoutine;
        PLIST_ENTRY listEntry = RemoveHeadList(&collection->polledDeviceReadQueue);

        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);

        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == PolledReadCancelRoutine);
            ASSERT(collection->numPendingReads > 0);
            collection->numPendingReads--;
        }
        else {
            /*
             *  IRP was cancelled and cancel routine was called.
             *  As soon as we drop the spinlock,
             *  the cancel routine will dequeue and complete this IRP.
             *  Initialize the IRP's listEntry so that the dequeue doesn't cause corruption.
             *  Then, don't touch the IRP.
             */
            ASSERT(irp->Cancel);
            InitializeListHead(&irp->Tail.Overlay.ListEntry);
            irp = NULL;
        }
    }

    KeReleaseSpinLock(&collection->polledDeviceReadQueueSpinLock, oldIrql);

    return irp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\remotewake.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: 

    wmi.c

Abstract

    Power handling

Author:

    jsenior

Environment:

    Kernel mode only

Revision History:


--*/


#include "pch.h"

#define WMI_WAIT_WAKE                0
#define WMI_SEL_SUSP                 0

//
// WMI System Call back functions
//
NTSTATUS
HidpIrpMajorSystemControl (
    IN  PHIDCLASS_DEVICE_EXTENSION  HidClassExtension,
    IN  PIRP                        Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and
    call into the WMI system library and let it handle this IRP for us.

--*/
{
    NTSTATUS            status;
    SYSCTL_IRP_DISPOSITION disposition;

    if (HidClassExtension->isClientPdo) {

        status = WmiSystemControl(&HidClassExtension->pdoExt.WmiLibInfo,
                                  HidClassExtension->pdoExt.pdo,
                                  Irp,
                                  &disposition);

    } else {
        
        status = WmiSystemControl(&HidClassExtension->fdoExt.WmiLibInfo,
                                  HidClassExtension->fdoExt.fdo,
                                  Irp,
                                  &disposition);
                
    }


    switch(disposition) {
    case IrpProcessed:
        //
        // This irp has been processed and may be completed or pending.
        //
        break;

    case IrpNotCompleted:
        //
        // This irp has not been completed, but has been fully processed.
        // we will complete it now
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case IrpForward:
    case IrpNotWmi:
        //
        // This irp is either not a WMI irp or is a WMI irp targetted
        // at a device lower in the stack.
        //
        status = HidpIrpMajorDefault(HidClassExtension, Irp);
        break;

    default:
        //
        // We really should never get here, but if we do just forward....
        //
        ASSERT(FALSE);
        status = HidpIrpMajorDefault(HidClassExtension, Irp);
        break;
    }

    return status;
}


VOID
HidpRemoteWakeComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    Catch the Wait wake Irp on its way back.

Return Value:

--*/
{
    PDO_EXTENSION           *pdoExt = Context;
    POWER_STATE             powerState;
    NTSTATUS                status;
    PHIDCLASS_WORK_ITEM_DATA    itemData;

    ASSERT (MinorFunction == IRP_MN_WAIT_WAKE);
    //
    // PowerState.SystemState is undefined when the WW irp has been completed
    //
    // ASSERT (PowerState.SystemState == PowerSystemWorking);

    InterlockedExchangePointer(&pdoExt->remoteWakeIrp, NULL);

    switch (IoStatus->Status) {
    case STATUS_SUCCESS:
        DBGVERBOSE(("HidClass: Remote Wake irp was completed successfully.\n"));

        //
        //  We do not need to request a set power to power up the device, since
        //  hidclass does this for us.
        //
/*        powerState.DeviceState = PowerDeviceD0;
        status = PoRequestPowerIrp(
                    pdoExt->PDO,
                    IRP_MN_SET_POWER,
                    powerState,
                    NULL,
                    NULL,
                    NULL);*/

        //
        // We do not notify the system that a user is present because:
        // 1  Win9x doesn't do this and we must maintain compatibility with it
        // 2  The USB PIX4 motherboards sends a wait wake event every time the
        //    machine wakes up, no matter if this device woke the machine or not
        // 
        // If we incorrectly notify the system a user is present, the following
        // will occur:
        // 1  The monitor will be turned on
        // 2  We will prevent the machine from transitioning from standby 
        //    (to PowerSystemWorking) to hibernate
        //
        // If a user is truly present, we will receive input in the service
        // callback and we will notify the system at that time.
        //
        // PoSetSystemState (ES_USER_PRESENT);

        if (pdoExt->remoteWakeEnabled) {
            //
            // We cannot call CreateWaitWake from this completion routine,
            // as it is a paged function.
            //
            itemData = (PHIDCLASS_WORK_ITEM_DATA)
                    ExAllocatePool (NonPagedPool, sizeof (HIDCLASS_WORK_ITEM_DATA));

            if (NULL != itemData) {
                itemData->Item = IoAllocateWorkItem(pdoExt->pdo);
                if (itemData->Item == NULL) {
                    ExFreePool(itemData);
                    DBGWARN (("Failed alloc work item -> no WW Irp."));
                } else {
                    itemData->PdoExt = pdoExt;
                    itemData->Irp = NULL;
                    status = IoAcquireRemoveLock (&pdoExt->removeLock, itemData);
                    if (NT_SUCCESS(status)) {
                        IoQueueWorkItem (itemData->Item,
                                         HidpCreateRemoteWakeIrpWorker,
                                         DelayedWorkQueue,
                                         itemData);
                    }
                    else {
                        //
                        // The device has been removed
                        //
                        IoFreeWorkItem (itemData->Item);
                        ExFreePool (itemData);
                    }
                }
            } else {
                //
                // Well, we dropped the WaitWake.
                //
                DBGWARN (("Failed alloc pool -> no WW Irp."));

            }
        }

        // fall through to the break

    //
    // We get a remove.  We will not (obviously) send another wait wake
    //
    case STATUS_CANCELLED:

    //
    // This status code will be returned if the device is put into a power state
    // in which we cannot wake the machine (hibernate is a good example).  When
    // the device power state is returned to D0, we will attempt to rearm wait wake
    //
    case STATUS_POWER_STATE_INVALID:
    case STATUS_ACPI_POWER_REQUEST_FAILED:

    //
    // We failed the Irp because we already had one queued, or a lower driver in
    // the stack failed it.  Either way, don't do anything.
    //
    case STATUS_INVALID_DEVICE_STATE:

    //
    // Somehow someway we got two WWs down to the lower stack.
    // Let's just don't worry about it.
    //
    case STATUS_DEVICE_BUSY:
        break;

    default:
        //
        // Something went wrong, disable the wait wake.
        //
        KdPrint(("KBDCLASS:  wait wake irp failed with %x\n", IoStatus->Status));
        HidpToggleRemoteWake (pdoExt, FALSE);
    }

}

BOOLEAN
HidpCheckRemoteWakeEnabled(
    IN PDO_EXTENSION *PdoExt
    )
{
    KIRQL irql;
    BOOLEAN enabled;

    KeAcquireSpinLock (&PdoExt->remoteWakeSpinLock, &irql);
    enabled = PdoExt->remoteWakeEnabled;
    KeReleaseSpinLock (&PdoExt->remoteWakeSpinLock, irql);

    return enabled;
}

void
HidpCreateRemoteWakeIrpWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PHIDCLASS_WORK_ITEM_DATA  ItemData
    )
{
    PAGED_CODE ();

    HidpCreateRemoteWakeIrp (ItemData->PdoExt);
    IoReleaseRemoveLock (&ItemData->PdoExt->removeLock, ItemData);
    IoFreeWorkItem(ItemData->Item);
    ExFreePool (ItemData);
}

BOOLEAN
HidpCreateRemoteWakeIrp (
    IN PDO_EXTENSION *PdoExt
    )
/*++

Routine Description:
    Catch the Wait wake Irp on its way back.

Return Value:

--*/
{
    POWER_STATE powerState;
    BOOLEAN     success = TRUE;
    NTSTATUS    status;
    PIRP        remoteWakeIrp;

    PAGED_CODE ();

    powerState.SystemState = PdoExt->deviceFdoExt->fdoExt.deviceCapabilities.SystemWake;
    status = PoRequestPowerIrp (PdoExt->pdo,
                                IRP_MN_WAIT_WAKE,
                                powerState,
                                HidpRemoteWakeComplete,
                                PdoExt,
                                &PdoExt->remoteWakeIrp);

    if (status != STATUS_PENDING) {
        success = FALSE;
    }

    return success;
}

VOID
HidpToggleRemoteWakeWorker(
    IN PDEVICE_OBJECT DeviceObject,
    PHIDCLASS_WORK_ITEM_DATA ItemData
    )
/*++

Routine Description:

--*/
{
    PDO_EXTENSION       *pdoExt;
    PIRP                remoteWakeIrp = NULL;
    KIRQL               irql;
    BOOLEAN             wwState = ItemData->RemoteWakeState ? TRUE : FALSE;
    BOOLEAN             toggled = FALSE;

    //
    // Can't be paged b/c we are using spin locks
    //
    // PAGED_CODE ();

    pdoExt = ItemData->PdoExt;

    KeAcquireSpinLock (&pdoExt->remoteWakeSpinLock, &irql);

    if (wwState != pdoExt->remoteWakeEnabled) {
        toggled = TRUE;
        if (pdoExt->remoteWakeEnabled) {
            remoteWakeIrp = (PIRP)
                InterlockedExchangePointer (&pdoExt->remoteWakeIrp, NULL);
        }
        
        pdoExt->remoteWakeEnabled = wwState;
    }

    KeReleaseSpinLock (&pdoExt->remoteWakeSpinLock, irql);

    if (toggled) {
        UNICODE_STRING strEnable;
        HANDLE         devInstRegKey;
        ULONG          tmp = wwState;

        //
        // write the value out to the registry
        //
        if ((NT_SUCCESS(IoOpenDeviceRegistryKey (pdoExt->pdo,
                                                 PLUGPLAY_REGKEY_DEVICE,
                                                 STANDARD_RIGHTS_ALL,
                                                 &devInstRegKey)))) {
            RtlInitUnicodeString (&strEnable, HIDCLASS_REMOTE_WAKE_ENABLE);

            ZwSetValueKey (devInstRegKey,
                           &strEnable,
                           0,
                           REG_DWORD,
                           &tmp,
                           sizeof(tmp));

            ZwClose (devInstRegKey);
        }
    }

    if (toggled && wwState) {
        //
        // wwState is our new state, so WW was just turned on
        //
        HidpCreateRemoteWakeIrp (pdoExt);
    }

    //
    // If we have an IRP, then WW has been toggled off, otherwise, if toggled is
    // TRUE, we need to save this in the reg and, perhaps, send down a new WW irp
    //
    if (remoteWakeIrp) {
        IoCancelIrp (remoteWakeIrp);
    }

    IoReleaseRemoveLock (&pdoExt->removeLock, HidpToggleRemoteWakeWorker);
    IoFreeWorkItem (ItemData->Item);
    ExFreePool (ItemData);
}

NTSTATUS
HidpToggleRemoteWake(
    PDO_EXTENSION       *PdoExt,
    BOOLEAN             RemoteWakeState
    )
{
    NTSTATUS       status;
    PHIDCLASS_WORK_ITEM_DATA itemData;

    status = IoAcquireRemoveLock (&PdoExt->removeLock, HidpToggleRemoteWakeWorker);
    if (!NT_SUCCESS (status)) {
        //
        // Device has gone away, just silently exit
        //
        return status;
    }

    itemData = (PHIDCLASS_WORK_ITEM_DATA)
        ALLOCATEPOOL(NonPagedPool, sizeof(HIDCLASS_WORK_ITEM_DATA));
    if (itemData) {
        itemData->Item = IoAllocateWorkItem(PdoExt->pdo);
        if (itemData->Item == NULL) {
            IoReleaseRemoveLock (&PdoExt->removeLock, HidpToggleRemoteWakeWorker);
        }
        else {
            itemData->PdoExt = PdoExt;
            itemData->RemoteWakeState = RemoteWakeState;

            if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
                //
                // We are safely at PASSIVE_LEVEL, call callback directly to perform
                // this operation immediately.
                //
                HidpToggleRemoteWakeWorker (PdoExt->pdo, itemData);

            } else {
                //
                // We are not at PASSIVE_LEVEL, so queue a workitem to handle this
                // at a later time.
                //
                IoQueueWorkItem (itemData->Item,
                                 HidpToggleRemoteWakeWorker,
                                 DelayedWorkQueue,
                                 itemData);
            }
        }
    }
    else {
        IoReleaseRemoveLock (&PdoExt->removeLock, HidpToggleRemoteWakeWorker);
    }

    return STATUS_SUCCESS;
}


VOID
HidpToggleSelSuspWorker(
    IN PDEVICE_OBJECT DeviceObject,
    PIO_WORKITEM WorkItem
    )
/*++

Routine Description:

--*/
{
    FDO_EXTENSION       *fdoExt;
    UNICODE_STRING strEnable;
    HANDLE         devInstRegKey;
    ULONG          tmp;

    fdoExt = &((PHIDCLASS_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->fdoExt;

    //
    // write the value out to the registry
    //

    tmp = fdoExt->idleEnabled ? TRUE : FALSE;

    if ((NT_SUCCESS(IoOpenDeviceRegistryKey (fdoExt->collectionPdoExtensions[0]->hidExt.PhysicalDeviceObject,
                                             PLUGPLAY_REGKEY_DEVICE,
                                             STANDARD_RIGHTS_ALL,
                                             &devInstRegKey)))) {

        RtlInitUnicodeString (&strEnable, HIDCLASS_SELECTIVE_SUSPEND_ON);

        ZwSetValueKey (devInstRegKey,
                       &strEnable,
                       0,
                       REG_DWORD,
                       &tmp,
                       sizeof(tmp));

        ZwClose (devInstRegKey);
        
    }

    IoFreeWorkItem (WorkItem);

}

NTSTATUS
HidpToggleSelSusp(
    FDO_EXTENSION       *FdoExt,
    BOOLEAN             SelSuspEnable
    )
{
    PIO_WORKITEM   workItem;
    BOOLEAN        oldState;
    KIRQL          oldIrql;
    

    KeAcquireSpinLock(&FdoExt->idleSpinLock,
                      &oldIrql);
    oldState = FdoExt->idleEnabled;
    FdoExt->idleEnabled = SelSuspEnable;

    KeReleaseSpinLock(&FdoExt->idleSpinLock,
                      oldIrql);

    if (oldState != SelSuspEnable) {

        if (!SelSuspEnable) {
            HidpCancelIdleNotification(FdoExt,
                                       FALSE);
        } else {
            HidpStartIdleTimeout(FdoExt,
                                 FALSE);
        }
    
        workItem = IoAllocateWorkItem(FdoExt->fdo);

        if(workItem) {

            if (KeGetCurrentIrql() == PASSIVE_LEVEL) {

                //
                // We are safely at PASSIVE_LEVEL, call callback directly to perform
                // this operation immediately.
                //
                HidpToggleSelSuspWorker (FdoExt->fdo, workItem);
                
            } else {
                //
                // We are not at PASSIVE_LEVEL, so queue a workitem to handle this
                // at a later time.
                //
                IoQueueWorkItem (workItem,
                                 HidpToggleSelSuspWorker,
                                 DelayedWorkQueue,
                                 workItem);

            }
            
        }
        
    }

    return STATUS_SUCCESS;
}



NTSTATUS
HidpSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PHIDCLASS_DEVICE_EXTENSION classExt;
    NTSTATUS            status;
    ULONG               size = 0;

    PAGED_CODE ();

    classExt = (PHIDCLASS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
    
    if (classExt->isClientPdo) {

        switch(GuidIndex) {
        case WMI_WAIT_WAKE:

            size = sizeof(BOOLEAN);

            if (BufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            } else if ((1 != DataItemId) || (0 != InstanceIndex)) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            status = HidpToggleRemoteWake (&classExt->pdoExt, *(PBOOLEAN) Buffer);
            break;

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

    } else {
        
        switch(GuidIndex) {
        case WMI_SEL_SUSP:

            size = sizeof(BOOLEAN);

            if (BufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            } else if ((1 != DataItemId) || (0 != InstanceIndex)) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            status = HidpToggleSelSusp (&classExt->fdoExt, *(PBOOLEAN) Buffer);
            break;

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            
        }

        
    }

    status = WmiCompleteRequest (DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_NO_INCREMENT);

    return status;
}

NTSTATUS
HidpSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PHIDCLASS_DEVICE_EXTENSION classExt;
    NTSTATUS          status;
    ULONG             size = 0;

    PAGED_CODE ();

    classExt = (PHIDCLASS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (classExt->isClientPdo) {
    
        switch(GuidIndex) {
        case WMI_WAIT_WAKE:

            size = sizeof(BOOLEAN);

            if (BufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            } else if (0 != InstanceIndex) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            status = HidpToggleRemoteWake (&classExt->pdoExt, *(PBOOLEAN) Buffer);
            break;

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;

        }

    } else {

        switch(GuidIndex) {
        case WMI_SEL_SUSP:

            size = sizeof(BOOLEAN);

            if (BufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            } else if (0 != InstanceIndex) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            status = HidpToggleSelSusp (&classExt->fdoExt, *(PBOOLEAN) Buffer);
            break;

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            
        }

    }

    status = WmiCompleteRequest (DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_NO_INCREMENT);

    return status;
}

NTSTATUS
HidpQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PHIDCLASS_DEVICE_EXTENSION classExt;
    NTSTATUS        status;
    ULONG           size = 0;

    PAGED_CODE ();

    classExt = (PHIDCLASS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (classExt->isClientPdo) {

        switch (GuidIndex) {
        case WMI_WAIT_WAKE:
            //
            // Only registers 1 instance for this guid
            //
            if ((0 != InstanceIndex) || (1 != InstanceCount)) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            size = sizeof(BOOLEAN);
    
            if (OutBufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            *(PBOOLEAN) Buffer = classExt->pdoExt.remoteWakeEnabled;
            *InstanceLengthArray = size;
            status = STATUS_SUCCESS;
            break;

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

    } else {

        switch(GuidIndex) {
        case WMI_SEL_SUSP:

            //
            // Only registers 1 instance for this guid
            //
            if ((0 != InstanceIndex) || (1 != InstanceCount)) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            size = sizeof(BOOLEAN);

            if (OutBufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            *(PBOOLEAN) Buffer = classExt->fdoExt.idleEnabled;
            *InstanceLengthArray = size;
            status = STATUS_SUCCESS;
            break;

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            
        }

    }


    status = WmiCompleteRequest (DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_NO_INCREMENT);

    return status;
}

NTSTATUS
HidpQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PHIDCLASS_DEVICE_EXTENSION classExt;
    PHIDCLASS_DRIVER_EXTENSION hidDriverExtension;
    PAGED_CODE ();

    classExt = (PHIDCLASS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (classExt->isClientPdo) {
    
        hidDriverExtension = (PHIDCLASS_DRIVER_EXTENSION) RefDriverExt(classExt->pdoExt.pdo->DriverObject);
        ASSERT(hidDriverExtension);

        *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
        *RegistryPath = &hidDriverExtension->RegistryPath;
        *Pdo = classExt->pdoExt.pdo;

        DerefDriverExt(classExt->pdoExt.pdo->DriverObject);

    } else {
  
        hidDriverExtension = classExt->fdoExt.driverExt;
        ASSERT(hidDriverExtension);

        *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
        *RegistryPath = &hidDriverExtension->RegistryPath;
        *Pdo = classExt->hidExt.PhysicalDeviceObject;    
        
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\read.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    read.c

Abstract

    Read handling routines

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"



/*
 ********************************************************************************
 *  HidpCancelReadIrp
 ********************************************************************************
 *
 *  If a queued read Irp gets cancelled by the user,
 *  this function removes it from our pending-read list.
 *
 */
VOID HidpCancelReadIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    FDO_EXTENSION *fdoExt;
    PHIDCLASS_COLLECTION collection;
    ULONG collectionIndex;
    KIRQL oldIrql;
    PIO_STACK_LOCATION irpSp;
    PHIDCLASS_FILE_EXTENSION fileExtension;

    ASSERT(hidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(hidDeviceExtension->isClientPdo);
    fdoExt = &hidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    collectionIndex = hidDeviceExtension->pdoExt.collectionIndex;
    collection = &fdoExt->classCollectionArray[collectionIndex];

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp->FileObject->Type == IO_TYPE_FILE);
    fileExtension = (PHIDCLASS_FILE_EXTENSION)irpSp->FileObject->FsContext;

    IoReleaseCancelSpinLock(Irp->CancelIrql);


    LockFileExtension(fileExtension, &oldIrql);

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    DBG_RECORD_READ(Irp, 0, 0, TRUE);
    ASSERT(collection->numPendingReads > 0);
    collection->numPendingReads--;

    UnlockFileExtension(fileExtension, oldIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


NTSTATUS EnqueueInterruptReadIrp(   PHIDCLASS_COLLECTION collection,
                                    PHIDCLASS_FILE_EXTENSION fileExtension,
                                    PIRP Irp)
{
    NTSTATUS status;
    PDRIVER_CANCEL oldCancelRoutine;

    RUNNING_DISPATCH();

    /*
     *  Must set a cancel routine before
     *  checking the Cancel flag.
     */
    oldCancelRoutine = IoSetCancelRoutine(Irp, HidpCancelReadIrp);
    ASSERT(!oldCancelRoutine);

    /*
     *  Make sure this Irp wasn't just cancelled.
     *  Note that there is NO RACE CONDITION here
     *  because we are holding the fileExtension lock.
     */
    if (Irp->Cancel){
        /*
         *  This IRP was cancelled.
         */
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine){
            /*
             *  The cancel routine was NOT called.
             *  Return error so that caller completes the IRP.
             */
            ASSERT(oldCancelRoutine == HidpCancelReadIrp);
            status = STATUS_CANCELLED;
        }
        else {
            /*
             *  The cancel routine was called.
             *  As soon as we drop the spinlock it will dequeue
             *  and complete the IRP.
             *  Initialize the IRP's listEntry so that the dequeue
             *  doesn't cause corruption.
             *  Then don't touch the irp.
             */
            InitializeListHead(&Irp->Tail.Overlay.ListEntry);
            collection->numPendingReads++;  // because cancel routine will decrement

            IoMarkIrpPending(Irp);
            status = Irp->IoStatus.Status = STATUS_PENDING;
        }
    }
    else {
        DBG_RECORD_READ(Irp, IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length, 0, FALSE)

        /*
         *  There are no reports waiting.
         *  Queue this irp onto the file extension's list of pending irps.
         */
        InsertTailList(&fileExtension->PendingIrpList, &Irp->Tail.Overlay.ListEntry);
        collection->numPendingReads++;

        IoMarkIrpPending(Irp);
        status = Irp->IoStatus.Status = STATUS_PENDING;
    }

    return status;
}


PIRP DequeueInterruptReadIrp(   PHIDCLASS_COLLECTION collection,
                                PHIDCLASS_FILE_EXTENSION fileExtension)
{
    PIRP irp = NULL;

    RUNNING_DISPATCH();

    while (!irp && !IsListEmpty(&fileExtension->PendingIrpList)){
        PDRIVER_CANCEL oldCancelRoutine;
        PLIST_ENTRY listEntry = RemoveHeadList(&fileExtension->PendingIrpList);

        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);

        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == HidpCancelReadIrp);
            ASSERT(collection->numPendingReads > 0);
            collection->numPendingReads--;
        }
        else {
            /*
             *  IRP was cancelled and cancel routine was called.
             *  As soon as we drop the spinlock,
             *  the cancel routine will dequeue and complete this IRP.
             *  Initialize the IRP's listEntry so that the dequeue doesn't cause corruption.
             *  Then, don't touch the IRP.
             */
            ASSERT(irp->Cancel);
            InitializeListHead(&irp->Tail.Overlay.ListEntry);
            irp = NULL;
        }
    }

    return irp;
}


/*
 ********************************************************************************
 *  HidpIrpMajorRead
 ********************************************************************************
 *
 *  Note: this function should not be pageable because
 *        reads can come in at dispatch level.
 *
 */
NTSTATUS HidpIrpMajorRead(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS status = STATUS_SUCCESS;
    FDO_EXTENSION *fdoExt;
    PDO_EXTENSION *pdoExt;
    PIO_STACK_LOCATION          irpSp;
    PHIDCLASS_FILE_EXTENSION    fileExtension;
    KIRQL oldIrql;

    ASSERT(HidDeviceExtension->isClientPdo);
    pdoExt = &HidDeviceExtension->pdoExt;
    fdoExt = &pdoExt->deviceFdoExt->fdoExt;
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Get our file extension.
     */
    if (!irpSp->FileObject ||
        (irpSp->FileObject &&
         !irpSp->FileObject->FsContext)) {
        DBGWARN(("Attempted read with no file extension"))
        Irp->IoStatus.Status = status = STATUS_PRIVILEGE_NOT_HELD;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
    ASSERT(irpSp->FileObject->Type == IO_TYPE_FILE);
    fileExtension = (PHIDCLASS_FILE_EXTENSION)irpSp->FileObject->FsContext;
    ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);

    /*
     *  Check security.
     *  The open must have been succeeded BY THIS DRIVER and
     *  (if this is a read on a keyboard or mouse)
     *  the client must be a kernel driver.
     */
    if (fileExtension->SecurityCheck && fileExtension->haveReadPrivilege){

        if (((fdoExt->state == DEVICE_STATE_START_SUCCESS) ||
             (fdoExt->state == DEVICE_STATE_STOPPING) ||
             (fdoExt->state == DEVICE_STATE_STOPPED))           &&
            ((pdoExt->state == COLLECTION_STATE_RUNNING) ||
             (pdoExt->state == COLLECTION_STATE_STOPPING) ||
             (pdoExt->state == COLLECTION_STATE_STOPPED))){

            ULONG                       collectionNum;
            PHIDCLASS_COLLECTION        classCollection;
            PHIDP_COLLECTION_DESC       collectionDesc;

            //
            // ISSUE: Is this safe to stop a polled collection like this?
            // interrupt driver collections have a restore read pump at power up
            // to D0, but I don't see any for polled collections...?
            //
            BOOLEAN isStopped = ((fdoExt->state == DEVICE_STATE_STOPPED)  ||
                                 (fdoExt->state == DEVICE_STATE_STOPPING)  ||
                                 (pdoExt->state == COLLECTION_STATE_STOPPING) ||
                                 (pdoExt->state == COLLECTION_STATE_STOPPED));

            Irp->IoStatus.Information = 0;


            /*
             *  Get our collection and collection description.
             */
            collectionNum = HidDeviceExtension->pdoExt.collectionNum;
            classCollection = GetHidclassCollection(fdoExt, collectionNum);
            collectionDesc = GetCollectionDesc(fdoExt, collectionNum);

            if (classCollection && collectionDesc){

                /*
                 *  Make sure the caller's read buffer is large enough to read at least one report.
                 */
                if (irpSp->Parameters.Read.Length >= collectionDesc->InputLength){

                    /*
                     *  We know we're going to try to transfer something into the caller's
                     *  buffer, so get the global address.  This will also serve to create
                     *  a mapped system address in the MDL if necessary.
                     */

                    if (classCollection->hidCollectionInfo.Polled){

                        /*
                         *  This is a POLLED collection.
                         */

                        #if DBG
                            if (fileExtension->isOpportunisticPolledDeviceReader &&
                                fileExtension->nowCompletingIrpForOpportunisticReader){
                                DBGWARN(("'Opportunistic' reader issuing read in completion routine"))
                            }
                        #endif

                        if (isStopped){
                            status = EnqueuePolledReadIrp(classCollection, Irp);
                        }
                        else if (fileExtension->isOpportunisticPolledDeviceReader &&
                            !classCollection->polledDataIsStale &&
                            !fileExtension->nowCompletingIrpForOpportunisticReader &&
                            (irpSp->Parameters.Read.Length >= classCollection->savedPolledReportLen)){

                            PUCHAR callersBuffer;

                            callersBuffer = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);

                            if (callersBuffer) {
                                ULONG userReportLength;
                                /*
                                 *  Use the polledDeviceReadQueueSpinLock to protect
                                 *  the savedPolledReportBuf.
                                 */
                                KeAcquireSpinLock(&classCollection->polledDeviceReadQueueSpinLock, &oldIrql);

                                /*
                                 *  This is an "opportunistic" reader who
                                 *  wants a result right away.
                                 *  We have a recent report,
                                 *  so just copy the last saved report.
                                 */
                                RtlCopyMemory(  callersBuffer,
                                                classCollection->savedPolledReportBuf,
                                                classCollection->savedPolledReportLen);
                                Irp->IoStatus.Information = userReportLength = classCollection->savedPolledReportLen;

                                KeReleaseSpinLock(&classCollection->polledDeviceReadQueueSpinLock, oldIrql);

                                DBG_RECORD_READ(Irp, userReportLength, (ULONG)callersBuffer[0], TRUE)
                                status = STATUS_SUCCESS;
                            }
                            else {
                                status = STATUS_INVALID_USER_BUFFER;
                            }
                        }
                        else {

                            status = EnqueuePolledReadIrp(classCollection, Irp);

                            /*
                             *  If this is an "opportunistic" polled
                             *  device reader, and we queued the irp,
                             *  make the read happen right away.
                             *  Make sure ALL SPINLOCKS ARE RELEASED
                             *  before we call out of the driver.
                             */
                            if (NT_SUCCESS(status) && fileExtension->isOpportunisticPolledDeviceReader){
                                ReadPolledDevice(pdoExt, FALSE);
                            }
                        }
                    }
                    else {

                        /*
                         *  This is an ordinary NON-POLLED collection.
                         *  We either:
                         *      1.  Satisfy this read with a queued report
                         *              or
                         *      2.  Queue this read IRP and satisfy it in the future
                         *          when a report comes in (on one of the ping-pong IRPs).
                         */

                        //
                        // We only stop interrupt devices when we power down.
                        //
                        if (fdoExt->devicePowerState != PowerDeviceD0) {
                            DBGINFO(("read report received in low power"));
                        }
                        isStopped |= (fdoExt->devicePowerState != PowerDeviceD0);

                        LockFileExtension(fileExtension, &oldIrql);
                        if (isStopped){
                            status = EnqueueInterruptReadIrp(classCollection, fileExtension, Irp);
                        } else {
                            ULONG userBufferRemaining = irpSp->Parameters.Read.Length;
                            PUCHAR callersBuffer;

                            callersBuffer = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);

                            if (callersBuffer) {
                                PUCHAR nextReportBuffer = callersBuffer;

                                /*
                                 *  There are some reports waiting.
                                 *
                                 *  Spin in this loop, filling up the caller's buffer with reports,
                                 *  until either the buffer fills up or we run out of reports.
                                 */
                                ULONG reportsReturned = 0;

                                status = STATUS_SUCCESS;

                                while (userBufferRemaining > 0){
                                    PHIDCLASS_REPORT reportExtension;
                                    ULONG reportSize = userBufferRemaining;

                                    reportExtension = DequeueInterruptReport(fileExtension, userBufferRemaining);
                                    if (reportExtension){
                                        status = HidpCopyInputReportToUser( fileExtension,
                                                                            reportExtension->UnparsedReport,
                                                                            &reportSize,
                                                                            nextReportBuffer);

                                        /*
                                         *  Whether we succeeded or failed, free this report.
                                         *  (If we failed, there may be something wrong with
                                         *   the report, so we'll just throw it away).
                                         */
                                        ExFreePool(reportExtension);

                                        if (NT_SUCCESS(status)){
                                            reportsReturned++;
                                            nextReportBuffer += reportSize;
                                            ASSERT(reportSize <= userBufferRemaining);
                                            userBufferRemaining -= reportSize;
                                        } else {
                                            DBGSUCCESS(status, TRUE)
                                            break;
                                        }
                                    } else {
                                        break;
                                    }
                                }

                                if (NT_SUCCESS(status)){
                                    if (!reportsReturned) {
                                        /*
                                         *  No reports are ready.  So queue the read IRP.
                                         */
                                        status = EnqueueInterruptReadIrp(classCollection, fileExtension, Irp);
                                    } else {
                                        /*
                                         *  We've succesfully copied something into the user's buffer,
                                         *  calculate how much we've copied and return in the irp.
                                         */
                                        Irp->IoStatus.Information = (ULONG)(nextReportBuffer - callersBuffer);
                                        DBG_RECORD_READ(Irp, (ULONG)Irp->IoStatus.Information, (ULONG)callersBuffer[0], TRUE)
                                    }
                                }
                            }
                            else {
                                status = STATUS_INVALID_USER_BUFFER;
                            }
                        }
                        UnlockFileExtension(fileExtension, oldIrql);
                    }
                } else {
                    status = STATUS_INVALID_BUFFER_SIZE;
                }
            }
            else {
                status = STATUS_DEVICE_NOT_CONNECTED;
            }

            DBGSUCCESS(status, TRUE)
        }
        else {
            /*
             *  This can legitimately happen.
             *  The device was disconnected between the client's open and read;
             *  or between a read-complete and the next read.
             */
            status = STATUS_DEVICE_NOT_CONNECTED;
        }
    }
    else {
        DBGWARN(("HidpIrpMajorRead: user-mode client does not have read privilege"))
        status = STATUS_PRIVILEGE_NOT_HELD;
    }


    /*
     *  If we satisfied the read Irp (did not queue it),
     *  then complete it here.
     */
    if (status != STATUS_PENDING){
        ULONG insideReadCompleteCount;

        Irp->IoStatus.Status = status;

        insideReadCompleteCount = InterlockedIncrement(&fileExtension->insideReadCompleteCount);
        if (insideReadCompleteCount <= INSIDE_READCOMPLETE_MAX){
            IoCompleteRequest(Irp, IO_KEYBOARD_INCREMENT);
        }
        else {
            /*
             *  All these nested reads are _probably_ occuring on the same thread,
             *  and we are going to run out of stack and crash if we keep completing
             *  synchronously.  So return pending for this IRP and schedule a workItem
             *  to complete it asynchronously, just to give the stack a chance to unwind.
             */
            ASYNC_COMPLETE_CONTEXT *asyncCompleteContext = ALLOCATEPOOL(NonPagedPool, sizeof(ASYNC_COMPLETE_CONTEXT));
            if (asyncCompleteContext){
                ASSERT(!Irp->CancelRoutine);
                DBGWARN(("HidpIrpMajorRead: CLIENT IS LOOPING ON READ COMPLETION -- scheduling workItem to complete IRP %ph (status=%xh) asynchronously", Irp, status))
                ExInitializeWorkItem(   &asyncCompleteContext->workItem,
                                        WorkItemCallback_CompleteIrpAsynchronously,
                                        asyncCompleteContext);
                asyncCompleteContext->sig = ASYNC_COMPLETE_CONTEXT_SIG;
                asyncCompleteContext->irp = Irp;
                asyncCompleteContext->devObj = pdoExt->pdo;
                ObReferenceObject(pdoExt->pdo);
                ExQueueWorkItem(&asyncCompleteContext->workItem, DelayedWorkQueue);

                status = STATUS_PENDING;
            }
            else {
                DBGERR(("HidpIrpMajorRead: completeIrpWorkItem alloc failed"))
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
        }

        InterlockedDecrement(&fileExtension->insideReadCompleteCount);
    }

    DBGSUCCESS(status, FALSE)
    return status;
}



VOID WorkItemCallback_CompleteIrpAsynchronously(PVOID context)
{
    ASYNC_COMPLETE_CONTEXT *asyncCompleteContext = context;

    ASSERT(asyncCompleteContext->sig == ASYNC_COMPLETE_CONTEXT_SIG);
    DBGVERBOSE(("WorkItemCallback_CompleteIrpAsynchronously: completing irp %ph with status %xh.", asyncCompleteContext->irp, asyncCompleteContext->irp->IoStatus.Status))

    /*
     *  Indicate that the irp may be completing
     */
    IoMarkIrpPending(asyncCompleteContext->irp);

    IoCompleteRequest(asyncCompleteContext->irp, IO_NO_INCREMENT);

    ObDereferenceObject(asyncCompleteContext->devObj);

    ExFreePool(asyncCompleteContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\security.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    security.c

Abstract

    Security routines.

    Note: This file uses NTDDK.H, which is blocked out by WDM.H .
          So it does not include PCH.H et al.

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"


#if !WIN95_BUILD
    /*
     *  Copied from ntrtl.h, which won't compile here.
     */
    __inline LUID RtlConvertLongToLuid(LONG Long)
    {
        LUID TempLuid;
        LARGE_INTEGER TempLi;

        TempLi = RtlConvertLongToLargeInteger(Long);
        TempLuid.LowPart = TempLi.LowPart;
        TempLuid.HighPart = TempLi.HighPart;
        return(TempLuid);
    }

    NTKERNELAPI BOOLEAN SeSinglePrivilegeCheck(LUID PrivilegeValue, KPROCESSOR_MODE PreviousMode);

#endif


BOOLEAN MyPrivilegeCheck(PIRP Irp)
{
    BOOLEAN result;
    
    #if DBG
        if (dbgSkipSecurity){
            return TRUE;
        }
    #endif

    #if WIN95_BUILD
        result = TRUE;
    #else
        {
            #ifndef SE_TCB_PRIVILEGE
                #define SE_TCB_PRIVILEGE (7L)
            #endif
            LUID priv = RtlConvertLongToLuid(SE_TCB_PRIVILEGE);
            result = SeSinglePrivilegeCheck(priv, Irp->RequestorMode);
        }
    #endif

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract

    Internal utility functions for the HID class driver.

Authors:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, HidpAddDevice)
        #pragma alloc_text(PAGE, HidpDriverUnload)
        #pragma alloc_text(PAGE, HidpGetDeviceDescriptor)
        #pragma alloc_text(PAGE, HidpQueryDeviceCapabilities)
        #pragma alloc_text(PAGE, HidpQueryIdForClientPdo)
        #pragma alloc_text(PAGE, SubstituteBusNames)
        #pragma alloc_text(PAGE, BuildCompatibleID)
        #pragma alloc_text(PAGE, HidpQueryCollectionCapabilities)
        #pragma alloc_text(PAGE, HidpQueryDeviceRelations)
        #pragma alloc_text(PAGE, HidpCreateClientPDOs)
        #pragma alloc_text(PAGE, MakeClientPDOName)
        #pragma alloc_text(PAGE, HidpCreateSymbolicLink)
        #pragma alloc_text(PAGE, HidpQueryInterface)
#endif



/*
 ********************************************************************************
 *  HidpCopyInputReportToUser
 ********************************************************************************
 *
 *  Copy a read report into a user's buffer.
 *
 *  Note:  ReportData is already "cooked" (already has report-id byte at start of report).
 *
 */
NTSTATUS HidpCopyInputReportToUser(
    IN PHIDCLASS_FILE_EXTENSION FileExtension,
    IN PUCHAR ReportData,
    IN OUT PULONG UserBufferLen,
    OUT PUCHAR UserBuffer
    )
{
    NTSTATUS result = STATUS_DEVICE_DATA_ERROR;
    ULONG reportId;
    PHIDP_REPORT_IDS reportIdentifier;
    FDO_EXTENSION *fdoExtension = FileExtension->fdoExt;

    RUNNING_DISPATCH();

    ASSERT(fdoExtension->deviceDesc.CollectionDescLength > 0);

    reportId = (ULONG)*ReportData;

    reportIdentifier = GetReportIdentifier(fdoExtension, reportId);
    if (reportIdentifier){
        PHIDP_COLLECTION_DESC collectionDesc;
        PHIDCLASS_COLLECTION hidpCollection;

        collectionDesc = GetCollectionDesc(fdoExtension, reportIdentifier->CollectionNumber);
        hidpCollection = GetHidclassCollection(fdoExtension, reportIdentifier->CollectionNumber);

        if (collectionDesc && hidpCollection){
            ULONG reportLength = collectionDesc->InputLength;

            if (*UserBufferLen >= reportLength){
                RtlCopyMemory(UserBuffer, ReportData, reportLength);
                result = STATUS_SUCCESS;
            }
            else {
                result = STATUS_INVALID_BUFFER_SIZE;
            }

            /*
             *  Return the actual length of the report (whether we copied or not).
             */
            *UserBufferLen = reportLength;
        }
    }

    ASSERT((result == STATUS_SUCCESS) || (result == STATUS_INVALID_BUFFER_SIZE));
    return result;
}





/*
 ********************************************************************************
 *  HidpAddDevice
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       This routine is called by configmgr when a new PDO is dected.
 *       It creates an Functional Device Object (FDO) and attaches it to the
 *       PDO.
 *
 *   Arguments:
 *
 *       DriverObject - pointer to the minidriver's driver object.
 *
 *       PhysicalDeviceObject - pointer to the PDO that the minidriver got in it's
 *                              AddDevice() routine.
 *
 *   Return Value:
 *
 *      Standard NT return value.
 *
 */
NTSTATUS HidpAddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PhysicalDeviceObject)
{
    PHIDCLASS_DRIVER_EXTENSION  hidDriverExtension;
    PHIDCLASS_DEVICE_EXTENSION  hidClassExtension;
    NTSTATUS                    status;
    UNICODE_STRING              uPdoName;
    PWSTR                       wPdoName;
    PVOID                       miniDeviceExtension;
    ULONG                       totalExtensionSize;
    ULONG                       thisHidId;
    PDEVICE_OBJECT              functionalDeviceObject;

    PAGED_CODE();

    DBG_COMMON_ENTRY()

    DBG_RECORD_DEVOBJ(PhysicalDeviceObject, "minidrvr PDO")


    //
    // Get a pointer to our per-driver extension, make sure it's one of ours.
    //

    hidDriverExtension = RefDriverExt(DriverObject);
    if (hidDriverExtension){

        ASSERT(DriverObject == hidDriverExtension->MinidriverObject);

        //
        // Construct a name for the FDO.  The only requirement, really, is
        // that it's unique.  For now we'll call them "_HIDx", where 'x' is some
        // unique number.
        //

        /*
         *  PDO name has form "\Device\_HIDx".
         */
        wPdoName = ALLOCATEPOOL(NonPagedPool, sizeof(L"\\Device\\_HID00000000"));
        if (wPdoName){

            //
            // Get the current value of NextHidId and increment it.  Since
            // InterlockedIncrement() returns the incremented value, subtract one to
            // get the pre-increment value of NextHidId;
            //
            thisHidId = InterlockedIncrement(&HidpNextHidNumber) - 1;
            swprintf(wPdoName, L"\\Device\\_HID%08x", thisHidId);
            RtlInitUnicodeString(&uPdoName, wPdoName);

            //
            // We've got a counted-string version of the device object name.  Calculate
            // the total size of the device extension and create the FDO.
            //
            totalExtensionSize = sizeof(HIDCLASS_DEVICE_EXTENSION) +
                                 hidDriverExtension->DeviceExtensionSize;

            status = IoCreateDevice( DriverObject,          // driver object
                                     totalExtensionSize,    // extension size
                                     &uPdoName,             // name of the FDO
                                     FILE_DEVICE_UNKNOWN,   // what the hell
                                     0,                     // DeviceCharacteristics
                                     FALSE,                 // not exclusive
                                     &functionalDeviceObject );

            if (NT_SUCCESS(status)){

                DBG_RECORD_DEVOBJ(functionalDeviceObject, "device FDO")

                ObReferenceObject(functionalDeviceObject);

                ASSERT(DriverObject->DeviceObject == functionalDeviceObject);
                ASSERT(functionalDeviceObject->DriverObject == DriverObject);


                //
                // We've created the device object.  Fill in the minidriver's extension
                // pointer and attach this FDO to the PDO.
                //

                hidClassExtension = functionalDeviceObject->DeviceExtension;
                RtlZeroMemory(hidClassExtension, totalExtensionSize);

                hidClassExtension->isClientPdo = FALSE;

                //
                //  Assign the name of the minidriver's PDO to our FDO.
                //
                hidClassExtension->fdoExt.name = uPdoName;

                //
                // The minidriver extension lives in the device extension and starts
                // immediately after our HIDCLASS_DEVICE_EXTENSION structure.  Note
                // that the first structure in the HIDCLASS_DEVICE_EXTENSION is the
                // public HID_DEVICE_EXTENSION structure, which is where the pointer
                // to the minidriver's per-device extension area lives.
                //

                miniDeviceExtension = (PVOID)(hidClassExtension + 1);
                hidClassExtension->hidExt.MiniDeviceExtension = miniDeviceExtension;

                //
                // Get a pointer to the physical device object passed in.  This device
                // object should already have the DO_DEVICE_INITIALIZING flag cleared.
                //

                ASSERT( (PhysicalDeviceObject->Flags & DO_DEVICE_INITIALIZING) == 0 );

                //
                // Attach the FDO to the PDO, storing the device object at the top of the
                // stack in our device extension.
                //

                hidClassExtension->hidExt.NextDeviceObject =
                    IoAttachDeviceToDeviceStack( functionalDeviceObject,
                                                 PhysicalDeviceObject );


                ASSERT(DriverObject->DeviceObject == functionalDeviceObject);
                ASSERT(functionalDeviceObject->DriverObject == DriverObject);

                //
                // The functional device requires two stack locations: one for the class
                // driver, and one for the minidriver.
                //

                functionalDeviceObject->StackSize++;

                //
                // We'll need a pointer to the physical device object as well for PnP
                // purposes.  Note that it's a virtual certainty that NextDeviceObject
                // and PhysicalDeviceObject are identical.
                //

                hidClassExtension->hidExt.PhysicalDeviceObject = PhysicalDeviceObject;
                hidClassExtension->Signature = HID_DEVICE_EXTENSION_SIG;
                hidClassExtension->fdoExt.fdo = functionalDeviceObject;
                hidClassExtension->fdoExt.driverExt = hidDriverExtension;
                hidClassExtension->fdoExt.outstandingRequests = 0;
                hidClassExtension->fdoExt.openCount = 0;
                hidClassExtension->fdoExt.state = DEVICE_STATE_INITIALIZED;

                //
                // Selective suspend portion.
                //
                hidClassExtension->fdoExt.idleState = IdleDisabled;
                hidClassExtension->fdoExt.idleTimeoutValue = BAD_POINTER;
                KeInitializeSpinLock(&hidClassExtension->fdoExt.idleNotificationSpinLock);
                KeInitializeEvent(&hidClassExtension->fdoExt.idleDoneEvent, NotificationEvent, TRUE);
                hidClassExtension->fdoExt.idleNotificationRequest = BAD_POINTER;
                hidClassExtension->fdoExt.idleCallbackInfo.IdleCallback = HidpIdleNotificationCallback;
                hidClassExtension->fdoExt.idleCallbackInfo.IdleContext = (PVOID) hidClassExtension;

                hidClassExtension->fdoExt.systemPowerState = PowerSystemWorking;
                hidClassExtension->fdoExt.devicePowerState = PowerDeviceD0;

                hidClassExtension->fdoExt.waitWakeIrp = BAD_POINTER;
                KeInitializeSpinLock(&hidClassExtension->fdoExt.waitWakeSpinLock);
                hidClassExtension->fdoExt.isWaitWakePending = FALSE;

                InitializeListHead(&hidClassExtension->fdoExt.collectionWaitWakeIrpQueue);
                KeInitializeSpinLock(&hidClassExtension->fdoExt.collectionWaitWakeIrpQueueSpinLock);

                InitializeListHead(&hidClassExtension->fdoExt.collectionPowerDelayedIrpQueue);
                KeInitializeSpinLock(&hidClassExtension->fdoExt.collectionPowerDelayedIrpQueueSpinLock);
                hidClassExtension->fdoExt.numPendingPowerDelayedIrps = 0;

                hidClassExtension->fdoExt.BusNumber = thisHidId;

                #if DBG
                    InitFdoExtDebugInfo(hidClassExtension);
                #endif

                EnqueueFdoExt(&hidClassExtension->fdoExt);

                /*
                 *  Indicate that this device object does direct I/O.
                 *
                 *  Set the flag that causes the IO subsystem to decrement the device
                 *  object's reference count *before* sending down IRP_MJ_CLOSEs.  We
                 *  need this because we delete the device object on the last close.
                 */
                functionalDeviceObject->Flags |= DO_DIRECT_IO;

                /*
                 *  The DO_POWER_PAGABLE bit of a device object
                 *  indicates to the kernel that the power-handling
                 *  code of the corresponding driver is pageable, and
                 *  so must be called at IRQL 0.
                 *  As a filter driver, we do not want to change the power
                 *  behavior of the driver stack in any way; therefore,
                 *  we copy this bit from the lower device object.
                 */
                functionalDeviceObject->Flags |= (PhysicalDeviceObject->Flags & DO_POWER_PAGABLE);

                /*
                 *  Must clear the initializing flag after initialization complete.
                 */
                functionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;


                ReadDeviceFlagsFromRegistry(&hidClassExtension->fdoExt,
                                            PhysicalDeviceObject);


                //
                // Since we have NOT seen a start device, we CANNOT send any non
                // pnp irps to the device yet.  We need to do that in the start
                // device requests.
                //


                //
                // Call the minidriver to let it do any extension initialization
                //

                status = hidDriverExtension->AddDevice(DriverObject, functionalDeviceObject);

                if (!NT_SUCCESS(status)) {
                    DequeueFdoExt(&hidClassExtension->fdoExt);
                    IoDetachDevice(hidClassExtension->hidExt.NextDeviceObject);
                    ObDereferenceObject(functionalDeviceObject);
                    IoDeleteDevice(functionalDeviceObject);
                    ExFreePool( wPdoName );
                }
            }
            else {
                TRAP;
                ExFreePool( wPdoName );
            }
        }
        else {
            TRAP;
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (!NT_SUCCESS(status)){
            DerefDriverExt(DriverObject);
        }
    }
    else {
        ASSERT(hidDriverExtension);
        status = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    DBGSUCCESS(status, TRUE)
    DBG_COMMON_EXIT()
    return status;
}



/*
 ********************************************************************************
 *  HidpDriverUnload
 ********************************************************************************
 *
 *
 */
VOID HidpDriverUnload(IN struct _DRIVER_OBJECT *minidriverObject)
{
    PHIDCLASS_DRIVER_EXTENSION hidDriverExt;

    PAGED_CODE();

    DBG_COMMON_ENTRY()

    /*
     *  This extra de-reference will cause our hidDriverExtension's
     *  reference count to eventually go to -1; at that time, we'll
     *  dequeue it.
     */
    hidDriverExt = DerefDriverExt(minidriverObject);
    ASSERT(hidDriverExt);

    /*
     *  Chain the unload call to the minidriver.
     */
    hidDriverExt->DriverUnload(minidriverObject);

    DBG_COMMON_EXIT()
}


NTSTATUS GetHIDRawReportDescriptor(FDO_EXTENSION *fdoExt, PIRP irp, ULONG descriptorLen)
{
    NTSTATUS status;

    if (descriptorLen){
        PUCHAR rawReportDescriptor = ALLOCATEPOOL(NonPagedPool, descriptorLen);

        if (rawReportDescriptor){
            const ULONG retries = 3;
            ULONG i;

            for (i = 0; i < retries; i++){
                PIO_STACK_LOCATION irpSp;

                irp->UserBuffer = rawReportDescriptor;
                irpSp = IoGetNextIrpStackLocation(irp);

                ASSERT(irpSp->Parameters.DeviceIoControl.InputBufferLength == 0);
                ASSERT(irpSp->Parameters.DeviceIoControl.Type3InputBuffer == NULL);
                irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                irpSp->Parameters.DeviceIoControl.OutputBufferLength = descriptorLen;
                irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_GET_REPORT_DESCRIPTOR;

                //
                // Call the minidriver to get the report descriptor.
                //
                status = HidpCallDriverSynchronous(fdoExt->fdo, irp);
                if (NT_SUCCESS(status)){
                    if (irp->IoStatus.Information == descriptorLen){
                        fdoExt->rawReportDescriptionLength = descriptorLen;
                        fdoExt->rawReportDescription = rawReportDescriptor;
                        break;
                    } else {
                        DBGWARN(("GetHIDRawReportDescriptor (attempt #%d) returned %xh/%xh bytes", i, irp->IoStatus.Information, descriptorLen))
                        status = STATUS_DEVICE_DATA_ERROR;
                    }
                } else {
                    DBGWARN(("GetHIDRawReportDescriptor (attempt #%d) failed with status %xh.", i, status))
                }
            }

            if (!NT_SUCCESS(status)){
                DBGWARN(("GetHIDRawReportDescriptor failed %d times.", retries))
                ExFreePool(rawReportDescriptor);
            }

        } else {
            DBGWARN(("alloc failed in GetHIDRawReportDescriptor"))
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        DBGWARN(("GetHIDRawReportDescriptor: descriptorLen is zero."))
        status = STATUS_DEVICE_DATA_ERROR;
    }

    DBGSUCCESS(status, FALSE)
    return status;
}



/*
 ********************************************************************************
 *  HidpGetDeviceDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpGetDeviceDescriptor(FDO_EXTENSION *fdoExtension)
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PHID_DESCRIPTOR hidDescriptor;
    ULONG rawReportDescriptorLength;

    PAGED_CODE();


    /*
     *  Retrieve:
     *
     *      1. Device descriptor (fixed portion)
     *      2. Device attributes
     *      3. Report descriptor
     */

    hidDescriptor = &fdoExtension->hidDescriptor;

    irp = IoAllocateIrp(fdoExtension->fdo->StackSize, FALSE);
    if (irp){
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_GET_DEVICE_DESCRIPTOR;

        /*
         *  This IOCTL uses buffering type METHOD_NEITHER, so
         *  the buffer is simply passed in irp->UserBuffer.
         */
        irp->UserBuffer = hidDescriptor;
        irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(HID_DESCRIPTOR);
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        status = HidpCallDriverSynchronous(fdoExtension->fdo, irp);
        DBGASSERT((status == STATUS_SUCCESS),
                  ("STATUS_SUCCESS not returned, %x returned",status),
                  TRUE)

        if (status == STATUS_SUCCESS){

            if (irp->IoStatus.Information == sizeof(HID_DESCRIPTOR)){

                irpSp = IoGetNextIrpStackLocation(irp);

                ASSERT(irpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL);
                ASSERT(irpSp->Parameters.DeviceIoControl.InputBufferLength == 0);
                ASSERT(!irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

                irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_GET_DEVICE_ATTRIBUTES;

                irp->UserBuffer = &fdoExtension->hidDeviceAttributes;
                irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(HID_DEVICE_ATTRIBUTES);

                status = HidpCallDriverSynchronous(fdoExtension->fdo, irp);
                DBGASSERT((status == STATUS_SUCCESS),
                          ("STATUS_SUCCESS not returned, %x returned",status),
                          TRUE)

                if (NT_SUCCESS (status)) {
                    ULONG i;

                    /*
                     *  We've got a hid descriptor, now we need to read the report descriptor.
                     *
                     *  Find the descriptor describing the report.
                     */
                    rawReportDescriptorLength = 0;
                    for (i = 0; i < hidDescriptor->bNumDescriptors; i++){
                        if (hidDescriptor->DescriptorList[i].bReportType == HID_REPORT_DESCRIPTOR_TYPE){
                            rawReportDescriptorLength = (ULONG)hidDescriptor->DescriptorList[i].wReportLength;
                            break;
                        }
                    }

                    status = GetHIDRawReportDescriptor(fdoExtension, irp, rawReportDescriptorLength);
                }
                else {
                    status = STATUS_DEVICE_DATA_ERROR;
                }
            }
            else {
                status = STATUS_DEVICE_DATA_ERROR;
            }
        }
        else {
            status = STATUS_DEVICE_DATA_ERROR;
        }

        IoFreeIrp(irp);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGSUCCESS(status, FALSE)
    return status;
}



/*
 ********************************************************************************
 *  HidpCreateSymbolicLink
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpCreateSymbolicLink(
    IN PDO_EXTENSION *pdoExt,
    IN ULONG collectionNum,
    IN BOOLEAN Create,
    IN PDEVICE_OBJECT Pdo
    )
{
    NTSTATUS status;
    PHIDCLASS_COLLECTION classCollection;

    PAGED_CODE();

    classCollection = GetHidclassCollection(&pdoExt->deviceFdoExt->fdoExt, collectionNum);
    if (classCollection){
        //
        // We've got a collection.  Figure out what it is and create a symbolic
        // link for it.  For now we assign the "input" guid to all hid devices.
        // The reference string is simply the collection number, zero-padded
        // to eight digits.
        //
        if (Create){

            /*
             *  Mark the PDO as initialized
             */
            Pdo->Flags |= DO_DIRECT_IO;
            Pdo->Flags &= ~DO_DEVICE_INITIALIZING;

            /*
             *  Create the symbolic link
             */
            status = IoRegisterDeviceInterface(
                        Pdo,
                        (LPGUID)&GUID_CLASS_INPUT,
                        NULL,
                        &classCollection->SymbolicLinkName );
            if (NT_SUCCESS(status)){

                /*
                 *  Now set the symbolic link for the association and store it..
                 */
                ASSERT(ISPTR(pdoExt->name));

                status = IoSetDeviceInterfaceState(&classCollection->SymbolicLinkName, TRUE);
            }
        }
        else {

            /*
             *  Disable the symbolic link
             */
            if (ISPTR(classCollection->SymbolicLinkName.Buffer)){
                status = IoSetDeviceInterfaceState(&classCollection->SymbolicLinkName, FALSE);
                ExFreePool( classCollection->SymbolicLinkName.Buffer );
                classCollection->SymbolicLinkName.Buffer = BAD_POINTER;
            }
            else {
                status = STATUS_SUCCESS;
            }
        }
    }
    else {
        status = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    DBGSUCCESS(status, TRUE)
    return status;
}





/*
 ********************************************************************************
 *  EnqueueInterruptReport
 ********************************************************************************
 *
 *
 */
VOID EnqueueInterruptReport(PHIDCLASS_FILE_EXTENSION fileExtension,
                            PHIDCLASS_REPORT report)
{
    PHIDCLASS_REPORT reportToDrop = NULL;

    RUNNING_DISPATCH();

    /*
     *  If the queue is full, drop the oldest report.
     */
    if (fileExtension->CurrentInputReportQueueSize >= fileExtension->MaximumInputReportQueueSize){
        PLIST_ENTRY listEntry;

        #if DBG
            if (fileExtension->dbgNumReportsDroppedSinceLastRead++ == 0){
                DBGWARN(("HIDCLASS dropping input reports because report queue (size %xh) is full ...", fileExtension->MaximumInputReportQueueSize))
                DBGASSERT((fileExtension->CurrentInputReportQueueSize == fileExtension->MaximumInputReportQueueSize),
                          ("Current report queue size (%xh) is greater than maximum (%xh)",
                           fileExtension->CurrentInputReportQueueSize,
                           fileExtension->MaximumInputReportQueueSize),
                          FALSE);
            }
        #endif

        ASSERT(!IsListEmpty(&fileExtension->ReportList));

        listEntry = RemoveHeadList(&fileExtension->ReportList);
        reportToDrop = CONTAINING_RECORD(listEntry, HIDCLASS_REPORT, ListEntry);
        fileExtension->CurrentInputReportQueueSize--;
    }

    /*
     *  Now queue the current report
     */
    InsertTailList(&fileExtension->ReportList, &report->ListEntry);
    fileExtension->CurrentInputReportQueueSize++;

    /*
     *  We don't have to be running < DPC_LEVEL to release reports since they
     * are allocated using NonPagePool.
     */
    if (reportToDrop){
        ExFreePool(reportToDrop);
    }

}



/*
 ********************************************************************************
 *  DequeueInterruptReport
 ********************************************************************************
 *
 *      Return the next interrupt report in the queue.
 *      If maxLen is not -1, then only return the report if it is <= maxlen.
 */
PHIDCLASS_REPORT DequeueInterruptReport(PHIDCLASS_FILE_EXTENSION fileExtension,
                                        LONG maxLen)
{
    PHIDCLASS_REPORT report;

    RUNNING_DISPATCH();

    if (IsListEmpty(&fileExtension->ReportList)){
        report = NULL;
    }
    else {
        PLIST_ENTRY listEntry = RemoveHeadList(&fileExtension->ReportList);
        report = CONTAINING_RECORD(listEntry, HIDCLASS_REPORT, ListEntry);

        if ((maxLen > 0) && (report->reportLength > (ULONG)maxLen)){
            /*
             *  This report is too big for the caller.
             *  So put the report back in the queue and return NULL.
             */
            InsertHeadList(&fileExtension->ReportList, &report->ListEntry);
            report = NULL;
        }
        else {
            InitializeListHead(&report->ListEntry);
            ASSERT(fileExtension->CurrentInputReportQueueSize > 0);
            fileExtension->CurrentInputReportQueueSize--;

            #if DBG
                if (fileExtension->dbgNumReportsDroppedSinceLastRead > 0){
                    DBGWARN(("... successful read(/flush) after %d reports were dropped.", fileExtension->dbgNumReportsDroppedSinceLastRead));
                    fileExtension->dbgNumReportsDroppedSinceLastRead = 0;
                }
            #endif
        }
    }

    return report;
}



/*
 ********************************************************************************
 *  HidpDestroyFileExtension
 ********************************************************************************
 *
 *
 */
VOID HidpDestroyFileExtension(PHIDCLASS_COLLECTION collection, PHIDCLASS_FILE_EXTENSION FileExtension)
{
    PFILE_OBJECT fileObject;

    //
    // Flush all of the pending reports on the file extension
    //
    HidpFlushReportQueue(FileExtension);

    /*
     *  Fail all the pending reads
     *  (it would be nice if apps always cancelled all their reads
     *   before closing the device, but this is not always the case).
     */
    CompleteAllPendingReadsForFileExtension(collection, FileExtension);

    //
    // Indicate in the file object that this file extension has gone away.
    //

    fileObject = FileExtension->FileObject;
    #if DBG
        fileObject->FsContext = NULL;
    #endif

    //
    // Free our extension
    //
    #if DBG
        FileExtension->Signature = ~HIDCLASS_FILE_EXTENSION_SIG;
    #endif
    ExFreePool( FileExtension );
}



/*
 ********************************************************************************
 *  HidpFlushReportQueue
 ********************************************************************************
 *
 *
 */
VOID HidpFlushReportQueue(IN PHIDCLASS_FILE_EXTENSION fileExtension)
{
    PHIDCLASS_REPORT report;
    KIRQL oldIrql;

    LockFileExtension(fileExtension, &oldIrql);
    while (report = DequeueInterruptReport(fileExtension, -1)){
        //
        // Ok to call this at DISPATCH_LEVEL, since report is NonPagedPool
        //
        ExFreePool(report);
    }
    UnlockFileExtension(fileExtension, oldIrql);
}



/*
 ********************************************************************************
 *  HidpGetCollectionInformation
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpGetCollectionInformation(
    IN FDO_EXTENSION *fdoExtension,
    IN ULONG collectionNumber,
    IN PVOID Buffer,
    IN OUT PULONG BufferSize
    )
{
    HID_COLLECTION_INFORMATION  hidCollectionInfo;
    PHIDP_COLLECTION_DESC       hidCollectionDesc;
    ULONG                       bytesToCopy;
    NTSTATUS                    status;


    /*
     *  Get a pointer to the appropriate collection descriptor.
     */
    hidCollectionDesc = GetCollectionDesc(fdoExtension, collectionNumber);
    if (hidCollectionDesc){
        //
        // Fill in hidCollectionInfo
        //
        hidCollectionInfo.DescriptorSize = hidCollectionDesc->PreparsedDataLength;

        hidCollectionInfo.Polled = fdoExtension->driverExt->DevicesArePolled;

        hidCollectionInfo.VendorID = fdoExtension->hidDeviceAttributes.VendorID;
        hidCollectionInfo.ProductID = fdoExtension->hidDeviceAttributes.ProductID;
        hidCollectionInfo.VersionNumber = fdoExtension->hidDeviceAttributes.VersionNumber;

        //
        // Copy as much of hidCollectionInfo as will fit in the output buffer.
        //
        if (*BufferSize < sizeof( HID_COLLECTION_INFORMATION)){
            /*
             *  The user's buffer is not big enough.
             *  We'll return the size that the buffer needs to be.
             *  Must return this with a real error code (not a warning)
             *  so that IO post-processing does not copy into (and past)
             *  the user's buffer.
             */
            bytesToCopy = *BufferSize;
            status = STATUS_INVALID_BUFFER_SIZE;
        }
        else {
            bytesToCopy = sizeof( HID_COLLECTION_INFORMATION );
            status = STATUS_SUCCESS;
        }

        RtlCopyMemory(Buffer, &hidCollectionInfo, bytesToCopy);
        *BufferSize = sizeof (HID_COLLECTION_INFORMATION);
    }
    else {
        status = STATUS_DATA_ERROR;
    }

    DBGSUCCESS(status, TRUE)
    return status;
}


/*
 ********************************************************************************
 *  HidpGetCollectionDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpGetCollectionDescriptor(   IN FDO_EXTENSION *fdoExtension,
                                        IN ULONG collectionId,
                                        IN PVOID Buffer,
                                        IN OUT PULONG BufferSize)
{
    PHIDP_COLLECTION_DESC       hidCollectionDesc;
    ULONG                       bytesToCopy;
    NTSTATUS                    status;

    hidCollectionDesc = GetCollectionDesc(fdoExtension, collectionId);
    if (hidCollectionDesc){

        /*
         *  Copy as much of the preparsed data as will fit in the output buffer.
         */
        if (*BufferSize < hidCollectionDesc->PreparsedDataLength){
            /*
             *  The user's buffer is not big enough for all the
             *  preparsed data.
             *  We'll return the size that the buffer needs to be.
             *  Must return this with a real error code (not a warning)
             *  so that IO post-processing does not copy into (and past)
             *  the user's buffer.
             */
            bytesToCopy = *BufferSize;
            status = STATUS_INVALID_BUFFER_SIZE;
        }
        else {
            bytesToCopy = hidCollectionDesc->PreparsedDataLength;
            status = STATUS_SUCCESS;
        }

        RtlCopyMemory(Buffer, hidCollectionDesc->PreparsedData, bytesToCopy);
        *BufferSize = hidCollectionDesc->PreparsedDataLength;
    }
    else {
        status = STATUS_DATA_ERROR;
    }

    DBGSUCCESS(status, TRUE)
    return status;
}



/*
 ********************************************************************************
 *  GetReportIdentifier
 ********************************************************************************
 *
 *
 */
PHIDP_REPORT_IDS GetReportIdentifier(FDO_EXTENSION *fdoExtension, ULONG reportId)
{
    PHIDP_REPORT_IDS result = NULL;
    PHIDP_DEVICE_DESC deviceDesc = &fdoExtension->deviceDesc;
    ULONG i;

    if (deviceDesc->ReportIDs){
        for (i = 0; i < deviceDesc->ReportIDsLength; i++){
            if (deviceDesc->ReportIDs[i].ReportID == reportId){
                result = &deviceDesc->ReportIDs[i];
                break;
            }
        }
    }

    if (fdoExtension->deviceSpecificFlags & DEVICE_FLAG_ALLOW_FEATURE_ON_NON_FEATURE_COLLECTION){
        /*
         *  This call from HidpGetSetFeature can fail because we allow
         *  feature access on non-feature collections.
         */
    }
    else {
        DBGASSERT(result, ("Bogus report identifier requested %d", reportId), FALSE)
    }

    return result;
}


/*
 ********************************************************************************
 *  GetCollectionDesc
 ********************************************************************************
 *
 *
 */
PHIDP_COLLECTION_DESC GetCollectionDesc(FDO_EXTENSION *fdoExtension, ULONG collectionId)
{
    PHIDP_COLLECTION_DESC result = NULL;
    PHIDP_DEVICE_DESC deviceDesc = &fdoExtension->deviceDesc;
    ULONG i;

    if (deviceDesc->CollectionDesc){
        for (i = 0; i < deviceDesc->CollectionDescLength; i++){
            if (deviceDesc->CollectionDesc[i].CollectionNumber == collectionId){
                result = &deviceDesc->CollectionDesc[i];
                break;
            }
        }
    }

    ASSERT(result);
    return result;
}

/*
 ********************************************************************************
 *  GetHidclassCollection
 ********************************************************************************
 *
 */
PHIDCLASS_COLLECTION GetHidclassCollection(FDO_EXTENSION *fdoExtension, ULONG collectionId)
{
    PHIDCLASS_COLLECTION result = NULL;
    PHIDP_DEVICE_DESC deviceDesc = &fdoExtension->deviceDesc;
    ULONG i;

    if (ISPTR(fdoExtension->classCollectionArray)){
        for (i = 0; i < deviceDesc->CollectionDescLength; i++){
            if (fdoExtension->classCollectionArray[i].CollectionNumber == collectionId){
                result = &fdoExtension->classCollectionArray[i];
                break;
            }
        }
    }

    return result;
}


/*
 ********************************************************************************
 *  MakeClientPDOName
 ********************************************************************************
 *
 *
 */
PUNICODE_STRING MakeClientPDOName(PUNICODE_STRING fdoName, ULONG collectionId)
{
    PUNICODE_STRING uPdoName;

    PAGED_CODE();

    uPdoName = (PUNICODE_STRING)ALLOCATEPOOL(NonPagedPool, sizeof(UNICODE_STRING));
    if (uPdoName){
        PWSTR wPdoName;

        wPdoName = (PWSTR)ALLOCATEPOOL(
                    PagedPool,
                    fdoName->Length+sizeof(L"#COLLECTION0000000x"));
        if (wPdoName){
            swprintf(wPdoName, L"%s#COLLECTION%08x", fdoName->Buffer, collectionId);
            RtlInitUnicodeString(uPdoName, wPdoName);
        }
        else {
            ExFreePool(uPdoName);
            uPdoName = NULL;
        }
    }

    return uPdoName;
}


/*
 ********************************************************************************
 *  HidpCreateClientPDOs
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpCreateClientPDOs(PHIDCLASS_DEVICE_EXTENSION hidClassExtension)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHIDCLASS_DRIVER_EXTENSION  hidDriverExtension;
    FDO_EXTENSION *fdoExt;

    PAGED_CODE();

    ASSERT(!hidClassExtension->isClientPdo);

    fdoExt = &hidClassExtension->fdoExt;

    hidDriverExtension = RefDriverExt(fdoExt->driverExt->MinidriverObject);
    if (hidDriverExtension){

        /*
         *  We will create one PDO for each collection on this device.
         */
        ULONG numPDOs = fdoExt->deviceDesc.CollectionDescLength;

        if (numPDOs){

            fdoExt->deviceRelations = (PDEVICE_RELATIONS)
                    ALLOCATEPOOL(NonPagedPool, sizeof(DEVICE_RELATIONS) + (numPDOs*sizeof(PDEVICE_OBJECT)));
            if (fdoExt->deviceRelations){

                fdoExt->collectionPdoExtensions =
                        ALLOCATEPOOL(NonPagedPool, numPDOs*sizeof(PHIDCLASS_DEVICE_EXTENSION));
                if (fdoExt->collectionPdoExtensions){

                    ULONG i;

                    fdoExt->deviceRelations->Count = numPDOs;

                    for (i = 0; i < numPDOs; i++){
                        PUNICODE_STRING uPdoName;
                        ULONG           totalExtensionSize;
                        ULONG collectionNum = fdoExt->deviceDesc.CollectionDesc[i].CollectionNumber;
                        PDEVICE_OBJECT  newClientPdo;

                        /*
                         *  Construct a name for the PDO we're about to create.
                         */
                        uPdoName = MakeClientPDOName(&fdoExt->name, collectionNum);
                        if (uPdoName){
                            /*
                             *  We use the same device extension for the client PDOs as for our FDO.
                             */
                            totalExtensionSize = sizeof(HIDCLASS_DEVICE_EXTENSION) +
                                             hidDriverExtension->DeviceExtensionSize;

                            /*
                             *  Create a PDO to represent this collection.
                             *  Since hidclass is not a real driver, it does not have a driver object;
                             *  so just use the minidriver's driver object.
                             *
                             *  NOTE - newClientPdo->NextDevice will point to this minidriver's NextDevice
                             */
                            ntStatus = IoCreateDevice(  hidDriverExtension->MinidriverObject, // driver object
                                                        totalExtensionSize,     // extension size
                                                        uPdoName,               // name of the PDO
                                                        FILE_DEVICE_UNKNOWN,    // Device type
                                                        0,                      // DeviceCharacteristics
                                                        FALSE,                  // not exclusive
                                                        &newClientPdo);
                            if (NT_SUCCESS(ntStatus)){
                                PHIDCLASS_DEVICE_EXTENSION clientPdoExtension = newClientPdo->DeviceExtension;
                                USHORT usagePage = fdoExt->deviceDesc.CollectionDesc[i].UsagePage;
                                USHORT usage = fdoExt->deviceDesc.CollectionDesc[i].Usage;

                                DBG_RECORD_DEVOBJ(newClientPdo, "cltn PDO")

                                ObReferenceObject(newClientPdo);

                                /*
                                 *  We may pass Irps from the upper stack to the lower stack,
                                 *  so make sure there are enough stack locations for the IRPs
                                 *  we pass down.
                                 */
                                newClientPdo->StackSize = fdoExt->fdo->StackSize+1;


                                /*
                                 *  Initialize the PDO's extension
                                 */
                                RtlZeroMemory(clientPdoExtension, totalExtensionSize);

                                clientPdoExtension->hidExt = hidClassExtension->hidExt;
                                clientPdoExtension->isClientPdo = TRUE;
                                clientPdoExtension->Signature = HID_DEVICE_EXTENSION_SIG;

                                clientPdoExtension->pdoExt.collectionNum = collectionNum;
                                clientPdoExtension->pdoExt.collectionIndex = i;
                                clientPdoExtension->pdoExt.pdo = newClientPdo;
                                clientPdoExtension->pdoExt.state = COLLECTION_STATE_UNINITIALIZED;
                                clientPdoExtension->pdoExt.deviceFdoExt = hidClassExtension;
                                clientPdoExtension->pdoExt.StatusChangeFn = BAD_POINTER;

                                clientPdoExtension->pdoExt.name = uPdoName;

                                clientPdoExtension->pdoExt.devicePowerState = PowerDeviceD0;
                                clientPdoExtension->pdoExt.systemPowerState = fdoExt->systemPowerState;
                                clientPdoExtension->pdoExt.MouseOrKeyboard = 
                                    ((usagePage == HID_USAGE_PAGE_GENERIC) &&
                                     ((usage == HID_USAGE_GENERIC_POINTER) ||
                                      (usage == HID_USAGE_GENERIC_MOUSE) ||
                                      (usage == HID_USAGE_GENERIC_KEYBOARD) ||
                                      (usage == HID_USAGE_GENERIC_KEYPAD)));

                                IoInitializeRemoveLock (&clientPdoExtension->pdoExt.removeLock, HIDCLASS_POOL_TAG, 0, 10);
                                KeInitializeSpinLock (&clientPdoExtension->pdoExt.remoteWakeSpinLock);
                                clientPdoExtension->pdoExt.remoteWakeIrp = NULL;
                                
                                /*
                                 *  Store a pointer to the new PDO in the FDO extension's deviceRelations array.
                                 */
                                fdoExt->deviceRelations->Objects[i] = newClientPdo;

                                /*
                                 *  Store a pointer to the PDO's extension.
                                 */
                                fdoExt->collectionPdoExtensions[i] = clientPdoExtension;

                                newClientPdo->Flags |= DO_POWER_PAGABLE;
                                newClientPdo->Flags &= ~DO_DEVICE_INITIALIZING;
                            }
                            else {
                                break;
                            }
                        }
                        else {
                            ntStatus = STATUS_NO_MEMORY;
                        }
                    }

                    if (!NT_SUCCESS(ntStatus)){
                        ExFreePool(fdoExt->collectionPdoExtensions);
                        fdoExt->collectionPdoExtensions = BAD_POINTER;
                    }
                }
                else {
                    ntStatus = STATUS_NO_MEMORY;
                }

                if (!NT_SUCCESS(ntStatus)){
                    ExFreePool(fdoExt->deviceRelations);
                    fdoExt->deviceRelations = BAD_POINTER;
                }
            }
            else {
                ntStatus = STATUS_NO_MEMORY;
            }
        }
        else {
            ASSERT(numPDOs);
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        DerefDriverExt(fdoExt->driverExt->MinidriverObject);
    }
    else {
        ASSERT(hidDriverExtension);
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    DBGSUCCESS(ntStatus, TRUE)
    return ntStatus;
}


/*
 ********************************************************************************
 *  MemDup
 ********************************************************************************
 *
 *  Return a fresh copy of the argument.
 *
 */
PVOID MemDup(POOL_TYPE PoolType, PVOID dataPtr, ULONG length)
{
    PVOID newPtr;

    newPtr = (PVOID)ALLOCATEPOOL(PoolType, length);
    if (newPtr){
        RtlCopyMemory(newPtr, dataPtr, length);
    }

    ASSERT(newPtr);
    return newPtr;
}

/*
 ********************************************************************************
 *  WStrLen
 ********************************************************************************
 *
 */
ULONG WStrLen(PWCHAR str)
{
    ULONG result = 0;

    while (*str++ != UNICODE_NULL){
        result++;
    }

    return result;
}


/*
 ********************************************************************************
 *  WStrCpy
 ********************************************************************************
 *
 */
ULONG WStrCpy(PWCHAR dest, PWCHAR src)
{
    ULONG result = 0;

    while (*dest++ = *src++){
        result++;
    }

    return result;
}

BOOLEAN WStrCompareN(PWCHAR str1, PWCHAR str2, ULONG maxChars)
{
        while ((maxChars > 0) && *str1 && (*str1 == *str2)){
                maxChars--;
                str1++;
                str2++;
        }

        return (BOOLEAN)((maxChars == 0) || (!*str1 && !*str2));
}

/*
 ********************************************************************************
 *  HidpNumberToString
 ********************************************************************************
 *
 */
void HidpNumberToString(PWCHAR String, USHORT Number, USHORT stringLen)
{
    const static WCHAR map[] = L"0123456789ABCDEF";
    LONG         i      = 0;
    ULONG        nibble = 0;

    ASSERT(stringLen);

    for (i = stringLen-1; i >= 0; i--) {
        String[i] = map[Number & 0x0F];
        Number >>= 4;
    }
}


/*
 ********************************************************************************
 *  CopyDeviceRelations
 ********************************************************************************
 *
 *
 */
PDEVICE_RELATIONS CopyDeviceRelations(PDEVICE_RELATIONS deviceRelations)
{
    PDEVICE_RELATIONS newDeviceRelations;

    if (deviceRelations){
        ULONG size = sizeof(DEVICE_RELATIONS) + (deviceRelations->Count*sizeof(PDEVICE_OBJECT));
        newDeviceRelations = MemDup(PagedPool, deviceRelations, size);
    }
    else {
        newDeviceRelations = NULL;
    }

    return newDeviceRelations;
}


/*
 ********************************************************************************
 *  HidpQueryDeviceRelations
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpQueryDeviceRelations(IN PHIDCLASS_DEVICE_EXTENSION hidClassExtension, IN OUT PIRP Irp)
{
    PIO_STACK_LOCATION ioStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(!hidClassExtension->isClientPdo);

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    if (ioStack->Parameters.QueryDeviceRelations.Type == BusRelations) {

        if (hidClassExtension->fdoExt.deviceRelations){
            /*
             *  Don't call HidpCreateClientPDOs again if it's
             *  already been called for this device.
             */
            ntStatus = STATUS_SUCCESS;
        }
        else {
            ntStatus = HidpCreateClientPDOs(hidClassExtension);
        }

        if (NT_SUCCESS(ntStatus)){
            ULONG i;

            /*
             *  NTKERN expects a new pointer each time it calls QUERY_DEVICE_RELATIONS;
             *  it then FREES THE POINTER.
             *  So we have to return a new pointer each time, whether or not we actually
             *  created our copy of the device relations for this call.
             */
            Irp->IoStatus.Information = (ULONG_PTR)CopyDeviceRelations(hidClassExtension->fdoExt.deviceRelations);

            if (Irp->IoStatus.Information){
                /*
                 *  PnP dereferences each device object
                 *  in the device relations list after each call.
                 *  So for each call, add an extra reference.
                 */
                for (i = 0; i < hidClassExtension->fdoExt.deviceRelations->Count; i++){
                    ObReferenceObject(hidClassExtension->fdoExt.deviceRelations->Objects[i]);
                    hidClassExtension->fdoExt.deviceRelations->Objects[i]->Flags &= ~DO_DEVICE_INITIALIZING;
                }
            }
            else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        DBGSUCCESS(ntStatus, TRUE)
    }
    else {
        /*
         *  We don't support this option, so just maintain
         *  the current status (do not return STATUS_NOT_SUPPORTED).
         */
        ntStatus = Irp->IoStatus.Status;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HidpQueryCollectionCapabilities
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpQueryCollectionCapabilities(   PDO_EXTENSION *pdoExt,
                                            IN OUT PIRP Irp)
{
    PDEVICE_CAPABILITIES deviceCapabilities;
    PIO_STACK_LOCATION ioStack;
    FDO_EXTENSION *fdoExt;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(pdoExt->deviceFdoExt->Signature == HID_DEVICE_EXTENSION_SIG);
    fdoExt = &pdoExt->deviceFdoExt->fdoExt;
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    deviceCapabilities = ioStack->Parameters.DeviceCapabilities.Capabilities;
    if (deviceCapabilities){

        /*
         *  Set all fields for the collection-PDO as for the device-FDO
         *  by default.
         */
        *deviceCapabilities = fdoExt->deviceCapabilities;

        /*
         *  Now override the fields we care about.
         */
        deviceCapabilities->LockSupported = FALSE;
        deviceCapabilities->EjectSupported = FALSE;
        deviceCapabilities->Removable = FALSE;
        deviceCapabilities->DockDevice = FALSE;
        deviceCapabilities->UniqueID = FALSE;
        deviceCapabilities->SilentInstall = TRUE;

        /*
         *  This field is very important;
         *  it causes HIDCLASS to get the START_DEVICE IRP immediately,
         *  if the device is not a keyboard or mouse.
         */
        deviceCapabilities->RawDeviceOK = !pdoExt->MouseOrKeyboard;

        /*
         *  This bit indicates that the device may be removed on NT
         *  without running the 'hot-unplug' utility.
         */
        deviceCapabilities->SurpriseRemovalOK = TRUE;

        DBGVERBOSE(("WAKE info: sysWake=%d devWake=%d; wake from D0=%d D1=%d D2=%d D3=%d.",
                    deviceCapabilities->SystemWake,
                    deviceCapabilities->DeviceWake,
                    (ULONG)deviceCapabilities->WakeFromD0,
                    (ULONG)deviceCapabilities->WakeFromD1,
                    (ULONG)deviceCapabilities->WakeFromD2,
                    (ULONG)deviceCapabilities->WakeFromD3))

        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    Irp->IoStatus.Information = (ULONG_PTR)deviceCapabilities;

    DBGSUCCESS(status, TRUE)
    return status;
}



/*
 ********************************************************************************
 *  BuildCompatibleID
 ********************************************************************************
 *
 *  Return a multi-string consisting of compatibility id's for this device
 *  in increasingly generic order (ending with HID_GENERIC_DEVICE).
 *
 *  author: kenray
 *
 */
PWSTR BuildCompatibleID(PHIDCLASS_DEVICE_EXTENSION hidClassExtension)
{
    USHORT usage, usagePage;
    ULONG spLength;
    ULONG totLength;
    ULONG i;
    PWSTR specificId = NULL;
    PWSTR compatIdList;
    PWSTR genericId;
    FDO_EXTENSION *fdoExt;

    PAGED_CODE();

    ASSERT(hidClassExtension->isClientPdo);
    fdoExt = &hidClassExtension->pdoExt.deviceFdoExt->fdoExt;

    ASSERT(ISPTR(fdoExt->deviceDesc.CollectionDesc));

    i = hidClassExtension->pdoExt.collectionIndex;
    usagePage = fdoExt->deviceDesc.CollectionDesc[i].UsagePage;
    usage = fdoExt->deviceDesc.CollectionDesc[i].Usage;


    switch (usagePage) {
    case HID_USAGE_PAGE_GENERIC:
        switch (usage) {
        case HID_USAGE_GENERIC_POINTER:
        case HID_USAGE_GENERIC_MOUSE:
            specificId = HIDCLASS_SYSTEM_MOUSE;
            break;
        case HID_USAGE_GENERIC_KEYBOARD:
        case HID_USAGE_GENERIC_KEYPAD:
            specificId = HIDCLASS_SYSTEM_KEYBOARD;
            break;
        case HID_USAGE_GENERIC_JOYSTICK:
        case HID_USAGE_GENERIC_GAMEPAD:
            specificId = HIDCLASS_SYSTEM_GAMING_DEVICE;
            break;
        case HID_USAGE_GENERIC_SYSTEM_CTL:
            specificId = HIDCLASS_SYSTEM_CONTROL;
            break;
        }
        break;

    case HID_USAGE_PAGE_CONSUMER:
        specificId = HIDCLASS_SYSTEM_CONSUMER_DEVICE;
        break;

    default:
        break;
    }

    spLength = (specificId) ? (WStrLen(specificId)+1) : 0;

    totLength = spLength +
                HIDCLASS_COMPATIBLE_ID_GENERIC_LENGTH +
                HIDCLASS_COMPATIBLE_ID_STANDARD_LENGTH +
                1;

    compatIdList = ALLOCATEPOOL(NonPagedPool, totLength * sizeof(WCHAR));
    if (compatIdList) {

        RtlZeroMemory (compatIdList, totLength * sizeof(WCHAR));
        if (specificId) {
            RtlCopyMemory (compatIdList, specificId, spLength * sizeof (WCHAR));
        }

        genericId = compatIdList + spLength;
        totLength = HIDCLASS_COMPATIBLE_ID_GENERIC_LENGTH;
        RtlCopyMemory (genericId,
                       HIDCLASS_COMPATIBLE_ID_GENERIC_NAME,
                       totLength*sizeof(WCHAR));

        HidpNumberToString (genericId + HIDCLASS_COMPATIBLE_ID_PAGE_OFFSET,
                            usagePage,
                            4);

        HidpNumberToString (genericId + HIDCLASS_COMPATIBLE_ID_USAGE_OFFSET,
                            usage,
                            4);

        RtlCopyMemory (genericId + totLength,
                       HIDCLASS_COMPATIBLE_ID_STANDARD_NAME,
                       HIDCLASS_COMPATIBLE_ID_STANDARD_LENGTH * sizeof (WCHAR));
    }

    return compatIdList;
}


/*
 ********************************************************************************
 *  SubstituteBusNames
 ********************************************************************************
 *
 *  oldIDs is a multi-String of hardware IDs.
 *
 *  1. Return a new string with each "<busName>\" prefix replaced by "HID\".
 *
 *  2. If the device has multiple collections, append "&Colxx" to each id.
 *
 */
PWCHAR SubstituteBusNames(PWCHAR oldIDs, FDO_EXTENSION *fdoExt, PDO_EXTENSION *pdoExt)
{
    ULONG newIdLen;
    PWCHAR id, newIDs;
    ULONG numCollections;
    WCHAR colNumStr[] = L"&Colxx";

    PAGED_CODE();

    numCollections = fdoExt->deviceDesc.CollectionDescLength;
    ASSERT(numCollections > 0);

    for (id = oldIDs, newIdLen = 0; *id; ){
        ULONG thisIdLen = WStrLen(id);

        /*
         *  This is a little sloppy because we're actually going to chop
         *  off the other bus name; but better this than walking each string.
         */
        newIdLen += thisIdLen + 1 + sizeof("HID\\");

        if (numCollections > 1){
            newIdLen += sizeof(colNumStr)/sizeof(WCHAR);
        }

        id += thisIdLen + 1;
    }

    /*
     *  Add one for the extra NULL at the end of the multi-string.
     */
    newIdLen++;

    newIDs = ALLOCATEPOOL(NonPagedPool, newIdLen*sizeof(WCHAR));
    if (newIDs){
        ULONG oldIdOff, newIdOff;

        /*
         *  Copy each string in the multi-string, replacing the bus name.
         */
        for (oldIdOff = newIdOff = 0; oldIDs[oldIdOff]; ){
            ULONG thisIdLen = WStrLen(oldIDs+oldIdOff);
            ULONG devIdOff;

            /*
             *  Copy the new bus name to the new string.
             */
            newIdOff += WStrCpy(newIDs+newIdOff, L"HID\\");

            /*
             *  Go past the old bus name in the old string.
             */
            for (devIdOff = 0; oldIDs[oldIdOff+devIdOff]; devIdOff++){
                if (oldIDs[oldIdOff+devIdOff] == L'\\'){
                    break;
                }
            }

            /*
             *  Copy the rest of this device id.
             */
            if (oldIDs[oldIdOff+devIdOff] == L'\\'){
                devIdOff++;
            }
            else {
                /*
                 *  Strange -- no bus name in hardware id.
                 *             Just copy the entire id.
                 */
                devIdOff = 0;
            }
            newIdOff += WStrCpy(newIDs+newIdOff, oldIDs+oldIdOff+devIdOff);

            if (numCollections > 1){
                /*
                 *  If there is more than one collection,
                 *  then also append the collection number.
                 */
                HidpNumberToString(colNumStr+4, (USHORT)pdoExt->collectionNum, 2);
                newIdOff += WStrCpy(newIDs+newIdOff, colNumStr);
            }

            /*
             *  Go past the single string terminator.
             */
            newIdOff++;

            oldIdOff += thisIdLen + 1;
        }

        /*
         *  Add extra NULL to terminate multi-string.
         */
        newIDs[newIdOff] = UNICODE_NULL;
    }

    return newIDs;
}

NTSTATUS
HidpQueryInterface(
    IN PHIDCLASS_DEVICE_EXTENSION hidClassExtension,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    ASSERT(hidClassExtension->isClientPdo);
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (RtlEqualMemory(irpSp->Parameters.QueryInterface.InterfaceType,
                       &GUID_HID_INTERFACE_NOTIFY,
                       sizeof(GUID))) {
        PDO_EXTENSION       *pdoExt;
        PHID_INTERFACE_NOTIFY_PNP notify;

        notify = (PHID_INTERFACE_NOTIFY_PNP) irpSp->Parameters.QueryInterface.Interface;
        if (notify->Size != sizeof(HID_INTERFACE_NOTIFY_PNP) ||
            notify->Version < 1 ||
            notify->StatusChangeFn == NULL) {
            //
            // return STATUS_UNSUPPORTED probably
            //
            return Irp->IoStatus.Status;
        }

        pdoExt = &hidClassExtension->pdoExt;

        pdoExt->StatusChangeFn = notify->StatusChangeFn;
        pdoExt->StatusChangeContext = notify->CallbackContext;
        return STATUS_SUCCESS;
    }
    else if (RtlEqualMemory(irpSp->Parameters.QueryInterface.InterfaceType,
                       &GUID_HID_INTERFACE_HIDPARSE,
                       sizeof(GUID))) {
        //
        // Required for Generic Input, to remove the direct link
        // b/w win32k and hidparse.
        //
        PHID_INTERFACE_HIDPARSE hidparse;

        hidparse = (PHID_INTERFACE_HIDPARSE) irpSp->Parameters.QueryInterface.Interface;
        if (hidparse->Size != sizeof(HID_INTERFACE_HIDPARSE) ||
            hidparse->Version < 1) {
            //
            // return STATUS_UNSUPPORTED probably
            //
            return Irp->IoStatus.Status;
        }
        hidparse->HidpGetCaps = HidP_GetCaps;
        return STATUS_SUCCESS;
    }

    //
    // return STATUS_UNSUPPORTED probably
    //
    return Irp->IoStatus.Status;
}


/*
 ********************************************************************************
 *  HidpQueryIdForClientPdo
 ********************************************************************************
 *
 *
 *
 */
NTSTATUS HidpQueryIdForClientPdo (
    IN PHIDCLASS_DEVICE_EXTENSION hidClassExtension,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS            status;
    PDO_EXTENSION       *pdoExt;
    FDO_EXTENSION       *fdoExt;

    PAGED_CODE();

    ASSERT(hidClassExtension->isClientPdo);
    pdoExt = &hidClassExtension->pdoExt;
    fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch (irpSp->Parameters.QueryId.IdType) {

    case BusQueryHardwareIDs:

        /*
         *  Call down to get a multi-string of hardware ids for the PDO.
         */
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = HidpCallDriverSynchronous(fdoExt->fdo, Irp);
        if (NT_SUCCESS(status)){
            PWCHAR oldIDs, newIDs;
            /*
             *  Replace the bus names in the current hardware IDs list with "HID\".
             */
            oldIDs = (PWCHAR)Irp->IoStatus.Information;
            Irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
            newIDs = SubstituteBusNames(oldIDs, fdoExt, pdoExt);
            ExFreePool(oldIDs);

            if (newIDs){

                /*
                 *  Now append the compatible ids to the end of the HardwareIDs list.
                 */
                PWCHAR compatIDs = BuildCompatibleID(hidClassExtension);
                if (compatIDs){
                    ULONG basicIDsLen, compatIDsLen;
                    PWCHAR allHwIDs;

                    /*
                     *  Find the lengths of the id multi-strings (not counting the extra NULL at end).
                     */
                    for (basicIDsLen = 0; newIDs[basicIDsLen]; basicIDsLen += WStrLen(newIDs+basicIDsLen)+1);
                    for (compatIDsLen = 0; compatIDs[compatIDsLen]; compatIDsLen += WStrLen(compatIDs+compatIDsLen)+1);

                    allHwIDs = ALLOCATEPOOL(PagedPool, (basicIDsLen+compatIDsLen+1)*sizeof(WCHAR));
                    if (allHwIDs){
                        RtlCopyMemory(allHwIDs, newIDs, basicIDsLen*sizeof(WCHAR));
                        RtlCopyMemory(  allHwIDs+basicIDsLen,
                                        compatIDs,
                                        (compatIDsLen+1)*sizeof(WCHAR));

                        Irp->IoStatus.Information = (ULONG_PTR)allHwIDs;
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }

                    ExFreePool(compatIDs);
                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }

                ExFreePool(newIDs);
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        DBGSUCCESS(status, TRUE)
        break;

    case BusQueryDeviceID:
        /*
         *  Call down to get a the device id for the device's PDO.
         */
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = HidpCallDriverSynchronous(fdoExt->fdo, Irp);
        if (NT_SUCCESS(status)){
            PWCHAR oldId, newId, tmpId;

            /*
             *  Replace the bus name (e.g. "USB\") with "HID\" in the device name.
             */

            /*
             *  First make this string into a multi-string.
             */
            oldId = (PWCHAR)Irp->IoStatus.Information;
            tmpId = ALLOCATEPOOL(PagedPool, (WStrLen(oldId)+2)*sizeof(WCHAR));
            if (tmpId){
                ULONG len = WStrCpy(tmpId, oldId);

                /*
                 *  Add the extra NULL to terminate the multi-string.
                 */
                tmpId[len+1] = UNICODE_NULL;

                /*
                 *  Change the bus name to "HID\"
                 */
                newId = SubstituteBusNames(tmpId, fdoExt, pdoExt);
                if (newId){
                    Irp->IoStatus.Information = (ULONG_PTR)newId;
                }
                else {
                    status = STATUS_DEVICE_DATA_ERROR;
                    Irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
                }

                ExFreePool(tmpId);
            }
            else {
                status = STATUS_DEVICE_DATA_ERROR;
                Irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
            }
            ExFreePool(oldId);
        }

        DBGSUCCESS(status, TRUE)
        break;

    case BusQueryInstanceID:

        /*
         *  Produce an instance-id for this collection-PDO.
         *
         *  Note: NTKERN frees the returned pointer, so we must provide a fresh pointer.
         */
        {
            PWSTR instanceId = MemDup(PagedPool, L"0000", sizeof(L"0000"));
            if (instanceId){
                ULONG i;

                /*
                 *  Find this collection-PDO in the device-relations array
                 *  and make the id be the PDO's index within that array.
                 */
                for (i = 0; i < fdoExt->deviceRelations->Count; i++){
                    if (fdoExt->deviceRelations->Objects[i] == pdoExt->pdo){
                        swprintf(instanceId, L"%04x", i);
                        break;
                    }
                }
                ASSERT(i < fdoExt->deviceRelations->Count);

                Irp->IoStatus.Information = (ULONG_PTR)instanceId;
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        DBGSUCCESS(status, TRUE)
        break;

    case BusQueryCompatibleIDs:

        //        we now return the compatible id's at the end of HardwareIDs
        //        so that there is no UI on plug-in for a compatible-id match
        //        for a class-PDO.
        // Irp->IoStatus.Information = (ULONG)BuildCompatibleID(hidClassExtension);
        Irp->IoStatus.Information = (ULONG_PTR)ALLOCATEPOOL(PagedPool, sizeof(L"\0"));
        if (Irp->IoStatus.Information) {
            *(ULONG *)Irp->IoStatus.Information = 0;  // double unicode-NULL.
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            ASSERT(0);
        }
        break;

    default:
        /*
         *  Do not return STATUS_NOT_SUPPORTED;
         *  keep the default status
         *  (this allows filter drivers to work).
         */
        status = Irp->IoStatus.Status;
        break;
    }

    return status;
}



/*
 ********************************************************************************
 *  AllClientPDOsInitialized
 ********************************************************************************
 *
 *
 */
BOOLEAN AllClientPDOsInitialized(FDO_EXTENSION *fdoExtension, BOOLEAN initialized)
{
    BOOLEAN result = TRUE;
    ULONG i;

    if (ISPTR(fdoExtension->deviceRelations)){
        for (i = 0; i < fdoExtension->deviceRelations->Count; i++){
            PDEVICE_OBJECT pdo = fdoExtension->deviceRelations->Objects[i];
            PHIDCLASS_DEVICE_EXTENSION pdoDevExt = pdo->DeviceExtension;
                    PDO_EXTENSION *pdoExt = &pdoDevExt->pdoExt;

                    /*
                     *  Trick: compare !-results so that all TRUE values are equal
                     */
            if (!initialized == !(pdoExt->state == COLLECTION_STATE_UNINITIALIZED)){
                DBGVERBOSE(("AllClientPDOsInitialized is returning FALSE for pdo %x, state = %d",
                            pdo, pdoExt->state))
                result = FALSE;
                break;
            }
        }
    }
    else {
        result = !initialized;
    }

    return result;
}


/*
 ********************************************************************************
 *  AnyClientPDOsInitialized
 ********************************************************************************
 *
 *
 */
BOOLEAN AnyClientPDOsInitialized(FDO_EXTENSION *fdoExtension, BOOLEAN initialized)
{
    BOOLEAN result = TRUE;
    ULONG i;

    if (ISPTR(fdoExtension->deviceRelations)){
        for (i = 0; i < fdoExtension->deviceRelations->Count; i++){
            PDEVICE_OBJECT pdo = fdoExtension->deviceRelations->Objects[i];
            PHIDCLASS_DEVICE_EXTENSION pdoDevExt = pdo->DeviceExtension;
            PDO_EXTENSION *pdoExt = &pdoDevExt->pdoExt;

            if (!initialized != !(pdoExt->state == COLLECTION_STATE_UNINITIALIZED)){
                result = TRUE;
                break;
            }
        }
    }
    else {
        result = !initialized;
    }

    return result;
}



/*
 ********************************************************************************
 *  HidpDeleteDeviceObjects
 ********************************************************************************
 *
 *  Delete the device-FDO and collection-PDO's  IF POSSIBLE.
 *  (must wait for REMOVE_DEVICE completion AND the IRP_MJ_CLOSE.
 *  Otherwise, return FALSE and we'll try again later.
 *
 *
 */
BOOLEAN HidpDeleteDeviceObjects(FDO_EXTENSION *fdoExt)
{
    ULONG i;

    /*
     *  Do this switch-a-roo to thwart re-entrancy problems.
     */
    PDEVICE_OBJECT objToDelete = fdoExt->fdo;
    fdoExt->fdo = BAD_POINTER;

    if (ISPTR(fdoExt->deviceRelations)){

        for (i = 0; i < fdoExt->deviceRelations->Count; i++){
            PDO_EXTENSION *pdoExt = &fdoExt->collectionPdoExtensions[i]->pdoExt;

            ASSERT(ISPTR(fdoExt->deviceRelations->Objects[i]));

            if (ISPTR(pdoExt->name)){
                RtlFreeUnicodeString(pdoExt->name);
                ExFreePool(pdoExt->name);
                pdoExt->name = BAD_POINTER;
            }

                        /*
                         *  Delete the client PDO.
                         *  Don't touch the pdoExt after doing this.
                         */
            ObDereferenceObject(fdoExt->deviceRelations->Objects[i]);
            IoDeleteDevice(fdoExt->deviceRelations->Objects[i]);
        }

        ExFreePool(fdoExt->deviceRelations);
    }
    fdoExt->deviceRelations = BAD_POINTER;

    if (ISPTR(fdoExt->collectionPdoExtensions)){
        ExFreePool(fdoExt->collectionPdoExtensions);
    }
    fdoExt->collectionPdoExtensions = BAD_POINTER;

    ObDereferenceObject(objToDelete);
    IoDeleteDevice(objToDelete);

    return TRUE;
}


/*
 ********************************************************************************
 *  HidpQueryDeviceCapabilities
 ********************************************************************************
 *
 *
 *
 */
NTSTATUS HidpQueryDeviceCapabilities(   IN PDEVICE_OBJECT PdoDeviceObject,
                                        IN PDEVICE_CAPABILITIES DeviceCapabilities)
{
    PIRP irp;
    NTSTATUS status;

    PAGED_CODE();

    irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);
    if (irp) {
        PIO_STACK_LOCATION nextStack;
        KEVENT event;

        nextStack = IoGetNextIrpStackLocation(irp);
        ASSERT(nextStack);

        nextStack->MajorFunction= IRP_MJ_PNP;
        nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoSetCompletionRoutine(irp,
                               HidpQueryCapsCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        RtlZeroMemory(DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));

        /*
         *  Caller needs to initialize some fields
         */
        DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
        DeviceCapabilities->Version = 1;
        DeviceCapabilities->Address = -1;
        DeviceCapabilities->UINumber = -1;

        nextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

        status = IoCallDriver(PdoDeviceObject, irp);

        if (status == STATUS_PENDING) {
           KeWaitForSingleObject(
                &event,
                Suspended,
                KernelMode,
                FALSE,
                NULL);
        }

        /*
         *  Note: we still own the IRP after the IoCallDriver() call
         *        because the completion routine returned
         *        STATUS_MORE_PROCESSING_REQUIRED.
         */
        status = irp->IoStatus.Status;

        IoFreeIrp(irp);

    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


/*
 ********************************************************************************
 *  CheckReportPowerEvent
 ********************************************************************************
 *
 *  Check whether the read report includes a power event.
 *  If it does, notify the system by completing the saved power-event Irp.
 *
 *  Note: report should point to a "cooked" report with the report-id byte
 *        included at the beginning of the report, whether or not the device
 *        included the report id.
 *
 */
VOID CheckReportPowerEvent( FDO_EXTENSION *fdoExt,
                            PHIDCLASS_COLLECTION collection,
                            PUCHAR report,
                            ULONG reportLen)
{
    ULONG powerMask;
    NTSTATUS status;

    ASSERT(ISPTR(fdoExt->collectionPdoExtensions));

    status = HidP_SysPowerEvent(    report,
                                    (USHORT)reportLen,
                                    collection->phidDescriptor,
                                    &powerMask);
    if (NT_SUCCESS(status)){

        if (powerMask){
            /*
             *  This report contains a power event!
             */

            PIRP irpToComplete = NULL;
            KIRQL oldIrql;

            KeAcquireSpinLock(&collection->powerEventSpinLock, &oldIrql);

            /*
             *  We should have gotten a IOCTL_GET_SYS_BUTTON_EVENT earlier and queued
             *  an IRP to return now.
             */
            if (ISPTR(collection->powerEventIrp)){
                PDRIVER_CANCEL oldCancelRoutine;

                /*
                 *  "Dequeue" the power event IRP.
                 */
                irpToComplete = collection->powerEventIrp;

                oldCancelRoutine = IoSetCancelRoutine(irpToComplete, NULL);
                if (oldCancelRoutine){
                    ASSERT(oldCancelRoutine == PowerEventCancelRoutine);
                }
                else {
                    /*
                     *  This IRP was cancelled and the cancel routine WAS called.
                     *  The cancel routine will complete this IRP
                     *  as soon as we drop the spinlock, so don't touch the IRP.
                     */
                    ASSERT(irpToComplete->Cancel);
                    irpToComplete = NULL;
                }

                collection->powerEventIrp = BAD_POINTER;
            }
            else {
                TRAP;
            }

            KeReleaseSpinLock(&collection->powerEventSpinLock, oldIrql);

            /*
             *  If completing the IRP,
             *  do so after releasing all spinlocks.
             */
            if (irpToComplete){
                /*
                 *  Complete the IRP with the power mask.
                 *
                 */
                ASSERT(irpToComplete->AssociatedIrp.SystemBuffer);
                *(PULONG)irpToComplete->AssociatedIrp.SystemBuffer = powerMask;
                irpToComplete->IoStatus.Information = sizeof(ULONG);
                irpToComplete->IoStatus.Status = STATUS_SUCCESS;
                IoCompleteRequest(irpToComplete, IO_NO_INCREMENT);
            }
        }
    }

}


VOID ReadDeviceFlagsFromRegistry(FDO_EXTENSION *fdoExt, PDEVICE_OBJECT pdo)
{
    NTSTATUS status;
    HANDLE hRegDriver;

    /*
     *  Open the driver registry key
     *  ( HKLM/System/CurrentControlSet/Control/Class/<GUID>/<#n> )
     */
    status = IoOpenDeviceRegistryKey(   pdo,
                                        PLUGPLAY_REGKEY_DRIVER,
                                        KEY_READ,
                                        &hRegDriver);
    if (NT_SUCCESS(status)){
        UNICODE_STRING deviceSpecificFlagsName;
        HANDLE hRegDeviceSpecificFlags;

        /*
         *  See if the DeviceSpecificFlags subkey exists.
         */
        RtlInitUnicodeString(&deviceSpecificFlagsName, L"DeviceSpecificFlags");
        status = OpenSubkey(    &hRegDeviceSpecificFlags,
                                hRegDriver,
                                &deviceSpecificFlagsName,
                                KEY_READ);

        if (NT_SUCCESS(status)){
            /*
             *  The registry DOES contain device-specific flags for this device.
             */

            /*
             *  The key value information struct is variable-length.
             *  The actual length is equal to the length of the base
             *  PKEY_VALUE_FULL_INFORMATION struct + the length of
             *  the name of the key + the length of the value.
             *  (The name of the key is a 4-byte hex number representing
             *   the 16-bit "source" usage value, written as a wide-char
             *   string; so with the terminating '\0', 5 wide chars).
             */
            #define MAX_DEVICE_SPECIFIC_FLAG_NAME_LEN 60
            UCHAR keyValueBytes[sizeof(KEY_VALUE_FULL_INFORMATION)+(MAX_DEVICE_SPECIFIC_FLAG_NAME_LEN+1)*sizeof(WCHAR)+sizeof(ULONG)];
            PKEY_VALUE_FULL_INFORMATION keyValueInfo = (PKEY_VALUE_FULL_INFORMATION)keyValueBytes;
            ULONG actualLen;
            ULONG keyIndex = 0;


            do {
                status = ZwEnumerateValueKey(
                            hRegDeviceSpecificFlags,
                            keyIndex,
                            KeyValueFullInformation,
                            keyValueInfo,
                            sizeof(keyValueBytes),
                            &actualLen);
                if (NT_SUCCESS(status)){

                    PWCHAR valuePtr;
                    WCHAR valueBuf[2];
                    USHORT value;

                    ASSERT(keyValueInfo->Type == REG_SZ);
                    ASSERT(keyValueInfo->NameLength/sizeof(WCHAR) <= MAX_DEVICE_SPECIFIC_FLAG_NAME_LEN);

                    valuePtr = (PWCHAR)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset);
                    WStrNCpy(valueBuf, valuePtr, 1);
                    valueBuf[1] = L'\0';

                    value = (USHORT)LAtoX(valueBuf);

                    if (value){
                        if (!WStrNCmpI( keyValueInfo->Name,
                                        L"AllowFeatureOnNonFeatureCollection",
                                        keyValueInfo->NameLength/sizeof(WCHAR))){

                            DBGWARN(("Device HACK: allowing feature access on non-feature collections"))
                            fdoExt->deviceSpecificFlags |=
                                DEVICE_FLAG_ALLOW_FEATURE_ON_NON_FEATURE_COLLECTION;
                        }

                    }

                    keyIndex++;
                }
            } while (NT_SUCCESS(status));

            ZwClose(hRegDeviceSpecificFlags);
        }

        ZwClose(hRegDriver);
    }
    else {
        /*
         *  For 'raw' devices, IoOpenDeviceRegistryKey can fail on the
         *  initial 'raw' starts before the devnode is created.
         */
    }

}


LONG WStrNCmpI(PWCHAR s1, PWCHAR s2, ULONG n)
{
    ULONG result;

    while (n && *s1 && *s2 && ((*s1|0x20) == (*s2|0x20))){
        s1++, s2++;
        n--;
    }

    if (n){
        result = ((*s1|0x20) > (*s2|0x20)) ? 1 : ((*s1|0x20) < (*s2|0x20)) ? -1 : 0;
    }
    else {
        result = 0;
    }

    return result;
}


ULONG LAtoX(PWCHAR wHexString)
/*++

Routine Description:

      Convert a hex string (without the '0x' prefix) to a ULONG.

Arguments:

    wHexString - null-terminated wide-char hex string
                 (with no "0x" prefix)

Return Value:

    ULONG value

--*/
{
    ULONG i, result = 0;

    for (i = 0; wHexString[i]; i++){
        if ((wHexString[i] >= L'0') && (wHexString[i] <= L'9')){
            result *= 0x10;
            result += (wHexString[i] - L'0');
        }
        else if ((wHexString[i] >= L'a') && (wHexString[i] <= L'f')){
            result *= 0x10;
            result += (wHexString[i] - L'a' + 0x0a);
        }
        else if ((wHexString[i] >= L'A') && (wHexString[i] <= L'F')){
            result *= 0x10;
            result += (wHexString[i] - L'A' + 0x0a);
        }
        else {
            ASSERT(0);
            break;
        }
    }

    return result;
}


ULONG WStrNCpy(PWCHAR dest, PWCHAR src, ULONG n)
{
    ULONG result = 0;

    while (n && (*dest++ = *src++)){
        result++;
        n--;
    }

    return result;
}


NTSTATUS OpenSubkey(    OUT PHANDLE Handle,
                        IN HANDLE BaseHandle,
                        IN PUNICODE_STRING KeyName,
                        IN ACCESS_MASK DesiredAccess
                   )
{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;

    PAGED_CODE();

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwOpenKey(Handle, DesiredAccess, &objectAttributes);

    return status;
}

PVOID
HidpGetSystemAddressForMdlSafe(PMDL MdlAddress)
{
    PVOID buf = NULL;
    /*
     *  Can't call MmGetSystemAddressForMdlSafe in a WDM driver,
     *  so set the MDL_MAPPING_CAN_FAIL bit and check the result
     *  of the mapping.
     */
    if (MdlAddress) {
        MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
        buf = MmGetSystemAddressForMdl(MdlAddress);
        MdlAddress->MdlFlags &= (~MDL_MAPPING_CAN_FAIL);
    }
    else {
        DBGASSERT(MdlAddress, ("MdlAddress passed into GetSystemAddress is NULL"), FALSE)
    }
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\write.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    write.c

Abstract

    Write handling routines

Author:

    Forrest Foltz
    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"




/*
 ********************************************************************************
 *  HidpInterruptWriteComplete
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpInterruptWriteComplete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)Context;
    NTSTATUS status = Irp->IoStatus.Status;
    PHID_XFER_PACKET hidWritePacket;

    DBG_COMMON_ENTRY()

    ASSERT(hidDeviceExtension->isClientPdo);

    ASSERT(Irp->UserBuffer);
    hidWritePacket = Irp->UserBuffer;
    ExFreePool(hidWritePacket);
    Irp->UserBuffer = NULL;

    if (NT_SUCCESS(status)){
        FDO_EXTENSION *fdoExt = &hidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;
        PHIDP_COLLECTION_DESC collectionDesc = GetCollectionDesc(fdoExt, hidDeviceExtension->pdoExt.collectionNum);

        if (collectionDesc){
            HidpSetDeviceBusy(fdoExt);

            Irp->IoStatus.Information = collectionDesc->OutputLength;
        } else {
            //
            // How could we get here? Had to get the collectionDesc in order 
            // to start the write!
            //
            TRAP;
        }

        DBGVERBOSE(("HidpInterruptWriteComplete: write irp %ph succeeded, wrote %xh bytes.", Irp, Irp->IoStatus.Information))
    }
    else {
        DBGWARN(("HidpInterruptWriteComplete: write irp %ph failed w/ status %xh.", Irp, status))
    }

    /*
     *  If the lower driver returned PENDING, mark our stack location as pending also.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }

    DBGSUCCESS(status, FALSE)
    DBG_COMMON_EXIT()
    return status;
}



/*
 ********************************************************************************
 *  HidpIrpMajorWrite
 ********************************************************************************
 *
 *  Note:  This function cannot be pageable code because
 *         writes can happen at dispatch level.
 *
 */
NTSTATUS HidpIrpMajorWrite(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS status;
    PDO_EXTENSION *pdoExt;
    FDO_EXTENSION *fdoExt;
    PIO_STACK_LOCATION currentIrpSp, nextIrpSp;
    BOOLEAN securityCheckOk = FALSE;
    PUCHAR buffer;
    PHIDP_REPORT_IDS reportIdentifier;
    PHIDP_COLLECTION_DESC collectionDesc;
    PHID_XFER_PACKET hidWritePacket;


    DBG_COMMON_ENTRY()

    ASSERT(HidDeviceExtension->isClientPdo);
    pdoExt = &HidDeviceExtension->pdoExt;
    fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);

    if (pdoExt->state != COLLECTION_STATE_RUNNING ||
        fdoExt->state != DEVICE_STATE_START_SUCCESS){
        status = STATUS_DEVICE_NOT_CONNECTED;
        goto HidpIrpMajorWriteDone;
    }

    /*
     *  Get the file extension.
     */
    if (currentIrpSp->FileObject){
        PHIDCLASS_FILE_EXTENSION fileExtension = (PHIDCLASS_FILE_EXTENSION)currentIrpSp->FileObject->FsContext;
        if (fileExtension) {
            ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);
            securityCheckOk = fileExtension->SecurityCheck;
        }
        DBGASSERT(fileExtension, ("Attempted write with no file extension"), FALSE)
    }
    else {
        /*
         *  KBDCLASS can send a NULL FileObject to set LEDs on a keyboard
         *  (it may need to do this for a keyboard which was opened by
         *   the raw user input thread, for which kbdclass has no fileObj).
         *  A write with FileObject==NULL can only come from kernel space,
         *  so we treat this as a secure write.
         */
        securityCheckOk = TRUE;
    }

    /*
     *  Check security.
     */
    if (!securityCheckOk){
        status = STATUS_PRIVILEGE_NOT_HELD;
        goto HidpIrpMajorWriteDone;
    }

    status = HidpCheckIdleState(HidDeviceExtension, Irp);
    if (status != STATUS_SUCCESS) {
        Irp = (status != STATUS_PENDING) ? Irp : (PIRP) BAD_POINTER;
        goto HidpIrpMajorWriteDone;
    }

    buffer = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);
    if (!buffer) {
        status = STATUS_INVALID_USER_BUFFER;
        goto HidpIrpMajorWriteDone;
    }

    /*
     *  Extract the report identifier with the given id from 
     *  the HID device extension. The report id is the first 
     *  byte of the buffer.
     */
    reportIdentifier = GetReportIdentifier(fdoExt, buffer[0]);
    collectionDesc = GetCollectionDesc(fdoExt, HidDeviceExtension->pdoExt.collectionNum);
    if (!collectionDesc || 
        !reportIdentifier) {
        status = STATUS_INVALID_PARAMETER;
        goto HidpIrpMajorWriteDone;
    }
    if (!reportIdentifier->OutputLength){
        status = STATUS_INVALID_PARAMETER;
        goto HidpIrpMajorWriteDone;
    }

    /*
     *  Make sure the caller's buffer is the right size.
     */
    if (currentIrpSp->Parameters.Write.Length != collectionDesc->OutputLength){
        status = STATUS_INVALID_BUFFER_SIZE;
        goto HidpIrpMajorWriteDone;
    }

    /*
     *  All parameters are correct. Allocate the write packet and 
     *  send this puppy down.
     */
    hidWritePacket = ALLOCATEPOOL(NonPagedPool, sizeof(HID_XFER_PACKET));
    if (!hidWritePacket){
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto HidpIrpMajorWriteDone;
    }
        
    /*
     *  Prepare write packet for minidriver.
     */
    hidWritePacket->reportBuffer = buffer;
    hidWritePacket->reportBufferLen = reportIdentifier->OutputLength;

    /*
     *  The client includes the report id as the first byte of the report.
     *  We send down the report byte only if the device has multiple
     *  report IDs (i.e. the report id is not implicit).
     */
    hidWritePacket->reportId = hidWritePacket->reportBuffer[0];
    if (fdoExt->deviceDesc.ReportIDs[0].ReportID == 0){
        ASSERT(hidWritePacket->reportId == 0);
        hidWritePacket->reportBuffer++;
    }

    Irp->UserBuffer = (PVOID)hidWritePacket;

    /*
     *  Prepare the next (lower) IRP stack location.
     *  This will be HIDUSB's "current" stack location.
     */
    nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_WRITE_REPORT;
    nextIrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(HID_XFER_PACKET);

    IoSetCompletionRoutine( Irp,
                            HidpInterruptWriteComplete,
                            (PVOID)HidDeviceExtension,
                            TRUE,
                            TRUE,
                            TRUE );

    status = HidpCallDriver(fdoExt->fdo, Irp);

    /*
     *  The Irp no longer belongs to us, and it can be
     *  completed at any time; so don't touch it.
     */
    Irp = (PIRP)BAD_POINTER;

HidpIrpMajorWriteDone:
    if (ISPTR(Irp)){
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGSUCCESS(status, FALSE)
    DBG_COMMON_EXIT();
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidclass\services.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: 

    services.c

Abstract

    Service entry points exposed by the HID class driver.

Author:

    Forrest Foltz
    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HidRegisterMinidriver)
#endif


/*
 ********************************************************************************
 *  HidRegisterMinidriver
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       This public service is called by a HidOnXxx minidriver from its
 *       driverentry routine to register itself as a newly loaded HID minidriver.
 *
 *       It creates a HIDCLASS_DRIVER_EXTENSION and returns it as reference data
 *       to the minidriver.
 *
 *   Arguments:
 *
 *       MinidriverRegistration - pointer to a registration packet that must be
 *                                completely filled in by the minidriver.
 *
 *   Return Value:
 *
 *      Standard NT return value.
 *
 *
 */
NTSTATUS HidRegisterMinidriver(IN PHID_MINIDRIVER_REGISTRATION MinidriverRegistration)
{
    PHIDCLASS_DRIVER_EXTENSION hidDriverExtension;
    PDRIVER_EXTENSION driverExtension;
    PDRIVER_OBJECT minidriverObject;
    NTSTATUS status;
    PUNICODE_STRING regPath;

    PAGED_CODE();

    if (MinidriverRegistration->Revision > HID_REVISION){
        DBGERR(("Revision mismatch: HIDCLASS revision is %xh, minidriver requires hidclass revision %xh.", HID_REVISION, MinidriverRegistration->Revision))
        status = STATUS_REVISION_MISMATCH;
        goto HidRegisterMinidriverExit;
    }

    /*
     *  Allocate a driver extension for this driver object
     *  and associate it with the object.
     *  (By using this interface, we never have to free
     *   this context; it gets freed when the driver object
     *   is freed).
     */
    status = IoAllocateDriverObjectExtension(
                    MinidriverRegistration->DriverObject,
                    (PVOID)"HIDCLASS",
                    sizeof(HIDCLASS_DRIVER_EXTENSION),
                    &hidDriverExtension
                    );

    if (!NT_SUCCESS(status)){
        goto HidRegisterMinidriverExit;
    }

    RtlZeroMemory(hidDriverExtension, sizeof(HIDCLASS_DRIVER_EXTENSION)); 

    //
    // Fill in various fields in our per-minidriver extension.
    //
    hidDriverExtension->MinidriverObject = MinidriverRegistration->DriverObject;
    hidDriverExtension->DeviceExtensionSize = MinidriverRegistration->DeviceExtensionSize;
    #if DBG
        hidDriverExtension->Signature = HID_DRIVER_EXTENSION_SIG;
    #endif

    //
    // Copy the regpath.
    //
    regPath = &hidDriverExtension->RegistryPath;
    regPath->MaximumLength = MinidriverRegistration->RegistryPath->Length 
        + sizeof (UNICODE_NULL);
    regPath->Buffer = ALLOCATEPOOL(NonPagedPool, regPath->MaximumLength);
    if (!regPath->Buffer) {
        DBGWARN(("Failed unicode string alloc."))
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto HidRegisterMinidriverExit;
    }
    RtlCopyUnicodeString(regPath, MinidriverRegistration->RegistryPath);

    //
    // Make a copy of the minidriver's original dispatch table and AddDevice routine
    //
    minidriverObject = MinidriverRegistration->DriverObject;
    RtlCopyMemory( hidDriverExtension->MajorFunction,
                   minidriverObject->MajorFunction,
                   sizeof( PDRIVER_DISPATCH ) * (IRP_MJ_MAXIMUM_FUNCTION + 1) );

    driverExtension = minidriverObject->DriverExtension;

    hidDriverExtension->DevicesArePolled = MinidriverRegistration->DevicesArePolled;


    //
    // Now set the minidriver's major dispatch functions (the ones that
    // we care about) to our dispatch routine instead
    //

    minidriverObject->MajorFunction[ IRP_MJ_CLOSE ] =
    minidriverObject->MajorFunction[ IRP_MJ_CREATE ] =
    minidriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ] =
    minidriverObject->MajorFunction[ IRP_MJ_INTERNAL_DEVICE_CONTROL ] =
    minidriverObject->MajorFunction[ IRP_MJ_PNP ] =
    minidriverObject->MajorFunction[ IRP_MJ_POWER ] =
    minidriverObject->MajorFunction[ IRP_MJ_READ ] =
    minidriverObject->MajorFunction[ IRP_MJ_WRITE ] =
    minidriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] =
        HidpMajorHandler;

    /*
     *  Hook the lower driver's AddDevice;
     *  our HidpAddDevice will chain the call down to the
     *  miniport's handler.
     */
    ASSERT(driverExtension->AddDevice);
    hidDriverExtension->AddDevice = driverExtension->AddDevice;
    driverExtension->AddDevice = HidpAddDevice;

    /*
     *  Hook the lower driver's Unload
     */
    ASSERT(minidriverObject->DriverUnload);
    hidDriverExtension->DriverUnload = minidriverObject->DriverUnload;
    minidriverObject->DriverUnload = HidpDriverUnload;

    /*
     *  Initialize the ReferenceCount to zero.
     *  It will be incremented for each AddDevice and decremented for
     *  each REMOVE_DEVICE.
     */
    hidDriverExtension->ReferenceCount = 0;

    //
    // Place the hid driver extension on our global list so we can find
    // it later (given a pointer to the minidriver object for which it
    // was created
    //
    if (!EnqueueDriverExt(hidDriverExtension)){
        status = STATUS_DEVICE_CONFIGURATION_ERROR;
    }
    
HidRegisterMinidriverExit:
    DBGSUCCESS(status, TRUE)
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hiddll\hiddll.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    HIDDLL.H

Abstract:

    This module contains the PRIVATE definitions for the
    code that implements the HID dll.

Environment:

    Kernel & user mode

Revision History:

    Aug-96 : created by Kenneth Ray

--*/


#ifndef _HIDDLL_H
#define _HIDDLL_H


#define malloc(size) LocalAlloc (LPTR, size)
#define ALLOCATION_SHIFT 4
#define RANDOM_DATA PtrToUlong(&HidD_Hello)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hiddll\hiddll.c ===
#include <stdlib.h>
#include <wtypes.h>

#include "initguid.h"
#include "hidclass.h"

#include "hidsdi.h"
#include "hiddll.h"


#include <winioctl.h>

//
// __cdecl main (int argc, char *argv[])
// {
//    return 0;
// }
//

int HidD_Hello (char * buff, int len)
{
   CHAR ret[] = "Hello\n";
   ULONG length = (sizeof (ret) < len) ? sizeof (ret) : len;

   memcpy (buff, ret, length);
   return sizeof (ret);
}



void __stdcall
HidD_GetHidGuid (
   OUT   LPGUID      HidGuid
   )
/*++
Routine Description:
   Please see hidsdi.h for explination

Notes:
--*/
{
    memcpy (HidGuid, &(GUID_CLASS_INPUT), sizeof (struct _GUID));
   *HidGuid = (GUID_CLASS_INPUT);
}

BOOLEAN __stdcall
HidD_GetPreparsedData (
   IN    HANDLE                  HidDeviceObject,
   OUT   PHIDP_PREPARSED_DATA  * PreparsedData
   )
/*++
Routine Description:
   please see hidsdi.h for explination

Notes:
--*/
{
   HID_COLLECTION_INFORMATION info;
   ULONG                      bytes;
   PULONG                     buffer;

   if (! DeviceIoControl (HidDeviceObject,
                          IOCTL_HID_GET_COLLECTION_INFORMATION,
                          0, 0,
                          &info, sizeof (info),
                          &bytes, NULL)) {
      return FALSE;
   }

   buffer = (PULONG) malloc (  info.DescriptorSize
                             + (ALLOCATION_SHIFT * sizeof (ULONG)));
   if (!buffer)
   {
      SetLastError (ERROR_NOT_ENOUGH_MEMORY);
      return FALSE;
   }

   *buffer = RANDOM_DATA;
   *PreparsedData = (PHIDP_PREPARSED_DATA) (buffer + ALLOCATION_SHIFT);

   return DeviceIoControl (HidDeviceObject,
                           IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                           0, 0,
                           *PreparsedData, info.DescriptorSize,
                           &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetAttributes (
    IN  HANDLE              HidDeviceObject,
    OUT PHIDD_ATTRIBUTES    Attributes
    )
/*++
Routine Description:
    Please see hidsdi.h for explination

--*/
{
    HID_COLLECTION_INFORMATION  info;
    ULONG                       bytes;

    if (! DeviceIoControl (HidDeviceObject,
                           IOCTL_HID_GET_COLLECTION_INFORMATION,
                           0, 0,
                           &info, sizeof (info),
                           &bytes, NULL)) {
        return FALSE;
    }

    Attributes->Size = sizeof (HIDD_ATTRIBUTES);
    Attributes->VendorID = info.VendorID;
    Attributes->ProductID = info.ProductID;
    Attributes->VersionNumber = info.VersionNumber;

    return TRUE;
}

BOOLEAN __stdcall
HidD_FreePreparsedData (
   IN   PHIDP_PREPARSED_DATA  PreparsedData
   )
/*++
Routine Description:
   please see hidsdi.h for explination

Notes:
--*/
{
   PULONG buffer;

   buffer = (PULONG) PreparsedData - ALLOCATION_SHIFT;

   if (RANDOM_DATA != *buffer) {
      return FALSE;
   }

   LocalFree (buffer);
   return TRUE;
}


BOOLEAN __stdcall
HidD_FlushQueue (
   IN    HANDLE            HidDeviceObject
   )
/*++
Routine Description:
   Please see hidsdi.h for explination

Notes:
--*/
{
   ULONG bytes;
   return DeviceIoControl (HidDeviceObject,
                           IOCTL_HID_FLUSH_QUEUE,
                           0, 0,
                           0, 0,
                           &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetConfiguration (
   IN   HANDLE               HidDeviceObject,
   OUT  PHIDD_CONFIGURATION  Configuration,
   IN   ULONG                ConfigurationLength
   )
/*++
Routine Description:
   Please see hidsdi.h for explination

Notes:
   We place a goo at the top so that we can enforce the must get before set
   rule.
--*/
{
   ULONG       bytes;

   Configuration->cookie = &HidD_GetConfiguration;

   return DeviceIoControl (HidDeviceObject,
                           IOCTL_HID_GET_DRIVER_CONFIG,
                           0,0,
                           &Configuration->size,
                           (ConfigurationLength - 4),
                           &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_SetConfiguration (
   IN   HANDLE               HidDeviceObject,
   OUT  PHIDD_CONFIGURATION  Configuration,
   IN   ULONG                ConfigurationLength
   )
/*++
Routine Description:
   Please see hidsdi.h for explanation

Notes:
   We place a goo at the top so that we can enforce the must get before set
   rule.
--*/
{
   ULONG       bytes;

   if (Configuration->cookie != &HidD_GetConfiguration) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
   }

   return DeviceIoControl (HidDeviceObject,
                           IOCTL_HID_SET_DRIVER_CONFIG,
                           0,0,
                           &Configuration->size, (ConfigurationLength - 4),
                           &bytes, NULL) != FALSE;
}

STDAPI_(BOOL)
Entry32(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {
        default: return TRUE;
        }
}

BOOLEAN __stdcall
DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
   switch (dwReason)
   {
      default: return TRUE;
   }
}

BOOLEAN __stdcall
HidD_GetNumInputBuffers (
    IN  HANDLE  HidDeviceObject,
    OUT PULONG  NumberBuffers) // Number of hid packets actually retained
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS,
                            NULL, 0,
                            NumberBuffers, sizeof (ULONG),
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_SetNumInputBuffers (
    IN  HANDLE HidDeviceObject,
    OUT ULONG  NumberBuffers) // Number of hid packets actually retained
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS,
                            &NumberBuffers, sizeof (ULONG),
                            NULL, 0,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetSerialNumberString (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    Buffer,
   IN    ULONG    BufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_SERIALNUMBER_STRING,
                            0, 0,
                            Buffer, BufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetManufacturerString (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    Buffer,
   IN    ULONG    BufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_MANUFACTURER_STRING,
                            0, 0,
                            Buffer, BufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetProductString (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    Buffer,
   IN    ULONG    BufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_PRODUCT_STRING,
                            0, 0,
                            Buffer, BufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetIndexedString (
    IN  HANDLE  HidDeviceObject,
    IN  ULONG   StringIndex,
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength
    )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_INDEXED_STRING,
                            &StringIndex, sizeof (ULONG),
                            Buffer, BufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetPhysicalDescriptor (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_GET_PHYSICAL_DESCRIPTOR,
                            0, 0,
                            ReportBuffer, ReportBufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetFeature (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_FEATURE,
                            0, 0,
                            ReportBuffer, ReportBufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_SetFeature (
   IN    HANDLE   HidDeviceObject,
   IN    PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_SET_FEATURE,
                            ReportBuffer, ReportBufferLength,
                            0, 0,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetInputReport (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_INPUT_REPORT,
                            0, 0,
                            ReportBuffer, ReportBufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_SetOutputReport (
   IN    HANDLE   HidDeviceObject,
   IN    PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_SET_OUTPUT_REPORT,
                            ReportBuffer, ReportBufferLength,
                            0, 0,
                            &bytes, NULL) != FALSE;
}


BOOLEAN __stdcall
HidD_GetMsGenreDescriptor (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_MS_GENRE_DESCRIPTOR,
                            0, 0,
                            ReportBuffer, ReportBufferLength,
                            &bytes, NULL) != FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hiddll\query.c ===
#define HIDPARSE_USERMODE
#include "..\hidparse\query.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hiddll\trnslate.c ===
#include "..\hidparse\trnslate.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hiddll\hidserv.c ===
/*++
 *
 *  Component:  hidserv.exe
 *  File:       hidserv.c
 *  Purpose:    main entry and NT service routines.
 * 
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#include <windows.h>
#include <shlwapi.h>
#include <tchar.h>

CHAR HidservServiceName[] = "HidServ";
CHAR HidservDisplayName[] = "HID Input Service";


void 
StartHidserv(
    void
    ) 
/*++
Routine Description:
    Cal the SCM to start the NT service.
--*/
{
    SC_HANDLE hSCM;
    SC_HANDLE hService;
    SERVICE_STATUS curStatus;
    BOOL Ret;

    // Open the SCM on this machine.
    hSCM = OpenSCManager(   NULL, 
                            NULL, 
                            SC_MANAGER_CONNECT);

    if (hSCM) {
        // Open this service for START access
        hService = OpenService( hSCM, 
                                HidservServiceName, 
                                SERVICE_START);

        if(hService) {

            // Start this service.
            Ret = StartService( hService, 
                                0,
                                NULL);
            
            // Close the service and the SCM
            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hSCM);
    }
}

void 
StopHidserv(
    void
    ) 
/*++
Routine Description:
    Cal the SCM to stop the NT service.
--*/
{
    SC_HANDLE hSCM;
    SC_HANDLE hService;
    SERVICE_STATUS Status;
    BOOL Ret;

    // Open the SCM on this machine.
    hSCM = OpenSCManager(   NULL, 
                            NULL, 
                            SC_MANAGER_CONNECT);

    if (hSCM) {
        // Open this service for DELETE access
        hService = OpenService( hSCM, 
                                HidservServiceName, 
                                SERVICE_STOP);

        if(hService) {
            // Stop this service.
            Ret = ControlService(   hService,
                                    SERVICE_CONTROL_STOP,
                                    &Status);

            CloseServiceHandle(hService);
        }
        CloseServiceHandle(hSCM);
    }
}


void 
InstallHidserv(
    void
    ) 
/*++
Routine Description:
    Install the NT service to Auto-start with no dependencies.
--*/
{
    SC_HANDLE hService;
    SC_HANDLE hSCM;
    TCHAR szModulePathname[] = "%SystemRoot%\\system32\\svchost.exe -k netsvcs";
    TCHAR szParameterKeyName[] = "System\\CurrentControlSet\\Services\\HidServ\\Parameters";
    TCHAR szServiceValName[] = "ServiceDll";
    TCHAR szServiceName[] = "HidServ";
    TCHAR szGroupName[] = "shsvc";

    TCHAR szSvcHostRegKey[] = "Software\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost";
    TCHAR szValue[] = TEXT("%SystemRoot%\\System32\\hidserv.dll");

    // Open the SCM on this machine.
    hSCM = OpenSCManager(   NULL, 
                            NULL, 
                            SC_MANAGER_CREATE_SERVICE);

    if (hSCM) {
        // The service should exist, so this should fail
        hService = CreateService(   hSCM, 
                                    HidservServiceName, 
                                    HidservDisplayName, 
                                    SERVICE_ALL_ACCESS,
                                    SERVICE_WIN32_SHARE_PROCESS, 
                                    SERVICE_AUTO_START, 
                                    SERVICE_ERROR_NORMAL, 
                                    szModulePathname, 
                                    NULL, NULL, NULL,
                                    NULL, NULL);
         
        // If for some reason the service had been removed, manually set registry values  
        if(hService) {
            HKEY hKey;
            LONG status;
                        
            status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                    szParameterKeyName,
                                    0,
                                    NULL,
                                    0,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKey,
                                    NULL);

            if(status == ERROR_SUCCESS) {
            
                status = RegSetValueEx(hKey,
                                       szServiceValName,
                                       0,
                                       REG_EXPAND_SZ,
                                       szValue,
                                       _tcslen(szValue));
               
                RegCloseKey(hKey);

            }

            status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                  szSvcHostRegKey,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hKey);
            if(status == ERROR_SUCCESS) {

                DWORD dwSize = 0;
                TCHAR* szData;
               
                status = RegQueryValueEx(hKey,
                                         szGroupName,
                                         0,
                                         NULL,
                                         NULL,
                                         &dwSize);
                if(status == ERROR_SUCCESS) {
                  
                    dwSize += (_tcslen(szServiceName)+2) * sizeof(TCHAR);
                    szData = (TCHAR*) malloc (dwSize);

                    if(szData) {
                        RegQueryValueEx(hKey,
                                        szGroupName,
                                        0,
                                        NULL,
                                        (LPBYTE) szData,
                                        &dwSize);

                        if(_tcsstr(szData, szServiceName) == NULL) {                  
                            szData = _tcscat(szData, TEXT(" "));
                            szData = _tcscat(szData, szServiceName);
                            RegSetValueEx(hKey,
                                          szGroupName,
                                          0,
                                          REG_MULTI_SZ,
                                          (LPBYTE) szData,
                                          _tcslen(szData));
                        }

                        free(szData);

                    }

                }
                RegCloseKey(hKey);
            }
               

            CloseServiceHandle(hService);

        } else {

            // Service exists, set to autostart
               
            hService = OpenService(hSCM,
                                   HidservServiceName,
                                   SERVICE_ALL_ACCESS);
            if (hService) {
                QUERY_SERVICE_CONFIG config;
                DWORD junk;
                HKEY hKey;
                LONG status;

                if (ChangeServiceConfig(hService,
                                        SERVICE_NO_CHANGE,
                                        SERVICE_AUTO_START,
                                        SERVICE_NO_CHANGE,
                                        NULL, NULL, NULL,
                                        NULL, NULL, NULL,
                                        HidservDisplayName)) {
                    // Wait until we're configured correctly.
                    while (QueryServiceConfig(hService, 
                                              &config,
                                              sizeof(config),
                                              &junk)) {
                        if (config.dwStartType == SERVICE_AUTO_START) {
                            break;
                        }
                    }
                }

                CloseServiceHandle(hService);
            }

        }
        CloseServiceHandle(hSCM);

    }

    // Go ahead and start the service for no-reboot install.
    StartHidserv();
}


void 
RemoveHidserv(
    void
    ) 
/*++
Routine Description:
    Remove the NT service from the registry database.
--*/
{
    SC_HANDLE hSCM;
    SC_HANDLE hService;

    // Stop the service first
    StopHidserv();
    
    // Open the SCM on this machine.
    hSCM = OpenSCManager(   NULL, 
                            NULL, 
                            SC_MANAGER_CONNECT);

    if (hSCM) {
        // Open this service for DELETE access
        hService = OpenService( hSCM, 
                                HidservServiceName, 
                                DELETE);

        if(hService) {
            // Remove this service from the SCM's database.
            DeleteService(hService);
            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hSCM);
    }
}

void 
CALLBACK
HidservInstaller(
    HWND        hwnd,
    HINSTANCE   hInstance, 
    LPSTR       szCmdLine, 
    int         iCmdShow
    )
/*++
Routine Description:
    HidServ starts as an NT Service (started by the SCM) unless
    a command line param is passed in. Command line params may be 
    used to start HidServ as a free-standing app, or to control
    the NT service.

    If compiled non-unicode, we bypass all the NT stuff.
--*/
{
   if(!szCmdLine){
        return;
   }else{
      if ((szCmdLine[0] == '-') || (szCmdLine[0] == '/')) {
         // Command line switch
         if (StrCmpI(&szCmdLine[1], "install") == 0) {
             InstallHidserv();
         } else if (StrCmpI(&szCmdLine[1], "remove")  == 0) {
             RemoveHidserv();
         } else if (StrCmpI(&szCmdLine[1], "stop")  == 0) {
             StopHidserv();
         } else {
             StartHidserv();
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidir\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Human Input Device (HID) minidriver for Infrared (IR) devices

          The HID IR Minidriver (HidIr) provides an abstraction layer for the
          HID Class to talk to HID IR devices.

Author:
            jsenior

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"


NTSTATUS
HidIrIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Process the Control IRPs sent to this device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION  irpStack;
    BOOLEAN             needsCompletion = TRUE;

    HidIrKdPrint((3, "HidIrIoctl Enter"));

    //
    // Get a pointer to the current location in the Irp
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get a pointer to the device extension
    //

    switch(irpStack->Parameters.DeviceIoControl.IoControlCode)
    {

    case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
        //
        //  Return the HID descriptor
        //

        HidIrKdPrint((3, "IOCTL_HID_GET_DEVICE_DESCRIPTOR"));
        ntStatus = HidIrGetHidDescriptor (DeviceObject, Irp, HID_HID_DESCRIPTOR_TYPE);
        break;

    case IOCTL_HID_GET_REPORT_DESCRIPTOR:
        //
        //  Return the Report descriptor
        //

        HidIrKdPrint((3, "IOCTL_HID_GET_REPORT_DESCRIPTOR"));
        ntStatus = HidIrGetHidDescriptor (DeviceObject, Irp, HID_REPORT_DESCRIPTOR_TYPE);
        break;

    case IOCTL_GET_PHYSICAL_DESCRIPTOR:
        //
        //  Return the Report descriptor
        //

        HidIrKdPrint((3, "IOCTL_HID_GET_REPORT_DESCRIPTOR"));
        ntStatus = HidIrGetHidDescriptor (DeviceObject, Irp, HID_PHYSICAL_DESCRIPTOR_TYPE);
        break;

    case IOCTL_HID_READ_REPORT:
        //
        //  Perform a read
        //

        HidIrKdPrint((3, "IOCTL_HID_READ_REPORT"));
        ntStatus = HidIrReadReport (DeviceObject, Irp, &needsCompletion);
        break;

    case IOCTL_HID_WRITE_REPORT:
        //
        //  Perform a write
        //

        HidIrKdPrint((3, "IOCTL_HID_WRITE_REPORT not supported for IR"));
        ntStatus = STATUS_UNSUCCESSFUL;
        break;

    case IOCTL_HID_ACTIVATE_DEVICE:
    case IOCTL_HID_DEACTIVATE_DEVICE:
        /*
         *  We don't do anything for these IOCTLs but some minidrivers might.
         */
        ntStatus = STATUS_SUCCESS;
        break;

    case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
        HidIrKdPrint((3, "IOCTL_GET_DEVICE_ATTRIBUTES"));
        ntStatus = HidIrGetDeviceAttributes(DeviceObject, Irp);
        break;

    case IOCTL_HID_GET_FEATURE:
    case IOCTL_HID_GET_INPUT_REPORT:
    case IOCTL_HID_SET_FEATURE:
    case IOCTL_HID_SET_OUTPUT_REPORT:
    case IOCTL_HID_GET_MS_GENRE_DESCRIPTOR:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         *  If the IRP is coming to us from user space,
         *  we must validate the buffer.
         */

    case IOCTL_HID_GET_STRING:
    case IOCTL_HID_GET_INDEXED_STRING:
        // Strings.
    case IOCTL_HID_SEND_IDLE_NOTIFICATION_REQUEST:
        // ntStatus = HidIrSendIdleNotificationRequest(DeviceObject, Irp, &needsCompletion);
        // break;

    default:
        HidIrKdPrint((3, "Unknown or unsupported IOCTL (%x)", irpStack->Parameters.DeviceIoControl.IoControlCode));
        /*
         *  Note: do not return STATUS_NOT_SUPPORTED;
         *  Just keep the default status (this allows filter drivers to work).
         */
        ntStatus = Irp->IoStatus.Status;
        break;

    }


    //
    // Complete Irp
    //

    if (needsCompletion) {
        ASSERT(ntStatus != STATUS_PENDING);

        //
        // Set real return status in Irp
        //

        Irp->IoStatus.Status = ntStatus;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    } 

    HidIrKdPrint((3, "HidIrIoctl Exit = %x", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidir\hidir.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    hidir.c

Abstract: Human Input Device (HID) minidriver that creates an example
        device.

--*/
#include "pch.h"

VOID
HidIrCheckIfMediaCenter();

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,HidIrCheckIfMediaCenter)
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING registryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    registryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    HID_MINIDRIVER_REGISTRATION HidIrdriverRegistration;

    HidIrKdPrint((3, "DriverEntry Enter"));

    HidIrKdPrint((3, "DriverObject (%lx)", DriverObject));

    //
    // Create dispatch points
    //
    // All of the other dispatch routines are handled by HIDCLASS, except for
    // IRP_MJ_POWER, which isn't implemented yet.
    //

    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = HidIrIoctl;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = HidIrPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = HidIrPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = HidIrSystemControl;
    DriverObject->DriverExtension->AddDevice                    = HidIrAddDevice;
    DriverObject->DriverUnload                                  = HidIrUnload;

    //
    // Register Sample layer with HIDCLASS.SYS module
    //

    HidIrdriverRegistration.Revision              = HID_REVISION;
    HidIrdriverRegistration.DriverObject          = DriverObject;
    HidIrdriverRegistration.RegistryPath          = registryPath;
    HidIrdriverRegistration.DeviceExtensionSize   = sizeof(HIDIR_EXTENSION);

    //  HIDIR does not need to be polled.
    HidIrdriverRegistration.DevicesArePolled      = FALSE;

    HidIrKdPrint((3, "DeviceExtensionSize = %x", HidIrdriverRegistration.DeviceExtensionSize));

    HidIrKdPrint((3, "Registering with HIDCLASS.SYS"));

    HidIrCheckIfMediaCenter();

    //
    // After registering with HIDCLASS, it takes over control of the device, and sends
    // things our way if they need device specific processing.
    //
    status = HidRegisterMinidriver(&HidIrdriverRegistration);

    HidIrKdPrint((3, "DriverEntry Exit = %x", status));

    return status;
}

ULONG RunningMediaCenter;

VOID
HidIrCheckIfMediaCenter()
{
    OBJECT_ATTRIBUTES attributes;
    HANDLE skuRegKey;
    NTSTATUS status;
    ULONG resultLength;
    UNICODE_STRING regString;
    UCHAR buffer[sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( ULONG )];

    PAGED_CODE();
    
    RunningMediaCenter = 0;

    //
    //  Open the MediaCenter SKU registry key
    //

    RtlInitUnicodeString( &regString, L"\\REGISTRY\\MACHINE\\SYSTEM\\WPA\\MediaCenter" );
    InitializeObjectAttributes( &attributes,
                                &regString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    status = ZwOpenKey( &skuRegKey,
                        KEY_READ,
                        &attributes );

    if (!NT_SUCCESS( status )) {
        return;
    }

    //
    // Read the Installed value from the registry.
    //

    RtlInitUnicodeString( &regString, L"Installed" );

    status = ZwQueryValueKey( skuRegKey,
                              &regString,
                              KeyValuePartialInformation,
                              buffer,
                              sizeof(buffer),
                              &resultLength );


    if (NT_SUCCESS( status )) {
        PKEY_VALUE_PARTIAL_INFORMATION info = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        if (info->DataLength == sizeof(ULONG)) {
            RunningMediaCenter = *((ULONG*) &((info)->Data));
        }
    } 

    //
    //  Close the registry entry
    //

    ZwClose(skuRegKey);
}

NTSTATUS
HidIrAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Process AddDevice.  Provides the opportunity to initialize the DeviceObject or the
    DriverObject.

Arguments:

    DriverObject - pointer to the driver object.

    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PHIDIR_EXTENSION       deviceExtension;
    LARGE_INTEGER timeout;
    timeout.HighPart = -1;
    timeout.LowPart = -1;

    HidIrKdPrint((3, "HidIrAddDevice Entry"));

    deviceExtension = GET_MINIDRIVER_HIDIR_EXTENSION( DeviceObject );

    deviceExtension->NumPendingRequests = 0;
    KeInitializeEvent( &deviceExtension->AllRequestsCompleteEvent,
                       NotificationEvent,
                       FALSE);

    deviceExtension->DeviceState = DEVICE_STATE_NONE;
    deviceExtension->DeviceObject = DeviceObject;
    deviceExtension->VersionNumber = 0x110;
//    deviceExtension->VendorID = 0x045e;
//    deviceExtension->ProductID = 0x006d;

    // Predispose timer to signalled.
    KeInitializeTimer(&deviceExtension->IgnoreStandbyTimer);
    KeSetTimer(&deviceExtension->IgnoreStandbyTimer, timeout, NULL);

    HidIrKdPrint((3, "HidIrAddDevice Exit = %x", status));

    return status;
}



VOID
HidIrUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc. in anticipation of this driver being unloaded.

Arguments:

    DriverObject - pointer to the driver object.

Return Value:

    VOID.

--*/
{
    HidIrKdPrint((3, "HidIrUnload Enter"));

    HidIrKdPrint((3, "Unloading DriverObject = %x", DriverObject));

    HidIrKdPrint((3, "Unloading Exit = VOID"));
}

NTSTATUS
HidIrSynchronousCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    UNREFERENCED_PARAMETER (DeviceObject);

    KeSetEvent ((PKEVENT) Context, 1, FALSE);
    // No special priority
    // No Wait

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}

NTSTATUS
HidIrCallDriverSynchronous(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    KEVENT event;
    NTSTATUS status;

    // Set next stack location

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           HidIrSynchronousCompletion,
                           &event,    // context
                           TRUE,
                           TRUE,
                           TRUE );
    status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

    if (status == STATUS_PENDING) {
       // wait for it...
       KeWaitForSingleObject(&event,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL);
       status = Irp->IoStatus.Status;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidir\dbg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    debug macros

Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__

#define HIDIR_TAG          'BdiH'        //"HidB"


#if DBG
/**********
DUBUG
***********/

//
// This Breakpoint means we either need to test the code path
// somehow or the code is not implemented.  ie either case we
// should not have any of these when the driver is finished
// and tested
//

#define HIR_TRAP()          {\
                            DbgPrint("<HB TRAP> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                            }


ULONG
_cdecl
HidIrKdPrintX(
    ULONG l,
    PCH Format,
    ...
    );

#define   HidIrKdPrint(_x_) HidIrKdPrintX _x_

#else
/**********
RETAIL
***********/

// debug macros for retail build

#define HIR_TRAP()
#define HidIrKdPrint(_x_)

#endif /* DBG */

#endif /* __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidir\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract


Author:

    Jay Senior

Environment:

    Kernel mode only

Revision History:


--*/



#include <wdm.h>
#include <hidport.h>
#include <hidpddi.h>
#include "hidir.h"
#include "dbg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidir\dbg.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Debug functions and services

Environment:

    kernel mode only

Notes:

Revision History:

    12/12/2001 : created jsenior

--*/

#include "pch.h"
#include "stdarg.h"
#include "stdio.h"

// paged functions
#ifdef ALLOC_PRAGMA
#endif

#if DBG

/******
DEBUG
******/

#define  DEFAULT_DEBUG_LEVEL    1

ULONG HidIrDebug_Trace_Level = DEFAULT_DEBUG_LEVEL;


ULONG
_cdecl
HidIrKdPrintX(
    ULONG l,
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function.

    Prints based on the value of the HidIrDEBUG_TRACE_LEVEL

    Also if HidIrW98_Debug_Trace is set then all debug messages
    with a level greater than one are modified to go in to the
    ntkern trace buffer.

    It is only valid to set HidIrW98_Debug_Trace on Win9x
    becuse the static data segments for drivers are marked read-only
    by the NT OS.

Arguments:

Return Value:


--*/
{
    va_list list;
    int i;
    int arg[6];

    if (HidIrDebug_Trace_Level >= l) {
        // dump line to debugger
        DbgPrint("'HIDIR.SYS: ");

        va_start(list, Format);
        for (i=0; i<6; i++)
            arg[i] = va_arg(list, int);

        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);
        DbgPrint("\n");
    }

    return 0;
}

#endif /* DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidir\hidir.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    hidir.h

--*/
#ifndef __HIDIR_H__
#define __HIDIR_H__

#include <hidusage.h>

//
//  Declarations of HID descriptor formats
//

#include <PSHPACK1.H>

typedef UCHAR HID_REPORT_DESCRIPTOR, *PHID_REPORT_DESCRIPTOR;

typedef UCHAR HID_PHYSICAL_DESCRIPTOR, *PHID_PHYSICAL_DESCRIPTOR;

typedef struct _HIDIR_DESCRIPTOR
{
    UCHAR   bLength;
    UCHAR   bDescriptorType;
    USHORT  bcdHID;
    UCHAR   bCountry;
    UCHAR   bNumDescriptors;

    /*
     *  This is an array of one OR MORE descriptors.
     */
    struct _HIDIR_DESCRIPTOR_DESC_LIST {
       UCHAR   bDescriptorType;
       USHORT  wDescriptorLength;
    } DescriptorList [1];

} HIDIR_DESCRIPTOR, * PHIDIR_DESCRIPTOR;

#include <POPPACK.H>

// Pool
#define HIDIR_POOL_TAG 'IdiH'
#define ALLOCATEPOOL(poolType, size) ExAllocatePoolWithTag((poolType), (size), HIDIR_POOL_TAG)

//
//  Device Extension
//
//  This data structure is hooked onto HIDCLASS' device extension, so both drivers can
//  have their own private data on each device object.
//

#define HIDIR_REPORT_SIZE sizeof(ULONG)
#define HIDIR_TABLE_ENTRY_SIZE(rl) (sizeof(ULONG) + (((rl)+0x00000003)&(~0x00000003)))

typedef struct _USAGE_TABLE_ENTRY {
    ULONG IRString;
    UCHAR UsageString[1];
} USAGE_TABLE_ENTRY, *PUSAGE_TABLE_ENTRY;

typedef struct _HIDIR_EXTENSION
{
    // What state has pnp got me in?
    ULONG                           DeviceState;

    // Ref counting
    LONG                            NumPendingRequests;
    KEVENT                          AllRequestsCompleteEvent;

    // My hid bth device object.
    PDEVICE_OBJECT                  DeviceObject;

    // Descriptors: HID, report, and physical
    HIDIR_DESCRIPTOR                HidDescriptor;
    PHID_REPORT_DESCRIPTOR          ReportDescriptor;
    ULONG                           ReportLength;

    BOOLEAN                         QueryRemove;

    // VID, PID, and version
    USHORT                          VendorID;
    USHORT                          ProductID;
    USHORT                          VersionNumber;

    ULONG                           NumUsages;
    PUCHAR                          MappingTable;
    USAGE_TABLE_ENTRY               PreviousButton;
    BOOLEAN                         ValidUsageSentLastTime[3];

    BOOLEAN                         KeyboardReportIdValid;
    UCHAR                           KeyboardReportId;
    BOOLEAN                         StandbyReportIdValid;
    UCHAR                           StandbyReportId;

    DEVICE_POWER_STATE              DevicePowerState;
    KTIMER                          IgnoreStandbyTimer;
} HIDIR_EXTENSION, *PHIDIR_EXTENSION;

#define DEVICE_STATE_NONE           0
#define DEVICE_STATE_STARTING       1
#define DEVICE_STATE_RUNNING        2
#define DEVICE_STATE_STOPPING       3
#define DEVICE_STATE_STOPPED        4
#define DEVICE_STATE_REMOVING       5

//
// Device Extension Macros
//

#define GET_MINIDRIVER_HIDIR_EXTENSION(DO) ((PHIDIR_EXTENSION) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->MiniDeviceExtension))

#define GET_NEXT_DEVICE_OBJECT(DO) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->NextDeviceObject)

//
// Turn on debug printing and breaking, if appropriate
//

#if DBG
#define DBGPrint(arg) DbgPrint arg
#define DBGBREAK DbgBreakPoint()
#else
#define DBGPrint(arg)
#define DBGBREAK
#endif

//
// Function prototypes
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING registryPath
    );

NTSTATUS
HidIrIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidIrPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidIrPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidIrAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FunctionalDeviceObject
    );

VOID
HidIrUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
HidIrGetDeviceAttributes(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidIrGetHidDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN USHORT DescriptorType
    );

NTSTATUS
HidIrReadReport(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    OUT BOOLEAN *NeedsCompletion
    );

NTSTATUS
HidIrIncrementPendingRequestCount(
    IN PHIDIR_EXTENSION DeviceExtension
    );

VOID
HidIrDecrementPendingRequestCount(
    IN PHIDIR_EXTENSION DeviceExtension
    );

NTSTATUS
HidIrSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidIrSynchronousCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
HidIrCallDriverSynchronous(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

extern ULONG RunningMediaCenter;

#endif // _HIDIR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidir\hid.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hid.c

Abstract: Human Input Device (HID) minidriver for Infrared (IR) devices

          The HID IR Minidriver (HidIr) provides an abstraction layer for the
          HID Class to talk to HID IR devices.

Author:
            jsenior

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"

PVOID
HidIrGetSystemAddressForMdlSafe(PMDL MdlAddress)
{
    PVOID buf = NULL;
    /*
     *  Can't call MmGetSystemAddressForMdlSafe in a WDM driver,
     *  so set the MDL_MAPPING_CAN_FAIL bit and check the result
     *  of the mapping.
     */
    if (MdlAddress) {
        MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
        buf = MmGetSystemAddressForMdl(MdlAddress);
        MdlAddress->MdlFlags &= ~(MDL_MAPPING_CAN_FAIL);
    }
    return buf;
}

/*
 ********************************************************************************
 *  HidIrGetHidDescriptor
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       Return the hid descriptor of the requested type. This ioctl can only 
 *       be sent from the HidClass driver. The hidclass driver always sends the
 *       irp with a userbuffer, so there is no need to check for its existence.
 *       But better safe then sorry...
 *
 *   Arguments:
 *
 *       DeviceObject - pointer to a device object.
 *
 *   Return Value:
 *
 *       NT status code.
 *
 */
NTSTATUS HidIrGetHidDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    USHORT DescriptorType
    )
{
    PHIDIR_EXTENSION devExt;
    PIO_STACK_LOCATION  irpStack;
    ULONG descLength = 0, bytesToCopy;
    PUCHAR descriptor = NULL;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrGetHidDescriptor type %x", DescriptorType));

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    bytesToCopy = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    switch (DescriptorType) {
    case HID_HID_DESCRIPTOR_TYPE:
        descLength = devExt->HidDescriptor.bLength;
        descriptor = (PUCHAR)&devExt->HidDescriptor;
        break;
    case HID_REPORT_DESCRIPTOR_TYPE:
        descLength = devExt->HidDescriptor.DescriptorList[0].wDescriptorLength;
        descriptor = devExt->ReportDescriptor;
        break;
    case HID_PHYSICAL_DESCRIPTOR_TYPE:
        // Not handled
        break;
    default:
        HIR_TRAP();
    }

    if (descLength == 0 ||
        descriptor == NULL) {
        return STATUS_UNSUCCESSFUL;
    }
    
    if (bytesToCopy > descLength) {
        bytesToCopy = descLength;
    }

    if (Irp->UserBuffer) {
        RtlCopyMemory((PUCHAR)Irp->UserBuffer, descriptor, bytesToCopy);
        Irp->IoStatus.Information = bytesToCopy;
    } else {
        HIR_TRAP();
        return STATUS_INVALID_USER_BUFFER;
    }

    return STATUS_SUCCESS;
}


/*
 ********************************************************************************
 *  HidIrGetDeviceAttributes
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       Fill in the given struct _HID_DEVICE_ATTRIBUTES. This ioctl can only 
 *       be sent from the HidClass driver. The hidclass driver always sends the
 *       irp with a userbuffer, so there is no need to check for its existence.
 *       But better safe then sorry...
 *
 *   Arguments:
 *
 *       DeviceObject - pointer to a device object.
 *
 *   Return Value:
 *
 *       NT status code.
 *
 */
NTSTATUS HidIrGetDeviceAttributes(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS ntStatus;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrGetDeviceAttributes Enter"));

    if (Irp->UserBuffer) {

        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
        PHID_DEVICE_ATTRIBUTES deviceAttributes = 
            (PHID_DEVICE_ATTRIBUTES) Irp->UserBuffer;

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength >=
            sizeof (HID_DEVICE_ATTRIBUTES)){

            PHIDIR_EXTENSION devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

            //
            // Report how many bytes were copied
            //
            Irp->IoStatus.Information = sizeof (HID_DEVICE_ATTRIBUTES);

            deviceAttributes->Size = sizeof (HID_DEVICE_ATTRIBUTES);
            // TODO: Get these values from the bth stack.
            deviceAttributes->VendorID = devExt->VendorID;
            deviceAttributes->ProductID = devExt->ProductID;
            deviceAttributes->VersionNumber = devExt->VersionNumber;
            ntStatus = STATUS_SUCCESS;
        } else {
            ntStatus = STATUS_INVALID_BUFFER_SIZE;
        }
    } else {
        HIR_TRAP();
        ntStatus = STATUS_INVALID_USER_BUFFER;
    }
                
    ASSERT(NT_SUCCESS(ntStatus));
    return ntStatus;
}


/*
 ********************************************************************************
 *  HidIrIncrementPendingRequestCount
 ********************************************************************************
 *
 *
 */
NTSTATUS HidIrIncrementPendingRequestCount(IN PHIDIR_EXTENSION DevExt)
{
    LONG newRequestCount;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    newRequestCount = InterlockedIncrement(&DevExt->NumPendingRequests);

    HidIrKdPrint((3, "Increment Pending Request Count to %x", newRequestCount));

    // Make sure that the device is capable of receiving new requests.
    if ((DevExt->DeviceState != DEVICE_STATE_RUNNING) &&
        (DevExt->DeviceState != DEVICE_STATE_STARTING)){

        HIR_TRAP();

        // Device cannot receive any more IOs, decrement back, fail the increment
        HidIrDecrementPendingRequestCount(DevExt);
        ntStatus = STATUS_NO_SUCH_DEVICE;
    }

    return ntStatus;
}


/*
 ********************************************************************************
 *  HidIrDecrementPendingRequestCount
 ********************************************************************************
 *
 *
 */
VOID HidIrDecrementPendingRequestCount(IN PHIDIR_EXTENSION DevExt)
{
    LONG PendingCount;

    ASSERT(DevExt->NumPendingRequests >= 0);

    PendingCount = InterlockedDecrement(&DevExt->NumPendingRequests);

    HidIrKdPrint((3, "Decrement Pending Request Count to %x", PendingCount));

    if (PendingCount < 0){

        ASSERT(DevExt->DeviceState != DEVICE_STATE_RUNNING);

        /*
         *  The device state is stopping, and the last outstanding request
         *  has just completed.
         *
         *  Note: RemoveDevice does an extra decrement, so we complete
         *        the REMOVE IRP on the transition to -1, whether this
         *        happens in RemoveDevice itself or subsequently while
         *        RemoveDevice is waiting for this event to fire.
         */

        KeSetEvent(&DevExt->AllRequestsCompleteEvent, 0, FALSE);
    }
}


/*
 ********************************************************************************
 *  HidIrReadCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HidIrReadCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PHIDIR_EXTENSION DevExt
    )
{
    NTSTATUS ntStatus = Irp->IoStatus.Status;
    ULONG bytesRead;
    PUCHAR buffer;
    BOOLEAN resend = FALSE;
    PHIDIR_EXTENSION devExt;

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    HidIrKdPrint((3, "HidIrReadCompletion status %x", ntStatus));

    ASSERT(Irp->MdlAddress);
    buffer = HidIrGetSystemAddressForMdlSafe(Irp->MdlAddress);

    if(!buffer) {
        // If this fails, we really should bugcheck, since someone 
        // in the kernel screwed up our MDL on us. I'll fail safely, but 
        // definitely trap on debug builds.
        HIR_TRAP();
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
    } else if (NT_SUCCESS(ntStatus)){
        
        // Get the bytes read from the status block
        bytesRead = (ULONG)Irp->IoStatus.Information;

        // Predispose to zero 
        Irp->IoStatus.Information = 0;
        
        if (bytesRead == sizeof(ULONG)) {
            ULONG value, i;

            RtlCopyMemory(&value, buffer, sizeof(ULONG));
            if (value == 0) {
                // Key up. Do we have a pending key down?
                if (devExt->PreviousButton.UsageString[0]) {
                    // We have a pending key down. Send key up.
                    PUCHAR destination;
    
                    // Send the ~usage.
                    HidIrKdPrint((2,"Sending ~usage"));
                    Irp->IoStatus.Information = devExt->ReportLength;
                    destination = (PUCHAR) Irp->UserBuffer;
                    RtlZeroMemory(Irp->UserBuffer, Irp->IoStatus.Information); // already checked that buffer is big enuf.
                    destination[0] = devExt->PreviousButton.UsageString[0]; // report ID
                    RtlZeroMemory(&devExt->PreviousButton, sizeof(devExt->PreviousButton));
                } else {
                    // No pending key down message for this key up. Fire it back.
                    resend = TRUE;
                }
            } else if (value == devExt->PreviousButton.IRString) {
                // Same thing as last time. Fire it back down.
                resend = TRUE;
            } else {
                // Something new. Hmmm...
                ULONG entrySize = HIDIR_TABLE_ENTRY_SIZE(devExt->ReportLength);
                PUSAGE_TABLE_ENTRY entry;
                
                // Predispose to bounce the irp back down if we don't find a match.
                resend = TRUE;
                for (i = 0; i < devExt->NumUsages; i++) {
                    entry = (PUSAGE_TABLE_ENTRY) (devExt->MappingTable+(entrySize*i));

                    if (entry->IRString == value) {
                        HidIrKdPrint((2,"Found usage %x!", value));

                        // New usage. Copy it and complete the irp.
                        Irp->IoStatus.Information = devExt->ReportLength;

                        RtlCopyMemory(Irp->UserBuffer, 
                                      entry->UsageString, 
                                      devExt->ReportLength);
                        RtlCopyMemory(&devExt->PreviousButton, 
                                      entry, 
                                      sizeof(devExt->PreviousButton));
                        
                        // Check if we are allowed to send up standby button presses yet.
                        if (KeReadStateTimer(&devExt->IgnoreStandbyTimer) ||
                            !devExt->StandbyReportIdValid ||
                            devExt->StandbyReportId != entry->UsageString[0]) {
                            resend = FALSE;
                        }
                        break;
                    }
                }
                if (resend) {
                    // This might be an OEM button. Check if it's within the approved range.
                    if (value >= 0x800F0400 && value <= 0x800F04FF) {

                        PUCHAR usageString = Irp->UserBuffer;
                        UCHAR oemValue = (UCHAR) (value & 0xFF);

                        // It's in the range!  
                        HidIrKdPrint((2,"OEM button %x", value));
                        RtlZeroMemory(usageString, devExt->ReportLength);
                        
                        // Check if this is the "flag" button. If so, and we are not running 
                        // media center, we want to eject the windows key instead.
                        if (oemValue == 0x0D && !RunningMediaCenter && devExt->KeyboardReportIdValid) {
                            HidIrKdPrint((2,"Change flag button to Windows key"));
                            usageString[0] = devExt->KeyboardReportId; 
                            usageString[1] = 0x8;
                            Irp->IoStatus.Information = devExt->ReportLength;
                        } else {
                            usageString[0] = 0x1;
                            usageString[1] = oemValue;
                            Irp->IoStatus.Information = 2;
                        }
                        
                        devExt->PreviousButton.IRString = value;
                        devExt->PreviousButton.UsageString[0] = usageString[0];
                        resend = FALSE;
                    }
                }
            }

            HidIrKdPrint((3, "HidIrReadCompletion buffer value 0x%x", value));

        } else {
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        }

    } else if (ntStatus == STATUS_CANCELLED){
        /*
         *  The IRP was cancelled, which means that the device is probably getting removed.
         */
        HidIrKdPrint((1, "Read irp %p cancelled ...", Irp));
        ASSERT(!Irp->CancelRoutine);
    }

    // Balance the increment we did when we issued the read.
    HidIrDecrementPendingRequestCount(DevExt);

    //
    // Don't need the MDL and buffer anymore.
    //
    if (Irp->MdlAddress) {
        IoFreeMdl(Irp->MdlAddress);
        Irp->MdlAddress = NULL;
        if (buffer) {
            ExFreePool(buffer);
        }
    }

    // If we didn't get anything useful back, just poke it back down 
    // to the hardware.
    if (resend) {
        BOOLEAN needsCompletion = TRUE;
        ntStatus = HidIrReadReport(DeviceObject, Irp, &needsCompletion);
        if (!needsCompletion) {
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        Irp->IoStatus.Status = ntStatus; // fall thru and irp will complete.
    }
    
    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }

    return STATUS_SUCCESS; // something other than SMPR
}

/*
 ********************************************************************************
 *  HidIrReadReport
 ********************************************************************************
 *
 *   Routine Description:
 *
 *
 *    Arguments:
 *
 *       DeviceObject - Pointer to class device object.
 *
 *      IrpStack     - Pointer to Interrupt Request Packet.
 *
 *
 *   Return Value:
 *
 *      STATUS_SUCCESS, STATUS_UNSUCCESSFUL.
 *
 *
 *  Note: this function cannot be pageable because reads/writes
 *        can be made at dispatch-level.
 */
NTSTATUS HidIrReadReport(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT BOOLEAN *NeedsCompletion)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PHIDIR_EXTENSION devExt;
    PUCHAR buffer;
    ULONG bufferLen;
    PIO_STACK_LOCATION irpStack;

    HidIrKdPrint((3, "HidIrReadReport Enter"));

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    ASSERT(Irp->UserBuffer);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < devExt->ReportLength) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    bufferLen = HIDIR_REPORT_SIZE;
    buffer = ALLOCATEPOOL(NonPagedPool, bufferLen);
    if (buffer) {
        ASSERT(!Irp->MdlAddress);
        if (IoAllocateMdl(buffer,
                          bufferLen,
                          FALSE,
                          FALSE,
                          Irp)) {
            MmBuildMdlForNonPagedPool(Irp->MdlAddress);

            irpStack = IoGetNextIrpStackLocation(Irp);

            irpStack->MajorFunction = IRP_MJ_READ;
            irpStack->DeviceObject = GET_NEXT_DEVICE_OBJECT(DeviceObject);
            irpStack->Parameters.Read.Length = bufferLen;

            IoSetCompletionRoutine( 
                        Irp,
                        HidIrReadCompletion,
                        devExt,
                        TRUE,
                        TRUE,
                        TRUE );

            //
            // We need to keep track of the number of pending requests
            // so that we can make sure they're all cancelled properly during
            // processing of a stop device request.
            //
            if (NT_SUCCESS(HidIrIncrementPendingRequestCount(devExt))){
                status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
                *NeedsCompletion = FALSE;
            } else {
                IoFreeMdl(Irp->MdlAddress);
                Irp->MdlAddress = NULL;
                ExFreePool(buffer);
                status = STATUS_NO_SUCH_DEVICE;
            }
        } else {
            ExFreePool(buffer);
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }


    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidparse\hidparse.c ===
#include "wdm.h"
#include "hidpddi.h"
#include "hidparse.h"

NTSTATUS
DriverEntry (
   IN    PDRIVER_OBJECT    DriverObject,
   OUT   PUNICODE_STRING   RegistryPath
   )
/*++
RoutineDescription:
   Driver Entry Point.
   This entry point is called by the I/O subsystem.

Arguments:
   DriverObject - pointer to the driver object

   RegistryPath - pointer to a unicode string representing the path
                  to driver-specific key in the registry

Return Value:
   NT status code

--*/
{
    UNREFERENCED_PARAMETER  (RegistryPath);
    UNREFERENCED_PARAMETER  (DriverObject);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidir\sysctrl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Human Input Device (HID) minidriver for Infrared (IR) devices

          The HID IR Minidriver (HidIr) provides an abstraction layer for the
          HID Class to talk to HID IR devices.

Author:
            jsenior

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, HidIrSystemControl)
#endif


/*
 ************************************************************
 *  HidIrSystemControl
 ************************************************************
 *
 */
NTSTATUS HidIrSystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  thisStackLoc;

    PAGED_CODE();

    thisStackLoc = IoGetCurrentIrpStackLocation(Irp);

    switch(thisStackLoc->Parameters.DeviceIoControl.IoControlCode){

        default:
            /*
             *  Note: do not return STATUS_NOT_SUPPORTED;
             *  If completing the IRP here,
             *  just keep the default status
             *  (this allows filter drivers to work).
             */
            status = Irp->IoStatus.Status;
            break;
    }


    IoCopyCurrentIrpStackLocationToNext(Irp);

    status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidparse\hidparse.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    HIDPARSE.H

Abstract:

    This module contains the PRIVATE (driver-only) definitions for the
    code that implements the usbd driver.

Environment:

    Kernel & user mode

Revision History:

    Aug-96 : created by Kenneth Ray

--*/


#ifndef _HIDPARSE_H
#define _HIDPARSE_H

#include "hidtoken.h"

#define HIDP_POOL_TAG (ULONG) 'PdiH'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, HIDP_POOL_TAG);
// ExAllocatePool is only called in the descript.c and hidparse.c code.
// all other modules are linked into the user DLL.  They cannot allocate any
// memory.

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect

#define DEFAULT_DBG_LEVEL 1 // errors AND warnings

#if DBG
#define HidP_KdPrint(_level_,_x_) \
            if (DEFAULT_DBG_LEVEL <= _level_) { \
               DbgPrint ("'HidParse.SYS: "); \
               DbgPrint _x_; \
            }

#define TRAP() DbgBreakPoint()

#else
#define HidP_KdPrint(_level_,_x_)
#define TRAP()

#endif

#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#define MAX(a,b) (((a) < (b)) ? (b) : (a))

#define HIDP_ISCONST(x)    ((BOOLEAN) ((  (x) & 0x01)  ? TRUE : FALSE))
#define HIDP_ISARRAY(x)    ((BOOLEAN) ((!((x) & 0x02)) ? TRUE : FALSE))
#define HIDP_ISABSOLUTE(x) ((BOOLEAN) ((!((x) & 0x04)) ? TRUE : FALSE))
#define HIDP_HASNULL(x)    ((BOOLEAN) ((  (x) & 0x40)  ? TRUE : FALSE))

#define HIDP_MAX_UNKNOWN_ITEMS 4

typedef struct _HIDP_CHANNEL_DESC
{
   USHORT   UsagePage;
   UCHAR    ReportID;
   UCHAR    BitOffset;    // 0 to 8 value describing bit alignment

   USHORT   ReportSize;   // HID defined report size
   USHORT   ReportCount;  // HID defined report count
   USHORT   ByteOffset;   // byte position of start of field in report packet
   USHORT   BitLength;    // total bit length of this channel

   ULONG    BitField;   // The 8 (plus extra) bits associated with a main item

   USHORT   ByteEnd;      // First byte not containing bits of this channel.
   USHORT   LinkCollection;  // A unique internal index pointer
   USHORT   LinkUsagePage;
   USHORT   LinkUsage;

   ULONG  MoreChannels: 1; // Are there more channel desc associated with
                              // this array.  This happens if there is a
                              // several usages for one main item.
   ULONG  IsConst: 1; // Does this channel represent filler
   ULONG  IsButton: 1; // Is this a channel of binary usages, not value usages.
   ULONG  IsAbsolute: 1; // As apposed to relative
   ULONG  IsRange: 1;
   ULONG  IsAlias: 1; // a usage described in a delimiter
   ULONG  IsStringRange: 1;
   ULONG  IsDesignatorRange: 1;
   ULONG  Reserved: 20;
   ULONG  NumGlobalUnknowns: 4;

   struct _HIDP_UNKNOWN_TOKEN GlobalUnknowns [HIDP_MAX_UNKNOWN_ITEMS];

   union {
      struct {
         USHORT   UsageMin,         UsageMax;
         USHORT   StringMin,        StringMax;
         USHORT   DesignatorMin,    DesignatorMax;
         USHORT   DataIndexMin,     DataIndexMax;
      } Range;
      struct {
         USHORT   Usage,            Reserved1;
         USHORT   StringIndex,      Reserved2;
         USHORT   DesignatorIndex,  Reserved3;
         USHORT   DataIndex,        Reserved4;
      } NotRange;
   };

   union {
      struct {
         LONG     LogicalMin,       LogicalMax;
      } button;
      struct {
         BOOLEAN  HasNull;  // Does this channel have a null report
         UCHAR    Reserved[3];
         LONG     LogicalMin,       LogicalMax;
         LONG     PhysicalMin,      PhysicalMax;
      } Data;
   };

   ULONG    Units;
   ULONG    UnitExp;

} HIDP_CHANNEL_DESC, *PHIDP_CHANNEL_DESC;

struct _CHANNEL_REPORT_HEADER
{
   USHORT Offset;  // Position in the _CHANNEL_ITEM array
   USHORT Size;    // Length in said array
   USHORT Index;
   USHORT ByteLen; // The length of the data including reportID.
                   // This is the longest such report that might be received
                   // for the given collection.
};

#define HIDP_PREPARSED_DATA_SIGNATURE1 'PdiH'
#define HIDP_PREPARSED_DATA_SIGNATURE2 'RDK '

typedef struct _HIDP_SYS_POWER_INFO {
    ULONG   PowerButtonMask;

} HIDP_SYS_POWER_INFO, *PHIDP_SYS_POWER_INFO;

typedef struct _HIDP_PREPARSED_DATA
{
    LONG   Signature1, Signature2;
    USHORT Usage;
    USHORT UsagePage;

    HIDP_SYS_POWER_INFO;

    // The following channel report headers point to data within
    // the Data field below using array indices.
    struct _CHANNEL_REPORT_HEADER Input;
    struct _CHANNEL_REPORT_HEADER Output;
    struct _CHANNEL_REPORT_HEADER Feature;

    // After the CANNEL_DESC array the follows a LinkCollection array nodes.
    // LinkCollectionArrayOffset is the index given to RawBytes to find
    // the first location of the _HIDP_LINK_COLLECTION_NODE structure array
    // (index zero) and LinkCollectionArrayLength is the number of array
    // elements in that array.
    USHORT LinkCollectionArrayOffset;
    USHORT LinkCollectionArrayLength;

    union {
        HIDP_CHANNEL_DESC    Data[];
        UCHAR                RawBytes[];
    };
} HIDP_PREPARSED_DATA;

typedef struct _HIDP_PRIVATE_LINK_COLLECTION_NODE
{
    USAGE    LinkUsage;
    USAGE    LinkUsagePage;
    USHORT   Parent;
    USHORT   NumberOfChildren;
    USHORT   NextSibling;
    USHORT   FirstChild;
    ULONG    CollectionType: 8;  // As defined in 6.2.2.6 of HID spec
    ULONG    IsAlias : 1; // This link node is an allias of the next link node.
    ULONG    Reserved: 23;
} HIDP_PRIVATE_LINK_COLLECTION_NODE, *PHIDP_PRIVATE_LINK_COLLECTION_NODE;



// +++++++++++++++++++++++++++++++++++
// The ITEMS supported by this Parser
// +++++++++++++++++++++++++++++++++++

typedef UCHAR HIDP_ITEM;


//
// Power buttons supported by this parser
//
#define HIDP_USAGE_SYSCTL_PAGE HID_USAGE_PAGE_GENERIC
#define HIDP_USAGE_SYSCTL_POWER HID_USAGE_GENERIC_SYSCTL_POWER
#define HIDP_USAGE_SYSCTL_SLEEP HID_USAGE_GENERIC_SYSCTL_SLEEP
#define HIDP_USAGE_SYSCTL_WAKE  HID_USAGE_GENERIC_SYSCTL_WAKE


//
//
// Keyboard Translation
// translation tables from usages to i8042 scan codes.
//

typedef ULONG HIDP_LOOKUP_TABLE_PROC (
                  IN  PULONG    Table,
                  IN  ULONG     Usage
                  );
typedef HIDP_LOOKUP_TABLE_PROC * PHIDP_LOOKUP_TABLE_PROC;

typedef BOOLEAN HIDP_SCANCODE_SUBTRANSLATION (
                  IN     ULONG                         * Table,
                  IN     UCHAR                           Index,
                  IN     PHIDP_INSERT_SCANCODES          Insert,
                  IN     PVOID                           Context,
                  IN     HIDP_KEYBOARD_DIRECTION         KeyAction,
                  IN OUT PHIDP_KEYBOARD_MODIFIER_STATE   ModifierState
                  );
typedef HIDP_SCANCODE_SUBTRANSLATION * PHIDP_SCANCODE_SUBTRANSLATION;

typedef struct _HIDP_SCANCODE_SUBTABLE {
   PHIDP_SCANCODE_SUBTRANSLATION ScanCodeFcn;
   PULONG                        Table;
} HIDP_SCANCODE_SUBTABLE, *PHIDP_SCANCODE_SUBTABLE;


NTSTATUS HidP_TranslateUsage (
             USAGE                         Usage,
             HIDP_KEYBOARD_DIRECTION       KeyAction,
             PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
             PHIDP_LOOKUP_TABLE_PROC       LookupTableProc,
             PULONG                        TranslationTable,
             PHIDP_SCANCODE_SUBTABLE       SubTranslationTable,
             PHIDP_INSERT_SCANCODES        InsertCodesProcedure,
             PVOID                         InsertCodesContext
             );

HIDP_LOOKUP_TABLE_PROC HidP_StraightLookup;
HIDP_LOOKUP_TABLE_PROC HidP_AssociativeLookup;

HIDP_SCANCODE_SUBTRANSLATION HidP_KeyboardKeypadCode;
HIDP_SCANCODE_SUBTRANSLATION HidP_ModifierCode;
HIDP_SCANCODE_SUBTRANSLATION HidP_VendorBreakCodesAsMakeCodes;
HIDP_SCANCODE_SUBTRANSLATION HidP_PrintScreenCode;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidir\power.c ===
#include "pch.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, HidIrPower)
#endif

/*
 ************************************************************
 *  HidIrPower 
 ************************************************************
 *
 *  Process Power IRPs sent to this device.
 *  Don't have to call PoStartNextPowerIrp, since hidclass does it for us.
 *
 */
NTSTATUS HidIrPower(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PHIDIR_EXTENSION deviceExtension;

    HidIrKdPrint((3, "HidIrPower Entry"));

    deviceExtension = GET_MINIDRIVER_HIDIR_EXTENSION( DeviceObject );

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->MinorFunction) {
    case IRP_MN_SET_POWER:                        
        if (irpSp->Parameters.Power.Type == DevicePowerState) {
            if (deviceExtension->DevicePowerState != PowerDeviceD0 &&
                irpSp->Parameters.Power.State.DeviceState == PowerDeviceD0) {
                // We are returning from a low power state.
                // Set a timer that will cause hidir to ignore any standby buttons until it triggers
                LARGE_INTEGER timeout;
                timeout.HighPart = -1;
                timeout.LowPart = -50000000; // 5 seconds should be plenty
                KeSetTimer(&deviceExtension->IgnoreStandbyTimer, timeout, NULL);
            }
            deviceExtension->DevicePowerState = irpSp->Parameters.Power.State.DeviceState;
        }
    }

    IoSkipCurrentIrpStackLocation(Irp);
    status = PoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

    HidIrKdPrint((3, "HidIrPower Exit: %x", status));
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidir\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Human Input Device (HID) minidriver for Infrared (IR) devices

          The HID IR Minidriver (HidIr) provides an abstraction layer for the
          HID Class to talk to HID IR devices.

Author:
            jsenior

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"

//
//  The HID descriptor has some basic device info and tells how long the report
//  descriptor is.
//

HIDIR_DESCRIPTOR HidIrHidDescriptor = {
        0x09,   // length of HID descriptor
        0x21,   // descriptor type == HID
        0x0100, // hid spec release
        0x00,   // country code == Not Specified
        0x01,   // number of HID class descriptors
        0x22,   // report descriptor type
        0       // total length of report descriptor (to be set)
};

//
//  The report descriptor completely lays out what read and write packets will 
//  look like and indicates what the semantics are for each field. This here is 
//  what the report descriptor looks like in a broken out format. This is 
//  actually retrieved from the registry (device key).
//
/*
HID_REPORT_DESCRIPTOR HidIrReportDescriptor[] = {
    // Keyboard
        0x05,   0x01,       // Usage Page (Generic Desktop),
        0x09,   0x06,       // Usage (Keyboard),
        0xA1,   0x01,       // Collection (Application),
        0x85,   0x01,       //  Report Id (1)
        
        0x05,   0x07,       //  usage page key codes
        0x19,   0xe0,       //  usage min left control
        0x29,   0xe7,       //  usage max keyboard right gui
        0x75,   0x01,       //  report size 1
        0x95,   0x08,       //  report count 8
        0x81,   0x02,       //  input (Variable)
        
        0x19,   0x00,       //  usage min 0
        0x29,   0x91,       //  usage max 91
        0x26,   0xff, 0x00, //  logical max 0xff
        0x75,   0x08,       //  report size 8
        0x95,   0x01,       //  report count 1
        0x81,   0x00,       //  Input (Data, Array),
        0xC0,               // End Collection

    // Consumer Controls
        0x05,   0x0c,       // Usage Page (Consumer Controls),
        0x09,   0x01,       // Usage (Consumer Control),
        0xA1,   0x01,       // Collection (Application),
        0x85,   0x02,       //  Report Id (2)
        0x19,   0x00,       //  Usage Minimum (0),
        0x2a,   0x3c, 0x02, //  Usage Maximum (23c)  
        0x15,   0x00,       //  Logical Minimum (0),
        0x26,   0x3c, 0x02, //  Logical Maximum (23c)  
        0x95,   0x01,       //  Report Count (1),
        0x75,   0x10,       //  Report Size (16),
        0x81,   0x00,       //  Input (Data, Array), 
        0xC0,               // End Collection

    // Standby button
        0x05, 0x01,         // Usage Page (Generic Desktop),
        0x09, 0x80,         // Usage (System Control),
        0xa1, 0x01,         // Collection (Application),
        0x85, 0x03,         //  Report Id (3)
        0x19, 0x81,         //  Usage Minimum (0x81),
        0x29, 0x83,         //  Usage Maximum (0x83),
        0x25, 0x01,         //  Logical Maximum(1),
        0x75, 0x01,         //  Report Size (1),
        0x95, 0x03,         //  Report Count (3),
        0x81, 0x02,         //  Input
        0x95, 0x05,         //  Report Count (5),
        0x81, 0x01,         //  Input (Constant),
        0xc0                // End Collection   
        };
          

//
//  The mapping table translates from what the irbus driver gives us into a 
//  HID report to return to hidclass. The hid report is of the correct length
//  according to what the registry told us (device key).
//
USAGE_TABLE_ENTRY HidIrMappingTable[] = {
    { 0x00001808, {0x01,0x00,0x1e}},  // 1
    { 0x00001828, {0x01,0x00,0x1f}},  // 2
    { 0x00001818, {0x01,0x00,0x20}},  // 3
    { 0x0000182b, {0x01,0x02,0x20}},  // # (shift+3)
    { 0x00001804, {0x01,0x00,0x21}},  // 4
    { 0x00001824, {0x01,0x00,0x22}},  // 5
    { 0x00001814, {0x01,0x00,0x23}},  // 6
    { 0x0000180c, {0x01,0x00,0x24}},  // 7
    { 0x0000182c, {0x01,0x00,0x25}},  // 8
    
    { 0x00000001, {0x01,0x00,0x55}},  // Numpad *
    
    { 0x0000181c, {0x01,0x00,0x26}},  // 9
    { 0x00001822, {0x01,0x00,0x27}},  // 0
    { 0x00001836, {0x01,0x00,0x28}},  // return
    
    { 0x0000000B, {0x01,0x04,0x29}},  // alt+escape
    
    { 0x0000182b, {0x01,0x00,0x2a}},  // delete (backspace)
    { 0x00001806, {0x01,0x00,0x2b}},  // tab
    { 0x0000180e, {0x01,0x02,0x2b}},  // shift+tab
    { 0x00001826, {0x01,0x00,0x4b}},  // page up
    { 0x0000182e, {0x01,0x00,0x4e}},  // page down
    { 0x0000181e, {0x01,0x00,0x51}},  // down
    { 0x00001816, {0x01,0x00,0x52}},  // up
    { 0x0000181a, {0x01,0x00,0x65}},  // context

    { 0x00001813, {0x02,0x09,0x02}},  // AC Properties
    { 0x00001800, {0x02,0x24,0x02}},  // AC Back
    { 0x0000180a, {0x02,0x2a,0x02}},  // AC favorites
    { 0x00001823, {0x02,0x30,0x02}},  // AC full screen

    { 0x00001830, {0x02,0xb0,0x00}},  // AC Media play
    { 0x00001830, {0x02,0xb1,0x00}},  // AC Media pause
    { 0x0000183e, {0x02,0xb2,0x00}},  // AC Media record
    { 0x00001829, {0x02,0xb3,0x00}},  // AC FF
    { 0x00001838, {0x02,0xb4,0x00}},  // AC RW
    { 0x00001831, {0x02,0xb5,0x00}},  // AC Media next track
    { 0x00001811, {0x02,0xb6,0x00}},  // AC Media previous track
    { 0x00001821, {0x02,0xb7,0x00}},  // AC Media Stop
    
    { 0x0000000B, {0x02,0xe9,0x00}},  // AC volume up
    { 0x0000000B, {0x02,0xea,0x00}},  // AC volume down
    { 0x0000000B, {0x02,0xe2,0x00}},  // AC volume mute
    
    { 0x00001803, {0x02,0x8d,0x00}},  // AC select program guide
    { 0x00001801, {0x02,0x9c,0x00}},  // AC channel up
    { 0x0000183c, {0x02,0x9d,0x00}}};  // AC channel down



*/

NTSTATUS
HidIrRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
HidIrCleanupDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
HidIrStopDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
HidIrStopCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HidIrStartCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidIrInitDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
HidIrStartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

#ifdef ALLOC_PRAGMA
// NOTE: Every single function in this file is pageable.
    #pragma alloc_text(PAGE, HidIrStartDevice)
    #pragma alloc_text(PAGE, HidIrPnP)
    #pragma alloc_text(PAGE, HidIrRemoveDevice)
    #pragma alloc_text(PAGE, HidIrCleanupDevice)
    #pragma alloc_text(PAGE, HidIrStopDevice)
    #pragma alloc_text(PAGE, HidIrStopCompletion)
    #pragma alloc_text(PAGE, HidIrStartCompletion)
    #pragma alloc_text(PAGE, HidIrInitDevice)
#endif

NTSTATUS
HidIrStartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Begins initialization a given instance of a HID device.  Work done here occurs before
    the parent node gets to do anything.

Arguments:

    DeviceObject - pointer to the device object for this instance.

Return Value:

    NT status code

--*/
{
    PHIDIR_EXTENSION devExt;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG oldDeviceState;

    PAGED_CODE();

    // Get a pointer to the device extension
    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    HidIrKdPrint((3, "HidIrStartDevice devExt = %x", devExt));

    // Start the device
    oldDeviceState = devExt->DeviceState;
    devExt->DeviceState = DEVICE_STATE_STARTING;

    KeResetEvent(&devExt->AllRequestsCompleteEvent);

    if ((oldDeviceState == DEVICE_STATE_STOPPING) ||
        (oldDeviceState == DEVICE_STATE_STOPPED)  ||
        (oldDeviceState == DEVICE_STATE_REMOVING)){

        /*
         *  We did an extra decrement when the device was stopped.
         *  Now that we're restarting, we need to bump it back to zero.
         */
        NTSTATUS incStat = HidIrIncrementPendingRequestCount(devExt);
        ASSERT(NT_SUCCESS(incStat));
        ASSERT(devExt->NumPendingRequests == 0);
        HidIrKdPrint((2, "Got start-after-stop; re-incremented pendingRequestCount"));
    }

    HidIrKdPrint((3, "HidIrStartDevice Exit = %x", ntStatus));

    return ntStatus;
}

NTSTATUS
HidIrQueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   *Data,
    OUT ULONG   *DataLength
    )
{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    ULONG           length;
    KEY_VALUE_FULL_INFORMATION info;

    ASSERT(Data);
    ASSERT(DataLength);

    // Init
    *Data = NULL;
    *DataLength = 0;

    RtlInitUnicodeString (&valueName, ValueNameString);

    status = ZwQueryValueKey (Handle,
                              &valueName,
                              KeyValueFullInformation,
                              &info,
                              sizeof(info),
                              &length);
    
    if (STATUS_BUFFER_TOO_SMALL == status ||
        STATUS_BUFFER_OVERFLOW == status) {
        PKEY_VALUE_FULL_INFORMATION fullInfo;

        fullInfo = ALLOCATEPOOL (PagedPool, length);

        if (fullInfo) {

            status = ZwQueryValueKey (Handle,
                                      &valueName,
                                      KeyValueFullInformation,
                                      fullInfo,
                                      length,
                                      &length);
            if (NT_SUCCESS(status)) {
                *DataLength = fullInfo->DataLength;
                *Data = ALLOCATEPOOL (NonPagedPool, fullInfo->DataLength);
                if (*Data) {
                    RtlCopyMemory (*Data,
                                   ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                                   fullInfo->DataLength);
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            
            ExFreePool (fullInfo);
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else if (NT_SUCCESS(status)) {
        HIR_TRAP(); // we didn't alloc any space. This is bad.
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

#define HIDIR_REPORT_LENGTH L"ReportLength"
#define HIDIR_REPORT_DESCRIPTOR L"ReportDescriptor"
#define HIDIR_MAPPING_TABLE L"ReportMappingTable"
#define HIDIR_VENDOR_ID L"VendorID"
#define HIDIR_PRODUCT_ID L"ProductID"

NTSTATUS
HidIrInitDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Get the device information and attempt to initialize a configuration
    for a device.  If we cannot identify this as a valid HID device or
    configure the device, our start device function is failed.

Arguments:

    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PHIDIR_EXTENSION devExt;
    PHID_DEVICE_EXTENSION hidExtension;
    HANDLE devInstRegKey = NULL;
    ULONG dataLen;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrInitDevice Entry"));

    hidExtension = DeviceObject->DeviceExtension;
    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    devExt->HidDescriptor = HidIrHidDescriptor;

    status = IoOpenDeviceRegistryKey (hidExtension->PhysicalDeviceObject,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      STANDARD_RIGHTS_READ,
                                      &devInstRegKey);

    if (NT_SUCCESS (status)) {
        PULONG reportLength;
        status = HidIrQueryDeviceKey (devInstRegKey,
                                      HIDIR_REPORT_LENGTH,
                                      &reportLength,
                                      &dataLen);
        if (NT_SUCCESS (status)) {
            if (dataLen == sizeof(ULONG)) {
                devExt->ReportLength = *reportLength;
            } else {
                status = STATUS_INVALID_BUFFER_SIZE;
            }
            ExFreePool(reportLength);
        }
    }
  
    if (NT_SUCCESS(status)) {
        status = HidIrQueryDeviceKey (devInstRegKey,
                                      HIDIR_REPORT_DESCRIPTOR,
                                      &devExt->ReportDescriptor,
                                      &dataLen);
        if (NT_SUCCESS(status)) {
            ASSERT(dataLen);
            devExt->HidDescriptor.DescriptorList[0].wDescriptorLength = (USHORT)dataLen;
        }
    }

    if (NT_SUCCESS(status)) {
        PULONG vendorID;
        status = HidIrQueryDeviceKey (devInstRegKey,
                                      HIDIR_VENDOR_ID,
                                      &vendorID,
                                      &dataLen);
        if (NT_SUCCESS (status)) {
            if (dataLen == sizeof(ULONG)) {
                devExt->VendorID = (USHORT)*vendorID;
            } else {
                status = STATUS_INVALID_BUFFER_SIZE;
            }
            ExFreePool(vendorID);
        }
    }

    if (NT_SUCCESS(status)) {
        PULONG productID;
        status = HidIrQueryDeviceKey (devInstRegKey,
                                      HIDIR_PRODUCT_ID,
                                      &productID,
                                      &dataLen);
        if (NT_SUCCESS (status)) {
            if (dataLen == sizeof(ULONG)) {
                devExt->ProductID = (USHORT)*productID;
            } else {
                status = STATUS_INVALID_BUFFER_SIZE;
            }
            ExFreePool(productID);
        }
    }

    if (NT_SUCCESS (status)) {
        PUCHAR mappingTable;
        status = HidIrQueryDeviceKey (devInstRegKey,
                                      HIDIR_MAPPING_TABLE,
                                      &mappingTable,
                                      &dataLen);
        if (NT_SUCCESS(status)) {
            ULONG i;
            ULONG entrySize = HIDIR_TABLE_ENTRY_SIZE(devExt->ReportLength);

            ASSERT(dataLen > sizeof(ULONG)+devExt->ReportLength); // at least one entry
            ASSERT((dataLen % (sizeof(ULONG)+devExt->ReportLength)) == 0); // not malformed data

            // This will round down for malformed data.
            devExt->NumUsages = dataLen / (sizeof(ULONG)+devExt->ReportLength);
            // I have to do all this for 64-bit.
            devExt->MappingTable = ALLOCATEPOOL(NonPagedPool, devExt->NumUsages*entrySize);

            if (devExt->MappingTable) {

                // Fill in the table
                for (i = 0; i < devExt->NumUsages; i++) {
                    RtlCopyMemory(devExt->MappingTable+(entrySize*i), 
                                  mappingTable+((sizeof(ULONG)+devExt->ReportLength)*i),
                                  sizeof(ULONG));
                    RtlCopyMemory(devExt->MappingTable+(entrySize*i)+sizeof(ULONG), 
                                  mappingTable+((sizeof(ULONG)+devExt->ReportLength)*i)+sizeof(ULONG),
                                  devExt->ReportLength);
                }
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            ExFreePool(mappingTable);
        }
    }

    if (devInstRegKey) {
        ZwClose(devInstRegKey);
    }

    if (NT_SUCCESS(status)) {
        HIDP_DEVICE_DESC deviceDesc;     // 0x30 bytes

        // Find the keyboard and standby button collections and their associated report IDs.
        ASSERT(!devExt->KeyboardReportIdValid);
        if (NT_SUCCESS(HidP_GetCollectionDescription(
                        devExt->ReportDescriptor,
                        devExt->HidDescriptor.DescriptorList[0].wDescriptorLength,
                        NonPagedPool,
                        &deviceDesc))) {
            ULONG i,j;
            UCHAR nCollectionKbd, nCollectionStandby;
            BOOLEAN foundKbd = FALSE, foundStandby = FALSE;
            for (i = 0; i < deviceDesc.CollectionDescLength; i++) {
                PHIDP_COLLECTION_DESC collection = &deviceDesc.CollectionDesc[i];
                
                if (collection->UsagePage == HID_USAGE_PAGE_GENERIC &&
                    (collection->Usage == HID_USAGE_GENERIC_KEYBOARD ||
                     collection->Usage == HID_USAGE_GENERIC_KEYPAD)) {
                    
                    // Found the collection, onto the report id!
                    nCollectionKbd = collection->CollectionNumber;
                    foundKbd = TRUE;
                } else if (collection->UsagePage == HID_USAGE_PAGE_GENERIC &&
                           collection->Usage == HID_USAGE_GENERIC_SYSTEM_CTL) {
                    nCollectionStandby = collection->CollectionNumber;
                    foundStandby = TRUE;
                }
            }
            for (j = 0; j < deviceDesc.ReportIDsLength; j++) {
                if (foundKbd && deviceDesc.ReportIDs[j].CollectionNumber == nCollectionKbd) {

                    // I make the assumption that there is only one report id on this collection.
                    devExt->KeyboardReportId = deviceDesc.ReportIDs[j].ReportID;
                    devExt->KeyboardReportIdValid = TRUE;
                } else if (foundStandby && deviceDesc.ReportIDs[j].CollectionNumber == nCollectionStandby) {

                    // I make the assumption that there is only one report id on this collection.
                    devExt->StandbyReportId = deviceDesc.ReportIDs[j].ReportID;
                    devExt->StandbyReportIdValid = TRUE;
                }
            }

            HidP_FreeCollectionDescription(&deviceDesc);
        }                                        
    }

    return status;
}

NTSTATUS
HidIrStartCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Completes initialization a given instance of a HID device.  Work done here occurs
    after the parent node has done its StartDevice.

Arguments:

    DeviceObject - pointer to the device object for this instance.

Return Value:

    NT status code

--*/
{
    PHIDIR_EXTENSION devExt;
    NTSTATUS ntStatus;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrStartCompletion Enter"));

    //
    // Get a pointer to the device extension
    //

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    devExt->DeviceState = DEVICE_STATE_RUNNING;

    HidIrKdPrint((3, "DeviceObject (%x) was started!", DeviceObject));

    ntStatus = HidIrInitDevice(DeviceObject);

    if(NT_SUCCESS(ntStatus)) {
        HidIrKdPrint((3, "DeviceObject (%x) was configured!", DeviceObject));
    } else {
        HidIrKdPrint((1, "'HIDIR.SYS: DeviceObject (%x) configuration failed!", DeviceObject));
        devExt->DeviceState = DEVICE_STATE_STOPPING;
    }

    HidIrKdPrint((3, "HidIrStartCompletion Exit = %x", ntStatus));

    return ntStatus;
}


NTSTATUS
HidIrStopDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Stops a given instance of a device.  Work done here occurs before the parent
    does its stop device.

Arguments:

    DeviceObject - pointer to the device object.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHIDIR_EXTENSION devExt;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrStopDevice Enter"));

    //
    // Get a pointer to the device extension
    //

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    HidIrKdPrint((3, "DeviceExtension = %x", devExt));

    devExt->DeviceState = DEVICE_STATE_STOPPING;

    HidIrDecrementPendingRequestCount(devExt);
    KeWaitForSingleObject( &devExt->AllRequestsCompleteEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    //
    // Stop the device
    //

    HidIrKdPrint((3, "HidIrStopDevice = %x", ntStatus));

    return ntStatus;
}

VOID
HidIrFreeResources(
    PHIDIR_EXTENSION DevExt
    )
{
    PAGED_CODE();

    if (DevExt->ReportDescriptor) {
        ExFreePool(DevExt->ReportDescriptor);
        DevExt->ReportDescriptor = NULL;
    }
    
    if (DevExt->MappingTable) {
        ExFreePool(DevExt->MappingTable);
        DevExt->MappingTable = NULL;
    }

    DevExt->KeyboardReportIdValid = FALSE;
    DevExt->StandbyReportIdValid = FALSE;
}

NTSTATUS
HidIrStopCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Stops a given instance of a device.  Work done here occurs after the parent
    has done its stop device.

Arguments:

    DeviceObject - pointer to the device object.

Return Value:

    NT status code

--*/
{
    PHIDIR_EXTENSION devExt;
    NTSTATUS ntStatus;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrStopCompletion Enter"));

    //
    // Get a pointer to the device extension
    //

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    HidIrKdPrint((3, "DeviceExtension = %x", devExt));

    ntStatus = Irp->IoStatus.Status;

    if(NT_SUCCESS(ntStatus)) {

        HidIrKdPrint((3, "DeviceObject (%x) was stopped!", DeviceObject));

    } else {
        //
        // The PnP call failed!
        //

        HidIrKdPrint((3, "DeviceObject (%x) failed to stop!", DeviceObject));
    }

    HidIrFreeResources(devExt);

    devExt->DeviceState = DEVICE_STATE_STOPPED;

    HidIrKdPrint((3, "HidIrStopCompletion Exit = %x", ntStatus));

    return ntStatus;
}

NTSTATUS
HidIrCleanupDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PHIDIR_EXTENSION devExt;
    ULONG oldDeviceState;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrCleanupDevice Enter"));

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    oldDeviceState = devExt->DeviceState;
    devExt->DeviceState = DEVICE_STATE_REMOVING;

    if (devExt->QueryRemove) {
        // We are severing our relationship with this device
        // through a disable/uninstall in device manager.
        // If the device is virtually cabled, we must "unplug"
        // that device so that it can go elsewhere.
    }

    if (oldDeviceState == DEVICE_STATE_RUNNING) {
        HidIrDecrementPendingRequestCount(devExt);
    } else {
        ASSERT( devExt->NumPendingRequests == -1 );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
HidIrRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Removes a given instance of a device.

Arguments:

    DeviceObject - pointer to the device object.

Return Value:

    NT status code

--*/
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PHIDIR_EXTENSION devExt;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrRemoveDevice Enter"));

    //
    // Get a pointer to the device extension
    //

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    HidIrKdPrint((3, "DeviceExtension = %x", devExt));

    HidIrCleanupDevice(DeviceObject);

    KeWaitForSingleObject( &devExt->AllRequestsCompleteEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    KeCancelTimer( &devExt->IgnoreStandbyTimer );

    HidIrFreeResources(devExt);

    ASSERT(devExt->NumPendingRequests == -1);

    HidIrKdPrint((3, "HidIrRemoveDevice = %x", ntStatus));

    return ntStatus;
}

NTSTATUS
HidIrPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the PnP IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpStack;
    PIO_STACK_LOCATION NextStack;
    PHIDIR_EXTENSION devExt;

    PAGED_CODE();

    //
    // Get a pointer to the device extension
    //

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    //
    // Get a pointer to the current location in the Irp
    //

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    HidIrKdPrint((3, "HidIrPnP fn %x DeviceObject = %x DeviceExtension = %x", IrpStack->MinorFunction, DeviceObject, devExt));

    switch(IrpStack->MinorFunction)
    {
    case IRP_MN_START_DEVICE:
        ntStatus = HidIrStartDevice(DeviceObject);
        break;

    case IRP_MN_STOP_DEVICE:
        ntStatus = HidIrStopDevice(DeviceObject);
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        ntStatus = HidIrCleanupDevice(DeviceObject);
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
        devExt->QueryRemove = TRUE;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        devExt->QueryRemove = FALSE;
        break;

    case IRP_MN_REMOVE_DEVICE:
        ntStatus = HidIrRemoveDevice(DeviceObject);
        break;

    }

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = HidIrCallDriverSynchronous(DeviceObject, Irp);

        switch(IrpStack->MinorFunction)
        {
        case IRP_MN_START_DEVICE:
            if (NT_SUCCESS(ntStatus)) {
                ntStatus = HidIrStartCompletion(DeviceObject, Irp);
                Irp->IoStatus.Status = ntStatus;

            }
            if (!NT_SUCCESS(ntStatus)) {
                HidIrDecrementPendingRequestCount(devExt);
            }
            break;

        case IRP_MN_STOP_DEVICE:
            ntStatus = HidIrStopCompletion(DeviceObject, Irp);
            break;

        default:
            break;
        }
    }

    // Set the status of the Irp
    Irp->IoStatus.Status = ntStatus;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    HidIrKdPrint((3, "HidIrPnP Exit status %x", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidparse\query.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    query.c

Abstract:

    This module contains the code for querying HID report packets.

Environment:

    Kernel & user mode

Revision History:

    Aug-96 : created by Kenneth Ray

--*/

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#include <wtypes.h>
#include "hidsdi.h"
#include "hidparse.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HidP_GetCaps)
#pragma alloc_text(PAGE, HidP_GetLinkCollectionNodes)
#pragma alloc_text(PAGE, HidP_GetButtonCaps)
#pragma alloc_text(PAGE, HidP_GetSpecificButtonCaps)
#pragma alloc_text(PAGE, HidP_GetValueCaps)
#pragma alloc_text(PAGE, HidP_GetSpecificValueCaps)
#pragma alloc_text(PAGE, HidP_MaxUsageListLength)
#pragma alloc_text(PAGE, HidP_InitializeReportForID)
#pragma alloc_text(PAGE, HidP_GetExtendedAttributes)
#endif


#define PAGED_CODE()
#ifndef HIDPARSE_USERMODE
#if DBG
    typedef UCHAR KIRQL;
    KIRQL KeGetCurrentIrql();
    #define APC_LEVEL 0x1

    ULONG _cdecl DbgPrint (PCH Format, ...);
    NTSYSAPI VOID NTAPI RtlAssert(PVOID, PVOID, ULONG, PCHAR);

    #define ASSERT( exp ) \
            if (!(exp)) RtlAssert( #exp, __FILE__, __LINE__, NULL )

    #undef PAGED_CODE
    #define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
        HidP_KdPrint(2, ( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
        ASSERT(FALSE); \
        }
#else // DBG
    #define ASSERT(x)
#endif // DBG
#else // HIDPARSE_USERMODE
    #define ASSERT(x)
#endif // HIDPARSE_USERMODE

#define CHECK_PPD(_x_) \
   if ((HIDP_PREPARSED_DATA_SIGNATURE1 != (_x_)->Signature1) ||\
       (HIDP_PREPARSED_DATA_SIGNATURE2 != (_x_)->Signature2)) \
   { return HIDP_STATUS_INVALID_PREPARSED_DATA; }

ULONG
HidP_ExtractData (
   IN    USHORT   ByteOffset,
   IN    USHORT   BitOffset,
   IN    USHORT   BitLength,
   IN    PUCHAR   Report
   )
/*++
Routine Description:
   Given a HID report a byte offset, bit offset and bitlength extract the
   bits from the report in little endian BIT order.
--*/
{
   ULONG    inspect = 0;
   USHORT   tmpByte = 0;
   USHORT   tmpBit  = 0;

   // Start with the high bits and work our way down.
   //
   // Little endian (by bit)
   // Byte 2  |Byte 1 |Byte 0
   // 765432107654321076543210  (bits)
   //
   // Get low byte first.  (need the higher bits)
   // Offset is from bit zero.
   //

   tmpByte = (ByteOffset << 3) + BitOffset + BitLength;
   tmpBit = tmpByte & 7;
   tmpByte >>= 3;

   if (BitLength < tmpBit) {
       inspect = (UCHAR) Report [tmpByte] & ((1 << tmpBit) - 1);
       inspect >>= BitOffset;
       return inspect;
   }

   if (tmpBit)
   {  // Not Byte alligned!

      inspect = (UCHAR) Report [tmpByte] & ((1 << tmpBit) - 1);
      BitLength -= tmpBit;
   }
   tmpByte--;

   while (BitLength >= 8)
   {
      inspect <<= 8;
      inspect |= (UCHAR) Report[tmpByte];
      BitLength -= 8;
      tmpByte--;
   }

   if (BitLength)
   {
      inspect <<= BitLength;
      inspect |= (UCHAR) (  (Report [tmpByte] >> (8 - BitLength))
                          & ((1 << BitLength) - 1));
   }
   return inspect;
}

void
HidP_InsertData (
   IN       USHORT   ByteOffset,
   IN       USHORT   BitOffset,
   IN       USHORT   BitLength, // Length of the value set in bits.
   IN OUT   PUCHAR   Report,
   IN       ULONG    Value
   )
/*++
Routine Description:
   Given a HID report a byte offset, bit offset and bitlength set those bits
   in little endian BIT order to the value provided.
--*/
{
    ULONG   mask;
    ULONG   tmpBit;
    //
    // Little endian (by bit)
    // Byte 2  |Byte 1 |Byte 0
    // 765432107654321076543210  (bits)
    //
    // Get low byte first.  (need the higher bits)
    // Offset is from bit zero.
    //

    tmpBit = BitLength + BitOffset;
    if (tmpBit < 8) {
        mask = (1 << tmpBit) - (1 << BitOffset);
        Report [ByteOffset] &= ~mask;
        Report [ByteOffset] |= (UCHAR) ((Value << BitOffset) & mask);
        return;
    }

    if (BitOffset)
    {  // Not byte aligned, deal with the last partial byte.

        Report [ByteOffset] &= ((1 << BitOffset) - 1); // Zap upper bits
        Report [ByteOffset] |= (UCHAR) (Value << BitOffset);
        BitLength -= (8 - BitOffset);
        Value >>= (8 - BitOffset);
        ByteOffset++;
    }

    while (BitLength >= 8)
    {
        Report [ByteOffset] = (UCHAR) Value;
        Value >>= 8;
        BitLength -= 8;
        ByteOffset++;
    }

    if (BitLength)
    {
        Report [ByteOffset] &= ((UCHAR) 0 - (UCHAR) (1 << BitLength));
        // Zap lower bits.
        Report [ByteOffset] |= (Value & ((1 << BitLength) - 1));
    }
}


HidP_DeleteArrayEntry (
   IN       ULONG    BitPos,
   IN       USHORT   BitLength, // Length of the value set in bits.
   IN       USHORT   ReportCount,
   IN       ULONG    Value, // Value to delete.
   IN OUT   PUCHAR   Report
   )
/*++
Routine Description:
   Given a HID report a byte offset, bit offset and bitlength
   remove that data item from the report, by shifting all data items
   left until the last item finally setting that one to zero.
   In otherwards clear the given entry from the hid array.

   NOTE: If there are two such values set we only eliminate the first one.
--*/
{
    ULONG   tmpValue;
    ULONG   localBitPos; // for debugging only. Compiler should kill this line.
    ULONG   localRemaining;
    ULONG   nextBitPos;

    localBitPos = BitPos;
    tmpValue = 0;
    localRemaining = ReportCount;

    ASSERT (0 < ReportCount);
    ASSERT (0 != Value);

    //
    // Find the data.
    //

    while (0 < localRemaining) {
        tmpValue = HidP_ExtractData ((USHORT) (localBitPos >> 3),
                                     (USHORT) (localBitPos & 7),
                                     BitLength,
                                     Report);

        if (Value == tmpValue) {
            break;
        }

        localBitPos += BitLength;
        localRemaining--;
    }

    if (Value != tmpValue) {
        return HIDP_STATUS_BUTTON_NOT_PRESSED;
    }

    while (1 < localRemaining) {
        nextBitPos = localBitPos + BitLength;

        tmpValue = HidP_ExtractData ((USHORT) (nextBitPos >> 3),
                                     (USHORT) (nextBitPos & 7),
                                     BitLength,
                                     Report);

        HidP_InsertData ((USHORT) (localBitPos >> 3),
                         (USHORT) (localBitPos & 7),
                         BitLength,
                         Report,
                         tmpValue);

        localBitPos = nextBitPos;
        localRemaining--;
    }

    HidP_InsertData ((USHORT) (localBitPos >> 3),
                     (USHORT) (localBitPos & 7),
                     BitLength,
                     Report,
                     0);

    return HIDP_STATUS_SUCCESS;
}


NTSTATUS __stdcall
HidP_GetCaps (
   IN   PHIDP_PREPARSED_DATA      PreparsedData,
   OUT  PHIDP_CAPS                Capabilities
   )
/*++
Routine Description:
   Please see Hidpi.h for routine description

Notes:
--*/
{
   ULONG               i;
   HIDP_CHANNEL_DESC * data;

   PAGED_CODE();
   CHECK_PPD (PreparsedData);

   for (i = 0; i < sizeof (HIDP_CAPS) / sizeof (ULONG); i++) {
       ((PULONG) Capabilities) [0] = 0;
   }

   Capabilities->UsagePage = PreparsedData->UsagePage;
   Capabilities->Usage = PreparsedData->Usage;
   Capabilities->InputReportByteLength = PreparsedData->Input.ByteLen;
   Capabilities->OutputReportByteLength = PreparsedData->Output.ByteLen;
   Capabilities->FeatureReportByteLength = PreparsedData->Feature.ByteLen;

    // Reserved fields go here

   Capabilities->NumberLinkCollectionNodes =
       PreparsedData->LinkCollectionArrayLength;

   Capabilities->NumberInputButtonCaps = 0;
   Capabilities->NumberInputValueCaps = 0;
   Capabilities->NumberOutputButtonCaps = 0;
   Capabilities->NumberOutputValueCaps = 0;
   Capabilities->NumberFeatureButtonCaps = 0;
   Capabilities->NumberFeatureValueCaps = 0;

   i=PreparsedData->Input.Offset;
   data = &PreparsedData->Data[i];
   Capabilities->NumberInputDataIndices = 0;
   for (; i < PreparsedData->Input.Index; i++, data++)
   {
      if (data->IsButton)
      {
         Capabilities->NumberInputButtonCaps++;
      } else
      {
         Capabilities->NumberInputValueCaps++;
      }
      Capabilities->NumberInputDataIndices += data->Range.DataIndexMax
                                            - data->Range.DataIndexMin
                                            + 1;
   }

   i=PreparsedData->Output.Offset;
   data = &PreparsedData->Data[i];
   Capabilities->NumberOutputDataIndices = 0;
   for (; i < PreparsedData->Output.Index; i++, data++)
   {
      if (data->IsButton)
      {
         Capabilities->NumberOutputButtonCaps++;
      } else
      {
         Capabilities->NumberOutputValueCaps++;
      }

      Capabilities->NumberOutputDataIndices += data->Range.DataIndexMax
                                             - data->Range.DataIndexMin
                                             + 1;
   }

   i=PreparsedData->Feature.Offset;
   data = &PreparsedData->Data[i];
   Capabilities->NumberFeatureDataIndices = 0;
   for (; i < PreparsedData->Feature.Index; i++, data++)
   {
      if (data->IsButton)
      {
         Capabilities->NumberFeatureButtonCaps++;
      } else
      {
         Capabilities->NumberFeatureValueCaps++;
      }

      Capabilities->NumberFeatureDataIndices += data->Range.DataIndexMax
                                              - data->Range.DataIndexMin
                                              + 1;
   }

   return HIDP_STATUS_SUCCESS;
}

NTSTATUS __stdcall
HidP_GetLinkCollectionNodes (
   OUT      PHIDP_LINK_COLLECTION_NODE LinkCollectionNodes,
   IN OUT   PULONG                     LinkCollectionNodesLength,
   IN       PHIDP_PREPARSED_DATA       PreparsedData
   )
/*++
Routine Description:
   Please see Hidpi.h for routine description

--*/
{
   PHIDP_PRIVATE_LINK_COLLECTION_NODE nodeArray;
   ULONG                      length;
   ULONG                      i;
   NTSTATUS                   status = HIDP_STATUS_SUCCESS;

   PAGED_CODE();
   CHECK_PPD (PreparsedData);

   if (*LinkCollectionNodesLength < PreparsedData->LinkCollectionArrayLength) {
      length = *LinkCollectionNodesLength;
      status = HIDP_STATUS_BUFFER_TOO_SMALL;
   } else {
      length = PreparsedData->LinkCollectionArrayLength;
   }
   *LinkCollectionNodesLength = PreparsedData->LinkCollectionArrayLength;

   nodeArray = (PHIDP_PRIVATE_LINK_COLLECTION_NODE)
               (PreparsedData->RawBytes +
                PreparsedData->LinkCollectionArrayOffset);

   for (i = 0;
        i < length;
        i++, LinkCollectionNodes++, nodeArray++ ) {
       // *LinkCollectionNodes = *nodeArray;

       LinkCollectionNodes->LinkUsage = nodeArray->LinkUsage;
       LinkCollectionNodes->LinkUsagePage = nodeArray->LinkUsagePage;
       LinkCollectionNodes->Parent = nodeArray->Parent;
       LinkCollectionNodes->NumberOfChildren = nodeArray->NumberOfChildren;
       LinkCollectionNodes->NextSibling = nodeArray->NextSibling;
       LinkCollectionNodes->FirstChild = nodeArray->FirstChild;
       LinkCollectionNodes->CollectionType = nodeArray->CollectionType;
       LinkCollectionNodes->IsAlias = nodeArray->IsAlias;

   }
   return status;
}

#undef HidP_GetButtonCaps
NTSTATUS __stdcall
HidP_GetButtonCaps (
   IN       HIDP_REPORT_TYPE     ReportType,
   OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
   IN OUT   PUSHORT              ButtonCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
   )
/*++
Routine Description:
   Please see Hidpi.h for routine description

Notes:
--*/
{
   return HidP_GetSpecificButtonCaps (ReportType,
                                      0,
                                      0,
                                      0,
                                      ButtonCaps,
                                      ButtonCapsLength,
                                      PreparsedData);
}

NTSTATUS __stdcall
HidP_GetSpecificButtonCaps (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,      // Optional (0 => ignore)
   IN       USHORT               LinkCollection, // Optional (0 => ignore)
   IN       USAGE                Usage,          // Optional (0 => ignore)
   OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
   IN OUT   PUSHORT              ButtonCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
   )
/*++
Routine Description:
   Please see Hidpi.h for routine description

Notes:
--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   PHIDP_CHANNEL_DESC   channel;
   NTSTATUS             status = HIDP_STATUS_USAGE_NOT_FOUND;
   USHORT i, j;

   PAGED_CODE();
   CHECK_PPD (PreparsedData);

   switch (ReportType) {
   case HidP_Input:
       iof = &PreparsedData->Input;
       break;

   case HidP_Output:
       iof = &PreparsedData->Output;
       break;

   case HidP_Feature:
       iof = &PreparsedData->Feature;
       break;

   default:
       return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   for (i = iof->Offset, j = 0; i < iof->Index ; i++)
   {
      channel = &PreparsedData->Data[i];
      if ((channel->IsButton) &&
          ((!UsagePage || (UsagePage == channel->UsagePage)) &&
           (!LinkCollection || (LinkCollection == channel->LinkCollection)
                            || ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
                                (0 == channel->LinkCollection))) &&
           (!Usage || ((channel->Range.UsageMin <= Usage) &&
                       (Usage <= channel->Range.UsageMax)))))
      {
         status = HIDP_STATUS_SUCCESS;

         if (j < *ButtonCapsLength)
         {
            ButtonCaps[j].UsagePage = channel->UsagePage;
            ButtonCaps[j].LinkCollection = channel->LinkCollection;
            ButtonCaps[j].LinkUsagePage = channel->LinkUsagePage;
            ButtonCaps[j].LinkUsage = channel->LinkUsage;
            ButtonCaps[j].IsRange = (BOOLEAN) channel->IsRange;
            ButtonCaps[j].IsStringRange = (BOOLEAN) channel->IsStringRange;
            ButtonCaps[j].IsDesignatorRange=(BOOLEAN)channel->IsDesignatorRange;
            ButtonCaps[j].ReportID = channel->ReportID;
            ButtonCaps[j].BitField = (USHORT) channel->BitField;
            ButtonCaps[j].IsAbsolute = (BOOLEAN) channel->IsAbsolute;
            ButtonCaps[j].IsAlias = (BOOLEAN) channel->IsAlias;
//            if (channel->IsRange)
//            {
            ButtonCaps[j].Range.UsageMin = channel->Range.UsageMin;
            ButtonCaps[j].Range.UsageMax = channel->Range.UsageMax;
            ButtonCaps[j].Range.DataIndexMin = channel->Range.DataIndexMin;
            ButtonCaps[j].Range.DataIndexMax = channel->Range.DataIndexMax;
//            } else
//            {
//               ButtonCaps[j].NotRange.Usage = channel->NotRange.Usage;
//            }
//            if (channel->IsStringRange)
//            {
            ButtonCaps[j].Range.StringMin = channel->Range.StringMin;
            ButtonCaps[j].Range.StringMax = channel->Range.StringMax;
//            } else
//            {
//               ButtonCaps[j].NotRange.StringIndex
//                  = channel->NotRange.StringIndex;
//            }
//            if (channel->IsDesignatorRange)
//            {
            ButtonCaps[j].Range.DesignatorMin = channel->Range.DesignatorMin;
            ButtonCaps[j].Range.DesignatorMax = channel->Range.DesignatorMax;
//            } else
//            {
//               ButtonCaps[j].NotRange.DesignatorIndex
//                  = channel->NotRange.DesignatorIndex;
//            }
         } else {
             status = HIDP_STATUS_BUFFER_TOO_SMALL;
         }
         j++;
      }
   }
   *ButtonCapsLength = j;
   return status;
}

#undef HidP_GetValueCaps
NTSTATUS __stdcall
HidP_GetValueCaps (
   IN       HIDP_REPORT_TYPE     ReportType,
   OUT      PHIDP_VALUE_CAPS     ValueCaps,
   IN OUT   PUSHORT              ValueCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
   )
/*++
Routine Description:
   Please see Hidpi.h for routine description

Notes:
--*/
{
   return HidP_GetSpecificValueCaps (ReportType,
                                    0,
                                    0,
                                    0,
                                    ValueCaps,
                                    ValueCapsLength,
                                    PreparsedData);
}

NTSTATUS __stdcall
HidP_GetSpecificValueCaps (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,      // Optional (0 => ignore)
   IN       USHORT               LinkCollection, // Optional (0 => ignore)
   IN       USAGE                Usage,          // Optional (0 => ignore)
   OUT      PHIDP_VALUE_CAPS     ValueCaps,
   IN OUT   PUSHORT              ValueCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
   )
/*++
Routine Description:
   Please see Hidpi.h for routine description

Notes:
--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   PHIDP_CHANNEL_DESC   channel;
   NTSTATUS             status = HIDP_STATUS_USAGE_NOT_FOUND;
   USHORT   i, j;

   CHECK_PPD (PreparsedData);
   PAGED_CODE ();

   switch (ReportType) {
   case HidP_Input:
       iof = &PreparsedData->Input;
       break;

   case HidP_Output:
       iof = &PreparsedData->Output;
       break;

   case HidP_Feature:
       iof = &PreparsedData->Feature;
       break;

   default:
       return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   for (i = iof->Offset, j = 0; i < iof->Index ; i++)
   {
      channel = &PreparsedData->Data[i];
      if ((!channel->IsButton) &&
          ((!UsagePage || (UsagePage == channel->UsagePage)) &&
           (!LinkCollection || (LinkCollection == channel->LinkCollection)
                            || ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
                                (0 == channel->LinkCollection))) &&
           (!Usage || ((channel->Range.UsageMin <= Usage) &&
                       (Usage <= channel->Range.UsageMax)))))
      {
         status = HIDP_STATUS_SUCCESS;

         if (j < *ValueCapsLength)
         {
            ValueCaps[j].UsagePage = channel->UsagePage;
            ValueCaps[j].LinkCollection = channel->LinkCollection;
            ValueCaps[j].LinkUsagePage = channel->LinkUsagePage;
            ValueCaps[j].LinkUsage = channel->LinkUsage;
            ValueCaps[j].IsRange = (BOOLEAN) channel->IsRange;
            ValueCaps[j].IsStringRange = (BOOLEAN) channel->IsStringRange;
            ValueCaps[j].IsDesignatorRange =(BOOLEAN)channel->IsDesignatorRange;
            ValueCaps[j].ReportID = channel->ReportID;
            ValueCaps[j].BitField = (USHORT) channel->BitField;
            ValueCaps[j].BitSize = channel->ReportSize;
            ValueCaps[j].IsAbsolute = (BOOLEAN) channel->IsAbsolute;
            ValueCaps[j].HasNull = channel->Data.HasNull;
            ValueCaps[j].Units = channel->Units;
            ValueCaps[j].UnitsExp = channel->UnitExp;
            ValueCaps[j].LogicalMin = channel->Data.LogicalMin;
            ValueCaps[j].LogicalMax = channel->Data.LogicalMax;
            ValueCaps[j].PhysicalMin = channel->Data.PhysicalMin;
            ValueCaps[j].PhysicalMax = channel->Data.PhysicalMax;
            ValueCaps[j].IsAlias = (BOOLEAN) channel->IsAlias;
//            if (channel->IsRange)
//            {
            ValueCaps[j].Range.UsageMin = channel->Range.UsageMin;
            ValueCaps[j].Range.UsageMax = channel->Range.UsageMax;
            ValueCaps[j].Range.DataIndexMin = channel->Range.DataIndexMin;
            ValueCaps[j].Range.DataIndexMax = channel->Range.DataIndexMax;
//            } else
//            {
//               ValueCaps[j].NotRange.Usage = channel->NotRange.Usage;
//            }
//            if (channel->IsStringRange)
//            {
            ValueCaps[j].Range.StringMin = channel->Range.StringMin;
            ValueCaps[j].Range.StringMax = channel->Range.StringMax;
//            } else
//            {
//               ValueCaps[j].NotRange.StringIndex
//                  = channel->NotRange.StringIndex;
//            }
//            if (channel->IsDesignatorRange)
//            {
            ValueCaps[j].Range.DesignatorMin = channel->Range.DesignatorMin;
            ValueCaps[j].Range.DesignatorMax = channel->Range.DesignatorMax;
//            } else
//            {
//               ValueCaps[j].NotRange.DesignatorIndex
//                  = channel->NotRange.DesignatorIndex;
//            }


            ValueCaps[j].ReportCount = (channel->IsRange)
                                     ? 1
                                     : channel->ReportCount;

         } else {
             status = HIDP_STATUS_BUFFER_TOO_SMALL;
         }
         j++;
      }
   }
   *ValueCapsLength = j;
   return status;
}

NTSTATUS __stdcall
HidP_GetExtendedAttributes (
    IN      HIDP_REPORT_TYPE            ReportType,
    IN      USHORT                      DataIndex,
    IN      PHIDP_PREPARSED_DATA        PreparsedData,
    OUT     PHIDP_EXTENDED_ATTRIBUTES   Attributes,
    IN OUT  PULONG                      LengthAttributes
    )
/*++

Routine Description:

   Please See hidpi.h for description.

--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC              channel;
    HIDP_EXTENDED_ATTRIBUTES        buffer;
    ULONG       channelIndex    = 0;
    NTSTATUS    status = HIDP_STATUS_DATA_INDEX_NOT_FOUND;
    ULONG       i;
    ULONG       actualLen, copyLen = 0;

    CHECK_PPD (PreparsedData);

    PAGED_CODE ();

    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    for (channelIndex = iof->Offset, channel = PreparsedData->Data;
         channelIndex < iof->Index;
         channelIndex++, channel++) {

        if ((channel->Range.DataIndexMin <= DataIndex) &&
            (DataIndex <= channel->Range.DataIndexMax)) {

            RtlZeroMemory (Attributes, *LengthAttributes);
            RtlZeroMemory (&buffer, sizeof (buffer));

            //
            // Set the fixed parameters
            //
            buffer.NumGlobalUnknowns = (UCHAR) channel->NumGlobalUnknowns;
            // buffer.GlobalUnknowns = channel->GlobalUnknowns;

            //
            // Set the length
            //
            actualLen = FIELD_OFFSET (HIDP_EXTENDED_ATTRIBUTES, Data)
                      + (buffer.NumGlobalUnknowns * sizeof(HIDP_UNKNOWN_TOKEN));

            //
            // Copy over the fixed paramters
            //
            copyLen = MIN (*LengthAttributes, sizeof (buffer));
            RtlCopyMemory (Attributes, &buffer, copyLen);

            //
            // Copy over the data.
            //
            copyLen = MIN (*LengthAttributes, actualLen)
                    - FIELD_OFFSET (HIDP_EXTENDED_ATTRIBUTES, Data);

            if (copyLen) {
                RtlCopyMemory ((PVOID) Attributes->Data,
                               (PVOID) channel->GlobalUnknowns,
                               copyLen);
            }

            if (*LengthAttributes < actualLen) {
                status = HIDP_STATUS_BUFFER_TOO_SMALL;
            } else {
                status = HIDP_STATUS_SUCCESS;
            }

            break;
        }
    }

    return status;
}

NTSTATUS __stdcall
HidP_InitializeReportForID (
   IN       HIDP_REPORT_TYPE      ReportType,
   IN       UCHAR                 ReportID,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN OUT   PCHAR                 Report,
   IN       ULONG                 ReportLength
   )
/*++

Routine Description:

   Please See hidpi.h for description.

--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC              channel;
    NTSTATUS  status          = HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    ULONG     channelIndex    = 0;
    ULONG     reportBitIndex  = 0;
    ULONG     nullMask        = 0;
    LONG      nullValue       = 0;
    ULONG     i;

    CHECK_PPD (PreparsedData);

    PAGED_CODE ();

    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    if ((USHORT) ReportLength != iof->ByteLen) {
        return HIDP_STATUS_INVALID_REPORT_LENGTH;
    }

    if (0 == iof->ByteLen) {
        return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    }

    RtlZeroMemory (Report, ReportLength);
    // Set the report ID for this report
    Report[0] = ReportID;

    for (channelIndex = iof->Offset, channel = PreparsedData->Data;
         channelIndex < iof->Index;
         channelIndex++, channel++) {
        //
        // Walk the list of channels looking for fields that need initialization
        //

        if (channel->ReportID != ReportID) {
            continue;
        }
        status = HIDP_STATUS_SUCCESS;

        if ((channel->IsButton) || (channel->IsConst) || (channel->IsAlias)) {
            //
            // Buttons are initialized to zero
            // Constants cannot be set
            // Aliases are referenced by their first entries
            //
            continue;
        }


        if (channel->Data.HasNull) {

            if (32 == channel->ReportSize) {
                nullMask = -1;
            } else {
                nullMask = (1 << channel->ReportSize) - 1;
            }
            //
            // Note logical values are always unsigned.
            // (Not to be confused with physical values which are signed.)
            //
            if (channel->Data.LogicalMax < channel->Data.LogicalMin) {
                //
                // This is really an error.  I'm not sure what I should do here.
                //
                nullValue = 0;

            } else {
                nullValue = (channel->Data.LogicalMin - 1) & nullMask;
            }


            if ((channel->Data.LogicalMin <= nullValue) &&
                (nullValue <= channel->Data.LogicalMax)) {
                //
                //
                //
                // Now what?
                //
                nullValue = 0;
            }

        } else {
            //
            // I don't know what I should do in this case: the device has no
            // reported nul state.
            //
            // For now let's just leave it zero
            //
            nullValue = 0;
        }

        if (0 == nullValue) {
            //
            // Nothing to do on this pass
            //
            continue;
        }

        if (channel->IsRange) {
            for (i = 0, reportBitIndex = (channel->ByteOffset << 3)
                                       + (channel->BitOffset);

                 i < channel->ReportCount;

                 i++, reportBitIndex += channel->ReportSize) {
                //
                // Set all the fields in the range
                //
                HidP_InsertData ((USHORT) (reportBitIndex >> 3),
                                 (USHORT) (reportBitIndex & 7),
                                 channel->ReportSize,
                                 Report,
                                 nullValue);
            }
        } else {

            HidP_InsertData (channel->ByteOffset,
                             channel->BitOffset,
                             channel->ReportSize,
                             Report,
                             nullValue);
        }
    }
    return status;
}

USAGE
HidP_Index2Usage (
   PHIDP_CHANNEL_DESC   Channels,
   ULONG                Index
   )
/*++
   Routine Description:
      Given an array of channels convert an index (the likes of which you might
      find in an array field of a HID report) into a usage value.
--*/
{
   USHORT               len;
   PHIDP_CHANNEL_DESC   startChannel = Channels;
   USAGE                usageMin;
   USAGE                usageMax;

   if (!Index) {
       return 0;
   }

   while (Channels->MoreChannels) {
       // The channels are listed in reverse order.
       Channels++;
   }

   while (Index) {
       if (Channels->IsRange) {
           usageMin = Channels->Range.UsageMin;
           usageMin = (usageMin ? usageMin : 1);
           // Index is 1 based (an index of zero is no usage at all)
           // But a UsageMin of zero means that UsageMin is exclusive.
           // That means that if the index is 1 and UsageMin is non-zero,
           // than this function should return UsageMin

           usageMax = Channels->Range.UsageMax;
           len = (usageMax + 1) - usageMin;
           //               ^^^ Usage Max is inclusive.

           if (Index <= len) {
               return ((USAGE) Index) + usageMin - 1;
           } else {
               Index -= len;
           }
       } else if (1 == Index) {
               return Channels->NotRange.Usage;
       } else {
           Index--;
       }

       if (startChannel != Channels) {
           Channels--;
           continue;
       }
       return 0;
   }
   return 0;
}

ULONG
HidP_Usage2Index (
   PHIDP_CHANNEL_DESC   Channels,
   USAGE                Usage
   )
/*++
   Routine Description:
      Given an usage convert it into an index suitable for placement into an
      array main item.
--*/
{
   PHIDP_CHANNEL_DESC   startChannel;
   ULONG                index = 0;
   USAGE                UsageMin;
   USAGE                UsageMax;

   startChannel = Channels;

   while (Channels->MoreChannels) {
      Channels++;
   }

   for (; startChannel <= Channels; Channels--) {
       if (Channels->IsRange) {
           UsageMin = Channels->Range.UsageMin;
           UsageMin = (UsageMin ? UsageMin : 1);
           // Index is 1 based (an index of zero is no usage at all)
           // But a UsageMin of zero means that UsageMin is exclusive.
           // That means that if the index is 1 and UsageMin is non-zero,
           // than this function should return UsageMin
           UsageMax = Channels->Range.UsageMax;
           if ((UsageMin <= Usage) && (Usage <= UsageMax)) {
               return (index + 1 + Usage - UsageMin);
           }
           index += 1 + (UsageMax - UsageMin);
       } else {
           index++;
           if (Usage == Channels->NotRange.Usage) {
               return index;
           }
       }
   }
   return 0;
}


NTSTATUS __stdcall
HidP_SetUnsetOneUsage (
   struct _CHANNEL_REPORT_HEADER *,
   USAGE,
   USHORT,
   USAGE,
   PHIDP_PREPARSED_DATA,
   PCHAR,
   BOOLEAN);

NTSTATUS __stdcall
HidP_SetUsages (
   IN       HIDP_REPORT_TYPE      ReportType,
   IN       USAGE                 UsagePage,
   IN       USHORT                LinkCollection,
   IN       PUSAGE                UsageList,
   IN OUT   PULONG                UsageLength,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN OUT   PCHAR                 Report,
   IN       ULONG                 ReportLength
   )
/*++

Routine Description:
   Please See hidpi.h for description.

Notes:
--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   NTSTATUS  status      = HIDP_STATUS_SUCCESS;
   ULONG     usageIndex  = 0;

   CHECK_PPD (PreparsedData);

   switch (ReportType) {
   case HidP_Input:
       iof = &PreparsedData->Input;
       break;
   case HidP_Output:
       iof = &PreparsedData->Output;
       break;
   case HidP_Feature:
       iof = &PreparsedData->Feature;
       break;
   default:
       return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   if ((USHORT) ReportLength != iof->ByteLen) {
      return HIDP_STATUS_INVALID_REPORT_LENGTH;
   }

   if (0 == iof->ByteLen) {
       return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
   }

   for (usageIndex = 0; usageIndex < *UsageLength; usageIndex++) {

       if (0 == UsageList [usageIndex]) {
           continue;
       }

       status = HidP_SetUnsetOneUsage (iof,
                                       UsagePage,
                                       LinkCollection,
                                       UsageList [usageIndex],
                                       PreparsedData,
                                       Report,
                                       TRUE);
       if (!NT_SUCCESS(status)) {
           break;
       }
   }
   *UsageLength = usageIndex;
   return status;
}

NTSTATUS __stdcall
HidP_UnsetUsages (
   IN       HIDP_REPORT_TYPE      ReportType,
   IN       USAGE                 UsagePage,
   IN       USHORT                LinkCollection,
   IN       PUSAGE                UsageList,
   IN OUT   PULONG                UsageLength,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN OUT   PCHAR                 Report,
   IN       ULONG                 ReportLength
   )
/*++

Routine Description:
   Please See hidpi.h for description.

Notes:
--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   NTSTATUS  status      = HIDP_STATUS_SUCCESS;
   ULONG     usageIndex  = 0;

   CHECK_PPD (PreparsedData);

   switch (ReportType) {
   case HidP_Input:
      iof = &PreparsedData->Input;
      break;
   case HidP_Output:
      iof = &PreparsedData->Output;
      break;
   case HidP_Feature:
      iof = &PreparsedData->Feature;
      break;
   default:
      return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   if ((USHORT) ReportLength != iof->ByteLen) {
      return HIDP_STATUS_INVALID_REPORT_LENGTH;
   }

   if (0 == iof->ByteLen) {
       return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
   }

   for (usageIndex = 0; usageIndex < *UsageLength; usageIndex++) {

       if (0 == UsageList [usageIndex]) {
           continue;
       }

       status = HidP_SetUnsetOneUsage (iof,
                                       UsagePage,
                                       LinkCollection,
                                       UsageList [usageIndex],
                                       PreparsedData,
                                       Report,
                                       FALSE);
       if (!NT_SUCCESS(status)) {
           break;
       }
   }
   *UsageLength = usageIndex;
   return status;
}

NTSTATUS __stdcall
HidP_SetUnsetOneUsage (
   struct _CHANNEL_REPORT_HEADER * IOF,
   USAGE                           UsagePage,
   USHORT                          LinkCollection,
   USAGE                           Usage,
   PHIDP_PREPARSED_DATA            PreparsedData,
   PCHAR                           Report,
   BOOLEAN                         Set
   )
/*++
Routine Description:
   Perform the work of SetUsage one usage at a time.
   Yes this is slow but it works.

Notes:
   This function assumes the report length has already been verified.
--*/
{
   PHIDP_CHANNEL_DESC   channel         = 0;
   PHIDP_CHANNEL_DESC   priChannel      = 0;
   PHIDP_CHANNEL_DESC   firstChannel    = 0;
   // the channel where the array starts

   ULONG                channelIndex    = 0;
   ULONG                reportByteIndex = 0;
   ULONG                inspect         = 0;
   USHORT               reportBitIndex  = 0;
   BOOLEAN              wrongReportID   = FALSE;
   BOOLEAN              noArraySpace    = FALSE;
   BOOLEAN              notPressed      = FALSE;
   NTSTATUS             status          = HIDP_STATUS_SUCCESS;

   for (channelIndex = IOF->Offset; channelIndex < IOF->Index; channelIndex++) {
      channel = (PreparsedData->Data + channelIndex);
      if (priChannel) {
         if (!priChannel->MoreChannels) {
            firstChannel = channel;
         }
      } else {
         firstChannel = channel;
      }
      priChannel = channel;

      if ((!channel->IsButton) ||
          (channel->UsagePage != UsagePage)) {
          continue;
      }

      //
      // If LinkCollection is zero we will not filter by link collections
      // If channel->LinkCollection is zero this is the root collection.
      // Therefore if LinkCollection == channel->LinkCollection then this is OK
      //
      if ((!LinkCollection) ||
          (LinkCollection == channel->LinkCollection) ||
          ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
           (0 == channel->LinkCollection))) {
          ;

      } else {
          continue;
      }

      if (   ((channel->IsRange)  && (channel->Range.UsageMin <= Usage)
                                  && (Usage <= channel->Range.UsageMax))
          || ((!channel->IsRange) && (channel->NotRange.Usage == Usage))) {
          //
          // Test the report ID to see if it is compatible.
          //
         if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
             //
             // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
             // HIDP_INCOMPATIBLE_REPORT_ID.
             wrongReportID = TRUE;
             continue;
         }

         Report[0] = (CHAR) channel->ReportID;
         //
         // Set the report ID for this report
         //

         if (1 == channel->ReportSize) {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset
                           + (USHORT) (Usage - channel->Range.UsageMin);

            if (Set) {
                Report [reportBitIndex >> 3] |= (1 << (reportBitIndex & 7));
            } else if (Report [reportBitIndex >> 3] & (1 << (reportBitIndex & 7))) {
                Report [reportBitIndex >> 3] &= ~(1 << (reportBitIndex & 7));
            } else {
                return HIDP_STATUS_BUTTON_NOT_PRESSED;
            }

            return HIDP_STATUS_SUCCESS;
         } else if (Set) {  // usage array


            for (reportBitIndex = channel->BitOffset;
                 reportBitIndex < (channel->BitOffset + channel->BitLength);
                 reportBitIndex += channel->ReportSize) {

               inspect = HidP_ExtractData (
                     (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                     (USHORT) (reportBitIndex & 7),
                     channel->ReportSize,
                     Report);

               if (inspect) {
                  //
                  // Distinguish between errors HIDP_USAGE_NOT_FOUND and
                  // HIDP_BUFFER_TOO_SMALL
                  //
                  noArraySpace = TRUE;
                  continue;
               }

               inspect = HidP_Usage2Index (firstChannel, Usage);
               if (!inspect) {
                  //
                  // Gads!  We should NEVER get here!
                  // We already know that the given usage falls into the
                  // current channel, so it should translate into an index.
                  //
                  return HIDP_STATUS_INTERNAL_ERROR;
               }

               HidP_InsertData (
                   (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                   (USHORT) (reportBitIndex & 7),
                   channel->ReportSize,
                   Report,
                   inspect);
               return HIDP_STATUS_SUCCESS;
            }
            // If we got to this point then there was no room to add this
            // usage into the given array.  However there might be another
            // array later into which the given usage might fit.  Let's continue
            // looking.

            while (channel->MoreChannels) {
               // Skip by all the additional channels that describe this
               // same data field.
               channelIndex++;
               channel = (PreparsedData->Data + channelIndex);
            }
            priChannel = channel;

         } else { // Set a Usage Array

             inspect = HidP_Usage2Index (firstChannel, Usage);

             reportBitIndex += channel->ByteOffset << 3;
             status = HidP_DeleteArrayEntry (reportBitIndex,
                                             channel->ReportSize,
                                             channel->ReportCount,
                                             inspect,
                                             Report);

             if (HIDP_STATUS_BUTTON_NOT_PRESSED == status) {
                 notPressed = TRUE;
                 continue;
             }

             if (NT_SUCCESS (status)) {
                 return status;
             } else {
                 ASSERT (0 == status);
             }
         }  // end byte aray
      }
   }
   if (wrongReportID) {
      return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
   }
   if (notPressed) {
       return HIDP_STATUS_BUTTON_NOT_PRESSED;
   }
   if (noArraySpace) {
      return HIDP_STATUS_BUFFER_TOO_SMALL;
   }
   return HIDP_STATUS_USAGE_NOT_FOUND;
}

NTSTATUS __stdcall
HidP_GetUsagesEx (
    IN       HIDP_REPORT_TYPE     ReportType,
    IN       USHORT               LinkCollection, // Optional
    OUT      PUSAGE_AND_PAGE      ButtonList,
    IN OUT   ULONG *              UsageLength,
    IN       PHIDP_PREPARSED_DATA PreparsedData,
    IN       PCHAR                Report,
    IN       ULONG                ReportLength
    )
/*++
Routine Description:
    Please see hidpi.h for description.

--*/
{
    return HidP_GetUsages (ReportType,
                           0,
                           LinkCollection,
                           (PUSAGE) ButtonList,
                           UsageLength,
                           PreparsedData,
                           Report,
                           ReportLength);
}

NTSTATUS __stdcall
HidP_GetUsages (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,
   IN       USHORT               LinkCollection,
   OUT      USAGE *              UsageList,
   IN OUT   ULONG *              UsageLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData,
   IN       PCHAR                Report,
   IN       ULONG                ReportLength
   )
/*++

Routine Description:
   Please see hidpi.h for description.

Notes:
--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC  channel;
    USHORT              channelIndex   = 0;
    USHORT              usageListIndex = 0;
    USHORT              reportBitIndex = 0;
    USHORT              tmpBitIndex;
    NTSTATUS            status         = HIDP_STATUS_SUCCESS;
    ULONG               data           = 0;
    USHORT              inspect        = 0;
    BOOLEAN             wrongReportID  = FALSE;
    BOOLEAN             found          = FALSE;
    PUSAGE_AND_PAGE     usageAndPage   = (PUSAGE_AND_PAGE) UsageList;

    CHECK_PPD (PreparsedData);

    memset (UsageList, '\0', *UsageLength * sizeof (USAGE));

    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    if ((USHORT) ReportLength != iof->ByteLen) {
        return HIDP_STATUS_INVALID_REPORT_LENGTH;
    }

    if (0 == iof->ByteLen) {
        return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    }

    for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++){
        channel = (PreparsedData->Data + channelIndex);
        if ((!channel->IsButton) ||
            ((UsagePage) && (channel->UsagePage != UsagePage))) {

            continue;
        }

        //
        // If LinkCollection is zero we will not filter by link collections
        // If channel->LinkCollection is zero this is the root collection.
        // Therefore if LinkCollection == channel->LinkCollection then this is OK
        //
        if ((!LinkCollection) ||
            (LinkCollection == channel->LinkCollection) ||
            ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
             (0 == channel->LinkCollection))) {
            ;

        } else {
            continue;
        }

        // Test the report ID to see if it is compatible.
        if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
            // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
            // HIDP_INCOMPATIBLE_REPORT_ID.
            wrongReportID = TRUE;
            continue;
        }

        found = TRUE;

        if (1 == channel->ReportSize) {
            // A bitfield
            //
            // Little endian (by bit)
            // Byte 2  |Byte 1 |Byte 0
            // 765432107654321076543210  (bits)
            //
            // Get low byte first.  (need the higher bits)
            // Offset is from bit zero.
            //

            for (reportBitIndex = channel->BitOffset;
                 reportBitIndex < (channel->BitLength + channel->BitOffset);
                 reportBitIndex++) {
                 // Check it one bit at a time.
                tmpBitIndex = reportBitIndex + (channel->ByteOffset << 3);
                inspect = Report [tmpBitIndex >> 3] & (1 << (tmpBitIndex & 7));
                tmpBitIndex = reportBitIndex - channel->BitOffset;
                if (inspect) {
                    if (channel->IsRange) {
                        inspect = channel->Range.UsageMin + tmpBitIndex;
                    } else {
                        inspect = channel->NotRange.Usage;
                    }

                    if (usageListIndex < *UsageLength) {
                        if (0 == UsagePage) {
                            usageAndPage[usageListIndex].UsagePage
                                = channel->UsagePage;
                            usageAndPage[usageListIndex].Usage = inspect;
                        } else {
                            UsageList[usageListIndex] = inspect;
                        }
                    }
                    usageListIndex++;
                }
            }
            continue;
        }

        for (reportBitIndex = channel->BitOffset;
             reportBitIndex < (channel->BitOffset + channel->BitLength);
             reportBitIndex += channel->ReportSize) {
             // an array of usages.
            data = HidP_ExtractData (
                     (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                     (USHORT) (reportBitIndex & 7),
                     channel->ReportSize,
                     Report);

            if (data) {
                inspect = HidP_Index2Usage (channel, data);
                if (!inspect) {
                    // We found an invalid index.  I'm not quite sure what
                    // we should do with it.  But lets just ignore it since
                    // we cannot convert it into a real usage.
                    continue;
                }
                if (usageListIndex < *UsageLength) {
                    if (0 == UsagePage) {
                        usageAndPage[usageListIndex].UsagePage
                            = channel->UsagePage;
                        usageAndPage[usageListIndex].Usage = inspect;
                    } else {
                        UsageList[usageListIndex] = inspect;
                    }
                }
                usageListIndex++;
            }
        }

        while (channel->MoreChannels) {
            // Skip by all the additional channels that describe this
            // same data field.
            channelIndex++;
            channel = (PreparsedData->Data + channelIndex);
        }

    } // end for channel

    if (*UsageLength < usageListIndex) {
        status = HIDP_STATUS_BUFFER_TOO_SMALL;
    }

    *UsageLength = usageListIndex;
    if (!found) {
        if (wrongReportID) {
            status = HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
        } else {
            status = HIDP_STATUS_USAGE_NOT_FOUND;
        }
    }

    return status;
}

ULONG __stdcall
HidP_MaxUsageListLength (
   IN HIDP_REPORT_TYPE      ReportType,
   IN USAGE                 UsagePage,
   IN PHIDP_PREPARSED_DATA  PreparsedData
   )
/*++
Routine Description:
   Please see hidpi.h for description.

Notes:
--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC  channel;
    USHORT              channelIndex   = 0;
    ULONG               len = 0;

    PAGED_CODE ();

    if ((HIDP_PREPARSED_DATA_SIGNATURE1 != PreparsedData->Signature1) &&
        (HIDP_PREPARSED_DATA_SIGNATURE2 != PreparsedData->Signature2)) {
        return 0;
    }


    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return 0;
    }

    for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++){
        channel = (PreparsedData->Data + channelIndex);
        if (channel->IsButton &&
            ((!UsagePage) || (channel->UsagePage == UsagePage))) {

            // How many buttons can show up in this device?
            // If this is a bitmap then the max number of buttons is the length
            // aka the count, if this is an array then the max number of buttons
            // is the number of array positions aka the count.
            len += channel->ReportCount;
        }
    }
    return len;
}

ULONG __stdcall
HidP_MaxDataListLength (
   IN HIDP_REPORT_TYPE      ReportType,
   IN PHIDP_PREPARSED_DATA  PreparsedData
   )
/*++
Routine Description:
   Please see hidpi.h for description.

Notes:
--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC  channel;
    USHORT              channelIndex   = 0;
    ULONG               len = 0;

    PAGED_CODE ();

    if ((HIDP_PREPARSED_DATA_SIGNATURE1 != PreparsedData->Signature1) &&
        (HIDP_PREPARSED_DATA_SIGNATURE2 != PreparsedData->Signature2)) {
        return 0;
    }


    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return 0;
    }

    for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++){
        channel = (PreparsedData->Data + channelIndex);

        if (channel->IsButton) {
            // How many buttons can show up in this device?
            // If this is a bitmap then the max number of buttons is the length
            // aka the count, if this is an array then the max number of buttons
            // is the number of array positions aka the count.
            len += channel->ReportCount;
        } else if (channel->IsRange) {
            len += channel->ReportCount;
        } else {
            len += 1;
        }
    }
    return len;
}


NTSTATUS __stdcall
HidP_SetUsageValue (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,
   IN       USHORT               LinkCollection, // Optional
   IN       USAGE                Usage,
   IN       ULONG                UsageValue,
   IN       PHIDP_PREPARSED_DATA PreparsedData,
   IN OUT   PCHAR                Report,
   IN       ULONG                ReportLength
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   PHIDP_CHANNEL_DESC              channel;
   ULONG     channelIndex    = 0;
   ULONG     reportBitIndex  = 0;
   NTSTATUS  status          = HIDP_STATUS_SUCCESS;
   BOOLEAN   wrongReportID   = FALSE;




   CHECK_PPD (PreparsedData);

   switch (ReportType) {
   case HidP_Input:
      iof = &PreparsedData->Input;
      break;
   case HidP_Output:
      iof = &PreparsedData->Output;
      break;
   case HidP_Feature:
      iof = &PreparsedData->Feature;
      break;
   default:
      return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   if ((USHORT) ReportLength != iof->ByteLen) {
      return HIDP_STATUS_INVALID_REPORT_LENGTH;
   }

   if (0 == iof->ByteLen) {
       return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
   }

   for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++) {
      channel = (PreparsedData->Data + channelIndex);

      if ((channel->IsButton) ||
          (channel->UsagePage != UsagePage)) {
          continue;
      }

      //
      // If LinkCollection is zero we will not filter by link collections
      // If channel->LinkCollection is zero this is the root collection.
      // Therefore if LinkCollection == channel->LinkCollection then this is OK
      //
      if ((!LinkCollection) ||
          (LinkCollection == channel->LinkCollection) ||
          ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
           (0 == channel->LinkCollection))) {
          ;

      } else {
          continue;
      }

      if (channel->IsRange) {
         if ((channel->Range.UsageMin <= Usage) &&
             (Usage <= channel->Range.UsageMax)) {

            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset
                           + (  (Usage - channel->Range.UsageMin)
                              * channel->ReportSize);
         } else {
            continue;
         }
      } else {
         if (channel->NotRange.Usage == Usage) {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset;
         } else {
            continue;
         }
      }
      // Test the report ID to see if it is compatible.
      if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
         // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
         // HIDP_INCOMPATIBLE_REPORT_ID.
         wrongReportID = TRUE;
         continue;
      }
      Report[0] = (CHAR) channel->ReportID;
      // Set the report ID for this report


      HidP_InsertData ((USHORT) (reportBitIndex >> 3),
                    (USHORT) (reportBitIndex & 7),
                    channel->ReportSize,
                    Report,
                    UsageValue);

      return HIDP_STATUS_SUCCESS;
   }
   if (wrongReportID) {
      return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
   }
   return HIDP_STATUS_USAGE_NOT_FOUND;
}


NTSTATUS __stdcall
HidP_SetUsageValueArray (
    IN    HIDP_REPORT_TYPE     ReportType,
    IN    USAGE                UsagePage,
    IN    USHORT               LinkCollection, // Optional
    IN    USAGE                Usage,
    OUT   PCHAR                UsageValue,
    IN    USHORT               UsageValueByteLength,
    IN    PHIDP_PREPARSED_DATA PreparsedData,
    IN    PCHAR                Report,
    IN    ULONG                ReportLength
    )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC              channel;
    ULONG       channelIndex    = 0;
    ULONG       reportBitIndex;
    ULONG       i,j;
    NTSTATUS    status          = HIDP_STATUS_SUCCESS;
    BOOLEAN     wrongReportID   = FALSE;

    CHECK_PPD (PreparsedData);

    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    if ((USHORT) ReportLength != iof->ByteLen) {
        return HIDP_STATUS_INVALID_REPORT_LENGTH;
    }

    if (0 == iof->ByteLen) {
        return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    }

    for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++){
        channel = (PreparsedData->Data + channelIndex);

        if ((channel->IsButton) ||
            (channel->UsagePage != UsagePage)) {
            continue;
        }

        //
        // If LinkCollection is zero we will not filter by link collections
        // If channel->LinkCollection is zero this is the root collection.
        // Therefore if LinkCollection == channel->LinkCollection then this is OK
        //
        if ((!LinkCollection) ||
            (LinkCollection == channel->LinkCollection) ||
            ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
             (0 == channel->LinkCollection))) {
            ;

        } else {
            continue;
        }

        if (channel->IsRange) {
            if ((channel->Range.UsageMin <= Usage) &&
                (Usage <= channel->Range.UsageMax)) {
                return HIDP_STATUS_NOT_VALUE_ARRAY;
            } else {
                continue;
            }
        } else {
            if (channel->NotRange.Usage == Usage) {
                if (1 == channel->ReportCount) {
                    return HIDP_STATUS_NOT_VALUE_ARRAY;
                }
                reportBitIndex =(channel->ByteOffset << 3) + channel->BitOffset;
            } else {
                continue;
            }
        }

        // Test the report ID to see if it is compatible.
        if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
            // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
            // HIDP_INCOMPATIBLE_REPORT_ID.
            wrongReportID = TRUE;
            continue;
        }
        Report[0] = (CHAR) channel->ReportID;
        // Set the report ID for this report

        if ((UsageValueByteLength * 8) <
            (channel->ReportCount * channel->ReportSize)) {
            return HIDP_STATUS_BUFFER_TOO_SMALL;
        }

        if (0 == (channel->ReportSize % 8)) {
            //
            // set the data the easy way: one byte at a time.
            //
            for (i = 0; i < channel->ReportCount; i++) {
                for (j = 0; j < (UCHAR) (channel->ReportSize / 8); j++) {
                    HidP_InsertData ((USHORT) (reportBitIndex >> 3),
                                  (USHORT) (reportBitIndex & 7),
                                  8,
                                  Report,
                                  *UsageValue);
                    reportBitIndex += 8;
                    UsageValue++;
                }
            }
        } else {
            //
            // Do it the hard way: one bit at a time.
            //
            return HIDP_STATUS_NOT_IMPLEMENTED;
        }

        return HIDP_STATUS_SUCCESS;
    }
    if (wrongReportID) {
        return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
    }
    return HIDP_STATUS_USAGE_NOT_FOUND;
}


NTSTATUS __stdcall
HidP_SetScaledUsageValue (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,
   IN       USHORT               LinkCollection, // Optional
   IN       USAGE                Usage,
   IN       LONG                 UsageValue,
   IN       PHIDP_PREPARSED_DATA PreparsedData,
   IN OUT   PCHAR                Report,
   IN       ULONG                ReportLength
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   PHIDP_CHANNEL_DESC              channel;
   ULONG     channelIndex    = 0;
   ULONG     reportBitIndex  = 0;
   NTSTATUS  status          = HIDP_STATUS_USAGE_NOT_FOUND;
   LONG      logicalMin, logicalMax;
   LONG      physicalMin, physicalMax;
   LONG      value;
   BOOLEAN   wrongReportID   = FALSE;

   CHECK_PPD (PreparsedData);

   switch (ReportType) {
   case HidP_Input:
      iof = &PreparsedData->Input;
      break;
   case HidP_Output:
      iof = &PreparsedData->Output;
      break;
   case HidP_Feature:
      iof = &PreparsedData->Feature;
      break;
   default:
      return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   if ((USHORT) ReportLength != iof->ByteLen) {
      return HIDP_STATUS_INVALID_REPORT_LENGTH;
   }

   if (0 == iof->ByteLen) {
       return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
   }

   for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++) {
      channel = (PreparsedData->Data + channelIndex);

      if ((channel->IsButton) ||
          (channel->UsagePage != UsagePage)) {
          continue;
      }

      //
      // If LinkCollection is zero we will not filter by link collections
      // If channel->LinkCollection is zero this is the root collection.
      // Therefore if LinkCollection == channel->LinkCollection then this is OK
      //
      if ((!LinkCollection) ||
          (LinkCollection == channel->LinkCollection) ||
          ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
           (0 == channel->LinkCollection))) {
          ;

      } else {
          continue;
      }

      if (channel->IsRange) {
         if ((channel->Range.UsageMin <= Usage) &&
             (Usage <= channel->Range.UsageMax)) {

             reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset
                           + (  (Usage - channel->Range.UsageMin)
                              * channel->ReportSize);
         } else {
            continue;
         }
      } else {
         if (channel->NotRange.Usage == Usage) {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset;
         } else {
            continue;
         }
      }
      // Test the report ID to see if it is compatible.
      if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
         // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
         // HIDP_INCOMPATIBLE_REPORT_ID.
         wrongReportID = TRUE;
         continue;
      }
      Report[0] = (CHAR) channel->ReportID;
      // Set the report ID for this report

      logicalMin = channel->Data.LogicalMin;
      logicalMax = channel->Data.LogicalMax;
      physicalMin = channel->Data.PhysicalMin;
      physicalMax = channel->Data.PhysicalMax;

      //
      // The code path here is ALWAYS the same, we should test it once
      // and then use some sort of switch statement to do the calculation.
      //

      if ((0 == physicalMin) &&
          (0 == physicalMax) &&
          (logicalMin != logicalMax)) {
          //
          // The device did not set the physical min and max values
          //
          if ((logicalMin <= UsageValue) && (UsageValue <= logicalMax)) {
              value = UsageValue;

              //
              // fix the sign bit
              // I should store away the sign bit somewhere so I don't
              // have to calculate it all the time.
              //
              if (value & 0x80000000) {
                  value |= (1 << (channel->ReportSize - 1));
              } else {
                  value &= ((1 << (channel->ReportSize - 1)) - 1);
              }
          } else {
              if (channel->Data.HasNull) {
                  value = (1 << (channel->ReportSize - 1));// Most negitive value
                  status = HIDP_STATUS_NULL;
              } else {
                  return HIDP_STATUS_VALUE_OUT_OF_RANGE;
              }
          }


      } else {
          //
          // The device has physical descriptors.
          //

          if ((logicalMax <= logicalMin) || (physicalMax <= physicalMin)) {
              return HIDP_STATUS_BAD_LOG_PHY_VALUES;
          }

          if ((physicalMin <= UsageValue) && (UsageValue <= physicalMax)) {
              value = logicalMin + ((UsageValue - physicalMin) *
                                    (logicalMax - logicalMin + 1) /
                                    (physicalMax - physicalMin + 1));
          } else {
              if (channel->Data.HasNull) {
                  value = (1 << (channel->ReportSize - 1));// Most negitive value
                  status = HIDP_STATUS_NULL;
              } else {
                  return HIDP_STATUS_VALUE_OUT_OF_RANGE;
              }
          }
      }
      HidP_InsertData ((USHORT) (reportBitIndex >> 3),
                       (USHORT) (reportBitIndex & 7),
                       channel->ReportSize,
                       Report,
                       (ULONG) value);

      return HIDP_STATUS_SUCCESS;
   }
   if (wrongReportID) {
      return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
   }
   return status;
}



NTSTATUS __stdcall
HidP_GetUsageValue (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,
   IN       USHORT               LinkCollection, // Optional
   IN       USAGE                Usage,
   OUT      PULONG               UsageValue,
   IN       PHIDP_PREPARSED_DATA PreparsedData,
   IN       PCHAR                Report,
   IN       ULONG                ReportLength
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   PHIDP_CHANNEL_DESC              channel;
   ULONG     channelIndex    = 0;
   ULONG     reportBitIndex  = 0;
   ULONG     reportByteIndex = 0;
   NTSTATUS  status          = HIDP_STATUS_SUCCESS;
   ULONG     inspect         = 0;
   BOOLEAN   wrongReportID   = FALSE;

   CHECK_PPD (PreparsedData);

   switch (ReportType)
   {
   case HidP_Input:
      iof = &PreparsedData->Input;
      break;
   case HidP_Output:
      iof = &PreparsedData->Output;
      break;
   case HidP_Feature:
      iof = &PreparsedData->Feature;
      break;
   default:
      return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   if ((USHORT) ReportLength != iof->ByteLen) {
       return HIDP_STATUS_INVALID_REPORT_LENGTH;
   }

   if (0 == iof->ByteLen) {
       return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
   }

   for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++)
   {
      channel = (PreparsedData->Data + channelIndex);

      if ((channel->IsButton) ||
          (channel->UsagePage != UsagePage)) {
          continue;
      }

      //
      // If LinkCollection is zero we will not filter by link collections
      // If channel->LinkCollection is zero this is the root collection.
      // Therefore if LinkCollection == channel->LinkCollection then this is OK
      //
      if ((!LinkCollection) ||
          (LinkCollection == channel->LinkCollection) ||
          ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
           (0 == channel->LinkCollection))) {
          ;

      } else {
          continue;
      }

      if (channel->IsRange) {

         if ((channel->Range.UsageMin <= Usage) &&
             (Usage <= channel->Range.UsageMax))
         {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset
                           + (  (Usage - channel->Range.UsageMin)
                              * channel->ReportSize);
         } else
         {
            continue;
         }
      } else
      {
         if (channel->NotRange.Usage == Usage)
         {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset;
         } else
         {
            continue;
         }
      }

      // Test the report ID to see if it is compatible.
      if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
         // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
         // HIDP_INCOMPATIBLE_REPORT_ID.
         wrongReportID = TRUE;
         continue;
      }

      inspect = HidP_ExtractData ((USHORT) (reportBitIndex >> 3),
                              (USHORT) (reportBitIndex & 7),
                              channel->ReportSize,
                              Report);

      *UsageValue = inspect;
      return HIDP_STATUS_SUCCESS;
   }
   if (wrongReportID) {
      return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
   }
   return HIDP_STATUS_USAGE_NOT_FOUND;
}


NTSTATUS __stdcall
HidP_GetUsageValueArray (
    IN    HIDP_REPORT_TYPE     ReportType,
    IN    USAGE                UsagePage,
    IN    USHORT               LinkCollection, // Optional
    IN    USAGE                Usage,
    OUT   PCHAR                UsageValue,
    IN    USHORT               UsageValueByteLength,
    IN    PHIDP_PREPARSED_DATA PreparsedData,
    IN    PCHAR                Report,
    IN    ULONG                ReportLength
    )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC              channel;
    ULONG       channelIndex    = 0;
    ULONG       reportBitIndex;
    ULONG       i,j;
    NTSTATUS    status          = HIDP_STATUS_SUCCESS;
    ULONG       inspect         = 0;
    BOOLEAN     wrongReportID   = FALSE;

    CHECK_PPD (PreparsedData);

    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    if ((USHORT) ReportLength != iof->ByteLen) {
        return HIDP_STATUS_INVALID_REPORT_LENGTH;
    }

    if (0 == iof->ByteLen) {
        return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    }

    for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++){
        channel = (PreparsedData->Data + channelIndex);

        if ((channel->IsButton) ||
            (channel->UsagePage != UsagePage)) {
            continue;
        }

        //
        // If LinkCollection is zero we will not filter by link collections
        // If channel->LinkCollection is zero this is the root collection.
        // Therefore if LinkCollection == channel->LinkCollection then this is OK
        //
        if ((!LinkCollection) ||
            (LinkCollection == channel->LinkCollection) ||
            ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
             (0 == channel->LinkCollection))) {
            ;

        } else {
            continue;
        }

        if (channel->IsRange) {
            if ((channel->Range.UsageMin <= Usage) &&
                (Usage <= channel->Range.UsageMax)) {

                return HIDP_STATUS_NOT_VALUE_ARRAY;
            } else {
                continue;
            }
        } else {
            if (channel->NotRange.Usage == Usage) {
                if (1 == channel->ReportCount) {
                    return HIDP_STATUS_NOT_VALUE_ARRAY;
                }
                reportBitIndex =(channel->ByteOffset << 3) + channel->BitOffset;
            } else {
                continue;
            }
        }

        // Test the report ID to see if it is compatible.
        if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
            // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
            // HIDP_INCOMPATIBLE_REPORT_ID.
            wrongReportID = TRUE;
            continue;
        }

        if ((UsageValueByteLength * 8) <
            (channel->ReportCount * channel->ReportSize)) {
            return HIDP_STATUS_BUFFER_TOO_SMALL;
        }

        if (0 == (channel->ReportSize % 8)) {
            //
            // Retrieve the data the easy way
            //
            for (i = 0; i < channel->ReportCount; i++) {
                for (j = 0; j < (USHORT) (channel->ReportSize / 8); j++) {
                    *UsageValue = (CHAR) HidP_ExtractData (
                                                (USHORT) (reportBitIndex >> 3),
                                                (USHORT) (reportBitIndex & 7),
                                                8,
                                                Report);
                    reportBitIndex += 8;
                    UsageValue++;
                }
            }
        } else {
            //
            // Do it the hard way
            //
            return HIDP_STATUS_NOT_IMPLEMENTED;
        }

        return HIDP_STATUS_SUCCESS;
    }
    if (wrongReportID) {
        return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
    }
    return HIDP_STATUS_USAGE_NOT_FOUND;
}


NTSTATUS __stdcall
HidP_GetScaledUsageValue (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,
   IN       USHORT               LinkCollection, // Optional
   IN       USAGE                Usage,
   OUT      PLONG                UsageValue,
   IN       PHIDP_PREPARSED_DATA PreparsedData,
   IN       PCHAR                Report,
   IN       ULONG                ReportLength
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   PHIDP_CHANNEL_DESC              channel;
   ULONG     channelIndex    = 0;
   ULONG     reportBitIndex  = 0;
   ULONG     reportByteIndex = 0;
   NTSTATUS  status          = HIDP_STATUS_SUCCESS;
   ULONG     inspect         = 0;
   LONG      logicalMin, logicalMax;
   LONG      physicalMin, physicalMax;
   LONG      value;
   BOOLEAN   wrongReportID   = FALSE;

   CHECK_PPD (PreparsedData);

   switch (ReportType) {
   case HidP_Input:
      iof = &PreparsedData->Input;
      break;
   case HidP_Output:
      iof = &PreparsedData->Output;
      break;
   case HidP_Feature:
      iof = &PreparsedData->Feature;
      break;
   default:
      return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   if ((USHORT) ReportLength != iof->ByteLen) {
      return HIDP_STATUS_INVALID_REPORT_LENGTH;
   }

   if (0 == iof->ByteLen) {
       return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
   }

   for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++) {
      channel = (PreparsedData->Data + channelIndex);

      if ((channel->IsButton) ||
          (channel->UsagePage != UsagePage)) {
          continue;
      }

      //
      // If LinkCollection is zero we will not filter by link collections
      // If channel->LinkCollection is zero this is the root collection.
      // Therefore if LinkCollection == channel->LinkCollection then this is OK
      //
      if ((!LinkCollection) ||
          (LinkCollection == channel->LinkCollection) ||
          ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
           (0 == channel->LinkCollection))) {
          ;

      } else {
          continue;
      }

      if (channel->IsRange) {
         if ((channel->Range.UsageMin <= Usage) &&
             (Usage <= channel->Range.UsageMax)) {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset
                           + (  (Usage - channel->Range.UsageMin)
                              * channel->ReportSize);
         } else {
            continue;
         }
      } else {
         if (channel->NotRange.Usage == Usage) {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset;
         } else {
            continue;
         }
      }

      // Test the report ID to see if it is compatible.
      if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
         // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
         // HIDP_INCOMPATIBLE_REPORT_ID.
         wrongReportID = TRUE;
         continue;
      }

      logicalMin = channel->Data.LogicalMin;
      logicalMax = channel->Data.LogicalMax;
      physicalMin = channel->Data.PhysicalMin;
      physicalMax = channel->Data.PhysicalMax;

      inspect = HidP_ExtractData ((USHORT) (reportBitIndex >> 3),
                              (USHORT) (reportBitIndex & 7),
                              channel->ReportSize,
                              Report);

      //
      // Sign extend the value;
      // Find the top most bit of the field.
      // (logical and with 1 shifted by bit length minus one)
      // based on that, set the upper most bits.
      //
      value = (LONG) (inspect | ((inspect & (1 << (channel->ReportSize - 1))) ?
                                 ((~(1 << (channel->ReportSize - 1))) + 1) :
                                 0));

      //
      // the code path here is ALWAYS the same, we should test it once
      // and then use some sort of switch statement to do the calculation.
      //

      if ((0 == physicalMin) &&
          (0 == physicalMax) &&
          (logicalMin != logicalMax)) {
          //
          // The Device did not set the physical Min and Max Values
          //
          *UsageValue = value;

      } else if ((logicalMax <= logicalMin) || (physicalMax <= physicalMin)) {
          *UsageValue = 0;
          return HIDP_STATUS_BAD_LOG_PHY_VALUES;

      } else {
          // the Min and Max are both inclusive.
          // The value is in range
          // *UsageValue = physicalMin + (((value - logicalMin) *
          //                               (physicalMax - physicalMin)) /
          //                              (logicalMax - logicalMin));
          // not enough accuracy.
          //
          *UsageValue = physicalMin
                      + (LONG)(((LONGLONG)(value - logicalMin) *
                                (LONGLONG)(physicalMax - physicalMin)) /
                               (LONGLONG)(logicalMax - logicalMin));
      }

      if ((logicalMin <= value) && (value <= logicalMax)) {
          return HIDP_STATUS_SUCCESS;

      } else {
          // The value is not in range
          *UsageValue = 0;

          if (channel->Data.HasNull) {
              return HIDP_STATUS_NULL;
          } else {
              return HIDP_STATUS_VALUE_OUT_OF_RANGE;
          }
      }

   }
   if (wrongReportID) {
      return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
   }
   return HIDP_STATUS_USAGE_NOT_FOUND;
}


NTSTATUS __stdcall
HidP_SetOneData (
   struct _CHANNEL_REPORT_HEADER * Iof,
   IN       PHIDP_DATA            Data,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN OUT   PCHAR                 Report
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
    PHIDP_CHANNEL_DESC   channel;
    ULONG     inspect;
    NTSTATUS  status          = HIDP_STATUS_SUCCESS;
    USHORT    channelIndex    = 0;
    USHORT    dataListIndex   = 0;
    USHORT    reportBitIndex;
    BOOLEAN   wrongReportID   = FALSE;
    BOOLEAN   noArraySpace    = FALSE;
    BOOLEAN   notPressed      = FALSE;

    for (channelIndex = Iof->Offset; channelIndex < Iof->Index; channelIndex++){
        channel = (PreparsedData->Data + channelIndex);

        if ((channel->Range.DataIndexMin <= Data->DataIndex) &&
            (Data->DataIndex <= channel->Range.DataIndexMax)) {

            if ((!channel->IsRange) && (1 != channel->ReportCount)) {
                //
                // This value array.  We cannot access this here.
                //
                return HIDP_STATUS_IS_VALUE_ARRAY;
            }

            // Test the report ID to see if it is compatible.
            if (0 != Report[0]) {
                if (channel->ReportID != (UCHAR) Report[0]) {
                    wrongReportID = TRUE;
                    continue;
                }
            } else {
                Report[0] = (CHAR) channel->ReportID;
            }

            if (channel->IsButton) {

                if (1 == channel->ReportSize) {
                    // A bitfield
                    //
                    // Little endian (by bit)
                    // Byte 2  |Byte 1 |Byte 0
                    // 765432107654321076543210  (bits)
                    //
                    // Get low byte first.  (need the higher bits)
                    // Offset is from bit zero.
                    //
                    reportBitIndex = (channel->ByteOffset << 3)
                                   + channel->BitOffset
                                   + (USHORT) (Data->DataIndex -
                                               channel->Range.DataIndexMin);

                    if (Data->On) {
                        Report [reportBitIndex >> 3] |= (1 << (reportBitIndex & 7));
                    } else if (Report [reportBitIndex >> 3] &
                               (1 << (reportBitIndex & 7))) {

                        Report [reportBitIndex >> 3] &= ~(1 << (reportBitIndex & 7));
                    } else {
                        return HIDP_STATUS_BUTTON_NOT_PRESSED;
                    }

                    return HIDP_STATUS_SUCCESS;
                }

                //
                // Not a bit field
                // an array of usages then.
                //

                //
                // Are we clearing a usage from this array?
                //
                if (FALSE == Data->On) {
                    //
                    // NB Wizard Time (tm)
                    //
                    // We know that data indices are assigned consecutively
                    // for every control, and that the array channels
                    // are reversed in the channel array.
                    //
                    // inspect is the index (1 based not zero based) into the
                    // channel array.
                    //
                    // Skip to the last channel that describes this same data
                    // fild;
                    //
                    while (channel->MoreChannels) {
                        channelIndex++;
                        channel++;
                    }
                    inspect = Data->DataIndex - channel->Range.DataIndexMin + 1;

                    if (0 == channel->Range.UsageMin) {
                        inspect--;
                    }

                    // Clear the value of inspect which is the usage translated
                    // to the index in the array.

                    reportBitIndex = channel->BitOffset
                                   + (channel->ByteOffset << 3);

                    status = HidP_DeleteArrayEntry (reportBitIndex,
                                                    channel->ReportSize,
                                                    channel->ReportCount,
                                                    inspect,
                                                    Report);

                    if (HIDP_STATUS_BUTTON_NOT_PRESSED == status) {
                        notPressed = TRUE;
                        continue;
                    }

                    if (NT_SUCCESS (status)) {
                        return status;
                    } else {
                        ASSERT (0 == status);
                    }
                }

                //
                // We are clearly setting a usage into an array.
                //
                for (reportBitIndex = channel->BitOffset;
                     reportBitIndex < (channel->BitOffset + channel->BitLength);
                     reportBitIndex += channel->ReportSize) {
                    // Search for an empty entry in this array

                    inspect = (USHORT) HidP_ExtractData (
                        (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                        (USHORT) (reportBitIndex & 7),
                        channel->ReportSize,
                        Report);

                    if (inspect) {
                        //
                        // Distinguish between errors HIDP_INDEX_NOT_FOUND and
                        // HIDP_BUFFER_TOO_SMALL
                        //
                        noArraySpace = TRUE;
                        continue;
                    }

                    //
                    // NB Wizard Time (tm)
                    //
                    // We know that data indices are assigned consecutively
                    // for every control, and that the array channels
                    // are reversed in the channel array.
                    //
                    // inspect is the index (1 based not zero based) into the
                    // channel array.
                    //
                    // Skip to the last channel that describes this same data
                    // fild;
                    //
                    while (channel->MoreChannels) {
                        channelIndex++;
                        channel++;
                    }
                    inspect = Data->DataIndex - channel->Range.DataIndexMin + 1;

                    if (0 == channel->Range.UsageMin) {
                        inspect--;
                    }

                    HidP_InsertData (
                        (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                        (USHORT) (reportBitIndex & 7),
                        channel->ReportSize,
                        Report,
                        inspect);
                    return HIDP_STATUS_SUCCESS;
                } // end of search for entry

                continue;
            }

            //
            // Not a button therefore a value.
            //

            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset
                           + (  (Data->DataIndex - channel->Range.DataIndexMin)
                              * channel->ReportSize);

            HidP_InsertData ((USHORT) (reportBitIndex >> 3),
                             (USHORT) (reportBitIndex & 7),
                             channel->ReportSize,
                             Report,
                             Data->RawValue);

            return HIDP_STATUS_SUCCESS;

        } // end matched data index
    } // end for loop

    if (wrongReportID) {
        return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
    }
    if (notPressed) {
        return HIDP_STATUS_BUTTON_NOT_PRESSED;
    }
    if (noArraySpace) {
        return HIDP_STATUS_BUFFER_TOO_SMALL;
    }
    return HIDP_STATUS_DATA_INDEX_NOT_FOUND;
}

NTSTATUS
HidP_SetData (
   IN       HIDP_REPORT_TYPE      ReportType,
   IN       PHIDP_DATA            DataList,
   IN OUT   PULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN OUT   PCHAR                 Report,
   IN       ULONG                 ReportLength
   )
{
    ULONG       dataIndex;
    NTSTATUS    status;
    struct _CHANNEL_REPORT_HEADER * iof;

    CHECK_PPD (PreparsedData);

    switch (ReportType) {
    case HidP_Input:
       iof = &PreparsedData->Input;
       break;
    case HidP_Output:
       iof = &PreparsedData->Output;
       break;
    case HidP_Feature:
       iof = &PreparsedData->Feature;
       break;
    default:
       return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    if ((USHORT) ReportLength != iof->ByteLen) {
        return HIDP_STATUS_INVALID_REPORT_LENGTH;
    }

    if (0 == iof->ByteLen) {
        return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    }

    for (dataIndex = 0; dataIndex < *DataLength; dataIndex++, DataList++) {
        status = HidP_SetOneData (iof, DataList, PreparsedData, Report);

        if (!NT_SUCCESS (status)) {
            break;
        }
    }
    *DataLength = dataIndex;
    return status;
}

NTSTATUS __stdcall
HidP_GetData (
   IN       HIDP_REPORT_TYPE      ReportType,
   OUT      PHIDP_DATA            DataList,
   IN OUT   PULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN       PCHAR                 Report,
   IN       ULONG                 ReportLength
   )
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC              channel;
    ULONG     inspect;
    USHORT    channelIndex  = 0;
    USHORT    dataListIndex = 0;
    USHORT    reportBitIndex;
    USHORT    tmpBitIndex;
     USHORT    tmpDataIndex;
    NTSTATUS  status          = HIDP_STATUS_SUCCESS;

    CHECK_PPD (PreparsedData);

    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
       break;
    case HidP_Output:
       iof = &PreparsedData->Output;
       break;
    case HidP_Feature:
       iof = &PreparsedData->Feature;
       break;
    default:
       return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    if ((USHORT) ReportLength != iof->ByteLen) {
        return HIDP_STATUS_INVALID_REPORT_LENGTH;
    }

    if (0 == iof->ByteLen) {
        return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    }

    for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++) {
        channel = (PreparsedData->Data + channelIndex);

        if ((!channel->IsRange) && (1 != channel->ReportCount)) {
            //
            // This value array.  We cannot access this here.
            //
            continue;
        }

        // Test the report ID to see if it is compatible.
        if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
            continue;
        }

        if (channel->IsButton) {
            if (1 == channel->ReportSize) {
                // A bitfield
                //
                // Little endian (by bit)
                // Byte 2  |Byte 1 |Byte 0
                // 765432107654321076543210  (bits)
                //
                // Get low byte first.  (need the higher bits)
                // Offset is from bit zero.
                //

                for (reportBitIndex = channel->BitOffset;
                     reportBitIndex < (channel->BitLength + channel->BitOffset);
                     reportBitIndex++) {
                    // Check it one bit at a time.
                    tmpBitIndex = reportBitIndex + (channel->ByteOffset << 3);
                    inspect = Report [tmpBitIndex >> 3] & (1 << (tmpBitIndex & 7));
                    tmpBitIndex = reportBitIndex - channel->BitOffset;
                    if (inspect) {
                        if (channel->IsRange) {
                            inspect = channel->Range.DataIndexMin + tmpBitIndex;
                        } else {
                            inspect = channel->NotRange.DataIndex;
                        }

                        if (dataListIndex < *DataLength) {
                            DataList[dataListIndex].On = TRUE;
                            DataList[dataListIndex].DataIndex = (USHORT)inspect;
                        }
                        dataListIndex++;
                    }
                }
                continue;
            }

            //
            // Not a bit field
            // an array of usages.
            //

            for (reportBitIndex = channel->BitOffset;
                 reportBitIndex < (channel->BitOffset + channel->BitLength);
                 reportBitIndex += channel->ReportSize) {

                inspect = (USHORT) HidP_ExtractData (
                        (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                        (USHORT) (reportBitIndex & 7),
                        channel->ReportSize,
                        Report);

                if (inspect) {
                    //
                    // NB Wizard Time (tm)
                    //
                    // We know that data indices are assigned consecutively
                    // for every control, and that the array channels
                    // are reversed in the channel array.
                    //
                    // inspect is the index (1 based not zero based) into the
                    // channel array.
                    //
                    if (0 == inspect) {
                        continue;
                    }

                    //
                    // Skip to the last channel that describes this same data
                    // fild;
                    //
                    while (channel->MoreChannels) {
                        channelIndex++;
                        channel++;
                    }
                    inspect += channel->Range.DataIndexMin - 1;
                    if (0 == channel->Range.UsageMin) {
                        inspect++;
                    }

                    if (dataListIndex < *DataLength) {
                        DataList [dataListIndex].On = TRUE;
                        DataList [dataListIndex].DataIndex = (USHORT) inspect;
                    }
                    dataListIndex++;
                }
            }
            continue;
        }
        //
        // Not a button so therefore a value.
        //

        for (reportBitIndex = channel->BitOffset, tmpDataIndex = 0;
             reportBitIndex < (channel->BitOffset + channel->BitLength);
             reportBitIndex += channel->ReportSize, tmpDataIndex++) {

            inspect = HidP_ExtractData (
                        (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                        (USHORT) (reportBitIndex & 7),
                        channel->ReportSize,
                        Report);

            if (dataListIndex < *DataLength) {

                ASSERT(tmpDataIndex + channel->Range.DataIndexMin <=
                        channel->Range.DataIndexMax);
                DataList [dataListIndex].RawValue = inspect;
                DataList [dataListIndex].DataIndex =
                    channel->Range.DataIndexMin + tmpDataIndex;
            }
            dataListIndex++;
        }
    }

    if (*DataLength < dataListIndex) {
        status = HIDP_STATUS_BUFFER_TOO_SMALL;
    }

    *DataLength = dataListIndex;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidparse\descript.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    descript.c

Abstract:
    This module contains the code for parsing HID descriptors.

Environment:

    Kernel & user mode

Revision History:

    Aug-96 : created by Kenneth Ray

--*/

#include "wdm.h"
#include "hidpddi.h"
#include "hidusage.h"

#define FAR
#include "poclass.h"
#include "hidparse.h"

#define HIDP_LINK_COLLECTION_NODE use internal "private" only
#define PHIDP_LINK_COLLECTION_NODE use internal "private" only


typedef struct _HIDP_COLLECTION_DESC_LIST
{
   struct _HIDP_COLLECTION_DESC;
   struct _HIDP_COLLECTION_DESC_LIST * NextCollection;
} HIDP_COLLECTION_DESC_LIST, *PHIDP_COLLECTION_DESC_LIST;

typedef struct _HIDP_PARSE_GLOBAL_PUSH
{
   USHORT UsagePage;
   USHORT ReportSize,    ReportCount;
   USHORT NumGlobalUnknowns;

   LONG   LogicalMin,    LogicalMax;
   LONG   PhysicalMin,   PhysicalMax;
   ULONG  UnitExp,       Unit;
   HIDP_UNKNOWN_TOKEN    GlobalUnknowns [HIDP_MAX_UNKNOWN_ITEMS];

   struct _HIDP_REPORT_IDS        * ReportIDs;
   struct _HIDP_PARSE_GLOBAL_PUSH * Pop;
} HIDP_PARSE_GLOBAL_PUSH, *PHIDP_PARSE_GLOBAL_PUSH;


typedef struct _HIDP_PARSE_LOCAL_RANGE
{
   BOOLEAN  Range;
   BOOLEAN  IsAlias;
   // This usage is an alias (as declaired with a delimiter)
   // An alias of the next LOCAL_RANGE on the LOCAL_RANGE stack
   USHORT   UsagePage;
   USHORT   Value,  Min,  Max;
} HIDP_PARSE_LOCAL_RANGE, *PHIDP_PARSE_LOCAL_RANGE;

typedef struct _HIDP_PARSE_LOCAL_RANGE_LIST
{
   HIDP_PARSE_LOCAL_RANGE;
   UCHAR       Depth;
   UCHAR       Reserved2[1];
   struct _HIDP_PARSE_LOCAL_RANGE_LIST * Next;
} HIDP_PARSE_LOCAL_RANGE_LIST, *PHIDP_PARSE_LOCAL_RANGE_LIST;

NTSTATUS HidP_AllocateCollections (PHIDP_REPORT_DESCRIPTOR, ULONG, POOL_TYPE, PHIDP_COLLECTION_DESC_LIST *, PULONG, PHIDP_GETCOLDESC_DBG, PHIDP_DEVICE_DESC);
NTSTATUS HidP_ParseCollections (PHIDP_REPORT_DESCRIPTOR, ULONG, POOL_TYPE, PHIDP_COLLECTION_DESC_LIST, ULONG, PHIDP_GETCOLDESC_DBG, PHIDP_DEVICE_DESC);
void HidP_AssignDataIndices (PHIDP_PREPARSED_DATA, PHIDP_GETCOLDESC_DBG);
PHIDP_PARSE_LOCAL_RANGE_LIST HidP_FreeUsageList (PHIDP_PARSE_LOCAL_RANGE_LIST);
PHIDP_PARSE_LOCAL_RANGE_LIST HidP_PushUsageList (PHIDP_PARSE_LOCAL_RANGE_LIST, POOL_TYPE, BOOLEAN);
PHIDP_PARSE_LOCAL_RANGE_LIST HidP_PopUsageList (PHIDP_PARSE_LOCAL_RANGE_LIST);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HidP_AllocateCollections)
#pragma alloc_text(PAGE, HidP_ParseCollections)
#pragma alloc_text(PAGE, HidP_AssignDataIndices)
#pragma alloc_text(PAGE, HidP_GetCollectionDescription)
#pragma alloc_text(PAGE, HidP_FreeUsageList)
#pragma alloc_text(PAGE, HidP_PushUsageList)
#pragma alloc_text(PAGE, HidP_PopUsageList)
#endif


NTSTATUS
HidP_GetCollectionDescription(
   IN     PHIDP_REPORT_DESCRIPTOR   ReportDesc,
   IN     ULONG                     DescLength,
   IN     POOL_TYPE                 PoolType,
   OUT    PHIDP_DEVICE_DESC         DeviceDesc
   )
/*++
Routine Description:
   see hidpi.h for a description of this function.

    GetCollectionDescription is a one time cost.
    The following function and its support functions were put together
    in as straight forward (as HID will allow) manner.
    Not major opt. has been made.

--*/
{
   NTSTATUS                   status = STATUS_SUCCESS;
   PHIDP_COLLECTION_DESC_LIST collectDesc = 0;
   PHIDP_COLLECTION_DESC_LIST nextCollectDesc = 0;
   ULONG                      numCols = 0;
   ULONG                      collectionDescLength = 0;

// First Pass allocate memory for the collections.

   DeviceDesc->Dbg.ErrorCode = HIDP_GETCOLDESC_SUCCESS;

   RtlZeroMemory (DeviceDesc, sizeof (HIDP_DEVICE_DESC));

   HidP_KdPrint(0, ("'Preparing to Allocate memory\n"));
   status = HidP_AllocateCollections (ReportDesc,
                                      DescLength,
                                      PoolType,
                                      &collectDesc,
                                      &numCols,
                                      &DeviceDesc->Dbg,
                                      DeviceDesc);
   if (0 == numCols)
   {
      // No collections were reported.  That means that this device did not
      // report any top level collections in its report descriptor.
      // This is most bad.
      status = STATUS_NO_DATA_DETECTED;
      goto HIDP_GETCOLLECTIONS_REJECT;
   }
   if (!NT_SUCCESS(status))
   {
      // Something went wrong in the allocation of the memory.
      goto HIDP_GETCOLLECTIONS_REJECT;
   }

   // Second Pass fill in the data.

   HidP_KdPrint(0, ("'Starting Parsing Pass\n"));
   status = HidP_ParseCollections(ReportDesc,
                                  DescLength,
                                  PoolType,
                                  collectDesc,
                                  numCols,
                                  &DeviceDesc->Dbg,
                                  DeviceDesc);


   if (NT_SUCCESS (status))
   {
      DeviceDesc->CollectionDesc =
          (PHIDP_COLLECTION_DESC)
          ExAllocatePool (PoolType, numCols * sizeof (HIDP_COLLECTION_DESC));

       if (! (DeviceDesc->CollectionDesc))
       {
          status = STATUS_INSUFFICIENT_RESOURCES;
          HidP_KdPrint(2, ("Insufficitent Resources at VERY END\n"));
          DeviceDesc->Dbg.BreakOffset = DescLength;
          DeviceDesc->Dbg.ErrorCode =   HIDP_GETCOLDESC_RESOURCES;
          goto HIDP_GETCOLLECTIONS_REJECT;
       }

       //
       // Here we flatten out the collection descriptions but we never
       // flatten the PHIDP_PREPARSED_DATA data.  We could (should) do that as
       // well if we ever optimize.
       //
       DeviceDesc->CollectionDescLength = numCols;
       numCols = 0;
       while (collectDesc)
       {
          nextCollectDesc = collectDesc->NextCollection;
          RtlCopyMemory (DeviceDesc->CollectionDesc + (numCols++),
                         collectDesc,
                         sizeof (HIDP_COLLECTION_DESC));
          HidP_AssignDataIndices (collectDesc->PreparsedData, &DeviceDesc->Dbg);
          ExFreePool (collectDesc);
          collectDesc = nextCollectDesc;
       }

       return STATUS_SUCCESS;
   }

HIDP_GETCOLLECTIONS_REJECT:
   while (collectDesc)
   {
      nextCollectDesc = collectDesc->NextCollection;
      if (collectDesc->PreparsedData)
      {
         ExFreePool (collectDesc->PreparsedData);
      }
      ExFreePool (collectDesc);
      collectDesc = nextCollectDesc;
   }

   if (DeviceDesc->ReportIDs)
   {
      ExFreePool (DeviceDesc->ReportIDs);
   }
   return status;
}

#define MORE_DATA(_pos_, _len_) \
      if (!((_pos_) < (_len_))) \
      { \
        DeviceDesc->Dbg.BreakOffset = descIndex; \
        DeviceDesc->Dbg.ErrorCode = HIDP_GETCOLDESC_BUFFER; \
        return STATUS_BUFFER_TOO_SMALL; \
      }

NTSTATUS
HidP_AllocateCollections (
   IN  PHIDP_REPORT_DESCRIPTOR      RepDesc,
   IN  ULONG                        RepDescLen,
   IN  POOL_TYPE                    PoolType,
   OUT PHIDP_COLLECTION_DESC_LIST * ColsRet,
   OUT PULONG                       NumCols,
   OUT PHIDP_GETCOLDESC_DBG         Dbg,
   OUT PHIDP_DEVICE_DESC            DeviceDesc)
/*++
Routine Description:
   Allocate a link list of Collection descriptors for use by the preparser.
   Each collection descriptor represents a top level app collection found
   in the given report descriptor, and contains enough memory (scratch space)
   into which to write the preparsed data.
   Return a linked list of such collections.

   In each collection also allocate enough space for the preparsed data, based
   on the number of channels required.

   Also allocate memory for the three report ID structures.

Parameters:
   Rep      The given raw report descriptor.
   RepLen   Length of this said descriptor.
   ColsRet  The head of the list of collection descriptors.
   NumCols  Then number of collection descriptors in said list.
--*/
{
   PHIDP_COLLECTION_DESC_LIST preCol    = 0;
   PHIDP_COLLECTION_DESC_LIST curCol    = 0;
   PHIDP_PREPARSED_DATA       preparsed = 0;

   HIDP_ITEM    item;
   ULONG        descIndex       = 0;
   LONG         colDepth        = 0; // nested collections
   SHORT        usageDepth      = 0; // How many usages for each main item

   USHORT       inputChannels   = 0;
   USHORT       outputChannels  = 0;
   USHORT       featureChannels = 0;
   USHORT       length;
   USHORT       numLinkCollections = 0;
   // Link Collections within a top level collection.
   UCHAR        tmpBitField     = 0;

   BOOLEAN      newReportID = FALSE;
   UCHAR        numReports = 0;
   BOOLEAN      defaultReportIDUsed = FALSE;
   BOOLEAN      noDefaultReportIDAllowed = FALSE;
   //
   // numReports indicates the number of HIDP_REPORT_IDS structures needed
   // to describe this device.  If the device has only one top level collection
   // then the report descriptor need not contain a report id declaration, and
   // the given device will not prepend a report ID to the input report packets.
   // newReportID indicates the parser has found no report id declaration thus
   // far in the report descriptor.
   //
   // newReportID is set to TRUE with each entrance of a top level collection,
   // this allocation routine sets this to FALSE when it see a report ID
   // declaration.
   //
   // We start newReportID as FALSE so that we can test for TRUE on entering
   // a top level collection.  If, for some reason, we enter an additional top
   // level collection and newReportID is still set to TRUE then we have a
   // violation of the HID spec.  `No report may span a top level collection.'
   //
   // Also a report ID of zero is not allowed.  If there is no declaration
   // of a report id then (1) all channels will have there report id field set
   // to zero (aka none) (2) only one top level collection may be encountered.
   // We track this with the defaultReportIDUsed noDefaultReportIDAllowed
   // locals.
   //

   *NumCols = 0;
   // currentTopCollection = 1;
   //
   // each collection returned from the preparser has a unique collection number
   // associated with it.  The preparser only concerns itself with top-level
   // collections.  This number DOES NOT in any way correspond with the
   // accessor functions, used by the client, described in hidpi.h.  The client
   // receives only one collection at a time, and within each top level
   // collection there are subcollections (link collections) which are
   // given another set of numberings.
   // We track the current collection number by the number of collections,
   // argument passed in by the caller.
   //


   while (descIndex < RepDescLen)
   {
      item = *(RepDesc + descIndex++);
      switch (item)
      {
      case HIDP_MAIN_COLLECTION:
         MORE_DATA (descIndex, RepDescLen);
         item = *(RepDesc + descIndex++);
         if (1 == ++colDepth)
         {  // We will regard any top level collection as an application
            // collection.
            // We will regard second level collections as a linked collection
            // (or sub collection defined by the HIDP_PRIVATE_LINK_COLLECTION_NODE)
            //

            inputChannels = outputChannels = featureChannels = 0;
            numLinkCollections = 1;
            // Link collection zero is understood to be the top level
            // collection so we need to start out with at least one node
            // allocated.

            if (0 == usageDepth) {
                HidP_KdPrint (2, ("No usage for top level collection: %d!\n",
                               *NumCols));
                Dbg->BreakOffset = descIndex;
                Dbg->ErrorCode = HIDP_GETCOLDESC_TOP_COLLECTION_USAGE;
                Dbg->Args[0] = *NumCols;
                return STATUS_COULD_NOT_INTERPRET;
            } else if (1 < usageDepth) {
                HidP_KdPrint (2, ("Multiple usages for top level collection: %d\n",
                               *NumCols));
                Dbg->BreakOffset = descIndex;
                Dbg->ErrorCode = HIDP_GETCOLDESC_TOP_COLLECTION_USAGE;
                Dbg->Args[0] = *NumCols;
                return STATUS_COULD_NOT_INTERPRET;
            }

            if (newReportID) {
               // This is not the first top collection since this variable is
               // initialized to false.
               // Seeing this set means we have parsed an entire top level
               // collection without seing a report id.  This is bad.
               // A device with more than one top level colletion must have
               // more than one report.  And the last top level collection
               // declared no such report.
               HidP_KdPrint (2, ("No report ID for collection: %d\n", *NumCols));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_NO_REPORT_ID;
               Dbg->Args[0] = *NumCols;
               return STATUS_COULD_NOT_INTERPRET;

            } else if (defaultReportIDUsed) {
               // This is not the first top collection since this variable is
               // initialized to FALSE;
               // So if ever we see this as true we are starting a new top
               // level collection which means there must be report ID from the
               // device and therefore there cannot exist a single channel
               // that has no declared report ID.
               HidP_KdPrint (2, ("Default report ID used inappropriately\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
               Dbg->Args[0] = *NumCols;
               return STATUS_COULD_NOT_INTERPRET;

            }

            numReports++;
            newReportID = TRUE;

            (*NumCols)++; // One more top level collection found.
            HidP_KdPrint(2, ("'Top Level Collection %d found\n", *NumCols));
            preCol = curCol;
            curCol = (PHIDP_COLLECTION_DESC_LIST)
               ExAllocatePool (PoolType, sizeof (HIDP_COLLECTION_DESC_LIST));
            if (!curCol) {
               HidP_KdPrint(2, ("No Resources to make Top level collection\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_LINK_RESOURCES;
               return STATUS_INSUFFICIENT_RESOURCES;

            }
            RtlZeroMemory (curCol, sizeof (HIDP_COLLECTION_DESC_LIST));

            if (preCol) {
               preCol->NextCollection = curCol;

            } else {
               *ColsRet = curCol;
            }
         } else if (1 < colDepth) {  // a linked collection

            HidP_KdPrint(0, ("'Enter Link Collection\n"));
            if (0 == usageDepth) {
                HidP_KdPrint (1, ("***************************************\n"));
                HidP_KdPrint (1, ("Warning! Link collection without usage \n"));
                HidP_KdPrint (1, ("Pos (%d), depth (%d)\n", descIndex, colDepth));
                HidP_KdPrint (1, ("***************************************\n"));
                usageDepth = 1;
            } else if (1 < usageDepth) {
                HidP_KdPrint (1, ("Link Collection with multiple usage decls\n"));
            }
            numLinkCollections += usageDepth;
         }
         usageDepth = 0;
         break;

      case HIDP_MAIN_ENDCOLLECTION:
         usageDepth = 0;
         if (--colDepth < 0) {
            HidP_KdPrint(2, ("Extra End Collection\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_UNEXP_END_COL;

            return STATUS_COULD_NOT_INTERPRET;
         }
         if (0 < colDepth) {
            HidP_KdPrint(0, ("'Exit Link Collection\n"));
            continue;
         }
         HidP_KdPrint (0, ("'Collection %d exit\n", *NumCols));
         curCol->CollectionNumber = (UCHAR) *NumCols;
         length = sizeof (HIDP_PREPARSED_DATA)
                           + (sizeof (HIDP_CHANNEL_DESC)
                              * (inputChannels
                                 + outputChannels
                                 + featureChannels))
                           + (sizeof (HIDP_PRIVATE_LINK_COLLECTION_NODE))
                              * numLinkCollections;

         curCol->PreparsedDataLength = length;
         curCol->PreparsedData =
               (PHIDP_PREPARSED_DATA) ExAllocatePool (PoolType, length);

         if (!curCol->PreparsedData) {
            HidP_KdPrint(2, ("Could not allocate space for PreparsedData\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_PREPARSE_RESOURCES;
            return STATUS_INSUFFICIENT_RESOURCES;
         }

         RtlZeroMemory (curCol->PreparsedData, curCol->PreparsedDataLength);
         // Set the offsets
         preparsed = curCol->PreparsedData;

         preparsed->Signature1 = HIDP_PREPARSED_DATA_SIGNATURE1;
         preparsed->Signature2 = HIDP_PREPARSED_DATA_SIGNATURE2;
         preparsed->Input.Index = (UCHAR) preparsed->Input.Offset = 0;
         length = preparsed->Input.Size = inputChannels;

         preparsed->Output.Index = preparsed->Output.Offset = (UCHAR) length;
         length += (preparsed->Output.Size = outputChannels);

         preparsed->Feature.Index = preparsed->Feature.Offset = (UCHAR) length;
         length += (preparsed->Feature.Size = featureChannels);

         preparsed->LinkCollectionArrayOffset =
                  length * sizeof (HIDP_CHANNEL_DESC);
         preparsed->LinkCollectionArrayLength = numLinkCollections;

         break;

      case HIDP_LOCAL_USAGE_4:
      case HIDP_LOCAL_USAGE_MIN_4:
         descIndex += 2;

      case HIDP_LOCAL_USAGE_2:
      case HIDP_LOCAL_USAGE_MIN_2:
         descIndex++;

      case HIDP_LOCAL_USAGE_1:
      case HIDP_LOCAL_USAGE_MIN_1:
         MORE_DATA (descIndex++, RepDescLen);
         usageDepth++;
         break;

      case HIDP_LOCAL_DELIMITER:
          if (1 != (item = *(RepDesc + descIndex))) {
              HidP_KdPrint (2, ("Delimiter not start %x\n", item));
              Dbg->BreakOffset = descIndex;
              Dbg->ErrorCode = HIDP_GETCOLDESC_MISMATCH_OC_DELIMITER;
              Dbg->Args[0] = item;
              return STATUS_COULD_NOT_INTERPRET;
          }

          MORE_DATA (descIndex++, RepDescLen);
          while (TRUE) {
              if (descIndex >= RepDescLen) {
                  HidP_KdPrint (2, ("End delimiter NOT found!\n"));
                  Dbg->BreakOffset = descIndex;
                  Dbg->ErrorCode = HIDP_GETCOLDESC_NO_CLOSE_DELIMITER;
                  return STATUS_COULD_NOT_INTERPRET;
              }
              item = *(RepDesc + descIndex++);

              if (HIDP_LOCAL_DELIMITER == item) {
                  if (0 != (item = *(RepDesc + descIndex))) {
                      HidP_KdPrint (2, ("Delimiter not stop %x\n", item));
                      Dbg->BreakOffset = descIndex;
                      Dbg->ErrorCode = HIDP_GETCOLDESC_MISMATCH_OC_DELIMITER;
                      Dbg->Args[0] = item;
                      return STATUS_COULD_NOT_INTERPRET;
                  }
                  MORE_DATA (descIndex++, RepDescLen);
                  break;
              }

              switch (item) {
//
// TODO: kenray
//
// Usage Min / Max not yet supported within delimiter.
//
//            case HIDP_LOCAL_USAGE_MAX_4:
//               descIndex += 2;
//            case HIDP_LOCAL_USAGE_MAX_2:
//               descIndex++;
//            case HIDP_LOCAL_USAGE_MAX_1:
//               descIndex++;
//               break;

              case HIDP_LOCAL_USAGE_4:
//            case HIDP_LOCAL_USAGE_MIN_4:
                  descIndex += 2;
              case HIDP_LOCAL_USAGE_2:
//            case HIDP_LOCAL_USAGE_MIN_2:
                  descIndex++;
              case HIDP_LOCAL_USAGE_1:
//            case HIDP_LOCAL_USAGE_MIN_1:
                  MORE_DATA (descIndex++, RepDescLen);
                  usageDepth++;
                  break;

              default:
                HidP_KdPrint (2, ("Invalid token found within delimiter!\n"));
                HidP_KdPrint (2, ("Only Usages are allowed within a delimiter\n"));
//               HidP_KdPrint (("IE: Only Usage, UsageMin, UsageMax tokens\n"));
                HidP_KdPrint (2, ("IE: Only Usage token allowes (no min or max)\n"));
                Dbg->BreakOffset = descIndex;
                Dbg->ErrorCode = HIDP_GETCOLDESC_NOT_VALID_DELIMITER;
                Dbg->Args[0] = item;
                return STATUS_COULD_NOT_INTERPRET;
              }
          }
          break;

      case HIDP_MAIN_INPUT_2:
         MORE_DATA (descIndex + 1, RepDescLen);
         tmpBitField = *(RepDesc + descIndex++);
         descIndex++;
         goto HIDP_ALLOC_MAIN_INPUT;

      case HIDP_MAIN_INPUT_1:
         MORE_DATA (descIndex, RepDescLen);
         tmpBitField = *(RepDesc + descIndex++);

HIDP_ALLOC_MAIN_INPUT:
         if (0 == usageDepth) {
             if (HIDP_ISCONST(tmpBitField)) {
                 break;
             }
             HidP_KdPrint (2, ("Non constant main item found without usage decl\n"));
             Dbg->BreakOffset = descIndex;
             Dbg->ErrorCode = HIDP_GETCOLDESC_MAIN_ITEM_NO_USAGE;
             return STATUS_COULD_NOT_INTERPRET;
         }

         inputChannels += (usageDepth ? usageDepth : 1);
         if (newReportID) {
            if (noDefaultReportIDAllowed) {
               // A report ID declaration was found somewhere earlier in this
               // report descriptor.  This means that ALL main items must
               // have a declared report ID.
               HidP_KdPrint (2, ("Default report ID used inappropriately\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
               Dbg->Args[0] = *NumCols;
               return STATUS_COULD_NOT_INTERPRET;
            }
            defaultReportIDUsed = TRUE;
         }
         if (0 == colDepth) {
            HidP_KdPrint (2, ("Main item found not in top level collection\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_INVALID_MAIN_ITEM;
            return STATUS_COULD_NOT_INTERPRET;
         }
         usageDepth = 0;
         break;

      case HIDP_MAIN_OUTPUT_2:
         MORE_DATA (descIndex + 1, RepDescLen);
         tmpBitField = *(RepDesc + descIndex++);
         descIndex++;
         goto HIDP_ALLOC_MAIN_OUTPUT;

      case HIDP_MAIN_OUTPUT_1:
         MORE_DATA (descIndex, RepDescLen);
         tmpBitField = *(RepDesc + descIndex++);

HIDP_ALLOC_MAIN_OUTPUT:
         if (0 == usageDepth) {
             if (HIDP_ISCONST(tmpBitField)) {
                 break;
             }
             HidP_KdPrint (2, ("Non constant main item found without usage decl\n"));
             Dbg->BreakOffset = descIndex;
             Dbg->ErrorCode = HIDP_GETCOLDESC_MAIN_ITEM_NO_USAGE;
             return STATUS_COULD_NOT_INTERPRET;
         }

         outputChannels += (usageDepth ? usageDepth : 1);
         if (newReportID) {
            if (noDefaultReportIDAllowed) {
               // A report ID declaration was found somewhere earlier in this
               // report descriptor.  This means that ALL main items must
               // have a declared report ID.
               HidP_KdPrint (2, ("Default report ID used inappropriately\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
               Dbg->Args[0] = *NumCols;
               return STATUS_COULD_NOT_INTERPRET;
            }
            defaultReportIDUsed = TRUE;
         }
         if (0 == colDepth) {
            HidP_KdPrint (2, ("Main item found not in top level collection\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_INVALID_MAIN_ITEM;
            return STATUS_COULD_NOT_INTERPRET;
         }
         usageDepth = 0;
         break;

      case HIDP_MAIN_FEATURE_2:
         MORE_DATA (descIndex + 1, RepDescLen);
         tmpBitField = *(RepDesc + descIndex++);
         descIndex++;
         goto HIDP_ALLOC_MAIN_FEATURE;

      case HIDP_MAIN_FEATURE_1:
         MORE_DATA (descIndex, RepDescLen);
         tmpBitField = *(RepDesc + descIndex++);

HIDP_ALLOC_MAIN_FEATURE:
         if (0 == usageDepth) {
             if (HIDP_ISCONST(tmpBitField)) {
                 break;
             }
             HidP_KdPrint (2, ("Non constant main item found without usage decl\n"));
             Dbg->BreakOffset = descIndex;
             Dbg->ErrorCode = HIDP_GETCOLDESC_MAIN_ITEM_NO_USAGE;
             return STATUS_COULD_NOT_INTERPRET;
         }

         featureChannels += (usageDepth ? usageDepth : 1);
         if (newReportID) {
            if (noDefaultReportIDAllowed) {
               // A report ID declaration was found somewhere earlier in this
               // report descriptor.  This means that ALL main items must
               // have a declared report ID.
               HidP_KdPrint (2, ("Default report ID used inappropriately\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
               Dbg->Args[0] = *NumCols;
               return STATUS_COULD_NOT_INTERPRET;
            }
            defaultReportIDUsed = TRUE;
         }
         if (0 == colDepth) {
            HidP_KdPrint (2, ("Main item found not in top level collection\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_INVALID_MAIN_ITEM;
            return STATUS_COULD_NOT_INTERPRET;
         }
         usageDepth = 0;
         break;

      case HIDP_GLOBAL_REPORT_ID:
         MORE_DATA (descIndex, RepDescLen);
         item = *(RepDesc + descIndex++);

         if (0 < colDepth) {
            ASSERT (curCol);
         } else {
            HidP_KdPrint(2, ("Report ID outside of Top level collection\n"));
            HidP_KdPrint(2, ("Reports cannot span more than one top level \n"));
            HidP_KdPrint(2, ("Report ID found: %d", (ULONG) item));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_REPORT_ID;
            Dbg->Args[0] = item;
            return STATUS_COULD_NOT_INTERPRET;
         }

         if (newReportID) {
            newReportID = FALSE;
         } else {
            numReports++;
         }

         noDefaultReportIDAllowed = TRUE;
         if (defaultReportIDUsed) {
            // A report ID declaration was found somewhere earlier in this
            // report descriptor.  This means that ALL main items must
            // have a declared report ID.
            HidP_KdPrint (2, ("Default report ID used inappropriately\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
            Dbg->Args[0] = *NumCols;
            return STATUS_COULD_NOT_INTERPRET;
         }
         break;

      case HIDP_ITEM_LONG:
         HidP_KdPrint (2, ("Long Items not supported %x\n", item));
         Dbg->BreakOffset = descIndex;
         Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
         Dbg->Args[0] = item;
         return STATUS_COULD_NOT_INTERPRET;

      default:
         // Bump past the data bytes in the descriptor.
         length = (item & HIDP_ITEM_LENGTH_DATA);
         length = (3 == length) ? 4 : length;
         if (!((descIndex + length) <= RepDescLen)) {
            // OK the lower 2 bits in the item represent the length of the
            // data if this is 3 then there are 4 data bytes following this
            // item.  DescPos already points to the next data item.
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_ONE_BYTE;
            return STATUS_BUFFER_TOO_SMALL;
         }
         descIndex += length;
         break;
      }
   }

   //
   // According to the HID spec no report id may span a top level collection.
   // which means that each collection must have at least one report, and there
   // should be at least as many report IDs as collections.  Unless there is
   // only one report (therefore only one collection).  In this case no report
   // ID will be sent from the device.  But in this case we return saying there
   // was indeed one report anyway.  The ReportID decsriptor was of length one.
   // Therefore numReports must always be greater than or equal to the number
   // of collections.
   //
   // For output and feature reports, report ids are sent as an extra argument
   // so they will always be present even if they are zero.  (Zero means that
   // the device did not list a report ID in the descriptor.)
   //
   // However with input packets the report ID is part of the packet itself:
   // the first byte.  UNLESS there is only one report, and then it is not
   // present.
   //
   // __For input packets___
   // the device can have a report ID even if it has only one
   // report.  This is odd, as it wastes a byte, but then again who knows the
   // mind of an IHV.  For this reason, hidparse must check to see if the
   // reportID  list is of length one and the report id itself (in the one and
   // only one space) is zero in order to determine if the device sends no
   // reports ids.
   // If it is zero (the device is not allowed to send report ids of zero)
   // than that report id was simulated meaning the number of bytes in the
   // packet from the device is one less than the number of byte given to the
   // user.
   // If is is non-zero, then the number of bytes from the device is the same
   // as the number of bytes given to the user.
   //

   if (numReports < *NumCols) {
      HidP_KdPrint (2, ("Report IDS cannot span collections.\n"));
      HidP_KdPrint (2, ("This means that you must have at least one report ID\n"));
      HidP_KdPrint (2, ("For each TOP level collection, unless you have only\n"));
      HidP_KdPrint (2, ("report.\n"));
      Dbg->BreakOffset = descIndex;
      Dbg->ErrorCode = HIDP_GETCOLDESC_NO_REPORT_ID;
      return STATUS_COULD_NOT_INTERPRET;
   }

   if (0 < colDepth) {
      HidP_KdPrint(2, ("End Collection not found\n"));
      Dbg->BreakOffset = descIndex;
      Dbg->ErrorCode = HIDP_GETCOLDESC_UNEXP_END_COL;
      return STATUS_COULD_NOT_INTERPRET;
   }

   //
   // Now that we have seen the entire structure, allocate the structure for
   // holding the report id switch table.
   //

   if (0 == numReports) {
      HidP_KdPrint (2, ("No top level collections were found! \n"));
      Dbg->BreakOffset = descIndex;
      Dbg->ErrorCode = HIDP_GETCOLDESC_NO_DATA;
      return STATUS_NO_DATA_DETECTED;
   }

   DeviceDesc->ReportIDsLength = numReports;
   DeviceDesc->ReportIDs = (PHIDP_REPORT_IDS)
      ExAllocatePool (PoolType, numReports * sizeof (HIDP_REPORT_IDS));

   if (!DeviceDesc->ReportIDs) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory (DeviceDesc->ReportIDs, numReports * sizeof (HIDP_REPORT_IDS));

   return STATUS_SUCCESS;
}


PHIDP_PARSE_LOCAL_RANGE_LIST
HidP_FreeUsageList (
   PHIDP_PARSE_LOCAL_RANGE_LIST  Usage
   )
/*++
RoutineDescription:
   clear off all the usages in the linked list
   But do not free the first element in the list.
--*/
{
   PHIDP_PARSE_LOCAL_RANGE_LIST curUsage;
   while (Usage->Next) {
       curUsage = Usage;
       Usage = curUsage->Next;
       ExFreePool (curUsage);
   }
   RtlZeroMemory (Usage, sizeof (HIDP_PARSE_LOCAL_RANGE_LIST));
   return Usage;
}

PHIDP_PARSE_LOCAL_RANGE_LIST
HidP_PushUsageList (
   PHIDP_PARSE_LOCAL_RANGE_LIST  Usage,
   POOL_TYPE                     PoolType,
   BOOLEAN                       WithinDelimiter
   )
/*++
RoutineDescription:
   allocate another Usage node and add it to the top O the list.
--*/
{
   PHIDP_PARSE_LOCAL_RANGE_LIST newUsage;

   newUsage = (PHIDP_PARSE_LOCAL_RANGE_LIST)
            ExAllocatePool (PoolType, sizeof (HIDP_PARSE_LOCAL_RANGE_LIST));
   if (newUsage) {
       RtlZeroMemory (newUsage, sizeof (HIDP_PARSE_LOCAL_RANGE_LIST));
       newUsage->Next = Usage;
       if (!WithinDelimiter) {
           newUsage->Depth = Usage->Depth
                           + (Usage->Range ? (Usage->Max - Usage->Min + 1) : 1);
       } else {
           newUsage->Depth = Usage->Depth;
           //
           // Note ranges are not allowed in delimiters therefore we know
           // that all entries in the delimiter are equal and are length 1
           //
       }
   } else {
       HidP_FreeUsageList (Usage);
   }
   return newUsage;
}

PHIDP_PARSE_LOCAL_RANGE_LIST
HidP_PopUsageList (
   PHIDP_PARSE_LOCAL_RANGE_LIST  Usage
   )
{
    PHIDP_PARSE_LOCAL_RANGE_LIST  newUsage;

    if (Usage->Next) {
        newUsage = Usage->Next;
        ExFreePool (Usage);
    } else {
        newUsage = Usage;
#if DBG
        RtlFillMemory (newUsage, sizeof (HIDP_PARSE_LOCAL_RANGE_LIST), 0xDB);
        newUsage->Depth = 0;
#endif
    }
    return newUsage;
}


#define ONE_BYTE_DATA(_data_, _pos_, _dbg_)    \
         if (!((_pos_) < RepDescLen)) { \
               status = STATUS_BUFFER_TOO_SMALL; \
               KdPrint(("More Data Expected\n")); \
               _dbg_->ErrorCode = HIDP_GETCOLDESC_ONE_BYTE; \
               _dbg_->BreakOffset = descIndex; \
               goto HIDP_PARSE_REJECT; \
            } \
         (_data_) = *(RepDesc + (_pos_)++);

#define TWO_BYTE_DATA(_data_, _pos_, _dbg_)      \
         if (!((_pos_) + 1 < RepDescLen)) { \
               status = STATUS_BUFFER_TOO_SMALL; \
               KdPrint(("More Data Expected\n")); \
               _dbg_->ErrorCode = HIDP_GETCOLDESC_TWO_BYTE; \
               _dbg_->BreakOffset = descIndex; \
               goto HIDP_PARSE_REJECT; \
            } \
         (_data_) = *(RepDesc + (_pos_)++);        \
         (_data_) |= *(RepDesc + (_pos_)++) << 8;


#define FOUR_BYTE_DATA(_data_, _pos_, _dbg_)     \
         if (!((_pos_) + 3 < RepDescLen)) { \
               status = STATUS_BUFFER_TOO_SMALL; \
               KdPrint(("More Data Expected\n")); \
               _dbg_->ErrorCode = HIDP_GETCOLDESC_FOUR_BYTE; \
               _dbg_->BreakOffset = descIndex; \
               goto HIDP_PARSE_REJECT; \
            } \
         (_data_) = *(RepDesc + (_pos_)++);        \
         (_data_) |= *(RepDesc + (_pos_)++) << 8;  \
         (_data_) |= *(RepDesc + (_pos_)++) << 16; \
         (_data_) |= *(RepDesc + (_pos_)++) << 24;

#define BIT_EXTEND_1(_data_) \
         (_data_) = ((_data_) & 0xFF) \
                  | (((_data_) & 0x80) ? 0xFFFFFF00 : 0)

#define BIT_EXTEND_2(_data_) \
         (_data_) = ((_data_) & 0xFFFF) \
                  | (((_data_) & 0x8000) ? 0xFFFF0000 : 0)


NTSTATUS
HidP_ParseCollections (
   IN     PHIDP_REPORT_DESCRIPTOR      RepDesc,
   IN     ULONG                        RepDescLen,
   IN     POOL_TYPE                    PoolType,
   IN OUT PHIDP_COLLECTION_DESC_LIST   Cols,
   IN     ULONG                        NumCols,
   OUT    PHIDP_GETCOLDESC_DBG         Dbg,
   IN OUT PHIDP_DEVICE_DESC            DeviceDesc)
/*++
Routine Description:
   Given a nice linked list of collection descriptors parse into those
   descriptors the information descerned from the Raw Report Descriptor.
   Each given CollectionDescriptor already has the proper amount of memory
   in the PreparsedData field.

Parameters:
   Rep      The given raw report descriptor.
   RepLen   Length of this said descriptor.
   ColsRet  The head of the list of collection descriptors.
   NumCols  Then number of collection descriptors in said list.
--*/
{
   HIDP_PREPARSED_DATA           safeData;
   HIDP_PARSE_GLOBAL_PUSH        firstPush  = {0,0,0,0,0,0,0,0,0,0,0};
   HIDP_PARSE_LOCAL_RANGE_LIST   firstUsage = {0,0,0,0,0};
   HIDP_PARSE_LOCAL_RANGE        designator = {0,0,0,0};
   HIDP_PARSE_LOCAL_RANGE        string     = {0,0,0,0};
   HIDP_PARSE_LOCAL_RANGE        zeroLocal  = {0,0,0,0};

   PHIDP_COLLECTION_DESC_LIST    appCol        = 0;
   PHIDP_PREPARSED_DATA          preparsed     = &safeData;
   PHIDP_PARSE_GLOBAL_PUSH       push          = &firstPush;
   PHIDP_PARSE_GLOBAL_PUSH       tmpPush       = 0;
   PHIDP_PARSE_LOCAL_RANGE_LIST  usage         = &firstUsage;
   PHIDP_PARSE_LOCAL_RANGE_LIST  tmpUsage      = 0;
   PHIDP_CHANNEL_DESC            channel       = 0;
   PHIDP_PRIVATE_LINK_COLLECTION_NODE    linkNodeArray = 0;
   PHIDP_PRIVATE_LINK_COLLECTION_NODE    parentLCNode  = 0;
   PHIDP_PRIVATE_LINK_COLLECTION_NODE    currentLCNode = 0;
   struct _HIDP_UNKNOWN_TOKEN *  unknownToken;
   USHORT                        linkNodeIndex = 0;

   ULONG        descIndex    = 0;
   ULONG        colDepth     = 0;
   NTSTATUS     status       = STATUS_SUCCESS;
   USHORT       bitPos;
   HIDP_ITEM    item;
   USHORT       tmpBitField      = 0;
   USHORT       tmpCount         = 0;
   USHORT       i;
   PUSHORT      channelIndex     = 0;

   PHIDP_REPORT_IDS              currentReportIDs = DeviceDesc->ReportIDs;
   PHIDP_REPORT_IDS              tmpReportIDs;
   BOOLEAN                       isFirstReportID = TRUE;
   BOOLEAN                       withinDelimiter = FALSE;
   BOOLEAN                       firstUsageWithinDelimiter = TRUE;
   BOOLEAN                       isAlias = FALSE;
   UCHAR                         collectionType;
   UCHAR                         tmpID;

   UNREFERENCED_PARAMETER (NumCols);

   while (descIndex < RepDescLen)
   {
      item = *(RepDesc + descIndex++);
      switch (item)
      {
      case HIDP_MAIN_COLLECTION:
         ONE_BYTE_DATA (collectionType, descIndex, Dbg);
         if (1 == ++colDepth)
         {
            //
            // We will regard any top level collection as an application
            // collection as approved by the HID committee
            //
            // we will regard second level collections as a link collection.
            //

            if (appCol)
            {
               appCol = appCol->NextCollection;
            } else
            {
               appCol = Cols;
            }
            ASSERT (appCol);

            HidP_KdPrint(0, ("'Parse Collection %d \n", appCol->CollectionNumber));

            preparsed = appCol->PreparsedData;
            ASSERT (preparsed);

            //
            // Set up the report IDs for this collection
            // There is one report ID array for all top level collections
            //
            push->ReportIDs = currentReportIDs;
            isFirstReportID = TRUE;
            // Make room for the Report ID as the first byte.
            currentReportIDs->InputLength = 8;
            currentReportIDs->OutputLength = 8;
            currentReportIDs->FeatureLength = 8;
            currentReportIDs->ReportID = 0;
            currentReportIDs->CollectionNumber = appCol->CollectionNumber;
            currentReportIDs++;

            preparsed->UsagePage = appCol->UsagePage = usage->UsagePage ?
                                                       usage->UsagePage :
                                                       push->UsagePage;
            if (usage->Range){
               preparsed->Usage = appCol->Usage = usage->Min;
            } else {
               preparsed->Usage = appCol->Usage = usage->Value;
            }
            designator = string = zeroLocal;
            usage = HidP_FreeUsageList (usage);
            if (0 == appCol->Usage) {
                //
                // Explicitly check for Usage ID (0) which is reserved
                //
                HidP_KdPrint(2, ("Top Level Collection %x defined with Report ID 0! (UP: %x)\n",
                                 appCol->CollectionNumber,
                                 appCol->UsagePage));
#if 0
                Dbg->BreakOffset = descIndex;
                Dbg->ErrorCode = HIDP_GETCOLDESC_TOP_COLLECTION_USAGE;
                Dbg->Args[0] = appCol->CollectionNumber;
                status = STATUS_COULD_NOT_INTERPRET;
                goto HIDP_PARSE_REJECT;
#endif
            }

            //
            // Initialize the Link node array for this top level collection.
            // There is a link node array for each top level collection
            //
            linkNodeArray = (PHIDP_PRIVATE_LINK_COLLECTION_NODE)
                            (preparsed->RawBytes +
                             preparsed->LinkCollectionArrayOffset);

            ASSERT (0 < preparsed->LinkCollectionArrayLength);
            parentLCNode   = &(linkNodeArray[0]);
            currentLCNode  = &(linkNodeArray[0]);
            linkNodeIndex = 0;

            parentLCNode->LinkUsagePage = appCol->UsagePage;
            parentLCNode->LinkUsage = appCol->Usage;
            parentLCNode->Parent = 0;
            parentLCNode->NumberOfChildren = 0;
            parentLCNode->NextSibling = 0;
            parentLCNode->FirstChild = 0;
            parentLCNode->CollectionType = collectionType;

         } else if (1 < colDepth)
         {
            linkNodeIndex++;
            parentLCNode = currentLCNode;
            ASSERT (linkNodeIndex < preparsed->LinkCollectionArrayLength);
            currentLCNode = &linkNodeArray[linkNodeIndex];

            //
            // Pop of the usage stack all the usages which are aliases, and
            // create a link collection node for each one.
            // Each allias link collection node has the IsAlias bit set.
            // The last one does not have the bit set, and becomes the
            // collection number for all controls list within this aliased
            // link collection.
            //
            //

            while (TRUE) {
                currentLCNode->LinkUsagePage = usage->UsagePage ?
                                               usage->UsagePage :
                                               push->UsagePage;
                currentLCNode->LinkUsage = usage->Range ?
                                           usage->Min :
                                           usage->Value;
                currentLCNode->Parent = (USHORT)(parentLCNode - linkNodeArray);
                ASSERT (currentLCNode->Parent < preparsed->LinkCollectionArrayLength);
                currentLCNode->NumberOfChildren = 0;
                currentLCNode->FirstChild = 0;
                currentLCNode->NextSibling = parentLCNode->FirstChild;
                parentLCNode->FirstChild = linkNodeIndex;
                parentLCNode->NumberOfChildren++;
                currentLCNode->CollectionType = collectionType;

                if (usage->IsAlias) {
                    currentLCNode->IsAlias = TRUE;
                    linkNodeIndex++;
                    ASSERT (linkNodeIndex < preparsed->LinkCollectionArrayLength);
                    currentLCNode = &linkNodeArray[linkNodeIndex];
                } else {
                    break;
                }
            }
            designator = string = zeroLocal;
            usage = HidP_FreeUsageList (usage);
         }
         break;

      case HIDP_MAIN_ENDCOLLECTION:
         if (0 == colDepth--) {
             status = STATUS_COULD_NOT_INTERPRET;
             goto HIDP_PARSE_REJECT;

         } else if (0 < colDepth) {
            ASSERT ((parentLCNode - linkNodeArray) == currentLCNode->Parent);
            currentLCNode = parentLCNode;
            ASSERT (currentLCNode->Parent < preparsed->LinkCollectionArrayLength);
            parentLCNode = &linkNodeArray[currentLCNode->Parent];
            break;
         }

         HidP_KdPrint(0, ("'X Parse Collection %d \n", appCol->CollectionNumber));


         //
         // Walk the report IDs for this collection
         //
         for (tmpReportIDs = currentReportIDs - 1;
              tmpReportIDs != DeviceDesc->ReportIDs - 1;
              tmpReportIDs--)
         {
            if (tmpReportIDs->CollectionNumber != appCol->CollectionNumber)
            {
               continue;
            }
            if ((0 != (tmpReportIDs->InputLength & 7)) ||
                (0 != (tmpReportIDs->OutputLength & 7)) ||
                (0 != (tmpReportIDs->FeatureLength & 7)))
            {
               HidP_KdPrint(2, ("Col %x Report %x NOT byte alligned!! %x %x %x\n",
                             appCol->CollectionNumber,
                             tmpReportIDs->ReportID,
                             tmpReportIDs->InputLength,
                             tmpReportIDs->OutputLength,
                             tmpReportIDs->FeatureLength));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_BYTE_ALLIGN;
               Dbg->Args[0] = appCol->CollectionNumber,
               Dbg->Args[1] = tmpReportIDs->ReportID,
               Dbg->Args[2] = tmpReportIDs->InputLength;
               Dbg->Args[3] = tmpReportIDs->OutputLength;
               Dbg->Args[4] = tmpReportIDs->FeatureLength;
               status = STATUS_COULD_NOT_INTERPRET;
               goto HIDP_PARSE_REJECT;
            }

            preparsed->Input.ByteLen = MAX (preparsed->Input.ByteLen,
                                            tmpReportIDs->InputLength >> 3);
            preparsed->Output.ByteLen = MAX (preparsed->Output.ByteLen,
                                             tmpReportIDs->OutputLength >> 3);
            preparsed->Feature.ByteLen = MAX (preparsed->Feature.ByteLen,
                                              tmpReportIDs->FeatureLength >> 3);

            //
            // We are now done with this report so convert the length to
            // bytes instead of bits, and remove the report id, if the
            // device will not send one.
            //

            if (0 == tmpReportIDs->ReportID)
            {
               // The report ID was never set; therefore, for input the device
               // will not send a report id.
               tmpReportIDs->InputLength = (tmpReportIDs->InputLength >> 3) - 1;
               tmpReportIDs->OutputLength = (tmpReportIDs->OutputLength >> 3) -1;
               tmpReportIDs->FeatureLength = (tmpReportIDs->FeatureLength >> 3) -1;
            } else
            {
               tmpReportIDs->InputLength = (8 == tmpReportIDs->InputLength)
                                         ? 0
                                         : tmpReportIDs->InputLength >> 3;
               tmpReportIDs->OutputLength = (8 == tmpReportIDs->OutputLength)
                                          ? 0
                                          : tmpReportIDs->OutputLength >> 3;
               tmpReportIDs->FeatureLength = (8 == tmpReportIDs->FeatureLength)
                                           ? 0
                                           : tmpReportIDs->FeatureLength >> 3;
            }
         }

         //
         // This field is adjusted and always accounts for a space for the
         // included report ID, even if the device itslef has only one report
         // and therefore sends no report ids.  (The input report is one byte
         // smaller.)
         //
         // BUT if the length is one, then only the report ID exists.
         // This means that the device has no data to send for that field.
         // Therefore return zero.
         //
         // Remember that the BitLen fields were spiked earlier with values
         // of 8 (one byte).
         //
         // appCol->XXXLength is the length expected from/by the client
         // currentReportID->XxLength == the length expected from/by the device
         //
         if (1 == (appCol->InputLength = preparsed->Input.ByteLen))
         {
            appCol->InputLength = preparsed->Input.ByteLen = 0;
         }
         if (1 == (appCol->OutputLength = preparsed->Output.ByteLen))
         {
            appCol->OutputLength = preparsed->Output.ByteLen = 0;
         }
         if (1 == (appCol->FeatureLength = preparsed->Feature.ByteLen))
         {
            appCol->FeatureLength = preparsed->Feature.ByteLen = 0;
         }

         break;

      case HIDP_GLOBAL_USAGE_PAGE_1:
         ONE_BYTE_DATA (push->UsagePage, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_USAGE_PAGE_2:
         TWO_BYTE_DATA (push->UsagePage, descIndex, Dbg);
         break;

//
// 16 bits allowed only.
//      case HIDP_GLOBAL_USAGE_PAGE_4:
//         FOUR_BYTE_DATA (push->UsagePage, descIndex, Dbg);
//         break;
//

      case HIDP_GLOBAL_LOG_MIN_1:
         ONE_BYTE_DATA (push->LogicalMin, descIndex, Dbg);
         BIT_EXTEND_1 (push->LogicalMin);
         break;

      case HIDP_GLOBAL_LOG_MIN_2:
         TWO_BYTE_DATA (push->LogicalMin, descIndex, Dbg);
         BIT_EXTEND_2 (push->LogicalMin);
         break;

      case HIDP_GLOBAL_LOG_MIN_4:
         FOUR_BYTE_DATA (push->LogicalMin, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_LOG_MAX_1:
         ONE_BYTE_DATA (push->LogicalMax, descIndex, Dbg);
         BIT_EXTEND_1 (push->LogicalMax);
         break;

      case HIDP_GLOBAL_LOG_MAX_2:
         TWO_BYTE_DATA (push->LogicalMax, descIndex, Dbg);
         BIT_EXTEND_2 (push->LogicalMax);
         break;

      case HIDP_GLOBAL_LOG_MAX_4:
         FOUR_BYTE_DATA (push->LogicalMax, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_PHY_MIN_1:
         ONE_BYTE_DATA (push->PhysicalMin, descIndex, Dbg);
         BIT_EXTEND_1 (push->PhysicalMin);
         break;

      case HIDP_GLOBAL_PHY_MIN_2:
         TWO_BYTE_DATA (push->PhysicalMin, descIndex, Dbg);
         BIT_EXTEND_2 (push->PhysicalMin);
         break;

      case HIDP_GLOBAL_PHY_MIN_4:
         FOUR_BYTE_DATA (push->PhysicalMin, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_PHY_MAX_1:
         ONE_BYTE_DATA (push->PhysicalMax, descIndex, Dbg);
         BIT_EXTEND_1 (push->PhysicalMax);
         break;

      case HIDP_GLOBAL_PHY_MAX_2:
         TWO_BYTE_DATA (push->PhysicalMax, descIndex, Dbg);
         BIT_EXTEND_2 (push->PhysicalMax);
         break;

      case HIDP_GLOBAL_PHY_MAX_4:
         FOUR_BYTE_DATA (push->PhysicalMax, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_UNIT_EXP_1:
         ONE_BYTE_DATA (push->UnitExp, descIndex, Dbg);
         BIT_EXTEND_1 (push->UnitExp);
         break;

      case HIDP_GLOBAL_UNIT_EXP_2:
         TWO_BYTE_DATA (push->UnitExp, descIndex, Dbg);
         BIT_EXTEND_2 (push->UnitExp);
         break;

      case HIDP_GLOBAL_UNIT_EXP_4:
         FOUR_BYTE_DATA (push->UnitExp, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_UNIT_1:
          ONE_BYTE_DATA (push->Unit, descIndex, Dbg);
          break;

      case HIDP_GLOBAL_UNIT_2:
          TWO_BYTE_DATA (push->Unit, descIndex, Dbg);
          break;

      case HIDP_GLOBAL_UNIT_4:
          FOUR_BYTE_DATA (push->Unit, descIndex, Dbg);
          break;

      case HIDP_GLOBAL_REPORT_SIZE:
         ONE_BYTE_DATA (push->ReportSize, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_REPORT_COUNT_1:
         ONE_BYTE_DATA (push->ReportCount, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_REPORT_COUNT_2:
         TWO_BYTE_DATA (push->ReportCount, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_REPORT_ID:
         //
         // If a device has no report GLOBAL_REPORT_ID token in its descriptor
         // then it will never transmit a report ID in its input reports,
         // and the report ID for each channel will be set to zero.
         //
         // But, if anywhere in the report, a device declares a report ID
         // that device must always transmit a report ID with input reports,
         // AND more importantly that report ID MUST NOT BE ZERO.
         //
         // This means that if we find a report id token, that we can just
         // overwrite the first report ID structure with the given report ID
         // because we know that the first ID structure (initialized to zero
         // and therefore not valid) will not be used for any of the channels.
         //
         ONE_BYTE_DATA (tmpID, descIndex, Dbg);

         //
         // Search to see if this report id has been used before.
         //
         for (tmpReportIDs = DeviceDesc->ReportIDs;
              tmpReportIDs != currentReportIDs;
              tmpReportIDs++) {

            if (tmpReportIDs->ReportID == tmpID) {
               //
               // A duplicate!
               // Make sure that it is for this same collection
               //
               if (tmpReportIDs->CollectionNumber != appCol->CollectionNumber) {
                  HidP_KdPrint(2, ("Reports cannot span more than one top level \n"));
                  HidP_KdPrint(2, ("Report ID %d found in collections [%d %d]",
                                   (ULONG) tmpID,
                                   (ULONG) tmpReportIDs->CollectionNumber,
                                   (ULONG) appCol->CollectionNumber));
                  Dbg->BreakOffset = descIndex;
                  Dbg->ErrorCode = HIDP_GETCOLDESC_REPORT_ID;
                  Dbg->Args[0] = item;
                  status = HIDP_STATUS_INVALID_REPORT_TYPE;
                  goto HIDP_PARSE_REJECT;
               }
               //
               // Use this report ID.
               //
               push->ReportIDs = tmpReportIDs;
               break;
            }
         } // continue looking.

         if (isFirstReportID) {
            isFirstReportID = FALSE;
         } else if (tmpReportIDs == currentReportIDs) {
               //
               // We have not seen this report ID before.
               // make a new container.
               //
               push->ReportIDs = currentReportIDs;
               // Make room for the Report ID as the first byte.
               currentReportIDs->InputLength = 8;
               currentReportIDs->OutputLength = 8;
               currentReportIDs->FeatureLength = 8;
               currentReportIDs->CollectionNumber = appCol->CollectionNumber;
               currentReportIDs++;
         }

         push->ReportIDs->ReportID = tmpID;

         if (0 == push->ReportIDs->ReportID) {
            status = HIDP_STATUS_INVALID_REPORT_TYPE;
            HidP_KdPrint(2, ("Report IDs cannot be zero (0)\n"));
            Dbg->ErrorCode = HIDP_GETCOLDESC_BAD_REPORT_ID;
            Dbg->BreakOffset = descIndex;
            goto HIDP_PARSE_REJECT;
         }
         break;

      case HIDP_GLOBAL_PUSH:
         tmpPush = (PHIDP_PARSE_GLOBAL_PUSH)
                   ExAllocatePool (PoolType, sizeof (HIDP_PARSE_GLOBAL_PUSH));
         if (!tmpPush)
         {
            status = STATUS_INSUFFICIENT_RESOURCES;
            HidP_KdPrint(2, ("No Resources to Push global stack\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_PUSH_RESOURCES;
            goto HIDP_PARSE_REJECT;
         }
         HidP_KdPrint(0, ("Push Global Stack\n"));
         *tmpPush = *push;
         tmpPush->Pop = push;
         push = tmpPush;
         break;

      case HIDP_GLOBAL_POP:
         tmpPush = push->Pop;
         ExFreePool (push);
         push = tmpPush;
         HidP_KdPrint(0, ("Pop Global Stack\n"));

         break;

//
// Local Items
//

      //
      // We already verified that only "approved" tokens will be within
      // the open / close of the following delimiter.  This simplifies
      // our parsing here tremendously.
      //
      case HIDP_LOCAL_DELIMITER:
          ONE_BYTE_DATA (item, descIndex, Dbg);
          if (1 == item) {
              withinDelimiter = TRUE;
              firstUsageWithinDelimiter = TRUE;
          } else if (0 == item) {
              withinDelimiter = FALSE;
          } else {
              TRAP ();
          }
          break;

      case HIDP_LOCAL_USAGE_1:
      case HIDP_LOCAL_USAGE_2:
      case HIDP_LOCAL_USAGE_4:
         if ((&firstUsage == usage) || usage->Value || usage->Max || usage->Min) {
            usage = HidP_PushUsageList (usage, PoolType, withinDelimiter);
            if (!usage) {
               status = STATUS_INSUFFICIENT_RESOURCES;
               HidP_KdPrint(2, ("No Resources to Push Usage stack\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_PUSH_RESOURCES;
               goto HIDP_PARSE_REJECT;
            }
         }
         usage->Range = FALSE;
         if (HIDP_LOCAL_USAGE_1 == item) {
            ONE_BYTE_DATA (usage->Value, descIndex, Dbg);
         } else if (HIDP_LOCAL_USAGE_2 == item) {
            TWO_BYTE_DATA (usage->Value, descIndex, Dbg);
         } else {
            TWO_BYTE_DATA (usage->Value, descIndex, Dbg);
            TWO_BYTE_DATA (usage->UsagePage, descIndex, Dbg);
            // upper 16 bits overwrite the default usage page.
         }

         if (withinDelimiter) {
             usage->IsAlias = !firstUsageWithinDelimiter;
             firstUsageWithinDelimiter = FALSE;
         }
         if (0 == usage->Value) {
             //
             // Test to see if they have used Usage ID (0) which is reserved.
             // But instead of breaking just print an error
             //
             HidP_KdPrint(2, ("Usage ID (0) explicitly usaged!  This usage is reserved.  Offset (%x)\n",
                              descIndex));
         }
         break;

      //
      // NB: before we can add delimiters to usage ranges we must insure
      // that the range is identical for all entries within the delimiter.
      //

      case HIDP_LOCAL_USAGE_MIN_1:
      case HIDP_LOCAL_USAGE_MIN_2:
      case HIDP_LOCAL_USAGE_MIN_4:
         if ((&firstUsage == usage) || (usage->Min) || (usage->Value)) {
            usage = HidP_PushUsageList (usage, PoolType, FALSE);
            if (!usage) {
               status = STATUS_INSUFFICIENT_RESOURCES;
               HidP_KdPrint(2, ("No Resources to Push Usage stack\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_PUSH_RESOURCES;
               goto HIDP_PARSE_REJECT;
            }
         }
         usage->Range = TRUE;
         if (HIDP_LOCAL_USAGE_MIN_1 == item) {
            ONE_BYTE_DATA (usage->Min, descIndex, Dbg);
         } else if (HIDP_LOCAL_USAGE_MIN_2 == item) {
            TWO_BYTE_DATA (usage->Min, descIndex, Dbg);
         } else {
            TWO_BYTE_DATA (usage->Min, descIndex, Dbg);
            TWO_BYTE_DATA (usage->UsagePage, descIndex, Dbg);
            // upper 16 bits overwrite the default usage page.
         }
         break;

      case HIDP_LOCAL_USAGE_MAX_1:
      case HIDP_LOCAL_USAGE_MAX_2:
      case HIDP_LOCAL_USAGE_MAX_4:
         if ((&firstUsage == usage) || (usage->Max) || (usage->Value)) {
            usage = HidP_PushUsageList (usage, PoolType, FALSE);
            if (!usage) {
               status = STATUS_INSUFFICIENT_RESOURCES;
               HidP_KdPrint(2, ("No Resources to Push Usage stack\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_PUSH_RESOURCES;
               goto HIDP_PARSE_REJECT;
            }
         }
         usage->Range = TRUE;
         if (HIDP_LOCAL_USAGE_MAX_1 == item) {
            ONE_BYTE_DATA (usage->Max, descIndex, Dbg);
         } else if (HIDP_LOCAL_USAGE_MAX_2 == item) {
            TWO_BYTE_DATA (usage->Max, descIndex, Dbg);
         } else {
            TWO_BYTE_DATA (usage->Max, descIndex, Dbg);
            TWO_BYTE_DATA (usage->UsagePage, descIndex, Dbg);
            // upper 16 bits overwrite the default usage page.
         }
         break;

      case HIDP_LOCAL_DESIG_INDEX:
         designator.Range = FALSE;
         ONE_BYTE_DATA (designator.Value, descIndex, Dbg);
         break;

      case HIDP_LOCAL_DESIG_MIN:
         designator.Range = TRUE;
         ONE_BYTE_DATA (designator.Min, descIndex, Dbg);
         break;

      case HIDP_LOCAL_DESIG_MAX:
         designator.Range = TRUE;
         ONE_BYTE_DATA (designator.Max, descIndex, Dbg);
         break;

      case HIDP_LOCAL_STRING_INDEX:
         string.Range = FALSE;
         ONE_BYTE_DATA (string.Value, descIndex, Dbg);
         break;

      case HIDP_LOCAL_STRING_MIN:
         string.Range = TRUE;
         ONE_BYTE_DATA (string.Min, descIndex, Dbg);
         break;

      case HIDP_LOCAL_STRING_MAX:
         string.Range = TRUE;
         ONE_BYTE_DATA (string.Max, descIndex, Dbg);
         break;

      case HIDP_MAIN_INPUT_1:
         tmpReportIDs = push->ReportIDs;
         bitPos = tmpReportIDs->InputLength; // The distance into the report
         HidP_KdPrint(0, ("'Main Offset:%x \n", bitPos));
         tmpReportIDs->InputLength += push->ReportSize * push->ReportCount;
         channelIndex = &(preparsed->Input.Index);
         ONE_BYTE_DATA (tmpBitField, descIndex, Dbg);
         goto HIDP_PARSE_MAIN_ITEM;

      case HIDP_MAIN_INPUT_2:
         tmpReportIDs = push->ReportIDs;
         bitPos = tmpReportIDs->InputLength; // The distance into the report
         HidP_KdPrint(0, ("'Main2 offset:%x \n", bitPos));
         tmpReportIDs->InputLength += push->ReportSize * push->ReportCount;
         channelIndex = &(preparsed->Input.Index);
         TWO_BYTE_DATA (tmpBitField, descIndex, Dbg);
         goto HIDP_PARSE_MAIN_ITEM;

      case HIDP_MAIN_OUTPUT_1:
         tmpReportIDs = push->ReportIDs;
         bitPos = tmpReportIDs->OutputLength; // The distance into the report
         HidP_KdPrint(0, ("'Out offset:%x \n", bitPos));
         tmpReportIDs->OutputLength += push->ReportSize * push->ReportCount;
         channelIndex = &(preparsed->Output.Index);
         ONE_BYTE_DATA (tmpBitField, descIndex, Dbg);
         goto HIDP_PARSE_MAIN_ITEM;

      case HIDP_MAIN_OUTPUT_2:
         tmpReportIDs = push->ReportIDs;
         bitPos = tmpReportIDs->OutputLength; // The distance into the report
         HidP_KdPrint(0, ("'Out2 offset:%x \n", bitPos));
         tmpReportIDs->OutputLength += push->ReportSize * push->ReportCount;
         channelIndex = &(preparsed->Output.Index);
         TWO_BYTE_DATA (tmpBitField, descIndex, Dbg);
         goto HIDP_PARSE_MAIN_ITEM;

      case HIDP_MAIN_FEATURE_1:
         tmpReportIDs = push->ReportIDs;
         bitPos = tmpReportIDs->FeatureLength; // The distance into the report
         HidP_KdPrint(0, ("'Feature offset:%x \n", bitPos));
         tmpReportIDs->FeatureLength += push->ReportSize * push->ReportCount;
         channelIndex = &(preparsed->Feature.Index);
         ONE_BYTE_DATA (tmpBitField, descIndex, Dbg);
         goto HIDP_PARSE_MAIN_ITEM;

      case HIDP_MAIN_FEATURE_2:
         tmpReportIDs = push->ReportIDs;
         bitPos = tmpReportIDs->FeatureLength; // The distance into the report
         HidP_KdPrint(0, ("'Feature2 offset:%x \n", bitPos));
         tmpReportIDs->FeatureLength += push->ReportSize * push->ReportCount;
         channelIndex = &(preparsed->Feature.Index);
         TWO_BYTE_DATA (tmpBitField, descIndex, Dbg);

      HIDP_PARSE_MAIN_ITEM:

          // You can have a constant field that does return data.
          // so we probably shouldn't skip it.
          // BUT it should NOT be an array style button field.
         if (HIDP_ISARRAY (tmpBitField)) {
             if (HIDP_ISCONST(tmpBitField)) {
                 break;
             }
             //
             // Here we have a list of indices that refer to the usages
             // described prior.  For each of the prior usages, up to the depth
             // found, we allocate a channel structure to describe the given
             // usages.  These channels are linked so that we will later know
             // that they all describe the same filled.
             //

             //
             // We do no support delimiteres in array declairations.
             // To do so would require a large change to Index2Usage which
             // instead of returning only one usage would have to return
             // several.
             //

             if (usage->IsAlias) {
                 status = STATUS_COULD_NOT_INTERPRET;
                 HidP_KdPrint(2, ("Currently this parser does not support\n"));
                 HidP_KdPrint(2, ("Delimiters for array declairations\n"));
                 Dbg->BreakOffset = descIndex;
                 Dbg->ErrorCode = HIDP_GETCOLDESC_UNSUPPORTED;
                 goto HIDP_PARSE_REJECT;
             }

             for ( ;
                  usage != &firstUsage;
                  (*channelIndex)++,
                  usage = HidP_PopUsageList (usage)) {

                 channel = &(preparsed->Data[*channelIndex]);

                 channel->BitField = tmpBitField;

                 // field that says this channel is linked
                 channel->MoreChannels = TRUE;

                 // say what link collection number we are in.
                 channel->LinkCollection = (USHORT)(currentLCNode - linkNodeArray);
                 channel->LinkUsage = currentLCNode->LinkUsage;
                 channel->LinkUsagePage = currentLCNode->LinkUsagePage;

                 if (usage->UsagePage) {
                     // The default usage page been overwritten.
                     channel->UsagePage = usage->UsagePage;
                 } else {
                     channel->UsagePage = push->UsagePage;
                 }

                 channel->BitOffset = (UCHAR) bitPos & 7;
                 channel->ByteOffset = (USHORT) bitPos >> 3;
                 channel->ReportSize = push->ReportSize;
                 channel->ReportCount = push->ReportCount;

                 channel->BitLength = push->ReportSize * push->ReportCount;
                 channel->ByteEnd = (channel->BitOffset + channel->BitLength);
                 channel->ByteEnd = (channel->ByteEnd >> 3)
                                  + ((channel->ByteEnd & 7) ? 1 : 0)
                                  + channel->ByteOffset;


                 channel->ReportID = push->ReportIDs->ReportID;
                 channel->Units = push->Unit;
                 channel->UnitExp = push->UnitExp;

                 channel->IsConst = FALSE;

                 channel->IsButton = TRUE;
                 channel->IsAbsolute = HIDP_ISABSOLUTE(tmpBitField);
                 channel->button.LogicalMin = push->LogicalMin;
                 channel->button.LogicalMax = push->LogicalMax;

                 channel->IsRange = usage->Range;
                 channel->IsDesignatorRange = designator.Range;
                 channel->IsStringRange = string.Range;

                 if (usage->Range) {
                     channel->Range.UsageMin = usage->Min;
                     channel->Range.UsageMax = usage->Max;
                 } else {
                     channel->Range.UsageMin =
                         channel->Range.UsageMax = usage->Value;
                 }
                 if (designator.Range) {
                     channel->Range.DesignatorMin = designator.Min;
                     channel->Range.DesignatorMax = designator.Max;
                 } else {
                     channel->Range.DesignatorMin =
                         channel->Range.DesignatorMax = designator.Value;
                 }

                 if (string.Range) {
                     channel->Range.StringMin = string.Min;
                     channel->Range.StringMax = string.Max;
                 } else {
                     channel->Range.StringMin =
                         channel->Range.StringMax = string.Value;
                 }

                 channel->NumGlobalUnknowns = push->NumGlobalUnknowns;

                 if (push->NumGlobalUnknowns) {
                     RtlCopyMemory (channel->GlobalUnknowns,
                                    push->GlobalUnknowns,
                                    push->NumGlobalUnknowns
                                    * sizeof (HIDP_UNKNOWN_TOKEN));
                 }

                 //
                 // Check for power buttons
                 //
                 if (HIDP_USAGE_SYSCTL_PAGE == channel->UsagePage) {
                     if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_POWER) &&
                         (HIDP_USAGE_SYSCTL_POWER <= channel->Range.UsageMax)) {
                         preparsed->PowerButtonMask |= SYS_BUTTON_POWER;
                     }
                     if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_SLEEP) &&
                         (HIDP_USAGE_SYSCTL_SLEEP <= channel->Range.UsageMax)) {
                         preparsed->PowerButtonMask |= SYS_BUTTON_SLEEP;
                     }
                     if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_WAKE) &&
                         (HIDP_USAGE_SYSCTL_WAKE <= channel->Range.UsageMax)) {
                         preparsed->PowerButtonMask |= SYS_BUTTON_WAKE;
                     }
                 }

             }

             ASSERT (0 == usage->Depth);

             channel->MoreChannels = FALSE;
             designator = string = zeroLocal;
             break;
         } // end array style channel


         channel = &(preparsed->Data[*channelIndex]);
         if (HIDP_ISCONST(tmpBitField)) {
             if ((0 == usage->Depth) ||
                 ((0 == usage->Value) && (0 == usage->Min)
                                      && (0 == usage->Max))) {
                 //
                 // A constant channel with no usage.  Skip it.
                 //

                 usage = HidP_FreeUsageList (usage);
                 ASSERT (usage == &firstUsage);
                 ASSERT (0 == usage->Depth);
                 break;
             }
             channel->IsConst = TRUE;
         } else {
             channel->IsConst = FALSE;
         }

         tmpCount = usage->Depth // - 1
                  + (usage->Range ? (usage->Max - usage->Min) : 0);  // + 1

#if 0
         while (tmpCount > push->ReportCount) {
             // Get rid of excess usages.
             tmpCount = usage->Depth - 1;
             usage = HidP_PopUsageList (usage);

             ASSERT (tmpCount == (usage->Depth +
                                  (usage->Range ? (usage->Max - usage->Min) : 0)));
         }
#else
         while (tmpCount > push->ReportCount) {
             // Get rid of excess usages.

             if (tmpCount <= usage->Depth) {
                 // We've got enough in the linked usages to fulfill this request
                 tmpCount = usage->Depth - 1;
                 usage = HidP_PopUsageList (usage);

                 ASSERT (tmpCount ==
                         (usage->Depth +
                          (usage->Range ? (usage->Max - usage->Min) : 0)));
             } else {
                 // We don't have enough in the linked usages, but we've too
                 // much in this range.  So, adjust the max value of the
                 // range so that it won't be too many usages.

                 ASSERT (usage->Range);
                 usage->Max = push->ReportCount - usage->Depth + usage->Min;

                 tmpCount = usage->Depth + (usage->Max - usage->Min);
             }
         }
         ASSERT (tmpCount <= push->ReportCount);
         // Now we should no longer have too many usages.
         //
#endif
         //
         // The last value in the link (aka the top) must be
         // repeated if there are less usages than there are
         // report counts.  That particular usage applies to all
         // field in this main item not yet accounted for.  In this
         // case a single channel descriptor is allocated and
         // report count is set to the number of fields referenced
         // by this usage.
         //
         // Not the usages are listed in reverse order of there appearence
         // in the report descriptor, so the first usage found in this list
         // is the one that should be repeated.
         //
         // tmpCount is the number of field to which this first usage applies.
         //

         tmpCount = 1 + push->ReportCount - tmpCount
                  + usage->Max - usage->Min;

         //
         // The following loop assigns the usage to the fields in this main
         // item in reverse order.
         //
         bitPos += push->ReportSize * (push->ReportCount - tmpCount);
         for (i = 0;
              i < push->ReportCount;

              i += tmpCount, // Bump i by the number of fields for this channel
              tmpCount = 1 + (usage->Range ? (usage->Max - usage->Min) : 0),
              bitPos -= (push->ReportSize * tmpCount)) {

             do { // do for all the aliases.
                 channel = &(preparsed->Data[(*channelIndex)++]);

                 // set the IsAlias flag now and then clear the last one
                 // at the close of this Do while loop.
                 channel->IsAlias = TRUE;

                 channel->BitField = tmpBitField;
                 channel->MoreChannels = FALSE; // only valid for arrays
                 channel->LinkCollection = (USHORT)(currentLCNode - linkNodeArray);
                 channel->LinkUsage = currentLCNode->LinkUsage;
                 channel->LinkUsagePage = currentLCNode->LinkUsagePage;

                 if (usage->UsagePage) {
                     // The default usage page been overwritten.
                     channel->UsagePage = usage->UsagePage;
                 } else {
                     channel->UsagePage = push->UsagePage;
                 }

                 channel->BitOffset = (UCHAR) bitPos & 7;
                 channel->ByteOffset = (USHORT) bitPos >> 3;
                 channel->ReportSize = push->ReportSize;
                 channel->ReportCount = tmpCount;

                 channel->BitLength = push->ReportSize * tmpCount;
                 channel->ByteEnd = (channel->BitOffset + channel->BitLength);
                 channel->ByteEnd = (channel->ByteEnd >> 3)
                                  + ((channel->ByteEnd & 7) ? 1 : 0)
                                  + channel->ByteOffset;

                 channel->ReportID = push->ReportIDs->ReportID;

                 channel->IsAbsolute = HIDP_ISABSOLUTE(tmpBitField);

                 channel->Units = push->Unit;
                 channel->UnitExp = push->UnitExp;

                 if (1 == push->ReportSize) {
                     channel->IsButton = TRUE;
                 } else {
                     channel->IsButton = FALSE;
                     channel->Data.HasNull = HIDP_HASNULL(channel->BitField);
                     channel->Data.LogicalMin = push->LogicalMin;
                     channel->Data.LogicalMax = push->LogicalMax;
                     channel->Data.PhysicalMin = push->PhysicalMin;
                     channel->Data.PhysicalMax = push->PhysicalMax;
                 }

                 channel->IsDesignatorRange = designator.Range;
                 channel->IsStringRange = string.Range;
                 channel->IsRange = usage->Range;
                 if (usage->Range) {
                     channel->Range.UsageMin = usage->Min;
                     channel->Range.UsageMax = usage->Max;
                 } else {
                     channel->Range.UsageMin =
                         channel->Range.UsageMax = usage->Value;
                 }

                 if (designator.Range) {
                     channel->Range.DesignatorMin = designator.Min;
                     channel->Range.DesignatorMax = designator.Max;
                 } else {
                     channel->Range.DesignatorMin =
                         channel->Range.DesignatorMax = designator.Value;
                 }

                 if (string.Range) {
                     channel->Range.StringMin = string.Min;
                     channel->Range.StringMax = string.Max;
                 } else {
                     channel->Range.StringMin =
                         channel->Range.StringMax = string.Value;
                 }
                 isAlias = usage->IsAlias;
                 usage   = HidP_PopUsageList (usage); // discard used usage

                 channel->NumGlobalUnknowns = push->NumGlobalUnknowns;
                 if (push->NumGlobalUnknowns) {
                     RtlCopyMemory (channel->GlobalUnknowns,
                                    push->GlobalUnknowns,
                                    push->NumGlobalUnknowns
                                    * sizeof (HIDP_UNKNOWN_TOKEN));
                 }

                 //
                 // Check for power buttons
                 //
                 if (HIDP_USAGE_SYSCTL_PAGE == channel->UsagePage) {
                     if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_POWER) &&
                         (HIDP_USAGE_SYSCTL_POWER <= channel->Range.UsageMax)) {
                         preparsed->PowerButtonMask |= SYS_BUTTON_POWER;
                     }
                     if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_SLEEP) &&
                         (HIDP_USAGE_SYSCTL_SLEEP <= channel->Range.UsageMax)) {
                         preparsed->PowerButtonMask |= SYS_BUTTON_SLEEP;
                     }
                     if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_WAKE) &&
                         (HIDP_USAGE_SYSCTL_WAKE <= channel->Range.UsageMax)) {
                         preparsed->PowerButtonMask |= SYS_BUTTON_WAKE;
                     }
                 }

             } while (isAlias);

             channel->IsAlias = FALSE;
         } // for all channels in this main item

         // Zero out the locals.
         designator = string = zeroLocal;

         // Hopefully we have used all the local usages now
         ASSERT (usage == &firstUsage);
         break;

      default:
#ifdef HIDP_REJECT_UNDEFINED
         HidP_KdPrint (2, ("Item Unknown %x\n", item));
         Dbg->BreakOffset = descIndex;
         Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
         Dbg->Args[0] = item;
         status = STATUS_ILLEGAL_INSTRUCTION;
         goto HIDP_PARSE_REJECT;
#else
         if (HIDP_IS_MAIN_ITEM (item)) {
             HidP_KdPrint (2, ("Unknown MAIN item: %x\n", item));
             Dbg->BreakOffset = descIndex;
             Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
             Dbg->Args[0] = item;
             status = STATUS_ILLEGAL_INSTRUCTION;
             goto HIDP_PARSE_REJECT;

         } else if (HIDP_IS_GLOBAL_ITEM (item)) {
             if (HIDP_MAX_UNKNOWN_ITEMS == push->NumGlobalUnknowns) {
                 push->NumGlobalUnknowns--;
                 // overwrite the last entry;
             }
             unknownToken = &push->GlobalUnknowns[push->NumGlobalUnknowns];
             unknownToken->Token = item;
             switch (item & HIDP_ITEM_LENGTH_DATA) {
             case 0:
                 break;
             case 1:
                 ONE_BYTE_DATA (unknownToken->BitField, descIndex, Dbg);
                 break;
             case 2:
                 TWO_BYTE_DATA (unknownToken->BitField, descIndex, Dbg);
                 break;
             case 3:
                 FOUR_BYTE_DATA (unknownToken->BitField, descIndex, Dbg);
                 break;
             }
             push->NumGlobalUnknowns++;

         } else if (HIDP_IS_LOCAL_ITEM (item)) {
             HidP_KdPrint (2, ("Unknown LOCAL item: %x\n", item));
             Dbg->BreakOffset = descIndex;
             Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
             Dbg->Args[0] = item;
             status = STATUS_ILLEGAL_INSTRUCTION;
             goto HIDP_PARSE_REJECT;

         } else if (HIDP_IS_RESERVED_ITEM (item)) {
             HidP_KdPrint (2, ("Unknown RESERVED item: %x\n", item));
             Dbg->BreakOffset = descIndex;
             Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
             Dbg->Args[0] = item;
             status = STATUS_ILLEGAL_INSTRUCTION;
             goto HIDP_PARSE_REJECT;
         }

#endif

         break;
      }
   }

   HidP_FreeUsageList (usage);
   //
   // Since the number of report IDs could be less than the total allocated,
   // due to the fact that some might be repeated, reset the length of the
   // array to reflect the total amount which we found.
   //
   DeviceDesc->ReportIDsLength =
       (ULONG)(currentReportIDs - DeviceDesc->ReportIDs);

   return status;

HIDP_PARSE_REJECT:
   while (push != &firstPush)
   {
      tmpPush = push;
      push = push->Pop;
      ExFreePool (tmpPush);
   }
   if (NULL != usage) {
       //
       // If usage is null, that means that something went wrong. (probably
       // in the push usage routine).  In this case the usage memory should
       // have already been freed.
       //
       HidP_FreeUsageList (usage);
   }
   return status;
}

VOID
HidP_FreeCollectionDescription (
    IN  PHIDP_DEVICE_DESC   Desc
    )
{
    ULONG i;

    for (i=0; i < Desc->CollectionDescLength; i++) {
        ExFreePool (Desc->CollectionDesc[i].PreparsedData);
    }
    ExFreePool (Desc->CollectionDesc);
    ExFreePool (Desc->ReportIDs);

    //
    // Do NOT free Desc itself.
    //
}

#define PHIDP_SYS_POWER_EVENT_BUTTON_LENGTH 0x20
NTSTATUS
HidP_SysPowerEvent (
    IN  PCHAR                   HidPacket,
    IN  USHORT                  HidPacketLength,
    IN  PHIDP_PREPARSED_DATA    Ppd,
    OUT PULONG                  OutputBuffer
    )
{
    USAGE       buttonList [PHIDP_SYS_POWER_EVENT_BUTTON_LENGTH];
    ULONG       length = PHIDP_SYS_POWER_EVENT_BUTTON_LENGTH;
    NTSTATUS    status = STATUS_NOT_SUPPORTED;
    ULONG       i;

    *OutputBuffer = 0;

    if (Ppd->PowerButtonMask) {

        status = HidP_GetUsages (HidP_Input,
                                 HIDP_USAGE_SYSCTL_PAGE,
                                 0,
                                 buttonList,
                                 &length,
                                 Ppd,
                                 HidPacket,
                                 HidPacketLength);

        if (NT_SUCCESS (status)) {
            for (i = 0; i < length; i++) {

                switch (buttonList[i]) {
                case HIDP_USAGE_SYSCTL_POWER:
                    *OutputBuffer |= SYS_BUTTON_POWER;
                    break;

                case HIDP_USAGE_SYSCTL_WAKE:
                    *OutputBuffer |= SYS_BUTTON_WAKE;
                    break;


                case HIDP_USAGE_SYSCTL_SLEEP:
                    *OutputBuffer |= SYS_BUTTON_SLEEP;
                    break;
                }
            }
        }
    }
    return status;
}

NTSTATUS
HidP_SysPowerCaps (
    IN  PHIDP_PREPARSED_DATA    Ppd,
    OUT PULONG                  OutputBuffer
    )
{
    *OutputBuffer = Ppd->PowerButtonMask;
    return STATUS_SUCCESS;
}

void
HidP_AssignDataIndices (
    PHIDP_PREPARSED_DATA Ppd,
    PHIDP_GETCOLDESC_DBG Dbg
    )
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC   channel;
    PHIDP_CHANNEL_DESC   scan;
    PHIDP_CHANNEL_DESC   end;
    USHORT i;
    USHORT dataIndex;

    PAGED_CODE();
    UNREFERENCED_PARAMETER (Dbg);

    iof = &Ppd->Input;

    while (TRUE) {
        dataIndex = 0;

        for (i = iof->Offset, channel = &Ppd->Data[iof->Offset];
             i < iof->Index ;
             i++, channel++) {

            if (!channel->MoreChannels) {
                channel->Range.DataIndexMin = dataIndex;
                dataIndex += channel->Range.UsageMax - channel->Range.UsageMin;
                channel->Range.DataIndexMax = dataIndex;
                dataIndex++;
            } else {
                //
                // An array channel.  We must number these backwards.
                //

                scan = channel;

                while (scan->MoreChannels) {
                    scan++;
                    i++;
                }
                end = scan;

                do {
                    scan->Range.DataIndexMin = dataIndex;
                    dataIndex += scan->Range.UsageMax
                               - scan->Range.UsageMin;

                    scan->Range.DataIndexMax = dataIndex;
                    dataIndex++;
                    scan--;

                } while ( channel <= scan );
                channel = end;
            }
        }

        if (&Ppd->Input == iof) {
            iof = &Ppd->Output;
        } else if (&Ppd->Output == iof) {
            iof = &Ppd->Feature;
        } else {
            ASSERT (&Ppd->Feature == iof);
            break;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidparse\test\descript.c ===
#include "wdm.h"
#include "hidpddi.h"
#include "hidusage.h"

#define FAR
#include "poclass.h"
#include "hidparse.h"

#include <stdio.h>
#include <malloc.h>

#define ExAllocatePoolWithTag(pool, bytes, tag) ( pool = pool, malloc (bytes))
#define ExFreePool(foo) free (foo)
#define RtlAssert(e, f, l, null) \
    { printf ("Assert Failed: %s \n %s \n %d \n", e, f, l ); _asm { int 3 } }
#define DbgBreakPoint() _asm { int 3 }
#define KeGetCurrentIrql() 0

#undef HidP_KdPrint
#undef KdPrint
#define HidP_KdPrint(_l_,_x_) \
                printf ("HidParse.SYS: "); \
                printf _x_;
#define KdPrint(_a_) HidP_KdPrint(0,_a_)


#include "..\descript.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidparse\trnslate.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    query.c

Abstract:

    This module contains the code for Translating HID report packets.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : created by Kenneth Ray

--*/

#include <wtypes.h>

#include "hidsdi.h"
#include "hidparse.h"


NTSTATUS __stdcall
HidP_UsageListDifference (
   IN    PUSAGE  PreviousUsageList,
   IN    PUSAGE  CurrentUsageList,
   OUT   PUSAGE  BreakUsageList,
   OUT   PUSAGE  MakeUsageList,
   IN    ULONG    UsageListLength
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
   ULONG    i,j;
   ULONG    test;
   ULONG    b; // an index into MakeUsageList
   ULONG    m; // an index into BreakUsageList
   USHORT   usage;
   BOOLEAN  found;

   b = m = 0;

   //
   // This assumes that UsageListLength will be a small number.
   // No keyboard today can generate more than 14 keys in one packet, and
   // there is no anticipation for other devices with greater than 14 usages
   // at once.  For this reason the straight forward naive approach follows...
   //
   // These lists are not sorted.
   //

   //
   // Find the Old usages.
   //
   for (i=0; i<UsageListLength; i++) {
      usage = PreviousUsageList[i];

      if (0 == usage) {
         break;  // Zeros Only at the end.
      }

      found = FALSE;
      for (j=0; j<UsageListLength; j++) {
         test = CurrentUsageList [j];

         if (0 == test) {
            break; // Zeros only at the end.
         }
         if (test == usage) {
            found = TRUE;
            break;
         }
      }

      if (!found) {
         BreakUsageList [b++] = usage;
      }
   }


   //
   // Find the New usages.
   //
   for (i=0; i<UsageListLength; i++) {
      usage = CurrentUsageList[i];

      if (0 == usage) {
         break;  // Zeros Only at the end.
      }

      found = FALSE;
      for (j=0; j<UsageListLength; j++) {
         test = PreviousUsageList [j];

         if (0 == test) {
            break; // Zeros only at the end.
         }
         if (test == usage) {
            found = TRUE;
            break;
         }
      }

      if (!found) {
         MakeUsageList [m++] = usage;
      }
   }

   while (b < UsageListLength) {
      BreakUsageList [b++] = 0;
   }

   while (m < UsageListLength) {
      MakeUsageList [m++] = 0;
   }

   return HIDP_STATUS_SUCCESS;
}

NTSTATUS __stdcall
HidP_UsageAndPageListDifference (
   IN    PUSAGE_AND_PAGE PreviousUsageList,
   IN    PUSAGE_AND_PAGE CurrentUsageList,
   OUT   PUSAGE_AND_PAGE BreakUsageList,
   OUT   PUSAGE_AND_PAGE MakeUsageList,
   IN    ULONG           UsageListLength
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
   ULONG    i,j;
   ULONG    b; // an index into MakeUsageList
   ULONG    m; // an index into BreakUsageList
   BOOLEAN          found;
   USAGE_AND_PAGE   usage;
   USAGE_AND_PAGE   test;
   USAGE_AND_PAGE   zero = {0,0};

   b = m = 0;

   //
   // This assumes that UsageListLength will be a small number.
   // No keyboard today can generate more than 14 keys in one packet, and
   // there is no anticipation for other devices with greater than 14 usages
   // at once.  For this reason the straight forward naive approach follows...
   //
   // These lists are not sorted.
   //

   //
   // Find the Old usages.
   //
   for (i=0; i<UsageListLength; i++) {
      usage = PreviousUsageList[i];

      if (HidP_IsSameUsageAndPage (zero, usage)) {
         break;  // Zeros Only at the end.
      }

      found = FALSE;
      for (j=0; j<UsageListLength; j++) {
         test = CurrentUsageList [j];

         if (HidP_IsSameUsageAndPage (zero, test)) {
            break; // Zeros only at the end.
         }
         if (HidP_IsSameUsageAndPage (test, usage)) {
            found = TRUE;
            break;
         }
      }

      if (!found) {
         BreakUsageList [b++] = usage;
      }
   }


   //
   // Find the New usages.
   //
   for (i=0; i<UsageListLength; i++) {
      usage = CurrentUsageList[i];

      if (HidP_IsSameUsageAndPage (zero, usage)) {
         break;  // Zeros Only at the end.
      }

      found = FALSE;
      for (j=0; j<UsageListLength; j++) {
         test = PreviousUsageList [j];

         if (HidP_IsSameUsageAndPage (zero, test)) {
            break; // Zeros only at the end.
         }
         if (HidP_IsSameUsageAndPage (test, usage)) {
            found = TRUE;
            break;
         }
      }

      if (!found) {
         MakeUsageList [m++] = usage;
      }
   }

   while (b < UsageListLength) {
      BreakUsageList [b++] = zero;
   }

   while (m < UsageListLength) {
      MakeUsageList [m++] = zero;
   }

   return HIDP_STATUS_SUCCESS;
}

#define KPAD(_X_) 0x ## _X_ ## F0
#define SHFT(_X_) 0x ## _X_ ## F1
#define VEND(_X_) 0x ## _X_ ## F2
#define PTSC(_X_) 0x ## _X_ ## F3

#define NONE 0xFF

//
// A table to convert a Hid Keyboard usage into a scan code.
// The scan codes from F0 ~ FF are special, they are used to indicate that
// a secondary translation is required.
// This secondary translation is done by way of the secondary translation
// function found in the ScanCodeSubTable structure array below.
//
ULONG HidP_KeyboardToScanCodeTable [0x100] = {
//
// This is a straight lookup table
//
//       + 00     + 01     + 02     + 03     + 04     + 05     + 06    + 07
//       + 08     + 09     + 0A     + 0B     + 0C     + 0D     + 0E    + OF
/*0x00*/ NONE,    NONE,    NONE,    NONE,    0x1E,    0x30,    0x2E,   0x20,
/*0x08*/ 0x12,    0x21,    0x22,    0x23,    0x17,    0x24,    0x25,   0x26,
/*0x10*/ 0x32,    0x31,    0x18,    0x19,    0x10,    0x13,    0x1F,   0x14,
/*0x18*/ 0x16,    0x2F,    0x11,    0x2D,    0x15,    0x2C,    0x02,   0x03,
/*0x20*/ 0x04,    0x05,    0x06,    0x07,    0x08,    0x09,    0x0A,   0x0B,
/*0x28*/ 0x1C,    0x01,    0x0E,    0x0F,    0x39,    0x0C,    0x0D,   0x1A,
/*0x30*/ 0x1B,    0x2B,    0x2B,    0x27,    0x28,    0x29,    0x33,   0x34,
/*0x38*/ 0x35,    SHFT(8), 0x3B,    0x3C,    0x3D,    0x3E,    0x3F,   0x40,
/*0x40*/ 0x41,    0x42,    0x43,    0x44,    0x57,    0x58,    PTSC(0),SHFT(9),
/*0x48*/ 0x451DE1,KPAD(0), KPAD(1), KPAD(2), KPAD(3), KPAD(4), KPAD(5),KPAD(6),
/*0x50*/ KPAD(7), KPAD(8), KPAD(9), SHFT(A), 0x35E0,  0x37,    0x4A,   0x4E,
/*0x58*/ 0x1CE0,  0x4F,    0x50,    0x51,    0x4B,    0x4C,    0x4D,   0x47,
/*0x60*/ 0x48,    0x49,    0x52,    0x53,    0x56,    0x5DE0,  0x5EE0, 0x59,
/*0x68*/ 0x64,    0x65,    0x66,    0x67,    0x68,    0x69,    0x6A,   0x6B,
/*0x70*/ 0x6C,    0x6D,    0x6E,    0x76,    NONE,    NONE,    NONE,   NONE,
/*0x78*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0x80*/ NONE,    NONE,    NONE,    NONE,    NONE,    0x7E,    NONE,   0x73,
/*0x88*/ 0x70,    0x7D,    0x79,    0x7B,    0x5C,    NONE,    NONE,   NONE,
/*0x90*/ VEND(0), VEND(1), 0x78,    0x77,    0x76,    NONE,    NONE,   NONE,
/*0x98*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xA0*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xA8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xB0*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xB8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xC0*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xC8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xD0*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xD8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xE0*/ SHFT(0), SHFT(1), SHFT(2), SHFT(3), SHFT(4), SHFT(5), SHFT(6),SHFT(7),
/*0xE8*/ NONE,    0x5EE0,  0x5FE0,  0x63E0,  NONE,    NONE,    NONE,   NONE,
/*KPAD*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xF8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
};

ULONG HidP_XlateKbdPadCodesSubTable[] = {
   /*     + 00    + 01    + 02     + 03    + 04    + 05    + 06     + 07 */
   /*     + 08    + 09    + 0A     + 0B    + 0C    + 0D    + 0E     + OF */
   /*0x48*/         0x52E0, 0x47E0, 0x49E0,  0x53E0, 0x4FE0, 0x51E0,  0x4DE0,
   /*0x50*/ 0x4BE0, 0x50E0, 0x48E0
};


ULONG HidP_XlateModifierCodesSubTable[] = {
   //
   // NOTE These modifier codes in this table are in a VERY SPECIAL order.
   // that is: they are in the order of appearence in the
   // _HIDP_KEYBOARD_SHIFT_STATE union.
   //
   //     + 00   + 01   + 02   + 03    + 04    + 05   + 06    + 07
   //     + 08   + 09   + 0A   + 0B    + 0C    + 0D   + 0E    + OF
   //       LCtrl  LShft  LAlt   LGUI    RCtrl   RShft  RAlt    RGUI
   /*0xE0*/ 0x1D,  0x2A,  0x38,  0x5BE0, 0x1DE0, 0x36,  0x38E0, 0x5CE0,
   /*0x39 CAPS_LOCK*/     0x3A,
   /*0x47 SCROLL_LOCK*/   0x46,
   /*0x53 NUM_LOCK*/      0x45
   // This table is set up so that indices into this table greater than 7
   // are sticky.  HidP_ModifierCode uses this as an optimization for
   // updating the Modifier state table.
   //
};

ULONG HidP_BreakCodesAsMakeCodesTable[] = {
    //
    // Vendor scan codes that have the high bit set and are technically
    // break codes, but are sent as make codes.  No break code will be sent.
    //
    //       + 00  + 01  + 02  + 03  + 04  + 05  + 06  + 07
    //       + 08  + 09  + 0A  + 0B  + 0C  + 0D  + 0E  + OF
    /*0x90*/  0xF2, 0xF1
    //
};

ULONG HidP_XlatePrtScrCodesSubTable[] = {
   /*     + 00    + 01    + 02     + 03    + 04    + 05    + 06     + 07 */
   /*     + 08    + 09    + 0A     + 0B    + 0C    + 0D    + 0E     + OF */
   /*0x40*/                                                  0x37E0
};

HIDP_SCANCODE_SUBTABLE HidP_KeyboardSubTables[0x10] = {
   /* F0 */     {HidP_KeyboardKeypadCode, HidP_XlateKbdPadCodesSubTable},
   /* F1 */     {HidP_ModifierCode, HidP_XlateModifierCodesSubTable},
   /* F2 */     {HidP_VendorBreakCodesAsMakeCodes, HidP_BreakCodesAsMakeCodesTable},
   /* F3 */     {HidP_PrintScreenCode, HidP_XlatePrtScrCodesSubTable},
   /* F4 */     {NULL, NULL},
   /* F5 */     {NULL, NULL},
   /* F6 */     {NULL, NULL},
   /* F7 */     {NULL, NULL},
   /* F8 */     {NULL, NULL},
   /* F9 */     {NULL, NULL},
   /* FA */     {NULL, NULL},
   /* FB */     {NULL, NULL},
   /* FC */     {NULL, NULL},
   /* FD */     {NULL, NULL},
   /* FE */     {NULL, NULL},
   /* FF */     {NULL, NULL}
};

#define HIDP_CONSUMER_TABLE_SIZE 16
ULONG HidP_ConsumerToScanCodeTable [HIDP_CONSUMER_TABLE_SIZE] = {
//
// This is an association table
//
// Usage -> Scancode
//
    0x0224, 0x6AE0, // WWW Back
    0x0225, 0x69E0, // WWW Forward
    0x0226, 0x68E0, // WWW Stop
    0x0227, 0x67E0, // WWW Refresh
    0x0221, 0x65E0, // WWW Search
    0x022A, 0x66E0, // WWW Favorites
    0x0223, 0x32E0, // WWW Home
    0x018A, 0x6CE0  // Mail
};

HIDP_SCANCODE_SUBTABLE HidP_ConsumerSubTables [1] = {
    {NULL, NULL}
};

//
//BOOLEAN
//HidP_KbdPutKey (
//   ULONG                   Code,
//   HIDP_KEYBOARD_DIRECTION KeyAction,
//   PHIDP_INSERT_SCANCODES  Insert,
//   PVOID                   Context)
//
// Add the scan codes to the callers buffer using the callback routine
// Insert.
//
// If we find a zero in the list then we are done with no error
// If we find a invalid code (anything that starts with an F, then
// we have a problem.  No where in current published i8042 specs is there
// a scan code of F0 ~ FF.
//
// If we are breaking then we need to set the high byte.
//

BOOLEAN
HidP_KbdPutKey (
    ULONG                   PassedCode,
    HIDP_KEYBOARD_DIRECTION KeyAction,
    PHIDP_INSERT_SCANCODES  Insert,
    PVOID                   Context)
{
   PUCHAR pCode = (PCHAR)&PassedCode;
   ULONG i;

   for (i = 0; i < sizeof(ULONG); i++) {
       //
       // Some swell keyboard vendors have added Fx charaters to their
       // keyboards which we now have to emulate.
       //
       // if ((0xF0 & *pCode) == 0xF0) {
       //     return FALSE;
       // }
       if (0 == pCode[i]) {
           break;
       }
       if (HidP_Keyboard_Break == KeyAction) {
           pCode[i] |= 0x80;
       }
   }
   if (i) {
       (*Insert)(Context, pCode, i);
   }
   return TRUE;
}

NTSTATUS
HidP_TranslateUsagesToI8042ScanCodes (
    PUSAGE                        ChangedUsageList, // Those usages that changed
    ULONG                         UsageListLength,
    HIDP_KEYBOARD_DIRECTION       KeyAction,
    PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
    PHIDP_INSERT_SCANCODES        InsertCodesProcedure,
    PVOID                         InsertCodesContext
    )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
    PUSAGE      usage;
    ULONG       i;
    NTSTATUS    status = HIDP_STATUS_SUCCESS;

    for (i = 0, usage = ChangedUsageList;
         i < UsageListLength;
         i++, usage++) {

        if (0 == *usage) {
            // No more interesting usages.  Zero terminated if not max length.
            break;
        }
        status = HidP_TranslateUsage (*usage,
                                      KeyAction,
                                      ModifierState,
                                      HidP_StraightLookup,
                                      HidP_KeyboardToScanCodeTable,
                                      HidP_KeyboardSubTables,
                                      InsertCodesProcedure,
                                      InsertCodesContext);

        if (HIDP_STATUS_SUCCESS != status) {
            break;
        }
    }

    return status;
}

NTSTATUS __stdcall
HidP_TranslateUsageAndPagesToI8042ScanCodes (
    PUSAGE_AND_PAGE               ChangedUsageList, // Those usages that changed
    ULONG                         UsageListLength,
    HIDP_KEYBOARD_DIRECTION       KeyAction,
    PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
    PHIDP_INSERT_SCANCODES        InsertCodesProcedure,
    PVOID                         InsertCodesContext
    )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
    PUSAGE_AND_PAGE usage;
    ULONG           i;
    NTSTATUS        status = HIDP_STATUS_SUCCESS;

    for (i = 0, usage = ChangedUsageList;
         i < UsageListLength;
         i++, usage++) {

        if (0 == usage->Usage) {
            break;
        }

        switch (usage->UsagePage) {
        case HID_USAGE_PAGE_KEYBOARD:

            status = HidP_TranslateUsage (usage->Usage,
                                          KeyAction,
                                          ModifierState,
                                          HidP_StraightLookup,
                                          HidP_KeyboardToScanCodeTable,
                                          HidP_KeyboardSubTables,
                                          InsertCodesProcedure,
                                          InsertCodesContext);
            break;

        case HID_USAGE_PAGE_CONSUMER:

            status = HidP_TranslateUsage (usage->Usage,
                                          KeyAction,
                                          ModifierState,
                                          HidP_AssociativeLookup,
                                          HidP_ConsumerToScanCodeTable,
                                          HidP_ConsumerSubTables,
                                          InsertCodesProcedure,
                                          InsertCodesContext);
            break;

        default:
            status = HIDP_STATUS_I8042_TRANS_UNKNOWN;
        }

        if (HIDP_STATUS_SUCCESS != status) {
            break;
        }
    }

    return status;
}

NTSTATUS __stdcall
HidP_TranslateUsage (
    USAGE                         Usage,
    HIDP_KEYBOARD_DIRECTION       KeyAction,
    PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
    PHIDP_LOOKUP_TABLE_PROC       LookupTableProc,
    PULONG                        TranslationTable,
    PHIDP_SCANCODE_SUBTABLE       SubTranslationTable,
    PHIDP_INSERT_SCANCODES        InsertCodesProcedure,
    PVOID                         InsertCodesContext
    )
/*++
Routine Description:

Notes:

--*/
{
   ULONG                    scancode;
   PHIDP_SCANCODE_SUBTABLE  table;
   NTSTATUS                 status;

   scancode = (* LookupTableProc) (TranslationTable, Usage);

   if (0 == scancode) {
       return HIDP_STATUS_I8042_TRANS_UNKNOWN;
   }

   if ((ModifierState->LeftControl || ModifierState->RightControl) &&
       (scancode == 0x451DE1)) {
       //
       // The scancode of the pause key completely changes
       // if the control key is down.
       //
       scancode = 0x46E0;
   } 

   if ((0xF0 & scancode) == 0xF0) {
       // Use a secondary table
       table = &SubTranslationTable [scancode & 0xF];
       if (table->ScanCodeFcn) {
           if ((*table->ScanCodeFcn)  (table->Table,
                                       (UCHAR) ((scancode & 0xFF00) >> 8),
                                       InsertCodesProcedure,
                                       InsertCodesContext,
                                       KeyAction,
                                       ModifierState)) {
               ;
           } else {
               return HIDP_STATUS_I8042_TRANS_UNKNOWN;
           }
       } else {
           return HIDP_STATUS_I8042_TRANS_UNKNOWN;
       }
   } else {
       HidP_KbdPutKey (scancode,
                       KeyAction,
                       InsertCodesProcedure,
                       InsertCodesContext);
   }
   return HIDP_STATUS_SUCCESS;
}

BOOLEAN
HidP_KeyboardKeypadCode (
   IN     ULONG                         * Table,
   IN     UCHAR                           Index,
   IN     PHIDP_INSERT_SCANCODES          Insert,
   IN     PVOID                           Context,
   IN     HIDP_KEYBOARD_DIRECTION         KeyAction,
   IN OUT PHIDP_KEYBOARD_MODIFIER_STATE   ModifierState
   )
/*++
Routine Description:

Notes:

--*/
{
   //
   // The num lock key (if set then we add even more scan codes for these
   // keys)
   //
   ULONG DarrylRis_Magic_Code = 0x2AE0;
   BOOLEAN  status = TRUE;

   if ((ModifierState->NumLock) && (HidP_Keyboard_Make == KeyAction) ) {
       status = HidP_KbdPutKey (DarrylRis_Magic_Code, KeyAction, Insert, Context);
   } 

   if (!status) {
       return status;
   }

   status = HidP_KbdPutKey (Table[Index], KeyAction, Insert, Context);

   if (!status) {
       return status;
   }

   if ((ModifierState->NumLock) && (HidP_Keyboard_Break == KeyAction) ) {
       status = HidP_KbdPutKey (DarrylRis_Magic_Code, KeyAction, Insert, Context);
   }

   return status;
}

BOOLEAN
HidP_ModifierCode (
   IN     ULONG                         * Table,
   IN     UCHAR                           Index,
   IN     PHIDP_INSERT_SCANCODES          Insert,
   IN     PVOID                           Context,
   IN     HIDP_KEYBOARD_DIRECTION         KeyAction,
   IN OUT PHIDP_KEYBOARD_MODIFIER_STATE   ModifierState
   )
/*++
Routine Description:

Notes:

--*/
{
   if (Index >> 3) {
      //
      // Indices greater than 8 are sticky.
      //
      switch (KeyAction) {
      case HidP_Keyboard_Make:
         if (!(ModifierState->ul & (1 << (Index+16)))) {
             //
             // Mark this as the first make.
             //
             ModifierState->ul |= (1 << (Index+16));
             //
             // Only toggle the state when this is the first make sent.
             //
             ModifierState->ul ^= (1 << Index);
         }
         break;
      case HidP_Keyboard_Break:
         //
         // Clear the fist make field.
         //
         ModifierState->ul &= ~(1 << (Index+16));
         break;
      }

   } else {
      switch (KeyAction) {
      case HidP_Keyboard_Make:
         // The key is now on
         ModifierState->ul |= (1 << Index);
         break;
      case HidP_Keyboard_Break:
         // The key is now off
         ModifierState->ul &= ~(1 << Index);
         break;
      }
   }
   return HidP_KbdPutKey (Table[Index], KeyAction, Insert, Context);
}

BOOLEAN
HidP_VendorBreakCodesAsMakeCodes (
   IN     ULONG                         * Table,
   IN     UCHAR                           Index,
   IN     PHIDP_INSERT_SCANCODES          Insert,
   IN     PVOID                           Context,
   IN     HIDP_KEYBOARD_DIRECTION         KeyAction,
   IN OUT PHIDP_KEYBOARD_MODIFIER_STATE   ModifierState
   )
{
    //
    // Vendor scan codes that have the high bit set and are technically
    // break codes, but are sent as make codes.  No break code will be sent.
    //
    UNREFERENCED_PARAMETER (ModifierState);

    switch (KeyAction) {
    case HidP_Keyboard_Make:
        return HidP_KbdPutKey (Table[Index], KeyAction, Insert, Context);

    case HidP_Keyboard_Break:
        // do Nothing
        return TRUE;

    default:
        return FALSE;
    }
}

BOOLEAN
HidP_PrintScreenCode (
   IN     ULONG                         * Table,
   IN     UCHAR                           Index,
   IN     PHIDP_INSERT_SCANCODES          Insert,
   IN     PVOID                           Context,
   IN     HIDP_KEYBOARD_DIRECTION         KeyAction,
   IN OUT PHIDP_KEYBOARD_MODIFIER_STATE   ModifierState
   )
/*++
Routine Description:

Notes:

--*/
{
   BOOLEAN  status = TRUE;

   //
   // Special casing for the printscreen key.
   //
   if (ModifierState->LeftAlt || ModifierState->RightAlt) {
       //
       // Alt key down.
       //
       status = HidP_KbdPutKey (0x54, KeyAction, Insert, Context);
   } else if (ModifierState->LeftShift || ModifierState->RightShift ||
              ModifierState->LeftControl  || ModifierState->RightControl) {
       //
       // Shift or ctrl keys down.
       //
       status = HidP_KbdPutKey (Table[Index], KeyAction, Insert, Context);
   } else {
       //
       // No modifier keys down. Add some extra "padding" to the make and break.
       //
       ULONG DarrylRis_Magic_Code = 0x2AE0;
       
       if (HidP_Keyboard_Make == KeyAction) {
           status = HidP_KbdPutKey (DarrylRis_Magic_Code, KeyAction, Insert, Context);
       } 
    
       if (!status) {
           return status;
       }
    
       status = HidP_KbdPutKey (Table[Index], KeyAction, Insert, Context);
    
       if (!status) {
           return status;
       }
    
       if (HidP_Keyboard_Break == KeyAction) {
           status = HidP_KbdPutKey (DarrylRis_Magic_Code, KeyAction, Insert, Context);
       }
   }

   return status;
}

ULONG
HidP_StraightLookup (
    IN  PULONG   Table,
    IN  ULONG    Usage
    )
{
    if (Usage > 0xFF) {
        // We have
        // have no translation for this usage.
        return 0;
    }

    return Table[Usage];
}

ULONG
HidP_AssociativeLookup (
    IN  PULONG   Table,
    IN  ULONG    Usage
    )
{
    ULONG   i;

    for (i = 0; i < (HIDP_CONSUMER_TABLE_SIZE - 1); i+=2) {
        if (Usage == Table[i]) {
            return Table[i+1];
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidparse\test\query.c ===
#define HIDPARSE_USERMODE
#include "..\query.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidparse\test\hidparse.c ===
typedef int POOL_TYPE;

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>
#include <hidpddi.h>
#include <hidparse.h>

#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
    { printf ("Assert Failed: %s \n %s \n %d \n", #exp, __FILE__, __LINE__ ); }


NTSTATUS __stdcall
HidP_SetUnsetOneUsage (
   struct _CHANNEL_REPORT_HEADER *,
   USAGE,
   USHORT,
   USAGE,
   PHIDP_PREPARSED_DATA,
   PCHAR,
   BOOLEAN);



typedef union _HID_PPD_FLAGS {
    struct {
        ULONG   InputChannels       : 1;
        ULONG   OutputChannels      : 1;
        ULONG   FeatureChannels     : 1;
        ULONG   LinkCollections     : 1;
        ULONG   FullChannelListing  : 1;
        ULONG   ReportLocation      : 1;
        ULONG   Reserved            : 25;
        ULONG   IgnoreSignature     : 1;
    };
    ULONG Flags;
} HID_PPD_FLAGS;

VOID HID_DumpPpd (PHIDP_PREPARSED_DATA Ppd, HID_PPD_FLAGS Flags);

void __cdecl main ()
{
    HID_PPD_FLAGS   flags;
    ULONG           i;
    UCHAR desc[] = {0x05,   0x0C,   0x09,   0x01,
                    0xA1,   0x01,   0x85,   0x01,
                    0x09,   0x36,   0xA1,   0x02,
                    0x05,   0x09,   0x19,   0x01,
                    0x29,   0x10,   0x15,   0x00,
                    0x25,   0x01,   0x35,   0x00,
                    0x45,   0x01,   0x75,   0x01,
                    0x95,   0x10,   0x81,   0x02,
                    0xC0,   0x15,   0x01,
                    0x25,   0x03,   0x75,   0x02,
                    0x95,   0x01,   0x05,   0x0C,
                    0x09,   0xB0,   0xA1,   0x02,
                    0x05,   0x08,   0x09,   0x3C,
                    0xA1,   0x02,   0x09,   0x3D,
                    0x09,   0x3F,   0x09,   0x41,
                    0x91,   0x00,   0xC0,
                    0x09,   0x47,   0xA1,   0x02,
                    0x09,   0x48,   0x09,   0x49,
                    0x09,   0x4A,   0x91,   0x00,
                    0x91,   0x01,   0x91,   0x01,
                    0xC0,   0xC0,
                    0x05,   0x14,   0x15,   0x00,
                    0x09,   0x20,   0xA1,   0x02,
                    0x09,   0x35,   0x25,   0x03,
                    0x75,   0x03,   0x95,   0x01,
                    0xB1,   0x03,   0x09,   0x36,
                    0x25,   0x1F,   0x75,   0x05,
                    0xB1,   0x03,   0xC0,
                    0x09,   0x32,   0xA1,   0x02,
                    0x85,   0x02,   0x09,   0x33,
                    0x75,   0x03,   0x95,   0x01,
                    0x25,   0x07,   0xB1,   0x22,
                    0x09,   0x34,   0x75,   0x05,
                    0x25,   0x1F,   0xB1,   0x22,
                    0xC0,   0x09,   0x2B,
                    0xA1,   0x02,   0x09,   0x33,
                    0x75,   0x03,   0x95,   0x01,
                    0x25,   0x07,   0xB1,   0x22,
                    0x09,   0x34,   0x75,   0x05,
                    0x25,   0x1F,   0xB1,   0x22,
                    0x75,   0x08,   0x95,   0x04,
                    0x15,   0x20,   0x26,   0xFE,   0x00,
                    0x09,   0x2C,   0xB1,   0x02,
                    0xC0,   0xC0
    };

    unsigned char PwrReportDescriptor[] = {
    0x05, 0x84,                    // USAGE_PAGE (Power Device)
    0x09, 0x04,                    // USAGE (UPS)
    0xa1, 0x01,                    // COLLECTION (Application)
    0x85, 0x01,                    //   REPORT_ID (1)
    0x09, 0x1e,                    //   USAGE (Flow)
    0xa1, 0x02,                    //   COLLECTION (Logical)
    0x09, 0x1f,                    //     USAGE (FlowID)
    0x75, 0x04,                    //     REPORT_SIZE (4)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
    0x25, 0x0f,                    //     LOGICAL_MAXIMUM (15)
    0x65, 0x00,                    //     UNIT (None)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x09, 0x00,                    //     USAGE (Undefined)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x09, 0x01,                    //     USAGE (iName)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x26, 0xff, 0x00,              //     LOGICAL_MAXIMUM (255)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x09, 0x40,                    //     USAGE (ConfigVoltage)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x67, 0x21, 0xd1, 0xf0, 0x00,  //     UNIT (SI Lin:Volts)
    0x55, 0x07,                    //     UNIT_EXPONENT (7)
    0x26, 0xfe, 0x00,              //     LOGICAL_MAXIMUM (254)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x09, 0x42,                    //     USAGE (ConfigFrequency)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x66, 0x01, 0xf0,              //     UNIT (SI Lin:Hertz)
    0x55, 0x00,                    //     UNIT_EXPONENT (0)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x09, 0x43,                    //     USAGE (ConfigApparentPower)
    0x75, 0x10,                    //     REPORT_SIZE (16)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x66, 0x21, 0xd1,              //     UNIT (SI Lin:Power)
    0x55, 0x07,                    //     UNIT_EXPONENT (7)
    0x27, 0xfe, 0xff, 0x00, 0x00,  //     LOGICAL_MAXIMUM (65534)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x65, 0x00,                    //     UNIT (None)
    0xc0,                          //   END_COLLECTION
    0x09, 0x24,                    //   USAGE (PowerSummary)
    0xa1, 0x00,                    //   COLLECTION (Physical)
    0x85, 0x02,                    //     REPORT_ID (2)
    0x09, 0x25,                    //     USAGE (PowerSummaryID)
    0x09, 0x1f,                    //     USAGE (FlowID)
    0x75, 0x04,                    //     REPORT_SIZE (4)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x25, 0x0f,                    //     LOGICAL_MAXIMUM (15)
    0x65, 0x00,                    //     UNIT (None)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x09, 0x01,                    //     USAGE (iName)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x25, 0x0f,                    //     LOGICAL_MAXIMUM (15)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x0b, 0x2c, 0x00, 0x85, 0x00,  //     USAGE (Battery System:CapacityMode)
    0x0b, 0x8b, 0x00, 0x85, 0x00,  //     USAGE (Battery System:Rechargable)
    0x75, 0x01,                    //     REPORT_SIZE (1)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x09, 0x00,                    //     USAGE (Undefined)
    0x75, 0x06,                    //     REPORT_SIZE (6)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x0b, 0x83, 0x00, 0x85, 0x00,  //     USAGE (Battery System:DesignCapacity)
    0x0b, 0x67, 0x00, 0x85, 0x00,  //     USAGE (Battery System:FullChargeCapacity)
    0x75, 0x18,                    //     REPORT_SIZE (24)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x67, 0x01, 0x10, 0x10, 0x00,  //     UNIT (SI Lin:Battery Capacity)
    0x27, 0xfe, 0xff, 0xff, 0x00,  //     LOGICAL_MAXIMUM (16777214)
    0xb1, 0x02,                    //     FEATURE (Data,Var,Abs)
    0x09, 0x40,                    //     USAGE (ConfigVoltage)
    0x75, 0x10,                    //     REPORT_SIZE (16)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x67, 0x21, 0xd1, 0xf0, 0x00,  //     UNIT (SI Lin:Volts)
    0x55, 0x05,                    //     UNIT_EXPONENT (5)
    0x27, 0xfe, 0xff, 0x00, 0x00,  //     LOGICAL_MAXIMUM (65534)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x0b, 0x8c, 0x00, 0x85, 0x00,  //     USAGE (Battery System:WarningCapacityLimit)
    0x0b, 0x29, 0x00, 0x85, 0x00,  //     USAGE (Battery System:RemainingCapacityLimit)
    0x0b, 0x8d, 0x00, 0x85, 0x00,  //     USAGE (Battery System:CapacityGranularity1)
    0x0b, 0x8e, 0x00, 0x85, 0x00,  //     USAGE (Battery System:CapacityGranularity2)
    0x75, 0x18,                    //     REPORT_SIZE (24)
    0x95, 0x04,                    //     REPORT_COUNT (4)
    0x67, 0x01, 0x10, 0x10, 0x00,  //     UNIT (SI Lin:Battery Capacity)
    0x55, 0x00,                    //     UNIT_EXPONENT (0)
    0x27, 0xfe, 0xff, 0xff, 0x00,  //     LOGICAL_MAXIMUM (16777214)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x09, 0xfe,                    //     USAGE (iProduct)
    0x09, 0xff,                    //     USAGE (iSerialNumber)
    0x0b, 0x89, 0x00, 0x85, 0x00,  //     USAGE (Battery System:iDeviceChemistery)
    0x0b, 0x87, 0x00, 0x85, 0x00,  //     USAGE (Battery System:iManufacturerName)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x04,                    //     REPORT_COUNT (4)
    0x25, 0x0f,                    //     LOGICAL_MAXIMUM (15)
    0x65, 0x00,                    //     UNIT (None)
    0xb1, 0x03,                    //     FEATURE (Cnst,Var,Abs)
    0x09, 0x30,                    //     USAGE (Voltage)
    0x75, 0x10,                    //     REPORT_SIZE (16)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x67, 0x21, 0xd1, 0xf0, 0x00,  //     UNIT (SI Lin:Volts)
    0x55, 0x05,                    //     UNIT_EXPONENT (5)
    0x27, 0xfe, 0xff, 0x00, 0x00,  //     LOGICAL_MAXIMUM (65534)
    0xb1, 0x02,                    //     FEATURE (Data,Var,Abs)
    0x09, 0x31,                    //     USAGE (Current)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x67, 0x01, 0x00, 0x10, 0x00,  //     UNIT (SI Lin:Amps)
    0x55, 0x0e,                    //     UNIT_EXPONENT (-2)
    0xb1, 0x02,                    //     FEATURE (Data,Var,Abs)
    0x0b, 0x66, 0x00, 0x85, 0x00,  //     USAGE (Battery System:RemainingCapacity)
    0x75, 0x18,                    //     REPORT_SIZE (24)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x67, 0x01, 0x10, 0x10, 0x00,  //     UNIT (SI Lin:Battery Capacity)
    0x55, 0x00,                    //     UNIT_EXPONENT (0)
    0x27, 0xfe, 0xff, 0xff, 0x00,  //     LOGICAL_MAXIMUM (16777214)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x0b, 0x68, 0x00, 0x85, 0x00,  //     USAGE (Battery System:RunTimeToEmpty)
    0x75, 0x10,                    //     REPORT_SIZE (16)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x66, 0x01, 0x10,              //     UNIT (SI Lin:Time)
    0x55, 0x00,                    //     UNIT_EXPONENT (0)
    0x27, 0xfe, 0xff, 0x00, 0x00,  //     LOGICAL_MAXIMUM (65534)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x09, 0x35,                    //     USAGE (PercentLoad)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x26, 0xfe, 0x00,              //     LOGICAL_MAXIMUM (254)
    0x65, 0x00,                    //     UNIT (None)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x09, 0x02,                    //     USAGE (PresentStatus)
    0xa1, 0x02,                    //     COLLECTION (Logical)
    0x05, 0x85,                    //       USAGE_PAGE (Battery System)
    0x09, 0xd0,                    //       USAGE (ACPresent)
    0x09, 0x42,                    //       USAGE (BelowRemainingCapacityLimit)
    0x09, 0x44,                    //       USAGE (Charging)
    0x09, 0x45,                    //       USAGE (Discharging)
    0x0b, 0x69, 0x00, 0x84, 0x00,  //       USAGE (Power Device:ShutdownImminent)
    0x0b, 0x65, 0x00, 0x84, 0x00,  //       USAGE (Power Device:Overload)
    0x09, 0x00,                    //       USAGE (Undefined)
    0x09, 0x00,                    //       USAGE (Undefined)
    0x75, 0x01,                    //       REPORT_SIZE (1)
    0x95, 0x08,                    //       REPORT_COUNT (8)
    0x25, 0x01,                    //       LOGICAL_MAXIMUM (1)
    0x81, 0x02,                    //       INPUT (Data,Var,Abs)
    0xc0,                          //     END_COLLECTION
    0xc0,                          //   END_COLLECTION
    0xc0                           // END_COLLECTION
    };

    UCHAR rawDesc[] = {
        0x05, 0x80, 0x09, 0x01, 0xA1, 0x01, 0x85, 0x01,
        0x75, 0x08, 0x95, 0x80, 0x15, 0x00, 0x26, 0xFF,
        0x00, 0x09, 0x02, 0xB2, 0x02, 0x01, 0x85, 0x02,
        0x75, 0x10, 0x95, 0x01, 0x15, 0x00, 0x27, 0xFF,
        0xFF, 0x00, 0x00, 0x09, 0x04, 0xB1, 0x02, 0x85,
        0x03, 0x09, 0x09, 0xA1, 0x02, 0x05, 0x81, 0x09,
        0x01, 0x25, 0x01, 0x75, 0x08, 0x95, 0x01, 0xB1,
        0x40, 0xC0, 0x05, 0x82, 0x85, 0x04, 0x09, 0x20,
        0x09, 0x22, 0x09, 0x30, 0x09, 0x32, 0x09, 0x24,
        0x75, 0x08, 0x95, 0x05, 0x26, 0xFF, 0x00, 0xB1,
        0x62, 0x09, 0x20, 0x09, 0x22, 0x09, 0x30, 0x09,
        0x32, 0x09, 0x24, 0x81, 0x62, 0x85, 0x05, 0x09,
        0x26, 0x09, 0x3A, 0x09, 0x40, 0x09, 0x42, 0x09,
        0x44, 0x95, 0x05, 0xB1, 0x62, 0x09, 0x26, 0x09,
        0x3A, 0x09, 0x40, 0x09, 0x42, 0x09, 0x44, 0x81,
        0x62, 0x85, 0x06, 0x09, 0x10, 0x09, 0x12, 0x09,
        0x16, 0x09, 0x18, 0x09, 0x1A, 0x95, 0x05, 0xB1,
        0x62, 0x09, 0x10, 0x09, 0x12, 0x09, 0x16, 0x09,
        0x18, 0x09, 0x1A, 0x81, 0x62, 0x85, 0x07, 0x09,
        0x6C, 0x09, 0x6E, 0x09, 0x70, 0x95, 0x03, 0xB1,
        0x62, 0x09, 0x6C, 0x09, 0x6E, 0x09, 0x70, 0x81,
        0x62, 0x85, 0x08, 0x09, 0x5E, 0xA1, 0x02, 0x05,
        0x81, 0x09, 0x03, 0x75, 0x08, 0x95, 0x01, 0x25,
        0x01, 0xB1, 0x40, 0xC0, 0x05, 0x82, 0x09, 0x60,
        0xA1, 0x02, 0x05, 0x81, 0x09, 0x01, 0x75, 0x08,
        0x25, 0x01, 0xB1, 0x40, 0xC0, 0x05, 0x83, 0x85,
        0x09, 0x09, 0x02, 0x75, 0x08, 0x25, 0x01, 0xB1,
        0x02, 0x09, 0x01, 0xA1, 0x02, 0x05, 0x81, 0x09,
        0x02, 0x09, 0x04, 0x75, 0x08, 0x25, 0x02, 0xB1, 0x40, 0xC0, 0xC0
    };

    UCHAR anotherRawDesc[] = {

        0x05, 0x01, // USAGE_PAGE (Generic Desktop)    05 01
        0x09, 0x02, // USAGE (Mouse)                   09 02
        0xA1, 0x01, // COLLECTION (Application)        A1 01
        0x05, 0x09, // USAGE_PAGE (Button)             05 09
        0x19, 0x01, // USAGE_MINIMUM (Button 1)        19 01
        0x29, 0x02, // USAGE_MAXIMUM (Button 2)        29 02
        0x09, 0x0C, // USAGE (Button 12)               09 0C
        0x15, 0x81, // LOGICAL_MINIMUM (-127)          15 81
        0x25, 0x7F, // LOGICAL_MAXIMUM (127)           25 7F
        0x75, 0x08, // REPORT_SIZE (8)                 75 08
        0x95, 0x03, // REPORT_COUNT (3)                95 03
        0x81, 0x02, // INPUT (Data,Var,Abs)            81 02
        0xC0 // END_COLLECTION                  C0
    };

    UCHAR yetAnotherRawDesc[] = {

        0x05, 0x01, // USAGE_PAGE (Generic Desktop)    05 01
        0x09, 0x02, // USAGE (Mouse)                   09 02
        0xA1, 0x01, // COLLECTION (Application)        A1 01
        0x05, 0x09, // USAGE_PAGE (Button)             05 09
        0x19, 0x01, // USAGE_MINIMUM (Button 1)        19 01
        0x29, 0x08, // USAGE_MAXIMUM (Button 8)
        0x09, 0x0C, // USAGE (Button 12)               09 0C
        0x19, 0x30, // USAGE_MINIMUM (Button 30)       19 30
        0x29, 0x32, // USAGE_MAXIMUM (Button 32)
        0x15, 0x81, // LOGICAL_MINIMUM (-127)          15 81
        0x25, 0x7F, // LOGICAL_MAXIMUM (127)           25 7F
        0x75, 0x04, // REPORT_SIZE (4)
        0x95, 0x10, // REPORT_COUNT (10)               95 10
        0x81, 0x00, // INPUT (Data,Var,Array)          81 00
        0xC0 // END_COLLECTION                  C0
    };

    UCHAR yard[] = {
        0x05, 0x01, 0x09, 0x05, 0x95, 0x00, 0xa1, 0x01,
        0x05, 0x01, 0x09, 0x01, 0xa1, 0x00, 0x09, 0x30,
        0x09, 0x31, 0x15, 0x81, 0x25, 0x7f, 0x35, 0x00,
        0x45, 0xff, 0x66, 0x00, 0x00, 0x75, 0x08, 0x95,
        0x02, 0x81, 0x02, 0xc0, 0x05, 0x09, 0x15, 0x00,
        0x25, 0x01, 0x35, 0x00, 0x45, 0x01, 0x66, 0x00,
        0x00, 0x75, 0x01, 0x95, 0x0a, 0x19, 0x01, 0x29,
        0x0a, 0x81, 0x02, 0x06, 0x00, 0xff, 0x15, 0x00,
        0x25, 0x01, 0x35, 0x00, 0x45, 0x01, 0x66, 0x00,
        0x00, 0x75, 0x01, 0x95, 0x04, 0x19, 0x01, 0x29,
        0x04, 0x81, 0x02, 0x75, 0x01, 0x95, 0x02, 0x81,
        0x01, 0xc0
    };

    UCHAR yard2[236] = {
        0x05, 0x80,                    // USAGE_PAGE (Monitor)
        0x09, 0x01,                    // USAGE (Monitor Control)
        0xa1, 0x01,                    // COLLECTION (Application)
        0x85, 0x01,                    //   REPORT_ID (1)
        0x75, 0x08,                    //   REPORT_SIZE (8)
        0x95, 0x80,                    //   REPORT_COUNT (128)
        0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
        0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
        0x09, 0x02,                    //   USAGE (EDID Information)
        0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)
        0x85, 0x02,                    //   REPORT_ID (2)
        0x75, 0x10,                    //   REPORT_SIZE (16)
        0x95, 0x01,                    //   REPORT_COUNT (1)
        0x27, 0xff, 0xff, 0x00, 0x00,  //   LOGICAL_MAXIMUM (65535)
        0x09, 0x04,                    //   USAGE (VESA Version)
        0xb1, 0x02,                    //   FEATURE (Data,Var,Abs)
        0x85, 0x03,                    //   REPORT_ID (3)
        0x09, 0x09,                    //   USAGE (Sync Type)
        0xa1, 0x02,                    //   COLLECTION (Logical)
        0x05, 0x81,                    //     USAGE_PAGE (Monitor Enumerated Values)
        0x09, 0x01,                    //     USAGE (ENUM 0)
        0x09, 0x02,                    //     USAGE (ENUM 1)
        0x09, 0x03,                    //     USAGE (ENUM 2)
        0x75, 0x08,                    //     REPORT_SIZE (8)
        0x95, 0x01,                    //     REPORT_COUNT (1)
        0x25, 0x02,                    //     LOGICAL_MAXIMUM (2)
        0xb1, 0x40,                    //     FEATURE (Data,Ary,Abs,Null)
        0xc0,                          //   END_COLLECTION
        0x85, 0x04,                    //   REPORT_ID (4)
        0x05, 0x82,                    //   USAGE_PAGE (VESA Virtual Controls)
        0x09, 0x20,                    //   USAGE (Horizontal Position )
        0x09, 0x22,                    //   USAGE (Horizontal Size )
        0x09, 0x30,                    //   USAGE (Vertical Position )
        0x09, 0x32,                    //   USAGE (Vertical Size )
        0x09, 0x24,                    //   USAGE (Horizontal Pincushion )
        0x75, 0x08,                    //   REPORT_SIZE (8)
        0x95, 0x05,                    //   REPORT_COUNT (5)
        0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
        0xb1, 0x22,                    //   FEATURE (Data,Var,Abs,NPrf)
        0x09, 0x20,                    //   USAGE (Horizontal Position )
        0x09, 0x22,                    //   USAGE (Horizontal Size )
        0x09, 0x30,                    //   USAGE (Vertical Position )
        0x09, 0x32,                    //   USAGE (Vertical Size )
        0x09, 0x24,                    //   USAGE (Horizontal Pincushion )
        0x81, 0x22,                    //   INPUT (Data,Var,Abs,NPrf)
        0x85, 0x05,                    //   REPORT_ID (5)
        0x09, 0x26,                    //   USAGE (Horizontal Pincushion Balance )
        0x09, 0x3a,                    //   USAGE (Vertical Linearity )
        0x09, 0x40,                    //   USAGE (Parallelogram Distortion)
        0x09, 0x42,                    //   USAGE (Trapezoidal Distortion)
        0x09, 0x44,                    //   USAGE (Tilt)
        0x95, 0x05,                    //   REPORT_COUNT (5)
        0xb1, 0x22,                    //   FEATURE (Data,Var,Abs,NPrf)
        0x09, 0x26,                    //   USAGE (Horizontal Pincushion Balance )
        0x09, 0x3a,                    //   USAGE (Vertical Linearity )
        0x09, 0x40,                    //   USAGE (Parallelogram Distortion)
        0x09, 0x42,                    //   USAGE (Trapezoidal Distortion)
        0x09, 0x44,                    //   USAGE (Tilt)
        0x81, 0x22,                    //   INPUT (Data,Var,Abs,NPrf)
        0x85, 0x06,                    //   REPORT_ID (6)
        0x09, 0x10,                    //   USAGE (Brightness)
        0x09, 0x12,                    //   USAGE (Contrast)
        0x09, 0x16,                    //   USAGE (Video Gain Red)
        0x09, 0x18,                    //   USAGE (Video Gain Green)
        0x09, 0x1a,                    //   USAGE (Video Gain Blue)
        0x95, 0x05,                    //   REPORT_COUNT (5)
        0xb1, 0x22,                    //   FEATURE (Data,Var,Abs,NPrf)
        0x09, 0x10,                    //   USAGE (Brightness)
        0x09, 0x12,                    //   USAGE (Contrast)
        0x09, 0x16,                    //   USAGE (Video Gain Red)
        0x09, 0x18,                    //   USAGE (Video Gain Green)
        0x09, 0x1a,                    //   USAGE (Video Gain Blue)
        0x81, 0x22,                    //   INPUT (Data,Var,Abs,NPrf)
        0x85, 0x07,                    //   REPORT_ID (7)
        0x09, 0x6c,                    //   USAGE (Video Black Level Red)
        0x09, 0x6e,                    //   USAGE (Video Black Level Green)
        0x09, 0x70,                    //   USAGE (Video Black Level Blue)
        0x95, 0x03,                    //   REPORT_COUNT (3)
        0xb1, 0x22,                    //   FEATURE (Data,Var,Abs,NPrf)
        0x09, 0x6c,                    //   USAGE (Video Black Level Red)
        0x09, 0x6e,                    //   USAGE (Video Black Level Green)
        0x09, 0x70,                    //   USAGE (Video Black Level Blue)
        0x81, 0x22,                    //   INPUT (Data,Var,Abs,NPrf)
        0x85, 0x08,                    //   REPORT_ID (8)
        0x09, 0x5e,                    //   USAGE (Input Level Select)
        0xa1, 0x02,                    //   COLLECTION (Logical)
        0x05, 0x81,                    //     USAGE_PAGE (Monitor Enumerated Values)
        0x09, 0x02,                    //     USAGE (ENUM 1)
        0x09, 0x03,                    //     USAGE (ENUM 2)
        0x09, 0x04,                    //     USAGE (ENUM 3)
        0x09, 0x05,                    //     USAGE (ENUM 4)
        0x75, 0x08,                    //     REPORT_SIZE (8)
        0x95, 0x01,                    //     REPORT_COUNT (1)
        0x25, 0x04,                    //     LOGICAL_MAXIMUM (4)
        0xb1, 0x40,                    //     FEATURE (Data,Ary,Abs,Null)
        0xc0,                          //   END_COLLECTION
        0x09, 0x60,                    //   USAGE (ENUM 95)
        0xa1, 0x02,                    //   COLLECTION (Logical)
        0x05, 0x81,                    //     USAGE_PAGE (Monitor Enumerated Values)
        0x09, 0x01,                    //     USAGE (ENUM 0)
        0x09, 0x02,                    //     USAGE (ENUM 1)
        0x09, 0x04,                    //     USAGE (ENUM 3)
        0x75, 0x08,                    //     REPORT_SIZE (8)
        0x25, 0x06,                    //     LOGICAL_MAXIMUM (6)
        0xb1, 0x40,                    //     FEATURE (Data,Ary,Abs,Null)
        0xc0,                          //   END_COLLECTION
        0x85, 0x09,                    //   REPORT_ID (9)
        0x05, 0x83,                    //   USAGE_PAGE (VESA Command)
        0x09, 0x00,                    //   USAGE (Undefined)
        0x75, 0x08,                    //   REPORT_SIZE (8)
        0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
        0x91, 0x02,                    //   OUTPUT (Data,Var,Abs)
        0x09, 0x01,                    //   USAGE (Settings)
        0x75, 0x08,                    //   REPORT_SIZE (8)
        0x25, 0x03,                    //   LOGICAL_MAXIMUM (3)
        0x91, 0x02,                    //   OUTPUT (Data,Var,Abs)
        0xc0                           // END_COLLECTION
    };


    UCHAR anotherDescriptorWhichBreaksTheParser [] = {
        0x09, 0x02,                    // USAGE (PresentStatus)
        0xa1, 0x02,                    // COLLECTION (Logical)
        0x05, 0x85,                    // USAGE_PAGE (Battery System)
        0x09, 0xd0,                    // USAGE (ACPresent)
        0x09, 0x42,                    // USAGE (BelowRemainingCapacityLimit)
        0x09, 0x44,                    // USAGE (Charging)
        0x09, 0x45,                    // USAGE (Discharging)
        0x0b, 0x69, 0x00, 0x84, 0x00,  // USAGE (Power Device:ShutdownImminent)
        0x0b, 0x65, 0x00, 0x84, 0x00,  // USAGE (Power Device:Overload)
        0x0b, 0x00, 0x00, 0x84, 0x00,  // USAGE (Power Device:Undefined)
        0x0b, 0x00, 0x00, 0x84, 0x00,  // USAGE (Power Device:Undefined)
        0x75, 0x01,                    // REPORT_SIZE (1)
        0x95, 0x08,                    // REPORT_COUNT (8)
        0x25, 0x01,                    // LOGICAL_MAXIMUM (1)
        0x81, 0x83,                    // INPUT (Cnst,Var,Abs,Vol)
        0xc0
    };

    UCHAR   afd [] = {
        0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
        0x09, 0x02,                    // USAGE (Mouse)
        0xa1, 0x01,                    // COLLECTION (Application)
        0x09, 0x01,                    //   USAGE (Pointer)
        0xa1, 0x00,                    //   COLLECTION (Physical)
        0x05, 0x09,                    //     USAGE_PAGE (Button)
        0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
        0x29, 0x03,                    //     USAGE_MAXIMUM (Button 3)
        0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
        0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
        0x95, 0x03,                    //     REPORT_COUNT (3)
        0x75, 0x01,                    //     REPORT_SIZE (1)
        0x81, 0x02,                    //     INPUT (Data,Var,Abs)
        0x95, 0x01,                    //     REPORT_COUNT (1)
        0x75, 0x05,                    //     REPORT_SIZE (5)
        0x81, 0x01,                    //     INPUT (Cnst,Ary,Abs)
        0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
        0x09, 0x30,                    //     USAGE (X)
        0x09, 0x31,                    //     USAGE (Y)
        0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
        0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
        0x75, 0x08,                    //     REPORT_SIZE (8)
        0x95, 0x02,                    //     REPORT_COUNT (2)
        0x81, 0x06,                    //     INPUT (Data,Var,Rel)
        0xc0,                          //   END_COLLECTION
        0xc0                           // END_COLLECTION
    };

    UCHAR   afd2 [] = {
        0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
        0x09, 0x01,                    // USAGE (Pointer)
        0xa1, 0x01,                    // COLLECTION (Application)
        0x05, 0x01,                    //   USAGE_PAGE (Generic Desktop)
        0x09, 0x01,                    //   USAGE (Pointer)
        0xa1, 0x00,                    //   COLLECTION (Physical)
        0x09, 0x00,                    //     USAGE (Undefined)
        0x75, 0x08,                    //     REPORT_SIZE (8)
        0x95, 0x01,                    //     REPORT_COUNT (1)
        0x81, 0x01,                    //     INPUT (Cnst,Ary,Abs)
        0x05, 0x09,                    //     USAGE_PAGE (Button)
        0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
        0x29, 0x01,                    //     USAGE_MAXIMUM (Button 1)
        0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
        0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
        0x35, 0x00,                    //     PHYSICAL_MINIMUM (0)
        0x45, 0x01,                    //     PHYSICAL_MAXIMUM (1)
        0x66, 0x00, 0x00,              //     UNIT (None)
        0x75, 0x01,                    //     REPORT_SIZE (1)
        0x95, 0x01,                    //     REPORT_COUNT (1)
        0x81, 0x62,                    //     INPUT (Data,Var,Abs,NPrf,Null)
        0x75, 0x01,                    //     REPORT_SIZE (1)
        0x95, 0x07,                    //     REPORT_COUNT (7)
        0x81, 0x01,                    //     INPUT (Cnst,Ary,Abs)
        0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
        0x09, 0x30,                    //     USAGE (X)
        0x09, 0x31,                    //     USAGE (Y)
        0x16, 0x00, 0x00,              //     LOGICAL_MINIMUM (0)
        0x26, 0x00, 0x10,              //     LOGICAL_MAXIMUM (4096)
        0x36, 0x00, 0x00,              //     PHYSICAL_MINIMUM (0)
        0x46, 0xff, 0x7f,              //     PHYSICAL_MAXIMUM (32767)
        0x66, 0x00, 0x00,              //     UNIT (None)
        0x75, 0x10,                    //     REPORT_SIZE (16)
        0x95, 0x02,                    //     REPORT_COUNT (2)
        0x81, 0x62,                    //     INPUT (Data,Var,Abs,NPrf,Null)
        0x09, 0x3b,                    //     USAGE (Byte Count)
        0x16, 0x00, 0x00,              //     LOGICAL_MINIMUM (0)
        0x26, 0x00, 0x01,              //     LOGICAL_MAXIMUM (256)
        0x36, 0x00, 0x00,              //     PHYSICAL_MINIMUM (0)
        0x46, 0x00, 0x01,              //     PHYSICAL_MAXIMUM (256)
        0x66, 0x00, 0x00,              //     UNIT (None)
        0x75, 0x10,                    //     REPORT_SIZE (16)
        0x95, 0x01,                    //     REPORT_COUNT (1)
        0x81, 0x62,                    //     INPUT (Data,Var,Abs,NPrf,Null)
        0xc0,                          //   END_COLLECTION
        0xc0                           // END_COLLECTION
    };

    UCHAR adwbtp2 [] = {
        0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
        0x09, 0x06,                    // USAGE (Keyboard)
        0xa1, 0x01,                    // COLLECTION (Application)
        0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
        0x19, 0xe0,                    //   USAGE_MINIMUM (Keyboard LeftControl)
        0x29, 0xe7,                    //   USAGE_MAXIMUM (Keyboard Right GUI)
        0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
        0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
        0x75, 0x01,                    //   REPORT_SIZE (1)
        0x95, 0x08,                    //   REPORT_COUNT (8)
        0x81, 0x02,                    //   INPUT (Data,Var,Abs)
        0x75, 0x08,                    //   REPORT_SIZE (8)
        0x95, 0x01,                    //   REPORT_COUNT (1)
        0x81, 0x01,                    //   INPUT (Cnst,Ary,Abs)
        0x95, 0x05,                    //   REPORT_COUNT (5)
        0x75, 0x01,                    //   REPORT_SIZE (1)
        0x05, 0x08,                    //   USAGE_PAGE (LEDs)
        0x19, 0x01,                    //   USAGE_MINIMUM (Num Lock)
        0x29, 0x03,                    //   USAGE_MAXIMUM (Scroll Lock)
        0x29, 0x03,                    //   USAGE_MAXIMUM (Scroll Lock)
        0x91, 0x02,                    //   OUTPUT (Data,Var,Abs)
        0x95, 0x01,                    //   REPORT_COUNT (1)
        0x75, 0x03,                    //   REPORT_SIZE (3)
        0x75, 0x03,                    //   REPORT_SIZE (3)
        0x91, 0x01,                    //   OUTPUT (Cnst,Ary,Abs)
        0x95, 0x06,                    //   REPORT_COUNT (6)
        0x75, 0x08,                    //   REPORT_SIZE (8)
        0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
        0x25, 0x65,                    //   LOGICAL_MAXIMUM (101)
        0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
        0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))
        0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)
        0x81, 0x00,                    //   INPUT (Data,Ary,Abs)
        0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
        0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))
        0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)
        0xc0                           // END_COLLECTION
    };


    UCHAR vendorDescriptorsSometimeRequireSpecialCode[] = {
        0x05, 0x01, 0x09, 0x04,
        0xA1, 0x01, 0x85, 0x01,
        0x09, 0x01, 0xA1, 0x00,
        0x95, 0x01, 0x75, 0x04,
        0x15, 0x00, 0x25, 0x07,
        0x35, 0x00, 0x46, 0x3B,
        0x01, 0x66, 0x14, 0x00,
        0x09, 0x39, 0x81, 0x42,
        0x95, 0x04, 0x75, 0x01,
        0x15, 0x00, 0x25, 0x01,
        0x35, 0x00, 0x45, 0x01,
        0x66, 0x00, 0x00, 0x05,
        0x09, 0x19, 0x01, 0x29,
        0x04, 0xA4, 0x81, 0x02,
        0x95, 0x02, 0x75, 0x0A,
        0x16, 0x00, 0xFE, 0x26,
        0xFF, 0x01, 0x35, 0x00,
        0x46, 0xFF, 0x03, 0x05,
        0x01, 0x09, 0x30, 0x09,
        0x31, 0x81, 0x02, 0x95,
        0x04, 0x75, 0x01, 0x81,
        0x01, 0xC0, 0xB4, 0x05,
        0x09, 0x95, 0x07, 0x19,
        0x05, 0x29, 0x0B, 0x81,
        0x02, 0x95, 0x01, 0x81,
        0x01, 0x75, 0x06, 0x15,
        0xE0, 0x25, 0x1F, 0x35,
        0x00, 0x45, 0x3F, 0x05,
        0x01, 0x09, 0x36, 0x81,
        0x02, 0x06, 0x01, 0xFF,
        0x0A, 0x01, 0x00, 0x75,
        0x02, 0x81, 0x02, 0xC0
    };

    UCHAR ReportDescriptor[] = {
        0x05, 0x84,                    // USAGE_PAGE (Power Device)
        0x09, 0x04,                    // USAGE (UPS)
        0xa1, 0x01,                    // COLLECTION (Application)
        0x05, 0x84,                    //   USAGE_PAGE (Power Device)
        0x09, 0x24,                    //   USAGE (PowerSummary)
        0xa1, 0x00,                    //   COLLECTION (Physical)
        0x05, 0x85,                    //     USAGE_PAGE (Battery System)
        0x85, 0x01,                    //     REPORT_ID (1)
        0x67, 0x01, 0x10, 0x10, 0x00,  //     UNIT (SI Lin:Battery Capacity)
        0x95, 0x03,                    //     REPORT_COUNT (1)
        0x75, 0x03,                    //     REPORT_SIZE (1)
        0x09, 0x65,                    //     USAGE
        0xb1, 0x02,                    //     FEATURE (Data,Var,Abs)
        0x09, 0x66,                    //     USAGE (RemainingCapacity)
        0x95, 0x01,                    //     REPORT_COUNT (1)
        0x75, 0x18,                    //     REPORT_SIZE (24)
        0xb1, 0x02,                    //     FEATURE (Data,Var,Abs)
        0x09, 0x67,                    //     USAGE
        0x75, 0x07,                    //     REPORT_SIZE (7)
        0xb1, 0x02,                    //     FEATURE (Data,Var,Abs)
        0x09, 0x68,                    //     USAGE
        0x75, 0x18,                    //     REPORT_SIZE (24)
        0xb1, 0x02,                    //     FEATURE (Data,Var,Abs)
        0xc0,                          //   END_COLLECTION
        0xc0                           // END_COLLECTION
    };

    UCHAR   Rd[] = {
        0x05, 0x01,  // USAGE_PAGE (Generic Desktop)    05 01
        0x09, 0x06, // USAGE (Keyboard)
        0xA1, 0x01, // COLLECTION (Application)
        0x09, 0x30, // USAGE (X)
        0x75, 0x08, // REPORT_SIZE (8)
        0x95, 0x01, // REPORT_COUNT (1)
        0x82, 0x02, 0x01, // INPUT (Data,Var,Abs,Buf)
        0x09, 0x31, // USAGE (Y)
        0x95, 0x02, // REPORT_COUNT (2)
        0x82, 0x02, 0x01, // INPUT (Data,Var,Abs,Buf)
        0x09, 0x32, // USAGE (Z)
        0x09, 0x38, // USAGE (Wheel)
        0x82, 0x02, 0x01, // INPUT (Data,Var,Abs,Buf)
        0x19, 0x33, // USAGE Min (Rx)
        0x29, 0x34, // USAGE Max (Ry)
        0x95, 0x04, // REPORT_COUNT (4)
        0x82, 0x02, 0x01, // INPUT (Data,Var,Abs,Buf)
        0x09, 0x35, // USAGE (Rz)
        0x09, 0x36, // USAGE (Slider)
        0x75, 0x07, // REPORT_SIZE (7)
        0x95, 0x04, // REPORT_COUNT (4)
        0x81, 0x02, // INPUT (Data,Var,Abs)
        0x95, 0x01, // REPORT_COUNT (1)
        0x75, 0x04, // REPORT_SIZE (4)
        0x81, 0x01, // INPUT (Cnst,Ary,Abs)
        0xC0 // END_COLLECTION
    };

    UCHAR Rd2 [50] = {
        0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
        0x09, 0x02,                    // USAGE (Mouse)
        0xa1, 0x01,                    // COLLECTION (Application)
        0x85, 0x01,                    //   REPORT_ID (1)
        0x75, 0x0F,                    //   REPORT_SIZE (16)
        0x95, 0x01,                    //   REPORT_COUNT (1)
        0x15, 0x0b,                    //   LOGICAL_MINIMUM (11)
        0x25, 0x1c,                    //   LOGICAL_MAXIMUM (28)
        0x09, 0x30,                    //   USAGE (X)
        0x81, 0x22,                    //   INPUT (Data,Var,Abs,NPrf)
        0x85, 0x02,                    //   REPORT_ID (2)
        0x09, 0x32,                    //   USAGE (Z)
        0x75, 0x08,                    //   REPORT_SIZE (8)
        0x95, 0x01,                    //   REPORT_COUNT (1)
        0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
        0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
        0x81, 0x02,                    //   INPUT (Data,Var,Abs)
        0x85, 0x01,                    //   REPORT_ID (1)
        0x75, 0x09,                    //   REPORT_SIZE (8)
        0x95, 0x01,                    //   REPORT_COUNT (1)
        0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
        0x25, 0x03,                    //   LOGICAL_MAXIMUM (3)
        0x09, 0x31,                    //   USAGE (Y)
        0x81, 0x22,                    //   INPUT (Data,Var,Abs,NPrf)
        0xc0                           // END_COLLECTION
    };

    UCHAR Rd3[40] = {
        0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
        0x09, 0x02,                    // USAGE (Mouse)
        0xa1, 0x01,                    // COLLECTION (Application)
        0x85, 0x01,                    //   REPORT_ID (1)
        0x75, 0x10,                    //   REPORT_SIZE (16)
        0x95, 0x01,                    //   REPORT_COUNT (1)
        0x15, 0x0b,                    //   LOGICAL_MINIMUM (11)
        0x25, 0x1c,                    //   LOGICAL_MAXIMUM (28)
        0x09, 0x30,                    //   USAGE (X)
        0x81, 0x22,                    //   INPUT (Data,Var,Abs,NPrf)
        0xc0,                          // END_COLLECTION
        0x09, 0x06,                    // USAGE (Keyboard)
        0xa1, 0x01,                    // COLLECTION (Application)
        0x85, 0x01,                    //   REPORT_ID (1)
        0x75, 0x08,                    //   REPORT_SIZE (8)
        0x95, 0x01,                    //   REPORT_COUNT (1)
        0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
        0x25, 0x40,                    //   LOGICAL_MAXIMUM (64)
        0x09, 0x31,                    //   USAGE (Y)
        0x81, 0x02,                    //   INPUT (Data,Var,Abs)
        0xc0                           // END_COLLECTION
    };


    UCHAR Rd4[] = {
        0x05, 0x01, 0x09, 0x02, 0xa1, 0x01, 0x85, 0x01,
        0x09, 0x01, 0xa1, 0x00, 0x05, 0x09, 0x19, 0x01,
        0x29, 0x03, 0x15, 0x00, 0x25, 0x01, 0x95, 0x03,
        0x75, 0x01, 0x81, 0x02, 0x95, 0x01, 0x75, 0x05,
        0x81, 0x01, 0x05, 0x01, 0x09, 0x30, 0x09, 0x31,
        0x15, 0x81, 0x25, 0x7f, 0x75, 0x08, 0x95, 0x02,
        0x81, 0x06, 0xc0, 0xc0, 0x05, 0x01, 0x09, 0x80,
        0xa1, 0x01, 0x85, 0x02, 0x19, 0x81, 0x29, 0x83,
        0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 0x03,
        0x81, 0x06, 0x95, 0x05, 0x81, 0x01, 0x75, 0x08,
        0x95, 0x02, 0x81, 0x01, 0xc0, 0x05, 0x0c, 0x09,
        0x01, 0xa1, 0x01, 0x85, 0x03, 0x09, 0xcd, 0x09,
        0xb7, 0x09, 0xb5, 0x09, 0xb6, 0x0a, 0x23, 0x02,
        0x0a, 0x8a, 0x01, 0x15, 0x00, 0x25, 0x01, 0x75,
        0x01, 0x95, 0x06, 0x81, 0x06, 0x75, 0x01, 0x95,
        0x02, 0x81, 0x01, 0x09, 0xe2, 0x09, 0xe9, 0x09,
        0xea, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95,
        0x03, 0x81, 0x06, 0x75, 0x01, 0x95, 0x05, 0x81,
        0x01, 0x75, 0x08, 0x95, 0x01, 0x81, 0x01, 0xc0,
        0x06, 0x46, 0xff, 0x09, 0x04, 0xa1, 0x01, 0x85,
        0x04,
        0x09, 0xcd, // here we have 6 usages in a row.
        0x09, 0xb7,
        0x09, 0xb5,
        0x09, 0xb6,
        0x0a, 0x23, 0x02,
        0x0a, 0x8a, 0x01,
        0x15, 0x00, 0x25, 0x01,
        0x75, 0x01, 0x95, 0x06,
        0x81, 0x06, // here we have a main item of count 6 that uses them all up.

        0x75, 0x01, 0x95, 0x02, 0x81, 0x01, // here we have a constant input item with no usages.
        0x75, 0x08, 0x95, 0x02, 0x81, 0x01, // here we have another constant input item with no usages; then usage min 0, max FF,
        0x19, 0x00, 0x29, 0xff, // usage Min 00, Max FF
        0x15, 0x81, 0x25, 0x7f, // logical min -127, max 127
        0x75, 0x08, 0x95, 0x01, // size 8, count 1
        0xb1, 0x02, 0xc0 // finally a feature item.
    };

    UCHAR Rd5[] = {
        0x05, 0x01, 0x09, 0x06, 0xA1, 0x01, // Top level collection
        0x05, 0x07, 0x19, 0xE0, 0x29, 0xE7, // Page 5, Min e0, max e7
        0x15, 0x00, 0x25, 0x01, // log min/max
        0x75, 0x01, 0x95, 0x08, 0x81, 0x02, // size 1, Count 8, MAIN
        0x75, 0x08, 0x95, 0x01, 0x81, 0x01, // size 8, Count 1, MAIN Cnst.
        0x95, 0x05, 0x75, 0x01, // Count 5, size 1
        0x05, 0x08, 0x19, 0x01, 0x29, 0x03, 0x29, 0x03, // Page 5, Min 1, Max 3
                                                        // max 3, A 2ND Mi/Ma!
        0x91, 0x02, // Output
        0x95, 0x01, 0x75, 0x03, 0x75, 0x03, // Count 1, Size 3
        0x91, 0x01, // Output Cnst.
        0x95, 0x06, 0x75, 0x08, // Count 6, Size 8
        0x15, 0x00, 0x25, 0x65, // log min/max
        0x05, 0x07, 0x19, 0x00, 0x29, 0x65, // Page 7, min 0, max 65
        0x81, 0x00, // Array
        0xC0
    };

    UCHAR Rd6[] = {
        0x05, 0x01, 0x09, 0x06, 0xA1, 0x01, // Top level Collection
        0x05, 0x07, 0x19, 0xE0, 0x29, 0xE7, // Page 5, Min e0, max e7
        0x15, 0x00, 0x25, 0x01, // log min/max
        0x75, 0x01, 0x95, 0x08, 0x81, 0x02, // size 1, Cnt 8, MAIN
        0x95, 0x01, 0x75, 0x08, 0x81, 0x01, // size 8, Cnt 1, MAIN
        0x95, 0x05, 0x75, 0x01, // Count 5, size 1
        0x05, 0x08, 0x19, 0x01, 0x29, 0x03, // page 5, min 1, max 3, NO DOUBLE
        0x91, 0x02, // output
        0x95, 0x01, 0x75, 0x03, // Count 1, Size 3
        0x91, 0x01, // output cnst.
        0x95, 0x06, 0x75, 0x08, // Count 6, Size 8
        0x15, 0x00, 0x25, 0x65, //log min/max
        0x05, 0x07, 0x19, 0x00, 0x29, 0x65, // Page 7, min 0 max 65
        0x81, 0x00, // Array
        0xC0
    };

    UCHAR Rd7[] = {
        0x05, 0x03, 0x09, 0x03, 0xa1, 0x01, 0x05, 0x01,
        0x0a, 0xc8, 0x60, 0x05, 0x03, 0x0a, 0x6a, 0x32,
        0x85, 0x2d, 0x16, 0xcb, 0x24, 0x26, 0xae, 0x2e,
        0x75, 0x0e, 0x95, 0x05, 0x91, 0x22, 0x05, 0x02,
        0x1a, 0xfe, 0x31, 0x2a, 0x01, 0x32, 0x85, 0x2d,
        0x16, 0x6b, 0xff, 0x25, 0x62, 0x75, 0x09, 0x95,
        0x05, 0x81, 0x22, 0x05, 0x01, 0x0a, 0x86, 0x2c,
        0x85, 0x2d, 0x16, 0x5c, 0xfd, 0x26, 0xf5, 0x02,
        0x75, 0x0c, 0x95, 0x07, 0x91, 0x22, 0x05, 0x03,
        0x0a, 0xff, 0x52, 0x05, 0x02, 0x0a, 0x60, 0x62,
        0x85, 0x2d, 0x15, 0xe9, 0x25, 0x16, 0x75, 0x06,
        0x95, 0x10, 0xb1, 0x22, 0x05, 0x01, 0x0a, 0xf8,
        0x5d, 0x05, 0x02, 0x1a, 0xc4, 0x69, 0x2a, 0xc7,
        0x69, 0x05, 0x01, 0x0a, 0x65, 0x34, 0x05, 0x03,
        0x0a, 0x22, 0x6d, 0x05, 0x01, 0x0a, 0x01, 0x3a,
        0x05, 0x03, 0x0a, 0x04, 0x24, 0x05, 0x01, 0x0a,
        0xa9, 0x69, 0x85, 0x2d, 0x16, 0x39, 0xf1, 0x26,
        0x48, 0x04, 0x75, 0x0e, 0x95, 0x0d, 0x81, 0x22,
        0x05, 0x01, 0x0a, 0xbc, 0x33, 0x05, 0x03, 0x1a,
        0x35, 0x1e, 0x2a, 0x36, 0x1e, 0x85, 0x2d, 0x15,
        0x03, 0x25, 0x07, 0x75, 0x03, 0x95, 0x0e, 0x81,
        0x22, 0x75, 0x03, 0x95, 0x01, 0x85, 0x2d, 0x81,
        0x01, 0x75, 0x06, 0x95, 0x01, 0x85, 0x2d, 0x91,
        0x01, 0xc0, 0x05, 0x01, 0x09, 0x03, 0xa1, 0x01,
        0x05, 0x01, 0x1a, 0xe6, 0x79, 0x2a, 0xe9, 0x79,
        0x05, 0x01, 0x0a, 0x23, 0x67, 0x05, 0x03, 0x1a,
        0x86, 0x03, 0x2a, 0x87, 0x03, 0x05, 0x03, 0x1a,
        0x21, 0x25, 0x2a, 0x23, 0x25, 0x85, 0x75, 0x16,
        0x09, 0x02, 0x26, 0x0b, 0x35, 0x75, 0x0e, 0x95,
        0x0a, 0x81, 0x22, 0x05, 0x01, 0x0a, 0x80, 0x11,
        0x05, 0x02, 0x0a, 0x32, 0x1b, 0x05, 0x02, 0x0a,
        0x7f, 0x61, 0x85, 0x75, 0x16, 0x92, 0x0e, 0x26,
        0x26, 0x0f, 0x75, 0x0c, 0x95, 0x03, 0xb1, 0x22,
        0x05, 0x02, 0x0a, 0xe1, 0x10, 0x05, 0x01, 0x0a,
        0xce, 0x61, 0x05, 0x01, 0x0a, 0xf2, 0x20, 0x05,
        0x03, 0x1a, 0x63, 0x6d, 0x2a, 0x65, 0x6d, 0x05,
        0x01, 0x0a, 0x3b, 0x17, 0x85, 0x75, 0x16, 0x66,
        0x02, 0x26, 0x00, 0x04, 0x75, 0x0b, 0x95, 0x0b,
        0x91, 0x22, 0x05, 0x03, 0x1a, 0xd1, 0x74, 0x2a,
        0xd5, 0x74, 0x05, 0x02, 0x0a, 0xbd, 0x5e, 0x05,
        0x02, 0x0a, 0x1a, 0x4f, 0x05, 0x02, 0x0a, 0x43,
        0x31, 0x85, 0x75, 0x16, 0xfc, 0x14, 0x26, 0xc9,
        0x33, 0x75, 0x0f, 0x95, 0x0f, 0x81, 0x22, 0x05,
        0x03, 0x1a, 0x18, 0x0b, 0x2a, 0x19, 0x0b, 0x05,
        0x03, 0x0a, 0xb6, 0x5b, 0x05, 0x01, 0x0a, 0x3f,
        0x4b, 0x05, 0x02, 0x0a, 0xa5, 0x21, 0x05, 0x02,
        0x0a, 0x3b, 0x55, 0x05, 0x02, 0x1a, 0x2f, 0x0b,
        0x2a, 0x31, 0x0b, 0x05, 0x03, 0x1a, 0x9a, 0x0a,
        0x2a, 0x9d, 0x0a, 0x85, 0x75, 0x16, 0xb6, 0x01,
        0x26, 0x12, 0x02, 0x75, 0x0d, 0x95, 0x0d, 0x81,
        0x22, 0x05, 0x01, 0x1a, 0xcb, 0x7a, 0x2a, 0xcc,
        0x7a, 0x85, 0x75, 0x15, 0x07, 0x25, 0x08, 0x75,
        0x05, 0x95, 0x03, 0x81, 0x22, 0x05, 0x03, 0x0a,
        0x24, 0x6e, 0x05, 0x03, 0x1a, 0xb0, 0x77, 0x2a,
        0xb2, 0x77, 0x85, 0x75, 0x16, 0xc5, 0xed, 0x26,
        0x7b, 0x5d, 0x75, 0x10, 0x95, 0x0f, 0x91, 0x22,
        0x05, 0x02, 0x1a, 0x6e, 0x1e, 0x2a, 0x71, 0x1e,
        0x05, 0x03, 0x1a, 0x83, 0x3d, 0x2a, 0x84, 0x3d,
        0x05, 0x02, 0x1a, 0x13, 0x5d, 0x2a, 0x14, 0x5d,
        0x85, 0x75, 0x15, 0x13, 0x25, 0x17, 0x75, 0x06,
        0x95, 0x0d, 0x91, 0x22, 0x05, 0x02, 0x1a, 0x68,
        0x5d, 0x2a, 0x6a, 0x5d, 0x05, 0x03, 0x1a, 0x2f,
        0x21, 0x2a, 0x30, 0x21, 0x05, 0x02, 0x0a, 0xbd,
        0x04, 0x85, 0x75, 0x16, 0x5c, 0x14, 0x26, 0x43,
        0x19, 0x75, 0x0d, 0x95, 0x08, 0xb1, 0x22, 0x05,
        0x01, 0x0a, 0xf1, 0x57, 0x05, 0x02, 0x1a, 0x00,
        0x64, 0x2a, 0x09, 0x64, 0x05, 0x03, 0x1a, 0x43,
        0x30, 0x2a, 0x46, 0x30, 0x85, 0x75, 0x15, 0xd4,
        0x25, 0x37, 0x75, 0x07, 0x95, 0x10, 0x81, 0x22,
        0x75, 0x03, 0x95, 0x01, 0x85, 0x75, 0x81, 0x01,
        0x75, 0x01, 0x95, 0x01, 0x85, 0x75, 0x91, 0x01,
        0x75, 0x04, 0x95, 0x01, 0x85, 0x75, 0xb1, 0x01,
        0xc0, 0x05, 0x02, 0x09, 0x03, 0xa1, 0x01, 0x05,
        0x03, 0x1a, 0xbc, 0x47, 0x2a, 0xc0, 0x47, 0x85,
        0x86, 0x16, 0x69, 0xfd, 0x26, 0xc0, 0x02, 0x75,
        0x0b, 0x95, 0x06, 0xb1, 0x22, 0x75, 0x06, 0x95,
        0x01, 0x85, 0x86, 0xb1, 0x01, 0xc0, 0x05, 0x01,
        0x09, 0x01, 0xa1, 0x01, 0x05, 0x01, 0x1a, 0x57,
        0x52, 0x2a, 0x58, 0x52, 0x85, 0x6c, 0x16, 0x46,
        0x1c, 0x26, 0xbd, 0x1c, 0x75, 0x0e, 0x95, 0x03,
        0xb1, 0x22, 0x05, 0x02, 0x0a, 0xbd, 0x43, 0x05,
        0x02, 0x0a, 0x3c, 0x4e, 0x05, 0x03, 0x1a, 0x2a,
        0x20, 0x2a, 0x2b, 0x20, 0x05, 0x02, 0x1a, 0xd7,
        0x0b, 0x2a, 0xd9, 0x0b, 0x85, 0x6c, 0x15, 0x05,
        0x25, 0x07, 0x75, 0x03, 0x95, 0x07, 0x91, 0x22,
        0x05, 0x01, 0x0a, 0x1f, 0x77, 0x05, 0x03, 0x0a,
        0x20, 0x30, 0x85, 0x6c, 0x15, 0x08, 0x25, 0x0c,
        0x75, 0x05, 0x95, 0x04, 0xb1, 0x22, 0x05, 0x01,
        0x1a, 0xa8, 0x53, 0x2a, 0xa9, 0x53, 0x05, 0x01,
        0x0a, 0x7c, 0x5d, 0x05, 0x02, 0x0a, 0x7b, 0x4c,
        0x85, 0x6c, 0x15, 0x67, 0x25, 0x6f, 0x75, 0x08,
        0x95, 0x0f, 0x81, 0x22, 0x05, 0x03, 0x0a, 0xde,
        0x64, 0x85, 0x6c, 0x15, 0xbe, 0x25, 0xfb, 0x75,
        0x08, 0x95, 0x05, 0x91, 0x22, 0x05, 0x03, 0x1a,
        0xf5, 0x69, 0x2a, 0xf6, 0x69, 0x85, 0x6c, 0x15,
        0xee, 0x25, 0xf4, 0x75, 0x08, 0x95, 0x04, 0x91,
        0x22, 0x05, 0x02, 0x0a, 0x60, 0x24, 0x05, 0x03,
        0x1a, 0xcc, 0x6e, 0x2a, 0xcd, 0x6e, 0x85, 0x6c,
        0x16, 0xbf, 0xfd, 0x26, 0xa1, 0x0f, 0x75, 0x0d,
        0x95, 0x06, 0xb1, 0x22, 0x05, 0x01, 0x0a, 0x17,
        0x78, 0x05, 0x02, 0x0a, 0x66, 0x72, 0x85, 0x6c,
        0x16, 0x34, 0x02, 0x26, 0x4c, 0x02, 0x75, 0x0a,
        0x95, 0x02, 0x91, 0x22, 0x05, 0x01, 0x0a, 0xf7,
        0x41, 0x05, 0x03, 0x1a, 0xf2, 0x55, 0x2a, 0xf3,
        0x55, 0x05, 0x02, 0x0a, 0x4e, 0x5e, 0x85, 0x6c,
        0x16, 0x27, 0x2b, 0x26, 0x1c, 0x3e, 0x75, 0x0f,
        0x95, 0x0a, 0x81, 0x22, 0x05, 0x01, 0x1a, 0xa0,
        0x6c, 0x2a, 0xa1, 0x6c, 0x85, 0x6c, 0x16, 0x06,
        0x01, 0x26, 0xe3, 0x02, 0x75, 0x0b, 0x95, 0x0e,
        0x91, 0x22, 0x75, 0x02, 0x95, 0x01, 0x85, 0x6c,
        0x81, 0x01, 0x75, 0x05, 0x95, 0x01, 0x85, 0x6c,
        0x91, 0x01, 0x75, 0x04, 0x95, 0x01, 0x85, 0x6c,
        0xb1, 0x01, 0xc0
    };

    UCHAR Rd8 [] = {
        0x05, 0x01, 0x09, 0x02, 0xa1, 0x01, 0x85, 0x01,
        0x09, 0x01, 0xa1, 0x00, 0x05, 0x09, 0x19, 0x01,
        0x29, 0x03, 0x15, 0x00, 0x25, 0x01, 0x95, 0x03,
        0x75, 0x01, 0x81, 0x02, 0x95, 0x01, 0x75, 0x05,
        0x81, 0x03, 0x05, 0x01, 0x09, 0x30, 0x09, 0x31,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xcd, 0xef, 0x08, 0x1d, 0x00, 0x06, 0x80, 0x01,
        0x55, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0xa0, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x44, 0x03, 0xff, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00
    };

    UCHAR Rd9 [] = {
        0x05, 0x01, 0x09, 0x02, 0xa1, 0x01, 0x85, 0x01,
        0x09, 0x01, 0xa1, 0x00, 0x05, 0x09, 0x19, 0x01,
        0x29, 0x03, 0x15, 0x00, 0x25, 0x01, 0x95, 0x03,
        0x75, 0x01, 0x81, 0x02, 0x95, 0x01, 0x75, 0x05,
        0x81, 0x03, 0x05, 0x01, 0x09, 0x30, 0x09, 0x31,
        0x09, 0x38, 0x15, 0x81, 0x25, 0x7f, 0x75, 0x08,
        0x95, 0x03, 0x81, 0x06, 0xc0, 0xc0, 0x05, 0x01,
        0x09, 0x80, 0xa1, 0x01, 0x85, 0x02, 0x09, 0x83,
        0x09, 0x82, 0x09, 0x81, 0x25, 0x01, 0x15, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xcd, 0xef, 0x05, 0x00, 0x00
    };

    HIDP_DATA data [] = {  {2,0,1},
                           {2,0,0},
                           };

    ULONG status, colLen, repLen;
    HIDP_DEVICE_DESC        devDesc;
    USAGE usages [] = { 0x4, 0x2, 0x30, 0x32, 0x32, 0x07 };
    UCHAR report [0x8];
    ULONG usagesLength = sizeof usages / sizeof (USAGE);

    memset (report, 0, sizeof report);

    status = HidP_GetCollectionDescription (Rd9,
                                            sizeof Rd9,
                                            0,
                                            &devDesc);

    for (i=0; i<devDesc.CollectionDescLength; i++) {
        printf("______________Collection %d___________\n", i);
        printf("----------------VV %d VV---------------\n", i);
        flags.Flags = 0xF;
        HID_DumpPpd (devDesc.CollectionDesc[i].PreparsedData, flags);
        printf("----------------- %d ------------------\n", i);
        flags.Flags = 0xFF;
        HID_DumpPpd (devDesc.CollectionDesc[i].PreparsedData, flags);
        printf("---------------^^ %d ^^----------------\n", i);

    }

#if 0
    HidP_SetUsageValue (HidP_Feature,
                        (USAGE) 0x85,
                        0,
                        0x66,
                        0xFFFFFFFF,
                        devDesc.CollectionDesc[i].PreparsedData,
                        report,
                        sizeof report);

    HidP_GetUsageValue (HidP_Feature,
                        (USAGE) 0x85,
                        0,
                        0x66,
                        &i,
                        devDesc.CollectionDesc[i].PreparsedData,
                        report,
                        sizeof report);

    i = 0;
    HidP_SetUsageValue (HidP_Feature,
                        (USAGE) 0x85,
                        0,
                        0x67,
                        0xFFFFFFFF,
                        devDesc.CollectionDesc[i].PreparsedData,
                        report,
                        sizeof report);

    HidP_GetUsageValue (HidP_Feature,
                        (USAGE) 0x85,
                        0,
                        0x67,
                        &i,
                        devDesc.CollectionDesc[i].PreparsedData,
                        report,
                        sizeof report);

    i = 0;
    HidP_SetUsageValue (HidP_Feature,
                        (USAGE) 0x85,
                        0,
                        0x68,
                        0xFFFFFFFF,
                        devDesc.CollectionDesc[i].PreparsedData,
                        report,
                        sizeof report);

    HidP_GetUsageValue (HidP_Feature,
                        (USAGE) 0x85,
                        0,
                        0x68,
                        &i,
                        devDesc.CollectionDesc[i].PreparsedData,
                        report,
                        sizeof report);

    HidP_UnsetUsages (HidP_Input,
                      (USHORT) 0x09,
                      0,
                      usages,
                      &usagesLength,
                      devDesc.CollectionDesc[i].PreparsedData,
                      report,
                      sizeof report);

    usagesLength = 2;
    HidP_SetData (HidP_Feature,
                  data,
                  &usagesLength,
                  devDesc.CollectionDesc[i].PreparsedData,
                  report,
                  sizeof report);

#endif

    printf("Hello world\n");
}


VOID
HID_DumpChannel (
    PHIDP_CHANNEL_DESC  Channel,
    HID_PPD_FLAGS       Flags
    )
{
    printf ("-------CHANNEL---------\n");
    printf ("P %x ID %x Col %x Sz %x Cnt %x UMin %x UMax %x ",
             Channel->UsagePage,
             Channel->ReportID,
             Channel->LinkCollection,
             Channel->ReportSize,
             Channel->ReportCount,
             Channel->Range.UsageMin,
             Channel->Range.UsageMax);

    if (Channel->MoreChannels) {
        printf ("MoreChannels ");
    }
    if (Channel->IsConst) {
        printf ("Const ");
    }
    if (Channel->IsButton) {
        printf ("Button ");
    } else {
        printf ("Value ");
    }
    if (Channel->IsAbsolute) {
        printf ("Absolute ");
    }
    if (Channel->IsAlias) {
        printf ("ALIAS! ");
    }

    printf ("\n");

    if (Flags.FullChannelListing) {
        printf ("LinkUP %x LinkU %x SMin %x SMax %x "
                 "DMin %x DMax %x IndexMin %x IndexMax %x\n",
                 Channel->LinkUsagePage,
                 Channel->LinkUsage,
                 Channel->Range.StringMin,
                 Channel->Range.StringMax,
                 Channel->Range.DesignatorMin,
                 Channel->Range.DesignatorMax,
                 Channel->Range.DataIndexMin,
                 Channel->Range.DataIndexMax);

        if (!Channel->IsButton) {
            if (Channel->Data.HasNull) {
                printf ("Has Null ");
            }
            printf ("LMin %x LMax %x PMin %x PMax %x \n",
                     Channel->Data.LogicalMin,
                     Channel->Data.LogicalMax,
                     Channel->Data.PhysicalMin,
                     Channel->Data.PhysicalMax);
        }
    }

    if (Flags.ReportLocation) {
        printf ("ByteOffset %x BitOffset %x BitLength %x ByteEnd %x\n",
                 Channel->ByteOffset,
                 Channel->BitOffset,
                 Channel->BitLength,
                 Channel->ByteEnd);
    }
}

VOID
HID_DumpLink (
    ULONG LinkNo,
    PHIDP_LINK_COLLECTION_NODE Node
    )
{
    printf ("Link %x: U %x P %x Par %x #C %x NxSib %x 1stC %x ",
             LinkNo,
             Node->LinkUsage,
             Node->LinkUsagePage,
             Node->Parent,
             Node->NumberOfChildren,
             Node->NextSibling,
             Node->FirstChild);

    if (Node->IsAlias) {
        printf (" ALIAS\n");
    } else {
        printf ("\n");
    }
}

VOID
HID_DumpPpd (
    PHIDP_PREPARSED_DATA    Ppd,
    HID_PPD_FLAGS           Flags
    )
{
    ULONG i;
    PHIDP_CHANNEL_DESC          channel;
    PHIDP_LINK_COLLECTION_NODE  node;

    if (!Flags.IgnoreSignature) {
        if ((HIDP_PREPARSED_DATA_SIGNATURE1 != Ppd->Signature1) ||
            (HIDP_PREPARSED_DATA_SIGNATURE2 != Ppd->Signature2)) {

            printf("Preparsed Data signature does not match, probably aint\n");
            return;
        }
    }

    if (Flags.InputChannels) {
        printf ("\n========== Input Channels =========\n");
        for (i = Ppd->Input.Offset; i < Ppd->Input.Index; i++) {
            channel = &Ppd->Data [i];
            HID_DumpChannel (channel, Flags);
        }
    } else {
        printf ("Input channels: off %x sz %x indx %x bytelen %x\n",
                 Ppd->Input.Offset,
                 Ppd->Input.Size,
                 Ppd->Input.Index,
                 Ppd->Input.ByteLen);
    }

    if (Flags.OutputChannels) {
        printf ("\n========== Output Channels =========\n");
        for (i = Ppd->Output.Offset; i < Ppd->Output.Index; i++) {
            channel = &Ppd->Data [i];
            HID_DumpChannel (channel, Flags);
        }

    } else {
        printf ("Output channels: off %x sz %x indx %x bytelen %x\n",
                 Ppd->Output.Offset,
                 Ppd->Output.Size,
                 Ppd->Output.Index,
                 Ppd->Output.ByteLen);
    }

    if (Flags.FeatureChannels) {
        printf ("\n========== Feature Channels =========\n");
        for (i = Ppd->Feature.Offset; i < Ppd->Feature.Index; i++) {
            channel = &Ppd->Data [i];
            HID_DumpChannel (channel, Flags);
        }

    } else {
        printf ("Feature channels: off %x sz %x indx %x bytelen %x\n",
                 Ppd->Feature.Offset,
                 Ppd->Feature.Size,
                 Ppd->Feature.Index,
                 Ppd->Feature.ByteLen);
    }

    if (Flags.LinkCollections) {
        printf ("\n========== Link Collections =========\n");
        node = (PHIDP_LINK_COLLECTION_NODE)
               (Ppd->RawBytes + Ppd->LinkCollectionArrayOffset);

        for (i = 0; i < Ppd->LinkCollectionArrayLength; i++, node++) {
            HID_DumpLink (i, node);
        }

    } else {
        printf ("Link Collections: %x \n",
                 Ppd->LinkCollectionArrayLength);
    }
    printf ("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidusb\hid.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Human Input Device (HID) minidriver for Universal Serial Bus (USB) devices

          The HID USB Minidriver (HUM, Hum) provides an abstraction layer for the
          HID Class so that future HID devices whic are not USB devices can be supported.

Author:
            forrestf
            ervinp
            jdunn

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, HumGetHidDescriptor)
    #pragma alloc_text(PAGE, HumGetReportDescriptor)
    #pragma alloc_text(PAGE, HumGetStringDescriptor)
    #pragma alloc_text(PAGE, HumGetPhysicalDescriptor)
    #pragma alloc_text(PAGE, HumGetDeviceAttributes)
    #pragma alloc_text(PAGE, HumGetMsGenreDescriptor)
#endif




resetWorkItemContext *resetWorkItemsList = NULL;
KSPIN_LOCK resetWorkItemsListSpinLock;

PVOID
HumGetSystemAddressForMdlSafe(PMDL MdlAddress) 
{ 
    PVOID buf = NULL;
    /*
     *  Can't call MmGetSystemAddressForMdlSafe in a WDM driver,
     *  so set the MDL_MAPPING_CAN_FAIL bit and check the result
     *  of the mapping.
     */
    if (MdlAddress) {
        MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
        buf = MmGetSystemAddressForMdl(MdlAddress);
        MdlAddress->MdlFlags &= ~(MDL_MAPPING_CAN_FAIL); 
    } else {
        ASSERT(MdlAddress);
    }
    return buf;
}

/*
 ********************************************************************************
 *  GetInterruptInputPipeForDevice
 ********************************************************************************
 *
 *
 *  For composite devices, a device interface can be identified by the unique endpoint
 *  (i.e. pipe) that it uses for interrupt input.
 *  This function returns information about that pipe.
 *
 */
PUSBD_PIPE_INFORMATION GetInterruptInputPipeForDevice(PDEVICE_EXTENSION DeviceExtension)
{
    ULONG i;
    PUSBD_PIPE_INFORMATION pipeInfo = NULL;

    for (i = 0; i < DeviceExtension->Interface->NumberOfPipes; i++){
        UCHAR endPtAddr = DeviceExtension->Interface->Pipes[i].EndpointAddress;
        USBD_PIPE_TYPE pipeType = DeviceExtension->Interface->Pipes[i].PipeType;

        if ((endPtAddr & USB_ENDPOINT_DIRECTION_MASK) && (pipeType == UsbdPipeTypeInterrupt)){
            pipeInfo = &DeviceExtension->Interface->Pipes[i];
            break;
        }
    }

    return pipeInfo;
}


/*
 ********************************************************************************
 *  GetInterruptOutputPipeForDevice
 ********************************************************************************
 *
 *
 *  For composite devices, a device interface can be identified by the unique endpoint
 *  (i.e. pipe) that it uses for interrupt input.
 *  This function returns information about that pipe.
 *
 */
PUSBD_PIPE_INFORMATION GetInterruptOutputPipeForDevice(PDEVICE_EXTENSION DeviceExtension)
{
    ULONG i;
    PUSBD_PIPE_INFORMATION pipeInfo = NULL;

    for (i = 0; i < DeviceExtension->Interface->NumberOfPipes; i++){
        UCHAR endPtAddr = DeviceExtension->Interface->Pipes[i].EndpointAddress;
        USBD_PIPE_TYPE pipeType = DeviceExtension->Interface->Pipes[i].PipeType;

        if (!(endPtAddr & USB_ENDPOINT_DIRECTION_MASK) && (pipeType == UsbdPipeTypeInterrupt)){
            pipeInfo = &DeviceExtension->Interface->Pipes[i];
            break;
        }
    }

    return pipeInfo;
}


/*
 ********************************************************************************
 *  HumGetHidDescriptor
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       Free all the allocated resources, etc.
 *
 *   Arguments:
 *
 *       DeviceObject - pointer to a device object.
 *
 *   Return Value:
 *
 *       NT status code.
 *
 */
NTSTATUS HumGetHidDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    if (DeviceExtension->HidDescriptor.bLength > 0) {

        ULONG bytesToCopy = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
        if (bytesToCopy > DeviceExtension->HidDescriptor.bLength) {
            bytesToCopy = DeviceExtension->HidDescriptor.bLength;
        }

        ASSERT(Irp->UserBuffer);
        RtlCopyMemory((PUCHAR)Irp->UserBuffer, (PUCHAR)&DeviceExtension->HidDescriptor, bytesToCopy);
        Irp->IoStatus.Information = bytesToCopy;
        ntStatus = STATUS_SUCCESS;
    } 
    else {
        ASSERT(DeviceExtension->HidDescriptor.bLength > 0);
        Irp->IoStatus.Information = 0;
        ntStatus = STATUS_UNSUCCESSFUL;
    }


    ASSERT(NT_SUCCESS(ntStatus));
    return ntStatus;
}


/*
 ********************************************************************************
 *  HumGetDeviceAttributes
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       Fill in the given struct _HID_DEVICE_ATTRIBUTES
 *
 *   Arguments:
 *
 *       DeviceObject - pointer to a device object.
 *
 *   Return Value:
 *
 *       NT status code.
 *
 */
NTSTATUS HumGetDeviceAttributes(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PHID_DEVICE_ATTRIBUTES deviceAttributes;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    deviceAttributes = (PHID_DEVICE_ATTRIBUTES) Irp->UserBuffer;

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength >= 
        sizeof (HID_DEVICE_ATTRIBUTES)){ 

        //
        // Report how many bytes were copied
        //
        Irp->IoStatus.Information = sizeof (HID_DEVICE_ATTRIBUTES);

        deviceAttributes->Size = sizeof (HID_DEVICE_ATTRIBUTES);
        deviceAttributes->VendorID = deviceExtension->DeviceDescriptor->idVendor;
        deviceAttributes->ProductID = deviceExtension->DeviceDescriptor->idProduct;
        deviceAttributes->VersionNumber = deviceExtension->DeviceDescriptor->bcdDevice;
        ntStatus = STATUS_SUCCESS;
    } 
    else {
        ntStatus = STATUS_INVALID_BUFFER_SIZE;
    }

    ASSERT(NT_SUCCESS(ntStatus));
    return ntStatus;
}

/*
 ********************************************************************************
 *  HumGetReportDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HumGetReportDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PDEVICE_EXTENSION       DeviceExtension;
    PIO_STACK_LOCATION      IrpStack;
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PVOID                   Report = NULL;
    ULONG                   ReportLength;
    ULONG                   bytesToCopy;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    ReportLength = DeviceExtension->HidDescriptor.wReportLength + 64;

    if (DeviceExtension->DeviceFlags & DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE) {
        PUSBD_PIPE_INFORMATION pipeInfo;
        
        pipeInfo = GetInterruptInputPipeForDevice(DeviceExtension);
        if (pipeInfo){
            UCHAR deviceInputEndpoint = pipeInfo->EndpointAddress & ~USB_ENDPOINT_DIRECTION_MASK;

            ntStatus = HumGetDescriptorRequest(
                           DeviceObject,
                           URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT,
                           DeviceExtension->HidDescriptor.bReportType,  // better be HID_REPORT_DESCRIPTOR_TYPE
                           &Report,
                           &ReportLength,
                           sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                           0,   // Specify zero for all hid class descriptors except physical
                           deviceInputEndpoint);
        } 
        else {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
    } 
    else {
        ntStatus = HumGetDescriptorRequest(
                        DeviceObject,
                        URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE,
                        DeviceExtension->HidDescriptor.bReportType, // better be HID_REPORT_DESCRIPTOR_TYPE
                        &Report,
                        &ReportLength,
                        sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                        0,      // Specify zero for all hid class descriptors except physical
                        DeviceExtension->Interface->InterfaceNumber); // Interface number when not requesting string descriptor
    }

    if (NT_SUCCESS(ntStatus)) {
        
        ASSERT(Report);

        bytesToCopy = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

        if (bytesToCopy > DeviceExtension->HidDescriptor.wReportLength) {
            bytesToCopy = DeviceExtension->HidDescriptor.wReportLength;
        }

        if (bytesToCopy > ReportLength) {
            bytesToCopy = ReportLength;
        }

        ASSERT(Irp->UserBuffer);
        RtlCopyMemory((PUCHAR)Irp->UserBuffer, (PUCHAR)Report, bytesToCopy);

        //
        // Report how many bytes were copied
        //
        Irp->IoStatus.Information = bytesToCopy;

        ExFreePool(Report);
    }

    return ntStatus;
}


/*
 ********************************************************************************
 *  HumIncrementPendingRequestCount
 ********************************************************************************
 *
 *
 */
NTSTATUS HumIncrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension)
{
    LONG newRequestCount;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    newRequestCount = InterlockedIncrement(&DeviceExtension->NumPendingRequests);

    //
    // Make sure that the device is capable of receiving new requests.
    //
    if ((DeviceExtension->DeviceState != DEVICE_STATE_RUNNING) &&
        (DeviceExtension->DeviceState != DEVICE_STATE_STARTING)){

        //
        // Device cannot receive any more IOs, decrement back, fail the increment
        //
        HumDecrementPendingRequestCount(DeviceExtension);
        ntStatus = STATUS_NO_SUCH_DEVICE;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumDecrementPendingRequestCount
 ********************************************************************************
 *
 *
 */
VOID HumDecrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension)
{
    LONG PendingCount;

    ASSERT(DeviceExtension->NumPendingRequests >= 0);

    PendingCount = InterlockedDecrement(&DeviceExtension->NumPendingRequests);
    if (PendingCount < 0){
        
        ASSERT(DeviceExtension->DeviceState != DEVICE_STATE_RUNNING);

        /*
         *  The device state is stopping, and the last outstanding request
         *  has just completed.
         *
         *  Note: RemoveDevice does an extra decrement, so we complete 
         *        the REMOVE IRP on the transition to -1, whether this 
         *        happens in RemoveDevice itself or subsequently while
         *        RemoveDevice is waiting for this event to fire.
         */

        KeSetEvent(&DeviceExtension->AllRequestsCompleteEvent, 0, FALSE);
    }
}




/*
 ********************************************************************************
 *  HumReadReport
 ********************************************************************************
 *
 *   Routine Description:
 *
 *
 *    Arguments:
 *
 *       DeviceObject - Pointer to class device object.
 *
 *      IrpStack     - Pointer to Interrupt Request Packet.
 *
 *
 *   Return Value:
 *
 *      STATUS_SUCCESS, STATUS_UNSUCCESSFUL.
 *
 *
 *  Note: this function cannot be pageable because reads/writes
 *        can be made at dispatch-level.
 */
NTSTATUS HumReadReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack;
    PVOID ReportBuffer;
    ULONG ReportTotalSize;
    PIO_STACK_LOCATION NextStack;
    PURB Urb;

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(Irp->UserBuffer);

    ReportBuffer = Irp->UserBuffer;
    ReportTotalSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (ReportTotalSize && ReportBuffer){
        PUSBD_PIPE_INFORMATION inputInterruptPipe;

        inputInterruptPipe = GetInterruptInputPipeForDevice(DeviceExtension);
        if (inputInterruptPipe){

            /*
             *  Allocate a request block for the USB stack.
             *  (It will be freed by the completion routine).
             */
            Urb = ExAllocatePoolWithTag( NonPagedPool, sizeof(URB), HIDUSB_TAG);
            if (Urb){
                //
                //  Initialize the URB
                //
                RtlZeroMemory(Urb, sizeof(URB));

                Urb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
                Urb->UrbBulkOrInterruptTransfer.Hdr.Length = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );

                Urb->UrbBulkOrInterruptTransfer.PipeHandle = inputInterruptPipe->PipeHandle;
                ASSERT (Urb->UrbBulkOrInterruptTransfer.PipeHandle != NULL);

                Urb->UrbBulkOrInterruptTransfer.TransferBufferLength = ReportTotalSize;
                Urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
                Urb->UrbBulkOrInterruptTransfer.TransferBuffer = ReportBuffer;
                Urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_IN;
                Urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

                IoSetCompletionRoutine( Irp,
                                        HumReadCompletion,
                                        Urb,    // context
                                        TRUE,
                                        TRUE,
                                        TRUE );

                NextStack = IoGetNextIrpStackLocation(Irp);

                ASSERT(NextStack);

                NextStack->Parameters.Others.Argument1 = Urb;
                NextStack->MajorFunction = IrpStack->MajorFunction;

                NextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

                NextStack->DeviceObject = GET_NEXT_DEVICE_OBJECT(DeviceObject);


                //
                // We need to keep track of the number of pending requests
                // so that we can make sure they're all cancelled properly during
                // processing of a stop device request.
                //
                if (NT_SUCCESS(HumIncrementPendingRequestCount(DeviceExtension))){
                    ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
                    *NeedsCompletion = FALSE;
                } 
                else {
                    ExFreePool(Urb);
                    ntStatus = STATUS_NO_SUCH_DEVICE;
                }
            } 
            else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        } 
        else {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
    } 
    else {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumResetInterruptPipe
 ********************************************************************************
 *
 *  Reset The usb interrupt pipe.
 *
 */
NTSTATUS HumResetInterruptPipe(IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS ntStatus;
    PURB urb;
    PDEVICE_EXTENSION DeviceExtension;
    PUSBD_PIPE_INFORMATION pipeInfo;
    
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    urb = ExAllocatePoolWithTag(NonPagedPool, sizeof(struct _URB_PIPE_REQUEST), HIDUSB_TAG);

    if (urb) {
        urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL;
        pipeInfo = GetInterruptInputPipeForDevice(DeviceExtension);
        if (pipeInfo) {
            urb->UrbPipeRequest.PipeHandle = pipeInfo->PipeHandle;
    
            ntStatus = HumCallUSB(DeviceObject, urb);
        } else {
            //
            // This device doesn't have an interrupt IN pipe. 
            // Odd, but possible. I.e. USB monitor
            //
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }

        ExFreePool(urb);
    } 
    else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumGetPortStatus
 ********************************************************************************
 *
 *  Passes a URB to the USBD class driver
 *
 */
NTSTATUS HumGetPortStatus(IN PDEVICE_OBJECT DeviceObject, IN PULONG PortStatus)
{
    NTSTATUS ntStatus;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;


    *PortStatus = 0;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_GET_PORT_STATUS,
                GET_NEXT_DEVICE_OBJECT(DeviceObject),
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = PortStatus;


    ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), irp);
    if (ntStatus == STATUS_PENDING) {
        ntStatus = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);
    } 
    else {
        ioStatus.Status = ntStatus;
    }


    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumResetParentPort
 ********************************************************************************
 *
 *  Sends a RESET_PORT request to our USB PDO.
 *
 */
NTSTATUS HumResetParentPort(IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS ntStatus;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_RESET_PORT,
                GET_NEXT_DEVICE_OBJECT(DeviceObject),
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), irp);
    if (ntStatus == STATUS_PENDING) {
        ntStatus = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);
    }
    else {
        ioStatus.Status = ntStatus;
    }

    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    return ntStatus;
}


/*
 ********************************************************************************
 *  HumResetWorkItem
 ********************************************************************************
 *
 *  Resets the interrupt pipe after a read error is encountered.
 *
 */
NTSTATUS HumResetWorkItem(IN PDEVICE_OBJECT deviceObject, IN PVOID Context)
{
    resetWorkItemContext *resetWorkItemObj;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS ntStatus;
    ULONG portStatus;

    /*
     *  Get the information out of the resetWorkItemContext and free it.
     */
    resetWorkItemObj = (resetWorkItemContext *)Context;
    ASSERT(resetWorkItemObj);
    ASSERT(resetWorkItemObj->sig == RESET_WORK_ITEM_CONTEXT_SIG);

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(resetWorkItemObj->deviceObject);

    ntStatus = HumIncrementPendingRequestCount(DeviceExtension);
    if (NT_SUCCESS(ntStatus)){
    
        //
        // Check the port state, if it is disabled we will need 
        // to re-enable it
        //
        ntStatus = HumGetPortStatus(resetWorkItemObj->deviceObject, &portStatus);

        if (NT_SUCCESS(ntStatus)){
            
            if (portStatus & USBD_PORT_CONNECTED){
                /*
                 *  Device is still present, attempt reset.
                 *
                 *  Note: Resetting the port will close the endpoint(s).
                 *        So before resetting the port, we must make sure
                 *        that there is no pending IO.
                 */
                DBGPRINT(1,("Attempting port reset"));
                ntStatus = HumAbortPendingRequests(resetWorkItemObj->deviceObject);

                if (NT_SUCCESS(ntStatus)){
                    HumResetParentPort(resetWorkItemObj->deviceObject);
                }
                else {
                    DBGWARN(("HumResetWorkItem: HumAbortPendingRequests failed with status %xh.", ntStatus));
                }
            }

            //
            // now attempt to reset the stalled pipe, this will clear the stall
            // on the device as well.
            //

            /*
             *  This call does not close the endpoint, so it should be ok
             *  to make this call whether or not we succeeded in aborting
             *  all pending IO.
             */
            if (NT_SUCCESS(ntStatus)) {
                ntStatus = HumResetInterruptPipe(resetWorkItemObj->deviceObject);
            }        
        } 
        else {
            DBGWARN(("HumResetWorkItem: HumGetPortStatus failed with status %xh.", ntStatus));
        }

        HumDecrementPendingRequestCount(DeviceExtension);
    }

    /*
     *  Clear the ResetWorkItem ptr in the device extension
     *  AFTER resetting the pipe so we don't end up with
     *  two threads resetting the same pipe at the same time.
     */
    (VOID)InterlockedExchange((PVOID) &DeviceExtension->ResetWorkItem, 0);

    /*
     *  The IRP that returned the error which prompted us to do this reset
     *  is still owned by HIDUSB because we returned 
     *  STATUS_MORE_PROCESSING_REQUIRED in the completion routine.
     *  Now that the hub is reset, complete this failed IRP.
     */
    DBGPRINT(1,("Completing IRP %ph following port reset", resetWorkItemObj->irpToComplete));
    IoCompleteRequest(resetWorkItemObj->irpToComplete, IO_NO_INCREMENT);
    
    IoFreeWorkItem(resetWorkItemObj->ioWorkItem);
    ExFreePool(resetWorkItemObj);

    /*
     *  Balance the increment from when we queued the workItem.
     */
    HumDecrementPendingRequestCount(DeviceExtension);

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumReadCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HumReadCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    NTSTATUS ntStatus;
    NTSTATUS result = STATUS_SUCCESS;
    PURB urb;
    ULONG bytesRead;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    //
    // We passed a pointer to the URB as our context, get it now.
    //
    urb = (PURB)Context;
    ASSERT(urb);

    ntStatus = Irp->IoStatus.Status;
    if (NT_SUCCESS(ntStatus)){
        //
        // Get the bytes read and store in the status block
        //

        bytesRead = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
        Irp->IoStatus.Information = bytesRead;
    } 
    else if (ntStatus == STATUS_CANCELLED){
        /*
         *  The IRP was cancelled, which means that the device is probably getting removed.
         */
        DBGPRINT(2,("Read irp %p cancelled ...", Irp));
        ASSERT(!Irp->CancelRoutine);
    } 
    else if (ntStatus != STATUS_DEVICE_NOT_CONNECTED) {

        DBGWARN(("Read irp %ph failed with status %xh -- scheduling RESET ...", Irp, ntStatus));

        if (NT_SUCCESS(HumIncrementPendingRequestCount(deviceExtension))){
            resetWorkItemContext *resetWorkItemObj;

            resetWorkItemObj = ExAllocatePoolWithTag(NonPagedPool, sizeof(resetWorkItemContext), HIDUSB_TAG);
            if (resetWorkItemObj){
                PVOID comperand = NULL;

                resetWorkItemObj->ioWorkItem = IoAllocateWorkItem(deviceExtension->functionalDeviceObject);
                if (resetWorkItemObj->ioWorkItem){

                    comperand = InterlockedCompareExchangePointer (
                                      &deviceExtension->ResetWorkItem,  // dest
                                      &resetWorkItemObj->ioWorkItem,    // exchange
                                      comperand);                       // comperand

                    if (!comperand){

                        resetWorkItemObj->sig = RESET_WORK_ITEM_CONTEXT_SIG;
                        resetWorkItemObj->irpToComplete = Irp;
                        resetWorkItemObj->deviceObject = DeviceObject;

                        IoQueueWorkItem(    resetWorkItemObj->ioWorkItem, 
                                            HumResetWorkItem,
                                            DelayedWorkQueue,
                                            resetWorkItemObj);

                        /*
                         *  Return STATUS_MORE_PROCESSING_REQUIRED so NTKERN doesn't
                         *  keep processing the IRP.
                         */
                        result = STATUS_MORE_PROCESSING_REQUIRED;
                    } 
                    else {
                        //
                        // We already have a reset op queued.
                        //
                        IoFreeWorkItem(resetWorkItemObj->ioWorkItem);
                        ExFreePool(resetWorkItemObj);
                        HumDecrementPendingRequestCount(deviceExtension);
                    }
                } 
                else {
                    ExFreePool(resetWorkItemObj);
                    HumDecrementPendingRequestCount(deviceExtension);
                }
            } 
            else {
                HumDecrementPendingRequestCount(deviceExtension);
            }
        } 
    }

    //
    // Don't need the URB anymore
    //
    ExFreePool(urb);

    /*
     *  Balance the increment we did when we issued the read.
     */
    HumDecrementPendingRequestCount(deviceExtension);

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }
    return result;
}



/*
 ********************************************************************************
 *  HumWriteReport
 ********************************************************************************
 *
 *    Routine Description:
 *
 *
 *   Arguments:
 *
 *      DeviceObject - Pointer to class device object.
 *
 *      IrpStack     - Pointer to Interrupt Request Packet.
 *
 *
 *   Return Value:
 *
 *   STATUS_SUCCESS, STATUS_UNSUCCESSFUL.
 *
 *
 *  Note: this function cannot be pageable because reads/writes
 *        can be made at dispatch-level.
 */
NTSTATUS HumWriteReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack, nextIrpStack;
    PURB Urb;

    PHID_XFER_PACKET hidWritePacket;

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    nextIrpStack = IoGetNextIrpStackLocation(Irp);

    hidWritePacket = (PHID_XFER_PACKET)Irp->UserBuffer;
    if (hidWritePacket){

        if (hidWritePacket->reportBuffer && hidWritePacket->reportBufferLen){
            PUSBD_PIPE_INFORMATION interruptPipe;

            Urb = ExAllocatePoolWithTag(NonPagedPool, sizeof(URB), HIDUSB_TAG);
            if (Urb){
                
                RtlZeroMemory(Urb, sizeof( URB ));

                if (DeviceExtension->DeviceFlags & DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE) {

                    /*
                     *  This is an old device which follows the pre-final spec.
                     *  We use the endpoint address of the input pipe
                     *  with the direction bit cleared.
                     */

                    #if DBG
                        interruptPipe = GetInterruptOutputPipeForDevice(DeviceExtension);
                        ASSERT(!interruptPipe);
                    #endif

                    interruptPipe = GetInterruptInputPipeForDevice(DeviceExtension);
                    if (interruptPipe){
                        UCHAR deviceInputEndpoint = interruptPipe->EndpointAddress & ~USB_ENDPOINT_DIRECTION_MASK;

                        /*
                         *   A control operation consists of 3 stages: setup, data, and status.
                         *   In the setup stage the device receives an 8-byte frame comprised of
                         *   the following fields of a _URB_CONTROL_VENDOR_OR_CLASS_REQUEST structure:
                         *   See section 7.2 in the USB HID specification for how to fill out these fields.
                         *
                         *      UCHAR RequestTypeReservedBits;
                         *      UCHAR Request;
                         *      USHORT Value;
                         *      USHORT Index;
                         *
                         */
                        HumBuildClassRequest(
