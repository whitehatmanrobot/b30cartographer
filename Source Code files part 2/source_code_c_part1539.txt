

#define WS_BORDER       0x00800000L
#define WS_CAPTION      0x00c00000L
#define WS_DLGFRAME     0x00400000L
#define WS_VSCROLL      0x00200000L
#define WS_HSCROLL      0x00100000L
#define WS_SYSMENU      0x00080000L
#define WS_SIZEBOX      0x00040000L
#define WS_GROUP        0x00020000L
#define WS_TABSTOP      0x00010000L

#define WS_ICONIC       WS_MINIMIZE

/* Class styles */
#define CS_VREDRAW      0x0001
#define CS_HREDRAW      0x0002
#define CS_KEYCVTWINDOW 0x0004
#define CS_DBLCLKS      0x0008
			/* 0x0010 reserved */
#define CS_OWNDC        0x0020
#define CS_CLASSDC      0x0040
#define CS_MENUPOPUP    0x0080
#define CS_NOKEYCVT     0x0100
#define CS_SAVEBITS     0x0800

/* Shorthand for the common cases */
#define WS_TILEDWINDOW   (WS_TILED | WS_CAPTION | WS_SYSMENU | WS_SIZEBOX)
#define WS_POPUPWINDOW   (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW   (WS_CHILD)

/* Edit control styles */
#define ES_LEFT             0x0000L
#define ES_CENTER           0x0001L
#define ES_RIGHT            0x0002L
#define ES_MULTILINE        0x0004L
#define ES_UPPERCASE        0x0008L
#define ES_LOWERCASE        0x0010L
#define ES_PASSWORD         0x0020L
#define ES_AUTOVSCROLL      0x0040L
#define ES_AUTOHSCROLL      0x0080L
#define ES_NOHIDESEL        0x0100L
#define ES_OEMCONVERT       0x0400L

/* button control styles */
#define BS_PUSHBUTTON    0L
#define BS_DEFPUSHBUTTON 1L
#define BS_CHECKBOX      2L
#define BS_AUTOCHECKBOX  3L
#define BS_RADIOBUTTON   4L
#define BS_3STATE        5L
#define BS_AUTO3STATE    6L
#define BS_GROUPBOX      7L
#define BS_USERBUTTON    8L
#define BS_AUTORADIOBUTTON 9L
#define BS_PUSHBOX       10L
#define BS_OWNERDRAW	   0x0BL
#define BS_LEFTTEXT      0x20L

/* Dialog Styles */
#define DS_ABSALIGN	    0x01L
#define DS_SYSMODAL	    0x02L
#define DS_LOCALEDIT	    0x20L   /* Edit items get Local storage. */
#define DS_SETFONT	    0x40L   /* User specified font for Dlg controls */
#define DS_MODALFRAME	    0x80L   /* Can be combined with WS_CAPTION  */
#define DS_NOIDLEMSG	    0x100L  /* WM_ENTERIDLE message will not be sent */

/* listbox style bits */
#define LBS_NOTIFY        0x0001L
#define LBS_SORT          0x0002L
#define LBS_NOREDRAW      0x0004L
#define LBS_MULTIPLESEL   0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL	      0x0800L
#define LBS_STANDARD      (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

/* Combo Box styles */
#define CBS_SIMPLE	      0x0001L
#define CBS_DROPDOWN	      0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L

/* scroll bar styles */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L

/* Conventional dialog box and message box command IDs */
#define IDOK         1
#define IDCANCEL     2
#define IDABORT      3
#define IDRETRY      4
#define IDIGNORE     5
#define IDYES        6
#define IDNO         7

/* Static control constants */
#define SS_LEFT       0L
#define SS_CENTER     1L
#define SS_RIGHT      2L
#define SS_ICON       3L
#define SS_BLACKRECT  4L
#define SS_GRAYRECT   5L
#define SS_WHITERECT  6L
#define SS_BLACKFRAME 7L
#define SS_GRAYFRAME  8L
#define SS_WHITEFRAME 9L
#define SS_USERITEM   10L

/* Virtual Keys, Standard Set */

#define VK_LBUTTON  0x01
#define VK_RBUTTON  0x02
#define VK_CANCEL   0x03
#define VK_MBUTTON  0x04    /* NOT contiguous with L & RBUTTON */
#define VK_BACK     0x08
#define VK_TAB      0x09
#define VK_CLEAR    0x0c
#define VK_RETURN   0x0d
#define VK_SHIFT    0x10
#define VK_CONTROL  0x11
#define VK_MENU     0x12
#define VK_PAUSE    0x13
#define VK_CAPITAL  0x14
#define VK_ESCAPE   0x1b
#define VK_SPACE    0x20

#define VK_PRIOR    0x21
#define VK_NEXT     0x22
#define VK_END      0x23
#define VK_HOME     0x24
#define VK_LEFT     0x25
#define VK_UP       0x26
#define VK_RIGHT    0x27
#define VK_DOWN     0x28

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#define VK_SELECT   0x29
#define VK_PRINT    0x2a
#define VK_EXECUTE  0x2b
#define VK_SNAPSHOT 0x2c
#define VK_INSERT   0x2d
#define VK_DELETE   0x2e
#define VK_HELP     0x2f

#define VK_NUMPAD0  0x60
#define VK_NUMPAD1  0x61
#define VK_NUMPAD2  0x62
#define VK_NUMPAD3  0x63
#define VK_NUMPAD4  0x64
#define VK_NUMPAD5  0x65
#define VK_NUMPAD6  0x66
#define VK_NUMPAD7  0x67
#define VK_NUMPAD8  0x68
#define VK_NUMPAD9  0x69
#define VK_MULTIPLY 0x6A
#define VK_ADD      0x6B
#define VK_SEPARATOR 0x6C
#define VK_SUBTRACT 0x6D
#define VK_DECIMAL  0x6E
#define VK_DIVIDE   0x6F

#define VK_F1       0x70
#define VK_F2       0x71
#define VK_F3       0x72
#define VK_F4       0x73
#define VK_F5       0x74
#define VK_F6       0x75
#define VK_F7       0x76
#define VK_F8       0x77
#define VK_F9       0x78
#define VK_F10      0x79
#define VK_F11      0x7a
#define VK_F12      0x7b
#define VK_F13      0x7c
#define VK_F14      0x7d
#define VK_F15      0x7e
#define VK_F16      0x7f
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\streamb.h ===
/***
*streamb.h - definitions/declarations for the streambuf class
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the streambuf class.
*   [AT&T C++]
*
****/

#ifndef _INC_STREAMB
#define _INC_STREAMB


#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

#ifndef NULL
#define NULL    0
#endif 

#ifndef EOF
#define EOF (-1)
#endif 

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

typedef long streampos, streamoff;

class streambuf {
public:

    virtual ~streambuf();

    inline int in_avail() const;
    inline int out_waiting() const;
    int sgetc();
    int snextc();
    int sbumpc();
    void stossc();

    inline int sputbackc(char);

    inline int sputc(int);
    inline int sputn(const char _HFAR_ *,int);
    inline int sgetn(char _HFAR_ *,int);

    virtual int sync();

//  enum seek_dir { beg=0, cur=1, end=2 };  // CONSIDER: needed ???

    virtual streambuf* setbuf(char _HFAR_ *, int);
    virtual streampos seekoff(streamoff,ios::seek_dir,int =ios::in|ios::out);
    virtual streampos seekpos(streampos,int =ios::in|ios::out);

    virtual int xsputn(const char _HFAR_ *,int);
    virtual int xsgetn(char _HFAR_ *,int);

    virtual int overflow(int =EOF) = 0; // pure virtual function
    virtual int underflow() = 0;    // pure virtual function

    virtual int pbackfail(int);

    void dbp();

protected:
    streambuf();
    streambuf(char _HFAR_ *,int);

    inline char _HFAR_ * base() const;
    inline char _HFAR_ * ebuf() const;
    inline char _HFAR_ * pbase() const;
    inline char _HFAR_ * pptr() const;
    inline char _HFAR_ * epptr() const;
    inline char _HFAR_ * eback() const;
    inline char _HFAR_ * gptr() const;
    inline char _HFAR_ * egptr() const;
    inline int blen() const;
    inline void setp(char _HFAR_ *,char _HFAR_ *);
    inline void setg(char _HFAR_ *,char _HFAR_ *,char _HFAR_ *);
    inline void pbump(int);
    inline void gbump(int);

    void setb(char _HFAR_ *,char _HFAR_ *,int =0);
    inline int unbuffered() const;
    inline void unbuffered(int);
    int allocate();
    virtual int doallocate();

private:
    int _fAlloc;
    int _fUnbuf;
    int x_lastc;
    char _HFAR_ * _base;
    char _HFAR_ * _ebuf;
    char _HFAR_ * _pbase;
    char _HFAR_ * _pptr;
    char _HFAR_ * _epptr;
    char _HFAR_ * _eback;
    char _HFAR_ * _gptr;
    char _HFAR_ * _egptr;
};

inline int streambuf::in_avail() const { return (gptr()<_egptr) ? (_egptr-gptr()) : 0; }
inline int streambuf::out_waiting() const { return (_pptr>=_pbase) ? (_pptr-_pbase) : 0; }

inline int streambuf::sputbackc(char _c){ return (_eback<gptr()) ? *(--_gptr)=_c : pbackfail(_c); }

inline int streambuf::sputc(int _i){ return (_pptr<_epptr) ? (unsigned char)(*(_pptr++)=(char)_i) : overflow(_i); }

inline int streambuf::sputn(const char _HFAR_ * _str,int _n) { return xsputn(_str, _n); }
inline int streambuf::sgetn(char _HFAR_ * _str,int _n) { return xsgetn(_str, _n); }

inline char _HFAR_ * streambuf::base() const { return _base; }
inline char _HFAR_ * streambuf::ebuf() const { return _ebuf; }
inline int streambuf::blen() const  {return ((_ebuf > _base) ? (_ebuf-_base) : 0); }
inline char _HFAR_ * streambuf::pbase() const { return _pbase; }
inline char _HFAR_ * streambuf::pptr() const { return _pptr; }
inline char _HFAR_ * streambuf::epptr() const { return _epptr; }
inline char _HFAR_ * streambuf::eback() const { return _eback; }
inline char _HFAR_ * streambuf::gptr() const { return _gptr; }
inline char _HFAR_ * streambuf::egptr() const { return _egptr; }
inline void streambuf::gbump(int n) { if (_egptr) _gptr += n; }
inline void streambuf::pbump(int n) { if (_epptr) _pptr += n; }
inline void streambuf::setg(char _HFAR_ * eb, char _HFAR_ * g, char _HFAR_ * eg) {_eback=eb; _gptr=g; _egptr=eg; x_lastc=EOF; }
inline void streambuf::setp(char _HFAR_ * p, char _HFAR_ * ep) {_pptr=_pbase=p; _epptr=ep; }
inline int streambuf::unbuffered() const { return _fUnbuf; }
inline void streambuf::unbuffered(int fUnbuf) { _fUnbuf = fUnbuf; }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\syscall.h ===
/*
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1992-1994
 *      All Rights Reserved.
 */

#define Abort                           0x00
#define Std_Con_Input                   0x01
#define Std_Con_Output                  0x02
#define Std_Aux_Input                   0x03
#define Std_Aux_Output                  0x04
#define Std_Printer_Output              0x05
#define Raw_Con_IO                      0x06
#define Raw_Con_Input                   0x07
#define Std_Con_Input_No_Echo           0x08
#define Std_Con_String_Output           0x09
#define Std_Con_String_Input            0x0A
#define Std_Con_Input_Status            0x0B
#define Std_Con_Input_Flush             0x0C
#define Disk_Reset                      0x0D
#define Set_Default_Drive               0x0E
#define FCB_Open                        0x0F
#define FCB_Close                       0x10
#define Dir_Search_First                0x11
#define Dir_Search_Next                 0x12
#define FCB_Delete                      0x13
#define FCB_Seq_Read                    0x14
#define FCB_Seq_Write                   0x15
#define FCB_Create                      0x16
#define FCB_Rename                      0x17
#define Get_Default_Drive               0x19
#define Set_DMA                         0x1A
#define Get_Default_DPB                 0x1F    /* ;Internal */
#define FCB_Random_Read                 0x21
#define FCB_Random_Write                0x22
#define Get_FCB_File_Length             0x23
#define Get_FCB_Position                0x24
#define Set_Interrupt_Vector            0x25
#define Create_Process_Data_Block       0x26
#define FCB_Random_Read_Block           0x27
#define FCB_Random_Write_Block          0x28
#define Parse_File_Descriptor           0x29
#define Get_Date                        0x2A
#define Set_Date                        0x2B
#define Get_Time                        0x2C
#define Set_Time                        0x2D
#define Set_Verify_On_Write             0x2E

/*
 *  Extended functionality group
 */
#define Get_DMA                         0x2F
#define Get_Version                     0x30
#define Keep_Process                    0x31
#define Get_DPB                         0x32    /* ;Internal */
#define Set_CTRL_C_Trapping             0x33
#define Get_InDOS_Flag                  0x34
#define Get_Interrupt_Vector            0x35
#define Get_Drive_Freespace             0x36
#define Char_Oper                       0x37
#define International                   0x38

/*
 *  Directory Group
 */
#define MKDir                           0x39
#define RMDir                           0x3A
#define CHDir                           0x3B

/*
 *  File Group
 */
#define Creat                           0x3C
#define Open                            0x3D
#define Close                           0x3E
#define Read                            0x3F
#define Write                           0x40
#define Unlink                          0x41
#define LSeek                           0x42
#define CHMod                           0x43
#define IOCtl                           0x44
#define XDup                            0x45
#define XDup2                           0x46
#define Current_Dir                     0x47

/*
 *  Memory Group
 */
#define Alloc                           0x48
#define Dealloc                         0x49
#define Setblock                        0x4A

/*
 *  Process Group
 */
#define Exec                            0x4B
#define Exit                            0x4C
#define WaitProcess                     0x4D
#define Find_First                      0x4E

/*
 *  Special Group
 */
#define Find_Next                       0x4F

/*
 *  Special System Group
 */
#define Set_Current_PDB                 0x50    /* ;Internal */
#define Get_Current_PDB                 0x51    /* ;Internal */
#define Get_In_Vars                     0x52    /* ;Internal */
#define SetDPB                          0x53    /* ;Internal */
#define Get_Verify_On_Write             0x54
#define Dup_PDB                         0x55    /* ;Internal */
#define Rename                          0x56
#define File_Times                      0x57
#define File_Times_Get_Mod                0x00
#define File_Times_Set_Mod                0x01
#define File_Times_Get_EA                 0x02  // For OS/2
#define File_Times_Set_EA                 0x03  // For OS/2
#define File_Times_Get_Acc                0x04
#define File_Times_Set_Acc                0x05

#define AllocOper                       0x58

/*
 *  Network extention system calls
 */
#define GetExtendedError                0x59
#define CreateTempFile                  0x5A
#define CreateNewFile                   0x5B
#define LockOper                        0x5C    // Lock and Unlock
#define ServerCall                      0x5D    // CommitAll, ServerDOSCall,    /* ;Internal */
                                                // CloseByName, CloseUser,      /* ;Internal */
                                                // CloseUserProcess,            /* ;Internal */
                                                // GetOpenFileList              /* ;Internal */
#define UserOper                        0x5E    // Get and Set
#define AssignOper                      0x5F    // On, Off, Get, Set, Cancel
#define xNameTrans                      0x60
#define PathParse                       0x61
#define GetCurrentPSP                   0x62
#define Hongeul                         0x63
#define ECS_CALL                        0x63    // DBCS support
#define Set_Printer_Flag                0x64    /* ;Internal */
#define GetExtCntry                     0x65
#define GetSetCdPg                      0x66
#define ExtHandle                       0x67
#define Commit                          0x68
#define GetSetMediaID                   0x69
#define IFS_IOCTL                       0x6B
#define ExtOpen                         0x6C
#define ROM_FIND_FIRST                  0x6D    /* ;Internal */
#define ROM_FIND_NEXT                   0x6E    /* ;Internal */
#define ROM_EXCLUDE                     0x6F    /* ;Internal */
#define GetSetNLS                       0x70
#define LN_Generic                      0x71
#define LN_FindClose                    0x72
#define Get_Set_DriveInfo               0x73
#define Get_DriveInfo                     0x00
#define Set_DriveInfo                     0x01
#define DriveInfo_AccDate                   0x00
#define DriveInfo_Commit                    0x01
#define AccDate_Disable                       0x00
#define AccDate_Enable                        0x02
#define Commit_Enable                         0x00
#define Commit_Disable                        0x08
#define Set_Oem_Handler                 0xF8
#define OEM_C1                          0xF9
#define OEM_C2                          0xFA
#define OEM_C3                          0xFB
#define OEM_C4                          0xFC
#define OEM_C5                          0xFD
#define OEM_C6                          0xFE
#define OEM_C7                          0xFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\strstrea.h ===
/***
*strstream.h - definitions/declarations for strstreambuf, strstream
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the strstream and strstreambuf classes.
*   [AT&T C++]
*
****/

#ifndef _INC_STRSTREAM
#define _INC_STRSTREAM

#include <iostream.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

class strstreambuf : public streambuf  {
public:
        strstreambuf();
        strstreambuf(int);
        strstreambuf(char _HFAR_ *, int, char _HFAR_ * = 0);
        strstreambuf(unsigned char _HFAR_ *, int, unsigned char _HFAR_ * = 0);
        strstreambuf(signed char _HFAR_ _HFAR_ *, int, signed char _HFAR_ * = 0);
        strstreambuf(void _HFAR_ * (*a)(long), void (*f) (void _HFAR_ *));
        ~strstreambuf();

    void    freeze(int =1);
    char _HFAR_ * str();

virtual int overflow(int);
virtual int underflow();
virtual streambuf* setbuf(char  _HFAR_ *, int);
virtual streampos seekoff(streamoff, ios::seek_dir, int);
virtual int sync();     // not in spec.

protected:
virtual int doallocate();
private:
    int x_dynamic;
    int     x_bufmin;
    int     _fAlloc;
    int x_static;
    void _HFAR_ * (* x_alloc)(long);
    void    (* x_free)(void _HFAR_ *);
};

class istrstream : public istream {
public:
        istrstream(char _HFAR_ *);
        istrstream(char _HFAR_ *, int);
        ~istrstream();

inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char _HFAR_ *   str() { return rdbuf()->str(); }
};

class ostrstream : public ostream {
public:
        ostrstream();
        ostrstream(char _HFAR_ *, int, int = ios::out);
        ~ostrstream();

inline  int pcount() const { return rdbuf()->out_waiting(); }
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char _HFAR_ *   str() { return rdbuf()->str(); }
};

class strstream : public iostream { // strstreambase ???
public:
        strstream();
        strstream(char _HFAR_ *, int, int);
        ~strstream();

inline  int pcount() const { return rdbuf()->out_waiting(); } // not in spec.
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ostream::rdbuf(); }
inline  char _HFAR_ *   str() { return rdbuf()->str(); }
};

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the function declarations for the string
*   manipulation functions.
*   [ANSI/System V]
*
****/

#ifndef _INC_STRING

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif 

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 

/* function prototypes */

void * __cdecl _memccpy(void *, const void *,
    int, unsigned int);
void * __cdecl memchr(const void *, int, size_t);
int __cdecl memcmp(const void *, const void *,
    size_t);
int __cdecl _memicmp(const void *, const void *,
    unsigned int);
void * __cdecl memcpy(void *, const void *,
    size_t);
void * __cdecl memmove(void *, const void *,
    size_t);
void * __cdecl memset(void *, int, size_t);
void __cdecl _movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);
char * __cdecl strcat(char *, const char *);
char * __cdecl strchr(const char *, int);
int __cdecl strcmp(const char *, const char *);
int __cdecl _strcmpi(const char *, const char *);
int __cdecl strcoll(const char *, const char *);
int __cdecl _stricmp(const char *, const char *);
char * __cdecl strcpy(char *, const char *);
size_t __cdecl strcspn(const char *, const char *);
char * __cdecl _strdup(const char *);
char * __cdecl _strerror(const char *);
char * __cdecl strerror(int);
size_t __cdecl strlen(const char *);
char * __cdecl _strlwr(char *);
char * __cdecl strncat(char *, const char *,
    size_t);
int __cdecl strncmp(const char *, const char *,
    size_t);
int __cdecl _strnicmp(const char *, const char *,
    size_t);
char * __cdecl strncpy(char *, const char *,
    size_t);
char * __cdecl _strnset(char *, int, size_t);
char * __cdecl strpbrk(const char *,
    const char *);
char * __cdecl strrchr(const char *, int);
char * __cdecl _strrev(char *);
char * __cdecl _strset(char *, int);
size_t __cdecl strspn(const char *, const char *);
char * __cdecl strstr(const char *,
    const char *);
char * __cdecl strtok(char *, const char *);
char * __cdecl _strupr(char *);
size_t __cdecl strxfrm (char *, const char *,
    size_t);


/* model independent function prototypes */

void __far * __far __cdecl _fmemccpy(void __far *, const void __far *,
    int, unsigned int);
void __far * __far __cdecl _fmemchr(const void __far *, int, size_t);
int __far __cdecl _fmemcmp(const void __far *, const void __far *,
    size_t);
void __far * __far __cdecl _fmemcpy(void __far *, const void __far *,
    size_t);
int __far __cdecl _fmemicmp(const void __far *, const void __far *,
    unsigned int);
void __far * __far __cdecl _fmemmove(void __far *, const void __far *,
    size_t);
void __far * __far __cdecl _fmemset(void __far *, int, size_t);
char __far * __far __cdecl _fstrcat(char __far *, const char __far *);
char __far * __far __cdecl _fstrchr(const char __far *, int);
int __far __cdecl _fstrcmp(const char __far *, const char __far *);
int __far __cdecl _fstricmp(const char __far *, const char __far *);
char __far * __far __cdecl _fstrcpy(char __far *, const char __far *);
size_t __far __cdecl _fstrcspn(const char __far *, const char __far *);
char __far * __far __cdecl _fstrdup(const char __far *);
char __near * __far __cdecl _nstrdup(const char __far *);
size_t __far __cdecl _fstrlen(const char __far *);
char __far * __far __cdecl _fstrlwr(char __far *);
char __far * __far __cdecl _fstrncat(char __far *, const char __far *,
    size_t);
int __far __cdecl _fstrncmp(const char __far *, const char __far *,
    size_t);
int __far __cdecl _fstrnicmp(const char __far *, const char __far *,
    size_t);
char __far * __far __cdecl _fstrncpy(char __far *, const char __far *,
    size_t);
char __far * __far __cdecl _fstrnset(char __far *, int, size_t);
char __far * __far __cdecl _fstrpbrk(const char __far *,
    const char __far *);
char __far * __far __cdecl _fstrrchr(const char __far *, int);
char __far * __far __cdecl _fstrrev(char __far *);
char __far * __far __cdecl _fstrset(char __far *, int);
size_t __far __cdecl _fstrspn(const char __far *, const char __far *);
char __far * __far __cdecl _fstrstr(const char __far *,
    const char __far *);
char __far * __far __cdecl _fstrtok(char __far *, const char __far *);
char __far * __far __cdecl _fstrupr(char __far *);


#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl memccpy(void *, const void *,
    int, unsigned int);
int __cdecl memicmp(const void *, const void *,
    unsigned int);
void __cdecl movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);
int __cdecl strcmpi(const char *, const char *);
int __cdecl stricmp(const char *, const char *);
char * __cdecl strdup(const char *);
char * __cdecl strlwr(char *);
int __cdecl strnicmp(const char *, const char *,
    size_t);
char * __cdecl strnset(char *, int, size_t);
char * __cdecl strrev(char *);
char * __cdecl strset(char *, int);
char * __cdecl strupr(char *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STRING
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\sysdetmg.h ===
/***MD sysdetmg.h - System Detection Manager definitions
 *
 *  This module contains System Detection Manager definitions including
 *  Detection Module Services definitions and Module Function definitions.
 *
 *  Copyright (c) 1992,1993 Microsoft Corporation
 *  Author:	Michael Tsang (MikeTs)
 *  Created	12/10/92
 *
 *  MODIFICATION HISTORY
 */


#ifndef _INC_SYSDETMG
#define _INC_SYSDETMG


/* do not complain about in-line comment and pragma use in windows.h */
#pragma warning(disable:4001 4103 4705)

#include <sdmerror.h>
#ifdef CALLCM	//only do this hack if we need to call CM
#define WINVER	0x030a		//system detection can be run under win31
#include <windows.h>

// Windows.h defines the following set of things for old reg users, whose
// WINVER is less than 0x0400.	Normally this is not a problem, but SYSDETMG
// is a special DLL whose winver is 0x030a, but we really use Win4.0 reg
// error codes, so we need to pick up the defines in WINERROR.H, so this
// prevents macro redef warnings.

#ifdef ERROR_SUCCESS
#undef ERROR_SUCCESS
#endif
#ifdef ERROR_BADDB
#undef ERROR_BADDB
#endif
#ifdef ERROR_BADKEY
#undef ERROR_BADKEY
#endif
#ifdef ERROR_CANTOPEN
#undef ERROR_CANTOPEN
#endif
#ifdef ERROR_CANTREAD
#undef ERROR_CANTREAD
#endif
#ifdef ERROR_CANTWRITE
#undef ERROR_CANTWRITE
#endif
#ifdef ERROR_INSUFFICIENT_MEMORY
#undef ERROR_INSUFFICIENT_MEMORY
#endif
#ifdef ERROR_INVALID_PARAMETER
#undef ERROR_INVALID_PARAMETER
#endif
#ifdef ERROR_ACCESS_DENIED
#undef ERROR_ACCESS_DENIED
#endif
#ifdef HKEY_CLASSES_ROOT
#undef HKEY_CLASSES_ROOT
#endif
#ifndef REG_BINARY
#define REG_BINARY		0x0003
#endif
#ifndef HKEY_CURRENT_CONFIG
#define HKEY_CURRENT_CONFIG	((HKEY)0x80000005)
#endif
#ifndef HKEY_LOCAL_MACHINE
#define HKEY_LOCAL_MACHINE	((HKEY)0x80000002)
#endif
#else	//ifdef SYSDETMG
#include <windows.h>
#endif

#include <winerror.h>
#define NOPRSHT 	//do not include prsht.h
#include <setupx.h>


/*** Miscellaneou macros
 */

#define BYTEOF(d,i)	(((BYTE *)&(d))[i])
#define WORDOF(d,i)	(((WORD *)&(d))[i])
#define LOCAL		PASCAL FAR
#define LOCALC		CDECL FAR
#define DLLENTRY	_loadds WINAPI
#define DEREF(x)	((x) = (x))
#define ALLOC(n)	((VOID FAR *)GlobalAllocPtr(GHND, (n)))
#define FREE(p) 	GlobalFreePtr((p))
#ifdef ERRMSG
  #define CATMSG(p)	CatMsg p
  #define CATERR(rc,p)	{if (rc) CatMsg p;}
#else
  #define CATMSG(p)
  #define CATERR(rc,p)
#endif
#ifdef DEBUG
  #define ENTER(p)	EnterProc p
  #define EXIT(p)	ExitProc p
  #define PRINTTRACE(p) PrintTrace p
#else
  #define ENTER(p)
  #define EXIT(p)
  #define PRINTTRACE(p)
#endif
#define CODESEG 	_based(_segname("_CODE"))


/*** Implementation constants
 */

#define MAX_PATHNAME_LEN	63	//max. length of path name
#define MAX_CLASSNAME_LEN	15	//max. length of device class name
#define MAX_FUNCNAME_LEN	31	//max. length of function name
#define MAX_DEVNAME_LEN 	15	//max. length of device name
#define MAX_INSTNAME_LEN	15	//device instance name length
#define MAX_DOSDEVNAME_LEN	8	//dos device name length
#define MAX_PARAMLINE_LEN	63	//TSR parameter line length
#define MAX_DESC_LEN		63	//max. description length


/*** Callback function error
 */

#define DCBERR_NONE		0x00000000	//no error
#define DCBERR_SKIP		0x80000001	//skip detection function
#define DCBERR_ABORT		0x80000002	//abort detection


/*** Other constants
 */

#define STR_INFNAME_MSDETINF	"msdet.inf"	//main detection INF name

//dwfDetOpen flags
#define DOF_CUSTOM		0x00000001	//custom detection
#define DOF_NORISK		0x00000002	//no risk detection mode
#define DOF_CLEANREG		0x00000004	//clean hw from registry
#define DOF_QUIET		0x00000008	//don't show progress bar
#define DOF_VERBOSE		0x00000010	//detection progress dialog
#define DOF_NORECOVER		0x00000020	//no recover from last crash
#define DOF_MAXCALLBACK 	0x00000040	//maximum callback
#define DOF_PROMPTBEFORE	0x00000080	//prompt before detect
#define DOF_PROGRESSCALLBACK	0x00000100	//do progress callback
#define DOF_INSETUP		0x00000200	//called by Setup
#define DOF_LOGPERFORMANCE	0x00000400	//enable performance logging
#define DOF_ERRORPOPUP		0x00008000	//enable error message box

//dwfDetect flags
#define DETF_NORISK		0x00010000	//no risk detection
#define DETF_VERIFY		0x00020000	//verify mode

//dwCallBackContext
#define CBC_DEVDETECTED 	1	//device detected
#define CBC_REPORTERR		2	//report error
#define CBC_QUERYRES		3	//DMSQueryIOMem has been called
#define CBC_DETECTDONE		4	//detection done
#define CBC_VERIFYDANGER	5	//verifying old danger entry
#define CBC_NEWDANGER		6	//creating new danger entry
#define CBC_DISCARDCRASH	7	//discarding a crash entry
#define CBC_VERIFYDONE		8	//finish verifying devices
#define CBC_BEGINVERIFY 	9	//begin verify
#define CBC_VERIFYPROGRESS	10	//verify progress
#define CBC_BEGINDETECT 	11	//begin detection
#define CBC_DETECTPROGRESS	12	//detection progress
#define CBC_DETECTING		13	//just above to detect a device
#define CBC_DISCARDDANGER	14	//discard a danger entry
#define CBC_SKIPCRASHFUNC	15	//skip a crash function
#define CBC_DMSWRITELOG 	16	//detection module log entry
#define CBC_PERFORMANCE 	17	//log detection performance data

//dwfSearch flags
#define MSF_REALADDR		0x00000001	//real mode address
#define MSF_IGNORECASE		0x00000002	//case insensitive search

//dwResType values
#define RESTYPE_IO		1		//I/O resource
#define RESTYPE_MEM		2		//memory resource
#define RESTYPE_IRQ		3		//irq resource
#define RESTYPE_DMA		4		//dma resource

//Return values of DMSQueryIOMem or DMSQueryIRQDMA
#define RES_NOMATCH	0	//resources have no owner
#define RES_OVERLAP	1	//resources overlap with existing owner
#define RES_MATCH	2	//resources match with existing owner
#define RES_SHARED	3	//resources are shareable by the owner
#define RES_SUPERSET	4	//resources are superset of existing owner


/*** Function type definitions
 */

typedef LONG (DLLENTRY *LPFNDET)(HDET, DWORD, DWORD);
typedef LONG (FAR PASCAL _loadds *LPFNDCB)(DWORD, LPSTR, DWORD);
typedef VOID (FAR PASCAL _loadds *LPFNICB)(DWORD);
typedef VOID (FAR PASCAL *LPFNGEN)();
typedef DWORD (FAR PASCAL _loadds *LPFNPROC)();


/*** Structure and related definitions
 */

#define HANDLE_NULL	0	//null handle
typedef DWORD HDET;		//detection handle
typedef DWORD HDEV;		//device handle
typedef union _REGS FAR *LPREGS;
typedef struct _SREGS FAR *LPSREGS;

#define SYSENVF_EISASYSTEM	0x00000001
#define SYSENVF_MCASYSTEM	0x00000002

#define MACHINFO_MCABUS 	0x02000000	//machine has MCA bus
#define MACHINFO_EXTBIOSAREA	0x04000000	//extended BIOS area allocated
#define MACHINFO_WAITEXTEVENT	0x08000000	//wait ext. event supported
#define MACHINFO_INT154FCALLOUT 0x10000000	//int15/4f callout at int09
#define MACHINFO_CMOSRTC	0x20000000	//CMOS/RTC installed
#define MACHINFO_PIC2		0x40000000	//2nd PIC
#define MACHINFO_HDDMA3 	0x80000000	//hard disk BIOS using DMA3

typedef struct sysenv_s
{
    DWORD dwSDMVersion; 			//byte 0,1=build number
						//byte 2=version minor
						//byte 3=version major
    DWORD dwWinVer;				//byte 0=winver minor
						//byte 1=winver major
						//byte 2=dosver minor
						//byte 3=dosver major
    DWORD dwWinFlags;				//WinFlags from GetWinFlags
    DWORD dwMachineInfo;			//byte 0=model
						//byte 1=sub-model
						//byte 2=BIOS revision
						//byte 3=features
    DWORD dwfSysEnv;				//system environment flags
    char szDetPath[MAX_PATHNAME_LEN + 1];	//detection path string
} SYSENV;

typedef SYSENV *PSYSENV;
typedef SYSENV FAR *LPSYSENV;

typedef struct resinfo_s
{
    int icIO;		//number of I/O resource regions
    int ioffsetIO;	//offset of I/O resource array
    int icMem;		//number of memory resource regions
    int ioffsetMem;	//offset of memory resource array
    int icIRQ;		//number of IRQs
    int ioffsetIRQ;	//offset of IRQ resource array
    int icDMA;		//number of DMAs
    int ioffsetDMA;	//offset of DMA resource array
    int icbResBuff;	//resource buffer size that follows
			//  IOMEM and/or IRQDMA array follows here
} RESINFO;

typedef RESINFO *PRESINFO;
typedef RESINFO FAR *LPRESINFO;

typedef struct ownerinfo_s
{
    char szClassName[MAX_CLASSNAME_LEN + 1];	//owner's class name
    char szDevName[MAX_DEVNAME_LEN + 1];	//owner's device name
    HDEV hdevOwner;				//owner's device handle
    LPRESINFO lpresinfo;			//resource info.
} OWNERINFO;

typedef OWNERINFO *POWNERINFO;
typedef OWNERINFO FAR *LPOWNERINFO;

typedef struct iomem_s
{
    DWORD dwStartAddr;		//region starting address
    DWORD dwEndAddr;		//region ending address
    DWORD dwDecodeMask; 	//decode mask (don't care aliases)
    DWORD dwAliasMask;		//alias mask (used aliases)
    DWORD dwResAttr;		//region attributes
} IOMEM;

typedef IOMEM *PIOMEM;
typedef IOMEM FAR *LPIOMEM;

typedef struct irqdma_s
{
    DWORD dwResNum;		//IRQ or DMA number
    DWORD dwResAttr;		//attributes for this IRQ or DMA
} IRQDMA;

typedef IRQDMA *PIRQDMA;
typedef IRQDMA FAR *LPIRQDMA;

//dwfDev flags
#define DEVF_CHARDEV	0x00000001	//lpstrDevName is a char dev name

typedef struct dosdev_s
{
    char szFileName[MAX_DOSDEVNAME_LEN + 1];//driver filename to query
    char szDevName[MAX_DOSDEVNAME_LEN + 1];//to hold device name
    WORD wfDevAttr;			//to hold device attribute
    WORD wcUnits;			//to hold number of block dev units
    WORD wbitIRQs;			//to hold IRQ bit vector used by dev.
    DWORD dwDevHdrPtr;			//to hold pointer to device header
    DWORD dwNextDevHdrPtr;		//to hold pointer to next in chain
} DOSDEV;

typedef DOSDEV *PDOSDEV;
typedef DOSDEV FAR *LPDOSDEV;

typedef struct dostsr_s
{
    char szPathName[MAX_PATH_LEN + 1];	//to hold the TSR full path name
    char szMCBOwner[9];
    WORD segTSRPSP;			//to hold TSR's segment address
    WORD wcparaTSRSize; 		//to hold TSR's size in paragrahs
    WORD segParentPSP;
    WORD wbitIRQs;			//to hold IRQ bit vector used by TSR
    char szParamLine[MAX_PARAMLINE_LEN + 1];//to hold TSR's parameter line
    DWORD dwNextMCBPtr; 		//to hold the seg addr of next MCB
} DOSTSR;

typedef DOSTSR *PDOSTSR;
typedef DOSTSR FAR *LPDOSTSR;

#define MAX_MCA_SLOTS		8

/*** EISA related stuff
 */

#define MAX_EISAID_LEN		7
#define MAX_EISA_SLOTS		16
#define MAX_IOCONFIGS		20
#define MAX_MEMCONFIGS		9
#define MAX_IRQCONFIGS		7
#define MAX_DMACONFIGS		4

#define IDSLOT_DUPID		0x0080
#define IDSLOT_NOREADID 	0x0040
#define IDSLOT_SLOTTYPEMASK	0x0030
#define IDSLOT_EXPANSLOT	0x0000
#define IDSLOT_EMBEDSLOT	0x0010
#define IDSLOT_VIRTSLOT 	0x0020
#define IDSLOT_DUPCFGIDMASK	0x000f
#define IDSLOT_INCOMPLETECONFIG 0x8000
#define IDSLOT_SUPPORTIOCHKERR	0x0200
#define IDSLOT_SUPPORTENABLE	0x0100

#define FUNCINFO_FUNCDISABLED	0x80
#define FUNCINFO_FREEFORMDATA	0x40
#define FUNCINFO_IOINITENTRIES	0x20
#define FUNCINFO_IORANGEENTRIES 0x10
#define FUNCINFO_DMAENTRIES	0x08
#define FUNCINFO_IRQENTRIES	0x04
#define FUNCINFO_MEMENTRIES	0x02
#define FUNCINFO_TYPEENTRY	0x01

#define PORTINFO_MOREENTRIES	0x80
#define PORTINFO_SHARED 	0x40
#define PORTINFO_NUMPORTMASK	0x1f

#define MEMCFG_MOREENTRIES	0x80
#define MEMCFG_SHARED		0x20
#define MEMCFG_MEMTYPEMASK	0x18
#define MEMCFG_CACHED		0x02
#define MEMCFG_READWRITE	0x01

#define MEMSIZ_DECODEMASK	0x0c
#define MEMSIZ_DECODE20BIT	0x00
#define MEMSIZ_DECODE24BIT	0x04
#define MEMSIZ_DECODE32BIT	0x08

#define IRQCFG_MOREENTRIES	0x80
#define IRQCFG_SHARED		0x40
#define IRQCFG_LEVELTRIGGERED	0x20
#define IRQCFG_INTNUMMASK	0x0f

#define DMACFG_MOREENTRIES	0x0080
#define DMACFG_SHARED		0x0040
#define DMACFG_DMANUMMASK	0x0007
#define DMACFG_TIMINGMASK	0x3000
#define DMACFG_XFERSIZEMASK	0x0c00


#pragma pack(1)
typedef struct memconfig_s
{
    BYTE  bMemConfig;
    BYTE  bMemDataSize;
    BYTE  bStartAddrLo; 	//divided by 0x100
    WORD  wStartAddrHi;
    WORD  wMemSize;		//divided by 0x400
} MEMCONFIG;


typedef struct ioconfig_s
{
    BYTE  bPortInfo;
    WORD  wStartPort;
} IOCONFIG;


typedef struct initdata_s
{
    BYTE  bInitType;
    WORD  wPortAddr;
} INITDATA;


typedef struct eisaconfig_s
{
    DWORD dwEISAID;
    WORD  wIDSlotInfo;
    BYTE  bMajorRev;
    BYTE  bMinorRev;
    BYTE  abSelections[26];
    BYTE  bFuncInfo;
    char  achTypeInfo[80];
    MEMCONFIG amemconfig[MAX_MEMCONFIGS];
    WORD  awIRQConfig[MAX_IRQCONFIGS];
    WORD  awDMAConfig[MAX_DMACONFIGS];
    IOCONFIG aioconfig[MAX_IOCONFIGS];
    INITDATA ainitdata[20];
} EISACONFIG;

typedef EISACONFIG FAR *LPEISACONFIG;


/*** DPMI call structure
 */

typedef struct dwregs_s
{
    DWORD   edi;
    DWORD   esi;
    DWORD   ebp;
    DWORD   rmdw1;
    DWORD   ebx;
    DWORD   edx;
    DWORD   ecx;
    DWORD   eax;
} DWREGS;

typedef struct wregs_s
{
    WORD    di;
    WORD    rmw1;
    WORD    si;
    WORD    rmw2;
    WORD    bp;
    WORD    rmw3;
    DWORD   rmw4;
    WORD    bx;
    WORD    rmw5;
    WORD    dx;
    WORD    rmw6;
    WORD    cx;
    WORD    rmw7;
    WORD    ax;
} WREGS;

typedef struct bregs_s
{
    DWORD   rmb1[4];
    BYTE    bl;
    BYTE    bh;
    WORD    rmb2;
    BYTE    dl;
    BYTE    dh;
    WORD    rmb3;
    BYTE    cl;
    BYTE    ch;
    WORD    rmb4;
    BYTE    al;
    BYTE    ah;
} BREGS;

typedef struct rmcs_s
{
    union
    {
	DWREGS	dw;
	WREGS	w;
	BREGS	b;
    }	    regs;
    WORD    flags;
    WORD    es;
    WORD    ds;
    WORD    fs;
    WORD    gs;
    WORD    ip;
    WORD    cs;
    WORD    sp;
    WORD    ss;
} RMCS, FAR *LPRMCS;
#pragma pack()


/*** SDS Services prototypes
 */

LONG DLLENTRY SDSOpen(HWND hwnd, LPCSTR lpstrDetPath, WORD wfDetOpen,
		      LPFNDCB lpfnCallBack, LPSTR lpstrParams);
LONG DLLENTRY SDSClose(VOID);
LONG DLLENTRY SDSDetect(LPSTR lpstrClass, LPSTR lpstrFunc, WORD wfDetect,
			DWORD dwDetParam);
LONG DLLENTRY SDSRegAvoidRes(int icIO, LPIOMEM lpaio,
			     int icMem, LPIOMEM lpamem,
			     int icIRQ, LPIRQDMA lpairq,
			     int icDMA, LPIRQDMA lpadma);
VOID DLLENTRY SDSGetErrMsg(LONG lErr, LPSTR lpstrBuff, int icbLen);


/*** DMS Services prototypes
 */

VOID _loadds FAR CDECL CatMsg(LPCSTR lpstrFormat, ...);
VOID _loadds FAR CDECL EnterProc(int iTraceLevel, LPCSTR lpstrFormat, ...);
VOID _loadds FAR CDECL ExitProc(int iTraceLevel, LPCSTR lpstrFormat, ...);
VOID _loadds FAR CDECL PrintTrace(int iTraceLevel, LPCSTR lpstrFormat, ...);
LONG DLLENTRY DMSQueryIOMem(HDET hdet, int iResType, int icEntries,
			    LPIOMEM lpaiomem, LPOWNERINFO lpownerinfo);
LONG DLLENTRY DMSQueryIRQDMA(HDET hdet, int iResType, int icEntries,
			     LPIRQDMA lpairqdma, LPOWNERINFO lpownerinfo);
LONG DLLENTRY DMSRegHW(HDET hdet, LPSTR lpstrHWName,
		       HKEY FAR *lphkHW, HINF FAR *lphinfHW,
		       int icIO, LPIOMEM lpaio,
		       int icMem, LPIOMEM lpamem,
		       int icIRQ, LPIRQDMA lpairq,
		       int icDMA, LPIRQDMA lpadma,
		       WORD wfRegHW);
int DLLENTRY DMSInp(unsigned uPort);
unsigned DLLENTRY DMSInpw(unsigned uPort);
DWORD DLLENTRY DMSInpdw(unsigned uPort);
int DLLENTRY DMSOutp(unsigned uPort, int iData);
unsigned DLLENTRY DMSOutpw(unsigned uPort, unsigned uData);
DWORD DLLENTRY DMSOutpdw(unsigned uPort, DWORD dwData);
int DLLENTRY DMSDetectIRQ(unsigned uIRQMask, LPFNICB lpfnIntOn,
			  LPFNICB lpfnIntOff, DWORD dwParam);
BOOL DLLENTRY DMSTimeout(DWORD dwcTicks);
VOID DLLENTRY DMSDelayTicks(DWORD dwcTicks);
LPBYTE DLLENTRY DMSGetMemAlias(DWORD dwRealMemAddr, DWORD dwcbSize);
VOID DLLENTRY DMSFreeMemAlias(LPBYTE lpbMemAlias);
LPBYTE DLLENTRY DMSFindMemStr(LPBYTE lpbAddr, DWORD dwcbSize, LPCSTR lpstr,
			      WORD wfSearch);
LONG DLLENTRY DMSQueryDosDev(DWORD dwDevHdrPtr, LPCSTR lpstrDevName,
			     WORD wfDev, LPDOSDEV lpdosdev);
LONG DLLENTRY DMSQueryDosTSR(DWORD dwMCBPtr, LPSTR lpstrTSRName,
			     LPDOSTSR lpdostsr);
VOID DLLENTRY DMSQuerySysEnv(LPSYSENV lpsysenv);
LONG DLLENTRY DMSGetIHVEISADevSlots(LPCSTR lpstrIHVID);
LONG DLLENTRY DMSGetSlotEISAID(int iSlot, LPSTR lpstrDevID);
LONG DLLENTRY DMSGetEISAFuncConfig(int iSlot, int iFunc,
				   LPEISACONFIG lpcfg, LPSTR lpstrEISAID);
BOOL DLLENTRY DMSGetEISACardConfig(int iSlot, LPSTR lpstrDevID,
				   int FAR *lpicIO, LPIOMEM lpaio,
				   int FAR *lpicMem, LPIOMEM lpamem,
				   int FAR *lpicIRQ, LPIRQDMA lpairq,
				   int FAR *lpicDMA, LPIRQDMA lpadma,
				   WORD wcbTypeBuff, LPSTR lpstrTypeBuff);
LONG DLLENTRY DMSGetMCADevSlots(WORD wMCAID);
LONG DLLENTRY DMSGetSlotMCAID(int iSlot);
int DLLENTRY DMSInt86x(int iIntNum, LPREGS lpregsIn, LPREGS lpregsOut,
		       LPSREGS lpsregs);
BOOL DLLENTRY DMSQueryVerifyState(HDET hdet);
LPSTR DLLENTRY DMSCatPath(LPSTR lpstrPath, LPSTR lpstrName);
LPSTR DLLENTRY DMSGetWinDir(LPSTR lpstrWinDir, int icbBuffLen);
LPFNPROC DLLENTRY DMSRegRing0Proc(LPFNPROC lpfnR3Proc, int icwArg);
VOID DLLENTRY DMSFreeRing0Proc(LPFNPROC lpfnR0Proc);
LONG DLLENTRY DMSWriteLog(LPSTR lpstrMsg);


/*** Module function error codes
 */

#define MODERR_NONE		0L		//no error
#define MODERR_SDMERR		0x80008001	//sysdetmg error
#define MODERR_REGERR		0x80008002	//cannot access registry
#define MODERR_UNRECOVERABLE	0x80000003	//unrecoverable error

#endif	//_INC_SYSDETMG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\tapi.h ===
// The  Telephony  API  is jointly copyrighted by Intel and Microsoft.  You are
// granted  a royalty free worldwide, unlimited license to make copies, and use
// the   API/SPI  for  making  applications/drivers  that  interface  with  the
// specification provided that this paragraph and the Intel/Microsoft copyright
// statement is maintained as is in the text and source code files.
//
// Copyright 1994 Microsoft, all rights reserved.
// Portions copyright 1992, 1993 Intel/Microsoft, all rights reserved.

#ifndef TAPI_H
#define TAPI_H

#include <windows.h>

#pragma pack(1)
// Type definitions of the data types used in tapi

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


#define DECLARE_OPAQUE32(name)  struct name##__ { int unused; }; \
				typedef const struct name##__ FAR* name

DECLARE_OPAQUE32(HCALL);
typedef HCALL FAR * LPHCALL;

DECLARE_OPAQUE32(HLINE);
typedef HLINE FAR * LPHLINE;

DECLARE_OPAQUE32(HPHONE);
typedef HPHONE FAR * LPHPHONE;

DECLARE_OPAQUE32(HLINEAPP);
typedef HLINEAPP FAR * LPHLINEAPP;

DECLARE_OPAQUE32(HPHONEAPP);
typedef HPHONEAPP FAR * LPHPHONEAPP;

typedef HICON FAR * LPHICON;
// typedef of the LINE callback procedure
typedef void (CALLBACK * LINECALLBACK)  (DWORD hDevice,
					      DWORD dwMessage,
					      DWORD dwInstance,
					      DWORD dwParam1,
					      DWORD dwParam2,
					      DWORD dwParam3);

// typedef of the PHONE callback procedure
typedef void (CALLBACK * PHONECALLBACK)  (DWORD hDevice,
					       DWORD dwMessage,
					       DWORD dwInstance,
					       DWORD dwParam1,
					       DWORD dwParam2,
					       DWORD dwParam3);


// Messages for Phones and Lines

#define LINE_ADDRESSSTATE           0L
#define LINE_CALLINFO               1L
#define LINE_CALLSTATE              2L
#define LINE_CLOSE                  3L
#define LINE_DEVSPECIFIC            4L
#define LINE_DEVSPECIFICFEATURE 5L
#define LINE_GATHERDIGITS           6L
#define LINE_GENERATE               7L
#define LINE_LINEDEVSTATE           8L
#define LINE_MONITORDIGITS          9L
#define LINE_MONITORMEDIA           10L
#define LINE_MONITORTONE            11L
#define LINE_REPLY                  12L
#define LINE_REQUEST                    13L
#define PHONE_BUTTON                    14L
#define PHONE_CLOSE                 15L
#define PHONE_DEVSPECIFIC           16L
#define PHONE_REPLY                 17L
#define PHONE_STATE                 18L
#define LINE_CREATE                                     19L
#define PHONE_CREATE                                    20L

// Define Simple Telephony Constants.

#define TAPI_REPLY                    WM_USER + 99

#define TAPIERR_CONNECTED           0L
#define TAPIERR_DROPPED             -1L
#define TAPIERR_NOREQUESTRECIPIENT  -2L
#define TAPIERR_REQUESTQUEUEFULL    -3L
#define TAPIERR_INVALDESTADDRESS    -4L
#define TAPIERR_INVALWINDOWHANDLE   -5L
#define TAPIERR_INVALDEVICECLASS    -6L
#define TAPIERR_INVALDEVICEID       -7L
#define TAPIERR_DEVICECLASSUNAVAIL  -8L    
#define TAPIERR_DEVICEIDUNAVAIL     -9L    
#define TAPIERR_DEVICEINUSE         -10L    
#define TAPIERR_DESTBUSY            -11L    
#define TAPIERR_DESTNOANSWER        -12L    
#define TAPIERR_DESTUNAVAIL         -13L    
#define TAPIERR_UNKNOWNWINHANDLE    -14L    
#define TAPIERR_UNKNOWNREQUESTID    -15L    
#define TAPIERR_REQUESTFAILED       -16L
#define TAPIERR_REQUESTCANCELLED    -17L
#define TAPIERR_INVALPOINTER        -18L


#define TAPIMAXDESTADDRESSSIZE    80L 
#define TAPIMAXAPPNAMESIZE        40L
#define TAPIMAXCALLEDPARTYSIZE    40L
#define TAPIMAXCOMMENTSIZE        80L
#define TAPIMAXDEVICECLASSSIZE    40L
#define TAPIMAXDEVICEIDSIZE       40L


// Data types and values for Phones


#define PHONEBUTTONFUNCTION_UNKNOWN          0x00000000
#define PHONEBUTTONFUNCTION_CONFERENCE       0x00000001
#define PHONEBUTTONFUNCTION_TRANSFER         0x00000002
#define PHONEBUTTONFUNCTION_DROP             0x00000003
#define PHONEBUTTONFUNCTION_HOLD             0x00000004
#define PHONEBUTTONFUNCTION_RECALL           0x00000005
#define PHONEBUTTONFUNCTION_DISCONNECT       0x00000006
#define PHONEBUTTONFUNCTION_CONNECT          0x00000007
#define PHONEBUTTONFUNCTION_MSGWAITON        0x00000008
#define PHONEBUTTONFUNCTION_MSGWAITOFF       0x00000009
#define PHONEBUTTONFUNCTION_SELECTRING       0x0000000A
#define PHONEBUTTONFUNCTION_ABBREVDIAL       0x0000000B
#define PHONEBUTTONFUNCTION_FORWARD          0x0000000C
#define PHONEBUTTONFUNCTION_PICKUP           0x0000000D
#define PHONEBUTTONFUNCTION_RINGAGAIN        0x0000000E
#define PHONEBUTTONFUNCTION_PARK             0x0000000F
#define PHONEBUTTONFUNCTION_REJECT           0x00000010
#define PHONEBUTTONFUNCTION_REDIRECT         0x00000011
#define PHONEBUTTONFUNCTION_MUTE             0x00000012
#define PHONEBUTTONFUNCTION_VOLUMEUP         0x00000013
#define PHONEBUTTONFUNCTION_VOLUMEDOWN       0x00000014
#define PHONEBUTTONFUNCTION_SPEAKERON        0x00000015
#define PHONEBUTTONFUNCTION_SPEAKEROFF       0x00000016
#define PHONEBUTTONFUNCTION_FLASH            0x00000017
#define PHONEBUTTONFUNCTION_DATAON           0x00000018
#define PHONEBUTTONFUNCTION_DATAOFF          0x00000019
#define PHONEBUTTONFUNCTION_DONOTDISTURB     0x0000001A
#define PHONEBUTTONFUNCTION_INTERCOM         0x0000001B
#define PHONEBUTTONFUNCTION_BRIDGEDAPP       0x0000001C
#define PHONEBUTTONFUNCTION_BUSY             0x0000001D
#define PHONEBUTTONFUNCTION_CALLAPP          0x0000001E
#define PHONEBUTTONFUNCTION_DATETIME         0x0000001F
#define PHONEBUTTONFUNCTION_DIRECTORY        0x00000020
#define PHONEBUTTONFUNCTION_COVER            0x00000021
#define PHONEBUTTONFUNCTION_CALLID           0x00000022
#define PHONEBUTTONFUNCTION_LASTNUM          0x00000023
#define PHONEBUTTONFUNCTION_NIGHTSRV         0x00000024
#define PHONEBUTTONFUNCTION_SENDCALLS        0x00000025
#define PHONEBUTTONFUNCTION_MSGINDICATOR     0x00000026
#define PHONEBUTTONFUNCTION_REPDIAL          0x00000027
#define PHONEBUTTONFUNCTION_SETREPDIAL       0x00000028
#define PHONEBUTTONFUNCTION_SYSTEMSPEED      0x00000029
#define PHONEBUTTONFUNCTION_STATIONSPEED     0x0000002A
#define PHONEBUTTONFUNCTION_CAMPON           0x0000002B
#define PHONEBUTTONFUNCTION_SAVEREPEAT       0x0000002C
#define PHONEBUTTONFUNCTION_QUEUECALL        0x0000002D
#define PHONEBUTTONFUNCTION_NONE             0x0000002E

typedef struct phonebuttoninfo_tag {
    DWORD    dwTotalSize;
    DWORD    dwNeededSize;
    DWORD    dwUsedSize;

    DWORD    dwButtonMode;
    DWORD    dwButtonFunction;

    DWORD    dwButtonTextSize;
    DWORD    dwButtonTextOffset;

    DWORD    dwDevSpecificSize;
    DWORD    dwDevSpecificOffset;
} PHONEBUTTONINFO, FAR *LPPHONEBUTTONINFO;

#define PHONEBUTTONMODE_DUMMY        0x00000001
#define PHONEBUTTONMODE_CALL         0x00000002
#define PHONEBUTTONMODE_FEATURE      0x00000004
#define PHONEBUTTONMODE_KEYPAD       0x00000008
#define PHONEBUTTONMODE_LOCAL        0x00000010
#define PHONEBUTTONMODE_DISPLAY      0x00000020

#define PHONEBUTTONSTATE_UP          0x00000001
#define PHONEBUTTONSTATE_DOWN        0x00000002

typedef struct phoneextensionid_tag {
    DWORD    dwExtensionID0;
    DWORD    dwExtensionID1;
    DWORD    dwExtensionID2;
    DWORD    dwExtensionID3;
} PHONEEXTENSIONID, FAR *LPPHONEEXTENSIONID;


typedef struct phonecaps_tag {
    DWORD    dwTotalSize;
    DWORD    dwNeededSize;
    DWORD    dwUsedSize;

    DWORD    dwProviderInfoSize;
    DWORD    dwProviderInfoOffset;

    DWORD    dwPhoneInfoSize;
    DWORD    dwPhoneInfoOffset;

    DWORD    dwPermanentPhoneID;
    DWORD    dwPhoneNameSize;
    DWORD    dwPhoneNameOffset;
    DWORD    dwStringFormat;    

    DWORD    dwPhoneStates;
    DWORD    dwHookSwitchDevs;
    DWORD    dwHandsetHookSwitchModes;
    DWORD    dwSpeakerHookSwitchModes;
    DWORD    dwHeadsetHookSwitchModes;

    DWORD    dwVolumeFlags;
    DWORD    dwGainFlags;
    DWORD    dwDisplayNumRows;
    DWORD    dwDisplayNumColumns;
    DWORD    dwNumRingModes;
    DWORD    dwNumButtonLamps;

    DWORD    dwButtonModesSize;
    DWORD    dwButtonModesOffset;

    DWORD    dwButtonFunctionsSize;
    DWORD    dwButtonFunctionsOffset;

    DWORD    dwLampModesSize;
    DWORD    dwLampModesOffset;

    DWORD    dwNumSetData;
    DWORD    dwSetDataSize;
    DWORD    dwSetDataOffset;

    DWORD    dwNumGetData;
    DWORD    dwGetDataSize;
    DWORD    dwGetDataOffset;

    DWORD    dwDevSpecificSize;
    DWORD    dwDevSpecificOffset;

} PHONECAPS, FAR *LPPHONECAPS;

#define PHONEERR_ALLOCATED              0x90000001
#define PHONEERR_BADDEVICEID            0x90000002
#define PHONEERR_INCOMPATIBLEAPIVERSION 0x90000003
#define PHONEERR_INCOMPATIBLEEXTVERSION 0x90000004
#define PHONEERR_INIFILECORRUPT         0x90000005
#define PHONEERR_INUSE                  0x90000006
#define PHONEERR_INVALAPPHANDLE         0x90000007
#define PHONEERR_INVALAPPNAME           0x90000008
#define PHONEERR_INVALBUTTONLAMPID      0x90000009
#define PHONEERR_INVALBUTTONMODE        0x9000000A
#define PHONEERR_INVALBUTTONSTATE       0x9000000B
#define PHONEERR_INVALDATAID            0x9000000C
#define PHONEERR_INVALDEVICECLASS       0x9000000D
#define PHONEERR_INVALEXTVERSION        0x9000000E
#define PHONEERR_INVALHOOKSWITCHDEV     0x9000000F
#define PHONEERR_INVALHOOKSWITCHMODE    0x90000010
#define PHONEERR_INVALLAMPMODE          0x90000011
#define PHONEERR_INVALPARAM             0x90000012
#define PHONEERR_INVALPHONEHANDLE       0x90000013
#define PHONEERR_INVALPHONESTATE        0x90000014
#define PHONEERR_INVALPOINTER           0x90000015
#define PHONEERR_INVALPRIVILEGE         0x90000016
#define PHONEERR_INVALRINGMODE          0x90000017
#define PHONEERR_NODEVICE               0x90000018
#define PHONEERR_NODRIVER               0x90000019
#define PHONEERR_NOMEM                  0x9000001A
#define PHONEERR_NOTOWNER               0x9000001B
#define PHONEERR_OPERATIONFAILED        0x9000001C
#define PHONEERR_OPERATIONUNAVAIL       0x9000001D
#define PHONEERR_RESOURCEUNAVAIL        0x9000001F
#define PHONEERR_REQUESTOVERRUN         0x90000020              
#define PHONEERR_STRUCTURETOOSMALL      0x90000021
#define PHONEERR_UNINITIALIZED          0x90000022
#define PHONEERR_REINIT                 0x90000023

#define PHONEHOOKSWITCHDEV_HANDSET      0x00000001
#define PHONEHOOKSWITCHDEV_SPEAKER      0x00000002
#define PHONEHOOKSWITCHDEV_HEADSET      0x00000004
	      
#define PHONEHOOKSWITCHMODE_ONHOOK      0x00000001
#define PHONEHOOKSWITCHMODE_MIC         0x00000002
#define PHONEHOOKSWITCHMODE_SPEAKER     0x00000004
#define PHONEHOOKSWITCHMODE_MICSPEAKER  0x00000008
#define PHONEHOOKSWITCHMODE_UNKNOWN     0x00000010              

#define PHONELAMPMODE_DUMMY              0x00000001
#define PHONELAMPMODE_OFF                0x00000002
#define PHONELAMPMODE_STEADY             0x00000004
#define PHONELAMPMODE_WINK               0x00000008
#define PHONELAMPMODE_FLASH              0x00000010
#define PHONELAMPMODE_FLUTTER            0x00000020
#define PHONELAMPMODE_BROKENFLUTTER      0x00000040
#define PHONELAMPMODE_UNKNOWN            0x00000080


#define PHONEPRIVILEGE_MONITOR        0x00000001
#define PHONEPRIVILEGE_OWNER          0x00000002

#define PHONESTATE_OTHER               0x00000001
#define PHONESTATE_CONNECTED           0x00000002
#define PHONESTATE_DISCONNECTED        0x00000004
#define PHONESTATE_OWNER               0x00000008
#define PHONESTATE_MONITORS            0x00000010
#define PHONESTATE_DISPLAY             0x00000020
#define PHONESTATE_LAMP                0x00000040
#define PHONESTATE_RINGMODE            0x00000080
#define PHONESTATE_RINGVOLUME          0x00000100
#define PHONESTATE_HANDSETHOOKSWITCH   0x00000200
#define PHONESTATE_HANDSETVOLUME       0x00000400
#define PHONESTATE_HANDSETGAIN         0x00000800
#define PHONESTATE_SPEAKERHOOKSWITCH   0x00001000
#define PHONESTATE_SPEAKERVOLUME       0x00002000
#define PHONESTATE_SPEAKERGAIN         0x00004000
#define PHONESTATE_HEADSETHOOKSWITCH   0x00008000
#define PHONESTATE_HEADSETVOLUME       0x00010000
#define PHONESTATE_HEADSETGAIN         0x00020000
#define PHONESTATE_SUSPEND             0x00040000
#define PHONESTATE_RESUME              0x00080000
#define PHONESTATE_DEVSPECIFIC         0x00100000
#define PHONESTATE_REINIT              0x00200000
/* Tapi 1.1 change */
#define PHONESTATE_CAPSCHANGE               0x00400000


typedef struct phonestatus_tag {
    DWORD    dwTotalSize;
    DWORD    dwNeededSize;
    DWORD    dwUsedSize;

    DWORD    dwStatusFlags; 
    DWORD    dwNumOwners;
    DWORD    dwNumMonitors;
    DWORD    dwRingMode;
    DWORD    dwRingVolume;

    DWORD    dwHandsetHookSwitchMode;
    DWORD    dwHandsetVolume;
    DWORD    dwHandsetGain;

    DWORD    dwSpeakerHookSwitchMode;
    DWORD    dwSpeakerVolume;
    DWORD    dwSpeakerGain;

    DWORD    dwHeadsetHookSwitchMode;
    DWORD    dwHeadsetVolume;
    DWORD    dwHeadsetGain;

    DWORD    dwDisplaySize;
    DWORD    dwDisplayOffset;

    DWORD    dwLampModesSize;
    DWORD    dwLampModesOffset;

    DWORD    dwOwnerNameSize;
    DWORD    dwOwnerNameOffset;

    DWORD    dwDevSpecificSize;
    DWORD    dwDevSpecificOffset;
} PHONESTATUS, FAR *LPPHONESTATUS;

#define PHONESTATUSFLAGS_CONNECTED    0x00000001
#define PHONESTATUSFLAGS_SUSPENDED    0x00000002

#define STRINGFORMAT_ASCII   0x00000001
#define STRINGFORMAT_DBCS    0x00000002
#define STRINGFORMAT_UNICODE 0x00000003
#define STRINGFORMAT_BINARY  0x00000004

typedef struct varstring_tag {
    DWORD    dwTotalSize;
    DWORD    dwNeededSize;
    DWORD    dwUsedSize;

    DWORD    dwStringFormat;
    DWORD    dwStringSize;
    DWORD    dwStringOffset;
} VARSTRING, FAR *LPVARSTRING;

// Data types and values for Lines


#define LINEADDRCAPFLAGS_FWDNUMRINGS        0x00000001
#define LINEADDRCAPFLAGS_PICKUPGROUPID      0x00000002    
#define LINEADDRCAPFLAGS_SECURE             0x00000004
#define LINEADDRCAPFLAGS_BLOCKIDDEFAULT     0x00000008
#define LINEADDRCAPFLAGS_BLOCKIDOVERRIDE    0x00000010
#define LINEADDRCAPFLAGS_DIALED             0x00000020
#define LINEADDRCAPFLAGS_ORIGOFFHOOK        0x00000040
#define LINEADDRCAPFLAGS_DESTOFFHOOK        0x00000080
#define LINEADDRCAPFLAGS_FWDCONSULT         0x00000100
#define LINEADDRCAPFLAGS_SETUPCONFNULL      0x00000200
#define LINEADDRCAPFLAGS_AUTORECONNECT      0x00000400
#define LINEADDRCAPFLAGS_COMPLETIONID       0x00000800
#define LINEADDRCAPFLAGS_TRANSFERHELD       0x00001000
#define LINEADDRCAPFLAGS_TRANSFERMAKE       0x00002000
#define LINEADDRCAPFLAGS_CONFERENCEHELD     0x00004000
#define LINEADDRCAPFLAGS_CONFERENCEMAKE     0x00008000
#define LINEADDRCAPFLAGS_PARTIALDIAL        0x00010000
#define LINEADDRCAPFLAGS_FWDSTATUSVALID     0x00020000
#define LINEADDRCAPFLAGS_FWDINTEXTADDR      0x00040000
#define LINEADDRCAPFLAGS_FWDBUSYNAADDR      0x00080000
#define LINEADDRCAPFLAGS_ACCEPTTOALERT      0x00100000
#define LINEADDRCAPFLAGS_CONFDROP           0x00200000
#define LINEADDRCAPFLAGS_PICKUPCALLWAIT     0x00400000

typedef struct lineaddresscaps_tag {
    DWORD    dwTotalSize;
    DWORD    dwNeededSize;
    DWORD    dwUsedSize;

    DWORD    dwLineDeviceID;

    DWORD    dwAddressSize;
    DWORD    dwAddressOffset;

    DWORD    dwDevSpecificSize;
    DWORD    dwDevSpecificOffset;

    DWORD    dwAddressSharing;
    DWORD    dwAddressStates;
    DWORD    dwCallInfoStates;
    DWORD    dwCallerIDFlags;
    DWORD    dwCalledIDFlags;
    DWORD    dwConnectedIDFlags;
    DWORD    dwRedirectionIDFlags;
    DWORD    dwRedirectingIDFlags;
    DWORD    dwCallStates;
    DWORD    dwDialToneModes;
    DWORD    dwBusyModes;
    DWORD    dwSpecialInfo;
    DWORD    dwDisconnectModes;

    DWORD    dwMaxNumActiveCalls;
    DWORD    dwMaxNumOnHoldCalls;
    DWORD    dwMaxNumOnHoldPendingCalls;
    DWORD    dwMaxNumConference;
    DWORD    dwMaxNumTransConf;

    DWORD    dwAddrCapFlags;
    DWORD    dwCallFeatures;
    DWORD    dwRemoveFromConfCaps;
    DWORD    dwRemoveFromConfState;
    DWORD    dwTransferModes;
    DWORD    dwParkModes;

    DWORD    dwForwardModes;
    DWORD    dwMaxForwardEntries;
    DWORD    dwMaxSpecificEntries;
    DWORD    dwMinFwdNumRings;
    DWORD    dwMaxFwdNumRings;

    DWORD    dwMaxCallCompletions;
    DWORD    dwCallCompletionConds;
    DWORD    dwCallCompletionModes;
    DWORD    dwNumCompletionMessages;
    DWORD    dwCompletionMsgTextEntrySize;
    DWORD    dwCompletionMsgTextSize;
    DWORD    dwCompletionMsgTextOffset;
/* Tapi 1.1 extension (ATM support) */
    DWORD    dwAddressFeatures;
} LINEADDRESSCAPS, FAR *LPLINEADDRESSCAPS;

#define LINEADDRESSMODE_ADDRESSID        0x00000001
#define LINEADDRESSMODE_DIALABLEADDR     0x00000002


#define LINEADDRESSSHARING_PRIVATE        0x00000001
#define LINEADDRESSSHARING_BRIDGEDEXCL    0x00000002
#define LINEADDRESSSHARING_BRIDGEDNEW     0x00000004
#define LINEADDRESSSHARING_BRIDGEDSHARED  0x00000008
#define LINEADDRESSSHARING_MONITORED      0x00000010

#define LINEADDRESSSTATE_OTHER            0x00000001
#define LINEADDRESSSTATE_DEVSPECIFIC      0x00000002
#define LINEADDRESSSTATE_INUSEZERO        0x00000004
#define LINEADDRESSSTATE_INUSEONE         0x00000008
#define LINEADDRESSSTATE_INUSEMANY        0x00000010
#define LINEADDRESSSTATE_NUMCALLS         0x00000020
#define LINEADDRESSSTATE_FORWARD          0x00000040
#define LINEADDRESSSTATE_TERMINALS        0x00000080
/* Tapi 1.1 change */
#define LINEADDRESSSTATE_CAPSCHANGE         0x00000100

typedef struct lineaddressstatus_tag {
    DWORD    dwTotalSize;
    DWORD    dwNeededSize;
    DWORD    dwUsedSize;

    DWORD    dwNumInUse;
    DWORD    dwNumActiveCalls;
    DWORD    dwNumOnHoldCalls;
    DWORD    dwNumOnHoldPendCalls;
    DWORD    dwAddressFeatures;

    DWORD    dwNumRingsNoAnswer;
    DWORD    dwForwardNumEntries;
    DWORD    dwForwardSize;
    DWORD    dwForwardOffset;

    DWORD    dwTerminalModesSize;
    DWORD    dwTerminalModesOffset;

    DWORD    dwDevSpecificSize;
    DWORD    dwDevSpecificOffset;
} LINEADDRESSSTATUS, FAR *LPLINEADDRESSSTATUS;

#define LINEADDRFEATURE_FORWARD           0x00000001
#define LINEADDRFEATURE_MAKECALL          0x00000002
#define LINEADDRFEATURE_PICKUP            0x00000004
#define LINEADDRFEATURE_SETMEDIACONTROL   0x00000008
#define LINEADDRFEATURE_SETTERMINAL       0x00000010
#define LINEADDRFEATURE_SETUPCONF         0x00000020
#define LINEADDRFEATURE_UNCOMPLETECALL    0x00000040
#define LINEADDRFEATURE_UNPARK            0x00000080


#define LINEANSWERMODE_NONE    0x00000001
#define LINEANSWERMODE_DROP    0x00000002
#define LINEANSWERMODE_HOLD    0x00000004

#define LINEBEARERMODE_VOICE            0x00000001
#define LINEBEARERMODE_SPEECH           0x00000002
#define LINEBEARERMODE_MULTIUSE         0x00000004
#define LINEBEARERMODE_DATA             0x00000008
#define LINEBEARERMODE_ALTSPEECHDATA    0x00000010
#define LINEBEARERMODE_NONCALLSIGNALING 0x00000020

#define LINEBUSYMODE_STATION    0x00000001
#define LINEBUSYMODE_TRUNK      0x00000002
#define LINEBUSYMODE_UNKNOWN    0x00000004
#define LINEBUSYMODE_UNAVAIL    0x00000008

#define LINECALLCOMPLCOND_BUSY        0x00000001
#define LINECALLCOMPLCOND_NOANSWER    0x00000002

#define LINECALLCOMPLMODE_CAMPON      0x00000001
#define LINECALLCOMPLMODE_CALLBACK    0x00000002
#define LINECALLCOMPLMODE_INTRUDE     0x00000004
#define LINECALLCOMPLMODE_MESSAGE     0x00000008

#define LINECALLFEATURE_ACCEPT                   0x00000001
#define LINECALLFEATURE_ADDTOCONF                0x00000002
#define LINECALLFEATURE_ANSWER                   0x00000004
#define LINECALLFEATURE_BLINDTRANSFER            0x00000008
#define LINECALLFEATURE_COMPLETECALL             0x00000010
#define LINECALLFEATURE_COMPLETETRANSF           0x00000020
#define LINECALLFEATURE_DIAL                     0x00000040
#define LINECALLFEATURE_DROP                     0x00000080
#define LINECALLFEATURE_GATHERDIGITS             0x00000100
#define LINECALLFEATURE_GENERATEDIGITS           0x00000200
#define LINECALLFEATURE_GENERATETONE             0x00000400
#define LINECALLFEATURE_HOLD                     0x00000800
#define LINECALLFEATURE_MONITORDIGITS            0x00001000
#define LINECALLFEATURE_MONITORMEDIA             0x00002000
#define LINECALLFEATURE_MONITORTONES             0x00004000
#define LINECALLFEATURE_PARK                     0x00008000
#define LINECALLFEATURE_PREPAREADDCONF           0x00010000
#define LINECALLFEATURE_REDIRECT                 0x00020000
#define LINECALLFEATURE_REMOVEFROMCONF           0x00040000
#define LINECALLFEATURE_SECURECALL               0x00080000
#define LINECALLFEATURE_SENDUSERUSER             0x00100000
#define LINECALLFEATURE_SETCALLPARAMS            0x00200000
#define LINECALLFEATURE_SETMEDIACONTROL          0x00400000
#define LINECALLFEATURE_SETTERMINAL              0x00800000
#define LINECALLFEATURE_SETUPCONF                0x01000000
#define LINECALLFEATURE_SETUPTRANSFER            0x02000000
#define LINECALLFEATURE_SWAPHOLD                 0x04000000
#define LINECALLFEATURE_UNHOLD                   0x08000000

typedef struct linedialparams_tag {
    DWORD    dwDialPause;
    DWORD    dwDialSpeed;
    DWORD    dwDigitDuration;
    DWORD    dwWaitForDialtone;
} LINEDIALPARAMS, FAR *LPLINEDIALPARAMS;

typedef struct linecallinfo_tag {
    DWORD    dwTotalSize;
    DWORD    dwNeededSize;
    DWORD    dwUsedSize;

    HLINE    hLine;
    DWORD    dwLineDeviceID;
    DWORD    dwAddressID;

    DWORD    dwBearerMode;
    DWORD    dwRate;
    DWORD    dwMediaMode;

    DWORD    dwAppSpecific;
    DWORD    dwCallID;
    DWORD    dwRelatedCallID;
    DWORD    dwCallParamFlags;
    DWORD    dwCallStates;

    DWORD    dwMonitorDigitModes;
    DWORD    dwMonitorMediaModes;
    LINEDIALPARAMS    DialParams;

    DWORD    dwOrigin;
    DWORD    dwReason;
    DWORD    dwCompletionID;
    DWORD    dwNumOwners;
    DWORD    dwNumMonitors;

    DWORD    dwCountryCode;
    DWORD    dwTrunk;

    DWORD    dwCallerIDFlags;
    DWORD    dwCallerIDSize;
    DWORD    dwCallerIDOffset;
    DWORD    dwCallerIDNameSize;
    DWORD    dwCallerIDNameOffset;

    DWORD    dwCalledIDFlags;
    DWORD    dwCalledIDSize;
    DWORD    dwCalledIDOffset;
    DWORD    dwCalledIDNameSize;
    DWORD    dwCalledIDNameOffset;

    DWORD    dwConnectedIDFlags;
    DWORD    dwConnectedIDSize;
    DWORD    dwConnectedIDOffset;
    DWORD    dwConnectedIDNameSize;
    DWORD    dwConnectedIDNameOffset;

    DWORD    dwRedirectionIDFlags;
    DWORD    dwRedirectionIDSize;
    DWORD    dwRedirectionIDOffset;
    DWORD    dwRedirectionIDNameSize;
    DWORD    dwRedirectionIDNameOffset;

    DWORD    dwRedirectingIDFlags;
    DWORD    dwRedirectingIDSize;
    DWORD    dwRedirectingIDOffset;
    DWORD    dwRedirectingIDNameSize;
    DWORD    dwRedirectingIDNameOffset;

    DWORD    dwAppNameSize;
    DWORD    dwAppNameOffset;

    DWORD    dwDisplayableAddressSize;
    DWORD    dwDisplayableAddressOffset;

    DWORD    dwCalledPartySize;
    DWORD    dwCalledPartyOffset;

    DWORD    dwCommentSize;
    DWORD    dwCommentOffset;

    DWORD    dwDisplaySize;
    DWORD    dwDisplayOffset;

    DWORD    dwUserUserInfoSize;
    DWORD    dwUserUserInfoOffset;

    DWORD    dwHighLevelCompSize;
    DWORD    dwHighLevelCompOffset;

    DWORD    dwLowLevelCompSize;
    DWORD    dwLowLevelCompOffset;

    DWORD    dwChargingInfoSize;
    DWORD    dwChargingInfoOffset;

    DWORD    dwTerminalModesSize;
    DWORD    dwTerminalModesOffset;

    DWORD    dwDevSpecificSize;
    DWORD    dwDevSpecificOffset;
} LINECALLINFO, FAR *LPLINECALLINFO;

#define LINECALLINFOSTATE_OTHER             0x00000001
#define LINECALLINFOSTATE_DEVSPECIFIC       0x00000002
#define LINECALLINFOSTATE_BEARERMODE        0x00000004
#define LINECALLINFOSTATE_RATE              0x00000008
#define LINECALLINFOSTATE_MEDIAMODE         0x00000010
#define LINECALLINFOSTATE_APPSPECIFIC       0x00000020
#define LINECALLINFOSTATE_CALLID            0x00000040
#define LINECALLINFOSTATE_RELATEDCALLID     0x00000080
#define LINECALLINFOSTATE_ORIGIN            0x00000100
#define LINECALLINFOSTATE_REASON            0x00000200
#define LINECALLINFOSTATE_COMPLETIONID      0x00000400
#define LINECALLINFOSTATE_NUMOWNERINCR      0x00000800
#define LINECALLINFOSTATE_NUMOWNERDECR      0x00001000
#define LINECALLINFOSTATE_NUMMONITORS       0x00002000
#define LINECALLINFOSTATE_TRUNK             0x00004000
#define LINECALLINFOSTATE_CALLERID          0x00008000
#define LINECALLINFOSTATE_CALLEDID          0x00010000
#define LINECALLINFOSTATE_CONNECTEDID       0x00020000
#define LINECALLINFOSTATE_REDIRECTIONID     0x00040000
#define LINECALLINFOSTATE_REDIRECTINGID     0x00080000
#define LINECALLINFOSTATE_DISPLAY           0x00100000
#define LINECALLINFOSTATE_USERUSERINFO      0x00200000
#define LINECALLINFOSTATE_HIGHLEVELCOMP     0x00400000
#define LINECALLINFOSTATE_LOWLEVELCOMP      0x00800000
#define LINECALLINFOSTATE_CHARGINGINFO      0x01000000
#define LINECALLINFOSTATE_TERMINAL          0x02000000
#define LINECALLINFOSTATE_DIALPARAMS        0x04000000
#define LINECALLINFOSTATE_MONITORMODES      0x08000000

typedef struct linecalllist_tag {
    DWORD    dwTotalSize;
    DWORD    dwNeededSize;
    DWORD    dwUsedSize;
    
    DWORD    dwCallsNumEntries;
    DWORD    dwCallsSize;
    DWORD    dwCallsOffset;
} LINECALLLIST, FAR *LPLINECALLLIST;

#define LINECALLORIGIN_OUTBOUND    0x00000001
#define LINECALLORIGIN_INTERNAL    0x00000002
#define LINECALLORIGIN_EXTERNAL    0x00000004
#define LINECALLORIGIN_UNKNOWN     0x00000010
#define LINECALLORIGIN_UNAVAIL     0x00000020
#define LINECALLORIGIN_CONFERENCE  0x00000040

#define LINECALLPARAMFLAGS_SECURE           0x00000001
#define LINECALLPARAMFLAGS_IDLE             0x00000002
#define LINECALLPARAMFLAGS_BLOCKID          0x00000004
#define LINECALLPARAMFLAGS_ORIGOFFHOOK      0x00000008
#define LINECALLPARAMFLAGS_DESTOFFHOOK      0x00000010

typedef struct linecallparams_tag {     // Defaults:
    DWORD    dwTotalSize;               // ---------
    
    DWORD    dwBearerMode;              // voice
    DWORD    dwMinRate;                 // (3.1kHz)
    DWORD    dwMaxRate;                 // (3.1kHz)
    DWORD    dwMediaMode;               // interactiveVoice

    DWORD    dwCallParamFlags;          // 0
    DWORD    dwAddressMode;             // addressID
    DWORD    dwAddressID;               // (any available)

    LINEDIALPARAMS  DialParams;         // (0, 0, 0, 0)
    
    DWORD    dwOrigAddressSize;         // 0
    DWORD    dwOrigAddressOffset;
    DWORD    dwDisplayableAddressSize;
    DWORD    dwDisplayableAddressOffset;

    DWORD    dwCalledPartySize;         // 0
    DWORD    dwCalledPartyOffset;

    DWORD    dwCommentSize;             // 0
    DWORD    dwCommentOffset;

    DWORD    dwUserUserInfoSize;        // 0
    DWORD    dwUserUserInfoOffset;

    DWORD    dwHighLevelCompSize;       // 0
    DWORD    dwHighLevelCompOffset;

    DWORD    dwLowLevelCompSize;        // 0
    DWORD    dwLowLevelCompOffset;

    DWORD    dwDevSpecificSize;         // 0
    DWORD    dwDevSpecificOffset;
} LINECALLPARAMS, FAR *LPLINECALLPARAMS;


#define LINECALLPARTYID_BLOCKED         0x00000001
#define LINECALLPARTYID_OUTOFAREA       0x00000002
#define LINECALLPARTYID_NAME            0x00000004
#define LINECALLPARTYID_ADDRESS         0x00000008
#define LINECALLPARTYID_PARTIAL         0x00000010
#define LINECALLPARTYID_UNKNOWN         0x00000020
#define LINECALLPARTYID_UNAVAIL         0x00000040

#define LINECALLPRIVILEGE_NONE          0x00000001
#define LINECALLPRIVILEGE_MONITOR       0x00000002
#define LINECALLPRIVILEGE_OWNER         0x00000004

#define LINECALLREASON_DIRECT           0x00000001
#define LINECALLREASON_FWDBUSY          0x00000002
#define LINECALLREASON_FWDNOANSWER      0x00000004
#define LINECALLREASON_FWDUNCOND        0x00000008
#define LINECALLREASON_PICKUP           0x00000010
#define LINECALLREASON_UNPARK           0x00000020
#define LINECALLREASON_REDIRECT         0x00000040
#define LINECALLREASON_CALLCOMPLETION   0x00000080
#define LINECALLREASON_TRANSFER         0x00000100
#define LINECALLREASON_REMINDER         0x00000200
#define LINECALLREASON_UNKNOWN          0x00000400
#define LINECALLREASON_UNAVAIL          0x00000800

#define LINECALLSELECT_LINE     0x00000001
#define LINECALLSELECT_ADDRESS  0x00000002
#define LINECALLSELECT_CALL     0x00000004

#define LINECALLSTATE_IDLE                  0x00000001
#define LINECALLSTATE_OFFERING              0x00000002
#define LINECALLSTATE_ACCEPTED              0x00000004
#define LINECALLSTATE_DIALTONE              0x00000008
#define LINECALLSTATE_DIALING               0x00000010
#define LINECALLSTATE_RINGBACK              0x00000020
#define LINECALLSTATE_BUSY                  0x00000040
#define LINECALLSTATE_SPECIALINFO           0x00000080
#define LINECALLSTATE_CONNECTED             0x00000100
#define LINECALLSTATE_PROCEEDING            0x00000200
#define LINECALLSTATE_ONHOLD                0x00000400
#define LINECALLSTATE_CONFERENCED           0x00000800
#define LINECALLSTATE_ONHOLDPENDCONF        0x00001000
#define LINECALLSTATE_ONHOLDPENDTRANSFER    0x00002000
#define LINECALLSTATE_DISCONNECTED          0x00004000
#define LINECALLSTATE_UNKNOWN               0x00008000

typedef struct linecallstatus_tag {
    DWORD    dwTotalSize;
    DWORD    dwNeededSize;
    DWORD    dwUsedSize;

    DWORD    dwCallState;
    DWORD    dwCallStateMode;
    DWORD    dwCallPrivilege;
    DWORD    dwCallFeatures;

    DWORD    dwDevSpecificSize;
    DWORD    dwDevSpecificOffset;
} LINECALLSTATUS, FAR *LPLINECALLSTATUS;

#define LINEDEVCAPFLAGS_CROSSADDRCONF   0x00000001
#define LINEDEVCAPFLAGS_HIGHLEVCOMP     0x00000002
#define LINEDEVCAPFLAGS_LOWLEVCOMP      0x00000004
#define LINEDEVCAPFLAGS_MEDIACONTROL    0x00000008
#define LINEDEVCAPFLAGS_MULTIPLEADDR    0x00000010
#define LINEDEVCAPFLAGS_CLOSEDROP       0x00000020
#define LINEDEVCAPFLAGS_DIALBILLING     0x00000040
#define LINEDEVCAPFLAGS_DIALQUIET       0x00000080
#define LINEDEVCAPFLAGS_DIALDIALTONE    0x00000100

typedef struct lineextensionid_tag {
    DWORD    dwExtensionID0;
    DWORD    dwExtensionID1;
    DWORD    dwExtensionID2;
    DWORD    dwExtensionID3;
} LINEEXTENSIONID, FAR *LPLINEEXTENSIONID;


typedef struct linedevcaps_tag {
    DWORD    dwTotalSize;
    DWORD    dwNeededSize;
    DWORD    dwUsedSize;

    DWORD    dwProviderInfoSize;
    DWORD    dwProviderInfoOffset;

    DWORD    dwSwitchInfoSize;
    DWORD    dwSwitchInfoOffset;

    DWORD    dwPermanentLineID;
    DWORD    dwLineNameSize;
    DWORD    dwLineNameOffset;
    DWORD    dwStringFormat;
    
    DWORD    dwAddressModes;
    DWORD    dwNumAddresses;
    DWORD    dwBearerModes;
    DWORD    dwMaxRate;
    DWORD    dwMediaModes;

    DWORD    dwGenerateToneModes;
    DWORD    dwGenerateToneMaxNumFreq;
    DWORD    dwGenerateDigitModes;
    DWORD    dwMonitorToneMaxNumFreq;
    DWORD    dwMonitorToneMaxNumEntries;
    DWORD    dwMonitorDigitModes;
    DWORD    dwGatherDigitsMinTimeout;
    DWORD    dwGatherDigitsMaxTimeout;

    DWORD    dwMedCtlDigitMaxListSize;
    DWORD    dwMedCtlMediaMaxListSize;
    DWORD    dwMedCtlToneMaxListSize;
    DWORD    dwMedCtlCallStateMaxListSize;

    DWORD    dwDevCapFlags;
    DWORD    dwMaxNumActiveCalls;
    DWORD    dwAnswerMode;
    DWORD    dwRingModes;
    DWORD    dwLineStates;

    DWORD    dwUUIAcceptSize;
    DWORD    dwUUIAnswerSize;
    DWORD    dwUUIMakeCallSize;
    DWORD    dwUUIDropSize;
    DWORD    dwUUISendUserUserInfoSize;
    DWORD    dwUUICallInfoSize;
    
    LINEDIALPARAMS    MinDialParams;
    LINEDIALPARAMS    MaxDialParams;
    LINEDIALPARAMS    DefaultDialParams;

    DWORD    dwNumTerminals;
    DWORD    dwTerminalCapsSize;
    DWORD    dwTerminalCapsOffset;
    DWORD    dwTerminalTextEntrySize;
    DWORD    dwTerminalTextSize;
    DWORD    dwTerminalTextOffset;

    DWORD    dwDevSpecificSize;
    DWORD    dwDevSpecificOffset;
/* Tapi 1.1 changes */
    DWORD    dwLineFeatures;
} LINEDEVCAPS, FAR *LPLINEDEVCAPS;
    
#define LINEDEVSTATE_OTHER              0x00000001
#define LINEDEVSTATE_RINGING            0x00000002
#define LINEDEVSTATE_CONNECTED          0x00000004
#define LINEDEVSTATE_DISCONNECTED       0x00000008
#define LINEDEVSTATE_MSGWAITON          0x00000010
#define LINEDEVSTATE_MSGWAITOFF         0x00000020
#define LINEDEVSTATE_INSERVICE          0x00000040
#define LINEDEVSTATE_OUTOFSERVICE       0x00000080
#define LINEDEVSTATE_MAINTENANCE        0x00000100
#define LINEDEVSTATE_OPEN               0x00000200
#define LINEDEVSTATE_CLOSE              0x00000400
#define LINEDEVSTATE_NUMCALLS           0x00000800
#define LINEDEVSTATE_NUMCOMPLETIONS     0x00001000
#define LINEDEVSTATE_TERMINALS          0x00002000
#define LINEDEVSTATE_ROAMMODE           0x00004000
#define LINEDEVSTATE_BATTERY            0x00008000
#define LINEDEVSTATE_SIGNAL             0x00010000
#define LINEDEVSTATE_DEVSPECIFIC        0x00020000
#define LINEDEVSTATE_REINIT             0x00040000
#define LINEDEVSTATE_LOCK               0x00080000
/* Tapi 1.1 change */
#define LINEDEVSTATE_CAPSCHANGE         0x00100000
#define LINEDEVSTATE_CONFIGCHANGE       0x00200000
#define LINEDEVSTATE_TRANSLATECHANGE    0x00400000


typedef struct linedevstatus_tag {
    DWORD    dwTotalSize;
    DWORD    dwNeededSize;
    DWORD    dwUsedSize;

    DWORD    dwNumOpens;
    DWORD    dwOpenMediaModes;
    DWORD    dwNumActiveCalls;
    DWORD    dwNumOnHoldCalls;
    DWORD    dwNumOnHoldPendCalls;
    DWORD    dwLineFeatures;
    DWORD    dwNumCallCompletions;
    DWORD    dwRingMode;
    DWORD    dwSignalLevel;
    DWORD    dwBatteryLevel;
    DWORD    dwRoamMode;
    
    DWORD    dwDevStatusFlags;
    
    DWORD    dwTerminalModesSize;
    DWORD    dwTerminalModesOffset;
    
    DWORD    dwDevSpecificSize;
    DWORD    dwDevSpecificOffset;
} LINEDEVSTATUS, FAR *LPLINEDEVSTATUS;

#define LINEDEVSTATUSFLAGS_CONNECTED  0x00000001
#define LINEDEVSTATUSFLAGS_MSGWAIT    0x00000002
#define LINEDEVSTATUSFLAGS_INSERVICE  0x00000004
#define LINEDEVSTATUSFLAGS_LOCKED     0x00000008


#define LINEDIALTONEMODE_NORMAL    0x00000001
#define LINEDIALTONEMODE_SPECIAL   0x00000002
#define LINEDIALTONEMODE_INTERNAL  0x00000004
#define LINEDIALTONEMODE_EXTERNAL  0x00000008
#define LINEDIALTONEMODE_UNKNOWN   0x00000010
#define LINEDIALTONEMODE_UNAVAIL   0x00000020
    
#define LINEDIGITMODE_PULSE    0x00000001
#define LINEDIGITMODE_DTMF     0x00000002
#define LINEDIGITMODE_DTMFEND  0x00000004
    
#define LINEDISCONNECTMODE_NORMAL       0x00000001
#define LINEDISCONNECTMODE_UNKNOWN      0x00000002
#define LINEDISCONNECTMODE_REJECT       0x00000004
#define LINEDISCONNECTMODE_PICKUP       0x00000008
#define LINEDISCONNECTMODE_FORWARDED    0x00000010
#define LINEDISCONNECTMODE_BUSY         0x00000020
#define LINEDISCONNECTMODE_NOANSWER     0x00000040
#define LINEDISCONNECTMODE_BADADDRESS   0x00000080
#define LINEDISCONNECTMODE_UNREACHABLE  0x00000100
#define LINEDISCONNECTMODE_CONGESTION   0x00000200
#define LINEDISCONNECTMODE_INCOMPATIBLE 0x00000400
#define LINEDISCONNECTMODE_UNAVAIL      0x00000800

#define LINEERR_ALLOCATED                   0x80000001
#define LINEERR_BADDEVICEID                 0x80000002
#define LINEERR_BEARERMODEUNAVAIL           0x80000003
#define LINEERR_CALLUNAVAIL                 0x80000005
#define LINEERR_COMPLETIONOVERRUN           0x80000006
#define LINEERR_CONFERENCEFULL              0x80000007
#define LINEERR_DIALBILLING                 0x80000008
#define LINEERR_DIALDIALTONE                0x80000009
#define LINEERR_DIALPROMPT                  0x8000000A
#define LINEERR_DIALQUIET                   0x8000000B
#define LINEERR_INCOMPATIBLEAPIVERSION      0x8000000C
#define LINEERR_INCOMPATIBLEEXTVERSION      0x8000000D
#define LINEERR_INIFILECORRUPT              0x8000000E
#define LINEERR_INUSE                       0x8000000F
#define LINEERR_INVALADDRESS                0x80000010
#define LINEERR_INVALADDRESSID              0x80000011
#define LINEERR_INVALADDRESSMODE            0x80000012
#define LINEERR_INVALADDRESSSTATE           0x80000013
#define LINEERR_INVALAPPHANDLE              0x80000014
#define LINEERR_INVALAPPNAME                0x80000015
#define LINEERR_INVALBEARERMODE             0x80000016
#define LINEERR_INVALCALLCOMPLMODE          0x80000017
#define LINEERR_INVALCALLHANDLE             0x80000018
#define LINEERR_INVALCALLPARAMS             0x80000019
#define LINEERR_INVALCALLPRIVILEGE          0x8000001A
#define LINEERR_INVALCALLSELECT             0x8000001B
#define LINEERR_INVALCALLSTATE              0x8000001C
#define LINEERR_INVALCALLSTATELIST          0x8000001D
#define LINEERR_INVALCARD                   0x8000001E
#define LINEERR_INVALCOMPLETIONID           0x8000001F
#define LINEERR_INVALCONFCALLHANDLE         0x80000020
#define LINEERR_INVALCONSULTCALLHANDLE      0x80000021
#define LINEERR_INVALCOUNTRYCODE            0x80000022
#define LINEERR_INVALDEVICECLASS            0x80000023
#define LINEERR_INVALDEVICEHANDLE           0x80000024
#define LINEERR_INVALDIALPARAMS             0x80000025
#define LINEERR_INVALDIGITLIST              0x80000026
#define LINEERR_INVALDIGITMODE              0x80000027
#define LINEERR_INVALDIGITS                 0x80000028
#define LINEERR_INVALEXTVERSION             0x80000029
#define LINEERR_INVALGROUPID                0x8000002A
#define LINEERR_INVALLINEHANDLE             0x8000002B
#define LINEERR_INVALLINESTATE              0x8000002C
#define LINEERR_INVALLOCATION               0x8000002D
#define LINEERR_INVALMEDIALIST              0x8000002E
#define LINEERR_INVALMEDIAMODE              0x8000002F
#define LINEERR_INVALMESSAGEID              0x80000030
#define LINEERR_INVALPARAM                  0x80000032
#define LINEERR_INVALPARKID                 0x80000033
#define LINEERR_INVALPARKMODE               0x80000034
#define LINEERR_INVALPOINTER                0x80000035
#define LINEERR_INVALPRIVSELECT             0x80000036
#define LINEERR_INVALRATE                   0x80000037
#define LINEERR_INVALREQUESTMODE            0x80000038
#define LINEERR_INVALTERMINALID             0x80000039
#define LINEERR_INVALTERMINALMODE           0x8000003A
#define LINEERR_INVALTIMEOUT                0x8000003B 
#define LINEERR_INVALTONE                   0x8000003C
#define LINEERR_INVALTONELIST               0x8000003D
#define LINEERR_INVALTONEMODE               0x8000003E
#define LINEERR_INVALTRANSFERMODE           0x8000003F
#define LINEERR_LINEMAPPERFAILED            0x80000040
#define LINEERR_NOCONFERENCE                0x80000041
#define LINEERR_NODEVICE                    0x80000042
#define LINEERR_NODRIVER                    0x80000043
#define LINEERR_NOMEM                       0x80000044
#define LINEERR_NOREQUEST                   0x80000045
#define LINEERR_NOTOWNER                    0x80000046
#define LINEERR_NOTREGISTERED               0x80000047
#define LINEERR_OPERATIONFAILED             0x80000048
#define LINEERR_OPERATIONUNAVAIL            0x80000049
#define LINEERR_RATEUNAVAIL                 0x8000004A
#define LINEERR_RESOURCEUNAVAIL             0x8000004B
#define LINEERR_REQUESTOVERRUN              0x8000004C
#define LINEERR_STRUCTURETOOSMALL           0x8000004D
#define LINEERR_TARGETNOTFOUND              0x8000004E
#define LINEERR_TARGETSELF                  0x8000004F
#define LINEERR_UNINITIALIZED               0x80000050
#define LINEERR_USERUSERINFOTOOBIG          0x80000051
#define LINEERR_REINIT                      0x80000052
#define LINEERR_ADDRESSBLOCKED              0x80000053
#define LINEERR_BILLINGREJECTED             0x80000054
#define LINEERR_INVALFEATURE                0x80000055
#define LINEERR_NOMULTIPLEINSTANCE          0x80000056


#define LINEFEATURE_DEVSPECIFIC     0x00000001
#define LINEFEATURE_DEVSPECIFICFEAT 0x00000002
#define LINEFEATURE_FORWARD         0x00000004
#define LINEFEATURE_MAKECALL        0x00000008
#define LINEFEATURE_SETMEDIACONTROL 0x00000010
#define LINEFEATURE_SETTERMINAL     0x00000020

typedef struct lineforward_tag {
    DWORD    dwForwardMode;

    DWORD    dwCallerAddressSize;
    DWORD    dwCallerAddressOffset;
    
    DWORD    dwDestCountryCode;
    DWORD    dwDestAddressSize;
    DWORD    dwDestAddressOffset;    
} LINEFORWARD, FAR *LPLINEFORWARD;

typedef struct lineforwardlist_tag {
    DWORD    dwTotalSize;

    DWORD    dwNumEntries;
    LINEFORWARD    ForwardList[1];
} LINEFORWARDLIST, FAR *LPLINEFORWARDLIST;

#define LINEFORWARDMODE_UNCOND          0x00000001
#define LINEFORWARDMODE_UNCONDINTERNAL  0x00000002
#define LINEFORWARDMODE_UNCONDEXTERNAL  0x00000004
#define LINEFORWARDMODE_UNCONDSPECIFIC  0x00000008
#define LINEFORWARDMODE_BUSY            0x00000010
#define LINEFORWARDMODE_BUSYINTERNAL    0x00000020
#define LINEFORWARDMODE_BUSYEXTERNAL    0x00000040
#define LINEFORWARDMODE_BUSYSPECIFIC    0x00000080
#define LINEFORWARDMODE_NOANSW          0x00000100
#define LINEFORWARDMODE_NOANSWINTERNAL  0x00000200
#define LINEFORWARDMODE_NOANSWEXTERNAL  0x00000400
#define LINEFORWARDMODE_NOANSWSPECIFIC  0x00000800
#define LINEFORWARDMODE_BUSYNA          0x00001000
#define LINEFORWARDMODE_BUSYNAINTERNAL  0x00002000
#define LINEFORWARDMODE_BUSYNAEXTERNAL  0x00004000
#define LINEFORWARDMODE_BUSYNASPECIFIC  0x00008000

#define LINEGATHERTERM_BUFFERFULL    0x00000001
#define LINEGATHERTERM_TERMDIGIT     0x00000002
#define LINEGATHERTERM_FIRSTTIMEOUT  0x00000004
#define LINEGATHERTERM_INTERTIMEOUT  0x00000008
#define LINEGATHERTERM_CANCEL        0x00000010

#define LINEGENERATETERM_DONE    0x00000001
#define LINEGENERATETERM_CANCEL  0x00000002

typedef struct linegeneratetone_tag {
    DWORD    dwFrequency;
    DWORD    dwCadenceOn;
    DWORD    dwCadenceOff;
    DWORD    dwVolume;
} LINEGENERATETONE, FAR *LPLINEGENERATETONE;

#define LINEMAPPER         0xFFFFFFFF
typedef struct linemediacontrolcallstate_tag {
    DWORD    dwCallStates;
    DWORD    dwMediaControl;
} LINEMEDIACONTROLCALLSTATE, 
FAR *LPLINEMEDIACONTROLCALLSTATE;

typedef struct linemediacontroldigit_tag {
    DWORD            dwDigit;
    DWORD            dwDigitModes;
    DWORD            dwMediaControl;
} LINEMEDIACONTROLDIGIT, FAR *LPLINEMEDIACONTROLDIGIT;

typedef struct linemediacontrolmedia_tag {
    DWORD            dwMediaModes;
    DWORD            dwDuration;
    DWORD            dwMediaControl;
} LINEMEDIACONTROLMEDIA, FAR *LPLINEMEDIACONTROLMEDIA;

typedef struct linemediacontroltone_tag {
    DWORD    dwAppSpecific;
    DWORD    dwDuration;
    DWORD    dwFrequency1;
    DWORD    dwFrequency2;
    DWORD    dwFrequency3;
    DWORD    dwMediaControl;
} LINEMEDIACONTROLTONE, FAR *LPLINEMEDIACONTROLTONE;

#define LINEMEDIACONTROL_NONE           0x00000001
#define LINEMEDIACONTROL_START          0x00000002
#define LINEMEDIACONTROL_RESET          0x00000004
#define LINEMEDIACONTROL_PAUSE          0x00000008
#define LINEMEDIACONTROL_RESUME         0x00000010
#define LINEMEDIACONTROL_RATEUP         0x00000020
#define LINEMEDIACONTROL_RATEDOWN       0x00000040
#define LINEMEDIACONTROL_RATENORMAL     0x00000080
#define LINEMEDIACONTROL_VOLUMEUP       0x00000100
#define LINEMEDIACONTROL_VOLUMEDOWN     0x00000200
#define LINEMEDIACONTROL_VOLUMENORMAL   0x00000400

#define LINEMEDIAMODE_UNKNOWN           0x00000002
#define LINEMEDIAMODE_INTERACTIVEVOICE  0x00000004
#define LINEMEDIAMODE_AUTOMATEDVOICE    0x00000008
#define LINEMEDIAMODE_DATAMODEM         0x00000010
#define LINEMEDIAMODE_G3FAX             0x00000020
#define LINEMEDIAMODE_TDD               0x00000040
#define LINEMEDIAMODE_G4FAX             0x00000080
#define LINEMEDIAMODE_DIGITALDATA       0x00000100
#define LINEMEDIAMODE_TELETEX           0x00000200
#define LINEMEDIAMODE_VIDEOTEX          0x00000400
#define LINEMEDIAMODE_TELEX             0x00000800
#define LINEMEDIAMODE_MIXED             0x00001000
#define LINEMEDIAMODE_ADSI              0x00002000
#define LINEMEDIAMODE_VOICEVIEW         0x00004000

#define LAST_LINEMEDIAMODE                   0x00004000


typedef struct linemonitortone_tag {
    DWORD    dwAppSpecific;
    DWORD    dwDuration;
    DWORD    dwFrequency1;
    DWORD    dwFrequency2;
    DWORD    dwFrequency3;
} LINEMONITORTONE, FAR *LPLINEMONITORTONE;

#define LINEPARKMODE_DIRECTED       0x00000001
#define LINEPARKMODE_NONDIRECTED    0x00000002

#define LINEREMOVEFROMCONF_NONE    0x00000001
#define LINEREMOVEFROMCONF_LAST    0x00000002
#define LINEREMOVEFROMCONF_ANY     0x00000003

typedef struct linereqmakecall_tag {
    char    szDestAddress[TAPIMAXDESTADDRESSSIZE];
    char    szAppName[TAPIMAXAPPNAMESIZE];
    char    szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    char    szComment[TAPIMAXCOMMENTSIZE];
} LINEREQMAKECALL, FAR *LPLINEREQMAKECALL;

typedef struct linereqmediacall_tag {
    HWND    hWnd;
    WPARAM  wRequestID;
    char    szDeviceClass[TAPIMAXDEVICECLASSSIZE];
    unsigned char    ucDeviceID[TAPIMAXDEVICEIDSIZE];
    DWORD    dwSize;
    DWORD    dwSecure;
    char    szDestAddress[TAPIMAXDESTADDRESSSIZE];
    char    szAppName[TAPIMAXAPPNAMESIZE];
    char    szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    char    szComment[TAPIMAXCOMMENTSIZE];
} LINEREQMEDIACALL, FAR *LPLINEREQMEDIACALL;

#define LINEREQUESTMODE_MAKECALL     0x00000001
#define LINEREQUESTMODE_MEDIACALL    0x00000002
#define LINEREQUESTMODE_DROP         0x00000004

#define LAST_LINEREQUESTMODE         LINEREQUESTMODE_MEDIACALL


#define LINEROAMMODE_UNKNOWN    0x00000001
#define LINEROAMMODE_UNAVAIL    0x00000002
#define LINEROAMMODE_HOME       0x00000004
#define LINEROAMMODE_ROAMA      0x00000008
#define LINEROAMMODE_ROAMB      0x00000010

#define LINESPECIALINFO_NOCIRCUIT    0x00000001
#define LINESPECIALINFO_CUSTIRREG    0x00000002
#define LINESPECIALINFO_REORDER      0x00000004
#define LINESPECIALINFO_UNKNOWN      0x00000008
#define LINESPECIALINFO_UNAVAIL      0x00000010

typedef struct linetermcaps_tag {
    DWORD    dwTermDev;
    DWORD    dwTermModes;
    DWORD    dwTermSharing;
} LINETERMCAPS, FAR *LPLINETERMCAPS;

#define LINETERMDEV_PHONE      0x00000001
#define LINETERMDEV_HEADSET    0x00000002
#define LINETERMDEV_SPEAKER    0x00000004

#define LINETERMMODE_BUTTONS       0x00000001
#define LINETERMMODE_LAMPS         0x00000002
#define LINETERMMODE_DISPLAY       0x00000004
#define LINETERMMODE_RINGER        0x00000008
#define LINETERMMODE_HOOKSWITCH    0x00000010
#define LINETERMMODE_MEDIATOLINE   0x00000020
#define LINETERMMODE_MEDIAFROMLINE 0x00000040
#define LINETERMMODE_MEDIABIDIRECT 0x00000080

#define LINETERMSHARING_PRIVATE       0x00000001
#define LINETERMSHARING_SHAREDEXCL    0x00000002
#define LINETERMSHARING_SHAREDCONF    0x00000004

#define LINETONEMODE_CUSTOM    0x00000001
#define LINETONEMODE_RINGBACK  0x00000002
#define LINETONEMODE_BUSY      0x00000004
#define LINETONEMODE_BEEP      0x00000008
#define LINETONEMODE_BILLING   0x00000010

#define LINETRANSFERMODE_TRANSFER    0x00000001
#define LINETRANSFERMODE_CONFERENCE  0x00000002

typedef struct linetranslateoutput_tag {
    DWORD dwTotalSize;
    DWORD dwNeededSize;
    DWORD dwUsedSize;

    DWORD dwDialableStringSize;
    DWORD dwDialableStringOffset;
    DWORD dwDisplayableStringSize;
    DWORD dwDisplayableStringOffset;

    DWORD dwCurrentCountry;
    DWORD dwDestCountry;
    DWORD dwTranslateResults;
} LINETRANSLATEOUTPUT, FAR *LPLINETRANSLATEOUTPUT;

typedef struct linetranslatecaps_tag {
    DWORD dwTotalSize;
    DWORD dwNeededSize;
    DWORD dwUsedSize;

    DWORD dwNumLocations;
    DWORD dwLocationListSize;
    DWORD dwLocationListOffset;
    
    DWORD dwCurrentLocationID;
    
    DWORD dwNumCards;
    DWORD dwCardListSize;
    DWORD dwCardListOffset;

    DWORD dwCurrentPreferredCardID;
} LINETRANSLATECAPS, FAR *LPLINETRANSLATECAPS;

typedef struct linelocationentry_tag {
    DWORD dwPermanentLocationID;
    DWORD dwLocationNameSize;
    DWORD dwLocationNameOffset;
    DWORD dwCountryCode;
    DWORD dwCityCodeSize;
    DWORD dwCityCodeOffset;
    DWORD dwPreferredCardID;
/* Tapi 1.1 changes */
    DWORD dwLocalAccessCodeSize;
    DWORD dwLocalAccessCodeOffset;
    DWORD dwLongDistanceAccessCodeSize;
    DWORD dwLongDistanceAccessCodeOffset;
    DWORD dwTollPrefixListSize;
    DWORD dwTollPrefixListOffset;
    DWORD dwCountryID;
} LINELOCATIONENTRY, FAR *LPLINELOCATIONENTRY;

typedef struct linecardentry_tag {
    DWORD dwPermanentCardID;
    DWORD dwCardNameSize;
    DWORD dwCardNameOffset;
/* Tapi 1.1 changes */
    DWORD dwCardNumberDigits;
    DWORD dwSameAreaRuleSize;
    DWORD dwSameAreaRuleOffset;
    DWORD dwLongDistanceRuleSize;
    DWORD dwLongDistanceRuleOffset;
    DWORD dwInternationalRuleSize;
    DWORD dwInternationalRuleOffset;
    DWORD dwHideIfBlank;
} LINECARDENTRY, FAR *LPLINECARDENTRY;

/* Tapi 1.1 changes */
typedef struct linecountrylist_tag {
    DWORD dwTotalSize;
    DWORD dwNeededSize;
    DWORD dwUsedSize;

    DWORD dwNumCountries;
    DWORD dwCountryListSize;
    DWORD dwCountryListOffset;
} LINECOUNTRYLIST, FAR *LPLINECOUNTRYLIST;

typedef struct linecountryentry_tag {
    DWORD dwCountryID;
    DWORD dwCountryCode;
    DWORD dwNextCountryID;
    DWORD dwCountryNameSize;
    DWORD dwCountryNameOffset;
    DWORD dwSameAreaRuleSize;
    DWORD dwSameAreaRuleOffset;
    DWORD dwLongDistanceRuleSize;
    DWORD dwLongDistanceRuleOffset;
    DWORD dwInternationalRuleSize;
    DWORD dwInternationalRuleOffset;
} LINECOUNTRYENTRY, FAR *LPLINECOUNTRYENTRY;

typedef struct lineproviderlist_tag {
    DWORD dwTotalSize;
    DWORD dwNeededSize;
    DWORD dwUsedSize;
    DWORD dwNumProviders;
    DWORD dwProviderListSize;
    DWORD dwProviderListOffset;
} LINEPROVIDERLIST, FAR *LPLINEPROVIDERLIST;

typedef struct lineproviderentry_tag {
    DWORD dwPermanentProviderID;
    DWORD dwProviderFilenameSize;
    DWORD dwProviderFilenameOffset;
} LINEPROVIDERENTRY, FAR *LPLINEPROVIDERENTRY;




#define LINETOLLLISTOPTION_ADD         0x00000001
#define LINETOLLLISTOPTION_REMOVE      0x00000002

#define LINETRANSLATEOPTION_CARDOVERRIDE  0x00000001

#define LINETRANSLATERESULT_CANONICAL              0x00000001
#define LINETRANSLATERESULT_INTERNATIONAL          0x00000002
#define LINETRANSLATERESULT_LONGDISTANCE           0x00000004
#define LINETRANSLATERESULT_LOCAL                  0x00000008
#define LINETRANSLATERESULT_INTOLLLIST             0x00000010
#define LINETRANSLATERESULT_NOTINTOLLLIST          0x00000020
#define LINETRANSLATERESULT_DIALBILLING            0x00000040
#define LINETRANSLATERESULT_DIALQUIET              0x00000080
#define LINETRANSLATERESULT_DIALDIALTONE           0x00000100
#define LINETRANSLATERESULT_DIALPROMPT             0x00000200

#ifdef ATWORK
// Callback message prototype
BOOL WINAPI tapiPerformCallback(
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam);
#endif

// Simple Telephony prototypes

LONG WINAPI tapiRequestMakeCall(
	LPCSTR lpszDestAddress,
	LPCSTR lpszAppName,
	LPCSTR lpszCalledParty,
	LPCSTR lpszComment);

LONG WINAPI tapiRequestMediaCall(
	HWND hWnd,
	WPARAM wRequestID,
	LPCSTR lpszDeviceClass,
	LPCSTR lpDeviceID,
	DWORD dwSize,
	DWORD dwSecure,
	LPCSTR lpszDestAddress,
	LPCSTR lpszAppName,
	LPCSTR lpszCalledParty,
	LPCSTR lpszComment);

LONG WINAPI tapiRequestDrop(
	HWND hWnd,
	WPARAM wRequestID);

LONG WINAPI lineRegisterRequestRecipient(
	HLINEAPP hLineApp,
	DWORD dwRegistrationInstance,
	DWORD dwRequestMode,
	DWORD bEnable);

LONG WINAPI tapiGetLocationInfo(
	LPSTR lpszCountryCode,
	LPSTR lpszCityCode);
	
// Tapi Address Translation procedures
LONG WINAPI lineSetCurrentLocation(
    HLINEAPP hLineApp,
    DWORD dwLocation);

LONG WINAPI lineSetTollList(
    HLINEAPP hLineApp,
    DWORD dwDeviceID,
    LPCSTR lpszAddressIn,
    DWORD dwTollListOption);

LONG WINAPI lineTranslateAddress(
    HLINEAPP hLineApp,
    DWORD dwDeviceID,
    DWORD dwAPIVersion,
    LPCSTR lpszAddressIn,
    DWORD dwCard,
    DWORD dwTranslateOptions,
    LPLINETRANSLATEOUTPUT lpTranslateOutput);

LONG WINAPI lineGetTranslateCaps(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps);


// Tapi function prototypes

LONG WINAPI lineAccept(
	HCALL hCall, 
	LPCSTR lpsUserUserInfo,
	DWORD dwSize);

LONG WINAPI lineAddToConference(
	HCALL hConfCall, 
	HCALL hConsultCall);

LONG WINAPI lineAnswer(
	HCALL hCall,
	LPCSTR lpsUserUserInfo,
	DWORD dwSize);

LONG WINAPI lineBlindTransfer(
	HCALL hCall, 
	LPCSTR lpszDestAddress,
	DWORD dwCountryCode);

LONG WINAPI lineClose(
	HLINE hLine);

LONG WINAPI  lineCompleteCall(
	HCALL hCall, 
	LPDWORD lpdwCompletionID, 
	DWORD dwCompletionMode, 
	DWORD dwMessageID);

LONG WINAPI lineCompleteTransfer(
	HCALL hCall, 
	HCALL hConsultCall,
	LPHCALL lphConfCall,
	DWORD dwTransferMode);

LONG WINAPI lineConfigDialog(
	DWORD dwDeviceID,
	HWND  hwndOwner,
	LPCSTR lpszDeviceClass);

LONG WINAPI lineDeallocateCall(
	HCALL hCall);

LONG WINAPI lineDevSpecific(
	HLINE hLine, 
	DWORD dwAddressID,
	HCALL hCall,
	LPVOID lpParams, 
	DWORD dwSize);

LONG WINAPI lineDevSpecificFeature(
	HLINE hLine, 
	DWORD dwFeature, 
	LPVOID lpParams, 
	DWORD dwSize);

LONG WINAPI lineDial(
	HCALL hCall, 
	LPCSTR lpszDestAddress, 
	DWORD dwCountryCode);

LONG WINAPI lineDrop(
	HCALL hCall, 
	LPCSTR lpsUserUserInfo, 
	DWORD dwSize);

LONG WINAPI lineForward(
	HLINE hLine, 
	DWORD bAllAddresses, 
	DWORD dwAddressID, 
	LPLINEFORWARDLIST const lpForwardList, 
	DWORD dwNumRingsNoAnswer,
	LPHCALL lphConsultCall,
	LPLINECALLPARAMS const lpCallParams);

LONG WINAPI lineGatherDigits(
	HCALL hCall, 
	DWORD dwDigitModes, 
	LPSTR lpsDigits, 
	DWORD dwNumDigits, 
	LPCSTR lpszTerminationDigits, 
	DWORD dwFirstDigitTimeout, 
	DWORD dwInterDigitTimeout);

LONG WINAPI lineGenerateDigits(
	HCALL hCall, 
	DWORD dwDigitMode, 
	LPCSTR lpszDigits, 
	DWORD dwDuration);

LONG WINAPI lineGenerateTone(
	HCALL hCall, 
	DWORD dwToneMode,
	DWORD dwDuration,
	DWORD dwNumTones,
	LPLINEGENERATETONE const lpTones);

LONG WINAPI lineGetAddressCaps(
	HLINEAPP hLineApp, 
	DWORD dwDeviceID, 
	DWORD dwAddressID, 
	DWORD dwAPIVersion,
	DWORD dwExtVersion, 
	LPLINEADDRESSCAPS lpAddressCaps);

LONG WINAPI lineGetAddressID(
	HLINE hLine, 
	LPDWORD lpdwAddressID, 
	DWORD dwAddressMode, 
	LPCSTR lpsAddress, 
	DWORD dwSize);

LONG WINAPI lineGetAddressStatus(
	HLINE hLine,
	DWORD dwAddressID,
	LPLINEADDRESSSTATUS lpAddressStatus);

LONG WINAPI lineGetCallInfo(
	HCALL hCall, 
	LPLINECALLINFO lpCallInfo);

LONG WINAPI lineGetCallStatus(
	HCALL hCall, 
	LPLINECALLSTATUS lpCallStatus);

LONG WINAPI lineGetConfRelatedCalls(
	HCALL hCall,
	LPLINECALLLIST lpCallList);
	
LONG WINAPI lineGetDevCaps(
	HLINEAPP hLineApp, 
	DWORD dwDeviceID, 
	DWORD dwAPIVersion,
	DWORD dwExtVersion, 
	LPLINEDEVCAPS lpLineDevCaps);

LONG WINAPI lineGetDevConfig(
	DWORD dwDeviceID,
	LPVARSTRING lpDeviceConfig,
	LPCSTR lpszDeviceClass);

LONG WINAPI lineGetNewCalls(
	HLINE hLine,
	DWORD dwAddressID,
	DWORD dwSelect,
	LPLINECALLLIST lpCallList);

LONG WINAPI lineGetIcon(
	DWORD dwDeviceID,
	LPCSTR lpszDeviceClass,
	LPHICON lphIcon);
	
LONG WINAPI lineGetID(
	HLINE hLine,
	DWORD dwAddressID, 
	HCALL hCall,
	DWORD dwSelect,        
	LPVARSTRING lpDeviceID, 
	LPCSTR lpszDeviceClass);

LONG WINAPI lineGetLineDevStatus(
	HLINE hLine, 
	LPLINEDEVSTATUS lpLineDevStatus);

LONG WINAPI lineGetNumRings(
	HLINE hLine, 
	DWORD dwAddressID, 
	LPDWORD lpdwNumRings);

LONG WINAPI lineGetRequest(
	HLINEAPP hLineApp,
	DWORD dwRequestMode,
	LPVOID lpRequestBuffer);

LONG WINAPI lineGetStatusMessages(
	HLINE hLine, 
	LPDWORD lpdwLineStates, 
	LPDWORD lpdwAddressStates);

LONG WINAPI lineHandoff(
	HCALL hCall, 
	LPCSTR lpszFileName,
	DWORD dwMediaMode);

LONG WINAPI lineHold(
	HCALL hCall);

LONG WINAPI lineInitialize(
	LPHLINEAPP lphLineApp,
	HINSTANCE hInstance,
	LINECALLBACK lpfnCallback,
	LPCSTR lpszAppName,
	LPDWORD lpdwNumDevs);

LONG WINAPI lineMakeCall(
	HLINE hLine, 
	LPHCALL lphCall, 
	LPCSTR lpszDestAddress, 
	DWORD dwCountryCode, 
	LPLINECALLPARAMS const lpCallParams);

LONG WINAPI lineMonitorDigits(
	HCALL hCall, 
	DWORD dwDigitModes);

LONG WINAPI lineMonitorMedia(
	HCALL hCall, 
	DWORD dwMediaModes);

LONG WINAPI lineMonitorTones(
	HCALL hCall, 
	LPLINEMONITORTONE const lpToneList, 
	DWORD dwNumEntries);

LONG WINAPI lineNegotiateAPIVersion(
	HLINEAPP hLineApp,
	DWORD dwDeviceID,
	DWORD dwAPILowVersion,
	DWORD dwAPIHighVersion,
	LPDWORD lpdwAPIVersion,
	LPLINEEXTENSIONID lpExtensionID);

LONG WINAPI lineNegotiateExtVersion(
	HLINEAPP hLineApp,
	DWORD dwDeviceID,
	DWORD dwAPIVersion,
	DWORD dwExtLowVersion,
	DWORD dwExtHighVersion,
	LPDWORD lpdwExtVersion);

LONG WINAPI lineOpen(
	HLINEAPP hLineApp, 
	DWORD dwDeviceID,
	LPHLINE lphLine,
	DWORD dwAPIVersion,
	DWORD dwExtVersion,
	DWORD dwCallbackInstance,
	DWORD dwPrivileges,
	DWORD dwMediaModes,
	LPLINECALLPARAMS const lpCallParams);

LONG WINAPI linePark(
	HCALL hCall, 
	DWORD dwParkMode, 
	LPCSTR lpszDirAddress,
	LPVARSTRING lpNonDirAddress);

LONG WINAPI linePickup(
	HLINE hLine,
	DWORD dwAddressID,
	LPHCALL lphCall, 
	LPCSTR lpszDestAddress, 
	LPCSTR lpszGroupID);

LONG WINAPI linePrepareAddToConference(
	HCALL            hConfCall,
	LPHCALL          lphConsultCall,
	LPLINECALLPARAMS const lpCallParams);
	
LONG WINAPI lineRedirect(
	HCALL hCall, 
	LPCSTR lpszDestAddress, 
	DWORD dwCountryCode);

LONG WINAPI lineRemoveFromConference(
	HCALL hCall);

LONG WINAPI lineSecureCall(
	HCALL hCall);

LONG WINAPI lineSendUserUserInfo(
	HCALL hCall, 
	LPCSTR lpsUserUserInfo, 
	DWORD dwSize);

LONG WINAPI lineSetAppSpecific(
	HCALL hCall, 
	DWORD dwAppSpecific);

LONG WINAPI lineSetCallParams(
	HCALL hCall, 
	DWORD dwBearerMode,
	DWORD dwMinRate,
	DWORD dwMaxRate,
	LPLINEDIALPARAMS const lpDialParams);

LONG WINAPI lineSetCallPrivilege(
	HCALL hCall,
	DWORD dwCallPrivilege);

LONG WINAPI lineSetDevConfig(
	DWORD dwDeviceID,
	LPVOID const lpDeviceConfig,
	DWORD dwSize,
	LPCSTR lpszDeviceClass);

LONG WINAPI lineSetMediaControl(
	HLINE hLine,
	DWORD dwAddressID,
	HCALL hCall, 
	DWORD dwSelect,
	LPLINEMEDIACONTROLDIGIT const lpDigitList, 
	DWORD dwDigitNumEntries, 
	LPLINEMEDIACONTROLMEDIA const lpMediaList, 
	DWORD dwMediaNumEntries, 
	LPLINEMEDIACONTROLTONE const lpToneList, 
	DWORD dwToneNumEntries, 
	LPLINEMEDIACONTROLCALLSTATE const lpCallStateList, 
	DWORD dwCallStateNumEntries);

LONG WINAPI lineSetMediaMode(
	HCALL hCall,
	DWORD dwMediaModes);

LONG WINAPI lineSetNumRings(
	HLINE hLine, 
	DWORD dwAddressID, 
	DWORD dwNumRings);

LONG WINAPI lineSetStatusMessages(
	HLINE hLine, 
	DWORD dwLineStates, 
	DWORD dwAddressStates);

LONG WINAPI lineSetTerminal(
	HLINE hLine, 
	DWORD dwAddressID,
	HCALL hCall,
	DWORD dwSelect,
	DWORD dwTerminalModes, 
	DWORD dwTerminalID, 
	DWORD  bEnable);

LONG WINAPI lineSetupConference(
	HCALL hCall,
	HLINE hLine,
	LPHCALL lphConfCall, 
	LPHCALL lphConsultCall, 
	DWORD dwNumParties,
	LPLINECALLPARAMS const lpCallParams);

LONG WINAPI lineSetupTransfer(
	HCALL hCall, 
	LPHCALL lphConsultCall,
	LPLINECALLPARAMS const lpCallParams);

LONG WINAPI lineShutdown(
	HLINEAPP hLineApp);

LONG WINAPI lineSwapHold(
	HCALL hActiveCall, 
	HCALL hHeldCall);

LONG WINAPI lineUncompleteCall(
	HLINE hLine, 
	DWORD dwCompletionID);

LONG WINAPI lineUnhold(
	HCALL hCall);

LONG WINAPI lineUnpark(
	HLINE hLine,
	DWORD dwAddressID,
	LPHCALL lphCall, 
	LPCSTR lpszDestAddress);

LONG WINAPI phoneClose(
	HPHONE hPhone);

LONG WINAPI phoneConfigDialog(
	DWORD dwDeviceID,
	HWND  hwndOwner,
	LPCSTR lpszDeviceClass);


LONG WINAPI phoneDevSpecific(
	HPHONE hPhone, 
	LPVOID lpParams, 
	DWORD dwSize);

LONG WINAPI phoneGetButtonInfo(
	HPHONE hPhone, 
	DWORD dwButtonLampID, 
	LPPHONEBUTTONINFO lpButtonInfo);

LONG WINAPI phoneGetData(
	HPHONE hPhone, 
	DWORD dwDataID, 
	LPVOID lpData, 
	DWORD dwSize);

LONG WINAPI phoneGetDevCaps(
	HPHONEAPP hPhoneApp, 
	DWORD dwDeviceID,
	DWORD dwAPIVersion, 
	DWORD dwExtVersion, 
	LPPHONECAPS lpPhoneCaps);

LONG WINAPI phoneGetDisplay(
	HPHONE hPhone, 
	LPVARSTRING lpDisplay);

LONG WINAPI phoneGetGain(
	HPHONE hPhone, 
	DWORD dwHookSwitchDev, 
	LPDWORD lpdwGain);

LONG WINAPI phoneGetHookSwitch(
	HPHONE hPhone, 
	LPDWORD lpdwHookSwitchDevs);

LONG WINAPI phoneGetIcon(
	DWORD dwDeviceID,
	LPCSTR lpszDeviceClass,
	LPHICON lphIcon);

LONG WINAPI phoneGetID(
	HPHONE hPhone, 
	LPVARSTRING lpDeviceID, 
	LPCSTR lpszDeviceClass);

LONG WINAPI phoneGetLamp(
	HPHONE hPhone, 
	DWORD dwButtonLampID, 
	LPDWORD lpdwLampMode);

LONG WINAPI phoneGetRing(
	HPHONE hPhone, 
	LPDWORD lpdwRingMode, 
	LPDWORD lpdwVolume);

LONG WINAPI phoneGetStatus(
	HPHONE hPhone, 
	LPPHONESTATUS lpPhoneStatus);

LONG WINAPI phoneGetStatusMessages(
	HPHONE hPhone, 
	LPDWORD lpdwPhoneStates,
	LPDWORD lpdwButtonModes,
	LPDWORD lpdwButtonStates);

LONG WINAPI phoneGetVolume(
	HPHONE hPhone, 
	DWORD dwHookSwitchDev, 
	LPDWORD lpdwVolume);

LONG WINAPI phoneInitialize(
	LPHPHONEAPP   lphPhoneApp,
	HINSTANCE     hInstance,
	PHONECALLBACK lpfnCallback,
	LPCSTR lpszAppName,
	LPDWORD       lpdwNumDevs);

LONG WINAPI phoneNegotiateAPIVersion(
	HPHONEAPP hPhoneApp,
	DWORD dwDeviceID,
	DWORD dwAPILowVersion,
	DWORD dwAPIHighVersion,
	LPDWORD lpdwAPIVersion,
	LPPHONEEXTENSIONID lpExtensionID);

LONG WINAPI phoneNegotiateExtVersion(
	HPHONEAPP hPhoneApp,
	DWORD dwDeviceID,
	DWORD dwAPIVersion,
	DWORD dwExtLowVersion,
	DWORD dwExtHighVersion,
	LPDWORD lpdwExtVersion);

LONG WINAPI phoneOpen(
	HPHONEAPP hPhoneApp, 
	DWORD dwDeviceID,
	LPHPHONE lphPhone,
	DWORD dwAPIVersion,
	DWORD dwExtVersion,
	DWORD dwCallbackInstance,
	DWORD dwPrivilege);

LONG WINAPI phoneSetButtonInfo(
	HPHONE hPhone, 
	DWORD dwButtonLampID, 
	LPPHONEBUTTONINFO const lpButtonInfo);

LONG WINAPI phoneSetData(
	HPHONE hPhone, 
	DWORD dwDataID, 
	LPVOID const lpData, 
	DWORD dwSize);

LONG WINAPI phoneSetDisplay(
	HPHONE hPhone, 
	DWORD dwRow, 
	DWORD dwColumn, 
	LPCSTR lpsDisplay,
	DWORD dwSize);

LONG WINAPI phoneSetGain(
	HPHONE hPhone, 
	DWORD  dwHookSwitchDev, 
	DWORD  dwGain);

LONG WINAPI phoneSetHookSwitch(
	HPHONE hPhone, 
	DWORD  dwHookSwitchDevs, 
	DWORD  dwHookSwitchMode);

LONG WINAPI phoneSetLamp(
	HPHONE hPhone, 
	DWORD  dwButtonLampID, 
	DWORD  dwLampMode);

LONG WINAPI phoneSetRing(
	HPHONE hPhone, 
	DWORD  dwRingMode, 
	DWORD  dwVolume);

LONG WINAPI phoneSetStatusMessages(
	HPHONE hPhone, 
	DWORD  dwPhoneStates,
	DWORD  dwButtonModes,
	DWORD  dwButtonStates);

LONG WINAPI phoneSetVolume(
	HPHONE hPhone, 
	DWORD  dwHookSwitchDev, 
	DWORD  dwVolume);

LONG WINAPI phoneShutdown(
	HPHONEAPP hPhoneApp);

/* Tapi 1.1 extensions */

LONG WINAPI lineTranslateDialog(
	HLINEAPP hLineApp,
	DWORD dwDeviceID,
	DWORD dwAPIVersion,
	HWND hwndOwner,
	LPCSTR lpszAddressIn);

LONG WINAPI lineAddLocation(
	LPCSTR lpszLocationName,
	LPCSTR lpszLocalAccessCode,
	LPCSTR lpszLongDistanceAccessCode,
	LPCSTR lpszAreaCode,
	DWORD dwCountryID,
	DWORD dwPermanentCardID,
	LPCSTR lpszTollPrefixList,
	LPDWORD lpdwPermanentLocationID);

LONG WINAPI lineSetLocation(
	DWORD dwPermanentLocationID,
	LPCSTR lpszLocationName,
	LPCSTR lpszLocalAccessCode,
	LPCSTR lpszLongDistanceAccessCode,
	LPCSTR lpszAreaCode,
	DWORD dwCountryID,
	DWORD dwPermanentCardID,
	LPCSTR lpszTollPrefixList);

LONG WINAPI lineRemoveLocation(
	DWORD dwPermanentLocationID);

LONG WINAPI lineAddCard(
	LPCSTR lpszCardName,
	LPCSTR lpszCardNumber,
	LPCSTR lpszSameAreaRule,
	LPCSTR lpszLongDistanceRule,
	LPCSTR lpszInternationalRule,
	DWORD dwHideIfBlank,
	LPDWORD lpdwPermanentCardID);

LONG WINAPI lineSetCard(
	DWORD dwPermanentCardID,
	LPCSTR lpszCardName,
	LPCSTR lpszCardNumber,
	LPCSTR lpszSameAreaRule,
	LPCSTR lpszLongDistanceRule,
	LPCSTR lpszInternationalRule,
	DWORD dwHideIfBlank);

LONG WINAPI lineRemoveCard(
	DWORD dwPermanentCardID);

LONG WINAPI lineGetCountry(
	DWORD dwCountryID,
	LPLINECOUNTRYLIST lpLineCountryList);

LONG WINAPI lineSetCountry(
	DWORD dwCountryId,
	DWORD dwCountryCode,
	DWORD dwNextCountry,
	LPCSTR lpszCountryName,
	LPCSTR lpszSameAreaRule,
	LPCSTR lpszLongDistanceRule,
	LPCSTR lpszInternationalRule);

LONG WINAPI lineGetAppPriority(
	LPCSTR lpszAppName,
	DWORD dwMediaMode,
	LPLINEEXTENSIONID lpExtensionID,
	DWORD dwRequestMode,
	LPVARSTRING lpExtensionName,
	LPDWORD lpdwPriority);

LONG WINAPI lineSetAppPriority(
	LPCSTR lpszAppName,
	DWORD dwMediaMode,
	LPLINEEXTENSIONID lpExtensionID,
	DWORD dwRequestMode,
	LPCSTR lpszExtensionName,
	DWORD dwPriority);

LONG WINAPI lineAddProvider(
	LPCSTR lpszProviderFilename,
	HWND hwndOwner,
	LPDWORD lpdwPermanentProviderID);

LONG WINAPI lineConfigProvider(
	HWND hwndOwner,
	DWORD dwPermanentProviderID);

LONG WINAPI lineRemoveProvider(
	DWORD dwPermanentProviderID,
	HWND hwndOwner);

LONG WINAPI lineGetProviderList(
	LPLINEPROVIDERLIST lpProviderList);




#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#pragma pack()

#endif // TAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\testing.h ===
/*---------------------------------------------------------*\
|                                                           |
|  TESTING.H                                                |
|                                                           |
|  Testing's very own include file!                         |
\*---------------------------------------------------------*/



/* This has all of the defines for the wParam and lParam that go along with
 * the WM_TESTING message 
 */
/* wParam defines - Area
 */
#define   TEST_PRINTMAN          0x0001
#define   TEST_GDI               0x0002


/* lParam defines - Details (in LOWORD) 
 */
#define   TEST_PRINTJOB_START    0x0001 /* when bits start going to the port */
#define   TEST_PRINTJOB_END      0x0002 /* when bits stop going to the port  */
#define   TEST_QUEUE_READY       0x0003 /* when the queue is ready to accept a job */
#define   TEST_QUEUE_EMPTY       0x0004 /* when the last job is done being sent    */

#define   TEST_START_DOC         0x0001 /* print job is started              */
#define   TEST_END_DOC           0x0002 /* print job is ended                */


/* Defines for UserSeeUserDo and GDISeeGDIDo functions 
 */
LONG API UserSeeUserDo(WORD wMsg, WORD wParam, LONG lParam);
LONG API GDISeeGDIDo(WORD wMsg, WORD wParam, LONG lParam);

/* Defines for the various messages one can pass for the SeeDo functions. 
 */
#define SD_LOCALALLOC   0x0001  /* Alloc using flags wParam and lParam bytes.
                                 * Returns handle to data.  
                                 */
#define SD_LOCALFREE    0x0002  /* Free the memory allocated by handle wParam
                                 */
#define SD_LOCALCOMPACT 0x0003  /* Return the number of free bytes available 
                                 */
#define SD_GETUSERMENUHEAP 0x0004 /* Return the handle to the far menu heap
                                   * maintained by user. 
                                   */
#define SD_GETCLASSHEADPTR 0x0005 /* Return the near pointer to the head of 
                                   * the linked list of CLS structures.
                                   * Interface: wParam = NULL; lParam = NULL;
                                   */

#define SD_GETUSERHWNDHEAP 0x0006 /* Return the handle to the far window heap
                                   * maintained by user.
                                   */

#define SD_GETGDIHEAP      0x0007 /* Return the handle to the far heap
                                   * maintained by gdi.
                                   */
#define SD_GETPDCEFIRST    0x0008 /* Returns USER's head of dc cache entry list */
#define SD_GETHWNDDESKTOP  0x0009 /* Returns USER's head of window tree */

#define SD_LOCAL32ALLOC    0x000A /* Allocs mem from 32-bit heap.
                                   * wParam = heap (0=Window/GDI, 1=Menu)
                                   * lParam = amount of memory to allocate.
                                   * returns handle of memory
                                   */

#define SD_LOCAL32FREE     0x000B /* Frees mem allocated by SD_LOCAL32ALLOC.
                                   * wParam = heap (0=Window/GDI, 1=Menu)
                                   * lParam = handle
                                   * returns nothing.
                                   */

#define SD_GETSAFEMODE     0x000C /* Returns GDI's safe mode setting.
                                   * 0 = full acceleration
                                   * 1 = minimal acceleration
                                   * 2 = no acceleration
                                   * If the user requests safe mode but the
                                   *   display driver doesn't support it the
                                   *   safe mode setting will be 0
                                   */

#define SD_GETESIEDIPTRS   0x000D /* Returns a bit array indicating which
                                   * display driver DDIs have trashed esi or
                                   * edi.  This only works in DEBUG.  In RETAIL
                                   * this function will return 0.
                                   *
                                   * Each DDI uses two bits in the bit array
                                   * that indicate if esi, edi, resp. have been
                                   * trashed.  The table is 32 bytes long.
                                   *
                                   * For the DCT tests make sure all 32 bytes
                                   * are 0.
                                   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\thunks.h ===
/*****************************************************************************\
*                                                                             *
* thunks.h -  thunking functions, types, and definitions                      *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* NOTE: windows.h must be #included first				      *
*                                                                             *
* Copyright (c) 1994, Microsoft Corp.	All rights reserved.	              *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_THUNKS
#define _INC_THUNKS

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifndef _INC_WINDOWS    /* Must include windows.h first */
#error windows.h must be included before thunks.h
#endif  /* _INC_WINDOWS */

DWORD  WINAPI  MapSL(DWORD);
DWORD  WINAPI  MapLS(DWORD);
VOID   WINAPI  UnMapLS(LPVOID);

#endif  /* _INC_THUNKS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the various declarations and definitions
*   for the time routines.
*   [ANSI/System V]
*
****/

#ifndef _INC_TIME

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

/* implementation defined time types */

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

/* structure for use with localtime(), gmtime(), etc. */

#ifndef _TM_DEFINED
struct tm {
    int tm_sec; /* seconds after the minute - [0,59] */
    int tm_min; /* minutes after the hour - [0,59] */
    int tm_hour;    /* hours since midnight - [0,23] */
    int tm_mday;    /* day of the month - [1,31] */
    int tm_mon; /* months since January - [0,11] */
    int tm_year;    /* years since 1900 */
    int tm_wday;    /* days since Sunday - [0,6] */
    int tm_yday;    /* days since January 1 - [0,365] */
    int tm_isdst;   /* daylight savings time flag */
    };
#define _TM_DEFINED
#endif 


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC  1000


/* extern declarations for the global variables used by the ctime family of
 * routines.
 */

extern int __near __cdecl _daylight;    /* non-zero if daylight savings time is used */
extern long __near __cdecl _timezone;   /* difference in seconds between GMT and local time */
extern char * __near __cdecl _tzname[2];/* standard/daylight savings time zone names */


/* function prototypes */

#ifdef _MT
double __pascal difftime(time_t, time_t);
#else 
double __cdecl difftime(time_t, time_t);
#endif 

char * __cdecl asctime(const struct tm *);
char * __cdecl ctime(const time_t *);
#ifndef _WINDLL
clock_t __cdecl clock(void);
#endif 
struct tm * __cdecl gmtime(const time_t *);
struct tm * __cdecl localtime(const time_t *);
time_t __cdecl mktime(struct tm *);
#ifndef _WINDLL
size_t __cdecl strftime(char *, size_t, const char *,
    const struct tm *);
#endif 
char * __cdecl _strdate(char *);
char * __cdecl _strtime(char *);
time_t __cdecl time(time_t *);
void __cdecl _tzset(void);

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

extern int __near __cdecl daylight;
extern long __near __cdecl timezone;
extern char * __near __cdecl tzname[2];

void __cdecl tzset(void);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_TIME
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\toolhelp.inc ===
;**************************************************************************
;*  TOOLHELP.INC - toolhelp.dll functions, types, and definitions
;*
;*	Assembly-language public include file for TOOLHELP.DLL
;*
;*	Version 1.0								      *
;*
;* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.
;**************************************************************************

;** General symbol values
MAX_DATA        EQU     11
MAX_PATH16      EQU     255
MAX_MODULE_NAME EQU     8 + 1           ;Leave room for the zero and padding
MAX_CLASSNAME   EQU     255

; ----- Global heap walking -----

GLOBALENTRY STRUC
ge_dwSize       DD      ?               ;Structure version
ge_dwAddress    DD      ?               ;This block's address
ge_dwBlockSize  DD      ?               ;This block's size
ge_hBlock       DW      ?               ;This block's handle
ge_wcLock       DW      ?               ;Lock count
ge_wcPageLock   DW      ?               ;Page lock count
ge_wFlags       DW      ?               ;Block flags
ge_wHeapPresent DW      ?               ;Size of available local heap
ge_hOwner       DW      ?               ;Owner handle
ge_wType        DW      ?               ;Block type
ge_wData        DW      ?               ;Type-specific data
ge_dwNext       DD      ?               ;Pointer to next block
ge_dwNextAlt    DD      ?               ;Next free/LRU block in chain
GLOBALENTRY ENDS

; ** GlobalFirst()/GlobalNext() flags
GLOBAL_ALL      EQU     0
GLOBAL_LRU      EQU     1
GLOBAL_FREE     EQU     2

; ** GLOBALENTRY.ge_wType entries
GT_UNKNOWN      EQU     0
GT_DGROUP       EQU     1
GT_DATA         EQU     2
GT_CODE         EQU     3
GT_TASK         EQU     4
GT_RESOURCE     EQU     5
GT_MODULE       EQU     6
GT_FREE         EQU     7
GT_INTERNAL     EQU     8
GT_SENTINEL     EQU     9
GT_BURGERMASTER EQU     10

; ** if GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData:
GD_USERDEFINED          EQU     0
GD_CURSORCOMPONENT      EQU     1
GD_BITMAP               EQU     2
GD_ICONCOMPONENT        EQU     3
GD_MENU                 EQU     4
GD_DIALOG               EQU     5
GD_STRING               EQU     6
GD_FONTDIR              EQU     7
GD_FONT                 EQU     8
GD_ACCELERATORS         EQU     9
GD_RCDATA               EQU     10
GD_ERRTABLE             EQU     11
GD_CURSOR               EQU     12
GD_ICON                 EQU     14
GD_NAMETABLE            EQU     15
GD_MAX_RESOURCE         EQU     15

;** GLOBALENTRY.wFlags
GF_PDB_OWNER    EQU     100h            ;Low byte is KERNEL flags

; ----- Local heap walking -----

LOCALENTRY STRUC
le_dwSize       DD      ?
le_hHandle      DW      ?
le_wAddress     DW      ?
le_wSize        DW      ?
le_wFlags       DW      ?
le_wcLock       DW      ?
le_wType        DW      ?
le_hHeap        DW      ?
le_wHeapType    DW      ?
le_wNext        DW      ?
LOCALENTRY ENDS

; ** LOCALENTRY.wHeapType flags
NORMAL_HEAP     EQU     0
USER_HEAP       EQU     1
GDI_HEAP        EQU     2

;** LOCALENTRY.wFlags
LF_FIXED                EQU     1
LF_FREE                 EQU     2
LF_MOVEABLE             EQU     4

;** LOCALENTRY.wType
LT_NORMAL               EQU     0
LT_FREE                 EQU     0ffh
LT_GDI_PEN              EQU     1
LT_GDI_BRUSH            EQU     2
LT_GDI_FONT             EQU     3
LT_GDI_PALETTE          EQU     4
LT_GDI_BITMAP           EQU     5
LT_GDI_RGN              EQU     6
LT_GDI_DC               EQU     7
LT_GDI_DISABLED_DC      EQU     8
LT_GDI_METADC           EQU     9
LT_GDI_METAFILE         EQU     10
LT_GDI_MAX              EQU     LT_GDI_METAFILE
LT_USER_CLASS           EQU     1
LT_USER_WND             EQU     2
LT_USER_STRING          EQU     3
LT_USER_MENU            EQU     4
LT_USER_CLIP            EQU     5
LT_USER_CBOX            EQU     6
LT_USER_PALETTE         EQU     7
LT_USER_ED              EQU     8
LT_USER_BWL             EQU     9
LT_USER_OWNERDRAW       EQU     10
LT_USER_SPB             EQU     11
LT_USER_CHECKPOINT      EQU     12
LT_USER_DCE             EQU     13
LT_USER_MWP             EQU     14
LT_USER_PROP            EQU     15
LT_USER_LBIV            EQU     16
LT_USER_MISC            EQU     17
LT_USER_ATOMS           EQU     18
LT_USER_LOCKINPUTSTATE  EQU     19
LT_USER_HOOKLIST        EQU     20
LT_USER_USERSEEUSERDOALLOC EQU  21
LT_USER_HOTKEYLIST      EQU     22
LT_USER_POPUPMENU       EQU     23
LT_USER_ICON            EQU     24
LT_USER_QMSG            EQU     26
LT_USER_VWININFO        EQU     27
LT_USER_SMS             EQU     28
LT_USER_PROCESSINFO     EQU     29
LT_USER_ATTACHINFO      EQU     30
LT_USER_SYSCOLORTEMP    EQU     31
LT_USER_HANDLETABLE     EQU     32
LT_USER_SWITCHWNDINFO   EQU     33
LT_USER_HOOKMSG         EQU     34
LT_USER_MAX             EQU     34

; ----- Local32 heap walking -----

LOCAL32INFO     STRUC
li32_dwSize                     DD      ?
li32_dwMemReserved              DD      ?
li32_dwMemCommitted             DD      ?
li32_dwTotalFree                DD      ?
li32_dwLargestFreeBlock         DD      ?
li32_dwcFreeHandles             DD      ?
LOCAL32INFO     ENDS

LOCAL32ENTRY    STRUC
le32_dwSize          DD      ?
le32_hHandle         DW      ?
le32_dwAddress       DD      ?
le32_dwSizeBlock     DD      ?
le32_wFlags          DW      ?
le32_wType           DW      ?
le32_hHeap           DW      ?
le32_wHeapType       DW      ?
le32_dwNext          DD      ?
le32_dwNextAlt       DD      ?
LOCAL32ENTRY    ENDS

; ----- Stack tracing -----

STACKTRACEENTRY STRUC
st_dwSize       DD      ?
st_hTask        DW      ?
st_wSS          DW      ?
st_wBP          DW      ?
st_wCS          DW      ?
st_wIP          DW      ?
st_hModule      DW      ?
st_wSegment     DW      ?
st_wFlags       DW      ?
STACKTRACEENTRY ENDS

;** STACKTRACEENTRY.wFlags values
FRAME_FAR       EQU     0
FRAME_NEAR      EQU     1

; ----- Module list walking -----

MODULEENTRY STRUC
me_dwSize       DD      ?
me_szModule     DB      MAX_MODULE_NAME + 1 DUP(?)
me_hModule      DW      ?
me_wcUsage      DW      ?
me_szExePath    DB      MAX_PATH16 + 1 + 1 DUP(?)
me_wNext        DW      ?
MODULEENTRY ENDS

; ----- Task list walking -----

TASKENTRY STRUC
te_dwSize               DD      ?
te_hTask                DW      ?
te_hTaskParent          DW      ?
te_hInst                DW      ?
te_hModule              DW      ?
te_wSS                  DW      ?
te_wSP                  DW      ?
te_wStackTop            DW      ?
te_wStackMinimum        DW      ?
te_wStackBottom         DW      ?
te_wcEvents             DW      ?
te_hQueue               DW      ?
te_szModule             DB      MAX_MODULE_NAME + 1 DUP(?)
te_wPSPOffset           DW      ?
te_hNext                DW      ?
TASKENTRY ENDS

;** TaskSwitch() return values
TS_ERROR    EQU         0
TS_NEW      EQU         1
TS_OLD      EQU         2

; ----- Window Class enumeration -----

CLASSENTRY STRUC
ce_dwSize               DD      ?
ce_hInst                DW      ?
ce_szClassName          DB      MAX_CLASSNAME + 1 DUP(?)
ce_wNext                DW      ?
CLASSENTRY ENDS

; ----- Information functions -----

VMEMMANINFO STRUC
vmm_dwSize              DD      ?
vmm_dwLargestFreeBlock  DD      ?
vmm_dwMaxPagesAvailable DD      ?
vmm_dwMaxPagesLockable  DD      ?
vmm_dwTotalLinearSpace  DD      ?
vmm_dwTotalUnlockedPages DD     ?
vmm_dwFreePages         DD      ?
vmm_dwTotalPages        DD      ?
vmm_dwFreeLinearSpace   DD      ?
vmm_dwSwapFilePages     DD      ?
vmm_wPageSize           DW      ?
VMEMMANINFO ENDS

SYSHEAPINFO STRUC
si_dwSize               DD      ?
si_wUserFreePercent     DW      ?
si_wGDIFreePercent      DW      ?
si_hUserSegment         DW      ?
si_hGDISegment          DW      ?
si_hWndSegment          DW      ?
si_hMenuSegment         DW      ?
si_hGDI32Segment        DW      ?
SYSHEAPINFO ENDS

; ----- Notifications -----

;* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
;*      should ignore these.
;*
NFY_UNKNOWN     EQU     0

;** NFY_LOADSEG:  dwData points to a NFYLOADSEG structure
NFY_LOADSEG     EQU     1
NFYLOADSEG STRUC
nls_dwSize              DD      ?
nls_wSelector           DW      ?
nls_wSegNum             DW      ?
nls_wType               DW      ?       ;Low bit set for DATA, clear for CODE
nls_wcInstance          DW      ?       ;Instance count ONLY VALID FOR DATA!
nls_lpstrModuleName     DD      ?
NFYLOADSEG ENDS

;** NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed
NFY_FREESEG     EQU     2

;** NFY_STARTDLL:  dwData points to a NFYSTARTDLL structure
NFY_STARTDLL    EQU     3
NFYSTARTDLL STRUC
nsd_dwSize              DD      ?
nsd_hModule             DW      ?
nsd_wCS                 DW      ?
nsd_wIP                 DW      ?
NFYSTARTDLL ENDS

;** NFY_STARTTASK:  dwData is the CS:IP of the task start address
NFY_STARTTASK   EQU     4

;** NFY_EXITTASK:  The low byte of dwData contains the program exit code
NFY_EXITTASK    EQU     5

;** NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed
NFY_DELMODULE   EQU     6

;** NFY_RIP:  LOWORD(dwData) is the fatal exit code
;** NFY_RIP:  dwData points to a NFYRIP structure
NFY_RIP         EQU     7
NFYRIP STRUC
nrp_dwSize      DD      ?
nrp_wIP         DW      ?
nrp_wCS         DW      ?
nrp_wSS         DW      ?
nrp_wBP         DW      ?
nrp_wExitCode   DW      ?
NFYRIP ENDS

;** NFY_TASKIN:  No data.  Callback should do GetCurrentTask()
NFY_TASKIN      EQU     8

;** NFY_TASKOUT:  No data.  Callback should do GetCurrentTask()
NFY_TASKOUT     EQU     9

;** NFY_INCHAR:  Return value of callback is used.  If FALSE, mapped to 'i'
NFY_INCHAR      EQU     10

;** NFY_OUTSTR:  dwData points to the string to be displayed
NFY_OUTSTR      EQU     11

;** NFY_LOGERROR:  dwData points to a NFYLOGERROR struct
NFY_LOGERROR    EQU     12
NFYLOGERROR STRUC
nle_dwSize      DD      ?
nle_wErrCode    DW      ?
nle_lpInfo      DD      ?       ;Error-code dependent
NFYLOGERROR ENDS

;** NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct
NFY_LOGPARAMERROR EQU   13
NFYLOGPARAMERROR STRUC
nlp_dwSize              DD      ?
nlp_wErrCode            DW      ?
nlp_lpfnErrorAddr       DD      ?
nlp_lpBadParam          DD      ?
NFYLOGPARAMERROR ENDS

;** NotifyRegister() flags
NF_NORMAL       EQU     0
NF_TASKSWITCH   EQU     1
NF_RIP          EQU     2

;** TerminateApp() flag values
UAE_BOX         EQU     0
NO_UAE_BOX      EQU     1

TIMERINFO STRUC
ti_dwSize               DD      ?
ti_dwmsSinceStart       DD      ?
ti_dwmsThisVM           DD      ?
TIMERINFO ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines XENIX style macros for accessing arguments of a
*   function which takes a variable number of arguments.
*   [System V]
*
****/

#ifdef __cplusplus
extern "C" {
#endif 

#ifdef _WINDLL
#define _FARARG_ __far
#else 
#define _FARARG_
#endif 

#if (_MSC_VER <= 600)
#define __far       _far
#endif 

#ifdef __STDC__
#error varargs.h incompatible with ANSI (use stdarg.h)
#endif 

#ifndef _VA_LIST_DEFINED
typedef char _FARARG_ *va_list;
#define _VA_LIST_DEFINED
#endif 

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ( *(t _FARARG_ *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\tspi.h ===
// The  Telephony  API  is jointly copyrighted by Intel and Microsoft.  You are
// granted  a royalty free worldwide, unlimited license to make copies, and use
// the   API/SPI  for  making  applications/drivers  that  interface  with  the
// specification provided that this paragraph and the Intel/Microsoft copyright
// statement is maintained as is in the text and source code files.
//
// Copyright 1994 Microsoft, all rights reserved.
// Portions copyright 1992, 1993 Intel/Microsoft, all rights reserved.

#ifndef TSPI_H
#define TSPI_H


#include <windows.h>

#include "tapi.h"

// tspi.h  is  only  of  use  in  conjunction  with tapi.h.  Very few types are
// defined  in  tspi.h.   Most  types of procedure formal parameters are simply
// passed through from corresponding procedures in tapi.h.  A working knowledge
// of the TAPI interface is required for an understanding of this interface.

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef DECLARE_OPAQUE32
#define DECLARE_OPAQUE32(name)  struct name##__ { int unused; }; \
				typedef const struct name##__ FAR* name
#endif  // DECLARE_OPAQUE32

#ifndef TSPIAPI
#define TSPIAPI __export __far __pascal
#endif

DECLARE_OPAQUE32(HDRVCALL);
DECLARE_OPAQUE32(HDRVLINE);
DECLARE_OPAQUE32(HDRVPHONE);

typedef HDRVCALL FAR * LPHDRVCALL;
typedef HDRVLINE FAR * LPHDRVLINE;
typedef HDRVPHONE FAR * LPHDRVPHONE;

DECLARE_OPAQUE32(HTAPICALL);
DECLARE_OPAQUE32(HTAPILINE);
DECLARE_OPAQUE32(HTAPIPHONE);

typedef HTAPICALL FAR * LPHTAPICALL;
typedef HTAPILINE FAR * LPHTAPILINE;
typedef HTAPIPHONE FAR * LPHTAPIPHONE;



typedef void (CALLBACK * LINEEVENT) (
    HTAPILINE   htLine,
    HTAPICALL   htCall,
    DWORD       dwMsg,
    DWORD       dwParam1,
    DWORD       dwParam2,
    DWORD       dwParam3);

typedef void (CALLBACK * PHONEEVENT) (
    HTAPIPHONE  htPhone,
    DWORD       dwMsg,
    DWORD       dwParam1,
    DWORD       dwParam2,
    DWORD       dwParam3);


#define TSPI_MESSAGE_BASE 500
    // The lowest-numbered TSPI-specific message ID number

#define LINE_NEWCALL                                            ((long) TSPI_MESSAGE_BASE + 0)
#define LINE_CALLDEVSPECIFIC                    ((long) TSPI_MESSAGE_BASE + 1)
#define LINE_CALLDEVSPECIFICFEATURE     ((long) TSPI_MESSAGE_BASE + 2)

#define INITIALIZE_NEGOTIATION 0xFFFFFFFFL


typedef DWORD DRV_REQUESTID;

typedef void (CALLBACK * ASYNC_COMPLETION) (
    DRV_REQUESTID  dwRequestID,
    LONG           lResult);



// TSPIAPI TSPI_line functions
// ----------------------------------------------------------------------------
    
LONG TSPIAPI TSPI_lineAccept(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCSTR         lpsUserUserInfo,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineAddToConference(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdConfCall,
    HDRVCALL       hdConsultCall);

LONG TSPIAPI TSPI_lineAnswer(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCSTR         lpsUserUserInfo,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineBlindTransfer(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCSTR         lpszDestAddress,
    DWORD          dwCountryCode);

LONG TSPIAPI TSPI_lineClose(
    HDRVLINE  hdLine);

LONG TSPIAPI TSPI_lineCloseCall(
    HDRVCALL  hdCall);

LONG TSPIAPI TSPI_lineCompleteCall(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPDWORD        lpdwCompletionID,
    DWORD          dwCompletionMode,
    DWORD          dwMessageID);

LONG TSPIAPI TSPI_lineCompleteTransfer(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    HDRVCALL       hdConsultCall,
    HTAPICALL      htConfCall,
    LPHDRVCALL     lphdConfCall,
    DWORD          dwTransferMode);

LONG TSPIAPI TSPI_lineConditionalMediaDetection(
    HDRVLINE          hdLine,
    DWORD             dwMediaModes,
    LPLINECALLPARAMS  const lpCallParams);

LONG TSPIAPI TSPI_lineConfigDialog(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass);

LONG TSPIAPI TSPI_lineDevSpecific(
    DRV_REQUESTID  dwRequestID,
    HDRVLINE       hdLine,
    DWORD          dwAddressID,
    HDRVCALL       hdCall,
    LPVOID         lpParams,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineDevSpecificFeature(
    DRV_REQUESTID  dwRequestID,
    HDRVLINE       hdLine,
    DWORD          dwFeature,
    LPVOID         lpParams,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineDial(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCSTR         lpszDestAddress,
    DWORD          dwCountryCode);

LONG TSPIAPI TSPI_lineDrop(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCSTR         lpsUserUserInfo,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineDropOnClose(
    HDRVCALL       hdCall);

LONG TSPIAPI TSPI_lineDropNoOwner(
    HDRVCALL       hdCall);

LONG TSPIAPI TSPI_lineForward(
    DRV_REQUESTID     dwRequestID,
    HDRVLINE          hdLine,
    DWORD             bAllAddresses,
    DWORD             dwAddressID,
    LPLINEFORWARDLIST const lpForwardList,
    DWORD             dwNumRingsNoAnswer,
    HTAPICALL         htConsultCall,
    LPHDRVCALL        lphdConsultCall,
    LPLINECALLPARAMS  const lpCallParams);

LONG TSPIAPI TSPI_lineGatherDigits(
    HDRVCALL       hdCall,
    DWORD          dwEndToEndID,
    DWORD          dwDigitModes,
    LPSTR          lpsDigits,
    DWORD          dwNumDigits,
    LPCSTR         lpszTerminationDigits,
    DWORD          dwFirstDigitTimeout,
    DWORD          dwInterDigitTimeout);

LONG TSPIAPI TSPI_lineGenerateDigits(
    HDRVCALL       hdCall,
    DWORD          dwEndToEndID,
    DWORD          dwDigitMode,
    LPCSTR         lpszDigits,
    DWORD          dwDuration);

LONG TSPIAPI TSPI_lineGenerateTone(
    HDRVCALL            hdCall,
    DWORD               dwEndToEndID,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones);

LONG TSPIAPI TSPI_lineGetAddressCaps(
    DWORD              dwDeviceID,
    DWORD              dwAddressID,
    DWORD              dwTSPIVersion,
    DWORD              dwExtVersion,
    LPLINEADDRESSCAPS  lpAddressCaps);

LONG TSPIAPI TSPI_lineGetAddressID(
    HDRVLINE       hdLine,
    LPDWORD        lpdwAddressID,
    DWORD          dwAddressMode,
    LPCSTR         lpsAddress,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineGetAddressStatus(
    HDRVLINE             hdLine,
    DWORD                dwAddressID,
    LPLINEADDRESSSTATUS  lpAddressStatus);

LONG TSPIAPI TSPI_lineGetCallAddressID(
    HDRVCALL  hdCall,
    LPDWORD   lpdwAddressID);

LONG TSPIAPI TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  lpCallInfo);

LONG TSPIAPI TSPI_lineGetCallStatus(
    HDRVCALL          hdCall,
    LPLINECALLSTATUS  lpCallStatus);

LONG TSPIAPI TSPI_lineGetDevCaps(
    DWORD          dwDeviceID,
    DWORD          dwTSPIVersion,
    DWORD          dwExtVersion,
    LPLINEDEVCAPS  lpLineDevCaps);

LONG TSPIAPI TSPI_lineGetDevConfig(
	DWORD dwDeviceID,
	LPVARSTRING lpDeviceConfig,
	LPCSTR lpszDeviceClass);

LONG TSPIAPI TSPI_lineGetExtensionID(
    DWORD              dwDeviceID,
    DWORD              dwTSPIVersion,
    LPLINEEXTENSIONID  lpExtensionID);

LONG TSPIAPI TSPI_lineGetIcon(
    DWORD    dwDeviceID,
    LPCSTR   lpszDeviceClass,
    LPHICON  lphIcon);

LONG TSPIAPI TSPI_lineGetID(
    HDRVLINE       hdLine,
    DWORD          dwAddressID,
    HDRVCALL       hdCall,
    DWORD          dwSelect,
    LPVARSTRING    lpDeviceID,
    LPCSTR         lpszDeviceClass);

LONG TSPIAPI TSPI_lineGetLineDevStatus(
    HDRVLINE         hdLine,
    LPLINEDEVSTATUS  lpLineDevStatus);

LONG TSPIAPI TSPI_lineGetNumAddressIDs(
    HDRVLINE    hdLine,
    LPDWORD     lpdwNumAddressIDs);

LONG TSPIAPI TSPI_lineHold(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall);

LONG TSPIAPI TSPI_lineMakeCall(
    DRV_REQUESTID     dwRequestID,
    HDRVLINE          hdLine,
    HTAPICALL         htCall,
    LPHDRVCALL        lphdCall,
    LPCSTR            lpszDestAddress,
    DWORD             dwCountryCode,
    LPLINECALLPARAMS  const lpCallParams);

LONG TSPIAPI TSPI_lineMonitorDigits(
    HDRVCALL       hdCall,
    DWORD          dwDigitModes);

LONG TSPIAPI TSPI_lineMonitorMedia(
    HDRVCALL       hdCall,
    DWORD          dwMediaModes);

LONG TSPIAPI TSPI_lineMonitorTones(
    HDRVCALL           hdCall,
    DWORD              dwToneListID,
    LPLINEMONITORTONE  const lpToneList,
    DWORD              dwNumEntries);

LONG TSPIAPI TSPI_lineNegotiateExtVersion(
    DWORD    dwDeviceID,
    DWORD    dwTSPIVersion,
    DWORD    dwLowVersion,
    DWORD    dwHighVersion,
    LPDWORD  lpdwExtVersion);

LONG TSPIAPI TSPI_lineNegotiateTSPIVersion(
    DWORD    dwDeviceID,
    DWORD    dwLowVersion,
    DWORD    dwHighVersion,
    LPDWORD  lpdwTSPIVersion);

LONG TSPIAPI TSPI_lineOpen(
    DWORD       dwDeviceID,
    HTAPILINE   htLine,
    LPHDRVLINE  lphdLine,
    DWORD       dwTSPIVersion,
    LINEEVENT   lpfnEventProc);

LONG TSPIAPI TSPI_linePark(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    DWORD          dwParkMode,
    LPCSTR         lpszDirAddress,
    LPVARSTRING    lpNonDirAddress);

LONG TSPIAPI TSPI_linePickup(
    DRV_REQUESTID  dwRequestID,
    HDRVLINE       hdLine,
    DWORD          dwAddressID,
    HTAPICALL      htCall,
    LPHDRVCALL     lphdCall,
    LPCSTR         lpszDestAddress,
    LPCSTR         lpszGroupID);

LONG TSPIAPI TSPI_linePrepareAddToConference(
    DRV_REQUESTID     dwRequestID,
    HDRVCALL          hdConfCall,
    HTAPICALL         htConsultCall,
    LPHDRVCALL        lphdConsultCall,
    LPLINECALLPARAMS  const lpCallParams);

LONG TSPIAPI TSPI_lineRedirect(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCSTR         lpszDestAddress,
    DWORD          dwCountryCode);

LONG TSPIAPI TSPI_lineRemoveFromConference(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall);

LONG TSPIAPI TSPI_lineSecureCall(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall);

LONG TSPIAPI TSPI_lineSelectExtVersion(
    HDRVLINE  hdLine,
    DWORD     dwExtVersion);

LONG TSPIAPI TSPI_lineSendUserUserInfo(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall,
    LPCSTR         lpsUserUserInfo,
    DWORD          dwSize);

LONG TSPIAPI TSPI_lineSetAppSpecific(
    HDRVCALL       hdCall,
    DWORD          dwAppSpecific);

LONG TSPIAPI TSPI_lineSetCallParams(
    DRV_REQUESTID     dwRequestID,
    HDRVCALL          hdCall,
    DWORD             dwBearerMode,
    DWORD             dwMinRate,
    DWORD             dwMaxRate,
    LPLINEDIALPARAMS  const lpDialParams);

LONG TSPIAPI TSPI_lineSetDefaultMediaDetection(
    HDRVLINE       hdLine,
    DWORD          dwMediaModes);

LONG TSPIAPI TSPI_lineSetDevConfig(
    DWORD                       dwDeviceID,
    LPVOID                      const lpDeviceConfig,
    DWORD                       dwSize,
    LPCSTR                      lpszDeviceClass);

LONG TSPIAPI TSPI_lineSetMediaControl(
    HDRVLINE                     hdLine,
    DWORD                        dwAddressID,
    HDRVCALL                     hdCall,
    DWORD                        dwSelect,
    LPLINEMEDIACONTROLDIGIT      const lpDigitList,
    DWORD                        dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA      const lpMediaList,
    DWORD                        dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE       const lpToneList,
    DWORD                        dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE  const lpCallStateList,
    DWORD                        dwCallStateNumEntries);

LONG TSPIAPI TSPI_lineSetMediaMode(
    HDRVCALL       hdCall,
    DWORD          dwMediaMode);

LONG TSPIAPI TSPI_lineSetStatusMessages(
    HDRVLINE       hdLine,
    DWORD          dwLineStates,
    DWORD          dwAddressStates);

LONG TSPIAPI TSPI_lineSetTerminal(
    DRV_REQUESTID  dwRequestID,
    HDRVLINE       hdLine,
    DWORD          dwAddressID,
    HDRVCALL       hdCall,
    DWORD          dwSelect,
    DWORD          dwTerminalModes,
    DWORD          dwTerminalID,
    DWORD           bEnable);

LONG TSPIAPI TSPI_lineSetupConference(
    DRV_REQUESTID     dwRequestID,
    HDRVCALL          hdCall,
    HDRVLINE          hdLine,
    HTAPICALL         htConfCall,
    LPHDRVCALL        lphdConfCall,
    HTAPICALL         htConsultCall,
    LPHDRVCALL        lphdConsultCall,
    DWORD             dwNumParties,
    LPLINECALLPARAMS  const lpCallParams);

LONG TSPIAPI TSPI_lineSetupTransfer(
    DRV_REQUESTID     dwRequestID,
    HDRVCALL          hdCall,
    HTAPICALL         htConsultCall,
    LPHDRVCALL        lphdConsultCall,
    LPLINECALLPARAMS  const lpCallParams);

LONG TSPIAPI TSPI_lineSwapHold(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdActiveCall,
    HDRVCALL       hdHeldCall);

LONG TSPIAPI TSPI_lineUncompleteCall(
    DRV_REQUESTID  dwRequestID,
    HDRVLINE       hdLine,
    DWORD          dwCompletionID);

LONG TSPIAPI TSPI_lineUnhold(
    DRV_REQUESTID  dwRequestID,
    HDRVCALL       hdCall);

LONG TSPIAPI TSPI_lineUnpark(
    DRV_REQUESTID  dwRequestID,
    HDRVLINE       hdLine,
    DWORD          dwAddressID,
    HTAPICALL      htCall,
    LPHDRVCALL     lphdCall,
    LPCSTR         lpszDestAddress);



// TSPIAPI TSPI_phone functions
// ----------------------------------------------------------------------------

LONG TSPIAPI TSPI_phoneClose(
    HDRVPHONE  hdPhone);

LONG TSPIAPI TSPI_phoneConfigDialog(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass);

LONG TSPIAPI TSPI_phoneDevSpecific(
    DRV_REQUESTID  dwRequestID,
    HDRVPHONE      hdPhone,
    LPVOID         lpParams,
    DWORD          dwSize);

LONG TSPIAPI TSPI_phoneGetButtonInfo(
    HDRVPHONE          hdPhone,
    DWORD              dwButtonLampID,
    LPPHONEBUTTONINFO  lpButtonInfo);

LONG TSPIAPI TSPI_phoneGetData(
    HDRVPHONE      hdPhone,
    DWORD          dwDataID,
    LPVOID         lpData,
    DWORD          dwSize);

LONG TSPIAPI TSPI_phoneGetDevCaps(
    DWORD          dwDeviceID,
    DWORD          dwTSPIVersion,
    DWORD          dwExtVersion,
    LPPHONECAPS    lpPhoneCaps);

LONG TSPIAPI TSPI_phoneGetDisplay(
    HDRVPHONE      hdPhone,
    LPVARSTRING    lpDisplay);

LONG TSPIAPI TSPI_phoneGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID);

LONG TSPIAPI TSPI_phoneGetGain(
    HDRVPHONE      hdPhone,
    DWORD          dwHookSwitchDev,
    LPDWORD        lpdwGain);

LONG TSPIAPI TSPI_phoneGetHookSwitch(
    HDRVPHONE      hdPhone,
    LPDWORD        lpdwHookSwitchDevs);

LONG TSPIAPI TSPI_phoneGetIcon(
    DWORD    dwDeviceID,
    LPCSTR   lpszDeviceClass,
    LPHICON  lphIcon);

LONG TSPIAPI TSPI_phoneGetID(
    HDRVPHONE      hdPhone,
    LPVARSTRING    lpDeviceID,
    LPCSTR         lpszDeviceClass);

LONG TSPIAPI TSPI_phoneGetLamp(
    HDRVPHONE      hdPhone,
    DWORD          dwButtonLampID,
    LPDWORD        lpdwLampMode);

LONG TSPIAPI TSPI_phoneGetRing(
    HDRVPHONE      hdPhone,
    LPDWORD        lpdwRingMode,
    LPDWORD        lpdwVolume);

LONG TSPIAPI TSPI_phoneGetStatus(
    HDRVPHONE      hdPhone,
    LPPHONESTATUS  lpPhoneStatus);

LONG TSPIAPI TSPI_phoneGetVolume(
    HDRVPHONE      hdPhone,
    DWORD          dwHookSwitchDev,
    LPDWORD        lpdwVolume);

LONG TSPIAPI TSPI_phoneNegotiateExtVersion(
    DWORD    dwDeviceID,
    DWORD    dwTSPIVersion,
    DWORD    dwLowVersion,
    DWORD    dwHighVersion,
    LPDWORD  lpdwExtVersion);

LONG TSPIAPI TSPI_phoneNegotiateTSPIVersion(
    DWORD    dwDeviceID,
    DWORD    dwLowVersion,
    DWORD    dwHighVersion,
    LPDWORD  lpdwTSPIVersion);

LONG TSPIAPI TSPI_phoneOpen(
    DWORD        dwDeviceID,
    HTAPIPHONE   htPhone,
    LPHDRVPHONE  lphdPhone,
    DWORD        dwTSPIVersion,
    PHONEEVENT   lpfnEventProc);

LONG TSPIAPI TSPI_phoneSelectExtVersion(
    HDRVPHONE  hdPhone,
    DWORD      dwExtVersion);

LONG TSPIAPI TSPI_phoneSetButtonInfo(
    DRV_REQUESTID            dwRequestID,
    HDRVPHONE                hdPhone,
    DWORD                    dwButtonLampID,
    LPPHONEBUTTONINFO  const lpButtonInfo);

LONG TSPIAPI TSPI_phoneSetData(
    DRV_REQUESTID  dwRequestID,
    HDRVPHONE      hdPhone,
    DWORD          dwDataID,
    LPVOID         const lpData,
    DWORD          dwSize);

LONG TSPIAPI TSPI_phoneSetDisplay(
    DRV_REQUESTID  dwRequestID,
    HDRVPHONE      hdPhone,
    DWORD          dwRow,
    DWORD          dwColumn,
    LPCSTR         lpsDisplay,
    DWORD          dwSize);

LONG TSPIAPI TSPI_phoneSetGain(
    DRV_REQUESTID  dwRequestID,
    HDRVPHONE      hdPhone,
    DWORD          dwHookSwitchDev,
    DWORD          dwGain);

LONG TSPIAPI TSPI_phoneSetHookSwitch(
    DRV_REQUESTID  dwRequestID,
    HDRVPHONE      hdPhone,
    DWORD          dwHookSwitchDevs,
    DWORD          dwHookSwitchMode);

LONG TSPIAPI TSPI_phoneSetLamp(
    DRV_REQUESTID  dwRequestID,
    HDRVPHONE      hdPhone,
    DWORD          dwButtonLampID,
    DWORD          dwLampMode);

LONG TSPIAPI TSPI_phoneSetRing(
    DRV_REQUESTID  dwRequestID,
    HDRVPHONE      hdPhone,
    DWORD          dwRingMode,
    DWORD          dwVolume);

LONG TSPIAPI TSPI_phoneSetStatusMessages(
    HDRVPHONE      hdPhone,
    DWORD          dwPhoneStates,
    DWORD          dwButtonModes,
    DWORD          dwButtonStates);

LONG TSPIAPI TSPI_phoneSetVolume(
    DRV_REQUESTID  dwRequestID,
    HDRVPHONE      hdPhone,
    DWORD          dwHookSwitchDev,
    DWORD          dwVolume);



// TSPIAPI TSPI_provider functions
// ----------------------------------------------------------------------------

LONG TSPIAPI TSPI_providerConfig(
    HWND   hwndOwner,
    DWORD  dwPermanentProviderID);

LONG TSPIAPI TSPI_providerInit(
    DWORD             dwTSPIVersion,
    DWORD             dwPermanentProviderID,
    DWORD             dwLineDeviceIDBase,
    DWORD             dwPhoneDeviceIDBase,
    DWORD             dwNumLines,
    DWORD             dwNumPhones,
    ASYNC_COMPLETION  lpfnCompletionProc);

LONG TSPIAPI TSPI_providerInstall(
    HWND   hwndOwner,
    DWORD  dwPermanentProviderID);

LONG TSPIAPI TSPI_providerRemove(
    HWND   hwndOwner,
    DWORD  dwPermanentProviderID);

LONG TSPIAPI TSPI_providerShutdown(
    DWORD    dwTSPIVersion);

LONG TSPIAPI TSPI_providerEnumDevices(
    DWORD    dwPermanentProviderID,
    LPDWORD  lpdwNumLines,
    LPDWORD  lpdwNumPhones);


// The following macros are the ordinal numbers of the exported tspi functions

#define TSPI_PROC_BASE            500

#define TSPI_LINEACCEPT                    (TSPI_PROC_BASE + 0)
#define TSPI_LINEADDTOCONFERENCE           (TSPI_PROC_BASE + 1)
#define TSPI_LINEANSWER                    (TSPI_PROC_BASE + 2)
#define TSPI_LINEBLINDTRANSFER             (TSPI_PROC_BASE + 3)
#define TSPI_LINECLOSE                     (TSPI_PROC_BASE + 4)
#define TSPI_LINECLOSECALL                 (TSPI_PROC_BASE + 5)
#define TSPI_LINECOMPLETECALL              (TSPI_PROC_BASE + 6)
#define TSPI_LINECOMPLETETRANSFER          (TSPI_PROC_BASE + 7)
#define TSPI_LINECONDITIONALMEDIADETECTION (TSPI_PROC_BASE + 8)
#define TSPI_LINECONFIGDIALOG              (TSPI_PROC_BASE + 9)
#define TSPI_LINEDEVSPECIFIC               (TSPI_PROC_BASE + 10)
#define TSPI_LINEDEVSPECIFICFEATURE        (TSPI_PROC_BASE + 11)
#define TSPI_LINEDIAL                      (TSPI_PROC_BASE + 12)
#define TSPI_LINEDROP                      (TSPI_PROC_BASE + 13)
#define TSPI_LINEFORWARD                   (TSPI_PROC_BASE + 14)
#define TSPI_LINEGATHERDIGITS              (TSPI_PROC_BASE + 15)
#define TSPI_LINEGENERATEDIGITS            (TSPI_PROC_BASE + 16)
#define TSPI_LINEGENERATETONE              (TSPI_PROC_BASE + 17)
#define TSPI_LINEGETADDRESSCAPS            (TSPI_PROC_BASE + 18)
#define TSPI_LINEGETADDRESSID              (TSPI_PROC_BASE + 19)
#define TSPI_LINEGETADDRESSSTATUS          (TSPI_PROC_BASE + 20)
#define TSPI_LINEGETCALLADDRESSID          (TSPI_PROC_BASE + 21)
#define TSPI_LINEGETCALLINFO               (TSPI_PROC_BASE + 22)
#define TSPI_LINEGETCALLSTATUS             (TSPI_PROC_BASE + 23)
#define TSPI_LINEGETDEVCAPS                (TSPI_PROC_BASE + 24)
#define TSPI_LINEGETDEVCONFIG              (TSPI_PROC_BASE + 25)
#define TSPI_LINEGETEXTENSIONID            (TSPI_PROC_BASE + 26)
#define TSPI_LINEGETICON                   (TSPI_PROC_BASE + 27)
#define TSPI_LINEGETID                     (TSPI_PROC_BASE + 28)
#define TSPI_LINEGETLINEDEVSTATUS          (TSPI_PROC_BASE + 29)
#define TSPI_LINEGETNUMADDRESSIDS          (TSPI_PROC_BASE + 30)
#define TSPI_LINEHOLD                      (TSPI_PROC_BASE + 31)
#define TSPI_LINEMAKECALL                  (TSPI_PROC_BASE + 32)
#define TSPI_LINEMONITORDIGITS             (TSPI_PROC_BASE + 33)
#define TSPI_LINEMONITORMEDIA              (TSPI_PROC_BASE + 34)
#define TSPI_LINEMONITORTONES              (TSPI_PROC_BASE + 35)
#define TSPI_LINENEGOTIATEEXTVERSION       (TSPI_PROC_BASE + 36)
#define TSPI_LINENEGOTIATETSPIVERSION      (TSPI_PROC_BASE + 37)
#define TSPI_LINEOPEN                      (TSPI_PROC_BASE + 38)
#define TSPI_LINEPARK                      (TSPI_PROC_BASE + 39)
#define TSPI_LINEPICKUP                    (TSPI_PROC_BASE + 40)
#define TSPI_LINEPREPAREADDTOCONFERENCE    (TSPI_PROC_BASE + 41)
#define TSPI_LINEREDIRECT                  (TSPI_PROC_BASE + 42)
#define TSPI_LINEREMOVEFROMCONFERENCE      (TSPI_PROC_BASE + 43)
#define TSPI_LINESECURECALL                (TSPI_PROC_BASE + 44)
#define TSPI_LINESELECTEXTVERSION          (TSPI_PROC_BASE + 45)
#define TSPI_LINESENDUSERUSERINFO          (TSPI_PROC_BASE + 46)
#define TSPI_LINESETAPPSPECIFIC            (TSPI_PROC_BASE + 47)
#define TSPI_LINESETCALLPARAMS             (TSPI_PROC_BASE + 48)
#define TSPI_LINESETDEFAULTMEDIADETECTION  (TSPI_PROC_BASE + 49)
#define TSPI_LINESETDEVCONFIG              (TSPI_PROC_BASE + 50)
#define TSPI_LINESETMEDIACONTROL           (TSPI_PROC_BASE + 51)
#define TSPI_LINESETMEDIAMODE              (TSPI_PROC_BASE + 52)
#define TSPI_LINESETSTATUSMESSAGES         (TSPI_PROC_BASE + 53)
#define TSPI_LINESETTERMINAL               (TSPI_PROC_BASE + 54)
#define TSPI_LINESETUPCONFERENCE           (TSPI_PROC_BASE + 55)
#define TSPI_LINESETUPTRANSFER             (TSPI_PROC_BASE + 56)
#define TSPI_LINESWAPHOLD                  (TSPI_PROC_BASE + 57)
#define TSPI_LINEUNCOMPLETECALL            (TSPI_PROC_BASE + 58)
#define TSPI_LINEUNHOLD                    (TSPI_PROC_BASE + 59)
#define TSPI_LINEUNPARK                    (TSPI_PROC_BASE + 60)
#define TSPI_PHONECLOSE                    (TSPI_PROC_BASE + 61)
#define TSPI_PHONECONFIGDIALOG             (TSPI_PROC_BASE + 62)
#define TSPI_PHONEDEVSPECIFIC              (TSPI_PROC_BASE + 63)
#define TSPI_PHONEGETBUTTONINFO            (TSPI_PROC_BASE + 64)
#define TSPI_PHONEGETDATA                  (TSPI_PROC_BASE + 65)
#define TSPI_PHONEGETDEVCAPS               (TSPI_PROC_BASE + 66)
#define TSPI_PHONEGETDISPLAY               (TSPI_PROC_BASE + 67)
#define TSPI_PHONEGETEXTENSIONID           (TSPI_PROC_BASE + 68)
#define TSPI_PHONEGETGAIN                  (TSPI_PROC_BASE + 69)
#define TSPI_PHONEGETHOOKSWITCH            (TSPI_PROC_BASE + 70)
#define TSPI_PHONEGETICON                  (TSPI_PROC_BASE + 71)
#define TSPI_PHONEGETID                    (TSPI_PROC_BASE + 72)
#define TSPI_PHONEGETLAMP                  (TSPI_PROC_BASE + 73)
#define TSPI_PHONEGETRING                  (TSPI_PROC_BASE + 74)
#define TSPI_PHONEGETSTATUS                (TSPI_PROC_BASE + 75)
#define TSPI_PHONEGETVOLUME                (TSPI_PROC_BASE + 76)
#define TSPI_PHONENEGOTIATEEXTVERSION      (TSPI_PROC_BASE + 77)
#define TSPI_PHONENEGOTIATETSPIVERSION     (TSPI_PROC_BASE + 78)
#define TSPI_PHONEOPEN                     (TSPI_PROC_BASE + 79)
#define TSPI_PHONESELECTEXTVERSION         (TSPI_PROC_BASE + 80)
#define TSPI_PHONESETBUTTONINFO            (TSPI_PROC_BASE + 81)
#define TSPI_PHONESETDATA                  (TSPI_PROC_BASE + 82)
#define TSPI_PHONESETDISPLAY               (TSPI_PROC_BASE + 83)
#define TSPI_PHONESETGAIN                  (TSPI_PROC_BASE + 84)
#define TSPI_PHONESETHOOKSWITCH            (TSPI_PROC_BASE + 85)
#define TSPI_PHONESETLAMP                  (TSPI_PROC_BASE + 86)
#define TSPI_PHONESETRING                  (TSPI_PROC_BASE + 87)
#define TSPI_PHONESETSTATUSMESSAGES        (TSPI_PROC_BASE + 88)
#define TSPI_PHONESETVOLUME                (TSPI_PROC_BASE + 89)
#define TSPI_PROVIDERCONFIG                (TSPI_PROC_BASE + 90)
#define TSPI_PROVIDERINIT                  (TSPI_PROC_BASE + 91)
#define TSPI_PROVIDERINSTALL               (TSPI_PROC_BASE + 92)
#define TSPI_PROVIDERREMOVE                (TSPI_PROC_BASE + 93)
#define TSPI_PROVIDERSHUTDOWN              (TSPI_PROC_BASE + 94)
#define TSPI_PROVIDERENUMDEVICES           (TSPI_PROC_BASE + 95)
#define TSPI_LINEDROPONCLOSE               (TSPI_PROC_BASE + 96)
#define TSPI_LINEDROPNOOWNER               (TSPI_PROC_BASE + 97)


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  // TSPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\toolhelp.h ===
/*****************************************************************************\
*                                                                             *
* toolhelp.h -  toolhelp.dll functions, types, and definitions                *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* NOTE: windows.h must be #included first				      *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP
#define _INC_TOOLHELP

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _INC_WINDOWS    /* If included with 3.0 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#define HTASK       HANDLE
#endif  /* _INC_WINDOWS */

/****** General symbols ******************************************************/
#define MAX_DATA        11

#define MAX_PATH16      255

#define MAX_MODULE_NAME 8 + 1
#define MAX_CLASSNAME   255

/****** Global heap walking ***************************************************/
typedef struct tagGLOBALINFO
{
    DWORD dwSize;
    WORD wcItems;
    WORD wcItemsFree;
    WORD wcItemsLRU;
} GLOBALINFO;

typedef struct tagGLOBALENTRY
{
    DWORD dwSize;
    DWORD dwAddress;
    DWORD dwBlockSize;
    HGLOBAL hBlock;
    WORD wcLock;
    WORD wcPageLock;
    WORD wFlags;
    BOOL wHeapPresent;
    HGLOBAL hOwner;
    WORD wType;
    WORD wData;
    DWORD dwNext;
    DWORD dwNextAlt;
} GLOBALENTRY;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

/* GLOBALENTRY.wFlags */
#define GF_PDB_OWNER        0x0100      /* Low byte is KERNEL flags */

BOOL    WINAPI GlobalInfo(GLOBALINFO FAR* lpGlobalInfo);
BOOL    WINAPI GlobalFirst(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalNext(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalEntryHandle(GLOBALENTRY FAR* lpGlobal, HGLOBAL hItem);
BOOL    WINAPI GlobalEntryModule(GLOBALENTRY FAR* lpGlobal, HMODULE hModule, WORD wSeg);
WORD    WINAPI GlobalHandleToSel(HGLOBAL hMem);

/****** Local heap walking ***************************************************/

typedef struct tagLOCALINFO
{
    DWORD dwSize;
    WORD wcItems;
} LOCALINFO;

typedef struct tagLOCALENTRY
{
    DWORD dwSize;
    HLOCAL hHandle;
    WORD wAddress;
    WORD wSize;
    WORD wFlags;
    WORD wcLock;
    WORD wType;
    WORD hHeap;
    WORD wHeapType;
    WORD wNext;
} LOCALENTRY;

/* LOCALENTRY.wHeapType flags */
#define NORMAL_HEAP     0
#define USER_HEAP       1
#define GDI_HEAP        2

/* LOCALENTRY.wFlags */
#define LF_FIXED        1
#define LF_FREE         2
#define LF_MOVEABLE     4

/* LOCALENTRY.wType */
#define LT_NORMAL                   0
#define LT_FREE                     0xff
#define LT_GDI_PEN                  1   /* LT_GDI_* is for GDI's heap */
#define LT_GDI_BRUSH                2
#define LT_GDI_FONT                 3
#define LT_GDI_PALETTE              4
#define LT_GDI_BITMAP               5
#define LT_GDI_RGN                  6
#define LT_GDI_DC                   7
#define LT_GDI_DISABLED_DC          8
#define LT_GDI_METADC               9
#define LT_GDI_METAFILE             10
#define LT_GDI_MAX                  LT_GDI_METAFILE
#define LT_USER_CLASS               1   /* LT_USER_* is for USER's heap */
#define LT_USER_WND                 2
#define LT_USER_STRING              3
#define LT_USER_MENU                4
#define LT_USER_CLIP                5
#define LT_USER_CBOX                6
#define LT_USER_PALETTE             7
#define LT_USER_ED                  8
#define LT_USER_BWL                 9
#define LT_USER_OWNERDRAW           10
#define LT_USER_SPB                 11
#define LT_USER_CHECKPOINT          12
#define LT_USER_DCE                 13
#define LT_USER_MWP                 14
#define LT_USER_PROP                15
#define LT_USER_LBIV                16
#define LT_USER_MISC                17
#define LT_USER_ATOMS               18
#define LT_USER_LOCKINPUTSTATE      19
#define LT_USER_HOOKLIST            20
#define LT_USER_USERSEEUSERDOALLOC  21
#define LT_USER_HOTKEYLIST          22
#define LT_USER_POPUPMENU           23
#define LT_USER_ICON                24
#define LT_USER_QMSG                26
#define LT_USER_VWININFO            27
#define LT_USER_SMS                 28
#define LT_USER_PROCESSINFO         29
#define LT_USER_ATTACHINFO          30
#define LT_USER_SYSCOLORTEMP        31
#define LT_USER_HANDLETABLE         32
#define LT_USER_SWITCHWNDINFO       33
#define LT_USER_HOOKMSG             34
#define LT_USER_MAX                 34

BOOL    WINAPI LocalInfo(LOCALINFO FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalFirst(LOCALENTRY FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalNext(LOCALENTRY FAR* lpLocal);

/****** Local 32-bit heap walking ********************************************/

typedef HANDLE HLOCAL32;

typedef struct tagLOCAL32INFO
{
    DWORD dwSize;
    DWORD dwMemReserved;
    DWORD dwMemCommitted;
    DWORD dwTotalFree;
    DWORD dwLargestFreeBlock;
    DWORD dwcFreeHandles;
} LOCAL32INFO;

typedef struct tagLOCAL32ENTRY
{
    DWORD dwSize;
    HLOCAL32 hHandle;
    DWORD dwAddress;
    DWORD dwSizeBlock;
    WORD wFlags;
    WORD wType;
    WORD hHeap;
    WORD wHeapType;
    DWORD dwNext;
    DWORD dwNextAlt;
} LOCAL32ENTRY;

/* LOCAL32ENTRY.wHeapType flags same as LOCALENTRY.wHeapType flags */

/* LOCAL32ENTRY.wFlags same as LOCALENTRY.wFlags */

/* LOCAL32ENTRY.wType same as LOCALENTRY.wType */

BOOL    WINAPI Local32Info(LOCAL32INFO FAR* lpli32, HGLOBAL hHeap);
BOOL    WINAPI Local32First(LOCAL32ENTRY FAR* lple32, HGLOBAL hHeap);
BOOL    WINAPI Local32Next(LOCAL32ENTRY FAR* lple32);

/****** Stack Tracing ********************************************************/

typedef struct tagSTACKTRACEENTRY
{
    DWORD dwSize;
    HTASK hTask;
    WORD wSS;
    WORD wBP;
    WORD wCS;
    WORD wIP;
    HMODULE hModule;
    WORD wSegment;
    WORD wFlags;
} STACKTRACEENTRY;

/* STACKTRACEENTRY.wFlags values */
#define FRAME_FAR       0
#define FRAME_NEAR      1

BOOL    WINAPI StackTraceFirst(STACKTRACEENTRY FAR* lpStackTrace, HTASK hTask);
BOOL    WINAPI StackTraceCSIPFirst(STACKTRACEENTRY FAR* lpStackTrace,
            WORD wSS, WORD wCS, WORD wIP, WORD wBP);
BOOL    WINAPI StackTraceNext(STACKTRACEENTRY FAR* lpStackTrace);

/****** Module list walking **************************************************/

typedef struct tagMODULEENTRY
{
    DWORD dwSize;
    char szModule[MAX_MODULE_NAME + 1];
    HMODULE hModule;
    WORD wcUsage;
    char szExePath[MAX_PATH16 + 1];
    WORD wNext;
} MODULEENTRY;

BOOL    WINAPI ModuleFirst(MODULEENTRY FAR* lpModule);
BOOL    WINAPI ModuleNext(MODULEENTRY FAR* lpModule);
HMODULE WINAPI ModuleFindName(MODULEENTRY FAR* lpModule, LPCSTR lpstrName);
HMODULE WINAPI ModuleFindHandle(MODULEENTRY FAR* lpModule, HMODULE hModule);

/****** Task list walking *****************************************************/

typedef struct tagTASKENTRY
{
    DWORD dwSize;
    HTASK hTask;
    HTASK hTaskParent;
    HINSTANCE hInst;
    HMODULE hModule;
    WORD wSS;
    WORD wSP;
    WORD wStackTop;
    WORD wStackMinimum;
    WORD wStackBottom;
    WORD wcEvents;
    HGLOBAL hQueue;
    char szModule[MAX_MODULE_NAME + 1];
    WORD wPSPOffset;
    HANDLE hNext;
} TASKENTRY;

BOOL    WINAPI TaskFirst(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskNext(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskFindHandle(TASKENTRY FAR* lpTask, HTASK hTask);
DWORD   WINAPI TaskSetCSIP(HTASK hTask, WORD wCS, WORD wIP);
DWORD   WINAPI TaskGetCSIP(HTASK hTask);
BOOL    WINAPI TaskSwitch(HTASK hTask, DWORD dwNewCSIP);

/****** Window Class enumeration **********************************************/

typedef struct tagCLASSENTRY
{
    DWORD dwSize;
    HMODULE hInst;              /* This is really an hModule */
    char szClassName[MAX_CLASSNAME + 1];
    WORD wNext;
} CLASSENTRY;

BOOL    WINAPI ClassFirst(CLASSENTRY FAR* lpClass);
BOOL    WINAPI ClassNext(CLASSENTRY FAR* lpClass);

/****** Information functions *************************************************/

typedef struct tagMEMMANINFO
{
    DWORD dwSize;
    DWORD dwLargestFreeBlock;
    DWORD dwMaxPagesAvailable;
    DWORD dwMaxPagesLockable;
    DWORD dwTotalLinearSpace;
    DWORD dwTotalUnlockedPages;
    DWORD dwFreePages;
    DWORD dwTotalPages;
    DWORD dwFreeLinearSpace;
    DWORD dwSwapFilePages;
    WORD wPageSize;
} MEMMANINFO;

BOOL    WINAPI MemManInfo(MEMMANINFO FAR* lpEnhMode);

typedef struct tagSYSHEAPINFO
{
    DWORD dwSize;
    WORD wUserFreePercent;
    WORD wGDIFreePercent;
    HGLOBAL hUserSegment;
    HGLOBAL hGDISegment;
    HGLOBAL hWndSegment;
    HGLOBAL hMenuSegment;
    HGLOBAL hGDI32Segment;
} SYSHEAPINFO;

BOOL    WINAPI SystemHeapInfo(SYSHEAPINFO FAR* lpSysHeap);

/****** Interrupt Handling ****************************************************/

/* Hooked interrupts */
#define INT_DIV0            0
#define INT_1               1
#define INT_3               3
#define INT_UDINSTR         6
#define INT_STKFAULT        12
#define INT_GPFAULT         13
#define INT_BADPAGEFAULT    14
#define INT_CTLALTSYSRQ     256

/* TOOLHELP Interrupt callbacks registered with InterruptRegister should
 *  always be written in assembly language.  The stack frame is not 
 *  compatible with high level language conventions.
 *
 *  This stack frame looks as follows to the callback.  All registers
 *  should be preserved across this callback to allow restarting fault.
 *               ------------
 *               |   Flags  |  [SP + 0Eh]
 *               |    CS    |  [SP + 0Ch]
 *               |    IP    |  [SP + 0Ah]
 *               |  Handle  |  [SP + 08h]
 *               |Exception#|  [SP + 06h]
 *               |    AX    |  [SP + 04h]  AX Saved to allow MakeProcInstance
 *               |  Ret CS  |  [SP + 02h]
 *       SP--->  |  Ret IP  |  [SP + 00h]
 *               ------------
 */
BOOL    WINAPI InterruptRegister(HTASK hTask, FARPROC lpfnIntCallback);
BOOL    WINAPI InterruptUnRegister(HTASK hTask);

/*  Notifications:
 *      When a notification callback is called, two parameters are passed
 *      in:  a WORD, wID, and another DWORD, dwData.  wID is one of
 *      the values NFY_* below.  Callback routines should ignore unrecog-
 *      nized values to preserve future compatibility.  Callback routines
 *      are also passed a dwData value.  This may contain data or may be
 *      a FAR pointer to a structure, or may not be used depending on
 *      which notification is being received.
 *
 *      In all cases, if the return value of the callback is TRUE, the
 *      notification will NOT be passed on to other callbacks.  It has
 *      been handled.  This should be used sparingly and only with certain
 *      notifications.  Callbacks almost always return FALSE.
 */

/* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
 *  should ignore these.
 */
#define NFY_UNKNOWN         0

/* NFY_LOADSEG:  dwData points to a NFYLOADSEG structure */
#define NFY_LOADSEG         1
typedef struct tagNFYLOADSEG
{
    DWORD dwSize;
    WORD wSelector;
    WORD wSegNum;
    WORD wType;             /* Low bit set if data seg, clear if code seg */
    WORD wcInstance;        /* Instance count ONLY VALID FOR DATA SEG */
    LPCSTR lpstrModuleName;
} NFYLOADSEG;

/* NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed */
#define NFY_FREESEG         2

/* NFY_STARTDLL:  dwData points to a NFYLOADSEG structure */
#define NFY_STARTDLL        3
typedef struct tagNFYSTARTDLL
{
    DWORD dwSize;
    HMODULE hModule;
    WORD wCS;
    WORD wIP;
} NFYSTARTDLL;

/* NFY_STARTTASK:  dwData is the CS:IP of the start address of the task */
#define NFY_STARTTASK       4

/* NFY_EXITTASK:  The low byte of dwData contains the program exit code */
#define NFY_EXITTASK        5

/* NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed */
#define NFY_DELMODULE       6

/* NFY_RIP:  dwData points to a NFYRIP structure */
#define NFY_RIP             7
typedef struct tagNFYRIP
{
    DWORD dwSize;
    WORD wIP;
    WORD wCS;
    WORD wSS;
    WORD wBP;
    WORD wExitCode;
} NFYRIP;

/* NFY_TASKIN:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKIN          8

/* NFY_TASKOUT:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKOUT         9

/* NFY_INCHAR:  Return value from callback is used.  If NULL, mapped to 'i' */
#define NFY_INCHAR          10

/* NFY_OUTSTR:  dwData points to the string to be displayed */
#define NFY_OUTSTR          11

/* NFY_LOGERROR:  dwData points to a NFYLOGERROR struct */
#define NFY_LOGERROR        12
typedef struct tagNFYLOGERROR
{
    DWORD dwSize;
    UINT wErrCode;
    void FAR* lpInfo;       /* Error code-dependent */
} NFYLOGERROR;

/* NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct */
#define NFY_LOGPARAMERROR   13
typedef struct tagNFYLOGPARAMERROR
{
    DWORD dwSize;
    UINT wErrCode;
    FARPROC lpfnErrorAddr;
    void FAR* FAR* lpBadParam;
} NFYLOGPARAMERROR;

/* NotifyRegister() flags */
#define NF_NORMAL       0
#define NF_TASKSWITCH   1
#define NF_RIP          2

typedef BOOL (CALLBACK* LPFNNOTIFYCALLBACK)(WORD wID, DWORD dwData);

BOOL    WINAPI NotifyRegister(HTASK hTask, LPFNNOTIFYCALLBACK lpfn, WORD wFlags);
BOOL    WINAPI NotifyUnRegister(HTASK hTask);

/****** Miscellaneous *********************************************************/

void    WINAPI TerminateApp(HTASK hTask, WORD wFlags);

/* TerminateApp() flag values */
#define UAE_BOX     0
#define NO_UAE_BOX  1

DWORD   WINAPI MemoryRead(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);
DWORD   WINAPI MemoryWrite(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);

typedef struct tagTIMERINFO
{
    DWORD dwSize;
    DWORD dwmsSinceStart;
    DWORD dwmsThisVM;
} TIMERINFO;

BOOL    WINAPI TimerCount(TIMERINFO FAR* lpTimer);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* !_INC_TOOLHELP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\valid.h ===
#define IsValidPtrIn(pv,cb)  (!IsBadReadPtr ((pv),(cb)))
#define IsValidPtrOut(pv,cb) (!IsBadWritePtr((pv),(cb)))

STDAPI_(BOOL) IsValidInterface( void FAR* pv );
STDAPI_(BOOL) IsValidIid( REFIID riid );

 
#ifdef _DEBUG

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__); return; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", _szAssertFile, __LINE__), retval)

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__), retval)
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) {\
    FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__); return; }

//** INTERFACE ID validation macro:
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (FnAssert(#iid,"Invalid iid", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    FnAssert(#iid,"Invalid iid", _szAssertFile, __LINE__); return retval; }
#else



//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return; 
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE ID validation macro:
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) \
    return retval; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\userproc.h ===
/*****************************************************************************\
*                                                                             *
* userproc.h - Addition exports from USER.EXE				      *
*                                                                             *
* Copyright (c) 1993-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

/*  lParam of WM_DROPOBJECT and WM_QUERYDROPOBJECT points to one of these.
 */
typedef struct _dropstruct
  {
    HWND  hwndSource;
    HWND  hwndSink;
    WORD  wFmt;
    DWORD dwData;
    POINT ptDrop;
    DWORD dwControlData;
  } DROPSTRUCT;

#define DOF_EXECUTABLE	0x8001
#define DOF_DOCUMENT	0x8002
#define DOF_DIRECTORY	0x8003
#define DOF_MULTIPLE	0x8004

typedef DROPSTRUCT FAR * LPDROPSTRUCT;

WORD FAR PASCAL GetInternalWindowPos(HWND,LPRECT,LPPOINT);
BOOL FAR PASCAL SetInternalWindowPos(HWND,WORD,LPRECT,LPPOINT);

void FAR PASCAL CalcChildScroll(HWND,WORD);
void FAR PASCAL ScrollChildren(HWND,WORD,WORD,LONG);

DWORD FAR PASCAL DragObject(HWND hwndParent, HWND hwndFrom, WORD wFmt,
    DWORD dwData, HANDLE hCursor);
BOOL FAR PASCAL DragDetect(HWND hwnd, POINT pt);

void FAR PASCAL FillWindow(HWND hwndBrush, HWND hwndPaint, HDC hdc,
    HBRUSH hBrush);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\vcr.h ===
/***************************************************************************
 *                                                                         *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY  *
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE    *
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR  *
 *  PURPOSE.                                                               *
 *                                                                         *
 *  Copyright (c) 1993  Microsoft Corporation.  All Rights Reserved.	   *
 *                                                                         *
 * File:  vcr.h                                                            *
 * Title:           VCR-MCI Command Table Include File                     *
 *                                                                         *
 ***************************************************************************/

/* string resource base for vcr device type */
#define MCI_VCR_OFFSET                          1280

/* system MCI commands */
#define MCI_LIST                                0x0878
#define MCI_SETAUDIO                            0x0873 
#define MCI_SETVIDEO                            0x0876 
#define MCI_SIGNAL                              0x0875 

/* custom MCI commands for VCRs */
#define MCI_MARK                                (MCI_USER_MESSAGES + 0)
#define MCI_INDEX                               (MCI_USER_MESSAGES + 1)
#define MCI_SETTUNER                            (MCI_USER_MESSAGES + 2)
#define MCI_SETVCR                              (MCI_USER_MESSAGES + 3)
#define MCI_SETTIMECODE                         (MCI_USER_MESSAGES + 4)

/* Test is appplicable to all commands */
#define MCI_TEST                                0x00000020L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VCR_GETDEVCAPS_CAN_DETECT_LENGTH    0x00004001L
#define MCI_VCR_GETDEVCAPS_SEEK_ACCURACY        0x00004002L
#define MCI_VCR_GETDEVCAPS_HAS_CLOCK            0x00004003L
#define MCI_VCR_GETDEVCAPS_CAN_REVERSE          0x00004004L
#define MCI_VCR_GETDEVCAPS_NUMBER_OF_MARKS      0x00004005L
#define MCI_VCR_GETDEVCAPS_CAN_TEST             0x00004006L
#define MCI_VCR_GETDEVCAPS_CAN_PREROLL          0x00004007L
#define MCI_VCR_GETDEVCAPS_CAN_PREVIEW          0x00004008L
#define MCI_VCR_GETDEVCAPS_CAN_MONITOR_SOURCES  0x00004009L
#define MCI_VCR_GETDEVCAPS_HAS_TIMECODE         0x0000400AL
#define MCI_VCR_GETDEVCAPS_CAN_FREEZE           0x0000401BL
#define MCI_VCR_GETDEVCAPS_CLOCK_INCREMENT_RATE 0x0000401CL

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_VCR_INFO_VERSION                    0x00010000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VCR_PLAY_REVERSE                    0x00010000L
#define MCI_VCR_PLAY_AT                         0x00020000L
#define MCI_VCR_PLAY_SCAN                       0x00040000L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_VCR_RECORD_INITIALIZE               0x00010000L
#define MCI_VCR_RECORD_AT                       0x00020000L
#define MCI_VCR_RECORD_PREVIEW                  0x00040000L

/* flags for dwFlags parameter of MCI_CUE command message */
#define MCI_VCR_CUE_INPUT                       0x00010000L
#define MCI_VCR_CUE_OUTPUT                      0x00020000L
#define MCI_VCR_CUE_PREROLL                     0x00040000L
#define MCI_VCR_CUE_REVERSE                     0x00080000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_VCR_SEEK_REVERSE                    0x00010000L
#define MCI_VCR_SEEK_MARK                       0x00020000L
#define MCI_VCR_SEEK_AT                         0x00040000L
                                               
/* flags for dwFlags parameter of MCI_SETTUNER command message */
#define MCI_VCR_SETTUNER_CHANNEL                0x00010000L
#define MCI_VCR_SETTUNER_CHANNEL_UP             0x00020000L
#define MCI_VCR_SETTUNER_CHANNEL_DOWN           0x00040000L
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_UP        0x00080000L
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_DOWN      0x00100000L
#define MCI_VCR_SETTUNER_NUMBER                 0x00200000L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_VCR_SET_TIME_MODE                   0x00010000L
#define MCI_VCR_SET_POWER                       0x00020000L
#define MCI_VCR_SET_RECORD_FORMAT               0x00040000L
#define MCI_VCR_SET_COUNTER_FORMAT              0x00080000L
#define MCI_VCR_SET_INDEX                       0x00100000L
#define MCI_VCR_SET_ASSEMBLE_RECORD             0x00200000L
#define MCI_VCR_SET_TRACKING                    0x00400000L
#define MCI_VCR_SET_SPEED                       0x00800000L
#define MCI_VCR_SET_TAPE_LENGTH                 0x01000000L
#define MCI_VCR_SET_COUNTER_VALUE               0x02000000L
#define MCI_VCR_SET_CLOCK                       0x04000000L
#define MCI_VCR_SET_PAUSE_TIMEOUT               0x08000000L
#define MCI_VCR_SET_PREROLL_DURATION            0x10000000L
#define MCI_VCR_SET_POSTROLL_DURATION           0x20000000L

/* flags for dwItem parameter of MCI_SETTIMECODE commmand message */
#define MCI_VCR_SETTIMECODE_RECORD              0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VCR_STATUS_FRAME_RATE               0x00004001L /* Frame rate   */
#define MCI_VCR_STATUS_SPEED                    0x00004002L /* Speed        */
#define MCI_VCR_STATUS_MEDIA_TYPE               0x00004003L
#define MCI_VCR_STATUS_RECORD_FORMAT            0x00004004L
#define MCI_VCR_STATUS_PLAY_FORMAT              0x00004005L
#define MCI_VCR_STATUS_AUDIO_SOURCE             0x00004006L
#define MCI_VCR_STATUS_AUDIO_SOURCE_NUMBER      0x00004007L
#define MCI_VCR_STATUS_VIDEO_SOURCE             0x00004008L
#define MCI_VCR_STATUS_VIDEO_SOURCE_NUMBER      0x00004009L
#define MCI_VCR_STATUS_AUDIO_MONITOR            0x0000400AL
#define MCI_VCR_STATUS_AUDIO_MONITOR_NUMBER     0x0000400BL
#define MCI_VCR_STATUS_VIDEO_MONITOR            0x0000400CL
#define MCI_VCR_STATUS_VIDEO_MONITOR_NUMBER     0x0000400DL
#define MCI_VCR_STATUS_INDEX_ON                 0x0000400EL
#define MCI_VCR_STATUS_INDEX                    0x0000400FL
#define MCI_VCR_STATUS_COUNTER_FORMAT           0x00004010L
#define MCI_VCR_STATUS_COUNTER_RESOLUTION       0x00004011L
#define MCI_VCR_STATUS_TIMECODE_TYPE            0x00004012L
#define MCI_VCR_STATUS_COUNTER_VALUE            0x00004013L
#define MCI_VCR_STATUS_TUNER_CHANNEL            0x00004014L
#define MCI_VCR_STATUS_WRITE_PROTECTED          0x00004015L
#define MCI_VCR_STATUS_TIMECODE_RECORD          0x00004016L
#define MCI_VCR_STATUS_VIDEO_RECORD             0x00004017L
#define MCI_VCR_STATUS_AUDIO_RECORD             0x00004018L
#define MCI_VCR_STATUS_TIME_TYPE                0x00004019L
#define MCI_VCR_STATUS_TIME_MODE                0x0000401AL
#define MCI_VCR_STATUS_POWER_ON                 0x0000401BL
#define MCI_VCR_STATUS_CLOCK                    0x0000401CL
#define MCI_VCR_STATUS_ASSEMBLE_RECORD          0x0000401DL
#define MCI_VCR_STATUS_TIMECODE_PRESENT         0x0000401EL
#define MCI_VCR_STATUS_NUMBER_OF_VIDEO_TRACKS   0x0000401FL
#define MCI_VCR_STATUS_NUMBER_OF_AUDIO_TRACKS   0x00004020L
#define MCI_VCR_STATUS_CLOCK_ID                 0x00004021L
#define MCI_VCR_STATUS_PAUSE_TIMEOUT            0x00004022L
#define MCI_VCR_STATUS_PREROLL_DURATION         0x00004023L
#define MCI_VCR_STATUS_POSTROLL_DURATION        0x00004024L
#define MCI_VCR_STATUS_VIDEO                    0x00004025L
#define MCI_VCR_STATUS_AUDIO                    0x00004026L

#define MCI_VCR_STATUS_NUMBER                   0x00080000L

/* flags for dwFlags parameter of MCI_ESCAPE command message */
#define MCI_VCR_ESCAPE_STRING                   0x00000100L

/* flags for dwFlags parameter of MCI_LIST command message */
#define MCI_VCR_LIST_VIDEO_SOURCE               0x00010000L
#define MCI_VCR_LIST_AUDIO_SOURCE               0x00020000L
#define MCI_VCR_LIST_COUNT                      0x00040000L
#define MCI_VCR_LIST_NUMBER                     0x00080000L

/* flags for dwFlags parameter of MCI_MARK command message */
#define MCI_VCR_MARK_WRITE                      0x00010000L
#define MCI_VCR_MARK_ERASE                      0x00020000L

/* flags for dwFlags parameter for MCI_SETAUDIO command message */
#define MCI_VCR_SETAUDIO_RECORD                 0x00010000L
#define MCI_VCR_SETAUDIO_SOURCE                 0x00020000L
#define MCI_VCR_SETAUDIO_MONITOR                0x00040000L
#define MCI_VCR_SETAUDIO_TO                     0x00200000L
#define MCI_VCR_SETAUDIO_NUMBER                 0x00400000L

/* flags for dwFlags parameter for MCI_SETVIDEO command message */
#define MCI_VCR_SETVIDEO_RECORD                 0x00010000L
#define MCI_VCR_SETVIDEO_SOURCE                 0x00020000L
#define MCI_VCR_SETVIDEO_MONITOR                0x00040000L
#define MCI_VCR_SETVIDEO_TO                     0x00100000L
#define MCI_VCR_SETVIDEO_NUMBER                 0x00200000L

/* The following is the function digitalvideo drivers must use 
 * to signal when a frame marked by the SIGNAL command has been rendered:
 *
 *  SEND_VCRSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos )
 *
 * The following is a description of the parameters:
 *
 *  dwFlags    - the dwFlags parameter passed when the signal was set
 *  dwCallback - the dwCallback value from the MCI_VCR_SIGNAL_PARMS struct
 *               used to set the signal
 *  hDriver    - the handle assigned to the driver by MMSYSTEM when the 
 *               device was opened
 *  wDeviceID  - the device ID
 *  dwUser     - the dwUserParm value from the MCI_VCR_SIGNAL_PARMS struct
 *               used to set the signal
 *  dwPos      - the position at which the signal was sent, in the current
 *               time format.
 *
 * The window indicated by the handle in the dwCallback field is notified 
 * by means of a Windows message with the following form:
 *
 * msg    = MM_MCISIGNAL
 * wParam = wDeviceID of the sending driver 
 * lParam = the uservalue specified or the position the signal was sent
 *          at; the latter if the MCI_VCR_SIGNAL_POSITION flag was set 
 *          in the dwFlags parameter when the signal was created.
 */

#define SEND_VCRSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos ) \
  DriverCallback( (dwCallback), DCB_WINDOW, (HANDLE)(wDeviceID), MM_MCISIGNAL,\
  hDriver, ((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwPos):(dwUser),\
  ((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwUser):(dwPos))


/* Window message for signal notification */
#define MM_MCISIGNAL                            0x3CB

/* flags for dwFlags parameter of MCI_SIGNAL command message */
#define MCI_VCR_SIGNAL_AT                       0x00010000L
#define MCI_VCR_SIGNAL_EVERY                    0x00020000L
#define MCI_VCR_SIGNAL_USERVAL                  0x00040000L
#define MCI_VCR_SIGNAL_CANCEL                   0x00080000L
#define MCI_VCR_SIGNAL_POSITION                 0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_VCR_STEP_FRAMES                     0x00010000L
#define MCI_VCR_STEP_REVERSE                    0x00020000L

/* flags for dwFlags parameter of MCI_FREEZE command message */
#define MCI_VCR_FREEZE_INPUT                    0x00010000L
#define MCI_VCR_FREEZE_OUTPUT                   0x00020000L
#define MCI_VCR_FREEZE_FIELD                    0x00040000L
#define MCI_VCR_FREEZE_FRAME                    0x00080000L

/* flags for dwFlags parameter of MCI_UNFREEZE command message */
#define MCI_VCR_UNFREEZE_INPUT                  0x00010000L
#define MCI_VCR_UNFREEZE_OUTPUT                 0x00020000L

/* string resource values for vcr media types */
#define MCI_VCR_MEDIA_8MM                       (MCI_VCR_OFFSET + 1)
#define MCI_VCR_MEDIA_HI8                       (MCI_VCR_OFFSET + 2)
#define MCI_VCR_MEDIA_VHS                       (MCI_VCR_OFFSET + 3)
#define MCI_VCR_MEDIA_SVHS                      (MCI_VCR_OFFSET + 4)
#define MCI_VCR_MEDIA_BETA                      (MCI_VCR_OFFSET + 5)
#define MCI_VCR_MEDIA_EDBETA                    (MCI_VCR_OFFSET + 6)
#define MCI_VCR_MEDIA_OTHER                     (MCI_VCR_OFFSET + 7)

/* string resource values for vcr play/record formats */
#define MCI_VCR_FORMAT_SP                       (MCI_VCR_OFFSET + 8)
#define MCI_VCR_FORMAT_LP                       (MCI_VCR_OFFSET + 9)
#define MCI_VCR_FORMAT_EP                       (MCI_VCR_OFFSET + 10)
#define MCI_VCR_FORMAT_OTHER                    (MCI_VCR_OFFSET + 11)

/* string resource values for timecode types */
#define MCI_VCR_TIME_TIMECODE                   (MCI_VCR_OFFSET + 12)
#define MCI_VCR_TIME_COUNTER                    (MCI_VCR_OFFSET + 13)
#define MCI_VCR_TIME_DETECT                     (MCI_VCR_OFFSET + 14)

/* string resource values for src types */
#define MCI_VCR_SRC_TYPE_TUNER                  (MCI_VCR_OFFSET + 15)
#define MCI_VCR_SRC_TYPE_LINE                   (MCI_VCR_OFFSET + 16)
#define MCI_VCR_SRC_TYPE_SVIDEO                 (MCI_VCR_OFFSET + 17)
#define MCI_VCR_SRC_TYPE_RGB                    (MCI_VCR_OFFSET + 18)
#define MCI_VCR_SRC_TYPE_AUX                    (MCI_VCR_OFFSET + 19)
#define MCI_VCR_SRC_TYPE_GENERIC                (MCI_VCR_OFFSET + 20)
#define MCI_VCR_SRC_TYPE_MUTE                   (MCI_VCR_OFFSET + 21)
#define MCI_VCR_SRC_TYPE_OUTPUT                 (MCI_VCR_OFFSET + 22)

/* string resource values for vcr counters */
#define MCI_VCR_INDEX_TIMECODE                  (MCI_VCR_OFFSET + 23)         
#define MCI_VCR_INDEX_COUNTER                   (MCI_VCR_OFFSET + 24)   
#define MCI_VCR_INDEX_DATE                      (MCI_VCR_OFFSET + 25)
#define MCI_VCR_INDEX_TIME                      (MCI_VCR_OFFSET + 26)

/* string resources for timecode type and counter resolution */
#define MCI_VCR_COUNTER_RES_SECONDS             (MCI_VCR_OFFSET + 27)            
#define MCI_VCR_COUNTER_RES_FRAMES              (MCI_VCR_OFFSET + 28)

#define MCI_VCR_TIMECODE_TYPE_SMPTE             (MCI_VCR_OFFSET + 29)
#define MCI_VCR_TIMECODE_TYPE_SMPTE_DROP        (MCI_VCR_OFFSET + 30)
#define MCI_VCR_TIMECODE_TYPE_OTHER             (MCI_VCR_OFFSET + 31)
#define MCI_VCR_TIMECODE_TYPE_NONE              (MCI_VCR_OFFSET + 32)

#define MCI_VCR_PLUS                            (MCI_VCR_OFFSET + 33)
#define MCI_VCR_MINUS                           (MCI_VCR_OFFSET + 34)
#define MCI_VCR_RESET                           (MCI_VCR_OFFSET + 35)

#ifndef RC_INVOKED

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_VCR_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
    DWORD   dwMark;
    DWORD   dwAt;
} MCI_VCR_SEEK_PARMS;
typedef MCI_VCR_SEEK_PARMS FAR *LPMCI_VCR_SEEK_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_VCR_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTimeMode;
    DWORD   dwRecordFormat;
    DWORD   dwCounterFormat;
    DWORD   dwIndex;
    DWORD   dwTracking;
    DWORD   dwSpeed;
    DWORD   dwLength;
    DWORD   dwCounter;
    DWORD   dwClock;
    DWORD   dwPauseTimeout;
    DWORD   dwPrerollDuration;
    DWORD   dwPostrollDuration;
} MCI_VCR_SET_PARMS;
typedef MCI_VCR_SET_PARMS FAR *LPMCI_VCR_SET_PARMS;

/* parameter block for MCI_VCR_SETTUNER command message */
typedef struct tagMCI_VCR_SETTUNER_PARMS {
    DWORD   dwCallback;
    DWORD   dwChannel;
    DWORD   dwNumber;
} MCI_VCR_SETTUNER_PARMS;
typedef MCI_VCR_SETTUNER_PARMS FAR *LPMCI_VCR_SETTUNER_PARMS;

/* parameter block for MCI_ESCAPE command message */
typedef struct tagMCI_VCR_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VCR_ESCAPE_PARMS;
typedef MCI_VCR_ESCAPE_PARMS FAR *LPMCI_VCR_ESCAPE_PARMS;

/* parameter block for MCI_LIST command message */
typedef struct tagMCI_VCR_LIST_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwNumber;
} MCI_VCR_LIST_PARMS;
typedef MCI_VCR_LIST_PARMS FAR *LPMCI_VCR_LIST_PARMS;

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_VCR_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwAt;
} MCI_VCR_RECORD_PARMS;
typedef MCI_VCR_RECORD_PARMS FAR *LPMCI_VCR_RECORD_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VCR_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwAt;
} MCI_VCR_PLAY_PARMS;
typedef MCI_VCR_PLAY_PARMS FAR *LPMCI_VCR_PLAY_PARMS;

/* parameter block for MCI_SETAUDIO command message */
typedef struct tagMCI_VCR_SETAUDIO_PARMS {
    DWORD   dwCallback;
    DWORD   dwTrack;
    DWORD   dwTo;
    DWORD   dwNumber;
} MCI_VCR_SETAUDIO_PARMS;
typedef MCI_VCR_SETAUDIO_PARMS FAR *LPMCI_VCR_SETAUDIO_PARMS;

/* parameter block for MCI_SIGNAL command message */
typedef struct tagMCI_VCR_SIGNAL_PARMS {
    DWORD   dwCallback;
    DWORD   dwPosition;
    DWORD   dwPeriod;
    DWORD   dwUserParm;
} MCI_VCR_SIGNAL_PARMS;
typedef MCI_VCR_SIGNAL_PARMS FAR * LPMCI_VCR_SIGNAL_PARMS;

/* parameter block for MCI_VCR_STATUS command message */
typedef struct tagMCI_VCR_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
    DWORD   dwNumber;
} MCI_VCR_STATUS_PARMS;
typedef MCI_VCR_STATUS_PARMS FAR * LPMCI_VCR_STATUS_PARMS;

/* parameter block for MCI_SETVIDEO command message */
typedef struct tagMCI_VCR_SETVIDEO_PARMS {
    DWORD   dwCallback;
    DWORD   dwTrack;
    DWORD   dwTo;
    DWORD   dwNumber;
} MCI_VCR_SETVIDEO_PARMS;
typedef MCI_VCR_SETVIDEO_PARMS FAR *LPMCI_VCR_SETVIDEO_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VCR_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VCR_STEP_PARMS;
typedef MCI_VCR_STEP_PARMS FAR *LPMCI_VCR_STEP_PARMS;

/* parameter block for MCI_CUE command message */
typedef struct tagMCI_VCR_CUE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_VCR_CUE_PARMS;
typedef MCI_VCR_CUE_PARMS FAR *LPMCI_VCR_CUE_PARMS;

#endif /* NOT RC_INVOKED */

/* VCR error codes */
#define MCIERR_VCR_CANNOT_OPEN_COMM         (MCIERR_CUSTOM_DRIVER_BASE + 1)
#define MCIERR_VCR_CANNOT_WRITE_COMM        (MCIERR_CUSTOM_DRIVER_BASE + 2)
#define MCIERR_VCR_READ_TIMEOUT             (MCIERR_CUSTOM_DRIVER_BASE + 3)
#define MCIERR_VCR_COMMAND_BUFFER_FULL      (MCIERR_CUSTOM_DRIVER_BASE + 4)
#define MCIERR_VCR_COMMAND_CANCELLED        (MCIERR_CUSTOM_DRIVER_BASE + 5)
#define MCIERR_VCR_POWER_OFF                (MCIERR_CUSTOM_DRIVER_BASE + 6)
#define MCIERR_VCR_COMMAND_FAILED           (MCIERR_CUSTOM_DRIVER_BASE + 7)
#define MCIERR_VCR_SEARCH                   (MCIERR_CUSTOM_DRIVER_BASE + 8)
#define MCIERR_VCR_CONDITION                (MCIERR_CUSTOM_DRIVER_BASE + 9)
#define MCIERR_VCR_CAMERA_MODE              (MCIERR_CUSTOM_DRIVER_BASE + 10)
#define MCIERR_VCR_VCR_MODE                 (MCIERR_CUSTOM_DRIVER_BASE + 11)
#define MCIERR_VCR_COUNTER_TYPE             (MCIERR_CUSTOM_DRIVER_BASE + 12)
#define MCIERR_VCR_TUNER                    (MCIERR_CUSTOM_DRIVER_BASE + 13)
#define MCIERR_VCR_EMERGENCY_STOP           (MCIERR_CUSTOM_DRIVER_BASE + 14)
#define MCIERR_VCR_MEDIA_UNMOUNTED          (MCIERR_CUSTOM_DRIVER_BASE + 15)
#define MCIERR_VCR_REGISTER                 (MCIERR_CUSTOM_DRIVER_BASE + 16)
#define MCIERR_VCR_TRACK_FAILURE            (MCIERR_CUSTOM_DRIVER_BASE + 17)
#define MCIERR_VCR_CUE_FAILED_FLAGS         (MCIERR_CUSTOM_DRIVER_BASE + 18)
#define MCIERR_VCR_ISWRITEPROTECTED         (MCIERR_CUSTOM_DRIVER_BASE + 19)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\variant.h ===
/*** 
*variant.h
*
*  Copyright (C) 1992-1993, Microsoft Corporation.  All Rights Reserved.
*
*Purpose:
*  This file declares VARIANT, and related data types.
*
*Implementation Notes:
*  This file requires ole2.h
*
*****************************************************************************/

#ifndef _VARIANT_H_
#define _VARIANT_H_


#ifndef HUGEP
# ifdef _MAC
#  define HUGEP FAR
# elif  WIN32
#  define HUGEP
# else
#  define HUGEP _huge
# endif
#endif


/* Forward Declarations */

#ifdef __cplusplus
interface IDispatch;
#else
typedef interface IDispatch IDispatch;
#endif


typedef char FAR* BSTR;
typedef BSTR FAR* LPBSTR;


typedef struct FARSTRUCT tagSAFEARRAYBOUND {
    ULONG cElements;
    LONG lLbound;
} SAFEARRAYBOUND, FAR* LPSAFEARRAYBOUND;

typedef struct FARSTRUCT tagSAFEARRAY {
    USHORT cDims;
    USHORT fFeatures;
    USHORT cbElements;
    USHORT cLocks;
    ULONG handle;
    void HUGEP* pvData;
    SAFEARRAYBOUND rgsabound[1];
} SAFEARRAY, FAR* LPSAFEARRAY;

#define FADF_AUTO       0x0001	/* array is allocated on the stack         */
#define FADF_STATIC     0x0002	/* array is staticly allocated             */
#define FADF_EMBEDDED   0x0004	/* array is embedded in a structure        */
#define FADF_FIXEDSIZE  0x0010	/* array may not be resized or reallocated */
#define FADF_BSTR       0x0100	/* an array of BSTRs                       */
#define FADF_UNKNOWN    0x0200	/* an array of IUnknown*                   */
#define FADF_DISPATCH   0x0400	/* an array of IDispatch*                  */
#define FADF_VARIANT    0x0800	/* an array of VARIANTs                    */
#define FADF_RESERVED   0xF0E8  /* bits reserved for future use            */


/* 0 == FALSE, -1 == TRUE */
typedef short VARIANT_BOOL;


typedef double DATE;


/* This is a helper struct for use in handling currency. */
typedef struct FARSTRUCT tagCY {
#ifdef _MAC
    long	  Hi;
    unsigned long Lo;
#else
    unsigned long Lo;
    long	  Hi;
#endif
} CY;


/*
 * VARENUM usage key,
 *
 *   [V] - may appear in a VARIANT
 *   [T] - may appear in a TYPEDESC
 *   [P] - may appear in an OLE property set
 *
 */
enum VARENUM
{
    VT_EMPTY           = 0,   /* [V]   [P]  nothing                     */
    VT_NULL            = 1,   /* [V]        SQL style Null              */
    VT_I2              = 2,   /* [V][T][P]  2 byte signed int           */
    VT_I4              = 3,   /* [V][T][P]  4 byte signed int           */
    VT_R4              = 4,   /* [V][T][P]  4 byte real                 */
    VT_R8              = 5,   /* [V][T][P]  8 byte real                 */
    VT_CY              = 6,   /* [V][T][P]  currency                    */
    VT_DATE            = 7,   /* [V][T][P]  date                        */
    VT_BSTR            = 8,   /* [V][T][P]  binary string               */
    VT_DISPATCH        = 9,   /* [V][T]     IDispatch FAR*              */
    VT_ERROR           = 10,  /* [V][T]     SCODE                       */
    VT_BOOL            = 11,  /* [V][T][P]  True=-1, False=0            */
    VT_VARIANT         = 12,  /* [V][T][P]  VARIANT FAR*                */
    VT_UNKNOWN         = 13,  /* [V][T]     IUnknown FAR*               */
    VT_WBSTR           = 14,  /* [V][T]     wide binary string          */

    VT_I1              = 16,  /*    [T]     signed char                 */
    VT_UI1             = 17,  /*    [T]     unsigned char               */
    VT_UI2             = 18,  /*    [T]     unsigned short              */
    VT_UI4             = 19,  /*    [T]     unsigned short              */
    VT_I8              = 20,  /*    [T][P]  signed 64-bit int           */
    VT_UI8             = 21,  /*    [T]     unsigned 64-bit int         */
    VT_INT             = 22,  /*    [T]     signed machine int          */
    VT_UINT            = 23,  /*    [T]     unsigned machine int        */
    VT_VOID            = 24,  /*    [T]     C style void                */
    VT_HRESULT         = 25,  /*    [T]                                 */
    VT_PTR             = 26,  /*    [T]     pointer type                */
    VT_SAFEARRAY       = 27,  /*    [T]     (use VT_ARRAY in VARIANT)   */
    VT_CARRAY          = 28,  /*    [T]     C style array               */
    VT_USERDEFINED     = 29,  /*    [T]     user defined type	        */
    VT_LPSTR           = 30,  /*    [T][P]  null terminated string      */
    VT_LPWSTR          = 31,  /*    [T][P]  wide null terminated string */

    VT_FILETIME        = 64,  /*       [P]  FILETIME                    */
    VT_BLOB            = 65,  /*       [P]  Length prefixed bytes       */
    VT_STREAM          = 66,  /*       [P]  Name of the stream follows  */
    VT_STORAGE         = 67,  /*       [P]  Name of the storage follows */
    VT_STREAMED_OBJECT = 68,  /*       [P]  Stream contains an object   */
    VT_STORED_OBJECT   = 69,  /*       [P]  Storage contains an object  */
    VT_BLOB_OBJECT     = 70,  /*       [P]  Blob contains an object     */
    VT_CF              = 71,  /*       [P]  Clipboard format            */
    VT_CLSID           = 72   /*       [P]  A Class ID                  */
};

#define VT_VECTOR      0x1000 /*       [P]  simple counted array        */
#define VT_ARRAY       0x2000 /* [V]        SAFEARRAY*                  */
#define VT_BYREF       0x4000 /* [V]                                    */
#define VT_RESERVED    0x8000


typedef unsigned short VARTYPE;

typedef struct FARSTRUCT tagVARIANT VARIANT;
typedef struct FARSTRUCT tagVARIANT FAR* LPVARIANT;
typedef struct FARSTRUCT tagVARIANT VARIANTARG;
typedef struct FARSTRUCT tagVARIANT FAR* LPVARIANTARG;

struct FARSTRUCT tagVARIANT{
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    union {
      short	   iVal;             /* VT_I2                */
      long	   lVal;             /* VT_I4                */
      float	   fltVal;           /* VT_R4                */
      double	   dblVal;           /* VT_R8                */
      VARIANT_BOOL bool;             /* VT_BOOL              */
      SCODE	   scode;            /* VT_ERROR             */
      CY	   cyVal;            /* VT_CY                */
      DATE	   date;             /* VT_DATE              */
      BSTR	   bstrVal;          /* VT_BSTR              */
      IUnknown	   FAR* punkVal;     /* VT_UNKNOWN           */
      IDispatch	   FAR* pdispVal;    /* VT_DISPATCH          */
      SAFEARRAY	   FAR* parray;	     /* VT_ARRAY|*           */

      short	   FAR* piVal;       /* VT_BYREF|VT_I2	     */
      long	   FAR* plVal;       /* VT_BYREF|VT_I4	     */
      float	   FAR* pfltVal;     /* VT_BYREF|VT_R4       */
      double	   FAR* pdblVal;     /* VT_BYREF|VT_R8       */
      VARIANT_BOOL FAR* pbool;       /* VT_BYREF|VT_BOOL     */
      SCODE	   FAR* pscode;      /* VT_BYREF|VT_ERROR    */
      CY	   FAR* pcyVal;      /* VT_BYREF|VT_CY       */
      DATE	   FAR* pdate;       /* VT_BYREF|VT_DATE     */
      BSTR	   FAR* pbstrVal;    /* VT_BYREF|VT_BSTR     */
      IUnknown FAR* FAR* ppunkVal;   /* VT_BYREF|VT_UNKNOWN  */
      IDispatch FAR* FAR* ppdispVal; /* VT_BYREF|VT_DISPATCH */
      SAFEARRAY FAR* FAR* pparray;   /* VT_BYREF|VT_ARRAY|*  */
      VARIANT	   FAR* pvarVal;     /* VT_BYREF|VT_VARIANT  */

      void	   FAR* byref;	     /* Generic ByRef        */
    }
#ifdef NONAMELESSUNION
    u
#endif
     ;
};

#ifdef NONAMELESSUNION
# define V_UNION(X, Y) ((X)->u.Y)
#else
# define V_UNION(X, Y) ((X)->Y)
#endif

/* Variant access macros */
#define V_VT(X)          ((X)->vt)
#define V_ISBYREF(X)     (V_VT(X)&VT_BYREF)
#define V_ISARRAY(X)     (V_VT(X)&VT_ARRAY)
#define V_ISVECTOR(X)    (V_VT(X)&VT_VECTOR)

#define V_NONE(X)        V_I2(X)
#define V_I2(X)	         V_UNION(X, iVal)
#define V_I2REF(X)       V_UNION(X, piVal)
#define V_I4(X)          V_UNION(X, lVal)
#define V_I4REF(X)       V_UNION(X, plVal)
#define V_R4(X)	         V_UNION(X, fltVal)
#define V_R4REF(X)       V_UNION(X, pfltVal)
#define V_R8(X)	         V_UNION(X, dblVal)
#define V_R8REF(X)       V_UNION(X, pdblVal)
#define V_BOOL(X)        V_UNION(X, bool)
#define V_BOOLREF(X)     V_UNION(X, pbool)
#define V_ERROR(X)       V_UNION(X, scode)
#define V_ERRORREF(X)    V_UNION(X, pscode)
#define V_CY(X)	         V_UNION(X, cyVal)
#define V_CYREF(X)       V_UNION(X, pcyVal)
#define V_DATE(X)        V_UNION(X, date)
#define V_DATEREF(X)     V_UNION(X, pdate)
#define V_BSTR(X)        V_UNION(X, bstrVal)
#define V_BSTRREF(X)     V_UNION(X, pbstrVal)
#define V_UNKNOWN(X)     V_UNION(X, punkVal)
#define V_UNKNOWNREF(X)  V_UNION(X, ppunkVal)
#define V_DISPATCH(X)    V_UNION(X, pdispVal)
#define V_DISPATCHREF(X) V_UNION(X, ppdispVal)
#define V_VARIANTREF(X)  V_UNION(X, pvarVal)
#define V_ARRAY(X)       V_UNION(X, parray)
#define V_ARRAYREF(X)    V_UNION(X, pparray)
#define V_BYREF(X)       V_UNION(X, byref)

#endif /* _VARIANT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\version.h ===
/*
** #define OFFICIAL   1 
** #define FINAL      1 
*/

/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the         *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values            *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG 
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include "ver.h"
#endif 

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION                     "4.00.105"
#define VER_PRODUCTVERSION_STR      "4.00.105\0"
#define VER_PRODUCTVERSION          4,00,0,105
#define VER_PRODUCTVERSION_DW       (0x04000000 | 105)

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\ver.h ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved	      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL
#define VFT2_DRV_INPUTMETHOD    0x0000000BL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

#ifdef LIB

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

#endif /* LIB */

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\vmemory.h ===
/***
* vmemory.h - Virtual Memory (VM) Management Routines
*
*	Copyright (c) 1989-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file provides prototypes and definitions for
*	the virtual memory management routines.
*
*******************************************************************************/

#ifndef _INC_VMEMORY

#if (_MSC_VER <= 600)
#define __far       _far
#define __pascal    _pascal
#endif

/* virtual memory handle type */
typedef unsigned long _vmhnd_t;

/* null handle value */
#define _VM_NULL	((_vmhnd_t) 0)

/* use all available DOS memory for virtual heap */
#define _VM_ALLDOS	0

/* swap areas */
#define _VM_EMS 	1
#define _VM_XMS 	2
#define _VM_DISK	4
#define _VM_ALLSWAP	(_VM_EMS | _VM_XMS | _VM_DISK)

/* clean/dirty flags */
#define _VM_CLEAN	0
#define _VM_DIRTY	1

/* function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

void __far __pascal _vfree(_vmhnd_t);
int __far __pascal _vheapinit(unsigned int, unsigned int, unsigned int);
void __far __pascal _vheapterm(void);
void __far * __far __pascal _vload(_vmhnd_t, int);
void __far * __far __pascal _vlock(_vmhnd_t);
unsigned int __far __pascal _vlockcnt(_vmhnd_t);
_vmhnd_t __far __pascal _vmalloc(unsigned long);
unsigned long __far __pascal _vmsize(_vmhnd_t);
_vmhnd_t __far __pascal _vrealloc(_vmhnd_t , unsigned long);
void __far __pascal _vunlock(_vmhnd_t, int);

#ifdef __cplusplus
}
#endif

#define _INC_VMEMORY
#endif /* _INC_VMEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\w32sys.h ===
/*************************************************************************\
* w32sys.h
*
* Win32S i/f
*
* Copyright (c) 1991-1994, Microsoft Corp.	All rights reserved.
\*************************************************************************/

#ifndef APIENTRY
#define APIENTRY _far _pascal _loadds
#endif

HANDLE APIENTRY GetPEResourceTable(WORD hFile);
HANDLE APIENTRY LoadPEResource(HANDLE hFile, LPSTR lpResTable, LPSTR lpId, LPSTR lpType);
WORD   APIENTRY GetW32SysVersion(VOID);
BOOL   APIENTRY GetPEExeInfo(LPSTR lpFileName, LPSTR lpBuff, WORD cbBuff, WORD iInfo);
WORD   APIENTRY ExecPE(LPSTR  lpPath, LPSTR lpCmd, WORD nCmdShow);
BOOL   APIENTRY IsPEFormat(LPSTR lpFileName, WORD hFile);

/*
 * Constants for GetPEExeInfo iInfo parameter
 */
#define GPEI_MODNAME     1
#define GPEI_DESCRIPTION 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\vfw.h ===
/****************************************************************************
 *
 *      VfW.H - Video for windows include file version 1.1
 *
 *      Copyright (c) 1991-1994, Microsoft Corp.  All rights reserved.
 *
 *      This include files defines interfaces to the following
 *      components of VfW 1.0 OR VFW 1.1
 *
 *          COMPMAN         - Installable Compression Manager.
 *          DRAWDIB         - Routines for drawing to the display.
 *          VIDEO           - Video Capture Driver Interface
 *
 *          AVIFMT          - AVI File Format structure definitions.
 *          MMREG           - FOURCC and other things
 *
 *          AVIFile         - Interface for reading AVI Files and AVI Streams
 *          MCIWND          - MCI/AVI window class
 *          AVICAP          - AVI Capture Window class
 *
 *          MSACM           - Audio compression manager.
 *
 *      The following symbols control inclusion of various parts of this file:
 *
 *          NOCOMPMAN       - dont include COMPMAN
 *          NODRAWDIB       - dont include DRAWDIB
 *          NOVIDEO         - dont include video capture interface
 *
 *          NOAVIFMT        - dont include AVI file format structs
 *          NOMMREG         - dont include MMREG
 *
 *          NOAVIFILE       - dont include AVIFile interface
 *          NOMCIWND        - dont include AVIWnd class.
 *          NOAVICAP        - dont include AVICap class.
 *
 *          NOMSACM         - dont include ACM stuff.
 *
 ****************************************************************************/

#ifndef _INC_VFW
#define _INC_VFW

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****************************************************************************
 *
 *  types
 *
 ***************************************************************************/

#ifdef WIN32
#define VFWAPI  WINAPI
#define VFWAPIV WINAPIV
#else
#ifndef VFWAPI
#define VFWAPI  FAR PASCAL
#define VFWAPIV FAR CDECL
#endif
#endif

/****************************************************************************
 *
 *  VideoForWindowsVersion() - returns version of VfW
 *
 ***************************************************************************/

DWORD FAR PASCAL VideoForWindowsVersion(void);

/****************************************************************************
 *
 *  call these to start stop using VfW from your app.
 *
 ***************************************************************************/

LONG VFWAPI InitVFW(void);
LONG VFWAPI TermVFW(void);

/****************************************************************************
 *
 *  do we need MMSYSTEM?
 *
 ****************************************************************************/

#if !defined(_INC_MMSYSTEM) && (!defined(NOVIDEO) || !defined(NOAVICAP))
    #include <mmsystem.h>
#endif

/****************************************************************************/
/*                                                                          */
/*        Macros                                                            */
/*                                                                          */
/*  should we define this??                                                 */
/*                                                                          */
/****************************************************************************/

#ifndef MKFOURCC
#define MKFOURCC( ch0, ch1, ch2, ch3 )                                    \
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#if !defined(_INC_MMSYSTEM)
    #define mmioFOURCC MKFOURCC
#endif

/**************************************************************************
 *
 *  DRAWDIB - Routines for drawing to the display.
 *
 *************************************************************************/

#ifndef NODRAWDIB
    #include <drawdib.h>
#endif  /* NODRAWDIB */

/****************************************************************************
 *
 *  AVIFMT - AVI file format definitions
 *
 ****************************************************************************/

#ifndef NOAVIFMT
    #ifndef _INC_MMSYSTEM
        typedef DWORD FOURCC;
    #endif
    #include <avifmt.h>
#endif /* NOAVIFMT */

/****************************************************************************
 *
 *  MMREG.H (standard include file for MM defines, like FOURCC and things)
 *
 ***************************************************************************/

#ifndef NOMMREG
    #include <mmreg.h>
#endif

/****************************************************************************
 *
 *  AVIFile - routines for reading/writing standard AVI files
 *
 ***************************************************************************/

#ifndef NOAVIFILE
    #include <avifile.h>
#endif  /* NOAVIFILE */

/****************************************************************************
 *
 *  COMPMAN - Installable Compression Manager.
 *
 ****************************************************************************/

#ifndef NOCOMPMAN
    #include <compman.h>
#endif  /* NOCOMPMAN */

/****************************************************************************
 *
 *  MCIWnd - Window class for MCI objects
 *
 ***************************************************************************/

#ifndef NOMCIWND
    #include <mciwnd.h>
#endif  /* NOAVIFILE */

/****************************************************************************
 *
 *  VIDEO - Video Capture Driver Interface
 *
 ****************************************************************************/

#if !defined(NOAVICAP) || !defined(NOVIDEO)
    #include <msvideo.h>
#endif  /* NOVIDEO */

/****************************************************************************
 *
 *  AVICAP - Window class for AVI capture
 *
 ***************************************************************************/

#ifndef NOAVICAP
    #include <avicap.h>
#endif  /* NOAVIFILE */

/****************************************************************************
 *
 *  ACM (Audio compression manager)
 *
 ***************************************************************************/

#ifndef NOMSACM
    #include <msacm.h>
#endif

/****************************************************************************
 *
 *  File Preview dialog (if commdlg.h was included already)
 *
 ***************************************************************************/

#ifdef OFN_READONLY
    BOOL VFWAPI GetOpenFileNamePreview(LPOPENFILENAME lpofn);
    BOOL VFWAPI GetSaveFileNamePreview(LPOPENFILENAME lpofn);
#endif

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_VFW */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\wfext.h ===
/*****************************************************************************\
*                                                                             *
* wfext.h -     Windows File Manager Extensions definitions		      *
*                                                                             *
* Version 3.10								      *
*                                                                             *
* Copyright (c) 1991-1994, Microsoft Corp. All rights reserved. 	      *
*                                                                             *
*******************************************************************************/

#ifndef _INC_WFEXT
#define _INC_WFEXT    /* #defined if wfext.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define MENU_TEXT_LEN		40

#define FMMENU_FIRST		1
#define FMMENU_LAST		99

#define FMEVENT_LOAD		100
#define FMEVENT_UNLOAD		101
#define FMEVENT_INITMENU	102
#define FMEVENT_USER_REFRESH	103
#define FMEVENT_SELCHANGE	104
#define FMEVENT_TOOLBARLOAD	105
#define FMEVENT_HELPSTRING	106

#define FMFOCUS_DIR		1
#define FMFOCUS_TREE		2
#define FMFOCUS_DRIVES		3
#define FMFOCUS_SEARCH		4

#define FM_GETFOCUS		(WM_USER + 0x0200)
#define FM_GETDRIVEINFO		(WM_USER + 0x0201)
#define FM_GETSELCOUNT		(WM_USER + 0x0202)
#define FM_GETSELCOUNTLFN	(WM_USER + 0x0203)	/* LFN versions are odd */
#define FM_GETFILESEL		(WM_USER + 0x0204)
#define FM_GETFILESELLFN	(WM_USER + 0x0205)	/* LFN versions are odd */
#define FM_REFRESH_WINDOWS	(WM_USER + 0x0206)
#define FM_RELOAD_EXTENSIONS	(WM_USER + 0x0207)

typedef struct tagFMS_GETFILESEL
{
        UINT wTime;
        UINT wDate;
	DWORD dwSize;
	BYTE bAttr;
        char szName[260];               /* always fully qualified */
} FMS_GETFILESEL, FAR *LPFMS_GETFILESEL;

typedef struct tagFMS_GETDRIVEINFO       /* for drive */
{
	DWORD dwTotalSpace;
	DWORD dwFreeSpace;
	char szPath[260];		/* current directory */
	char szVolume[14];		/* volume label */
	char szShare[128];		/* if this is a net drive */
} FMS_GETDRIVEINFO, FAR *LPFMS_GETDRIVEINFO;

typedef struct tagFMS_LOAD
{
	DWORD dwSize;				/* for version checks */
	char  szMenuName[MENU_TEXT_LEN];	/* output */
	HMENU hMenu;				/* output */
        UINT  wMenuDelta;                       /* input */
} FMS_LOAD, FAR *LPFMS_LOAD;

typedef struct tagEXT_BUTTON
{
	WORD idCommand;			/* menu command to trigger */
	WORD idsHelp;			/* help string ID */
	WORD fsStyle;			/* button style */
} EXT_BUTTON, FAR *LPEXT_BUTTON;

#define FMTB_BUTTON	0x00
#define FMTB_SEP	0x01

typedef struct tagFMS_TOOLBARLOAD
{
	DWORD dwSize;			/* for version checks */
	LPEXT_BUTTON lpButtons;		/* output */
	WORD cButtons;			/* output, 0==>no buttons */
	WORD cBitmaps;			/* number of non-sep buttons */
	WORD idBitmap;			/* output */
	HBITMAP hBitmap;		/* output if idBitmap==0 */
} FMS_TOOLBARLOAD, FAR *LPFMS_TOOLBARLOAD;

typedef struct tagFMS_HELPSTRING
{
	int idCommand;			/* input, -1==>the menu was selected */
	HMENU hMenu;			/* input, the extensions menu */
	char szHelp[128];		/* output, the help string */
} FMS_HELPSTRING, FAR *LPFMS_HELPSTRING;

typedef DWORD (CALLBACK *FM_EXT_PROC)(HWND, UINT, LONG);
typedef DWORD (CALLBACK *FM_UNDELETE_PROC)(HWND, LPSTR);

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_WFEXT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\winboot.inc ===
db	0EBH,03CH,090H,04DH,053H,057H,049H,04EH
	db	034H,02EH,030H,000H,002H,008H,001H,000H
	db	002H,000H,002H,003H,051H,0F8H,008H,000H
	db	011H,000H,004H,000H,001H,000H,000H,000H
	db	000H,000H,000H,000H,080H,000H,029H,000H
	db	000H,000H,000H,04EH,04FH,020H,04EH,041H
	db	04DH,045H,020H,020H,020H,020H,046H,041H
	db	054H,031H,032H,020H,020H,020H,0FAH,033H
	db	0C9H,08EH,0D1H,0BCH,0FCH,07BH,016H,007H
	db	0BDH,078H,000H,0C5H,076H,000H,01EH,056H
	db	016H,055H,0BFH,022H,005H,089H,07EH,000H
	db	089H,04EH,002H,0B1H,00BH,0FCH,0F3H,0A4H
	db	006H,01FH,0BDH,000H,07CH,0C6H,045H,0FEH
	db	00FH,08BH,046H,018H,088H,045H,0F9H,0FBH
	db	0CDH,013H,072H,06FH,08AH,046H,010H,098H
	db	0F7H,066H,016H,003H,046H,01CH,013H,056H
	db	01EH,003H,046H,00EH,013H,0D1H,050H,052H
	db	089H,046H,0FCH,089H,056H,0FEH,0B8H,020H
	db	000H,08BH,076H,011H,0F7H,0E6H,08BH,05EH
	db	00BH,003H,0C3H,048H,0F7H,0F3H,001H,046H
	db	0FCH,011H,04EH,0FEH,05AH,058H,0BBH,000H
	db	007H,08BH,0FBH,0B1H,001H,0E8H,083H,000H
	db	072H,031H,0B1H,00BH,056H,0BEH,0F1H,07DH
	db	0F3H,0A6H,05EH,074H,038H,04EH,074H,00BH
	db	003H,0F9H,083H,0C7H,015H,03BH,0FBH,072H
	db	0E9H,0EBH,0DBH,0BEH,068H,07DH,0ACH,00AH
	db	0C0H,078H,00BH,074H,013H,0B4H,00EH,0BBH
	db	007H,000H,0CDH,010H,0EBH,0F0H,0BEH,0A4H
	db	07DH,0EBH,0EBH,0BEH,07AH,07DH,0EBH,0E6H
	db	033H,0C0H,0CDH,016H,05EH,01FH,08FH,004H
	db	08FH,044H,002H,0CDH,019H,08BH,07DH,00FH
	db	08BH,0C7H,048H,048H,08AH,04EH,00DH,0F7H
	db	0E1H,003H,046H,0FCH,013H,056H,0FEH,0BBH
	db	000H,007H,053H,0B1H,003H,0E8H,023H,000H
	db	05BH,072H,0D0H,0BEH,08EH,07DH,081H,03FH
	db	04DH,05AH,075H,0B2H,081H,0BFH,000H,002H
	db	042H,04AH,075H,0AAH,08BH,046H,0FCH,08BH
	db	056H,0FEH,05EH,01FH,05EH,01FH,0EAH,000H
	db	002H,070H,000H,03BH,056H,018H,0F5H,072H
	db	02EH,050H,052H,051H,0F7H,076H,018H,08AH
	db	0CAH,041H,033H,0D2H,0F7H,076H,01AH,08AH
	db	0F2H,08AH,056H,024H,08AH,0E8H,0D0H,0CCH
	db	0D0H,0CCH,00AH,0CCH,0B8H,001H,002H,0CDH
	db	013H,059H,05AH,058H,072H,009H,040H,075H
	db	001H,042H,003H,05EH,00BH,0E2H,0CCH,0C3H
	db	00DH,00AH,04EH,06FH,06EH,02DH,053H,079H
	db	073H,074H,065H,06DH,020H,064H,069H,073H
	db	06BH,080H,00DH,00AH,053H,079H,073H,074H
	db	065H,06DH,020H,064H,069H,073H,06BH,020H
	db	065H,072H,072H,06FH,072H,080H,00DH,00AH
	db	049H,06EH,076H,061H,06CH,069H,064H,020H
	db	073H,079H,073H,074H,065H,06DH,020H,066H
	db	069H,06CH,065H,080H,00DH,00AH,052H,065H
	db	070H,06CH,061H,063H,065H,020H,061H,06EH
	db	064H,020H,070H,072H,065H,073H,073H,020H
	db	061H,06EH,079H,020H,06BH,065H,079H,020H
	db	077H,068H,065H,06EH,020H,072H,065H,061H
	db	064H,079H,00DH,00AH,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,057H,049H,04EH,042H,04FH,04FH,054H
	db	020H,053H,059H,053H,000H,000H,055H,0AAH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\windows.inc ===
;*************************************************************************
;
;       WINDOWS.INC - Windows assembly language structures & constants
;
; Copyright (c) 1985-1994, Microsoft Corp.	All rights reserved.
;*************************************************************************
;
; Conditional Block includes:   (True states)
;     NOTEXT - don't include TextMetric struc & text drawing modes & stock objs.
;     NORASTOPS - don't include binary and ternary raster ops.
;     NOVK      - don't include virtual key definitions
;     NOMB      - don't include message box definitions
;     NOWM      - don't include window messages
;
;
FALSE   =       0
TRUE    =       1
NULL    =       0

;*******************************************************************
;
;       Rectangle
;
;*******************************************************************

RECT    struc
        rcLeft          dw      ?
        rcTop           dw      ?
        rcRight         dw      ?
        rcBottom        dw      ?
RECT    ends

;*******************************************************************
;
;  Window Class structure
;
;*******************************************************************

WNDCLASS struc
        clsStyle        dw      ?       ; class style
        clsLpfnWndProc  dd      ?
        clsCbClsExtra   dw      ?
        clsCbWndExtra   dw      ?
        clsHInstance    dw      ?       ; instance handle
        clsHIcon        dw      ?       ; class icon handle
        clsHCursor      dw      ?       ; class cursor handle
        clsHbrBackground dw     ?       ; class background brush
        clsLpszMenuName dd      ?       ; menu name
        clsLpszClassName dd     ?       ; far ptr to class name
WNDCLASS ends

IFNDEF NOTEXT
TEXTMETRIC struc
    tmHeight	    dw	    ?
    tmAscent	    dw	    ?
    tmDescent	    dw	    ?
    tmIntLeading    dw	    ?
    tmExtLeading    dw	    ?
    tmAveCharWidth  dw	    ?
    tmMaxCharWidth  dw	    ?
    tmWeight	    dw	    ?
    tmItalic	    db	    ?
    tmUnderlined    db	    ?
    tmStruckOut     db	    ?
    tmFirstChar     db	    ?
    tmLastChar	    db	    ?
    tmDefaultChar   db	    ?
    tmBreakChar     db	    ?
    tmPitch	    db	    ?
    tmCharSet	    db	    ?
    tmOverhang	    dw	    ?
    tmAspectX	    dw	    ?
    tmAspectY	    dw	    ?
TEXTMETRIC ends

LF_FACESIZE	EQU	32

LOGFONT struc
    lfHeight	      dw   ?
    lfWidth	      dw   ?
    lfEscapement      dw   ?
    lfOrientation     dw   ?
    lfWeight	      dw   ?
    lfItalic	      db   ?
    lfUnderline       db   ?
    lfStrikeOut       db   ?
    lfCharSet	      db   ?
    lfOutPrecision    db   ?
    lfClipPrecision   db   ?
    lfQuality	      db   ?
    lfPitchAndFamily  db   ?
    lfFaceName	      db   LF_FACESIZE dup(?)
LOGFONT ends

LOGBRUSH struc
    lbStyle         dw ?
    lbColor         dd ?
    lbHatch         dw ?
LOGBRUSH ends

;
;  Text Drawing modes
;
TRANSPARENT     = 1
OPAQUE          = 2
;
; Mapping Modes
;
MM_TEXT         =   1
MM_LOMETRIC     =   2
MM_HIMETRIC     =   3
MM_LOENGLISH    =   4
MM_HIENGLISH    =   5
MM_TWIPS        =   6
MM_ISOTROPIC    =   7
MM_ANISOTROPIC  =   8
;
; Coordinate Modes
;
ABSOLUTE        =   1
RELATIVE        =   2
;
;  Stock Logical Objects
;
WHITE_BRUSH         =  0
LTGRAY_BRUSH        =  1
GRAY_BRUSH          =  2
DKGRAY_BRUSH        =  3
BLACK_BRUSH         =  4
NULL_BRUSH          =  5
HOLLOW_BRUSH        =  5
WHITE_PEN           =  6
BLACK_PEN           =  7
NULL_PEN            =  8
DOT_MARKER          =  9
OEM_FIXED_FONT      = 10
ANSI_FIXED_FONT     = 11
ANSI_VAR_FONT       = 12
SYSTEM_FONT         = 13
DEVICE_DEFAULT_FONT = 14
DEFAULT_PALETTE     = 15
SYSTEM_FIXED_FONT   = 16
ENDIF
;
; Brush Styles
;
BS_SOLID        =   0
BS_NULL         =   1
BS_HOLLOW       =   BS_NULL
BS_HATCHED      =   2
BS_PATTERN      =   3
BS_INDEXED      =   4
BS_DIBPATTERN	=   5
;
; Hatch Styles
;
HS_HORIZONTAL   =   0       ; -----
HS_VERTICAL     =   1       ; |||||
HS_FDIAGONAL    =   2       ; \\\\\
HS_BDIAGONAL    =   3       ; /////
HS_CROSS        =   4       ; +++++
HS_DIAGCROSS    =   5       ; xxxxx
;
; Pen Styles
;
PS_SOLID        =   0
PS_DASH         =   1       ; -------
PS_DOT          =   2       ; .......
PS_DASHDOT      =   3       ; _._._._
PS_DASHDOTDOT   =   4       ; _.._.._
PS_NULL         =   5
PS_INSIDEFRAME  =   6
;
; Device Parameters for GetDeviceCaps()
;
DRIVERVERSION =0     ; Device driver version
TECHNOLOGY    =2     ; Device classification
HORZSIZE      =4     ; Horizontal size in millimeters
VERTSIZE      =6     ; Vertical size in millimeters
HORZRES       =8     ; Horizontal width in pixels
VERTRES       =10    ; Vertical width in pixels
BITSPIXEL     =12    ; Number of bits per pixel
PLANES        =14    ; Number of planes
NUMBRUSHES    =16    ; Number of brushes the device has
NUMPENS       =18    ; Number of pens the device has
NUMMARKERS    =20    ; Number of markers the device has
NUMFONTS      =22    ; Number of fonts the device has
NUMCOLORS     =24    ; Number of colors the device supports
PDEVICESIZE   =26    ; Size required for device descriptor
CURVECAPS     =28    ; Curve capabilities
LINECAPS      =30    ; Line capabilities
POLYGONALCAPS =32    ; Polygonal capabilities
TEXTCAPS      =34    ; Text capabilities
CLIPCAPS      =36    ; Clipping capabilities
RASTERCAPS    =38    ; Bitblt capabilities
ASPECTX       =40    ; Length of the X leg
ASPECTY       =42    ; Length of the Y leg
ASPECTXY      =44    ; Length of the hypotenuse

LOGPIXELSX    =88    ; Logical pixels/inch in X
LOGPIXELSY    =90    ; Logical pixels/inch in Y

SIZEPALETTE   =104   ; Number of entries in physical palette
NUMRESERVED   =106   ; Number of reserved entries in palette
COLORRES      =108   ; Actual color resolution
;
ifndef NOGDICAPMASKS
;
; Device Capability Masks:
;
; Device Technologies
DT_PLOTTER       =   0  ; /* Vector plotter                   */
DT_RASDISPLAY    =   1  ; /* Raster display                   */
DT_RASPRINTER    =   2  ; /* Raster printer                   */
DT_RASCAMERA     =   3  ; /* Raster camera                    */
DT_CHARSTREAM    =   4  ; /* Character-stream, PLP            */
DT_METAFILE      =   5  ; /* Metafile, VDM                    */
DT_DISPFILE      =   6  ; /* Display-file                     */
;
; Curve Capabilities
CC_NONE          =   0  ; /* Curves not supported             */
CC_CIRCLES       =   1  ; /* Can do circles                   */
CC_PIE           =   2  ; /* Can do pie wedges                */
CC_CHORD         =   4  ; /* Can do chord arcs                */
CC_ELLIPSES      =   8  ; /* Can do ellipese                  */
CC_WIDE          =   16 ; /* Can do wide lines                */
CC_STYLED        =   32 ; /* Can do styled lines              */
CC_WIDESTYLED    =   64 ; /* Can do wide styled lines         */
CC_INTERIORS     =   128; /* Can do interiors                 */
;
; Line Capabilities
LC_NONE          =   0  ; /* Lines not supported              */
LC_POLYLINE      =   2  ; /* Can do polylines                 */
LC_MARKER        =   4  ; /* Can do markers                   */
LC_POLYMARKER    =   8  ; /* Can do polymarkers               */
LC_WIDE          =   16 ; /* Can do wide lines                */
LC_STYLED        =   32 ; /* Can do styled lines              */
LC_WIDESTYLED    =   64 ; /* Can do wide styled lines         */
LC_INTERIORS     =   128; /* Can do interiors                 */
;
; Polygonal Capabilities
PC_NONE          =   0  ; /* Polygonals not supported         */
PC_POLYGON       =   1  ; /* Can do polygons                  */
PC_RECTANGLE     =   2  ; /* Can do rectangles                */
PC_WINDPOLYGON   =   4  ; /* Can do winding polygons          */
PC_TRAPEZOID     =   4  ; /* Can do trapezoids                */
PC_SCANLINE      =   8  ; /* Can do scanlines                 */
PC_WIDE          =   16 ; /* Can do wide borders              */
PC_STYLED        =   32 ; /* Can do styled borders            */
PC_WIDESTYLED    =   64 ; /* Can do wide styled borders       */
PC_INTERIORS     =   128; /* Can do interiors                 */
PC_POLYPOLYGON   =   256; /* Can do PolyPolygons              */

;
; Polygonal Capabilities */
CP_NONE          =   0  ; /* No clipping of output            */
CP_RECTANGLE     =   1  ; /* Output clipped to rects          */
;
; Text Capabilities
TC_OP_CHARACTER  =   0001h ; /* Can do OutputPrecision   CHARACTER      */
TC_OP_STROKE     =   0002h ; /* Can do OutputPrecision   STROKE         */
TC_CP_STROKE     =   0004h ; /* Can do ClipPrecision     STROKE         */
TC_CR_90         =   0008h ; /* Can do CharRotAbility    90             */
TC_CR_ANY        =   0010h ; /* Can do CharRotAbility    ANY            */
TC_SF_X_YINDEP   =   0020h ; /* Can do ScaleFreedom      X_YINDEPENDENT */
TC_SA_DOUBLE     =   0040h ; /* Can do ScaleAbility      DOUBLE         */
TC_SA_INTEGER    =   0080h ; /* Can do ScaleAbility      INTEGER        */
TC_SA_CONTIN     =   0100h ; /* Can do ScaleAbility      CONTINUOUS     */
TC_EA_DOUBLE     =   0200h ; /* Can do EmboldenAbility   DOUBLE         */
TC_IA_ABLE       =   0400h ; /* Can do ItalisizeAbility  ABLE           */
TC_UA_ABLE       =   0800h ; /* Can do UnderlineAbility  ABLE           */
TC_SO_ABLE       =   1000h ; /* Can do StrikeOutAbility  ABLE           */
TC_RA_ABLE       =   2000h ; /* Can do RasterFontAble    ABLE           */
TC_VA_ABLE       =   4000h ; /* Can do VectorFontAble    ABLE           */
TC_RESERVED      =   8000h
;
; Raster Capabilities
RC_BITBLT        =   1      ; /* Can do standard BLT.             */
RC_BANDING       =   2      ; /* Device requires banding support  */
RC_SCALING       =   4      ; /* Device requires scaling support  */
RC_BITMAP64      =   8      ; /* Device can support >64K bitmap   */
RC_GDI20_OUTPUT  =   0010h  ; /* has 2.0 output calls         */
RC_DI_BITMAP     =   0080h  ; /* supports DIB to memory       */
RC_PALETTE       =   0100h  ; /* supports a palette           */
RC_DIBTODEV      =   0200h  ; /* supports DIBitsToDevice      */
RC_BIGFONT       =   0400h  ; /* supports >64K fonts          */
RC_STRETCHBLT    =   0800h  ; /* supports StretchBlt          */
RC_FLOODFILL     =   1000h  ; /* supports FloodFill           */
RC_STRETCHDIB    =   2000h  ; /* supports StretchDIBits       */

endif       ;NOGDICAPMASKS

; palette entry flags
;
PC_RESERVED     = 1    ;/* palette index used for animation */
PC_EXPLICIT     = 2    ;/* palette index is explicit to device */
PC_NOCOLLAPSE	= 4    ;/* do not match color to system palette */

; DIB color table identifiers
;
DIB_RGB_COLORS  = 0    ;/* color table in RGBTriples */
DIB_PAL_COLORS  = 1    ;/* color table in palette indices */
;

;constants for Get/SetSystemPaletteUse()
;
SYSPAL_STATIC	= 1
SYSPAL_NOSTATIC	= 2

; constants for CreateDIBitmap
CBM_INIT        = 4    ;/* initialize bitmap */
;
; Bitmap format constants
BI_RGB          = 0
BI_RLE8         = 1
BI_RLE4         = 2
;
;
ANSI_CHARSET	    = 0
SYMBOL_CHARSET	    = 2
SHIFTJIS_CHARSET    = 128   ;/* Japan  */
HANGEUL_CHARSET     = 129   ;/* Korea  */
GB2312_CHARSET	    = 134   ;/* China  */
CHINESEBIG5_CHARSET = 136   ;/* Taiwan */
OEM_CHARSET	    = 255
;
;  styles for CombineRgn
;
RGN_AND  = 1
RGN_OR   = 2
RGN_XOR  = 3
RGN_DIFF = 4
RGN_COPY = 5
;
;  Predefined cursor & icon IDs
;
IDC_ARROW       = 32512
IDC_IBEAM       = 32513
IDC_WAIT        = 32514
IDC_CROSS       = 32515
IDC_UPARROW     = 32516
IDC_SIZE        = 32640
IDC_ICON        = 32641
IDC_SIZENWSE    = 32642
IDC_SIZENESW    = 32643
IDC_SIZEWE      = 32644
IDC_SIZENS      = 32645
IDC_APPSTARTING = 32650

IDI_APPLICATION = 32512
IDI_HAND        = 32513
IDI_QUESTION    = 32514
IDI_EXCLAMATION = 32515
IDI_ASTERISK    = 32516

;
; OEM Resource Ordinal Numbers */
;
OBM_CLOSE         =  32754
OBM_UPARROW       =  32753
OBM_DNARROW       =  32752
OBM_RGARROW       =  32751
OBM_LFARROW       =  32750
OBM_REDUCE        =  32749
OBM_ZOOM          =  32748
OBM_RESTORE       =  32747
OBM_REDUCED       =  32746
OBM_ZOOMD         =  32745
OBM_RESTORED      =  32744
OBM_UPARROWD      =  32743
OBM_DNARROWD      =  32742
OBM_RGARROWD      =  32741
OBM_LFARROWD      =  32740
OBM_MNARROW       =  32739
OBM_COMBO         =  32738
OBM_UPARROWI	  =  32737
OBM_DNARROWI	  =  32736
OBM_RGARROWI	  =  32735
OBM_LFARROWI	  =  32734

OBM_OLD_CLOSE     =  32767
OBM_SIZE          =  32766
OBM_OLD_UPARROW   =  32765
OBM_OLD_DNARROW   =  32764
OBM_OLD_RGARROW   =  32763
OBM_OLD_LFARROW   =  32762
OBM_BTSIZE        =  32761
OBM_CHECK         =  32760
OBM_CHECKBOXES    =  32759
OBM_BTNCORNERS    =  32758
OBM_OLD_REDUCE    =  32757
OBM_OLD_ZOOM      =  32756
OBM_OLD_RESTORE   =  32755

OCR_NORMAL        =  32512
OCR_IBEAM         =  32513
OCR_WAIT          =  32514
OCR_CROSS         =  32515
OCR_UP            =  32516
OCR_SIZE          =  32640
OCR_ICON          =  32641
OCR_SIZENWSE      =  32642
OCR_SIZENESW      =  32643
OCR_SIZEWE        =  32644
OCR_SIZENS        =  32645
OCR_SIZEALL       =  32646
OCR_ICOCUR        =  32647

OIC_SAMPLE        =  32512
OIC_HAND          =  32513
OIC_QUES          =  32514
OIC_BANG          =  32515
OIC_NOTE          =  32516

;
;   Scroll bar constants
;
SB_HORZ = 0
SB_VERT = 1
SB_CTL  = 2
SB_BOTH = 3
;
;   Scroll Commands
;
SB_LINEUP        = 0
SB_LINEDOWN      = 1
SB_PAGEUP        = 2
SB_PAGEDOWN      = 3
SB_THUMBPOSITION = 4
SB_THUMBTRACK    = 5
SB_TOP           = 6
SB_BOTTOM        = 7
SB_ENDSCROLL     = 8
;
;  MessageBox type flags
;
IFNDEF                  NOMB
MB_OK                   = 0000H
MB_OKCANCEL             = 0001H
MB_ABORTRETRYIGNORE     = 0002H
MB_YESNOCANCEL          = 0003H
MB_YESNO                = 0004H
MB_RETRYCANCEL          = 0005H

MB_ICONHAND             = 0010H
MB_ICONQUESTION         = 0020H
MB_ICONEXCLAMATION      = 0030H
MB_ICONASTERISK         = 0040H

MB_DEFBUTTON1           = 0000H
MB_DEFBUTTON2           = 0100H
MB_DEFBUTTON3           = 0200H

MB_APPLMODAL            = 0000H
MB_SYSTEMMODAL          = 1000H
MB_TASKMODAL            = 2000H

MB_NOFOCUS              = 8000H

;
;  Conventional dialog box and message box command IDs
;
IDOK     =   1
IDCANCEL =   2
IDABORT  =   3
IDRETRY  =   4
IDIGNORE =   5
IDYES    =   6
IDNO     =   7
;
;  Flags for OpenFile
;
OF_READ 	    = 0000H
OF_WRITE	    = 0001H
OF_READWRITE	    = 0002H
OF_SHARE_COMPAT	    = 0000H
OF_SHARE_EXCLUSIVE  = 0010H
OF_SHARE_DENY_WRITE = 0020H
OF_SHARE_DENY_READ  = 0030H
OF_SHARE_DENY_NONE  = 0040H
OF_PARSE	    = 0100H
OF_DELETE	    = 0200H
OF_VERIFY	    = 0400H     ; Used with OF_REOPEN
OF_SEARCH	    = 0400H     ; Used without OF_REOPEN
OF_CANCEL           = 0800H
OF_CREATE           = 1000H
OF_PROMPT           = 2000H
OF_EXIST            = 4000H
OF_REOPEN           = 8000H

TF_FORCEDRIVE   = 80H

OPENSTRUC       STRUC
opLen   db      ?
opDisk  db      ?
opXtra  dw      ?
opDate  dw      ?
opTime  dw      ?
opFile  db      120 dup (?)
OPENSTRUC       ENDS
;
;  DrawText format flags
;
DT_LEFT         = 00H
DT_CENTER       = 01H
DT_RIGHT        = 02H
DT_TOP          = 00H
DT_VCENTER      = 04H
DT_BOTTOM       = 08H
DT_WORDBREAK    = 10H
DT_SINGLELINE   = 20H
DT_EXPANDTABS   = 40H
DT_TABSTOP      = 80H
DT_NOCLIP       =    0100H
DT_EXTERNALLEADING = 0200H
DT_CALCRECT     =    0400H
DT_NOPREFIX     =    0800H
DT_INTERNAL     =    1000H
ENDIF

;
; ExtFloodFill style flags
;
FLOODFILLBORDER  =  0
FLOODFILLSURFACE =  1

;
; Memory manager flags
;
LMEM_FIXED      =   0000h
LMEM_MOVEABLE   =   0002h
LMEM_NOCOMPACT  =   0010H
LMEM_NODISCARD  =   0020H
LMEM_ZEROINIT   =   0040h
LMEM_MODIFY     =   0080H
LMEM_DISCARDABLE=   0F00h
LHND    =    LMEM_MOVEABLE+LMEM_ZEROINIT
LPTR    =    LMEM_FIXED+LMEM_ZEROINIT
; Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE)
LMEM_DISCARDED  =   4000H
LMEM_LOCKCOUNT  =   00FFH

NONZEROLHND     =    LMEM_MOVEABLE
NONZEROLPTR     =    LMEM_FIXED

GMEM_FIXED      =   0000h
GMEM_MOVEABLE   =   0002h
GMEM_NOCOMPACT  =   0010h
GMEM_NODISCARD  =   0020h
GMEM_ZEROINIT   =   0040h
GMEM_MODIFY     =   0080h
GMEM_DISCARDABLE=   0100h
GMEM_NOT_BANKED =   1000h
GMEM_DDESHARE   =   2000h
GMEM_SHARE	=   2000h
GMEM_NOTIFY     =   4000h
GMEM_LOWER      =   GMEM_NOT_BANKED
GHND            =   GMEM_MOVEABLE+GMEM_ZEROINIT
GPTR            =   GMEM_FIXED+GMEM_ZEROINIT

; Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE)
GMEM_DISCARDED  =    4000h
GMEM_LOCKCOUNT  =    00FFh

; Flags returned by GetWinFlags

WF_PMODE        =    0001h
WF_CPU286       =    0002h
WF_CPU386       =    0004h
WF_CPU486       =    0008h
WF_STANDARD	=    0010h
WF_WIN286	=    0010h
WF_ENHANCED	=    0020h
WF_WIN386	=    0020h
WF_CPU086	=    0040h
WF_CPU186	=    0080h
WF_CPUR4000     =    0100h
WF_RESERVED200  =    0200h
WF_80x87	=    0400h
WF_PAGING	=    0800h
WF_DOSPAGING    =    1000h
WF_WINNT        =    4000h
WF_WLO          =    8000h
WF_CPUMASK      =    0FC00h	; mask against hiword of GetWinFlags
WF_CPU_X86      =    0
WF_CPU_R4000    =    1
WF_CPU_ALPHA    =    2
WF_CPU_CLIPPER  =    3

; WEP fSystemExit flag values
WEP_SYSTEM_EXIT	=	1
WEP_FREE_DLL	=	0

;  Virtual Keys, Standard Set

IFNDEF          NOVK
VK_LBUTTON      = 01H
VK_RBUTTON      = 02H
VK_CANCEL       = 03H
VK_BACK         = 08H
VK_TAB          = 09H
VK_CLEAR        = 0cH
VK_RETURN       = 0dH
VK_SHIFT        = 10H
VK_CONTROL      = 11H
VK_MENU         = 12H
VK_PAUSE        = 13H
VK_CAPITAL      = 14H
VK_ESCAPE       = 1bH
VK_SPACE        = 20H

VK_PRIOR        = 21H
VK_NEXT         = 22H
VK_END          = 23H
VK_HOME         = 24H
VK_LEFT         = 25H
VK_UP           = 26H
VK_RIGHT        = 27H
VK_DOWN         = 28H

;  VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z'
;  VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0'

VK_PRINT        = 2aH
VK_EXECUTE      = 2bH
VK_SNAPSHOT	= 2ch	; Printscreen key..
VK_INSERT       = 2dH
VK_DELETE       = 2eH
VK_HELP         = 2fH

VK_NUMPAD0      = 60H
VK_NUMPAD1      = 61H
VK_NUMPAD2      = 62H
VK_NUMPAD3      = 63H
VK_NUMPAD4      = 64H
VK_NUMPAD5      = 65H
VK_NUMPAD6      = 66H
VK_NUMPAD7      = 67H
VK_NUMPAD8      = 68H
VK_NUMPAD9      = 69H
VK_MULTIPLY     = 6AH
VK_ADD          = 6BH
VK_SEPARATER    = 6CH
VK_SUBTRACT     = 6DH
VK_DECIMAL      = 6EH
VK_DIVIDE       = 6FH

VK_F1           = 70H
VK_F2           = 71H
VK_F3           = 72H
VK_F4           = 73H
VK_F5           = 74H
VK_F6           = 75H
VK_F7           = 76H
VK_F8           = 77H
VK_F9           = 78H
VK_F10          = 79H
VK_F11          = 7aH
VK_F12          = 7bH
VK_F13          = 7cH
VK_F14          = 7dH
VK_F15          = 7eH
VK_F16          = 7fH
VK_F17		= 80H
VK_F18		= 81H
VK_F19		= 82H
VK_F20		= 83H
VK_F21		= 84H
VK_F22		= 85H
VK_F23		= 86H
VK_F24		= 87H

VK_NUMLOCK      = 90H
VK_SCROLL       = 91H
ENDIF

IFNDEF NOWH

; SetWindowsHook() codes
WH_MSGFILTER       = (-1)
WH_JOURNALRECORD   = 0
WH_JOURNALPLAYBACK = 1
WH_KEYBOARD        = 2
WH_GETMESSAGE      = 3
WH_CALLWNDPROC     = 4
IFNDEF NOWIN31
WH_CBT             = 5
WH_SYSMSGFILTER    = 6
WH_MOUSE	   = 7
WH_HARDWARE	   = 8
WH_DEBUG	   = 9
ENDIF
;
; Hook Codes
HC_GETLPLPFN	   = (-3)
HC_LPLPFNNEXT      = (-2)
HC_LPFNNEXT        = (-1)
HC_ACTION          = 0
HC_GETNEXT         = 1
HC_SKIP            = 2
HC_NOREM           = 3
HC_NOREMOVE        = 3
HC_SYSMODALON      = 4
HC_SYSMODALOFF     = 5
;
; CBT Hook Codes
HCBT_MOVESIZE      = 0
HCBT_MINMAX        = 1
HCBT_QS            = 2
HCBT_CREATEWND	   = 3
HCBT_DESTROYWND	   = 4
HCBT_ACTIVATE	   = 5
HCBT_CLICKSKIPPED  = 6
HCBT_KEYSKIPPED    = 7
HCBT_SYSCOMMAND	   = 8
HCBT_SETFOCUS	   = 9

;
; WH_MSGFILTER Filter Proc Codes
MSGF_DIALOGBOX     = 0
MSGF_MENU          = 2
MSGF_MOVE          = 3
MSGF_SIZE          = 4
MSGF_SCROLLBAR     = 5
MSGF_NEXTWINDOW    = 6
;
; Window Manager Hook Codes
WC_INIT            = 1
WC_SWP             = 2
WC_DEFWINDOWPROC   = 3
WC_MINMAX          = 4
WC_MOVE            = 5
WC_SIZE            = 6
WC_DRAWCAPTION     = 7
;

; Message Structure used in Journaling
EVENTMSG    struc
    message     dw ?
    paramL      dw ?
    paramH      dw ?
    time        dd ?
EVENTMSG    ends

ENDIF ;NOWH

; Window field offsets for GetWindowLong() and GetWindowWord()
GWL_WNDPROC       =  (-4)
GWW_HINSTANCE     =  (-6)
GWW_HWNDPARENT    =  (-8)
GWW_ID            =  (-12)
GWL_STYLE         =  (-16)
GWL_EXSTYLE       =  (-20)

; GetWindow() Constants
GW_HWNDFIRST	  =  0
GW_HWNDLAST	  =  1
GW_HWNDNEXT	  =  2
GW_HWNDPREV	  =  3
GW_OWNER	  =  4
GW_CHILD	  =  5

; Class field offsets for GetClassLong() and GetClassWord()
GCL_MENUNAME      =  (-8)
GCW_HBRBACKGROUND =  (-10)
GCW_HCURSOR       =  (-12)
GCW_HICON         =  (-14)
GCW_HMODULE       =  (-16)
GCW_CBWNDEXTRA    =  (-18)
GCW_CBCLSEXTRA    =  (-20)
GCL_WNDPROC       =  (-24)
GCW_STYLE         =  (-26)

; WinWhere() Area Codes
HTERROR           =  (-2)
HTTRANSPARENT     =  (-1)
HTNOWHERE         =  0
HTCLIENT          =  1
HTCAPTION         =  2
HTSYSMENU         =  3
HTGROWBOX         =  4
HTSIZE            =  HTGROWBOX
HTMENU            =  5
HTHSCROLL         =  6
HTVSCROLL         =  7
HTREDUCE          =  8
HTZOOM            =  9
HTLEFT            =  10
HTRIGHT           =  11
HTTOP             =  12
HTTOPLEFT         =  13
HTTOPRIGHT        =  14
HTBOTTOM          =  15
HTBOTTOMLEFT      =  16
HTBOTTOMRIGHT     =  17
HTSIZEFIRST       =  HTLEFT
HTSIZELAST        =  HTBOTTOMRIGHT



;*************************************************************************
;
;       Misc structures & constants
;
;*************************************************************************

IFNDEF  NOMST
POINT   struc
        ptX             dw      ?
        ptY             dw      ?
POINT   ends

LOGPEN struc
    lopnStyle       dw ?
    lopnWidth       db (SIZE POINT) DUP(?)
    lopnColor       dd ?
LOGPEN ends


BITMAP STRUC
        bmType         DW ?
        bmWidth        DW ?
        bmHeight       DW ?
        bmWidthBytes   DW ?
        bmPlanes       DB ?
        bmBitsPixel    DB ?
        bmBits         DD ?
BITMAP ENDS

RGBTRIPLE	struc
	rgbBlue		db ?
	rgbGreen	db ?
	rgbRed		db ?
RGBTRIPLE	ends

RGBQUAD         struc
        rgbqBlue        db ?
        rgbqGreen       db ?
        rgbqRed         db ?
        rgbqReserved    db ?
RGBQUAD         ends

; structures for defining DIBs
BITMAPCOREHEADER struc
        bcSize      dd ?
        bcWidth     dw ?
        bcHeight    dw ?
        bcPlanes    dw ?
        bcBitCount  dw ?
BITMAPCOREHEADER ends

BITMAPINFOHEADER struc
        biSize           dd ?
        biWidth          dd ?
        biHeight         dd ?
        biPlanes         dw ?
        biBitCount       dw ?

        biCompression    dd ?
        biSizeImage      dd ?
        biXPelsPerMeter  dd ?
        biYPelsPerMeter  dd ?
        biClrUsed        dd ?
        biClrImportant   dd ?
BITMAPINFOHEADER ends

BITMAPINFO  struc
    bmiHeader   db (SIZE BITMAPINFOHEADER) DUP (?)
    bmiColors   db ?            ; array of RGBQUADs
BITMAPINFO  ends

BITMAPCOREINFO  struc
    bmciHeader  db (SIZE BITMAPCOREHEADER) DUP (?)
    bmciColors  db ?            ; array of RGBTRIPLEs
BITMAPCOREINFO  ends

BITMAPFILEHEADER struc
    bfType          dw ?
    bfSize          dd ?
    bfReserved1     dw ?
    bfReserved2     dw ?
    bfOffBits       dd ?
BITMAPFILEHEADER ends


WNDSTRUC struc
        WSwndStyle        dd      ?
        WSwndID           dw      ?
        WSwndText         dw      ?
        WSwndParent       dw      ?
        WSwndInstance     dw      ?
        WSwndClassProc    dd      ?
WNDSTRUC ends
;
;  Message structure
;
MSGSTRUCT       struc
msHWND          dw      ?
msMESSAGE       dw      ?
msWPARAM        dw      ?
msLPARAM        dd      ?
msTIME          dd      ?
msPT            dd      ?
MSGSTRUCT       ends

NEWPARMS struc
        nprmHwnd        dw      ?
        nprmCmd         db      ?
NEWPARMS ends
ENDIF

PAINTSTRUCT STRUC
    PShdc         DW ?
    PSfErase      DW ?
    PSrcPaint     DB size RECT dup(?)
    PSfRestore    DW ?
    PSfIncUpdate  DW ?
    PSrgbReserved DB 16 dup(?)
PAINTSTRUCT ENDS


CREATESTRUCT struc
    cs_lpCreateParams  dd ?
    cs_hInstance       dw ?
    cs_hMenu           dw ?
    cs_hwndParent      dw ?
    cs_cy              dw ?
    cs_cx              dw ?
    cs_y               dw ?
    cs_x               dw ?
    cs_style           dd ?
    cs_lpszName        dd ?
    cs_lpszClass       dd ?
    cs_dwExStyle       dd ?
CREATESTRUCT  ends
;
;       PostError constants
;
WARNING     = 0           ; command codes
MINOR_ERROR = 1
FATAL_ERROR = 2

IGNORE      = 0           ; response codes
RETRY       = 1
ABORT       = 2
;
; GDI-related constants & commands
;
ERRORREGION     = 0
NULLREGION      = 1
SIMPLEREGION    = 2
COMPLEXREGION   = 3

IFNDEF NORASTOPS
;
; Binary raster ops
;
R2_BLACK        =  1
R2_NOTMERGEPEN  =  2
R2_MASKNOTPEN   =  3
R2_NOTCOPYPEN   =  4
R2_MASKPENNOT   =  5
R2_NOT          =  6
R2_XORPEN       =  7
R2_NOTMASKPEN   =  8
R2_MASKPEN      =  9
R2_NOTXORPEN    = 10
R2_NOP          = 11
R2_MERGENOTPEN  = 12
R2_COPYPEN      = 13
R2_MERGEPENNOT  = 14
R2_MERGEPEN     = 15
R2_WHITE        = 16
;
; Ternary raster ops
;
SRCCOPY_L     = 0020h   ;dest=source
SRCCOPY_H     = 00CCh
SRCPAINT_L    = 0086h   ;dest=source OR dest
SRCPAINT_H    = 00EEh
SRCAND_L      = 00C6h   ;dest=source AND   dest
SRCAND_H      = 0088h
SRCINVERT_L   = 0046h   ;dest= source XOR      dest
SRCINVERT_H   = 0066h
SRCERASE_L    = 0328h   ;dest= source AND (not dest )
SRCERASE_H    = 0044h
NOTSRCCOPY_L  = 0008h   ;dest= (not source)
NOTSRCCOPY_H  = 0033h
NOTSRCERASE_L = 00A6h   ;dest= (not source) AND (not dest)
NOTSRCERASE_H = 0011h
MERGECOPY_L   = 00CAh   ;dest= (source AND pattern)
MERGECOPY_H   = 00C0h
MERGEPAINT_L  = 0226h   ;dest= (source AND pattern) OR dest
MERGEPAINT_H  = 00BBh
PATCOPY_L     = 0021h   ;dest= pattern
PATCOPY_H     = 00F0h
PATPAINT_L    = 0A09h   ;DPSnoo
PATPAINT_H    = 00FBh
PATINVERT_L   = 0049h   ;dest= pattern XOR     dest
PATINVERT_H   = 005Ah
DSTINVERT_L   = 0009h   ;dest= (not dest)
DSTINVERT_H   = 0055h
BLACKNESS_L   = 0042h   ;dest= BLACK
BLACKNESS_H   = 0000h
WHITENESS_L   = 0062h   ;dest= WHITE
WHITENESS_H   = 00FFh
;
; StretchBlt modes
;
BLACKONWHITE    = 1
WHITEONBLACK    = 2
COLORONCOLOR    = 3
;
; New StretchBlt modes
;
STRETCH_ANDSCANS    = 1
STRETCH_ORSCANS     = 2
STRETCH_DELETESCANS = 3
;
; PolyFill modes
;
ALTERNATE       = 1
WINDING         = 2
ENDIF
;
; Text Alignment Options
;
TA_NOUPDATECP   =  0
TA_UPDATECP     =  1

TA_LEFT         =  0
TA_RIGHT        =  2
TA_CENTER       =  6

TA_TOP          =  0
TA_BOTTOM       =  8
TA_BASELINE     =  24

ETO_GRAYED      =  1
ETO_OPAQUE      =  2
ETO_CLIPPED     =  4

ASPECT_FILTERING = 1

ifndef NOMETAFILE

; Metafile Functions */
META_SETBKCOLOR            =  0201h
META_SETBKMODE             =  0102h
META_SETMAPMODE            =  0103h
META_SETROP2               =  0104h
META_SETRELABS             =  0105h
META_SETPOLYFILLMODE       =  0106h
META_SETSTRETCHBLTMODE     =  0107h
META_SETTEXTCHAREXTRA      =  0108h
META_SETTEXTCOLOR          =  0209h
META_SETTEXTJUSTIFICATION  =  020Ah
META_SETWINDOWORG          =  020Bh
META_SETWINDOWEXT          =  020Ch
META_SETVIEWPORTORG        =  020Dh
META_SETVIEWPORTEXT        =  020Eh
META_OFFSETWINDOWORG       =  020Fh
META_SCALEWINDOWEXT        =  0400h
META_OFFSETVIEWPORTORG     =  0211h
META_SCALEVIEWPORTEXT      =  0412h
META_LINETO                =  0213h
META_MOVETO                =  0214h
META_EXCLUDECLIPRECT       =  0415h
META_INTERSECTCLIPRECT     =  0416h
META_ARC                   =  0817h
META_ELLIPSE               =  0418h
META_FLOODFILL             =  0419h
META_PIE                   =  081Ah
META_RECTANGLE             =  041Bh
META_ROUNDRECT             =  061Ch
META_PATBLT                =  061Dh
META_SAVEDC                =  001Eh
META_SETPIXEL              =  041Fh
META_OFFSETCLIPRGN         =  0220h
META_TEXTOUT               =  0521h
META_BITBLT                =  0922h
META_STRETCHBLT            =  0B23h
META_POLYGON               =  0324h
META_POLYLINE              =  0325h
META_ESCAPE                =  0626h
META_RESTOREDC             =  0127h
META_FILLREGION            =  0228h
META_FRAMEREGION           =  0429h
META_INVERTREGION          =  012Ah
META_PAINTREGION           =  012Bh
META_SELECTCLIPREGION      =  012Ch
META_SELECTOBJECT          =  012Dh
META_SETTEXTALIGN          =  012Eh
META_DRAWTEXT              =  062Fh

META_CHORD		   =  0830h
META_SETMAPPERFLAGS	   =  0231h
META_EXTTEXTOUT		   =  0a32h
META_SETDIBTODEV	   =  0d33h
META_SELECTPALETTE	   =  0234h
META_REALIZEPALETTE	   =  0035h
META_ANIMATEPALETTE	   =  0436h
META_SETPALENTRIES	   =  0037h
META_POLYPOLYGON	   =  0538h
META_RESIZEPALETTE	   =  0139h

META_DIBBITBLT		   =  0940h
META_DIBSTRETCHBLT	   =  0b41h
META_DIBCREATEPATTERNBRUSH =  0142h
META_STRETCHDIB		   =  0f43h

META_DELETEOBJECT	   =  01f0h

META_CREATEPALETTE	   =  00f7h
META_CREATEBRUSH           =  00F8h
META_CREATEPATTERNBRUSH    =  01F9h
META_CREATEPENINDIRECT     =  02FAh
META_CREATEFONTINDIRECT    =  02FBh
META_CREATEBRUSHINDIRECT   =  02FCh
META_CREATEBITMAPINDIRECT  =  02FDh
META_CREATEBITMAP          =  06FEh
META_CREATEREGION          =  06FFh

; /* Clipboard Metafile Picture Structure */
HANDLETABLE struc
    ht_objectHandle  dw      ?
HANDLETABLE ends

METARECORD struc
    mr_rdSize	     dd      ?
    mr_rdFunction    dw      ?
    mr_rdParm	     dw      ?
METARECORD ends

METAFILEPICT struc
    mfp_mm	dw	?
    mfp_xExt	dw	?
    mfp_yExt	dw	?
    mfp_hMF	dw	?
METAFILEPICT ends

METAHEADER struc
  mtType	dw	?
  mtHeaderSize	dw	?
  mtVersion	dw	?
  mtSize	dd	?
  mtNoObjects	dw	?
  mtMaxRecord	dd	?
  mtNoParameters dw	?
METAHEADER ends

endif ; NOMETAFILE

; GDI Escapes
NEWFRAME                  =   1
ABORTDOC                  =   2
NEXTBAND                  =   3
SETCOLORTABLE             =   4
GETCOLORTABLE             =   5
FLUSHOUTPUT               =   6
DRAFTMODE                 =   7
QUERYESCSUPPORT           =   8
SETABORTPROC              =   9
STARTDOC                  =   10
;; This value conflicts with a std WIN386 MACRO definition
;;ENDDOC		    =	11
GETPHYSPAGESIZE           =   12
GETPRINTINGOFFSET         =   13
GETSCALINGFACTOR          =   14
MFCOMMENT                 =   15
GETPENWIDTH               =   16
SETCOPYCOUNT              =   17
SELECTPAPERSOURCE         =   18
DEVICEDATA                =   19
PASSTHROUGH               =   19
GETTECHNOLGY		  =   20
GETTECHNOLOGY		  =   20
SETENDCAP                 =   21
SETLINEJOIN               =   22
SETMITERLIMIT             =   23
BANDINFO                  =   24
DRAWPATTERNRECT           =   25
GETVECTORPENSIZE          =   26
GETVECTORBRUSHSIZE        =   27
ENABLEDUPLEX              =   28
ENABLEMANUALFEED	  =   29
GETSETPAPERBINS 	  =   29
GETSETPRINTORIENT	  =   30
ENUMPAPERBINS		  =   31

GETEXTENDEDTEXTMETRICS    =   256
GETEXTENTTABLE            =   257
GETPAIRKERNTABLE          =   258
GETTRACKKERNTABLE         =   259

EXTTEXTOUT                =   512

ENABLERELATIVEWIDTHS      =   768
ENABLEPAIRKERNING         =   769
SETKERNTRACK              =   770
SETALLJUSTVALUES	  =   771
SETCHARSET		  =   772

GETSETSCREENPARAMS        =   3072

STRETCHBLT                =   2048


; Spooler Error Codes
SP_NOTREPORTED            =   4000h
SP_ERROR                  =   (-1)
SP_APPABORT               =   (-2)
SP_USERABORT              =   (-3)
SP_OUTOFDISK              =   (-4)
SP_OUTOFMEMORY            =   (-5)

PR_JOBSTATUS              =   0000

; Object Definitions for EnumObjects()
OBJ_PEN                   =   1
OBJ_BRUSH                 =   2

;
; Menu flags for Change/Check/Enable MenuItem
;
MF_INSERT       =   0000h
MF_CHANGE       =   0080h
MF_APPEND       =   0100h
MF_DELETE       =   0200h
MF_REMOVE       =   1000h

MF_BYCOMMAND    =   0000h
MF_BYPOSITION   =   0400h

MF_SEPARATOR    =   0800h

MF_ENABLED      =   0000h
MF_GRAYED       =   0001h
MF_DISABLED     =   0002h

MF_UNCHECKED    =   0000h
MF_CHECKED      =   0008h
MF_USECHECKBITMAPS= 0200h

MF_STRING       =   0000h
MF_BITMAP       =   0004h
MF_OWNERDRAW    =   0100h

MF_POPUP        =   0010h
MF_MENUBARBREAK =   0020h
MF_MENUBREAK    =   0040h

MF_UNHILITE     =   0000h
MF_HILITE       =   0080h

MF_SYSMENU      =   2000h
MF_HELP         =   4000h
MF_MOUSESELECT  =   8000h


;
;  System Menu Command Values
;
SC_SIZE        = 0F000h
SC_MOVE        = 0F010h
SC_MINIMIZE    = 0F020h
SC_MAXIMIZE    = 0F030h
SC_NEXTWINDOW  = 0F040h
SC_PREVWINDOW  = 0F050h
SC_CLOSE       = 0F060h
SC_VSCROLL     = 0F070h
SC_HSCROLL     = 0F080h
SC_MOUSEMENU   = 0F090h
SC_KEYMENU     = 0F100h
SC_ARRANGE     = 0F110h
SC_RESTORE     = 0F120h
SC_TASKLIST    = 0F130h
SC_SCREENSAVE  = 0F140h
SC_HOTKEY      = 0F150h

SC_ICON        = SC_MINIMIZE
SC_ZOOM        = SC_MAXIMIZE

;
;  Window State Messages
;
IFNDEF  NOWM
WM_STATE            = 0000H

WM_NULL             = 0000h
WM_CREATE           = 0001h
WM_DESTROY          = 0002h
WM_MOVE             = 0003h
WM_SIZE             = 0005h
WM_ACTIVATE         = 0006h
WM_SETFOCUS         = 0007h
WM_KILLFOCUS        = 0008h
WM_ENABLE           = 000Ah
WM_SETREDRAW        = 000Bh
WM_SETTEXT          = 000Ch
WM_GETTEXT          = 000Dh
WM_GETTEXTLENGTH    = 000Eh
WM_PAINT            = 000Fh

WM_CLOSE            = 0010h
WM_QUERYENDSESSION  = 0011h
WM_QUIT             = 0012h
WM_QUERYOPEN        = 0013h
WM_ERASEBKGND       = 0014h
WM_SYSCOLORCHANGE   = 0015h
WM_ENDSESSION       = 0016h
WM_SHOWWINDOW       = 0018h
WM_CTLCOLOR         = 0019h
WM_WININICHANGE     = 001Ah
WM_DEVMODECHANGE    = 001Bh
WM_ACTIVATEAPP      = 001Ch
WM_FONTCHANGE       = 001Dh
WM_TIMECHANGE       = 001Eh
WM_CANCELMODE       = 001Fh

WM_SETCURSOR        = 0020h
WM_MOUSEACTIVATE    = 0021h
WM_CHILDACTIVATE    = 0022h
WM_QUEUESYNC        = 0023h
WM_GETMINMAXINFO    = 0024h
WM_HELP             = 0025h
WM_ICONERASEBKGND   = 0027h
WM_NEXTDLGCTL       = 0028h
WM_SPOOLERSTATUS    = 002Ah
WM_DRAWITEM         = 002Bh
WM_MEASUREITEM      = 002Ch
WM_DELETEITEM       = 002Dh
WM_VKEYTOITEM       = 002Eh
WM_CHARTOITEM       = 002Fh

WM_SETFONT          = 0030h
WM_GETFONT          = 0031h
WM_QUERYDRAGICON    = 0037h
;WM_WINHELP         = 0038h ;Win32
WM_COMPAREITEM	    = 0039h
;WM_FULLSCREEN      = 003Ah ;Win32
;WM_CLIENTSHUTDOWN  = 003Bh ;Win32
;WM_DDEMLEVENT      = 003Ch ;Win32
;MM_CALCSCROLL      = 003Fh ;Win32

WM_COMPACTING       = 0041h
;WM_OTHERWINDOWCREATED = 0042h ;Win32
;WM_OTHERWINDOWDESTROYED = 0043h ;Win32
WM_COMMNOTIFY       = 0044h
WM_WINDOWPOSCHANGING= 0046h
WM_WINDOWPOSCHANGED = 0047h
WM_POWER            = 0048h
;WM_COPYGLOBALDATA  = 0049h ;Win32
;WM_COPYDATA        = 004Ah ;Win32
;WM_CANCELJOURNAL   = 004Bh ;Win32
;WM_LOGONNOTIFY     = 004Ch ;Win32
WM_NOTIFY           = 004Eh
;WM_ACCESS_WINDOW   = 004Fh ;Win32

WM_TCARD	    = 0052h
WM_HELP 	    = 0053h


;WM_FINALDESTROY    = 0070h

WM_NCCREATE         = 0081h
WM_NCDESTROY        = 0082h
WM_NCCALCSIZE       = 0083h
WM_NCHITTEST        = 0084h
WM_NCPAINT          = 0085h
WM_NCACTIVATE       = 0086h
WM_GETDLGCODE       = 0087h

WM_NCMOUSEMOVE      = 00A0h
WM_NCLBUTTONDOWN    = 00A1h
WM_NCLBUTTONUP      = 00A2h
WM_NCLBUTTONDBLCLK  = 00A3h
WM_NCRBUTTONDOWN    = 00A4h
WM_NCRBUTTONUP      = 00A5h
WM_NCRBUTTONDBLCLK  = 00A6h
WM_NCMBUTTONDOWN    = 00A7h
WM_NCMBUTTONUP      = 00A8h
WM_NCMBUTTONDBLCLK  = 00A9h

WM_KEYFIRST         = 0100h
WM_KEYDOWN          = 0100h
WM_KEYUP            = 0101h
WM_CHAR             = 0102h
WM_DEADCHAR         = 0103h
WM_SYSKEYDOWN       = 0104h
WM_SYSKEYUP         = 0105h
WM_SYSCHAR          = 0106h
WM_SYSDEADCHAR      = 0107h
WM_KEYLAST          = 0108h
WM_INTERIM          = 010Ch

WM_INITDIALOG       = 0110h
WM_COMMAND          = 0111h
WM_SYSCOMMAND       = 0112h
WM_TIMER            = 0113h
WM_HSCROLL          = 0114h
WM_VSCROLL          = 0115h
WM_INITMENU         = 0116h
WM_INITMENUPOPUP    = 0117h
WM_MENUSELECT       = 011Fh

WM_MENUCHAR         = 0120h
WM_ENTERIDLE        = 0121h

;WM_CTLCOLORFIRST       = 0132h ;Win32
;WM_CTLCOLORMSGBOX      = 0132h ;Win32
;WM_CTLCOLOREDIT        = 0133h ;Win32
;WM_CTLCOLORLISTBOX     = 0134h ;Win32
;WM_CTLCOLORBTN         = 0135h ;Win32
;WM_CTLCOLORDLG         = 0136h ;Win32
;WM_CTLCOLORSCROLLBAR   = 0137h ;Win32
;WM_CTLCOLORSTATIC      = 0138h ;Win32
;WM_CTLCOLORLAST        = 0138h ;Win32

;CB_GETEDITSEL          = 0140h ;Win32
;CB_LIMITTEXT           = 0141h ;Win32
;CB_SETEDITSEL          = 0142h ;Win32
;CB_ADDSTRING           = 0143h ;Win32
;CB_DELETESTRING        = 0144h ;Win32
;CB_DIR                 = 0145h ;Win32
;CB_GETCOUNT            = 0146h ;Win32
;CB_GETCURSEL           = 0147h ;Win32
;CB_GETLBTEXT           = 0148h ;Win32
;CB_GETLBTEXTLEN        = 0149h ;Win32
;CB_INSERTSTRING        = 014Ah ;Win32
;CB_RESETCONTENT        = 014Bh ;Win32
;CB_FINDSTRING          = 014Ch ;Win32
;CB_SELECTSTRING        = 014Dh ;Win32
;CB_SETCURSEL           = 014Eh ;Win32
;CB_SHOWDROPDOWN        = 014Fh ;Win32

;CB_GETITEMDATA         = 0150h ;Win32
;CB_SETITEMDATA         = 0151h ;Win32
;CB_GETDROPPEDCONTROLRECT   = 0152h ;Win32
;CB_SETITEMHEIGHT       = 0153h ;Win32
;CB_GETITEMHEIGHT       = 0154h ;Win32
;CB_SETEXTENDEDUI       = 0155h ;Win32
;CB_GETEXTENDEDUI       = 0156h ;Win32
;CB_GETDROPPEDSTATE     = 0157h ;Win32
;CB_FINDSTRINGEXACT     = 0158h ;Win32
;CB_SETLOCALE           = 0159h ;Win32
;CB_GETLOCALE           = 015ah ;Win32

;STM_SETICON            = 0170h ;Win32
;STM_GETICON            = 0171h ;Win32

;LB_ADDSTRING           = 0180h ;Win32
;LB_INSERTSTRING        = 0181h ;Win32
;LB_DELETESTRING        = 0182h ;Win32
;LB_SELITEMRANGEEX      = 0183h ;Win32
;LB_RESETCONTENT        = 0184h ;Win32
;LB_SETSEL              = 0185h ;Win32
;LB_SETCURSEL           = 0186h ;Win32
;LB_GETSEL              = 0187h ;Win32
;LB_GETCURSEL           = 0188h ;Win32
;LB_GETTEXT             = 0189h ;Win32
;LB_GETTEXTLEN          = 018Ah ;Win32
;LB_GETCOUNT            = 018Bh ;Win32
;LB_SELECTSTRING        = 018Ch ;Win32
;LB_DIR                 = 018Dh ;Win32
;LB_GETTOPINDEX         = 018Eh ;Win32
;LB_FINDSTRING          = 018Fh ;Win32

;LB_GETSELCOUNT         = 0190h ;Win32
;LB_GETSELITEMS         = 0191h ;Win32
;LB_SETTABSTOPS         = 0192h ;Win32
;LB_GETHORIZONTALEXTENT = 0193h ;Win32
;LB_SETHORIZONTALEXTENT = 0194h ;Win32
;LB_SETCOLUMNWIDTH      = 0195h ;Win32
;LB_ADDFILE             = 0196h ;Win32
;LB_SETTOPINDEX         = 0197h ;Win32
;LB_GETITEMRECT         = 0198h ;Win32
;LB_GETITEMDATA         = 0199h ;Win32
;LB_SETITEMDATA         = 019Ah ;Win32
;LB_SELITEMRANGE        = 019Bh ;Win32
;LB_SETANCHORINDEX      = 019Ch ;Win32
;LB_GETANCHORINDEX      = 019Dh ;Win32
;LB_SETCARETINDEX       = 019Eh ;Win32
;LB_GETCARETINDEX       = 019Fh ;Win32

;LB_SETITEMHEIGHT       = 01A0h ;Win32
;LB_GETITEMHEIGHT       = 01A1h ;Win32
;LB_FINDSTRINGEXACT     = 01A2h ;Win32
;LBCB_CARETON           = 01A3h ;Win32
;LBCB_CARETOFF          = 01A4h ;Win32
;LB_SETLOCALE           = 01A5h ;Win32
;LB_GETLOCALE           = 01A6h ;Win32
;LB_SETCOUNT            = 01A7h ;Win32

;MN_SETHMENU            = 01E0h ;Win32
;MN_GETHMENU            = 01E1h ;Win32
;MN_SIZEWINDOW          = 01E2h ;Win32
;MN_OPENHIERARCHY       = 01E3h ;Win32
;MN_CLOSEHIERARCHY      = 01E4h ;Win32
;MN_SELECTITEM          = 01E5h ;Win32
;MN_CANCELMENUS         = 01E6h ;Win32
;MN_SELECTFIRSTVALIDITEM    = 01E7h ;Win32
;MN_GETPPOPUPMENU       = 01EAh ;Win32
;MN_FINDMENUWINDOWFROMPOINT = 01EBh ;Win32
;MN_SHOWPOPUPWINDOW     = 01ECh ;Win32
;MN_BUTTONDOWN          = 01EDh ;Win32
;MN_MOUSEMOVE           = 01EEh ;Win32
;MN_BUTTONUP            = 01EFh ;Win32
;MN_SETTIMERTOOPENHIERARCHY = 01F0 ;Win32

WM_MOUSEFIRST       = 0200h
WM_MOUSEMOVE        = 0200h
WM_LBUTTONDOWN      = 0201h
WM_LBUTTONUP        = 0202h
WM_LBUTTONDBLCLK    = 0203h
WM_RBUTTONDOWN      = 0204h
WM_RBUTTONUP        = 0205h
WM_RBUTTONDBLCLK    = 0206h
WM_MBUTTONDOWN      = 0207h
WM_MBUTTONUP        = 0208h
WM_MBUTTONDBLCLK    = 0209h
WM_MOUSELAST        = 0209h

WM_PARENTNOTIFY     = 0210h

WM_MDICREATE        = 0220h
WM_MDIDESTROY       = 0221h
WM_MDIACTIVATE      = 0222h
WM_MDIRESTORE       = 0223h
WM_MDINEXT          = 0224h
WM_MDIMAXIMIZE      = 0225h
WM_MDITILE          = 0226h
WM_MDICASCADE       = 0227h
WM_MDIICONARRANGE   = 0228h
WM_MDIGETACTIVE     = 0229h

WM_MDISETMENU       = 0230h
WM_DROPFILES	    = 0233h
;WM_MDIREFRESHMENU  = 0234h ;Win32

WM_HANGEULLAST      = 029Fh ;Win32

WM_CUT              = 0300h
WM_COPY             = 0301h
WM_PASTE            = 0302h
WM_CLEAR            = 0303h
WM_UNDO             = 0304h
WM_RENDERFORMAT     = 0305h
WM_RENDERALLFORMATS = 0306h
WM_DESTROYCLIPBOARD = 0307h
WM_DRAWCLIPBOARD    = 0308h
WM_PAINTCLIPBOARD   = 0309h
WM_VSCROLLCLIPBOARD = 030Ah
WM_SIZECLIPBOARD    = 030Bh
WM_ASKCBFORMATNAME  = 030Ch
WM_CHANGECBCHAIN    = 030Dh
WM_HSCROLLCLIPBOARD = 030Eh
WM_QUERYNEWPALETTE  = 030Fh
WM_PALETTEISCHANGING = 0310h
WM_PALETTECHANGED   = 0311h
;WM_HOTKEY          = 0312h     ;Win32
;WM_HOOKMSG         = 0314h     ;Win32
;WM_EXITPROCESS     = 0315h     ;Win32
WM_PRINT            = 0317h
WM_PRINTCLIENT      = 0318h

WM_PENWINFIRST      equ 0380h
WM_PENWINLAST       equ 038Fh

WM_COALESCE_FIRST  equ 0390h
WM_COALESCE_LAST   equ 039Fh

;  private window messages start here
WM_USER             = 0400H

;  private app messages start here
WM_APP              = 8000H
ENDIF           ; NOWM

; WM_MOUSEACTIVATE Return Codes
MA_ACTIVATE       =  1
MA_ACTIVATEANDEAT =  2
MA_NOACTIVATE     =  3

; Size message commands
SIZENORMAL       = 0
SIZEICONIC       = 1
SIZEFULLSCREEN   = 2
SIZEZOOMSHOW     = 3
SIZEZOOMHIDE     = 4

; ShowWindow() Commands
SW_HIDE            = 0
SW_SHOWNORMAL      = 1
SW_NORMAL          = 1
SW_SHOWMINIMIZED   = 2
SW_SHOWMAXIMIZED   = 3
SW_MAXIMIZE        = 3
SW_SHOWNOACTIVATE  = 4
SW_SHOW            = 5
SW_MINIMIZE        = 6
SW_SHOWMINNOACTIVE = 7
SW_SHOWNA          = 8
SW_RESTORE         = 9

; Old ShowWindow() Commands
HIDE_WINDOW        = 0
SHOW_OPENWINDOW    = 1
SHOW_ICONWINDOW    = 2
SHOW_FULLSCREEN    = 3
SHOW_OPENNOACTIVATE= 4

;  identifiers for the WM_SHOWWINDOW message
SW_PARENTCLOSING =  1
SW_OTHERZOOM     =  2
SW_PARENTOPENING =  3
SW_OTHERUNZOOM   =  4
;
; Key state masks for mouse messages
;
MK_LBUTTON       = 0001h
MK_RBUTTON       = 0002h
MK_SHIFT         = 0004h
MK_CONTROL       = 0008h
MK_MBUTTON       = 0010h
;
; Class styles
;
CS_VREDRAW         = 0001h
CS_HREDRAW         = 0002h
CS_KEYCVTWINDOW    = 0004H
CS_DBLCLKS         = 0008h
; 		     0010h reserved
CS_OWNDC           = 0020h
CS_CLASSDC         = 0040h
CS_PARENTDC        = 0080h
CS_NOKEYCVT        = 0100h
CS_SAVEBITS        = 0800h
CS_NOCLOSE         = 0200h
CS_BYTEALIGNCLIENT = 1000h
CS_BYTEALIGNWINDOW = 2000h
CS_GLOBALCLASS     = 4000h    ; Global window class

;
; Special CreateWindow position value
;
CW_USEDEFAULT	EQU    8000h

;
; Windows styles (the high words)
;
WS_OVERLAPPED   = 00000h
WS_ICONICPOPUP  = 0C000h
WS_POPUP        = 08000h
WS_CHILD        = 04000h
WS_MINIMIZE     = 02000h
WS_VISIBLE      = 01000h
WS_DISABLED     = 00800h
WS_CLIPSIBLINGS = 00400h
WS_CLIPCHILDREN = 00200h
WS_MAXIMIZE     = 00100h
WS_CAPTION      = 000C0h     ; WS_BORDER | WS_DLGFRAME
WS_BORDER       = 00080h
WS_DLGFRAME     = 00040h
WS_VSCROLL      = 00020h
WS_HSCROLL      = 00010h
WS_SYSMENU      = 00008h
WS_THICKFRAME   = 00004h
WS_HREDRAW      = 00002h
WS_VREDRAW      = 00001h
WS_GROUP        = 00002h
WS_TABSTOP      = 00001h
WS_MINIMIZEBOX  = 00002h
WS_MAXIMIZEBOX  = 00001h

; Common Window Styles

WS_OVERLAPPEDWINDOW = WS_OVERLAPPED + WS_CAPTION + WS_SYSMENU + WS_THICKFRAME + WS_MINIMIZEBOX + WS_MAXIMIZEBOX
WS_POPUPWINDOW  = WS_POPUP + WS_BORDER + WS_SYSMENU
WS_CHILDWINDOW  = WS_CHILD
WS_TILEDWINDOW  = WS_OVERLAPPEDWINDOW

WS_TILED        = WS_OVERLAPPED
WS_ICONIC       = WS_MINIMIZE
WS_SIZEBOX      = WS_THICKFRAME

; Extended Window Styles (low words)
WS_EX_DLGMODALFRAME  = 0001
WS_EX_DRAGOBJECT     = 0002
WS_EX_NOPARENTNOTIFY = 0004
WS_EX_TOPMOST        = 0008

;
; predefined clipboard formats
;
CF_TEXT         =  1
CF_BITMAP       =  2
CF_METAFILEPICT =  3
CF_SYLK         =  4
CF_DIF          =  5
CF_TIFF         =  6
CF_OEMTEXT      =  7
CF_DIB          =  8
CF_PALETTE      =  9
CF_PENDATA      = 10
CF_RIFF         = 11
CF_WAVE         = 12

CF_OWNERDISPLAY = 80h       ; owner display
CF_DSPTEXT      = 81h       ; display text
CF_DSPBITMAP    = 82h       ; display bitmap
CF_DSPMETAFILEPICT  = 83h   ; display metafile
;
; Private clipboard format range
;
CF_PRIVATEFIRST       = 200h       ; Anything in this range doesn't
CF_PRIVATELAST        = 2ffh       ; get GlobalFree'd
CF_GDIOBJFIRST        = 300h       ; Anything in this range gets
CF_GDIOBJLAST         = 3ffh       ; DeleteObject'ed


MAKEINTRESOURCE MACRO a
        mov     ax,a
        xor     dx,dx
        ENDM
;
;  Predefined resource types
;
RT_CURSOR       = 1              ; must be passed through MAKEINTRESOURCE
RT_BITMAP       = 2
RT_ICON         = 3
RT_MENU         = 4
RT_DIALOG       = 5
RT_STRING       = 6
RT_FONTDIR      = 7
RT_FONT         = 8
RT_ACCELERATOR  = 9
RT_RCDATA       = 10

;** NOTE: if any new resource types are introduced above this point, then the
;** value of DIFFERENCE must be changed.
;** (RT_GROUP_CURSOR - RT_CURSOR) must always be equal to DIFFERENCE
;** (RT_GROUP_ICON - RT_ICON) must always be equal to DIFFERENCE

DIFFERENCE       =   11

RT_GROUP_CURSOR  =   RT_CURSOR + DIFFERENCE
RT_GROUP_ICON    =   RT_ICON + DIFFERENCE



IFNDEF NOMDI
MDICREATESTRUCT     struc
    szClass	    dd ?
    szTitle	    dd ?
    hOwner	    dw ?
    x		    dw ?
    y		    dw ?
    cxc 	    dw ?
    cyc 	    dw ?
    style	    dd ?
MDICREATESTRUCT ends

CLIENTCREATESTRUCT  struc
    hWindowMenu     dw ?
    idFirstChild    dw ?
CLIENTCREATESTRUCT ends
ENDIF

; NOMDI


PALETTEENTRY	    struc
    peRed	    db ?
    peGreen	    db ?
    peBlue	    db ?
    peFlags	    db ?
PALETTEENTRY	    ends

; Logical Palette
LOGPALETTE	    struc
    palVersion	    dw ?
    palNumEntries   dw ?
    palPalEntry     db ?  ; array of PALETTEENTRY
LOGPALETTE	    ends

; DRAWITEMSTRUCT for ownerdraw
DRAWITEMSTRUCT	    struc
    drCtlType	      dw ?
    drCtlID	      dw ?
    dritemID	      dw ?
    dritemAction      dw ?
    dritemState       dw ?
    drhwndItem	      dw ?
    drhDC	      dw ?
    drrcItem	      DB size RECT dup(?)
    dritemData	      dd ?
DRAWITEMSTRUCT ends

; DELETEITEMSTRUCT for ownerdraw
DELETEITEMSTRUCT    struc
    deCtlType	      dw ?
    deCtlID	      dw ?
    deitemID	      dw ?
    dehwndItem	      dw ?
    deitemData	      dd ?
DELETEITEMSTRUCT ends

; MEASUREITEMSTRUCT for ownerdraw
MEASUREITEMSTRUCT   struc
    meCtlType	      dw ?
    meCtlID	      dw ?
    meitemID	      dw ?
    meitemWidth       dw ?
    meitemHeight      dw ?
    meitemData	      dd ?
MEASUREITEMSTRUCT ends

; COMPAREITEMSTUCT for ownerdraw sorting
COMPAREITEMSTRUCT   struc
    coCtlType   dw ?
    coCtlID     dw ?
    cohwndItem  dw ?
    coitemID1   dw ?
    coitemData1 dd ?
    coitemID2   dw ?
    coitemData2 dd ?
COMPAREITEMSTRUCT   ends

; Owner draw control types
ODT_MENU      =  1
ODT_LISTBOX   =  2
ODT_COMBOBOX  =  3
ODT_BUTTON    =  4

; Owner draw actions
ODA_DRAWENTIRE = 1
ODA_SELECT     = 2
ODA_FOCUS      = 4

; Owner draw state
ODS_SELECTED   = 0001h
ODS_GRAYED     = 0002h
ODS_DISABLED   = 0004h
ODS_CHECKED    = 0008h
ODS_FOCUS      = 0010h

; PeekMessage() Options
PM_NOREMOVE    = 0000h
PM_REMOVE      = 0001h
PM_NOYIELD     = 0002h

; SetWindowPos Flags
SWP_NOSIZE       =  0001h
SWP_NOMOVE       =  0002h
SWP_NOZORDER     =  0004h
SWP_NOREDRAW     =  0008h
SWP_NOACTIVATE   =  0010h
SWP_DRAWFRAME    =  0020h
SWP_SHOWWINDOW   =  0040h
SWP_HIDEWINDOW   =  0080h
SWP_NOCOPYBITS   =  0100h
SWP_NOREPOSITION =  0200h


IFNDEF NOWINMESSAGES

; Listbox messages
LB_ADDSTRING	       = (WM_USER+1)
LB_INSERTSTRING        = (WM_USER+2)
LB_DELETESTRING        = (WM_USER+3)
LB_RESETCONTENT        = (WM_USER+5)
LB_SETSEL	       = (WM_USER+6)
LB_SETCURSEL	       = (WM_USER+7)
LB_GETSEL	       = (WM_USER+8)
LB_GETCURSEL	       = (WM_USER+9)
LB_GETTEXT	       = (WM_USER+10)
LB_GETTEXTLEN	       = (WM_USER+11)
LB_GETCOUNT	       = (WM_USER+12)
LB_SELECTSTRING        = (WM_USER+13)
LB_DIR		       = (WM_USER+14)
LB_GETTOPINDEX	       = (WM_USER+15)
LB_FINDSTRING	       = (WM_USER+16)
LB_GETSELCOUNT	       = (WM_USER+17)
LB_GETSELITEMS	       = (WM_USER+18)
LB_SETTABSTOPS	       = (WM_USER+19)
LB_GETHORIZONTALEXTENT = (WM_USER+20)
LB_SETHORIZONTALEXTENT = (WM_USER+21)
LB_SETTOPINDEX	       = (WM_USER+24)
LB_GETITEMRECT	       = (WM_USER+25)
LB_GETITEMDATA	       = (WM_USER+26)
LB_SETITEMDATA	       = (WM_USER+27)
LB_SELITEMRANGE        = (WM_USER+28)
LB_SETCARETINDEX       = (WM_USER+31)
LB_GETCARETINDEX       = (WM_USER+32)
IFNDEF NOWIN31
LB_SETITEMHEIGHT       = (WM_USER+33)
LB_GETITEMHEIGHT       = (WM_USER+34)
LB_FINDSTRINGEXACT     = (WM_USER+35)
ENDIF

LB_SETLOCALE	       = (WM_USER+38)   ; Win NT
LB_GETLOCALE	       = (WM_USER+39)   ; Win NT
;; LB_SETCOUNT	       = (WM_USER+40)   ; Win NT
LB_INITSTORAGE	       = (WM_USER+41)   

ENDIF
; NOWINMESSAGES

; Listbox Styles
LBS_NOTIFY            = 0001h
LBS_SORT              = 0002h
LBS_NOREDRAW          = 0004h
LBS_MULTIPLESEL       = 0008h
LBS_OWNERDRAWFIXED    = 0010h
LBS_OWNERDRAWVARIABLE = 0020h
LBS_HASSTRINGS        = 0040h
LBS_USETABSTOPS       = 0080h
LBS_NOINTEGRALHEIGHT  = 0100h
LBS_MULTICOLUMN       = 0200h
LBS_WANTKEYBOARDINPUT = 0400h
LBS_EXTENDEDSEL	      = 0800h
LBS_STANDARD          = LBS_NOTIFY + LBS_SORT + WS_VSCROLL + WS_BORDER
LBS_DISABLENOSCROLL   = 1000h

; Listbox Notification Codes
LBN_ERRSPACE      =  (-2)
LBN_SELCHANGE     =  1
LBN_DBLCLK        =  2
LBN_SELCANCEL     =  3
LBN_SETFOCUS      =  4
LBN_KILLFOCUS     =  5

IFNDEF NOWINMESSAGES

; Edit Control Messages
EM_GETSEL              = (WM_USER+0)
EM_SETSEL              = (WM_USER+1)
EM_GETRECT             = (WM_USER+2)
EM_SETRECT             = (WM_USER+3)
EM_SETRECTNP           = (WM_USER+4)
EM_SCROLL              = (WM_USER+5)
EM_LINESCROLL          = (WM_USER+6)
EM_GETMODIFY           = (WM_USER+8)
EM_SETMODIFY           = (WM_USER+9)
EM_GETLINECOUNT        = (WM_USER+10)
EM_LINEINDEX           = (WM_USER+11)
EM_SETHANDLE           = (WM_USER+12)
EM_GETHANDLE           = (WM_USER+13)
EM_LINELENGTH          = (WM_USER+17)
EM_REPLACESEL          = (WM_USER+18)
EM_SETFONT             = (WM_USER+19)
EM_GETLINE             = (WM_USER+20)
EM_LIMITTEXT           = (WM_USER+21)
EM_CANUNDO             = (WM_USER+22)
EM_UNDO                = (WM_USER+23)
EM_FMTLINES            = (WM_USER+24)
EM_LINEFROMCHAR        = (WM_USER+25)
EM_SETWORDBREAK        = (WM_USER+26)
EM_SETTABSTOPS         = (WM_USER+27)
EM_SETPASSWORDCHAR     = (WM_USER+28)
EM_EMPTYUNDOBUFFER     = (WM_USER+29)
IFNDEF NOWIN31
EM_GETFIRSTVISIBLELINE = (WM_USER+30)
EM_SETREADONLY         = (WM_USER+31)
EM_SETWORDBREAKPROC    = (WM_USER+32)
EM_GETWORDBREAKPROC    = (WM_USER+33)
EM_GETPASSWORDCHAR     = (WM_USER+34)
ENDIF

ENDIF
; NOWINMESSAGES


; Edit Control Styles (low word)
ES_LEFT            = 0000h
ES_CENTER          = 0001h
ES_RIGHT           = 0002h
ES_MULTILINE       = 0004h
ES_UPPERCASE       = 0008h
ES_LOWERCASE       = 0010h
ES_PASSWORD        = 0020h
ES_AUTOVSCROLL     = 0040h
ES_AUTOHSCROLL     = 0080h
ES_NOHIDESEL       = 0100h
ES_OEMCONVERT      = 0400h
IFNDEF NOWIN31
ES_READONLY        = 0800h
ES_WANTRETURN      = 1000h
ENDIF


; Edit Control Notification Codes
EN_SETFOCUS        = 0100h
EN_KILLFOCUS       = 0200h
EN_CHANGE          = 0300h
EN_UPDATE          = 0400h
EN_ERRSPACE        = 0500h
EN_MAXTEXT         = 0501h
EN_HSCROLL         = 0601h
EN_VSCROLL         = 0602h

IFNDEF NOWINMESSAGES

; Button Control Messages
BM_GETCHECK	   = (WM_USER+0)
BM_SETCHECK	   = (WM_USER+1)
BM_GETSTATE	   = (WM_USER+2)
BM_SETSTATE	   = (WM_USER+3)
BM_SETSTYLE	   = (WM_USER+4)

ENDIF
; NOWINMESSAGES

; Button Control Styles (low word)
BS_PUSHBUTTON      = 00h
BS_DEFPUSHBUTTON   = 01h
BS_CHECKBOX        = 02h
BS_AUTOCHECKBOX    = 03h
BS_RADIOBUTTON     = 04h
BS_3STATE          = 05h
BS_AUTO3STATE      = 06h
BS_GROUPBOX        = 07h
BS_USERBUTTON      = 08h
BS_AUTORADIOBUTTON = 09h
BS_OWNERDRAW       = 0Bh
BS_LEFTTEXT        = 20h

; User Button Notification Codes
BN_CLICKED         = 0
BN_PAINT           = 1
BN_HILITE          = 2
BN_UNHILITE        = 3
BN_DISABLE         = 4
BN_DOUBLECLICKED   = 5

; Dialog Styles (low words)
DS_ABSALIGN        = 01h
DS_SYSMODAL        = 02h
DS_LOCALEDIT       = 20h  ;/* Edit items get Local storage. */
DS_SETFONT         = 40h  ;/* User specified font for Dlg controls */
DS_MODALFRAME      = 80h  ;/* Can be combined with WS_CAPTION  */
DS_NOIDLEMSG       = 100h ;/* WM_ENTERIDLE message will not be sent */

IFNDEF NOWINMESSAGES

; Dialog box messages
DM_GETDEFID	   = (WM_USER+0)
DM_SETDEFID	   = (WM_USER+1)

ENDIF   ;NOWINMESSAGES

; Dialog Codes
DLGC_WANTARROWS     = 0001h    ;  /* Control wants arrow keys         */
DLGC_WANTTAB        = 0002h    ;  /* Control wants tab keys           */
DLGC_WANTALLKEYS    = 0004h    ;  /* Control wants all keys           */
DLGC_WANTMESSAGE    = 0004h    ;  /* Pass message to control          */
DLGC_HASSETSEL      = 0008h    ;  /* Understands EM_SETSEL message    */
DLGC_DEFPUSHBUTTON  = 0010h    ;  /* Default pushbutton               */
DLGC_UNDEFPUSHBUTTON= 0020h    ;  /* Non-default pushbutton           */
DLGC_RADIOBUTTON    = 0040h    ;  /* Radio button                     */
DLGC_WANTCHARS      = 0080h    ;  /* Want WM_CHAR messages            */
DLGC_STATIC         = 0100h    ;  /* Static item: don't include       */
DLGC_BUTTON         = 2000h    ;  /* Button item: can be checked      */

; Combo Box return Values
CB_OKAY          =   0
CB_ERR           =   (-1)
CB_ERRSPACE      =   (-2)

; Combo Box Notification Codes
CBN_ERRSPACE     =   (-1)
CBN_SELCHANGE    =   1
CBN_DBLCLK       =   2
CBN_SETFOCUS     =   3
CBN_KILLFOCUS    =   4
CBN_EDITCHANGE   =   5
CBN_EDITUPDATE   =   6
CBN_DROPDOWN     =   7

; Combo Box styles (low words)
CBS_SIMPLE           = 0001h
CBS_DROPDOWN         = 0002h
CBS_DROPDOWNLIST     = 0003h
CBS_OWNERDRAWFIXED   = 0010h
CBS_OWNERDRAWVARIABLE= 0020h
CBS_AUTOHSCROLL      = 0040h
CBS_OEMCONVERT       = 0080h
CBS_SORT             = 0100h
CBS_HASSTRINGS       = 0200h
CBS_NOINTEGRALHEIGHT = 0400h

IFNDEF NOWINMESSAGES

; Combo Box messages
CB_GETEDITSEL	         = (WM_USER+0)
CB_LIMITTEXT	         = (WM_USER+1)
CB_SETEDITSEL	         = (WM_USER+2)
CB_ADDSTRING	         = (WM_USER+3)
CB_DELETESTRING          = (WM_USER+4)
CB_DIR		         = (WM_USER+5)
CB_GETCOUNT	         = (WM_USER+6)
CB_GETCURSEL	         = (WM_USER+7)
CB_GETLBTEXT	         = (WM_USER+8)
CB_GETLBTEXTLEN          = (WM_USER+9)
CB_INSERTSTRING          = (WM_USER+10)
CB_RESETCONTENT          = (WM_USER+11)
CB_FINDSTRING	         = (WM_USER+12)
CB_SELECTSTRING          = (WM_USER+13)
CB_SETCURSEL	         = (WM_USER+14)
CB_SHOWDROPDOWN          = (WM_USER+15)
CB_GETITEMDATA           = (WM_USER+16)
CB_SETITEMDATA           = (WM_USER+17)
IFNDEF NOWIN31
CB_GETDROPPEDCONTROLRECT = (WM_USER+18)
CB_SETITEMHEIGHT         = (WM_USER+19)
CB_GETITEMHEIGHT         = (WM_USER+20)
CB_SETEXTENDEDUI         = (WM_USER+21)
CB_GETEXTENDEDUI         = (WM_USER+22)
CB_GETDROPPEDSTATE       = (WM_USER+23)
CB_FINDSTRINGEXACT       = (WM_USER+24)
ENDIF

ENDIF ; NOWINMESSAGES

; Static Control styles (low word)
SS_LEFT            = 00h
SS_CENTER          = 01h
SS_RIGHT           = 02h
SS_ICON            = 03h
SS_BLACKRECT       = 04h
SS_GRAYRECT        = 05h
SS_WHITERECT       = 06h
SS_BLACKFRAME      = 07h
SS_GRAYFRAME       = 08h
SS_WHITEFRAME      = 09h
SS_SIMPLE          = 0Bh
SS_LEFTNOWORDWRAP  = 0Ch
SS_NOPREFIX        = 80h    ; Don't do "&" character translation

IFNDEF NOWIN31
IFNDEF NOWINMESSAGES

;Static Control Messages
STM_SETICON        = (WM_USER+0)
STM_GETICON        = (WM_USER+1)
ENDIF
ENDIF

; Scroll Bar Styles (low word)
SBS_HORZ                    = 0000h
SBS_VERT                    = 0001h
SBS_TOPALIGN                = 0002h
SBS_LEFTALIGN               = 0002h
SBS_BOTTOMALIGN             = 0004h
SBS_RIGHTALIGN              = 0004h
SBS_SIZEBOXTOPLEFTALIGN     = 0002h
SBS_SIZEBOXBOTTOMRIGHTALIGN = 0004h
SBS_SIZEBOX                 = 0008h

IFNDEF NOSYSMETRICS

; GetSystemMetrics() codes
SM_CXSCREEN           =  0
SM_CYSCREEN           =  1
SM_CXVSCROLL          =  2
SM_CYHSCROLL          =  3
SM_CYCAPTION          =  4
SM_CXBORDER           =  5
SM_CYBORDER           =  6
SM_CXDLGFRAME         =  7
SM_CYDLGFRAME         =  8
SM_CYVTHUMB           =  9
SM_CXHTHUMB           =  10
SM_CXICON             =  11
SM_CYICON             =  12
SM_CXCURSOR           =  13
SM_CYCURSOR           =  14
SM_CYMENU             =  15
SM_CXFULLSCREEN       =  16
SM_CYFULLSCREEN       =  17
SM_CYKANJIWINDOW      =  18
SM_MOUSEPRESENT       =  19
SM_CYVSCROLL          =  20
SM_CXHSCROLL          =  21
SM_DEBUG              =  22
SM_SWAPBUTTON         =  23
SM_RESERVED1          =  24
SM_RESERVED2          =  25
SM_RESERVED3          =  26
SM_RESERVED4          =  27
SM_CXMIN              =  28
SM_CYMIN              =  29
SM_CXSIZE             =  30
SM_CYSIZE             =  31
SM_CXFRAME            =  32
SM_CYFRAME            =  33
SM_CXMINTRACK         =  34
SM_CYMINTRACK         =  35

IFNDEF NOWIN31
SM_CXDOUBLECLK        =  36
SM_CYDOUBLECLK        =  37
SM_CXICONSPACING      =  38
SM_CYICONSPACING      =  39
SM_MENUDROPALIGNMENT  =  40
SM_PENWINDOWS         =  41
SM_DBCSENABLED        =  42
SM_CMOUSEBUTTONS      =  43
SM_SECURE             =  44
ENDIF
IFNDEF NOWIN40
SM_CXEDGE             =  45
SM_CYEDGE             =  46
SM_CXMINSPACING       =  47
SM_CYMINSPACING       =  48
SM_CXSMICON           =  49
SM_CYSMICON           =  50
SM_CYSMCAPTION        =  51
SM_CXSMSIZE           =  52
SM_CYSMSIZE           =  53
SM_CXMENUSIZE         =  54
SM_CYMENUSIZE         =  55
SM_ARRANGE            =  56
SM_USERTYPE           =  57
SM_XWORKAREA          =  58
SM_YWORKAREA          =  59
SM_CXWORKAREA         =  60
SM_CYWORKAREA         =  61
SM_CYCAPTIONICON      =  62
SM_CYSMCAPTIONICON    =  63
SM_CXMINIMIZED        =  64
SM_CYMINIMIZED        =  65
SM_CXMAXTRACK         =  66
SM_CYMAXTRACK         =  67
SM_CXMAXIMIZED        =  68
SM_CYMAXIMIZED        =  69
SM_SHOWSOUNDS         =  70
SM_KEYBOARDPREF       =  71
SM_HIGHCONTRAST       =  72
SM_SCREENREADER       =  73
SM_CURSORSIZE         =  74
SM_CLEANBOOT	      =  75
SM_CXDRAG             =  76
SM_CYDRAG             =  77
SM_NETWORK	          =  78
SM_CXMENUCHECK        =  79
SM_CYMENUCHECK        =  80
ENDIF
SM_MAX		          =  80
SM_CMETRICSMAX        =  81

ENDIF   ;NOSYSMETRICS

IFNDEF  NOCOLOR

COLOR_SCROLLBAR           = 0
COLOR_BACKGROUND          = 1
COLOR_ACTIVECAPTION       = 2
COLOR_INACTIVECAPTION     = 3
COLOR_MENU                = 4
COLOR_WINDOW              = 5
COLOR_WINDOWFRAME         = 6
COLOR_MENUTEXT            = 7
COLOR_WINDOWTEXT          = 8
COLOR_CAPTIONTEXT         = 9
COLOR_ACTIVEBORDER        = 10
COLOR_INACTIVEBORDER      = 11
COLOR_APPWORKSPACE        = 12
COLOR_HIGHLIGHT           = 13
COLOR_HIGHLIGHTTEXT       = 14
COLOR_BTNFACE             = 15
COLOR_BTNSHADOW           = 16
COLOR_GRAYTEXT            = 17
COLOR_BTNTEXT             = 18
IFNDEF NOWIN31
COLOR_INACTIVECAPTIONTEXT = 19
COLOR_BTNHILIGHT          = 20
ENDIF
ENDIF   ;NOCOLOR

; Commands to pass WinHelp()
HELP_CONTEXT	=0001h	;/* Display topic in ulTopic */
HELP_QUIT	=0002h	;/* Terminate help */
HELP_INDEX	=0003h	;/* Display index */
HELP_HELPONHELP =0004h	;/* Display help on using help */
HELP_SETINDEX	=0005h	;/* Set the current Index for multi index help */
HELP_KEY	=0101h	;/* Display topic for keyword in offabData */

IFNDEF NOCOMM

NOPARITY        =   0
ODDPARITY       =   1
EVENPARITY      =   2
MARKPARITY      =   3
SPACEPARITY     =   4

ONESTOPBIT      =   0
ONE5STOPBITS    =   1
TWOSTOPBITS     =   2

IGNORE          =   0      ; /* Ignore signal    */
INFINITE        =   0FFFFh ; /* Infinite timeout */

; Error Flags
CE_RXOVER       =    0001h ; /* Receive Queue overflow       */
CE_OVERRUN      =    0002h ; /* Receive Overrun Error        */
CE_RXPARITY     =    0004h ; /* Receive Parity Error         */
CE_FRAME        =    0008h ; /* Receive Framing error        */
CE_BREAK        =    0010h ; /* Break Detected               */
CE_CTSTO        =    0020h ; /* CTS Timeout                  */
CE_DSRTO        =    0040h ; /* DSR Timeout                  */
CE_RLSDTO       =    0080h ; /* RLSD Timeout                 */
CE_TXFULL       =    0100h ; /* TX Queue is full             */
CE_PTO          =    0200h ; /* LPTx Timeout                 */
CE_IOE          =    0400h ; /* LPTx I/O Error               */
CE_DNS          =    0800h ; /* LPTx Device not selected     */
CE_OOP          =    1000h ; /* LPTx Out-Of-Paper            */
CE_MODE         =    8000h ; /* Requested mode unsupported   */

IE_BADID        =    (-1)  ;  /* Invalid or unsupported id    */
IE_OPEN         =    (-2)  ;  /* Device Already Open          */
IE_NOPEN        =    (-3)  ;  /* Device Not Open              */
IE_MEMORY       =    (-4)  ;  /* Unable to allocate queues    */
IE_DEFAULT      =    (-5)  ;  /* Error in default parameters  */
IE_HARDWARE     =    (-10) ;  /* Hardware Not Present         */
IE_BYTESIZE     =    (-11) ;  /* Illegal Byte Size            */
IE_BAUDRATE     =    (-12) ;  /* Unsupported BaudRate         */

; Events
EV_RXCHAR       =    0001h ; /* Any Character received       */
EV_RXFLAG       =    0002h ; /* Received certain character   */
EV_TXEMPTY      =    0004h ; /* Transmitt Queue Empty        */
EV_CTS          =    0008h ; /* CTS changed state            */
EV_DSR          =    0010h ; /* DSR changed state            */
EV_RLSD         =    0020h ; /* RLSD changed state           */
EV_BREAK        =    0040h ; /* BREAK received               */
EV_ERR          =    0080h ; /* Line status error occurred   */
EV_RING         =    0100h ; /* Ring signal detected         */
EV_PERR         =    0200h ; /* Printer error occured        */
EV_CTSS         =    0400h ; /* CTS state                    */
EV_DSRS         =    0800h ; /* DSR state                    */
EV_RLSDS        =    1000h ; /* RLSD state                   */
EV_RingTe       =    2000h ; /* Ring Trailing Edge Indicator */


; Escape Functions
SETXOFF         =    1     ;  /* Simulate XOFF received       */
SETXON          =    2     ;  /* Simulate XON received        */
SETRTS          =    3     ;  /* Set RTS high                 */
CLRRTS          =    4     ;  /* Set RTS low                  */
SETDTR          =    5     ;  /* Set DTR high                 */
CLRDTR          =    6     ;  /* Set DTR low                  */
RESETDEV        =    7     ;  /* Reset device if possible     */

LPTx            =    80h   ; /* Set if ID is for LPT device  */

IFNDEF NOWIN31
; new escape functions
GETMAXLPT   equ  8	   ; Max supported LPT id
GETMAXCOM   equ  9	   ; Max supported COM id
GETBASEIRQ  equ 10	   ; Get port base & irq for a port

; Comm Baud Rate indices
CBR_110     equ 0FF10h
CBR_300     equ 0FF11h
CBR_600     equ 0FF12h
CBR_1200    equ 0FF13h
CBR_2400    equ 0FF14h
CBR_4800    equ 0FF15h
CBR_9600    equ 0FF16h
CBR_14400   equ 0FF17h
CBR_19200   equ 0FF18h
;		0FF19h	(reserved)
;		0FF1Ah	(reserved)
CBR_38400   equ 0FF1Bh
;		0FF1Ch	(reserved)
;		0FF1Dh	(reserved)
;		0FF1Eh	(reserved)
CBR_56000   equ 0FF1Fh
;		0FF20h	(reserved)
;		0FF21h	(reserved)
;		0FF22h	(reserved)
CBR_128000  equ 0FF23h
;		0FF24h	(reserved)
;		0FF25h	(reserved)
;		0FF26h	(reserved)
CBR_256000  equ 0FF27h

; notifications passed in low word of lParam on WM_COMMNOTIFY messages
CN_RECEIVE  equ 1	    ; bytes are available in the input queue
CN_TRANSMIT equ 2	    ; fewer than wOutTrigger bytes still
			    ; remain in the output queue waiting
			    ; to be transmitted.
CN_EVENT    equ 4	    ; an enabled event has occurred

ENDIF


DCB     struc
    DCB_Id             db ?  ; /* Internal Device ID              */
    DCB_BaudRate       dw ?  ; /* Baudrate at which runing        */
    DCB_ByteSize       db ?  ; /* Number of bits/byte, 4-8        */
    DCB_Parity         db ?  ; /* 0-4=None,Odd,Even,Mark,Space    */
    DCB_StopBits       db ?  ; /* 0,1,2 = 1, 1.5, 2               */
    DCB_RlsTimeout     dw ?  ; /* Timeout for RLSD to be set      */
    DCB_CtsTimeout     dw ?  ; /* Timeout for CTS to be set       */
    DCB_DsrTimeout     dw ?  ; /* Timeout for DSR to be set       */

    DCB_BitMask1       db ?

    ;   BYTE fBinary: 1;     /* Binary Mode (skip EOF check     */
    ;   BYTE fRtsDisable:1;  /* Don't assert RTS at init time   */
    ;   BYTE fParity: 1;     /* Enable parity checking          */
    ;   BYTE fOutxCtsFlow:1; /* CTS handshaking on output       */
    ;   BYTE fOutxDsrFlow:1; /* DSR handshaking on output       */
    ;   BYTE fDummy: 2;      /* Reserved                        */
    ;   BYTE fDtrDisable:1;  /* Don't assert DTR at init time   */

    DCB_BitMask2       db ?

    ;   BYTE fOutX: 1;       /* Enable output X-ON/X-OFF        */
    ;   BYTE fInX: 1;        /* Enable input X-ON/X-OFF         */
    ;   BYTE fPeChar: 1;     /* Enable Parity Err Replacement   */
    ;   BYTE fNull: 1;       /* Enable Null stripping           */
    ;   BYTE fChEvt: 1;      /* Enable Rx character event.      */
    ;   BYTE fDtrflow: 1;    /* DTR handshake on input          */
    ;   BYTE fRtsflow: 1;    /* RTS handshake on input          */
    ;   BYTE fDummy2: 1;

    DCB_XonChar        db ? ; /* Tx and Rx X-ON character        */
    DCB_XoffChar       db ? ; /* Tx and Rx X-OFF character       */
    DCB_XonLim         dw ? ; /* Transmit X-ON threshold         */
    DCB_XoffLim        dw ? ; /* Transmit X-OFF threshold        */
    DCB_PeChar         db ? ; /* Parity error replacement char   */
    DCB_EofChar        db ? ; /* End of Input character          */
    DCB_EvtChar        db ? ; /* Recieved Event character        */
    DCB_TxDelay        dw ? ; /* Amount of time between chars    */
DCB     ends

COMSTAT     struc
    COMS_BitMask1   db ?

;    BYTE fCtsHold: 1;   /* Transmit is on CTS hold         */
;    BYTE fDsrHold: 1;   /* Transmit is on DSR hold         */
;    BYTE fRlsdHold: 1;  /* Transmit is on RLSD hold        */
;    BYTE fXoffHold: 1;  /* Received handshake              */
;    BYTE fXoffSent: 1;  /* Issued handshake                */
;    BYTE fEof: 1;       /* End of file character found     */
;    BYTE fTxim: 1;      /* Character being transmitted     */


    COMS_cbInQue    dw ?  ;   /* count of characters in Rx Queue */
    COMS_cbOutQue   dw ?  ;   /* count of characters in Tx Queue */
COMSTAT     ends

ENDIF       ;NOCOM

;
; Installable Driver Support
;
; Driver Messages
DRV_LOAD	    = 0001h
DRV_ENABLE	    = 0002h
DRV_OPEN	    = 0003h
DRV_CLOSE	    = 0004h
DRV_DISABLE	    = 0005h
DRV_FREE	    = 0006h
DRV_CONFIGURE	    = 0007h
DRV_QUERYCONFIGURE  = 0008h
DRV_INSTALL	    = 0009h
DRV_REMOVE	    = 000Ah
DRV_EXITSESSION	    = 000Bh
DRV_POWER	    = 000Fh
DRV_QUERYENDSESSION = 0010h
DRV_EXITSESSIONCANCELLED = 0011h
DRV_RESERVED	    = 0800h
DRV_USER	    = 4000h

;LPARAM of DRV_CONFIGURE message and return values
DRVCONFIGINFO struc
    DRVCNF_dwDCISize	      dw ?
    DRVCNF_lpszDCISectionName dd ?
    DRVCNF_lpszDCIAliasName   dd ?
DRVCONFIGINFO ends

DRVCNF_CANCEL	    = 0000h
DRVCNF_OK	    = 0001h
DRVCNF_RESTART	    = 0002h




IFNDEF  NOKERNEL
;
; Common Kernel errors
; 
ERR_GALLOC	= 01030h	; GlobalAlloc Failed
ERR_GREALLOC	= 01031h	; GlobalReAlloc Failed
ERR_GLOCK	= 01032h	; GlobalLock Failed
ERR_LALLOC	= 01033h	; LocalAlloc Failed
ERR_LREALLOC	= 01034h	; LocalReAlloc Failed
ERR_LLOCK	= 01035h	; LocalLock Failed
ERR_ALLOCRES	= 01036h	; AllocResource Failed
ERR_LOCKRES	= 01037h	; LockResource Failed
ERR_LOADMODULE  = 01038h	; LoadModule failed

;
; Common User Errors 
;
ERR_CREATEDLG	     =	01045h ; /* Create Dlg failure due to LoadMenu failure */
ERR_CREATEDLG2	     =	01046h ; /* Create Dlg failure due to CreateWindow Failure */
ERR_REGISTERCLASS    =	01047h ; /* RegisterClass failure due to Class already registered */
ERR_DCBUSY	     =	01048h ; /* DC Cache is full */
ERR_CREATEWND	     =	01049h ; /* Create Wnd failed due to class not found */
ERR_STRUCEXTRA	     =  01050h ; /* Unallocated Extra space is used */
ERR_LOADSTR	     =	01051h ; /* LoadString() failed */
ERR_LOADMENU	     =	01052h ; /* LoadMenu Failed     */
ERR_NESTEDBEGINPAINT =  01053h ; /* Nested BeginPaint() calls */
ERR_BADINDEX	     =  01054h ; /* Bad index to Get/Set Class/Window Word/Long */
ERR_CREATEMENU	     =	01055h ; /* Error creating menu */

;
; Common GDI Errors
;
ERR_CREATEDC	    = 01070h	; /* CreateDC/CreateIC etc., failure */
ERR_CREATEMETA      = 01071h	; /* CreateMetafile failure */
ERR_DELOBJSELECTED  = 01072h	; /* Bitmap being deleted is selected into DC */
ERR_SELBITMAP	    = 01073h	; /* Bitmap being selected is already selected elsewhere */

ENDIF	    ;NOKERNEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\win32.h ===
/****************************************************************************
 *
 *  Win32.h
 *
 *  Windows 16/32 porting helper file
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#ifndef INC_OLE2
#define INC_OLE2
#endif

#ifndef INC_WIN32_H
#define INC_WIN32_H  // Protect against double inclusion of this file

#if !defined(WIN32) && defined(_WIN32)
    #define WIN32
#endif

#if !defined(DEBUG) && defined(_DEBUG)
    #define DEBUG
#endif


#ifdef WIN32

// Set up a single define to allow CHICAGO or NT (Daytona)
#ifdef UNICODE // Could use WINVER <= 0x400 ...
    #define DAYTONA
    #undef CHICAGO
#else
    #ifndef CHICAGO
        #define CHICAGO
    #endif
    #undef  DAYTONA
#endif // UNICODE

#ifndef RC_INVOKED
    #pragma warning(disable:4103)
#endif
    #define	_INC_OLE

#else  // 16 bit compilation - must be Chicago

    #ifndef CHICAGO
    #define	CHICAGO
    #endif

#endif  // WIN32

#if !defined(_INC_WINDOWS) || !defined(_WINDOWS)
#include <windows.h>
#include <windowsx.h>
#if WINVER >= 0x400
#include <winerror.h>
#endif
#include <mmsystem.h>
#endif // INC_WINDOWS...

#ifndef EXTERN_C
#ifdef __cplusplus
	#define EXTERN_C extern "C"
#else
	#define EXTERN_C extern
#endif
#endif

// Not just for Daytona, things like mciavi define WINVER=0x30a
#ifndef WS_EX_RIGHT
        #define WS_EX_RIGHT             0x00001000L     // ;Internal 4.0
        #define WS_EX_LEFT              0x00000000L     // ;Internal 4.0
        #define WS_EX_RTLREADING        0x00002000L     // ;Internal 4.0
        #define WS_EX_LTRREADING        0x00000000L     // ;Internal 4.0
        #define WS_EX_LEFTSCROLLBAR     0x00004000L     // ;Internal 4.0
        #define WS_EX_RIGHTSCROLLBAR    0x00000000L     // ;Internal 4.0
#endif

// Win 16 and Win 32 use different macros to turn code debugging on/off
// Map the 16 bit version to the NT conventions.
// In particular on NT, debug builds are identified by DBG==1  (and retail
// with DBG==0), hence the NT only source uses #if DBG.  Note: #ifdef DBG
// is ALWAYS true on NT.
// Chicago (and VFW 16 bit code) uses #ifdef DEBUG.  The complex of
// instructions below should ensure that whether this is Chicago or NT that
//    a debug build implies DEBUG defined and DBG==1
//    a retail build implies DEBUG NOT defined, and DBG==0

#ifdef WIN32
#ifndef DBG
#ifdef DEBUG
    #define DBG 1
#else
    #define DBG 0
#endif
#endif

#undef DEBUG

#if DBG
    #define DEBUG
    #define STATICFN
    #define STATICDT
#else
    #define STATICFN static
    #define STATICDT static
#endif

#else    // !WIN32
    #define STATICFN static
    #define STATICDT static
#endif //WIN32

#define FASTCALL  __fastcall
#define _FASTCALL __fastcall

#if !defined NUMELMS
#define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif


#ifdef WIN32

/* --- Win32 version --------------------------------------------------- */

        #include <string.h>
        #include <memory.h>

        #undef CDECL
#ifdef MIPS
	#define __stdcall
	#define _stdcall
	#define _cdecl
	#define __cdecl
        #define CDECL
#else
        #define CDECL _cdecl
#endif

    //typedef BITMAPINFOHEADER FAR *LPBITMAPINFOHEADER;

	#define far
	#define _far
	#define __far
	#define HUGE_T
	#define HUGE
	#define huge
	#define _huge
	#define __huge
	#define near
	#define _near
        #define __near
        #define _fastcall
        #define __fastcall
	#define _loadds
	#define __loadds
	#define _LOADDS
	#define LOADDS
        #define _export     //should _export be blank?
	#define __export
	#define EXPORT
        #define _based(x)
	#define __based(x)
        #define _based32(x)
        #define __based32(x)

        #ifdef _X86_
        // __inline provides speed improvements for x86 platforms.  Unfortunately
        // the MIPS compiler does not have inline support.  Alpha is unknown, so
        // we do not assume and play it safe.
        #define INLINE   __inline
        #define inline   __inline
        #define _inline  __inline
        #else
        #define INLINE
        #define inline
        #define _inline
        #define __inline
        #endif

	//typedef RGBQUAD FAR *LPRGBQUAD;

        #ifdef DAYTONA
        typedef LRESULT (*DRIVERPROC)(DWORD, HDRVR, UINT, WPARAM, LPARAM);
        #endif

        #define GetCurrentTask()    (HTASK)GetCurrentThreadId()

        #define WF_PMODE        0x0001
        #define WF_CPU286       0x0002
        #define WF_CPU386       0x0004
        #define WF_CPU486       0x0008
        #define WF_80x87        0x0400
        #define WF_PAGING       0x0800

        #define GetWinFlags()   (WF_PMODE|WF_CPU486|WF_PAGING|WF_80x87)
	
        //#define hmemcpy  memcpy
        #define _fmemcpy memcpy
        #define _fmemset memset
	//#define lstrcpyn(dest, source, cb)  ( strncpy(dest, source, cb), ((char *) dest) [cb - 1] = 0)

	//!!! should use LARGE_INTEGER stuff.
	#define muldiv32                MulDiv
	#define muldivru32(a,b,c)       (long)(((double)(a) * (double)(b) + (double)((c)-1)) / (double)(c))
	#define muldivrd32(a,b,c)       (long)(((double)(a) * (double)(b)) / (double)(c))

	#define IsTask(x) ((x) != 0)
	#define IsGDIObject(obj) (GetObjectType((HGDIOBJ)(obj)) != 0)
	
	#define SZCODEA CHAR
	#define SZCODE  TCHAR
        typedef TCHAR * NPTSTR;

#ifndef UNICODE
// !!!!!!! need lstrcpyW, lstrlenW, wsprintfW, lstrcpynW for Chicago!
#endif
	
#else

/* --- Win16 version --------------------------------------------------- */

        #include <string.h>
        #include <memory.h>

	#define SZCODEA SZCODE
        typedef char  TCHAR;
        typedef WORD  WCHAR;
        typedef NPSTR NPTSTR;
        typedef LPSTR LPTSTR;
	typedef LPSTR LPOLESTR;
	typedef LPCSTR LPCOLESTR;
	typedef char  OLECHAR;
	
	typedef int   INT;

	#define _LOADDS _loadds
	#define LOADDS	_loadds
	#define EXPORT	_export

	#define HUGE	_huge

        #define DRIVERS_SECTION "Drivers"
        #define MCI_SECTION "MCI"
        #define MCIAVI_SECTION "MCIAVI"
	#define TEXT(sz) sz

	// stuff in muldiv32.asm
	EXTERN_C  LONG FAR PASCAL muldiv32(LONG,LONG,LONG);
	EXTERN_C  LONG FAR PASCAL muldivru32(LONG,LONG,LONG);
        EXTERN_C  LONG FAR PASCAL muldivrd32(LONG,LONG,LONG);

        #define UNALIGNED
        #define INLINE __inline
        #define CharPrev AnsiPrev

        /*
         * define these so we can explicitly use Ansi or Unicode versions
         * in the NT code, and the standard entry point for Win16.
         */
        #define SetWindowTextA                  SetWindowText
        #define GetProfileStringA               GetProfileString
        #define GetPrivateProfileStringA        GetPrivateProfileString
        #define GetProfileIntA                  GetProfileInt
        #define GetModuleHandleA                GetModuleHandle
        #define GetModuleFileNameA              GetModuleFileName
        #define wvsprintfA                      wvsprintf
        #define wsprintfA                       wsprintf
        #define lstrcmpA                        lstrcmp
        #define lstrcmpiA                       lstrcmpi
        #define lstrcpyA                        lstrcpy
        #define lstrcatA                        lstrcat
        #define lstrlenA                        lstrlen
        #define LoadStringA                     LoadString
        #define LoadStringW                     LoadString
        #define OutputDebugStringA              OutputDebugString
        #define MessageBoxA                     MessageBox

	// Needed for writing OLE-style code that builds 16/32....
	#define lstrcpyW lstrcpy
	#define lstrcpynW lstrcpyn
	#define lstrlenW lstrlen

	#define SZCODE char _based(_segname("_CODE"))
	#define LPCWSTR      LPCSTR
	#define LPCTSTR      LPCSTR
	#define LPWSTR       LPSTR
        #define PTSTR        PSTR

/****** Alternate porting layer macros ****************************************/

#ifndef GET_WPARAM

    /* USER MESSAGES: */

    #define GET_WPARAM(wp, lp)                      (wp)
    #define GET_LPARAM(wp, lp)                      (lp)

    #define GET_WM_ACTIVATE_STATE(wp, lp)               (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)          (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)                (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)   \
            (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)              (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)               HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd) \
            (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)                   (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)                 (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)                  HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
            (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define WM_CTLCOLORMSGBOX       0x0132
    #define WM_CTLCOLOREDIT         0x0133
    #define WM_CTLCOLORLISTBOX      0x0134
    #define WM_CTLCOLORBTN          0x0135
    #define WM_CTLCOLORDLG          0x0136
    #define WM_CTLCOLORSCROLLBAR    0x0137
    #define WM_CTLCOLORSTATIC       0x0138

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)            (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)           (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)           HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type) \
            (WPARAM)(hdc), MAKELONG(hwnd, type)


    #define GET_WM_MENUSELECT_CMD(wp, lp)               (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)             LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)             (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)  \
            (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)
    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA)\
            (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW) 0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)                (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)               (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)               (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)    \
            (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)             (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)              HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)       (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)               (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)               (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd) \
            (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y) \
            (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)              (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)              (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) \
            (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)                 LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)                   HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd) \
            0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)     \
            0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)       (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)                 (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)                  LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)    \
            (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)                 (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)                  LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
            (WPARAM)(code), MAKELONG(pos, hwnd)

#endif  // !GET_WPARAM

#endif  // !WIN32

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\windisk.h ===
/*
 * PLEASE NOTE: WINDISK is the file "WINDISK.CPL", this means
 *		you cannot implicit link to these APIs by simply
 *		linking with WINDISK.LIB. This is because KERNEL
 *		will only implicit link to module file names with
 *		the .DLL or .EXE extensions.
 *
 *		To use these APIs you need to LoadLibrary("WINDISK.CPL")
 *		and then use GetProcAddress.
 *
 *		  WDFMTDRVPROC lpfnFmtDrv;
 *		  HINSTANCE wdInst;
 *
 *		  wdInst = LoadLibrary("WINDISK.CPL");
 *		  if (wdInst) {
 *		    lpfnFmtDrv = (WDFMTDRVPROC)GetProcAddress(wdInst,"WinDisk_FormatDrive");
 *		    if (HIWORD(lpfnFmtDrv)) {
 *		      switch ((*lpfnFmtDrv)(hwnd, drive, WD_FMTID_DEFAULT, WD_FMT_OPT_FULL)) {
 *
 *			  case WD_FMT_ERROR:
 *
 *			  ...
 *
 *		      }
 *		      FreeLibrary(wdInst);
 *		    } else {
 *		      FreeLibrary(wdInst);
 *		      goto NoLib;
 *		    }
 *		  } else {
 *		NoLib:
 *
 *		WINDISK.LIB is provided for completeness only (and also
 *		allows you to figure out the ordinal, note that
 *		GetProcAddress "by name" is recommended however).
 */

/*
 * The WinDisk_FormatDrive API provides access to the WINDISK
 *   format dialog. This allows apps which want to format disks
 *   to bring up the same dialog that WINDISK does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FormatDrive
 *   engine.
 *
 *   NOTE that the user can format as many diskettes in the specified
 *   drive, or as many times, as he/she wishes to. There is no way to
 *   force any specififc number of disks to format. If you want this
 *   ability, you will have to write your own front end for the
 *   DMaint_FormatDrive engine.
 *
 *   NOTE also that the format will not start till the user pushes the
 *   start button in the dialog. There is no way to do auto start. If
 *   you want this ability, you will have to write your own front end
 *   for the DMaint_FormatDrive engine.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *     drive   = The 0 based (A: == 0) drive number of the drive to format
 *     fmtID   = The ID of the physical format to format the disk with
 *		 NOTE: The special value WD_FMTID_DEFAULT means "use the
 *		       default format specified by the DMaint_FormatDrive
 *		       engine". If you want to FORCE a particular format
 *		       ID "up front" you will have to call
 *		       DMaint_GetFormatOptions yourself before calling
 *		       this to obtain the valid list of phys format IDs
 *		       (contents of the PhysFmtIDList array in the
 *		       FMTINFOSTRUCT).
 *     options = There is currently only one option bit defined
 *
 *		  WD_FMT_OPT_FULL
 *
 *		 The normal defualt in the WINDISK format dialog is
 *		 "Quick Format", setting this option bit indicates that
 *		 the caller wants to start with FULL format selected
 *		 (this is useful for folks detecting "unformatted" disks
 *		 and wanting to bring up the format dialog).
 *
 *		 All other bits are reserved for future expansion and
 *		 must be 0.
 *
 *		 Please note that this is a bit field and not a value
 *		 and treat it accordingly.
 *
 *   RETURN
 *	The return is either one of the WD_FMT_* values, or if the
 *	returned DWORD value is not == to one of these values, then
 *	the return is the physical format ID of the last succesful
 *	format. The LOWORD of this value can be passed on subsequent
 *	calls as the fmtID parameter to "format the same type you did
 *	last time".
 *
 */
DWORD WINAPI WinDisk_FormatDrive(HWND hwnd, WORD drive, WORD fmtID,
				 WORD options);

typedef DWORD (CALLBACK* WDFMTDRVPROC)(HWND,WORD,WORD,WORD);

//
// Special value of fmtID which means "use the default format"
//
#define WD_FMTID_DEFAULT    0xFFFF

//
// Option bits for options parameter
//
#define WD_FMT_OPT_FULL     0x0001

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define WD_FMT_ERROR	0xFFFFFFFFL	// Error on last format, drive may be formatable
#define WD_FMT_CANCEL	0xFFFFFFFEL	// Last format was canceled
#define WD_FMT_NOFORMAT 0xFFFFFFFDL	// Drive is not formatable


/*
 * The WinDisk_CheckDrive API provides access to the WINDISK
 *   Check Disk dialog. This allows apps which want to check disks
 *   to bring up the same dialog that WINDISK does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FixDrive
 *   engine.
 *
 *   NOTE that the check will not start till the user pushes the
 *   start button in the dialog unless the CHKOPT_AUTO option is set.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *     options = These options basically coorespond to the check boxes
 *		 in the Advanced Options dialog. See CHKOPT_ defines
 *		 below.
 *     DrvList = This is a DWORD bit field which indicates the 0 based
 *		 drive numbers to check. Bit 0 = A, Bit 1 = B, ...
 *		 For use on this API at least one bit must be set (if
 *		 this argument is 0, the call will return WD_CHK_NOCHK).
 *
 *   RETURN
 *	The return is either one of the WD_CHK_* values.
 *
 */
DWORD WINAPI WinDisk_CheckDrive(HWND hwnd, WORD options, DWORD DrvList);


typedef DWORD (CALLBACK* WDCHKDRVPROC)(HWND,WORD,DWORD);

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define WD_CHK_ERROR	0xFFFFFFFFL	// Fatal Error on check
#define WD_CHK_CANCEL	0xFFFFFFFEL	// Check was canceled
#define WD_CHK_NOCHK	0xFFFFFFFDL	// At least one Drive is not "checkable"
#define WD_CHK_SMNOTFIX 0xFFFFFFFCL	// Some errors were not fixed

//
// Option bits
//
// IMPORTANT NOTE: These are set up so that the default setting is 0
//		   for all bits WITH ONE EXCEPTION. Currently the default
//		   setting has the CHKOPT_XLCPY bit set......
//
// Also note that specification of invalid combonations of bits (for example
// setting both CHKOPT_XLCPY and CHKOPT_XLDEL) will result in very random
// behavior.
//
#define CHKOPT_REP	       0x0001	// Generate detail report
#define CHKOPT_RO	       0x0002	// Run in preview mode
#define CHKOPT_NOSYS	       0x0004	// Surf Anal don't check system area
#define CHKOPT_NODATA	       0x0008	// Surf Anal don't check data area
#define CHKOPT_NOBAD	       0x0010	// Disable Surface Analysis
#define CHKOPT_LSTMF	       0x0020	// Convert lost clusters to files
#define CHKOPT_NOCHKNM	       0x0040	// Don't check file names
#define CHKOPT_NOCHKDT	       0x0080	// DOn't check date/time fields
#define CHKOPT_INTER	       0x0100	// Interactive mode
#define CHKOPT_XLCPY	       0x0200	// Def cross link resolution is COPY
#define CHKOPT_XLDEL	       0x0400	// Def cross link resolution is DELETE
#define CHKOPT_ALLHIDSYS       0x0800	// All HID SYS files are unmovable
#define CHKOPT_NOWRTTST        0x1000	// Surf Anal no write testing.
#define CHKOPT_DRVLISTONLY     0x4000	// Normaly all drives in the system
					// are shown in the drive list box
					// and those on the DrvList are selected
					// This option says put only the drives
					// in DrvList in the list box and
					// disable the control
#define CHKOPT_AUTO	       0x8000	// Auto push start button

/*
 * The WinDisk_GetBigDriveBM API provides access to the drive bitmaps
 *   WINDISK uses in its main drive dialogs.
 *
 *   These bitmaps are intended for dialogs, and are intended
 *   to have a "chart" drawn on top of them. WINDISK draws
 *   the Used/Free chart. This chart is intended to look like
 *   the disk inside the drive.
 *
 *   These bitmaps are placed on a background of COLOR_DIALOG. There
 *   is no way to change this mapping color.
 *
 *   The returned HBITMAP belongs to the calling app, it is up to the
 *   caller to call DeleteObject on it to free it.
 *
 *   PARAMETERS
 *
 *     drive   = The 0 based (A: == 0) drive number of the drive to get
 *		 the drive bitmap of.
 *     lpChrt  -> an array of 9 words whose format and meaning
 *		  depends on the returned "chart style" type
 *     options = There are currently no options defined this param should
 *		 be zero. This field is reserved for future expansion.
 *
 *   RETURN
 *	The return is 0 if the bitmap could not be loaded (memory or
 *	invalid drive).
 *
 *	If the return is non-zero, the LOWORD is an HBITMAP,
 *	and the HIWORD is a "chart style" ID which defines the
 *	format of the data placed at lpChrt and the style for
 *	the chart placed on top of the bitmap by WINDISK.
 *
 *	 USETYPE_NONE	is for never-writable drives (like CD-ROM).
 *			lpChrt data is not used.
 *	 USETYPE_ELLIPS is for circular type drives (Fixed,Floppy).
 *	 USETYPE_BARH	is a horizontal parallelogram (RAMDrive).
 *	 USETYPE_BARV	is a verticle parallelogram.
 *
 * lpChrt[0] word is the "3-D effect" height/width for the parallelogram or
 *   ellips. NOTE that the 3-D effect is disabled if the height/width
 *   is 0. Also note that with 3-D effect disabled, the parallelogram
 *   can be turned into a rectangle.
 *
 * For USETYPE_ELLIPS, the next four words (lpChrt[1],lpChrt[2],lpChrt[3]
 *   and lpChrt[4]) form a RECT structure which defines the bounding
 *   rect for the ellips (including the 3-D effect). This RECT is in
 *   coordinates of the returned bitmap (0,0 corresponds to the top
 *   leftmost pixel of the bitmap).
 *
 * For USETYPE_BARH or USETYPE_BARV the 8 words starting at lpChrt[1]
 *   are four POINT structures which define a parallelogram for the
 *   chart (NOT including the 3-D effect).
 *
 *    POINT 0 is at lpChrt[1]
 *    POINT 1 is at lpChrt[3]
 *    POINT 2 is at lpChrt[5]
 *    POINT 3 is at lpChrt[7]
 *
 *    the "3-D->" in the following indicate the sides that the 3-D effect
 *    is drawn on. And the numbers are the point array
 *    indexes.
 *
 *	 USETYPE_BARH (0.y)==(1.y) and (3.y)==(2.y)
 *
 *	       0 _____________ 1
 *		 \ 	      \
 *	    3-D-> \ 	       \
 *		   \ 		\
 *		  3 ------------- 2
 *			  ^
 *			 3-D
 *
 *	 USETYPE_BARV (0.x)==(3.x) and (1.x)==(2.x)
 *
 *		     1
 *		  /|
 *		 / |
 *		/  |
 *	     0 |   |
 *	       |   |
 *	       |   | <- 3-D
 *	       |   |
 *	       |   |
 *	       |   |
 *	       |   |
 *	       |   | 2
 *	       |  /
 *	       | / <- 3-D
 *	       |/
 *
 *	       3
 *
 */
DWORD WINAPI WinDisk_GetBigDriveBM(WORD drive, LPWORD lpChrt, WORD options);

typedef DWORD (CALLBACK* WDGETBDBMPROC)(WORD,LPWORD,WORD);

//
// HIWORD return "chart type" values
//
#define USETYPE_ELLIPS	0
#define USETYPE_BARV	1
#define USETYPE_BARH	2
#define USETYPE_NONE	3

/*
 * The WinDisk_PropSheet API provides access to the main drive
 *   dialog.
 *
 *   This API is intended for the SHELL so it can bring up a
 *   drive property sheet.
 *
 *   PARAMETERS
 *
 *     drive   = The 0 based (A: == 0) drive number of the drive to bring
 *		 up the property dialog for.
 *     hwnd    = The HWND which will own the dialog
 *     options = There are currently no options defined this param should
 *		 be zero. This field is reserved for future expansion.
 *
 *   RETURN
 *	The return is -2 if the drive number is invalid.
 *	Else the return is the return from a DialogBox call to bring
 *	up the dialog. NOTE that -1 means that the DialogBox failed.
 *
 */
int WINAPI WinDisk_PropSheet(int drive, HWND hwndpar, WORD options);

typedef int (CALLBACK* WDPROPSHEET)(int,HWND,WORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\windefs.inc ===
;***************************************************************************
;                                                                          *
;   Copyright (C) 1983-1994 by Microsoft Inc.				    *
;                                                                          *
;***************************************************************************

;       Macros for disabling and restoring hardware interrupt enable flag
;
;       The LeaveCrit macro has been updated for the mask problem on
;       the 80286 processor.


EnterCrit   MACRO
        pushf
        cli
ENDM

LeaveCrit   macro   reg 		;;this macro will restore the state of
ifnb	<reg>				;;the interrupt flag to what is was
	pop	reg&x			;;before EnterCrit.  All other flags
	test	reg&h, 2		;;are discarded.
	jz	@f
	sti
@@:
else
	push	bp
	mov	bp, sp
	test	byte ptr [bp+3], 2
	jz	@f
	sti
@@:
	pop	bp
	popf
endif
	endm


if 0
POPFF	equ	<LeaveCrit>

LeaveCrit   MACRO
        POPFF
ENDM
endif

POPFF	MACRO				;;this macro will restore ALL flags,
	local	a			;;EXCEPT the interrupt flag, to
	jmp	$+3			;;their previous state
a       label   near
        iret
        push    cs
        call    a
ENDM




;***************************************************************************
;                                                                          *
;   Inquire data structures for Timer, Keyboard, Mouse and Cursor modules  *
;                                                                          *
;***************************************************************************

TIMERINFO       STRUC
tiResolution    DD      0       ; #microseconds each timer tick
TIMERINFO       ENDS

KBINFO          STRUC
kbRanges        DB      4 dup (0)  ; Far East ranges for KANJI
kbStateSize     DW      0       ; #bytes of state info maintained by TOASCII
KBINFO          ENDS


MOUSEINFO       STRUC
msExists        DB      0       ; true => mouse exists
msRelative      DB      0       ; true => relative coordinate
msNumButtons    DW      0       ; number of buttons on the mouse
msRate          DW      0       ; maximum rate of mouse input events
msXThresh       DW      0       ; threshold before acceleration
msYThresh       DW      0       ;
msXRes          DW      0       ; x resolution
msYRes          DW      0       ; y resolution
MOUSEINFO       ENDS


CURSORINFO      STRUC
dpXRate         DW      0       ; horizontal mickey/pixel ratio
dpYRate         DW      0       ; vertical mickey/pixel ratio
CURSORINFO      ENDS


;***************************************************************************
;                                                                          *
; Cursor data structure passed to OEM routines.  Defines a graphics display*
; cursor in terms of a hotspot, an AND mask and an XOR mask.  The hot      *
; spot defines the pixel within the cursor that is the cursor is "pointing"*
; to.  So when displaying a cursor at location X,Y the pixel that          *
; is the hot spot should be painted at that X,Y coordinate.  The "shape"   *
; of the cursor is defined by two pixel masks.  The first mask is ANDed    *
; with the bits in the display bitmap and the second mask is XORed with    *
; the result to determine the bits that will be placed in the display      *
; bitmap.  The bits for the masks are in the byte array that begins        *
; at the csBits field, with the AND mask bits first, followed by the       *
; XOR mask bits.  The csWidthBytes field is the width of ONE mask, in      *
; bytes.  Currently, MS-WIN will only generate cursors whose width and     *
; height are both 16.                                                      *
;                                                                          *
;***************************************************************************

cursorShape     STRUC
csHotX          DW      0
csHotY          DW      0
csWidth         DW      0
csHeight        DW      0
csWidthBytes    DW      0
csColor         DW      0
    ; Beginning of an array of bytes that contain the bits for the AND and
    ; XOR masks.  The first csHeight * csWidthBytes bytes contain the bits
    ; for the AND mask and the next csHeight * csWidthBytes bytes contain
    ; the bits for the XOR mask.
;csBits          DB  2*2*16 DUP (?)
cursorShape     ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\winerror.h ===
/************************************************************************
*                                                                       *
*   winerror.h --  error code definitions for the Win32 API functions   *
*                                                                       *
*   Copyright (c) 1991-1994, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef _WINERROR_
#define _WINERROR_


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: NO_ERROR
//
// MessageText:
//
//  NO_ERROR
//
#define NO_ERROR                         0L    // dderror

//
// MessageId: ERROR_SUCCESS
//
// MessageText:
//
//  The configuration registry database operation completed successfully.
//
#define ERROR_SUCCESS                    0L

//
// MessageId: ERROR_INVALID_FUNCTION
//
// MessageText:
//
//  Incorrect function.
//
#define ERROR_INVALID_FUNCTION           1L    // dderror

//
// MessageId: ERROR_FILE_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the file specified.
//
#define ERROR_FILE_NOT_FOUND             2L

//
// MessageId: ERROR_PATH_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the path specified.
//
#define ERROR_PATH_NOT_FOUND             3L

//
// MessageId: ERROR_TOO_MANY_OPEN_FILES
//
// MessageText:
//
//  The system cannot open the file.
//
#define ERROR_TOO_MANY_OPEN_FILES        4L

//
// MessageId: ERROR_ACCESS_DENIED
//
// MessageText:
//
//  Access is denied.
//
#define ERROR_ACCESS_DENIED              5L

//
// MessageId: ERROR_INVALID_HANDLE
//
// MessageText:
//
//  The handle is invalid.
//
#define ERROR_INVALID_HANDLE             6L

//
// MessageId: ERROR_ARENA_TRASHED
//
// MessageText:
//
//  The storage control blocks were destroyed.
//
#define ERROR_ARENA_TRASHED              7L

//
// MessageId: ERROR_NOT_ENOUGH_MEMORY
//
// MessageText:
//
//  Not enough storage is available to process this command.
//
#define ERROR_NOT_ENOUGH_MEMORY          8L    // dderror

//
// MessageId: ERROR_INVALID_BLOCK
//
// MessageText:
//
//  The storage control block address is invalid.
//
#define ERROR_INVALID_BLOCK              9L

//
// MessageId: ERROR_BAD_ENVIRONMENT
//
// MessageText:
//
//  The environment is incorrect.
//
#define ERROR_BAD_ENVIRONMENT            10L

//
// MessageId: ERROR_BAD_FORMAT
//
// MessageText:
//
//  An attempt was made to load a program with an
//  incorrect format.
//
#define ERROR_BAD_FORMAT                 11L

//
// MessageId: ERROR_INVALID_ACCESS
//
// MessageText:
//
//  The access code is invalid.
//
#define ERROR_INVALID_ACCESS             12L

//
// MessageId: ERROR_INVALID_DATA
//
// MessageText:
//
//  The data is invalid.
//
#define ERROR_INVALID_DATA               13L

//
// MessageId: ERROR_OUTOFMEMORY
//
// MessageText:
//
//  Not enough storage is available to complete this operation.
//
#define ERROR_OUTOFMEMORY                14L

//
// MessageId: ERROR_INVALID_DRIVE
//
// MessageText:
//
//  The system cannot find the drive specified.
//
#define ERROR_INVALID_DRIVE              15L

//
// MessageId: ERROR_CURRENT_DIRECTORY
//
// MessageText:
//
//  The directory cannot be removed.
//
#define ERROR_CURRENT_DIRECTORY          16L

//
// MessageId: ERROR_NOT_SAME_DEVICE
//
// MessageText:
//
//  The system cannot move the file
//  to a different disk drive.
//
#define ERROR_NOT_SAME_DEVICE            17L

//
// MessageId: ERROR_NO_MORE_FILES
//
// MessageText:
//
//  There are no more files.
//
#define ERROR_NO_MORE_FILES              18L

//
// MessageId: ERROR_WRITE_PROTECT
//
// MessageText:
//
//  The media is write protected.
//
#define ERROR_WRITE_PROTECT              19L

//
// MessageId: ERROR_BAD_UNIT
//
// MessageText:
//
//  The system cannot find the device specified.
//
#define ERROR_BAD_UNIT                   20L

//
// MessageId: ERROR_NOT_READY
//
// MessageText:
//
//  The device is not ready.
//
#define ERROR_NOT_READY                  21L

//
// MessageId: ERROR_BAD_COMMAND
//
// MessageText:
//
//  The device does not recognize the command.
//
#define ERROR_BAD_COMMAND                22L

//
// MessageId: ERROR_CRC
//
// MessageText:
//
//  Data error (cyclic redundancy check)
//
#define ERROR_CRC                        23L

//
// MessageId: ERROR_BAD_LENGTH
//
// MessageText:
//
//  The program issued a command but the
//  command length is incorrect.
//
#define ERROR_BAD_LENGTH                 24L

//
// MessageId: ERROR_SEEK
//
// MessageText:
//
//  The drive cannot locate a specific
//  area or track on the disk.
//
#define ERROR_SEEK                       25L

//
// MessageId: ERROR_NOT_DOS_DISK
//
// MessageText:
//
//  The specified disk or diskette cannot be accessed.
//
#define ERROR_NOT_DOS_DISK               26L

//
// MessageId: ERROR_SECTOR_NOT_FOUND
//
// MessageText:
//
//  The drive cannot find the sector requested.
//
#define ERROR_SECTOR_NOT_FOUND           27L

//
// MessageId: ERROR_OUT_OF_PAPER
//
// MessageText:
//
//  The printer is out of paper.
//
#define ERROR_OUT_OF_PAPER               28L

//
// MessageId: ERROR_WRITE_FAULT
//
// MessageText:
//
//  The system cannot write to the specified device.
//
#define ERROR_WRITE_FAULT                29L

//
// MessageId: ERROR_READ_FAULT
//
// MessageText:
//
//  The system cannot read from the specified device.
//
#define ERROR_READ_FAULT                 30L

//
// MessageId: ERROR_GEN_FAILURE
//
// MessageText:
//
//  A device attached to the system is not functioning.
//
#define ERROR_GEN_FAILURE                31L

//
// MessageId: ERROR_SHARING_VIOLATION
//
// MessageText:
//
//  The process cannot access the file because
//  it is being used by another process.
//
#define ERROR_SHARING_VIOLATION          32L

//
// MessageId: ERROR_LOCK_VIOLATION
//
// MessageText:
//
//  The process cannot access the file because
//  another process has locked a portion of the file.
//
#define ERROR_LOCK_VIOLATION             33L

//
// MessageId: ERROR_WRONG_DISK
//
// MessageText:
//
//  The wrong diskette is in the drive.
//  Insert %2 (Volume Serial Number: %3)
//  into drive %1.
//
#define ERROR_WRONG_DISK                 34L

//
// MessageId: ERROR_SHARING_BUFFER_EXCEEDED
//
// MessageText:
//
//  Too many files opened for sharing.
//
#define ERROR_SHARING_BUFFER_EXCEEDED    36L

//
// MessageId: ERROR_HANDLE_EOF
//
// MessageText:
//
//  Reached end of file.
//
#define ERROR_HANDLE_EOF                 38L

//
// MessageId: ERROR_HANDLE_DISK_FULL
//
// MessageText:
//
//  The disk is full.
//
#define ERROR_HANDLE_DISK_FULL           39L

//
// MessageId: ERROR_NOT_SUPPORTED
//
// MessageText:
//
//  The network request is not supported.
//
#define ERROR_NOT_SUPPORTED              50L

//
// MessageId: ERROR_REM_NOT_LIST
//
// MessageText:
//
//  The remote computer is not available.
//
#define ERROR_REM_NOT_LIST               51L

//
// MessageId: ERROR_DUP_NAME
//
// MessageText:
//
//  A duplicate name exists on the network.
//
#define ERROR_DUP_NAME                   52L

//
// MessageId: ERROR_BAD_NETPATH
//
// MessageText:
//
//  The network path was not found.
//
#define ERROR_BAD_NETPATH                53L

//
// MessageId: ERROR_NETWORK_BUSY
//
// MessageText:
//
//  The network is busy.
//
#define ERROR_NETWORK_BUSY               54L

//
// MessageId: ERROR_DEV_NOT_EXIST
//
// MessageText:
//
//  The specified network resource is no longer
//  available.
//
#define ERROR_DEV_NOT_EXIST              55L

//
// MessageId: ERROR_TOO_MANY_CMDS
//
// MessageText:
//
//  The network BIOS command limit has been reached.
//
#define ERROR_TOO_MANY_CMDS              56L

//
// MessageId: ERROR_ADAP_HDW_ERR
//
// MessageText:
//
//  A network adapter hardware error occurred.
//
#define ERROR_ADAP_HDW_ERR               57L

//
// MessageId: ERROR_BAD_NET_RESP
//
// MessageText:
//
//  The specified server cannot perform the requested
//  operation.
//
#define ERROR_BAD_NET_RESP               58L

//
// MessageId: ERROR_UNEXP_NET_ERR
//
// MessageText:
//
//  An unexpected network error occurred.
//
#define ERROR_UNEXP_NET_ERR              59L

//
// MessageId: ERROR_BAD_REM_ADAP
//
// MessageText:
//
//  The remote adapter is not compatible.
//
#define ERROR_BAD_REM_ADAP               60L

//
// MessageId: ERROR_PRINTQ_FULL
//
// MessageText:
//
//  The printer queue is full.
//
#define ERROR_PRINTQ_FULL                61L

//
// MessageId: ERROR_NO_SPOOL_SPACE
//
// MessageText:
//
//  Space to store the file waiting to be printed is
//  not available on the server.
//
#define ERROR_NO_SPOOL_SPACE             62L

//
// MessageId: ERROR_PRINT_CANCELLED
//
// MessageText:
//
//  Your file waiting to be printed was deleted.
//
#define ERROR_PRINT_CANCELLED            63L

//
// MessageId: ERROR_NETNAME_DELETED
//
// MessageText:
//
//  The specified network name is no longer available.
//
#define ERROR_NETNAME_DELETED            64L

//
// MessageId: ERROR_NETWORK_ACCESS_DENIED
//
// MessageText:
//
//  Network access is denied.
//
#define ERROR_NETWORK_ACCESS_DENIED      65L

//
// MessageId: ERROR_BAD_DEV_TYPE
//
// MessageText:
//
//  The network resource type is not correct.
//
#define ERROR_BAD_DEV_TYPE               66L

//
// MessageId: ERROR_BAD_NET_NAME
//
// MessageText:
//
//  The network name cannot be found.
//
#define ERROR_BAD_NET_NAME               67L

//
// MessageId: ERROR_TOO_MANY_NAMES
//
// MessageText:
//
//  The name limit for the local computer network
//  adapter card was exceeded.
//
#define ERROR_TOO_MANY_NAMES             68L

//
// MessageId: ERROR_TOO_MANY_SESS
//
// MessageText:
//
//  The network BIOS session limit was exceeded.
//
#define ERROR_TOO_MANY_SESS              69L

//
// MessageId: ERROR_SHARING_PAUSED
//
// MessageText:
//
//  The remote server has been paused or is in the
//  process of being started.
//
#define ERROR_SHARING_PAUSED             70L

//
// MessageId: ERROR_REQ_NOT_ACCEP
//
// MessageText:
//
//  The network request was not accepted.
//
#define ERROR_REQ_NOT_ACCEP              71L

//
// MessageId: ERROR_REDIR_PAUSED
//
// MessageText:
//
//  The specified printer or disk device has been paused.
//
#define ERROR_REDIR_PAUSED               72L

//
// MessageId: ERROR_FILE_EXISTS
//
// MessageText:
//
//  The file exists.
//
#define ERROR_FILE_EXISTS                80L

//
// MessageId: ERROR_CANNOT_MAKE
//
// MessageText:
//
//  The directory or file cannot be created.
//
#define ERROR_CANNOT_MAKE                82L

//
// MessageId: ERROR_FAIL_I24
//
// MessageText:
//
//  Fail on INT 24
//
#define ERROR_FAIL_I24                   83L

//
// MessageId: ERROR_OUT_OF_STRUCTURES
//
// MessageText:
//
//  Storage to process this request is not available.
//
#define ERROR_OUT_OF_STRUCTURES          84L

//
// MessageId: ERROR_ALREADY_ASSIGNED
//
// MessageText:
//
//  The local device name is already in use.
//
#define ERROR_ALREADY_ASSIGNED           85L

//
// MessageId: ERROR_INVALID_PASSWORD
//
// MessageText:
//
//  The specified network password is not correct.
//
#define ERROR_INVALID_PASSWORD           86L

//
// MessageId: ERROR_INVALID_PARAMETER
//
// MessageText:
//
//  The parameter is incorrect.
//
#define ERROR_INVALID_PARAMETER          87L    // dderror

//
// MessageId: ERROR_NET_WRITE_FAULT
//
// MessageText:
//
//  A write fault occurred on the network.
//
#define ERROR_NET_WRITE_FAULT            88L

//
// MessageId: ERROR_NO_PROC_SLOTS
//
// MessageText:
//
//  The system cannot start another process at
//  this time.
//
#define ERROR_NO_PROC_SLOTS              89L

//
// MessageId: ERROR_TOO_MANY_SEMAPHORES
//
// MessageText:
//
//  Cannot create another system semaphore.
//
#define ERROR_TOO_MANY_SEMAPHORES        100L

//
// MessageId: ERROR_EXCL_SEM_ALREADY_OWNED
//
// MessageText:
//
//  The exclusive semaphore is owned by another process.
//
#define ERROR_EXCL_SEM_ALREADY_OWNED     101L

//
// MessageId: ERROR_SEM_IS_SET
//
// MessageText:
//
//  The semaphore is set and cannot be closed.
//
#define ERROR_SEM_IS_SET                 102L

//
// MessageId: ERROR_TOO_MANY_SEM_REQUESTS
//
// MessageText:
//
//  The semaphore cannot be set again.
//
#define ERROR_TOO_MANY_SEM_REQUESTS      103L

//
// MessageId: ERROR_INVALID_AT_INTERRUPT_TIME
//
// MessageText:
//
//  Cannot request exclusive semaphores at interrupt time.
//
#define ERROR_INVALID_AT_INTERRUPT_TIME  104L

//
// MessageId: ERROR_SEM_OWNER_DIED
//
// MessageText:
//
//  The previous ownership of this semaphore has ended.
//
#define ERROR_SEM_OWNER_DIED             105L

//
// MessageId: ERROR_SEM_USER_LIMIT
//
// MessageText:
//
//  Insert the diskette for drive %1.
//
#define ERROR_SEM_USER_LIMIT             106L

//
// MessageId: ERROR_DISK_CHANGE
//
// MessageText:
//
//  Program stopped because alternate diskette was not inserted.
//
#define ERROR_DISK_CHANGE                107L

//
// MessageId: ERROR_DRIVE_LOCKED
//
// MessageText:
//
//  The disk is in use or locked by
//  another process.
//
#define ERROR_DRIVE_LOCKED               108L

//
// MessageId: ERROR_BROKEN_PIPE
//
// MessageText:
//
//  The pipe has been ended.
//
#define ERROR_BROKEN_PIPE                109L

//
// MessageId: ERROR_OPEN_FAILED
//
// MessageText:
//
//  The system cannot open the
//  device or file specified.
//
#define ERROR_OPEN_FAILED                110L

//
// MessageId: ERROR_BUFFER_OVERFLOW
//
// MessageText:
//
//  The file name is too long.
//
#define ERROR_BUFFER_OVERFLOW            111L

//
// MessageId: ERROR_DISK_FULL
//
// MessageText:
//
//  There is not enough space on the disk.
//
#define ERROR_DISK_FULL                  112L

//
// MessageId: ERROR_NO_MORE_SEARCH_HANDLES
//
// MessageText:
//
//  No more internal file identifiers available.
//
#define ERROR_NO_MORE_SEARCH_HANDLES     113L

//
// MessageId: ERROR_INVALID_TARGET_HANDLE
//
// MessageText:
//
//  The target internal file identifier is incorrect.
//
#define ERROR_INVALID_TARGET_HANDLE      114L

//
// MessageId: ERROR_INVALID_CATEGORY
//
// MessageText:
//
//  The IOCTL call made by the application program is
//  not correct.
//
#define ERROR_INVALID_CATEGORY           117L

//
// MessageId: ERROR_INVALID_VERIFY_SWITCH
//
// MessageText:
//
//  The verify-on-write switch parameter value is not
//  correct.
//
#define ERROR_INVALID_VERIFY_SWITCH      118L

//
// MessageId: ERROR_BAD_DRIVER_LEVEL
//
// MessageText:
//
//  The system does not support the command requested.
//
#define ERROR_BAD_DRIVER_LEVEL           119L

//
// MessageId: ERROR_CALL_NOT_IMPLEMENTED
//
// MessageText:
//
//  This function is only valid in Windows NT mode.
//
#define ERROR_CALL_NOT_IMPLEMENTED       120L

//
// MessageId: ERROR_SEM_TIMEOUT
//
// MessageText:
//
//  The semaphore timeout period has expired.
//
#define ERROR_SEM_TIMEOUT                121L

//
// MessageId: ERROR_INSUFFICIENT_BUFFER
//
// MessageText:
//
//  The data area passed to a system call is too
//  small.
//
#define ERROR_INSUFFICIENT_BUFFER        122L    // dderror

//
// MessageId: ERROR_INVALID_NAME
//
// MessageText:
//
//  The filename, directory name, or volume label syntax is incorrect.
//
#define ERROR_INVALID_NAME               123L

//
// MessageId: ERROR_INVALID_LEVEL
//
// MessageText:
//
//  The system call level is not correct.
//
#define ERROR_INVALID_LEVEL              124L

//
// MessageId: ERROR_NO_VOLUME_LABEL
//
// MessageText:
//
//  The disk has no volume label.
//
#define ERROR_NO_VOLUME_LABEL            125L

//
// MessageId: ERROR_MOD_NOT_FOUND
//
// MessageText:
//
//  The specified module could not be found.
//
#define ERROR_MOD_NOT_FOUND              126L

//
// MessageId: ERROR_PROC_NOT_FOUND
//
// MessageText:
//
//  The specified procedure could not be found.
//
#define ERROR_PROC_NOT_FOUND             127L

//
// MessageId: ERROR_WAIT_NO_CHILDREN
//
// MessageText:
//
//  There are no child processes to wait for.
//
#define ERROR_WAIT_NO_CHILDREN           128L

//
// MessageId: ERROR_CHILD_NOT_COMPLETE
//
// MessageText:
//
//  The %1 application cannot be run in Windows NT mode.
//
#define ERROR_CHILD_NOT_COMPLETE         129L

//
// MessageId: ERROR_DIRECT_ACCESS_HANDLE
//
// MessageText:
//
//  Attempt to use a file handle to an open disk partition for an
//  operation other than raw disk I/O.
//
#define ERROR_DIRECT_ACCESS_HANDLE       130L

//
// MessageId: ERROR_NEGATIVE_SEEK
//
// MessageText:
//
//  An attempt was made to move the file pointer before the beginning of the file.
//
#define ERROR_NEGATIVE_SEEK              131L

//
// MessageId: ERROR_SEEK_ON_DEVICE
//
// MessageText:
//
//  The file pointer cannot be set on the specified device or file.
//
#define ERROR_SEEK_ON_DEVICE             132L

//
// MessageId: ERROR_IS_JOIN_TARGET
//
// MessageText:
//
//  A JOIN or SUBST command
//  cannot be used for a drive that
//  contains previously joined drives.
//
#define ERROR_IS_JOIN_TARGET             133L

//
// MessageId: ERROR_IS_JOINED
//
// MessageText:
//
//  An attempt was made to use a
//  JOIN or SUBST command on a drive that has
//  already been joined.
//
#define ERROR_IS_JOINED                  134L

//
// MessageId: ERROR_IS_SUBSTED
//
// MessageText:
//
//  An attempt was made to use a
//  JOIN or SUBST command on a drive that has
//  already been substituted.
//
#define ERROR_IS_SUBSTED                 135L

//
// MessageId: ERROR_NOT_JOINED
//
// MessageText:
//
//  The system tried to delete
//  the JOIN of a drive that is not joined.
//
#define ERROR_NOT_JOINED                 136L

//
// MessageId: ERROR_NOT_SUBSTED
//
// MessageText:
//
//  The system tried to delete the
//  substitution of a drive that is not substituted.
//
#define ERROR_NOT_SUBSTED                137L

//
// MessageId: ERROR_JOIN_TO_JOIN
//
// MessageText:
//
//  The system tried to join a drive
//  to a directory on a joined drive.
//
#define ERROR_JOIN_TO_JOIN               138L

//
// MessageId: ERROR_SUBST_TO_SUBST
//
// MessageText:
//
//  The system tried to substitute a
//  drive to a directory on a substituted drive.
//
#define ERROR_SUBST_TO_SUBST             139L

//
// MessageId: ERROR_JOIN_TO_SUBST
//
// MessageText:
//
//  The system tried to join a drive to
//  a directory on a substituted drive.
//
#define ERROR_JOIN_TO_SUBST              140L

//
// MessageId: ERROR_SUBST_TO_JOIN
//
// MessageText:
//
//  The system tried to SUBST a drive
//  to a directory on a joined drive.
//
#define ERROR_SUBST_TO_JOIN              141L

//
// MessageId: ERROR_BUSY_DRIVE
//
// MessageText:
//
//  The system cannot perform a JOIN or SUBST at this time.
//
#define ERROR_BUSY_DRIVE                 142L

//
// MessageId: ERROR_SAME_DRIVE
//
// MessageText:
//
//  The system cannot join or substitute a
//  drive to or for a directory on the same drive.
//
#define ERROR_SAME_DRIVE                 143L

//
// MessageId: ERROR_DIR_NOT_ROOT
//
// MessageText:
//
//  The directory is not a subdirectory of the root directory.
//
#define ERROR_DIR_NOT_ROOT               144L

//
// MessageId: ERROR_DIR_NOT_EMPTY
//
// MessageText:
//
//  The directory is not empty.
//
#define ERROR_DIR_NOT_EMPTY              145L

//
// MessageId: ERROR_IS_SUBST_PATH
//
// MessageText:
//
//  The path specified is being used in
//  a substitute.
//
#define ERROR_IS_SUBST_PATH              146L

//
// MessageId: ERROR_IS_JOIN_PATH
//
// MessageText:
//
//  Not enough resources are available to
//  process this command.
//
#define ERROR_IS_JOIN_PATH               147L

//
// MessageId: ERROR_PATH_BUSY
//
// MessageText:
//
//  The path specified cannot be used at this time.
//
#define ERROR_PATH_BUSY                  148L

//
// MessageId: ERROR_IS_SUBST_TARGET
//
// MessageText:
//
//  An attempt was made to join
//  or substitute a drive for which a directory
//  on the drive is the target of a previous
//  substitute.
//
#define ERROR_IS_SUBST_TARGET            149L

//
// MessageId: ERROR_SYSTEM_TRACE
//
// MessageText:
//
//  System trace information was not specified in your
//  CONFIG.SYS file, or tracing is disallowed.
//
#define ERROR_SYSTEM_TRACE               150L

//
// MessageId: ERROR_INVALID_EVENT_COUNT
//
// MessageText:
//
//  The number of specified semaphore events for
//  DosMuxSemWait is not correct.
//
#define ERROR_INVALID_EVENT_COUNT        151L

//
// MessageId: ERROR_TOO_MANY_MUXWAITERS
//
// MessageText:
//
//  DosMuxSemWait did not execute; too many semaphores
//  are already set.
//
#define ERROR_TOO_MANY_MUXWAITERS        152L

//
// MessageId: ERROR_INVALID_LIST_FORMAT
//
// MessageText:
//
//  The DosMuxSemWait list is not correct.
//
#define ERROR_INVALID_LIST_FORMAT        153L

//
// MessageId: ERROR_LABEL_TOO_LONG
//
// MessageText:
//
//  The volume label you entered exceeds the
//  11 character limit.  The first 11 characters were written
//  to disk.  Any characters that exceeded the 11 character limit
//  were automatically deleted.
//
#define ERROR_LABEL_TOO_LONG             154L

//
// MessageId: ERROR_TOO_MANY_TCBS
//
// MessageText:
//
//  Cannot create another thread.
//
#define ERROR_TOO_MANY_TCBS              155L

//
// MessageId: ERROR_SIGNAL_REFUSED
//
// MessageText:
//
//  The recipient process has refused the signal.
//
#define ERROR_SIGNAL_REFUSED             156L

//
// MessageId: ERROR_DISCARDED
//
// MessageText:
//
//  The segment is already discarded and cannot be locked.
//
#define ERROR_DISCARDED                  157L

//
// MessageId: ERROR_NOT_LOCKED
//
// MessageText:
//
//  The segment is already unlocked.
//
#define ERROR_NOT_LOCKED                 158L

//
// MessageId: ERROR_BAD_THREADID_ADDR
//
// MessageText:
//
//  The address for the thread ID is not correct.
//
#define ERROR_BAD_THREADID_ADDR          159L

//
// MessageId: ERROR_BAD_ARGUMENTS
//
// MessageText:
//
//  The argument string passed to DosExecPgm is not correct.
//
#define ERROR_BAD_ARGUMENTS              160L

//
// MessageId: ERROR_BAD_PATHNAME
//
// MessageText:
//
//  The specified path is invalid.
//
#define ERROR_BAD_PATHNAME               161L

//
// MessageId: ERROR_SIGNAL_PENDING
//
// MessageText:
//
//  A signal is already pending.
//
#define ERROR_SIGNAL_PENDING             162L

//
// MessageId: ERROR_MAX_THRDS_REACHED
//
// MessageText:
//
//  No more threads can be created in the system.
//
#define ERROR_MAX_THRDS_REACHED          164L

//
// MessageId: ERROR_LOCK_FAILED
//
// MessageText:
//
//  Unable to lock a region of a file.
//
#define ERROR_LOCK_FAILED                167L

//
// MessageId: ERROR_BUSY
//
// MessageText:
//
//  The requested resource is in use.
//
#define ERROR_BUSY                       170L

//
// MessageId: ERROR_CANCEL_VIOLATION
//
// MessageText:
//
//  A lock request was not outstanding for the supplied cancel region.
//
#define ERROR_CANCEL_VIOLATION           173L

//
// MessageId: ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
//
// MessageText:
//
//  The file system does not support atomic changes to the lock type.
//
#define ERROR_ATOMIC_LOCKS_NOT_SUPPORTED 174L

//
// MessageId: ERROR_INVALID_SEGMENT_NUMBER
//
// MessageText:
//
//  The system detected a segment number that was not correct.
//
#define ERROR_INVALID_SEGMENT_NUMBER     180L

//
// MessageId: ERROR_INVALID_ORDINAL
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_ORDINAL            182L

//
// MessageId: ERROR_ALREADY_EXISTS
//
// MessageText:
//
//  Cannot create a file when that file already exists.
//
#define ERROR_ALREADY_EXISTS             183L

//
// MessageId: ERROR_INVALID_FLAG_NUMBER
//
// MessageText:
//
//  The flag passed is not correct.
//
#define ERROR_INVALID_FLAG_NUMBER        186L

//
// MessageId: ERROR_SEM_NOT_FOUND
//
// MessageText:
//
//  The specified system semaphore name was not found.
//
#define ERROR_SEM_NOT_FOUND              187L

//
// MessageId: ERROR_INVALID_STARTING_CODESEG
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_STARTING_CODESEG   188L

//
// MessageId: ERROR_INVALID_STACKSEG
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_STACKSEG           189L

//
// MessageId: ERROR_INVALID_MODULETYPE
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_MODULETYPE         190L

//
// MessageId: ERROR_INVALID_EXE_SIGNATURE
//
// MessageText:
//
//  Cannot run %1 in Windows NT mode.
//
#define ERROR_INVALID_EXE_SIGNATURE      191L

//
// MessageId: ERROR_EXE_MARKED_INVALID
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_EXE_MARKED_INVALID         192L

//
// MessageId: ERROR_BAD_EXE_FORMAT
//
// MessageText:
//
//  %1 is not a valid Windows NT application.
//
#define ERROR_BAD_EXE_FORMAT             193L

//
// MessageId: ERROR_ITERATED_DATA_EXCEEDS_64k
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_ITERATED_DATA_EXCEEDS_64k  194L

//
// MessageId: ERROR_INVALID_MINALLOCSIZE
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_MINALLOCSIZE       195L

//
// MessageId: ERROR_DYNLINK_FROM_INVALID_RING
//
// MessageText:
//
//  The operating system cannot run this
//  application program.
//
#define ERROR_DYNLINK_FROM_INVALID_RING  196L

//
// MessageId: ERROR_IOPL_NOT_ENABLED
//
// MessageText:
//
//  The operating system is not presently
//  configured to run this application.
//
#define ERROR_IOPL_NOT_ENABLED           197L

//
// MessageId: ERROR_INVALID_SEGDPL
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_SEGDPL             198L

//
// MessageId: ERROR_AUTODATASEG_EXCEEDS_64k
//
// MessageText:
//
//  The operating system cannot run this
//  application program.
//
#define ERROR_AUTODATASEG_EXCEEDS_64k    199L

//
// MessageId: ERROR_RING2SEG_MUST_BE_MOVABLE
//
// MessageText:
//
//  The code segment cannot be greater than or equal to 64KB.
//
#define ERROR_RING2SEG_MUST_BE_MOVABLE   200L

//
// MessageId: ERROR_RELOC_CHAIN_XEEDS_SEGLIM
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM   201L

//
// MessageId: ERROR_INFLOOP_IN_RELOC_CHAIN
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INFLOOP_IN_RELOC_CHAIN     202L

//
// MessageId: ERROR_ENVVAR_NOT_FOUND
//
// MessageText:
//
//  The system could not find the environment
//  option that was entered.
//
#define ERROR_ENVVAR_NOT_FOUND           203L

//
// MessageId: ERROR_NO_SIGNAL_SENT
//
// MessageText:
//
//  No process in the command subtree has a
//  signal handler.
//
#define ERROR_NO_SIGNAL_SENT             205L

//
// MessageId: ERROR_FILENAME_EXCED_RANGE
//
// MessageText:
//
//  The filename or extension is too long.
//
#define ERROR_FILENAME_EXCED_RANGE       206L

//
// MessageId: ERROR_RING2_STACK_IN_USE
//
// MessageText:
//
//  The ring 2 stack is in use.
//
#define ERROR_RING2_STACK_IN_USE         207L

//
// MessageId: ERROR_META_EXPANSION_TOO_LONG
//
// MessageText:
//
//  The global filename characters, * or ?, are entered
//  incorrectly or too many global filename characters are specified.
//
#define ERROR_META_EXPANSION_TOO_LONG    208L

//
// MessageId: ERROR_INVALID_SIGNAL_NUMBER
//
// MessageText:
//
//  The signal being posted is not correct.
//
#define ERROR_INVALID_SIGNAL_NUMBER      209L

//
// MessageId: ERROR_THREAD_1_INACTIVE
//
// MessageText:
//
//  The signal handler cannot be set.
//
#define ERROR_THREAD_1_INACTIVE          210L

//
// MessageId: ERROR_LOCKED
//
// MessageText:
//
//  The segment is locked and cannot be reallocated.
//
#define ERROR_LOCKED                     212L

//
// MessageId: ERROR_TOO_MANY_MODULES
//
// MessageText:
//
//  Too many dynamic link modules are attached to this
//  program or dynamic link module.
//
#define ERROR_TOO_MANY_MODULES           214L

//
// MessageId: ERROR_NESTING_NOT_ALLOWED
//
// MessageText:
//
//  Can't nest calls to LoadModule.
//
#define ERROR_NESTING_NOT_ALLOWED        215L

//
// MessageId: ERROR_BAD_PIPE
//
// MessageText:
//
//  The pipe state is invalid.
//
#define ERROR_BAD_PIPE                   230L

//
// MessageId: ERROR_PIPE_BUSY
//
// MessageText:
//
//  All pipe instances are busy.
//
#define ERROR_PIPE_BUSY                  231L

//
// MessageId: ERROR_NO_DATA
//
// MessageText:
//
//  The pipe is being closed.
//
#define ERROR_NO_DATA                    232L

//
// MessageId: ERROR_PIPE_NOT_CONNECTED
//
// MessageText:
//
//  No process is on the other end of the pipe.
//
#define ERROR_PIPE_NOT_CONNECTED         233L

//
// MessageId: ERROR_MORE_DATA
//
// MessageText:
//
//  More data is available.
//
#define ERROR_MORE_DATA                  234L    // dderror

//
// MessageId: ERROR_VC_DISCONNECTED
//
// MessageText:
//
//  The session was cancelled.
//
#define ERROR_VC_DISCONNECTED            240L

//
// MessageId: ERROR_INVALID_EA_NAME
//
// MessageText:
//
//  The specified extended attribute name was invalid.
//
#define ERROR_INVALID_EA_NAME            254L

//
// MessageId: ERROR_EA_LIST_INCONSISTENT
//
// MessageText:
//
//  The extended attributes are inconsistent.
//
#define ERROR_EA_LIST_INCONSISTENT       255L

//
// MessageId: ERROR_NO_MORE_ITEMS
//
// MessageText:
//
//  No more data is available.
//
#define ERROR_NO_MORE_ITEMS              259L

//
// MessageId: ERROR_CANNOT_COPY
//
// MessageText:
//
//  The Copy API cannot be used.
//
#define ERROR_CANNOT_COPY                266L

//
// MessageId: ERROR_DIRECTORY
//
// MessageText:
//
//  The directory name is invalid.
//
#define ERROR_DIRECTORY                  267L

//
// MessageId: ERROR_EAS_DIDNT_FIT
//
// MessageText:
//
//  The extended attributes did not fit in the buffer.
//
#define ERROR_EAS_DIDNT_FIT              275L

//
// MessageId: ERROR_EA_FILE_CORRUPT
//
// MessageText:
//
//  The extended attribute file on the mounted file system is corrupt.
//
#define ERROR_EA_FILE_CORRUPT            276L

//
// MessageId: ERROR_EA_TABLE_FULL
//
// MessageText:
//
//  The extended attribute table file is full.
//
#define ERROR_EA_TABLE_FULL              277L

//
// MessageId: ERROR_INVALID_EA_HANDLE
//
// MessageText:
//
//  The specified extended attribute handle is invalid.
//
#define ERROR_INVALID_EA_HANDLE          278L

//
// MessageId: ERROR_EAS_NOT_SUPPORTED
//
// MessageText:
//
//  The mounted file system does not support extended attributes.
//
#define ERROR_EAS_NOT_SUPPORTED          282L

//
// MessageId: ERROR_NOT_OWNER
//
// MessageText:
//
//  Attempt to release mutex not owned by caller.
//
#define ERROR_NOT_OWNER                  288L

//
// MessageId: ERROR_TOO_MANY_POSTS
//
// MessageText:
//
//  Too many posts were made to a semaphore.
//
#define ERROR_TOO_MANY_POSTS             298L

//
// MessageId: ERROR_MR_MID_NOT_FOUND
//
// MessageText:
//
//  The system cannot find message for message number 0x%1
//  in message file for %2.
//
#define ERROR_MR_MID_NOT_FOUND           317L

//
// MessageId: ERROR_INVALID_ADDRESS
//
// MessageText:
//
//  Attempt to access invalid address.
//
#define ERROR_INVALID_ADDRESS            487L

//
// MessageId: ERROR_ARITHMETIC_OVERFLOW
//
// MessageText:
//
//  Arithmetic result exceeded 32 bits.
//
#define ERROR_ARITHMETIC_OVERFLOW        534L

//
// MessageId: ERROR_PIPE_CONNECTED
//
// MessageText:
//
//  There is a process on other end of the pipe.
//
#define ERROR_PIPE_CONNECTED             535L

//
// MessageId: ERROR_PIPE_LISTENING
//
// MessageText:
//
//  Waiting for a process to open the other end of the pipe.
//
#define ERROR_PIPE_LISTENING             536L

//
// MessageId: ERROR_EA_ACCESS_DENIED
//
// MessageText:
//
//  Access to the extended attribute was denied.
//
#define ERROR_EA_ACCESS_DENIED           994L

//
// MessageId: ERROR_OPERATION_ABORTED
//
// MessageText:
//
//  The I/O operation has been aborted because of either a thread exit
//  or an application request.
//
#define ERROR_OPERATION_ABORTED          995L

//
// MessageId: ERROR_IO_INCOMPLETE
//
// MessageText:
//
//  Overlapped I/O event is not in a signalled state.
//
#define ERROR_IO_INCOMPLETE              996L

//
// MessageId: ERROR_IO_PENDING
//
// MessageText:
//
//  Overlapped I/O operation is in progress.
//
#define ERROR_IO_PENDING                 997L    // dderror

//
// MessageId: ERROR_NOACCESS
//
// MessageText:
//
//  Invalid access to memory location.
//
#define ERROR_NOACCESS                   998L

//
// MessageId: ERROR_SWAPERROR
//
// MessageText:
//
//  Error performing inpage operation.
//
#define ERROR_SWAPERROR                  999L

//
// MessageId: ERROR_STACK_OVERFLOW
//
// MessageText:
//
//  Recursion too deep, stack overflowed.
//
#define ERROR_STACK_OVERFLOW             1001L

//
// MessageId: ERROR_INVALID_MESSAGE
//
// MessageText:
//
//  The window cannot act on the sent message.
//
#define ERROR_INVALID_MESSAGE            1002L

//
// MessageId: ERROR_CAN_NOT_COMPLETE
//
// MessageText:
//
//  Cannot complete this function.
//
#define ERROR_CAN_NOT_COMPLETE           1003L

//
// MessageId: ERROR_INVALID_FLAGS
//
// MessageText:
//
//  Invalid flags.
//
#define ERROR_INVALID_FLAGS              1004L

//
// MessageId: ERROR_UNRECOGNIZED_VOLUME
//
// MessageText:
//
//  The volume does not contain a recognized file system.
//  Please make sure that all required file system drivers are loaded and that the
//  volume is not corrupt.
//
#define ERROR_UNRECOGNIZED_VOLUME        1005L

//
// MessageId: ERROR_FILE_INVALID
//
// MessageText:
//
//  The volume for a file has been externally altered such that the
//  opened file is no longer valid.
//
#define ERROR_FILE_INVALID               1006L

//
// MessageId: ERROR_FULLSCREEN_MODE
//
// MessageText:
//
//  The requested operation cannot be performed in full-screen mode.
//
#define ERROR_FULLSCREEN_MODE            1007L

//
// MessageId: ERROR_NO_TOKEN
//
// MessageText:
//
//  An attempt was made to reference a token that does not exist.
//
#define ERROR_NO_TOKEN                   1008L

//
// MessageId: ERROR_BADDB
//
// MessageText:
//
//  The configuration registry database is corrupt.
//
#define ERROR_BADDB                      1009L

//
// MessageId: ERROR_BADKEY
//
// MessageText:
//
//  The configuration registry key is invalid.
//
#define ERROR_BADKEY                     1010L

//
// MessageId: ERROR_CANTOPEN
//
// MessageText:
//
//  The configuration registry key could not be opened.
//
#define ERROR_CANTOPEN                   1011L

//
// MessageId: ERROR_CANTREAD
//
// MessageText:
//
//  The configuration registry key could not be read.
//
#define ERROR_CANTREAD                   1012L

//
// MessageId: ERROR_CANTWRITE
//
// MessageText:
//
//  The configuration registry key could not be written.
//
#define ERROR_CANTWRITE                  1013L

//
// MessageId: ERROR_REGISTRY_RECOVERED
//
// MessageText:
//
//  One of the files in the Registry database had to be recovered
//  by use of a log or alternate copy.  The recovery was successful.
//
#define ERROR_REGISTRY_RECOVERED         1014L

//
// MessageId: ERROR_REGISTRY_CORRUPT
//
// MessageText:
//
//  The Registry is corrupt. The structure of one of the files that contains
//  Registry data is corrupt, or the system's image of the file in memory
//  is corrupt, or the file could not be recovered because the alternate
//  copy or log was absent or corrupt.
//
#define ERROR_REGISTRY_CORRUPT           1015L

//
// MessageId: ERROR_REGISTRY_IO_FAILED
//
// MessageText:
//
//  An I/O operation initiated by the Registry failed unrecoverably.
//  The Registry could not read in, or write out, or flush, one of the files
//  that contain the system's image of the Registry.
//
#define ERROR_REGISTRY_IO_FAILED         1016L

//
// MessageId: ERROR_NOT_REGISTRY_FILE
//
// MessageText:
//
//  The system has attempted to load or restore a file into the Registry, but the
//  specified file is not in a Registry file format.
//
#define ERROR_NOT_REGISTRY_FILE          1017L

//
// MessageId: ERROR_KEY_DELETED
//
// MessageText:
//
//  Illegal operation attempted on a Registry key which has been marked for deletion.
//
#define ERROR_KEY_DELETED                1018L

//
// MessageId: ERROR_NO_LOG_SPACE
//
// MessageText:
//
//  System could not allocate the required space in a Registry log.
//
#define ERROR_NO_LOG_SPACE               1019L

//
// MessageId: ERROR_KEY_HAS_CHILDREN
//
// MessageText:
//
//  Cannot create a symbolic link in a Registry key that already
//  has subkeys or values.
//
#define ERROR_KEY_HAS_CHILDREN           1020L

//
// MessageId: ERROR_CHILD_MUST_BE_VOLATILE
//
// MessageText:
//
//  Cannot create a stable subkey under a volatile parent key.
//
#define ERROR_CHILD_MUST_BE_VOLATILE     1021L

//
// MessageId: ERROR_NOTIFY_ENUM_DIR
//
// MessageText:
//
//  A notify change request is being completed and the information
//  is not being returned in the caller's buffer. The caller now
//  needs to enumerate the files to find the changes.
//
#define ERROR_NOTIFY_ENUM_DIR            1022L

//
// MessageId: ERROR_DEPENDENT_SERVICES_RUNNING
//
// MessageText:
//
//  A stop control has been sent to a service which other running services
//  are dependent on.
//
#define ERROR_DEPENDENT_SERVICES_RUNNING 1051L

//
// MessageId: ERROR_INVALID_SERVICE_CONTROL
//
// MessageText:
//
//  The requested control is not valid for this service
//
#define ERROR_INVALID_SERVICE_CONTROL    1052L

//
// MessageId: ERROR_SERVICE_REQUEST_TIMEOUT
//
// MessageText:
//
//  The service did not respond to the start or control request in a timely
//  fashion.
//
#define ERROR_SERVICE_REQUEST_TIMEOUT    1053L

//
// MessageId: ERROR_SERVICE_NO_THREAD
//
// MessageText:
//
//  A thread could not be created for the service.
//
#define ERROR_SERVICE_NO_THREAD          1054L

//
// MessageId: ERROR_SERVICE_DATABASE_LOCKED
//
// MessageText:
//
//  The service database is locked.
//
#define ERROR_SERVICE_DATABASE_LOCKED    1055L

//
// MessageId: ERROR_SERVICE_ALREADY_RUNNING
//
// MessageText:
//
//  An instance of the service is already running.
//
#define ERROR_SERVICE_ALREADY_RUNNING    1056L

//
// MessageId: ERROR_INVALID_SERVICE_ACCOUNT
//
// MessageText:
//
//  The account name is invalid or does not exist.
//
#define ERROR_INVALID_SERVICE_ACCOUNT    1057L

//
// MessageId: ERROR_SERVICE_DISABLED
//
// MessageText:
//
//  The specified service is disabled and cannot be started.
//
#define ERROR_SERVICE_DISABLED           1058L

//
// MessageId: ERROR_CIRCULAR_DEPENDENCY
//
// MessageText:
//
//  Circular service dependency was specified.
//
#define ERROR_CIRCULAR_DEPENDENCY        1059L

//
// MessageId: ERROR_SERVICE_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified service does not exist as an installed service.
//
#define ERROR_SERVICE_DOES_NOT_EXIST     1060L

//
// MessageId: ERROR_SERVICE_CANNOT_ACCEPT_CTRL
//
// MessageText:
//
//  The service cannot accept control messages at this time.
//
#define ERROR_SERVICE_CANNOT_ACCEPT_CTRL 1061L

//
// MessageId: ERROR_SERVICE_NOT_ACTIVE
//
// MessageText:
//
//  The service has not been started.
//
#define ERROR_SERVICE_NOT_ACTIVE         1062L

//
// MessageId: ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
//
// MessageText:
//
//  The service process could not connect to the service controller.
//
#define ERROR_FAILED_SERVICE_CONTROLLER_CONNECT 1063L

//
// MessageId: ERROR_EXCEPTION_IN_SERVICE
//
// MessageText:
//
//  An exception occurred in the service when handling the control request.
//
#define ERROR_EXCEPTION_IN_SERVICE       1064L

//
// MessageId: ERROR_DATABASE_DOES_NOT_EXIST
//
// MessageText:
//
//  The database specified does not exist.
//
#define ERROR_DATABASE_DOES_NOT_EXIST    1065L

//
// MessageId: ERROR_SERVICE_SPECIFIC_ERROR
//
// MessageText:
//
//  The service has returned a service-specific error code.
//
#define ERROR_SERVICE_SPECIFIC_ERROR     1066L

//
// MessageId: ERROR_PROCESS_ABORTED
//
// MessageText:
//
//  The process terminated unexpectedly.
//
#define ERROR_PROCESS_ABORTED            1067L

//
// MessageId: ERROR_SERVICE_DEPENDENCY_FAIL
//
// MessageText:
//
//  The dependency service or group failed to start.
//
#define ERROR_SERVICE_DEPENDENCY_FAIL    1068L

//
// MessageId: ERROR_SERVICE_LOGON_FAILED
//
// MessageText:
//
//  The service did not start due to a logon failure.
//
#define ERROR_SERVICE_LOGON_FAILED       1069L

//
// MessageId: ERROR_SERVICE_START_HANG
//
// MessageText:
//
//  After starting, the service hung in a start-pending state.
//
#define ERROR_SERVICE_START_HANG         1070L

//
// MessageId: ERROR_INVALID_SERVICE_LOCK
//
// MessageText:
//
//  The specified service database lock is invalid.
//
#define ERROR_INVALID_SERVICE_LOCK       1071L

//
// MessageId: ERROR_SERVICE_MARKED_FOR_DELETE
//
// MessageText:
//
//  The specified service has been marked for deletion.
//
#define ERROR_SERVICE_MARKED_FOR_DELETE  1072L

//
// MessageId: ERROR_SERVICE_EXISTS
//
// MessageText:
//
//  The specified service already exists.
//
#define ERROR_SERVICE_EXISTS             1073L

//
// MessageId: ERROR_ALREADY_RUNNING_LKG
//
// MessageText:
//
//  The system is currently running with the last-known-good configuration.
//
#define ERROR_ALREADY_RUNNING_LKG        1074L

//
// MessageId: ERROR_SERVICE_DEPENDENCY_DELETED
//
// MessageText:
//
//  The dependency service does not exist or has been marked for
//  deletion.
//
#define ERROR_SERVICE_DEPENDENCY_DELETED 1075L

//
// MessageId: ERROR_BOOT_ALREADY_ACCEPTED
//
// MessageText:
//
//  The current boot has already been accepted for use as the
//  last-known-good control set.
//
#define ERROR_BOOT_ALREADY_ACCEPTED      1076L

//
// MessageId: ERROR_SERVICE_NEVER_STARTED
//
// MessageText:
//
//  No attempts to start the service have been made since the last boot.
//
#define ERROR_SERVICE_NEVER_STARTED      1077L

//
// MessageId: ERROR_DUPLICATE_SERVICE_NAME
//
// MessageText:
//
//  The name is already in use as either a service name or a service display
//  name.
//
#define ERROR_DUPLICATE_SERVICE_NAME     1078L

//
// MessageId: ERROR_END_OF_MEDIA
//
// MessageText:
//
//  The physical end of the tape has been reached.
//
#define ERROR_END_OF_MEDIA               1100L

//
// MessageId: ERROR_FILEMARK_DETECTED
//
// MessageText:
//
//  A tape access reached a filemark.
//
#define ERROR_FILEMARK_DETECTED          1101L

//
// MessageId: ERROR_BEGINNING_OF_MEDIA
//
// MessageText:
//
//  Beginning of tape or partition was encountered.
//
#define ERROR_BEGINNING_OF_MEDIA         1102L

//
// MessageId: ERROR_SETMARK_DETECTED
//
// MessageText:
//
//  A tape access reached the end of a set of files.
//
#define ERROR_SETMARK_DETECTED           1103L

//
// MessageId: ERROR_NO_DATA_DETECTED
//
// MessageText:
//
//  No more data is on the tape.
//
#define ERROR_NO_DATA_DETECTED           1104L

//
// MessageId: ERROR_PARTITION_FAILURE
//
// MessageText:
//
//  Tape could not be partitioned.
//
#define ERROR_PARTITION_FAILURE          1105L

//
// MessageId: ERROR_INVALID_BLOCK_LENGTH
//
// MessageText:
//
//  When accessing a new tape of a multivolume partition, the current
//  blocksize is incorrect.
//
#define ERROR_INVALID_BLOCK_LENGTH       1106L

//
// MessageId: ERROR_DEVICE_NOT_PARTITIONED
//
// MessageText:
//
//  Tape partition information could not be found when loading a tape.
//
#define ERROR_DEVICE_NOT_PARTITIONED     1107L

//
// MessageId: ERROR_UNABLE_TO_LOCK_MEDIA
//
// MessageText:
//
//  Unable to lock the media eject mechanism.
//
#define ERROR_UNABLE_TO_LOCK_MEDIA       1108L

//
// MessageId: ERROR_UNABLE_TO_UNLOAD_MEDIA
//
// MessageText:
//
//  Unable to unload the media.
//
#define ERROR_UNABLE_TO_UNLOAD_MEDIA     1109L

//
// MessageId: ERROR_MEDIA_CHANGED
//
// MessageText:
//
//  Media in drive may have changed.
//
#define ERROR_MEDIA_CHANGED              1110L

//
// MessageId: ERROR_BUS_RESET
//
// MessageText:
//
//  The I/O bus was reset.
//
#define ERROR_BUS_RESET                  1111L

//
// MessageId: ERROR_NO_MEDIA_IN_DRIVE
//
// MessageText:
//
//  No media in drive.
//
#define ERROR_NO_MEDIA_IN_DRIVE          1112L

//
// MessageId: ERROR_NO_UNICODE_TRANSLATION
//
// MessageText:
//
//  No mapping for the Unicode character exists in the target multi-byte code page.
//
#define ERROR_NO_UNICODE_TRANSLATION     1113L

//
// MessageId: ERROR_DLL_INIT_FAILED
//
// MessageText:
//
//  A dynamic link library (DLL) initialization routine failed.
//
#define ERROR_DLL_INIT_FAILED            1114L

//
// MessageId: ERROR_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
//  A system shutdown is in progress.
//
#define ERROR_SHUTDOWN_IN_PROGRESS       1115L

//
// MessageId: ERROR_NO_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
//  Unable to abort the system shutdown because no shutdown was in progress.
//
#define ERROR_NO_SHUTDOWN_IN_PROGRESS    1116L

//
// MessageId: ERROR_IO_DEVICE
//
// MessageText:
//
//  The request could not be performed because of an I/O device error.
//
#define ERROR_IO_DEVICE                  1117L

//
// MessageId: ERROR_SERIAL_NO_DEVICE
//
// MessageText:
//
//  No serial device was successfully initialized.  The serial driver will unload.
//
#define ERROR_SERIAL_NO_DEVICE           1118L

//
// MessageId: ERROR_IRQ_BUSY
//
// MessageText:
//
//  Unable to open a device that was sharing an interrupt request (IRQ)
//  with other devices. At least one other device that uses that IRQ
//  was already opened.
//
#define ERROR_IRQ_BUSY                   1119L

//
// MessageId: ERROR_MORE_WRITES
//
// MessageText:
//
//  A serial I/O operation was completed by another write to the serial port.
//  (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)
//
#define ERROR_MORE_WRITES                1120L

//
// MessageId: ERROR_COUNTER_TIMEOUT
//
// MessageText:
//
//  A serial I/O operation completed because the time-out period expired.
//  (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)
//
#define ERROR_COUNTER_TIMEOUT            1121L

//
// MessageId: ERROR_FLOPPY_ID_MARK_NOT_FOUND
//
// MessageText:
//
//  No ID address mark was found on the floppy disk.
//
#define ERROR_FLOPPY_ID_MARK_NOT_FOUND   1122L

//
// MessageId: ERROR_FLOPPY_WRONG_CYLINDER
//
// MessageText:
//
//  Mismatch between the floppy disk sector ID field and the floppy disk
//  controller track address.
//
#define ERROR_FLOPPY_WRONG_CYLINDER      1123L

//
// MessageId: ERROR_FLOPPY_UNKNOWN_ERROR
//
// MessageText:
//
//  The floppy disk controller reported an error that is not recognized
//  by the floppy disk driver.
//
#define ERROR_FLOPPY_UNKNOWN_ERROR       1124L

//
// MessageId: ERROR_FLOPPY_BAD_REGISTERS
//
// MessageText:
//
//  The floppy disk controller returned inconsistent results in its registers.
//
#define ERROR_FLOPPY_BAD_REGISTERS       1125L

//
// MessageId: ERROR_DISK_RECALIBRATE_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a recalibrate operation failed, even after retries.
//
#define ERROR_DISK_RECALIBRATE_FAILED    1126L

//
// MessageId: ERROR_DISK_OPERATION_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a disk operation failed even after retries.
//
#define ERROR_DISK_OPERATION_FAILED      1127L

//
// MessageId: ERROR_DISK_RESET_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a disk controller reset was needed, but
//  even that failed.
//
#define ERROR_DISK_RESET_FAILED          1128L

//
// MessageId: ERROR_EOM_OVERFLOW
//
// MessageText:
//
//  Physical end of tape encountered.
//
#define ERROR_EOM_OVERFLOW               1129L

//
// MessageId: ERROR_NOT_ENOUGH_SERVER_MEMORY
//
// MessageText:
//
//  Not enough server storage is available to process this command.
//
#define ERROR_NOT_ENOUGH_SERVER_MEMORY   1130L    // dderror

//
// MessageId: ERROR_POSSIBLE_DEADLOCK
//
// MessageText:
//
//  A potential deadlock condition has been detected.
//
#define ERROR_POSSIBLE_DEADLOCK          1131L    // dderror




///////////////////////////
//                       //
// Winnet32 Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_BAD_USERNAME
//
// MessageText:
//
//  The specified username is invalid.
//
#define ERROR_BAD_USERNAME               2202L

//
// MessageId: ERROR_NO_NETWORK
//
// MessageText:
//
//  The network is not present or not started.
//
#define ERROR_NO_NETWORK                 2138L

//
// MessageId: ERROR_NOT_CONNECTED
//
// MessageText:
//
//  This network connection does not exist.
//
#define ERROR_NOT_CONNECTED              2250L

//
// MessageId: ERROR_OPEN_FILES
//
// MessageText:
//
//  This network connection has files open or requests pending.
//
#define ERROR_OPEN_FILES                 2401L

//
// MessageId: ERROR_DEVICE_IN_USE
//
// MessageText:
//
//  The device is in use by an active process and cannot be disconnected.
//
#define ERROR_DEVICE_IN_USE              2404L

//
// MessageId: ERROR_BAD_DEVICE
//
// MessageText:
//
//  The specified device name is invalid.
//
#define ERROR_BAD_DEVICE                 1200L

//
// MessageId: ERROR_CONNECTION_UNAVAIL
//
// MessageText:
//
//  The device is not currently connected but it is a remembered connection.
//
#define ERROR_CONNECTION_UNAVAIL         1201L

//
// MessageId: ERROR_DEVICE_ALREADY_REMEMBERED
//
// MessageText:
//
//  An attempt was made to remember a device that had previously been remembered.
//
#define ERROR_DEVICE_ALREADY_REMEMBERED  1202L

//
// MessageId: ERROR_NO_NET_OR_BAD_PATH
//
// MessageText:
//
//  No network provider accepted the given network path.
//
#define ERROR_NO_NET_OR_BAD_PATH         1203L

//
// MessageId: ERROR_BAD_PROVIDER
//
// MessageText:
//
//  The specified network provider name is invalid.
//
#define ERROR_BAD_PROVIDER               1204L

//
// MessageId: ERROR_CANNOT_OPEN_PROFILE
//
// MessageText:
//
//  Unable to open the network connection profile.
//
#define ERROR_CANNOT_OPEN_PROFILE        1205L

//
// MessageId: ERROR_BAD_PROFILE
//
// MessageText:
//
//  The network connection profile is corrupt.
//
#define ERROR_BAD_PROFILE                1206L

//
// MessageId: ERROR_NOT_CONTAINER
//
// MessageText:
//
//  Cannot enumerate a non-container.
//
#define ERROR_NOT_CONTAINER              1207L

//
// MessageId: ERROR_EXTENDED_ERROR
//
// MessageText:
//
//  An extended error has occurred.
//
#define ERROR_EXTENDED_ERROR             1208L

//
// MessageId: ERROR_INVALID_GROUPNAME
//
// MessageText:
//
//  The format of the specified group name is invalid.
//
#define ERROR_INVALID_GROUPNAME          1209L

//
// MessageId: ERROR_INVALID_COMPUTERNAME
//
// MessageText:
//
//  The format of the specified computer name is invalid.
//
#define ERROR_INVALID_COMPUTERNAME       1210L

//
// MessageId: ERROR_INVALID_EVENTNAME
//
// MessageText:
//
//  The format of the specified event name is invalid.
//
#define ERROR_INVALID_EVENTNAME          1211L

//
// MessageId: ERROR_INVALID_DOMAINNAME
//
// MessageText:
//
//  The format of the specified domain name is invalid.
//
#define ERROR_INVALID_DOMAINNAME         1212L

//
// MessageId: ERROR_INVALID_SERVICENAME
//
// MessageText:
//
//  The format of the specified service name is invalid.
//
#define ERROR_INVALID_SERVICENAME        1213L

//
// MessageId: ERROR_INVALID_NETNAME
//
// MessageText:
//
//  The format of the specified network name is invalid.
//
#define ERROR_INVALID_NETNAME            1214L

//
// MessageId: ERROR_INVALID_SHARENAME
//
// MessageText:
//
//  The format of the specified share name is invalid.
//
#define ERROR_INVALID_SHARENAME          1215L

//
// MessageId: ERROR_INVALID_PASSWORDNAME
//
// MessageText:
//
//  The format of the specified password is invalid.
//
#define ERROR_INVALID_PASSWORDNAME       1216L

//
// MessageId: ERROR_INVALID_MESSAGENAME
//
// MessageText:
//
//  The format of the specified message name is invalid.
//
#define ERROR_INVALID_MESSAGENAME        1217L

//
// MessageId: ERROR_INVALID_MESSAGEDEST
//
// MessageText:
//
//  The format of the specified message destination is invalid.
//
#define ERROR_INVALID_MESSAGEDEST        1218L

//
// MessageId: ERROR_SESSION_CREDENTIAL_CONFLICT
//
// MessageText:
//
//  The credentials supplied conflict with an existing set of credentials.
//
#define ERROR_SESSION_CREDENTIAL_CONFLICT 1219L

//
// MessageId: ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to establish a session to a Lan Manager server, but there
//  are already too many sessions established to that server.
//
#define ERROR_REMOTE_SESSION_LIMIT_EXCEEDED 1220L

//
// MessageId: ERROR_DUP_DOMAINNAME
//
// MessageText:
//
//  The workgroup or domain name is already in use by another computer on the
//  network.
//
#define ERROR_DUP_DOMAINNAME                1221L

//
// MessageId: ERROR_RETRY
//
// MessageText:
//
//  The operation being requested was not performed, and a retry should be performed.
//
#define ERROR_RETRY             1222L

//
// MessageId: ERROR_CANCELLED
//
// MessageText:
//
//  The operation being requested was cancelled.
//
#define ERROR_CANCELLED         1223L

//
// MessageId: ERROR_NOT_AUTHENTICATED
//
// MessageText:
//
//  The operation being requested was not performed because the user 
//  has not been authenticated.
//
#define ERROR_NOT_AUTHENTICATED 1224L

//
// MessageId: ERROR_NOT_LOGGED_ON
//
// MessageText:
//
//  The operation being requested was not performed because the user 
//  has not logged on to the network.
//
#define ERROR_NOT_LOGGED_ON     1225L

//
// MessageId: ERROR_CONTINUE
//
// MessageText:
//
//  Return that wants caller to continue with work in progress.
//
#define ERROR_CONTINUE           1226L

//
// MessageId: ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
//  An attempt was made to perform an initialization operation when 
//  initialization has already been completed.
//
#define ERROR_ALREADY_INITIALIZED           1227L


///////////////////////////
//                       //
// Security Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_NOT_ALL_ASSIGNED
//
// MessageText:
//
//  Not all privileges referenced are assigned to the caller.
//
#define ERROR_NOT_ALL_ASSIGNED           1300L

//
// MessageId: ERROR_SOME_NOT_MAPPED
//
// MessageText:
//
//  Some mapping between account names and security IDs was not done.
//
#define ERROR_SOME_NOT_MAPPED            1301L

//
// MessageId: ERROR_NO_QUOTAS_FOR_ACCOUNT
//
// MessageText:
//
//  No system quota limits are specifically set for this account.
//
#define ERROR_NO_QUOTAS_FOR_ACCOUNT      1302L

//
// MessageId: ERROR_LOCAL_USER_SESSION_KEY
//
// MessageText:
//
//  No encryption key is available.  A well-known encryption key was returned.
//
#define ERROR_LOCAL_USER_SESSION_KEY     1303L

//
// MessageId: ERROR_NULL_LM_PASSWORD
//
// MessageText:
//
//  The NT password is too complex to be converted to a LAN Manager
//  password.  The LAN Manager password returned is a NULL string.
//
#define ERROR_NULL_LM_PASSWORD           1304L

//
// MessageId: ERROR_UNKNOWN_REVISION
//
// MessageText:
//
//  The revision level is unknown.
//
#define ERROR_UNKNOWN_REVISION           1305L

//
// MessageId: ERROR_REVISION_MISMATCH
//
// MessageText:
//
//  Indicates two revision levels are incompatible.
//
#define ERROR_REVISION_MISMATCH          1306L

//
// MessageId: ERROR_INVALID_OWNER
//
// MessageText:
//
//  This security ID may not be assigned as the owner of this object.
//
#define ERROR_INVALID_OWNER              1307L

//
// MessageId: ERROR_INVALID_PRIMARY_GROUP
//
// MessageText:
//
//  This security ID may not be assigned as the primary group of an object.
//
#define ERROR_INVALID_PRIMARY_GROUP      1308L

//
// MessageId: ERROR_NO_IMPERSONATION_TOKEN
//
// MessageText:
//
//  An attempt has been made to operate on an impersonation token
//  by a thread that is not currently impersonating a client.
//
#define ERROR_NO_IMPERSONATION_TOKEN     1309L

//
// MessageId: ERROR_CANT_DISABLE_MANDATORY
//
// MessageText:
//
//  The group may not be disabled.
//
#define ERROR_CANT_DISABLE_MANDATORY     1310L

//
// MessageId: ERROR_NO_LOGON_SERVERS
//
// MessageText:
//
//  There are currently no logon servers available to service the logon
//  request.
//
#define ERROR_NO_LOGON_SERVERS           1311L

//
// MessageId: ERROR_NO_SUCH_LOGON_SESSION
//
// MessageText:
//
//   A specified logon session does not exist.  It may already have
//   been terminated.
//
#define ERROR_NO_SUCH_LOGON_SESSION      1312L

//
// MessageId: ERROR_NO_SUCH_PRIVILEGE
//
// MessageText:
//
//   A specified privilege does not exist.
//
#define ERROR_NO_SUCH_PRIVILEGE          1313L

//
// MessageId: ERROR_PRIVILEGE_NOT_HELD
//
// MessageText:
//
//   A required privilege is not held by the client.
//
#define ERROR_PRIVILEGE_NOT_HELD         1314L

//
// MessageId: ERROR_INVALID_ACCOUNT_NAME
//
// MessageText:
//
//  The name provided is not a properly formed account name.
//
#define ERROR_INVALID_ACCOUNT_NAME       1315L

//
// MessageId: ERROR_USER_EXISTS
//
// MessageText:
//
//  The specified user already exists.
//
#define ERROR_USER_EXISTS                1316L

//
// MessageId: ERROR_NO_SUCH_USER
//
// MessageText:
//
//  The specified user does not exist.
//
#define ERROR_NO_SUCH_USER               1317L

//
// MessageId: ERROR_GROUP_EXISTS
//
// MessageText:
//
//  The specified group already exists.
//
#define ERROR_GROUP_EXISTS               1318L

//
// MessageId: ERROR_NO_SUCH_GROUP
//
// MessageText:
//
//  The specified group does not exist.
//
#define ERROR_NO_SUCH_GROUP              1319L

//
// MessageId: ERROR_MEMBER_IN_GROUP
//
// MessageText:
//
//  Either the specified user account is already a member of the specified
//  group, or the specified group cannot be deleted because it contains
//  a member.
//
#define ERROR_MEMBER_IN_GROUP            1320L

//
// MessageId: ERROR_MEMBER_NOT_IN_GROUP
//
// MessageText:
//
//  The specified user account is not a member of the specified group account.
//
#define ERROR_MEMBER_NOT_IN_GROUP        1321L

//
// MessageId: ERROR_LAST_ADMIN
//
// MessageText:
//
//  The last remaining administration account cannot be disabled
//  or deleted.
//
#define ERROR_LAST_ADMIN                 1322L

//
// MessageId: ERROR_WRONG_PASSWORD
//
// MessageText:
//
//  Unable to update the password.  The value provided as the current
//  password is incorrect.
//
#define ERROR_WRONG_PASSWORD             1323L

//
// MessageId: ERROR_ILL_FORMED_PASSWORD
//
// MessageText:
//
//  Unable to update the password.  The value provided for the new password
//  contains values that are not allowed in passwords.
//
#define ERROR_ILL_FORMED_PASSWORD        1324L

//
// MessageId: ERROR_PASSWORD_RESTRICTION
//
// MessageText:
//
//  Unable to update the password because a password update rule has been
//  violated.
//
#define ERROR_PASSWORD_RESTRICTION       1325L

//
// MessageId: ERROR_LOGON_FAILURE
//
// MessageText:
//
//  Logon failure: unknown user name or bad password.
//
#define ERROR_LOGON_FAILURE              1326L

//
// MessageId: ERROR_ACCOUNT_RESTRICTION
//
// MessageText:
//
//  Logon failure: user account restriction.
//
#define ERROR_ACCOUNT_RESTRICTION        1327L

//
// MessageId: ERROR_INVALID_LOGON_HOURS
//
// MessageText:
//
//  Logon failure: account logon time restriction violation.
//
#define ERROR_INVALID_LOGON_HOURS        1328L

//
// MessageId: ERROR_INVALID_WORKSTATION
//
// MessageText:
//
//  Logon failure: user not allowed to log on to this computer.
//
#define ERROR_INVALID_WORKSTATION        1329L

//
// MessageId: ERROR_PASSWORD_EXPIRED
//
// MessageText:
//
//  Logon failure: the specified account password has expired.
//
#define ERROR_PASSWORD_EXPIRED           1330L

//
// MessageId: ERROR_ACCOUNT_DISABLED
//
// MessageText:
//
//  Logon failure: account currently disabled.
//
#define ERROR_ACCOUNT_DISABLED           1331L

//
// MessageId: ERROR_NONE_MAPPED
//
// MessageText:
//
//  No mapping between account names and security IDs was done.
//
#define ERROR_NONE_MAPPED                1332L

//
// MessageId: ERROR_TOO_MANY_LUIDS_REQUESTED
//
// MessageText:
//
//  Too many local user identifiers (LUIDs) were requested at one time.
//
#define ERROR_TOO_MANY_LUIDS_REQUESTED   1333L

//
// MessageId: ERROR_LUIDS_EXHAUSTED
//
// MessageText:
//
//  No more local user identifiers (LUIDs) are available.
//
#define ERROR_LUIDS_EXHAUSTED            1334L

//
// MessageId: ERROR_INVALID_SUB_AUTHORITY
//
// MessageText:
//
//  The subauthority part of a security ID is invalid for this particular use.
//
#define ERROR_INVALID_SUB_AUTHORITY      1335L

//
// MessageId: ERROR_INVALID_ACL
//
// MessageText:
//
//  The access control list (ACL) structure is invalid.
//
#define ERROR_INVALID_ACL                1336L

//
// MessageId: ERROR_INVALID_SID
//
// MessageText:
//
//  The security ID structure is invalid.
//
#define ERROR_INVALID_SID                1337L

//
// MessageId: ERROR_INVALID_SECURITY_DESCR
//
// MessageText:
//
//  The security descriptor structure is invalid.
//
#define ERROR_INVALID_SECURITY_DESCR     1338L

//
// MessageId: ERROR_BAD_INHERITANCE_ACL
//
// MessageText:
//
//  The inherited access control list (ACL) or access control entry (ACE)
//  could not be built.
//
#define ERROR_BAD_INHERITANCE_ACL        1340L

//
// MessageId: ERROR_SERVER_DISABLED
//
// MessageText:
//
//  The server is currently disabled.
//
#define ERROR_SERVER_DISABLED            1341L

//
// MessageId: ERROR_SERVER_NOT_DISABLED
//
// MessageText:
//
//  The server is currently enabled.
//
#define ERROR_SERVER_NOT_DISABLED        1342L

//
// MessageId: ERROR_INVALID_ID_AUTHORITY
//
// MessageText:
//
//  The value provided was an invalid value for an identifier authority.
//
#define ERROR_INVALID_ID_AUTHORITY       1343L

//
// MessageId: ERROR_ALLOTTED_SPACE_EXCEEDED
//
// MessageText:
//
//  No more memory is available for security information updates.
//
#define ERROR_ALLOTTED_SPACE_EXCEEDED    1344L

//
// MessageId: ERROR_INVALID_GROUP_ATTRIBUTES
//
// MessageText:
//
//  The specified attributes are invalid, or incompatible with the
//  attributes for the group as a whole.
//
#define ERROR_INVALID_GROUP_ATTRIBUTES   1345L

//
// MessageId: ERROR_BAD_IMPERSONATION_LEVEL
//
// MessageText:
//
//  Either a required impersonation level was not provided, or the
//  provided impersonation level is invalid.
//
#define ERROR_BAD_IMPERSONATION_LEVEL    1346L

//
// MessageId: ERROR_CANT_OPEN_ANONYMOUS
//
// MessageText:
//
//  Cannot open an anonymous level security token.
//
#define ERROR_CANT_OPEN_ANONYMOUS        1347L

//
// MessageId: ERROR_BAD_VALIDATION_CLASS
//
// MessageText:
//
//  The validation information class requested was invalid.
//
#define ERROR_BAD_VALIDATION_CLASS       1348L

//
// MessageId: ERROR_BAD_TOKEN_TYPE
//
// MessageText:
//
//  The type of the token is inappropriate for its attempted use.
//
#define ERROR_BAD_TOKEN_TYPE             1349L

//
// MessageId: ERROR_NO_SECURITY_ON_OBJECT
//
// MessageText:
//
//  Unable to perform a security operation on an object
//  which has no associated security.
//
#define ERROR_NO_SECURITY_ON_OBJECT      1350L

//
// MessageId: ERROR_CANT_ACCESS_DOMAIN_INFO
//
// MessageText:
//
//  Either the domain controller is not available, or information
//  within the domain is protected.
//
#define ERROR_CANT_ACCESS_DOMAIN_INFO    1351L

//
// MessageId: ERROR_INVALID_SERVER_STATE
//
// MessageText:
//
//  The security account manager (SAM) or local security
//  authority (LSA) server was in the wrong state to perform
//  the security operation.
//
#define ERROR_INVALID_SERVER_STATE       1352L

//
// MessageId: ERROR_INVALID_DOMAIN_STATE
//
// MessageText:
//
//  The domain was in the wrong state to perform the security operation.
//
#define ERROR_INVALID_DOMAIN_STATE       1353L

//
// MessageId: ERROR_INVALID_DOMAIN_ROLE
//
// MessageText:
//
//  The requested operation cannot be completed by this domain controller
//  in its present role (backup or primary).
//
#define ERROR_INVALID_DOMAIN_ROLE        1354L

//
// MessageId: ERROR_NO_SUCH_DOMAIN
//
// MessageText:
//
//  The specified domain did not exist.
//
#define ERROR_NO_SUCH_DOMAIN             1355L

//
// MessageId: ERROR_DOMAIN_EXISTS
//
// MessageText:
//
//  The specified domain already exists.
//
#define ERROR_DOMAIN_EXISTS              1356L

//
// MessageId: ERROR_DOMAIN_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to exceed the limit on the number of domains per server.
//
#define ERROR_DOMAIN_LIMIT_EXCEEDED      1357L

//
// MessageId: ERROR_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
//  Unable to complete the requested operation because of either a
//  catastrophic media failure or a data structure corruption on the disk.
//
#define ERROR_INTERNAL_DB_CORRUPTION     1358L

//
// MessageId: ERROR_INTERNAL_ERROR
//
// MessageText:
//
//  The security account database contains an internal inconsistency.
//
#define ERROR_INTERNAL_ERROR             1359L

//
// MessageId: ERROR_GENERIC_NOT_MAPPED
//
// MessageText:
//
//  Generic access types were contained in an access mask which should
//  already be mapped to non-generic types.
//
#define ERROR_GENERIC_NOT_MAPPED         1360L

//
// MessageId: ERROR_BAD_DESCRIPTOR_FORMAT
//
// MessageText:
//
//  A security descriptor is not in the right format (absolute or self-relative).
//
#define ERROR_BAD_DESCRIPTOR_FORMAT      1361L

//
// MessageId: ERROR_NOT_LOGON_PROCESS
//
// MessageText:
//
//  The requested action is restricted for use by logon processes
//  only.  The calling process has not registered as a logon process.
//
#define ERROR_NOT_LOGON_PROCESS          1362L

//
// MessageId: ERROR_LOGON_SESSION_EXISTS
//
// MessageText:
//
//  Cannot start a new logon session with an ID that is already in use.
//
#define ERROR_LOGON_SESSION_EXISTS       1363L

//
// MessageId: ERROR_NO_SUCH_PACKAGE
//
// MessageText:
//
//  A specified authentication package is unknown.
//
#define ERROR_NO_SUCH_PACKAGE            1364L

//
// MessageId: ERROR_BAD_LOGON_SESSION_STATE
//
// MessageText:
//
//  The logon session is not in a state that is consistent with the
//  requested operation.
//
#define ERROR_BAD_LOGON_SESSION_STATE    1365L

//
// MessageId: ERROR_LOGON_SESSION_COLLISION
//
// MessageText:
//
//  The logon session ID is already in use.
//
#define ERROR_LOGON_SESSION_COLLISION    1366L

//
// MessageId: ERROR_INVALID_LOGON_TYPE
//
// MessageText:
//
//  A logon request contained an invalid logon type value.
//
#define ERROR_INVALID_LOGON_TYPE         1367L

//
// MessageId: ERROR_CANNOT_IMPERSONATE
//
// MessageText:
//
//  Unable to impersonate via a named pipe until data has been read
//  from that pipe.
//
#define ERROR_CANNOT_IMPERSONATE         1368L

//
// MessageId: ERROR_RXACT_INVALID_STATE
//
// MessageText:
//
//  The transaction state of a Registry subtree is incompatible with the
//  requested operation.
//
#define ERROR_RXACT_INVALID_STATE        1369L

//
// MessageId: ERROR_RXACT_COMMIT_FAILURE
//
// MessageText:
//
//  An internal security database corruption has been encountered.
//
#define ERROR_RXACT_COMMIT_FAILURE       1370L

//
// MessageId: ERROR_SPECIAL_ACCOUNT
//
// MessageText:
//
//  Cannot perform this operation on built-in accounts.
//
#define ERROR_SPECIAL_ACCOUNT            1371L

//
// MessageId: ERROR_SPECIAL_GROUP
//
// MessageText:
//
//  Cannot perform this operation on this built-in special group.
//
#define ERROR_SPECIAL_GROUP              1372L

//
// MessageId: ERROR_SPECIAL_USER
//
// MessageText:
//
//  Cannot perform this operation on this built-in special user.
//
#define ERROR_SPECIAL_USER               1373L

//
// MessageId: ERROR_MEMBERS_PRIMARY_GROUP
//
// MessageText:
//
//  The user cannot be removed from a group because the group
//  is currently the user's primary group.
//
#define ERROR_MEMBERS_PRIMARY_GROUP      1374L

//
// MessageId: ERROR_TOKEN_ALREADY_IN_USE
//
// MessageText:
//
//  The token is already in use as a primary token.
//
#define ERROR_TOKEN_ALREADY_IN_USE       1375L

//
// MessageId: ERROR_NO_SUCH_ALIAS
//
// MessageText:
//
//  The specified local group does not exist.
//
#define ERROR_NO_SUCH_ALIAS              1376L

//
// MessageId: ERROR_MEMBER_NOT_IN_ALIAS
//
// MessageText:
//
//  The specified account name is not a member of the local group.
//
#define ERROR_MEMBER_NOT_IN_ALIAS        1377L

//
// MessageId: ERROR_MEMBER_IN_ALIAS
//
// MessageText:
//
//  The specified account name is already a member of the local group.
//
#define ERROR_MEMBER_IN_ALIAS            1378L

//
// MessageId: ERROR_ALIAS_EXISTS
//
// MessageText:
//
//  The specified local group already exists.
//
#define ERROR_ALIAS_EXISTS               1379L

//
// MessageId: ERROR_LOGON_NOT_GRANTED
//
// MessageText:
//
//  Logon failure: the user has not been granted the requested
//  logon type at this computer.
//
#define ERROR_LOGON_NOT_GRANTED          1380L

//
// MessageId: ERROR_TOO_MANY_SECRETS
//
// MessageText:
//
//  The maximum number of secrets that may be stored in a single system has been
//  exceeded.
//
#define ERROR_TOO_MANY_SECRETS           1381L

//
// MessageId: ERROR_SECRET_TOO_LONG
//
// MessageText:
//
//  The length of a secret exceeds the maximum length allowed.
//
#define ERROR_SECRET_TOO_LONG            1382L

//
// MessageId: ERROR_INTERNAL_DB_ERROR
//
// MessageText:
//
//  The local security authority database contains an internal inconsistency.
//
#define ERROR_INTERNAL_DB_ERROR          1383L

//
// MessageId: ERROR_TOO_MANY_CONTEXT_IDS
//
// MessageText:
//
//  During a logon attempt, the user's security context accumulated too many
//  security IDs.
//
#define ERROR_TOO_MANY_CONTEXT_IDS       1384L

//
// MessageId: ERROR_LOGON_TYPE_NOT_GRANTED
//
// MessageText:
//
//  Logon failure: the user has not been granted the requested logon type
//  at this computer.
//
#define ERROR_LOGON_TYPE_NOT_GRANTED     1385L

//
// MessageId: ERROR_NT_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  A cross-encrypted password is necessary to change a user password.
//
#define ERROR_NT_CROSS_ENCRYPTION_REQUIRED 1386L

//
// MessageId: ERROR_NO_SUCH_MEMBER
//
// MessageText:
//
//  A new member could not be added to a local group because the member does
//  not exist.
//
#define ERROR_NO_SUCH_MEMBER             1387L

//
// MessageId: ERROR_INVALID_MEMBER
//
// MessageText:
//
//  A new member could not be added to an local group because the member has the
//  wrong account type.
//
#define ERROR_INVALID_MEMBER             1388L

//
// MessageId: ERROR_TOO_MANY_SIDS
//
// MessageText:
//
//  Too many security IDs have been specified.
//
#define ERROR_TOO_MANY_SIDS              1389L

//
// MessageId: ERROR_LM_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  A cross-encrypted password is necessary to change this user password.
//
#define ERROR_LM_CROSS_ENCRYPTION_REQUIRED 1390L

//
// MessageId: ERROR_NO_INHERITANCE
//
// MessageText:
//
//  Indicates an ACL contains no inheritable components
//
#define ERROR_NO_INHERITANCE             1391L

//
// MessageId: ERROR_FILE_CORRUPT
//
// MessageText:
//
//  The file or directory is corrupt and non-readable.
//
#define ERROR_FILE_CORRUPT               1392L

//
// MessageId: ERROR_DISK_CORRUPT
//
// MessageText:
//
//  The disk structure is corrupt and non-readable.
//
#define ERROR_DISK_CORRUPT               1393L

//
// MessageId: ERROR_NO_USER_SESSION_KEY
//
// MessageText:
//
//  There is no user session key for the specified logon session.
//
#define ERROR_NO_USER_SESSION_KEY        1394L

// End of security error codes



///////////////////////////
//                       //
// WinUser Error Codes   //
//                       //
///////////////////////////


//
// MessageId: ERROR_INVALID_WINDOW_HANDLE
//
// MessageText:
//
//  Invalid window handle.
//
#define ERROR_INVALID_WINDOW_HANDLE      1400L

//
// MessageId: ERROR_INVALID_MENU_HANDLE
//
// MessageText:
//
//  Invalid menu handle.
//
#define ERROR_INVALID_MENU_HANDLE        1401L

//
// MessageId: ERROR_INVALID_CURSOR_HANDLE
//
// MessageText:
//
//  Invalid cursor handle.
//
#define ERROR_INVALID_CURSOR_HANDLE      1402L

//
// MessageId: ERROR_INVALID_ACCEL_HANDLE
//
// MessageText:
//
//  Invalid accelerator table handle.
//
#define ERROR_INVALID_ACCEL_HANDLE       1403L

//
// MessageId: ERROR_INVALID_HOOK_HANDLE
//
// MessageText:
//
//  Invalid hook handle.
//
#define ERROR_INVALID_HOOK_HANDLE        1404L

//
// MessageId: ERROR_INVALID_DWP_HANDLE
//
// MessageText:
//
//  Invalid handle to a multiple-window position structure.
//
#define ERROR_INVALID_DWP_HANDLE         1405L

//
// MessageId: ERROR_TLW_WITH_WSCHILD
//
// MessageText:
//
//  Cannot create a top-level child window.
//
#define ERROR_TLW_WITH_WSCHILD           1406L

//
// MessageId: ERROR_CANNOT_FIND_WND_CLASS
//
// MessageText:
//
//  Cannot find window class.
//
#define ERROR_CANNOT_FIND_WND_CLASS      1407L

//
// MessageId: ERROR_WINDOW_OF_OTHER_THREAD
//
// MessageText:
//
//  Invalid window, belongs to other thread.
//
#define ERROR_WINDOW_OF_OTHER_THREAD     1408L

//
// MessageId: ERROR_HOTKEY_ALREADY_REGISTERED
//
// MessageText:
//
//  Hot key is already registered.
//
#define ERROR_HOTKEY_ALREADY_REGISTERED  1409L

//
// MessageId: ERROR_CLASS_ALREADY_EXISTS
//
// MessageText:
//
//  Class already exists.
//
#define ERROR_CLASS_ALREADY_EXISTS       1410L

//
// MessageId: ERROR_CLASS_DOES_NOT_EXIST
//
// MessageText:
//
//  Class does not exist.
//
#define ERROR_CLASS_DOES_NOT_EXIST       1411L

//
// MessageId: ERROR_CLASS_HAS_WINDOWS
//
// MessageText:
//
//  Class still has open windows.
//
#define ERROR_CLASS_HAS_WINDOWS          1412L

//
// MessageId: ERROR_INVALID_INDEX
//
// MessageText:
//
//  Invalid index.
//
#define ERROR_INVALID_INDEX              1413L

//
// MessageId: ERROR_INVALID_ICON_HANDLE
//
// MessageText:
//
//  Invalid icon handle.
//
#define ERROR_INVALID_ICON_HANDLE        1414L

//
// MessageId: ERROR_PRIVATE_DIALOG_INDEX
//
// MessageText:
//
//  Using private DIALOG window words.
//
#define ERROR_PRIVATE_DIALOG_INDEX       1415L

//
// MessageId: ERROR_LISTBOX_ID_NOT_FOUND
//
// MessageText:
//
//  The listbox identifier was not found.
//
#define ERROR_LISTBOX_ID_NOT_FOUND       1416L

//
// MessageId: ERROR_NO_WILDCARD_CHARACTERS
//
// MessageText:
//
//  No wildcards were found.
//
#define ERROR_NO_WILDCARD_CHARACTERS     1417L

//
// MessageId: ERROR_CLIPBOARD_NOT_OPEN
//
// MessageText:
//
//  Thread does not have a clipboard open.
//
#define ERROR_CLIPBOARD_NOT_OPEN         1418L

//
// MessageId: ERROR_HOTKEY_NOT_REGISTERED
//
// MessageText:
//
//  Hot key is not registered.
//
#define ERROR_HOTKEY_NOT_REGISTERED      1419L

//
// MessageId: ERROR_WINDOW_NOT_DIALOG
//
// MessageText:
//
//  The window is not a valid dialog window.
//
#define ERROR_WINDOW_NOT_DIALOG          1420L

//
// MessageId: ERROR_CONTROL_ID_NOT_FOUND
//
// MessageText:
//
//  Control ID not found.
//
#define ERROR_CONTROL_ID_NOT_FOUND       1421L

//
// MessageId: ERROR_INVALID_COMBOBOX_MESSAGE
//
// MessageText:
//
//  Invalid message for a combo box because it does not have an edit control.
//
#define ERROR_INVALID_COMBOBOX_MESSAGE   1422L

//
// MessageId: ERROR_WINDOW_NOT_COMBOBOX
//
// MessageText:
//
//  The window is not a combo box.
//
#define ERROR_WINDOW_NOT_COMBOBOX        1423L

//
// MessageId: ERROR_INVALID_EDIT_HEIGHT
//
// MessageText:
//
//  Height must be less than 256.
//
#define ERROR_INVALID_EDIT_HEIGHT        1424L

//
// MessageId: ERROR_DC_NOT_FOUND
//
// MessageText:
//
//  Invalid device context (DC) handle.
//
#define ERROR_DC_NOT_FOUND               1425L

//
// MessageId: ERROR_INVALID_HOOK_FILTER
//
// MessageText:
//
//  Invalid hook procedure type.
//
#define ERROR_INVALID_HOOK_FILTER        1426L

//
// MessageId: ERROR_INVALID_FILTER_PROC
//
// MessageText:
//
//  Invalid hook procedure.
//
#define ERROR_INVALID_FILTER_PROC        1427L

//
// MessageId: ERROR_HOOK_NEEDS_HMOD
//
// MessageText:
//
//  Cannot set non-local hook without a module handle.
//
#define ERROR_HOOK_NEEDS_HMOD            1428L

//
// MessageId: ERROR_GLOBAL_ONLY_HOOK
//
// MessageText:
//
//  This hook procedure can only be set globally.
//
#define ERROR_GLOBAL_ONLY_HOOK           1429L

//
// MessageId: ERROR_JOURNAL_HOOK_SET
//
// MessageText:
//
//  The journal hook procedure is already installed.
//
#define ERROR_JOURNAL_HOOK_SET           1430L

//
// MessageId: ERROR_HOOK_NOT_INSTALLED
//
// MessageText:
//
//  The hook procedure is not installed.
//
#define ERROR_HOOK_NOT_INSTALLED         1431L

//
// MessageId: ERROR_INVALID_LB_MESSAGE
//
// MessageText:
//
//  Invalid message for single-selection listbox.
//
#define ERROR_INVALID_LB_MESSAGE         1432L

//
// MessageId: ERROR_SETCOUNT_ON_BAD_LB
//
// MessageText:
//
//  LB_SETCOUNT sent to non-lazy listbox.
//
#define ERROR_SETCOUNT_ON_BAD_LB         1433L

//
// MessageId: ERROR_LB_WITHOUT_TABSTOPS
//
// MessageText:
//
//  This list box does not support tab stops.
//
#define ERROR_LB_WITHOUT_TABSTOPS        1434L

//
// MessageId: ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
//
// MessageText:
//
//  Cannot destroy object created by another thread.
//
#define ERROR_DESTROY_OBJECT_OF_OTHER_THREAD 1435L

//
// MessageId: ERROR_CHILD_WINDOW_MENU
//
// MessageText:
//
//  Child windows cannot have menus.
//
#define ERROR_CHILD_WINDOW_MENU          1436L

//
// MessageId: ERROR_NO_SYSTEM_MENU
//
// MessageText:
//
//  The window does not have a system menu.
//
#define ERROR_NO_SYSTEM_MENU             1437L

//
// MessageId: ERROR_INVALID_MSGBOX_STYLE
//
// MessageText:
//
//  Invalid message box style.
//
#define ERROR_INVALID_MSGBOX_STYLE       1438L

//
// MessageId: ERROR_INVALID_SPI_VALUE
//
// MessageText:
//
//  Invalid system-wide (SPI_*) parameter.
//
#define ERROR_INVALID_SPI_VALUE          1439L

//
// MessageId: ERROR_SCREEN_ALREADY_LOCKED
//
// MessageText:
//
//  Screen already locked.
//
#define ERROR_SCREEN_ALREADY_LOCKED      1440L

//
// MessageId: ERROR_HWNDS_HAVE_DIFF_PARENT
//
// MessageText:
//
//  All handles to windows in a multiple-window position structure must
//  have the same parent.
//
#define ERROR_HWNDS_HAVE_DIFF_PARENT     1441L

//
// MessageId: ERROR_NOT_CHILD_WINDOW
//
// MessageText:
//
//  The window is not a child window.
//
#define ERROR_NOT_CHILD_WINDOW           1442L

//
// MessageId: ERROR_INVALID_GW_COMMAND
//
// MessageText:
//
//  Invalid GW_* command.
//
#define ERROR_INVALID_GW_COMMAND         1443L

//
// MessageId: ERROR_INVALID_THREAD_ID
//
// MessageText:
//
//  Invalid thread identifier.
//
#define ERROR_INVALID_THREAD_ID          1444L

//
// MessageId: ERROR_NON_MDICHILD_WINDOW
//
// MessageText:
//
//  Cannot process a message from a window that is not a multiple document
//  interface (MDI) window.
//
#define ERROR_NON_MDICHILD_WINDOW        1445L

//
// MessageId: ERROR_POPUP_ALREADY_ACTIVE
//
// MessageText:
//
//  Popup menu already active.
//
#define ERROR_POPUP_ALREADY_ACTIVE       1446L

//
// MessageId: ERROR_NO_SCROLLBARS
//
// MessageText:
//
//  The window does not have scroll bars.
//
#define ERROR_NO_SCROLLBARS              1447L

//
// MessageId: ERROR_INVALID_SCROLLBAR_RANGE
//
// MessageText:
//
//  Scroll bar range cannot be greater than 0x7FFF.
//
#define ERROR_INVALID_SCROLLBAR_RANGE    1448L

//
// MessageId: ERROR_INVALID_SHOWWIN_COMMAND
//
// MessageText:
//
//  Cannot show or remove the window in the way specified.
//
#define ERROR_INVALID_SHOWWIN_COMMAND    1449L

// End of WinUser error codes



///////////////////////////
//                       //
// Eventlog Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_EVENTLOG_FILE_CORRUPT
//
// MessageText:
//
//  The event log file is corrupt.
//
#define ERROR_EVENTLOG_FILE_CORRUPT      1500L

//
// MessageId: ERROR_EVENTLOG_CANT_START
//
// MessageText:
//
//  No event log file could be opened, so the event logging service did not start.
//
#define ERROR_EVENTLOG_CANT_START        1501L

//
// MessageId: ERROR_LOG_FILE_FULL
//
// MessageText:
//
//  The event log file is full.
//
#define ERROR_LOG_FILE_FULL              1502L

//
// MessageId: ERROR_EVENTLOG_FILE_CHANGED
//
// MessageText:
//
//  The event log file has changed between reads.
//
#define ERROR_EVENTLOG_FILE_CHANGED      1503L

// End of eventlog error codes



///////////////////////////
//                       //
//   RPC Status Codes    //
//                       //
///////////////////////////


//
// MessageId: RPC_S_INVALID_STRING_BINDING
//
// MessageText:
//
//  The string binding is invalid.
//
#define RPC_S_INVALID_STRING_BINDING     1700L

//
// MessageId: RPC_S_WRONG_KIND_OF_BINDING
//
// MessageText:
//
//  The binding handle is not the correct type.
//
#define RPC_S_WRONG_KIND_OF_BINDING      1701L

//
// MessageId: RPC_S_INVALID_BINDING
//
// MessageText:
//
//  The binding handle is invalid.
//
#define RPC_S_INVALID_BINDING            1702L

//
// MessageId: RPC_S_PROTSEQ_NOT_SUPPORTED
//
// MessageText:
//
//  The RPC protocol sequence is not supported.
//
#define RPC_S_PROTSEQ_NOT_SUPPORTED      1703L

//
// MessageId: RPC_S_INVALID_RPC_PROTSEQ
//
// MessageText:
//
//  The RPC protocol sequence is invalid.
//
#define RPC_S_INVALID_RPC_PROTSEQ        1704L

//
// MessageId: RPC_S_INVALID_STRING_UUID
//
// MessageText:
//
//  The string universal unique identifier (UUID) is invalid.
//
#define RPC_S_INVALID_STRING_UUID        1705L

//
// MessageId: RPC_S_INVALID_ENDPOINT_FORMAT
//
// MessageText:
//
//  The endpoint format is invalid.
//
#define RPC_S_INVALID_ENDPOINT_FORMAT    1706L

//
// MessageId: RPC_S_INVALID_NET_ADDR
//
// MessageText:
//
//  The network address is invalid.
//
#define RPC_S_INVALID_NET_ADDR           1707L

//
// MessageId: RPC_S_NO_ENDPOINT_FOUND
//
// MessageText:
//
//  No endpoint was found.
//
#define RPC_S_NO_ENDPOINT_FOUND          1708L

//
// MessageId: RPC_S_INVALID_TIMEOUT
//
// MessageText:
//
//  The timeout value is invalid.
//
#define RPC_S_INVALID_TIMEOUT            1709L

//
// MessageId: RPC_S_OBJECT_NOT_FOUND
//
// MessageText:
//
//  The object universal unique identifier (UUID) was not found.
//
#define RPC_S_OBJECT_NOT_FOUND           1710L

//
// MessageId: RPC_S_ALREADY_REGISTERED
//
// MessageText:
//
//  The object universal unique identifier (UUID) has already been registered.
//
#define RPC_S_ALREADY_REGISTERED         1711L

//
// MessageId: RPC_S_TYPE_ALREADY_REGISTERED
//
// MessageText:
//
//  The type universal unique identifier (UUID) has already been registered.
//
#define RPC_S_TYPE_ALREADY_REGISTERED    1712L

//
// MessageId: RPC_S_ALREADY_LISTENING
//
// MessageText:
//
//  The RPC server is already listening.
//
#define RPC_S_ALREADY_LISTENING          1713L

//
// MessageId: RPC_S_NO_PROTSEQS_REGISTERED
//
// MessageText:
//
//  No protocol sequences have been registered.
//
#define RPC_S_NO_PROTSEQS_REGISTERED     1714L

//
// MessageId: RPC_S_NOT_LISTENING
//
// MessageText:
//
//  The RPC server is not listening.
//
#define RPC_S_NOT_LISTENING              1715L

//
// MessageId: RPC_S_UNKNOWN_MGR_TYPE
//
// MessageText:
//
//  The manager type is unknown.
//
#define RPC_S_UNKNOWN_MGR_TYPE           1716L

//
// MessageId: RPC_S_UNKNOWN_IF
//
// MessageText:
//
//  The interface is unknown.
//
#define RPC_S_UNKNOWN_IF                 1717L

//
// MessageId: RPC_S_NO_BINDINGS
//
// MessageText:
//
//  There are no bindings.
//
#define RPC_S_NO_BINDINGS                1718L

//
// MessageId: RPC_S_NO_PROTSEQS
//
// MessageText:
//
//  There are no protocol sequences.
//
#define RPC_S_NO_PROTSEQS                1719L

//
// MessageId: RPC_S_CANT_CREATE_ENDPOINT
//
// MessageText:
//
//  The endpoint cannot be created.
//
#define RPC_S_CANT_CREATE_ENDPOINT       1720L

//
// MessageId: RPC_S_OUT_OF_RESOURCES
//
// MessageText:
//
//  Not enough resources are available to complete this operation.
//
#define RPC_S_OUT_OF_RESOURCES           1721L

//
// MessageId: RPC_S_SERVER_UNAVAILABLE
//
// MessageText:
//
//  The RPC server is unavailable.
//
#define RPC_S_SERVER_UNAVAILABLE         1722L

//
// MessageId: RPC_S_SERVER_TOO_BUSY
//
// MessageText:
//
//  The RPC server is too busy to complete this operation.
//
#define RPC_S_SERVER_TOO_BUSY            1723L

//
// MessageId: RPC_S_INVALID_NETWORK_OPTIONS
//
// MessageText:
//
//  The network options are invalid.
//
#define RPC_S_INVALID_NETWORK_OPTIONS    1724L

//
// MessageId: RPC_S_NO_CALL_ACTIVE
//
// MessageText:
//
//  There is not a remote procedure call active in this thread.
//
#define RPC_S_NO_CALL_ACTIVE             1725L

//
// MessageId: RPC_S_CALL_FAILED
//
// MessageText:
//
//  The remote procedure call failed.
//
#define RPC_S_CALL_FAILED                1726L

//
// MessageId: RPC_S_CALL_FAILED_DNE
//
// MessageText:
//
//  The remote procedure call failed and did not execute.
//
#define RPC_S_CALL_FAILED_DNE            1727L

//
// MessageId: RPC_S_PROTOCOL_ERROR
//
// MessageText:
//
//  A remote procedure call (RPC) protocol error occurred.
//
#define RPC_S_PROTOCOL_ERROR             1728L

//
// MessageId: RPC_S_CANNOT_BIND
//
// MessageText:
//
//  An attempt to bind with the RPC server failed.
//
#define RPC_S_CANNOT_BIND                1729L

//
// MessageId: RPC_S_UNSUPPORTED_TRANS_SYN
//
// MessageText:
//
//  The transfer syntax is not supported by the RPC server.
//
#define RPC_S_UNSUPPORTED_TRANS_SYN      1730L

//
// MessageId: RPC_S_SERVER_OUT_OF_MEMORY
//
// MessageText:
//
//  The RPC server has insufficient memory to complete this operation.
//
#define RPC_S_SERVER_OUT_OF_MEMORY       1731L

//
// MessageId: RPC_S_UNSUPPORTED_TYPE
//
// MessageText:
//
//  The universal unique identifier (UUID) type is not supported.
//
#define RPC_S_UNSUPPORTED_TYPE           1732L

//
// MessageId: RPC_S_INVALID_TAG
//
// MessageText:
//
//  The tag is invalid.
//
#define RPC_S_INVALID_TAG                1733L

//
// MessageId: RPC_S_INVALID_BOUND
//
// MessageText:
//
//  The array bounds are invalid.
//
#define RPC_S_INVALID_BOUND              1734L

//
// MessageId: RPC_S_NO_ENTRY_NAME
//
// MessageText:
//
//  The binding does not contain an entry name.
//
#define RPC_S_NO_ENTRY_NAME              1735L

//
// MessageId: RPC_S_INVALID_NAME_SYNTAX
//
// MessageText:
//
//  The name syntax is invalid.
//
#define RPC_S_INVALID_NAME_SYNTAX        1736L

//
// MessageId: RPC_S_UNSUPPORTED_NAME_SYNTAX
//
// MessageText:
//
//  The name syntax is not supported.
//
#define RPC_S_UNSUPPORTED_NAME_SYNTAX    1737L

//
// MessageId: RPC_S_SERVER_NOT_LISTENING
//
// MessageText:
//
//  The RPC server is not listening for remote procedure calls.
//
#define RPC_S_SERVER_NOT_LISTENING       1738L

//
// MessageId: RPC_S_UUID_NO_ADDRESS
//
// MessageText:
//
//  No network address is available to use to construct a universal
//  unique identifier (UUID).
//
#define RPC_S_UUID_NO_ADDRESS            1739L

//
// MessageId: RPC_S_DUPLICATE_ENDPOINT
//
// MessageText:
//
//  The endpoint is a duplicate.
//
#define RPC_S_DUPLICATE_ENDPOINT         1740L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_TYPE
//
// MessageText:
//
//  The authentication type is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_TYPE         1741L

//
// MessageId: RPC_S_MAX_CALLS_TOO_SMALL
//
// MessageText:
//
//  The maximum number of calls is too small.
//
#define RPC_S_MAX_CALLS_TOO_SMALL        1742L

//
// MessageId: RPC_S_STRING_TOO_LONG
//
// MessageText:
//
//  The string is too long.
//
#define RPC_S_STRING_TOO_LONG            1743L

//
// MessageId: RPC_S_PROTSEQ_NOT_FOUND
//
// MessageText:
//
//  The RPC protocol sequence was not found.
//
#define RPC_S_PROTSEQ_NOT_FOUND          1744L

//
// MessageId: RPC_S_PROCNUM_OUT_OF_RANGE
//
// MessageText:
//
//  The procedure number is out of range.
//
#define RPC_S_PROCNUM_OUT_OF_RANGE       1745L

//
// MessageId: RPC_S_BINDING_HAS_NO_AUTH
//
// MessageText:
//
//  The binding does not contain any authentication information.
//
#define RPC_S_BINDING_HAS_NO_AUTH        1746L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_SERVICE
//
// MessageText:
//
//  The authentication service is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_SERVICE      1747L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_LEVEL
//
// MessageText:
//
//  The authentication level is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_LEVEL        1748L

//
// MessageId: RPC_S_INVALID_AUTH_IDENTITY
//
// MessageText:
//
//  The security context is invalid.
//
#define RPC_S_INVALID_AUTH_IDENTITY      1749L

//
// MessageId: RPC_S_UNKNOWN_AUTHZ_SERVICE
//
// MessageText:
//
//  The authorization service is unknown.
//
#define RPC_S_UNKNOWN_AUTHZ_SERVICE      1750L

//
// MessageId: EPT_S_INVALID_ENTRY
//
// MessageText:
//
//  The entry is invalid.
//
#define EPT_S_INVALID_ENTRY              1751L

//
// MessageId: EPT_S_CANT_PERFORM_OP
//
// MessageText:
//
//  The server endpoint cannot perform the operation.
//
#define EPT_S_CANT_PERFORM_OP            1752L

//
// MessageId: EPT_S_NOT_REGISTERED
//
// MessageText:
//
//  There are no more endpoints available from the endpoint mapper.
//
#define EPT_S_NOT_REGISTERED             1753L

//
// MessageId: RPC_S_NOTHING_TO_EXPORT
//
// MessageText:
//
//  No interfaces have been exported.
//
#define RPC_S_NOTHING_TO_EXPORT          1754L

//
// MessageId: RPC_S_INCOMPLETE_NAME
//
// MessageText:
//
//  The entry name is incomplete.
//
#define RPC_S_INCOMPLETE_NAME            1755L

//
// MessageId: RPC_S_INVALID_VERS_OPTION
//
// MessageText:
//
//  The version option is invalid.
//
#define RPC_S_INVALID_VERS_OPTION        1756L

//
// MessageId: RPC_S_NO_MORE_MEMBERS
//
// MessageText:
//
//  There are no more members.
//
#define RPC_S_NO_MORE_MEMBERS            1757L

//
// MessageId: RPC_S_NOT_ALL_OBJS_UNEXPORTED
//
// MessageText:
//
//  There is nothing to unexport.
//
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED    1758L

//
// MessageId: RPC_S_INTERFACE_NOT_FOUND
//
// MessageText:
//
//  The interface was not found.
//
#define RPC_S_INTERFACE_NOT_FOUND        1759L

//
// MessageId: RPC_S_ENTRY_ALREADY_EXISTS
//
// MessageText:
//
//  The entry already exists.
//
#define RPC_S_ENTRY_ALREADY_EXISTS       1760L

//
// MessageId: RPC_S_ENTRY_NOT_FOUND
//
// MessageText:
//
//  The entry is not found.
//
#define RPC_S_ENTRY_NOT_FOUND            1761L

//
// MessageId: RPC_S_NAME_SERVICE_UNAVAILABLE
//
// MessageText:
//
//  The name service is unavailable.
//
#define RPC_S_NAME_SERVICE_UNAVAILABLE   1762L

//
// MessageId: RPC_S_INVALID_NAF_IF
//
// MessageText:
//
//  The network address family is invalid.
//
#define RPC_S_INVALID_NAF_IF             1763L

//
// MessageId: RPC_S_CANNOT_SUPPORT
//
// MessageText:
//
//  The requested operation is not supported.
//
#define RPC_S_CANNOT_SUPPORT             1764L

//
// MessageId: RPC_S_NO_CONTEXT_AVAILABLE
//
// MessageText:
//
//  No security context is available to allow impersonation.
//
#define RPC_S_NO_CONTEXT_AVAILABLE       1765L

//
// MessageId: RPC_S_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error occurred in a remote procedure call (RPC).
//
#define RPC_S_INTERNAL_ERROR             1766L

//
// MessageId: RPC_S_ZERO_DIVIDE
//
// MessageText:
//
//  The RPC server attempted an integer division by zero.
//
#define RPC_S_ZERO_DIVIDE                1767L

//
// MessageId: RPC_S_ADDRESS_ERROR
//
// MessageText:
//
//  An addressing error occurred in the RPC server.
//
#define RPC_S_ADDRESS_ERROR              1768L

//
// MessageId: RPC_S_FP_DIV_ZERO
//
// MessageText:
//
//  A floating-point operation at the RPC server caused a division by zero.
//
#define RPC_S_FP_DIV_ZERO                1769L

//
// MessageId: RPC_S_FP_UNDERFLOW
//
// MessageText:
//
//  A floating-point underflow occurred at the RPC server.
//
#define RPC_S_FP_UNDERFLOW               1770L

//
// MessageId: RPC_S_FP_OVERFLOW
//
// MessageText:
//
//  A floating-point overflow occurred at the RPC server.
//
#define RPC_S_FP_OVERFLOW                1771L

//
// MessageId: RPC_X_NO_MORE_ENTRIES
//
// MessageText:
//
//  The list of RPC servers available for the binding of auto handles
//  has been exhausted.
//
#define RPC_X_NO_MORE_ENTRIES            1772L

//
// MessageId: RPC_X_SS_CHAR_TRANS_OPEN_FAIL
//
// MessageText:
//
//  Unable to open the character translation table file.
//
#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL    1773L

//
// MessageId: RPC_X_SS_CHAR_TRANS_SHORT_FILE
//
// MessageText:
//
//  The file containing the character translation table has fewer than
//  512 bytes.
//
#define RPC_X_SS_CHAR_TRANS_SHORT_FILE   1774L

//
// MessageId: RPC_X_SS_IN_NULL_CONTEXT
//
// MessageText:
//
//  A null context handle was passed from the client to the host during
//  a remote procedure call.
//
#define RPC_X_SS_IN_NULL_CONTEXT         1775L

//
// MessageId: RPC_X_SS_CONTEXT_DAMAGED
//
// MessageText:
//
//  The context handle changed during a remote procedure call.
//
#define RPC_X_SS_CONTEXT_DAMAGED         1777L

//
// MessageId: RPC_X_SS_HANDLES_MISMATCH
//
// MessageText:
//
//  The binding handles passed to a remote procedure call do not match.
//
#define RPC_X_SS_HANDLES_MISMATCH        1778L

//
// MessageId: RPC_X_SS_CANNOT_GET_CALL_HANDLE
//
// MessageText:
//
//  The stub is unable to get the remote procedure call handle.
//
#define RPC_X_SS_CANNOT_GET_CALL_HANDLE  1779L

//
// MessageId: RPC_X_NULL_REF_POINTER
//
// MessageText:
//
//  A null reference pointer was passed to the stub.
//
#define RPC_X_NULL_REF_POINTER           1780L

//
// MessageId: RPC_X_ENUM_VALUE_OUT_OF_RANGE
//
// MessageText:
//
//  The enumeration value is out of range.
//
#define RPC_X_ENUM_VALUE_OUT_OF_RANGE    1781L

//
// MessageId: RPC_X_BYTE_COUNT_TOO_SMALL
//
// MessageText:
//
//  The byte count is too small.
//
#define RPC_X_BYTE_COUNT_TOO_SMALL       1782L

//
// MessageId: RPC_X_BAD_STUB_DATA
//
// MessageText:
//
//  The stub received bad data.
//
#define RPC_X_BAD_STUB_DATA              1783L

//
// MessageId: ERROR_INVALID_USER_BUFFER
//
// MessageText:
//
//  The supplied user buffer is not valid for the requested operation.
//
#define ERROR_INVALID_USER_BUFFER        1784L

//
// MessageId: ERROR_UNRECOGNIZED_MEDIA
//
// MessageText:
//
//  The disk media is not recognized.  It may not be formatted.
//
#define ERROR_UNRECOGNIZED_MEDIA         1785L

//
// MessageId: ERROR_NO_TRUST_LSA_SECRET
//
// MessageText:
//
//  The workstation does not have a trust secret.
//
#define ERROR_NO_TRUST_LSA_SECRET        1786L

//
// MessageId: ERROR_NO_TRUST_SAM_ACCOUNT
//
// MessageText:
//
//  The domain controller does not have an account for this workstation.
//
#define ERROR_NO_TRUST_SAM_ACCOUNT       1787L

//
// MessageId: ERROR_TRUSTED_DOMAIN_FAILURE
//
// MessageText:
//
//  The trust relationship between the primary domain and the trusted
//  domain failed.
//
#define ERROR_TRUSTED_DOMAIN_FAILURE     1788L

//
// MessageId: ERROR_TRUSTED_RELATIONSHIP_FAILURE
//
// MessageText:
//
//  The trust relationship between this workstation and the primary
//  domain failed.
//
#define ERROR_TRUSTED_RELATIONSHIP_FAILURE 1789L

//
// MessageId: ERROR_TRUST_FAILURE
//
// MessageText:
//
//  The network logon failed.
//
#define ERROR_TRUST_FAILURE              1790L

//
// MessageId: RPC_S_CALL_IN_PROGRESS
//
// MessageText:
//
//  A remote procedure call is already in progress for this thread.
//
#define RPC_S_CALL_IN_PROGRESS           1791L

//
// MessageId: ERROR_NETLOGON_NOT_STARTED
//
// MessageText:
//
//  An attempt was made to logon, but the network logon service was not started.
//
#define ERROR_NETLOGON_NOT_STARTED       1792L

//
// MessageId: ERROR_ACCOUNT_EXPIRED
//
// MessageText:
//
//  The user's account has expired.
//
#define ERROR_ACCOUNT_EXPIRED            1793L

//
// MessageId: ERROR_REDIRECTOR_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The redirector is in use and cannot be unloaded.
//
#define ERROR_REDIRECTOR_HAS_OPEN_HANDLES 1794L

//
// MessageId: ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified printer driver is already installed.
//
#define ERROR_PRINTER_DRIVER_ALREADY_INSTALLED 1795L

//
// MessageId: ERROR_UNKNOWN_PORT
//
// MessageText:
//
//  The specified port is unknown.
//
#define ERROR_UNKNOWN_PORT               1796L

//
// MessageId: ERROR_UNKNOWN_PRINTER_DRIVER
//
// MessageText:
//
//  The printer driver is unknown.
//
#define ERROR_UNKNOWN_PRINTER_DRIVER     1797L

//
// MessageId: ERROR_UNKNOWN_PRINTPROCESSOR
//
// MessageText:
//
//  The print processor is unknown.
//
#define ERROR_UNKNOWN_PRINTPROCESSOR     1798L

//
// MessageId: ERROR_INVALID_SEPARATOR_FILE
//
// MessageText:
//
//  The specified separator file is invalid.
//
#define ERROR_INVALID_SEPARATOR_FILE     1799L

//
// MessageId: ERROR_INVALID_PRIORITY
//
// MessageText:
//
//  The specified priority is invalid.
//
#define ERROR_INVALID_PRIORITY           1800L

//
// MessageId: ERROR_INVALID_PRINTER_NAME
//
// MessageText:
//
//  The printer name is invalid.
//
#define ERROR_INVALID_PRINTER_NAME       1801L

//
// MessageId: ERROR_PRINTER_ALREADY_EXISTS
//
// MessageText:
//
//  The printer already exists.
//
#define ERROR_PRINTER_ALREADY_EXISTS     1802L

//
// MessageId: ERROR_INVALID_PRINTER_COMMAND
//
// MessageText:
//
//  The printer command is invalid.
//
#define ERROR_INVALID_PRINTER_COMMAND    1803L

//
// MessageId: ERROR_INVALID_DATATYPE
//
// MessageText:
//
//  The specified datatype is invalid.
//
#define ERROR_INVALID_DATATYPE           1804L

//
// MessageId: ERROR_INVALID_ENVIRONMENT
//
// MessageText:
//
//  The Environment specified is invalid.
//
#define ERROR_INVALID_ENVIRONMENT        1805L

//
// MessageId: RPC_S_NO_MORE_BINDINGS
//
// MessageText:
//
//  There are no more bindings.
//
#define RPC_S_NO_MORE_BINDINGS           1806L

//
// MessageId: ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an interdomain trust account.  Use your normal user account or remote user account to access this server.
//
#define ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT 1807L

//
// MessageId: ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is a workstation trust account.  Use your normal user account or remote user account to access this server.
//
#define ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT 1808L

//
// MessageId: ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an server trust account.  Use your normal user account or remote user account to access this server.
//
#define ERROR_NOLOGON_SERVER_TRUST_ACCOUNT 1809L

//
// MessageId: ERROR_DOMAIN_TRUST_INCONSISTENT
//
// MessageText:
//
//  The name or security ID (SID) of the domain specified is inconsitent
//  with the trust information for that domain.
//
#define ERROR_DOMAIN_TRUST_INCONSISTENT  1810L

//
// MessageId: ERROR_SERVER_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The server is in use and cannot be unloaded.
//
#define ERROR_SERVER_HAS_OPEN_HANDLES    1811L

//
// MessageId: ERROR_RESOURCE_DATA_NOT_FOUND
//
// MessageText:
//
//  The specified image file did not contain a resource section.
//
#define ERROR_RESOURCE_DATA_NOT_FOUND    1812L

//
// MessageId: ERROR_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
//  The specified resource type can not be found in the image file.
//
#define ERROR_RESOURCE_TYPE_NOT_FOUND    1813L

//
// MessageId: ERROR_RESOURCE_NAME_NOT_FOUND
//
// MessageText:
//
//  The specified resource name can not be found in the image file.
//
#define ERROR_RESOURCE_NAME_NOT_FOUND    1814L

//
// MessageId: ERROR_RESOURCE_LANG_NOT_FOUND
//
// MessageText:
//
//  The specified resource language ID cannot be found in the image file.
//
#define ERROR_RESOURCE_LANG_NOT_FOUND    1815L

//
// MessageId: ERROR_NOT_ENOUGH_QUOTA
//
// MessageText:
//
//  Not enough quota is available to process this command.
//
#define ERROR_NOT_ENOUGH_QUOTA           1816L    // dderror

//
// MessageId: RPC_S_GROUP_MEMBER_NOT_FOUND
//
// MessageText:
//
//  The group member was not found.
//
#define RPC_S_GROUP_MEMBER_NOT_FOUND     1898L

//
// MessageId: EPT_S_CANT_CREATE
//
// MessageText:
//
//  The endpoint mapper database could not be created.
//
#define EPT_S_CANT_CREATE                1899L

//
// MessageId: RPC_S_INVALID_OBJECT
//
// MessageText:
//
//  The object universal unique identifier (UUID) is the nil UUID.
//
#define RPC_S_INVALID_OBJECT             1900L

#endif // _WINERROR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\windowsx.h ===
/*****************************************************************************\
*                                                                             *
* windowsx.h -  Macro APIs, window message crackers, and control APIs         *
*                                                                             *
* Version 3.10								      *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWSX
#define _INC_WINDOWSX

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****** KERNEL Macro APIs ****************************************************/

#define     GetInstanceModule(hInstance) \
                GetModuleHandle((LPCSTR)MAKELP(0, hInstance))

#define     GlobalPtrHandle(lp)         \
                ((HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(lp))))

#define     GlobalLockPtr(lp)		\
                ((BOOL)SELECTOROF(GlobalLock(GlobalPtrHandle(lp))))
#define     GlobalUnlockPtr(lp) 	\
                GlobalUnlock(GlobalPtrHandle(lp))

#define     GlobalAllocPtr(flags, cb)	\
                (GlobalLock(GlobalAlloc((flags), (cb))))
#define     GlobalReAllocPtr(lp, cbNew, flags)	\
                (GlobalUnlockPtr(lp), GlobalLock(GlobalReAlloc(GlobalPtrHandle(lp) , (cbNew), (flags))))
#define     GlobalFreePtr(lp)		\
                (GlobalUnlockPtr(lp), (BOOL)GlobalFree(GlobalPtrHandle(lp)))

/****** GDI Macro APIs *******************************************************/

#define     DeletePen(hpen)	    DeleteObject((HGDIOBJ)(HPEN)(hpen))
#define     SelectPen(hdc, hpen)    ((HPEN)SelectObject((hdc), (HGDIOBJ)(HPEN)(hpen)))
#define     GetStockPen(i)	    ((HPEN)GetStockObject(i))

#define     DeleteBrush(hbr)	    DeleteObject((HGDIOBJ)(HBRUSH)(hbr))
#define     SelectBrush(hdc, hbr)   ((HBRUSH)SelectObject((hdc), (HGDIOBJ)(HBRUSH)(hbr)))
#define     GetStockBrush(i)	    ((HBRUSH)GetStockObject(i))

#define     DeleteRgn(hrgn)	    DeleteObject((HGDIOBJ)(HRGN)(hrgn))

#define     CopyRgn(hrgnDst, hrgnSrc)               CombineRgn(hrgnDst, hrgnSrc, 0, RGN_COPY)
#define     IntersectRgn(hrgnResult, hrgnA, hrgnB)  CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_AND)
#define     SubtractRgn(hrgnResult, hrgnA, hrgnB)   CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_DIFF)
#define     UnionRgn(hrgnResult, hrgnA, hrgnB)      CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define     XorRgn(hrgnResult, hrgnA, hrgnB)        CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)

#define     DeletePalette(hpal)     DeleteObject((HGDIOBJ)(HPALETTE)(hpal))

#define     DeleteFont(hfont)	    DeleteObject((HGDIOBJ)(HFONT)(hfont))
#define     SelectFont(hdc, hfont)  ((HFONT)SelectObject((hdc), (HGDIOBJ)(HFONT)(hfont)))
#define     GetStockFont(i)	    ((HFONT)GetStockObject(i))

#define     DeleteBitmap(hbm)       DeleteObject((HGDIOBJ)(HBITMAP)(hbm))
#define     SelectBitmap(hdc, hbm)  ((HBITMAP)SelectObject((hdc), (HGDIOBJ)(HBITMAP)(hbm)))

#define     InsetRect(lprc, dx, dy) InflateRect((lprc), -(dx), -(dy))

/****** USER Macro APIs ******************************************************/

#define     GetWindowInstance(hwnd) ((HINSTANCE)GetWindowWord(hwnd, GWW_HINSTANCE))

#define     GetWindowStyle(hwnd)    ((DWORD)GetWindowLong(hwnd, GWL_STYLE))
#define     GetWindowExStyle(hwnd)  ((DWORD)GetWindowLong(hwnd, GWL_EXSTYLE))

#define     GetWindowOwner(hwnd)    GetWindow(hwnd, GW_OWNER)

#define     GetFirstChild(hwnd)     GetTopWindow(hwnd)
#define     GetFirstSibling(hwnd)   GetWindow(hwnd, GW_HWNDFIRST)
#define     GetLastSibling(hwnd)    GetWindow(hwnd, GW_HWNDLAST)
#define     GetNextSibling(hwnd)    GetWindow(hwnd, GW_HWNDNEXT)
#define     GetPrevSibling(hwnd)    GetWindow(hwnd, GW_HWNDPREV)

#define     GetWindowID(hwnd)	    GetDlgCtrlID(hwnd)

#define     SetWindowRedraw(hwnd, fRedraw)  \
                    ((void)SendMessage(hwnd, WM_SETREDRAW, (WPARAM)(BOOL)(fRedraw), 0L))

#define     SubclassWindow(hwnd, lpfn)	\
		((WNDPROC)SetWindowLong((hwnd), GWL_WNDPROC, (LPARAM)(WNDPROC)(lpfn)))

#define     IsMinimized(hwnd)	IsIconic(hwnd)
#define     IsMaximized(hwnd)	IsZoomed(hwnd)
#define     IsRestored(hwnd)    ((GetWindowStyle(hwnd) & (WS_MINIMIZE | WS_MAXIMIZE)) == 0L)

#define     SetWindowFont(hwnd, hfont, fRedraw) FORWARD_WM_SETFONT((hwnd), (hfont), (fRedraw), SendMessage)

#define     GetWindowFont(hwnd)                 FORWARD_WM_GETFONT((hwnd), SendMessage)

#if (WINVER >= 0x030a)
#define     MapWindowRect(hwndFrom, hwndTo, lprc) \
                    MapWindowPoints((hwndFrom), (hwndTo), (POINT FAR*)(lprc), 2)
#endif  /* WINVER >= 0x030a */

#define     IsLButtonDown()	(GetKeyState(VK_LBUTTON) < 0)
#define     IsRButtonDown()	(GetKeyState(VK_RBUTTON) < 0)
#define     IsMButtonDown()	(GetKeyState(VK_MBUTTON) < 0)

#define     SubclassDialog(hwndDlg, lpfn) \
		((DLGPROC)SetWindowLong(hwndDlg, DWL_DLGPROC, (LPARAM)(DLGPROC)(lpfn)))

#define     SetDlgMsgResult(hwnd, msg, result)	 \
    (((msg) == WM_CTLCOLOR || (msg) == WM_COMPAREITEM || (msg) == WM_VKEYTOITEM ||  \
    (msg) == WM_CHARTOITEM || (msg) == WM_QUERYDRAGICON || (msg) == WM_INITDIALOG)  \
    ? (BOOL)LOWORD(result) : (SetWindowLong((hwnd), DWL_MSGRESULT, (LPARAM)(LRESULT)(result)), TRUE))

#define     DefDlgProcEx(hwnd, msg, wParam, lParam, pfRecursion) \
    (*(pfRecursion) = TRUE, DefDlgProc(hwnd, msg, wParam, lParam))

#define     CheckDefDlgRecursion(pfRecursion) \
    if (*(pfRecursion)) { *(pfRecursion) = FALSE; return FALSE; }

/****** Message crackers ****************************************************/

#define HANDLE_MSG(hwnd, message, fn)    \
    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))

/* void Cls_OnCompacting(HWND hwnd, UINT compactRatio); */
#define HANDLE_WM_COMPACTING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_COMPACTING(hwnd, compactRatio, fn) \
    (void)(fn)((hwnd), WM_COMPACTING, (WPARAM)(UINT)(compactRatio), 0L)

/* void Cls_OnWinIniChange(HWND hwnd, LPCSTR lpszSectionName); */
#define HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_WININICHANGE(hwnd, lpszSectionName, fn) \
    (void)(fn)((hwnd), WM_WININICHANGE, 0, (LPARAM)(LPCSTR)(lpszSectionName))

/* void Cls_OnSysColorChange(HWND hwnd); */
#define HANDLE_WM_SYSCOLORCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_SYSCOLORCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_SYSCOLORCHANGE, 0, 0L)

/* BOOL Cls_OnQueryNewPalette(HWND hwnd); */
#define HANDLE_WM_QUERYNEWPALETTE(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYNEWPALETTE(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYNEWPALETTE, 0, 0L)

/* void Cls_OnPaletteIsChanging(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTEISCHANGING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTEISCHANGING(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTEISCHANGING, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTECHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTECHANGED(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTECHANGED, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnFontChange(HWND hwnd); */
#define HANDLE_WM_FONTCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_FONTCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_FONTCHANGE, 0, 0L)

/* void Cls_OnSpoolerStatus(HWND hwnd, UINT status, int cJobInQueue); */
#define HANDLE_WM_SPOOLERSTATUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SPOOLERSTATUS(hwnd, status, cJobInQueue, fn) \
    (void)(fn)((hwnd), WM_SPOOLERSTATUS, (WPARAM)(status), MAKELPARAM((UINT)(cJobInQueue), 0))

/* void Cls_OnDevModeChange(HWND hwnd, LPCSTR lpszDeviceName); */
#define HANDLE_WM_DEVMODECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_DEVMODECHANGE(hwnd, lpszDeviceName, fn) \
    (void)(fn)((hwnd), WM_DEVMODECHANGE, 0,(LPARAM)(LPCSTR)(lpszDeviceName))

/* void Cls_OnTimeChange(HWND hwnd); */
#define HANDLE_WM_TIMECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_TIMECHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_TIMECHANGE, 0, 0L)

/* void Cls_OnPower(HWND hwnd, int code); */
#define HANDLE_WM_POWER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_POWER(hwnd, code, fn) \
    (void)(fn)((hwnd), WM_POWER, (WPARAM)(code), 0L)

/* BOOL Cls_OnQueryEndSession(HWND hwnd); */
#define HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYENDSESSION(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYENDSESSION, 0, 0L)

/* void Cls_OnEndSession(HWND hwnd, BOOL fEnding); */
#define HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENDSESSION(hwnd, fEnding, fn) \
    (void)(fn)((hwnd), WM_ENDSESSION, (WPARAM)(BOOL)(fEnding), 0L)

/* void Cls_OnQuit(HWND hwnd, int exitCode); */
#define HANDLE_WM_QUIT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_QUIT(hwnd, exitCode, fn) \
    (void)(fn)((hwnd), WM_QUIT, (WPARAM)(exitCode), 0L)

/* void Cls_OnSystemError(HWND hwnd, int errCode); */
#define HANDLE_WM_SYSTEMERROR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_SYSTEMERROR(hwnd, errCode, fn) \
    (void)(fn)((hwnd), WM_SYSTEMERROR, (WPARAM)(errCode), 0L)

/* BOOL Cls_OnCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (CREATESTRUCT FAR*)(lParam)) ? 0L : (LRESULT)-1L)
#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* BOOL Cls_OnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_NCCREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (CREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCCREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* void Cls_OnDestroy(HWND hwnd); */
#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROY, 0, 0L)

/* void Cls_OnNCDestroy(HWND hwnd); */
#define HANDLE_WM_NCDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_NCDESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_NCDESTROY, 0, 0L)

/* void Cls_OnShowWindow(HWND hwnd, BOOL fShow, UINT status); */
#define HANDLE_WM_SHOWWINDOW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_SHOWWINDOW(hwnd, fShow, status, fn) \
    (void)(fn)((hwnd), WM_SHOWWINDOW, (WPARAM)(BOOL)(fShow), MAKELPARAM((UINT)(status), 0))

/* void Cls_OnSetRedraw(HWND hwnd, BOOL fRedraw); */
#define HANDLE_WM_SETREDRAW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_SETREDRAW(hwnd, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETREDRAW, (WPARAM)(fRedraw), 0L)

/* void Cls_OnEnable(HWND hwnd, BOOL fEnable); */
#define HANDLE_WM_ENABLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENABLE(hwnd, fEnable, fn) \
    (void)(fn)((hwnd), WM_ENABLE, (WPARAM)(BOOL)(fEnable), 0L)

/* void Cls_OnSetText(HWND hwnd, LPCSTR lpszText); */
#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
    (void)(fn)((hwnd), WM_SETTEXT, 0, (LPARAM)(LPCSTR)(lpszText))

/* INT Cls_OnGetText(HWND hwnd, int cchTextMax, LPSTR lpszText) */
#define HANDLE_WM_GETTEXT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (int)(wParam), (LPSTR)(lParam))
#define FORWARD_WM_GETTEXT(hwnd, cchTextMax, lpszText, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXT, (WPARAM)(int)(cchTextMax), (LPARAM)(LPSTR)(lpszText))

/* INT Cls_OnGetTextLength(HWND hwnd); */
#define HANDLE_WM_GETTEXTLENGTH(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)(hwnd)
#define FORWARD_WM_GETTEXTLENGTH(hwnd, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXTLENGTH, 0, 0L)

/* BOOL Cls_OnWindowPosChanging(HWND hwnd, WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGING(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (WINDOWPOS FAR*)(lParam))
#define FORWARD_WM_WINDOWPOSCHANGING(hwnd, lpwpos, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_WINDOWPOSCHANGING, 0, (LPARAM)(WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnWindowPosChanged(HWND hwnd, const WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const WINDOWPOS FAR*)(lParam)), 0L)
#define FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, fn) \
    (void)(fn)((hwnd), WM_WINDOWPOSCHANGED, 0, (LPARAM)(const WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnMove(HWND hwnd, int x, int y); */
#define HANDLE_WM_MOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_MOVE(hwnd, x, y, fn) \
    (void)(fn)((hwnd), WM_MOVE, 0, MAKELPARAM((int)(x), (int)(y)))

/* void Cls_OnSize(HWND hwnd, UINT state, int cx, int cy); */
#define HANDLE_WM_SIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SIZE(hwnd, state, cx, cy, fn) \
    (void)(fn)((hwnd), WM_SIZE, (WPARAM)(UINT)(state), MAKELPARAM((int)(cx), (int)(cy)))

/* void Cls_OnClose(HWND hwnd); */
#define HANDLE_WM_CLOSE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLOSE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLOSE, 0, 0L)

/* BOOL Cls_OnQueryOpen(HWND hwnd); */
#define HANDLE_WM_QUERYOPEN(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYOPEN(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYOPEN, 0, 0L)

/* void Cls_OnGetMinMaxInfo(HWND hwnd, MINMAXINFO FAR* lpMinMaxInfo); */
#define HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MINMAXINFO FAR*)(lParam)), 0L)
#define FORWARD_WM_GETMINMAXINFO(hwnd, lpMinMaxInfo, fn) \
    (void)(fn)((hwnd), WM_GETMINMAXINFO, 0, (LPARAM)(MINMAXINFO FAR*)(lpMinMaxInfo))

/* void Cls_OnPaint(HWND hwnd); */
#define HANDLE_WM_PAINT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PAINT(hwnd, fn) \
    (void)(fn)((hwnd), WM_PAINT, 0, 0L)

/* BOOL Cls_OnEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* BOOL Cls_OnIconEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ICONERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ICONERASEBKGND(hwnd, hdc, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_ICONERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* void Cls_OnNCPaint(HWND hwnd, HRGN hrgn); */
#define HANDLE_WM_NCPAINT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HRGN)(wParam)), 0L)
#define FORWARD_WM_NCPAINT(hwnd, hrgn, fn) \
    (void)(fn)((hwnd), WM_NCPAINT, (WPARAM)(HRGN)(hrgn), 0L)

/* UINT Cls_OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS FAR* lpcsp) */
#define HANDLE_WM_NCCALCSIZE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (NCCALCSIZE_PARAMS FAR*)(lParam))
#define FORWARD_WM_NCCALCSIZE(hwnd, fCalcValidRects, lpcsp, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCCALCSIZE, (WPARAM)(fCalcValidRects), (LPARAM)(NCCALCSIZE_PARAMS FAR*)(lpcsp))

/* UINT Cls_OnNCHitTest(HWND hwnd, int x, int y); */
#define HANDLE_WM_NCHITTEST(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_NCHITTEST(hwnd, x, y, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCHITTEST, 0, MAKELPARAM((int)(x), (int)(y)))

/* HICON Cls_OnQueryDragIcon(HWND hwnd); */
#define HANDLE_WM_QUERYDRAGICON(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_QUERYDRAGICON(hwnd, fn) \
    (HICON)(UINT)(DWORD)(fn)((hwnd), WM_QUERYDRAGICON, 0, 0L)

#ifdef _INC_SHELLAPI
/* void Cls_OnDropFiles(HWND hwnd, HDROP hdrop); */
#define HANDLE_WM_DROPFILES(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HDROP)(wParam)), 0L)
#define FORWARD_WM_DROPFILES(hwnd, hdrop, fn) \
    (void)(fn)((hwnd), WM_DROPFILES, (WPARAM)(hdrop), 0L)
#endif  /* _INC_SHELLAPI */

/* void Cls_OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_ACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, fn) \
    (void)(fn)((hwnd), WM_ACTIVATE, (WPARAM)(UINT)(state), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnActivateApp(HWND hwnd, BOOL fActivate, HTASK htaskActDeact); */
#define HANDLE_WM_ACTIVATEAPP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HTASK)LOWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATEAPP(hwnd, fActivate, htaskActDeact, fn) \
    (void)(fn)((hwnd), WM_ACTIVATEAPP, (WPARAM)(BOOL)(fActivate), MAKELPARAM((htaskActDeact),0))

/* BOOL Cls_OnNCActivate(HWND hwnd, BOOL fActive, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_NCACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam))
#define FORWARD_WM_NCACTIVATE(hwnd, fActive, hwndActDeact, fMinimized, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCACTIVATE, (WPARAM)(BOOL)(fActive), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnSetFocus(HWND hwnd, HWND hwndOldFocus) */
#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)

/* void Cls_OnKillFocus(HWND hwnd, HWND hwndNewFocus); */
#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_CHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_CHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_DEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_DEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_DEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnSysDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSDEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSDEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSDEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_RBUTTONDBLCLK : WM_RBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnRButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_RBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_RBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_MBUTTONDBLCLK : WM_MBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnMButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_MBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMOUSEMOVE(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMOUSEMOVE, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCLBUTTONDBLCLK : WM_NCLBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCLBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCRBUTTONDBLCLK : WM_NCRBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCRBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCMBUTTONDBLCLK : WM_NCMBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCMButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* int Cls_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_MOUSEACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_MOUSEACTIVATE(hwnd, hwndTopLevel, codeHitTest, msg, fn) \
    (int)(DWORD)(fn)((hwnd), WM_MOUSEACTIVATE, (WPARAM)(HWND)(hwndTopLevel), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnCancelMode(HWND hwnd); */
#define HANDLE_WM_CANCELMODE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CANCELMODE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CANCELMODE, 0, 0L)

/* void Cls_OnTimer(HWND hwnd, UINT id); */
#define HANDLE_WM_TIMER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_TIMER(hwnd, id, fn) \
    (void)(fn)((hwnd), WM_TIMER, (WPARAM)(UINT)(id), 0L)

/* void Cls_OnInitMenu(HWND hwnd, HMENU hMenu); */
#define HANDLE_WM_INITMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam)), 0L)
#define FORWARD_WM_INITMENU(hwnd, hMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENU, (WPARAM)(HMENU)(hMenu), 0L)

/* void Cls_OnInitMenuPopup(HWND hwnd, HMENU hMenu, int item, BOOL fSystemMenu); */
#define HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam), (int)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_INITMENUPOPUP(hwnd, hMenu, item, fSystemMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENUPOPUP, (WPARAM)(HMENU)(hMenu), MAKELPARAM((item),(fSystemMenu)))

/* void Cls_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags); */
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)HIWORD(lParam), (LOWORD(lParam) & MF_POPUP) ? 0 : (int)(wParam), \
                            (LOWORD(lParam) & MF_POPUP) ? (HMENU)(wParam) : 0, LOWORD(lParam)), 0L)
#define FORWARD_WM_MENUSELECT(hwnd, hmenu, item, hmenuPopup, flags, fn) \
    (void)(fn)((hwnd), WM_MENUSELECT, ((flags) & MF_POPUP) ? (WPARAM)(HMENU)(hmenuPopup) : (WPARAM)(int)(item), MAKELPARAM((flags), (hmenu)))

/* DWORD Cls_OnMenuChar(HWND hwnd, UINT ch, UINT flags, HMENU hmenu); */
#define HANDLE_WM_MENUCHAR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam), LOWORD(lParam), (HMENU)HIWORD(lParam));
#define FORWARD_WM_MENUCHAR(hwnd, ch, flags, hmenu, fn) \
    (DWORD)(fn)((hwnd), WM_MENUCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((flags), (UINT)(hmenu)))

/* void Cls_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify); */
#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
    (void)(fn)((hwnd), WM_COMMAND, (WPARAM)(int)(id), MAKELPARAM((UINT)(hwndCtl), (codeNotify)))

/* void Cls_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_HSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_VSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam),  (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnCut(HWND hwnd); */
#define HANDLE_WM_CUT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CUT(hwnd, fn) \
    (void)(fn)((hwnd), WM_CUT, 0, 0L)

/* void Cls_OnCopy(HWND hwnd); */
#define HANDLE_WM_COPY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_COPY(hwnd, fn) \
    (void)(fn)((hwnd), WM_COPY, 0, 0L)

/* void Cls_OnPaste(HWND hwnd); */
#define HANDLE_WM_PASTE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PASTE(hwnd, fn) \
    (void)(fn)((hwnd), WM_PASTE, 0, 0L)

/* void Cls_OnClear(HWND hwnd); */
#define HANDLE_WM_CLEAR(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLEAR(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLEAR, 0, 0L)

/* void Cls_OnUndo(HWND hwnd); */
#define HANDLE_WM_UNDO(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_UNDO(hwnd, fn) \
    (void)(fn)((hwnd), WM_UNDO, 0, 0L)

/* HANDLE Cls_OnRenderFormat(HWND hwnd, UINT fmt); */
#define HANDLE_WM_RENDERFORMAT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HANDLE)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_RENDERFORMAT(hwnd, fmt, fn) \
    (HANDLE)(UINT)(DWORD)(fn)((hwnd), WM_RENDERFORMAT, (WPARAM)(UINT)(fmt), 0L)

/* void Cls_OnRenderAllFormats(HWND hwnd); */
#define HANDLE_WM_RENDERALLFORMATS(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_RENDERALLFORMATS(hwnd, fn) \
    (void)(fn)((hwnd), WM_RENDERALLFORMATS, 0, 0L)

/* void Cls_OnDestroyClipboard(HWND hwnd); */
#define HANDLE_WM_DESTROYCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROYCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROYCLIPBOARD, 0, 0L)

/* void Cls_OnDrawClipboard(HWND hwnd); */
#define HANDLE_WM_DRAWCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DRAWCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DRAWCLIPBOARD, 0, 0L)

/* void Cls_OnPaintClipboard(HWND hwnd, HWND hwndCBViewer, const PAINTSTRUCT FAR* lpPaintStruct) */
#define HANDLE_WM_PAINTCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const PAINTSTRUCT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_PAINTCLIPBOARD(hwnd, hwndCBViewer, lpPaintStruct, fn) \
    (void)(fn)((hwnd), WM_PAINTCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lpPaintStruct))

/* void Cls_OnSizeClipboard(HWND hwnd, HWND hwndCBViewer, const RECT FAR* lprc); */
#define HANDLE_WM_SIZECLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const RECT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SIZECLIPBOARD(hwnd, hwndCBViewer, lprc, fn) \
    (void)(fn)((hwnd), WM_SIZECLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lprc))

/* void Cls_OnVScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_VSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnHScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_HSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnAskCBFormatName(HWND hwnd, int cchMax, LPSTR rgchName); */
#define HANDLE_WM_ASKCBFORMATNAME(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (LPSTR)(lParam)), 0L)
#define FORWARD_WM_ASKCBFORMATNAME(hwnd, cchMax, rgchName, fn) \
    (void)(fn)((hwnd), WM_ASKCBFORMATNAME, (WPARAM)(int)(cchMax), (LPARAM)(rgchName))

/* void Cls_OnChangeCBChain(HWND hwnd, HWND hwndRemove, HWND hwndNext); */
#define HANDLE_WM_CHANGECBCHAIN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHANGECBCHAIN(hwnd, hwndRemove, hwndNext, fn) \
    (void)(fn)((hwnd), WM_CHANGECBCHAIN, (WPARAM)(HWND)(hwndRemove), MAKELPARAM((UINT)(hwndNext), 0))

/* BOOL Cls_OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_SETCURSOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam));
#define FORWARD_WM_SETCURSOR(hwnd, hwndCursor, codeHitTest, msg, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_SETCURSOR, (WPARAM)(HWND)(hwndCursor), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnSysCommand(HWND hwnd, UINT cmd, int x, int y); */
#define HANDLE_WM_SYSCOMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, fn) \
    (void)(fn)((hwnd), WM_SYSCOMMAND, (WPARAM)(UINT)(cmd), MAKELPARAM((x), (y)))

/* HWND Cls_MDICreate(HWND hwnd, const MDICREATESTRUCT FAR* lpmcs); */
#define HANDLE_WM_MDICREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (MDICREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_MDICREATE(hwnd, lpmcs, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDICREATE, 0, (LPARAM)(lpmcs))

/* void Cls_MDIDestroy(HWND hwnd, HWND hwndDestroy); */
#define HANDLE_WM_MDIDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIDESTROY(hwnd, hwndDestroy, fn) \
    (void)(fn)((hwnd), WM_MDIDESTROY, (WPARAM)(hwndDestroy), 0L)

/* NOTE: Usable only by MDI client windows */
/* void Cls_MDIActivate(HWND hwnd, BOOL fActive, HWND hwndActivate, HWND hwndDeactivate); */
#define HANDLE_WM_MDIACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (HWND)HIWORD(lParam)), 0L)
#define FORWARD_WM_MDIACTIVATE(hwnd, fActive, hwndActivate, hwndDeactivate, fn) \
    (void)(fn)(hwnd, WM_MDIACTIVATE, (WPARAM)(fActive), MAKELPARAM((hwndActivate), (hwndDeactivate)))

/* void Cls_MDIRestore(HWND hwnd, HWND hwndRestore); */
#define HANDLE_WM_MDIRESTORE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIRESTORE(hwnd, hwndRestore, fn) \
    (void)(fn)((hwnd), WM_MDIRESTORE, (WPARAM)(hwndRestore), 0L)

/* HWND Cls_MDINext(HWND hwnd, HWND hwndCur, BOOL fPrev); */
#define HANDLE_WM_MDINEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_MDINEXT(hwnd, hwndCur, fPrev, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDINEXT, (WPARAM)(hwndCur), MAKELPARAM((fPrev), 0))

/* void Cls_MDIMaximize(HWND hwnd, HWND hwndMaximize); */
#define HANDLE_WM_MDIMAXIMIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIMAXIMIZE(hwnd, hwndMaximize, fn) \
    (void)(fn)((hwnd), WM_MDIMAXIMIZE, (WPARAM)(hwndMaximize), 0L)

/* BOOL Cls_MDITile(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDITILE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDITILE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDITILE, (WPARAM)(cmd), 0L)

/* BOOL Cls_MDICascade(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDICASCADE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDICASCADE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDICASCADE, (WPARAM)(cmd), 0L)

/* void Cls_MDIIconArrange(HWND hwnd); */
#define HANDLE_WM_MDIICONARRANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_MDIICONARRANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_MDIICONARRANGE, 0, 0L)

/* HWND Cls_MDIGetActive(HWND hwnd); */
#define HANDLE_WM_MDIGETACTIVE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_MDIGETACTIVE(hwnd, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDIGETACTIVE, 0, 0L)

/* HMENU Cls_MDISetMenu(HWND hwnd, BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow); */
#define HANDLE_WM_MDISETMENU(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (HMENU)LOWORD(lParam), (HMENU)HIWORD(lParam))
#define FORWARD_WM_MDISETMENU(hwnd, fRefresh, hmenuFrame, hmenuWindow, fn) \
    (HMENU)(UINT)(DWORD)(fn)((hwnd), WM_MDISETMENU, (WPARAM)(fRefresh), MAKELPARAM((hmenuFrame), (hmenuWindow)))

/* void Cls_OnChildActivate(HWND hwnd); */
#define HANDLE_WM_CHILDACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CHILDACTIVATE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CHILDACTIVATE, 0, 0L)

/* BOOL Cls_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam); */
#define HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(BOOL)(fn)((hwnd), (HWND)(wParam), lParam);
#define FORWARD_WM_INITDIALOG(hwnd, hwndFocus, lParam, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_INITDIALOG, (WPARAM)(HWND)(hwndFocus), (lParam))

/* HWND Cls_OnNextDlgCtl(HWND hwnd, HWND hwndSetFocus, BOOL fNext) */
#define HANDLE_WM_NEXTDLGCTL(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HWND)(fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam))
#define FORWARD_WM_NEXTDLGCTL(hwnd, hwndSetFocus, fNext, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_NEXTDLGCTL, (WPARAM)(HWND)(hwndSetFocus), MAKELPARAM((fNext), 0))

/* void Cls_OnParentNotify(HWND hwnd, UINT msg, HWND hwndChild, int idChild); */
#define HANDLE_WM_PARENTNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_PARENTNOTIFY(hwnd, msg, hwndChild, idChild, fn) \
    (void)(fn)((hwnd), WM_PARENTNOTIFY, (WPARAM)(UINT)(msg), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(idChild)))

/* void Cls_OnEnterIdle(HWND hwnd, UINT source, HWND hwndSource); */
#define HANDLE_WM_ENTERIDLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_ENTERIDLE(hwnd, source, hwndSource, fn) \
    (void)(fn)((hwnd), WM_ENTERIDLE, (WPARAM)(UINT)(source), MAKELPARAM((UINT)(HWND)(hwndSource), 0))

/* UINT Cls_OnGetDlgCode(HWND hwnd, MSG FAR* lpmsg); */
#define HANDLE_WM_GETDLGCODE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd, (MSG FAR*)(lParam))
#define FORWARD_WM_GETDLGCODE(hwnd, lpmsg, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_GETDLGCODE, (SELECTOROF(lpmsg) ? lpmsg->wParam : 0), (LPARAM)(lpmsg))

/* HBRUSH Cls_OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type); */
#define HANDLE_WM_CTLCOLOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)LOWORD(lParam), (int)(HIWORD(lParam)))
#define FORWARD_WM_CTLCOLOR(hwnd, hdc, hwndChild, type, fn) \
    (HBRUSH)(UINT)(DWORD)(fn)((hwnd), WM_CTLCOLOR, (WPARAM)(HDC)(hdc), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(int)(type)))

/* void Cls_OnSetFont(HWND hwndCtl, HFONT hfont, BOOL fRedraw); */
#define HANDLE_WM_SETFONT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HFONT)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SETFONT(hwnd, hfont, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETFONT, (WPARAM)(HFONT)(hfont), MAKELPARAM((UINT)(BOOL)(fRedraw), 0))

/* HFONT Cls_OnGetFont(HWND hwnd); */
#define HANDLE_WM_GETFONT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HFONT)(fn)(hwnd)
#define FORWARD_WM_GETFONT(hwnd, fn) \
    (HFONT)(UINT)(DWORD)(fn)((hwnd), WM_GETFONT, 0, 0L)

/* void Cls_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT FAR* lpDrawItem); */
#define HANDLE_WM_DRAWITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DRAWITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DRAWITEM(hwnd, lpDrawItem, fn) \
    (void)(fn)((hwnd), WM_DRAWITEM, 0, (LPARAM)(const DRAWITEMSTRUCT FAR*)(lpDrawItem))

/* void Cls_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem); */
#define HANDLE_WM_MEASUREITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MEASUREITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_MEASUREITEM(hwnd, lpMeasureItem, fn) \
    (void)(fn)((hwnd), WM_MEASUREITEM, 0, (LPARAM)(MEASUREITEMSTRUCT FAR*)(lpMeasureItem))

/* void Cls_OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT FAR* lpDeleteItem) */
#define HANDLE_WM_DELETEITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DELETEITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DELETEITEM(hwnd, lpDeleteItem, fn) \
    (void)(fn)((hwnd), WM_DELETEITEM, 0, (LPARAM)(const DELETEITEMSTRUCT FAR*)(lpDeleteItem))

/* int Cls_OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT FAR* lpCompareItem); */
#define HANDLE_WM_COMPAREITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (const COMPAREITEMSTRUCT FAR*)(lParam))
#define FORWARD_WM_COMPAREITEM(hwnd, lpCompareItem, fn) \
    (int)(DWORD)(fn)((hwnd), WM_COMPAREITEM, 0, (LPARAM)(const COMPAREITEMSTRUCT FAR*)(lpCompareItem))

/* int Cls_OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_VKEYTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_VKEYTOITEM(hwnd, vk, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_VKEYTOITEM, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* int Cls_OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_CHARTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_CHARTOITEM(hwnd, ch, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_CHARTOITEM, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* void Cls_OnQueueSync(HWND hwnd); */
#define HANDLE_WM_QUEUESYNC(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_QUEUESYNC(hwnd, fn) \
    (void)(fn)((hwnd), WM_QUEUESYNC, 0, 0L)

/* void Cls_OnCommNotify(HWND hwnd, int cid, UINT flags); */
#define HANDLE_WM_COMMNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_COMMNOTIFY(hwnd, cid, flags, fn) \
    (void)(fn)((hwnd), WM_COMMNOTIFY, (WPARAM)(cid), MAKELPARAM((flags), 0))

/****** Static control message APIs ******************************************/

#define Static_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Static_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Static_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Static_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Static_SetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
#define Static_GetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_GETICON, 0, 0L))

/****** Button control message APIs ******************************************/

#define Button_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Button_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Button_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Button_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Button_GetCheck(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETCHECK, 0, 0L))
#define Button_SetCheck(hwndCtl, check)     ((void)SendMessage((hwndCtl), BM_SETCHECK, (WPARAM)(int)(check), 0L))

#define Button_GetState(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETSTATE, 0, 0L))
#define Button_SetState(hwndCtl, state)     ((UINT)(DWORD)SendMessage((hwndCtl), BM_SETSTATE, (WPARAM)(int)(state), 0L))

#define Button_SetStyle(hwndCtl, style, fRedraw) ((void)SendMessage((hwndCtl), BM_SETSTYLE, (WPARAM)LOWORD(style), MAKELPARAM(((fRedraw) ? TRUE : FALSE), 0)))

/****** Edit control message APIs ********************************************/

#define Edit_Enable(hwndCtl, fEnable)           EnableWindow((hwndCtl), (fEnable))

#define Edit_GetText(hwndCtl, lpch, cchMax)     GetWindowText((hwndCtl), (lpch), (cchMax))
#define Edit_GetTextLength(hwndCtl)             GetWindowTextLength(hwndCtl)
#define Edit_SetText(hwndCtl, lpsz)             SetWindowText((hwndCtl), (lpsz))

#define Edit_LimitText(hwndCtl, cchMax)         ((void)SendMessage((hwndCtl), EM_LIMITTEXT, (WPARAM)(cchMax), 0L))

#define Edit_GetLineCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINECOUNT, 0, 0L))
#define Edit_GetLine(hwndCtl, line, lpch, cchMax) ((*((int FAR*)(lpch)) = (cchMax)), ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINE, (WPARAM)(int)(line), (LPARAM)(LPSTR)(lpch))))

#define Edit_GetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_GETRECT, 0, (LPARAM)(RECT FAR*)(lprc)))
#define Edit_SetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_SETRECT, 0, (LPARAM)(const RECT FAR*)(lprc)))
#define Edit_SetRectNoPaint(hwndCtl, lprc)      ((void)SendMessage((hwndCtl), EM_SETRECTNP, 0, (LPARAM)(const RECT FAR*)(lprc)))

#define Edit_GetSel(hwndCtl)                    ((DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L))
#define Edit_SetSel(hwndCtl, ichStart, ichEnd)  ((void)SendMessage((hwndCtl), EM_SETSEL, 0, MAKELPARAM((ichStart), (ichEnd))))
#define Edit_ReplaceSel(hwndCtl, lpszReplace)   ((void)SendMessage((hwndCtl), EM_REPLACESEL, 0, (LPARAM)(LPCSTR)(lpszReplace)))

#define Edit_GetModify(hwndCtl)                 ((BOOL)(DWORD)SendMessage((hwndCtl), EM_GETMODIFY, 0, 0L))
#define Edit_SetModify(hwndCtl, fModified)      ((void)SendMessage((hwndCtl), EM_SETMODIFY, (WPARAM)(UINT)(fModified), 0L))

#define Edit_LineFromChar(hwndCtl, ich)         ((int)(DWORD)SendMessage((hwndCtl), EM_LINEFROMCHAR, (WPARAM)(int)(ich), 0L))
#define Edit_LineIndex(hwndCtl, line)           ((int)(DWORD)SendMessage((hwndCtl), EM_LINEINDEX, (WPARAM)(int)(line), 0L))
#define Edit_LineLength(hwndCtl, line)          ((int)(DWORD)SendMessage((hwndCtl), EM_LINELENGTH, (WPARAM)(int)(line), 0L))

#define Edit_Scroll(hwndCtl, dv, dh)            ((void)SendMessage((hwndCtl), EM_LINESCROLL, 0, MAKELPARAM((dv), (dh))))

#define Edit_CanUndo(hwndCtl)                   ((BOOL)(DWORD)SendMessage((hwndCtl), EM_CANUNDO, 0, 0L))
#define Edit_Undo(hwndCtl)                      ((BOOL)(DWORD)SendMessage((hwndCtl), EM_UNDO, 0, 0L))
#define Edit_EmptyUndoBuffer(hwndCtl)           ((void)SendMessage((hwndCtl), EM_EMPTYUNDOBUFFER, 0, 0L))

#define Edit_SetPasswordChar(hwndCtl, ch)       ((void)SendMessage((hwndCtl), EM_SETPASSWORDCHAR, (WPARAM)(UINT)(ch), 0L))

#define Edit_SetTabStops(hwndCtl, cTabs, lpTabs) ((void)SendMessage((hwndCtl), EM_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(const int FAR*)(lpTabs)))

#define Edit_FmtLines(hwndCtl, fAddEOL)         ((BOOL)(DWORD)SendMessage((hwndCtl), EM_FMTLINES, (WPARAM)(BOOL)(fAddEOL), 0L))

#define Edit_GetHandle(hwndCtl)                 ((HLOCAL)(UINT)(DWORD)SendMessage((hwndCtl), EM_GETHANDLE, 0, 0L))
#define Edit_SetHandle(hwndCtl, h)              ((void)SendMessage((hwndCtl), EM_SETHANDLE, (WPARAM)(UINT)(HLOCAL)(h), 0L))

#if (WINVER >= 0x030a)
#define Edit_GetFirstVisibleLine(hwndCtl)       ((int)(DWORD)SendMessage((hwndCtl), EM_GETFIRSTVISIBLELINE, 0, 0L))

#define Edit_SetReadOnly(hwndCtl, fReadOnly)    ((BOOL)(DWORD)SendMessage((hwndCtl), EM_SETREADONLY, (WPARAM)(BOOL)(fReadOnly), 0L))

#define Edit_GetPasswordChar(hwndCtl)           ((char)(DWORD)SendMessage((hwndCtl), EM_GETPASSWORDCHAR, 0, 0L))

#define Edit_SetWordBreakProc(hwndCtl, lpfnWordBreak) ((void)SendMessage((hwndCtl), EM_SETWORDBREAKPROC, 0, (LPARAM)(EDITWORDBREAKPROC)(lpfnWordBreak)))
#define Edit_GetWordBreakProc(hwndCtl)          ((EDITWORDBREAKPROC)SendMessage((hwndCtl), EM_GETWORDBREAKPROC, 0, 0L))
#endif /* WINVER >= 0x030a */

/****** ScrollBar control message APIs ***************************************/

/* NOTE: flags parameter is a collection of ESB_* values, NOT a boolean! */
#define ScrollBar_Enable(hwndCtl, flags)            EnableScrollBar((hwndCtl), SB_CTL, (flags))

#define ScrollBar_Show(hwndCtl, fShow)              ShowWindow((hwndCtl), (fShow) ? SW_SHOWNORMAL : SW_HIDE)

#define ScrollBar_SetPos(hwndCtl, pos, fRedraw)     SetScrollPos((hwndCtl), SB_CTL, (pos), (fRedraw))
#define ScrollBar_GetPos(hwndCtl)                   GetScrollPos((hwndCtl), SB_CTL)

#define ScrollBar_SetRange(hwndCtl, posMin, posMax, fRedraw)    SetScrollRange((hwndCtl), SB_CTL, (posMin), (posMax), (fRedraw))
#define ScrollBar_GetRange(hwndCtl, lpposMin, lpposMax)         GetScrollRange((hwndCtl), SB_CTL, (lpposMin), (lpposMax))

/****** ListBox control message APIs *****************************************/

#define ListBox_Enable(hwndCtl, fEnable)            EnableWindow((hwndCtl), (fEnable))

#define ListBox_GetCount(hwndCtl)                   ((int)(DWORD)SendMessage((hwndCtl), LB_GETCOUNT, 0, 0L))
#define ListBox_ResetContent(hwndCtl)               ((BOOL)(DWORD)SendMessage((hwndCtl), LB_RESETCONTENT, 0, 0L))

#define ListBox_AddString(hwndCtl, lpsz)            ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ListBox_InsertString(hwndCtl, index, lpsz)  ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ListBox_AddItemData(hwndCtl, data)          ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(data)))
#define ListBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_DeleteString(hwndCtl, index)        ((int)(DWORD)SendMessage((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ListBox_GetTextLen(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXTLEN, (WPARAM)(int)(index), 0L))
#define ListBox_GetText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ListBox_GetItemData(hwndCtl, index)         ((LRESULT)(DWORD)SendMessage((hwndCtl), LB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ListBox_SetItemData(hwndCtl, index, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_FindString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_FindItemData(hwndCtl, indexStart, data) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_SetSel(hwndCtl, fSelect, index)     ((int)(DWORD)SendMessage((hwndCtl), LB_SETSEL, (WPARAM)(BOOL)(fSelect), MAKELPARAM((index), 0)))
#define ListBox_SelItemRange(hwndCtl, fSelect, first, last)    ((int)(DWORD)SendMessage((hwndCtl), LB_SELITEMRANGE, (WPARAM)(BOOL)(fSelect), MAKELPARAM((first), (last))))

#define ListBox_GetCurSel(hwndCtl)                  ((int)(DWORD)SendMessage((hwndCtl), LB_GETCURSEL, 0, 0L))
#define ListBox_SetCurSel(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), LB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ListBox_SelectString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_SelectItemData(hwndCtl, indexStart, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_GetSel(hwndCtl, index)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETSEL, (WPARAM)(int)(index), 0L))
#define ListBox_GetSelCount(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELCOUNT, 0, 0L))
#define ListBox_GetTopIndex(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETTOPINDEX, 0, 0L))
#define ListBox_GetSelItems(hwndCtl, cItems, lpItems) ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELITEMS, (WPARAM)(int)(cItems), (LPARAM)(int FAR*)(lpItems)))

#define ListBox_SetTopIndex(hwndCtl, indexTop)      ((int)(DWORD)SendMessage((hwndCtl), LB_SETTOPINDEX, (WPARAM)(int)(indexTop), 0L))

#define ListBox_SetColumnWidth(hwndCtl, cxColumn)   ((void)SendMessage((hwndCtl), LB_SETCOLUMNWIDTH, (WPARAM)(int)(cxColumn), 0L))
#define ListBox_GetHorizontalExtent(hwndCtl)        ((int)(DWORD)SendMessage((hwndCtl), LB_GETHORIZONTALEXTENT, 0, 0L))
#define ListBox_SetHorizontalExtent(hwndCtl, cxExtent)     ((void)SendMessage((hwndCtl), LB_SETHORIZONTALEXTENT, (WPARAM)(int)(cxExtent), 0L))

#define ListBox_SetTabStops(hwndCtl, cTabs, lpTabs) ((BOOL)(DWORD)SendMessage((hwndCtl), LB_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(int FAR*)(lpTabs)))

#define ListBox_GetItemRect(hwndCtl, index, lprc)   ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMRECT, (WPARAM)(int)(index), (LPARAM)(RECT FAR*)(lprc)))

#define ListBox_SetCaretIndex(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_SETCARETINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetCaretIndex(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETCARETINDEX, 0, 0L))

#define ListBox_SetAnchorIndex(hwndCtl, index)      ((void)SendMessage((hwndCtl), LB_SETANCHORINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetAnchorIndex(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), LB_GETANCHORINDEX, 0, 0L))

#if (WINVER >= 0x030a)
#define ListBox_FindStringExact(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ListBox_SetItemHeight(hwndCtl, index, cy)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMHEIGHT, (WPARAM)(int)(index), MAKELPARAM((cy), 0)))
#define ListBox_GetItemHeight(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMHEIGHT, (WPARAM)(int)(index), 0L))
#endif  /* WINVER >= 0x030a */

#define ListBox_Dir(hwndCtl, attrs, lpszFileSpec)   ((int)(DWORD)SendMessage((hwndCtl), LB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

/****** ComboBox control message APIs ****************************************/

#define ComboBox_Enable(hwndCtl, fEnable)       EnableWindow((hwndCtl), (fEnable))

#define ComboBox_GetText(hwndCtl, lpch, cchMax) GetWindowText((hwndCtl), (lpch), (cchMax))
#define ComboBox_GetTextLength(hwndCtl)         GetWindowTextLength(hwndCtl)
#define ComboBox_SetText(hwndCtl, lpsz)         SetWindowText((hwndCtl), (lpsz))

#define ComboBox_LimitText(hwndCtl, cchLimit)   ((int)(DWORD)SendMessage((hwndCtl), CB_LIMITTEXT, (WPARAM)(int)(cchLimit), 0L))

#define ComboBox_GetEditSel(hwndCtl)            ((DWORD)SendMessage((hwndCtl), CB_GETEDITSEL, 0, 0L))
#define ComboBox_SetEditSel(hwndCtl, ichStart, ichEnd) ((int)(DWORD)SendMessage((hwndCtl), CB_SETEDITSEL, 0, MAKELPARAM((ichStart), (ichEnd))))

#define ComboBox_GetCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), CB_GETCOUNT, 0, 0L))
#define ComboBox_ResetContent(hwndCtl)          ((int)(DWORD)SendMessage((hwndCtl), CB_RESETCONTENT, 0, 0L))

#define ComboBox_AddString(hwndCtl, lpsz)       ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ComboBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ComboBox_AddItemData(hwndCtl, data)     ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(data)))
#define ComboBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_DeleteString(hwndCtl, index)   ((int)(DWORD)SendMessage((hwndCtl), CB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ComboBox_GetLBTextLen(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXTLEN, (WPARAM)(int)(index), 0L))
#define ComboBox_GetLBText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ComboBox_GetItemData(hwndCtl, index)        ((LRESULT)(DWORD)SendMessage((hwndCtl), CB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ComboBox_SetItemData(hwndCtl, index, data)  ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_FindString(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ComboBox_FindItemData(hwndCtl, indexStart, data)    ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_GetCurSel(hwndCtl)                 ((int)(DWORD)SendMessage((hwndCtl), CB_GETCURSEL, 0, 0L))
#define ComboBox_SetCurSel(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ComboBox_SelectString(hwndCtl, indexStart, lpszSelect)  ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszSelect)))
#define ComboBox_SelectItemData(hwndCtl, indexStart, data)      ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_Dir(hwndCtl, attrs, lpszFileSpec)  ((int)(DWORD)SendMessage((hwndCtl), CB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

#define ComboBox_ShowDropdown(hwndCtl, fShow)       ((BOOL)(DWORD)SendMessage((hwndCtl), CB_SHOWDROPDOWN, (WPARAM)(BOOL)(fShow), 0L))

#if (WINVER >= 0x030a)
#define ComboBox_FindStringExact(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ComboBox_GetDroppedState(hwndCtl)           ((BOOL)(DWORD)SendMessage((hwndCtl), CB_GETDROPPEDSTATE, 0, 0L))
#define ComboBox_GetDroppedControlRect(hwndCtl, lprc) ((void)SendMessage((hwndCtl), CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)(RECT FAR*)(lprc)))

#define ComboBox_GetItemHeight(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), CB_GETITEMHEIGHT, 0, 0L))
#define ComboBox_SetItemHeight(hwndCtl, cyItem)     ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMHEIGHT, (WPARAM)(int)(index), 0L))

#define ComboBox_GetExtendedUI(hwndCtl)             ((UINT)(DWORD)SendMessage((hwndCtl), CB_GETEXTENDEDUI, 0, 0L))
#define ComboBox_SetExtendedUI(hwndCtl, flags)      ((int)(DWORD)SendMessage((hwndCtl), CB_SETEXTENDEDUI, (WPARAM)(UINT)(flags), 0L))
#endif  /* WINVER >= 0x030a */

/****** Alternate porting layer macros ***************************************/

/* USER MESSAGES: */

#define GET_WPARAM(wp, lp)                      (wp)
#define GET_LPARAM(wp, lp)                      (lp)

#define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
#define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      ((BOOL)HIWORD(lp))
#define GET_WM_ACTIVATE_HWND(wp, lp)            ((HWND)LOWORD(lp))
#define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      \
        (WPARAM)(s), (LPARAM)MAKELONG(hwnd, fmin)

#define GET_WM_CHARTOITEM_CHAR(wp, lp)          ((CHAR)wp)
#define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
#define GET_WM_CHARTOITEM_HWND(wp, lp)          LOWORD(lp)
#define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    \
        (WPARAM)ch, (LPARAM)MAKELONG(hwnd, pos)

#define GET_WM_COMMAND_ID(wp, lp)               (wp)
#define GET_WM_COMMAND_HWND(wp, lp)             (HWND)(LOWORD(lp))
#define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
        (WPARAM)id, MAKELONG(hwnd, cmd)

#define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
#define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)(LOWORD(lp))
#define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
#define GET_WM_CTLCOLOR_MSG(type)               WM_CTLCOLOR
#define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type) \
        (WPARAM)(hdc), (LPARAM)MAKELONG(hwnd, type)


#define GET_WM_MENUSELECT_CMD(wp, lp)               (wp)
#define GET_WM_MENUSELECT_FLAGS(wp, lp)             (UINT)LOWORD(lp)
#define GET_WM_MENUSELECT_HMENU(wp, lp)             (HMENU)(HIWORD(lp))
#define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)  \
        (WPARAM)cmd, (LPARAM)MAKELONG(f, hmenu)

// Note: the following are for interpreting MDI child messages.
#define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (wp)
#define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
#define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)
// Note: the following is for sending to the MDI client window.
#define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA)\
        (WPARAM)(hwndA), 0

#define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   \
    (WPARAM)TRUE, (LPARAM)MAKELONG(hmenuF, hmenuW)

#define GET_WM_MENUCHAR_CHAR(wp, lp)                (CHAR)(wp)
#define GET_WM_MENUCHAR_HMENU(wp, lp)               (HMENU)HIWORD(lp)
#define GET_WM_MENUCHAR_FMENU(wp, lp)               (BOOL)LOWORD(lp)
#define GET_WM_MENUCHAR_MPS(ch, hmenu, f)    \
        (WPARAM)ch, (LPARAM)MAKELONG(f, hmenu)

#define GET_WM_PARENTNOTIFY_MSG(wp, lp)             (wp)
#define GET_WM_PARENTNOTIFY_ID(wp, lp)              HIWORD(lp)
#define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)       (HWND)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_X(wp, lp)               (int)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_Y(wp, lp)               (int)HIWORD(lp)
#define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd) \
        (WPARAM)msg, (LPARAM)MAKELONG(hwnd, id)
#define GET_WM_PARENTNOTIFY2_MPS(msg, x, y) \
        (WPARAM)msg, (LPARAM)MAKELONG(x, y)

#define GET_WM_VKEYTOITEM_CODE(wp, lp)              (wp)
#define GET_WM_VKEYTOITEM_ITEM(wp, lp)              HIWORD(lp)
#define GET_WM_VKEYTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
#define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) \
        (WPARAM)code, (LPARAM)MAKELONG(hwnd, item)

#define GET_EM_SETSEL_START(wp, lp)                 (int)LOWORD(lp)
#define GET_EM_SETSEL_END(wp, lp)                   (int)HIWORD(lp)
#define GET_EM_SETSEL_MPS(iStart, iEnd) \
        (WPARAM)TRUE, MAKELONG(iStart, iEnd)

#define GET_EM_LINESCROLL_MPS(vert, horz)     \
        (WPARAM)0, (LPARAM)MAKELONG(vert, horz)

#define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)       (HWND)LOWORD(lp)

#define GET_WM_HSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_HSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_HSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_HSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)code, (LPARAM)MAKELONG(pos, hwnd)

#define GET_WM_VSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_VSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)code, (LPARAM)MAKELONG(pos, hwnd)


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* !_INC_WINDOWSX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\windows.h ===
/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 4.00                                                  *
*                                                                             *
*               Copyright (c) 1985-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x0400).  To exclude
*                   definitions introduced in version 4.0 (or above)
*                   #define WINVER 0x0300
*                   or 0x0310 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
* NOIMT             Installable messge thunk APIs and definitions
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If WINVER is not defined, assume version 4.0 */
#ifndef WINVER
#define WINVER  0x0400
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID        void

#define FAR         _far
#define NEAR        _near
#define PASCAL      _pascal
#define CDECL       _cdecl
#define WINAPI      _far _pascal
#define CALLBACK    _far _pascal
#define WINCAPI     _far _cdecl

/****** Simple types & common helper macros *********************************/

typedef int             BOOL;
#define FALSE           0
#define TRUE            1

typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned long   DWORD;

typedef WORD            WCHAR;

typedef unsigned int    UINT;

#ifdef STRICT
typedef signed long     LONG;
#else
#define LONG            long
#endif

typedef short           SHORT;
typedef unsigned long   ULONG;

#define LOBYTE(w)       ((BYTE)(w))
#define HIBYTE(w)       ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)       ((WORD)(DWORD)(l))
#define HIWORD(l)       ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high)     ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)        (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)        (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT            WPARAM;
typedef LONG            LPARAM;
typedef LONG            LRESULT;

#define MAKELPARAM(low, high)   ((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)  ((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL            0
#endif

typedef char NEAR*      PSTR;
typedef char NEAR*      NPSTR;

typedef char FAR*       LPSTR;
typedef const char FAR* LPCSTR;

typedef BYTE NEAR*      PBYTE;
typedef BYTE FAR*       LPBYTE;
typedef const BYTE FAR* LPCBYTE;

typedef int NEAR*       PINT;
typedef int FAR*        LPINT;

typedef WORD NEAR*      PWORD;
typedef WORD FAR*       LPWORD;

typedef long NEAR*      PLONG;
typedef long FAR*       LPLONG;

typedef DWORD NEAR*     PDWORD;
typedef DWORD FAR*      LPDWORD;

typedef void FAR*       LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE*         PHANDLE;
typedef HANDLE NEAR*    SPHANDLE;
typedef HANDLE FAR*     LPHANDLE;

typedef HANDLE          HGLOBAL;
typedef HANDLE          HLOCAL;

typedef HANDLE          GLOBALHANDLE;
typedef HANDLE          LOCALHANDLE;

typedef UINT            ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

DWORD   WINAPI GetFreeSpace(UINT);
UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE        0x0001
#define WF_CPU286       0x0002
#define WF_CPU386       0x0004
#define WF_CPU486       0x0008
#define WF_STANDARD     0x0010
#define WF_WIN286       0x0010
#define WF_ENHANCED     0x0020
#define WF_WIN386       0x0020
#define WF_CPU086       0x0040
#define WF_CPU186       0x0080
#if (WINVER < 0x030a)
#define WF_LARGEFRAME   0x0100
#define WF_SMALLFRAME   0x0200
#endif
#define WF_80x87        0x0400
#define WF_PAGING       0x0800
#define WF_DOSPAGING    0x1000
#define WF_WINNT        0x4000
#define WF_WLO          0x8000
#define WF_CPUMASK      0xFC000000
#define WF_CPU_X86	0
#define WF_CPU_R4000	1
#define WF_CPU_ALPHA	2
#define WF_CPU_CLIPPER	3


LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING     0x8000
#define ERR_PARAM       0x4000

#define ERR_SIZE_MASK   0x3000
#define ERR_BYTE        0x1000
#define ERR_WORD        0x2000
#define ERR_DWORD       0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE       0x6001
#define ERR_BAD_FLAGS       0x6002
#define ERR_BAD_INDEX       0x6003
#define ERR_BAD_DVALUE      0x7004
#define ERR_BAD_DFLAGS      0x7005
#define ERR_BAD_DINDEX      0x7006
#define ERR_BAD_PTR         0x7007
#define ERR_BAD_FUNC_PTR    0x7008
#define ERR_BAD_SELECTOR    0x6009
#define ERR_BAD_STRING_PTR  0x700a
#define ERR_BAD_HANDLE      0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS          0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069

/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
#if (WINVER >= 0x0400)
    WORD    chDefRIP;
#endif /* WINVER >= 0x0400 */
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS             0x0001
#define WDI_FILTER              0x0002
#define WDI_ALLOCBREAK          0x0004
#define WDI_DEFRIP              0x0008

/* dwOptions values */
#define DBO_CHECKHEAP           0x0001
#define DBO_BUFFERFILL          0x0004
#define DBO_DISABLEGPTRAPPING   0x0010
#define DBO_CHECKFREE           0x0020

#define DBO_SILENT              0x8000

#define DBO_TRACEBREAK          0x2000
#define DBO_WARNINGBREAK        0x1000
#define DBO_NOERRORBREAK        0x0800
#define DBO_NOFATALBREAK        0x0400
#define DBO_INT3BREAK           0x0100

/* DebugOutput flags values */
#define DBF_TRACE               0x0000
#define DBF_WARNING             0x4000
#define DBF_ERROR               0x8000
#define DBF_FATAL               0xc000

/* dwFilter values */
#define DBF_KERNEL              0x1000
#define DBF_KRN_MEMMAN          0x0001
#define DBF_KRN_LOADMODULE      0x0002
#define DBF_KRN_SEGMENTLOAD     0x0004
#define DBF_USER                0x0800
#define DBF_GDI                 0x0400
#define DBF_MMSYSTEM            0x0040
#define DBF_PENWIN              0x0020
#define DBF_APPLICATION         0x0008
#define DBF_DRIVER              0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42

#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM         0x43
BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */



void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS  0x0001
#define SEM_NOGPFAULTERRORBOX   0x0002
#define SEM_NOOPENFILEERRORBOX  0x8000

UINT    WINAPI SetErrorMode(UINT);

#if (WINVER >= 0x0400)
void    WINAPI SetLastError(DWORD);
DWORD   WINAPI GetLastError(void);
#endif /* WINVER >= 0x0400 */


/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);

#if (WINVER >= 0x0400)
void    WINAPI ProfStart32(void);
void    WINAPI ProfStop32(void);
void    WINAPI ProfClear32(void);
void    WINAPI ProfFlush32(void);
void    WINAPI ProfFinish32(void);
#endif /* WINVER >= 0x0400) */
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)

HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

#if (WINVER >= 0x0400)
BOOL    WINAPI GetModuleName(HINSTANCE, LPSTR, int);
#endif /* WINVER >= 0x0400 */

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE NEAR *, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT    offSegment;
    UINT    cbSegment;
    UINT    flags;
    UINT    cbAlloc;
    HGLOBAL h;
    UINT    alignShift;
    UINT    reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define WEP_SYSTEM_EXIT 1
#define WEP_FREE_DLL 0

/****** Task Management *****************************************************/

#endif /* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);


/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND                (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR                (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED     0x4000
#define GMEM_LOCKCOUNT     0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)

#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED     0x4000
#define LMEM_LOCKCOUNT     0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);
#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ             0x0000
#define OF_WRITE            0x0001
#define OF_READWRITE        0x0002
#define OF_SHARE_COMPAT     0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE            0x0100
#define OF_DELETE           0x0200
#define OF_VERIFY           0x0400  /* Used with OF_REOPEN */
#define OF_SEARCH           0x0400  /* Used without OF_REOPEN */
#define OF_CANCEL           0x0800
#define OF_CREATE           0x1000
#define OF_PROMPT           0x2000
#define OF_EXIST            0x4000
#define OF_REOPEN           0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ                0
#define WRITE               1
#define READ_WRITE          2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long WINAPI _hread(HFILE, void _huge*, long);
long WINAPI _hwrite(HFILE, const void _huge*, long);
#endif /* WINVER >= 0x030a */

#endif /* NOLFILEIO */

#if (WINVER >= 0x0400)
DWORD   WINAPI GetCurrentDirectory(DWORD, LPSTR);
BOOL    WINAPI SetCurrentDirectory(LPCSTR);

#define MAX_PATH 260

#define _FILETIME_
typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, NEAR *PFILETIME, FAR *LPFILETIME;

typedef struct _WIN32_FIND_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    char   cFileName[ MAX_PATH ];
    char   cAlternateFileName[ 14 ];
} WIN32_FIND_DATA, NEAR *PWIN32_FIND_DATA, FAR *LPWIN32_FIND_DATA;

#define FILE_ATTRIBUTE_READONLY         0x00000001
#define FILE_ATTRIBUTE_HIDDEN           0x00000002
#define FILE_ATTRIBUTE_SYSTEM           0x00000004
#define FILE_ATTRIBUTE_DIRECTORY        0x00000010
#define FILE_ATTRIBUTE_ARCHIVE          0x00000020
#define FILE_ATTRIBUTE_NORMAL           0x00000080
#define FILE_ATTRIBUTE_TEMPORARY        0x00000100
#define FILE_ATTRIBUTE_ATOMIC_WRITE     0x00000200
#define FILE_ATTRIBUTE_XACTION_WRITE    0x00000400

DECLARE_HANDLE(HFINDFILE);
#define INVALID_HFINDFILE       ((HFINDFILE)-1)
#define INVALID_HANDLE_VALUE    ((HANDLE)-1)

HFINDFILE WINAPI FindFirstFile(LPCSTR, LPWIN32_FIND_DATA);
BOOL      WINAPI FindNextFile(HFINDFILE, LPWIN32_FIND_DATA);
BOOL      WINAPI FindClose(HFINDFILE);

DWORD     WINAPI GetFileAttributes(LPCSTR);
BOOL      WINAPI SetFileAttributes(LPCSTR, DWORD);
BOOL      WINAPI GetDiskFreeSpace(LPCSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD);
BOOL      WINAPI CreateDirectory(LPCSTR, LPVOID);
BOOL      WINAPI RemoveDirectory(LPCSTR);
BOOL      WINAPI DeleteFile(LPCSTR);
#endif /* WINVER >= 0x0400 */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE     (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS          0x0000
#define WN_NOT_SUPPORTED    0x0001
#define WN_NET_ERROR        0x0002
#define WN_MORE_DATA        0x0003
#define WN_BAD_POINTER      0x0004
#define WN_BAD_VALUE        0x0005
#define WN_BAD_PASSWORD     0x0006
#define WN_ACCESS_DENIED    0x0007
#define WN_FUNCTION_BUSY    0x0008
#define WN_WINDOWS_ERROR    0x0009
#define WN_BAD_USER         0x000A
#define WN_OUT_OF_MEMORY    0x000B
#define WN_CANCEL           0x000C
#define WN_CONTINUE         0x000D

/* Connection errors */
#define WN_NOT_CONNECTED    0x0030
#define WN_OPEN_FILES       0x0031
#define WN_BAD_NETNAME      0x0032
#define WN_BAD_LOCALNAME    0x0033
#define WN_ALREADY_CONNECTED    0x0034
#define WN_DEVICE_ERROR         0x0035
#define WN_CONNECTION_CLOSED    0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)     GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR       MAKEINTRESOURCE(1)
#define RT_BITMAP       MAKEINTRESOURCE(2)
#define RT_ICON         MAKEINTRESOURCE(3)
#define RT_MENU         MAKEINTRESOURCE(4)
#define RT_DIALOG       MAKEINTRESOURCE(5)
#define RT_STRING       MAKEINTRESOURCE(6)
#define RT_FONTDIR      MAKEINTRESOURCE(7)
#define RT_FONT         MAKEINTRESOURCE(8)
#define RT_ACCELERATOR  MAKEINTRESOURCE(9)
#define RT_RCDATA       MAKEINTRESOURCE(10)
#define RT_GROUP_CURSOR MAKEINTRESOURCE(12)
#define RT_GROUP_ICON   MAKEINTRESOURCE(14)
#define RT_PLUGPLAY     MAKEINTRESOURCE(19)
#define RT_VXD          MAKEINTRESOURCE(20)

#endif  /* NORESOURCE */


#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640
#define OCR_ICON            32641
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647
#define OCR_NO              32648   
#if (WINVER >= 0x0400)
#endif  /* WINVER >= 0x400 */

#define OIC_SAMPLE          32512
#define OIC_HAND            32513
#define OIC_QUES            32514
#define OIC_BANG            32515
#define OIC_NOTE            32516

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#if (WINVER >= 0x0400)
BOOL    WINAPI GetPrivateProfileStruct(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR);
BOOL    WINAPI WritePrivateProfileStruct(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR);
UINT    WINAPI GetProfileSectionNames(LPSTR, UINT);
UINT    WINAPI GetPrivateProfileSectionNames(LPSTR, UINT, LPCSTR);
int     WINAPI GetPrivateProfileSection(LPCSTR, LPSTR, UINT, LPCSTR);
int     WINAPI GetProfileSection(LPCSTR, LPSTR, UINT);
BOOL    WINAPI WritePrivateProfileSection(LPCSTR, LPCSTR, LPCSTR);
BOOL    WINAPI WriteProfileSection(LPCSTR, LPCSTR);
#endif /* WINVER >= 0x0400 */

/****** Registration Database Support ***************************************/
/* return codes from Registration functions */
/* Retained for win 3.x compatibility  and not needed 4.0 onwards */
/* For 4.0 onwards you should be including winerror.h */

#if (WINVER < 0x0400)

#define ERROR_SUCCESS			0L
#define ERROR_BADDB                     1L
#define ERROR_BADKEY			2L
#define ERROR_CANTOPEN			3L
#define ERROR_CANTREAD			4L
#define ERROR_CANTWRITE			5L
#define ERROR_INSUFFICIENT_MEMORY	6L
#define ERROR_INVALID_PARAMETER         7L
#define	ERROR_ACCESS_DENIED		8L

#endif /* WINVER < 0x400 */

#define REG_SZ				0x0001

#if (WINVER >= 0x0400)
#define REG_BINARY			0x0003
#endif

typedef DWORD HKEY;
typedef HKEY FAR* LPHKEY;

#if (WINVER < 0x0400)		// Win 3.1 compatibility
#define HKEY_CLASSES_ROOT		(( HKEY) 0x1)
#else				// Win 4 upwards
#define HKEY_CLASSES_ROOT		(( HKEY) 0x80000000)
#define HKEY_CURRENT_USER		(( HKEY) 0x80000001)
#define HKEY_LOCAL_MACHINE		(( HKEY) 0x80000002)
#define HKEY_USERS			(( HKEY) 0x80000003)
#define HKEY_PERFORMANCE_DATA		(( HKEY) 0x80000004)
#define HKEY_CURRENT_CONFIG		(( HKEY) 0x80000005)
#define HKEY_DYN_DATA			(( HKEY) 0x80000006)
#define HKEY_PREDEF_KEYS		7
#endif

LONG    WINAPI RegOpenKey(HKEY, LPCSTR, LPHKEY);
LONG    WINAPI RegCreateKey(HKEY, LPCSTR, LPHKEY);
LONG    WINAPI RegCloseKey(HKEY);
LONG    WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG    WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG    WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG    WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

#if (WINVER >= 0x0400)
LONG    WINAPI RegDeleteValue(HKEY, LPCSTR);
LONG    WINAPI RegEnumValue(HKEY, DWORD, LPCSTR,
                         LONG FAR *, DWORD, LONG FAR *, LPBYTE,
                         LONG FAR *);
LONG    WINAPI RegQueryValueEx(HKEY, LPCSTR, LONG FAR *, LONG FAR *,
			    LPBYTE, LONG FAR *);
LONG    WINAPI RegSetValueEx(HKEY, LPCSTR, DWORD, DWORD, LPBYTE, DWORD);
LONG    WINAPI RegFlushKey(HKEY);
LONG	WINAPI RegSaveKey(HKEY, LPCSTR,LPVOID);
LONG	WINAPI RegLoadKey(HKEY, LPCSTR,LPCSTR);
LONG	WINAPI RegUnLoadKey(HKEY, LPCSTR);

#endif		// WINVER >= 0x0400

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);

#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, DWORD);
#if (WINVER >= 0x0400)
LPSTR   WINAPI lstrcatn(LPSTR, LPCSTR, int);
#endif /* WINVER >= 0x0400 */
#endif /* WINVER >= 0x030a */
#endif /* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif /* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);


/****** Keyboard Driver Functions *******************************************/

#ifndef NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif /* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;
typedef const RECT FAR * LPCRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;
typedef const POINT FAR * LPCPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#if (WINVER >= 0x0400)

/* Common structures for 4.X/Win32 GDI APIs */

typedef struct tagPOINTS
{
   SHORT    x;
   SHORT    y;

} POINTS;
typedef POINTS*       PPOINTS;
typedef POINTS NEAR*  NPPOINTS;
typedef POINTS FAR*   LPPOINTS;
typedef const POINTS FAR* LPCPOINTS;

typedef struct tagPOINTL
{
   LONG     x;
   LONG     y;

} POINTL;
typedef POINTL*       PPOINTL;
typedef POINTL NEAR*  NPPOINTL;
typedef POINTL FAR*   LPPOINTL;
typedef const POINTL FAR* LPCPOINTL;

typedef struct tagSIZEL
{
   LONG     cx;
   LONG     cy;

} SIZEL;
typedef SIZEL*       PSIZEL;
typedef SIZEL NEAR*  NPSIZEL;
typedef SIZEL FAR*   LPSIZEL;
typedef const SIZEL FAR* LPCSIZEL;

typedef struct tagRECTL
{                      
   LONG     left;      
   LONG     top;       
   LONG     right;     
   LONG     bottom;    
                       
} RECTL;               
typedef RECTL*       PRECTL; 
typedef RECTL NEAR*  NPRECTL; 
typedef RECTL FAR*   LPRECTL;  
typedef const RECTL FAR* LPCRECTL;
#endif /* WINVER >= 0x0400 */

#define MAKEPOINT(l)     (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, LPCRECT lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, LPRECT lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY       DCB_ACCUMULATE
#define DCB_SET         (DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080
#define PC_POLYPOLYGON      0x0100

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT         1
#define MM_LOMETRIC     2
#define MM_HIMETRIC     3
#define MM_LOENGLISH    4
#define MM_HIENGLISH    5
#define MM_TWIPS        6
#define MM_ISOTROPIC    7
#define MM_ANISOTROPIC  8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);

/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)      ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)  ((BYTE)(rgb))
#define GetGValue(rgb)  ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)  ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

HBRUSH   WINAPI GetSysColorBrush(int);
COLORREF WINAPI GetSysColor(int);
void     WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR             0
#define COLOR_DESKTOP               1
#define COLOR_ACTIVECAPTION         2
#define COLOR_INACTIVECAPTION       3
#define COLOR_MENU                  4
#define COLOR_WINDOW                5
#define COLOR_WINDOWFRAME           6
#define COLOR_MENUTEXT              7
#define COLOR_WINDOWTEXT            8
#define COLOR_CAPTIONTEXT           9
#define COLOR_ACTIVEBORDER          10
#define COLOR_INACTIVEBORDER        11
#define COLOR_APPWORKSPACE          12
#define COLOR_HIGHLIGHT             13
#define COLOR_HIGHLIGHTTEXT         14
#define COLOR_3DFACE                15
#define COLOR_3DSHADOW              16
#define COLOR_GRAYTEXT              17
#define COLOR_BTNTEXT               18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT   19
#define COLOR_3DHILIGHT             20
#if (WINVER >= 0x0400)
#define COLOR_3DDKSHADOW            21
#define COLOR_3DLIGHT               22
#define COLOR_MSGBOX                23
#define COLOR_MSGBOXTEXT            24
#endif /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */

#define COLOR_BACKGROUND            COLOR_DESKTOP
#define COLOR_BTNFACE               COLOR_3DFACE
#define COLOR_BTNSHADOW             COLOR_3DSHADOW
#define COLOR_BTNHIGHLIGHT          COLOR_3DHILIGHT

#endif  /* NOCOLOR */

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN         1
#define OBJ_BRUSH       2

#if (WINVER >= 0x0400)

HANDLE WINAPI SetObjectOwner(HGDIOBJ, HANDLE);

#endif

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID        0
#define PS_DASH         1
#define PS_DOT          2
#define PS_DASHDOT      3
#define PS_DASHDOTDOT   4
#define PS_NULL         5
#define PS_INSIDEFRAME  6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN       6
#define BLACK_PEN       7
#define NULL_PEN        8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID        0
#define BS_NULL         1
#define BS_HOLLOW       BS_NULL
#define BS_HATCHED      2
#define BS_PATTERN      3
#define BS_INDEXED      4
#define BS_DIBPATTERN   5

/* Hatch Styles */
#define HS_HORIZONTAL   0
#define HS_VERTICAL     1
#define HS_FDIAGONAL    2
#define HS_BDIAGONAL    3
#define HS_CROSS        4
#define HS_DIAGCROSS    5
#define HS_API_MAX      6

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH        PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH    0
#define LTGRAY_BRUSH   1
#define GRAY_BRUSH     2
#define DKGRAY_BRUSH   3
#define BLACK_BRUSH    4
#define NULL_BRUSH     5
#define HOLLOW_BRUSH   NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif /* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(LPCRECT);
HRGN    WINAPI CreateEllipticRgnIndirect(LPCRECT);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(LPCPOINT, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(LPCPOINT, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR           0
#define NULLREGION      1
#define SIMPLEREGION    2
#define COMPLEXREGION   3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND         1
#define RGN_OR          2
#define RGN_XOR         3
#define RGN_DIFF        4
#define RGN_COPY        5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, LPRECT);

BOOL    WINAPI RectInRegion(HRGN, LPCRECT);
BOOL    WINAPI PtInRegion(HRGN, int, int);


/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED 0x01 /* palette index used for animation */
#define PC_EXPLICIT 0x02 /* palette index is explicit to device */
#define PC_NOCOLLAPSE 0x04 /* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define SYSPAL_STATIC   1
#define SYSPAL_NOSTATIC 2

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, LPRECT);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, LPCRECT);


/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, LPCPOINT, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, LPCPOINT, int);
BOOL    WINAPI PolyPolygon(HDC, LPCPOINT, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, LPCRECT, HBRUSH);
int     WINAPI FrameRect(HDC, LPCRECT, HBRUSH);
BOOL    WINAPI InvertRect(HDC, LPCRECT);

void    WINAPI DrawFocusRect(HDC, LPCRECT);

/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, LPCRECT, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED      0x0001
#define ETO_OPAQUE      0x0002
#define ETO_CLIPPED     0x0004

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_LEFT             0x0000
#define DT_CENTER           0x0001
#define DT_RIGHT            0x0002
#define DT_TOP              0x0000
#define DT_VCENTER          0x0004
#define DT_BOTTOM           0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE       0x0020
#define DT_EXPANDTABS       0x0040
#define DT_TABSTOP          0x0080
#define DT_NOCLIP           0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT         0x0400
#define DT_NOPREFIX         0x0800
#define DT_INTERNAL         0x1000
#define DT_EDITCONTROL      0x00002000

int     WINAPI DrawText(HDC, LPCSTR, int, LPRECT, UINT);

#if (WINVER >= 0x0400)
typedef struct tagDRAWTEXTPARAMS
{
    DWORD   cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
}   DRAWTEXTPARAMS, FAR *LPDRAWTEXTPARAMS;

int     WINAPI DrawTextEx(HDC, LPCSTR, int, LPRECT, DWORD, LPDRAWTEXTPARAMS);
#endif /* WINVER >= 0x0400 */

#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

/* Monolithic state-drawing routine */

#if (WINVER >= 0x0400)
/* Image type */
#define DST_COMPLEX     0x0000
#define DST_TEXT        0x0001
#define DST_PREFIXTEXT  0x0002
#define DST_ICON        0x0003
#define DST_BITMAP      0x0004

/* State type */
#define DSS_NORMAL      0x0000
#define DSS_UNION       0x0010  /* Old gray string appearance */
#define DSS_DISABLED    0x0020
#define DSS_MONO        0x0080

#ifdef STRICT
typedef BOOL (CALLBACK* DRAWSTATEPROC)(HDC, LPARAM, WPARAM, int, int);
#else
typedef FARPROC DRAWSTATEPROC;
#endif
BOOL    WINAPI DrawState(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);
#endif /* WINVER >= 0x0400 */

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP   0x0000
#define TA_UPDATECP     0x0001
#define TA_LEFT         0x0000
#define TA_RIGHT        0x0002
#define TA_CENTER       0x0006
#define TA_TOP          0x0000
#define TA_BOTTOM       0x0008
#define TA_BASELINE     0x0018

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

/* Logical Font */
#define LF_FACESIZE     32

#ifndef NOGDIOBJ
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE     0
#define FW_THIN         100
#define FW_EXTRALIGHT   200
#define FW_LIGHT        300
#define FW_NORMAL       400
#define FW_MEDIUM       500
#define FW_SEMIBOLD     600
#define FW_BOLD         700
#define FW_EXTRABOLD    800
#define FW_HEAVY        900

#define FW_ULTRALIGHT   FW_EXTRALIGHT
#define FW_REGULAR      FW_NORMAL
#define FW_DEMIBOLD     FW_SEMIBOLD
#define FW_ULTRABOLD    FW_EXTRABOLD
#define FW_BLACK        FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET        0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET      2
#if (WINVER >= 0x0400)
#define	MAC_CHARSET         77
#endif /* WINVER >= 0x0400 */
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define GB2312_CHARSET      134
#define CHINESEBIG5_CHARSET 136
#define OEM_CHARSET         255
#define HEBREW_CHARSET		 177
#define ARABIC_CHARSET		 178
#define GREEK_CHARSET		 161
#define TURKISH_CHARSET		 162
#define EASTEUROPE_CHARSET	 238
#define RUSSIAN_CHARSET		 204

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS      0
#define OUT_STRING_PRECIS       1
#define OUT_CHARACTER_PRECIS    2
#define OUT_STROKE_PRECIS       3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS           4
#define OUT_DEVICE_PRECIS       5
#define OUT_RASTER_PRECIS       6
#define OUT_TT_ONLY_PRECIS      7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK               0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES          0x10
#define CLIP_TT_ALWAYS          0x20
#define CLIP_EMBEDDED           0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16


DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING    0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

int     WINAPI GetTextFace(HDC, int, LPSTR);

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif /* NOGDIOBJ */


typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;


#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_VARIABLE_PITCH 0x01
#define TMPF_VECTOR         0x02
#define TMPF_DEVICE         0x08

/*
 * Yes, this looks bogus.  But it's because we got confused and named the
 * flag wrong.  LOGFONTs have an lfPitchAndFamily field, where FIXED_PITCH
 * is 0x01.  But TEXTMETRICs have a tmPitchAndFamily field, where
 * VARIABLE_PITCH is 0x01.  It's easy to confuse the two.  We're sorry.
*/
#define TMPF_FIXED_PITCH    TMPF_VARIABLE_PITCH

#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE       0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x0400)

#define PANOSE_COUNT               10
#define PAN_FAMILYTYPE_INDEX        0
#define PAN_SERIFSTYLE_INDEX        1
#define PAN_WEIGHT_INDEX            2
#define PAN_PROPORTION_INDEX        3
#define PAN_CONTRAST_INDEX          4
#define PAN_STROKEVARIATION_INDEX   5
#define PAN_ARMSTYLE_INDEX          6
#define PAN_LETTERFORM_INDEX        7
#define PAN_MIDLINE_INDEX           8
#define PAN_XHEIGHT_INDEX           9

#define PAN_CULTURE_LATIN           0

#define PAN_ANY                         0 /* Any                            */
#define PAN_NO_FIT                      1 /* No Fit                         */

#define PAN_FAMILY_TEXT_DISPLAY         2 /* Text and Display               */
#define PAN_FAMILY_SCRIPT               3 /* Script                         */
#define PAN_FAMILY_DECORATIVE           4 /* Decorative                     */
#define PAN_FAMILY_PICTORIAL            5 /* Pictorial                      */

#define PAN_SERIF_COVE                  2 /* Cove                           */
#define PAN_SERIF_OBTUSE_COVE           3 /* Obtuse Cove                    */
#define PAN_SERIF_SQUARE_COVE           4 /* Square Cove                    */
#define PAN_SERIF_OBTUSE_SQUARE_COVE    5 /* Obtuse Square Cove             */
#define PAN_SERIF_SQUARE                6 /* Square                         */
#define PAN_SERIF_THIN                  7 /* Thin                           */
#define PAN_SERIF_BONE                  8 /* Bone                           */
#define PAN_SERIF_EXAGGERATED           9 /* Exaggerated                    */
#define PAN_SERIF_TRIANGLE             10 /* Triangle                       */
#define PAN_SERIF_NORMAL_SANS          11 /* Normal Sans                    */
#define PAN_SERIF_OBTUSE_SANS          12 /* Obtuse Sans                    */
#define PAN_SERIF_PERP_SANS            13 /* Prep Sans                      */
#define PAN_SERIF_FLARED               14 /* Flared                         */
#define PAN_SERIF_ROUNDED              15 /* Rounded                        */

#define PAN_WEIGHT_VERY_LIGHT           2 /* Very Light                     */
#define PAN_WEIGHT_LIGHT                3 /* Light                          */
#define PAN_WEIGHT_THIN                 4 /* Thin                           */
#define PAN_WEIGHT_BOOK                 5 /* Book                           */
#define PAN_WEIGHT_MEDIUM               6 /* Medium                         */
#define PAN_WEIGHT_DEMI                 7 /* Demi                           */
#define PAN_WEIGHT_BOLD                 8 /* Bold                           */
#define PAN_WEIGHT_HEAVY                9 /* Heavy                          */
#define PAN_WEIGHT_BLACK               10 /* Black                          */
#define PAN_WEIGHT_NORD                11 /* Nord                           */

#define PAN_PROP_OLD_STYLE              2 /* Old Style                      */
#define PAN_PROP_MODERN                 3 /* Modern                         */
#define PAN_PROP_EVEN_WIDTH             4 /* Even Width                     */
#define PAN_PROP_EXPANDED               5 /* Expanded                       */
#define PAN_PROP_CONDENSED              6 /* Condensed                      */
#define PAN_PROP_VERY_EXPANDED          7 /* Very Expanded                  */
#define PAN_PROP_VERY_CONDENSED         8 /* Very Condensed                 */
#define PAN_PROP_MONOSPACED             9 /* Monospaced                     */

#define PAN_CONTRAST_NONE               2 /* None                           */
#define PAN_CONTRAST_VERY_LOW           3 /* Very Low                       */
#define PAN_CONTRAST_LOW                4 /* Low                            */
#define PAN_CONTRAST_MEDIUM_LOW         5 /* Medium Low                     */
#define PAN_CONTRAST_MEDIUM             6 /* Medium                         */
#define PAN_CONTRAST_MEDIUM_HIGH        7 /* Mediim High                    */
#define PAN_CONTRAST_HIGH               8 /* High                           */
#define PAN_CONTRAST_VERY_HIGH          9 /* Very High                      */

#define PAN_STROKE_GRADUAL_DIAG         2 /* Gradual/Diagonal               */
#define PAN_STROKE_GRADUAL_TRAN         3 /* Gradual/Transitional           */
#define PAN_STROKE_GRADUAL_VERT         4 /* Gradual/Vertical               */
#define PAN_STROKE_GRADUAL_HORZ         5 /* Gradual/Horizontal             */
#define PAN_STROKE_RAPID_VERT           6 /* Rapid/Vertical                 */
#define PAN_STROKE_RAPID_HORZ           7 /* Rapid/Horizontal               */
#define PAN_STROKE_INSTANT_VERT         8 /* Instant/Vertical               */

#define PAN_STRAIGHT_ARMS_HORZ          2 /* Straight Arms/Horizontal       */
#define PAN_STRAIGHT_ARMS_WEDGE         3 /* Straight Arms/Wedge            */
#define PAN_STRAIGHT_ARMS_VERT          4 /* Straight Arms/Vertical         */
#define PAN_STRAIGHT_ARMS_SINGLE_SERIF  5 /* Straight Arms/Single-Serif     */
#define PAN_STRAIGHT_ARMS_DOUBLE_SERIF  6 /* Straight Arms/Double-Serif     */
#define PAN_BENT_ARMS_HORZ              7 /* Non-Straight Arms/Horizontal   */
#define PAN_BENT_ARMS_WEDGE             8 /* Non-Straight Arms/Wedge        */
#define PAN_BENT_ARMS_VERT              9 /* Non-Straight Arms/Vertical     */
#define PAN_BENT_ARMS_SINGLE_SERIF     10 /* Non-Straight Arms/Single-Serif */
#define PAN_BENT_ARMS_DOUBLE_SERIF     11 /* Non-Straight Arms/Double-Serif */

#define PAN_LETT_NORMAL_CONTACT         2 /* Normal/Contact                 */
#define PAN_LETT_NORMAL_WEIGHTED        3 /* Normal/Weighted                */
#define PAN_LETT_NORMAL_BOXED           4 /* Normal/Boxed                   */
#define PAN_LETT_NORMAL_FLATTENED       5 /* Normal/Flattened               */
#define PAN_LETT_NORMAL_ROUNDED         6 /* Normal/Rounded                 */
#define PAN_LETT_NORMAL_OFF_CENTER      7 /* Normal/Off Center              */
#define PAN_LETT_NORMAL_SQUARE          8 /* Normal/Square                  */
#define PAN_LETT_OBLIQUE_CONTACT        9 /* Oblique/Contact                */
#define PAN_LETT_OBLIQUE_WEIGHTED      10 /* Oblique/Weighted               */
#define PAN_LETT_OBLIQUE_BOXED         11 /* Oblique/Boxed                  */
#define PAN_LETT_OBLIQUE_FLATTENED     12 /* Oblique/Flattened              */
#define PAN_LETT_OBLIQUE_ROUNDED       13 /* Oblique/Rounded                */
#define PAN_LETT_OBLIQUE_OFF_CENTER    14 /* Oblique/Off Center             */
#define PAN_LETT_OBLIQUE_SQUARE        15 /* Oblique/Square                 */

#define PAN_MIDLINE_STANDARD_TRIMMED    2 /* Standard/Trimmed               */
#define PAN_MIDLINE_STANDARD_POINTED    3 /* Standard/Pointed               */
#define PAN_MIDLINE_STANDARD_SERIFED    4 /* Standard/Serifed               */
#define PAN_MIDLINE_HIGH_TRIMMED        5 /* High/Trimmed                   */
#define PAN_MIDLINE_HIGH_POINTED        6 /* High/Pointed                   */
#define PAN_MIDLINE_HIGH_SERIFED        7 /* High/Serifed                   */
#define PAN_MIDLINE_CONSTANT_TRIMMED    8 /* Constant/Trimmed               */
#define PAN_MIDLINE_CONSTANT_POINTED    9 /* Constant/Pointed               */
#define PAN_MIDLINE_CONSTANT_SERIFED   10 /* Constant/Serifed               */
#define PAN_MIDLINE_LOW_TRIMMED        11 /* Low/Trimmed                    */
#define PAN_MIDLINE_LOW_POINTED        12 /* Low/Pointed                    */
#define PAN_MIDLINE_LOW_SERIFED        13 /* Low/Serifed                    */

#define PAN_XHEIGHT_CONSTANT_SMALL      2 /* Constant/Small                 */
#define PAN_XHEIGHT_CONSTANT_STD        3 /* Constant/Standard              */
#define PAN_XHEIGHT_CONSTANT_LARGE      4 /* Constant/Large                 */
#define PAN_XHEIGHT_DUCKING_SMALL       5 /* Ducking/Small                  */
#define PAN_XHEIGHT_DUCKING_STD         6 /* Ducking/Standard               */
#define PAN_XHEIGHT_DUCKING_LARGE       7 /* Ducking/Large                  */

#endif   /* WINVER >= 0x0400 */

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* NOSCALABLEFONT */
#endif  /* WINVER >= 0x030a */


#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR 0x00000040L
#define NTM_BOLD 0x00000020L
#define NTM_ITALIC 0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);
int     WINAPI EnumFontFamiliesEx(HDC, LPLOGFONT, FONTENUMPROC, LPARAM,DWORD);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2
#if (WINVER >= 0x0400)
#define	GGO_GRAY2_BITMAP   4
#define	GGO_GRAY4_BITMAP   5
#define	GGO_GRAY8_BITMAP   6
#endif /* WINVER >= 0x0400 */


#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE 0x0001
#define TT_ENABLED 0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB       0L
#define BI_RLE8      1L
#define BI_RLE4      2L
#define BI_BITFIELDS 3L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD      bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE      bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;

HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif /* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATOR               0x00FA0089L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L
#define SRCSTENCIL          0x00B8074AL
#define SRCINVSTENCIL       0x00E20746L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE 1
#define WHITEONBLACK 2
#define COLORONCOLOR 3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3


#if (WINVER >= 0x0400)
#define AVERAGE             5
#define STRETCH_AVESCANS    5
#endif /* WINVER >= 0x0400 */

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif /* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR             0x0201
#define META_SETBKMODE              0x0102
#define META_SETMAPMODE             0x0103
#define META_SETROP2                0x0104
#define META_SETRELABS              0x0105
#define META_SETPOLYFILLMODE        0x0106
#define META_SETSTRETCHBLTMODE      0x0107
#define META_SETTEXTCHAREXTRA       0x0108
#define META_SETTEXTCOLOR           0x0209
#define META_SETTEXTJUSTIFICATION   0x020A
#define META_SETWINDOWORG           0x020B
#define META_SETWINDOWEXT           0x020C
#define META_SETVIEWPORTORG         0x020D
#define META_SETVIEWPORTEXT         0x020E
#define META_OFFSETWINDOWORG        0x020F
#define META_SCALEWINDOWEXT         0x0410
#define META_OFFSETVIEWPORTORG      0x0211
#define META_SCALEVIEWPORTEXT       0x0412
#define META_LINETO                 0x0213
#define META_MOVETO                 0x0214
#define META_EXCLUDECLIPRECT        0x0415
#define META_INTERSECTCLIPRECT      0x0416
#define META_ARC                    0x0817
#define META_ELLIPSE                0x0418
#define META_FLOODFILL              0x0419
#define META_PIE                    0x081A
#define META_RECTANGLE              0x041B
#define META_ROUNDRECT              0x061C
#define META_PATBLT                 0x061D
#define META_SAVEDC                 0x001E
#define META_SETPIXEL               0x041F
#define META_OFFSETCLIPRGN          0x0220
#define META_TEXTOUT                0x0521
#define META_BITBLT                 0x0922
#define META_STRETCHBLT             0x0B23
#define META_POLYGON                0x0324
#define META_POLYLINE               0x0325
#define META_ESCAPE                 0x0626
#define META_RESTOREDC              0x0127
#define META_FILLREGION             0x0228
#define META_FRAMEREGION            0x0429
#define META_INVERTREGION           0x012A
#define META_PAINTREGION            0x012B
#define META_SELECTCLIPREGION       0x012C
#define META_SELECTOBJECT           0x012D
#define META_SETTEXTALIGN           0x012E
#define META_DRAWTEXT               0x062F

#define META_CHORD                  0x0830
#define META_SETMAPPERFLAGS         0x0231
#define META_EXTTEXTOUT             0x0a32
#define META_SETDIBTODEV            0x0d33
#define META_SELECTPALETTE          0x0234
#define META_REALIZEPALETTE         0x0035
#define META_ANIMATEPALETTE         0x0436
#define META_SETPALENTRIES          0x0037
#define META_POLYPOLYGON            0x0538
#define META_RESIZEPALETTE          0x0139

#define META_DIBBITBLT              0x0940
#define META_DIBSTRETCHBLT          0x0b41
#define META_DIBCREATEPATTERNBRUSH  0x0142
#define META_STRETCHDIB             0x0f43

#define META_EXTFLOODFILL           0x0548

#define META_RESETDC                0x014C
#define META_STARTDOC               0x014D
#define META_STARTPAGE              0x004F
#define META_ENDPAGE                0x0050
#define META_ABORTDOC               0x0052
#define META_ENDDOC                 0x005E

#define META_DELETEOBJECT           0x01f0

#define META_CREATEPALETTE          0x00f7
#define META_CREATEBRUSH            0x00F8
#define META_CREATEPATTERNBRUSH     0x01F9
#define META_CREATEPENINDIRECT      0x02FA
#define META_CREATEFONTINDIRECT     0x02FB
#define META_CREATEBRUSHINDIRECT    0x02FC
#define META_CREATEBITMAPINDIRECT   0x02FD
#define META_CREATEBITMAP           0x06FE
#define META_CREATEREGION           0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

int WINAPI SetAbortProc(HDC, ABORTPROC);

HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);

#endif  /* WINVER >= 0x030a */

typedef struct {
    short   cbSize;
    LPSTR   lpszDocName;
    LPSTR   lpszOutput;
    WORD    fwType;
    }	DOCINFO, FAR * LPDOCINFO;

#define DI_RAW		    0x0001
#define DI_DIRECT	    0x0002

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);
BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED      0x4000
#define SP_ERROR            (-1)
#define SP_APPABORT         (-2)
#define SP_USERABORT        (-3)
#define SP_OUTOFDISK        (-4)
#define SP_OUTOFMEMORY      (-5)

#define PR_JOBSTATUS        0x0000

#endif  /* NOGDI  */

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME                1
#define ABORTDOC                2
#define NEXTBAND                3
#define SETCOLORTABLE           4
#define GETCOLORTABLE           5
#define FLUSHOUTPUT             6
#define DRAFTMODE               7
#define QUERYESCSUPPORT         8
#define SETABORTPROC            9
#define STARTDOC                10
#define ENDDOC                  11
#define GETPHYSPAGESIZE         12
#define GETPRINTINGOFFSET       13
#define GETSCALINGFACTOR        14
#define MFCOMMENT               15
#define GETPENWIDTH             16
#define SETCOPYCOUNT            17
#define SELECTPAPERSOURCE       18
#define DEVICEDATA              19
#define PASSTHROUGH             19
#define GETTECHNOLGY            20
#define GETTECHNOLOGY           20
#define SETLINECAP              21
#define SETLINEJOIN             22
#define SETMITERLIMIT           23
#define BANDINFO                24
#define DRAWPATTERNRECT         25
#define GETVECTORPENSIZE        26
#define GETVECTORBRUSHSIZE      27
#define ENABLEDUPLEX            28
#define GETSETPAPERBINS         29
#define GETSETPRINTORIENT       30
#define ENUMPAPERBINS           31
#define SETDIBSCALING           32
#define EPSPRINTING             33
#define ENUMPAPERMETRICS        34
#define GETSETPAPERMETRICS      35
#define POSTSCRIPT_DATA         37
#define POSTSCRIPT_IGNORE       38
#define MOUSETRAILS             39

#define GETEXTENDEDTEXTMETRICS  256
#define GETEXTENTTABLE          257
#define GETPAIRKERNTABLE        258
#define GETTRACKKERNTABLE       259
#define EXTTEXTOUT              512
#define GETFACENAME             513
#define ENABLERELATIVEWIDTHS    768
#define ENABLEPAIRKERNING       769
#define SETKERNTRACK            770
#define SETALLJUSTVALUES        771
#define SETCHARSET              772

#define STRETCHBLT              2048
#define GETSETSCREENPARAMS      3072
#define QUERYDIBSUPPORT         3073
#define QDI_SETDIBITS           0x0001
#define QDI_GETDIBITS           0x0002
#define QDI_DIBTOSCREEN         0x0004
#define QDI_STRETCHDIB          0x0008

#define BEGIN_PATH              4096
#define CLIP_TO_PATH            4097
#define END_PATH                4098
#define EXT_DEVICE_CAPS         4099
#define RESTORE_CTM             4100
#define SAVE_CTM                4101
#define SET_ARC_DIRECTION       4102
#define SET_BACKGROUND_COLOR    4103
#define SET_POLY_MODE           4104
#define SET_SCREEN_ANGLE        4105
#define SET_SPREAD              4106
#define TRANSFORM_CTM           4107
#define SET_CLIP_BOX            4108
#define SET_BOUNDS              4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HWND);

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;     /* HICONs & HCURSORs are polymorphic */


/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN             0
#define SM_CYSCREEN             1
#define SM_CXVSCROLL            2
#define SM_CYHSCROLL            3
#define SM_CYCAPTION            4
#define SM_CXBORDER             5
#define SM_CYBORDER             6
#define SM_CXFIXEDFRAME         7
#define SM_CYFIXEDFRAME         8
#define SM_CYVTHUMB             9
#define SM_CXHTHUMB             10
#define SM_CXICON               11
#define SM_CYICON               12
#define SM_CXCURSOR             13
#define SM_CYCURSOR             14
#define SM_CYMENU               15
#define SM_CXFULLSCREEN         16
#define SM_CYFULLSCREEN         17
#define SM_CYKANJIWINDOW        18
#define SM_MOUSEPRESENT         19
#define SM_CYVSCROLL            20
#define SM_CXHSCROLL            21
#define SM_DEBUG                22
#define SM_SWAPBUTTON           23
#define SM_RESERVED1            24
#define SM_RESERVED2            25
#define SM_RESERVED3            26
#define SM_RESERVED4            27
#define SM_CXMIN                28
#define SM_CYMIN                29
#define SM_CXSIZE               30
#define SM_CYSIZE               31
#define SM_CXSIZEFRAME          32
#define SM_CYSIZEFRAME          33
#define SM_CXMINTRACK           34
#define SM_CYMINTRACK           35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK          36
#define SM_CYDOUBLECLK          37
#define SM_CXICONSPACING        38
#define SM_CYICONSPACING        39
#define SM_MENUDROPALIGNMENT    40
#define SM_PENWINDOWS           41
#define SM_DBCSENABLED          42
#endif  /* WINVER >= 0x030a */

#define SM_CXDLGFRAME           SM_CXFIXEDFRAME
#define SM_CYDLGFRAME           SM_CYFIXEDFRAME
#define SM_CXFRAME              SM_CXSIZEFRAME
#define SM_CYFRAME              SM_CYSIZEFRAME
#define SM_CMETRICS             81

#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);


/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)

#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP                 1
#define SPI_SETBEEP                 2
#define SPI_GETMOUSE                3
#define SPI_SETMOUSE                4
#define SPI_GETBORDER               5
#define SPI_SETBORDER               6
#define SPI_GETKEYBOARDSPEED        10
#define SPI_SETKEYBOARDSPEED        11
#define SPI_LANGDRIVER              12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY      18
#define SPI_SETGRIDGRANULARITY      19
#define SPI_SETDESKWALLPAPER        20
#define SPI_SETDESKPATTERN          21
#define SPI_GETKEYBOARDDELAY        22
#define SPI_SETKEYBOARDDELAY        23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP        25
#define SPI_SETICONTITLEWRAP        26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH       29
#define SPI_SETDOUBLECLKHEIGHT      30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME      32
#define SPI_SETMOUSEBUTTONSWAP      33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE          0x0001
#define SPIF_SENDCHANGE             0x0002
#define SPIF_SENDWININICHANGE       SPIF_SENDCHANGE

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(LPRECT, int, int, int, int);
void    WINAPI SetRectEmpty(LPRECT);

void    WINAPI CopyRect(LPRECT, LPCRECT);

BOOL    WINAPI IsRectEmpty(LPCRECT);

BOOL    WINAPI EqualRect(LPCRECT, LPCRECT);

BOOL    WINAPI IntersectRect(LPRECT, LPCRECT, LPCRECT);
BOOL    WINAPI UnionRect(LPRECT, LPCRECT, LPCRECT);
BOOL    WINAPI SubtractRect(LPRECT, LPCRECT, LPCRECT);

void    WINAPI OffsetRect(LPRECT, int, int);
void    WINAPI InflateRect(LPRECT, int, int);

BOOL    WINAPI PtInRect(LPCRECT, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND    hwnd;
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
    DWORD   time;
    POINT   pt;
} MSG, * PMSG, NEAR* NPMSG, FAR* LPMSG;

BOOL    WINAPI GetMessage(LPMSG, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(LPMSG, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE     0x0000
#define PM_REMOVE       0x0001
#define PM_NOYIELD      0x0002

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY          0x0001
#define QS_MOUSEMOVE    0x0002
#define QS_MOUSEBUTTON  0x0004
#define QS_MOUSE        (QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE  0x0008
#define QS_TIMER        0x0010
#define QS_PAINT        0x0020
#define QS_SENDMESSAGE  0x0040
#define QS_ALLINPUT     0x007f
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);

LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#if (WINVER >= 0x0400)
long  WINAPI  BroadcastSystemMessage(DWORD, LPDWORD, UINT, WPARAM, LPARAM);
                      
#define BSM_ALLCOMPONENTS       0x00000000
#define BSM_VXDS                0x00000001
#define BSM_NETDRIVER           0x00000002
#define BSM_INSTALLABLEDRIVERS  0x00000004
#define BSM_APPLICATIONS        0x00000008
                                          
#define BSF_QUERY               0x00000001
#define BSF_IGNORECURRENTTASK   0x00000002
#define BSF_FLUSHDISK           0x00000004
#define BSF_NOHANG              0x00000008
#define BSF_POSTMESSAGE         0x00000010
#define BSF_FORCEIFHUNG         0x00000020

/* Flags for wParam of WM_DEVICEBROADCAST message */
#define DBWF_LPARAMPOINTER	0x8000		
#define DBWF_LPARAMSTRING 	0x4000		
                                                
typedef struct tagBROADCASTSYSMSG
{
    UINT    uiMessage;                          
    WPARAM  wParam;                             
    LPARAM  lParam;                             
} BROADCASTSYSMSG;                              
                                                
typedef BROADCASTSYSMSG  FAR *LPBROADCASTSYSMSG;

#endif /* WINVER >= 0x0400 */
#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST ((HWND)-1)


BOOL WINAPI CallMsgFilter(LPMSG, int);

#define WH_GETMESSAGE           3

#define WH_CALLWNDPROC          4

#define WH_MSGFILTER            (-1)
#define WH_SYSMSGFILTER         6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX          0
#define MSGF_MENU               2
#define MSGF_MOVE               3
#define MSGF_SIZE               4
#define MSGF_SCROLLBAR          5
#define MSGF_NEXTWINDOW         6
#define MSGF_MAINLOOP           8
#define MSGF_USER               4096
#endif  /* NOMSG */

/* Standard window messages */
/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_NULL                 0x0000
#define WM_CREATE               0x0001
#define WM_DESTROY              0x0002
#define WM_MOVE                 0x0003
#define WM_SIZE                 0x0005
#define WM_ACTIVATE             0x0006
#define WM_SETFOCUS             0x0007
#define WM_KILLFOCUS            0x0008
#define WM_ENABLE               0x000A
#define WM_SETREDRAW            0x000B
#define WM_SETTEXT              0x000C
#define WM_GETTEXT              0x000D
#define WM_GETTEXTLENGTH        0x000E
#define WM_PAINT                0x000F

#define WM_CLOSE                0x0010
#define WM_QUERYENDSESSION      0x0011
#define WM_QUIT                 0x0012
#define WM_QUERYOPEN            0x0013
#define WM_ERASEBKGND           0x0014
#define WM_SYSCOLORCHANGE       0x0015
#define WM_ENDSESSION           0x0016
#define WM_SHOWWINDOW           0x0018
#define WM_CTLCOLOR             0x0019
#define WM_SETTINGCHANGE        0x001A
#define WM_WININICHANGE         WM_SETTINGCHANGE
#define WM_DEVMODECHANGE        0x001B
#define WM_ACTIVATEAPP          0x001C
#define WM_FONTCHANGE           0x001D
#define WM_TIMECHANGE           0x001E
#define WM_CANCELMODE           0x001F

#define WM_SETCURSOR            0x0020
#define WM_MOUSEACTIVATE        0x0021
#define WM_CHILDACTIVATE        0x0022
#define WM_QUEUESYNC            0x0023
#define WM_GETMINMAXINFO        0x0024
#define WM_ICONERASEBKGND       0x0027
#define WM_NEXTDLGCTL           0x0028
#define WM_SPOOLERSTATUS        0x002A
#define WM_DRAWITEM             0x002B
#define WM_MEASUREITEM          0x002C
#define WM_DELETEITEM           0x002D
#define WM_VKEYTOITEM           0x002E
#define WM_CHARTOITEM           0x002F

#define WM_SETFONT              0x0030
#define WM_GETFONT              0x0031
#define WM_QUERYDRAGICON        0x0037
#define WM_COMPAREITEM          0x0039

#define WM_COMPACTING           0x0041
#define WM_COMMNOTIFY           0x0044
#define WM_WINDOWPOSCHANGING    0x0046
#define WM_WINDOWPOSCHANGED     0x0047
#define WM_POWER                0x0048
#define WM_NOTIFY               0x004E

#define WM_TCARD		        0x0052
#define WM_HELP                 0x0053
#define WM_USERCHANGED		    0x0054



#define WM_NCCREATE             0x0081
#define WM_NCDESTROY            0x0082
#define WM_NCCALCSIZE           0x0083
#define WM_NCHITTEST            0x0084
#define WM_NCPAINT              0x0085
#define WM_NCACTIVATE           0x0086
#define WM_GETDLGCODE           0x0087

#define WM_NCMOUSEMOVE          0x00A0
#define WM_NCLBUTTONDOWN        0x00A1
#define WM_NCLBUTTONUP          0x00A2
#define WM_NCLBUTTONDBLCLK      0x00A3
#define WM_NCRBUTTONDOWN        0x00A4
#define WM_NCRBUTTONUP          0x00A5
#define WM_NCRBUTTONDBLCLK      0x00A6
#define WM_NCMBUTTONDOWN        0x00A7
#define WM_NCMBUTTONUP          0x00A8
#define WM_NCMBUTTONDBLCLK      0x00A9


#define WM_KEYFIRST             0x0100
#define WM_KEYDOWN              0x0100
#define WM_KEYUP                0x0101
#define WM_CHAR                 0x0102
#define WM_DEADCHAR             0x0103
#define WM_SYSKEYDOWN           0x0104
#define WM_SYSKEYUP             0x0105
#define WM_SYSCHAR              0x0106
#define WM_SYSDEADCHAR          0x0107
#define WM_KEYLAST              0x0108

#define WM_INITDIALOG           0x0110
#define WM_COMMAND              0x0111
#define WM_SYSCOMMAND           0x0112
#define WM_TIMER                0x0113
#define WM_HSCROLL              0x0114
#define WM_VSCROLL              0x0115
#define WM_INITMENU             0x0116
#define WM_INITMENUPOPUP        0x0117
#define WM_MENUSELECT           0x011F
#define WM_MENUCHAR             0x0120

#define WM_ENTERIDLE            0x0121

#define WM_MOUSEFIRST           0x0200
#define WM_MOUSEMOVE            0x0200
#define WM_LBUTTONDOWN          0x0201
#define WM_LBUTTONUP            0x0202
#define WM_LBUTTONDBLCLK        0x0203
#define WM_RBUTTONDOWN          0x0204
#define WM_RBUTTONUP            0x0205
#define WM_RBUTTONDBLCLK        0x0206
#define WM_MBUTTONDOWN          0x0207
#define WM_MBUTTONUP            0x0208
#define WM_MBUTTONDBLCLK        0x0209
#define WM_MOUSELAST            0x0209

#define WM_PARENTNOTIFY         0x0210

#define WM_MDICREATE            0x0220
#define WM_MDIDESTROY           0x0221
#define WM_MDIACTIVATE          0x0222
#define WM_MDIRESTORE           0x0223
#define WM_MDINEXT              0x0224
#define WM_MDIMAXIMIZE          0x0225
#define WM_MDITILE              0x0226
#define WM_MDICASCADE           0x0227
#define WM_MDIICONARRANGE       0x0228
#define WM_MDIGETACTIVE         0x0229

#define WM_MDISETMENU           0x0230
#define WM_DROPFILES            0x0233

#define WM_CUT                  0x0300
#define WM_COPY                 0x0301
#define WM_PASTE                0x0302
#define WM_CLEAR                0x0303
#define WM_UNDO                 0x0304
#define WM_RENDERFORMAT         0x0305
#define WM_RENDERALLFORMATS     0x0306
#define WM_DESTROYCLIPBOARD     0x0307
#define WM_DRAWCLIPBOARD        0x0308
#define WM_PAINTCLIPBOARD       0x0309
#define WM_SIZECLIPBOARD        0x030B
#define WM_VSCROLLCLIPBOARD     0x030A
#define WM_ASKCBFORMATNAME      0x030C
#define WM_CHANGECBCHAIN        0x030D
#define WM_HSCROLLCLIPBOARD     0x030E
#define WM_QUERYNEWPALETTE      0x030F

#define WM_PALETTEISCHANGING    0x0310
#define WM_PALETTECHANGED       0x0311
#define WM_PRINT                0x0317
#define WM_PRINTCLIENT          0x0318

/* WinPad specific messages */
#define WM_HANDHELDFIRST        0x0358
#define WM_HANDHELDLAST         0x035F

/* PenWindows specific messages */
#define WM_PENWINFIRST          0x0380
#define WM_PENWINLAST           0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST           0x0390
#define WM_COALESCE_LAST            0x039F

#define WM_USER                 0x0400

/* NOTE: All messages between WM_APP and 0xBFFF are for exclusive use by apps */
#define WM_APP                  0x8000

#if (WINVER >= 0x030a)
/****** Power management ****************************************************/

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

#if (WINVER >= 0x0400)
/*  wParam for WM_SIZING message  */
#define WMSZ_LEFT           1
#define WMSZ_RIGHT          2
#define WMSZ_TOP            3
#define WMSZ_TOPLEFT        4
#define WMSZ_TOPRIGHT       5
#define WMSZ_BOTTOM         6
#define WMSZ_BOTTOMLEFT     7
#define WMSZ_BOTTOMRIGHT    8

#endif  /* WINVER >= 0x400 */

/****** Application termination *********************************************/

void    WINAPI PostQuitMessage(int);

/****** Window class management *********************************************/

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, LPWNDCLASS);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002
#define CS_KEYCVTWINDOW     0x0004
#define CS_DBLCLKS          0x0008

#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080

#define CS_NOKEYCVT         0x0100
#define CS_NOCLOSE          0x0200
#define CS_SAVEBITS         0x0800

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000
#define CS_GLOBALCLASS      0x4000

#endif /* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME        (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR         (-12)
#define GCW_HICON           (-14)
#define GCW_HMODULE         (-16)
#define GCW_CBWNDEXTRA      (-18)
#define GCW_CBCLSEXTRA      (-20)
#define GCL_WNDPROC         (-24)
#define GCW_STYLE           (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif  /* WINVER >= 0x030a */
#endif /* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED           0x00000000L
#define WS_POPUP                0x80000000L
#define WS_CHILD                0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS         0x04000000L
#define WS_CLIPCHILDREN         0x02000000L

/* Generic window states */
#define WS_VISIBLE              0x10000000L
#define WS_DISABLED             0x08000000L

/* Main window states */
#define WS_MINIMIZE             0x20000000L
#define WS_MAXIMIZE             0x01000000L

/* Main window styles */
#define WS_CAPTION              0x00C00000L     /* WS_BORDER | WS_DLGFRAME */
#define WS_BORDER               0x00800000L
#define WS_DLGFRAME             0x00400000L
#define WS_VSCROLL              0x00200000L
#define WS_HSCROLL              0x00100000L
#define WS_SYSMENU              0x00080000L
#define WS_THICKFRAME           0x00040000L
#define WS_MINIMIZEBOX          0x00020000L
#define WS_MAXIMIZEBOX          0x00010000L

/* Control window styles */
#define WS_GROUP                0x00020000L
#define WS_TABSTOP              0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW     (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW          (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW          (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME     0x00000001L
#define WS_EX_NOPARENTNOTIFY    0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST           0x00000008L
#define WS_EX_ACCEPTFILES       0x00000010L
#define WS_EX_TRANSPARENT       0x00000020L
#endif  /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED                WS_OVERLAPPED
#define WS_ICONIC               WS_MINIMIZE
#define WS_SIZEBOX              WS_THICKFRAME
#define WS_TILEDWINDOW          WS_OVERLAPPEDWINDOW

#endif  /* NOWINSTYLES */


/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT, FAR * LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);

#ifndef NOSHOWWINDOW

#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           SW_SHOWNORMAL
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         SW_SHOWMAXIMIZED
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW         SW_HIDE
#define SHOW_OPENWINDOW     SW_SHOWNORMAL
#define SHOW_ICONWINDOW     SW_SHOWMINIMIZED
#define SHOW_FULLSCREEN     SW_SHOWMAXIMIZED
#define SHOW_OPENNOACTIVATE SW_SHOWNOACTIVATE

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM      SW_OTHERRESTORED
#endif /* NOSHOWWINDOW */

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowText(HWND, LPSTR, int);
int     WINAPI GetWindowTextLength(HWND);

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC     (-4)
#define GWW_HINSTANCE   (-6)
#define GWW_HWNDPARENT  (-8)
#define GWW_ID          (-12)
#define GWL_STYLE       (-16)
#define GWL_EXSTYLE     (-20)
#endif  /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT     ((int)0x8000)

void    WINAPI GetClientRect(HWND, LPRECT);
void    WINAPI GetWindowRect(HWND, LPRECT);


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);
/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME       SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000

/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM         ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)


#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

/* WM_SIZE message wParam values */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/* Obsolete constant names */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(LPRECT, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(LPRECT, DWORD, BOOL, DWORD);

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;

BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, POINT FAR*);
void    WINAPI ScreenToClient(HWND, POINT FAR*);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);
HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);


HWND    WINAPI GetTopWindow(HWND);
HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST        0
#define GW_HWNDLAST         1
#define GW_HWNDNEXT         2
#define GW_HWNDPREV         3
#define GW_OWNER            4
#define GW_CHILD            5

/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW          0x00000001L
#define DCX_CACHE           0x00000002L
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP      0x00000020L
#define DCX_EXCLUDERGN      0x00000040L
#define DCX_INTERSECTRGN    0x00000080L
#define DCX_LOCKWINDOWUPDATE 0x00000400L
#define DCX_USESTYLE        0x00010000L
#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/


/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC  hdc;
    BOOL fErase;
    RECT rcPaint;
    BOOL fRestore;
    BOOL fIncUpdate;
    BYTE rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI BeginPaint(HWND, LPPAINTSTRUCT);
void    WINAPI EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI UpdateWindow(HWND);

int     WINAPI ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, LPRECT, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, LPCRECT, BOOL);
void    WINAPI ValidateRect(HWND, LPCRECT);

void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, LPCRECT lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE      0x0001
#define RDW_INTERNALPAINT   0x0002
#define RDW_ERASE           0x0004
#define RDW_VALIDATE        0x0008

#define RDW_NOINTERNALPAINT 0x0010
#define RDW_NOERASE         0x0020
#define RDW_NOCHILDREN      0x0040
#define RDW_ALLCHILDREN     0x0080

#define RDW_UPDATENOW       0x0100
#define RDW_ERASENOW        0x0200
#define RDW_FRAME           0x0400
#define RDW_NOFRAME         0x0800

#endif  /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, LPCRECT, LPCRECT);
BOOL    WINAPI ScrollDC(HDC, int, int, LPCRECT, LPCRECT, HRGN, LPRECT);

#if (WINVER >= 0x030a)
int WINAPI ScrollWindowEx(HWND, int, int, LPCRECT, LPCRECT, HRGN, LPRECT, UINT);

#define SW_SCROLLCHILDREN       0x0001
#define SW_INVALIDATE           0x0002
#define SW_ERASE                0x0004
#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW          (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400

/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;


/* WM_NCHITTEST return codes */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTSIZE              4
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTGROWBOX           HTSIZE
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);
HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE         0
#define WA_ACTIVE           1
#define WA_CLICKACTIVE      2

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(BYTE FAR* );
void    WINAPI SetKeyboardState(BYTE FAR* );

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED     0x0100
#define KF_DLGMODE      0x0800
#define KF_MENUMODE     0x1000
#define KF_ALTDOWN      0x2000
#define KF_REPEAT       0x4000
#define KF_UP           0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON      0x01
#define VK_RBUTTON      0x02
#define VK_CANCEL       0x03
#define VK_MBUTTON      0x04
#define VK_BACK         0x08
#define VK_TAB          0x09
#define VK_CLEAR        0x0C
#define VK_RETURN       0x0D
#define VK_SHIFT        0x10
#define VK_CONTROL      0x11
#define VK_MENU         0x12
#define VK_PAUSE        0x13
#define VK_CAPITAL      0x14
#define VK_ESCAPE       0x1B
#define VK_SPACE        0x20
#define VK_PRIOR        0x21
#define VK_NEXT         0x22
#define VK_END          0x23
#define VK_HOME         0x24
#define VK_LEFT         0x25
#define VK_UP           0x26
#define VK_RIGHT        0x27
#define VK_DOWN         0x28
#define VK_SELECT       0x29
#define VK_PRINT        0x2A
#define VK_EXECUTE      0x2B
#define VK_SNAPSHOT     0x2C
#define VK_INSERT       0x2D
#define VK_DELETE       0x2E
#define VK_HELP         0x2F
#define VK_NUMPAD0      0x60
#define VK_NUMPAD1      0x61
#define VK_NUMPAD2      0x62
#define VK_NUMPAD3      0x63
#define VK_NUMPAD4      0x64
#define VK_NUMPAD5      0x65
#define VK_NUMPAD6      0x66
#define VK_NUMPAD7      0x67
#define VK_NUMPAD8      0x68
#define VK_NUMPAD9      0x69
#define VK_MULTIPLY     0x6A
#define VK_ADD          0x6B
#define VK_SEPARATOR    0x6C
#define VK_SUBTRACT     0x6D
#define VK_DECIMAL      0x6E
#define VK_DIVIDE       0x6F
#define VK_F1           0x70
#define VK_F2           0x71
#define VK_F3           0x72
#define VK_F4           0x73
#define VK_F5           0x74
#define VK_F6           0x75
#define VK_F7           0x76
#define VK_F8           0x77
#define VK_F9           0x78
#define VK_F10          0x79
#define VK_F11          0x7A
#define VK_F12          0x7B
#define VK_F13          0x7C
#define VK_F14          0x7D
#define VK_F15          0x7E
#define VK_F16          0x7F
#define VK_F17          0x80
#define VK_F18          0x81
#define VK_F19          0x82
#define VK_F20          0x83
#define VK_F21          0x84
#define VK_F22          0x85
#define VK_F23          0x86
#define VK_F24          0x87
#define VK_NUMLOCK      0x90
#define VK_SCROLL       0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '9' */

#endif  /* NOVIRTUALKEYCODES */


/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD     2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
HWND    WINAPI GetCapture(void);
void    WINAPI ReleaseCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON      0x0001
#define MK_RBUTTON      0x0002
#define MK_SHIFT        0x0004
#define MK_CONTROL      0x0008
#define MK_MBUTTON      0x0010
#endif  /* NOKEYSTATES */

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE            7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif /* NOWH */

/****** Mode control ********************************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);


/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);


#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, LPMSG);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct tagMENUITEMTEMPLATEHEADER
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct tagMENUITEMTEMPLATE
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

BOOL    WINAPI IsMenu(HMENU);

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);
HMENU   WINAPI GetMenu(HWND);
HMENU   WINAPI GetSystemMenu(HWND, BOOL);
HMENU   WINAPI GetSubMenu(HMENU, UINT);
BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);
BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);

BOOL    WINAPI DestroyMenu(HMENU);
BOOL    WINAPI SetMenu(HWND, HMENU);
void    WINAPI DrawMenuBar(HWND);
BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

#define MF_INSERT           0x0000  /* Obsolete -- only used by ChangeMenu */
#define MF_CHANGE           0x0080  /* Obsolete -- only used by ChangeMenu */
#define MF_APPEND           0x0100  /* Obsolete -- only used by ChangeMenu */
#define MF_DELETE           0x0200  /* Obsolete -- only used by ChangeMenu */
#define MF_REMOVE           0x1000  /* Obsolete -- only used by ChangeMenu */

#define MF_BYCOMMAND        0x0000  /* Obsolete -- only old APIs use these */
#define MF_BYPOSITION       0x0400  /* Obsolete -- only old APIs use these */
#define MF_USECHECKBITMAPS  0x0200  /* Obsolete -- replaced by MF_RADIOCHECK */
#define MF_HELP             0x4000  /* Obsolete -- use MF_RIGHTJUSTIFY */

#define MF_POPUP            0x0010  /* Obsolete -- replace by hSubMenu field */
#define MF_END              0x0080  /* Obsolete -- only used by old RES files */
#define MF_SYSMENU          0x2000  /* Passed back during WM_MENUSELECT */
#define MF_MOUSESELECT      0x8000  /* Passed back during WM_MENUSELECT */

#define MFT_STRING          0x0000
#define MFT_BITMAP          0x0004
#define MFT_MENUBARBREAK    0x0020
#define MFT_MENUBREAK       0x0040
#define MFT_OWNERDRAW       0x0100
#define MFT_RADIOCHECK      0x0200
#define MFT_SEPARATOR       0x0800
#define MFT_RIGHTJUSTIFY    0x4000
#define MFT_MASK            0x4B64

#define MFS_GRAYED          0x0003
#define MFS_DISABLED        0x0002
#define MFS_CHECKED         0x0008
#define MFS_HILITE          0x0080
#define MFS_ENABLED         0x0000
#define MFS_UNCHECKED       0x0000
#define MFS_UNHILITE        0x0000
#define MFS_DEFAULT         0x1000
#define MFS_MASK            0x108B

#define MFR_POPUP           0x01
#define MFR_END             0x80

/* old names for menu types & states */
#define MF_SEPARATOR        MFT_SEPARATOR

#define MF_GRAYED           0x0001
#define MF_DISABLED         0x0002

#define MF_CHECKED          MFS_CHECKED
#define MF_ENABLED          MFS_ENABLED
#define MF_UNCHECKED        MFS_UNCHECKED
#define MF_UNHILITE         MFS_UNHILITE

#define MF_STRING           MFT_STRING
#define MF_BITMAP           MFT_BITMAP
#define MF_OWNERDRAW        MFT_OWNERDRAW

#define MF_MENUBARBREAK     MFT_MENUBARBREAK
#define MF_MENUBREAK        MFT_MENUBREAK

#define MF_HILITE           MFS_HILITE

#define MF_DEFAULT          MFS_DEFAULT
#define MF_RIGHTJUSTIFY     MFT_RIGHTJUSTIFY


UINT    WINAPI EnableMenuItem(HMENU, UINT, UINT);
UINT    WINAPI CheckMenuItem(HMENU, UINT, UINT);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, LPCRECT);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON      0x0000

#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON     0x0002
#define TPM_LEFTALIGN       0x0000
#define TPM_CENTERALIGN     0x0004
#define TPM_RIGHTALIGN      0x0008
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

/* WM_H/VSCROLL commands */
#define SB_LINEUP           0
#define SB_LINELEFT         0
#define SB_LINEDOWN         1
#define SB_LINERIGHT        1
#define SB_PAGEUP           2
#define SB_PAGELEFT         2
#define SB_PAGEDOWN         3
#define SB_PAGERIGHT        3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_LEFT             6
#define SB_BOTTOM           7
#define SB_RIGHT            7
#define SB_ENDSCROLL        8

/* Scroll bar selection constants */
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI GetScrollRange(HWND, int, int FAR*, int FAR*);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT             1
#define CF_BITMAP           2
#define CF_METAFILEPICT     3
#define CF_SYLK             4
#define CF_DIF              5
#define CF_TIFF             6
#define CF_OEMTEXT          7
#define CF_DIB              8
#define CF_PALETTE          9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

#endif  /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);

void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(POINT FAR*);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#endif  /* WINVER >= 0x030a */

void    WINAPI ClipCursor(LPCRECT);
#if (WINVER >= 0x030a)
void    WINAPI GetClipCursor(LPRECT);
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW       MAKEINTRESOURCE(32512)
#define IDC_IBEAM       MAKEINTRESOURCE(32513)
#define IDC_WAIT        MAKEINTRESOURCE(32514)
#define IDC_CROSS       MAKEINTRESOURCE(32515)
#define IDC_UPARROW     MAKEINTRESOURCE(32516)
#define IDC_SIZE        MAKEINTRESOURCE(32640)
#define IDC_ICON        MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE    MAKEINTRESOURCE(32642)
#define IDC_SIZENESW    MAKEINTRESOURCE(32643)
#define IDC_SIZEWE      MAKEINTRESOURCE(32644)
#define IDC_SIZENS      MAKEINTRESOURCE(32645)
#define IDC_NO          MAKEINTRESOURCE(32648)


/****** Icon support *********************************************************/


HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);

typedef struct tagNEWHEADER
{
    WORD    Reserved;
    WORD    ResType;        /* RES_ICON or RES_CURSOR */
    WORD    ResCount;
} NEWHEADER, FAR *LPNEWHEADER;

#if (WINVER >= 0x0400)
/* Icon/Cursor header */
typedef struct tagCURSORSHAPE
{
    int     xHotSpot;
    int     yHotSpot;
    int     cx;
    int     cy;
    int     cbWidth;
    BYTE    Planes;
    BYTE    BitsPixel;
} CURSORSHAPE, FAR *LPCURSORSHAPE;
                                  
#endif /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#ifdef RC_INVOKED
#define IDI_APPLICATION     32512
#define IDI_HAND            32513
#define IDI_QUESTION        32514
#define IDI_EXCLAMATION     32515
#define IDI_ASTERISK        32516
#else
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND            MAKEINTRESOURCE(32513)
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK        MAKEINTRESOURCE(32516)
#endif /* RC_INVOKED */

#endif  /* NOICONS */


/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);
void    WINAPI ShowCaret(HWND);
void    WINAPI HideCaret(HWND);
void    WINAPI SetCaretPos(int, int);
void    WINAPI SetCaretBlinkTime(UINT);
void    WINAPI GetCaretPos(LPPOINT);
UINT    WINAPI GetCaretBlinkTime(void);

/****** WM_SYSCOMMAND support ***********************************************/

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE

#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HMENU  hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;

typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;



#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL        0x0000
#define MDITILE_HORIZONTAL      0x0001
#endif  /* WINVER >= 0x030a */

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);

LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, LPMSG);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);
BOOL    WINAPI TileChildWindows(HWND, UINT);
BOOL    WINAPI CascadeChildWindows(HWND, UINT);
#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG (MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA 30

/* Dialog styles */
#define DS_ABSALIGN         0x0001L
#define DS_SYSMODAL         0x0002L
#define DS_LOCALEDIT        0x0020L
#define DS_MODALFRAME       0x0080L
#define DS_NOIDLEMSG        0x0100L

/* Dialog messages */
#define DM_GETDEFID         (WM_USER+0)
#define DM_SETDEFID         (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID         0x534B

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT       0
#define DWL_DLGPROC         4
#define DWL_USER            8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, LPMSG);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR *, BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, LPRECT);
DWORD   WINAPI GetDialogBaseUnits(void);

/* dialog codes */
#define DLGC_WANTARROWS         0x0001
#define DLGC_WANTTAB            0x0002
#define DLGC_WANTALLKEYS        0x0004
#define DLGC_WANTMESSAGE        0x0004
#define DLGC_HASSETSEL          0x0008
#define DLGC_DEFPUSHBUTTON      0x0010
#define DLGC_UNDEFPUSHBUTTON    0x0020
#define DLGC_RADIOBUTTON        0x0040
#define DLGC_WANTCHARS          0x0080
#define DLGC_STATIC             0x0100
#define DLGC_BUTTON             0x2000

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX         0
#define CTLCOLOR_EDIT           1
#define CTLCOLOR_LISTBOX        2
#define CTLCOLOR_BTN            3
#define CTLCOLOR_DLG            4
#define CTLCOLOR_SCROLLBAR      5
#define CTLCOLOR_STATIC         6

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK            1
#define IDCANCEL        2
#define IDABORT         3
#define IDRETRY         4
#define IDIGNORE        5
#define IDYES           6
#define IDNO            7


typedef struct tagNMHDR
{
#ifdef tagWND
    HWND_16 hwndFrom;
#else
    HWND  hwndFrom;
#endif
    WORD  _wDummy1;						
    UINT  idFrom;
    WORD  _wDummy2;
    UINT  code;
    WORD  _wDummy3;
}   NMHDR;
typedef NMHDR FAR * LPNMHDR;

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU            1
#define ODT_LISTBOX         2
#define ODT_COMBOBOX        3
#define ODT_BUTTON          4

/* Owner draw actions */
#define ODA_DRAWENTIRE      0x0001
#define ODA_SELECT          0x0002
#define ODA_FOCUS           0x0004

/* Owner draw state */
#define ODS_SELECTED        0x0001
#define ODS_GRAYED          0x0002
#define ODS_DISABLED        0x0004
#define ODS_CHECKED         0x0008
#define ODS_FOCUS           0x0010

/* LPARAM of WM_DRAWITEM is LPDRAWITEMSTRUCT */
typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

/* LPARAM of WM_MEASUREITEM is LPMEASUREITEMSTRUCT */
typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

/* LPARAM of WM_DELETEITEM is LPDELETEITEMSTRUCT */
typedef struct tagDELETEITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    HWND        hwndItem;
    DWORD       itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

/* LPARAM of WM_COMPAREITEM is LPCOMPAREITEMSTRUCT */
typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL

#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON         (WM_USER+0)
#define STM_GETICON         (WM_USER+1)
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL

#define BS_RIGHTBUTTON      0x00000020L

#define BS_LEFTTEXT         BS_RIGHTBUTTON

#ifndef NOWINMESSAGES
/* Button Control Messages  */
#define BM_GETCHECK         (WM_USER+0)
#define BM_SETCHECK         (WM_USER+1)
#define BM_GETSTATE         (WM_USER+2)
#define BM_SETSTATE         (WM_USER+3)
#define BM_SETSTYLE         (WM_USER+4)
#define BM_CLICK            (WM_USER+5)

/* User Button Notification Codes */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_HILITE           2
#define BN_UNHILITE         3
#define BN_DISABLE          4
#define BN_DBLCLK           5
#define BN_DOUBLECLICKED    BN_DBLCLK
#endif /* NOWINMESSAGES */

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT                 0x0000L
#define ES_CENTER               0x0001L
#define ES_RIGHT                0x0002L
#define ES_MULTILINE            0x0004L
#define ES_UPPERCASE            0x0008L
#define ES_LOWERCASE            0x0010L
#define ES_PASSWORD             0x0020L
#define ES_AUTOVSCROLL          0x0040L
#define ES_AUTOHSCROLL          0x0080L
#define ES_NOHIDESEL            0x0100L
#define ES_OEMCONVERT           0x0400L
#if (WINVER >= 0x030a)
#define ES_READONLY             0x0800L
#define ES_WANTRETURN           0x1000L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL               (WM_USER+0)
#define EM_SETSEL               (WM_USER+1)
#define EM_GETRECT              (WM_USER+2)
#define EM_SETRECT              (WM_USER+3)
#define EM_SETRECTNP            (WM_USER+4)
#define EM_LINESCROLL           (WM_USER+6)
#define EM_SCROLLCARET          (WM_USER+7)
#define EM_GETMODIFY            (WM_USER+8)
#define EM_SETMODIFY            (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX            (WM_USER+11)
#define EM_SETHANDLE            (WM_USER+12)
#define EM_GETHANDLE            (WM_USER+13)
#define EM_LINELENGTH           (WM_USER+17)
#define EM_REPLACESEL           (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE              (WM_USER+20)
#define EM_SETLIMITTEXT         (WM_USER+21)
#define EM_CANUNDO              (WM_USER+22)
#define EM_UNDO                 (WM_USER+23)
#define EM_FMTLINES             (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS          (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)

#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE  (WM_USER+30)
#define EM_SETREADONLY          (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
#define EM_LIMITTEXT            EM_SETLIMITTEXT
#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT                 0
#define WB_RIGHT                1
#define WB_ISDELIMITER          2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS             0x0100
#define EN_KILLFOCUS            0x0200
#define EN_CHANGE               0x0300
#define EN_UPDATE               0x0400
#define EN_ERRSPACE             0x0500
#define EN_MAXTEXT              0x0501
#define EN_HSCROLL              0x0601
#define EN_VSCROLL              0x0602
#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ                0x0000L
#define SBS_VERT                0x0001L
#define SBS_TOPALIGN            0x0002L
#define SBS_LEFTALIGN           0x0002L
#define SBS_BOTTOMALIGN         0x0004L
#define SBS_RIGHTALIGN          0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN 0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX             0x0008L
#define SBS_FLAT                0x0010L

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY              0x0001L
#define LBS_SORT                0x0002L
#define LBS_NOREDRAW            0x0004L
#define LBS_MULTIPLESEL         0x0008L
#define LBS_OWNERDRAWFIXED      0x0010L
#define LBS_OWNERDRAWVARIABLE   0x0020L
#define LBS_HASSTRINGS          0x0040L
#define LBS_USETABSTOPS         0x0080L
#define LBS_NOINTEGRALHEIGHT    0x0100L
#define LBS_MULTICOLUMN         0x0200L
#define LBS_WANTKEYBOARDINPUT   0x0400L
#define LBS_EXTENDEDSEL         0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL     0x1000L
#endif  /* WINVER >= 0x030a */
#define LBS_STANDARD            (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING            (WM_USER+1)
#define LB_INSERTSTRING         (WM_USER+2)
#define LB_DELETESTRING         (WM_USER+3)
#define LB_RESETCONTENT         (WM_USER+5)
#define LB_SETSEL               (WM_USER+6)
#define LB_SETCURSEL            (WM_USER+7)
#define LB_GETSEL               (WM_USER+8)
#define LB_GETCURSEL            (WM_USER+9)
#define LB_GETTEXT              (WM_USER+10)
#define LB_GETTEXTLEN           (WM_USER+11)
#define LB_GETCOUNT             (WM_USER+12)
#define LB_SELECTSTRING         (WM_USER+13)
#define LB_DIR                  (WM_USER+14)
#define LB_GETTOPINDEX          (WM_USER+15)
#define LB_FINDSTRING           (WM_USER+16)
#define LB_GETSELCOUNT          (WM_USER+17)
#define LB_GETSELITEMS          (WM_USER+18)
#define LB_SETTABSTOPS          (WM_USER+19)
#define LB_GETHORIZONTALEXTENT  (WM_USER+20)
#define LB_SETHORIZONTALEXTENT  (WM_USER+21)
#define LB_SETCOLUMNWIDTH       (WM_USER+22)
#define LB_SETTOPINDEX          (WM_USER+24)
#define LB_GETITEMRECT          (WM_USER+25)
#define LB_GETITEMDATA          (WM_USER+26)
#define LB_SETITEMDATA          (WM_USER+27)
#define LB_SELITEMRANGE         (WM_USER+28)
#define LB_SETANCHORINDEX       (WM_USER+29)
#define LB_GETANCHORINDEX       (WM_USER+30)
#define LB_SETCARETINDEX        (WM_USER+31)
#define LB_GETCARETINDEX        (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT        (WM_USER+33)
#define LB_GETITEMHEIGHT        (WM_USER+34)
#define LB_FINDSTRINGEXACT      (WM_USER+35)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE            (-2)
#define LBN_SELCHANGE           1
#define LBN_DBLCLK              2
#define LBN_SELCANCEL           3
#define LBN_SETFOCUS            4
#define LBN_KILLFOCUS           5

/* Listbox message return values */
#define LB_OKAY                 0
#define LB_ERR                  (-1)
#define LB_ERRSPACE             (-2)

#define LB_CTLCODE              0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */

/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE           0x0000
#define DDL_READONLY            0x0001
#define DDL_HIDDEN              0x0002
#define DDL_SYSTEM              0x0004
#define DDL_DIRECTORY           0x0010
#define DDL_ARCHIVE             0x0020

#define DDL_POSTMSGS            0x2000
#define DDL_DRIVES              0x4000
#define DDL_EXCLUSIVE           0x8000

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE              0x0001L
#define CBS_DROPDOWN            0x0002L
#define CBS_DROPDOWNLIST        0x0003L
#define CBS_OWNERDRAWFIXED      0x0010L
#define CBS_OWNERDRAWVARIABLE   0x0020L
#define CBS_AUTOHSCROLL         0x0040L
#define CBS_OEMCONVERT          0x0080L
#define CBS_SORT                0x0100L
#define CBS_HASSTRINGS          0x0200L
#define CBS_NOINTEGRALHEIGHT    0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL     0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL           (WM_USER+0)
#define CB_LIMITTEXT            (WM_USER+1)
#define CB_SETEDITSEL           (WM_USER+2)
#define CB_ADDSTRING            (WM_USER+3)
#define CB_DELETESTRING         (WM_USER+4)
#define CB_DIR                  (WM_USER+5)
#define CB_GETCOUNT             (WM_USER+6)
#define CB_GETCURSEL            (WM_USER+7)
#define CB_GETLBTEXT            (WM_USER+8)
#define CB_GETLBTEXTLEN         (WM_USER+9)
#define CB_INSERTSTRING         (WM_USER+10)
#define CB_RESETCONTENT         (WM_USER+11)
#define CB_FINDSTRING           (WM_USER+12)
#define CB_SELECTSTRING         (WM_USER+13)
#define CB_SETCURSEL            (WM_USER+14)
#define CB_SHOWDROPDOWN         (WM_USER+15)
#define CB_GETITEMDATA          (WM_USER+16)
#define CB_SETITEMDATA          (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT        (WM_USER+19)
#define CB_GETITEMHEIGHT        (WM_USER+20)
#define CB_SETEXTENDEDUI        (WM_USER+21)
#define CB_GETEXTENDEDUI        (WM_USER+22)
#define CB_GETDROPPEDSTATE      (WM_USER+23)
#define CB_FINDSTRINGEXACT      (WM_USER+24)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE            (-1)
#define CBN_SELCHANGE           1
#define CBN_DBLCLK              2
#define CBN_SETFOCUS            3
#define CBN_KILLFOCUS           4
#define CBN_EDITCHANGE          5
#define CBN_EDITUPDATE          6
#define CBN_DROPDOWN            7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP             8
#define CBN_SELENDOK            9
#define CBN_SELENDCANCEL        10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY                 0
#define CB_ERR                  (-1)
#define CB_ERRSPACE             (-2)

#endif /* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */

/* Standard hook code */
#define HC_ACTION               0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN            (-3)
#define HC_LPLPFNNEXT           (-2)
#define HC_LPFNNEXT             (-1)

#endif /* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT              5

#define HCBT_MOVESIZE        0
#define HCBT_MINMAX          1
#define HCBT_QS              2
#define HCBT_CREATEWND       3
#define HCBT_DESTROYWND      4
#define HCBT_ACTIVATE        5
#define HCBT_CLICKSKIPPED    6
#define HCBT_KEYSKIPPED      7
#define HCBT_SYSCOMMAND      8
#define HCBT_SETFOCUS        9
#define HCBT_SETWINDOWTEXT  10

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    LPCREATESTRUCT lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif /* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE         8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3
#if (WINVER >= 0x0400)
#define HSHELL_WINDOWACTIVATED     4
#define HSHELL_GETMINRECT          5
#define HSHELL_REDRAW              6
#define HSHELL_TASKMAN             7
#define HSHELL_LANGUAGE            8 
#endif  /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREMOVE         3
#define HC_NOREM            HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif /* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG        9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE     hModuleHook;
    LPARAM      reserved;
    LPARAM      lParam;
    WPARAM      wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT        0x0001
#define HELP_QUIT           0x0002
#define HELP_INDEX          0x0003
#define HELP_CONTENTS       0x0003
#define HELP_HELPONHELP     0x0004
#define HELP_SETINDEX       0x0005
#define HELP_SETCONTENTS    0x0005
#define HELP_CONTEXTPOPUP   0x0008
#define HELP_FORCEFILE      0x0009
#define HELP_KEY            0x0101
#define HELP_COMMAND        0x0102
#define HELP_PARTIALKEY     0x0105
#define HELP_MULTIKEY       0x0201
#define HELP_SETWINPOS      0x0203

#if (WINVER >= 0x0400)

#define HELP_CONTEXTMENU    0x000a
#define HELP_FINDER         0x000b
#define HELP_WM_HELP        0x000c

#define HELP_TCARD          0x8000
#define HELP_TCARD_DATA     0x0010
#define HELP_TCARD_NEXT     0x0011
#define HELP_TCARD_OTHER_CALLER 0x0011

#endif  /* WINVER >= 0x0400 */

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */


/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK               0x0000
#define MB_OKCANCEL         0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL      0x0003
#define MB_YESNO            0x0004
#define MB_RETRYCANCEL      0x0005
#define MB_TYPEMASK         0x000F

#define MB_ICONHAND         0x0010
#define MB_ICONQUESTION     0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040
#define MB_ICONMASK         0x00F0

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1       0x0000
#define MB_DEFBUTTON2       0x0100
#define MB_DEFBUTTON3       0x0200
#if (WINVER >= 0x0400)
#define MB_DEFBUTTON4       0x0300
#endif
#define MB_DEFMASK          0x0F00

#define MB_APPLMODAL        0x0000
#define MB_SYSTEMMODAL      0x1000
#define MB_TASKMODAL        0x2000
#define MB_NOFOCUS          0x8000
#endif  /* NOMB */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
LPINT   WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512     0
#define S_PERIOD1024    1
#define S_PERIOD2048    2
#define S_PERIODVOICE   3
#define S_WHITE512      4
#define S_WHITE1024     5
#define S_WHITE2048     6
#define S_WHITEVOICE    7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY    0
#define S_THRESHOLD     1
#define S_ALLTHRESHOLD  2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL        0
#define S_LEGATO        1
#define S_STACCATO      2

/* Error return values */
#define S_SERDVNA       (-1)
#define S_SEROFM        (-2)
#define S_SERMACT       (-3)
#define S_SERQFUL       (-4)
#define S_SERBDNT       (-5)
#define S_SERDLN        (-6)
#define S_SERDCC        (-7)
#define S_SERDTP        (-8)
#define S_SERDVL        (-9)
#define S_SERDMD        (-10)
#define S_SERDSH        (-11)
#define S_SERDPT        (-12)
#define S_SERDFQ        (-13)
#define S_SERDDR        (-14)
#define S_SERDSR        (-15)
#define S_SERDST        (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY        0
#define ODDPARITY       1
#define EVENPARITY      2
#define MARKPARITY      3
#define SPACEPARITY     4

#define ONESTOPBIT      0
#define ONE5STOPBITS    1
#define TWOSTOPBITS     2

#define IGNORE          0
#define INFINITE        0xFFFF

/* Error Flags */
#define CE_RXOVER       0x0001
#define CE_OVERRUN      0x0002
#define CE_RXPARITY     0x0004
#define CE_FRAME        0x0008
#define CE_BREAK        0x0010
#define CE_CTSTO        0x0020
#define CE_DSRTO        0x0040
#define CE_RLSDTO       0x0080
#define CE_TXFULL       0x0100
#define CE_PTO          0x0200
#define CE_IOE          0x0400
#define CE_DNS          0x0800
#define CE_OOP          0x1000
#define CE_MODE         0x8000

#define IE_BADID        (-1)
#define IE_OPEN         (-2)
#define IE_NOPEN        (-3)
#define IE_MEMORY       (-4)
#define IE_DEFAULT      (-5)
#define IE_HARDWARE     (-10)
#define IE_BYTESIZE     (-11)
#define IE_BAUDRATE     (-12)

/* Events */
#define EV_RXCHAR       0x0001
#define EV_RXFLAG       0x0002
#define EV_TXEMPTY      0x0004
#define EV_CTS          0x0008
#define EV_DSR          0x0010
#define EV_RLSD         0x0020
#define EV_BREAK        0x0040
#define EV_ERR          0x0080
#define EV_RING         0x0100
#define EV_PERR         0x0200
#define EV_CTSS         0x0400
#define EV_DSRS         0x0800
#define EV_RLSDS        0x1000
#define EV_RingTe       0x2000
#define EV_RINGTE       EV_RingTe

/* Escape Functions */
#define SETXOFF         1
#define SETXON          2
#define SETRTS          3
#define CLRRTS          4
#define SETDTR          5
#define CLRDTR          6
#define RESETDEV        7

#define LPTx            0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT       8
#define GETMAXCOM       9
#define GETBASEIRQ      10

/* Comm Baud Rate indices */
#define CBR_110         0xFF10
#define CBR_300         0xFF11
#define CBR_600         0xFF12
#define CBR_1200        0xFF13
#define CBR_2400        0xFF14
#define CBR_4800        0xFF15
#define CBR_9600        0xFF16
#define CBR_14400       0xFF17
#define CBR_19200       0xFF18
#define CBR_38400       0xFF1B
#define CBR_56000       0xFF1F
#define CBR_128000      0xFF23
#define CBR_256000      0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE      0x0001
#define CN_TRANSMIT     0x0002
#define CN_EVENT        0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD            0x0001
#define DRV_ENABLE          0x0002
#define DRV_OPEN            0x0003
#define DRV_CLOSE           0x0004
#define DRV_DISABLE         0x0005
#define DRV_FREE            0x0006
#define DRV_CONFIGURE       0x0007
#define DRV_QUERYCONFIGURE  0x0008
#define DRV_INSTALL         0x0009
#define DRV_REMOVE          0x000A
#define DRV_EXITSESSION     0x000B
#define DRV_EXITAPPLICATION 0x000C
#define DRV_POWER           0x000F
#define DRV_NOTIFYMSG	      0x0010
/*#define DRV_QUERYENDSESSION 0x0010      */
/*#define DRV_EXITSESSIONCANCELLED 0x0011 */

#define DRV_RESERVED        0x0800
#define DRV_USER            0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL       0x0000
#define DRVCNF_OK           0x0001
#define DRVCNF_RESTART      0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT    0x0001
#define DRVEA_ABNORMALEXIT  0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY   0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE             0x00000002

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */

/****** Installable Message Thunk support ***********************************/

#if (WINVER > 0x030a)
#ifndef NOIMT

/* wReason codes */
#define IMT_REASON_ASYNC    0x00001
#define IMT_REASON_LS       0x00002
#define IMT_REASON_AFTER    0x00004

typedef struct tagIMTMSG
{
    HWND    hwnd;
    UINT    message;
    DWORD   wParam;
    LPARAM  lParam;
} IMTMSG, FAR* LPIMTMSG;

typedef struct tagIMTBUFFER
{
    DWORD   dwT1;
    DWORD   dwT2;
} IMTBUFFER, FAR* LPIMTBUFFER;

typedef BOOL (CALLBACK *IMTDISP)(WORD wReason, LPDWORD lpRetVal,
                                 LPIMTMSG lpMsg, LPIMTBUFFER lpBuffer);
BOOL WINAPI InstallIMT(LPSTR lpszClassName, IMTDISP pfnDispatcher,
                       WORD msgLo, WORD msgHi);
BOOL WINAPI UnInstallIMT(LPSTR lpszClassName, IMTDISP pfnDispatcher,
                         WORD msgLo, WORD msgHi);

#endif  /* !NOIMT */
#endif  /* WINVER > 0x030a */

#endif  /* NOUSER */

DWORD WINAPI RegisterServiceProcess(DWORD dwProcessId, DWORD dwServiceType);
#define RSP_UNREGISTER_SERVICE	0x00000000
#define RSP_SIMPLE_SERVICE	0x00000001

VOID WINAPI RegisterNetworkCapabilities(DWORD dwBitsToSet, DWORD dwValues);
#define RNC_NETWORKS  		0x00000001





#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif /* __cplusplus */

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\winnetwk.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/* WINNETWK.H -- Definitions for multi-network provider router DLL.
 *
 * History:
 *  08/31/93    lens    Added definitions
 *
 */

#ifndef _WINNETWK_
#include "..\inc\winnetwk.h"
#endif /* _WINNETWK_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\winmem32.h ===
/*
 * Function protypes and general defines for WINMEM32 DLL
 *	Version 1.00
 *
 * NOTE that WINDOWS.H must be included before this file.
 *
 */

/*
 *
 * The functions
 *
 */
WORD	FAR PASCAL GetWinMem32Version(void);
WORD	FAR PASCAL Global32Alloc(DWORD, LPWORD, DWORD, WORD);
WORD	FAR PASCAL Global32Realloc(WORD, DWORD, WORD);
WORD	FAR PASCAL Global32Free(WORD, WORD);
WORD	FAR PASCAL Global16PointerAlloc(WORD, DWORD, LPDWORD, DWORD, WORD);
WORD	FAR PASCAL Global16PointerFree(WORD, DWORD, WORD);
WORD	FAR PASCAL Global32CodeAlias(WORD, LPWORD, WORD);
WORD	FAR PASCAL Global32CodeAliasFree(WORD, WORD, WORD);

/*
 *
 * Error Codes
 *
 */
#define WM32_Invalid_Func	0001
#define WM32_Invalid_Flags	0002
#define WM32_Invalid_Arg	0003
#define WM32_Insufficient_Sels	0004
#define WM32_Insufficient_Mem	0005
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\winexp.h ===
/*****************************************************************************\
*                                                                             *
* winexp.h								      *
*                                                                             *
* Copyright (c) 1993-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/
#ifndef NOATOM
/* atom manager internals */
#define ATOMSTRUC struct atomstruct
typedef ATOMSTRUC NEAR *PATOM;
typedef ATOMSTRUC {
    PATOM chain;
    WORD  usage;             /* Atoms are usage counted. */
    BYTE  len;               /* length of ASCIZ name string */
    BYTE  name;              /* beginning of ASCIZ name string */
} ATOMENTRY;

typedef struct {
    int     numEntries;
    PATOM   pAtom[ 1 ];
} ATOMTABLE;
ATOMTABLE * PASCAL pAtomTable;
#endif

LPSTR	WINAPI lstrbscan(LPSTR, LPSTR);
LPSTR	WINAPI lstrbskip(LPSTR, LPSTR);

int	WINAPI OpenPathName(LPSTR, int);
int	WINAPI DeletePathName(LPSTR);
WORD	WINAPI _ldup(int);


/* scheduler things that the world knows not */
BOOL	WINAPI WaitEvent( HANDLE );
BOOL	WINAPI PostEvent( HANDLE );
BOOL	WINAPI KillTask( HANDLE );

/* print screen hooks */
BOOL	WINAPI SetPrtScHook(FARPROC);
FARPROC WINAPI GetPrtScHook(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\winnet.h ===
/*
 *  Windows/Network Interface
 *  Copyright (C) Microsoft 1989-1994
 *
 *  Standard WINNET Driver Header File, spec version 3.10
 */


typedef WORD far * LPWORD;


/*
 *  SPOOLING - CONTROLLING JOBS
 */

#define WNJ_NULL_JOBID  0


WORD WINAPI WNetOpenJob(LPSTR,LPSTR,WORD,LPINT);
WORD WINAPI WNetCloseJob(WORD,LPINT,LPSTR);
WORD WINAPI WNetWriteJob(HANDLE,LPSTR,LPINT);
WORD WINAPI WNetAbortJob(WORD,LPSTR);
WORD WINAPI WNetHoldJob(LPSTR,WORD);
WORD WINAPI WNetReleaseJob(LPSTR,WORD);
WORD WINAPI WNetCancelJob(LPSTR,WORD);
WORD WINAPI WNetSetJobCopies(LPSTR,WORD,WORD);

/*
 *  SPOOLING - QUEUE AND JOB INFO
 */

typedef struct _queuestruct {
    WORD    pqName;
    WORD    pqComment;
    WORD    pqStatus;
    WORD    pqJobcount;
    WORD    pqPrinters;
} QUEUESTRUCT;

typedef QUEUESTRUCT far * LPQUEUESTRUCT;

#define WNPRQ_ACTIVE    0x0
#define WNPRQ_PAUSE 0x1
#define WNPRQ_ERROR 0x2
#define WNPRQ_PENDING   0x3
#define WNPRQ_PROBLEM   0x4


typedef struct _jobstruct   {
    WORD    pjId;
    WORD    pjUsername;
    WORD    pjParms;
    WORD    pjPosition;
    WORD    pjStatus;
    DWORD   pjSubmitted;
    DWORD   pjSize;
    WORD    pjCopies;
    WORD    pjComment;
} JOBSTRUCT;

typedef JOBSTRUCT far * LPJOBSTRUCT;

#define WNPRJ_QSTATUS       0x0007
#define WNPRJ_QS_QUEUED            0x0000
#define WNPRJ_QS_PAUSED            0x0001
#define WNPRJ_QS_SPOOLING          0x0002
#define WNPRJ_QS_PRINTING          0x0003
#define WNPRJ_DEVSTATUS     0x0FF8
#define WNPRJ_DS_COMPLETE          0x0008
#define WNPRJ_DS_INTERV            0x0010
#define WNPRJ_DS_ERROR             0x0020
#define WNPRJ_DS_DESTOFFLINE           0x0040
#define WNPRJ_DS_DESTPAUSED        0x0080
#define WNPRJ_DS_NOTIFY            0x0100
#define WNPRJ_DS_DESTNOPAPER           0x0200
#define WNPRJ_DS_DESTFORMCHG           0x0400
#define WNPRJ_DS_DESTCRTCHG        0x0800
#define WNPRJ_DS_DESTPENCHG        0x1000

#define SP_QUEUECHANGED     0x0500


WORD WINAPI WNetWatchQueue(HWND,LPSTR,LPSTR,WORD);
WORD WINAPI WNetUnwatchQueue(LPSTR);
WORD WINAPI WNetLockQueueData(LPSTR,LPSTR,LPQUEUESTRUCT FAR *);
WORD WINAPI WNetUnlockQueueData(LPSTR);


/*
 *  CONNECTIONS
 *
 * these are defined in windows.h now
 *
 * WORD WINAPI WNetAddConnection(LPSTR,LPSTR,LPSTR);
 * WORD WINAPI WNetCancelConnection(LPSTR,BOOL);
 * WORD WINAPI WNetGetConnection(LPSTR,LPSTR,LPWORD);
 */

WORD WINAPI WNetRestoreConnection(HWND,LPSTR);

/*
 *  CAPABILITIES
 */

#define WNNC_SPEC_VERSION       0x0001

#define WNNC_NET_TYPE           0x0002
#define  WNNC_NET_NONE              0x0000
#define  WNNC_NET_MSNet             0x0100
#define  WNNC_NET_LanMan            0x0200
#define  WNNC_NET_NetWare           0x0300
#define  WNNC_NET_Vines             0x0400
#define  WNNC_NET_10NET             0x0500
#define  WNNC_NET_Locus             0x0600
#define  WNNC_NET_Sun_PC_NFS            0x0700
#define  WNNC_NET_LANstep           0x0800
#define  WNNC_NET_9TILES            0x0900
#define  WNNC_NET_LANtastic             0x0A00
#define  WNNC_NET_AS400                         0x0B00
#define  WNNC_NET_FTP_NFS                       0x0C00
#define  WNNC_NET_PATHWORKS                     0x0D00
#define  WNNC_NET_LifeNet			0x0E00
#define  WNNC_NET_POWERLan			0x0F00
#define  WNNC_NET_BWNFS				0x1000
#define  WNNC_NET_Cogent			0x1100
#define  WNNC_NET_Farallon			0x1200
#define  WNNC_NET_MultiNet			0x8000
#define   WNNC_SUBNET_NONE				0x0000
#define   WNNC_SUBNET_MSNet				0x0001
#define   WNNC_SUBNET_LanMan				0x0002
#define   WNNC_SUBNET_WinWorkgroups			0x0004
#define   WNNC_SUBNET_NetWare				0x0008
#define   WNNC_SUBNET_Vines				0x0010
#define   WNNC_SUBNET_10NET				0x0020
#define   WNNC_SUBNET_Locus				0x0040
#define   WNNC_SUBNET_Sun_PC_NFS			0x0080
#define   WNNC_SUBNET_LANstep				0x0100
#define   WNNC_SUBNET_9TILES				0x0200
#define   WNNC_SUBNET_LANtastic				0x0400
#define   WNNC_SUBNET_AS400				0x0800
#define   WNNC_SUBNET_FTP_NFS				0x1000
#define   WNNC_SUBNET_PATHWORKS				0x2000
#define   WNNC_SUBNET_Extension				0x4000
#define   WNNC_SUBNET_Other				0x8000

#define WNNC_DRIVER_VERSION     0x0003

#define WNNC_USER           0x0004
#define  WNNC_USR_GetUser           0x0001

#define WNNC_CONNECTION         0x0006
#define  WNNC_CON_AddConnection         0x0001
#define  WNNC_CON_CancelConnection      0x0002
#define  WNNC_CON_GetConnections        0x0004
#define  WNNC_CON_AutoConnect           0x0008
#define  WNNC_CON_BrowseDialog          0x0010
#define  WNNC_CON_RestoreConnection     0x0020

#define WNNC_PRINTING           0x0007
#define  WNNC_PRT_OpenJob           0x0002
#define  WNNC_PRT_CloseJob          0x0004
#define  WNNC_PRT_HoldJob           0x0010
#define  WNNC_PRT_ReleaseJob            0x0020
#define  WNNC_PRT_CancelJob         0x0040
#define  WNNC_PRT_SetJobCopies          0x0080
#define  WNNC_PRT_WatchQueue            0x0100
#define  WNNC_PRT_UnwatchQueue          0x0200
#define  WNNC_PRT_LockQueueData         0x0400
#define  WNNC_PRT_UnlockQueueData       0x0800
#define  WNNC_PRT_ChangeMsg         0x1000
#define  WNNC_PRT_AbortJob          0x2000
#define  WNNC_PRT_NoArbitraryLock       0x4000
#define  WNNC_PRT_WriteJob          0x8000

#define WNNC_DIALOG         0x0008
#define  WNNC_DLG_DeviceMode            0x0001
#define  WNNC_DLG_BrowseDialog          0x0002
#define  WNNC_DLG_ConnectDialog         0x0004
#define  WNNC_DLG_DisconnectDialog      0x0008
#define  WNNC_DLG_ViewQueueDialog       0x0010
#define  WNNC_DLG_PropertyDialog        0x0020
#define  WNNC_DLG_ConnectionDialog      0x0040
#define  WNNC_DLG_SharesDialog          0x0100
#define  WNNC_DLG_ShareAsDialog         0x0200

#define WNNC_ADMIN          0x0009
#define  WNNC_ADM_GetDirectoryType      0x0001
#define  WNNC_ADM_DirectoryNotify       0x0002
#define  WNNC_ADM_LongNames         0x0004
#define  WNNC_ADM_SetDefaultDrive       0x0008


#define WNNC_ERROR          0x000A
#define  WNNC_ERR_GetError          0x0001
#define  WNNC_ERR_GetErrorText          0x0002


WORD WINAPI WNetGetCaps(WORD);

/*
 *  OTHER
 */

WORD WINAPI WNetGetUser(LPSTR,LPINT);

/*
 *  BROWSE DIALOG
 */

#define WNBD_CONN_UNKNOWN   0x0
#define WNBD_CONN_DISKTREE  0x1
#define WNBD_CONN_PRINTQ    0x3
#define WNBD_MAX_LENGTH     0x80    // path length, includes the NULL

#define WNTYPE_DRIVE        1
#define WNTYPE_FILE     2
#define WNTYPE_PRINTER      3
#define WNTYPE_COMM     4

#define WNPS_FILE       0
#define WNPS_DIR        1
#define WNPS_MULT       2

WORD WINAPI WNetDeviceMode(HWND);
WORD WINAPI WNetBrowseDialog(HWND,WORD,LPSTR);
WORD WINAPI WNetConnectDialog(HWND,WORD);
WORD WINAPI WNetDisconnectDialog(HWND,WORD);
WORD WINAPI WNetConnectionDialog(HWND,WORD);
WORD WINAPI WNetViewQueueDialog(HWND,LPSTR);
WORD WINAPI WNetPropertyDialog(HWND hwndParent, WORD iButton, WORD nPropSel, LPSTR lpszName, WORD nType);
WORD WINAPI WNetGetPropertyText(WORD iButton, WORD nPropSel, LPSTR lpszName, LPSTR lpszButtonName, WORD cbButtonName, WORD nType);

/*
 *  ADMIN
 */

#define WNDT_NORMAL   0
#define WNDT_NETWORK  2

#define WNDN_MKDIR  1
#define WNDN_RMDIR  2
#define WNDN_MVDIR  3

WORD WINAPI WNetGetDirectoryType(LPSTR,LPINT);
WORD WINAPI WNetDirectoryNotify(HWND,LPSTR,WORD);

/*
 *  ERRORS
 */

WORD WINAPI WNetGetError(LPINT);
WORD WINAPI WNetGetErrorText(WORD,LPSTR,LPINT);


/*
 *  STATUS CODES
 */

/* General */
#define WN_SUCCESS          0x0000
#define WN_NOT_SUPPORTED        0x0001
#define WN_NET_ERROR            0x0002
#define WN_MORE_DATA            0x0003
#define WN_BAD_POINTER          0x0004
#define WN_BAD_VALUE            0x0005
#define WN_BAD_PASSWORD         0x0006
#define WN_ACCESS_DENIED        0x0007
#define WN_FUNCTION_BUSY        0x0008
#define WN_WINDOWS_ERROR        0x0009
#define WN_BAD_USER         0x000A
#define WN_OUT_OF_MEMORY        0x000B
#define WN_CANCEL           0x000C
#define WN_CONTINUE         0x000D

/* Connection */
#define WN_NOT_CONNECTED        0x0030
#define WN_OPEN_FILES           0x0031
#define WN_BAD_NETNAME          0x0032
#define WN_BAD_LOCALNAME        0x0033
#define WN_ALREADY_CONNECTED        0x0034
#define WN_DEVICE_ERROR         0x0035
#define WN_CONNECTION_CLOSED        0x0036
/* Printing */

#define WN_BAD_JOBID            0x0040
#define WN_JOB_NOT_FOUND        0x0041
#define WN_JOB_NOT_HELD         0x0042
#define WN_BAD_QUEUE            0x0043
#define WN_BAD_FILE_HANDLE      0x0044
#define WN_CANT_SET_COPIES      0x0045
#define WN_ALREADY_LOCKED       0x0046

/* BUGBUG, review these: new errors for chicago winnet calls */
#define     WN_NO_MORE_ENTRIES      0x0047
#define     WN_NO_NETWORK           0x0048
#define     WN_BAD_HANDLE           0x0049
#define     WN_NO_ERROR             0x0050
#define     WN_NO_NET_OR_BAD_PATH   0x0051
#define     WN_NOT_AUTHENTICATED    0x0052
#define     WN_NOT_CONTAINER        0x0053
#define     WN_NOT_LOGGED_ON        0x0054
#define     WN_RETRY                0x0055
#define     WN_BAD_PROVIDER         0x0056


#ifdef LFN

/* this is the data structure returned from LFNFindFirst and
 * LFNFindNext.  The last field, achName, is variable length.  The size
 * of the name in that field is given by cchName, plus 1 for the zero
 * terminator.
 */
typedef struct _filefindbuf2
  {
    WORD fdateCreation;
    WORD ftimeCreation;
    WORD fdateLastAccess;
    WORD ftimeLastAccess;
    WORD fdateLastWrite;
    WORD ftimeLastWrite;
    DWORD cbFile;
    DWORD cbFileAlloc;
    WORD attr;
    DWORD cbList;
    BYTE cchName;
    BYTE achName[1];
  } FILEFINDBUF2, FAR * PFILEFINDBUF2;

typedef BOOL (WINAPI *PQUERYPROC)( void );

WORD WINAPI LFNFindFirst(LPSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
WORD WINAPI LFNFindNext(HANDLE,LPINT,WORD,PFILEFINDBUF2);
WORD WINAPI LFNFindClose(HANDLE);
WORD WINAPI LFNGetAttribute(LPSTR,LPINT);
WORD WINAPI LFNSetAttribute(LPSTR,WORD);
WORD WINAPI LFNCopy(LPSTR,LPSTR,PQUERYPROC);
WORD WINAPI LFNMove(LPSTR,LPSTR);
WORD WINAPI LFNDelete(LPSTR);
WORD WINAPI LFNMKDir(LPSTR);
WORD WINAPI LFNRMDir(LPSTR);
WORD WINAPI LFNGetVolumeLabel(WORD,LPSTR);
WORD WINAPI LFNSetVolumeLabel(WORD,LPSTR);
WORD WINAPI LFNParse(LPSTR,LPSTR,LPSTR);
WORD WINAPI LFNVolumeType(WORD,LPINT);

/* return values from LFNParse
 */
#define FILE_83_CI      0
#define FILE_83_CS      1
#define FILE_LONG       2

/* volumes types from LFNVolumeType
 */
#define VOLUME_STANDARD     0
#define VOLUME_LONGNAMES    1

// will add others later, == DOS int 21h error codes.

// this error code causes a call to WNetGetError, WNetGetErrorText
// to get the error text.
#define ERROR_NETWORKSPECIFIC   0xFFFF

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\winsock.h ===
/* WINSOCK.H--definitions to be used with the WINSOCK.DLL
 *
 * This header file corresponds to version 1.1 of the Windows Sockets specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 *
 * Change log:
 *
 * Fri Apr 23 16:31:01 1993  Mark Towfiq  (towfiq@Microdyne.COM)
 *	New version from David Treadwell which adds extern "C" around
 *	__WSAFDIsSet() and removes "const" from buf param of
 *	WSAAsyncGetHostByAddr().  Added change log.
 *
 * Sat May 15 10:55:00 1993 David Treadwell (davidtr@microsoft.com)
 *  Fix the IN_CLASSC macro to account for class-D multicasts.
 *  Add AF_IPX == AF_NS.
 *
 */

#ifndef _WINSOCKAPI_
#define _WINSOCKAPI_

/*
 * Pull in WINDOWS.H if necessary
 */
#ifndef _INC_WINDOWS
#include <windows.h>
#endif /* _INC_WINDOWS */

/*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 */
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;

/*
 * The new type to be used in all
 * instances which refer to sockets.
 */
typedef u_int           SOCKET;

/*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK.H EXACTLY AS SHOWN HERE.
 */
#ifndef FD_SETSIZE
#define FD_SETSIZE      64
#endif /* FD_SETSIZE */

typedef struct fd_set {
        u_int   fd_count;               /* how many are SET? */
        SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */
} fd_set;

#ifdef __cplusplus
extern "C" {
#endif

extern int PASCAL FAR __WSAFDIsSet(SOCKET, fd_set FAR *);

#ifdef __cplusplus
}
#endif


#define FD_CLR(fd, set) do { \
    u_int __i; \
    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) { \
        if (((fd_set FAR *)(set))->fd_array[__i] == fd) { \
            while (__i < ((fd_set FAR *)(set))->fd_count-1) { \
                ((fd_set FAR *)(set))->fd_array[__i] = \
                    ((fd_set FAR *)(set))->fd_array[__i+1]; \
                __i++; \
            } \
            ((fd_set FAR *)(set))->fd_count--; \
            break; \
        } \
    } \
} while(0)

#define FD_SET(fd, set) do { \
    if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) \
        ((fd_set FAR *)(set))->fd_array[((fd_set FAR *)(set))->fd_count++]=fd;\
} while(0)

#define FD_ZERO(set) (((fd_set FAR *)(set))->fd_count=0)

#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)fd, (fd_set FAR *)set)

/*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 */
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */
#define timerisset(tvp)         ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp, uvp, cmp) \
        ((tvp)->tv_sec cmp (uvp)->tv_sec || \
         (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
#define timerclear(tvp)         (tvp)->tv_sec = (tvp)->tv_usec = 0

/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|(x<<8)|y)

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|(x<<8)|y)

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|(x<<8)|y)

#define FIONREAD    _IOR('f', 127, u_long) /* get # bytes to read */
#define FIONBIO     _IOW('f', 126, u_long) /* set/clear non-blocking i/o */
#define FIOASYNC    _IOW('f', 125, u_long) /* set/clear async i/o */

/* Socket I/O Controls */
#define SIOCSHIWAT  _IOW('s',  0, u_long)  /* set high watermark */
#define SIOCGHIWAT  _IOR('s',  1, u_long)  /* get high watermark */
#define SIOCSLOWAT  _IOW('s',  2, u_long)  /* set low watermark */
#define SIOCGLOWAT  _IOR('s',  3, u_long)  /* get low watermark */
#define SIOCATMARK  _IOR('s',  7, u_long)  /* at oob mark? */

/*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 */

struct  hostent {
        char    FAR * h_name;           /* official name of host */
        char    FAR * FAR * h_aliases;  /* alias list */
        short   h_addrtype;             /* host address type */
        short   h_length;               /* length of address */
        char    FAR * FAR * h_addr_list; /* list of addresses */
#define h_addr  h_addr_list[0]          /* address, for backward compat */
};

/*
 * It is assumed here that a network number
 * fits in 32 bits.
 */
struct  netent {
        char    FAR * n_name;           /* official name of net */
        char    FAR * FAR * n_aliases;  /* alias list */
        short   n_addrtype;             /* net address type */
        u_long  n_net;                  /* network # */
};

struct  servent {
        char    FAR * s_name;           /* official service name */
        char    FAR * FAR * s_aliases;  /* alias list */
        short   s_port;                 /* port # */
        char    FAR * s_proto;          /* protocol to use */
};

struct  protoent {
        char    FAR * p_name;           /* official protocol name */
        char    FAR * FAR * p_aliases;  /* alias list */
        short   p_proto;                /* protocol # */
};

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 */

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_GGP             2               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

/*
 * Port/socket numbers: network standard functions
 */
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

/*
 * UNIX TCP sockets
 */
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_CMDSERVER        514
#define IPPORT_EFSSERVER        520

/*
 * UNIX UDP sockets
 */
#define IPPORT_BIFFUDP          512
#define IPPORT_WHOSERVER        513
#define IPPORT_ROUTESERVER      520
                                        /* 520+1 also used */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024

/*
 * Link numbers
 */
#define IMPLINK_IP              155
#define IMPLINK_LOWEXPER        156
#define IMPLINK_HIGHEXPER       158

/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { u_short s_w1,s_w2; } S_un_w;
                u_long S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
#define IN_CLASSA(i)            (((long)(i) & 0x80000000) == 0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            (((long)(i) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            (((long)(i) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define INADDR_ANY              (u_long)0x00000000
#define INADDR_LOOPBACK         0x7f000001
#define INADDR_BROADCAST        (u_long)0xffffffff
#define INADDR_NONE             0xffffffff

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

#define WSADESCRIPTION_LEN      256
#define WSASYS_STATUS_LEN       128

typedef struct WSAData {
        WORD                    wVersion;
        WORD                    wHighVersion;
        char                    szDescription[WSADESCRIPTION_LEN+1];
        char                    szSystemStatus[WSASYS_STATUS_LEN+1];
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char FAR *              lpVendorInfo;
} WSADATA;

typedef WSADATA FAR *LPWSADATA;

/*
 * Options for use with [gs]etsockopt at the IP level.
 */
#define IP_OPTIONS      1               /* set/get IP per-packet options */

/*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 */

/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */
#define INVALID_SOCKET  (SOCKET)(~0)
#define SOCKET_ERROR            (-1)

/*
 * Types
 */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */
#define SOCK_RAW        3               /* raw-protocol interface */
#define SOCK_RDM        4               /* reliably-delivered message */
#define SOCK_SEQPACKET  5               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
#define SO_DEBUG        0x0001          /* turn on debugging info recording */
#define SO_ACCEPTCONN   0x0002          /* socket has had listen() */
#define SO_REUSEADDR    0x0004          /* allow local address reuse */
#define SO_KEEPALIVE    0x0008          /* keep connections alive */
#define SO_DONTROUTE    0x0010          /* just use interface addresses */
#define SO_BROADCAST    0x0020          /* permit sending of broadcast msgs */
#define SO_USELOOPBACK  0x0040          /* bypass hardware when possible */
#define SO_LINGER       0x0080          /* linger on close if data present */
#define SO_OOBINLINE    0x0100          /* leave received OOB data in line */

#define SO_DONTLINGER   (u_int)(~SO_LINGER)

/*
 * Additional options.
 */
#define SO_SNDBUF       0x1001          /* send buffer size */
#define SO_RCVBUF       0x1002          /* receive buffer size */
#define SO_SNDLOWAT     0x1003          /* send low-water mark */
#define SO_RCVLOWAT     0x1004          /* receive low-water mark */
#define SO_SNDTIMEO     0x1005          /* send timeout */
#define SO_RCVTIMEO     0x1006          /* receive timeout */
#define SO_ERROR        0x1007          /* get error status and clear */
#define SO_TYPE         0x1008          /* get socket type */

/*
 * Options for connect and disconnect data and options.  Used only by
 * non-TCP/IP transports such as DECNet, OSI TP4, etc.
 */
#define SO_CONNDATA     0x7000
#define SO_CONNOPT      0x7001
#define SO_DISCDATA     0x7002
#define SO_DISCOPT      0x7003
#define SO_CONNDATALEN  0x7004
#define SO_CONNOPTLEN   0x7005
#define SO_DISCDATALEN  0x7006
#define SO_DISCOPTLEN   0x7007

/*
 * TCP options.
 */
#define TCP_NODELAY     0x0001

/*
 * Address families.
 */
#define AF_UNSPEC       0               /* unspecified */
#define AF_UNIX         1               /* local to host (pipes, portals) */
#define AF_INET         2               /* internetwork: UDP, TCP, etc. */
#define AF_IMPLINK      3               /* arpanet imp addresses */
#define AF_PUP          4               /* pup protocols: e.g. BSP */
#define AF_CHAOS        5               /* mit CHAOS protocols */
#define AF_IPX          6               /* IPX and SPX */
#define AF_NS           6               /* XEROX NS protocols */
#define AF_ISO          7               /* ISO protocols */
#define AF_OSI          AF_ISO          /* OSI is ISO */
#define AF_ECMA         8               /* european computer manufacturers */
#define AF_DATAKIT      9               /* datakit protocols */
#define AF_CCITT        10              /* CCITT protocols, X.25 etc */
#define AF_SNA          11              /* IBM SNA */
#define AF_DECnet       12              /* DECnet */
#define AF_DLI          13              /* Direct data link interface */
#define AF_LAT          14              /* LAT */
#define AF_HYLINK       15              /* NSC Hyperchannel */
#define AF_APPLETALK    16              /* AppleTalk */
#define AF_NETBIOS      17              /* NetBios-style addresses */

#define AF_MAX          18

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
        u_short sa_family;              /* address family */
        char    sa_data[14];            /* up to 14 bytes of direct address */
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
        u_short sp_family;              /* address family */
        u_short sp_protocol;            /* protocol */
};

/*
 * Protocol families, same as address families for now.
 */
#define PF_UNSPEC       AF_UNSPEC
#define PF_UNIX         AF_UNIX
#define PF_INET         AF_INET
#define PF_IMPLINK      AF_IMPLINK
#define PF_PUP          AF_PUP
#define PF_CHAOS        AF_CHAOS
#define PF_NS           AF_NS
#define PF_IPX          AF_IPX
#define PF_ISO          AF_ISO
#define PF_OSI          AF_OSI
#define PF_ECMA         AF_ECMA
#define PF_DATAKIT      AF_DATAKIT
#define PF_CCITT        AF_CCITT
#define PF_SNA          AF_SNA
#define PF_DECnet       AF_DECnet
#define PF_DLI          AF_DLI
#define PF_LAT          AF_LAT
#define PF_HYLINK       AF_HYLINK
#define PF_APPLETALK    AF_APPLETALK

#define PF_MAX          AF_MAX

/*
 * Structure used for manipulating linger option.
 */
struct  linger {
        u_short l_onoff;                /* option on/off */
        u_short l_linger;               /* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define SOL_SOCKET      0xffff          /* options for socket level */

/*
 * Maximum queue length specifiable by listen.
 */
#define SOMAXCONN       5

#define MSG_OOB         0x1             /* process out-of-band data */
#define MSG_PEEK        0x2             /* peek at incoming message */
#define MSG_DONTROUTE   0x4             /* send without using routing tables */

#define MSG_MAXIOVLEN   16

#define	MSG_PARTIAL     0x8000          /* partial send or recv for message xport */

/*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 */
#define MAXGETHOSTSTRUCT        1024

/*
 * Define flags to be used with the WSAAsyncSelect() call.
 */
#define FD_READ         0x01
#define FD_WRITE        0x02
#define FD_OOB          0x04
#define FD_ACCEPT       0x08
#define FD_CONNECT      0x10
#define FD_CLOSE        0x20

/*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 */
#define WSABASEERR              10000
/*
 * Windows Sockets definitions of regular Microsoft C error constants
 */
#define WSAEINTR                (WSABASEERR+4)
#define WSAEBADF                (WSABASEERR+9)
#define WSAEACCES               (WSABASEERR+13)
#define WSAEFAULT               (WSABASEERR+14)
#define WSAEINVAL               (WSABASEERR+22)
#define WSAEMFILE               (WSABASEERR+24)

/*
 * Windows Sockets definitions of regular Berkeley error constants
 */
#define WSAEWOULDBLOCK          (WSABASEERR+35)
#define WSAEINPROGRESS          (WSABASEERR+36)
#define WSAEALREADY             (WSABASEERR+37)
#define WSAENOTSOCK             (WSABASEERR+38)
#define WSAEDESTADDRREQ         (WSABASEERR+39)
#define WSAEMSGSIZE             (WSABASEERR+40)
#define WSAEPROTOTYPE           (WSABASEERR+41)
#define WSAENOPROTOOPT          (WSABASEERR+42)
#define WSAEPROTONOSUPPORT      (WSABASEERR+43)
#define WSAESOCKTNOSUPPORT      (WSABASEERR+44)
#define WSAEOPNOTSUPP           (WSABASEERR+45)
#define WSAEPFNOSUPPORT         (WSABASEERR+46)
#define WSAEAFNOSUPPORT         (WSABASEERR+47)
#define WSAEADDRINUSE           (WSABASEERR+48)
#define WSAEADDRNOTAVAIL        (WSABASEERR+49)
#define WSAENETDOWN             (WSABASEERR+50)
#define WSAENETUNREACH          (WSABASEERR+51)
#define WSAENETRESET            (WSABASEERR+52)
#define WSAECONNABORTED         (WSABASEERR+53)
#define WSAECONNRESET           (WSABASEERR+54)
#define WSAENOBUFS              (WSABASEERR+55)
#define WSAEISCONN              (WSABASEERR+56)
#define WSAENOTCONN             (WSABASEERR+57)
#define WSAESHUTDOWN            (WSABASEERR+58)
#define WSAETOOMANYREFS         (WSABASEERR+59)
#define WSAETIMEDOUT            (WSABASEERR+60)
#define WSAECONNREFUSED         (WSABASEERR+61)
#define WSAELOOP                (WSABASEERR+62)
#define WSAENAMETOOLONG         (WSABASEERR+63)
#define WSAEHOSTDOWN            (WSABASEERR+64)
#define WSAEHOSTUNREACH         (WSABASEERR+65)
#define WSAENOTEMPTY            (WSABASEERR+66)
#define WSAEPROCLIM             (WSABASEERR+67)
#define WSAEUSERS               (WSABASEERR+68)
#define WSAEDQUOT               (WSABASEERR+69)
#define WSAESTALE               (WSABASEERR+70)
#define WSAEREMOTE              (WSABASEERR+71)

#define WSAEDISCON              (WSABASEERR+101)

/*
 * Extended Windows Sockets error constant definitions
 */
#define WSASYSNOTREADY          (WSABASEERR+91)
#define WSAVERNOTSUPPORTED      (WSABASEERR+92)
#define WSANOTINITIALISED       (WSABASEERR+93)

/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 */

#define h_errno         WSAGetLastError()

/* Authoritative Answer: Host not found */
#define WSAHOST_NOT_FOUND       (WSABASEERR+1001)
#define HOST_NOT_FOUND          WSAHOST_NOT_FOUND

/* Non-Authoritative: Host not found, or SERVERFAIL */
#define WSATRY_AGAIN            (WSABASEERR+1002)
#define TRY_AGAIN               WSATRY_AGAIN

/* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
#define WSANO_RECOVERY          (WSABASEERR+1003)
#define NO_RECOVERY             WSANO_RECOVERY

/* Valid name, no data record of requested type */
#define WSANO_DATA              (WSABASEERR+1004)
#define NO_DATA                 WSANO_DATA

/* no address, look for MX record */
#define WSANO_ADDRESS           WSANO_DATA
#define NO_ADDRESS              WSANO_ADDRESS

/*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 */
#if 0
#define EWOULDBLOCK             WSAEWOULDBLOCK
#define EINPROGRESS             WSAEINPROGRESS
#define EALREADY                WSAEALREADY
#define ENOTSOCK                WSAENOTSOCK
#define EDESTADDRREQ            WSAEDESTADDRREQ
#define EMSGSIZE                WSAEMSGSIZE
#define EPROTOTYPE              WSAEPROTOTYPE
#define ENOPROTOOPT             WSAENOPROTOOPT
#define EPROTONOSUPPORT         WSAEPROTONOSUPPORT
#define ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
#define EOPNOTSUPP              WSAEOPNOTSUPP
#define EPFNOSUPPORT            WSAEPFNOSUPPORT
#define EAFNOSUPPORT            WSAEAFNOSUPPORT
#define EADDRINUSE              WSAEADDRINUSE
#define EADDRNOTAVAIL           WSAEADDRNOTAVAIL
#define ENETDOWN                WSAENETDOWN
#define ENETUNREACH             WSAENETUNREACH
#define ENETRESET               WSAENETRESET
#define ECONNABORTED            WSAECONNABORTED
#define ECONNRESET              WSAECONNRESET
#define ENOBUFS                 WSAENOBUFS
#define EISCONN                 WSAEISCONN
#define ENOTCONN                WSAENOTCONN
#define ESHUTDOWN               WSAESHUTDOWN
#define ETOOMANYREFS            WSAETOOMANYREFS
#define ETIMEDOUT               WSAETIMEDOUT
#define ECONNREFUSED            WSAECONNREFUSED
#define ELOOP                   WSAELOOP
#define ENAMETOOLONG            WSAENAMETOOLONG
#define EHOSTDOWN               WSAEHOSTDOWN
#define EHOSTUNREACH            WSAEHOSTUNREACH
#define ENOTEMPTY               WSAENOTEMPTY
#define EPROCLIM                WSAEPROCLIM
#define EUSERS                  WSAEUSERS
#define EDQUOT                  WSAEDQUOT
#define ESTALE                  WSAESTALE
#define EREMOTE                 WSAEREMOTE
#endif

/* Socket function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

SOCKET PASCAL FAR accept (SOCKET s, struct sockaddr FAR *addr,
                          int FAR *addrlen);

int PASCAL FAR bind (SOCKET s, const struct sockaddr FAR *addr, int namelen);

int PASCAL FAR closesocket (SOCKET s);

int PASCAL FAR connect (SOCKET s, const struct sockaddr FAR *name, int namelen);

int PASCAL FAR ioctlsocket (SOCKET s, long cmd, u_long FAR *argp);

int PASCAL FAR getpeername (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockname (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockopt (SOCKET s, int level, int optname,
                           char FAR * optval, int FAR *optlen);

u_long PASCAL FAR htonl (u_long hostlong);

u_short PASCAL FAR htons (u_short hostshort);

unsigned long PASCAL FAR inet_addr (const char FAR * cp);

char FAR * PASCAL FAR inet_ntoa (struct in_addr in);

int PASCAL FAR listen (SOCKET s, int backlog);

u_long PASCAL FAR ntohl (u_long netlong);

u_short PASCAL FAR ntohs (u_short netshort);

int PASCAL FAR recv (SOCKET s, char FAR * buf, int len, int flags);

int PASCAL FAR recvfrom (SOCKET s, char FAR * buf, int len, int flags,
                         struct sockaddr FAR *from, int FAR * fromlen);

int PASCAL FAR select (int nfds, fd_set FAR *readfds, fd_set FAR *writefds,
                       fd_set FAR *exceptfds, const struct timeval FAR *timeout);

int PASCAL FAR send (SOCKET s, const char FAR * buf, int len, int flags);

int PASCAL FAR sendto (SOCKET s, const char FAR * buf, int len, int flags,
                       const struct sockaddr FAR *to, int tolen);

int PASCAL FAR setsockopt (SOCKET s, int level, int optname,
                           const char FAR * optval, int optlen);

int PASCAL FAR shutdown (SOCKET s, int how);

SOCKET PASCAL FAR socket (int af, int type, int protocol);

/* Database function prototypes */

struct hostent FAR * PASCAL FAR gethostbyaddr(const char FAR * addr,
                                              int len, int type);

struct hostent FAR * PASCAL FAR gethostbyname(const char FAR * name);

int PASCAL FAR gethostname (char FAR * name, int namelen);

struct servent FAR * PASCAL FAR getservbyport(int port, const char FAR * proto);

struct servent FAR * PASCAL FAR getservbyname(const char FAR * name,
                                              const char FAR * proto);

struct protoent FAR * PASCAL FAR getprotobynumber(int proto);

struct protoent FAR * PASCAL FAR getprotobyname(const char FAR * name);

/* Microsoft Windows Extension function prototypes */

int PASCAL FAR WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData);

int PASCAL FAR WSACleanup(void);

void PASCAL FAR WSASetLastError(int iError);

int PASCAL FAR WSAGetLastError(void);

BOOL PASCAL FAR WSAIsBlocking(void);

int PASCAL FAR WSAUnhookBlockingHook(void);

FARPROC PASCAL FAR WSASetBlockingHook(FARPROC lpBlockFunc);

int PASCAL FAR WSACancelBlockingCall(void);

HANDLE PASCAL FAR WSAAsyncGetServByName(HWND hWnd, u_int wMsg,
                                        const char FAR * name,
                                        const char FAR * proto,
                                        char FAR * buf, int buflen);

HANDLE PASCAL FAR WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port,
                                        const char FAR * proto, char FAR * buf,
                                        int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg,
                                         const char FAR * name, char FAR * buf,
                                         int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg,
                                           int number, char FAR * buf,
                                           int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByName(HWND hWnd, u_int wMsg,
                                        const char FAR * name, char FAR * buf,
                                        int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg,
                                        const char FAR * addr, int len, int type,
                                        char FAR * buf, int buflen);

int PASCAL FAR WSACancelAsyncRequest(HANDLE hAsyncTaskHandle);

int PASCAL FAR WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg,
                               long lEvent);

int PASCAL FAR WSARecvEx (SOCKET s, char FAR * buf, int len, int FAR *flags);

#ifdef __cplusplus
}
#endif

/* Microsoft Windows Extended data types */
typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr FAR *LPSOCKADDR;

typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in FAR *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger FAR *LPLINGER;

typedef struct in_addr IN_ADDR;
typedef struct in_addr *PIN_ADDR;
typedef struct in_addr FAR *LPIN_ADDR;

typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set FAR *LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent FAR *LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent FAR *LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent FAR *LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval FAR *LPTIMEVAL;

/*
 * Windows message parameter composition and decomposition
 * macros.
 *
 * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 */
#define WSAMAKEASYNCREPLY(buflen,error)     MAKELONG(buflen,error)
/*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 */
#define WSAMAKESELECTREPLY(event,error)     MAKELONG(event,error)
/*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
/*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
/*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTEVENT(lParam)           LOWORD(lParam)
/*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTERROR(lParam)           HIWORD(lParam)

#endif  /* _WINSOCKAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\woahack.h ===
/* Defines for WinOldAppHackoMatic flags which win386 oldapp can send to us. 
 * These are kept in user's global variable winOldAppHackoMaticFlags
 */

/*
 * WOAHACK_CHECKALTKEYSTATE
 *
 *  This is sent from WinOldAp to USER when the user has just pressed
 *  Alt+Space.  When the user does that, keyboard focus shifts from
 *  the DOS box to Windows.  This is particularly weird because the
 *  focus is changing while the user has a key down.  The message is
 *  sent to USER to let it know that the Alt key may be in a funky
 *  state right now.
 *
 *  The value of this must be a power of two because it is used
 *  in the winOldAppHackoMaticFlags variable as a bitmask.
 *
 * WOAHACK_IGNOREALTKEYDOWN
 *
 *  This is used internally by USER to keep track of the Alt key
 *  state, triggered by the WOAHACK_CHECKALTKEYSTATE message.
 *
 *  The value of this must be a power of two because it is used
 *  in the winOldAppHackoMaticFlags variable as a bitmask.
 *
 * WOAHACK_DISABLEREPAINTSCREEN
 *
 *  This is sent from WinOldAp to USER when the user has initiated
 *  an Alt+Tab sequence from a fullscreen VM.  This causes USER to
 *  defer the RepaintScreen that will be sent by the display driver.
 *  This speeds up Alt+Tab'ing.  When the Alt+Tab is complete,
 *  if the user selected another fullscreen DOS box, USER will ignore
 *  the RepaintScreen altogether, since it's about to lose the
 *  display focus anyway.  In all other cases, the RepaintScreen will
 *  be performed once the Alt+Tab is complete.
 *
 * WOAHACK_LOSINGDISPLAYFOCUS
 * WOAHACK_GAININGDISPLAYFOCUS
 *
 *  These messages are sent from WinOldAp to USER when the display
 *  focus is changing.  The WOAHACK_LOSINGDISPLAYFOCUS message is
 *  sent *before* Windows is about to lose focus, and the
 *  WOAHACK_GAININGDISPLAYFOCUS is sent *after* Windows has regained
 *  the display focus.
 *
 *  WinOldAp sends these messages whenever it is about to set the
 *  VM focus.  It doesn't check if the message is a repeat of a
 *  previous message.  (So, for example, USER may receive three
 *  copies of WOAHACK_GAININGDISPLAYFOCUS.)  USER maintains an
 *  internal variable to keep track of whether each receipt of the
 *  message is a change in the focus or just a redundant notification.
 *
 *  USER uses these messages to turn off the timer that is normally
 *  used to trigger the mouse drawing code in the display driver
 *  while Windows does not have the display focus, and to turn the
 *  timer back on once Windows gets the display back.
 *
 *  This is needed to make sure the display driver is otherwise
 *  quiet when the int 2F is dispatched from the VDD to notify the
 *  display driver that the focus has changed.  Not doing this
 *  opens the possibility of re-entrancy in the display driver.
 *
 *  WOAHACK_IMAWINOLDAPSORTOFGUY
 *
 *  WinOldAp needs to call this API once with this flag set so that
 *  USER can mark winoldap's queue as being winoldap.  USER needs
 *  to know that a particular queue is winoldap for several reasons
 *  having to do with task switching and priorities.
 */
#define WOAHACK_CHECKALTKEYSTATE 1
#define WOAHACK_IGNOREALTKEYDOWN 2
#define WOAHACK_DISABLEREPAINTSCREEN  3
#define WOAHACK_LOSINGDISPLAYFOCUS    4
#define WOAHACK_GAININGDISPLAYFOCUS   5
#define WOAHACK_IAMAWINOLDAPSORTOFGUY 6


/* ------ After this point comes information that can be publicized ------- */

/* WinOldApp related flags and Macros */

/*
 *  These property bits are stored in the flWinOldAp property of
 *  WinOldAp's main window.  They are provided so that USER and other
 *  applications can query the state of the DOS box.
 *
 *  These properties are read-only.  Changing them will cause Windows
 *  to get confused.
 *
 *  woapropIsWinOldAp
 *
 *	This bit is always set.
 *
 *  woapropFullscreen
 *
 *	Set if this a fullscreen DOS box rather than a windowed DOS box.
 *	Note that this bit is set even if WinOldAp does not have focus.
 *	(E.g., when iconic.)  Its purpose is to indicate what the state
 *	of the DOS box would be *if* it were to be activated.
 *
 *  woapropActive
 *
 *	Set if WinOldAp is active.  Note that one cannot merely
 *	check IsIconic(hwnd) because fullscreen DOS boxes are always
 *	iconic.
 *
 *  None of the other bits are used, although names for some of them
 *  have been chosen.  This does not represent any commitment to use
 *  them for the purpose the name suggests.
 *
 *  Other properties we may think of adding...
 *
 *	hvm
 *
 *	    This extended property contains the 32-bit VM handle.
 *
 *	hprop
 *
 *	    This property contains the property handle being used
 *	    by the DOS box.  (For utilities which want to be able
 *	    to modify the properties of a running DOS box, perhaps.)
 *
 */

#define WINOLDAP_PROP_NAME	"flWinOldAp"

extern ATOM atmWinOldAp;
#define WinOldApFlag(hwnd, flag) ((UINT)GetPropEx(hwnd, MAKEINTATOM(atmWinOldAp)) & woaprop##flag)

#define woapropIsWinOldAp	1
#define woapropFullscreen	2
#define woapropActive		4
#define woapropIdle		8
#define woapropClosable		64

#define IsWinOldApHwnd(hwnd) WinOldApFlag(hwnd, IsWinOldAp)
#define IsFullscreen(hwnd) WinOldApFlag(hwnd, Fullscreen)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\avidraw.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1991-1992. All rights reserved.

   Title:   avidraw.c - Functions that actually draw video for AVI.

*****************************************************************************/
#include "graphic.h"

//
// if the average key frame spacing is greater than this value, always
// force a buffer.
//
#define KEYFRAME_PANIC_SPACE       2500

#define YIELDATFUNNYTIMES

#define ALIGNULONG(i)     ((i+3)&(~3))                  /* ULONG aligned ! */
#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)

#ifdef WIN32
#define LockCurrentTask(x)	(x)
#else
extern FAR PASCAL LockCurrentTask(BOOL);
#endif

BOOL NEAR PASCAL DrawBits(NPMCIGRAPHIC npMCI, DWORD ckid, DWORD cksize, BOOL fHurryUp);
void NEAR PASCAL UpdateDisplayDibPalette(NPMCIGRAPHIC npMCI);

BOOL NEAR PASCAL ProcessPaletteChange(NPMCIGRAPHIC npMCI, DWORD cksize)
{
    UINT wStartIndex;
    UINT wNumEntries;
    UINT w;
    LPPALETTEENTRY ppe;

    npMCI->dwFlags |= MCIAVI_PALCHANGED;
    DPF2(("Setting PALCHANGED\n"));

    while (cksize > 4) {
	wStartIndex = GET_BYTE();
	wNumEntries = GET_BYTE();

	/* Skip filler word */
	GET_WORD();

	/* Zero is used as a shorthand for 256 */
	if (wNumEntries == 0)
            wNumEntries = 256;

        ppe = (LPVOID)npMCI->lp;

        for (w=0; w<wNumEntries; w++)
        {
            npMCI->argb[wStartIndex+w].rgbRed   = ppe[w].peRed;
            npMCI->argb[wStartIndex+w].rgbGreen = ppe[w].peGreen;
            npMCI->argb[wStartIndex+w].rgbBlue  = ppe[w].peBlue;
        }

	SKIP_BYTES(wNumEntries * sizeof(PALETTEENTRY));
	cksize -= 4 + wNumEntries * sizeof(PALETTEENTRY);
    }

    if (npMCI->pbiFormat->biBitCount == 8) {
	hmemcpy((LPBYTE) npMCI->pbiFormat + npMCI->pbiFormat->biSize,
		(LPBYTE) npMCI->argb,
		sizeof(RGBQUAD) * npMCI->pbiFormat->biClrUsed);
    }

#ifdef DEBUG	
    /* Make sure we've used up the entire chunk... */
    if (cksize != 0) {
	DPF(("MCIAVI: Problem with palc chunk\n"));
    }
#endif

    return TRUE;
}

/* Display the video from the current record.
*/
BOOL NEAR PASCAL DisplayVideoFrame(NPMCIGRAPHIC npMCI, BOOL fHurryUp)
{
    DWORD	ckid;
    DWORD	cksize;
    BOOL	fRet;
    int		stream;
    DWORD	dwRet;
    LONG        len;
    DWORD	dwDrawStart;
    LPVOID      lpSave;
    LPVOID      lpChunk;

    /* If we're allowed to skip frames, apply some relatively
    ** bogus heuristics to decide if we should do it, and
    ** pass the appropriate flag on to the driver.
    */
    if ((npMCI->lCurrentFrame & 0x0f) == 0) {
	fHurryUp = FALSE;
    }

    /* Even if SKIPFRAMES is off, count how many frames we _would_ have
    ** skipped if we could.
    */
    if (fHurryUp)
	++npMCI->dwSkippedFrames;

    if (!(npMCI->dwOptionFlags & MCIAVIO_SKIPFRAMES))
	fHurryUp = FALSE;

    /* Keep track of what we've drawn. */
    npMCI->lFrameDrawn = npMCI->lCurrentFrame;
    len = (LONG)npMCI->dwThisRecordSize;
    lpSave = npMCI->lp;

    /* If it's interleaved, adjust for the next record header.... */
    // !!! Only if not last frame?
    if (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED)
	len -= 3 * sizeof(DWORD);

    while (len >= 2 * sizeof(DWORD)) {

	/* Look at the next chunk */
	ckid = GET_DWORD();
	cksize = GET_DWORD();

	DPF3(("'%.4s': %lu bytes\n", (LPSTR) &ckid, cksize));
	
	if ((LONG) cksize > len) {
            AssertSz(FALSE, "Chunk obviously too big!");
	    break;
	}
	
        len -= ((cksize+1)&~1) + 8;

        if (len < -1) {
            AssertSz(FALSE, "Chunk overflowed what was read in!");
	    break;
	}

	lpChunk = npMCI->lp;
	
        stream = StreamFromFOURCC(ckid);

        if (stream == npMCI->nVideoStream) {

            if ((npMCI->lCurrentFrame < npMCI->lVideoStart) &&
                    !(npMCI->dwFlags & MCIAVI_REVERSE))
                goto skip;

            switch(TWOCCFromFOURCC(ckid)) {

            case cktypePALchange:
                ProcessPaletteChange(npMCI, cksize);
                npMCI->lLastPaletteChange = npMCI->lCurrentFrame;
                break;

            default:
                /* Some other chunk... */
                if (!fHurryUp && ckid)
                    dwDrawStart = timeGetTime();

                //!!! we need to handle half frames!!!

                fRet = DrawBits(npMCI, ckid, cksize, fHurryUp);

                if (!fRet)
                    return FALSE;

                if (!fHurryUp && ckid)
                    npMCI->dwLastDrawTime = timeGetTime() - dwDrawStart;

                if (npMCI->dwBufferedVideo)
                    npMCI->dwLastDrawTime = 0;

                break;
            }
        } else if (stream >= 0 && stream < npMCI->streams &&
                        SI(stream)->hicDraw) {
            dwRet = ICDraw(SI(stream)->hicDraw, (fHurryUp ? ICDRAW_HURRYUP : 0L),
                                SI(stream)->lpFormat,
                                (ckid == 0) ? 0L : npMCI->lp, cksize, npMCI->lCurrentFrame);
            // !!! Error check?
        }
skip:
	/* If not interleaved, we're done. */
	if (npMCI->wPlaybackAlg != MCIAVI_ALG_INTERLEAVED)
	    return TRUE;

        /* Skip to the next chunk */
        npMCI->lp = (HPSTR) lpChunk + ((cksize+1)&~1);
    }

    npMCI->lp = lpSave;

    return TRUE;
}

//
// mark all streams in the passed RECT as dirty
//
void NEAR PASCAL StreamInvalidate(NPMCIGRAPHIC npMCI, LPRECT prc)
{
    int i;
    int n;
    STREAMINFO *psi;
    RECT rc;

    if (prc)
        DPF2(("StreamInvalidate: [%d, %d, %d, %d]\n", *prc));
    else
        DPF2(("StreamInvalidate: NULL\n", *prc));

    for (n=i=0; i<npMCI->streams; i++) {

        psi = SI(i);

        // we always update any visible error streams

        if (!(psi->dwFlags & STREAM_ERROR) &&
            !(psi->dwFlags & STREAM_ENABLED))
            continue;

        if (IsRectEmpty(&psi->rcDest))
            continue;

        if (prc && !IntersectRect(&rc, prc, &psi->rcDest))
            continue;

        n++;
        psi->dwFlags |= STREAM_NEEDUPDATE;
    }

    //
    // !!!is this right? or should we always dirty the movie?
    //
    if (n > 0)
        npMCI->dwFlags |= MCIAVI_NEEDUPDATE;
    else
        npMCI->dwFlags &= ~MCIAVI_NEEDUPDATE;
}

//
//  update all dirty streams
//
//  if fPaint is set paint the area even if the stream handler does not
//
BOOL NEAR PASCAL DoStreamUpdate(NPMCIGRAPHIC npMCI, BOOL fPaint)
{
    int i;
    BOOL f=TRUE;
    STREAMINFO *psi;

    Assert(npMCI->hdc);
    SaveDC(npMCI->hdc);

    for (i=0; i<npMCI->streams; i++) {

        psi = SI(i);

        //
        // this stream is clean, dont paint it.
        //
        if (!(psi->dwFlags & (STREAM_DIRTY|STREAM_NEEDUPDATE))) {

            ExcludeClipRect(npMCI->hdc,
                DEST(i).left,DEST(i).top,DEST(i).right,DEST(i).bottom);

            continue;
        }

        psi->dwFlags &= ~STREAM_NEEDUPDATE;
        psi->dwFlags &= ~STREAM_DIRTY;

        if (psi->dwFlags & STREAM_ERROR) {
            UINT u;
            TCHAR ach[80];
            TCHAR szMessage[80];
            HBRUSH hbr = CreateHatchBrush(HS_BDIAGONAL, RGB(128,0,0));

            if (psi->sh.fccType == streamtypeVIDEO)
                 LoadString(ghModule, MCIAVI_CANT_DRAW_VIDEO, ach, sizeof(ach));
            else
                 LoadString(ghModule, MCIAVI_CANT_DRAW_STREAM, ach, sizeof(ach));

            FillRect(npMCI->hdc, &DEST(i), hbr);
            u = SetBkMode(npMCI->hdc, TRANSPARENT);
            wsprintf(szMessage, ach,
                (LPVOID)&psi->sh.fccType,
                (LPVOID)&psi->sh.fccHandler);
            DrawText(npMCI->hdc, szMessage, lstrlen(szMessage), &DEST(i),
                 DT_WORDBREAK|DT_VCENTER|DT_CENTER);
            SetBkMode(npMCI->hdc, u);
            DeleteObject(hbr);

            FrameRect(npMCI->hdc, &DEST(i), GetStockObject(BLACK_BRUSH));
        }

        else if (!(psi->dwFlags & STREAM_ENABLED)) {
            FillRect(npMCI->hdc, &DEST(i), GetStockObject(DKGRAY_BRUSH));
        }

        else if (psi->sh.fccType == streamtypeVIDEO &&
            !(npMCI->dwFlags & MCIAVI_SHOWVIDEO)) {

            continue;   // we will paint black here.
        }

        else if (npMCI->nVideoStreams > 0 && i == npMCI->nVideoStream) {

            if (!DrawBits(npMCI, 0L, 0L, FALSE)) {

                psi->dwFlags |= STREAM_NEEDUPDATE;
                f = FALSE;

                if (fPaint)         // will paint back if told to.
                    continue;
            }
        }
        else if (psi->hicDraw == NULL) {
            FillRect(npMCI->hdc, &DEST(i), GetStockObject(DKGRAY_BRUSH));
        }
        else if (ICDraw(psi->hicDraw,ICDRAW_UPDATE,psi->lpFormat,NULL,0,0) != 0) {

            psi->dwFlags |= STREAM_NEEDUPDATE;
            f = FALSE;

            // should other streams work like this?

            if (fPaint)             // will paint back if told to.
                continue;
        }

        //
        //  we painted so clean this area
        //
        ExcludeClipRect(npMCI->hdc,
            DEST(i).left,DEST(i).top,DEST(i).right,DEST(i).bottom);
    }

    // now paint black every where else

    FillRect(npMCI->hdc,&npMCI->rcDest,GetStockObject(BLACK_BRUSH));
    RestoreDC(npMCI->hdc, -1);

    //
    // do we still still need a update?
    //
    if (f) {
        npMCI->dwFlags &= ~MCIAVI_NEEDUPDATE;
    }
    else {
        DPF2(("StreamUpdate: update failed\n"));
        npMCI->dwFlags |= MCIAVI_NEEDUPDATE;
    }

    return f;
}

void NEAR PASCAL AlignPlaybackWindow(NPMCIGRAPHIC npMCI)
{
#ifndef WIN32
    DWORD dw;
    int x,y;
    HWND hwnd;      // the window we will move.
    RECT rc;

    // if (npMCI->hicDraw != npMCI->hicDrawInternal)
    //	    return;  !!! only align if using the default draw guy?

#pragma message("**** move this into the draw handler and/or DrawDib")
#pragma message("**** we need to query the alignment from the codec????")
    #define X_ALIGN 4
    #define Y_ALIGN 4

    // the MCIAVI_RELEASEDC flags means the DC came from a GetDC(npMCI->hwnd)

    if (!(npMCI->dwFlags & MCIAVI_RELEASEDC))
        return;

    //
    // dont align if the dest rect is not at 0,0
    //
    if (npMCI->rcMovie.left != 0 || npMCI->rcMovie.top != 0)
        return;

    dw = GetDCOrg(npMCI->hdc);

    x = LOWORD(dw) + npMCI->rcMovie.left;
    y = HIWORD(dw) + npMCI->rcMovie.top;

    if ((x & (X_ALIGN-1)) || (y & (Y_ALIGN-1)))
    {
        DPF2(("*** warning movie is not aligned! (%d,%d)***\n",x,y));

        //
        // find the first moveable window walking up the tree.
        //
        for (hwnd = npMCI->hwnd; hwnd; hwnd = GetParent(hwnd))
        {
            LONG l = GetWindowLong(hwnd, GWL_STYLE);
	
            // this window is toplevel stop
            if (!(l & WS_CHILD))
                break;

            // this window is sizeable (should be movable too)
            if (l & WS_THICKFRAME)
                break;

            // this window has a caption (is moveable)
            if ((l & WS_CAPTION) == WS_CAPTION)
                break;
	}
	
        //
        // dont move the window if it does not want to be moved.
        //
        if (IsWindowVisible(hwnd) &&
           !IsZoomed(hwnd) &&
           !IsIconic(hwnd) &&
            IsWindowEnabled(hwnd))
        {
            GetClientRect(hwnd, &rc);
            ClientToScreen(hwnd, (LPPOINT)&rc);

            //
            // if the movie is not in the upper corner of the window
            // don't align
            //
            if (x < rc.left || x-rc.left > 16 ||
                y < rc.top  || y-rc.top > 16)
                return;

            GetWindowRect(hwnd, &rc);
            OffsetRect(&rc, -(x & (X_ALIGN-1)), -(y & (Y_ALIGN-1)));

            if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
                ScreenToClient(GetParent(hwnd), (LPPOINT)&rc);

            // dont move window off of the screen.

            if (rc.left < 0 || rc.top < 0)
                return;

            DPF2(("*** moving window to [%d,%d,%d,%d]\n",rc));

            SetWindowPos(hwnd,NULL,rc.left,rc.top,0,0,
                SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
#ifdef DEBUG
            dw = GetDCOrg(npMCI->hdc);
            x = LOWORD(dw) + npMCI->rcMovie.left;
            y = HIWORD(dw) + npMCI->rcMovie.top;

            Assert(!(x & (X_ALIGN-1)) && !(y & (Y_ALIGN-1)));
#endif
	    }
	}
#endif
}
	
UINT NEAR PASCAL PrepareDC(NPMCIGRAPHIC npMCI)
{
    UINT u;
    int i;
    STREAMINFO *psi;


    DPF2(("*** PrepareDC(%04X)\n",npMCI->hdc));
    Assert(npMCI->hdc != NULL);

    if (!(npMCI->dwFlags & MCIAVI_FULLSCREEN) &&
        !(npMCI->dwFlags & MCIAVI_SEEKING) &&
        !(npMCI->dwFlags & MCIAVI_UPDATING) &&
         (npMCI->dwFlags & MCIAVI_SHOWVIDEO) ) {
        AlignPlaybackWindow(npMCI);
    }

    if (npMCI->hicDraw) {
	DPF2(("Calling ICDrawRealize\n"));
        u = (UINT)ICDrawRealize(npMCI->hicDraw, npMCI->hdc, npMCI->fForceBackground);
    } else {
        u = 0;
    }

    //
    //  realize the other strems, but force them into the background.
    //
    for (i=0; i<npMCI->streams; i++) {
        psi = SI(i);

        if (!(psi->dwFlags & STREAM_ENABLED))
            continue;

        if (psi->dwFlags & STREAM_ERROR)
            continue;

        if (psi == npMCI->psiVideo)
            continue;

        if (psi->hicDraw == NULL)
            continue;

        if (psi->hicDraw == npMCI->hicDraw)
            continue;

        ICDrawRealize(psi->hicDraw, npMCI->hdc, TRUE);
    }

    //
    // return "master" stream realize value.
    //
    return u;
}

void NEAR PASCAL UnprepareDC(NPMCIGRAPHIC npMCI)
{
    Assert(npMCI->hdc);
    DPF2(("*** UnprepareDC(%04X)\n",npMCI->hdc));
    SelectPalette(npMCI->hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
    RealizePalette(npMCI->hdc);
    //RestoreDC(npMCI->hdc, -1);
}

/* This function is called to actually handle drawing.
**
** ckid and cksize specify the type and size of the data to be drawn;
** it's located at npMCI->lp.
**
** If the fHurryUp flag is set, that means that we're behind and we
** shouldn't draw now. all we do it update the current buffered image
** and return...
*/

BOOL NEAR PASCAL DrawBits(NPMCIGRAPHIC npMCI, DWORD ckid, DWORD cksize, BOOL fHurryUp)
{
    LPVOID	lp = npMCI->lp;
    LPBITMAPINFOHEADER	lpFormat = npMCI->pbiFormat;
    DWORD       dwRet;
    DWORD       dwFlags;
    STREAMINFO *psi;

    if (!npMCI->pbiFormat)
	return TRUE;

    if (npMCI->fNoDrawing || !(npMCI->dwFlags & MCIAVI_SHOWVIDEO))
        return TRUE;

    psi = SI(npMCI->nVideoStream);

    //
    //  let's compute the flags we need to pass to ICDecompress() and
    //  to ICDraw()
    //
    //      ICDRAW_HURRYUP      - we are behind
    //      ICDRAW_PREROLL      - we are seeking (before a play)
    //      ICDRAW_UPDATE       - update of frame (repaint, ...)
    //      ICDRAW_NOTKEYFRAME  - this frame data is not a key.
    //

    dwFlags = 0;

    if (psi->dwFlags & STREAM_NEEDUPDATE)
        dwFlags |= ICDRAW_UPDATE;

    if (cksize == 0)
        dwFlags |= ICDRAW_NULLFRAME;

    if (ckid == 0) {
        dwFlags |= ICDRAW_UPDATE;
        lp = 0;
    }
    else if (fHurryUp) {
        dwFlags |= ICDRAW_HURRYUP;
        psi->dwFlags |= STREAM_DIRTY;
    }
    else if (!(npMCI->dwFlags & MCIAVI_REVERSE) &&
             (npMCI->lCurrentFrame < npMCI->lRealStart)) {
        dwFlags |= ICDRAW_PREROLL;
        psi->dwFlags |= STREAM_DIRTY;
    }

    if (npMCI->hpFrameIndex) {
        if ((ckid == 0L || cksize == 0) ||
                    FramePrevKey(npMCI->lCurrentFrame) != npMCI->lCurrentFrame)
            dwFlags |= ICDRAW_NOTKEYFRAME;
    }

    //
    //  now draw the frame, decompress first if needed.
    //
    if (npMCI->hic) {

        if (ckid != 0L && cksize != 0) {

            TIMESTART(timeDecompress);

	    npMCI->pbiFormat->biSizeImage = cksize; // !!! Is this safe?

	    dwRet = ICDecompress(npMCI->hic,
		    dwFlags,
		    npMCI->pbiFormat,
		    npMCI->lp,
		    &npMCI->bih,
		    npMCI->hpDecompress);

	    TIMEEND(timeDecompress);

	    if (dwRet == ICERR_DONTDRAW) {
		return TRUE; // !!!???
            }

	    // ICERR_NEWPALETTE?

	    dwFlags &= (~ICDRAW_NOTKEYFRAME);	// It's a key frame now....
        }

        if (dwFlags & (ICDRAW_HURRYUP|ICDRAW_PREROLL))
            return TRUE;

	lpFormat = &npMCI->bih;
	lp = npMCI->hpDecompress;
	cksize = npMCI->bih.biSizeImage;
    }

    TIMESTART(timeDraw);

    if ((npMCI->dwFlags & MCIAVI_PALCHANGED) &&
        !(dwFlags & (ICDRAW_HURRYUP|ICDRAW_PREROLL))) {

        if (psi->ps) {
            if (npMCI->hic) {
                //!!! should be psi->lpFormat *not* npMCI->pbiFormat
                ICDecompressGetPalette(npMCI->hic, npMCI->pbiFormat, &npMCI->bih);
                ICDrawChangePalette(npMCI->hicDraw, &npMCI->bih);
            }
            else {
                ICDrawChangePalette(npMCI->hicDraw, npMCI->pbiFormat);
            }
        }
        else {
            DPF2(("Calling ICDrawChangePalette\n"));
            ICDrawChangePalette(npMCI->hicDraw, &npMCI->bih);
        }

        npMCI->dwFlags &= ~(MCIAVI_PALCHANGED);

        dwFlags &= ~ICDRAW_HURRYUP; // should realy draw this!
    }

    if ((npMCI->dwFlags & MCIAVI_SEEKING) &&
        !(dwFlags & ICDRAW_PREROLL))
        PrepareDC(npMCI);

    lpFormat->biSizeImage = cksize; // !!! ??? Is this safe?

    //
    // !!!do we realy realy want to do this here?
    // or just relay on the MPlay(er) status function
    //
////if (npMCI->dwFlags & MCIAVI_WANTMOVE)
////    CheckWindowMoveFast(npMCI);

    DPF3(("Calling ICDraw on frame %ld  (%08lx)\n", npMCI->lCurrentFrame, dwFlags));

    dwRet = ICDraw(npMCI->hicDraw, dwFlags, lpFormat, lp, cksize,
		   npMCI->lCurrentFrame - npMCI->lFramePlayStart);

    TIMEEND(timeDraw);

    if ((LONG) dwRet < ICERR_OK) {
	DPF(("Driver failed ICM_DRAW message err=%ld\n", dwRet));
	return FALSE;
    }
    else {

        psi->dwFlags &= ~STREAM_NEEDUPDATE;

        if (!(dwFlags & (ICDRAW_HURRYUP|ICDRAW_PREROLL)))
            psi->dwFlags &= ~STREAM_DIRTY;
    }

    return TRUE;
}

/***************************************************************************
 ***************************************************************************/

static void FreeDecompressBuffer(NPMCIGRAPHIC npMCI)
{
    if (npMCI->hpDecompress)
	GlobalFreePtr(npMCI->hpDecompress);

    npMCI->hpDecompress = NULL;
    npMCI->cbDecompress = 0;
}

/***************************************************************************
 ***************************************************************************/

static BOOL GetDecompressBuffer(NPMCIGRAPHIC npMCI)
{
    int n = npMCI->nVideoStream;
    int dxDest = RCW(DEST(n));
    int dyDest = RCH(DEST(n));
    HPSTR   hp;

    npMCI->bih.biSizeImage = npMCI->bih.biHeight * DIBWIDTHBYTES(npMCI->bih);

    if ((LONG) npMCI->bih.biSizeImage <= npMCI->cbDecompress)
	return TRUE;

    if (!npMCI->hpDecompress)
	hp = GlobalAllocPtr(GHND|GMEM_SHARE, npMCI->bih.biSizeImage);
    else
	hp = GlobalReAllocPtr(npMCI->hpDecompress,
			      npMCI->bih.biSizeImage,
			      GMEM_MOVEABLE | GMEM_SHARE);

    if (hp == NULL) {
        npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
        return FALSE;
    }

    npMCI->hpDecompress = hp;
    npMCI->cbDecompress = npMCI->bih.biSizeImage;

    return TRUE;
}



/*
Possibilities:

1. We're starting to play.
We may need to switch into fullscreen mode.
We need a DrawBegin.


2. We're updating the screen.
Do we send a new DrawBegin?
Has anything changed since we last updated?  Perhaps we can use
a flag to say whether something has changed, and set it when we leave
fullscreen mode or when the window is stretched.

What if we're updating to memory?

3. We're playing, and the user has stretched the window.
The Draw device may need us to go back to a key frame.
If we have a separate decompressor, it may need us to go back to a key frame.


*/

#if 0
RestartCompressor()
{
    DWORD dwDrawFlags;

    dwDrawFlags = (npMCI->dwFlags & MCIAVI_FULLSCREEN) ?
				    ICDRAW_FULLSCREEN : ICDRAW_HDC;

    if (pfRestart)
	dwDrawFlags |= ICDRAW_CONTINUE;

    if (npMCI->dwFlags & MCIAVI_UPDATETOMEMORY)
	dwDrawFlags |= ICDRAW_MEMORYDC;


    if (npMCI->hic) {
	static struct  {
	    BITMAPINFOHEADER bi;
	    RGBQUAD          rgbq[256];
	}   dib;


    }
}
#endif


BOOL TryDrawDevice(NPMCIGRAPHIC npMCI, HIC hicDraw, DWORD dwDrawFlags, BOOL fTryDecompress)
{
    DWORD   dw;
    int     n = npMCI->nVideoStream;
    STREAMINFO *psi = SI(n);

    Assert(psi);

    if (hicDraw == NULL)
        return FALSE;

    // See if the standard draw device can handle the format
    dw = ICDrawBegin(hicDraw,
        dwDrawFlags,

        npMCI->hpal,           // palette to draw with
        npMCI->hwnd,           // window to draw to
        npMCI->hdc,            // HDC to draw to

	RCX(DEST(n)),
	RCY(DEST(n)),
	RCW(DEST(n)),
	RCH(DEST(n)),

        npMCI->pbiFormat,

	RCX(SOURCE(n)),
	RCY(SOURCE(n)),
	RCW(SOURCE(n)),
	RCH(SOURCE(n)),

	// !!! First of all, these two are backwards.
	// !!! Secondly, what if PlayuSec == 0?
	npMCI->dwPlayMicroSecPerFrame,
	1000000L);

    if (dw == ICERR_OK) {
	npMCI->hic = 0;
	npMCI->hicDraw = hicDraw;

	return TRUE;
    }

    if (npMCI->hicDecompress && fTryDecompress) {
	RECT	rc;

	// Ask the draw device to suggest a format, then try to get our
	// decompressor to make that format.
	dw = ICDrawSuggestFormat(hicDraw,
				 npMCI->pbiFormat,
				 &npMCI->bih,
				 RCW(SOURCE(n)),
				 RCH(SOURCE(n)),
				 RCW(DEST(n)),
				 RCH(DEST(n)),
				 npMCI->hicDecompress);

        if ((LONG)dw >= 0)
            dw = ICDecompressQuery(npMCI->hicDecompress,
                    npMCI->pbiFormat,&npMCI->bih);

        if ((LONG)dw < 0) {
            //
            //  default to the right format for the screen, in case the draw guy
            //  fails the draw suggest.
            //
            ICGetDisplayFormat(npMCI->hicDecompress,
                    npMCI->pbiFormat,&npMCI->bih, 0,
                    MulDiv((int)npMCI->pbiFormat->biWidth, RCW(psi->rcDest),RCW(psi->rcSource)),
                    MulDiv((int)npMCI->pbiFormat->biHeight,RCH(psi->rcDest),RCH(psi->rcSource)));

            dw = ICDecompressQuery(npMCI->hicDecompress,
                    npMCI->pbiFormat,&npMCI->bih);

	    if (dw != ICERR_OK) {
		npMCI->dwTaskError = MCIERR_INTERNAL;
		return FALSE;
	    }
        }

        if (npMCI->bih.biBitCount <= 8) {
            ICDecompressGetPalette(npMCI->hicDecompress,
                        npMCI->pbiFormat, &npMCI->bih);
        }
	
#ifdef DEBUG
	DPF(("InitDecompress: Decompressing %dx%dx%d '%4.4ls' to %dx%dx%d\n",
	    (int)npMCI->pbiFormat->biWidth,
	    (int)npMCI->pbiFormat->biHeight,
	    (int)npMCI->pbiFormat->biBitCount,
	    (LPSTR)(
	    npMCI->pbiFormat->biCompression == BI_RGB ? "None" :
	    npMCI->pbiFormat->biCompression == BI_RLE8 ? "Rle8" :
	    npMCI->pbiFormat->biCompression == BI_RLE4 ? "Rle4" :
	    (LPSTR)&npMCI->pbiFormat->biCompression),
	    (int)npMCI->bih.biWidth,
	    (int)npMCI->bih.biHeight,
	    (int)npMCI->bih.biBitCount));
#endif

	if (!GetDecompressBuffer(npMCI))
	    return FALSE;

	//
	// setup the "real" source rect we will draw with.
	//
#if 0
	rc.left = (int) ((SOURCE(n).left * npMCI->bih.biWidth) / npMCI->pbiFormat->biWidth);
	rc.right = (int) ((SOURCE(n).right * npMCI->bih.biWidth) / npMCI->pbiFormat->biWidth);
	rc.top = (int) ((SOURCE(n).top * npMCI->bih.biHeight) / npMCI->pbiFormat->biHeight);
	rc.bottom = (int) ((SOURCE(n).bottom * npMCI->bih.biHeight) / npMCI->pbiFormat->biHeight);
#else
	rc = SOURCE(n);
	rc.left = (int) ((rc.left * npMCI->bih.biWidth) / npMCI->pbiFormat->biWidth);
	rc.right = (int) ((rc.right * npMCI->bih.biWidth) / npMCI->pbiFormat->biWidth);
	rc.top = (int) ((rc.top * npMCI->bih.biHeight) / npMCI->pbiFormat->biHeight);
	rc.bottom = (int) ((rc.bottom * npMCI->bih.biHeight) / npMCI->pbiFormat->biHeight);
#endif
	dw = ICDrawBegin(hicDraw,
	    dwDrawFlags,
	    npMCI->hpal,           // palette to draw with
	    npMCI->hwnd,           // window to draw to
	    npMCI->hdc,            // HDC to draw to
	    RCX(DEST(n)),
	    RCY(DEST(n)),
	    RCW(DEST(n)),
	    RCH(DEST(n)),
	    &npMCI->bih,

	    rc.left, rc.top,
	    rc.right  - rc.left,
	    rc.bottom - rc.top,

	    // !!! First of all, these two are backwards.
	    // !!! Secondly, what if PlayuSec == 0?
	    npMCI->dwPlayMicroSecPerFrame,
	    1000000L);

	if (dw == ICERR_OK) {
	    npMCI->hic = npMCI->hicDecompress;
	    npMCI->hicDraw = hicDraw;
	    
	    // Now, we have the format we'd like the decompressor to decompress to...
            dw = ICDecompressBegin(npMCI->hicDecompress,
				   npMCI->pbiFormat,
				   &npMCI->bih);

	    if (dw != ICERR_OK) {
		DPF(("DrawBegin: decompressor succeeded query, failed begin!\n"));
		ICDrawEnd(npMCI->hicDraw);

		return FALSE;
	    }
	    return TRUE;
	}

	if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	    npMCI->dwTaskError = MCIERR_AVI_NODISPDIB;
	}
    }

    return FALSE;
}

BOOL FindDrawDevice(NPMCIGRAPHIC npMCI, DWORD dwDrawFlags)
{
    if (npMCI->dwFlags & MCIAVI_USERDRAWPROC) {
	// If the user has set a draw procedure, try it.
	if (TryDrawDevice(npMCI, npMCI->hicDrawDefault, dwDrawFlags, TRUE)) {
	    if (npMCI->hic) {
                DPF2(("Using decompressor, then application's draw device...\n"));
	    } else {
                DPF2(("Using application's draw device...\n"));
            }
	    return TRUE;
        }

	// If it fails, it fails.
	DPF(("Can't use application's draw device!\n"));
	return FALSE;
    }

    // First, try a pure draw device we've found.
    if (TryDrawDevice(npMCI, SI(npMCI->nVideoStream)->hicDraw, dwDrawFlags, FALSE)) {
        DPF2(("Draw device is drawing to the screen...\n"));
	return TRUE;
    }

    // Next, try see if the decompressor we found can draw too.
    // Should this even get asked before the guy above?!!!!
    if (TryDrawDevice(npMCI, npMCI->hicDecompress, dwDrawFlags, FALSE)) {
        DPF2(("Decompressor is drawing to the screen...\n"));
	return TRUE;
    }

    // No?  Then, get the standard draw device, for fullscreen or not.
    if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	// !!! If it's fullscreen, should we force a re-begin?
	// !!! Assume fullscreen only happens when play is starting?

	if (npMCI->hicDrawFull == NULL) {
            DPF2(("Opening default fullscreen codec...\n"));
            npMCI->hicDrawFull = ICOpen(streamtypeVIDEO,
                FOURCC_AVIFull,ICMODE_DRAW);

	    if (!npMCI->hicDrawFull)
		npMCI->hicDrawFull = (HIC) -1;
	}

	npMCI->hicDraw = npMCI->hicDrawFull;
    } else {
	if (npMCI->hicDrawDefault == NULL) {
            DPF2(("Opening default draw codec...\n"));
            npMCI->hicDrawDefault = ICOpen(streamtypeVIDEO,
                FOURCC_AVIDraw,ICMODE_DRAW);

	if (!npMCI->hicDrawDefault)
	    npMCI->hicDrawDefault = (HIC) -1;
        }

	npMCI->hicDraw = npMCI->hicDrawDefault;
    }

    // If there's an installed draw device, try it.
    if (npMCI->hicDraw && npMCI->hicDraw != (HIC) -1) {
	if (TryDrawDevice(npMCI, npMCI->hicDraw, dwDrawFlags, TRUE)) {
	    if (npMCI->hic) {
                DPF2(("Using decompressor, then default draw device...\n"));
	    } else {
                DPF2(("Using default draw device...\n"));
	    }
            return TRUE;
	}
    }

    if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	if (!npMCI->hicInternalFull)
	    npMCI->hicInternalFull = ICOpenFunction(streamtypeVIDEO,
		FOURCC_AVIFull,ICMODE_DRAW,(FARPROC)ICAVIFullProc);

	npMCI->hicDraw = npMCI->hicInternalFull;
    } else {
	if (!npMCI->hicInternal) {
	    npMCI->hicInternal = ICOpenFunction(streamtypeVIDEO,
		FOURCC_AVIDraw,ICMODE_DRAW,(FARPROC)ICAVIDrawProc);
#ifdef DEBUG
	    {
		extern HANDLE ghdd;
		npMCI->hdd = ghdd;
		ghdd = NULL;
	    }
#endif
	}

	npMCI->hicDraw = npMCI->hicInternal;
    }

    // As a last resort, try the built-in draw device.
    if (TryDrawDevice(npMCI, npMCI->hicDraw, dwDrawFlags, TRUE)) {
	if (npMCI->hic) {
            DPF2(("Using decompressor, then built-in draw device...\n"));
	} else {
            DPF2(("Using built-in draw device...\n"));
	}
	return TRUE;
    }

    return FALSE;
}

/**************************************************************************
* @doc  INTERNAL DRAWDIB
*
* @api BOOL | DibEq | This function compares two dibs.
*
* @parm LPBITMAPINFOHEADER lpbi1 | Pointer to one bitmap.
*       this DIB is assumed to have the colors after the BITMAPINFOHEADER
*
* @parm LPBITMAPINFOHEADER | lpbi2 | Pointer to second bitmap.
*       this DIB is assumed to have the colors after biSize bytes.
*
* @rdesc Returns TRUE if bitmaps are identical, FALSE otherwise.
*
**************************************************************************/
BOOL DibEq(LPBITMAPINFOHEADER lpbi1, LPBITMAPINFOHEADER lpbi2)
{
    return
        lpbi1->biCompression == lpbi2->biCompression   &&
        lpbi1->biSize        == lpbi2->biSize          &&
        lpbi1->biWidth       == lpbi2->biWidth         &&
        lpbi1->biHeight      == lpbi2->biHeight        &&
        lpbi1->biBitCount    == lpbi2->biBitCount;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | DrawBegin
 *
 *
 ***************************************************************************/
BOOL FAR PASCAL DrawBegin(NPMCIGRAPHIC npMCI, BOOL FAR *pfRestart)
{
    DWORD	dwDrawFlags;
    HIC		hicLast = npMCI->hic;
    HIC         hicLastDraw = npMCI->hicDraw;
    BITMAPINFOHEADER	bihDecompLast = npMCI->bih;

    if (npMCI->nVideoStreams == 0)
	return TRUE;

    if (!npMCI->pbiFormat)
        return TRUE;

    // if fullscreen, make sure we re-initialize....
    if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
    }

    npMCI->fNoDrawing = FALSE;

    dwDrawFlags = (npMCI->dwFlags & MCIAVI_FULLSCREEN) ?
				    ICDRAW_FULLSCREEN : ICDRAW_HDC;

    if (pfRestart) {
	dwDrawFlags |= ICDRAW_CONTINUE;
	*pfRestart = TRUE;
    }

    if (npMCI->dwFlags & MCIAVI_UPDATETOMEMORY)
	dwDrawFlags |= ICDRAW_MEMORYDC;

    // !!! What about easy mode?

    //
    // if the file has no keyframes force a buffer
    //
    if (npMCI->dwKeyFrameInfo == 0)
        dwDrawFlags |= ICDRAW_BUFFER;

    //
    // if the file has few keyframes also force a buffer.
    //
    if (MovieToTime(npMCI->dwKeyFrameInfo) > KEYFRAME_PANIC_SPACE)
        dwDrawFlags |= ICDRAW_BUFFER;

    if (dwDrawFlags & ICDRAW_BUFFER)
        DPF(("Forcing a decompress buffer because too few key frames\n"));

    if (npMCI->wTaskState > TASKIDLE &&
	    !(npMCI->dwFlags & MCIAVI_SEEKING) &&
	    !(npMCI->dwFlags & MCIAVI_FULLSCREEN) &&
	    (npMCI->dwFlags & MCIAVI_ANIMATEPALETTE)) {
	dwDrawFlags |= ICDRAW_ANIMATE;
#if 0
//
// I moved all this into ShowStage() where you could claim it realy belongs.
//
        if (npMCI->hwnd == npMCI->hwndDefault &&
	    !(GetWindowLong(npMCI->hwnd, GWL_STYLE) & WS_CHILD))
            SetActiveWindow(npMCI->hwnd);
#endif
    }

    if (npMCI->hdc == NULL) {
        DPF2(("DrawBegin() with NULL hdc!\n"));
    }

    if (FindDrawDevice(npMCI, dwDrawFlags)) {
	if (npMCI->hicDraw != hicLastDraw || (npMCI->hic != hicLast) ||
	    (npMCI->hic && !DibEq(&npMCI->bih, &bihDecompLast))) {
	    // !!! This obviously shouldn't always be invalidated!
            //
	    // make sure the, current image buffer is invalidated
            //
            DPF2(("Draw device is different; restarting....\n"));
            npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;

            npMCI->dwFlags |= MCIAVI_WANTMOVE;

	    if (pfRestart)
		*pfRestart = TRUE;
        }

        if (npMCI->dwFlags & MCIAVI_WANTMOVE)
            CheckWindowMove(npMCI, TRUE);

//	if (pfRestart)
//           *pfRestart = (dw == ICERR_GOTOKEYFRAME);

	npMCI->dwFlags &= ~(MCIAVI_NEEDDRAWBEGIN);

#if 0
	//
	// tell the compressor some interesting info.
	//

	if (npMCI->hicDraw) { // !!! Does npMCI->hic need to know this?
	    ICSendMessage(npMCI->hic, ICM_SET, ICM_FRAMERATE, npMCI->dwPlayMicroSecPerFrame);
	    ICSendMessage(npMCI->hic, ICM_SET, ICM_KEYFRAMERATE, npMCI->dwKeyFrameInfo);
	}
#endif

	return TRUE;
    }

    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | DrawEnd
 *
 * @parm NPMCIGRAPHIC | npMCI | pointer to instance data block.
 *
 ***************************************************************************/
void NEAR PASCAL DrawEnd(NPMCIGRAPHIC npMCI)
{
    if (!npMCI->pbiFormat)
	return;

    ICDrawEnd(npMCI->hicDraw);

    // if we were fullscreen, we now need to repaint and things....
    if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
    }

    /*
    ** let DrawDib clean up if we're animating the palette.
    */
    if (npMCI->wTaskState > TASKIDLE &&
        !(npMCI->dwFlags & MCIAVI_SEEKING) &&
        !(npMCI->dwFlags & MCIAVI_FULLSCREEN) &&
        !(npMCI->dwFlags & MCIAVI_UPDATING) &&
         (npMCI->dwFlags & MCIAVI_ANIMATEPALETTE)) {
	npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
	InvalidateRect(npMCI->hwnd, NULL, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\aviffmt.h ===
/****************************************************************************/
/*                                                                          */
/*        AVIFFMT.H - Include file for working with AVI files               */
/*                                                                          */
/*        Note: You must include WINDOWS.H and MMSYSTEM.H before            */
/*        including this file.                                              */
/*                                                                          */
/*        Copyright (c) 1991-1992, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

/*
 *
 * An AVI file is the following RIFF form:
 *
 *	RIFF('AVI' 
 *	      LIST('hdrl'
 *		    avih(<MainAVIHeader>)
 *                  LIST ('strl'
 *                      strh(<Stream header>)
 *                      strf(<Stream format>)
 *                      ... additional header data
 *            LIST('movi'	 
 *      	  { LIST('rec' 
 *      		      SubChunk...
 *      		   )
 *      	      | SubChunk } ....	    
 *            )
 *            [ <AVIIndex> ]
 *      )
 *
 *      The first two characters of each chunk are the track number.
 *      SubChunk = {  xxdh(<AVI DIB header>)
 *                  | xxdb(<AVI DIB bits>)
 *                  | xxdc(<AVI compressed DIB bits>)
 *                  | xxpc(<AVI Palette Change>)
 *                  | xxwb(<AVI WAVE bytes>)
 *                  | xxws(<AVI Silence record>)
 *                  | xxmd(<MIDI data>)
 *                  | additional custom chunks }
 *
 */
/*
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * We need a better description of the AVI file header here.
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *
 * The grouping into LIST 'rec' chunks implies only that the contents of
 *   the chunk should be read into memory at the same time.  This
 *   grouping is only necessary for interleaved files.
 *       
 * For loading efficiency, the beginning of each LIST 'rec' chunk may
 * be aligned on a 2K boundary.  (Actually, the beginning of the LIST
 * chunk should be 12 bytes before a 2K boundary, so that the data chunks
 * inside the LIST chunk are aligned.)
 *
 * If the AVI file is being played from CD-ROM in, it is recommended that
 * the file be padded.
 *
 * Limitations for the Alpha release:
 *	If the AVI file has audio, each record LIST must contain exactly
 *	one audio chunk, which must be the first chunk.
 *	Each record must contain exactly one video chunk (possibly preceded
 *	by one or more palette change chunks).
 *	No wave format or DIB header chunks may occur outside of the header.
 */

#ifndef _INC_AVIFFMT
#define _INC_AVIFFMT

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

/* Macro to make a TWOCC out of two characters */
#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

typedef WORD TWOCC;

/* form types, list types, and chunk types */
#define formtypeAVI             mmioFOURCC('A', 'V', 'I', ' ')
#define listtypeAVIHEADER       mmioFOURCC('h', 'd', 'r', 'l')
#define ckidAVIMAINHDR          mmioFOURCC('a', 'v', 'i', 'h')
#define listtypeSTREAMHEADER    mmioFOURCC('s', 't', 'r', 'l')
#define ckidSTREAMHEADER        mmioFOURCC('s', 't', 'r', 'h')
#define ckidSTREAMFORMAT        mmioFOURCC('s', 't', 'r', 'f')
#define ckidSTREAMHANDLERDATA   mmioFOURCC('s', 't', 'r', 'd')

#define listtypeAVIMOVIE        mmioFOURCC('m', 'o', 'v', 'i')
#define listtypeAVIRECORD       mmioFOURCC('r', 'e', 'c', ' ')

#define ckidAVINEWINDEX         mmioFOURCC('i', 'd', 'x', '1')

/*
** Here are some stream types.  Currently, only audio and video
** are supported.
*/
#define streamtypeVIDEO         mmioFOURCC('v', 'i', 'd', 's')
#define streamtypeAUDIO         mmioFOURCC('a', 'u', 'd', 's')
#define streamtypeMIDI          mmioFOURCC('m', 'i', 'd', 's')
#define streamtypeTEXT          mmioFOURCC('t', 'x', 't', 's')

/*
** Here are some compression types.
*/
#define comptypeRLE0            mmioFOURCC('R','L','E','0')
#define comptypeRLE             mmioFOURCC('R','L','E',' ')
#define comptypeDIB             mmioFOURCC('D','I','B',' ')

#define cktypeDIBbits           aviTWOCC('d', 'b')
#define cktypeDIBcompressed     aviTWOCC('d', 'c')
#define cktypeDIBhalf           aviTWOCC('d', 'x')
#define cktypePALchange         aviTWOCC('p', 'c')
#define cktypeWAVEbytes         aviTWOCC('w', 'b')
#define cktypeWAVEsilence       aviTWOCC('w', 's')

#define cktypeMIDIdata          aviTWOCC('m', 'd')

#define cktypeDIBheader         aviTWOCC('d', 'h')
#define cktypeWAVEformat        aviTWOCC('w', 'f')

#define ckidAVIPADDING          mmioFOURCC('J', 'U', 'N', 'K')
#define ckidOLDPADDING          mmioFOURCC('p', 'a', 'd', 'd')


/*
** Useful macros
*/
#define ToHex(n)	((BYTE) (((n) > 9) ? ((n) - 10 + 'A') : ((n) + '0')))
#define FromHex(n)	(((n) >= 'A') ? ((n) + 10 - 'A') : ((n) - '0'))

/* Macro to get stream number out of a FOURCC ckid */
#define StreamFromFOURCC(fcc) ((WORD) ((FromHex(LOBYTE(LOWORD(fcc))) << 4) + \
                                             (FromHex(HIBYTE(LOWORD(fcc))))))

/* Macro to get TWOCC chunk type out of a FOURCC ckid */
#define TWOCCFromFOURCC(fcc)    HIWORD(fcc)

/* Macro to make a ckid for a chunk out of a TWOCC and a stream number
** from 0-255.
**
** Warning: This is a nasty macro, and MS C 6.0 compiles it incorrectly
** if optimizations are on.  Ack.
*/
#define MAKEAVICKID(tcc, stream) \
        MAKELONG((ToHex((stream) & 0x0f) << 8) | ToHex(((stream) & 0xf0) >> 4), tcc)



/*
** Main AVI File Header 
*/	     
		     
/* flags for use in <dwFlags> in AVIFileHdr */
#define AVIF_HASINDEX		0x00000010	// Index at end of file?
#define AVIF_MUSTUSEINDEX	0x00000020
#define AVIF_ISINTERLEAVED	0x00000100
#define AVIF_VARIABLESIZEREC	0x00000200
#define AVIF_NOPADDING		0x00000400
#define AVIF_WASCAPTUREFILE	0x00010000
#define AVIF_COPYRIGHTED	0x00020000

/* The AVI File Header LIST chunk should be padded to this size */
#define AVI_HEADERSIZE  2048                    // size of AVI header list

/*****************************************************************************
 * @doc EXTERNAL AVI_FFMT
 * 
 * @types MainAVIHeader | The <t MainAVIHeader> structure contains 
 *	global information for the entire AVI file.  It is contained 
 *	within an 'avih' chunk within the LIST 'hdrl' chunk at the
 *	beginning of an AVI RIFF file.
 * 
 * @field DWORD | dwMicroSecPerFrame | Specifies the number of 
 *    microseconds between frames.
 *
 * @field DWORD | dwMaxBytesPerSec | Specifies the approximate 
 *    maximum data rate of file.
 *
 * @field DWORD | dwReserved1 | Reserved. (This field should be set to 0.)
 *
 * @field DWORD | dwFlags | Specifies any applicable flags. 
 *    The following flags are defined: 
 *
 *	@flag AVIF_HASINDEX | Indicates
 *		the AVI file has an 'idx1' chunk containing an index
 *		at the end of the file.  For good performance, all AVI 
 *		files should contain an index.
 *
 *	@flag AVIF_MUSTUSEINDEX | Indicates that the
 *		index, rather than the physical ordering of the chunks
 *		in the file, should be used to determine the order of
 *		presentation of the data.  For example, this could be
 *		used for creating a list frames for editing.
 *		
 *	@flag AVIF_ISINTERLEAVED | Indicates 
 *		the AVI file is interleaved.  
 *
 *	@flag AVIF_WASCAPTUREFILE | Indicates 
 *		the AVI file is a specially allocated file used for
 *		capturing real-time video.  Applications should warn the
 *		user before writing over a file with this flag set 
 *		because the user probably defragmented
 *		this file.
 *
 *	@flag AVIF_COPYRIGHTED | Indicates the
 *		AVI file contains copyrighted data and software.
 *    When this flag is used, 
 *    software should not permit the data to be duplicated. 
 *
 * @field DWORD | dwTotalFrames | Specifies the number of 
 *    frames of data in file.
 *
 * @field DWORD | dwInitialFrames | Specifies the initial frame 
 * for interleaved files. Non-interleaved files should specify 
 *	zero.
 *
 * @field DWORD | dwStreams | Specifies the number of streams in the file.
 *	   For example, a file with audio and video has 2 streams.
 *
 * @field DWORD | dwSuggestedBufferSize | Specifies the suggested 
 *    buffer size for reading the file.  Generally, this size 
 *    should be large enough to contain the largest chunk in 
 *    the file. If set to zero, or if it is too small, the playback
 *	   software will have to reallocate memory during playback 
 *	   which will reduce performance.
 *    
 *	   For an interleaved file, this buffer size should be large
 *	   enough to read an entire record and not just a chunk.
 *
 * @field DWORD | dwWidth | Specifies the width of the AVI file in pixels.
 *
 * @field DWORD | dwHeight | Specifies the height of the AVI file in pixels.
 *
 * @field DWORD | dwScale | This field is used with
 *	<e MainAVIHeader.dwRate> to specify the time scale that
 *	applies to the AVI file. In addition, each stream 
 * can have its own time scale.
 *
 *	Dividing <e MainAVIHeader.dwRate> by <e AVIStreamHeader.dwScale>
 *	gives the number of samples per second.
 *
 * @field DWORD | dwRate | See <e MainAVIHeader.dwScale>.
 *
 * @field DWORD | dwStart | Specifies the starting time of the AVI file.
 * The units are defined by <e MainAVIHeader.dwRate> and 
 * <e MainAVIHeader.dwScale>. This field is usually set to zero.
 *
 * @field DWORD | dwLength | Specifies the length of the AVI file. 
 * The units are defined by <e AVIStreamHeader.dwRate> and 
 * <e AVIStreamHeader.dwScale>. This length is returned by MCIAVI when 
 * using the frames time format.
 *
 ****************************************************************************/

typedef struct 
{
    DWORD		dwMicroSecPerFrame;	// frame display rate (or 0L)
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwPaddingGranularity;	// pad to multiples of this
                                                // size; normally 2K.
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwTotalFrames;		// # frames in file
    DWORD		dwInitialFrames;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;
    
    DWORD		dwWidth;
    DWORD		dwHeight;
    
    /* Do we want the stuff below for the whole movie, or just
    ** for the individual streams?
    */
    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwStart;  /* Is this always zero? */
    DWORD		dwLength; /* In units above... */
} MainAVIHeader;


/*
** Stream header
*/

/* !!! Do we need to distinguish between discrete and continuous streams? */

#define AVISF_DISABLED			0x00000001
#define AVISF_VIDEO_PALCHANGES		0x00010000
/* Do we need identity palette support? */

/*****************************************************************************
 * @doc EXTERNAL AVI_FFMT
 * 
 * @types AVIStreamHeader | The <t AVIStreamHeader> structure contains 
 *	   header information for a single stream of an file. It is contained 
 *    within an 'strh' chunk within a LIST 'strl' chunk that is itself
 *	   contained within the LIST 'hdrl' chunk at the beginning of
 *    an AVI RIFF file.
 * 
 * @field FOURCC | fccType | Contains a four-character code which specifies
 *	   the type of data contained in the stream. The following values are 
 *	   currently defined:
 *
 *	@flag 'vids' | Indicates the stream contains video data.  The stream 
 *    format chunk contains a <t BITMAPINFO> structure which can include
 *		palette information.
 *
 *	@flag 'auds' | Indicates the stream contains video data.  The stream 
 *    format chunk contains a <t WAVEFORMATEX> or <t PCMWAVEFORMAT>
 *		structure.
 *
 *    New data types should be registered with the <MI>Multimedia Developer 
 *    Registration Kit<D>.
 *
 * @field FOURCC | fccHandler | Contains a four-character code that 
 *	   identifies a specific data handler.
 *
 * @field DWORD | dwFlags | Specifies any applicable flags. 
 *    The bits in the high-order word of these flags 
 *    are specific to the type of data contained in the stream.
 *    The following flags are currently defined:
 *
 *	@flag AVISF_DISABLED | Indicates 
 *		this stream should not be enabled by default.
 *
 *	@flag AVISF_VIDEO_PALCHANGES | Indicates 
 *		this video stream contains palette changes. This flag warns
 *		the playback software that it will need to animate the 
 *		palette.
 *
 * @field DWORD | dwReserved1 | Reserved. (Should be set to 0.)
 *
 * @field DWORD | dwInitialFrames | Reserved for interleaved files. 
 *	   (Set this to 0 for non-interleaved files.)
 *
 * @field DWORD | dwScale | This field is used together with
 *	<e AVIStreamHeader.dwRate> to specify the time scale that
 *	this stream will use.
 *
 *	Dividing <e AVIStreamHeader.dwRate> by <e AVIStreamHeader.dwScale>
 *	gives the number of samples per second.
 *
 *	For video streams, this rate should be the frame rate.
 *
 *	For audio streams, this rate should correspond to the time needed for
 *	<e WAVEFORMATEX.nBlockAlign> bytes of audio, which for PCM audio simply
 *	reduces to the sample rate.
 *
 * @field DWORD | dwRate | See <e AVIStreamHeader.dwScale>.
 *
 * @field DWORD | dwStart | Specifies the starting time of the AVI file.
 * The units are defined by the 
 *	<e MainAVIHeader.dwRate> and <e MainAVIHeader.dwScale> fields
 *	in the main file header. Normally, this is zero, but it can
 *	specify a delay time for a stream which does not start concurrently 
 *	with the file.
 *
 *	Note: The 1.0 release of the AVI tools does not support a non-zero
 *	starting time.
 *
 * @field DWORD | dwLength | Specifies the length of this stream. 
 * The units are defined by the 
 *	<e AVIStreamHeader.dwRate> and <e AVIStreamHeader.dwScale>
 *	fields of the stream's header. 
 *
 * @field DWORD | dwSuggestedBufferSize | Suggests how large a buffer
 *	should be used to read this stream.  Typically, this contains a
 *	value corresponding to the largest chunk present in the stream. 
 * Using the correct buffer size makes playback more efficient.
 * Use zero if you do not know the correct buffer size. 
 *
 * @field DWORD | dwQuality | Specifies an indicator of the quality 
 * of the data in the stream. Quality is 
 *	represented as a number between 0 and 10000.  For compressed data,
 *	this typically represent the value of the quality parameter
 *	passed to the compression software.
 *
 * @field DWORD | dwSampleSize | Specifies the size of a single sample 
 * of data. This is set to 
 *	zero if the samples can vary in size.  If this number is non-zero, then
 *	multiple samples of data can be grouped into a single chunk within
 *	the file.  If it is zero, each sample of data (such as a video
 *	frame) must be in a separate chunk.
 *
 *	For video streams, this number is typically zero, although it
 *	can be non-zero if all video frames are the same size.
 *
 *	For audio streams, this number should be the same as the
 *	<e WAVEFORMATEX.nBlockAlign> field of the <t WAVEFORMATEX> structure
 *	describing the audio.
 *
 ****************************************************************************/
typedef struct {
    FOURCC		fccType;
    FOURCC		fccHandler;
    DWORD		dwFlags;	/* Contains AVITF_* flags */
    WORD		wPriority;
    WORD		wLanguage;
    DWORD		dwInitialFrames;
    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwStart;
    DWORD		dwLength; /* In units above... */

    // new....
    DWORD		dwSuggestedBufferSize;
    DWORD		dwQuality;
    DWORD		dwSampleSize;
    RECT		rcFrame;    /* does each frame need this? */

    /* additional type-specific data goes in StreamInfo chunk */
    
    /* For video: position within rectangle... */
    /* For audio: volume?  stereo channel? */
} AVIStreamHeader;

typedef struct {
    RECT    rcFrame;
} AVIVideoStreamInfo;

typedef struct {
    WORD    wLeftVolume;    // !!! Range?
    WORD    wRightVolume;
    DWORD   dwLanguage;	    // !!! Is there a standard representation of this?
} AVIAudioStreamInfo;


#define AVIIF_LIST          0x00000001L // chunk is a 'LIST'
#define AVIIF_TWOCC         0x00000002L // ckid is a TWOCC?
#define AVIIF_KEYFRAME      0x00000010L // this frame is a key frame.
#define AVIIF_FIRSTPART     0x00000020L // this frame is the start of a partial frame.
#define AVIIF_LASTPART      0x00000040L // this frame is the end of a partial frame.
#define AVIIF_MIDPART       (AVIIF_LASTPART|AVIIF_FIRSTPART)
#define AVIIF_NOTIME	    0x00000100L // this frame doesn't take any time

#define AVIIF_COMPUSE       0x0FFF0000L // these bits are for compressor use

/*****************************************************************************
 * @doc EXTERNAL AVI_FFMT
 * 
 * @types AVIINDEXENTRY | The AVI file index consists of an array
 *	of <t AVIINDEXENTRY> structures contained within an 'idx1'
 *	chunk at the end of an AVI file. This chunk follows the main LIST 'movi'
 *	chunk which contains the actual data.
 * 
 * @field DWORD | ckid | Specifies a four-character code corresponding 
 *    to the chunk ID of a data chunk in the file.
 *
 * @field DWORD | dwFlags | Specifies any applicable flags. 
 *    The flags in the low-order word are reserved for AVI, 
 *    while those in the high-order word can be used
 *    for stream- and compressor/decompressor-specific information.
 *    
 *	The following values are currently defined:
 *
 *	@flag AVIIF_LIST | Indicates the specified
 *		chunk is a 'LIST' chunk, and the <e AVIINDEXENTRY.ckid>
 *		field contains the list type of the chunk.
 *
 *	@flag AVIIF_KEYFRAME | Indicates this chunk
 *		is a key frame. Key frames do not require
 *		additional preceding chunks to be properly decoded.
 *
 *	@flag AVIIF_NOTIME | Indicates this chunk should have no effect
 *		on timing or calculating time values based on the number of chunks.
 *		For example, palette change chunks in a video stream
 *		should have this flag set, so that they are not counted
 *		as taking up a frame's worth of time.
 *
 * @field DWORD | dwChunkOffset | Specifies the position in the file of the 
 *    specified chunk. The position value includes the eight byte RIFF header.
 *
 * @field DWORD | dwChunkLength | Specifies the length of the 
 *    specified chunk. The length value does not include the eight
 *    byte RIFF header.
 *
 ****************************************************************************/
typedef struct
{
    DWORD		ckid;
    DWORD		dwFlags;
    DWORD		dwChunkOffset;		// Position of chunk
    DWORD		dwChunkLength;		// Length of chunk
} AVIINDEXENTRY;


/*
** Palette change chunk
**
** Used in video streams.
*/
typedef struct 
{
    BYTE		bFirstEntry;	/* first entry to change */
    BYTE		bNumEntries;	/* # entries to change (0 if 256) */
    WORD		wFlags;		/* Mostly to preserve alignment... */
    PALETTEENTRY	peNew[];	/* New color specifications */
} AVIPALCHANGE;

/*****************************************************************************
 * @doc EXTERNAL AVI_FFMT
 * 
 * @types AVIPALCHANGE | The <t AVIPALCHANGE> structure is used in 
 *	video streams containing palettized data to indicate the
 *	palette should change for subsequent video data.
 * 
 * @field BYTE | bFirstEntry | Specifies the first palette entry to change.
 *
 * @field BYTE | bNumEntries | Specifies the number of entries to change.
 * 
 * @field WORD | wFlags | Reserved. (This should be set to 0.)
 * 
 * @field PALETTEENTRY | peNew | Specifies an array of new palette entries.
 *
 ****************************************************************************/

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif /* INC_AVIFFMT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\aviplay.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   aviplay.c - Code for actually playing AVI files, part of
	       AVI's background task.

*****************************************************************************/
#include "graphic.h"

#define AVIREADMANY             // read more than one record at a time

#ifdef WIN32
//#define AVIREAD               // multi-threaded async read of file
#else
#undef AVIREAD
#endif

#ifdef AVIREAD
#include "aviread.h"
#endif

#define BOUND(x, low, high)     max(min(x, high), low)

#define ALIGNULONG(i)     ((i+3)&(~3))                  /* ULONG aligned ! */

//
// redefine StreamFromFOURCC to only handle 0-9 streams!
//
#undef StreamFromFOURCC
#define StreamFromFOURCC(fcc) (UINT)(HIBYTE(LOWORD(fcc)) - (BYTE)'0')

#ifdef DEBUG
static char szBadFrame[] = "Bad frame number";
static char szBadPos[]   = "Bad stream position";
#define AssertFrame(i)   AssertSz((long)(i) <= npMCI->lFrames && (long)(i) >= -(long)npMCI->wEarlyRecords, szBadFrame)
#define AssertPos(psi,i) AssertSz((long)(i) <= psi->lEnd && (long)(i) >= psi->lStart, szBadPos)
#else
#define AssertFrame(i)
#define AssertPos(psi,i)
#endif

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)

LONG NEAR PASCAL WhatFrameIsItTimeFor(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL TimeToQuit(NPMCIGRAPHIC npMCI);

void NEAR PASCAL FindKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos);
LONG NEAR PASCAL FindPrevKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos);
LONG NEAR PASCAL FindNextKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos);

BOOL NEAR PASCAL CalculateTargetFrame(NPMCIGRAPHIC npMCI);
DWORD NEAR PASCAL CalculatePosition(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL ReadRecord(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL ReadNextVideoFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi);
DWORD NEAR PASCAL ReadNextChunk(NPMCIGRAPHIC npMCI);

BOOL NEAR PASCAL ReadBuffer(NPMCIGRAPHIC npMCI, LONG off, LONG len);
BOOL NEAR PASCAL AllocateReadBuffer(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL ResizeReadBuffer(NPMCIGRAPHIC npMCI, DWORD dwNewSize);
void NEAR PASCAL ReleaseReadBuffer(NPMCIGRAPHIC npMCI);

BOOL NEAR PASCAL ProcessPaletteChanges(NPMCIGRAPHIC npMCI, LONG lFrame);

void DealWithOtherStreams(NPMCIGRAPHIC npMCI, LONG lFrame);
BOOL NEAR PASCAL StreamRead(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos);

static LPVOID AllocMem(DWORD dw);
#ifndef WIN32
#define FreeMem(lp) GlobalFree((HGLOBAL)SELECTOROF(lp))
#else
#define FreeMem(lp) GlobalFreePtr(lp)
#endif

INT     gwSkipTolerance = 4;
INT     gwHurryTolerance = 2;
INT     gwMaxSkipEver = 60;
#define YIELDEVERY      8

#ifdef DEBUG
#define WAITHISTOGRAM           /* Extra debugging information */
#define SHOWSKIPPED
//#define BEHINDHIST
#define DRAWTIMEHIST
#define READTIMEHIST
#define TIMEPLAY
#endif

#ifdef WAITHISTOGRAM
    UINT        wHist[100];
#endif


#ifdef SHOWSKIPPED
#define NUMSKIPSSHOWN   25
    LONG        lSkipped[NUMSKIPSSHOWN];
    UINT        wSkipped = 0;
#endif
#ifdef BEHINDHIST
#define NUMBEHIND       50
#define BEHINDOFFSET    10
    WORD        wBehind[NUMBEHIND];
#endif
#ifdef DRAWTIMEHIST
#define NUMDRAWN        100
    DWORD       dwDrawTime[NUMDRAWN];
    UINT        wDrawn;
#endif
#ifdef READTIMEHIST
#define NUMREAD        100
    DWORD       dwReadTime[NUMREAD];
    UINT        wRead;
#endif

#ifdef AVIREAD
/*
 * the aviread object creates a worker thread to read the file
 * asynchronously. That thread calls this callback function
 * to actually read a buffer from the file. The 'instance data' DWORD in
 * this case is npMCI. see aviread.h for outline.
 */
BOOL mciaviReadBuffer(PBYTE pData, DWORD dwInstanceData, long lSize, long * lpNextSize)
{
    NPMCIGRAPHIC npMCI = (NPMCIGRAPHIC) dwInstanceData;
    DWORD size;
    DWORD UNALIGNED * lp;

    if(mmioRead(npMCI->hmmio, pData, lSize) != lSize) {
	return(FALSE);
    }

    /* we've read in the complete chunk, plus the FOURCC, size and formtype of
     * the next chunk. So the size of the next chunk is the last but one
     * DWORD in this buffer
     */
    lp = (DWORD UNALIGNED *) (pData + lSize - 2 * sizeof(DWORD));
    size = *lp;

    /* don't forget to add on the FOURCC and size dwords */
    *lpNextSize = size + 2 * sizeof(DWORD);

    return(TRUE);
}
#endif

DWORD NEAR PASCAL PrepareToPlay(NPMCIGRAPHIC npMCI);
void  NEAR PASCAL CleanUpPlay(NPMCIGRAPHIC npMCI);
void  NEAR PASCAL CheckSignals(NPMCIGRAPHIC npMCI, LONG lFrame);

BOOL  NEAR PASCAL PlayNonInterleaved(NPMCIGRAPHIC npMCI);
BOOL  NEAR PASCAL PlayInterleaved(NPMCIGRAPHIC npMCI);
BOOL  NEAR PASCAL PlayAudioOnly(NPMCIGRAPHIC npMCI);
BOOL  NEAR PASCAL PlayNonIntFromCD(NPMCIGRAPHIC npMCI);

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api UINT | mciaviPlayFile | Play an AVI file.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc Notification code that should be returned.
 *
 ***************************************************************************/

UINT NEAR PASCAL mciaviPlayFile (NPMCIGRAPHIC npMCI)
{
    BOOL        fContinue;
    DWORD       dwFlags = npMCI->dwFlags;

    BOOL (NEAR PASCAL *Play)(NPMCIGRAPHIC npMCI);

#ifdef WAITHISTOGRAM
    UINT        w;
#endif
#ifdef SHOWSKIPPED
    wSkipped = 0;
#endif
#ifdef WAITHISTOGRAM
    for (w = 0; (int)w < (sizeof(wHist)/sizeof(wHist[0])); w++)
	wHist[w] = 0;
#endif
#ifdef BEHINDHIST
    for (w = 0; w < NUMBEHIND; w++)
	wBehind[w] = 0;
#endif
#ifdef DRAWTIMEHIST
    wDrawn = 0;
    for (w = 0; w < NUMDRAWN; w++)
	dwDrawTime[w] = 0;
#endif
#ifdef READTIMEHIST
    wRead = 0;
    for (w = 0; w < NUMREAD; w++)
	dwReadTime[w] = 0;
#endif

Repeat:
    Assert(npMCI->wTaskState == TASKSTARTING);

    TIMEZERO(timePlay);
    TIMEZERO(timePrepare);
    TIMEZERO(timeCleanup);
    TIMEZERO(timePaused);
    TIMEZERO(timeRead);
    TIMEZERO(timeWait);
    TIMEZERO(timeYield);
    TIMEZERO(timeVideo);
    TIMEZERO(timeOther);
    TIMEZERO(timeAudio);
    TIMEZERO(timeDraw);
    TIMEZERO(timeDecompress);

    TIMESTART(timePrepare);
    npMCI->dwTaskError = PrepareToPlay(npMCI);
    TIMEEND(timePrepare);

    //
    //  pick a play function.
    //
    switch (npMCI->wPlaybackAlg) {
	case MCIAVI_ALG_INTERLEAVED:
	    Play = PlayInterleaved;
	    break;

	case MCIAVI_ALG_CDROM:
	    Play = PlayNonIntFromCD;
	    break;

	case MCIAVI_ALG_HARDDISK:
	    Play = PlayNonInterleaved;
	    break;

	case MCIAVI_ALG_AUDIOONLY:
	    Play = PlayAudioOnly;
	    break;
	
	default:
	    Assert(0);
	    return MCI_NOTIFY_ABORTED; //???
    }

    // bias lTo by dwBufferedVideo so we play to the right place
    npMCI->lTo += npMCI->dwBufferedVideo;

    npMCI->lFramePlayStart = npMCI->lRealStart;

    DPF(("Playing from %ld to %ld, starting at %ld.\n", npMCI->lFrom, npMCI->lTo, npMCI->lCurrentFrame));

    if (npMCI->dwTaskError != 0L)
	goto SKIP_PLAYING;

    /* We're done initializing; now we're warming up to play. */
    npMCI->wTaskState = TASKCUEING;

    TIMESTART(timePlay);

    /* Loop until things are done */
    while (1) {

	if (npMCI->dwFlags & MCIAVI_REVERSE) {
	    if (npMCI->lCurrentFrame < npMCI->lTo)
		break;
	} else {
            if (npMCI->lCurrentFrame > npMCI->lTo)
		break;
	}

	if ((npMCI->wTaskState != TASKPLAYING) &&
		!(npMCI->dwFlags & MCIAVI_UPDATING)) {

	    TIMESTART(timeYield);
	    aviTaskYield();
	    TIMEEND(timeYield);
	}

	fContinue = Play(npMCI);
		
	if (!fContinue)
	    break;

	if (TimeToQuit(npMCI))
	    break;
	
	//
	//  while playing we may need to update
	//
	//  always mark the movie as clean, even if a stream fails to update
	//  otherwise we will need to stop play and restart.
	//
	if (!(npMCI->dwFlags & MCIAVI_SEEKING) &&
	     (npMCI->dwFlags & MCIAVI_NEEDUPDATE)) {
	    DoStreamUpdate(npMCI, FALSE);

	    if (npMCI->dwFlags & MCIAVI_NEEDUPDATE) {
		DOUT("Update failed while playing, I dont care!\n");
		npMCI->dwFlags &= ~MCIAVI_NEEDUPDATE;   //!!! I dont care if it failed
	    }
	}

	/* Increment the frame number.  If we're done, don't increment
	** it an extra time, but just get out.
	*/
	if (npMCI->dwFlags & MCIAVI_REVERSE) {
	    if (npMCI->lCurrentFrame > npMCI->lTo)
		--npMCI->lCurrentFrame;
	    else
		break;
	} else {
            if (npMCI->lCurrentFrame < npMCI->lTo)
		++npMCI->lCurrentFrame;
	    else
		break;
	}
    }

    TIMEEND(timePlay);

    if (npMCI->lCurrentFrame != npMCI->lTo) {

	DPF(("Ended at %ld, not %ld (drawn = %ld).\n", npMCI->lCurrentFrame, npMCI->lTo, npMCI->lFrameDrawn));

	//
	// if we ended early lets set lCurrentFrame to the last frame
	// drawn to guarentee we can re-paint the frame, we dont
	// want to do this when we play to end because after playing
	// from A to B the current position *must* be B or preston will
	// enter a bug.
	//
	// but only set this if lFrameDraw is valid
	//

	if (npMCI->lFrameDrawn > (-(LONG)npMCI->wEarlyRecords))
	    npMCI->lCurrentFrame = npMCI->lFrameDrawn;
    }

SKIP_PLAYING:
    /* Flush any extra changes out to screen */

    DPF2(("Updating unfinished changes....\n"));

    // Make sure we really draw.... !!!do we need this?
    // npMCI->lRealStart = npMCI->lCurrentFrame;

    if (npMCI->hdc)
	DoStreamUpdate(npMCI, FALSE);

    // !!! should we set npMCI->lCurrentFrame = npMCI->lFrameDrawn?
    ///!!!npMCI->lCurrentFrame = npMCI->lFrameDrawn;

    // !!! Should we update npMCI->lFrom to be npMCI->lCurrentFrame,
    // to make that the default location play will start from next?
	
//SKIP_PLAYING:
    npMCI->lTo -= npMCI->dwBufferedVideo;
    npMCI->lCurrentFrame -= npMCI->dwBufferedVideo;
    npMCI->dwBufferedVideo = 0;

    if (npMCI->lCurrentFrame < 0) {
	DPF2(("Adjusting position to be >= 0.\n"));
	npMCI->lCurrentFrame = 0;
    }

    if (npMCI->lTo < 0)
        npMCI->lTo = 0;

    /* Adjust position to be > start? */
    /* Adjust position to be > where it was when we began? */

    npMCI->dwTotalMSec += Now() - npMCI->dwMSecPlayStart;

    TIMESTART(timeCleanup);
    CleanUpPlay(npMCI);
    TIMEEND(timeCleanup);

#ifdef AVIREAD
    /* shut down async reader */
    if (npMCI->hAviRd) {
	avird_endread(npMCI->hAviRd);
	npMCI->hAviRd = NULL;
    }
#endif

    /* If we're repeating, do it.  It sure would be nice if we could repeat
    ** without de-allocating and then re-allocating all of our buffers....
    */
    if (npMCI->dwTaskError == 0 && (!(npMCI->dwFlags & MCIAVI_STOP)) &&
		(npMCI->dwFlags & MCIAVI_REPEATING)) {
	npMCI->lFrom = npMCI->lRepeatFrom;

	//
	//  DrawEnd() likes to clear this flag so make sure it gets set
	//  in the repeat case.
	//
	if (dwFlags & MCIAVI_FULLSCREEN)
	    npMCI->dwFlags |= MCIAVI_FULLSCREEN;

        //
        // make sure we set the task state back before we repeat.
        // otherwise our code will think we are playing, for example.
        // if the audio code thinks we are playing and see's the wave buffers
        // are empty it will reset the wave device then restart it when
        // they get full again, this is bad if we are pre-rolling audio.
        //
        npMCI->wTaskState = TASKSTARTING;
	goto Repeat;
    }

    /* Turn off flags only used during play. */
    npMCI->dwFlags &= ~(MCIAVI_STOP | MCIAVI_PAUSE | MCIAVI_SEEKING |
	    MCIAVI_REPEATING | MCIAVI_FULLSCREEN);

    if (npMCI->wTaskState == TASKPLAYING) {
	DWORD   dwCorrectTime;
	DWORD   dwFramesPlayed;

	dwFramesPlayed = (npMCI->dwFlags & MCIAVI_REVERSE) ?
	    npMCI->lFramePlayStart - npMCI->lCurrentFrame :
	    npMCI->lCurrentFrame - npMCI->lFramePlayStart;

	dwCorrectTime = muldiv32(dwFramesPlayed,
				muldiv32(npMCI->dwMicroSecPerFrame,
					1000L,
					(npMCI->dwSpeedFactor == 0 ?
						1000 : npMCI->dwSpeedFactor)),
				1000);

	if (dwCorrectTime != 0 && npMCI->dwTotalMSec != 0)
	    npMCI->dwSpeedPercentage = muldiv32(dwCorrectTime, 100,
						npMCI->dwTotalMSec);
	else
	    npMCI->dwSpeedPercentage = 100;

	if (dwFramesPlayed > 15) {
	    npMCI->lFramesPlayed      = (LONG)dwFramesPlayed;
	    npMCI->lFramesSeekedPast  = (LONG)npMCI->dwFramesSeekedPast;
	    npMCI->lSkippedFrames     = (LONG)npMCI->dwSkippedFrames;
	    npMCI->lAudioBreaks       = (LONG)npMCI->dwAudioBreaks;
	}

#ifdef DEBUG
	if (npMCI->dwFramesSeekedPast) {
	    DPF(("Didn't even read %ld frames.\n", npMCI->dwFramesSeekedPast));
	}
	if (npMCI->dwSkippedFrames && dwFramesPlayed > 0) {
	    DPF(("Skipped %ld of %ld frames. (%ld%%)\n",
			npMCI->dwSkippedFrames, dwFramesPlayed,
			npMCI->dwSkippedFrames*100/dwFramesPlayed));
	}
	if (npMCI->dwAudioBreaks) {
	    DPF(("Audio broke up %lu times.\n", npMCI->dwAudioBreaks));
	}
#ifndef TIMEPLAY
	DPF(("Played at %lu%% of correct speed.\n", npMCI->dwSpeedPercentage));
	DPF(("Correct time = %lu ms, Actual = %lu ms.\n",
				    dwCorrectTime, npMCI->dwTotalMSec));
#endif
#endif
#ifdef SHOWSKIPPED
	if (wSkipped) {
	    DPF(("Skipped: "));
	    for (w = 0; w < wSkipped; w++) {
		DPF(("%ld ", lSkipped[w]));
	    }
	    DPF(("\n"));
	}
#endif
	
#ifdef WAITHISTOGRAM
	if (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED) {
	    DPF(("Wait histogram: "));
	    for (w = 0; (int)w <= (int)npMCI->wABs; w++) {
		if (wHist[w]) {
		    DPF(("[%d]: %d  ",w,wHist[w]));
		}
	    }
	    DPF(("\n"));
	}
#endif
#ifdef BEHINDHIST
	DPF(("Behind histogram: "));
	for (w = 0; w <= NUMBEHIND; w++) {
	    if (wBehind[w]) {
		DPF(("[%d]: %d  ",w - BEHINDOFFSET,wBehind[w]));
	    }
	}
	DPF(("\n"));
#endif
#ifdef DRAWTIMEHIST
	DPF(("Draw times: "));
	for (w = 0; w < wDrawn; w++) {
	    DPF(("%lu ", dwDrawTime[w]));
	}
	DPF(("\n"));
#endif

#ifdef READTIMEHIST
	DPF(("Read times: "));
	for (w = 0; w < wRead; w++) {
	    DPF(("%lu ", dwReadTime[w]));
	}
	DPF(("\n"));
#endif

#ifdef TIMEPLAY
	#define SEC(time)    (UINT)(npMCI->time / 1000l) , (UINT)(npMCI->time % 1000l)
	#define SECX(time,t) SEC(time) , (npMCI->t ? (UINT)(npMCI->time * 100l / npMCI->t) : 0)

	DPF(("***********************************************************\r\n"));
	DPF(("    timePlay:         %3d.%03dsec\r\n",SEC(timePlay)));
	DPF(("     timeRead:        %3d.%03dsec (%d%%)\r\n",SECX(timeRead, timePlay)));
	DPF(("     timeWait:        %3d.%03dsec (%d%%)\r\n",SECX(timeWait, timePlay)));
	DPF(("     timeYield:       %3d.%03dsec (%d%%)\r\n",SECX(timeYield, timePlay)));
	DPF(("     timeVideo:       %3d.%03dsec (%d%%)\r\n",SECX(timeVideo, timePlay)));
	DPF(("      timeDraw:       %3d.%03dsec (%d%%)\r\n",SECX(timeDraw, timeVideo)));
	DPF(("      timeDecompress: %3d.%03dsec (%d%%)\r\n",SECX(timeDecompress, timeVideo)));
	DPF(("     timeAudio:       %3d.%03dsec (%d%%)\r\n",SECX(timeAudio, timePlay)));
	DPF(("     timeOther:       %3d.%03dsec (%d%%)\r\n",SECX(timeOther, timePlay)));
	DPF(("    timePaused:       %3d.%03dsec\r\n",SEC(timePaused)));
	DPF(("    timePrepare:      %3d.%03dsec\r\n",SEC(timePrepare)));
	DPF(("    timeCleanup:      %3d.%03dsec\r\n",SEC(timeCleanup)));
	DPF(("***********************************************************\r\n"));
#endif
    }

    if (npMCI->dwTaskError)
	return MCI_NOTIFY_FAILURE;

    if (npMCI->dwFlags & MCIAVI_REVERSE) {
	if (npMCI->lCurrentFrame <= npMCI->lTo)
	    return MCI_NOTIFY_SUCCESSFUL;
    } else {
	if (npMCI->lCurrentFrame >= npMCI->lTo)
	    return MCI_NOTIFY_SUCCESSFUL;
    }

    return MCI_NOTIFY_ABORTED;
}

BOOL NEAR PASCAL RestartAVI(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL PauseAVI(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL BePaused(NPMCIGRAPHIC npMCI);

/******************************************************************************
 *****************************************************************************/

#ifdef DEBUG

INLINE void FillR(HDC hdc, LPRECT prc, DWORD rgb)
{
    SetBkColor(hdc,rgb);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL);
}

void StatusBar(NPMCIGRAPHIC npMCI, int n, int dx, int max, int cur)
{
    HDC hdc;
    RECT rc;

    if (npMCI->dwFlags & MCIAVI_FULLSCREEN)
	return;

    if (cur > max)
        cur = max+1;

    if (cur < 0)
        cur = 0;

    hdc = GetWindowDC(npMCI->hwnd);

    //
    //  show the amount of audio and how far behind we are
    //
    rc.left = 32;
    rc.top  = 4 + n*5;
    rc.bottom = rc.top + 4;

    rc.right = rc.left + cur * dx;

    FillR(hdc, &rc, RGB(255,255,0));

    rc.left = rc.right;
    rc.right = rc.left + (max - cur) * dx;

    FillR(hdc, &rc, RGB(255,0,0));

    ReleaseDC(npMCI->hwnd, hdc);
}

#else

#define StatusBar(p,a,b,c,d)

#endif

/******************************************************************************
 *****************************************************************************/

BOOL NEAR PASCAL PlayInterleaved(NPMCIGRAPHIC npMCI)
{
    LONG iFrame;
    LONG iKey;
    LONG iNextKey;
    LONG iPrevKey;
    BOOL fHurryUp=FALSE;
    int  iHurryUp=0;
    BOOL fPlayedAudio = FALSE;
    BOOL f;

    BOOL NEAR PASCAL WaitTillNextFrame(NPMCIGRAPHIC npMCI);

    /* If lCurrentFrame == lFrames, we're really at the end of
    ** the file, so there isn't another record to read.
    */
    if (npMCI->lCurrentFrame < npMCI->lFrames) {
	/* Read new record into buffer */

        DPF2(("Reading", iFrame = (LONG)timeGetTime()));
	TIMESTART(timeRead);
	f = ReadRecord(npMCI);
	TIMEEND(timeRead);
        DPF2((".done %ldms\n", (LONG)timeGetTime() - iFrame));

	if (!f) {
	    npMCI->dwTaskError = MCIERR_INVALID_FILE;
	    DPF(("Error reading frame #%ld\n", npMCI->lCurrentFrame));
	    return FALSE;
	}

#ifdef JUMPINTERLEAVED
	if (npMCI->hWave && npMCI->wABFull == 0 &&
		npMCI->wTaskState == TASKPLAYING &&
		(npMCI->dwOptionFlags & MCIAVIO_SKIPFRAMES)) {
	    LONG lTemp;
	    // !!! figure out how far ahead to skip!

	    PauseAVI(npMCI);
	    npMCI->lFrom = npMCI->lCurrentFrame;

	    npMCI->lFrom += npMCI->wABs;

	    npMCI->lFrom += (((Now() - npMCI->dwTimingStart) * 1000L)
					    - npMCI->dwNextFrameMicroSec) /
					npMCI->dwPlayMicroSecPerFrame;

	    lTemp = FindNextKeyFrame(npMCI, npMCI->lFrom);

	    if (lTemp >= npMCI->lFrom)
		npMCI->lFrom = lTemp;
	
	    if (npMCI->lFrom > npMCI->lFrames - 1)
		npMCI->lFrom = npMCI->lFrames - 1;

	    DPF2(("Interleaved: jumping from %ld to %ld\n", npMCI->lCurrentFrame, npMCI->lFrom));
	    CalculateTargetFrame(npMCI);
	    return TRUE;
	}
#endif
	
	if (npMCI->hWave && npMCI->lCurrentFrame >= npMCI->lAudioStart) {
	    TIMESTART(timeAudio);
	    if (!PlayRecordAudio(npMCI, &fHurryUp, &fPlayedAudio)) {
		DPF(("Error playing frame #%ld audio\n", npMCI->lCurrentFrame));
		return FALSE;
	    }
	    TIMEEND(timeAudio);
	}
    }

    /* If we're at the right frame, and we haven't started yet,
    ** then begin play and start timing.
    */

    if ((npMCI->lCurrentFrame > npMCI->lRealStart + (LONG) npMCI->dwBufferedVideo) &&
			(npMCI->wTaskState != TASKPLAYING)) {
	if (!(npMCI->dwFlags & MCIAVI_PAUSE)) {
	    goto RestartPlay0;
	} else
	    goto PauseNow0;
    }

    if (npMCI->wTaskState == TASKPLAYING) {
	if (npMCI->dwFlags & MCIAVI_PAUSE) {
PauseNow0:              
	    PauseAVI(npMCI);

#ifndef WIN32
// no way do we want to do this on NT.  If you get a slow disk, you will
// never get to pause because we can't get the stuff in fast enough to keep up
	    /* The line below says that if we're trying to pause,
	    ** but we're behind on our audio, we should keep playing
	    ** for a little bit so that our audio buffers get full.
	    ** Unfortunately, the current code causes the code
	    ** above to get called over and over, which is bad.
	    */
	    if (fPlayedAudio && npMCI->wABFull < npMCI->wABs)
		goto KeepFilling;
#endif




	    BePaused(npMCI);
	
RestartPlay0:           
	    if (npMCI->dwFlags & MCIAVI_STOP)
		return FALSE;
	
	    RestartAVI(npMCI);
	}
    }

KeepFilling:
    if (npMCI->lCurrentFrame > npMCI->lVideoStart &&
        npMCI->lCurrentFrame < npMCI->lFrames &&
	npMCI->wTaskState == TASKPLAYING) {

        iFrame = WhatFrameIsItTimeFor(npMCI);

        if (iFrame >= npMCI->lFrames)
            goto dontskip;

	iHurryUp = (int)(iFrame - npMCI->lCurrentFrame);
	fHurryUp = iHurryUp > gwHurryTolerance;

//      if (iHurryUp > gwSkipTolerance && !npMCI->hpFrameIndex)
//           DPF("We should read the index?\n");

	if (iHurryUp > 1 && npMCI->hpFrameIndex && (npMCI->dwOptionFlags & MCIAVIO_SKIPFRAMES)) {

	    //
	    //  WE ARE BEHIND!!! by one or more frames.
	    //
	    //  if we are late we can do one of the following:
	    //
	    //      dont draw frames but keep reading/decompressing them
	    //      (ie set fHurryUp)
	    //
	    //      skip ahead to a key frame.
	    //
	    // !!! If we're very close to the next key frame, be more
	    // willing to skip ahead....
            //

            if (iHurryUp > gwSkipTolerance) {

                iNextKey = FrameNextKey(iFrame);
                iPrevKey = FramePrevKey(iFrame);

		if (iPrevKey > npMCI->lCurrentFrame &&
		    iFrame - iPrevKey < gwHurryTolerance &&
		    iNextKey - iFrame > gwSkipTolerance) {

		    DPF2(("Skipping from %ld to PREV KEY %ld (time for %ld next key=%ld).\n", npMCI->lCurrentFrame, iPrevKey, iFrame, iNextKey));
		    iKey = iPrevKey;
		}
		// !!! We'll only skip if the key frame is at most as far
		// ahead as we are behind.....
		else if (iNextKey > npMCI->lCurrentFrame &&
                    iNextKey <= iFrame + gwSkipTolerance /*gwMaxSkipEver*/) {
		    DPF2(("Skipping from %ld to NEXT KEY %ld (time for %ld prev key=%ld).\n", npMCI->lCurrentFrame, iNextKey, iFrame, iPrevKey));
		    iKey = iNextKey;
		} else {
                    DPF2(("WANTED to skip from %ld to %ld (time for %ld)!\n", npMCI->lCurrentFrame,iNextKey,iFrame));
		    goto dontskip;
		}

		npMCI->lVideoStart = iKey;
                npMCI->dwSkippedFrames += iKey - npMCI->lCurrentFrame;
dontskip:
		fHurryUp = TRUE;
	    }
	    else {
		iKey = FrameNextKey(npMCI->lCurrentFrame);

		if (iKey - npMCI->lCurrentFrame > 0 &&
                    iKey - npMCI->lCurrentFrame <= gwHurryTolerance) {
		    DPF2(("Skipping from %ld to next key frame %ld (time for %ld).\n", npMCI->lCurrentFrame, iKey, iFrame));

		    npMCI->dwSkippedFrames += iKey - npMCI->lCurrentFrame;
		    npMCI->lVideoStart = iKey;
		    fHurryUp = TRUE;
		}
	    }
	}
    }

    if (npMCI->dwFlags & MCIAVI_WAVEPAUSED)
	fHurryUp = TRUE;

    /* If we've actually started timing:
    **  Check if we should send a signal.
    **  Check to see if we should break out of the loop.
    **  Wait until it's time for the next frame.
    */
    if (npMCI->wTaskState == TASKPLAYING &&
        npMCI->lCurrentFrame >= npMCI->lVideoStart) {

	if (npMCI->dwSignals)
	    CheckSignals(npMCI, npMCI->lCurrentFrame - npMCI->dwBufferedVideo);

#ifdef WAITHISTOGRAM
	/* Adjust to achieve proper tension. */
	if (fPlayedAudio) {
	    /* If we're playing, keep statistics about how we're doing. */
	    ++wHist[npMCI->wABFull];
	}
#endif

        if (!WaitTillNextFrame(npMCI))
            return FALSE;
    }

    if (npMCI->lCurrentFrame >= npMCI->lVideoStart &&
        npMCI->lCurrentFrame < npMCI->lFrames) {

#ifdef SHOWSKIPPED
	if (fHurryUp && wSkipped < NUMSKIPSSHOWN) {
	    lSkipped[wSkipped++] = npMCI->lCurrentFrame;
	}
#endif
        /* hold critsec round all worker thread drawing */
	EnterCrit(npMCI);
	TIMESTART(timeVideo);
	if (!DisplayVideoFrame(npMCI, fHurryUp)) {
	    LeaveCrit(npMCI);
	    npMCI->dwTaskError = MCIERR_AVI_DISPLAYERROR;
	    return FALSE;
	}
	TIMEEND(timeVideo);
        LeaveCrit(npMCI);

#ifdef DRAWTIMEHIST
	if (!fHurryUp && (wDrawn < NUMDRAWN)) {
	    dwDrawTime[wDrawn++] = npMCI->dwLastDrawTime;
	}
#endif
    }

    StatusBar(npMCI, 0, 4, npMCI->wABs, npMCI->wABFull);
    StatusBar(npMCI, 1, 4, npMCI->wABs, npMCI->wABs - iHurryUp);

#ifdef AVIREAD
    if ((npMCI->hAviRd) && (npMCI->lpBuffer != NULL)) {
	/* finished with this buffer - put back on queue */
	avird_emptybuffer(npMCI->hAviRd, npMCI->lpBuffer);
	npMCI->lpBuffer = NULL;
    }
#endif

    return TRUE;
}

/******************************************************************************
 *****************************************************************************/

BOOL NEAR PASCAL PlayNonInterleaved(NPMCIGRAPHIC npMCI)
{
    BOOL fHurryUp = FALSE;
    int  iHurryUp;
    LONG iFrame;
    LONG iKey;
    LONG iNextKey;
    LONG iPrevKey;

    if (npMCI->hWave) {
	TIMESTART(timeAudio);
	KeepPlayingAudio(npMCI);
	TIMEEND(timeAudio);
    }

    if (npMCI->wTaskState == TASKPLAYING) {

        iFrame = WhatFrameIsItTimeFor(npMCI);

        if (iFrame >= npMCI->lFrames)
            goto dontskip;

	if (npMCI->dwFlags & MCIAVI_REVERSE) {

	    /* Since we're going backwards, always skip to key frame. */
	    DPF3(("  Current = %ld, time for %ld.\n", npMCI->lCurrentFrame, iFrame));
		
	    iFrame = FramePrevKey(iFrame);
		
	    // !!! Send signals for skipped frames?
	    npMCI->dwFramesSeekedPast += npMCI->lCurrentFrame - iFrame;
	    npMCI->dwSkippedFrames += npMCI->lCurrentFrame - iFrame;
	    npMCI->lCurrentFrame = iFrame;
        } else if (npMCI->lCurrentFrame < npMCI->lFrames) {

#ifdef BEHINDHIST
	    {
	    int      iDelta;
	    iDelta = iFrame - npMCI->lCurrentFrame + BEHINDOFFSET;
	    iDelta = min(NUMBEHIND, max(0, iDelta));
	    wBehind[iDelta]++;
	    }
#endif
	    iHurryUp = (int)(iFrame - npMCI->lCurrentFrame);
	    fHurryUp = iHurryUp > gwHurryTolerance;

	    if (iHurryUp > 1 && npMCI->hpFrameIndex && (npMCI->dwOptionFlags & MCIAVIO_SKIPFRAMES)) {

		//
		//  WE ARE BEHIND!!! by one or more frames.
		//
		//  if we are late we can do one of the following:
		//
		//      dont draw frames but keep reading/decompressing them
		//      (ie set fHurryUp)
		//
		//      skip ahead to a key frame.
		//
                // !!! If we're very close to the next key frame, be more
                // willing to skip ahead....
		//
	
		if (iHurryUp > gwSkipTolerance) {

		    iNextKey = FrameNextKey(iFrame);
		    iPrevKey = FramePrevKey(iFrame);

		    if (iPrevKey > npMCI->lCurrentFrame &&
			iFrame - iPrevKey < gwHurryTolerance &&
			iNextKey - iFrame > gwSkipTolerance) {

			DPF2(("Skipping from %ld to PREV KEY %ld (time for %ld next key=%ld).\n", npMCI->lCurrentFrame, iPrevKey, iFrame, iNextKey));

			iKey = iPrevKey;
                        fHurryUp = TRUE;
		    }
		    // !!! We'll only skip if the key frame is at most as far
		    // ahead as we are behind.....
		    else if (iNextKey > npMCI->lCurrentFrame &&
                        iNextKey <= iFrame + gwSkipTolerance /*gwMaxSkipEver*/) {
			DPF2(("Skipping from %ld to NEXT KEY %ld (time for %ld prev key=%ld).\n", npMCI->lCurrentFrame, iNextKey, iFrame, iPrevKey));
			iKey = iNextKey;        // assume next key
			fHurryUp = FALSE;
		    } else {
                        DPF2(("WANTED to skip from %ld to %ld (time for %ld)!\n", npMCI->lCurrentFrame,iNextKey,iFrame));
			goto dontskip;
		    }

		    npMCI->dwFramesSeekedPast += iKey - npMCI->lCurrentFrame;
		    npMCI->dwSkippedFrames += iKey - npMCI->lCurrentFrame;
		    npMCI->lCurrentFrame = iKey;
dontskip:
		    ;
		}
		else if (FramePrevKey(iFrame) == iFrame) {
		    DPF2(("Skipping from %ld to %ld (time for key frame).\n", npMCI->lCurrentFrame, iFrame));

		    iKey = iFrame;
		    npMCI->dwFramesSeekedPast += iKey - npMCI->lCurrentFrame;
		    npMCI->dwSkippedFrames += iKey - npMCI->lCurrentFrame;
		    npMCI->lCurrentFrame = iKey;

		    fHurryUp = FALSE;
		}
		else {
		    iKey = FrameNextKey(npMCI->lCurrentFrame);

		    if (iKey > npMCI->lCurrentFrame &&
			iKey - npMCI->lCurrentFrame <= gwHurryTolerance) {
			DPF2(("Skipping from %ld to next key frame %ld (time for %ld).\n", npMCI->lCurrentFrame, iKey, iFrame));

			npMCI->dwFramesSeekedPast += iKey - npMCI->lCurrentFrame;
			npMCI->dwSkippedFrames += iKey - npMCI->lCurrentFrame;
			npMCI->lCurrentFrame = iKey;

			fHurryUp = ((iKey - iFrame) > gwHurryTolerance);
		    }
		}
            }

            StatusBar(npMCI, 0, 4, npMCI->wABs, npMCI->wABFull);
            StatusBar(npMCI, 1, 4, npMCI->wABs, npMCI->wABs - iHurryUp);
	}
    }

    // !!! Somewhere in here, read other streams.
    // Should this be before, or after, video?

    /* If lCurrentFrame == lFrames, we're really at the end of
    ** the file, so there isn't another record to read.
    */
    if (npMCI->lCurrentFrame < npMCI->lFrames) {
	/* Read new record into buffer */

	npMCI->dwLastReadTime = (DWORD)(-(LONG)timeGetTime());
	TIMESTART(timeRead);
        if (!ReadNextVideoFrame(npMCI, NULL)) {
	    npMCI->dwTaskError = MCIERR_INVALID_FILE;
	    DPF2(("Error reading frame #%ld\n", npMCI->lCurrentFrame));
	    return FALSE;
	}
	TIMEEND(timeRead);

	npMCI->dwLastReadTime += timeGetTime();
	npMCI->lLastRead = npMCI->lCurrentFrame;

#ifdef READTIMEHIST
	if (wRead < NUMREAD) {
	    dwReadTime[wRead++] = npMCI->dwLastReadTime;
    }
#endif
    }

    /* If we're at the right frame, and we haven't started yet,
    ** then begin play and start timing.
    */
    if ((((npMCI->lCurrentFrame > (npMCI->lRealStart +
					(LONG) npMCI->dwBufferedVideo)) &&
                        (npMCI->lCurrentFrame < (npMCI->lTo))) ||
		(npMCI->dwFlags & MCIAVI_REVERSE)) &&
			(npMCI->wTaskState != TASKPLAYING) &&
			!(npMCI->dwFlags & MCIAVI_SEEKING)) {
	if (!(npMCI->dwFlags & MCIAVI_PAUSE)) {
	    goto RestartPlay;
	} else
	    goto PauseNow;
    }

    /* If we've actually started timing:
    **  Check if we should send a signal.
    **  Check to see if we should return FALSE out of the loop.
    **  Wait until it's time for the next frame.
    */
    if (npMCI->wTaskState == TASKPLAYING) {
	if (npMCI->dwFlags & MCIAVI_PAUSE) {
PauseNow:               
	    PauseAVI(npMCI);
	
	    BePaused(npMCI);
	
RestartPlay:            
	    if (TimeToQuit(npMCI))
		return FALSE;
	
	    RestartAVI(npMCI);
	}

	if (npMCI->dwSignals)
	    CheckSignals(npMCI, npMCI->lCurrentFrame - npMCI->dwBufferedVideo);

	if (npMCI->lCurrentFrame < npMCI->lFrames + (LONG) npMCI->dwBufferedVideo) {
	    while (1) {
		iFrame = WhatFrameIsItTimeFor(npMCI);

		TIMESTART(timeYield);
		aviTaskYield();
		TIMEEND(timeYield);
		
		if (npMCI->dwFlags & MCIAVI_REVERSE) {
		    if (iFrame <= npMCI->lCurrentFrame)
			break;

		    if (npMCI->lCurrentFrame < npMCI->lTo)
			break;
		} else {
		    if (iFrame >= npMCI->lCurrentFrame)
			break;

                    if (npMCI->lCurrentFrame > npMCI->lTo)
			break;
		}
		
		if (npMCI->hWave) {
		    TIMESTART(timeAudio);
		    KeepPlayingAudio(npMCI);
		    TIMEEND(timeAudio);
		}

		DPF3(("Waiting:  Current = %ld, time for %ld.\n", npMCI->lCurrentFrame, iFrame));

		if (TimeToQuit(npMCI))
		    return FALSE;
	    }
	}
	
	if (TimeToQuit(npMCI))
	    return FALSE;
    }

    if (((npMCI->lCurrentFrame >= npMCI->lVideoStart) &&
	    (npMCI->lCurrentFrame < npMCI->lFrames)) ||
	(npMCI->dwFlags & MCIAVI_REVERSE)) {
	EnterCrit(npMCI);
	TIMESTART(timeVideo);
	if (!DisplayVideoFrame(npMCI, fHurryUp)) {
	    npMCI->dwTaskError = MCIERR_AVI_DISPLAYERROR;
	    LeaveCrit(npMCI);
	    return FALSE;
	}
	TIMEEND(timeVideo);
	LeaveCrit(npMCI);
#ifdef DRAWTIMEHIST
	if (!fHurryUp && (wDrawn < NUMDRAWN)) {
	    dwDrawTime[wDrawn++] = npMCI->dwLastDrawTime;
        }
#endif
    }

    //
    // now is a good time to deal with other streams
    //
    if (npMCI->nOtherStreams > 0 || npMCI->nVideoStreams > 1) {

        if (npMCI->wTaskState != TASKPLAYING)
            iFrame = npMCI->lCurrentFrame;

	TIMESTART(timeOther);
        DealWithOtherStreams(npMCI, iFrame);
	TIMEEND(timeOther);
    }

    return TRUE;
}

/******************************************************************************
 *****************************************************************************/

BOOL NEAR PASCAL PlayAudioOnly(NPMCIGRAPHIC npMCI)
{
    npMCI->lFrameDrawn = npMCI->lCurrentFrame;

    if (npMCI->hWave) {
	TIMESTART(timeAudio);
	KeepPlayingAudio(npMCI);
	TIMEEND(timeAudio);
    }

    /* If we're at the right frame, and we haven't started yet,
    ** then begin play and start timing.
    */
    if ((npMCI->wTaskState != TASKPLAYING) &&
			!(npMCI->dwFlags & MCIAVI_SEEKING)) {
	if (!(npMCI->dwFlags & MCIAVI_PAUSE)) {
	    goto RestartPlay;
	} else
	    goto PauseNow;
    }

    /* If we've actually started timing:
    **  Check if we should send a signal.
    **  Check to see if we should return FALSE out of the loop.
    **  Wait until it's time for the next frame.
    */
    if (npMCI->wTaskState == TASKPLAYING) {

	npMCI->lCurrentFrame = WhatFrameIsItTimeFor(npMCI);

	if (npMCI->dwFlags & MCIAVI_PAUSE) {
PauseNow:               
	    PauseAVI(npMCI);
	
	    BePaused(npMCI);
	
RestartPlay:            
	    if (TimeToQuit(npMCI))
		return FALSE;
	
	    RestartAVI(npMCI);
	}

	if (npMCI->dwSignals)
	    CheckSignals(npMCI, npMCI->lCurrentFrame - npMCI->dwBufferedVideo);

	//
	// dont yield if updating
	//
	if (!(npMCI->dwFlags & MCIAVI_UPDATING)) {
	    TIMESTART(timeYield);
	    aviTaskYield();
	    TIMEEND(timeYield);
	}
	
	if (TimeToQuit(npMCI))
	    return FALSE;
    }

    return TRUE;
}

/******************************************************************************
 *****************************************************************************/

#pragma message("PlayNonIntFromCD needs fixed?")

BOOL NEAR PASCAL PlayNonIntFromCD(NPMCIGRAPHIC npMCI)
{
    BOOL fHurryUp = FALSE;
    LONG lNewFrame;
    DWORD ckid;
    UINT wStream;

AnotherChunk:
    /* If lCurrentFrame == lFrames, we're really at the end of
    ** the file, so there isn't another record to read.
    */
    if (npMCI->lCurrentFrame < npMCI->lFrames) {
	/* Read new record into buffer */

	TIMESTART(timeRead);
	ckid = ReadNextChunk(npMCI);
	TIMEEND(timeRead);

	if (ckid == 0) {
	    npMCI->dwTaskError = MCIERR_INVALID_FILE;
	    DPF(("Error reading frame #%ld\n", npMCI->lCurrentFrame));
	    return FALSE;
	}

	npMCI->lLastRead = npMCI->lCurrentFrame;
	wStream = StreamFromFOURCC(ckid);

	if (wStream == (UINT) npMCI->nVideoStream) {
	    if (TWOCCFromFOURCC(ckid) == cktypePALchange) {
		npMCI->lp += 2 * sizeof(DWORD);
		ProcessPaletteChange(npMCI, npMCI->dwThisRecordSize -
							    2 * sizeof(DWORD));
		npMCI->lLastPaletteChange = npMCI->lCurrentFrame;
		goto AnotherChunk;
	    }   
	} else if (wStream == (UINT) npMCI->nAudioStream) {
	    TIMESTART(timeAudio);
	    if (npMCI->hWave)
		HandleAudioChunk(npMCI);
	    TIMEEND(timeAudio);
	    goto AnotherChunk;
	} else {
	    goto AnotherChunk;
	}
    }

    if (npMCI->wTaskState == TASKPLAYING) {
	lNewFrame = WhatFrameIsItTimeFor(npMCI);

	DPF3(("  Current = %ld, time for %ld.\n", npMCI->lCurrentFrame, lNewFrame));
	if (npMCI->lCurrentFrame < lNewFrame) {         
	    fHurryUp = TRUE;
	}
    }

    /* If we're at the right frame, and we haven't started yet,
    ** then begin play and start timing.
    */
    if ((npMCI->lCurrentFrame > npMCI->lRealStart + (LONG) npMCI->dwBufferedVideo) &&
                        (npMCI->lCurrentFrame < npMCI->lTo) &&
			(npMCI->wTaskState != TASKPLAYING)) {

	if (!(npMCI->dwFlags & MCIAVI_PAUSE)) {
	    goto RestartPlay;
	} else
	    goto PauseNow;
    }

    /* If we've actually started timing:
    **  Check if we should send a signal.
    **  Check to see if we should return FALSE out of the loop.
    **  Wait until it's time for the next frame.
    */
    if (npMCI->wTaskState == TASKPLAYING) {
	if (npMCI->dwFlags & MCIAVI_PAUSE) {
PauseNow:               
	    PauseAVI(npMCI);
	
	    BePaused(npMCI);
	
RestartPlay:            
	    if (TimeToQuit(npMCI))
		return FALSE;
	
	    RestartAVI(npMCI);
	}

	if (npMCI->dwSignals)
	    CheckSignals(npMCI, npMCI->lCurrentFrame - npMCI->dwBufferedVideo);

WaitMore:
	lNewFrame = WhatFrameIsItTimeFor(npMCI);

	TIMESTART(timeYield);
	aviTaskYield();
	TIMEEND(timeYield);

	if (lNewFrame < npMCI->lCurrentFrame) {
	    DPF3(("Waiting:  Current = %ld, time for %ld.\n", npMCI->lCurrentFrame, lNewFrame));
	    if (TimeToQuit(npMCI))
		return FALSE;
	    else
		goto WaitMore;
	}
    }

    if (npMCI->lCurrentFrame >= npMCI->lVideoStart) {
	TIMESTART(timeVideo);
	EnterCrit(npMCI);
	if (!DisplayVideoFrame(npMCI, fHurryUp)) {
	    npMCI->dwTaskError = MCIERR_AVI_DISPLAYERROR;
	    LeaveCrit(npMCI);
	    return FALSE;
	}
	TIMEEND(timeVideo);
	LeaveCrit(npMCI);
    }

    return TRUE;
}


/******************************************************************************
 *****************************************************************************/

/* This function returns what frame we should be on. */
LONG NEAR PASCAL WhatFrameIsItTimeFor(NPMCIGRAPHIC npMCI)
{
    LONG        lTime;
    LONG        lFrame;

    // If timing is off, it's always just time to play the current frame.
    if (npMCI->dwPlayMicroSecPerFrame == 0)
	return npMCI->lCurrentFrame;

    //
    // if we have not started playing npMCI->dwTimingStart is bogus
    //
    Assert(npMCI->wTaskState == TASKPLAYING);
    AssertFrame(npMCI->lCurrentFrame - (LONG)npMCI->dwBufferedVideo);

    //
    //  NOTE we must grab dwTimingStart *before* calling
    //  timeGetTime() because dwTimingStart is changed in the wave
    //  callback and we dont want to have time go backward.
    //
    lTime = (volatile DWORD)npMCI->dwTimingStart;   // grab this as one unit!

    lTime = (LONG)timeGetTime() - lTime
	+ npMCI->dwLastDrawTime
//      + npMCI->dwLastReadTime
	;

    Assert(lTime >= 0);

    if (npMCI->hWave) {

	if (npMCI->dwFlags & MCIAVI_WAVEPAUSED)
	    lTime = 0;

	lTime += muldiv32(npMCI->dwAudioPlayed,
			   1000L, npMCI->pWF->nAvgBytesPerSec);
    }

    /* Convert from MS to frames.... */
    lFrame = muldiv32(lTime, 1000, npMCI->dwPlayMicroSecPerFrame);

    if (npMCI->dwFlags & MCIAVI_REVERSE) {

	lFrame = npMCI->lFramePlayStart - lFrame;

	if (lFrame < npMCI->lTo)
	    lFrame = npMCI->lTo;
    }
    else {
	lFrame = lFrame + npMCI->lFramePlayStart + npMCI->dwBufferedVideo;

        if ((lFrame > npMCI->lTo) && (lFrame > npMCI->lCurrentFrame))
            lFrame = npMCI->lTo;
    }

    if (lFrame > npMCI->lFrames + (LONG)npMCI->dwBufferedVideo || lFrame < 0) {
	DPF(("WhatFrameIsItTimeFor: bad frame %ld\n", lFrame));
	AssertSz(0, "bad frame in WhatFrameIsItTimeFor");
        lFrame = npMCI->lCurrentFrame;
    }

    return lFrame;
}

/******************************************************************************
 *****************************************************************************/

BOOL NEAR PASCAL PauseAVI(NPMCIGRAPHIC npMCI)
{
    if (npMCI->wTaskState == TASKPLAYING) {
        int stream;

        if (npMCI->hWave)
            waveOutPause(npMCI->hWave);

	if (npMCI->hicDraw)
	    ICDrawStop(npMCI->hicDraw);

	for (stream = 0; stream < npMCI->streams; stream++) {
            if (SI(stream)->hicDraw)
                ICDrawStop(SI(stream)->hicDraw);
	}

	npMCI->dwPauseTime = Now();
	npMCI->dwTotalMSec += npMCI->dwPauseTime - npMCI->dwMSecPlayStart;
    }

    if (npMCI->dwFlags & MCIAVI_CUEING) {
	/* If we're cueing, report that it was successful. */
	npMCI->dwFlags &= ~(MCIAVI_CUEING);
	GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUCCESSFUL);
    }

    DPF2(("MCIAVI: Pausing\n"));
    npMCI->wTaskState = TASKPAUSED;

    return TRUE;
}

/******************************************************************************
 *****************************************************************************/

BOOL NEAR PASCAL BePaused(NPMCIGRAPHIC npMCI)
{
    TIMEEND(timePlay);
    TIMESTART(timePaused);

    while (npMCI->dwFlags & MCIAVI_PAUSE) {
	if (npMCI->dwFlags & MCIAVI_STOP)
	    return FALSE;

	if (npMCI->dwFlags & MCIAVI_NEEDUPDATE) {
	    /* Since we're paused and we have nothing better
	    ** to do, update the screen.
	    */
	    DoStreamUpdate(npMCI, FALSE);
	}

	mmTaskBlock(npMCI->hTask);
    }

    TIMEEND(timePaused);
    TIMESTART(timePlay);

    return TRUE;
}


/******************************************************************************
 *****************************************************************************/

BOOL NEAR PASCAL RestartAVI(NPMCIGRAPHIC npMCI)
{
    int stream;

    Assert(npMCI->wTaskState != TASKPLAYING);

    /* Mark that play has actually begun */
    npMCI->wTaskState = TASKPLAYING;

    DPF(("MCIAVI: Starting\n"));

    TIMESTART(timeYield);
    aviTaskYield();
    aviTaskYield();
    aviTaskYield();
    TIMEEND(timeYield);

    DPF2(("MCIAVI: Starting (done yielding)\n"));

    /* Reset clock and restart */

    if (npMCI->dwPauseTime == 0)
	Assert(npMCI->dwTimingStart == 0);

    npMCI->dwMSecPlayStart = Now(); // get the time we started playing

    //
    // if we were paused subtract off the time we spent paused from
    // the timing start
    //
    if (npMCI->dwPauseTime == 0)
	npMCI->dwTimingStart = npMCI->dwMSecPlayStart;
    else
	npMCI->dwTimingStart += (npMCI->dwMSecPlayStart - npMCI->dwPauseTime);

    if (npMCI->hWave)
        waveOutRestart(npMCI->hWave);

    if (npMCI->hicDraw)
	ICDrawStart(npMCI->hicDraw);

    for (stream = 0; stream < npMCI->streams; stream++) {
        if (SI(stream)->hicDraw)
            ICDrawStart(SI(stream)->hicDraw);
    }

    return TRUE;
}

/* This function sets up things that will be needed to play.
**
** Returns zero if no error, otherwise an MCI error code.
**
** Note: Even if this function returns an error, CleanUpPlay()
** will still be called, so we don't have to cleanup here.
*/
DWORD NEAR PASCAL PrepareToPlay(NPMCIGRAPHIC npMCI)
{
    UINT        w;
    DWORD       dwPosition;
    int         stream;
    BOOL        fCDFile;
    BOOL        fNetFile;
    BOOL        fHardFile;

    Assert(npMCI->wTaskState != TASKPLAYING);

    //
    // lets choose the play back method:
    //
    //      playing reverse: (random access!)
    //          use MCIAVI_ALG_HARDDISK always (random access mode)
    //
    //      audio is preloaded: (will never happen?)
    //          on a CD-ROM   use MCIAVI_ALG_INTERLEAVED
    //          on a HARDDISK use MCIAVI_ALG_HARDDISK
    //          on a NET      use MCIAVI_ALG_HARDDISK
    //
    //      file is interleaved:
    //          on a CD-ROM   use MCIAVI_ALG_INTERLEAVED
    //          on a HARDDISK use MCIAVI_ALG_HARDDISK
    //          on a NET      use MCIAVI_ALG_HARDDISK
    //
    //      file is not interleaved:
    //          on a CD-ROM   use MCIAVI_ALG_CDROM
    //          on a HARDDISK use MCIAVI_ALG_HARDDISK
    //          on a NET      use MCIAVI_ALG_HARDDISK
    //

    fCDFile   = npMCI->uDriveType == DRIVE_CDROM;
    fNetFile  = npMCI->uDriveType == DRIVE_REMOTE;
    fHardFile = !fCDFile && !fNetFile;

    if (npMCI->nVideoStreams == 0 && npMCI->nOtherStreams == 0) {
	npMCI->wPlaybackAlg = MCIAVI_ALG_AUDIOONLY;
    } else if (npMCI->dwFlags & MCIAVI_REVERSE || npMCI->pf) {
	npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
    }
    else if (npMCI->dwFlags & MCIAVI_NOTINTERLEAVED) {
#if 0
	if (fCDFile)
	    npMCI->wPlaybackAlg = MCIAVI_ALG_CDROM;
	else
#endif
	if (fNetFile)
	    npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
	else
	    npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
    }
    else {
	if (fCDFile)
	    npMCI->wPlaybackAlg = MCIAVI_ALG_INTERLEAVED;
#if 0
	else if (fNetFile)
	    npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
	else
	    npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
#else
	else if (fNetFile)
	    npMCI->wPlaybackAlg = MCIAVI_ALG_INTERLEAVED;
	else
            npMCI->wPlaybackAlg = MCIAVI_ALG_INTERLEAVED;
#endif
    }

    // Interleaved playback doesn't work well at very low speeds!
    if ((npMCI->dwSpeedFactor < 100) &&
	(npMCI->wPlaybackAlg != MCIAVI_ALG_HARDDISK) &&
	(npMCI->wPlaybackAlg != MCIAVI_ALG_AUDIOONLY)) {
	DPF(("Was going to play interleaved, but speed < 10%% of normal...\n"));
	npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
    }

#if 0
//
// sigh! we need to always have the index read now, so we do it in
// aviopen
//
    /* Be sure the index has been read, if we need it. */

    if (npMCI->hpFrameIndex == NULL)
        if (npMCI->wPlaybackAlg != MCIAVI_ALG_INTERLEAVED || npMCI->lFrom > 0)
	ReadIndex(npMCI);
#endif

#ifdef DEBUG
    switch (npMCI->wPlaybackAlg) {
	case MCIAVI_ALG_INTERLEAVED:
	    Assert(!(npMCI->dwFlags & MCIAVI_NOTINTERLEAVED));
	    DPF(("playing a interleaved file\n"));
	    break;

	case MCIAVI_ALG_CDROM:
	    Assert(npMCI->dwFlags & MCIAVI_NOTINTERLEAVED);
	    DPF(("playing a non interleaved file from CD-ROM\n"));
	    break;

	case MCIAVI_ALG_HARDDISK:
	    if (npMCI->dwFlags & MCIAVI_NOTINTERLEAVED)
		DPF(("random access play (non-interleaved file)\n"));
	    else
		DPF(("random access play (interleaved file)\n"));
	    break;

	case MCIAVI_ALG_AUDIOONLY:
	    Assert(npMCI->nAudioStreams);
	    DPF(("audio-only!\n"));
	    break;
	
	default:
	    Assert(0);
	    break;
    }
#endif

#if 0
    //
    // set a MMIO buffer if we are playing interleaved of a non cd-rom
    //
    if (npMCI->hmmio && fNetFile && npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED) {

	#define BUFFER_SIZE (32l*1024)

	if (npMCI->lpMMIOBuffer == NULL) {

	    DPF(("Using %u byte MMIO buffer...\n", BUFFER_SIZE));

	    npMCI->lpMMIOBuffer = AllocMem(BUFFER_SIZE);

	    mmioSetBuffer(npMCI->hmmio, npMCI->lpMMIOBuffer, BUFFER_SIZE, 0);
	}

	//!!! should we do this for a seek?
	//!!! should we free this in CleanUpPlay?
    }
    else {
	if (npMCI->lpMMIOBuffer != NULL)
	    FreeMem(npMCI->lpMMIOBuffer);

	npMCI->lpMMIOBuffer = NULL;

	if (npMCI->hmmio)
	    mmioSetBuffer(npMCI->hmmio, NULL, 0, 0);
    }
#endif

    // !!!!
    gwHurryTolerance = GetProfileInt(TEXT("MCIAVI"), TEXT("Hurry"), 2);
    gwSkipTolerance = GetProfileInt(TEXT("MCIAVI"), TEXT("Skip"), gwHurryTolerance * 2);
    gwMaxSkipEver = GetProfileInt(TEXT("MCIAVI"), TEXT("MaxSkip"), max(60, gwSkipTolerance * 10));

    Assert(npMCI->lTo <= npMCI->lFrames);
    Assert(npMCI->lFrom >= 0);

    /* Clear out variables, so we'll know what needs to be released. */
    npMCI->hWave = NULL;
    npMCI->lpAudio = NULL;
    npMCI->lpBuffer = NULL;
    npMCI->dwBufferSize = 0L;
    npMCI->wABFull = 0;

    npMCI->dwSkippedFrames = 0L;
    npMCI->dwFramesSeekedPast = 0L;
    npMCI->dwAudioBreaks = 0L;

    npMCI->dwTotalMSec = 0;
    npMCI->dwLastDrawTime = 0;
    npMCI->dwLastReadTime = 0;
    npMCI->dwBufferedVideo = 0;
    npMCI->dwPauseTime = 0;
    npMCI->dwTimingStart = 0;

    /* Figure out how fast we're playing.... */
    if (npMCI->dwSpeedFactor)
	npMCI->dwPlayMicroSecPerFrame = muldiv32(npMCI->dwMicroSecPerFrame,
						 1000L,
						 npMCI->dwSpeedFactor);
    else
	npMCI->dwPlayMicroSecPerFrame = 0; // Special "play every frame" mode

    /* If we're already at the end, and we're going to repeat from the
    ** start of the file, just repeat now.
    */
    if ((npMCI->lFrom == npMCI->lTo) &&
		(npMCI->dwFlags & MCIAVI_REPEATING) &&
		(npMCI->lFrom != npMCI->lRepeatFrom)) {
	DPF(("Repeating from beginning before we've even started....\n"));
	npMCI->lFrom = npMCI->lRepeatFrom;
    }

    if (npMCI->lFrom == npMCI->lTo) {
	npMCI->dwFlags |= MCIAVI_SEEKING;
	npMCI->dwFlags &= ~(MCIAVI_REVERSE);
    }

    if (npMCI->dwFlags & MCIAVI_SEEKING)
	goto PlayWithoutWave;

    if (npMCI->hicDraw) {
	ICGetBuffersWanted(npMCI->hicDraw, &npMCI->dwBufferedVideo);
    }
#ifdef DEBUG
    npMCI->dwBufferedVideo = GetProfileInt(TEXT("MCIAVI"), TEXT("Buffer"), (int) npMCI->dwBufferedVideo);
#endif
    if (npMCI->dwFlags & MCIAVI_REVERSE) {
	npMCI->dwBufferedVideo = 0;
    }

    if (npMCI->dwBufferedVideo) {
	DPF(("Buffering %lu frames of video ahead....\n", npMCI->dwBufferedVideo));
    }

    //
    //  now initialize the audio stream
    //

    /* Open up our wave output device, if appropriate. */
    if ((npMCI->nAudioStreams > 0)
		&& (npMCI->dwFlags & MCIAVI_PLAYAUDIO)
		&& (npMCI->dwPlayMicroSecPerFrame != 0)) {
		
	npMCI->dwTaskError = SetUpAudio(npMCI, TRUE);

	if ((npMCI->dwTaskError == MCIERR_OUT_OF_MEMORY) &&
	    (npMCI->wPlaybackAlg != MCIAVI_ALG_AUDIOONLY)) {
	    DPF(("Not enough memory to play audio; continuing onward....\n"));
	    CleanUpAudio(npMCI);
	    npMCI->dwTaskError = 0;
	}
	
        if (npMCI->dwTaskError == MCIERR_WAVE_OUTPUTSINUSE) {
            //
            //  we cant get the wave device, time to go steal one.
            //
            //  only do this if we got a real play command
            //  from the user, and not a internal play command
            //  (like when repeating or restarting)
            //
            //  MCIAVI_NEEDTOSHOW is set when the play command
            //  came in through graphic.c (ie from the outside world)
            //
            if (npMCI->dwFlags & MCIAVI_NEEDTOSHOW) {
                if (StealWaveDevice(npMCI))
                     npMCI->dwTaskError = SetUpAudio(npMCI, TRUE);
            }
        }

        if (npMCI->dwTaskError == MCIERR_WAVE_OUTPUTSINUSE) {
            //
            // even though we did not steal the wave device we still
            // want it.
            //
            npMCI->dwFlags |= MCIAVI_LOSTAUDIO;     // we want it
	}

	if (((npMCI->dwTaskError == MCIERR_WAVE_OUTPUTSINUSE) ||
	     (npMCI->dwTaskError == MCIERR_WAVE_OUTPUTSUNSUITABLE)) &&
		    (npMCI->wPlaybackAlg != MCIAVI_ALG_AUDIOONLY))
	    npMCI->dwTaskError = 0;
	
	if (npMCI->dwTaskError)
	    return npMCI->dwTaskError;
    }

PlayWithoutWave:
    if (npMCI->dwFlags & MCIAVI_NEEDTOSHOW) {
	ShowStage(npMCI);       
    }
    /* Get and prepare the DC we're going to be playing into */

    // must hold the critsec when getting dc to avoid
    // interaction with window thread calling DeviceRealize

    EnterCrit(npMCI);

    if (npMCI->hdc == NULL) {
	npMCI->hdc = GetDC(npMCI->hwnd);    // Shouldn't use cached DC!
	npMCI->dwFlags |= MCIAVI_RELEASEDC;
    }

    if (npMCI->hdc == NULL) {
	LeaveCrit(npMCI);
	return MCIERR_DRIVER_INTERNAL;
    }

    if (npMCI->dwFlags & MCIAVI_SEEKING) {
	//
	// audio only
	//
	if (npMCI->nVideoStreams == 0 && npMCI->nOtherStreams == 0) {
	    npMCI->lCurrentFrame = npMCI->lFrom;
	    LeaveCrit(npMCI);
	    return 0;
	}
    }

    /* Start up the external decompressor, if any */
    /* !!!We should check these for errors */

    if (!DrawBegin(npMCI, NULL)) {
	LeaveCrit(npMCI);
	return npMCI->dwTaskError ? npMCI->dwTaskError : MCIERR_DRIVER_INTERNAL;
    }

    if (!(npMCI->dwFlags & MCIAVI_SEEKING))
	PrepareDC(npMCI);

    // critsec just held around getting and preparing dc - look at
    // devicerealize to see the function we are protecting against.
    LeaveCrit(npMCI);

    /*
    **  what if selecting the palette causes palette changes? we should
    **  yield and let the palette changes happen.
    */
    //aviTaskYield(); ????????

    if (npMCI->hicDraw && !(npMCI->dwFlags & MCIAVI_SEEKING) &&
		(npMCI->dwBufferedVideo > 0)) {
	ICDrawFlush(npMCI->hicDraw);
        npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
    }

    if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	/* Clear out key state flags:
	** We watch for escape, space, and the left button.
	*/
	GetAsyncKeyState(VK_ESCAPE);
	GetAsyncKeyState(VK_SPACE);
	GetAsyncKeyState(VK_LBUTTON);
    }

    /* Figure out where in the file to start playing from */
    CalculateTargetFrame(npMCI);

    // !!! ACK: We're starting from after where we planned to finish....
    if ((npMCI->dwFlags & MCIAVI_REVERSE) &&
	(npMCI->lCurrentFrame <= npMCI->lTo)) {
	npMCI->dwFlags |= MCIAVI_SEEKING;
    }

    // !!! This should be in CalcTarget
    if (npMCI->dwFlags & MCIAVI_SEEKING)
        npMCI->lTo = npMCI->lRealStart;

    //
    // start all the streams
    //
    for (stream = 0; stream < npMCI->streams; stream++) {

        STREAMINFO *psi = SI(stream);

	if (!(npMCI->dwFlags & MCIAVI_SEEKING)) {
	    if (SI(stream)->ps) {
		AVIStreamBeginStreaming(SI(stream)->ps,
                        MovieToStream(SI(stream), npMCI->lFrom),
                        MovieToStream(SI(stream), npMCI->lTo),
                        npMCI->dwPlayMicroSecPerFrame); // !!!
	    }
	}

        //
        // NOTE DrawBegin() handled the default draw guy
        //
        if (psi->hicDraw && psi->hicDraw != npMCI->hicDraw) {

            DWORD   dw;

            dw = ICDrawBegin(psi->hicDraw,
		(npMCI->dwFlags & MCIAVI_FULLSCREEN) ?
			ICDRAW_FULLSCREEN : ICDRAW_HDC,

		npMCI->hpal,           // palette to draw with
		npMCI->hwnd,           // window to draw to
		npMCI->hdc,            // HDC to draw to

                RCX(psi->rcDest),
                RCY(psi->rcDest),
                RCW(psi->rcDest),
                RCH(psi->rcDest),

		SI(stream)->lpFormat,

                RCX(psi->rcSource),
                RCY(psi->rcSource),
                RCW(psi->rcSource),
                RCH(psi->rcSource),

                muldiv32(psi->sh.dwRate, npMCI->dwSpeedFactor, 1000),
                psi->sh.dwScale);

            if ((LONG)dw < 0) {
                // !!! Error checking?
                DPF(("Draw handler failed ICDrawBegin() (err = %ld)\n", dw));
            }

            //
            // tell the draw handler the play range
            //
            ICDrawStartPlay(psi->hicDraw,psi->lPlayFrom, psi->lPlayTo);
	}
    }

    //
    // tell the draw handler the play range
    //
    if (npMCI->hicDraw) {
        ICDrawStartPlay(npMCI->hicDraw,npMCI->lRealStart,npMCI->lTo);
    }

    //
    //  seek to the right place in the file.
    //
    dwPosition = CalculatePosition(npMCI);

    if (dwPosition == 0) {
	return MCIERR_DRIVER_INTERNAL;
    }

#ifdef AVIREADMANY
    //
    //  see if we want to try to read two records at a shot, this
    //  should cut down the time spent in DOS doing reads.
    //
    //  we only can do this if we have a index, and the buffer
    //  sizes are "small enough"
    //
    //  if reading 2 buffers works good how about 3? 4?
    //
    //  this helps on CD's and Networks but makes things slower
    //  on KenO's hard disk, so dont do hard disks.
    //
    //  default is read many when coming from a Network, this is
    //  better than the old mmioSetBuffer() we used to do.
    //
    if (npMCI->uDriveType == DRIVE_REMOTE)
        npMCI->fReadMany = TRUE;
    else
        npMCI->fReadMany = FALSE;

    if (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED &&
        npMCI->dwSuggestedBufferSize <= 30*1024 &&
        GetProfileInt(TEXT("MCIAVI"), TEXT("ReadMany"), npMCI->fReadMany) &&
        npMCI->hpFrameIndex) {

        npMCI->dwBufferSize = npMCI->dwSuggestedBufferSize * 2;
        npMCI->fReadMany = TRUE;
    }
    else {
        npMCI->fReadMany = FALSE;
    }

    if (npMCI->fReadMany) {
        DPF(("MCIAVI: reading two records at once (%ld bytes).\n", npMCI->dwBufferSize));
        npMCI->lLastRead = npMCI->lCurrentFrame - 2;
    }
#endif

    AllocateReadBuffer(npMCI);

    // look for palette changes between the last place we read and where
    // we're starting....
    ProcessPaletteChanges(npMCI, npMCI->lVideoStart);

    if (npMCI->hmmio) {
	/* Seek to the start of frame we're playing from */
	mmioSeek(npMCI->hmmio, dwPosition, SEEK_SET);
    }

#ifdef AVIREAD
    /* start the async read object if we are using interleaved
     * and therefore consecutive reads
     */
    if (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED) {

	/* start async reader  - allocates itself new buffers */
	npMCI->hAviRd = avird_startread(mciaviReadBuffer, (DWORD) npMCI,
					npMCI->dwNextRecordSize,
					npMCI->lCurrentFrame,
					min(npMCI->lTo+1, npMCI->lFrames));

	if (!npMCI->hAviRd) {
	    DPF(("async read failed - reading synchronously\n"));
	    ResizeReadBuffer(npMCI, npMCI->dwNextRecordSize);
	}

    } else {
	npMCI->hAviRd = NULL;
    }

    if (!npMCI->hAviRd)
#endif
    {
	if (!npMCI->lpBuffer) {
	    return MCIERR_OUT_OF_MEMORY;
	}
    }

    if (npMCI->hWave) {
        TIMESTART(timeAudio);
	if (npMCI->wPlaybackAlg == MCIAVI_ALG_HARDDISK ||
            npMCI->wPlaybackAlg == MCIAVI_ALG_AUDIOONLY) {
	    /* Load audio into our buffers */
	    for (w = 0; w < npMCI->wABs; w++)
		KeepPlayingAudio(npMCI);
	} else if (npMCI->wPlaybackAlg == MCIAVI_ALG_CDROM) {
	    //!!!!
	    npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
        }
        TIMEEND(timeAudio);
    }

    return 0L;          /* Success! */
}

/******************************************************************************
 *****************************************************************************/

void NEAR PASCAL CleanUpPlay(NPMCIGRAPHIC npMCI)
{
    int stream;
	
    if (npMCI->wTaskState == TASKPLAYING) {
        if (npMCI->hicDraw) {
            ICDrawStop(npMCI->hicDraw);
            ICDrawStopPlay(npMCI->hicDraw);
        }
	
	for (stream = 0; stream < npMCI->streams; stream++) {
            if (SI(stream)->hicDraw) {
                ICDrawStop(SI(stream)->hicDraw);
                ICDrawStopPlay(SI(stream)->hicDraw);
            }
	}

	if (npMCI->hWave) {
	    waveOutRestart(npMCI->hWave); // some wave devices need this
	    waveOutReset(npMCI->hWave);
	}
    } else if (npMCI->wTaskState == TASKCUEING) {
	if (npMCI->hicDraw) {
	    /* Kick the device in the head to make sure it draws when we seek. */
	    ICDrawRenderBuffer(npMCI->hicDraw);
	}
    }

    if (!(npMCI->dwFlags & MCIAVI_SEEKING) &&
		(npMCI->dwBufferedVideo > 0)) {
	ICDrawFlush(npMCI->hicDraw);
	npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
    }

    /* end drawing this will leave fullscreen mode etc. */
    DrawEnd(npMCI);

    for (stream = 0; stream < npMCI->streams; stream++) {
        if (SI(stream)->hicDraw) {
	    DWORD   dw;
            dw = ICDrawEnd(SI(stream)->hicDraw);
	    // !!! Error checking?
	}
	if (!(npMCI->dwFlags & MCIAVI_SEEKING)) {
	    if (SI(stream)->ps) {
		AVIStreamEndStreaming(SI(stream)->ps);
	    }
	}
    }

    /* Clean up and close our wave output device. */

    if (npMCI->hWave) {

        Assert(!(npMCI->dwFlags & MCIAVI_LOSTAUDIO));

	CleanUpAudio(npMCI);

	//
	// if we are not being forced to give up the audio try to
	// give it to someone.
	//
        if (!(npMCI->dwFlags & MCIAVI_NEEDTOSHOW) &&
            !(npMCI->dwFlags & MCIAVI_UPDATING))
	    GiveWaveDevice(npMCI);
    }
    else {
	//
        //  done playing, we dont want a wave device any more
	//
        npMCI->dwFlags &= ~MCIAVI_LOSTAUDIO;
    }

    /* Release the DC we played into. */

    // worker thread must hold critsec round all access to hdc
    // (can be used by DeviceRealize on app thread)
    EnterCrit(npMCI);

    if (npMCI->hdc) {
	//
	// we MUST call this otherwise our palette will stay selected
	// as the foreground palette and it may get deleted (ie by
	// DrawDibBegin) while still the foreground palette and GDI
	// get's real pissed about this.
	//
	UnprepareDC(npMCI);
#if 0
	UnprepareDC(npMCI);

	if (npMCI->dwFlags & MCIAVI_ANIMATEPALETTE)
	    RealizePalette(npMCI->hdc);
#endif
	if (npMCI->dwFlags & MCIAVI_RELEASEDC) {
	    ReleaseDC(npMCI->hwnd, npMCI->hdc);
	    npMCI->hdc = NULL;
	    npMCI->dwFlags &= ~MCIAVI_RELEASEDC;
	}
    }
    LeaveCrit(npMCI);

#ifdef AVIREAD
    /* shut down async reader */
    if (npMCI->hAviRd) {
	avird_endread(npMCI->hAviRd);
	npMCI->hAviRd = NULL;
    } else
#endif
    {
	/* we weren't using async reader - so release the buffer we
	 * allocated
	 */
	ReleaseReadBuffer(npMCI);
    }

}

/******************************************************************************
 *****************************************************************************/

// !!! Should this take a "how many frames to check for" parameter,
// in case we need to check for signals on several frames at once?

void NEAR PASCAL CheckSignals(NPMCIGRAPHIC npMCI, LONG lFrame)
{
    LONG        lTemp;

    lTemp = npMCI->signal.dwPeriod == 0 ? lFrame :
			(((lFrame - npMCI->signal.dwPosition) %
					    npMCI->signal.dwPeriod) +
				npMCI->signal.dwPosition);

    if ((DWORD) lTemp == npMCI->signal.dwPosition) {
	/* Send the signal in the right time format */
	SEND_DGVSIGNAL(npMCI->dwSignalFlags,
			    npMCI->signal.dwCallback,
			    0,
			    (HANDLE) npMCI->wDevID,
			    npMCI->signal.dwUserParm,
			    ConvertFromFrames(npMCI, lFrame));
	// !!! Needs to use time format at time of signal command!
    }
}

/******************************************************************************
 *****************************************************************************/

BOOL NEAR PASCAL WaitTillNextFrame(NPMCIGRAPHIC npMCI)
{
#ifdef DEBUG
    int iWait = 0;
    StatusBar(npMCI,2,1,100,iWait);
#endif

    /* Here we wait for a while if we're ahead
     *   of schedule (so that we can yield nicely instead of blocking
     *   in the driver, for instance, and also so that we'll work off
     *   faster devices.)
     */
    /* Always yield at least once in a while */
    if ((npMCI->lCurrentFrame % YIELDEVERY) == 0) {
	TIMESTART(timeYield);
	aviTaskYield();
	TIMEEND(timeYield);
    }

    if (npMCI->dwFlags & MCIAVI_WAVEPAUSED)
	return TRUE;

    if (TimeToQuit(npMCI))
	return FALSE;

    Assert(npMCI->wTaskState == TASKPLAYING);
    AssertFrame(npMCI->lCurrentFrame - (LONG)npMCI->dwBufferedVideo);
    Assert(npMCI->lCurrentFrame <= npMCI->lTo);
    Assert(!(npMCI->dwFlags & MCIAVI_REVERSE));

    while (WhatFrameIsItTimeFor(npMCI) < npMCI->lCurrentFrame) {

        DPF2(("Waiting for %ld, time for %ld\n", npMCI->lCurrentFrame, WhatFrameIsItTimeFor(npMCI)));

	StatusBar(npMCI,2,1,100,++iWait);

	TIMESTART(timeWait);
	aviTaskYield();
	TIMEEND(timeWait);

	if (TimeToQuit(npMCI))
	    return FALSE;
    }

    return TRUE;
}

/* Idea: this should go from the current frame to the frame
** we actually have to be at to start playing from.
**
** If fPlaying is set, that means we're really going to play.
**
** When this finishes:
**      lAudioStart is set to the first frame with meaningful audio info
**      lVideoStart is the first frame with meaningful video info
**      lRealStart is the first frame that's 'real', namely
**              the original value of lCurrentFrame.  If the
**              SEEK EXACT flag is not set, then lRealStart may
**              actually not be what lCurrentFrame was, indicating
**              that play may start from somewhere else.
**      lCurrentFrame gets set to the first frame we have to read from.
**
** !!! This also needs to look for "palette key frames" or something.
*/
BOOL NEAR PASCAL CalculateTargetFrame(NPMCIGRAPHIC npMCI)
{
    int         i;
    LONG        lVideoPlace;
    BOOL        fForceBeginning = FALSE;

    npMCI->lCurrentFrame = npMCI->lFrom;
    npMCI->lRealStart = npMCI->lFrom;

    //
    //  walk all streams and figure out where to start
    //
    for (i=0; i<npMCI->streams; i++) {

        STREAMINFO *psi = SI(i);

        if (!(psi->dwFlags & STREAM_ENABLED))
            continue;

        if (psi->dwFlags & STREAM_ERROR)
            continue;

        if (psi->dwFlags & STREAM_AUDIO)
            continue;

        //
        // map from movie time to stream time.
        //
        psi->lPlayFrom = MovieToStream(psi, npMCI->lFrom);
        psi->lPlayTo   = MovieToStream(psi, npMCI->lTo);

        psi->dwFlags &= ~STREAM_ACTIVE;
	
        //
        // is this stream part of play?
        //
        if (psi->lPlayFrom < psi->lStart && psi->lPlayTo < psi->lStart)
            continue;

        if (psi->lPlayFrom >= psi->lEnd && psi->lPlayTo >= psi->lEnd)
            continue;

        psi->dwFlags |= STREAM_ACTIVE;

        psi->lPlayFrom  = BOUND(psi->lPlayFrom,psi->lStart,psi->lEnd);
        psi->lPlayTo    = BOUND(psi->lPlayTo,  psi->lStart,psi->lEnd);
        psi->lPlayStart = FindPrevKeyFrame(npMCI,psi,psi->lPlayFrom);

        //
        // if the main frame is invalid invalidate the stream too.
        //
        if (npMCI->lFrameDrawn <= (-(LONG)npMCI->wEarlyRecords)) {
            psi->lFrameDrawn = -4242;
        }

        //
        //  if we have a drawn frame use it!
        //
        if ((psi->lFrameDrawn  > psi->lPlayStart) &&
            (psi->lFrameDrawn <= psi->lPlayFrom))
            psi->lPlayStart = npMCI->lFrameDrawn + 1;

        //
        //  if seek exactly is off start play at the key frame
        //
        if (!(npMCI->dwOptionFlags & MCIAVIO_SEEKEXACT)) {

            if (psi->lPlayFrom == psi->lPlayTo)
                 psi->lPlayTo = psi->lPlayStart;

            psi->lPlayFrom = psi->lPlayStart;

            //!!! is this right for reverse?

            if (StreamToMovie(psi, psi->lPlayFrom) < npMCI->lFrom) {
//              npMCI->lRealStart = StreamToMovie(psi, psi->lPlayFrom);
//              npMCI->lFrom = npMCI->lRealStart;
            }
        }

//      if (StreamToMovie(psi, psi->lPlayStart) < npMCI->lCurrentFrame)
//          npMCI->lCurrentFrame = StreamToMovie(psi, psi->lPlayStart);

        DPF(("CalculateTargetFrame:  Stream #%d: from:%ld, to:%ld, start:%ld\n", i, psi->lPlayFrom, psi->lPlayTo, psi->lPlayStart));
    }

    //
    // we are done with now special case the video and audio streams.
    //

    /* If we're starting from the beginning, don't force the index
    ** to be read, but use it if we've already read it.
    */
    if (npMCI->lFrom == 0 && npMCI->hpFrameIndex == NULL)
	goto ForceBeginning;

    if (!npMCI->pbiFormat) {
	npMCI->lVideoStart = npMCI->lFrom;
	
	if (npMCI->lVideoStart >= npMCI->lFrames)
	    npMCI->lVideoStart = npMCI->lFrames - 1;
	
	lVideoPlace = npMCI->lVideoStart;
    } else
    if (npMCI->dwFlags & MCIAVI_HASINDEX) {

	if (npMCI->hpFrameIndex == NULL)
	    goto ForceBeginning;
	
	//
	// get nearest key frame
	//
	npMCI->lVideoStart = FramePrevKey(npMCI->lFrom);

	if (npMCI->lVideoStart) {
	    lVideoPlace = npMCI->lVideoStart;
	} else {
	    /* Didn't find a key frame--retreat to the beginning. */
	    npMCI->lVideoStart = -(LONG)npMCI->wEarlyVideo;
	    lVideoPlace = 0;
	}
	
        if ((npMCI->lFrameDrawn > npMCI->lVideoStart) &&
		(npMCI->lFrameDrawn <= npMCI->lFrom)) {
	    npMCI->lVideoStart = npMCI->lFrameDrawn + 1;
	    if (npMCI->lVideoStart >= npMCI->lFrames)
		npMCI->lVideoStart = npMCI->lFrames - 1;
	    lVideoPlace = npMCI->lFrameDrawn;
	}
    } else {
	/* Always go back to frame 0 */
ForceBeginning: 
	npMCI->lVideoStart = - (LONG) npMCI->wEarlyVideo;
	lVideoPlace = 0;
	fForceBeginning = TRUE;
    }

    if (!(npMCI->dwOptionFlags & MCIAVIO_SEEKEXACT)) {
	npMCI->lRealStart = lVideoPlace;
    }

    if (npMCI->hWave) {
	npMCI->lAudioStart = npMCI->lRealStart - (LONG) npMCI->wEarlyAudio;
    }

    if (npMCI->hWave && (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED))
	npMCI->lCurrentFrame = min(npMCI->lAudioStart, npMCI->lVideoStart);
    else
	npMCI->lCurrentFrame = npMCI->lVideoStart;

    if (npMCI->lRealStart < npMCI->lCurrentFrame)
	npMCI->lCurrentFrame = npMCI->lRealStart;

    if (fForceBeginning) {
	if (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED)
	    npMCI->lCurrentFrame = - (LONG) npMCI->wEarlyRecords;
	else
	    npMCI->lCurrentFrame = - (LONG) npMCI->wEarlyVideo;
    }

    if (npMCI->hWave) {
        LONG l;

        /* Figure out what sample of audio we should be starting at */

        //
        //  convert frame number to block
        //
        npMCI->dwAudioPos = MovieToStream(npMCI->psiAudio, npMCI->lRealStart);

        //
        // now convert block to byte position
        //
        npMCI->dwAudioPos = npMCI->dwAudioPos * npMCI->pWF->nBlockAlign;

        Assert(npMCI->dwAudioPos % npMCI->pWF->nBlockAlign == 0);

	if (npMCI->dwAudioPos > npMCI->dwAudioLength)
	    npMCI->dwAudioPos = npMCI->dwAudioLength;

        npMCI->dwAudioPlayed = 0L;

        //
        //  convert the audio start back to a frame number.
        //  and posibly readjust the video start time.
        //
        l = npMCI->lRealStart - StreamToMovie(npMCI->psiAudio,
                npMCI->dwAudioPos/npMCI->pWF->nBlockAlign);

        if (l < 0)
            DPF(("Audio will be ahead of the video by %ld frames\n", -l));
        else if (l > 0)
            DPF(("Audio will be behind the video by %ld frames\n", l));
    }

#ifdef DEBUG
    Assert(npMCI->lCurrentFrame < npMCI->lFrames);
    if (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED) {
	Assert(npMCI->lCurrentFrame >= - (LONG) npMCI->wEarlyRecords);
    }
    if (npMCI->hWave) {
	Assert(npMCI->lAudioStart <= npMCI->lFrames);
    }
    Assert(npMCI->lVideoStart < npMCI->lFrames);
#endif

    return TRUE;
}


/******************************************************************************
 *****************************************************************************/

void ReturnToOriginalPalette(NPMCIGRAPHIC npMCI)
{
    if (npMCI->bih.biClrUsed) {
	hmemcpy(npMCI->argb, npMCI->argbOriginal,
		npMCI->bih.biClrUsed * sizeof(RGBQUAD));

	if (npMCI->pbiFormat->biBitCount == 8) {
	    hmemcpy((LPBYTE) npMCI->pbiFormat + npMCI->pbiFormat->biSize,
		    (LPBYTE) npMCI->argb,
		    sizeof(RGBQUAD) * npMCI->pbiFormat->biClrUsed);
	}

	npMCI->dwFlags |= MCIAVI_PALCHANGED;
	npMCI->lLastPaletteChange = 0;
    }
}


/* Returns the position in the file where the frame referenced
** by lCurrentFrame is.
**
**  input   npMCI->lCurrentFrame
**
**  output  npMCI->dwNextRecordSize set correctly
**          npMCI->lLastRead set correctly
**          returns offset to read from
**
** If there's an error, returns zero.
*/
DWORD NEAR PASCAL CalculatePosition(NPMCIGRAPHIC npMCI)
{
    DWORD       dwPosition;

    AssertFrame(npMCI->lCurrentFrame);

    if (npMCI->pf || npMCI->nVideoStreams == 0)
	return 1;
			
    if (npMCI->lCurrentFrame + npMCI->wEarlyRecords == 0) {
ForceBeginning:
	npMCI->lCurrentFrame = - (LONG)npMCI->wEarlyRecords;
//!!!BeforeBeginning:
	dwPosition = npMCI->dwFirstRecordPosition;
	npMCI->dwNextRecordSize = npMCI->dwFirstRecordSize;
	npMCI->dwNextRecordType = npMCI->dwFirstRecordType;
    } else if (npMCI->dwFlags & MCIAVI_HASINDEX) {
	if (npMCI->hpFrameIndex == NULL)
	    goto ForceBeginning;
	
	dwPosition = FrameOffset(npMCI->lCurrentFrame);
	npMCI->dwNextRecordSize = FrameLength(npMCI->lCurrentFrame) + 8;
	npMCI->dwNextRecordType = 0;
    } else {
	goto ForceBeginning;
    }

    npMCI->lLastRead = npMCI->lCurrentFrame - 1;

    DPF3(("Frame %ld: Seeking to position %lX\n", npMCI->lCurrentFrame, dwPosition));

    DPF3(("CalculatePosition: next record = %lu bytes.\n", npMCI->dwNextRecordSize));

    mmioSeek(npMCI->hmmio, dwPosition, SEEK_SET);

    return dwPosition;
}

/***************************************************************************
 *
 ***************************************************************************/

BOOL NEAR PASCAL ReadIndexChunk(NPMCIGRAPHIC npMCI, LONG iIndex)
{
    Assert(iIndex >= 0 && iIndex < (LONG)npMCI->macIndex);

    return ReadBuffer(npMCI, (LONG)IndexOffset(iIndex), (LONG)IndexLength(iIndex) + 8);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | DealWithOtherStreams | does what is says
 *
 *  this function is called inside of the non-interlaved play loop.
 *  it's mission is to catch the "other" streams up to the current time.
 *
 *  right now all we do is go to key frames, we should fix this
 *
 * @parm NPMCIGRAPHIC | npMCI | pointer to instance data block.
 *
 ***************************************************************************/

void DealWithOtherStreams(NPMCIGRAPHIC npMCI, LONG lFrame)
{
    int i;
    STREAMINFO *psi;
    LONG lPos;
    LONG err;

    for (i=0; i<npMCI->streams; i++) {
	psi = SI(i);

	if (!(psi->dwFlags & STREAM_ENABLED))
	    continue;

	if (i == npMCI->nVideoStream)
	    continue;
	
	if (i == npMCI->nAudioStream)
            continue;

        if (psi->hicDraw == NULL)
            continue;

        lPos = MovieToStream(psi, lFrame);

        if (lPos < psi->lPlayStart || lPos > psi->lPlayTo) {
            DPF2(("OtherStream(%d): out of range lPos = %ld [%ld, %ld]\n", i, lPos, psi->lPlayStart, psi->lPlayTo));
            continue;
        }

        //
        // we have the right thing drawn now
        //
        // !!!we should not always go to a key frame.
        //
        //
        if (psi->lFrameDrawn >= psi->lLastKey &&
            psi->lFrameDrawn <= lPos &&
            lPos < psi->lNextKey) {
            DPF2(("OtherStream(%d) lPos = %ld, lFrameDrawn=%ld, NextKey=%ld\n", i, lPos, psi->lFrameDrawn, psi->lNextKey));
            continue;
        }

        FindKeyFrame(npMCI, psi, lPos);

        DPF2(("OtherStream(%d): pos=%ld (prev key=%ld, next key=%ld)\n",i,lPos,psi->lLastKey,psi->lNextKey));

        lPos = psi->lLastKey;

        if (!StreamRead(npMCI, psi, lPos)) {
            DPF2(("StreamRead failed\n"));
            continue;
        }

        //
        //  now draw the data.
        //
        err = (LONG)ICDraw(psi->hicDraw, 0L, psi->lpFormat,
                npMCI->lpBuffer,npMCI->dwThisRecordSize,
                psi->lLastKey - psi->lPlayFrom);

        if (err >= 0) {
            psi->dwFlags &= ~STREAM_NEEDUPDATE;
            psi->lFrameDrawn = lPos;
        }
        else {
            DPF2(("Draw failed!\n"));
        }
    }
}

/***************************************************************************
 *
 * FindKeyFrame
 *
 *  given a stream position, find the previous and next key frame
 *  cacheing the last ones found to make it sort of fast.
 *
 ***************************************************************************/

void NEAR PASCAL FindKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos)
{
    if (psi == NULL)
        psi = npMCI->psiVideo;

    Assert(psi);
//  AssertPos(psi, lPos);

    //
    //  if we are in the current key range return it.
    //
    if (psi->lLastKey <= lPos && lPos < psi->lNextKey)
        return;

    if (lPos < psi->lStart || lPos >= psi->lEnd)
        return;

    //
    //  otherwise query from the stream
    //
    if (psi->ps) {
        if (lPos == psi->lNextKey)
            psi->lLastKey = psi->lNextKey;
        else
            psi->lLastKey = AVIStreamFindSample(psi->ps, lPos, FIND_KEY|FIND_PREV);

        psi->lNextKey = AVIStreamFindSample(psi->ps, lPos+1, FIND_KEY|FIND_NEXT);

        if (psi->lLastKey == -1)
            ; // psi->lLastKey = psi->lStart;

        if (psi->lNextKey == -1)
            psi->lNextKey = psi->lEnd+1;
    }
    else if (psi->dwFlags & STREAM_VIDEO) {
        //
        // for a video stream either read our index or assume no key frames.
        //
        if (npMCI->hpFrameIndex && psi == npMCI->psiVideo) {
            psi->lLastKey = FramePrevKey(lPos);
            psi->lNextKey = FrameNextKey(lPos);
        }
        else {
            psi->lLastKey = psi->lStart;
            psi->lNextKey = psi->lEnd+1;
        }
    }
    else {
        //
        // for a non-video stream assume all key frames
        //
        psi->lLastKey = lPos;
        psi->lNextKey = lPos+1;
    }

    return;
}

/***************************************************************************
 ***************************************************************************/

LONG NEAR PASCAL FindPrevKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos)
{
    FindKeyFrame(npMCI, psi, lPos);
    return psi->lLastKey;
}

/***************************************************************************
 ***************************************************************************/

LONG NEAR PASCAL FindNextKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos)
{
    FindKeyFrame(npMCI, psi, lPos);
    return psi->lNextKey;
}

/***************************************************************************
 ***************************************************************************/

BOOL NEAR PASCAL ProcessPaletteChanges(NPMCIGRAPHIC npMCI, LONG lFrame)
{
    LONG        iPalette;
    LONG        iFrame;
    STREAMINFO *psi;
    DWORD       dw;

    if (!(npMCI->dwFlags & MCIAVI_ANIMATEPALETTE))
        return TRUE;

    psi = npMCI->psiVideo;
    Assert(psi);

#ifdef USEAVIFILE
    if (psi->ps) {

        //
        //  we are in the palette range nohting to do.
        //
        if (npMCI->lLastPaletteChange <= lFrame &&
            npMCI->lNextPaletteChange >  lFrame) {

            return TRUE;
        }

        dw = psi->cbFormat;

        //!!! should be psi->lpFormat
        if (AVIStreamReadFormat(psi->ps, lFrame, npMCI->pbiFormat, &dw) != 0) {
            DOUT("Unable to read Stream format\n");
            return FALSE;
        }

        npMCI->lLastPaletteChange = lFrame;
        npMCI->lNextPaletteChange = AVIStreamFindSample(psi->ps, lFrame+1, FIND_NEXT|FIND_FORMAT);

        if (npMCI->lNextPaletteChange == -1)
            npMCI->lNextPaletteChange = npMCI->lFrames+2;

        npMCI->dwFlags |= MCIAVI_PALCHANGED;
        return TRUE;
    }
#endif

    DPF2(("Looking for palette changes at %ld, last=%ld\n", lFrame, npMCI->lLastPaletteChange));

    if (lFrame < npMCI->lLastPaletteChange) {
	ReturnToOriginalPalette(npMCI);
    }

    /* If there's no index, assume we're starting from the beginning
    ** and thus we don't have to worry about palette changes.
    */
    if (npMCI->hpFrameIndex == NULL)
	return TRUE;

    //
    // walk from the last palette change to the current frame, and apply any
    // palette changes we find.
    //
    for (iFrame = npMCI->lLastPaletteChange,
	 iPalette = FramePalette(iFrame);
	 iFrame <= lFrame;
	 iFrame++) {

	if (iPalette != FramePalette(iFrame)) {

	    iPalette = FramePalette(iFrame);

	    /* We've found a palette change we need to deal with */
	    DPF2(("Processing palette change at frame %ld.\n", iFrame));

	    Assert(iPalette >= 0 && iPalette < (LONG)npMCI->macIndex);

	    if (!ReadIndexChunk(npMCI, iPalette))
		    return FALSE;

	    npMCI->lp += 2 * sizeof(DWORD);
	    ProcessPaletteChange(npMCI, IndexLength(iPalette));

	    npMCI->lLastPaletteChange = iFrame;
	}
    }

    return TRUE;
}

BOOL NEAR PASCAL ReadRecord(NPMCIGRAPHIC npMCI)
{
    LPDWORD pdw;

    AssertFrame(npMCI->lCurrentFrame);

#ifdef AVIREADMANY
    if (npMCI->fReadMany) {
        //
        //  either read two records or return the one we read last time.
        //
        Assert(npMCI->hpFrameIndex);
        Assert(npMCI->lCurrentFrame - npMCI->lLastRead > 0);
        Assert(npMCI->lCurrentFrame - npMCI->lLastRead <= 2);

        if (npMCI->lLastRead == npMCI->lCurrentFrame-1) {
            //
            //  return the second half of the buffer.
            //
            npMCI->lp = npMCI->lpBuffer + (UINT)npMCI->dwThisRecordSize;
            npMCI->dwThisRecordSize = npMCI->dwNextRecordSize;
        }
        else {
            //
            //  read in two buffers, and return the first one
            //
            //  figure out how much to read by looking at the index
            //  we dont have to worry about the last frame because
            //  the dummy index entry on the end is 0 in length.
            //
            npMCI->dwThisRecordSize = FrameLength(npMCI->lCurrentFrame) + 8;
            npMCI->dwNextRecordSize = FrameLength(npMCI->lCurrentFrame+1) + 8;

            if (!ReadBuffer(npMCI, -1,
                npMCI->dwThisRecordSize + npMCI->dwNextRecordSize))
                return FALSE;

            npMCI->lLastRead = npMCI->lCurrentFrame;
            npMCI->lp = npMCI->lpBuffer;
            npMCI->dwThisRecordSize -= npMCI->dwNextRecordSize;
        }

#ifdef DEBUG
        pdw = (LPDWORD)(npMCI->lp + npMCI->dwThisRecordSize - 3 * sizeof(DWORD));

        if (npMCI->lCurrentFrame < npMCI->lFrames - 1) {
            Assert(pdw[0] == FOURCC_LIST);
            Assert(pdw[2] == listtypeAVIRECORD);
        }
#endif
        return TRUE;
    }
    else
#endif
	
#ifdef AVIREAD
    if (npMCI->hAviRd) {
	/* async reader is going - get the next buffer from him */
	npMCI->lpBuffer = avird_getnextbuffer(npMCI->hAviRd, &dwThisBuffer);
	npMCI->dwThisRecordSize = npMCI->dwNextRecordSize;

	if ((dwThisBuffer == 0) || (npMCI->lpBuffer == NULL)) {
	    npMCI->dwTaskError = MCIERR_FILE_READ;
	    return FALSE;
	}
	
    } else
#endif
    {
	if (!ReadBuffer(npMCI, -1, (LONG)npMCI->dwNextRecordSize))
            return FALSE;
    }

    pdw = (LPDWORD)(npMCI->lp + npMCI->dwThisRecordSize - 3 * sizeof(DWORD));

    npMCI->dwNextRecordType = pdw[0];
    npMCI->dwNextRecordSize = pdw[1] + 2 * sizeof(DWORD);

#ifdef DEBUG
    if (npMCI->lCurrentFrame < npMCI->lFrames - 1) {
	Assert(pdw[0] == FOURCC_LIST);
	Assert(pdw[2] == listtypeAVIRECORD);
    }
#endif

    return TRUE;
}

DWORD NEAR PASCAL ReadNextChunk(NPMCIGRAPHIC npMCI)
{
    LPDWORD pdw;
    DWORD dw;

ReadAgain:
    dw = npMCI->dwNextRecordType;

    if (!ReadBuffer(npMCI, -1, (LONG)npMCI->dwNextRecordSize))
	return 0;

    pdw = (LPDWORD)(npMCI->lp + npMCI->dwNextRecordSize - 2 * sizeof(DWORD));

    if (dw == FOURCC_LIST)
	pdw--;

    npMCI->dwNextRecordType = pdw[0];
    npMCI->dwNextRecordSize = pdw[1] + 2 * sizeof(DWORD);

    if (dw == ckidAVIPADDING)
	goto ReadAgain;

    return dw;
}

BOOL NEAR PASCAL StreamRead(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos)
{
    LONG  lSize;

    Assert(psi);
    Assert(psi->ps);
	
    //
    // if we are before the start or after the end, read nothing.
    //
    if (lPos < psi->lStart || lPos >= psi->lEnd) {
        lSize = 0;
        goto done;
    }

    if (AVIStreamRead(psi->ps, lPos, 1,
        (LPSTR)npMCI->lpBuffer,npMCI->dwBufferSize,&lSize, NULL) != 0) {

        //
        // the read failed try incressing the buffer size
        //
        AVIStreamRead(psi->ps, lPos, 1, NULL, 0, &lSize, NULL);

        if (lSize > (LONG) (npMCI->dwBufferSize)) {

            DPF2(("ReadStream: Enlarging buffer....\n"));

            if (!ResizeReadBuffer(npMCI, lSize)) {
                DPF(("Failed to increase buffer size!\n"));
                npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
                return FALSE;
            }
        }

        if (AVIStreamRead(psi->ps, lPos, 1,
                (LPSTR)npMCI->lpBuffer,npMCI->dwBufferSize,&lSize,NULL) != 0) {
            npMCI->dwTaskError = MCIERR_FILE_READ;
            return FALSE;
        }
    }

done:
    npMCI->lp = npMCI->lpBuffer;
    npMCI->dwThisRecordSize = lSize;
    return TRUE;
}

BOOL NEAR PASCAL ReadNextVideoFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi)
{
    MMCKINFO    ck;

    if (psi == NULL)
        psi = npMCI->psiVideo;

    Assert(psi);
    AssertFrame(npMCI->lCurrentFrame);
	
#ifdef USEAVIFILE
    if (psi->ps) {
        LONG        lSize;
        LONG        lPos;

        //
        // map from movie time into this stream.
        //
        lPos = MovieToStream(psi, npMCI->lCurrentFrame);

        //
        // if we are before the start or after the end, read nothing.
        //
        if (lPos <  (LONG)psi->sh.dwStart ||
            lPos >= (LONG)psi->sh.dwStart+(LONG)psi->sh.dwLength) {
            lSize = 0;
            goto done;
        }

        //
	// if this frame has a new palette then deal wiht it
	//
	if (npMCI->dwFlags & MCIAVI_ANIMATEPALETTE) {
            ProcessPaletteChanges(npMCI, lPos);
	}
	
        if (AVIStreamRead(psi->ps, lPos, 1,
		      (LPSTR) npMCI->lpBuffer + 2 * sizeof(DWORD),
		      npMCI->dwBufferSize - 2 * sizeof(DWORD),
		      &lSize, NULL) != 0) {
	    //
	    // the read failed try incressing the buffer size
	    //
            AVIStreamRead(psi->ps, lPos, 1, NULL, 0, &lSize, NULL);

	    if (lSize > (LONG) (npMCI->dwBufferSize - 2 * sizeof(DWORD))) {

		DPF2(("ReadNextVideoFrame: Enlarging buffer....\n"));

		if (!ResizeReadBuffer(npMCI, lSize + 2 * sizeof(DWORD))) {
		    DPF(("Failed to increase buffer size!\n"));
		    npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
		    return FALSE;
		}       
	    }
	
            if (AVIStreamRead(psi->ps, lPos, 1,
		      (LPSTR) npMCI->lpBuffer + 2 * sizeof(DWORD),
		      npMCI->dwBufferSize - 2 * sizeof(DWORD),
		      &lSize, NULL) != 0) {
		return FALSE;
	    }
	}

done:
	((DWORD FAR *)npMCI->lpBuffer)[0] = MAKEAVICKID(cktypeDIBbits,
							npMCI->nVideoStream);
	((DWORD FAR *)npMCI->lpBuffer)[1] = lSize;

	npMCI->lp = npMCI->lpBuffer;

	npMCI->dwThisRecordSize = lSize + 2 * sizeof(DWORD);

	return TRUE;
    }
#endif
    //
    // if we are not reading the "next" frame then figure out where it is.
    //
    if (npMCI->lLastRead != npMCI->lCurrentFrame-1)
	CalculatePosition(npMCI);

    //
    // dwNextRecordSize is the size to read
    // and we are seeked to the right place.
    //
    if (npMCI->hpFrameIndex) {

	//
	// if this frame has a new palette then deal wiht it
	//
	if (npMCI->dwFlags & MCIAVI_ANIMATEPALETTE) {
	     if (FramePalette(npMCI->lCurrentFrame) !=
		 FramePalette(npMCI->lLastPaletteChange))

		ProcessPaletteChanges(npMCI, npMCI->lCurrentFrame);
	}
	
	//
	// now just go read the frame from the disk.
	//
	// if interleaved add 8 to skip the 'REC'!!!!
	//
	return ReadBuffer(npMCI,
	    (LONG)FrameOffset(npMCI->lCurrentFrame),
	    (LONG)FrameLength(npMCI->lCurrentFrame) + 8);
    } else {
ReadAgainNoIndex:
	for (;;) {
	    if (mmioDescend(npMCI->hmmio, &ck, NULL, 0) != 0) {
		DPF(("Unable to descend!\n"));
		npMCI->dwTaskError = MCIERR_INVALID_FILE;
		return FALSE;
	    }

	    /* If it's a list, stay descended in it. */
	    /* Hack: we never ascend.            */
	    if (ck.ckid == FOURCC_LIST)
		continue;

#ifdef ALPHAFILES
	    /* Skip wave bytes, since they've been preloaded. */
	    if (npMCI->dwFlags & MCIAVI_USINGALPHAFORMAT) {
		if ((ck.ckid != ckidAVIPADDING) &&
			(ck.ckid != ckidOLDPADDING) &&
			(ck.ckid != ckidWAVEbytes))
		    break;
	    } else
#endif
	    {
		if (StreamFromFOURCC(ck.ckid) == (WORD)npMCI->nVideoStream)
		    break;
	    }

	    mmioAscend(npMCI->hmmio, &ck, 0);
	}

	if (ck.cksize + 2 * sizeof(DWORD) > npMCI->dwBufferSize) {
	    if (!ResizeReadBuffer(npMCI, ck.cksize + 2 * sizeof(DWORD))) {
		DPF(("ReadNextVideoFrame: Failed to increase buffer size!\n"));
		npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
		return FALSE;
	    }
	}

	*((LPMMCKINFO) npMCI->lpBuffer) = ck;
	if (mmioRead(npMCI->hmmio, npMCI->lpBuffer + 2 * sizeof(DWORD),
			    ck.cksize) != (LONG) ck.cksize) {
	    npMCI->dwTaskError = MCIERR_INVALID_FILE;
	    return FALSE;
	}

	mmioAscend(npMCI->hmmio, &ck, 0);
	npMCI->lp = npMCI->lpBuffer;

	npMCI->dwThisRecordSize = ck.cksize + 2 * sizeof(DWORD);

	if (TWOCCFromFOURCC(ck.ckid) == cktypePALchange) {
	    npMCI->lp += 2 * sizeof(DWORD);
	    ProcessPaletteChange(npMCI, ck.cksize);
	    npMCI->lLastPaletteChange = npMCI->lCurrentFrame;
	    goto ReadAgainNoIndex;
	}
    }

    return TRUE;
}

BOOL NEAR PASCAL TimeToQuit(NPMCIGRAPHIC npMCI)
{
    /* If we're using DisplayDib, give the user a chance to break. */

    if ((npMCI->dwFlags & MCIAVI_FULLSCREEN) &&
		!(npMCI->dwFlags & MCIAVI_NOBREAK) &&
		(npMCI->wTaskState == TASKPLAYING)) {
	UINT u;

	u = GetAsyncKeyState(VK_ESCAPE) |
		GetAsyncKeyState(VK_SPACE) |
		GetAsyncKeyState(VK_LBUTTON);
	if (u & 1) {
	    /* Break out of play loop */
	    npMCI->dwFlags |= MCIAVI_STOP;
	}
    }

    if (npMCI->dwFlags & MCIAVI_STOP)
	return TRUE;

    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | AllocateReadBuffer | Allocates buffers needed to read
 *      disk information in to.  The amount of memory to allocate
 *      is in npMCI->dwBufferSize.
 *
 * @parm NPMCIGRAPHIC | npMCI | pointer to instance data block.
 *
 * @rdesc TRUE means OK, otherwise unable to allocate memory.
 *
 ***************************************************************************/
BOOL NEAR PASCAL AllocateReadBuffer(NPMCIGRAPHIC npMCI)
{
    if (npMCI->dwBufferSize == 0)
	npMCI->dwBufferSize = npMCI->dwSuggestedBufferSize;

    if (npMCI->dwBufferSize <= 8 * sizeof(DWORD))
    {
	if (npMCI->dwBytesPerSec > 0 &&
	    npMCI->dwBytesPerSec < 600l*1024 &&
	    npMCI->dwMicroSecPerFrame > 0)

	    npMCI->dwBufferSize = (muldiv32(npMCI->dwBytesPerSec,
			npMCI->dwMicroSecPerFrame,1000000L) + 2047) & ~2047;
	else
	    npMCI->dwBufferSize = 10*1024;

        npMCI->dwSuggestedBufferSize == npMCI->dwBufferSize;
    }

    DPF3(("MCIAVI: allocating %lu byte read buffer.\n", npMCI->dwBufferSize));

    if (npMCI->lpBuffer) {
	DPF(("Already have buffer in AllocateReadBuffer!\n"));
	return ResizeReadBuffer(npMCI, npMCI->dwBufferSize);
    }

    //!!! we dont need DOS memory when we have a MMIO buffer!
    //!!! we dont need DOS memory when we are using AVIFile???

    if (npMCI->lpMMIOBuffer != NULL || npMCI->pf)
        npMCI->lpBuffer = GlobalAllocPtr(GHND | GMEM_SHARE, npMCI->dwBufferSize);
    else
        npMCI->lpBuffer = AllocMem(npMCI->dwBufferSize);

    return npMCI->lpBuffer != NULL;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | ResizeReadBuffer | Enlarges buffer needed to read
 *      disk information in to.
 *
 * @parm NPMCIGRAPHIC | npMCI | pointer to instance data block.
 *
 * @parm DWORD | dwNewSize | new amount of memory to allocate
 *
 * @rdesc TRUE means OK, otherwise unable to allocate memory.
 *
 ***************************************************************************/
BOOL NEAR PASCAL ResizeReadBuffer(NPMCIGRAPHIC npMCI, DWORD dwNewSize)
{
    if (dwNewSize > npMCI->dwSuggestedBufferSize && !npMCI->fReadMany)
        npMCI->dwSuggestedBufferSize = dwNewSize;

    if (dwNewSize <= npMCI->dwBufferSize)
	return TRUE;

    DPF(("Increasing buffer size to %ld (was %ld).\n", dwNewSize, npMCI->dwBufferSize));

    ReleaseReadBuffer(npMCI);
    npMCI->dwBufferSize = dwNewSize;
    return AllocateReadBuffer(npMCI);
}
	
/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | ReleaseReadBuffer | Releases read buffer.
 *
 * @parm NPMCIGRAPHIC | npMCI | pointer to instance data block.
 *
 ***************************************************************************/
void NEAR PASCAL ReleaseReadBuffer(NPMCIGRAPHIC npMCI)
{
    if (npMCI->lpBuffer) {
	DPF3(("Releasing read buffer.\n"));
	
	GlobalFreePtr(npMCI->lpBuffer);

	npMCI->lpBuffer = NULL;
        npMCI->dwBufferSize = 0L;
        npMCI->fReadMany = FALSE;
    }
}
	
/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | ReadBuffer
 *
 ***************************************************************************/

BOOL NEAR PASCAL ReadBuffer(NPMCIGRAPHIC npMCI, LONG off, LONG len)
{
    npMCI->lp = npMCI->lpBuffer;
    npMCI->dwThisRecordSize = len;

    if (len == 0) {
	((DWORD FAR *)npMCI->lpBuffer)[0] = 0; //!!!lpIndexEntry->ckid;
	((DWORD FAR *)npMCI->lpBuffer)[1] = 0;
	npMCI->dwThisRecordSize = 8;
	return TRUE;
    }

    if (len > (LONG)npMCI->dwBufferSize) {
	if (!ResizeReadBuffer(npMCI, len)) {
	    DPF(("Failed to increase buffer size!\n"));
	    npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
	    return FALSE;
	}

	npMCI->lp = npMCI->lpBuffer;
    }

    if (off >= 0)
        DPF2(("ReadBuffer %ld bytes at %ld\n", len, off));
    else
        DPF2(("ReadBuffer %ld bytes\n", len));

    if (off >= 0)
	mmioSeek(npMCI->hmmio, off, SEEK_SET);

    if (mmioRead(npMCI->hmmio, npMCI->lp, len) != len) {
        npMCI->dwTaskError = MCIERR_FILE_READ;
	return FALSE;
    }

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LPVOID | AllocMem | try to allocate DOS memory (< 1Mb)
 *
 * @parm DWORD | dw | size in bytes
 *
 ***************************************************************************/
	
static LPVOID AllocMem(DWORD dw)
{
#ifndef WIN32
    /* Memory allocation internal routines */

    extern DWORD FAR PASCAL GlobalDosAlloc(DWORD);

    LPVOID p;

    if (p = (LPVOID)MAKELONG(0, LOWORD(GlobalDosAlloc(dw))))
        {
        DPF(("Got %ld bytes DOS memory\n", dw));
	GlobalReAlloc((HANDLE)HIWORD((DWORD)p), 0, GMEM_MODIFY|GMEM_SHARE);
	return p;
	}
    else
#endif
    {
        DPF(("unable to get %ld bytes of DOS memory\n", dw));
	return GlobalLock(GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE, dw));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\avitask.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   avitask.c - Background task that actually manipulates AVI files.

*****************************************************************************/
#include "graphic.h"

void FAR PASCAL DebugBreak(void);

BOOL FAR PASCAL mciaviCloseFile(NPMCIGRAPHIC npMCI);
BOOL FAR PASCAL mciaviOpenFile(NPMCIGRAPHIC npMCI);

#if defined(WIN32) || !defined(DEBUG)
#define StackTop()      (void *)0
#define StackMin()      (void *)0
#define StackBot()      (void *)0
#define StackMark()
#define StackTest()     TRUE
#else
#define STACK           _based(_segname("_STACK"))
#define StackTop()      *((UINT STACK *)10)
#define StackMin()      *((UINT STACK *)12)
#define StackBot()      *((UINT STACK *)14)
#define StackMark()     *((UINT STACK*)StackBot()) = 42
#define StackTest()     *((UINT STACK*)StackBot()) == 42
#endif


/***************************************************************************
 ***************************************************************************/

#ifndef WIN32
#pragma optimize("", off)
void FAR SetPSP(UINT psp)
{
    _asm {
        mov bx,psp
        mov ah,50h
        int 21h
    }
}
#pragma optimize("", on)
#endif

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | mciaviTask |  This function is the background task which plays
 *      AVI files. It is called as a result of the call to mmTaskCreate()
 *      in DeviceOpen(). When this function returns, the task is destroyed.
 *
 * @parm DWORD | dwInst | instance data passed to mmCreateTask - contains
 *      a pointer to an instance data block.
 *
 ***************************************************************************/

void FAR PASCAL _LOADDS mciaviTask(DWORD dwInst)
{
    NPMCIGRAPHIC npMCI;

    npMCI = (NPMCIGRAPHIC) dwInst;

    // Set this task's error mode to the same as the parent's.
    SetErrorMode(npMCI->uErrorMode);

    DPF2(("MCIAVI: Bkgd Task hTask=%04X\n", GetCurrentTask()));
    DPF2(("MCIAVI: Stack: %04X %04X %04X\n", StackTop(), StackMin(), StackBot()));

    /* Task state is TASKBEINGCREATED at fn. entry, then goes to TASKINIT. */

    Assert(npMCI && npMCI->wTaskState == TASKBEINGCREATED);

    npMCI->wTaskState = TASKINIT;

#ifndef WIN32
    //
    // in order to make this task, more like a "thread" we want to use the
    // same PSP as our parent, so we can share file handles and things.
    //
    // when we get created hTask is a PSP
    //
    npMCI->pspTask = GetCurrentPDB();   // save our PSP
#endif

    npMCI->hTask = GetCurrentTask();
    npMCI->dwTaskError = 0;

    /* Open the file  */

    if (!mciaviOpenFile(npMCI)) {
        // NOTE: IsTask() returns FALSE when hTask==0
        // Set hTask to 0 BEFORE setting wTaskState.  Our creator is polling
        // the state of wTaskState...
        // npMCI->wTaskState = TASKABORT;
        // npMCI->hTask = 0; // This stops others using this task thread.
        DPF1(("Failed to open AVI file\n"));
        goto exit;
    }

    while (IsTask(npMCI->hTask)) {

        npMCI->wTaskState = TASKIDLE;
        DPF2(("MCIAVI: Idle\n"));
        DPF2(("MCIAVI: Stack: %04X %04X %04X\n", StackTop(), StackMin(), StackBot()));

        StackMark();

        /* Block until task is needed. The task count could */
        /* be anything at the exit of playfile or recordfile */
        /* so continue to block until the state really changes. */

        while (npMCI->wTaskState == TASKIDLE)
        {
            mmTaskBlock(npMCI->hTask);
        }

        mciaviMessage(npMCI, npMCI->wTaskState);

        AssertSz(StackTest(), "Stack overflow");

        if (npMCI->wTaskState == TASKCLOSE) {
            break;
        }

    }
exit:
    mciaviTaskCleanup(npMCI);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api WORD | mciaviTaskCleanup |  called when the background task
 *      is being destroyed.  This is where critical cleanup goes.
 *
 ***************************************************************************/

void FAR PASCAL mciaviTaskCleanup(NPMCIGRAPHIC npMCI)
{

#ifndef WIN32
    //
    // restore our PSP back to normal before exit.
    //
    if (npMCI->pspTask)
    {
        SetPSP(npMCI->pspTask);
    }
#endif

#ifdef USEAVIFILE
    //
    // we must do this so COMPOBJ will shut down right.
    //
    FreeAVIFile(npMCI);
#endif

    //
    //  call a MSVideo shutdown routine.
    //

    //
    //  Signal the foreground task that we're all done.
    //  This must be absolutely the last thing we do.
    //
    npMCI->hTask = 0;
    npMCI->wTaskState = TASKCLOSED;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | mciaviMessage | this function handles a message from the
 *      background task.
 *
 ***************************************************************************/

void NEAR PASCAL mciaviMessage(NPMCIGRAPHIC npMCI, UINT msg)
{
    UINT  wNotification;

    switch (msg) {

    case TASKREADINDEX:
        Assert(0);
        break;

    /* Check to see if we just got closed */

    case TASKCLOSE:
        DPF1(("MCIAVI: Closing\n"));

	// hold critsec during close in case someone comes in to
	// eg DeviceRealize during the close when things are half-deleted.
	EnterCrit(npMCI);
        mciaviCloseFile(npMCI);
	LeaveCrit(npMCI);

        /* The htask must be set to NULL, otherwise CloseDevice() will  */
        /* get stuck. */

        // NOTE: IsTask() returns FALSE when hTask==0
        // npMCI->hTask = 0;
        // npMCI->wTaskState = TASKABORT;
        return;

    case TASKRELOAD:
 	DPF(("MCIAVI: Loading new file....\n"));
 	mciaviCloseFile(npMCI);
 	npMCI->dwTaskError = 0;
	npMCI->wTaskState = TASKINIT;

 	if (!mciaviOpenFile(npMCI)) {
	    // !!! mciaviOpenNew() !!!!!!!!!!!!!!!!!!!!!
	    npMCI->wTaskState = TASKCLOSE;
	    // npMCI->hTask = 0;
	    return;
	}
	break;

	// We've been woken up to play....
    case TASKSTARTING:
        DPF2(("MCIAVI: Now busy\n"));

        /* Reset to no error */
        npMCI->dwTaskError = 0;

        wNotification = mciaviPlayFile(npMCI);

        if ((wNotification != MCI_NOTIFY_FAILURE) ||
                ((npMCI->dwFlags & MCIAVI_WAITING) == 0))
            GraphicDelayedNotify(npMCI, wNotification);

        break;

    default:
        DPF(("MCIAVI: Unknown task state!!!! (%d)\n", msg));
        break;
    }
}

#ifdef WIN32

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api int | GetPrioritySeparation | Find the foreground process priority
 *    boost
 *
 * @rdesc Returns 0, 1 or 2
 *
 ***************************************************************************/

 DWORD GetPrioritySeparation(void)
 {
     static DWORD Win32PrioritySeparation = 0xFFFFFFFF;

     /* If we're not initialized get the current separation */

     if (Win32PrioritySeparation == 0xFFFFFFFF) {
         HKEY hKey;
         Win32PrioritySeparation = 2;  // This is the default

         /* Code copied from shell\control\main\prictl.c */

         if (RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 TEXT("SYSTEM\\CurrentControlSet\\Control\\PriorityControl"),
                 0,
                 KEY_QUERY_VALUE,
                 &hKey) == ERROR_SUCCESS) {

             DWORD Type;
             DWORD Length;

             Length = sizeof(Win32PrioritySeparation);

             /* Read the value which is the priority boost given to
                forground processes */

             if (RegQueryValueEx(
                      hKey,
                      TEXT("Win32PrioritySeparation"),
                      NULL,
                      &Type,
                      (LPBYTE)&Win32PrioritySeparation,
                      &Length
                      ) != ERROR_SUCCESS) {

                  Win32PrioritySeparation = 2;
             }

             RegCloseKey(hKey);
         }
     }

     return Win32PrioritySeparation;
 }
 #endif // WIN32

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void| aviTaskYield |  This function yields in the picky way windows
 *      wants us to.
 *
 *      basicly we Dispatch any messages in our que that belong to a window.
 *
 *      NOTE we should not remove
 *
 ***************************************************************************/

void NEAR PASCAL aviTaskYield(void)
{
    MSG msg;

#ifdef WIN32
    DWORD PrioritySeparation;

    //
    //  Do our own kind of 'yield'.  The reason for doing the
    //  Peekmessage on Windows 3.1 was that if you didn't call
    //  it Windows would think you were spinning out of control.
    //  For Windows NT if you call PeekMessage 100 times without
    //  getting anything your priority is lowered which would mess
    //  up our tinkering with the priority here.
    //

    PrioritySeparation = GetPrioritySeparation();

    if (PrioritySeparation != 0) {
        SetThreadPriority(GetCurrentThread(),
                          PrioritySeparation == 1 ?
                              THREAD_PRIORITY_BELOW_NORMAL :  // minus 1
                              THREAD_PRIORITY_LOWEST);        // minus 2
        Sleep(0);    // Causes reschedule decision
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
    } else {
        Sleep(0);    // Let other threads in
    }

#else

    //
    // if we were MCIWAVE we would do this....
    //
    //if (PeekMessage(&msg, NULL, 0, WM_MM_RESERVED_FIRST-1, PM_REMOVE))

    if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        DPF(("aviTaskYield: got message %04X to window %04X\n", msg.message, msg.hwnd));
        DispatchMessage(&msg);
    }
#endif // WIN32
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\cnfgdlg.h ===
//
// the configure dialog
//
#define IDA_CONFIG                  100

#define ID_WINDOW                   101
#define ID_VGA240                   102
#define ID_VGA200                   103
#define ID_ZOOM2                    104
#define ID_FAILIFNOWAVE		    105
#define ID_SEEKEXACT		    106
#define ID_STUPIDMODE		    107
#define ID_SKIPFRAMES               108
#define ID_DEFAULT                  109
#define ID_DEBUG                    110
#define ID_INFO                     111
#define ID_SIZE                     112
#define ID_ICON                     113

//
//  the debug options dialog.
//
#define IDA_DEBUG                   200
#define ID_SCREEN                   202
#define ID_BITMAP                   203
#define ID_SUCKS                    204
#define ID_RATE                     205
#define ID_LEVEL                    206
#define ID_BUILD                    207
#define ID_USE_AVIFILE              208

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\avifilex.h ===
////////////////////////////////////////////////////////////////////////////
//
// stuff needed for MCIAVI to run-time-link to AVIFile for playback.
// because most everything from AVIFILE.DLL is a OLE interface, we dont need
// to RTL to many functions.
//
////////////////////////////////////////////////////////////////////////////

#define USEAVIFILE      //!!! hey lets use AVIFile.

#ifdef USEAVIFILE

//#define _INC_AVIFMT     100     /* version number * 100 + revision */
#include <avifile.h>

UINT    uAVIFILE;
HMODULE hdllAVIFILE;
HMODULE hdllCOMPOBJ;

//
//  RTL to AVIFile...
//
void    (STDAPICALLTYPE *XAVIFileInit)(void);
void    (STDAPICALLTYPE *XAVIFileExit)(void);
HRESULT (STDAPICALLTYPE *XAVIFileOpen)(PAVIFILE FAR * ppfile,LPCTSTR szFile,UINT uMode,LPCLSID lpHandler);
HRESULT (STDAPICALLTYPE *XAVIMakeFileFromStreams)(PAVIFILE FAR *,int,PAVISTREAM FAR *);
HRESULT (STDAPICALLTYPE *XAVIStreamBeginStreaming)(PAVISTREAM   pavi,
			       LONG	    lStart,
			       LONG	    lEnd,
			       LONG	    lRate);
HRESULT (STDAPICALLTYPE *XAVIStreamEndStreaming)(PAVISTREAM   pavi);


#undef  AVIFileInit
#undef  AVIFileExit
#undef AVIFileOpen
#undef AVIFileInfo

#define AVIFileInit         XAVIFileInit
#define AVIFileExit         XAVIFileExit
#define AVIFileOpen         XAVIFileOpen
#define AVIMakeFileFromStreams  XAVIMakeFileFromStreams
#define AVIStreamBeginStreaming  XAVIStreamBeginStreaming
#define AVIStreamEndStreaming  XAVIStreamEndStreaming

#undef  AVIFileClose
#define AVIFileClose(p)                 (p)->lpVtbl->Release(p)
#define AVIFileInfo(p,a,b)              (p)->lpVtbl->Info(p, a, b)
#define AVIFileGetStream(p,a,b,c)       (p)->lpVtbl->GetStream(p,a,b,c)

#undef  AVIStreamClose
#define AVIStreamClose(p)               (p)->lpVtbl->Release(p)
#define AVIStreamInfo(p,a,b)            (p)->lpVtbl->Info(p, a, b)
#define AVIStreamReadFormat(p,a,b,c)    (p)->lpVtbl->ReadFormat(p, a, b, c)
#define AVIStreamReadData(p,a,b,c)      (p)->lpVtbl->ReadData(p, a, b, c)
#define AVIStreamFindSample(p,a,b)      (p)->lpVtbl->FindSample(p, a, b)

#define AVIStreamRead(p,a,b,c,d,e,f)    (p)->lpVtbl->Read(p,a,b,c,d,e,f)

// RTL to COMPOBJ
EXTERN_C BOOL STDAPICALLTYPE IsValidInterface(LPVOID pv);
BOOL    (STDAPICALLTYPE *XIsValidInterface)(LPVOID pv);

#define IsValidInterface XIsValidInterface

#endif  // USEAVIFILE


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\avitask.h ===
/****************************************************************************

Task State : MCIAVI has a separate background task for every open
instance of mciavi. The task handle and task state are stored  in
the  per-instance data structure.  The task can be in one of  four
states.

   TASKABORT : Set by the AVI task when it fails to open the requested
   file during initialisation.

   TASKINIT : This is the initial task state set when the
   instance data structure is initialized in mwOpenDevice()
   before the actual task is created by mmTaskCreate().
   After the task is created, mwOpenDevice() waits until
   the task state changes to TASKIDLE before returning
   success so that the background task is definitely initialized
   after an open call.

   TASKIDLE : The task sets the state to TASKIDLE and blocks whenever
   there is nothing to do. When the task wakes, the state is either
   TASKCLOSE if the instance is being closed or else TASKBUSY
   if  the task is to begin  recording or playback of the file.

   TASKCLOSE : mwCloseDevice() stops playback or recording which forces
   the task state to TASKIDLE and then sets the state to TASKCLOSE and
   wakes the task so that the task will destroy itself.

   TASKSTARTING: The task is in this state when it is initializing for
   playback, but hasn't started yet.  This is used so that the calling
   task can wait for play to start before returning "no error" as the
   result of an MCI play command.

   TASKCUEING: The task is in this state when it is reading extra
   records and buffering up audio before actually starting to play.

   TASKPAUSED: The task is in this state while it is paused.
   TASKPLAYING: The task is in this state during playback

****************************************************************************/

#define TASKABORT               0
#define TASKBEINGCREATED	1
#define TASKINIT		2
#define TASKIDLE		3
#define TASKSTARTING		4
#define TASKCUEING		5
#define TASKPLAYING		6
#define TASKPAUSED		7
#define TASKCLOSE		8
#define TASKCLOSED		9
//				9
//				10
#define TASKREADINDEX		11
#define TASKRELOAD		12

/* A function back in device.c */
DWORD mciaviTaskMessage(NPMCIGRAPHIC npMCI, int msg);
void NEAR PASCAL ShowStage(NPMCIGRAPHIC npMCI);

//
//  call this to RTL to AVIFile.
//
BOOL FAR InitAVIFile(NPMCIGRAPHIC npMCI);
BOOL FAR FreeAVIFile(NPMCIGRAPHIC npMCI);

/* Functions in avitask.c */
void FAR PASCAL _LOADDS mciaviTask(DWORD dwInst);
void FAR PASCAL mciaviTaskCleanup(NPMCIGRAPHIC npMCI);
void NEAR PASCAL mciaviMessage(NPMCIGRAPHIC npMCI, UINT msg);

/* Functions in aviplay.c */
UINT NEAR PASCAL mciaviPlayFile(NPMCIGRAPHIC npMCI);

/* Functions in avidraw.c */
/* !!! Should this be externally visible? */
BOOL NEAR PASCAL DoStreamUpdate(NPMCIGRAPHIC npMCI, BOOL fPaint);
void NEAR PASCAL StreamInvalidate(NPMCIGRAPHIC npMCI, LPRECT prc);

UINT NEAR PASCAL PrepareDC(NPMCIGRAPHIC npMCI);
void NEAR PASCAL UnprepareDC(NPMCIGRAPHIC npMCI);

BOOL FAR PASCAL DrawBegin(NPMCIGRAPHIC npMCI, BOOL FAR *fRestart);
void NEAR PASCAL DrawEnd(NPMCIGRAPHIC npMCI);

BOOL NEAR PASCAL DisplayVideoFrame(NPMCIGRAPHIC npMCI, BOOL fHurryUp);
BOOL NEAR PASCAL ProcessPaletteChange(NPMCIGRAPHIC npMCI, DWORD cksize);


/* Functions in avisound.c */
BOOL NEAR PASCAL PlayRecordAudio(NPMCIGRAPHIC npMCI, BOOL FAR *pfHurryUp,
				    BOOL FAR *pfPlayedAudio);
BOOL NEAR PASCAL KeepPlayingAudio(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL HandleAudioChunk(NPMCIGRAPHIC npMCI);

DWORD FAR PASCAL SetUpAudio(NPMCIGRAPHIC npMCI, BOOL fPlaying);
DWORD FAR PASCAL CleanUpAudio(NPMCIGRAPHIC npMCI);
void  FAR PASCAL BuildVolumeTable(NPMCIGRAPHIC npMCI);
BOOL  FAR PASCAL StealWaveDevice(NPMCIGRAPHIC npMCI);
BOOL  FAR PASCAL GiveWaveDevice(NPMCIGRAPHIC npMCI);

#define WM_AUDIO_ON  WM_USER+100
#define WM_AUDIO_OFF WM_USER+101

#ifdef WIN32
#define WM_AVISWP    WM_USER+102
#endif

// in hmemcpy.asm
#ifndef WIN32
LPVOID FAR PASCAL MemCopy(LPVOID dest, LPVOID source, LONG count);
#else
#define MemCopy memmove
#endif // WIN16

#define GET_BYTE()		(*((BYTE _huge *) (npMCI->lp))++)
#ifdef WIN32
#define GET_WORD()		(*((UNALIGNED WORD _huge *) (npMCI->lp))++)
#define GET_DWORD()		(*((UNALIGNED DWORD _huge *) (npMCI->lp))++)
#define PEEK_DWORD()		(*((UNALIGNED DWORD _huge *) (npMCI->lp)))
#else
#define GET_WORD()		(*((WORD _huge *) (npMCI->lp))++)
#define GET_DWORD()		(*((DWORD _huge *) (npMCI->lp))++)
#define PEEK_DWORD()		(*((DWORD _huge *) (npMCI->lp)))
#endif
#define SKIP_BYTES(nBytes)	((npMCI->lp) += (nBytes))

#define Now()		(timeGetTime())

void NEAR PASCAL aviTaskYield(void);

BOOL FAR PASCAL ReadIndex(NPMCIGRAPHIC npMCI);

LONG NEAR PASCAL FindPrevKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lFrame);
LONG NEAR PASCAL FindNextKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lFrame);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\aviopen.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   aviopen.c - open a AVI file

*****************************************************************************/
#include "graphic.h"

#ifdef WIN32
#include <wchar.h>
#endif

#ifdef USEAVIFILE
    #include <initguid.h>

    DEFINE_AVIGUID(IID_IAVIFile,            0x00020020, 0, 0);
    DEFINE_AVIGUID(IID_IAVIStream,          0x00020021, 0, 0);
#endif

#define comptypeNONE mmioFOURCC('N','O','N','E')

//
//  special error to use AVIFile to open this file.
//
#define AVIERR_NOT_AVIFILE  4242

//
//  if this is defined we will always use AVIFILE.DLL, except for
//  1:1 interleaved files.
//
#define USE_AVIFILE_FOR_NON_INT

/***************************************************************************
 *
 ***************************************************************************/

BOOL FAR PASCAL mciaviCloseFile(NPMCIGRAPHIC npMCI);
BOOL FAR PASCAL mciaviOpenFile(NPMCIGRAPHIC npMCI);

BOOL NEAR PASCAL InitStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi);
BOOL NEAR PASCAL InitVideoStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi);
BOOL NEAR PASCAL InitAudioStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi);
BOOL NEAR PASCAL InitOtherStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi);
void NEAR PASCAL CloseStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi);

BOOL NEAR PASCAL OpenFileInit(NPMCIGRAPHIC npMCI);

BOOL NEAR PASCAL ParseNewHeader(NPMCIGRAPHIC npMCI);
				
BOOL NEAR PASCAL OpenRiffAVIFile(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL OpenWithAVIFile(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL OpenInterface(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL OpenAVIFile(NPMCIGRAPHIC npMCI, IAVIFile FAR *pf);
BOOL NEAR PASCAL OpenAVIStream(NPMCIGRAPHIC npMCI, int stream, IAVIStream FAR *pf);

static BOOL NEAR PASCAL IsRectBogus(LPRECT prc);
static LONG NEAR PASCAL atol(char *sz);

#ifdef WIN32
    #define GetFileDriveType GetDriveType
#else
    static  UINT NEAR PASCAL GetFileDriveType(LPSTR szPath);
#endif


#ifndef WIN32
SZCODE szOLENLSDLL[] = "OLE2NLS.DLL";
SZCODE szOLENLSAPI[] = "GetUserDefaultLangID";
#endif

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | mciaviOpenFile | Open an AVI file.
 *      the filename we are to open is passed to npMCI->szFileName.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

BOOL FAR PASCAL mciaviOpenFile(NPMCIGRAPHIC npMCI)
{
    //
    // mciaviOpenFile should not be called with a file open!
    //
    Assert(npMCI->streams == 0);
    Assert(npMCI->hmmio == NULL);
    Assert(npMCI->hpIndex == NULL);
    Assert(!(npMCI->dwFlags & (
                        MCIAVI_NOTINTERLEAVED |
			MCIAVI_ANIMATEPALETTE |
			MCIAVI_CANDRAW |
                        MCIAVI_HASINDEX)));
    //
    //  !!!support open new
    //
    if (npMCI->szFilename[0] == '\0') {
    }

    //
    // what media is this file coming from, will be important later
    // when we play.
    //
    if (npMCI->szFilename[0] == '@')
        npMCI->uDriveType = DRIVE_INTERFACE;
    else
        npMCI->uDriveType = GetFileDriveType(npMCI->szFilename);

#ifdef DEBUG
    switch (npMCI->uDriveType) {
        case DRIVE_CDROM:
            DOUT2("Media is a CD-ROM\n");
            break;

        case DRIVE_REMOTE:
            DOUT2("Media is a Network\n");
            break;

        case DRIVE_FIXED:
            DOUT2("Media is a Hard disk\n");
            break;

        case DRIVE_REMOVABLE:
            DOUT2("Media is a floppy disk\n");
            break;

        case DRIVE_INTERFACE:
            DOUT2("Media is OLE COM Interface\n");
            break;

        default:
            DPF(("Unknown Media type %d\n", npMCI->uDriveType));
            break;
    }
#endif

#ifdef USEAVIFILE
    //
    // if the "filename" is of the form: '@########' then we assume we
    // have been pased a interface pointer of some sort.
    //
    if (npMCI->szFilename[0] == '@' &&
        OpenInterface(npMCI))
	goto DoneOpening;

    // !!! This will open even AVI files this way!
    if ((npMCI->dwOptionFlags & MCIAVIO_USEAVIFILE) &&
        OpenWithAVIFile(npMCI))
        goto DoneOpening;
#endif

    if (!OpenRiffAVIFile(npMCI)) {

        //
        //  unable to open RIFF file, if it was because it was
        //  not a AVI file, then give AVIFile a try.
        //
        if (npMCI->dwTaskError != AVIERR_NOT_AVIFILE)
            goto error;

#ifdef USEAVIFILE
        npMCI->dwTaskError = 0;

        if (!OpenWithAVIFile(npMCI))
#endif
            goto error;

    }

DoneOpening:
    if (OpenFileInit(npMCI)) {
        npMCI->dwTaskError = 0;
        return TRUE;
    }

error:
    mciaviCloseFile(npMCI);

    if (npMCI->dwTaskError == 0)
        npMCI->dwTaskError = MCIERR_INVALID_FILE;

    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | OpenFileInit | called after a file is opened to init things
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

BOOL NEAR PASCAL OpenFileInit(NPMCIGRAPHIC npMCI)
{
    int i;
    RECT rc;

    //
    //  lets make sure we opened something.
    //
    if (npMCI->streams == 0)
        return FALSE;

    if (npMCI->nVideoStreams + npMCI->nAudioStreams + npMCI->nOtherStreams == 0)
        return FALSE;

    if (npMCI->nVideoStreams == 0)
        npMCI->dwFlags &= ~MCIAVI_SHOWVIDEO;

    if (npMCI->nAudioStreams == 0)
        npMCI->dwFlags &= ~MCIAVI_PLAYAUDIO;

    if (npMCI->nAudioStreams > 1) {
	UINT	    wLang;
	int	    stream;
	
#ifndef WIN32
	UINT (WINAPI * GetUserDefaultLangID)(void);
	UINT	    u;
	HANDLE	    hdll;
	
        u = SetErrorMode(SEM_NOOPENFILEERRORBOX);
        hdll = LoadLibrary(szOLENLSDLL);
        SetErrorMode(u);

        if ((UINT)hdll > (UINT)HINSTANCE_ERROR)
	{
	    if ((FARPROC) GetUserDefaultLangID = GetProcAddress(hdll, szOLENLSAPI)) {
#endif
		wLang = GetUserDefaultLangID();
#ifndef WIN32
	    }
	    FreeLibrary(hdll);
	} else
	    wLang = 0;
#endif
	DPF(("Current language: %x\n", wLang));

	if (wLang > 0) {
	    for (stream = 0; stream < npMCI->streams; stream++) {
		if (SH(stream).fccType == streamtypeAUDIO) {

		    if (!(SH(stream).dwFlags & STREAM_ENABLED))
			continue;

		    if (SH(stream).wLanguage == wLang) {
                        npMCI->nAudioStream = stream;
                        npMCI->psiAudio = SI(stream);
			break;
		    }
		}
	    }
	}
    }

    if (npMCI->dwFlags & MCIAVI_NOTINTERLEAVED) {
        npMCI->wEarlyRecords = npMCI->wEarlyVideo;
    }
    else {
        npMCI->wEarlyRecords = max(npMCI->wEarlyVideo, npMCI->wEarlyAudio);
    }

    if (npMCI->wEarlyRecords == 0 &&
	    !(npMCI->dwFlags & MCIAVI_NOTINTERLEAVED)) {
        DPF(("Interleaved file with no audio skew?\n"));
        npMCI->dwFlags |= MCIAVI_NOTINTERLEAVED;
    }

    if (npMCI->dwFlags & MCIAVI_ANIMATEPALETTE) {
        DPF(("This AVI file has palette changes.\n"));

        if (npMCI->nVideoStreams > 1) {
            npMCI->dwFlags &= ~MCIAVI_ANIMATEPALETTE;
            DPF(("...But we are going to ignore them?\n"));
        }
    }

    //
    // this must be set
    //
    if (npMCI->dwSuggestedBufferSize == 0) {
        for (i=0; i<npMCI->streams; i++)
            npMCI->dwSuggestedBufferSize =
                max(SH(i).dwSuggestedBufferSize,npMCI->dwSuggestedBufferSize);
    }

    //
    // check all fields in the main header
    //
    if (npMCI->dwScale == 0 ||
        npMCI->dwRate == 0) {
    }

////will be set when header parsed
////npMCI->dwMicroSecPerFrame      = muldiv32(npMCI->dwScale, 1000000, npMCI->dwRate);
    npMCI->dwPlayMicroSecPerFrame  = npMCI->dwMicroSecPerFrame;

#define COMMON_SCALE    10000
    //
    // convert the rate/scale into something that is normalized to 1000
    //
    npMCI->dwRate = muldiv32(npMCI->dwRate, COMMON_SCALE, npMCI->dwScale);
    npMCI->dwScale = COMMON_SCALE;

    //
    // walk all streams and fix them up.
    //
    for (i=0; i<npMCI->streams; i++) {
        STREAMINFO *psi = SI(i);
        LONG lStart;
        LONG lEnd;

        //
        // convert the rate/scale into something that is normalized to 1000
        //
        psi->sh.dwRate = muldiv32(psi->sh.dwRate, COMMON_SCALE, psi->sh.dwScale);
        psi->sh.dwScale = COMMON_SCALE;

        //
        // trim any streams that hang over the movie.
        //
        lStart = MovieToStream(psi, 0);
        lEnd   = MovieToStream(psi, npMCI->lFrames);

        if ((LONG)(psi->sh.dwStart + psi->sh.dwLength) > lEnd) {

            DPF(("Stream #%d is too long, was %ld now %ld\n", i,
                psi->sh.dwLength, lEnd - psi->sh.dwStart));

            psi->sh.dwLength = lEnd - psi->sh.dwStart;
        }
    }

    //
    // fix up the movie rect
    //
    if (IsRectEmpty(&npMCI->rcMovie)) {
        DPF2(("Movie rect is empty\n"));

        SetRectEmpty(&rc);

        for (i=0; i<npMCI->streams; i++)
            UnionRect(&rc,&rc,&SH(i).rcFrame);

        npMCI->rcMovie = rc;
    }

    rc = npMCI->rcMovie;

    //
    // always read the index, so we can skip frames even on CD!
    //
    ReadIndex(npMCI);

    DPF(("Key frames are every (on average): %ld frames (%ld ms)\n",npMCI->dwKeyFrameInfo, MovieToTime(npMCI->dwKeyFrameInfo)));

    // force things to happen, in case we're re-loading
    SetRectEmpty(&npMCI->rcSource);
    SetRectEmpty(&npMCI->rcDest);

    /* this will call DrawDibBegin() ... */
    DevicePut(npMCI, &rc, MCI_DGV_PUT_SOURCE);

    /*
     * also set the dest rect. This should be done
     * by the WM_SIZE message sent during SetWindowToDefaultSize.
     * On NT, the WM_SIZE message is not sent synchronously since it
     * is an inter-thread sendmessage (the winproc is on the original thread
     * whereas we are currently running on the avi thread). The winproc
     * thread may well not get the WM_SIZE message until much too late, so
     * set the dest rect here. Note: don't use ResetDestRect since that
     * also relies on the window size, which is not set yet.
     */

    /* double frame size of destination if zoom by 2 */

    if (npMCI->dwOptionFlags & MCIAVIO_ZOOMBY2)
        SetRect(&rc, 0, 0, rc.right*2, rc.bottom*2);

    DevicePut(npMCI, &rc, MCI_DGV_PUT_DESTINATION);

    //
    // size the window and things.
    //
    SetWindowToDefaultSize(npMCI);

    DrawBegin(npMCI, NULL);
    return TRUE;
}

#ifdef USEAVIFILE

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | OpenWithAVIFile | Open an file using AVIFile
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

BOOL NEAR PASCAL OpenWithAVIFile(NPMCIGRAPHIC npMCI)
{
    IAVIFile FAR *pf = NULL;

    if (!InitAVIFile(npMCI))
        return FALSE;

    AVIFileOpen(&pf, npMCI->szFilename, MMIO_READ, 0);

    if (pf == NULL) {
        npMCI->dwTaskError = MCIERR_INVALID_FILE;
        return FALSE;
    }

    if (!OpenAVIFile(npMCI, pf)) {
        mciaviCloseFile(npMCI);
        pf->lpVtbl->Release(pf);
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | OpenInterface | Open an interface pointer
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

BOOL NEAR PASCAL OpenInterface(NPMCIGRAPHIC npMCI)
{
    IUnknown FAR *p;
    IAVIFile FAR *pf=NULL;
    IAVIStream FAR *ps=NULL;

    if (!InitAVIFile(npMCI))
        return FALSE;

    if (npMCI->szFilename[0] != '@')
        return FALSE;

#ifdef UNICODE
    p = (IUnknown FAR *)wcstol(npMCI->szFilename+1, NULL, 10);
#else
    p = (IUnknown FAR *)atol(npMCI->szFilename+1);
#endif

    if (!IsValidInterface(p))
        return FALSE;

#ifndef WIN32
    //!!!we need to do the PSP stuff? or will the TASK stuff in
    //!!!COMPOBJ mess us up?
    {
    extern void FAR SetPSP(UINT psp);
    SetPSP(npMCI->pspParent);
    }
#endif

    p->lpVtbl->QueryInterface(p, &IID_IAVIFile, (LPVOID FAR *)&pf);

    if (pf != NULL)
    {
        if (OpenAVIFile(npMCI, pf))
            return TRUE;

        pf->lpVtbl->Release(pf);
    }

    p->lpVtbl->QueryInterface(p, &IID_IAVIStream, (LPVOID FAR *)&ps);

    if (ps != NULL)
    {
        AVIMakeFileFromStreams(&pf, 1, &ps);
        ps->lpVtbl->Release(ps);

        if (pf == NULL)
            return FALSE;

        if (OpenAVIFile(npMCI, pf))
            return TRUE;

        pf->lpVtbl->Release(pf);
        return FALSE;
    }

    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | OpenAVIFile | Open an a AVIFile object
 *
 *  NOTE we do not do call AddRef() we assume we dont need to.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

BOOL NEAR PASCAL OpenAVIFile(NPMCIGRAPHIC npMCI, IAVIFile FAR *pf)
{
    AVIFILEINFO info;
    HRESULT hr;
    IAVIStream FAR *ps;
    STREAMINFO *psi;
    int i;

    Assert(npMCI->pf == NULL);

    _fmemset(&info, 0, sizeof(info));
    hr = AVIFileInfo(pf, &info, sizeof(info));

    if (FAILED(GetScode(hr))) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
        return FALSE;
    }

    DPF(("OpenAVIFile: %s\n", (LPSTR)info.szFileType));

    //
    // get rid of bad files
    //
    if (info.dwStreams == 0 || info.dwStreams > 255 || info.dwLength == 0) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
        return FALSE;
    }

    //
    // make a copy of the VTable, for later use
    //
    npMCI->pf = pf;
////npMCI->vt = *pf->lpVtbl;

    npMCI->dwFlags |= MCIAVI_HASINDEX;

    npMCI->dwMicroSecPerFrame = muldiv32(info.dwScale, 1000000, info.dwRate);

    npMCI->lFrames  = (LONG)info.dwLength;
    npMCI->dwRate   = info.dwRate;
    npMCI->dwScale  = info.dwScale;

    npMCI->streams  = (int)info.dwStreams;

    npMCI->dwBytesPerSec = info.dwMaxBytesPerSec;
    npMCI->dwSuggestedBufferSize = info.dwSuggestedBufferSize + 2*sizeof(DWORD);

    SetRect(&npMCI->rcMovie,0,0,(int)info.dwWidth,(int)info.dwHeight);

    npMCI->paStreamInfo = (STREAMINFO*)
        LocalAlloc(LPTR,npMCI->streams * sizeof(STREAMINFO));

    if (npMCI->paStreamInfo == NULL) {
        npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
        npMCI->pf = NULL;
        return FALSE;
    }

    for (i = 0; i < npMCI->streams; i++) {

        ps = NULL;
        AVIFileGetStream(pf, &ps, 0, i);

        if (ps == NULL) {
            npMCI->dwTaskError = MCIERR_INVALID_FILE;
            npMCI->pf = NULL;
            return FALSE;
        }

        if (!OpenAVIStream(npMCI, i, ps))
            DPF(("Error opening stream %d!\n", i));

        if (npMCI->dwTaskError) {
            npMCI->pf = NULL;
            return FALSE;
        }
    }

    //
    // compute the key frames every value
    //
    // do this by finding the key frame average over the first few frames.
    //
    #define NFRAMES 250

    if (psi = npMCI->psiVideo) {
        LONG l;
        int nKeyFrames=0;

        for (l=0; l<NFRAMES; l++) {
            if (AVIStreamFindSample(psi->ps, psi->sh.dwStart+l, FIND_PREV|FIND_KEY) == l)
                nKeyFrames++;
        }

        if (nKeyFrames > 1)
            npMCI->dwKeyFrameInfo = (DWORD)((NFRAMES + nKeyFrames/2)/nKeyFrames);
        else
            npMCI->dwKeyFrameInfo = 0;
    }

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | OpenAVIStream | Open an a AVIStream object
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

BOOL NEAR PASCAL OpenAVIStream(NPMCIGRAPHIC npMCI, int stream, IAVIStream FAR *ps)
{
    STREAMINFO* psi;
    AVISTREAMINFO info;
    HRESULT hr;

    _fmemset(&info, 0, sizeof(info));
    hr = AVIStreamInfo(ps, &info, sizeof(info));

    if (FAILED(GetScode(hr))) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
        return FALSE;
    }

    DPF(("OpenAVIStream(%d) %4.4s:%4.4s %s\n", stream, (LPSTR)&info.fccType, (LPSTR)&info.fccHandler, (LPSTR)info.szName));

    //
    // init the STREAMINFO from the IAVIStream
    //
    psi = SI(stream);

    psi->ps = ps;           // save interface
////psi->vt = *ps->lpVtbl;  // save VTable   !!!needed?

    psi->sh.fccType                 = info.fccType;
    psi->sh.fccHandler              = info.fccHandler;
    psi->sh.dwFlags                 = info.dwFlags;
    psi->sh.wPriority               = info.wPriority;
    psi->sh.wLanguage               = info.wLanguage;
    psi->sh.dwInitialFrames         = 0; // info.dwInitialFrames;
    psi->sh.dwScale                 = info.dwScale;
    psi->sh.dwRate                  = info.dwRate;
    psi->sh.dwStart                 = info.dwStart;
    psi->sh.dwLength                = info.dwLength;
    psi->sh.dwSuggestedBufferSize   = info.dwSuggestedBufferSize;
    psi->sh.dwQuality               = info.dwQuality;
    psi->sh.dwSampleSize            = info.dwSampleSize;
    psi->sh.rcFrame                 = info.rcFrame;
    DPF0(("OpenAVIStream: #%d, rc [%d %d %d %d]\n", stream, info.rcFrame));

    //
    // get the format of the stream.
    //
    AVIStreamFormatSize(ps, 0, &psi->cbFormat);
    psi->lpFormat = GlobalAllocPtr(GMEM_MOVEABLE, psi->cbFormat);

    if (!psi->lpFormat) {
        npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
        return FALSE;
    }

    AVIStreamReadFormat(psi->ps, 0, psi->lpFormat, &psi->cbFormat);

    //
    // get the extra data for the stream.
    //
    AVIStreamReadData(psi->ps,ckidSTREAMHANDLERDATA, NULL, &psi->cbData);

    if (psi->cbData > 0) {
        psi->lpData = GlobalAllocPtr(GMEM_MOVEABLE, psi->cbData);

        if (!psi->lpData) {
            npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
            return FALSE;
        }

        AVIStreamReadData(psi->ps, ckidSTREAMHANDLERDATA, NULL, &psi->cbData);
    }

    return InitStream(npMCI, psi);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | InitAVIFile | called to RTL to AVIFILE.DLL
 *
 * @rdesc TRUE means OK, otherwise error
 *
 ***************************************************************************/

#ifdef WIN32
    // For the moment the 16 bit and 32 bit AVIFILE DLLs share the same
    // name.  If the history of NT is to be repeated this will change.
    SZCODE szAVIFILE[] = TEXT("AVIFILE.DLL");
    SZCODE szCOMPOBJ[] = TEXT("COMPOB32");
#else
    SZCODE szAVIFILE[] = "AVIFILE.DLL";
    SZCODE szCOMPOBJ[] = "COMPOBJ";
#endif

// On NT the entry points will NOT be unicode strings, as there is
// no unicode version of GetProcAddress.  BUT SZCODE generate UNICODE...
SZCODEA szAVIFileInit[]      = "AVIFileInit";
SZCODEA szAVIFileExit[]      = "AVIFileExit";
SZCODEA szIsValidInterface[] = "IsValidInterface";
SZCODEA szAVIMakeFileFromStreams[] = "AVIMakeFileFromStreams";
SZCODEA szAVIStreamBeginStreaming[] = "AVIStreamBeginStreaming";
SZCODEA szAVIStreamEndStreaming[] = "AVIStreamEndStreaming";
#ifdef UNICODE
  // There has GOT to be a neat way of combining macros so that we can
  // assign AVIFileOpenA/W to the name string definining the entry point,
  // and still get avifilex.h to get AVIFileOpen function calls replaced by
  // using the function variable.
  SZCODEA szAVIFileOpen[]      = "AVIFileOpenW";
#else
  SZCODEA szAVIFileOpen[]      = "AVIFileOpen";
#endif

BOOL FAR InitAVIFile(NPMCIGRAPHIC npMCI)
{
    UINT u;

    if (hdllAVIFILE == (HMODULE)-1)
        return FALSE;

    if (hdllAVIFILE == NULL) {

        u = SetErrorMode(SEM_NOOPENFILEERRORBOX);
        hdllAVIFILE = LoadLibrary(szAVIFILE);
        SetErrorMode(u);

#ifndef WIN32
        if ((UINT)hdllAVIFILE <= (UINT)HINSTANCE_ERROR)
            hdllAVIFILE = NULL;
#endif

        if (hdllAVIFILE == NULL) {
            hdllAVIFILE = (HMODULE)-1;
            return FALSE;
        }

        hdllCOMPOBJ = GetModuleHandle(szCOMPOBJ);
        (FARPROC)XIsValidInterface = GetProcAddress(hdllCOMPOBJ, szIsValidInterface);

        Assert(hdllCOMPOBJ != NULL);
        Assert(XIsValidInterface != NULL);

        (FARPROC)XAVIFileInit = GetProcAddress(hdllAVIFILE, szAVIFileInit);
        (FARPROC)XAVIFileExit = GetProcAddress(hdllAVIFILE, szAVIFileExit);
        (FARPROC)XAVIFileOpen = GetProcAddress(hdllAVIFILE, szAVIFileOpen);
        (FARPROC)XAVIMakeFileFromStreams = GetProcAddress(hdllAVIFILE, szAVIMakeFileFromStreams);
        (FARPROC)XAVIStreamBeginStreaming = GetProcAddress(hdllAVIFILE, szAVIStreamBeginStreaming);
        (FARPROC)XAVIStreamEndStreaming = GetProcAddress(hdllAVIFILE, szAVIStreamEndStreaming);

        Assert(XAVIFileInit != NULL);
        Assert(XAVIFileExit != NULL);
        Assert(XAVIFileOpen != NULL);
        Assert(XAVIMakeFileFromStreams != NULL);
    }

    //
    // we need to call AVIFileInit() and AVIFileExit() for each task that
    // is using AVIFile or things will not work right.
    //
    if (!(npMCI->dwFlags & MCIAVI_USING_AVIFILE)) {

        npMCI->dwFlags |= MCIAVI_USING_AVIFILE;

        AVIFileInit();
        uAVIFILE++;
    }

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | FreeAVIFile | called to un-RTL to AVIFILE.DLL
 *
 * @rdesc TRUE means OK, otherwise error
 *
 ***************************************************************************/

BOOL FAR FreeAVIFile(NPMCIGRAPHIC npMCI)
{
    if (!(npMCI->dwFlags & MCIAVI_USING_AVIFILE))
        return FALSE;

    Assert(hdllAVIFILE != (HMODULE)-1 && hdllAVIFILE != NULL);

    // free this tasks use of AVIFile
    AVIFileExit();

    // if no more people using AVIFile lets the DLLs go.
    Assert(uAVIFILE > 0);
    uAVIFILE--;

    if (uAVIFILE == 0) {
        FreeLibrary(hdllAVIFILE);
        hdllAVIFILE = NULL;
        hdllCOMPOBJ = NULL;
    }
}

#endif /* USEAVIFILE */


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | OpenRiffAVIFile | Open an RIFF AVI file
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

BOOL NEAR PASCAL OpenRiffAVIFile(NPMCIGRAPHIC npMCI)
{
    HMMIO		hmmio;
    HANDLE		h = NULL;
    BOOL		fRet = TRUE;
    MMIOINFO		mmioInfo;
    MMCKINFO		ckRIFF;
    MMCKINFO		ckLIST;
    MMCKINFO            ckRECORD;

    _fmemset(&mmioInfo, 0, sizeof(MMIOINFO));
    mmioInfo.htask = (HANDLE)npMCI->hCallingTask;

    hmmio = mmioOpen(npMCI->szFilename, &mmioInfo, MMIO_READ | MMIO_DENYWRITE);

    if (hmmio == NULL)
        hmmio = mmioOpen(npMCI->szFilename, &mmioInfo, MMIO_READ);

    if (!hmmio) {
	switch (mmioInfo.wErrorRet) {
	    case MMIOERR_OUTOFMEMORY:
		npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
		break;
	    case MMIOERR_FILENOTFOUND:
	    case MMIOERR_CANNOTOPEN:
	    default:
		npMCI->dwTaskError = MCIERR_FILE_NOT_FOUND;
		break;
	}
	fRet = FALSE;
	goto exit;
    }

    npMCI->hmmio = hmmio;

    /*
    ** Descend into RIFF file
    */
    if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
	goto ERROR_BADFILE;
    }

    /*
     * check for a 'QuickTime AVI' file, a QuickTime AVI file is a
     * QuickTime public movie with a AVI file in the 'mdat' atom.
     */
    if (ckRIFF.cksize == mmioFOURCC('m','d','a','t'))
    {
        DPF(("File is a QuickTime public movie\n"));

        /*
         * now the 'mdat' atom better be a RIFF/AVI or we cant handle it.
         */
        if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0) {
            npMCI->dwTaskError = MCIERR_INVALID_FILE;
            goto ERROR_BADFILE;
        }
    }

    /* Make sure it's a RIFF file */
    if (ckRIFF.ckid != FOURCC_RIFF) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
        goto ERROR_NOTAVIFILE;
    }

    /* Otherwise, it should be an AVI file */
    if (ckRIFF.fccType != formtypeAVI) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
        goto ERROR_NOTAVIFILE;
    }

    /*
    ** Descend into header LIST
    */
    ckLIST.fccType = listtypeAVIHEADER;
    if (mmioDescend(hmmio, &ckLIST, &ckRIFF, MMIO_FINDLIST) != 0) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
	goto ERROR_BADFILE;
    }

    /* Leave space at end of buffer for pad word */
    h = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, ckLIST.cksize -
				    sizeof(DWORD) +
				    sizeof(DWORD));

    if (!h) {
	npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
	return FALSE;
    }

    npMCI->lp = npMCI->lpBuffer = (LPSTR) GlobalLock(h);

    DPF(("Reading header list: %lu bytes.\n", ckLIST.cksize - sizeof(DWORD)));

    if (mmioRead(hmmio, npMCI->lp, ckLIST.cksize - sizeof(DWORD))
			    != (LONG) (ckLIST.cksize - sizeof(DWORD))) {
	npMCI->dwTaskError = MCIERR_FILE_READ;
	goto ERROR_BADFILE;
    }

#ifdef USE_AVIFILE_FOR_NON_INT
    //
    //  we check here for AVI RIFF files we dont want to handle with our
    //  built in code, and want to pass on to AVIFILE.DLL
    //
    //  we handle the following files:
    //
    //      interleaved
    //
    //  we pass on the following files to AVIFILE.DLL
    //
    //      non-interleaved
    //
    //  pretty simple right now, just interleaved non-interlaved
    //  but could get as complex as you want.
    //
    {
    MainAVIHeader FAR * lpHdr;

    lpHdr = (MainAVIHeader FAR *)((BYTE FAR *)npMCI->lp + 8);

    if (!(lpHdr->dwFlags & AVIF_ISINTERLEAVED) ||
        lpHdr->dwInitialFrames == 0) {

        DOUT("File is not interleaved, giving it to AVIFILE.DLL\n");
        goto ERROR_NOTAVIFILE;
    }

    //
    // ok now we have a 1:1 interleved file.
    //
    // always use our code on a CD-ROM, but on other media...
    //
    switch (npMCI->uDriveType) {
        case DRIVE_CDROM:
            break;

        case DRIVE_REMOTE:
        case DRIVE_FIXED:
        case DRIVE_REMOVABLE:
            break;

        default:
            break;
    }
    }
#endif

    if (PEEK_DWORD() == ckidAVIMAINHDR) {
	if (!ParseNewHeader(npMCI))
	    goto ERROR_BADFILE;
    } else {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
	goto ERROR_BADFILE;
    }

    /* Ascend out of header LIST */
    if (mmioAscend(hmmio, &ckLIST, 0) != 0) {
	npMCI->dwTaskError = MCIERR_FILE_READ;
	goto ERROR_BADFILE;
    }

    /* Initially, no frame has been drawn */
    npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;

    /*
    ** Descend into big 'Movie LIST'
    */
    ckLIST.fccType = listtypeAVIMOVIE;
    if (mmioDescend(hmmio, &ckLIST, &ckRIFF, MMIO_FINDLIST) != 0) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
	goto ERROR_BADFILE;
    }

    npMCI->dwMovieListOffset = ckLIST.dwDataOffset;

    /* Calculate end of 'movi' list, in case we need to read the index */
    npMCI->dwBigListEnd = ckLIST.dwDataOffset + ckLIST.cksize +
				(ckLIST.cksize & 1);	

    /*
    ** Descend into header of first chunk
    */
    if (mmioDescend(hmmio, &ckRECORD, &ckLIST, 0) != 0) {
        npMCI->dwTaskError = MCIERR_INVALID_FILE;
        goto ERROR_BADFILE;
    }
    npMCI->dwFirstRecordType = ckRECORD.ckid;
    npMCI->dwFirstRecordSize = ckRECORD.cksize + 2 * sizeof(DWORD);
    npMCI->dwFirstRecordPosition = mmioSeek(hmmio, 0, SEEK_CUR);

    if (mmioAscend(hmmio, &ckRECORD, 0) != 0) {
	npMCI->dwTaskError = MCIERR_FILE_READ;
	goto ERROR_BADFILE;
    }

#ifdef DEBUG
    DPF2(("First record (%4.4s) 0x%lx bytes at position 0x%lx.\n",
                (LPSTR)&npMCI->dwFirstRecordType,
                npMCI->dwFirstRecordSize,
                npMCI->dwFirstRecordPosition));

    if (npMCI->dwFirstRecordPosition & 0x7ff) {
	DPF(("!!\n"));
	DPF(("!!  This file is not properly aligned to a 2K boundary.\n"));
	DPF(("!!  It may not play well from CD-ROM.\n"));
	DPF(("!!\n"));
    }
#endif

exit:
    if (!fRet)
        mciaviCloseFile(npMCI);

    if (h) {
        npMCI->lpBuffer = NULL;
        npMCI->dwBufferSize = 0L;
	GlobalUnlock(h);
	GlobalFree(h);
    }

    return fRet;

ERROR_NOTAVIFILE:
    npMCI->dwTaskError = AVIERR_NOT_AVIFILE;        // mark as not a AVI file

ERROR_BADFILE:
    fRet = FALSE;
    goto exit;
}

/***************************************************************************
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | ParseNewHeader | 'nuf said
 *
 ***************************************************************************/

BOOL NEAR PASCAL ParseNewHeader(NPMCIGRAPHIC npMCI)
{
    DWORD		dwHeaderSize;
    MainAVIHeader FAR *	lpHdr;
    int			stream;

    if (GET_DWORD() != ckidAVIMAINHDR) {
	goto FileError;
    }

    dwHeaderSize = GET_DWORD(); /* Skip size */

    /* Now, we're pointing at the actual header */
    lpHdr = (MainAVIHeader FAR *) npMCI->lp;

    npMCI->lFrames = (LONG)lpHdr->dwTotalFrames;
    npMCI->dwMicroSecPerFrame = lpHdr->dwMicroSecPerFrame;
    npMCI->dwRate = 1000000;
    npMCI->dwScale = npMCI->dwMicroSecPerFrame;

    /* Reject some bad values */
    if (!lpHdr->dwStreams || lpHdr->dwStreams > 255 || !npMCI->lFrames) {
	goto FileError;
    }

    npMCI->streams = (int) lpHdr->dwStreams;
    npMCI->dwBytesPerSec = lpHdr->dwMaxBytesPerSec;
    npMCI->wEarlyRecords = (UINT) lpHdr->dwInitialFrames;
    npMCI->dwSuggestedBufferSize = lpHdr->dwSuggestedBufferSize;

    SetRect(&npMCI->rcMovie,0,0,(int)lpHdr->dwWidth,(int)lpHdr->dwHeight);

    npMCI->dwFlags |= MCIAVI_HASINDEX;

    if (!(lpHdr->dwFlags & AVIF_ISINTERLEAVED)) {
	DPF(("File is not interleaved.\n"));
	npMCI->dwFlags |= MCIAVI_NOTINTERLEAVED;
    }

    SKIP_BYTES(dwHeaderSize);	/* Skip rest of chunk */

    npMCI->paStreamInfo = (STREAMINFO NEAR *)
		    LocalAlloc(LPTR, npMCI->streams * sizeof(STREAMINFO));
    // !!! error check

    for (stream = 0; stream < npMCI->streams; stream++) {
	AVIStreamHeader FAR *	lpStream;
	HPSTR			hpNextChunk;
        STREAMINFO *            psi = &npMCI->paStreamInfo[stream];
	
	if (GET_DWORD() != FOURCC_LIST) {
	    goto FileError;
	}

	dwHeaderSize = GET_DWORD(); /* Skip size */

	hpNextChunk = npMCI->lp + (dwHeaderSize + (dwHeaderSize & 1));
	
	if (GET_DWORD() != listtypeSTREAMHEADER) {
	    goto FileError;
	}
	
	/* Now, we're at the begging of the stream's header chunks. */

	if (GET_DWORD() != ckidSTREAMHEADER) {
	    goto FileError;
	}

	dwHeaderSize = GET_DWORD(); /* Skip size */

	/* Now, we're pointing at the stream header */
	lpStream = (AVIStreamHeader FAR *) npMCI->lp;
        hmemcpy(&psi->sh, lpStream, min(dwHeaderSize, sizeof(psi->sh)));

        //
        // reject files with more than one video stream.
        //
        if (psi->sh.fccType == streamtypeVIDEO &&
            npMCI->nVideoStreams >= 1) {
            DPF(("File has multiple video streams, giving it to AVIFILE.DLL\n"));
            goto DontHandleThisFile;
        }

	SKIP_BYTES(dwHeaderSize);
	
        /* Read the  format */
        if (GET_DWORD() != ckidSTREAMFORMAT) {
            goto FileError;
        }

        dwHeaderSize = GET_DWORD(); /* Skip size */

        if (dwHeaderSize > 16384L) {
	    goto FileError;
	}
	
        psi->cbFormat = dwHeaderSize;
        psi->lpFormat = GlobalAllocPtr(GHND,dwHeaderSize);
        if (!psi->lpFormat) {
            npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
            return FALSE;
        }
	
        hmemcpy(psi->lpFormat, npMCI->lp, dwHeaderSize);
	
        SKIP_BYTES(dwHeaderSize);

        if (PEEK_DWORD() == ckidSTREAMHANDLERDATA) {
	    GET_DWORD();
            dwHeaderSize = GET_DWORD(); /* Skip size */
	
            psi->cbData = dwHeaderSize;
            psi->lpData = GlobalAllocPtr(GHND,dwHeaderSize);

            if (!psi->lpData) {
                npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
		return FALSE;
            }

            hmemcpy(psi->lpData, npMCI->lp, dwHeaderSize);

            /* Skip to end of Data chunk */
            SKIP_BYTES(dwHeaderSize);
        } else {
            psi->cbData = 0;
            psi->lpData = NULL;
        }

        InitStream(npMCI, psi);
	
	npMCI->lp = hpNextChunk;
    }

    return TRUE;

FileError:
    npMCI->dwTaskError = MCIERR_INVALID_FILE;
    return FALSE;

DontHandleThisFile:
    npMCI->dwTaskError = AVIERR_NOT_AVIFILE;
    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | mciaviCloseFile | Close an AVI file.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

BOOL FAR PASCAL mciaviCloseFile (NPMCIGRAPHIC npMCI)
{
    if (!npMCI)
        return FALSE;

#ifdef DEBUG
    npMCI->mciid = MCIIDX;
#endif

    if (npMCI->lpMMIOBuffer) {
        GlobalFreePtr(npMCI->lpMMIOBuffer);
        npMCI->lpMMIOBuffer = NULL;
    }

    npMCI->hicDraw = NULL;

    if (npMCI->hicDrawDefault) {
	if (npMCI->hicDrawDefault != (HIC) -1)
	    ICClose(npMCI->hicDrawDefault);
        npMCI->hicDrawDefault = NULL;
    }

    if (npMCI->hicDrawFull) {
	if (npMCI->hicDrawFull != (HIC) -1)
	    ICClose(npMCI->hicDrawFull);
        npMCI->hicDrawFull = NULL;
    }

    if (npMCI->hicDecompress) {
	// !!! What if we never began it?
	ICDecompressEnd(npMCI->hicDecompress);

        ICClose(npMCI->hicDecompress);
        npMCI->hicDecompress = NULL;
    }

    if (npMCI->hicInternal) {
        ICClose(npMCI->hicInternal);
        npMCI->hicInternal = NULL;
    }

    if (npMCI->hicInternalFull) {
        ICClose(npMCI->hicInternalFull);
        npMCI->hicInternalFull = NULL;
    }

    if (npMCI->hmmio) {
	mmioClose(npMCI->hmmio, 0);
        npMCI->hmmio = NULL;
    }

    if (npMCI->hmmioAudio) {
	mmioClose(npMCI->hmmioAudio, 0);
        npMCI->hmmioAudio = NULL;
    }

    if (npMCI->pWF) {
	LocalFree((HANDLE) npMCI->pWF);
        npMCI->pWF = NULL;
    }

    if (npMCI->pbiFormat) {
	GlobalFreePtr(npMCI->pbiFormat);
        npMCI->pbiFormat = NULL;
    }

//  if (npMCI->hpal) {
//      DeleteObject(npMCI->hpal);
//      npMCI->hpal = NULL;
//  }

    if (npMCI->hpDecompress) {
        GlobalFreePtr(npMCI->hpDecompress);
        npMCI->hpDecompress = NULL;
    }

    if (npMCI->hpIndex) {
        GlobalFreePtr(npMCI->hpIndex);
        npMCI->hpIndex = NULL;
    }

    if (npMCI->hpFrameIndex) {
        GlobalFreePtr(npMCI->hpFrameIndex);  //!!!NTBUG not same pointer!
        npMCI->hpFrameIndex = NULL;
    }

    if (npMCI->pVolumeTable) {
        LocalFree((HLOCAL)npMCI->pVolumeTable);
        npMCI->pVolumeTable = NULL;
    }

#ifdef USEAVIFILE
    if (npMCI->pf) {
	AVIFileClose(npMCI->pf);
	npMCI->pf = NULL;
    }
#endif

    if (npMCI->paStreamInfo) {
        int i;

        for (i = 0; i < npMCI->streams; i++)
            CloseStream(npMCI, &npMCI->paStreamInfo[i]);

        LocalFree((HLOCAL)npMCI->paStreamInfo);
        npMCI->paStreamInfo = NULL;
    }

    npMCI->streams = 0;
    npMCI->nAudioStreams = 0;
    npMCI->nVideoStreams = 0;
    npMCI->nErrorStreams = 0;
    npMCI->nOtherStreams = 0;

    npMCI->wEarlyVideo = 0;
    npMCI->wEarlyAudio = 0;
    npMCI->wEarlyRecords = 0;

    //!!! I bet we need to clear more
    npMCI->dwFlags &= ~(MCIAVI_NOTINTERLEAVED |
			MCIAVI_ANIMATEPALETTE |
			MCIAVI_CANDRAW |
                        MCIAVI_HASINDEX);

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | CloseStream | Close an StreamAVI file.
 *
 ***************************************************************************/

void NEAR PASCAL CloseStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi)
{
    psi->dwFlags &= ~STREAM_ENABLED;
////psi->sh.fccType = 0;
////psi->sh.fccHandler = 0;

    if (psi->lpFormat)
        GlobalFreePtr(psi->lpFormat);
    psi->lpFormat = NULL;

    if (psi->lpData)
        GlobalFreePtr(psi->lpData);
    psi->lpData = NULL;

    if (psi->hicDraw)
        ICClose(psi->hicDraw);
    psi->hicDraw = NULL;

#ifdef USEAVIFILE
    if (psi->ps)
        AVIStreamClose(psi->ps);
    psi->ps = NULL;
#endif
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | InitStream | initialize a stream
 *
 ***************************************************************************/

BOOL NEAR PASCAL InitStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi)
{
    BOOL f;

    //
    // set flags
    //
    if (psi->sh.dwFlags & AVISF_VIDEO_PALCHANGES)
        psi->dwFlags |= STREAM_PALCHANGES;

    psi->lStart = (LONG)psi->sh.dwStart;
    psi->lEnd   = (LONG)psi->sh.dwStart + psi->sh.dwLength;

    if (psi->sh.fccType == streamtypeVIDEO &&
        !(npMCI->dwFlags & MCIAVI_NOTINTERLEAVED))
        psi->lStart -= (LONG)psi->sh.dwInitialFrames;

    switch(psi->sh.fccType) {
        case streamtypeVIDEO:
            f = InitVideoStream(npMCI, psi);
            break;

        case streamtypeAUDIO:
            f = InitAudioStream(npMCI, psi);
            break;

        default:
            f = InitOtherStream(npMCI, psi);
            break;
            }

    if (!f)  {
        psi->dwFlags |= STREAM_ERROR;
        npMCI->nErrorStreams++;
        CloseStream(npMCI, psi);
    }

    //
    // disable the stream if the file header says to
    //
    if (psi->sh.dwFlags & AVISF_DISABLED) {
        psi->dwFlags &= ~STREAM_ENABLED;
    }

    return f;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | InitVideoStream | initialize a video stream
 *
 ***************************************************************************/

BOOL NEAR PASCAL InitVideoStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi)
{
    LPBITMAPINFOHEADER lpbi;
    int stream = psi - npMCI->paStreamInfo;

    npMCI->wEarlyVideo = (UINT)psi->sh.dwInitialFrames;

    if (psi->sh.dwFlags & AVISF_VIDEO_PALCHANGES) {
        //!!! is this right.
        npMCI->dwFlags |= MCIAVI_ANIMATEPALETTE;
    }

    if (IsRectBogus(&psi->sh.rcFrame)) {
        DPF(("BOGUS Stream rectangle [%d %d %d %d]\n", psi->sh.rcFrame));
        SetRectEmpty(&psi->sh.rcFrame);
    }

    // In case the rectangle is totally wrong, chop it down to size....
    // !!! What if the user _wants_ a zero-size RECT?
    IntersectRect(&psi->sh.rcFrame, &psi->sh.rcFrame, &npMCI->rcMovie);

    if (IsRectEmpty(&psi->sh.rcFrame)) {
        DPF(("Video stream rect is empty, correcting\n"));
        SetRect(&psi->sh.rcFrame, 0, 0,
            (int)((LPBITMAPINFOHEADER)psi->lpFormat)->biWidth,
            (int)((LPBITMAPINFOHEADER)psi->lpFormat)->biHeight);
    }

    //
    // make sure the biCompression is right for RLE files.
    //
    lpbi = (LPBITMAPINFOHEADER)psi->lpFormat;

    if (psi->sh.fccHandler == 0) {

        if (lpbi->biCompression == 0)
            psi->sh.fccHandler = comptypeDIB;

        if (lpbi->biCompression == BI_RLE8 && lpbi->biBitCount == 8)
            psi->sh.fccHandler = comptypeRLE;

        if (lpbi->biCompression > 256)
            psi->sh.fccHandler = lpbi->biCompression;
    }

    if (lpbi->biCompression <= BI_RLE8 && lpbi->biBitCount == 8) {

        if (psi->sh.fccHandler == comptypeRLE0 ||
            psi->sh.fccHandler == comptypeRLE)
            lpbi->biCompression = BI_RLE8;

// Assuming a DIB handler has RGB data will blow up files that have RLE data.
// Unfortunately, VidEdit writes out files like this.
//        if (psi->sh.fccHandler == comptypeDIB)
//            lpbi->biCompression = BI_RGB;
    }

    //
    // make sure the color table is set to the right size
    //
    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
        lpbi->biClrUsed = (1 << (int)lpbi->biBitCount);

    //
    // try to open draw handler
    //
    if (psi->sh.fccHandler) {
        psi->hicDraw = ICDrawOpen(psi->sh.fccType,psi->sh.fccHandler,psi->lpFormat);

        if (psi->hicDraw)
            DPF(("Opened draw handler %4.4s:%4.4s\n", (LPSTR)&psi->sh.fccType,(LPSTR)&psi->sh.fccHandler));
    }

    //
    // one video stream is the master, he controls the palette etc
    // for lack of a better default the first video stream will
    // become the master.
    //
    if (npMCI->pbiFormat == NULL) {

        npMCI->nVideoStream = stream;
        npMCI->psiVideo = psi;

        npMCI->pbiFormat = (LPBITMAPINFOHEADER)
                    GlobalAllocPtr(GMEM_MOVEABLE, psi->cbFormat);

	if (!npMCI->pbiFormat) {
	    npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
	    return FALSE;
	}

	//
        // copy the entire format over
	//
        hmemcpy(npMCI->pbiFormat,psi->lpFormat,psi->cbFormat);

        npMCI->bih = *npMCI->pbiFormat;
        npMCI->bih.biSize = sizeof(BITMAPINFOHEADER);
        npMCI->bih.biCompression = BI_RGB;

        if (npMCI->bih.biClrUsed) {
            /* save the original colors. */
            hmemcpy(npMCI->argb, (LPBYTE)npMCI->pbiFormat + npMCI->pbiFormat->biSize,
                            (int)npMCI->bih.biClrUsed * sizeof(RGBQUAD));
            hmemcpy(npMCI->argbOriginal, (LPSTR) npMCI->pbiFormat + npMCI->pbiFormat->biSize,
                            (int)npMCI->bih.biClrUsed * sizeof(RGBQUAD));
        }

	//
	// now open the decompressor, try fastdecompress if it will do it.
	//
        npMCI->hicDecompress = ICLocate(ICTYPE_VIDEO,psi->sh.fccHandler,
                    psi->lpFormat,NULL,ICMODE_FASTDECOMPRESS);

	// fast decompress may not be supported
        if (npMCI->hicDecompress == NULL) {
            npMCI->hicDecompress = ICDecompressOpen(ICTYPE_VIDEO,
                        psi->sh.fccHandler,psi->lpFormat,NULL);
        }

	//
	// set any state data.
	//
        if (npMCI->hicDecompress && psi->cbData) {
            ICSetState(npMCI->hicDecompress, psi->lpData, psi->cbData);
        }

	if (psi->hicDraw == NULL && npMCI->hicDecompress == NULL &&
            psi->sh.fccHandler != comptypeRLE0 &&
            psi->sh.fccHandler != comptypeNONE &&
            psi->sh.fccHandler != comptypeDIB &&
            psi->sh.fccHandler != comptypeRLE &&
	    psi->sh.fccHandler != 0) {

            DPF(("Unable to open compressor '%4.4ls'!!!\n", (LPSTR) &psi->sh.fccHandler));

            npMCI->nVideoStream = -1;
            npMCI->psiVideo = NULL;

	    GlobalFreePtr(npMCI->pbiFormat);
            npMCI->pbiFormat = NULL;

            //
            // we would like to return a custom, error but MCI will not
            // find the error string because it has unloaded us (because
            // the open failed), so we return a bogus generic error.
            //
	    if (npMCI->streams == 1)	// this is the only stream
                npMCI->dwTaskError = MMSYSERR_NODRIVER; // MCIERR_AVI_NOCOMPRESSOR;

	    return FALSE;   // cant load this video stream
	}
    }
    else {
        //
        // this is not the default video stream find a draw handler that
        // can deal with the stream.
        //

        //
        // try VIDS.DRAW
        //
        // if that fails open a draw handler not-specific to the format
        //
        if (psi->hicDraw == NULL) {

            psi->hicDraw = ICOpen(psi->sh.fccType,FOURCC_AVIDraw,ICMODE_DRAW);

            if (psi->hicDraw)
                DOUT("Opened draw handler VIDS.DRAW\n");

            if (psi->hicDraw && ICDrawQuery(psi->hicDraw,psi->lpFormat) != ICERR_OK) {
                DOUT("Closing VIDS.DRAW because it cant handle this format");
                ICClose(psi->hicDraw);
                psi->hicDraw = NULL;
            }
        }

        //
        // if that fails open our internal handler.
        //
        if (psi->hicDraw == NULL) {

            psi->hicDraw = ICOpenFunction(psi->sh.fccType,
                FOURCC_AVIDraw,ICMODE_DRAW,(FARPROC)ICAVIDrawProc);

            if (psi->hicDraw)
                DOUT("Opened Internal draw handler\n");
        }
    }

    npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;

    psi->dwFlags |= STREAM_VIDEO;       // is a video stream
    psi->dwFlags |= STREAM_ENABLED;
    npMCI->nVideoStreams++;

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | InitAudioStream | initialize a audio stream
 *
 ***************************************************************************/

BOOL NEAR PASCAL InitAudioStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi)
{
    int stream = psi - npMCI->paStreamInfo;
    LPWAVEFORMAT pwf;

    npMCI->wEarlyAudio = (UINT)psi->sh.dwInitialFrames;

    pwf = (LPWAVEFORMAT)psi->lpFormat;

    if (pwf->nChannels == 0 || pwf->nSamplesPerSec == 0) {
        return FALSE;
    }

    if (pwf->wFormatTag == WAVE_FORMAT_PCM) {
        pwf->nBlockAlign = pwf->nChannels *
            ((((LPPCMWAVEFORMAT)pwf)->wBitsPerSample + 7) / 8);

        pwf->nAvgBytesPerSec = pwf->nBlockAlign * pwf->nSamplesPerSec;
    }

    psi->sh.dwSampleSize = pwf->nBlockAlign;

    psi->dwFlags |= STREAM_AUDIO;       // audio stream
    psi->dwFlags |= STREAM_ENABLED;     // enabled by default.

    //
    //  make sure dwRate and dwScale are right
    //  dwRate/dwScale should be blocks/sec
    //
    Assert(muldiv32(pwf->nAvgBytesPerSec,1000,pwf->nBlockAlign) ==
           muldiv32(psi->sh.dwRate, 1000, psi->sh.dwScale));

    //
    //  just to be safe set these ourself to the right value.
    //
    psi->sh.dwRate  = pwf->nAvgBytesPerSec;
    psi->sh.dwScale = pwf->nBlockAlign;

    //
    // only one audio stream can be active at once
    // for lack of a better default the first audio stream will
    // become the active one.
    //
    if (npMCI->nAudioStreams == 0) {
        npMCI->nAudioStream = stream;
        npMCI->psiAudio = psi;
    }

    npMCI->nAudioStreams++;
    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | InitOtherStream | initialize a random stream
 *
 ***************************************************************************/

BOOL NEAR PASCAL InitOtherStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi)
{
    int stream = psi - npMCI->paStreamInfo;

    /* Open the specified video compressor */
    psi->hicDraw = ICDrawOpen(psi->sh.fccType,psi->sh.fccHandler,psi->lpFormat);

    if (psi->hicDraw == NULL) {
        DPF(("Unable to play stream!\n"));
	return FALSE;
    }

    if (psi->cbData > 0) {
        ICSetState(psi->hicDraw, psi->lpData, psi->cbData);
    }
	
    psi->dwFlags |= STREAM_ENABLED;
////psi->dwFlags |= STREAM_OTHER;
    npMCI->nOtherStreams++;
    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | CleanIndex | This function cleans up the index loaded by
 *  ReadIndex() it does the following when cleaning up the index:
 *
 *      converts all offsets to be absolute
 *
 *      converts "alpha" format index's into new format.
 *
 *      computes the max buffer size needed to read this file.
 *
 ***************************************************************************/

static BOOL NEAR CleanIndex(NPMCIGRAPHIC npMCI)
{
    LONG        lScan;
    AVIINDEXENTRY FAR * px;
    AVIINDEXENTRY FAR * pxRec=NULL;
    DWORD       lIndexAdjust;

    Assert(npMCI->hpIndex != NULL);

    px = (AVIINDEXENTRY FAR *)npMCI->hpIndex;

#ifdef ALPHAFILES
    if (npMCI->dwFlags & MCIAVI_USINGALPHAFORMAT)
	lIndexAdjust = 0;
    else
#endif
    if (// (avihdr.dwFlags & AVIF_MUSTUSEINDEX) ||
                (px->dwChunkOffset < 100))
	lIndexAdjust = npMCI->dwMovieListOffset;
    else
	lIndexAdjust = (npMCI->dwMovieListOffset + sizeof(DWORD)) -
                            px->dwChunkOffset;

//!!! only compute this for the video stream! (or interleaved...)
    npMCI->dwSuggestedBufferSize = 0; // lets get this exactly right

    DPF(("Adjusting index by %ld bytes....\n", lIndexAdjust));

    /* Can we do anything to see if the index is valid? */
    for (lScan = 0; lScan < (LONG)npMCI->macIndex;
                lScan++, ++((AVIINDEXENTRY _huge *)px)) {
        DWORD   ckid;

        //
        // adjust the offset to be absolute
        //
        px->dwChunkOffset += lIndexAdjust;

        // get ckid
        ckid = px->ckid;

        //
        // make sure the buffer size is right, ignore audio chunks because
        // they are either in a 'rec' or we will be reading them into
        // internal buffers not the main buffer.365
        //
        if (((npMCI->dwFlags & MCIAVI_NOTINTERLEAVED) ||
            ckid == listtypeAVIRECORD) &&
            TWOCCFromFOURCC(ckid) != cktypeWAVEbytes) {

            if (px->dwChunkLength + 8 > npMCI->dwSuggestedBufferSize)
                npMCI->dwSuggestedBufferSize = px->dwChunkLength + 12;
        }

#ifdef ALPHAFILES
        //
        // convert a "old" index to a new index
        //
        if (npMCI->dwFlags & MCIAVI_USINGALPHAFORMAT) {
            switch(ckid) {
                case ckidDIBbits:
                    px->dwFlags |= AVIIF_KEYFRAME;
                    px->ckid = MAKEAVICKID(cktypeDIBbits, 0);
                    break;

                case ckidDIBcompressed:
                    px->ckid = MAKEAVICKID(cktypeDIBcompressed, 0);
                    break;

                case ckidDIBhalfframe:
                    px->ckid = MAKEAVICKID(cktypeDIBhalf, 0);
                    break;

                case ckidPALchange:
                    px->ckid = MAKEAVICKID(cktypePALchange, 0);
                    break;

                case ckidWAVEbytes:
                    px->ckid = MAKEAVICKID(cktypeWAVEbytes, 1);
                    break;

                case ckidWAVEsilence:
                    px->ckid = MAKEAVICKID(cktypeWAVEsilence, 1);
                    break;

                case ckidAVIPADDING:
                case ckidOLDPADDING:
                    px->ckid = ckidAVIPADDING;
                    break;
            }

            ckid = px->ckid;
        }
#endif
	
        //
        // do special things with the video stream.
        //

        if (StreamFromFOURCC(ckid) == (UINT)npMCI->nVideoStream) {

            //
            // fix up bogus index's by adding any missing AVIIF_KEYFRAME
            // bits. ie this only applies for RLE files.
            //
            if (TWOCCFromFOURCC(ckid) == cktypeDIBbits &&
                VIDFMT(npMCI->nVideoStream)->biCompression <= BI_RLE8)

                px->dwFlags |= AVIIF_KEYFRAME;

            //
            // for video streams, make sure the palette changes are marked
            // as a no time chunk
            //
            if (TWOCCFromFOURCC(ckid) == cktypePALchange)
                px->dwFlags |= AVIIF_NOTIME/*|AVIIF_PALCHANGE*/;

            //
            //  make sure the 'REC ' list has the right flags.
            //
            if (pxRec) {
                if ((px->dwFlags & AVIIF_KEYFRAME) !=
                    (pxRec->dwFlags & AVIIF_KEYFRAME)) {

                    // Record list does not have correct flags

                    pxRec->dwFlags &= ~AVIIF_KEYFRAME;
                    pxRec->dwFlags |= (px->dwFlags & AVIIF_KEYFRAME);
                }
            }
        }

        if (ckid == listtypeAVIRECORD) {

            pxRec = px;

            if (npMCI->dwFlags & MCIAVI_NOTINTERLEAVED) {
                DPF(("Non interleaved file with a 'REC ' in it?\n"));
                npMCI->wEarlyRecords = max(npMCI->wEarlyVideo, npMCI->wEarlyAudio);

                if (npMCI->wEarlyRecords > 0) {
                    DPF(("Interlaved file with bad header\n"));
                    npMCI->dwFlags &= ~MCIAVI_NOTINTERLEAVED;
                }
            }
	}
    }

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | MakeFrameIndex | makes the frame index
 *
 *      the frame index is a array of AVIFRAMEINDEX entries, one for each
 *      frame in the movie.  using the frame index we can easily find
 *      a given frame, along with it's keyframe and palette.
 *
 ***************************************************************************/

static BOOL NEAR MakeFrameIndex(NPMCIGRAPHIC npMCI)
{
    LONG        nFrames;
    LONG        iFrameStart;
    LONG        iFrame;
    LONG        iKeyFrame;
    LONG        nKeyFrames;
    LONG        iScan;
    LONG        iNewIndex;
    LONG        iPalette;
    BOOL        fInterleaved;
    DWORD       ckid;
    STREAMINFO *psi;

    AVIINDEXENTRY _huge * pNewIndex;
    AVIINDEXENTRY _huge * pIndexEntry;
    AVIFRAMEINDEX _huge * pFrameIndex;

    if (npMCI->nVideoStreams == 0)
        return TRUE;

    if (npMCI->hpFrameIndex != NULL)
        return TRUE;

    psi = npMCI->psiVideo;
    Assert(psi != NULL);

    fInterleaved = !(npMCI->dwFlags & MCIAVI_NOTINTERLEAVED);

    if (fInterleaved &&
        muldiv32(npMCI->dwRate, 1000, npMCI->dwScale) !=
        muldiv32(psi->sh.dwRate, 1000, psi->sh.dwScale)) {
        //
        //  master video stream should match the movie rate!
        //
        AssertSz(FALSE, "Video stream differnet rate than movie");
        npMCI->dwRate  = psi->sh.dwRate;
        npMCI->dwScale = psi->sh.dwScale;
    }

    if (fInterleaved)
        iFrameStart = -(LONG)npMCI->wEarlyRecords;
    else
        iFrameStart = -(LONG)npMCI->wEarlyVideo;

    nFrames = npMCI->lFrames - iFrameStart;

    npMCI->hpFrameIndex = (LPVOID)GlobalAllocPtr(GMEM_SHARE|GHND,
        (DWORD)(nFrames+1) * sizeof(AVIFRAMEINDEX));

    if (npMCI->hpFrameIndex == NULL) {
	DPF(("Couldn't allocate memory for frame index!\n"));
        return FALSE;
    }

    //
    //  do this so we can just index the array with the frame number
    //  (positive or neg)
    //
    npMCI->hpFrameIndex += (-iFrameStart);

    pFrameIndex = npMCI->hpFrameIndex;

    iFrame    = iFrameStart;
    iKeyFrame = -(LONG)npMCI->wEarlyVideo; // iFrameStart;
    iNewIndex = 0;
    iPalette  = -1; // first palette
    nKeyFrames= 0;

#ifdef USEAVIFILE
    if (npMCI->pf) {
        PAVISTREAM ps = SI(npMCI->nVideoStream)->ps;

        for (iFrame = 0; iFrame < npMCI->lFrames; iFrame++) {

            LONG iKey;

            iKey      = AVIStreamFindSample(ps,iFrame,FIND_PREV|FIND_KEY);
            iPalette  = AVIStreamFindSample(ps,iFrame,FIND_PREV|FIND_FORMAT);

            if (iKey != -1)
                iKeyFrame = iKey;

            if (iPalette == -1)
                iPalette = 0;

            pFrameIndex[iFrame].iPrevKey = (UINT)(iFrame - iKeyFrame);
            pFrameIndex[iFrame].iNextKey = 0;
            pFrameIndex[iFrame].iPalette = (WORD)iPalette;
	    pFrameIndex[iFrame].dwOffset = 0;
            pFrameIndex[iFrame].dwLength = 0;

            Assert(iPalette <= 0xFFFF);

            if (iFrame - iKeyFrame > 0xFFFF) {
                //!!! we need to set a flag!
                //!!! we need to throw out the index!
                AssertSz(FALSE, "File has too few key frames");
                pFrameIndex[iFrame].iPrevKey = 0;
            }
        }

	goto ack;
    }
#endif

    Assert(npMCI->hpIndex != NULL);
    Assert(npMCI->macIndex != 0L);
    pNewIndex   = npMCI->hpIndex;
    pIndexEntry = npMCI->hpIndex;

    for (iScan = 0; iScan < (LONG)npMCI->macIndex; iScan++, pIndexEntry++) {

        ckid = pIndexEntry->ckid;

        //
        // check for palette changes.
        //
        if (StreamFromFOURCC(ckid) == (UINT)npMCI->nVideoStream &&
            TWOCCFromFOURCC(ckid) == cktypePALchange) {

            iPalette = iNewIndex;

            pNewIndex[iNewIndex++] = *pIndexEntry;

            if (fInterleaved)
                pFrameIndex[iFrame-1].iPalette = (WORD)iPalette;
        }

        //
        // remove the video stream from the master index
        //
        if ((ckid != listtypeAVIRECORD) &&
            (StreamFromFOURCC(ckid) != (UINT)npMCI->nVideoStream)) {
            pNewIndex[iNewIndex++] = *pIndexEntry;
        }

        //
        //  in interleaved files a "frame" happens every list record
        //
        //  in non-interleaved files a "frame" happens every piece of
        //  data in the video stream (except no time chunks)
        //
        if (fInterleaved) {

            if (ckid != listtypeAVIRECORD)
                continue;

        } else {

            if ((StreamFromFOURCC(ckid) != (UINT)npMCI->nVideoStream) ||
                (pIndexEntry->dwFlags & AVIIF_NOTIME))

                continue;
        }

        AssertSz(iFrame < npMCI->lFrames,"Too many frames in index!");

        if (iFrame >= npMCI->lFrames) {
	    break;
        }

        if (pIndexEntry->dwFlags & AVIIF_KEYFRAME) {
            iKeyFrame = iFrame;
            nKeyFrames++;
        }

        pFrameIndex[iFrame].iPrevKey = (UINT)(iFrame - iKeyFrame);
        pFrameIndex[iFrame].iNextKey = 0;
        pFrameIndex[iFrame].iPalette = (WORD)iPalette;
        pFrameIndex[iFrame].dwOffset = pIndexEntry->dwChunkOffset;
        pFrameIndex[iFrame].dwLength = pIndexEntry->dwChunkLength;

        if (fInterleaved)
            pFrameIndex[iFrame].dwOffset += 3 * sizeof(DWORD);

        Assert(iPalette <= 0xFFFF);

        if (iFrame - iKeyFrame > 0xFFFF) {
            //!!! we need to set a flag!
            //!!! we need to throw out the index!
            AssertSz(FALSE, "File has too few key frames");
            pFrameIndex[iFrame].iPrevKey = 0;
        }

        iFrame++;
    }
ack:
    //
    //  iFrame better equal npMCI->lFrames
    //
    Assert(iFrame == npMCI->lFrames);

    if (iFrame < npMCI->lFrames)
        npMCI->lFrames = iFrame;

    //
    // make a "dummy" last frame
    //
    pFrameIndex[iFrame].iPrevKey = (UINT)(iFrame - iKeyFrame);
    pFrameIndex[iFrame].iNextKey = 0;
    pFrameIndex[iFrame].iPalette = (WORD)iPalette;
    pFrameIndex[iFrame].dwOffset = 0;
    pFrameIndex[iFrame].dwLength = 0;

    //
    // compute the key frames every value
    //
    if (nKeyFrames) {

        if (nKeyFrames > 1)
            npMCI->dwKeyFrameInfo = (DWORD)((nFrames + nKeyFrames/2)/nKeyFrames);
        else
            npMCI->dwKeyFrameInfo = 0;
    }

    //
    //  now go through the index, and fix all the iNextKey fields
    //
    pFrameIndex = npMCI->hpFrameIndex;
////iKeyFrame = npMCI->lFrames; //!!! what should this be set to? zero?

    for (iFrame = npMCI->lFrames; iFrame>=iFrameStart; iFrame--)
    {
        if (pFrameIndex[iFrame].iPrevKey == 0)
            iKeyFrame = iFrame;

        if (iKeyFrame >= iFrame)
            pFrameIndex[iFrame].iNextKey = (UINT)(iKeyFrame - iFrame);
        else
            pFrameIndex[iFrame].iNextKey = 0xFFFF;      // way far away

        if (iKeyFrame - iFrame > 0xFFFF) {
            //!!! we need to set a flag!
            //!!! we need to throw out the index!
            AssertSz(FALSE, "File has too few key frames");
            pFrameIndex[iFrame].iNextKey = 0;
        }
    }

    //
    // we dont need the index, if we are using AVIFile or
    // we have a interleaved file.  when the file is interleaved
    // we never do random access (except for palette changes)
    //
    // !!!this is not true, we need the index iff we have a audio only
    // file or we play a interleaved file real slow.
    //
    if (npMCI->pf /* ||
        (fInterleaved && !(npMCI->dwFlags & MCIAVI_ANIMATEPALETTE))*/ ) {
        DOUT("The Master index must go!\n");
        iNewIndex = 0;
    }

    //
    // now re-alloc the master index down to size.
    //
    // !!! do we even need the master index anymore, for interleaved files?
    //
    DPF(("Master index was %ld entries now %ld\n",npMCI->macIndex, iNewIndex));

    npMCI->macIndex = iNewIndex;

    if (iNewIndex > 0) {
        npMCI->hpIndex = (AVIINDEXENTRY _huge *)
		GlobalReAllocPtr(npMCI->hpIndex,
				 (LONG)iNewIndex * sizeof(AVIINDEXENTRY),
				 GMEM_MOVEABLE | GMEM_SHARE);

        Assert(npMCI->hpIndex != NULL);
    }
    else {
        if (npMCI->hpIndex)
            GlobalFreePtr(npMCI->hpIndex);
        npMCI->hpIndex = NULL;
    }

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | ReadIndex | Read the index into npMCI->hpIndex.  Should
 *	only be called if the HASINDEX flag is set.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data
 *
 * @rdesc TRUE means no errors, false means unable to read index.
 *
 ***************************************************************************/
BOOL FAR PASCAL ReadIndex(NPMCIGRAPHIC npMCI)
{
    MMCKINFO    ck;
    DWORD       dwOldPos;

    if (npMCI->hpIndex || npMCI->hpFrameIndex)
	return TRUE;

    if (!(npMCI->dwFlags & MCIAVI_HASINDEX))
	return FALSE;

    if (npMCI->pf) {
	MakeFrameIndex(npMCI);
	return TRUE;
    }

#if 0
    if (GetCurrentTask() != npMCI->hTask) {

	/* this function is called (from GraphicStatus) when
	 * possibly playing - so we have to suspend play while we read
	 * the index.
	 */
	TEMPORARYSTATE  ts;

	if (StopTemporarily(npMCI, &ts) == 0) {
            mciaviTaskMessage(npMCI, TASKREADINDEX);
	    RestartAgain(npMCI, &ts);
            return (npMCI->hpIndex != NULL);
        }
	return(FALSE);
    }
#else
    if (GetCurrentTask() != npMCI->hTask)
        return FALSE;
#endif

    dwOldPos = mmioSeek(npMCI->hmmio, 0, SEEK_CUR);

    DPF(("Reading index: starting from %lx\n", npMCI->dwBigListEnd));

    if (mmioSeek(npMCI->hmmio, npMCI->dwBigListEnd, SEEK_SET) == -1) {
IndexReadError:		
	DPF(("Error reading index!\n"));
        npMCI->dwFlags &= ~(MCIAVI_HASINDEX);
	mmioSeek(npMCI->hmmio, dwOldPos, SEEK_SET);
	return FALSE;
    }

    ck.ckid = ckidAVINEWINDEX;	
    if (mmioDescend(npMCI->hmmio, &ck, NULL, MMIO_FINDCHUNK) != 0) {
	goto IndexReadError;
    }

    /* A zero-size index isn't much good. */
    if (ck.cksize == 0)
	goto IndexReadError;

    npMCI->macIndex = ck.cksize / sizeof(AVIINDEXENTRY);
    npMCI->hpIndex = (AVIINDEXENTRY _huge *)
		     GlobalAllocPtr(GMEM_SHARE | GMEM_MOVEABLE, ck.cksize);

    if (!npMCI->hpIndex) {
	DPF(("Insufficient memory to read index.\n"));
	goto IndexReadError;
    }

#ifndef WIN32
    Assert(OFFSETOF(npMCI->hpIndex) == 0);
#endif

    if (mmioRead(npMCI->hmmio, (HPSTR) npMCI->hpIndex, ck.cksize) != (LONG) ck.cksize) {
	Assert(0);
	goto IndexReadError;
    }

    CleanIndex(npMCI);
    MakeFrameIndex(npMCI);

////should we do this for audio? remove video data?
////MakeStreamIndex(npMCI, ???);

    mmioSeek(npMCI->hmmio, dwOldPos, SEEK_SET);
    return TRUE;
}

/***************************************************************************
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | IsRectBogus | 'nuf said
 *
 ***************************************************************************/

static BOOL NEAR PASCAL IsRectBogus(LPRECT prc)
{
    if (prc->right  - prc->left <= 0 ||
        prc->bottom - prc->top <= 0 ||
        prc->bottom <= 0 ||
        prc->right <= 0)

        return TRUE;
    else
        return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | atol | local version of atol
 *
 ***************************************************************************/

static LONG NEAR PASCAL atol(char *sz)
{
    LONG l = 0;

    while (*sz && *sz >= '0' && *sz <= '9')
    	l = l*10 + *sz++ - '0';
    	
    return l;    	
}	

#ifndef WIN32

/*--------------------------------------------------------------------------
 *
 *  IsCDROMDrive() -
 *
 * Purpose:  Return non-zero if a RAM drive
 *
 *  wDrive   drive index (0=A, 1=B, ...)
 *
 *  return   TRUE/FALSE
 *-------------------------------------------------------------------------*/

#pragma optimize("", off)
static BOOL NEAR PASCAL IsCDROMDrive(UINT wDrive)
{
    BOOL f;

    _asm {
        mov ax, 1500h     /* first test for presence of MSCDEX */
        xor bx, bx
        int 2fh
        mov ax, bx        /* MSCDEX is not there if bx is still zero */
        or  ax, ax        /* ...so return FALSE from this function */
        jz  no_mscdex
        mov ax, 150bh     /* MSCDEX driver check API */
        mov cx, wDrive    /* ...cx is drive index */
        int 2fh
no_mscdex:
	mov f,ax
    }
    return f;
}
#pragma optimize("", on)

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | IsNetFile | is the passed file on a network drive?
 *
 ***************************************************************************/

static BOOL NEAR PASCAL IsNetFile(LPTSTR szFile)
{
    OFSTRUCT            of;

    if (OpenFile(szFile, &of, OF_PARSE) == -1)
        return FALSE;

    AnsiUpper(of.szPathName);

    if (of.szPathName[0] == '\\' && of.szPathName[1] == '\\')
        return TRUE;

    if (of.szPathName[0] == '/' && of.szPathName[1] == '/')
        return TRUE;
    if (of.szPathName[1] == ':' &&
        GetDriveType(of.szPathName[0] - 'A') == DRIVE_REMOTE &&
        !IsCDROMDrive(of.szPathName[0] - 'A'))

        return TRUE;

    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | IsCDROMFile | is the passed file on a CD-ROM drive?
 *
 ***************************************************************************/

static BOOL NEAR PASCAL IsCDROMFile(LPTSTR szFile)
{
    OFSTRUCT of;

    if (OpenFile(szFile, &of, OF_PARSE) == -1)
        return FALSE;

    AnsiUpper(of.szPathName);

    if (of.szPathName[0] == '\\' && of.szPathName[1] == '\\')
        return FALSE;

    if (of.szPathName[0] == '/' && of.szPathName[1] == '/')
        return FALSE;

    if (of.szPathName[1] == ':' &&
        GetDriveType(of.szPathName[0] - 'A') == DRIVE_REMOTE &&
        IsCDROMDrive(of.szPathName[0] - 'A'))

        return TRUE;

    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api UINT | GetFileDriveType | return drive type given a file
 *
 *      DRIVE_CDROM
 *      DRIVE_REMOTE
 *      DRIVE_FIXED
 *      DRIVE_REMOVABLE
 *
 ***************************************************************************/

static UINT NEAR PASCAL GetFileDriveType(LPSTR szPath)
{
    if (IsCDROMFile(szPath))
        return DRIVE_CDROM;

    if (IsNetFile(szPath))
        return DRIVE_REMOTE;

    if (szPath[1] == ':')
        return GetDriveType(szPath[0] - 'A');

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\avisound.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1991-1992. All rights reserved.

   Title:   avisound.c - Code for playing audio in AVI files.

*****************************************************************************/
#include "graphic.h"

#define AUDIO_PANIC 10
static UINT nAudioPanic;

//
// redefine StreamFromFOURCC to only handle 0-9 streams!
//
#undef StreamFromFOURCC
#define StreamFromFOURCC(fcc) (UINT)(HIBYTE(LOWORD(fcc)) - (BYTE)'0')

void FAR PASCAL _LOADDS mciaviWaveOutFunc(HWAVEOUT hWaveOut, UINT wMsg,
		    DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);

#ifndef WIN32
#define GetDS() (HGLOBAL)HIWORD((DWORD)(LPVOID)&ghModule)
#endif //WIN16

DWORD FAR PASCAL SetUpAudio(NPMCIGRAPHIC npMCI, BOOL fPlaying)
{
    UINT	w;
    LPWAVEHDR   lpWaveHdr;
    STREAMINFO *psi;

    if (npMCI->nAudioStreams == 0) {
	npMCI->wABs = 0;
	npMCI->wABOptimal = 0;
	return 0L;
    }

    nAudioPanic = GetProfileInt(TEXT("MCIAVI"), TEXT("AudioPanic"), AUDIO_PANIC);

    psi = SI(npMCI->nAudioStream);
    Assert(psi->sh.fccType == streamtypeAUDIO);
    Assert(psi->cbFormat);
    Assert(psi->lpFormat);

    if (!npMCI->pWF) {
        npMCI->pWF = (NPWAVEFORMAT)LocalAlloc(LPTR, (UINT)psi->cbFormat);

	if (!npMCI->pWF) {
	    return MCIERR_OUT_OF_MEMORY;
	}
    }

    hmemcpy(npMCI->pWF,psi->lpFormat,psi->cbFormat);

    npMCI->wEarlyAudio = (UINT)psi->sh.dwInitialFrames;
    npMCI->dwAudioLength = psi->sh.dwLength * psi->sh.dwSampleSize;

    if (npMCI->dwAudioLength < 1000L) {
        DPF(("AudioLength is bogus"));
        npMCI->dwAudioLength = muldiv32((npMCI->pWF->nAvgBytesPerSec + 100) *
                npMCI->lFrames,npMCI->dwMicroSecPerFrame,1000000L);
    }

    //
    // choose the audio playback method depending on how we are going to
    // recive audio data from the file.
    //
    switch (npMCI->wPlaybackAlg) {
        case MCIAVI_ALG_HARDDISK:
	case MCIAVI_ALG_AUDIOONLY:

            if (!npMCI->pf && !npMCI->hmmioAudio) {
                MMIOINFO            mmioInfo;

                _fmemset(&mmioInfo, 0, sizeof(MMIOINFO));
                mmioInfo.htask = (HANDLE) npMCI->hCallingTask; //ntmmsystem bug, should be threadid which is dword
                npMCI->hmmioAudio = mmioOpen(npMCI->szFilename, &mmioInfo,
                                        MMIO_READ | MMIO_DENYWRITE);

                if (npMCI->hmmioAudio == NULL)
                    npMCI->hmmioAudio = mmioOpen(npMCI->szFilename, &mmioInfo,
                                        MMIO_READ);

                if (!npMCI->hmmioAudio) {
		    Assert(0);
		    return MCIERR_DRIVER_INTERNAL;
		}
            }

            // fall through to CDROM

        case MCIAVI_ALG_CDROM:
            //!!!! we need to tune this!!!!
            // !!! We use four 1/2 second buffers.  This is arbitrary.
            npMCI->wABs = 4;
            npMCI->wABOptimal = 0;
            npMCI->dwABSize = npMCI->pWF->nAvgBytesPerSec / 2;
            break;

        case MCIAVI_ALG_INTERLEAVED:
            /* Fix up some values based on the header information */
            npMCI->dwABSize = muldiv32(npMCI->dwMicroSecPerFrame,
                    npMCI->pWF->nAvgBytesPerSec,1000000L) + 2047;

            npMCI->dwABSize &= ~(2047L);

            npMCI->wABs = npMCI->wEarlyAudio + 2 + (WORD) npMCI->dwBufferedVideo;

            /* Soundblaster hack: waveoutdone only accurate to 2K. */

            //!!!!!!!!!! is this right.

            if (npMCI->dwMicroSecPerFrame) {
                npMCI->wABOptimal = npMCI->wABs -
                        (UINT) (muldiv32(2048, 1, muldiv32(npMCI->dwMicroSecPerFrame,
                        npMCI->pWF->nAvgBytesPerSec,1000000L)));
            } else {
                npMCI->wABOptimal = 0;
            }

            //!!! hack so we can do burst reading, up to 1sec
            //npMCI->wABs += (int)muldiv32(1000000l, 1, npMCI->dwMicroSecPerFrame);

            DPF2(("Using %u audio buffers, of which %u should be full.\n", npMCI->wABs, npMCI->wABOptimal));
            break;

        default:
            Assert(0);
            return 0L;
    }

    npMCI->dwABSize -= npMCI->dwABSize % npMCI->pWF->nBlockAlign;

    if (!fPlaying)
	return 0L;

    /* This code adjusts the wave format block to play
    ** the audio at the correct speed to match the frame rate.
    */

    npMCI->pWF->nSamplesPerSec = muldiv32(npMCI->pWF->nSamplesPerSec,
					    npMCI->dwMicroSecPerFrame,
					    npMCI->dwPlayMicroSecPerFrame);

    npMCI->pWF->nAvgBytesPerSec = muldiv32(npMCI->pWF->nAvgBytesPerSec,
					    npMCI->dwMicroSecPerFrame,
					    npMCI->dwPlayMicroSecPerFrame);

    if (npMCI->pWF->wFormatTag == WAVE_FORMAT_PCM) {
	/* Make sure this is exactly right... */
	npMCI->pWF->nAvgBytesPerSec =
            npMCI->pWF->nSamplesPerSec * npMCI->pWF->nBlockAlign;
    }

    /* Kill any currently playing sound */
    sndPlaySound(NULL, 0);

    DPF2(("Opening wave device....\n"));
    /* Try to open a wave device. */
    w = waveOutOpen(&npMCI->hWave, (UINT)WAVE_MAPPER,
		(LPWAVEFORMATEX) npMCI->pWF,
		//(const LPWAVEFORMATEX) npMCI->pWF,
		(DWORD) &mciaviWaveOutFunc,
		(DWORD) (LPMCIGRAPHIC) npMCI,
                (DWORD)CALLBACK_FUNCTION);

    if (w) {
	DPF(("Unable to open wave device.\n"));

	npMCI->hWave = NULL;
        return w == WAVERR_BADFORMAT ?
			    MCIERR_WAVE_OUTPUTSUNSUITABLE :
			    MCIERR_WAVE_OUTPUTSINUSE;
    }

    npMCI->dwFlags &= ~MCIAVI_LOSTAUDIO;

#ifndef WIN32 // No need to lock it on NT - although we could with Virtual mem
              // functions
    //
    // page lock our DS so our wave callback function can
    // touch it without worry. see mciaviWaveOutFunc()
    //
    GlobalPageLock(GetDS());
#endif //WIN16

    /* Pause the wave output device, so it won't start playing
    ** when we're loading up the buffers.
    */
    if (waveOutPause(npMCI->hWave) != 0) {
	DPF(("Error from waveOutPause!\n"));
	return MCIERR_DRIVER_INTERNAL;
    }

    if (npMCI->dwFlags & MCIAVI_VOLUMESET) {
	DeviceSetVolume(npMCI, npMCI->dwVolume);
    } else {
	DeviceGetVolume(npMCI);
    }

    npMCI->lpAudio = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE,
		    npMCI->wABs * (npMCI->dwABSize + sizeof(WAVEHDR)));

    if (!npMCI->lpAudio) {
	return MCIERR_OUT_OF_MEMORY;
    }

    npMCI->dwAudioPlayed = 0L;
    npMCI->wNextAB = 0;
    npMCI->dwUsedThisAB = 0;

    /* Allocate and prepare our buffers */
    for (w = 0; w < npMCI->wABs; w++) {
	lpWaveHdr = (LPWAVEHDR) (npMCI->lpAudio + (w * sizeof(WAVEHDR)));

	lpWaveHdr->lpData = (HPSTR) npMCI->lpAudio +
				    npMCI->wABs * sizeof(WAVEHDR) +
				    w * npMCI->dwABSize;
	lpWaveHdr->dwBufferLength = npMCI->dwABSize;
	lpWaveHdr->dwBytesRecorded = 0L;
	lpWaveHdr->dwUser = 0L;
	lpWaveHdr->dwFlags = 0L;
	lpWaveHdr->dwLoops = 0L;
	lpWaveHdr->lpNext = 0L;
	lpWaveHdr->reserved = 0;
    }

    for (w = 0; w < npMCI->wABs; w++) {
	lpWaveHdr = (LPWAVEHDR) (npMCI->lpAudio + (w * sizeof(WAVEHDR)));

	if (waveOutPrepareHeader(npMCI->hWave, lpWaveHdr, sizeof(WAVEHDR))
			!= 0) {
	    return MCIERR_OUT_OF_MEMORY;
	}
	lpWaveHdr->dwFlags |= WHDR_DONE;
    }

    return 0L;
}

DWORD FAR PASCAL CleanUpAudio(NPMCIGRAPHIC npMCI)
{
    UINT	w;

    /* Clear flags relating to playing audio */
    npMCI->dwFlags &= ~(MCIAVI_WAVEPAUSED);

    if (npMCI->lpAudio) {
        waveOutRestart(npMCI->hWave); // just in case we are paused
	waveOutReset(npMCI->hWave);

	for (w = 0; w < npMCI->wABs; w++) {
	    LPWAVEHDR	lpWaveHdr;

	    lpWaveHdr = (LPWAVEHDR) (npMCI->lpAudio
					    + (w * sizeof(WAVEHDR)));

#if 0
	    lpWaveHdr->lpData = npMCI->lpAudio
				    + npMCI->wABs * sizeof(WAVEHDR)
				    + w * npMCI->dwABSize;
	    lpWaveHdr->dwBufferLength = npMCI->dwABSize;
#endif

	    /* Do we need to check for an error from this? */
	    waveOutUnprepareHeader(npMCI->hWave, lpWaveHdr,
						    sizeof(WAVEHDR));
	}
	GlobalFreePtr(npMCI->lpAudio);
	npMCI->lpAudio = NULL;

	Assert(npMCI->wABFull == 0);
    }

    DPF2(("Closing wave device.\n"));
    waveOutClose(npMCI->hWave);
    npMCI->hWave = 0;

#ifndef WIN32
    GlobalPageUnlock(GetDS());
#endif //WIN16

    return 0L;
}

BOOL NEAR PASCAL WaitForFreeAudioBuffer(NPMCIGRAPHIC npMCI, BOOL FAR *lpfHurry)
{
    LPWAVEHDR   lpWaveHdr;

    lpWaveHdr = (LPWAVEHDR) (npMCI->lpAudio
				+ (npMCI->wNextAB * sizeof(WAVEHDR)));

    /* Use the number of full audio buffers to decide if we're behind. */
    if (npMCI->wABFull < npMCI->wABOptimal) {
        *lpfHurry = TRUE;
    }

    /* If all of the audio buffers are full, we have to wait. */
    if (npMCI->wABFull == npMCI->wABs) {

        DWORD time = timeGetTime();

        #define AUDIO_WAIT_TIMEOUT 2000

        DOUT2("waiting for audio buffer.");

        // we better not wait if the device is not playing!
        Assert(!(npMCI->dwFlags & MCIAVI_WAVEPAUSED));

#ifdef XDEBUG
        GetAsyncKeyState(VK_ESCAPE);
        GetAsyncKeyState(VK_F2);
        GetAsyncKeyState(VK_F3);
        GetAsyncKeyState(VK_F4);
#endif
        while (npMCI->wABFull == npMCI->wABs) {

            if (npMCI->dwFlags & MCIAVI_STOP)
                return FALSE;

            aviTaskYield();

            //
            //  the "Fahrenheit VA Audio Wave Driver" may get confused
            //  if you call waveOutPause() and waveOutRestart() alot
            //  and it will stay paused no matter what you do, it has
            //  all our buffers and it still does not make any sound
            //  you can call waveOutRestart() until you are blue in
            //  the face, it will do nothing.
            //
            //  so this is why this routine can time out, after waiting
            //  2 seconds or so we just toss all the audio in the buffers
            //  and start over.
            //
            if (timeGetTime() - time > AUDIO_WAIT_TIMEOUT) {
                DOUT("Gave up waiting, reseting wave device\n");
                waveOutReset(npMCI->hWave);
                break;
            }

#ifdef XDEBUG
            if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) {
                DPF(("STOPPED WAITING! wABFull = %d, wABs = %d\n", npMCI->wABFull,npMCI->wABs));
                return FALSE;
            }

            if (GetAsyncKeyState(VK_F2) & 0x0001) {
                DOUT("Trying waveOutRestart\n");
                waveOutRestart(npMCI->hWave);
            }

            if (GetAsyncKeyState(VK_F3) & 0x0001) {
                DOUT("Trying waveOutReset\n");
                waveOutReset(npMCI->hWave);
            }

            if (GetAsyncKeyState(VK_F4) & 0x0001) {

                int i,n;

                for (i=n=0; i<(int)npMCI->wABs; i++) {

                    if (((LPWAVEHDR)npMCI->lpAudio)[i].dwFlags & WHDR_DONE) {
                        DPF(("Buffer #%d is done!\n", i));
                        n++;
                    }
                    else {
                        DPF(("Buffer #%d is not done\n", i));
                    }
                }

                if (n > 0)
                    DPF(("%d buffers are done but our callback did not get called!\n", n));
            }
#endif
        }

        DOUT2("done\n");
    }

    /* Debugging check that wave has finished playing--should never happen */
    Assert(lpWaveHdr->dwFlags & WHDR_DONE);

#if 0
    lpWaveHdr->lpData = npMCI->lpAudio +
				npMCI->wABs * sizeof(WAVEHDR) +
				npMCI->wNextAB * npMCI->dwABSize;
#endif

    return TRUE;
}

#ifndef WIN32
#pragma optimize("", off)
#endif

BOOL NEAR PASCAL ReadSomeAudio(NPMCIGRAPHIC npMCI, BYTE _huge * lpAudio,
				DWORD dwStart, DWORD FAR * pdwLength)
{
    DWORD	dwIndex = 0;
    DWORD	ckidAudio;
    DWORD	dwAudioPos = 0L;
    AVIINDEXENTRY far * lpIndexEntry;

    Assert(npMCI->wPlaybackAlg == MCIAVI_ALG_HARDDISK ||
           npMCI->wPlaybackAlg == MCIAVI_ALG_AUDIOONLY);

    Assert(npMCI->hpIndex);

    /*
    ** Figure out what type of chunk we're looking for,
    */
    ckidAudio = MAKEAVICKID(cktypeWAVEbytes, npMCI->nAudioStream);

    lpIndexEntry = (AVIINDEXENTRY FAR *) npMCI->hpIndex;

    for (dwIndex = 0; dwIndex < npMCI->macIndex;
                dwIndex++, ++((AVIINDEXENTRY _huge *) lpIndexEntry)) {

	if (lpIndexEntry->ckid != ckidAudio)
	    continue;
	
	if (dwAudioPos + lpIndexEntry->dwChunkLength > dwStart) {
	    DWORD	dwLengthNow;
	    DWORD	dwSeekTo;
	
	    dwLengthNow = lpIndexEntry->dwChunkLength;
	    dwSeekTo = lpIndexEntry->dwChunkOffset + 8;
	
	    if (dwAudioPos + dwLengthNow > dwStart + *pdwLength) {
		/* Attempted optimization: If we've already read some
		** data, and we can't read the next whole chunk, let's
		** leave it for later.
		*/
		if (dwAudioPos > dwStart && (!(npMCI->dwFlags & MCIAVI_REVERSE)))
		    break;
		dwLengthNow = dwStart + *pdwLength - dwAudioPos;
	    }
	
	    if (dwAudioPos < dwStart) {
		dwLengthNow -= (dwStart - dwAudioPos);
		dwSeekTo += (dwStart - dwAudioPos);
	    }

            mmioSeek(npMCI->hmmioAudio, dwSeekTo, SEEK_SET);

	    if (mmioRead(npMCI->hmmioAudio, lpAudio, dwLengthNow)
			    != (LONG) dwLengthNow) {
		DPF(("Error reading audio data (%lx bytes at %lx)\n", dwLengthNow, dwSeekTo));
		return FALSE;
	    }
	    lpAudio += dwLengthNow;	
	}
	
	dwAudioPos += lpIndexEntry->dwChunkLength;
	
	if (dwAudioPos >= dwStart + *pdwLength)
	    return TRUE;
    }

    if (dwAudioPos < dwStart)
	*pdwLength = 0;	    // return FALSE?
    else
	*pdwLength = dwAudioPos - dwStart;

    return TRUE;
}
#ifndef WIN32
#pragma optimize("", on)
#endif
	
BOOL NEAR PASCAL ReverseWaveBuffer(NPMCIGRAPHIC npMCI, LPWAVEHDR lpWaveHdr)
{
    DWORD   dwLeft = lpWaveHdr->dwBufferLength;
    BYTE _huge *hp1;
    BYTE _huge *hp2;
    DWORD   dwBlock = npMCI->pWF->nBlockAlign;
    BYTE    bTemp;
    DWORD   dw;

    Assert(npMCI->dwFlags & MCIAVI_REVERSE);
    Assert(npMCI->wPlaybackAlg == MCIAVI_ALG_HARDDISK ||
	   npMCI->wPlaybackAlg == MCIAVI_ALG_AUDIOONLY);

    /* This routine doesn't like it when the data doesn't end on a
    ** block boundary, so make it so.  This should never happen.
    */
    Assert((dwLeft % dwBlock) == 0);
    dwLeft -= dwLeft % dwBlock;

    hp1 = lpWaveHdr->lpData;
    hp2 = ((HPSTR) lpWaveHdr->lpData) + (dwLeft - dwBlock);

    while ((LONG) dwLeft > (LONG) dwBlock) {
	for (dw = 0; dw < dwBlock; dw++) {
	    bTemp = *hp1;
	    *hp1++ = *hp2;
	    *hp2++ = bTemp;
	}
	hp2 -= dwBlock * 2;
	dwLeft -= dwBlock * 2;
    }

    return TRUE;
}

void FAR PASCAL BuildVolumeTable(NPMCIGRAPHIC npMCI)
{
    int	    vol;
    int     i;

    if (!npMCI->pWF || npMCI->pWF->wFormatTag != WAVE_FORMAT_PCM)
        return;

    if (((NPPCMWAVEFORMAT) npMCI->pWF)->wBitsPerSample != 8)
        return;

    vol = (LOWORD(npMCI->dwVolume) + HIWORD(npMCI->dwVolume)) / 2;
    vol = (int) (((LONG) vol * 256) / 500);

    if (!npMCI->pVolumeTable)
        npMCI->pVolumeTable = (void *)LocalAlloc(LPTR, 256);

    if (!npMCI->pVolumeTable)
        return;

    for (i = 0; i < 256; i++) {
        npMCI->pVolumeTable[i] = (BYTE) min(255, max(0,
                (int) ((((LONG) (i - 128) * vol) / 256) + 128)));
    }
}

BOOL NEAR PASCAL AdjustVolume(NPMCIGRAPHIC npMCI, LPWAVEHDR lpWaveHdr)
{
    DWORD   dwLeft = lpWaveHdr->dwBufferLength;
    BYTE FAR *pb;

    if (npMCI->pWF->wFormatTag != WAVE_FORMAT_PCM)
	return FALSE;

    if (!npMCI->pVolumeTable)
        return FALSE;

    if (((NPPCMWAVEFORMAT)npMCI->pWF)->wBitsPerSample != 8)
        return FALSE;

    pb = lpWaveHdr->lpData;

#ifndef WIN32
    if (OFFSETOF(pb) + dwLeft > 64l*1024) {
	while (dwLeft--) {
            *pb = npMCI->pVolumeTable[*pb];
            ((BYTE _huge *)pb)++;
	}
    }
    else {
        while ((int)dwLeft--)
            *pb++ = npMCI->pVolumeTable[*pb];
    }
#else
    while ((int)dwLeft--)
        *pb++ = npMCI->pVolumeTable[*pb];
#endif

    return TRUE;
}

BOOL NEAR PASCAL PlaySomeAudio(NPMCIGRAPHIC npMCI, LPWAVEHDR lpWaveHdr)
{
    if (npMCI->pVolumeTable)
        AdjustVolume(npMCI, lpWaveHdr);

    lpWaveHdr->dwFlags &= ~WHDR_DONE;

    /* If we're playing and we've used all of our audio buffers, pause the
    ** wave device until we can fill more of them up.
    **
    ** we need to be carefull not to do this on the last frame!!!
    */
    if ((npMCI->wTaskState == TASKPLAYING) &&
        !(npMCI->dwFlags & MCIAVI_WAVEPAUSED) &&
        (npMCI->wABFull == 0 || npMCI->nAudioBehind > nAudioPanic)) {

        if (npMCI->wABFull > 0) {
            DPF(("Audio panic stop\n"));
        } else {
            DPF(("Audio queue empty; pausing wave device\n"));
        }

        //
        // some audio cards dont like starving it confuses them
        // it is kind of rude any way.  we are going to cause a audio break
        // anyway so if we lose a little bit of audio (a few frames or so)
        // no one will even notice (any worse than the audio break)
        //
        if (npMCI->wABFull <= 1) {
            DOUT("Trying audio hack!\n");
            waveOutReset(npMCI->hWave);
        }

        ++npMCI->dwAudioBreaks;
        waveOutPause(npMCI->hWave);

        ICDrawStop(npMCI->hicDraw);
	npMCI->dwFlags |= MCIAVI_WAVEPAUSED;
    }

    if (waveOutWrite(npMCI->hWave, lpWaveHdr, sizeof(WAVEHDR)) != 0) {
        DPF(("Error from waveOutWrite!\n"));
	npMCI->dwTaskError = MCIERR_AVI_AUDIOERROR;
	return FALSE;
    } else {
	++npMCI->wABFull;

	/* Use the next wave buffer next time */
	++npMCI->wNextAB;
	if (npMCI->wNextAB == npMCI->wABs)
	    npMCI->wNextAB = 0;
	
	npMCI->dwUsedThisAB = 0;
    }

    if (npMCI->wABFull < min(npMCI->wABOptimal, npMCI->wABFull/2))
        npMCI->nAudioBehind++;
    else
        npMCI->nAudioBehind=0;

    /* If we paused the wave device to let ourselves catch up, and
    ** we've caught up enough, restart the device.
    */
    if ((npMCI->dwFlags & MCIAVI_WAVEPAUSED) &&
        npMCI->wTaskState == TASKPLAYING &&
        npMCI->wABFull == npMCI->wABs) {

        DPF2(("restarting wave device\n"));
        waveOutRestart(npMCI->hWave);

	ICDrawStart(npMCI->hicDraw);
        npMCI->dwFlags &= ~(MCIAVI_WAVEPAUSED);
        npMCI->nAudioBehind = 0;
    }

    return TRUE;
}

/* Play the current record's audio */
BOOL NEAR PASCAL PlayRecordAudio(NPMCIGRAPHIC npMCI, BOOL FAR *pfHurryUp,
				    BOOL FAR *pfPlayedAudio)
{
    LPWAVEHDR	lpWaveHdr;
    FOURCC	ckid;
    DWORD	cksize;
    LPSTR	lpSave;
    LPSTR	lpData;
    BOOL	fRet = TRUE;
////BOOL        fSilence;
    LONG        len;
    DWORD	dwBytesTotal = 0L;
    DWORD       dwBytesThisChunk;

    Assert(npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED);

    lpSave = npMCI->lp;

    lpWaveHdr = ((LPWAVEHDR)npMCI->lpAudio) + npMCI->wNextAB;

    *pfPlayedAudio = FALSE;

    /* Remember!
    **
    ** In the new file format, things shouldn't necessarily need to
    ** be ordered with the wave stuff always first.
    */

    len = (LONG)npMCI->dwThisRecordSize;

    while (len > 3 * sizeof(DWORD)) {

	/* Look at the next chunk */
	ckid = GET_DWORD();
        cksize = GET_DWORD();

        lpData = npMCI->lp;

        len -= ((cksize + 1) & ~1) + 8;
        SKIP_BYTES((cksize + 1) & ~1);

        if (StreamFromFOURCC(ckid) != (UINT)npMCI->nAudioStream)
            continue;

        dwBytesThisChunk = cksize;

	if (!dwBytesTotal) {
	    if (!WaitForFreeAudioBuffer(npMCI, pfHurryUp))
		/* We had to stop waiting--the stop flag was probably set. */
		goto exit;
        }

        if (dwBytesThisChunk > npMCI->dwABSize - dwBytesTotal) {
            DPF(("Audio Record is too big!\n"));
            dwBytesThisChunk = npMCI->dwABSize - dwBytesTotal;
        }

        hmemcpy((BYTE _huge *)lpWaveHdr->lpData + dwBytesTotal,
                lpData, dwBytesThisChunk);

	dwBytesTotal += dwBytesThisChunk;
    }

    if (dwBytesTotal) {
	*pfPlayedAudio = TRUE;	
	lpWaveHdr->dwBufferLength = dwBytesTotal;
	
	fRet = PlaySomeAudio(npMCI, lpWaveHdr);
    }

    /* Use the number of full audio buffers to decide if we're behind. */
    if (npMCI->wABFull >= npMCI->wABOptimal) {
         *pfHurryUp = FALSE;
    }

exit:
    npMCI->lp = lpSave;

    return fRet;
}

/* For "preload audio" or "random access audio" modes, do what needs
** to be done to keep our buffers full.
*/
BOOL NEAR PASCAL KeepPlayingAudio(NPMCIGRAPHIC npMCI)
{
    LPWAVEHDR	lpWaveHdr;
    DWORD	dwBytesTotal = 0L;
    LONG        lNewAudioPos;
////BOOL        fFirstTime = TRUE;

    Assert(npMCI->wPlaybackAlg == MCIAVI_ALG_HARDDISK ||
	   npMCI->wPlaybackAlg == MCIAVI_ALG_AUDIOONLY);

PlayMore:
    lpWaveHdr = ((LPWAVEHDR)npMCI->lpAudio) + npMCI->wNextAB;

    if (npMCI->dwFlags & MCIAVI_REVERSE) {
	lNewAudioPos = npMCI->dwAudioPos - npMCI->dwABSize;
	if (lNewAudioPos < 0)
	    lNewAudioPos = 0;
	dwBytesTotal = npMCI->dwAudioPos - lNewAudioPos;
    } else {
	lNewAudioPos = npMCI->dwAudioPos + npMCI->dwABSize;
	if (lNewAudioPos > (LONG) npMCI->dwAudioLength)
	    lNewAudioPos = npMCI->dwAudioLength;
	dwBytesTotal = lNewAudioPos - npMCI->dwAudioPos;
    }

    if (dwBytesTotal == 0) {

        if (npMCI->dwFlags & MCIAVI_WAVEPAUSED) {

            DOUT("no more audio to play, restarting wave device\n");

            waveOutRestart(npMCI->hWave);
            ICDrawStart(npMCI->hicDraw);
            npMCI->dwFlags &= ~(MCIAVI_WAVEPAUSED);
            npMCI->nAudioBehind = 0;
        }

        return TRUE;
    }

    /* If all of the audio buffers are full, we have nothing to do */
    if (npMCI->wABFull == npMCI->wABs)
	return TRUE;

#if 0
    //!!!! Should we be yielding at all in here?
    //!!! NO NO! not if updating!!!!
    if (!fFirstTime) {
	aviTaskYield();
    }
    fFirstTime = FALSE;
#endif

    if (npMCI->dwFlags & MCIAVI_REVERSE)
	npMCI->dwAudioPos = lNewAudioPos;

#ifdef USEAVIFILE
    if (npMCI->pf) {
	LONG	    lPos;
	LONG	    lLength;

        lPos = npMCI->dwAudioPos / SH(npMCI->nAudioStream).dwSampleSize;
	lLength = dwBytesTotal / SH(npMCI->nAudioStream).dwSampleSize;

        AVIStreamRead(SI(npMCI->nAudioStream)->ps,
		      lPos, lLength,
		      lpWaveHdr->lpData,
		      npMCI->dwABSize,
		      NULL, NULL);
    }
    else
#endif
    {
	if (!ReadSomeAudio(npMCI, lpWaveHdr->lpData,
			npMCI->dwAudioPos,
			&dwBytesTotal))
	    return FALSE;
		
	if (dwBytesTotal == 0)
		return TRUE;
    }

    if (!(npMCI->dwFlags & MCIAVI_REVERSE))
	npMCI->dwAudioPos += dwBytesTotal;

    lpWaveHdr->dwBufferLength = dwBytesTotal;

    if (npMCI->dwFlags & MCIAVI_REVERSE) {
	ReverseWaveBuffer(npMCI, lpWaveHdr);
    }

    if (!PlaySomeAudio(npMCI, lpWaveHdr))
	return FALSE;

//  return TRUE;

    goto PlayMore;
}


/* Play the current chunk's audio */
BOOL NEAR PASCAL HandleAudioChunk(NPMCIGRAPHIC npMCI)
{
    LPWAVEHDR	lpWaveHdr;
    FOURCC	ckid;
    DWORD	cksize;
    BYTE _huge *lpData;
    BOOL	fRet = TRUE;
    BOOL	fSilence;
    DWORD	dwBytesTotal = 0L;
    DWORD       dwBytesThisChunk;
    DWORD       dwBytesThisBuffer;
    BOOL        fHurryUp;

    Assert(npMCI->wPlaybackAlg == MCIAVI_ALG_CDROM);

    while ((DWORD) (npMCI->lp - npMCI->lpBuffer)
            < npMCI->dwThisRecordSize - 3 * sizeof(DWORD)) {

	/* Look at the next chunk */
	ckid = GET_DWORD();
	cksize = GET_DWORD();

	lpData = npMCI->lp;
	SKIP_BYTES(cksize + (cksize & 1));

	fSilence = (TWOCCFromFOURCC(ckid) == cktypeWAVEsilence);

	if (fSilence) {
	    if (cksize != sizeof(DWORD)) {
		DPF(("Wave silence chunk of bad length!\n"));
		fRet = FALSE;
		npMCI->dwTaskError = MCIERR_INVALID_FILE;
		goto exit;
	    }
	    dwBytesThisChunk = PEEK_DWORD();
	} else {
	    dwBytesThisChunk = cksize;
	}

	while (dwBytesThisChunk > 0) {
	    lpWaveHdr = ((LPWAVEHDR)npMCI->lpAudio) + npMCI->wNextAB;

	    if (!WaitForFreeAudioBuffer(npMCI, &fHurryUp))
		/* We had to stop waiting--the stop flag was probably set. */
		goto exit;
	
	    dwBytesThisBuffer = min(dwBytesThisChunk,
			    npMCI->dwABSize - npMCI->dwUsedThisAB);

	    if (!fSilence) {
		/* Move the data into the buffer */
		hmemcpy((BYTE _huge *) lpWaveHdr->lpData + npMCI->dwUsedThisAB,
			lpData,
			dwBytesThisBuffer);
		lpData += dwBytesThisBuffer;
	    } else {
		/* Fill the buffer with silence */
		/* This isn't right for 16-bit! */
#ifndef WIN32
    #pragma message("WAVE silence chunks don't work right now.")
#endif
	//      fmemfill((BYTE _huge *)lpWaveHdr->lpData + npMCI->dwUsedThisAB,
	//				dwBytesThisBuffer, 0x80);
	    }
	
	    dwBytesThisChunk -= dwBytesThisBuffer;
	    npMCI->dwUsedThisAB += dwBytesThisBuffer;

//	    if (npMCI->dwUsedThisAB == npMCI->dwABSize) {
		lpWaveHdr->dwBufferLength = npMCI->dwUsedThisAB;

		fRet = PlaySomeAudio(npMCI, lpWaveHdr);
//	    }
	}
    }

exit:
    return fRet;
}



/******************************************************************************
*****************************************************************************/

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | StealWaveDevice | steal the audio device from another
 * instance of MCIAVI.
 *
 * @parm NPMCIGRAPHIC | npMCI | near ptr to the instance data
 *
 ***************************************************************************/

BOOL FAR PASCAL StealWaveDevice(NPMCIGRAPHIC npMCI)
{
    extern NPMCIGRAPHIC npMCIList; // in graphic.c
    NPMCIGRAPHIC np;

    Assert(npMCI->hWave == NULL);

    DPF(("StealWaveDevice '%s' hTask=%04X\n", (LPSTR)npMCI->szFilename, GetCurrentTask()));

    //
    //  walk the list of open MCIAVI instances and find one that
    //  will give up the wave device
    //
    for (np=npMCIList; np; np = np->npMCINext) {

        if (np->hWave) {
            DPF(("**** Stealing the wave device from '%s'.\n", (LPSTR)np->szFilename));

            //!!!should we call DeviceMute() or just call cleanup audio?
            //
            //!!!can this cause evil reenter cases?
            //
            //!!!we are calling this from another task, will this work ok?
            //!!!even in WIN32? mabey we should use SendMessage()
#if 1
            SendMessage(np->hwndDefault, WM_AUDIO_OFF, 0, 0);
#else
            np->dwFlags |= MCIAVI_LOSTAUDIO;
            DeviceMute(np, TRUE);
            np->dwFlags |= MCIAVI_LOSTAUDIO;
#endif
            return TRUE;
        }
    }

    DPF(("StealWaveDevice can't find a device to steal\n"));

    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | GiveWaveDevice | give away the audio device
 * instance of MCIAVI.
 *
 * @parm NPMCIGRAPHIC | npMCI | near ptr to the instance data
 *
 ***************************************************************************/

BOOL FAR PASCAL GiveWaveDevice(NPMCIGRAPHIC npMCI)
{
    extern NPMCIGRAPHIC npMCIList; // in graphic.c
    NPMCIGRAPHIC np;

    Assert(npMCI->hWave == NULL);

    DPF(("GiveWaveDevice '%s' hTask=%04X\n", (LPSTR)npMCI->szFilename, GetCurrentTask()));

    //
    //  walk the list of open MCIAVI instances and find one that
    //  will give up the wave device
    //
    for (np=npMCIList; np; np = np->npMCINext) {

        if (np->dwFlags & MCIAVI_LOSTAUDIO) {
            DPF(("**** Giving the wave device to '%s'.\n", (LPSTR)np->szFilename));

            PostMessage(np->hwndDefault, WM_AUDIO_ON, 0, 0);

            return TRUE;
        }
    }

    return FALSE;
}



#ifndef WIN32
#pragma alloc_text(FIX, mciaviWaveOutFunc)
#pragma optimize("", off)
#endif

void FAR PASCAL _LOADDS mciaviWaveOutFunc(HWAVEOUT hWaveOut, UINT wMsg,
		    DWORD dwInstance, DWORD dwParam1, DWORD dwParam2)
{
    NPMCIGRAPHIC npMCI;
    LPWAVEHDR    lpwh;

#ifndef WIN32
#ifndef WANT_286
        // If compiling -G3 we need to save the 386 registers
        _asm _emit 0x66  ; pushad
        _asm _emit 0x60
#endif
#endif

    npMCI = (NPMCIGRAPHIC)(UINT)dwInstance;
    lpwh = (LPWAVEHDR) dwParam1;

    switch(wMsg) {
	case MM_WOM_DONE:
	
            npMCI->wABFull--;
            npMCI->dwAudioPlayed += lpwh->dwBufferLength;
	    npMCI->dwTimingStart = timeGetTime();
	    break;
    }

#ifndef WIN32
#ifndef WANT_286
        // If compiling -G3 we need to restore the 386 registers
        _asm _emit 0x66  ; popad
        _asm _emit 0x61
#endif
#endif
}

#ifndef WIN32
#pragma optimize("", off)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\common.c ===
/* common.c
 *
 * Common functions useful for Windows programs.
 */



#include <windows.h>
#include <stdarg.h>
#include <win32.h> 	// This must be included, for both versions

#ifdef DEBUG  // On NT, ntavi.h might do an undef debug...
#include "common.h"


/* globals */
int		giDebugLevel = 0;	// current debug level (0 = disabled)
int		gfhDebugFile = -1;	// file handle for debug output (or -1)



/* InitializeDebugOutput(szAppName)
 *
 * Read the current debug level of this application (named <szAppName>)
 * from the [debug] section of win.ini, as well as the current location
 * for debug output.
 */
void FAR PASCAL
InitializeDebugOutput(LPSTR szAppName)
{
	char		achLocation[300]; // debug output location

	/* debugging is disabled by default (and if an error occurs below) */
	giDebugLevel = 0;
	gfhDebugFile = -1;

	/* get the debug output location */
        if ( (GetProfileStringA("debug", "Location", "", achLocation,
	                     sizeof(achLocation)) == sizeof(achLocation)) ||
	     (achLocation[0] == 0) )
		return;
	
	if (achLocation[0] == '>')
	{
		/* <achLocation> is the name of a file to overwrite (if
		 * a single '>' is given) or append to (if '>>' is given)
		 */
		if (achLocation[1] == '>')
			gfhDebugFile = _lopen(achLocation + 2, OF_WRITE);
		else
			gfhDebugFile = _lcreat(achLocation + 1, 0);
		
		if (gfhDebugFile < 0)
			return;
		
		if (achLocation[1] == '>')
			_llseek(gfhDebugFile, 0, SEEK_END);
	}
	else
	if (lstrcmpiA(achLocation, "aux") == 0)
	{
		/* use OutputDebugString() for debug output */
	}
	else
        if (lstrcmpiA(achLocation, "com1") == 0)
	{
                gfhDebugFile = _lopen(achLocation, OF_WRITE);
	}
        else
        if (lstrcmpiA(achLocation, "com2") == 0)
        {
                gfhDebugFile = _lopen(achLocation, OF_WRITE);
	}
	
	/* get the debug level */
	giDebugLevel = GetProfileIntA("debug", szAppName, 0);
}


/* TerminateDebugOutput()
 *
 * Terminate debug output for this application.
 */
void FAR PASCAL
TerminateDebugOutput(void)
{
	if (gfhDebugFile >= 0)
		_lclose(gfhDebugFile);
	gfhDebugFile = -1;
	giDebugLevel = 0;
}


/* _Assert(szExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
#ifndef WIN32
#pragma optimize("", off)
#endif

void FAR PASCAL
_Assert(char *szExp, char *szFile, int iLine)
{
	static char	ach[300];	// debug output (avoid stack overflow)
	int		id;
	int		iExitCode;
	void FAR PASCAL DebugBreak(void);

	/* display error message */

        if (szExp)
            wsprintfA(ach, "(%s)\nFile %s, line %d", (LPSTR)szExp, (LPSTR)szFile, iLine);
        else
            wsprintfA(ach, "File %s, line %d", (LPSTR)szFile, iLine);

	MessageBeep(MB_ICONHAND);
	id = MessageBoxA(NULL, ach, "Assertion Failed",
#ifdef BIDI
		MB_RTL_READING |
#endif
		MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

	/* abort, debug, or ignore */
	switch (id)
	{

	case IDABORT:

		/* kill this application */
		iExitCode = 0;
#ifndef WIN32
		_asm
		{
			mov	ah, 4Ch
			mov	al, BYTE PTR iExitCode
			int     21h
		}
#else
                FatalAppExit(0, TEXT("Good Bye"));
#endif // WIN16
		break;

	case IDRETRY:
		/* break into the debugger */
		DebugBreak();
		break;

	case IDIGNORE:
		/* ignore the assertion failure */
		break;
	}
}
#ifndef WIN32
#pragma optimize("", on)
#endif

/* _DebugPrintf(szFormat, ...)
 *
 * If the application's debug level is at or above <iDebugLevel>,
 * then output debug string <szFormat> with formatting codes
 * replaced with arguments in the argument list pointed to by <szArg1>.
 */
void FAR CDECL
_DebugPrintf(LPSTR szFormat, ...)
{
	static char	ach[300];	// debug output (avoid stack overflow)
	int		cch;		// length of debug output string
        NPSTR           pchSrc, pchDst;

#ifndef WIN32
        wvsprintf(ach, szFormat, (LPVOID)(&szFormat+1));
#else
        va_list va;

        va_start(va, szFormat);
        wvsprintfA(ach, szFormat, va);
        va_end(va);
#endif

	/* expand the newlines into carrige-return-line-feed pairs;
	 * first, figure out how long the new (expanded) string will be
	 */
	for (pchSrc = pchDst = ach; *pchSrc != 0; pchSrc++, pchDst++)
		if (*pchSrc == '\n')
			pchDst++;
	
	/* is <ach> large enough? */
	cch = pchDst - ach;
        Assert(cch < sizeof(ach));
	*pchDst-- = 0;

	/* working backwards, expand \n's to \r\n's */
	while (pchSrc-- > ach)
		if ((*pchDst-- = *pchSrc) == '\n')
			*pchDst-- = '\r';

	/* output the debug string */
	if (gfhDebugFile > 0)
		_lwrite(gfhDebugFile, ach, cch);
	else
		OutputDebugStringA(ach);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\fullproc.c ===
/****************************************************************************
 *
 *  DRAWPROC.C
 *
 *  Standard AVI drawing handler.
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <compman.h>
#include <dispdib.h>
#ifdef WIN32
#include <mmddk.h>
#endif

static SZCODE szDisplayDibLib[] = TEXT("DISPDIB.DLL");
static SZCODEA szDisplayDibEx[]  = "DisplayDibEx";

#define FOURCC_VIDS         mmioFOURCC('v','i','d','s')
#define FOURCC_AVIFull      mmioFOURCC('F','U','L','L')
#define VERSION_AVIFull     0x00010000      // 1.00

#ifndef HUGE
    #define HUGE _huge
#endif

extern FAR PASCAL LockCurrentTask(BOOL);

static int siUsage = 0;

HINSTANCE	ghDISPDIB = NULL; // handle to DISPDIB.DLL module
UINT (FAR PASCAL *DisplayDibExProc)(LPBITMAPINFOHEADER lpbi, int x, int y, BYTE HUGE * hpBits, UINT wFlags);

/***************************************************************************
 ***************************************************************************/

typedef struct {
    int                 xDst;           // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;
    int                 xSrc;           // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;
    HWND		hwnd;
    HWND                hwndOldFocus;
    BOOL                fRle;
    DWORD               biSizeImage;
} INSTINFO, *PINSTINFO;

// static stuff in this file.
LONG FAR PASCAL _loadds ICAVIFullProc(DWORD id, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2);
static LONG AVIFullOpen(ICOPEN FAR * icopen);
static LONG AVIFullClose(PINSTINFO pi);
static LONG AVIFullGetInfo(ICINFO FAR *icinfo, LONG lSize);
static LONG AVIFullQuery(PINSTINFO pi, LPBITMAPINFOHEADER lpbiIn);
static LONG AVIFullSuggestFormat(PINSTINFO pi, ICDRAWSUGGEST FAR *lpicd, LONG cbicd);
static LONG AVIFullBegin(PINSTINFO pi, ICDRAWBEGIN FAR *lpicd, LONG cbicd);
static LONG AVIFullDraw(PINSTINFO pi, ICDRAW FAR *lpicd, LONG cbicd);
static LONG AVIFullEnd(PINSTINFO pi);

/***************************************************************************
 ***************************************************************************/

LONG FAR PASCAL _loadds ICAVIFullProc(DWORD id, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2)
{
    INSTINFO *pi = (INSTINFO *)(UINT)id;

    switch (uiMessage)
    {
        case DRV_LOAD:
	    return 1;
	
        case DRV_FREE:
            return 1;

        /*********************************************************************
            open
        *********************************************************************/

        case DRV_OPEN:
	    if (ghDISPDIB == NULL) {
		UINT w;

		w = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

		if ((ghDISPDIB = LoadLibrary(szDisplayDibLib)) > HINSTANCE_ERROR) {
		    (FARPROC)DisplayDibExProc = GetProcAddress(ghDISPDIB, szDisplayDibEx);
		}
		else
		    ghDISPDIB = (HINSTANCE)-1;

		SetErrorMode(w);
	    }

	    if (DisplayDibExProc == NULL)
		return 0;
	
            if (lParam2 == 0L)
                return 1;

            return AVIFullOpen((ICOPEN FAR *)lParam2);

	case DRV_CLOSE:
	    if (id == 1)
		return 1;

            return AVIFullClose(pi);

        /*********************************************************************
            Configure/Info messages
        *********************************************************************/

        case DRV_QUERYCONFIGURE:    // configuration from drivers applet
            return 0;

        case DRV_CONFIGURE:
            return 1;

        case ICM_CONFIGURE:
        case ICM_ABOUT:
            return ICERR_UNSUPPORTED;

        /*********************************************************************
            state messages
        *********************************************************************/

        case ICM_GETSTATE:
        case ICM_SETSTATE:
            return 0L;

#if 0
        case ICM_GETINFO:
            return AVIFullGetInfo((ICINFO FAR *)lParam1, lParam2);
#endif

        /*********************************************************************
            decompress messages
        *********************************************************************/

        case ICM_DRAW_QUERY:
            return AVIFullQuery(pi, (LPBITMAPINFOHEADER)lParam1);

	case ICM_DRAW_SUGGESTFORMAT:
	    return AVIFullSuggestFormat(pi, (ICDRAWSUGGEST FAR *) lParam1, lParam2);

        case ICM_DRAW_BEGIN:
	    return AVIFullBegin(pi, (ICDRAWBEGIN FAR *) lParam1, lParam2);

        case ICM_DRAW:
            return AVIFullDraw(pi, (ICDRAW FAR *)lParam1, lParam2);

	case ICM_DRAW_CHANGEPALETTE:
	    DisplayDibExProc((LPBITMAPINFOHEADER) lParam1, 0, 0, NULL,
			DISPLAYDIB_NOWAIT | DISPLAYDIB_NOIMAGE);

	    return ICERR_OK;

        case ICM_DRAW_END:
            return AVIFullEnd(pi);

        /*********************************************************************
            standard driver messages
        *********************************************************************/

        case DRV_DISABLE:
        case DRV_ENABLE:
            return 1;

        case DRV_INSTALL:
        case DRV_REMOVE:
            return 1;
    }

    if (uiMessage < DRV_USER)
        return DefDriverProc(id,hDriver,uiMessage,lParam1,lParam2);
    else
        return ICERR_UNSUPPORTED;
}

/*****************************************************************************
 *
 * AVIFullOpen() is called from the DRV_OPEN message
 *
 ****************************************************************************/

static LONG AVIFullOpen(ICOPEN FAR * icopen)
{
    INSTINFO *  pinst;

    //
    // refuse to open if we are not being opened as a Video compressor
    //
    if (icopen->dwFlags & ICMODE_COMPRESS)
        return 0;

    if (icopen->dwFlags & ICMODE_DECOMPRESS)
        return 0;

    pinst = (INSTINFO *)LocalAlloc(LPTR, sizeof(INSTINFO));

    if (!pinst)
    {
        icopen->dwError = ICERR_MEMORY;
        return 0;
    }

    ++siUsage;

    //
    // return success.
    //
    icopen->dwError = ICERR_OK;

    return (LONG) (UINT) pinst;
}

/*****************************************************************************
 *
 * Close() is called on the DRV_CLOSE message.
 *
 ****************************************************************************/
static LONG AVIFullClose(PINSTINFO pi)
{
    LocalFree((HLOCAL) pi);

    if (--siUsage == 0) {
	/* unload DISPDIB library (if loaded) */
	if (ghDISPDIB != NULL && ghDISPDIB != (HINSTANCE) -1)
	    FreeLibrary(ghDISPDIB), ghDISPDIB = NULL;
    }

    return 1;
}

#if 0
/*****************************************************************************
 *
 * AVIFullGetInfo() implements the ICM_GETINFO message
 *
 ****************************************************************************/
static LONG AVIFullGetInfo(ICINFO FAR *icinfo, LONG lSize)
{
    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (lSize < sizeof(ICINFO))
        return 0;

    icinfo->dwSize	    = sizeof(ICINFO);
    icinfo->fccType         = FOURCC_VIDS;
    icinfo->fccHandler      = FOURCC_AVIFull;
    icinfo->dwFlags	    = VIDCF_DRAW;
    icinfo->dwVersion       = VERSION_AVIFull;
    icinfo->dwVersionICM    = ICVERSION;
    lstrcpy(icinfo->szDescription, szDescription);
    lstrcpy(icinfo->szName, szName);

    return sizeof(ICINFO);
}
#endif

/*****************************************************************************
 *
 * AVIFullQuery() implements ICM_DRAW_QUERY
 *
 ****************************************************************************/
static LONG AVIFullQuery(PINSTINFO pi,
			 LPBITMAPINFOHEADER lpbiIn)
{
    //
    // determine if the input DIB data is in a format we like.
    //
    if (lpbiIn == NULL)
        return ICERR_BADFORMAT;

    if (DisplayDibExProc(lpbiIn, 0, 0, 0,
                DISPLAYDIB_MODE_DEFAULT|DISPLAYDIB_NOWAIT|DISPLAYDIB_TEST) != 0)
	return ICERR_BADFORMAT;

    return ICERR_OK;
}


static LONG AVIFullSuggestFormat(PINSTINFO pi, ICDRAWSUGGEST FAR *lpicd, LONG cbicd)
{
    HIC hic;
    static int iFull = -1;
    int	iDepth;

    if (iFull < 0) {
	BITMAPINFOHEADER bih;

	bih.biSize = sizeof(bih);
	bih.biBitCount = 16;
	bih.biCompression = BI_RGB;
	bih.biWidth = 160;
	bih.biHeight = 120;

	iFull = (AVIFullQuery(pi, &bih) == ICERR_OK) ? 1 : 0;
    }

    iDepth = lpicd->lpbiIn->biBitCount > 8 && iFull == 1 ? 16 : 8;

    if (lpicd->lpbiSuggest == NULL)
	return sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD);

    hic = ICGetDisplayFormat(NULL, lpicd->lpbiIn,
			     lpicd->lpbiSuggest,
			     iDepth, 0, 0);

    if (hic)
	ICClose(hic);


    return sizeof(BITMAPINFOHEADER) + lpicd->lpbiSuggest->biClrUsed * sizeof(RGBQUAD);
}

/*****************************************************************************
 *
 * AVIFullBegin() implements ICM_DRAW_BEGIN
 *
 ****************************************************************************/

static LONG AVIFullBegin(PINSTINFO pi, ICDRAWBEGIN FAR *lpicd, LONG cbicd)
{
    UINT	w;
    LONG	lRet;

    if (!(lpicd->dwFlags & ICDRAW_FULLSCREEN))
	return ICERR_UNSUPPORTED; // !!! Necessary?

    lRet = AVIFullQuery(pi, lpicd->lpbi);
    if (lRet != 0 || (lpicd->dwFlags & ICDRAW_QUERY))
	return lRet;

    // Copy over whatever we want to remember
    pi->hwnd = lpicd->hwnd;
    pi->xDst = lpicd->xDst;
    pi->yDst = lpicd->yDst;
    pi->dxDst = lpicd->dxDst;
    pi->dyDst = lpicd->dyDst;
    pi->xSrc = lpicd->xSrc;
    pi->ySrc = lpicd->ySrc;
    pi->dxSrc = lpicd->dxSrc;
    pi->dySrc = lpicd->dySrc;

    //
    //  remember if this is RLE because we may need to hack it later.
    //
    pi->fRle = lpicd->lpbi->biCompression == BI_RLE8;
    pi->biSizeImage = (DWORD)(((UINT)lpicd->lpbi->biWidth+3)&~3)*(DWORD)(UINT)lpicd->lpbi->biHeight;

    pi->hwndOldFocus = GetFocus();
    SetFocus(NULL);

    //
    // we dont need to do this, DISPDIB will do it for us
    //
#if 0
    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
    LockCurrentTask(TRUE);
#endif

    /* Capture the mouse, so other apps don't get called. */
    SetCapture(pi->hwnd);

    /* We don't explicitly specify a graphics mode; DispDib will
    ** choose one for us.
    */
    w = DisplayDibExProc(lpicd->lpbi, 0, 0, NULL,
		DISPLAYDIB_BEGIN | DISPLAYDIB_NOWAIT);

    switch (w) {
	case DISPLAYDIB_INVALIDFORMAT:
	    return ICERR_BADFORMAT;
	
	case 0:
	    return ICERR_OK;

	default:
	    return ICERR_UNSUPPORTED;
    }
}


/*****************************************************************************
 *
 * AVIFullDraw() implements ICM_DRAW
 *
 ****************************************************************************/

static LONG AVIFullDraw(PINSTINFO pi, ICDRAW FAR *lpicd, LONG cbicd)
{
    UINT    wFlags;
    UINT    w;

    wFlags = DISPLAYDIB_NOPALETTE | DISPLAYDIB_NOWAIT;

    if (pi->dxDst > pi->dxSrc)
	wFlags |= DISPLAYDIB_ZOOM2;

    if (lpicd->dwFlags & ICDRAW_NULLFRAME) {
	return ICERR_OK;  // !!!
    }

    if (lpicd->dwFlags & ICDRAW_PREROLL) {
	if (((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression == BI_RGB) // !!!
	    return ICERR_OK;
    }

    if (lpicd->dwFlags & ICDRAW_HURRYUP)
	; // !!! DONTDRAW?

    if (lpicd->lpData == NULL)
        return ICERR_UNSUPPORTED;

    //
    // We need a hack here for the RLE case, to make sure that
    // DIBs are marked correctly as BI_RLE8 or BI_RGB....
    //
    if (pi->fRle) {
        if (lpicd->cbData == pi->biSizeImage)
            ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression = BI_RGB;
        else
            ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression = BI_RLE8;
    }

    w = DisplayDibExProc(lpicd->lpFormat, 0, 0, lpicd->lpData, wFlags);

    if (pi->fRle)
        ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression = BI_RLE8;

    if (w != DISPLAYDIB_NOERROR)
	return ICERR_ERROR;

    return ICERR_OK;
}

/*****************************************************************************
 *
 * AVIFullEnd() implements ICM_DRAW_END
 *
 ****************************************************************************/

static LONG AVIFullEnd(PINSTINFO pi)
{
    MSG  msg;
	
    DisplayDibExProc(NULL, 0, 0, NULL, DISPLAYDIB_END | DISPLAYDIB_NOWAIT);

    //
    // we dont need to do this, DISPDIB will do it for us
    //
#if 0
    LockCurrentTask(FALSE);

    /* Can we assume the error mode should be 0? */
    SetErrorMode(0);
#endif

    ReleaseCapture();

    /* Clear out left-over key messages */
    while (PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST,
			PM_REMOVE | PM_NOYIELD))
	;
    /* Clear out left-over mouse messages */
    while (PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
			PM_REMOVE | PM_NOYIELD))
	;
    SetFocus(pi->hwndOldFocus);

    return ICERR_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\device.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   device.c - Multimedia Systems Media Control Interface
            driver for AVI.

*****************************************************************************/
#include "graphic.h"
#include "avitask.h"

#define ALIGNULONG(i)     ((i+3)&(~3))                  /* ULONG aligned ! */
#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)

#ifdef WIN32
/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | TaskWaitComplete | wait for a task to complete
 *
 ***************************************************************************/

void TaskWaitComplete(NPMCIGRAPHIC npMCI)
{
    LONG lCount;

    /*
    ** Release the critical section so that the task can complete!
    */

    lCount = npMCI->lCritRefCount;
    npMCI->lCritRefCount = 0;
    LeaveCriticalSection(&npMCI->CritSec);

    /*
    ** Use the handle given to us when we created the task to wait
    ** for the thread to complete
    */

    WaitForSingleObject(npMCI->hThreadTermination, INFINITE);
    CloseHandle(npMCI->hThreadTermination);

    /*
    ** Restore our critical section state
    */

    EnterCriticalSection(&npMCI->CritSec);
    npMCI->lCritRefCount = lCount;
}
#endif

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | TaskWait | wait for a task state
 *      background task.
 *
 ***************************************************************************/

DWORD mciaviTaskWait(NPMCIGRAPHIC npMCI, int state, BOOL fMciWait)
{
#ifdef WIN32
    long lCount;
    MSG msg;
#endif
    DWORD	dwStartWaitTime = timeGetTime();
// #define TIMEOUT_VALUE        10000L

#ifndef WIN32
    Assert(npMCI->hTask != GetCurrentTask());
#endif

    /*
    ** either wait for a state (state > 0) or wait for not state (state < 0)
    **
    ** !!! if we want to timeout this is the place to do it.
    **
    ** !!! Should we put up a wait cursor here?
    */
    while (state < 0
        ? (int)npMCI->wTaskState == -state
        : (int)npMCI->wTaskState != state)
    {
        if (!IsTask(npMCI->hTask)) {
            npMCI->dwTaskError = MCIERR_DEVICE_NOT_READY;
            return MCIERR_DEVICE_NOT_READY;
        }

#ifdef WIN32
        /*
         * Critical sections:
         *
         * We hold a critical section around the whole of the
         * WinProc (among other things). The owning thread can re-enter
         * a critical section, but needs to Leave the same number of times.
         *
         * When yielding here, we need to release the critical section. To avoid
         * the problem of multiple entries, EnterCrit is a macro that
         * increments an entry count (protected by the critical section), and
         * only goes one level into the critsec. Correspondingly,
         * LeaveCrit decrements the count and only actually leaves if
         * the count reaches 0.
         *
         * Here, however, we need to actually Enter and Leave regardless
         * of the count, so that we release the critical section
         * to other threads during the yield. Thus we don't use the macro,
         * and we also save/restore the critsec count so someone else
         * getting the critsec while we are yielding will behave correctly.
         */

        lCount = npMCI->lCritRefCount;
        npMCI->lCritRefCount = 0;
        LeaveCriticalSection(&npMCI->CritSec);

       /*
        *  Sleep for > 0 because this thread may be at a higher priority than
        *  then thread actually playing the AVI because of the use of
        *  SetThreadPriorityBackground  and Sleep(0) only relinquishes
        *  the remainder of the time slice if another thread of the SAME
        *  PRIORITY is waiting to run.
        */

        Sleep(10);
#else
//      DirectedYield(npMCI->hTask);
        Yield();
#endif

#ifdef WM_AVISWP
        if (TRUE)
#else
        if (fMciWait)
#endif
        {
#ifdef WIN32
            /*
             * if it's safe to yield, it's safe to poll
             * messages fully. This way, we will be absolutely
             * sure of getting the async size messages etc
             */
            //aviTaskYield();
            // it clearly is not safe at this point, since this
            // yield can cause mci to close the driver, leaving us
            // with nowhere to return to.
            // handling messages for our own window is safe and should have the
            // desired effect.
#ifdef WM_AVISWP
            if (npMCI->hwnd) {
                if (PeekMessage(&msg, npMCI->hwnd, WM_AVISWP, WM_AVISWP, PM_REMOVE))
                    DispatchMessage(&msg);
            }
#endif

#endif

            if (fMciWait && mciDriverYield(npMCI->wDevID)) {
#ifdef WIN32
                EnterCriticalSection(&npMCI->CritSec);
                npMCI->lCritRefCount = lCount;
#endif
		break;
	    }
        } else {
#ifdef TIMEOUT_VALUE	
	    if (timeGetTime() > dwStartWaitTime + TIMEOUT_VALUE) {
		Assert(0);
		npMCI->dwTaskError = MCIERR_DEVICE_NOT_READY;
#ifdef WIN32
                EnterCriticalSection(&npMCI->CritSec);
                npMCI->lCritRefCount = lCount;
#endif
		return MCIERR_DEVICE_NOT_READY;
	    }
#endif	
	}
#ifdef WIN32
        EnterCriticalSection(&npMCI->CritSec);
        npMCI->lCritRefCount = lCount;
#endif
    }
    return 0L;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | mciaviTaskMessage | this function sends a message to the
 *      background task.
 *
 ***************************************************************************/

DWORD mciaviTaskMessage(NPMCIGRAPHIC npMCI, int msg)
{
    if (!IsTask(npMCI->hTask)) {
	npMCI->dwTaskError = MCIERR_DEVICE_NOT_READY;
	return npMCI->dwTaskError;
    }

    if (GetCurrentTask() == npMCI->hTask) {
        mciaviMessage(npMCI, msg);
        return npMCI->dwTaskError;
    }

    if (npMCI->wTaskState == TASKPAUSED) {
        DPF(("Ack! message while PAUSED!\n"));
	return 1; // !!! Real error?
    }

#ifdef DEBUG
    if (npMCI->wTaskState != TASKIDLE) {
        DPF0(("Unknown task state (mciaviTaskMessage) %d\n", npMCI->wTaskState));
    }
    Assert(npMCI->wTaskState == TASKIDLE);
#endif


    if (mciaviTaskWait(npMCI, TASKIDLE, FALSE) != 0) {
        DPF(("Error waiting for TASKIDLE in mciaviTaskMessage\n"));
        return npMCI->dwTaskError;
    }

    npMCI->dwTaskError = 0L;
    npMCI->wTaskState = msg;
    mmTaskSignal(npMCI->hTask);

    /*
    ** wait for the message to kick in
    */
    mciaviTaskWait(npMCI, -msg, FALSE);

    return npMCI->dwTaskError;
}

DWORD NEAR PASCAL StopTemporarily(NPMCIGRAPHIC npMCI, TEMPORARYSTATE FAR * ps)
{
    DWORD   dw;
    HWND    hCallback;

    DPF2(("StopTemporarily: stopping from state %u.\n", npMCI->wTaskState));

    Assert(ps);

    ps->wOldTaskState = npMCI->wTaskState;
    ps->dwFlags = npMCI->dwFlags;
    ps->lTo = npMCI->lTo - (LONG)npMCI->dwBufferedVideo;
    ps->lFrom = npMCI->lFrom;

    //
    // setting MCIAVI_UPDATING will make sure we dont yield or do
    // other wierd things unless we need to.  it is a bad name for the
    // flag I know I am sorry.
    //
    // it means we are stoping temporarily and will be restarted
    // the code will not do things like give our wave device
    // away or become the active window.
    //
    npMCI->dwFlags |= MCIAVI_UPDATING;

    /* Hide the delayed notification, if any, so it doesn't happen now. */
    hCallback = npMCI->hCallback;
    npMCI->hCallback = NULL;

    dw = DeviceStop(npMCI, MCI_WAIT);

    /* Restore the notification */
    npMCI->hCallback = hCallback;

    if (dw != 0 ) {
        if (ps->dwFlags & MCIAVI_UPDATING)
            npMCI->dwFlags |= MCIAVI_UPDATING;
        else
            npMCI->dwFlags &= ~MCIAVI_UPDATING;
    }

    DPF2(("StopTemporarily: stopped.\n"));
    return dw;
}

DWORD NEAR PASCAL RestartAgain(NPMCIGRAPHIC npMCI, TEMPORARYSTATE FAR * ps)
{
    DWORD   dw = 0;
    DWORD   dwFlags = 0;

    DPF2(("Restart Again: restarting.\n"));

    Assert(ps);

    if (ps->dwFlags & MCIAVI_REVERSE)
        dwFlags = MCI_DGV_PLAY_REVERSE;

    // !!! Make sure that this will actually cause a repeat in all cases....

    if (ps->dwFlags & MCIAVI_REPEATING)
        npMCI->dwFlags |= MCIAVI_REPEATING;
    else
        npMCI->dwFlags &= ~MCIAVI_REPEATING;

    if (ps->wOldTaskState == TASKPLAYING) {
	/* The only flags that matter at this point are the
	** VGA flags and the wait flag.  If we managed to
	** get a new command, neither is in effect, so it's
	** okay to pass zero for these flags.
	*/
	npMCI->lFrom = npMCI->lCurrentFrame;
	dw = DevicePlay(npMCI, ps->lTo, dwFlags | MCI_TO);
    } else if (ps->wOldTaskState == TASKCUEING) {
	/* Continue whatever we were doing */
	npMCI->lFrom = ps->lFrom;
	dw = DevicePlay(npMCI, ps->lTo, dwFlags | MCI_TO);
    } else if (ps->wOldTaskState == TASKPAUSED) {
	dw = DeviceCue(npMCI, 0, MCI_WAIT);
	npMCI->lTo = ps->lTo;
    } else if (ps->wOldTaskState == TASKIDLE) {
    } else {
	DPF(("Trying to restart: task state %u...\n", ps->wOldTaskState));
        Assert(0);
    }

    //
    // restore this flag so we can yield again.
    //
    if (ps->dwFlags & MCIAVI_UPDATING)
        npMCI->dwFlags |= MCIAVI_UPDATING;
    else
        npMCI->dwFlags &= ~MCIAVI_UPDATING;

    DPF2(("Restart Again: restarted.\n"));
    return dw;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | ShowStage | This utility function brings the default stage
 * window to the foreground on play, seek, step and pause commands. It
 * does nothing if the stage window is not the default window
 *
 * @parm NPMCIGRAPHIC | npMCI | near ptr to the instance data
 *
 ***************************************************************************/

void NEAR PASCAL ShowStage(NPMCIGRAPHIC npMCI)
{
    if (!(npMCI->dwFlags & MCIAVI_NEEDTOSHOW)) {
        DPF0(("ShowStage returning NEEDTOSHOW is OFF\n"));
        return;
    }

    if ((npMCI->dwFlags & MCIAVI_SHOWVIDEO) &&
	    npMCI->hwnd == npMCI->hwndDefault &&
////////////!(GetWindowLong(npMCI->hwnd, GWL_STYLE) & WS_CHILD) &&
	    (!IsWindowVisible (npMCI->hwnd) ||
		npMCI->hwnd != GetActiveWindow ())) {
#ifdef WM_AVISWP
        // Get the UI thread to do the window positioning
        // This routine can be called on the background task while the main
        // routine is waiting in mciaviTaskWait
        SendMessage(npMCI->hwnd, WM_AVISWP, 0,
                        SWP_NOMOVE | SWP_NOSIZE |
                        SWP_SHOWWINDOW |
                        (IsWindowVisible(npMCI->hwnd) ? SWP_NOACTIVATE : 0));
#else
	SetWindowPos(npMCI->hwnd, HWND_TOP, 0, 0, 0, 0,
			SWP_NOMOVE | SWP_NOSIZE |
			SWP_SHOWWINDOW |
			(IsWindowVisible(npMCI->hwnd) ? SWP_NOACTIVATE : 0));
#endif
    }

    //
    // if the movie has palette changes we need to make it the active
    // window otherwise the palette animation will not work right
    //
    if ((npMCI->dwFlags & MCIAVI_ANIMATEPALETTE) &&
            !(npMCI->dwFlags & MCIAVI_SEEKING) &&
            !(npMCI->dwFlags & MCIAVI_FULLSCREEN) &&
            !(npMCI->dwFlags & MCIAVI_UPDATING) &&
            npMCI->hwnd == npMCI->hwndDefault &&
            !(GetWindowLong(npMCI->hwnd, GWL_STYLE) & WS_CHILD)) {
        SetActiveWindow(npMCI->hwnd);
    }

    npMCI->dwFlags &= ~(MCIAVI_NEEDTOSHOW);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceOpen | Open an AVI file.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm LPSTR | lpName | file name.
 *
 * @parm DWORD | dwFlags | Open flags.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceOpen(NPMCIGRAPHIC npMCI, DWORD dwFlags)
{
    DWORD	dwRet = 0L;

    npMCI->wTaskState = TASKBEINGCREATED;

    npMCI->uErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS |
				     SEM_NOOPENFILEERRORBOX);

#ifndef WIN32
    // give our PSP to the task
    npMCI->pspParent = GetCurrentPDB();
#endif

    switch (mmTaskCreate(mciaviTask, &npMCI->hThreadTermination, (DWORD)(UINT)npMCI)) {
	case 0:


	    // Yield to the newly created task until it has
            // had a chance to initialize or fail to initialize

            while (npMCI->wTaskState <= TASKINIT) {

#ifndef WIN32
                Yield();
#else
                /* we have to peekmsg here since the threads are
                 * synchronised. but we don't need to actually
                 * pick up any messages - so limit ourselves to the
                 * avi window ones
                 */
                Sleep(1);
                if (npMCI->hwnd) {
                    MSG msg;

                    if (PeekMessage(&msg, npMCI->hwnd, 0, 0, PM_REMOVE)) {
                        DispatchMessage(&msg);
                    }
                }
#endif

         	if (npMCI->wTaskState != TASKBEINGCREATED && !IsTask(npMCI->hTask))
                    break;
            }

            /*
             * we need to do this peek message again.  We may have never
             * entered the body of the loop above, or if this thread
             * gets very little cpu during the above loop, we might fail to
             * execute the PeekMessage above AFTER the SetWindowPos happens
             * in mciaviOpen. In that case, the swp resizing will not happen
             * until the next getmessage or peekmessage - in that case,
             * it could come after the ShowWindow (bad) or after
             * another size request (much worse).
             *
             * First check the thread opened the device successfully
             */

	    if (!IsTask(npMCI->hTask)) {
                // Task thread failed its initialisation.  Wait for the
                // task to terminate before returning to the user.
                DPF2(("Waiting for task thread to terminate\n"));
#ifdef WIN32
                // On Win32 we must explicitly wait.  On Win16, because this
                // "thread" does not get control back until the task thread
                // releases control the wait is irrelevant and is not used.
                TaskWaitComplete(npMCI);
#endif
		dwRet = npMCI->dwTaskError;
            } else {

                if (npMCI->hwnd) {
                    MSG msg;
                    if (PeekMessage(&msg, npMCI->hwnd, 0, 0, PM_REMOVE)) {
                        DispatchMessage(&msg);
                    }
                }
            }

	    break;
	
	case TASKERR_NOTASKSUPPORT:
	case TASKERR_OUTOFMEMORY:
	default:
            npMCI->hTask = 0;
	    dwRet = MCIERR_OUT_OF_MEMORY;
	    break;
    }

    SetErrorMode(npMCI->uErrorMode);

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceStop | Stop an AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwFlags | Flags.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceStop(NPMCIGRAPHIC npMCI, DWORD dwFlags)
{
    DWORD dw = 0L;

    /* Stop the record or playback if the task is currently playing */

    if (!IsTask(npMCI->hTask))
	return MCIERR_DEVICE_NOT_READY;
	
    if (npMCI->wTaskState == TASKPLAYING || npMCI->wTaskState == TASKPAUSED
                    || npMCI->wTaskState == TASKCUEING
                    || npMCI->wTaskState == TASKSTARTING) {
        /* Set STOP flag - the task watches for this flag to be set. The
        ** STOP flag is cleared by the task when playback has stopped.
	*/
	// Assert(!(npMCI->dwFlags & MCIAVI_STOP));

	npMCI->dwFlags |= MCIAVI_STOP;

        /* Send an extra signal to the task in case it is still
        ** blocked. This will be true if we are paused or if play
        ** has just completed.
	*/

        mmTaskSignal(npMCI->hTask);

	/* Yield until playback is finished and we've really stopped. */
        mciaviTaskWait(npMCI, TASKIDLE, FALSE);
    } else {
#ifdef DEBUG
        if (npMCI->wTaskState != TASKIDLE) {
            DPF0(("Unknown task state (DeviceStop) %d\n", npMCI->wTaskState));
        }
        Assert(npMCI->wTaskState == TASKIDLE);	 // ??? Why ???
#endif
    }

    return dw;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DevicePause | Pause an AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwFlags | Flags.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DevicePause(NPMCIGRAPHIC npMCI, DWORD dwFlags)
{
    DWORD dw = 0L;

    // If we're currently seeking, allow that to finish before
    // pausing.  This could potentially lock up the machine for
    // a while, but the alternatives are ugly.
    mciaviTaskWait(npMCI, -TASKCUEING, FALSE);

    // Pause the record or playback if the task is currently playing
    // or recording (BUSY)

    if (npMCI->wTaskState == TASKPAUSED) {
	/* We're already paused at the right place, so
	** that means we did it.  Reset the flag, though, just in
	** case we were about to restart.
	*/
	npMCI->dwFlags |= MCIAVI_PAUSE;
	if (dwFlags & MCI_NOTIFY)
	    GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUCCESSFUL);
    } else if (npMCI->wTaskState == TASKPLAYING) {
	npMCI->dwFlags |= MCIAVI_PAUSE | MCIAVI_WAITING;
	
	/* If the notify flag is set, set a flag which will tell us to
	** send a notification when we actually pause.
	*/
	if (dwFlags & MCI_NOTIFY)
	    npMCI->dwFlags |= MCIAVI_CUEING;
	
        if (dwFlags & MCI_WAIT) {
	    /* We have to wait to actually pause. */
	    mciaviTaskWait(npMCI, -TASKPLAYING, TRUE);
	}
	
	npMCI->dwFlags &= ~(MCIAVI_WAITING);
    } else if (npMCI->wTaskState == TASKIDLE) {
	/* We're stopped.  Put us in paused mode by cueing. */
	npMCI->lTo = npMCI->lCurrentFrame;
	DeviceCue(npMCI, 0, dwFlags);
    } else {
	dw = MCIERR_NONAPPLICABLE_FUNCTION;
    }

    return dw;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceClose | Close an AVI file.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceClose (NPMCIGRAPHIC npMCI)
{
    DWORD dw = 0L;

    if (npMCI && IsTask(npMCI->hTask)) {
	/* Be sure to stop playing, one way or another... */
	DeviceStop(npMCI, MCI_WAIT);

        // task state is now TASKIDLE and blocked

#ifdef DEBUG
        if (npMCI->wTaskState != TASKIDLE) {
            DPF0(("Unknown task state (DeviceClose) %d\n", npMCI->wTaskState));
        }
        Assert(npMCI->wTaskState == TASKIDLE);
#endif

        // Set task state to TASKCLOSE - this informs the task that it is
        // time to die.

        mciaviTaskMessage(npMCI, TASKCLOSE);
	mciaviTaskWait(npMCI, TASKCLOSED, FALSE);

#ifdef WIN32

        /*
        ** Wait for the thread to complete so the DLL doesn't get unloaded
        ** while it's still executing code in that thread
        */

        TaskWaitComplete(npMCI);

#endif // WIN32
    }

    return dw;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DevicePlay | Play an AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwFlags | MCI flags from command.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DevicePlay (NPMCIGRAPHIC npMCI, LONG lPlayTo, DWORD dwFlags)
{
    HWND    hCallback;
    DWORD   dw = 0L;

    if (!IsTask(npMCI->hTask))
	return MCIERR_DEVICE_NOT_READY;
	
    /* if not already playing, start the task up. */

    if (dwFlags & MCI_NOTIFY) {
	/* Hide the delayed notification, if any, so it doesn't happen now. */
	hCallback = npMCI->hCallback;
	npMCI->hCallback = NULL;
    }

    /* First, figure out what mode to use. */
    if (dwFlags & (MCI_MCIAVI_PLAY_FULLSCREEN | MCI_MCIAVI_PLAY_FULLBY2)) {
        if (npMCI->rcDest.right - npMCI->rcDest.left >
            npMCI->rcMovie.right - npMCI->rcMovie.left)
	    dwFlags |= MCI_MCIAVI_PLAY_FULLBY2;
	
        if ((dwFlags & MCI_MCIAVI_PLAY_FULLBY2) &&
                (npMCI->rcMovie.right  <= 160) &&
                (npMCI->rcMovie.bottom <= 120)) {
            npMCI->dwFlags |= MCIAVI_ZOOMBY2;
	} else {
	    npMCI->dwFlags &= ~(MCIAVI_ZOOMBY2);
	}

	// !!! This check is dumb: Some DISPDIB's may support > 320x240....
        if ((npMCI->rcMovie.right > 320) || (npMCI->rcMovie.bottom > 240)) {
	    dw = MCIERR_AVI_TOOBIGFORVGA;
	    goto Exit;
	}

	/* If playing, we have to stop so that we'll get put into DispDib
		mode correctly. */
	dw = DeviceStop(npMCI, MCI_WAIT);
	
	if (dw)
	    goto Exit;

	if ((dwFlags & MCI_WAIT) && !(npMCI->dwFlags & MCIAVI_REPEATING))
	    npMCI->dwFlags |= MCIAVI_NOBREAK;
	else
	    npMCI->dwFlags &= ~(MCIAVI_NOBREAK);
		
	npMCI->dwFlags |= MCIAVI_FULLSCREEN;
    } else {
	npMCI->dwFlags &= ~(MCIAVI_FULLSCREEN);
    }

    if ((npMCI->dwFlags & MCIAVI_SEEKING) && (npMCI->lTo != npMCI->lFrom)) {
	/* We're currently seeking, so we have to restart to get audio
	** to work.
	*/
	DeviceStop(npMCI, MCI_WAIT);
    }

    /* If we're currently seeking, stop so play can begin immediately. */
    if (npMCI->wTaskState == TASKCUEING) {
	DeviceStop(npMCI, MCI_WAIT);
    }

    if (npMCI->wTaskState == TASKPLAYING || npMCI->wTaskState == TASKPAUSED) {
	if (((npMCI->dwFlags & MCIAVI_REVERSE) != 0) !=
		((dwFlags & MCI_DGV_PLAY_REVERSE) != 0))
	    DeviceStop(npMCI, MCI_WAIT);
    }

    // Make sure flags are cleared if they should be
    npMCI->dwFlags &= ~(MCIAVI_PAUSE | MCIAVI_CUEING | MCIAVI_REVERSE);

    if (dwFlags & MCI_DGV_PLAY_REPEAT) {
	npMCI->dwFlags |= MCIAVI_REPEATING;
    }

    if (dwFlags & MCI_NOTIFY) {
	/* Restore the notification */
	npMCI->hCallback = hCallback;
    }

    if (lPlayTo > npMCI->lFrames)
        lPlayTo = npMCI->lFrames;

    if (lPlayTo < 0)
        lPlayTo = 0;

    if (dwFlags & MCI_TO)
	npMCI->lTo = lPlayTo;

    if (dwFlags & MCI_DGV_PLAY_REVERSE)
	npMCI->dwFlags |= MCIAVI_REVERSE;

    npMCI->dwFlags |= MCIAVI_WAITING;

    if (npMCI->dwFlags & MCIAVI_NEEDTOSHOW) {
        ShowStage(npMCI);
        //
        // leave this set so the play code knows this is a "real" play
        // coming from the user, not a interal play/stop
        //
        // if the window needs shown we want to do it here if we can
        // not in the background task.
        //
        npMCI->dwFlags |= MCIAVI_NEEDTOSHOW;
    }

    if (npMCI->wTaskState == TASKPAUSED) {
	/* Wake the task up from pausing */
	mmTaskSignal(npMCI->hTask);
    } else if (npMCI->wTaskState == TASKCUEING ||
	       npMCI->wTaskState == TASKPLAYING) {
    } else {
        /* Tell the task what to do when it wakes up */

        mciaviTaskMessage(npMCI, TASKSTARTING);

	dw = npMCI->dwTaskError;
    }

    if (dwFlags & MCI_WAIT) {
	// yield to playback task until playback completes but don't
	// yield to application - apps must use driveryield to get
	// out of waits.

        mciaviTaskWait(npMCI, TASKIDLE, TRUE);
	
	dw = npMCI->dwTaskError;
    }

    if (dwFlags & (MCI_MCIAVI_PLAY_FULLSCREEN | MCI_MCIAVI_PLAY_FULLBY2)) {
	MSG	msg;
	
	/* Remove stray mouse and keyboard events after DispDib. */
	while (PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST,
					PM_NOYIELD | PM_REMOVE) ||
			PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
					PM_NOYIELD | PM_REMOVE))
	    ;
    }

    npMCI->dwFlags &= ~(MCIAVI_WAITING);
Exit:	
    return dw;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceResume | Play an AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwFlags | MCI flags from command.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceResume(NPMCIGRAPHIC npMCI, DWORD dwFlags)
{
    DWORD   dw = 0L;

    if (!IsTask(npMCI->hTask))
	return MCIERR_DEVICE_NOT_READY;
	
    dw = DevicePlay(npMCI, 0, dwFlags |
	    ((npMCI->dwFlags & MCIAVI_REVERSE) ? MCI_DGV_PLAY_REVERSE : 0));

    return dw;
}
/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceCue | Cue an AVI movie for playing.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm LONG | lTo | Frame to seek to, if MCI_TO set in <p dwFlags>.
 *
 * @parm DWORD | dwFlags | MCI flags from command.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceCue(NPMCIGRAPHIC npMCI, LONG lTo, DWORD dwFlags)
{
    DWORD dw = 0L;
    HWND    hCallback;

    /* if not already playing, start animation and set timer */

    if (!IsTask(npMCI->hTask))
	return MCIERR_DEVICE_NOT_READY;
	
    if (dwFlags & MCI_NOTIFY) {
	/* Hide the delayed notification, if any, so it doesn't happen now. */
	hCallback = npMCI->hCallback;
	npMCI->hCallback = NULL;
    }

    if (npMCI->dwFlags & MCIAVI_SEEKING) {
	/* We're currently seeking, so we have to start again to get audio
	** to work.
	*/
	DeviceStop(npMCI, MCI_WAIT);
    }

    if (dwFlags & MCI_TO) {
	DeviceStop(npMCI, MCI_WAIT);
	npMCI->lFrom = lTo;
    } else if (npMCI->wTaskState == TASKIDLE) {
	npMCI->lFrom = npMCI->lCurrentFrame;
    }

    if (dwFlags & MCI_NOTIFY) {
	/* Restore the notification */
	npMCI->hCallback = hCallback;
    }

    /* If we're ever resumed, we want to go to the end of the file. */
    npMCI->lTo = npMCI->lFrames;

    if (npMCI->wTaskState == TASKPAUSED) {
	/* We're already paused at the right place, so
	** that means we did it.
	*/
	if (dwFlags & MCI_NOTIFY)
	    GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUCCESSFUL);
    } else if (npMCI->wTaskState == TASKIDLE) {
	// !!! Is this the only condition we can do this in?	
	npMCI->dwFlags |= MCIAVI_PAUSE | MCIAVI_CUEING | MCIAVI_WAITING;

        mciaviTaskMessage(npMCI, TASKSTARTING);

        if (dwFlags & MCI_WAIT) {
            mciaviTaskWait(npMCI, -TASKCUEING, TRUE);
	}

	npMCI->dwFlags &= ~(MCIAVI_WAITING);
	
	dw = npMCI->dwTaskError;	
    } else if (npMCI->wTaskState == TASKCUEING) {
	npMCI->dwFlags |= MCIAVI_PAUSE | MCIAVI_CUEING | MCIAVI_WAITING;

        if (dwFlags & MCI_WAIT) {
            mciaviTaskWait(npMCI, -TASKCUEING, TRUE);
	}

	npMCI->dwFlags &= ~(MCIAVI_WAITING);
	
	dw = npMCI->dwTaskError;		
    } else if (npMCI->wTaskState == TASKPLAYING) {
	npMCI->dwFlags |= MCIAVI_PAUSE | MCIAVI_CUEING | MCIAVI_WAITING;

        if (dwFlags & MCI_WAIT) {
            mciaviTaskWait(npMCI, -TASKPLAYING, TRUE);
	}

	npMCI->dwFlags &= ~(MCIAVI_WAITING);
	
	dw = npMCI->dwTaskError;		
    } else {
	dw = MCIERR_NONAPPLICABLE_FUNCTION;
    }

    return dw;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSeek | Seek to a position in an AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm LONG | lTo | Frame to seek to.
 *
 * @parm DWORD | dwFlags | MCI flags from command.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceSeek(NPMCIGRAPHIC npMCI, LONG lTo, DWORD dwFlags)
{
    DWORD dw = 0;
    HWND    hCallback;

    DPF3(("DeviceSeek\n"));
    /* The window will be shown by the play code. */

    /* If we can just shorten a previous seek, do it. */
    if ((npMCI->wTaskState == TASKCUEING) &&
	    (npMCI->dwFlags & MCIAVI_SEEKING) &&
	    (npMCI->lCurrentFrame <= lTo) &&
	    (npMCI->lTo >= lTo)) {
	if (lTo != npMCI->lTo) {
	DPF3(("Seeking to %ld instead.\n", lTo));
	}
	npMCI->lTo = lTo;
	return 0L;
    }

    if (dwFlags & MCI_NOTIFY) {
	/* Hide the delayed notification, if any, so it doesn't happen now. */
	hCallback = npMCI->hCallback;
	npMCI->hCallback = NULL;
    }

    /* If playing, stop, so we can seek. */
    dw = DeviceStop(npMCI, MCI_WAIT);

    if (dwFlags & MCI_NOTIFY) {
	/* Restore the notification */
	npMCI->hCallback = hCallback;
    }

    // task state is now TASKIDLE and blocked

    if (npMCI->lCurrentFrame != lTo) {
	npMCI->dwFlags |= MCIAVI_WAITING;

	/* Essentially, we are telling the task: play just frame <lTo>.
	** When it gets there, it will update the screen for us.
	*/
	npMCI->lFrom = npMCI->lTo = lTo;
	mciaviTaskMessage(npMCI, TASKSTARTING);
	if (dwFlags & MCI_WAIT) {
	    mciaviTaskWait(npMCI, -TASKCUEING, TRUE);
	}
	npMCI->dwFlags &= ~(MCIAVI_WAITING);
    } else {
	/* Be sure the window gets shown and the notify gets sent,
	** even though we don't have to do anything.
	*/
	if (npMCI->dwFlags & MCIAVI_NEEDTOSHOW)
	    ShowStage(npMCI);

	if (dwFlags & MCI_NOTIFY)
	    GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUCCESSFUL);	
    }
	
    return dw;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | CheckIfActive | check to see if we are the active movie
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data block.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

static void CheckIfActive(NPMCIGRAPHIC npMCI)
{
    BOOL fActive;
    HWND hwndA;

    //
    //  are we the foreground window?
    //
    //  ??? should the value of <npMCI->fForceBackground> matter?
    //
    //  IMPORTANT:  This does NOT work under NT.  The best that can
    //  be done is to check GetForegroundWindow
    hwndA = GetActiveWindow();

    fActive = (hwndA == npMCI->hwnd) ||
              (GetFocus() == npMCI->hwnd) ||
              (IsChild(hwndA, npMCI->hwnd) && !npMCI->fForceBackground);

    DeviceSetActive(npMCI, fActive);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceRealize | Updates the frame into the given DC
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data block.
 *
 * @parm BOOL | fForceBackground | Realize as background palette?
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceRealize(NPMCIGRAPHIC npMCI)
{
    BOOL fGetDC;
    BOOL fPalChanged;
    BOOL fAlreadyDoneThat;

    if (npMCI->dwFlags & MCIAVI_WANTMOVE)
	CheckWindowMove(npMCI, TRUE);

    if (fAlreadyDoneThat = (BOOL)(npMCI->dwFlags & MCIAVI_UPDATING)) {
	DPF(("Re-entering DeviceRealize - but we don't care"));
    }

    if (fGetDC = (npMCI->hdc == NULL)) {
	npMCI->hdc = GetDC(npMCI->hwnd);
    }

    npMCI->dwFlags |= MCIAVI_UPDATING;

    fPalChanged = PrepareDC(npMCI) > 0;

    if (!fAlreadyDoneThat)
        npMCI->dwFlags &= ~MCIAVI_UPDATING;

    if (fGetDC) {
        UnprepareDC(npMCI);
        ReleaseDC(npMCI->hwnd, npMCI->hdc);
	npMCI->hdc = NULL;
    }

    if (fPalChanged)
        InvalidateRect(npMCI->hwnd, &npMCI->rcDest, TRUE);

    CheckIfActive(npMCI);

    return 0L;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceActivate | is the movie active?
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data block.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceSetActive(NPMCIGRAPHIC npMCI, BOOL fActive)
{
    if (fActive)
#ifdef WIN32
        // We must explicitly request a unicode string.  %s will not
        // work as dprintf uses wvsprintfA
        DPF(("**** '%hs' is active.\n", (LPTSTR)npMCI->szFilename));
#else
        DPF(("**** '%s' is active.\n", (LPTSTR)npMCI->szFilename));
#endif

    //
    //  if we are now the foreground "window" try to get the wave
    //  device back (iff it was stolen from us)
    //
    if (fActive && (npMCI->dwFlags & MCIAVI_LOSTAUDIO)) {

        if (StealWaveDevice(npMCI)) {
            Assert(npMCI->dwFlags & MCIAVI_PLAYAUDIO);
            Assert(npMCI->hWave == NULL);

            npMCI->dwFlags &= ~MCIAVI_PLAYAUDIO;
            DeviceMute(npMCI, FALSE);
        }
    }

    return 0;
}

/***************************************************************************
 *
 *  IsScreenDC() - returns true if the passed DC is a DC to the screen.
 *                 NOTE this checks for a DCOrg != 0, bitmaps always have
 *                 a origin of (0,0)  This will give the wrong info a
 *                 fullscreen DC.
 *
 ***************************************************************************/

#ifndef WIN32
#define IsScreenDC(hdc)     (GetDCOrg(hdc) != 0L)
#else
INLINE BOOL IsScreenDC(HDC hdc)
{
    POINT   pt;

    GetDCOrgEx(hdc, &pt);
    return pt.x != 0 && pt.y != 0;
}
#endif

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceUpdate | Updates the frame into the given DC
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data block.
 *
 * @parm HDC | hDC | DC to draw frame into.
 *
 * @parm LPRECT | lprc | Update rect.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceUpdate(NPMCIGRAPHIC npMCI, DWORD dwFlags, HDC hdc, LPRECT lprc)
{
    DWORD   dwErr = 0L;
    BOOL    f;
    HDC     hdcSave;
    TEMPORARYSTATE ts;
    HWND    hCallback;
    HCURSOR hcurPrev;
    RECT    rc;
    LONG    lFrameDrawn;

    if (!IsTask(npMCI->hTask)) {
        DPF0(("Returning DEVICE_NOT_READY from DeviceUpdate\n"));
        return MCIERR_DEVICE_NOT_READY;
    }

    if (npMCI->dwFlags & MCIAVI_UPDATING) {
        DPF(("DeviceUpdate has been reentered.\n"));
        Assert(0);
        return MCIERR_DEVICE_NOT_READY;
    }

    if (npMCI->dwFlags & MCIAVI_WANTMOVE)
	CheckWindowMove(npMCI, TRUE);

    //
    // see if we are the active movie now.
    //
    CheckIfActive(npMCI);

    /* Setting this flag insures that the background task doesn't
    ** yield while we're trying to update.
    */
    npMCI->dwFlags |= MCIAVI_UPDATING;

    //
    // mark the proper streams dirty, this will set the proper update flags
    //
    if (hdc)
        GetClipBox(hdc, &rc);
    else
        rc = npMCI->rcDest;

    if (lprc)
        IntersectRect(&rc, &rc, lprc);

    StreamInvalidate(npMCI, &rc);

    //
    // if they are drawing to the screen *assume* they wanted to set
    // the MCI_DGV_UPDATE_PAINT flag
    //
    if (IsScreenDC(hdc))
        dwFlags |= MCI_DGV_UPDATE_PAINT;

    //
    // if we are playing/seeking... (ie have a DC)
    // then realize the palette now. and set the update flag if we just need to
    // paint
    //
    // if we are paused, fall through so we can handle the case where
    // a update fails
    //
    // !!!mabey we should rework this code to do this even if playing?
    //
    if (npMCI->hdc &&
            (dwFlags & MCI_DGV_UPDATE_PAINT) &&
            (npMCI->wTaskState != TASKPAUSED) &&

            //!!! what is this?
            ((npMCI->wTaskState != TASKCUEING) ||
                (npMCI->lCurrentFrame <= 1) ||
                (npMCI->lCurrentFrame > npMCI->lRealStart - 30)) ) {

        Assert(npMCI->wTaskState == TASKPLAYING ||
               npMCI->wTaskState == TASKCUEING);

	UnprepareDC(npMCI);
        PrepareDC(npMCI);  // re-prepare

////////
//////// a update can fail when paused so we may have to stop/restart the task
////////
////////if (npMCI->wTaskState == TASKPAUSED)
////////    mmTaskSignal(npMCI->hTask);

        npMCI->dwFlags &= ~MCIAVI_UPDATING;
        return 0L;
    }

    //////////////////////////////////////////////////////////////////////
    //
    //  when we get here one of the follow applies
    //
    //      1.  we aren't playing/seeking/...
    //
    //      2.  we need to draw into a memory bitmap (not the screen)
    //
    //////////////////////////////////////////////////////////////////////

    //
    // are we updating to a memory bitmap?
    //
    if (!(dwFlags & MCI_DGV_UPDATE_PAINT))
        npMCI->dwFlags |= MCIAVI_UPDATETOMEMORY;

    //
    // if we are using a draw device (or are in easy mode) make sure we seek
    // to the frame we want and dont use the current decompress buffer that
    // may not be correct.
    //
    if ((npMCI->dwFlags & MCIAVI_UPDATETOMEMORY) ||
        (npMCI->dwFlags & MCIAVI_STUPIDMODE)) {
        DPF(("DeviceUpdate: decompress buffer may be bad, ignoring it....\n"));
	npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
    }

    //
    // honor the passed rect
    //
    if (lprc) {
        SaveDC(hdc);
        IntersectClipRect(hdc, lprc->left, lprc->top,
                               lprc->right, lprc->bottom);
    }

    //
    //  Always do an Update, if the update succeeds and we are at the right
    //  frame keep it.
    //
    //  if it fails or the frame is wrong re-draw
    //
    //  we need to do this because even though lFrameDrawn is a valid
    //  frame the draw handler may fail a update anyway (for example
    //  when decompressing to screen) so lFrameDrawn can be bogus and
    //  we do not know it until we try it.
    //

    lFrameDrawn = npMCI->lFrameDrawn;       // save this for compare

    if (npMCI->lFrameDrawn <= npMCI->lCurrentFrame &&
        npMCI->lFrameDrawn >= 0) {

        DPF2(("Update: redrawing frame %ld, current = %ld.\n", npMCI->lFrameDrawn, npMCI->lCurrentFrame));

	/* Save the DC, in case we're playing, but need to update
	** to a memory bitmap.
	*/
	hdcSave = npMCI->hdc;
        npMCI->hdc = hdc;

	/* Realize the palette here, because it will cause strange
        ** things to happen if we do it in the task.
        */
	if (npMCI->dwFlags & MCIAVI_NEEDDRAWBEGIN) {
	    DrawBegin(npMCI, NULL);

	    if (npMCI->lFrameDrawn < npMCI->lVideoStart) {
		npMCI->hdc = hdcSave;
		goto SlowUpdate;
	    }
	}

        PrepareDC(npMCI);        // make sure the palette is in there

	// worker thread must hold critsec round all drawing
        EnterCrit(npMCI);
        f = DoStreamUpdate(npMCI, FALSE);
	LeaveCrit(npMCI);

        UnprepareDC(npMCI);      // be sure to put things back....
        npMCI->hdc = hdcSave;

        if (!f) {
SlowUpdate:
            DPF(("DeviceUpdate failed! invalidating lFrameDrawn\n"));
            npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
        }
        else if (npMCI->lFrameDrawn >= npMCI->lCurrentFrame-1) {
            goto Exit;
        }
    }

    DPF(("Update: drawn = %ld, current = %ld.\n", npMCI->lFrameDrawn, npMCI->lCurrentFrame));

    //
    // stop everything.
    //
    StopTemporarily(npMCI, &ts);
    Assert(npMCI->hdc == NULL);
    Assert(npMCI->wTaskState == TASKIDLE);

    //
    // the problem this tries to fix is the following:
    // sometimes we are at N+1 but frame N is on the
    // screen, if we now play to N+1 a mismatch will occur
    //
    if (lFrameDrawn >= 0 && lFrameDrawn == npMCI->lCurrentFrame-1)
	npMCI->lFrom = npMCI->lTo = lFrameDrawn;
    else
	npMCI->lFrom = npMCI->lTo = npMCI->lCurrentFrame;

    /* Realize the palette here, because it will cause strange
    ** things to happen if we do it in the task.
    */
    npMCI->hdc = hdc;
    PrepareDC(npMCI);        // make sure the palette is in there

    hcurPrev =  SetCursor(LoadCursor(NULL, IDC_WAIT));

    /* Hide any notification, so it won't get sent... */
    hCallback = npMCI->hCallback;
    npMCI->hCallback = NULL;

    /* Wake the task up, and wait until it quiets down. */
    mciaviTaskMessage(npMCI, TASKSTARTING);
    mciaviTaskWait(npMCI, TASKIDLE, FALSE);
    dwErr = npMCI->dwTaskError;

    npMCI->hCallback = hCallback;

    // We may have just yielded.. so only set the cursor back if we
    // are still the wait cursor.
    if (hcurPrev) {
        hcurPrev = SetCursor(hcurPrev);
        if (hcurPrev != LoadCursor(NULL, IDC_WAIT))
            SetCursor(hcurPrev);
    }

    npMCI->hdc = NULL;

    if (dwErr == 0)
        dwErr = RestartAgain(npMCI,&ts);
Exit:
    if (lprc) {
        RestoreDC(hdc, -1);
    }

    npMCI->dwFlags &= ~(MCIAVI_UPDATING|MCIAVI_UPDATETOMEMORY);

    if (npMCI->dwFlags & MCIAVI_NEEDUPDATE) {
        DPF(("**** we did a DeviceUpdate but still dirty?\n"));
    }

    return dwErr;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceStatus | Returns the current status
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data block.
 *
 * @rdesc Returns value for MCI's return value
 *
 ***************************************************************************/

UINT PASCAL DeviceMode(NPMCIGRAPHIC npMCI)
{
    if (!IsTask(npMCI->hTask)) {
	return MCI_MODE_NOT_READY;
    }

    switch (npMCI->wTaskState) {
	case TASKIDLE:	
	    return MCI_MODE_STOP;
	
	case TASKCUEING:	
	    return MCI_MODE_SEEK;
	
	case TASKPLAYING:	
	    return MCI_MODE_PLAY;
	
	case TASKPAUSED:	
	    return MCI_MODE_PAUSE;
	
	case TASKBEINGCREATED:	
	case TASKINIT:	
	case TASKCLOSE:	
	case TASKSTARTING:	
	case TASKREADINDEX:	
	default:
            DPF(("Unexpected state %d in DeviceMode()\n", npMCI->wTaskState));
	    return MCI_MODE_NOT_READY;
    }
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DevicePosition | Returns the current frame
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data block.
 *
 * @parm LPLONG | lpl | returns current frame
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DevicePosition(NPMCIGRAPHIC npMCI, LPLONG lpl)
{
    LONG NEAR PASCAL WhatFrameIsItTimeFor(NPMCIGRAPHIC npMCI);
    LONG    l;

    l = npMCI->lCurrentFrame - npMCI->dwBufferedVideo;

#if 0
    if (npMCI->wTaskState == TASKPLAYING &&
			npMCI->wPlaybackAlg != MCIAVI_ALG_INTERLEAVED)
	l = WhatFrameIsItTimeFor(npMCI);
#endif

    if ((npMCI->wTaskState == TASKCUEING) &&
	    !(npMCI->dwFlags & MCIAVI_SEEKING) &&
	    l < npMCI->lRealStart)
	l = npMCI->lRealStart;

    if (l < 0)
	l = 0;

    *lpl = l;

    return 0L;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSetWindow | Set window for display
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm HWND | hwnd | Window to display into.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 * @comm Should this only take effect at time of next play?
 *
 ***************************************************************************/

DWORD PASCAL DeviceSetWindow(NPMCIGRAPHIC npMCI, HWND hwnd)
{
    DWORD	    dw = 0L;
    TEMPORARYSTATE  ts;

    /* Stop play before changing windows. */
    dw = StopTemporarily(npMCI, &ts);

    if (!dw) {
        npMCI->hwnd = hwnd;

        if (ts.wOldTaskState == TASKIDLE) {
#if 0
            DrawBegin(npMCI);
            DrawEnd(npMCI);
#else
	    npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
	    InvalidateRect(hwnd, &npMCI->rcDest, FALSE);
#endif
        }

	/* Should we update the window here? */

	/* Start playing again in the new window */
	dw = RestartAgain(npMCI, &ts);
    }

    return dw;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSpeed | Adjust the playback speed of an AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwNewSpeed | New speed, where 1000 is 'normal' speed.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 * @comm If we are currently playing, we stop the device, set our flag,
 *	and start playing again where we left off.  If we were paused,
 *	we end up stopped.  Is this bad?
 *
 ***************************************************************************/

DWORD PASCAL DeviceSetSpeed(NPMCIGRAPHIC npMCI, DWORD dwNewSpeed)
{
    DWORD	dw = 0L;
    TEMPORARYSTATE  ts;

    /* If new speed is the same as the old speed, return. */
    if (dwNewSpeed == npMCI->dwSpeedFactor)
	return 0L;

    // !!! What if we were cueing or paused?

    npMCI->dwSpeedFactor = dwNewSpeed;

    if (npMCI->wTaskState == TASKIDLE)
	return 0L;

    /* We're playing, so we have to adjust the playback rate in
    ** midstream.  If we don't have sound going, this is pretty
    ** easy.  If we do have sound, we either need to speed it up
    ** or slow it down or stop and start over.
    */

    // This code doesn't work, since there are internal variables that
    // need to be updated.  Therefore, just stop and restart, even if there
    // isn't any sound.
#if 0
    /* Figure out how fast we're playing.... */
    npMCI->dwPlayMicroSecPerFrame = muldiv32(npMCI->dwMicroSecPerFrame, 1000L,
						    npMCI->dwSpeedFactor);

    /* If there's no sound, we're done. */
    if ((npMCI->nAudioStreams == 0) ||
            !(npMCI->dwFlags & MCIAVI_PLAYAUDIO))
	return 0L;

    if (npMCI->hWave) {
	/* We could potentially try to do a waveOutSetPlaybackRate() here. */
    }
#endif

    dw = StopTemporarily(npMCI, &ts);

    if (!dw) {
	dw = RestartAgain(npMCI, &ts);
    }

    return dw;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceMute | Turn AVI sound on/off.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm BOOL | fMute | TRUE If sound should be turned off, FALSE
 *      if sound should stay on.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 * @comm If we are currently playing, we stop the device, set our flag,
 *	and start playing again where we left off.  If we were paused,
 *	we end up stopped.  Is this bad?
 *
 ***************************************************************************/

DWORD PASCAL DeviceMute(NPMCIGRAPHIC npMCI, BOOL fMute)
{
    DWORD	dw = 0L;
    TEMPORARYSTATE  ts;

    /* If there's no audio, just return. Should this be an error? */
    if (npMCI->nAudioStreams == 0)
        return 0L;

    /* If the mute state isn't changing, don't do anything. */
    if (npMCI->dwFlags & MCIAVI_PLAYAUDIO) {
	if (!fMute)
	    return 0L;
    } else {
	if (fMute)
	    return 0L;
    }

    /* Stop before changing mute */

    dw = StopTemporarily(npMCI, &ts);

    if (!dw) {

        if (fMute)
            npMCI->dwFlags &= ~MCIAVI_PLAYAUDIO;
        else
            npMCI->dwFlags |= MCIAVI_PLAYAUDIO;

	dw = RestartAgain(npMCI, &ts);
    }

    return dw;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSetVolume | Set AVI volume.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwVolume | ranges from 0 to 1000.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 * @comm If we are currently playing, we try to change the volume of the
 *	wave out device.
 *
 ***************************************************************************/

DWORD PASCAL DeviceSetVolume(NPMCIGRAPHIC npMCI, DWORD dwVolume)
{
    DWORD	dw = 0L;
    npMCI->dwVolume = dwVolume;

    npMCI->dwFlags |= MCIAVI_VOLUMESET;

    /* clear flag to emulate volume */;
    npMCI->fEmulatingVolume = FALSE;

    /* If there's no audio, just return. Should this be an error? */
    if (npMCI->nAudioStreams == 0)
	return 0L;

    dw = DeviceMute(npMCI, dwVolume == 0);

    if (npMCI->hWave && dw == 0L) {
	WORD	wLeft;
	WORD	wRight;

        if (LOWORD(dwVolume) >= 1000)
	    wLeft = 0xFFFF;
	else
            wLeft = (WORD) muldiv32(LOWORD(dwVolume), 32768L, 500L);

        if (HIWORD(dwVolume) >= 1000)
	    wRight = 0xFFFF;
	else
            wRight = (WORD) muldiv32(HIWORD(dwVolume), 32768L, 500L);

	// !!! Support left and right volume?
	dw = waveOutMessage(npMCI->hWave, WODM_SETVOLUME,
			    MAKELONG(wLeft, wRight), 0);

        if (dw != MMSYSERR_NOERROR && LOWORD(dwVolume) != 500) {
	    npMCI->fEmulatingVolume = TRUE;
	    BuildVolumeTable(npMCI);
	}

	dw = 0;
    }

    return dw;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceGetVolume | Check the wave output device's current
 *	volume.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 * @comm The volume is left in npMCI->dwVolume
 *
 * Issue: On devices with global volume control, like an SBPro, how should
 *	things work?
 *
 ***************************************************************************/
DWORD PASCAL DeviceGetVolume(NPMCIGRAPHIC npMCI)
{
    DWORD	dw;
    DWORD	dwVolume;

    if (npMCI->hWave) {
	// Get the current audio volume....
	dw = waveOutMessage(npMCI->hWave, WODM_GETVOLUME,
			    (DWORD) (DWORD FAR *)&dwVolume, 0);

	if (dw == 0) {
returnvolume:
            npMCI->dwVolume = MAKELONG((UINT)muldiv32(LOWORD(dwVolume), 500L, 32768L),
                                       (UINT)muldiv32(HIWORD(dwVolume), 500L, 32768L));
	}
    } else if (!(npMCI->dwFlags & MCIAVI_VOLUMESET)) {
	// We have no device open, and the user hasn't chosen a
	// volume yet.

        //
        // Try to find out what the current "default" volume is.
        //
        // I realy doubt zero is the current volume, try to work
        // with broken cards like the windows sound system.
        //
        dw = waveOutGetVolume((UINT)WAVE_MAPPER, &dwVolume);

        if (dw == 0 && dwVolume != 0)
	    goto returnvolume;

        dw = waveOutGetVolume(0, &dwVolume);

        if (dw == 0 && dwVolume != 0)
	    goto returnvolume;

	return MCIERR_NONAPPLICABLE_FUNCTION;
    }

    return 0;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSetAudioStream | Choose which audio stream to use.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm WORD | wStream | ranges from 1 to the number of streams.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceSetAudioStream(NPMCIGRAPHIC npMCI, UINT wAudioStream)
{
    DWORD	dw = 0L;
    TEMPORARYSTATE  ts;
    int		stream;

    /* If there's no audio, just return. Should this be an error? */

    if (npMCI->nAudioStreams == 0)
        return 0;

    for (stream = 0; stream < npMCI->streams; stream++) {
	if (SH(stream).fccType == streamtypeAUDIO) {
	    --wAudioStream;

	    if (wAudioStream == 0)
		break;
	}
    }

    if (stream == npMCI->nAudioStream)
	return 0;

    Assert(stream < npMCI->streams);

    /* Stop before changing mute */

    dw = StopTemporarily(npMCI, &ts);

    if (!dw) {
        npMCI->psiAudio = SI(stream);
	npMCI->nAudioStream = stream;
	
	dw = RestartAgain(npMCI, &ts);
    }

    return dw;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSetVideoStream | Choose which video stream is the
 *  "default".  Also can enable/disable a stream.  this works for both
 *  video and "other" streams.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm WORD | wStream | ranges from 1 to the number of streams.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceSetVideoStream(NPMCIGRAPHIC npMCI, UINT uStream, BOOL fOn)
{
    DWORD	dw = 0L;
    TEMPORARYSTATE  ts;
    int         stream;
    STREAMINFO *psi;

    //
    // find the Nth non-audio, non-error stream
    //
    for (stream = 0; stream < npMCI->streams; stream++) {

        psi = SI(stream);

        if (psi->sh.fccType == streamtypeAUDIO)
            continue;

        if (psi->dwFlags & STREAM_ERROR)
            continue;

        if (--uStream == 0)
            break;
    }

    if (stream == npMCI->streams)
        return MCIERR_OUTOFRANGE;

    /* Stop before changing */

    dw = StopTemporarily(npMCI, &ts);

    if (!dw) {

        if (fOn)
            psi->dwFlags |= STREAM_ENABLED;
        else
            psi->dwFlags &= ~STREAM_ENABLED;

        if (fOn && psi->sh.fccType == streamtypeVIDEO) {
            //!!! should we change the master timebase?
            DOUT("Setting main video stream\n");
#if 0
//
//  the master video stream is too special cased to change!
//
            npMCI->psiVideo = psi;
            npMCI->nVideoStream = stream;
#endif
        }

        if (!fOn && npMCI->nVideoStream == stream) {
            DOUT("Turning off main video stream\n");
            npMCI->dwFlags &= ~MCIAVI_SHOWVIDEO;
        }

        //
        //  now we turn MCIAVI_SHOWVIDEO off if no video/other streams
        //  are enabled.
        //
        npMCI->dwFlags &= ~MCIAVI_SHOWVIDEO;    // assume off.

        for (stream = 0; stream < npMCI->streams; stream++) {

            psi = SI(stream);

            if (psi->sh.fccType == streamtypeAUDIO)
                continue;

            if (psi->dwFlags & STREAM_ERROR)
                continue;

            if (!(psi->dwFlags & STREAM_ENABLED))
                continue;

            // at least one stream is enabled show "video"
            npMCI->dwFlags |= MCIAVI_SHOWVIDEO;
        }

        if (!(npMCI->dwFlags & MCIAVI_SHOWVIDEO))
            DOUT("All streams off\n");

	dw = RestartAgain(npMCI, &ts);
    }

    return dw;
}

/***************************************************************************
 *
 ***************************************************************************/

static void MapRect(RECT *prc, RECT*prcIn, RECT *prcFrom, RECT *prcTo)
{
    if (IsRectEmpty(prcFrom)) {
        SetRectEmpty(prc);
    }
    else {
        DPF0(("MapRect: In    [%d %d %d %d]\n", *prcIn));
        DPF0(("MapRect: From  [%d %d %d %d]\n", *prcFrom));
        DPF0(("MapRect: To    [%d %d %d %d]\n", *prcTo));
        prc->left  = prcTo->left + MulDiv(prcIn->left  - prcFrom->left, prcTo->right  - prcTo->left, prcFrom->right  - prcFrom->left);
        prc->top   = prcTo->top  + MulDiv(prcIn->top   - prcFrom->top,  prcTo->bottom - prcTo->top,  prcFrom->bottom - prcFrom->top);
        prc->right = prcTo->left + MulDiv(prcIn->right - prcFrom->left, prcTo->right  - prcTo->left, prcFrom->right  - prcFrom->left);
        prc->bottom= prcTo->top  + MulDiv(prcIn->bottom- prcFrom->top,  prcTo->bottom - prcTo->top,  prcFrom->bottom - prcFrom->top);
        DPF0(("MapRect: OUT   [%d %d %d %d]\n", *prc));
    }
}

/***************************************************************************
 *
 ***************************************************************************/

static void MapStreamRects(NPMCIGRAPHIC npMCI)
{
    int i;

    //
    //  now set the source and dest rects for each stream.
    //
    for (i=0; i<npMCI->streams; i++)
    {

        //
        // make sure the stream rect is in bounds
        //

	
        DPF0(("SH(%d) rcFrame  [%d %d %d %d]\n", i, SH(i).rcFrame));
        DPF0(("SI(%d) rcSource [%d %d %d %d]\n", i, SI(i)->rcSource));
        DPF0(("SI(%d) rcDest   [%d %d %d %d]\n", i, SI(i)->rcDest));
        DPF0(("np(%d) rcSource [%d %d %d %d]\n", i, npMCI->rcSource));
        DPF0(("np(%d) rcDest   [%d %d %d %d]\n", i, npMCI->rcDest  ));
        DPF0(("\n"));
        IntersectRect(&SI(i)->rcSource, &SH(i).rcFrame, &npMCI->rcSource);
        DPF0(("SI(%d) rcSource [%d %d %d %d]\n", i, SI(i)->rcSource));
        DPF0(("\n"));

        //
        // now map the stream source rect onto the destination
        //
        MapRect(&SI(i)->rcDest, &SI(i)->rcSource, &npMCI->rcSource, &npMCI->rcDest);
	
        DPF0(("SI(%d) rcSource [%d %d %d %d]\n", i, SI(i)->rcSource));
        DPF0(("SI(%d) rcDest   [%d %d %d %d]\n", i, SI(i)->rcDest));
        DPF0(("np(%d) rcSource [%d %d %d %d]\n", i, npMCI->rcSource));
        DPF0(("np(%d) rcDest   [%d %d %d %d]\n", i, npMCI->rcDest  ));
        DPF0(("\n"));

        //
        // make the stream source RECT (rcSource) relative to the
        // stream rect (rcFrame)
        //
        OffsetRect(&SI(i)->rcSource,-SH(i).rcFrame.left,-SH(i).rcFrame.top);
	
        DPF0(("SI(%d) rcSource [%d %d %d %d]\n", i, SI(i)->rcSource));
        DPF0(("SI(%d) rcDest   [%d %d %d %d]\n", i, SI(i)->rcDest));
        DPF0(("np(%d) rcSource [%d %d %d %d]\n", i, npMCI->rcSource));
        DPF0(("np(%d) rcDest   [%d %d %d %d]\n", i, npMCI->rcDest  ));
        DPF0(("\n"));
    }
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DevicePut | Change source or destination rectangle
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm LPRECT | lprc | Pointer to new rectangle to use.
 *
 * @parm DWORD | dwFlags | Flags: will be either MCI_DGV_PUT_DESTINATION
 *	or MCI_DGV_PUT_SOURCE.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 * @comm
 *	If we end up using a custom stretch buffer, it would go here.
 *
 ***************************************************************************/
DWORD FAR PASCAL DevicePut(NPMCIGRAPHIC npMCI, LPRECT lprc, DWORD dwFlags)
{
    RECT    rc;
    PRECT   prcPut;
    DWORD   dw = 0;

    if (dwFlags & MCI_DGV_PUT_DESTINATION) {
        DPF2(("DevicePut: destination [%d, %d, %d, %d]\n", *lprc));
        prcPut = &npMCI->rcDest;
    } else {
        DPF2(("DevicePut: source [%d, %d, %d, %d]\n", *lprc));
        prcPut = &npMCI->rcSource;

        //
        // make sure source rectangle is in range.
        //
        //  !!!should we return a error, or just fix the rectange???
        //
        rc = npMCI->rcMovie;
        IntersectRect(lprc, &rc, lprc);     // fix up the passed rect.
    }

    //
    // check for a bogus rect. either a NULL or inverted rect is considered
    // invalid.
    //
    // !!!NOTE we should handle a inverted rect (mirrored stretch)
    //
    if (lprc->left >= lprc->right ||
        lprc->top  >= lprc->bottom) {
        DPF2(("DevicePut: invalid rectangle [%d, %d, %d, %d]\n", *lprc));
        return MCIERR_OUTOFRANGE;
    }

    /* make sure the rect changed */
    if (EqualRect(prcPut,lprc))
        return 0L;

    InvalidateRect(npMCI->hwnd, &npMCI->rcDest, TRUE);
    rc = *prcPut;           /* save it */
    *prcPut = *lprc;        /* change it */
    InvalidateRect(npMCI->hwnd, &npMCI->rcDest, FALSE);

    /* has both the dest and source been set? */
    if (IsRectEmpty(&npMCI->rcDest) || IsRectEmpty(&npMCI->rcSource))
        return 0L;

    MapStreamRects(npMCI);
    StreamInvalidate(npMCI, NULL);      // invalidate the world

    if (npMCI->wTaskState <= TASKIDLE) {
	DPF2(("DevicePut: Idle, force DrawBegin on update\n"));
	npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
    }
    else {
	BOOL	fRestart;
	
        //
        //  we dont need to start/stop just begin again.
        //
	DPF2(("DevicePut: Calling DrawBegin()\n"));
	if (!DrawBegin(npMCI, &fRestart)) {
	    return npMCI->dwTaskError;
	}

        if (!DoStreamUpdate(npMCI, FALSE)) {
	    DPF(("Put: Failed update, forcing restart....\n"));
	    npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
	    fRestart = TRUE;
	}
	
	if (fRestart) {
            TEMPORARYSTATE  ts;

	    DPF2(("DevicePut: Stopping temporarily()\n"));

	    // !!! Set a flag here to prevent any more drawing
	    npMCI->fNoDrawing = TRUE;

            if (StopTemporarily(npMCI, &ts) != 0)
                return npMCI->dwTaskError;

	    // !!! We used to call InitDecompress here...
	    npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;

            RestartAgain(npMCI, &ts);

	    dw = npMCI->dwTaskError;
        }
    }

    return dw;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSetPalette | Changes the override palette.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm HPALETTE | hpal | New palette to use.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/
DWORD FAR PASCAL DeviceSetPalette(NPMCIGRAPHIC npMCI, HPALETTE hpal)
{
//
//  You might think it is a good idea to allow the app to change the
//  the palette while playing; think again. This will break
//  MagicSchoolBus, and cause us to get into a infinite palette fight.
//
#if 0
    DWORD dw = 0L;
    TEMPORARYSTATE  ts;

    dw = StopTemporarily(npMCI, &ts);

    // Remember this for later.
    npMCI->hpal = hpal;

    if (!dw) {
        npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
        dw = RestartAgain(npMCI, &ts);
    }

    return dw;
#else
    if (npMCI->hpal != hpal) {
        // Remember this for later.
        npMCI->hpal = hpal;
	// This won't happen until we restart the movie, so effectively, this
	// request for a palette change will be ignored for now.
        npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
        InvalidateRect(npMCI->hwnd, NULL, TRUE);
    }
    return 0;
#endif
}

#ifndef LOADACTUALLYWORKS
/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceLoad | Load a new AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwFlags | MCI flags from command.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceLoad(NPMCIGRAPHIC npMCI)
{
    DWORD   dw = 0L;

    if (!IsTask(npMCI->hTask))
	return MCIERR_DEVICE_NOT_READY;
	
    dw = DeviceStop(npMCI, MCI_WAIT);

    // Kill the current file and open a new file...

    mciaviTaskMessage(npMCI, TASKRELOAD);

    dw = npMCI->dwTaskError;

    return dw;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\drawproc.c ===
/****************************************************************************
 *
 *  DRAWPROC.C
 *
 *  Standard AVI drawing handler.
 *
 *      InstallAVIDrawHandler()
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <vfw.h>
#include "common.h"
#include "mciavi.h"

#define FOURCC_VIDS         mmioFOURCC('v','i','d','s')
#define FOURCC_AVIDraw      mmioFOURCC('D','R','A','W')
#define VERSION_AVIDraw     0x00010000      // 1.00

#ifdef DEBUG
    HDRAWDIB ghdd;
#endif

#ifndef HUGE
    #define HUGE _huge
#endif

/***************************************************************************
 ***************************************************************************/

typedef struct {
    HDRAWDIB		hdd;

    HDC                 hdc;            // HDC to draw to
			
    int                 xDst;           // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;
    int                 xSrc;           // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;
    BOOL                fBackground;

    BOOL                fRle;
    DWORD               biSizeImage;
    BOOL		fNeedUpdate;

    LONG                rate;           // playback rate (uSec / frame)
} INSTINFO, *PINSTINFO;

// static stuff in this file.
LONG FAR PASCAL _loadds ICAVIDrawProc(DWORD id, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2);

static LONG AVIDrawOpen(ICOPEN FAR * icopen);
static LONG AVIDrawClose(PINSTINFO pi);
static LONG AVIDrawGetInfo(ICINFO FAR *icinfo, LONG lSize);
static LONG AVIDrawQuery(PINSTINFO pi, LPBITMAPINFOHEADER lpbiIn);
static LONG AVIDrawSuggestFormat(PINSTINFO pi, ICDRAWSUGGEST FAR *lpicd, LONG cbicd);
static LONG AVIDrawBegin(PINSTINFO pi, ICDRAWBEGIN FAR *lpicd, LONG cbicd);
static LONG AVIDraw(PINSTINFO pi, ICDRAW FAR *lpicd, LONG cbicd);
static LONG AVIDrawEnd(PINSTINFO pi);
static LONG AVIDrawChangePalette(PINSTINFO pi, LPBITMAPINFOHEADER lpbi);

/***************************************************************************
 ***************************************************************************/

LONG FAR PASCAL _loadds ICAVIDrawProc(DWORD id, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2)
{
    INSTINFO *pi = (INSTINFO *)(UINT)id;

    switch (uiMessage)
    {
        case DRV_LOAD:
        case DRV_FREE:
            return 1;

        /*********************************************************************
            open
        *********************************************************************/

        case DRV_OPEN:
            if (lParam2 == 0L)
                return 1;

            return AVIDrawOpen((ICOPEN FAR *)lParam2);

	case DRV_CLOSE:
            return AVIDrawClose(pi);

        /*********************************************************************
            Configure/Info messages
        *********************************************************************/

        case DRV_QUERYCONFIGURE:    // configuration from drivers applet
            return 0;

        case DRV_CONFIGURE:
            return 1;

        case ICM_CONFIGURE:
        case ICM_ABOUT:
            return ICERR_UNSUPPORTED;

        /*********************************************************************
            state messages
        *********************************************************************/

        case ICM_GETSTATE:
        case ICM_SETSTATE:
            return 0L;

//      case ICM_GETINFO:
//          return AVIDrawGetInfo((ICINFO FAR *)lParam1, lParam2);

        /*********************************************************************
            decompress messages
        *********************************************************************/

        case ICM_DRAW_QUERY:
            return AVIDrawQuery(pi, (LPBITMAPINFOHEADER)lParam1);

	case ICM_DRAW_SUGGESTFORMAT:
	    return AVIDrawSuggestFormat(pi, (ICDRAWSUGGEST FAR *) lParam1, lParam2);

        case ICM_DRAW_BEGIN:
	    return AVIDrawBegin(pi, (ICDRAWBEGIN FAR *) lParam1, lParam2);

	case ICM_DRAW_REALIZE:
	    pi->hdc = (HDC) lParam1;
	
	    if (!pi->hdc || !pi->hdd)
		break;

	    pi->fBackground = (BOOL) lParam2;
	
	    return DrawDibRealize(pi->hdd, pi->hdc, pi->fBackground);

	case ICM_DRAW_GET_PALETTE:
	    if (!pi->hdd)
		break;

	    return (LONG) DrawDibGetPalette(pi->hdd);
	
        case ICM_DRAW:
            return AVIDraw(pi, (ICDRAW FAR *)lParam1, lParam2);

	case ICM_DRAW_CHANGEPALETTE:
	    return AVIDrawChangePalette(pi, (LPBITMAPINFOHEADER) lParam1);
	
        case ICM_DRAW_END:
            return AVIDrawEnd(pi);

        case ICM_DRAW_START:
            return DrawDibStart(pi->hdd, pi->rate);

        case ICM_DRAW_STOP:
            return DrawDibStop(pi->hdd);

        /*********************************************************************
            standard driver messages
        *********************************************************************/

        case DRV_DISABLE:
        case DRV_ENABLE:
            return 1;

        case DRV_INSTALL:
        case DRV_REMOVE:
            return 1;
    }

    return ICERR_UNSUPPORTED;
}

/*****************************************************************************
 *
 * AVIDrawOpen() is called from the DRV_OPEN message
 *
 ****************************************************************************/

static LONG AVIDrawOpen(ICOPEN FAR * icopen)
{
    INSTINFO *  pinst;

    if (icopen->dwFlags & ICMODE_COMPRESS)
        return 0;

    if (icopen->dwFlags & ICMODE_DECOMPRESS)
        return 0;

    pinst = (INSTINFO *)LocalAlloc(LPTR, sizeof(INSTINFO));

    if (!pinst)
    {
        icopen->dwError = ICERR_MEMORY;
        return 0;
    }

    DPF2(("*** AVIDrawOpen()\n"));

    //
    // init structure
    //
    pinst->hdd = DrawDibOpen();

#ifdef DEBUG
    ghdd = pinst->hdd;
#endif

    //
    // return success.
    //
    icopen->dwError = ICERR_OK;

    return (LONG) (UINT) pinst;
}

/*****************************************************************************
 *
 * Close() is called on the DRV_CLOSE message.
 *
 ****************************************************************************/
static LONG AVIDrawClose(PINSTINFO pi)
{
    DPF2(("*** AVIDrawClose()\n"));

    if (pi->hdd) {
	DrawDibClose(pi->hdd);
    }
    LocalFree((HLOCAL) pi);

    return 1;
}

#if 0
/*****************************************************************************
 *
 * AVIDrawGetInfo() implements the ICM_GETINFO message
 *
 ****************************************************************************/
static LONG AVIDrawGetInfo(ICINFO FAR *icinfo, LONG lSize)
{
    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (lSize < sizeof(ICINFO))
        return 0;

    icinfo->dwSize	    = sizeof(ICINFO);
    icinfo->fccType         = FOURCC_VIDS;
    icinfo->fccHandler      = FOURCC_AVIDraw;
    icinfo->dwFlags	    = VIDCF_DRAW;    // supports inter-frame
    icinfo->dwVersion       = VERSION_AVIDraw;
    icinfo->dwVersionICM    = ICVERSION;
    icinfo->szName[0]       = 0;
    icinfo->szDescription[0]= 0;

    return sizeof(ICINFO);
}
#endif

/*****************************************************************************
 *
 * AVIDrawQuery() implements ICM_DRAW_QUERY
 *
 ****************************************************************************/
static LONG AVIDrawQuery(PINSTINFO pi,
			 LPBITMAPINFOHEADER lpbiIn)
{
    //
    // determine if the input DIB data is in a format we like.
    //
    if (lpbiIn == NULL)
        return ICERR_BADFORMAT;

    //
    // determine if the input DIB data is in a format we like.
    //

    // !!! Do we need a DrawDibQuery or something here to let this handle
    // any compressed format?

#ifdef DRAWDIBNODECOMPRESS
    if (lpbiIn->biCompression != BI_RGB &&
#if 0
        !(lpbiIn->biBitCount == 8 && lpbiIn->biCompression == BI_RLE8))
#else
	1)
#endif
        return ICERR_BADFORMAT;
#endif

    return ICERR_OK;
}


static LONG AVIDrawSuggestFormat(PINSTINFO pi, ICDRAWSUGGEST FAR *lpicd, LONG cbicd)
{
    HIC hic;

    if (lpicd->lpbiSuggest == NULL)
	return sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD);

    hic = ICGetDisplayFormat(NULL, lpicd->lpbiIn, lpicd->lpbiSuggest,
			     0, lpicd->dxDst, lpicd->dyDst);

    if (hic)
	ICClose(hic);


    return sizeof(BITMAPINFOHEADER) + lpicd->lpbiSuggest->biClrUsed * sizeof(RGBQUAD);
}

/*****************************************************************************
 *
 * AVIDrawBegin() implements ICM_DRAW_BEGIN
 *
 ****************************************************************************/

static LONG AVIDrawBegin(PINSTINFO pi, ICDRAWBEGIN FAR *lpicd, LONG cbicd)
{
    LONG    l;
    UINT    wFlags;

    if (lpicd->dwFlags & ICDRAW_FULLSCREEN)
        return ICERR_UNSUPPORTED;

    l = AVIDrawQuery(pi, lpicd->lpbi);

    if ((l != 0) || (lpicd->dwFlags & ICDRAW_QUERY))
	return l;

    // Copy over whatever we want to remember
    pi->hdc = lpicd->hdc;
    pi->xDst = lpicd->xDst;
    pi->yDst = lpicd->yDst;
    pi->dxDst = lpicd->dxDst;
    pi->dyDst = lpicd->dyDst;
    pi->xSrc = lpicd->xSrc;
    pi->ySrc = lpicd->ySrc;
    pi->dxSrc = lpicd->dxSrc;
    pi->dySrc = lpicd->dySrc;
    pi->rate = muldiv32(lpicd->dwScale,1000000,lpicd->dwRate);

    // !!! Should this be done somewhere else? drawdib mabey!

    if (pi->hdc)
        SetStretchBltMode(pi->hdc, COLORONCOLOR);

    wFlags = 0;

    // !!! We need some way to have a "stupid" mode here....
    if (lpicd->dwFlags & ICDRAW_BUFFER)
        wFlags |= DDF_BUFFER;

    // Don't animate if we're realizing in the background
    if (lpicd->dwFlags & ICDRAW_ANIMATE && !(pi->fBackground))
        wFlags |= DDF_ANIMATE;

    //
    //  remember if this is RLE because we may need to hack it later.
    //
    pi->fRle = lpicd->lpbi->biCompression == BI_RLE8;
    pi->biSizeImage = (DWORD)(((UINT)lpicd->lpbi->biWidth+3)&~3)*(DWORD)(UINT)lpicd->lpbi->biHeight;

    DPF2(("*** AVIDrawBegin()\n"));

    if (lpicd->hpal == (HPALETTE)MCI_AVI_SETVIDEO_PALETTE_HALFTONE) {
        DrawDibSetPalette(pi->hdd, NULL);
        wFlags |= DDF_HALFTONE;
    }
    else
        DrawDibSetPalette(pi->hdd, lpicd->hpal);

    if (!DrawDibBegin(pi->hdd, pi->hdc,
		 pi->dxDst, pi->dyDst,
		 lpicd->lpbi,
		 pi->dxSrc, pi->dySrc,
		 wFlags))
	return ICERR_UNSUPPORTED;

    if (pi->hdc)
        DrawDibRealize(pi->hdd, pi->hdc, pi->fBackground);

    return ICERR_OK;
}


/*****************************************************************************
 *
 * AVIDraw() implements ICM_DRAW
 *
 ****************************************************************************/

static LONG AVIDraw(PINSTINFO pi, ICDRAW FAR *lpicd, LONG cbicd)
{
    UINT  wFlags;
    BOOL  f;

    wFlags = DDF_SAME_DRAW|DDF_SAME_HDC;  // !!! Right flags?

    if ((lpicd->lpData == NULL) || (lpicd->cbData == 0)) {

        if ((lpicd->dwFlags & ICDRAW_UPDATE) || pi->fNeedUpdate) {
            DrawDibRealize(pi->hdd, pi->hdc, pi->fBackground);
            wFlags |= DDF_UPDATE;
	    pi->fNeedUpdate = FALSE;
        }
	else
            return ICERR_OK;  // no data to draw.
    }
    else {
        if (lpicd->dwFlags & ICDRAW_PREROLL) {
            wFlags |= DDF_DONTDRAW;
	    pi->fNeedUpdate = TRUE;
	} else if (lpicd->dwFlags & ICDRAW_HURRYUP) {
            wFlags |= DDF_HURRYUP;
	    pi->fNeedUpdate = TRUE;
	} else
	    pi->fNeedUpdate = FALSE;

        if (lpicd->dwFlags & ICDRAW_NOTKEYFRAME)
            wFlags |= DDF_NOTKEYFRAME;

        //
        // if we get a update while playing and we are drawing RLE delta's
        // make sure we update.
        //
        if (pi->fRle && (lpicd->dwFlags & ICDRAW_UPDATE)) {
            DrawDibDraw(pi->hdd, pi->hdc, pi->xDst, pi->yDst,
                0,0,NULL,NULL,0,0,0,0,DDF_UPDATE|DDF_SAME_HDC|DDF_SAME_DRAW);
        }
    }

    //
    // We need a hack here for the RLE case, to make sure that
    // DIBs are marked correctly as BI_RLE8 or BI_RGB....
    //
    if (pi->fRle) {
        if (lpicd->cbData == pi->biSizeImage)
            ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression = BI_RGB;
        else
            ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression = BI_RLE8;
    }

    f = DrawDibDraw(pi->hdd, pi->hdc,
		pi->xDst, pi->yDst,
		pi->dxDst, pi->dyDst,
		lpicd->lpFormat,
                lpicd->lpData,
		pi->xSrc, pi->ySrc,
		pi->dxSrc, pi->dySrc,
                wFlags);

    if (pi->fRle)
        ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression = BI_RLE8;

    if (!f) {

	if (wFlags & DDF_UPDATE)
            DPF(("DrawDibUpdate failed\n"));
        else
            DPF(("DrawDibDraw failed\n"));

	if (wFlags & DDF_UPDATE)
	    return ICERR_CANTUPDATE;
	else
            return ICERR_ERROR;
    }

    return ICERR_OK;
}

static LONG AVIDrawChangePalette(PINSTINFO pi, LPBITMAPINFOHEADER lpbi)
{
    PALETTEENTRY    ape[256];
    LPRGBQUAD	    lprgb;
    int i;

    lprgb = (LPRGBQUAD) ((LPBYTE) lpbi + lpbi->biSize);

    for (i = 0; i < (int) lpbi->biClrUsed; i++) {
	ape[i].peRed = lprgb[i].rgbRed;
	ape[i].peGreen = lprgb[i].rgbGreen;
	ape[i].peBlue = lprgb[i].rgbBlue;
	ape[i].peFlags = 0;
    }
	
    DrawDibChangePalette(pi->hdd, 0, (int) lpbi->biClrUsed,
				 (LPPALETTEENTRY)ape);

    return ICERR_OK;
}

/*****************************************************************************
 *
 * AVIDrawEnd() implements ICM_DRAW_END
 *
 ****************************************************************************/

static LONG AVIDrawEnd(PINSTINFO pi)
{
    return ICERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\common.h ===
/* common.h
 *
 * Common functions useful for Windows programs.
 *
 * InitializeDebugOutput(szAppName):
 *
 *	Read debug level for this application (named <szAppName>) from
 *	win.ini's [debug] section, which should look like this:
 *
 *	   [debug]
 *	   location=aux			; use OutputDebugString() to output
 *	   foobar=2			; this app has debug level 2
 *	   blorg=0			; this app has debug output disabled
 *
 *	If you want debug output to go to a file instead of to the AUX
 *	device (or the debugger), use "location=>filename".  To append to
 *	the file instead of rewriting the file, use "location=>>filename".
 *
 *	If DEBUG is not #define'd, then the call to InitializeDebugOutput()
 *	generates no code,
 *
 * TerminateDebugOutput():
 *
 *	End debug output for this application.  If DEBUG is not #define'd,
 *	then the call to InitializeDebugOutput() generates no code.
 *
 * DPF((szFormat, args...))
 *
 *	If debugging output for this applicaton is enabled (see
 *	InitializeDebugOutput()), print debug output specified by format
 *	string <szFormat>, which may contain wsprintf()-style formatting
 *	codes corresponding to arguments <args>.  Example:
 *
 *		DPF(("in WriteFile(): szFile='%s', dwFlags=0x%08lx\n",
 *	     	(LSPTR) szFile, dwFlags));
 *
 * DPF2((szFormat, args...))
 * DPF3((szFormat, args...))
 * DPF4((szFormat, args...))
 *
 *	Like DPF, but only output the debug string if the debug level for
 *	this application is at least 2, 3, or 4, respectively.
 *
 * Assert(fExpr)
 *
 *	If DEBUG is #define'd, then generate an "assertion failed" message box
 *	allowing the user to abort the program, enter the debugger (the "Retry"
 *	button), or ignore the error.  If DEBUG is not #define'd then Assert()
 *	generates no code.
 *
 * AssertEval(fExpr)
 *
 *	Like Assert(), but evaluate and return <fExpr>, even if DEBUG
 *	is not #define'd.  (Use if you want the BOOL expression to be
 *	evaluated even in a retail build.)
 */

#ifdef DEBUG
	/* Assert() macros */
	#undef Assert
	#undef AssertSz
	#undef AssertEval
        #define AssertSz(x,sz)           ((x) ? (void)0 : (void)_Assert(sz, __FILE__, __LINE__))
        #define Assert(expr)             AssertSz(expr, #expr)
        #define AssertEval(expr)         Assert(expr)

	/* debug printf macros */
	#define DPF( _x_ )	if (giDebugLevel >= 1) _DebugPrintf _x_
        #define DPF0( _x_ )                            _DebugPrintf _x_
	#define DPF1( _x_ )	if (giDebugLevel >= 1) _DebugPrintf _x_
	#define DPF2( _x_ )	if (giDebugLevel >= 2) _DebugPrintf _x_
	#define DPF3( _x_ )	if (giDebugLevel >= 3) _DebugPrintf _x_
        #define DPF4( _x_ )     if (giDebugLevel >= 4) _DebugPrintf _x_

        #define DOUT( _x_ )      if (giDebugLevel >= 1) {static char _based(_segname("_CODE")) smag[] = _x_; _DebugPrintf(smag); }
        #define DOUT0( _x_ )                            {static char _based(_segname("_CODE")) smag[] = _x_; _DebugPrintf(smag); }
        #define DOUT1( _x_ )     if (giDebugLevel >= 1) {static char _based(_segname("_CODE")) smag[] = _x_; _DebugPrintf(smag); }
        #define DOUT2( _x_ )     if (giDebugLevel >= 2) {static char _based(_segname("_CODE")) smag[] = _x_; _DebugPrintf(smag); }
        #define DOUT3( _x_ )     if (giDebugLevel >= 3) {static char _based(_segname("_CODE")) smag[] = _x_; _DebugPrintf(smag); }
        #define DOUT4( _x_ )     if (giDebugLevel >= 4) {static char _based(_segname("_CODE")) smag[] = _x_; _DebugPrintf(smag); }

	/* prototypes */
	void FAR PASCAL InitializeDebugOutput(LPSTR szAppName);
	void FAR PASCAL TerminateDebugOutput(void);
        void FAR PASCAL _Assert(char *szExp, char *szFile, int iLine);
        void FAR CDECL _DebugPrintf(LPSTR szFormat, ...);
        extern int	giDebugLevel;	// current debug level

#else
	/* Assert() macros */
        #define AssertSz(expr,x)         ((void)0)
        #define Assert(expr)             ((void)0)
	#define AssertEval(expr)	 (expr)

	/* debug printf macros */
	#define DPF( x )
	#define DPF0( x )
	#define DPF1( x )
	#define DPF2( x )
	#define DPF3( x )
        #define DPF4( x )

        #define DOUT( x )
        #define DOUT0( x )
        #define DOUT1( x )
        #define DOUT2( x )
        #define DOUT3( x )
        #define DOUT4( x )

	/* stubs for debugging function prototypes */
	#define InitializeDebugOutput(szAppName)	0
	#define TerminateDebugOutput()			0
#endif


/* flags for _llseek() */
#ifndef SEEK_SET
	#define SEEK_SET	0	// seek relative to start of file
	#define SEEK_CUR	1	// seek relative to current position
	#define SEEK_END	2	// seek relative to end of file
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\graphic.h ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   graphic.h - Multimedia Systems Media Control Interface
            driver for AVI.

*****************************************************************************/

#define NOSHELLDEBUG
#include <windows.h>
#include <windowsx.h>
#define MCI_USE_OFFEXT
#include <mmsystem.h>
#include <win32.h> 	// This must be included, for both versions
#include <mmddk.h>
#ifndef RC_INVOKED
#include "ntaviprt.h"
#include "common.h"
#include "aviffmt.h"
#include <drawdib.h>
#include <compman.h>
#include "avifilex.h"   // include AVIFile stuff.
#include "digitalv.h"
#endif
#include "mciavi.h"

// Define this to make the code expire on a given date....
// #define EXPIRE (1994 * 65536 + 1 * 256 + 1)        // expire 1/1/1994

#ifndef DRIVE_CDROM
    #define DRIVE_CDROM 5
#endif

#define DRIVE_INTERFACE     42

#ifdef EXPIRE
#define MCIERR_AVI_EXPIRED		9999
#endif

#define MCIAVI_PRODUCTNAME       2
#define MCIAVI_VERSION           3
#define MCIAVI_BADMSVIDEOVERSION 4

#define MCIAVI_MENU_CONFIG       5
#define MCIAVI_MENU_STRETCH      6
#define MCIAVI_MENU_MUTE         7

#define MCIAVI_CANT_DRAW_VIDEO   8
#define MCIAVI_CANT_DRAW_STREAM  9

#define INFO_VIDEOFORMAT         10
#define INFO_MONOFORMAT          11
#define INFO_STEREOFORMAT        12
#define INFO_LENGTH              13
#define INFO_FILE                14
#define INFO_KEYFRAMES           15
#define INFO_AUDIO               16
#define INFO_SKIP                17
#define INFO_ADPCM               18
#define INFO_DATARATE            19
#define INFO_SKIPAUDIO           20
#define INFO_FILETYPE            21
#define INFO_FILETYPE_AVI        22
#define INFO_FILETYPE_INT        23
#define INFO_FILETYPE_ALPHA      24
#define INFO_FRAMERATE           25
#define INFO_STREAM              26
#define INFO_DISABLED            27
#define INFO_ALLKEYFRAMES        28
#define INFO_NOKEYFRAMES         29
#define INFO_COMPRESSED          30
#define INFO_NOTREAD		 31

#define MCIAVI_MAXSIGNALS	1
#define MCIAVI_MAXWINDOWS	8

/* Flags for dwFlags in MCIGRAPHIC */
#define MCIAVI_STOP		0x00000001L	/* We need to stop	*/
#define MCIAVI_PAUSE		0x00000002L	/* We need to be paused	*/
#define MCIAVI_CUEING		0x00000004L	/* We are in a cue command */
#define MCIAVI_WAITING          0x00000008L     /* We are waiting for a command to finish */
#define MCIAVI_PLAYAUDIO	0x00000010L	/* Audio enabled	*/
#define MCIAVI_LOSTAUDIO        0x00000020L     /* cant get audio device*/
#define MCIAVI_SHOWVIDEO        0x00000040L     /* Video enabled        */
#define MCIAVI_USING_AVIFILE    0x00000080L     /* RTL to AVIFile */
#define MCIAVI_USINGDISPDIB	0x00000100L	/* Now in MCGA mode	*/
#define MCIAVI_NEEDTOSHOW	0x00000200L	/* window needs to be shown */
#define MCIAVI_WANTMOVE         0x00000400L     /* call CheckWindowMove alot */
#define MCIAVI_ANIMATEPALETTE   0x00000800L     /* Palette animated */
#define MCIAVI_NEEDUPDATE       0x00001000L     /* Need to redraw full  */
#define MCIAVI_PALCHANGED       0x00002000L     /* Need to update palette */
#define MCIAVI_STUPIDMODE       0x00004000L     /* dont buffer mode  */
#define MCIAVI_CANDRAW          0x00008000L     /* display driver can draw format */
#define MCIAVI_FULLSCREEN       0x00010000L     /* draw fullscreen. */
#define MCIAVI_NEEDDRAWBEGIN    0x00020000L     /* compressor is drawing */
#define MCIAVI_UPDATETOMEMORY   0x00040000L     /* drawing to a bitmap */
#define MCIAVI_WAVEPAUSED       0x00080000L     /* waveOut is temporarily paused */
#define MCIAVI_NOTINTERLEAVED   0x00100000L     /* file is not interleaved. */
#define MCIAVI_USERDRAWPROC     0x00200000L     /* user has set draw proc*/
#define MCIAVI_Y                0x00400000L     /* */
#define MCIAVI_VOLUMESET	0x00800000L	/* Volume has been changed. */
#define	MCIAVI_HASINDEX		0x01000000L	/* File has index.	*/
#define MCIAVI_RELEASEDC        0x02000000L     /* we got the DC via GetDC */
#define MCIAVI_SEEKING		0x04000000L	/* audio disabled for seek. */
#define MCIAVI_UPDATING		0x08000000L	/* handling WM_PAINT-don't yield. */
#define MCIAVI_REPEATING	0x10000000L	/* repeat when play finishes. */
#define MCIAVI_REVERSE		0x20000000L	/* playing backwards.... */
#define MCIAVI_NOBREAK		0x40000000L	/* don't allow break out of DISPDIB */
#define MCIAVI_ZOOMBY2          0x80000000L    /* fullscreen zoomed by 2 */

/* Flags for dwOptionFlags */
#define MCIAVIO_SEEKEXACT	0x00000001L	/* If off, seek goes to
						** previous key frame
						** instead of real
						** target frame.	*/
#define MCIAVIO_SKIPFRAMES	0x00000002L	/* Skip frames to keep
						** synchronized.	*/
#define MCIAVIO_STRETCHTOWINDOW	0x00000004L	/* Resize destination
						** rectangle if window
						** resized.		*/

#define MCIAVIO_STUPIDMODE	0x00000020L	/* Don't do nice updating. */

#define MCIAVIO_ZOOMBY2		0x00000100L
#define MCIAVIO_USEVGABYDEFAULT	0x00000200L
#define MCIAVIO_USEAVIFILE      0x00000400L

#define MCIAVI_ALG_INTERLEAVED	0x0001
#define MCIAVI_ALG_CDROM	0x0002
#define MCIAVI_ALG_HARDDISK	0x0003
#define MCIAVI_ALG_AUDIOONLY	0x0004
#define MCIAVI_ALG_AVIFILE      0x0005

//
//  the frame index is indexed by frame number, it is used for
//  varible sizeed, fixed rate streams.
//
typedef struct
{
    WORD                iPrevKey;           // prev "key" frame
    WORD                iNextKey;           // next "key" frame
    WORD                iPalette;           // palette frame (this points into index!)
    UINT                wSmag;              //
    DWORD               dwOffset;           // Position of chunk (file offset)
    DWORD               dwLength;           // Length of chunk (in bytes)
} AVIFRAMEINDEX;

#define NOBASED32

#if defined(WIN32) || defined(NOBASED32)
    #define BASED32(p)      _huge
    #define P32(t,p)        ((t _huge *)(p))
    #define B32(t,p)        ((t _huge *)(p))
#else
    #define BASED32(p)      _based32((_segment)SELECTOROF(p))
    #define P32(t,p)        ((t BASED32(p) *)OFFSETOF(p))
    #define B32(t,p)        ((t BASED32(p) *)0)
#endif

#define Frame(n)        (P32(AVIFRAMEINDEX,npMCI->hpFrameIndex) + (DWORD)(n))
#define FrameNextKey(n) (LONG)((n) + (DWORD)Frame(n)->iNextKey)
#define FramePrevKey(n) (LONG)((n) - (DWORD)Frame(n)->iPrevKey)
#define FramePalette(n) (LONG)(Frame(n)->iPalette)
#define FrameOffset(n)  (DWORD)(Frame(n)->dwOffset)
#define FrameLength(n)  (DWORD)(Frame(n)->dwLength)

#define UseIndex(p)     SillyGlobal = (p)
#define Index(n)        (B32(AVIINDEXENTRY,npMCI->hpIndex) + (long)(n))
#define IndexOffset(n)  Index(n)->dwChunkOffset
#define IndexLength(n)  Index(n)->dwChunkLength
#define IndexFlags(n)   Index(n)->dwFlags
#define IndexID(n)      Index(n)->ckid

typedef struct {
    DWORD               dwFlags;        /* flags, STREAM_ENABLED... */
    AVIStreamHeader     sh;             /* AVIStreamHeader...*/

    DWORD               cbFormat;       /* Stream format...*/
    LPVOID		lpFormat;

    DWORD               cbData;         /* Extra stream data...*/
    LPVOID		lpData;

    HIC                 hicDraw;        /* Draw codec...*/

    RECT                rcSource;       /* rectangles...*/
    RECT                rcDest;

    LONG                lStart;         /* start */
    LONG                lEnd;           /* end */

    LONG                lPlayStart;     /* play start */
    LONG                lPlayFrom;      /* play from */
    LONG                lPlayTo;        /* play to */

    LONG                lFrameDrawn;    /* we drew this */
    LONG                lPos;           /* current pos */
    LONG                lNext;          /* next pos */
    LONG                lLastKey;       /* key frame */
    LONG                lNextKey;       /* next key frame */

#ifdef USEAVIFILE
    PAVISTREAM          ps;
////IAVIStreamVtbl      vt;     // so we can call direct.
#endif
} STREAMINFO;

#define STREAM_ENABLED      0x0001  // stream is enabled for play
#define STREAM_ACTIVE       0x0002  // stream is active for *current* play
#define STREAM_NEEDUPDATE   0x0004  // stream needs update (paint)
#define STREAM_ERROR        0x0008  // stream did not load
#define STREAM_DIRTY        0x0010  // stream not showing current frame.

#define STREAM_SKIP         0x0100  // can skip data
#define STREAM_PALCHANGES   0x0200  // stream has palette changes
#define STREAM_VIDEO        0x0400  // is a video stream
#define STREAM_AUDIO        0x0800  // is a audio stream
#define STREAM_PALCHANGED   0x1000  // palette has changed
#define STREAM_WANTIDLE     0x2000  // should get idle time
#define STREAM_WANTMOVE     0x4000  // should get ICM_DRAW_WINDOW message

#define SI(stream)	(npMCI->paStreamInfo + stream)
#define SH(stream)	(SI(stream)->sh)

#define SOURCE(stream)  (SI(stream)->rcSource)
#define DEST(stream)    (SI(stream)->rcDest)
#define FRAME(stream)   (SH(stream).rcFrame)

#define FORMAT(stream) (SI(stream)->lpFormat)
#define VIDFMT(stream) ((LPBITMAPINFOHEADER) FORMAT(stream))
#define AUDFMT(stream) ((LPPCMWAVEFORMAT) FORMAT(stream))

//
// map from "movie" time into stream time.
//
#define TimeToMovie(t)         muldiv32(t, npMCI->dwRate, npMCI->dwScale*1000)
#define MovieToTime(l)         muldiv32(l, npMCI->dwScale*1000, npMCI->dwRate)
#define TimeToStream(psi, t)   muldiv32(t, psi->sh.dwRate,       psi->sh.dwScale*1000)
#define StreamToTime(psi, l)   muldiv32(l, psi->sh.dwScale*1000, psi->sh.dwRate)

//
//  NOTE all dwScale's are equal so we can do this without as many
//  multiplies
//
#if 0
#define MovieToStream(psi, l)  muldiv32(l, npMCI->dwScale * psi->sh.dwRate, npMCI->dwRate * psi->sh.dwScale)
#define StreamToMovie(psi, l)  muldiv32(l, npMCI->dwScale * psi->sh.dwRate, npMCI->dwRate * psi->sh.dwScale)
#else
#define MovieToStream(psi, l)  muldiv32(l, psi->sh.dwRate, npMCI->dwRate)
#define StreamToMovie(psi, l)  muldiv32(l, psi->sh.dwRate, npMCI->dwRate)
#endif

/*
 * RECT macros to get X,Y,Width,Height
 */
#define RCX(rc)     ((rc).left)
#define RCY(rc)     ((rc).top)
#define RCW(rc)     ((rc).right - (rc).left)
#define RCH(rc)     ((rc).bottom - (rc).top)

/*
 * The major control block for an AVI device
 * Define markers to more easily identify the control block when dumping
 */
#define MCIID      (DWORD)(((WORD)('V' | ('F'<<8))) | ((WORD)('W' | ('>'<<8))<<16))
#define MCIIDX     (DWORD)(((WORD)('v' | ('.'<<8))) | ((WORD)('w' | ('-'<<8))<<16))

typedef struct _MCIGRAPHIC {

    struct _MCIGRAPHIC *npMCINext;

#ifdef DEBUG
    DWORD        mciid;          // visible identifier
#endif

/*
 * multiple-thread synchronization.  We hold a critical section per device
 */
#ifdef WIN32
    CRITICAL_SECTION CritSec;       // per-device lock
    LONG lCritRefCount;          // entry count - see ntaviprt.h
#endif

/*
** Basic MCI information
*/
    HWND	hCallback;      /* callback window handle */
    UINT	wDevID;         /* device ID */

/*
** Internal task operation status and flags
*/
#ifndef WIN32
    UINT        pspTask;        /* background task's PSP */
    UINT        pspParent;      /* PSP of the calling app */
#endif
    HTASK	hTask;		/* task id */
    HTASK	hCallingTask;	/* task who opened us */
    UINT	uErrorMode;	/* SetErrorMode value for calling task */
    DWORD	dwTaskError;	/* error return from task */
    UINT	wMessageCurrent;/* Command in progress, or zero */
    UINT	wTaskState;	/* current task state */
    DWORD	dwFlags;	/* flags */
    DWORD	dwOptionFlags;	/* more flags */

/*
** Additional information controlled by MCI commands
*/
    HPALETTE    hpal;           /* Palette forced with MCI commands */
    HWND        hwnd;           /* window handle for playback */
    HWND	hwndDefault;	/* default window handle */
    HWND        hwndOldFocus;   /* window which had keyboard focus */
    BOOL        fForceBackground;/* Select palette in foreground or back? */
    DWORD       dwTimeFormat;   /* current time format */
    RECT        rcMovie;        /* main movie rect */
    RECT	rcSource;	/* drawing source rect */
    RECT	rcDest; 	/* drawing destination rect */
    LONG        PlaybackRate;   /* 1000 is normal, more is fast.... */
    DWORD	dwSpeedFactor;  /* 1000 is normal, more is fast.... */


/*
** Information about currently open file
*/
    UINT        uDriveType;     /* drive type */
    NPTSTR	szFilename;     /* AVI filename */
    LONG	lFrames;        /* number of frames in movie */
    DWORD	dwBytesPerSec;	/* file attributes */
    DWORD       dwRate;         /* master time base */
    DWORD       dwScale;
    DWORD	dwMicroSecPerFrame;	
    DWORD	dwSuggestedBufferSize;
    DWORD	dwKeyFrameInfo;	/* how often key frames occur */
    UINT	wEarlyAudio;	/* more file information */
    UINT	wEarlyVideo;
    UINT	wEarlyRecords;

    STREAMINFO NEAR *paStreamInfo;
    int         streams;        // total streams
    int         nAudioStreams;  // total audio streams
    int         nVideoStreams;  // total video streams
    int         nOtherStreams;  // total other streams
    int         nErrorStreams;  // total error streams

    int         nAudioStream;   // current audio stream.
    int         nVideoStream;   // "master" video stream

    STREAMINFO *psiAudio;       // points to video stream
    STREAMINFO *psiVideo;       // points to audio stream

#ifdef USEAVIFILE
    PAVIFILE        pf;
////IAVIFileVtbl    vt;    // so we can call direct.
#else
    LPVOID          pf;     // Stupid variable to be zero.
#endif

/*
** video stream junk
*/
    BOOL        fNoDrawing;
    LONG        lFrameDrawn;    /* number of last frame drawn */

    /* Drawing information */
    HDC		hdc;		/* DC we're playing into */

    /* Video format */
    BITMAPINFOHEADER	FAR *pbiFormat;       /* video format information */

    /* BitmapInfo used for drawing */
    BITMAPINFOHEADER    bih;         /* video format information */
    RGBQUAD             argb[256];   /* current drawing colors */
    RGBQUAD             argbOriginal[256]; /* original colors */

/*
** Installable compressor information
*/
    //!!! move all this into the screen draw function!!!
    //!!! all this should be in DrawDIB !!!
    HIC         hic;
    HIC         hicDraw;

    LONG        cbDecompress;
    HPSTR       hpDecompress;   /* pointer to full frame buffer */

/*
** Holding area for compressors we might use....
*/
    HIC         hicDecompress;
    HIC         hicDrawDefault;
    HIC         hicDrawFull;
    HIC		hicInternal;
    HIC         hicInternalFull;

    LONG        lLastPaletteChange;
    LONG        lNextPaletteChange;

/*
** wave stream junk
*/
    /* Wave format stuff */
    NPWAVEFORMAT pWF;           /* current wave format */
    UINT	wABs;		/* number of audio buffers */
    UINT	wABOptimal;	/* number full if synchronized */
    DWORD	dwABSize;	/* size of one audio buffer */

    HMMIO	hmmioAudio;

    DWORD       dwVolume;        /* Audio volume, 1000 is full on */
    BOOL	fEmulatingVolume;/* Are we doing volume by table lookup? */
    BYTE *      pVolumeTable;

    DWORD	dwAudioLength;
    DWORD	dwAudioPos;

    /* Wave Output Device */
    HWAVEOUT	hWave;		/* wave device handle */
    UINT	wABFull;	/* number now full */
    UINT	wNextAB;	/* next buffer in line */
    UINT        nAudioBehind;   /* how many audio below full */
    HPSTR	lpAudio;	/* pointer to audio buffers */
    DWORD       dwUsedThisAB;

/*
** File index information
*/
    AVIINDEXENTRY _huge *  hpIndex;        /* pointer to index */
    DWORD                   macIndex;       /* # records in index */

    AVIFRAMEINDEX _huge *  hpFrameIndex;   /* pointer to frame index */

/*
** play/seek params
*/
    LONG	lTo;            /* frame we're playing to */
    LONG	lFrom;		/* frame we're playing from */
    LONG        lCurrentFrame;  /* current frame */
    LONG        lRepeatFrom;    /* Frame to repeat from */

/*
** Information regarding current play
*/
    UINT        wPlaybackAlg;   /* playback algorithm in use */

    LONG	lRealStart;	/* frame playback starts */
    LONG	lAudioStart;	/* first audio frame to play */
    LONG	lVideoStart;	/* first video frame to play */

    LONG	lLastRead;

    /* Timing */
    DWORD	dwMSecPlayStart;/* Start time */
    LONG	lFramePlayStart;/* Frame playing started at */

    DWORD	dwTotalMSec;	/* Total time spent playing */

    DWORD	dwTimingStart;
    DWORD	dwPauseTime;
    DWORD	dwPlayMicroSecPerFrame;
    DWORD	dwAudioPlayed;

/*
** Timing information
*/
    DWORD	dwLastDrawTime; /* How long did the last draw take? */
    DWORD       dwLastReadTime;

    /* Timing information kept after play completes */
    DWORD	dwSkippedFrames;    /* Frames skipped during current play */
    DWORD	dwFramesSeekedPast; /* Frames not even read */
    DWORD	dwAudioBreaks;  /* # times audio broke up, approx. */
    DWORD       dwSpeedPercentage;  /* Ratio of ideal time to time taken */

    /* Timing information for last play */
    LONG        lFramesPlayed;
    LONG        lSkippedFrames;     /* Frames skipped during last play */
    LONG        lFramesSeekedPast;  /* Frames not even read */
    LONG        lAudioBreaks;       /* # times audio broke up, approx. */

/*
** Information for pending 'signal' command
*/
    DWORD	dwSignals;
    DWORD	dwSignalFlags;
    MCI_DGV_SIGNAL_PARMS signal;

/*
** Information for watching to see if window has moved.
*/
    UINT        wRgnType;       /* Region type, empty, simple, complex.... */
#ifdef WIN32
    POINT       dwOrg;          /* Physical DC origin */
#else
    DWORD       dwOrg;          /* Physical DC origin */
#endif
    RECT        rcClip;         /* clip box */
    HANDLE      hThreadTermination; /* Handle to wait on for thread to
                                       terminate so it's safe to unload DLL
                                       Must be closed by us                */

/*
** Information for hardware drawing devices....
*/
    DWORD       dwBufferedVideo;

/*
** specific to RIFF files
*/
    HMMIO       hmmio;          /* animation file handle */

    BOOL        fReadMany;      /* read more than one record */

    DWORD       dwFirstRecordPosition;
    DWORD       dwFirstRecordSize;
    DWORD       dwFirstRecordType;

    DWORD       dwNextRecordSize;       // used for ReadNextChunk
    DWORD       dwNextRecordType;

    DWORD       dwMovieListOffset;
    DWORD       dwBigListEnd;

    /* Read Buffer */
    HPSTR	lp;		/* work pointer */
    LPVOID      lpMMIOBuffer;   /* pointer to MMIO read buffer */
    HPSTR	lpBuffer;	/* pointer to read buffer */
    DWORD	dwBufferSize;	/* Read buffer size */
    DWORD	dwThisRecordSize; /* size of current record */

/*
** DEBUG stuff and more timing info.
*/

#ifdef DEBUG
    HANDLE      hdd;    //!!!

    LONG        timePlay;       /* total play time */
    LONG        timePrepare;    /* time to prepare for play */
    LONG        timeCleanup;    /* time to clean up play */
    LONG        timePaused;     /* paused time */
    LONG        timeRead;       /* time reading from disk */
    LONG        timeWait;       /* time waiting */
    LONG        timeYield;      /* time yielding to other apps */
    LONG        timeVideo;      /* time "drawing" video stream */
    LONG        timeAudio;      /* time "drawing" audio stream */
    LONG        timeOther;      /* time "drawing" other streams */
    LONG        timeDraw;       /* time drawing frame via DrawDib/DispDib/ICDraw */
    LONG        timeDecompress; /* time decompressing frame via ICDecompress */
#endif

#ifdef AVIREAD
    /*
     * handle to current async read object
     */
    HAVIRD	hAviRd;
    HPSTR	lpOldBuffer;
#endif

} MCIGRAPHIC, *NPMCIGRAPHIC, FAR *LPMCIGRAPHIC;

extern HANDLE ghModule;             // in DRVPROC.C
extern TCHAR  szClassName[];        // in WINDOW.C

/*
** Flags to protect ourselves in case we're closed with a dialog up...
*/
extern BOOL   gfEvil;               // in GRAPHIC.C
extern BOOL   gfEvilSysMenu;        // in GRAPHIC.C
extern HDRVR  ghdrvEvil;            // in GRAPHIC.C

/*
** Functions in GRAPHIC.C
*/
BOOL FAR PASCAL  GraphicInit (void);
BOOL NEAR PASCAL  GraphicWindowInit (void);

#ifdef WIN32
BOOL NEAR PASCAL GraphicWindowFree(void);
#endif

void  PASCAL  GraphicFree (void);
DWORD PASCAL  GraphicDrvOpen (LPMCI_OPEN_DRIVER_PARMS lpParms);
void  FAR PASCAL  GraphicDelayedNotify (NPMCIGRAPHIC npMCI, UINT wStatus);
void FAR PASCAL GraphicImmediateNotify (UINT wDevID,
    LPMCI_GENERIC_PARMS lpParms,
    DWORD dwFlags, DWORD dwErr);
DWORD PASCAL  GraphicClose(NPMCIGRAPHIC npMCI);
DWORD NEAR PASCAL ConvertFromFrames(NPMCIGRAPHIC npMCI, LONG lFrame);
LONG NEAR PASCAL ConvertToFrames(NPMCIGRAPHIC npMCI, DWORD dwTime);

DWORD PASCAL mciDriverEntry(UINT wDeviceID, UINT wMessage, DWORD dwFlags, LPMCI_GENERIC_PARMS lpParms);

long FAR PASCAL _loadds GraphicWndProc(HWND, UINT, WPARAM, LPARAM);

void  CheckWindowMove(NPMCIGRAPHIC npMCI, BOOL fForce);

/*
** Functions in DEVICE.C
*/
DWORD PASCAL DeviceOpen(NPMCIGRAPHIC npMCI, DWORD dwFlags);
DWORD PASCAL DeviceClose(NPMCIGRAPHIC npMCI);
DWORD PASCAL DevicePlay(NPMCIGRAPHIC npMCI, LONG lPlayTo, DWORD dwFlags);
DWORD PASCAL DeviceResume(NPMCIGRAPHIC npMCI, DWORD dwFlags);
DWORD PASCAL DeviceCue(NPMCIGRAPHIC npMCI, LONG lTo, DWORD dwFlags);
DWORD PASCAL DeviceStop(NPMCIGRAPHIC npMCI, DWORD dwFlags);
DWORD PASCAL DevicePause(NPMCIGRAPHIC npMCI, DWORD dwFlags);
DWORD PASCAL DeviceSeek(NPMCIGRAPHIC npMCI, LONG lTo, DWORD dwFlags);
DWORD PASCAL DeviceRealize(NPMCIGRAPHIC npMCI);
DWORD PASCAL DeviceUpdate(NPMCIGRAPHIC npMCI, DWORD dwFlags, HDC hDC, LPRECT lprc);
UINT  PASCAL DeviceMode(NPMCIGRAPHIC npMCI);
DWORD PASCAL DevicePosition(NPMCIGRAPHIC npMCI, LPLONG lpl);
DWORD PASCAL DeviceSetWindow(NPMCIGRAPHIC npMCI, HWND hwnd);
DWORD PASCAL DeviceSetSpeed(NPMCIGRAPHIC npMCI, DWORD dwNewSpeed);
DWORD PASCAL DeviceMute(NPMCIGRAPHIC npMCI, BOOL fMute);
DWORD PASCAL DeviceSetVolume(NPMCIGRAPHIC npMCI, DWORD dwVolume);
DWORD PASCAL DeviceGetVolume(NPMCIGRAPHIC npMCI);
DWORD PASCAL DeviceSetAudioStream(NPMCIGRAPHIC npMCI, UINT uStream);
DWORD PASCAL DeviceSetVideoStream(NPMCIGRAPHIC npMCI, UINT uStream, BOOL fOn);
DWORD PASCAL DeviceSetActive(NPMCIGRAPHIC npMCI, BOOL fActive);

DWORD FAR PASCAL DevicePut(NPMCIGRAPHIC npMCI, LPRECT lprc, DWORD dwFlags);
DWORD FAR PASCAL DeviceSetPalette(NPMCIGRAPHIC npMCI, HPALETTE hpal);
DWORD PASCAL DeviceLoad(NPMCIGRAPHIC npMCI);

typedef struct {
    UINT    wOldTaskState;
    LONG    lTo;
    LONG    lFrom;
    DWORD   dwFlags;
} TEMPORARYSTATE;

DWORD NEAR PASCAL StopTemporarily(NPMCIGRAPHIC npMCI, TEMPORARYSTATE FAR * pts);
DWORD NEAR PASCAL RestartAgain(NPMCIGRAPHIC npMCI, TEMPORARYSTATE FAR * pts);

#if 0
#ifdef DEBUG
    void FAR PASCAL VerifyTaskState(NPMCIGRAPHIC npMCI, UINT wState);

    #define DEBUGVERIFYSTATE(npMCI, wState)    VerifyTaskState(npMCI, wState)
#else
    #define DEBUGVERIFYSTATE(npMCI, wState)    0
#endif
#endif


void FAR PASCAL SetWindowToDefaultSize(NPMCIGRAPHIC npMCI);
void FAR PASCAL ResetDestRect(NPMCIGRAPHIC npMCI);

DWORD FAR PASCAL ReadConfigInfo(void);
void  FAR PASCAL WriteConfigInfo(DWORD dwOptions);
BOOL  FAR PASCAL ConfigDialog(HWND, NPMCIGRAPHIC);

/*
** The Enumerate command isn't real: I'm just thinking about it.
*/
#define MCI_ENUMERATE			0x0901
#define MCI_ENUMERATE_STREAM		0x00000001L

// constants for dwItem field of MCI_STATUS_PARMS parameter block
#define MCI_AVI_STATUS_STREAMCOUNT	0x10000001L
#define MCI_AVI_STATUS_STREAMTYPE	0x10000002L
#define MCI_AVI_STATUS_STREAMENABLED	0x10000003L

// flags for dwFlags field of MCI_STATUS_PARMS parameter block
#define MCI_AVI_STATUS_STREAM		0x10000000L

// flags for dwFlags field of MCI_SET_PARMS parameter block
#define MCI_AVI_SET_STREAM		0x10000000L
#define MCI_AVI_SET_USERPROC		0x20000000L

/*
** Internal flag that can be used with SEEK
*/
#define MCI_AVI_SEEK_SHOWWINDOW		0x10000000L

extern INT	gwSkipTolerance;
extern INT	gwHurryTolerance;

/**************************************************************************
**************************************************************************/

#ifdef DEBUG
    extern DWORD FAR PASCAL timeGetTime(void);

    #define TIMEZERO(time)   npMCI->time  = 0;
    #define TIMESTART(time)  npMCI->time -= (LONG)timeGetTime()
    #define TIMEEND(time)    npMCI->time += (LONG)timeGetTime()
#else
    #define TIMEZERO(time)
    #define TIMESTART(time)
    #define TIMEEND(time)
#endif

/**************************************************************************
**************************************************************************/

#define FOURCC_AVIDraw      mmioFOURCC('D','R','A','W')
#define FOURCC_AVIFull      mmioFOURCC('F','U','L','L')
LONG FAR PASCAL _loadds ICAVIDrawProc(DWORD id, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2);
LONG FAR PASCAL _loadds ICAVIFullProc(DWORD id, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2);

/**************************************************************************
**************************************************************************/

#ifndef RC_INVOKED
#include "avitask.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\config.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   config.c - Multimedia Systems Media Control Interface
            driver for AVI - configuration dialog.

*****************************************************************************/
#include "graphic.h"
#include "cnfgdlg.h"

#define comptypeNONE            mmioFOURCC('n','o','n','e')

#ifndef WIN32
#define SZCODE char _based(_segname("_CODE"))
#else
#define SZCODE TCHAR
#endif

SZCODE szDEFAULTVIDEO[] =	TEXT("DefaultVideo");
SZCODE szVIDEOWINDOW[] =	TEXT("Window");
SZCODE szVIDEO240[] =           TEXT("240 Line Fullscreen");
SZCODE szSEEKEXACT[] =		TEXT("AccurateSeek");
SZCODE szZOOMBY2[] =		TEXT("ZoomBy2");
//SZCODE szSTUPIDMODE[] =         TEXT("DontBufferOffscreen");
SZCODE szSKIPFRAMES[] =         TEXT("SkipFrames");
SZCODE szUSEAVIFILE[] =         TEXT("UseAVIFile");

SZCODE szIni[] =		TEXT("MCIAVI");

SZCODE sz1[] = TEXT("1");
SZCODE sz0[] = TEXT("0");

SZCODE szIntl[] =               TEXT("Intl");
SZCODE szDecimal[] =            TEXT("sDecimal");
SZCODE szThousand[] =           TEXT("sThousand");

/* Make sure we only have one configure box up at a time.... */
HWND	ghwndConfig = NULL;

#ifdef DEBUG
BOOL FAR PASCAL _LOADDS DebugDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static NPMCIGRAPHIC npMCI = NULL;
    HWND cb;
    int i;
    TCHAR ach[40];

    extern int	giDebugLevel;	// current debug level (common.h)

    switch (wMsg) {
        case WM_INITDIALOG:
            npMCI = (NPMCIGRAPHIC)(UINT)lParam;

            //
            // set the DEBUG stuff.
            //
            CheckDlgButton(hDlg, ID_SCREEN, GetProfileInt(TEXT("DrawDib"), TEXT("DecompressToScreen"), 2));
            CheckDlgButton(hDlg, ID_BITMAP, GetProfileInt(TEXT("DrawDib"), TEXT("DecompressToBitmap"), 2));
            CheckDlgButton(hDlg, ID_SUCKS,  GetProfileInt(TEXT("DrawDib"), TEXT("DrawToBitmap"), 2));
            CheckDlgButton(hDlg, ID_USE_AVIFILE, (npMCI->dwOptionFlags & MCIAVIO_USEAVIFILE) != 0);
            SetScrollRange(GetDlgItem(hDlg, ID_RATE), SB_CTL, 0, 1000, TRUE);
            SetScrollPos(GetDlgItem(hDlg, ID_RATE), SB_CTL, (int)npMCI->PlaybackRate,TRUE);

            cb = GetDlgItem(hDlg, ID_LEVEL);
            SetWindowFont(cb, GetStockObject(ANSI_VAR_FONT), FALSE);

            ComboBox_AddString(cb, "0 - None");
	    ComboBox_AddString(cb, "1 - Level 1");
            ComboBox_AddString(cb, "2 - Level 2");
            ComboBox_AddString(cb, "3 - Level 3");
            ComboBox_AddString(cb, "4 - Level 4");

            ComboBox_SetCurSel(cb, giDebugLevel);

            #include "..\verinfo\usa\verinfo.h"
            wsprintf(ach,TEXT("Build %d.%02d.%02d"), MMVERSION, MMREVISION, MMRELEASE);
            SetDlgItemText(hDlg, ID_BUILD, ach);

            return TRUE;

        case WM_HSCROLL:
            i = GetScrollPos((HWND)HIWORD(lParam),SB_CTL);

            switch (LOWORD(wParam)) {
                case SB_LINEDOWN:      i+=10;  break;
                case SB_LINEUP:        i-=10;  break;
                case SB_PAGEDOWN:      i+=100; break;
                case SB_PAGEUP:        i-=100; break;
                case SB_THUMBTRACK:
                case SB_THUMBPOSITION: i = LOWORD(lParam); break;
            }

            if (i<0) i=0;
            if (i>1000) i=1000;

            SetScrollPos((HWND)HIWORD(lParam),SB_CTL,i,TRUE);
            break;

	case WM_COMMAND:
	    switch (wParam) {
		case IDCANCEL:
                case IDOK:
                    i = IsDlgButtonChecked(hDlg, ID_SUCKS);
                    if (i == 2)
                        WriteProfileString(TEXT("DrawDib"), TEXT("DrawToBitmap"), NULL);
                    else
                        WriteProfileString(TEXT("DrawDib"), TEXT("DrawToBitmap"), (LPTSTR)(i ? sz1 : sz0));

                    i = IsDlgButtonChecked(hDlg, ID_SCREEN);
                    if (i == 2)
                        WriteProfileString(TEXT("DrawDib"), TEXT("DecompressToScreen"),NULL);
                    else
                        WriteProfileString(TEXT("DrawDib"), TEXT("DecompressToScreen"),(LPTSTR)(i ? sz1 : sz0));

                    i = IsDlgButtonChecked(hDlg, ID_BITMAP);
                    if (i == 2)
                        WriteProfileString(TEXT("DrawDib"), TEXT("DecompressToBitmap"),NULL);
                    else
                        WriteProfileString(TEXT("DrawDib"), TEXT("DecompressToBitmap"),(LPTSTR)(i ? sz1 : sz0));

                    npMCI->PlaybackRate = GetScrollPos(GetDlgItem(hDlg, ID_RATE), SB_CTL);

                    giDebugLevel = ComboBox_GetCurSel(GetDlgItem(hDlg, ID_LEVEL));
                    wsprintf(ach,TEXT("%d"),giDebugLevel);
		    WriteProfileString(TEXT("Debug"),TEXT("MCIAVI"),ach);

                    if (IsDlgButtonChecked(hDlg, ID_USE_AVIFILE))
                        npMCI->dwOptionFlags |= MCIAVIO_USEAVIFILE;
                    else
                        npMCI->dwOptionFlags &= ~MCIAVIO_USEAVIFILE;

                    EndDialog(hDlg, TRUE);
                    break;

                case ID_RATE:
                    break;
	    }
	    break;
    }
    return FALSE;
}
#endif // DEBUG

LONG AVIGetFileSize(LPTSTR szFile)
{
    LONG        lSize;

#ifdef WIN32
    DWORD  dwHigh;
    HANDLE      fh;
    fh = CreateFile(szFile, GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ,
                    NULL, OPEN_EXISTING, 0, 0);

    if (fh == (HANDLE)HFILE_ERROR)
        return 0;

    lSize = (LONG)GetFileSize(fh, &dwHigh);
    CloseHandle(fh);
#else
    OFSTRUCT    of;
    HFILE       fh;
    fh = OpenFile(szFile, &of, OF_READ | OF_SHARE_DENY_NONE);

    if (fh == HFILE_ERROR)
        fh = OpenFile(szFile, &of, OF_READ);

    if (fh == HFILE_ERROR)
        return 0;

    lSize = _llseek(fh, 0, SEEK_END);
    _lclose(fh);
#endif

    return lSize;
}

//
//fill in the info box.
//
BOOL ConfigInfo(NPMCIGRAPHIC npMCI, HWND hwnd)
{
    PTSTR  pchInfo;
    LONG  len;
    DWORD time;
    PTSTR pch;
    TCHAR ach[80];
    TCHAR achDecimal[4];
    TCHAR achThousand[4];
    int i;

    if (npMCI == NULL)
        return FALSE;

    achDecimal[0]  = '.'; achDecimal[1] = 0;
    achThousand[0] = ','; achThousand[1] = 0;

    GetProfileString(szIntl, szDecimal,  achDecimal,  achDecimal,   sizeof(achDecimal));
    GetProfileString(szIntl, szThousand, achThousand, achThousand,  sizeof(achThousand));

    pchInfo = (PTSTR)LocalAlloc(LPTR, 8192*sizeof(TCHAR));

    if (pchInfo == NULL)
        return FALSE;

    pch = pchInfo;

    //
    // display file name
    //
    //  File: full path.
    //
    LoadString(ghModule, INFO_FILE, ach, sizeof(ach));
    pch += wsprintf(pch, ach, (LPTSTR)npMCI->szFilename);

    //
    // display file type
    //
    //  Type: type
    //
    if (npMCI->pf) {
#ifdef USEAVIFILE
	AVIFILEINFO info;
	LoadString(ghModule, INFO_FILETYPE, ach, sizeof(ach));
        npMCI->pf->lpVtbl->Info(npMCI->pf, &info, sizeof(info));
        pch += wsprintf(pch, ach, (LPSTR)info.szFileType);
#endif
    }
    else if (npMCI->dwFlags & MCIAVI_NOTINTERLEAVED) {
        LoadString(ghModule, INFO_FILETYPE_AVI, pch, 80);
        pch += lstrlen(pch);
    }
    else {
        LoadString(ghModule, INFO_FILETYPE_INT, pch, 80);
        pch += lstrlen(pch);
    }

    //
    // display length
    //
    //  Length: ## Frames (#.## sec)
    //
    LoadString(ghModule, INFO_LENGTH, ach, sizeof(ach));

    time = muldivru32(npMCI->lFrames, npMCI->dwMicroSecPerFrame, 1000L);

    pch += wsprintf(pch, ach,
        npMCI->lFrames, time/1000, achDecimal[0], (int)(time%1000));

    //
    // display the average data rate
    //
    //  Data Rate: #k/sec
    //
    len = npMCI->dwBigListEnd - npMCI->dwMovieListOffset;

    if (len == 0)
        len = AVIGetFileSize(npMCI->szFilename);

    if (len > 0) {
        LoadString(ghModule, INFO_DATARATE, ach, sizeof(ach));
        pch += wsprintf(pch, ach,muldiv32(len,1000,time) / 1024);
    }

    //
    // dump info on each stream.
    //
    for (i=0; i<npMCI->streams; i++) {

        STREAMINFO *psi = SI(i);

        LONG rate = muldiv32(psi->sh.dwRate,1000,psi->sh.dwScale);

        //
        // display video format
        //
        //  Video: MSVC 160x120x8 (cram) 15.000 fps
        //
        if (psi->lpFormat && psi->sh.fccType == streamtypeVIDEO) {

            LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER)psi->lpFormat;

            DWORD fccHandler = psi->sh.fccHandler;
            DWORD fccFormat  = lpbi->biCompression;

            if (fccHandler == 0)        fccHandler = comptypeNONE;
            if (fccHandler == BI_RLE8)  fccHandler = comptypeRLE;

            if (fccFormat == 0)         fccFormat = comptypeNONE;
            if (fccFormat == BI_RLE8)   fccFormat = comptypeRLE;

            LoadString(ghModule, INFO_VIDEOFORMAT, ach, sizeof(ach));

            pch += wsprintf(pch, ach,
                (LPVOID)&fccHandler,
                (int)lpbi->biWidth,
                (int)lpbi->biHeight,
                (int)lpbi->biBitCount,
                (LPVOID)&fccFormat,
                (UINT)(rate/1000), achDecimal[0], (UINT)(rate%1000));
        }

        //
        // display audio format
        //
        //  Audio: Mono 11.024KHz 8bit
        //
        else if (psi->lpFormat && psi->sh.fccType == streamtypeAUDIO) {

            LPWAVEFORMAT pwf = (LPWAVEFORMAT)psi->lpFormat;

            if (pwf->nChannels == 1)
                LoadString(ghModule, INFO_MONOFORMAT, ach, sizeof(ach));
            else
                LoadString(ghModule, INFO_STEREOFORMAT, ach, sizeof(ach));

            pch += wsprintf(pch, ach,
                (int)(pwf->nSamplesPerSec/1000),achDecimal[0],
                (int)(pwf->nSamplesPerSec%1000),
                (int)(pwf->nAvgBytesPerSec * 8 / (pwf->nSamplesPerSec * pwf->nChannels)));

            if (pwf->wFormatTag == WAVE_FORMAT_PCM) {
            }

            else if (pwf->wFormatTag == 2) {  // ADPCM
                pch -= 2; // skip over \r\n
                LoadString(ghModule, INFO_ADPCM, pch, 20);
                pch += lstrlen(pch);
            }

            else {
                pch -= 2; // skip over \r\n
                LoadString(ghModule, INFO_COMPRESSED, pch, 20);
                pch += lstrlen(pch);
            }

        }

        //
        // Other stream.
        //
        else if (psi->sh.fccType != 0) {

            LoadString(ghModule, INFO_STREAM, ach, sizeof(ach));

            pch += wsprintf(pch, ach,
                (LPSTR)&psi->sh.fccType,
                (LPSTR)&psi->sh.fccHandler);
        }

        if (!(psi->dwFlags & STREAM_ENABLED)) {
            pch -= 2; // skip over \r\n
            LoadString(ghModule, INFO_DISABLED, ach, sizeof(ach));
            pch += wsprintf(pch, ach);
        }
    }

#ifdef DEBUG
    //
    // show the frames skipped on the last play
    //
    if (npMCI->lFramesPlayed > 0) {
        LoadString(ghModule, INFO_SKIP, ach, sizeof(ach));
        pch += wsprintf(pch, ach,
            npMCI->lSkippedFrames,
            npMCI->lFramesPlayed,
            (int)(100L * npMCI->lSkippedFrames / npMCI->lFramesPlayed));
	
	//
	// show the frames not read on the last play
	//
	if (npMCI->lFramesSeekedPast > 0) {
	    LoadString(ghModule, INFO_NOTREAD, ach, sizeof(ach));
	    pch += wsprintf(pch, ach,
		npMCI->lFramesSeekedPast,
		(int)(100L * npMCI->lFramesSeekedPast / npMCI->lFramesPlayed));
	}

    }

    //
    // show the # audio breaks on the last play
    //
    if (npMCI->lFramesPlayed > 0 && npMCI->lAudioBreaks > 0) {
        LoadString(ghModule, INFO_SKIPAUDIO, ach, sizeof(ach));
        pch += wsprintf(pch, ach, npMCI->lAudioBreaks);
    }
#endif

    if (npMCI->dwKeyFrameInfo == 1) {
        LoadString(ghModule, INFO_ALLKEYFRAMES, ach, sizeof(ach));
        pch += wsprintf(pch, ach, (int)npMCI->dwKeyFrameInfo);
    }
    else if (npMCI->dwKeyFrameInfo == 0) {
        LoadString(ghModule, INFO_NOKEYFRAMES, ach, sizeof(ach));
        pch += wsprintf(pch, ach, (int)npMCI->dwKeyFrameInfo);
    }
    else {
        LoadString(ghModule, INFO_KEYFRAMES, ach, sizeof(ach));
        pch += wsprintf(pch, ach, (int)npMCI->dwKeyFrameInfo);
    }

#ifdef DEBUG
    //
    // timing info
    //
    #define SEC(time)    (UINT)(time / 1000l) , (UINT)(time % 1000l)
    #define SECX(time,t) SEC(time) , (t ? (UINT)(time * 100l / t) : 0)

    if (npMCI->lFramesPlayed > 0) {

        DRAWDIBTIME ddt;

        pch += wsprintf(pch, TEXT("MCIAVI-------------------------------------\r\n"));
        pch += wsprintf(pch, TEXT("timePlay:    \t%3d.%03dsec\r\n"),SEC(npMCI->timePlay));
        pch += wsprintf(pch, TEXT("timeRead:    \t%3d.%03dsec (%d%%)\r\n"),SECX(npMCI->timeRead, npMCI->timePlay));
        pch += wsprintf(pch, TEXT("timeWait:    \t%3d.%03dsec (%d%%)\r\n"),SECX(npMCI->timeWait, npMCI->timePlay));
        pch += wsprintf(pch, TEXT("timeYield:   \t%3d.%03dsec (%d%%)\r\n"),SECX(npMCI->timeYield, npMCI->timePlay));
        pch += wsprintf(pch, TEXT("timeVideo:   \t%3d.%03dsec (%d%%)\r\n"),SECX(npMCI->timeVideo, npMCI->timePlay));
        pch += wsprintf(pch, TEXT("timeDraw:    \t%3d.%03dsec (%d%%)\r\n"),SECX(npMCI->timeDraw,  npMCI->timePlay));
        pch += wsprintf(pch, TEXT("timeDecomp:  \t%3d.%03dsec (%d%%)\r\n"),SECX(npMCI->timeDecompress, npMCI->timePlay));
        pch += wsprintf(pch, TEXT("timeAudio:   \t%3d.%03dsec (%d%%)\r\n"),SECX(npMCI->timeAudio, npMCI->timePlay));
        pch += wsprintf(pch, TEXT("timePaused:  \t%3d.%03dsec\r\n"),SEC(npMCI->timePaused));
        pch += wsprintf(pch, TEXT("timePrepare: \t%3d.%03dsec\r\n"),SEC(npMCI->timePrepare));
        pch += wsprintf(pch, TEXT("timeCleanup: \t%3d.%03dsec\r\n"),SEC(npMCI->timeCleanup));

        if (npMCI->hdd && DrawDibTime(npMCI->hdd, &ddt)) {
            pch += wsprintf(pch, TEXT("DrawDib-------------------------------------\r\n"));
            pch += wsprintf(pch, TEXT("timeDraw:        \t%3d.%03dsec\r\n"), SEC(ddt.timeDraw));
            pch += wsprintf(pch, TEXT("timeDecompress:  \t%3d.%03dsec (%d%%)\r\n"), SECX(ddt.timeDecompress, ddt.timeDraw));
            pch += wsprintf(pch, TEXT("timeDither:      \t%3d.%03dsec (%d%%)\r\n"), SECX(ddt.timeDither,     ddt.timeDraw));
            pch += wsprintf(pch, TEXT("timeStretch:     \t%3d.%03dsec (%d%%)\r\n"), SECX(ddt.timeStretch,    ddt.timeDraw));
            pch += wsprintf(pch, TEXT("timeSetDIBits:   \t%3d.%03dsec (%d%%)\r\n"), SECX(ddt.timeSetDIBits,  ddt.timeDraw));
            pch += wsprintf(pch, TEXT("timeBlt:         \t%3d.%03dsec (%d%%)\r\n"), SECX(ddt.timeBlt,        ddt.timeDraw));
        }
    }
#endif

    //
    // now shove this mess into the info window.
    //
    Assert(pch - pchInfo < 8192);
    SetWindowFont(GetDlgItem(hwnd, ID_INFO), GetStockObject(ANSI_VAR_FONT), TRUE);
    SetDlgItemText(hwnd, ID_INFO, pchInfo);

    LocalFree((HLOCAL)pchInfo);

    return TRUE;
}

BOOL FAR PASCAL _LOADDS ConfigDlgProc(HWND hDlg, UINT wMsg,
						WPARAM wParam, LPARAM lParam)
{
    static NPMCIGRAPHIC npMCI = NULL;
    DWORD dwOptions;
    TCHAR ach[80];

    switch (wMsg) {
	case WM_INITDIALOG:
            npMCI = (NPMCIGRAPHIC)(UINT)lParam;
	    ghwndConfig = hDlg;

            if (npMCI)
                dwOptions = npMCI->dwOptionFlags;
            else
                dwOptions = ReadConfigInfo();
	
#ifndef WIN32
            // On NT we do not support full screen.  I wonder if this
            // will ever change ?
	    CheckRadioButton(hDlg, ID_WINDOW, ID_VGA240,
                (dwOptions & MCIAVIO_USEVGABYDEFAULT) ?
					    ID_VGA240 : ID_WINDOW);
#endif

	    CheckDlgButton(hDlg, ID_ZOOM2,
                                (dwOptions & MCIAVIO_ZOOMBY2) != 0);

	    CheckDlgButton(hDlg, ID_SKIPFRAMES,
                                (dwOptions & MCIAVIO_SKIPFRAMES) != 0);

#if 0  /////////////////////////////////////////////////////////////////////
	    CheckDlgButton(hDlg, ID_FAILIFNOWAVE,
                                (dwOptions & MCIAVIO_FAILIFNOWAVE) != 0);
	
	    CheckDlgButton(hDlg, ID_SEEKEXACT,
                                (dwOptions & MCIAVIO_SEEKEXACT) == 0);
#endif /////////////////////////////////////////////////////////////////////
	
//	    CheckDlgButton(hDlg, ID_STUPIDMODE,
//                                (dwOptions & MCIAVIO_STUPIDMODE) != 0);
	
	    EnableWindow(GetDlgItem(hDlg, ID_ZOOM2), TRUE);
//                                (dwOptions & MCIAVIO_STUPIDMODE) == 0);

            if (npMCI == NULL) {
                GetDlgItemText(hDlg, ID_DEFAULT, ach, sizeof(ach)/sizeof(TCHAR));
                SetDlgItemText(hDlg, IDOK, ach);
                ShowWindow(GetDlgItem(hDlg, ID_DEFAULT),SW_HIDE);
            }

            if (!ConfigInfo(npMCI, hDlg)) {
                RECT rcWindow;
                RECT rc;

                GetWindowRect(hDlg, &rcWindow);
                GetWindowRect(GetDlgItem(hDlg, ID_SIZE), &rc);

                SetWindowPos(hDlg, NULL, 0, 0,
                    rcWindow.right-rcWindow.left,
                    rc.top - rcWindow.top,
                    SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
            }
            return TRUE;

        case WM_ENDSESSION:
            if (wParam)
                EndDialog(hDlg, FALSE);
            break;

	case WM_COMMAND:
	    switch (wParam) {
                case ID_DEFAULT:
                case IDOK:
                    if (npMCI)
                        dwOptions = npMCI->dwOptionFlags;
                    else
                        dwOptions = 0;

                    /* Clear the flags we might set */

                    dwOptions &= ~(MCIAVIO_USEVGABYDEFAULT |
                                   MCIAVIO_SKIPFRAMES |
////                               MCIAVIO_FAILIFNOWAVE |
////                               MCIAVIO_SEEKEXACT |
                                   MCIAVIO_ZOOMBY2 |
                                   MCIAVIO_STUPIDMODE);
		
#ifndef WIN32
            // On NT we do not support full screen.  I wonder if this
            // will ever change ?
		    if (!IsDlgButtonChecked(hDlg, ID_WINDOW))
                        dwOptions |= MCIAVIO_USEVGABYDEFAULT;
#endif
				
		    if (IsDlgButtonChecked(hDlg, ID_SKIPFRAMES))
                        dwOptions |= MCIAVIO_SKIPFRAMES;

////                if (IsDlgButtonChecked(hDlg, ID_FAILIFNOWAVE))
////                    dwOptions |= MCIAVIO_FAILIFNOWAVE;

////                if (!IsDlgButtonChecked(hDlg, ID_SEEKEXACT))
                        dwOptions |= MCIAVIO_SEEKEXACT;
				
//		    if (IsDlgButtonChecked(hDlg, ID_STUPIDMODE))
//                        dwOptions |= MCIAVIO_STUPIDMODE;
//
//                    else if (IsDlgButtonChecked(hDlg, ID_ZOOM2))
                    if (IsDlgButtonChecked(hDlg, ID_ZOOM2))
                        dwOptions |= MCIAVIO_ZOOMBY2;

                    if (wParam == ID_DEFAULT || npMCI == NULL)
                        WriteConfigInfo(dwOptions);

                    if (wParam == IDOK) {

                        if (npMCI)
                            npMCI->dwOptionFlags = dwOptions;

                        EndDialog(hDlg, TRUE);
                    }
		    break;
		
//                case ID_STUPIDMODE:
//		    EnableWindow(GetDlgItem(hDlg, ID_ZOOM2),
//			    !IsDlgButtonChecked(hDlg, ID_STUPIDMODE));
//
//		    /* Clear "zoom" if easy mode checked */
//		    if (IsDlgButtonChecked(hDlg, ID_STUPIDMODE))
//			CheckDlgButton(hDlg, ID_ZOOM2, FALSE);
//		    break;
		
		case IDCANCEL:
		    EndDialog(hDlg, FALSE);
		    break;
#ifdef DEBUG
                case ID_DEBUG:
                    DialogBoxParam(ghModule, MAKEINTRESOURCE(IDA_DEBUG),
                            hDlg, DebugDlgProc, (DWORD)(UINT)npMCI);
                    break;
#endif
	    }
	    break;
    }
    return FALSE;
}

DWORD FAR PASCAL ReadConfigInfo(void)
{
    int		i;
    DWORD	dwOptions = 0L;
    HDC		hdc;
    //
    // ask the display device if it can do 256 color.
    //
    hdc = GetDC(NULL);
    i = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
    ReleaseDC(NULL, hdc);

    i = GetProfileInt(szIni, szDEFAULTVIDEO,
		(i < 8 && (GetWinFlags() & WF_CPU286)) ? 240 : 0);

    if (i >= 200)
	dwOptions |= MCIAVIO_USEVGABYDEFAULT;

////if (GetProfileInt(szIni, szSEEKEXACT, 1))
	dwOptions |= MCIAVIO_SEEKEXACT;

    if (GetProfileInt(szIni, szZOOMBY2, 0))
	dwOptions |= MCIAVIO_ZOOMBY2;

////if (GetProfileInt(szIni, szFAILIFNOWAVE, 0))
////    dwOptions |= MCIAVIO_FAILIFNOWAVE;

//    if (GetProfileInt(szIni, szSTUPIDMODE, 0))
//	dwOptions |= MCIAVIO_STUPIDMODE;

    if (GetProfileInt(szIni, szSKIPFRAMES, 1))
        dwOptions |= MCIAVIO_SKIPFRAMES;

    if (GetProfileInt(szIni, szUSEAVIFILE, 0))
        dwOptions |= MCIAVIO_USEAVIFILE;

    return dwOptions;
}

void FAR PASCAL WriteConfigInfo(DWORD dwOptions)
{
    // !!! This shouldn't get written out if it is the default!
    WriteProfileString(szIni, szDEFAULTVIDEO,
	 (dwOptions & MCIAVIO_USEVGABYDEFAULT) ? szVIDEO240 : szVIDEOWINDOW);

////WriteProfileString(szIni, szSEEKEXACT,
////        (dwOptions & MCIAVIO_SEEKEXACT) ? sz1 : sz0);

    WriteProfileString(szIni, szZOOMBY2,
	    (dwOptions & MCIAVIO_ZOOMBY2) ? sz1 : sz0);

////WriteProfileString(szIni, szFAILIFNOWAVE,
////        (dwOptions & MCIAVIO_FAILIFNOWAVE) ? sz1 : sz0);

//    WriteProfileString(szIni, szSTUPIDMODE,
//            (dwOptions & MCIAVIO_STUPIDMODE) ? sz1 : sz0);

    WriteProfileString(szIni, szSKIPFRAMES,
            (dwOptions & MCIAVIO_SKIPFRAMES) ? sz1 : sz0);

    WriteProfileString(szIni, szUSEAVIFILE,
            (dwOptions & MCIAVIO_USEAVIFILE) ? sz1 : sz0);
}

BOOL FAR PASCAL ConfigDialog(HWND hwnd, NPMCIGRAPHIC npMCI)
{
    #define MAX_WINDOWS 10
    HWND    hwndActive[MAX_WINDOWS];
    BOOL    f;
    int     i;
    HWND    hwndT;

    if (ghwndConfig) {
        MessageBeep(0);
        return FALSE;
    }

    if (hwnd == NULL)
        hwnd = GetActiveWindow();

    //
    // enum all the toplevel windows of this task and disable them!
    //
    for (hwndT = GetWindow(GetDesktopWindow(), GW_CHILD), i=0;
         hwndT && i < MAX_WINDOWS;
         hwndT = GetWindow(hwndT, GW_HWNDNEXT)) {

        if (IsWindowEnabled(hwndT) &&
            	IsWindowVisible(hwndT) &&
            	(HTASK)GetWindowTask(hwndT) == GetCurrentTask() &&
	    	hwndT != hwnd) {	// don't disable our parent
            hwndActive[i++] = hwndT;
            EnableWindow(hwndT, FALSE);
        }
    }

    f = DialogBoxParam(ghModule, MAKEINTRESOURCE(IDA_CONFIG),
            hwnd, ConfigDlgProc, (DWORD)(UINT)npMCI);

    //
    // restore all windows
    //
    while (i-- > 0)
        EnableWindow(hwndActive[i], TRUE);

    if (hwnd)
        SetActiveWindow(hwnd);

    ghwndConfig = NULL;

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\drvproc.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   drvproc.c - Multimedia Systems Media Control Interface
            driver for AVI.

*****************************************************************************/
#include "graphic.h"
#include "cnfgdlg.h"            // to get IDA_CONFIG
#include "avitask.h"            // to get mciaviTaskCleanup()

#ifndef WIN32 // Not used in 32 bit world
void NEAR PASCAL AppExit(HTASK htask, BOOL fNormalExit);
#endif

#define CONFIG_ID   10000L  // Use the hiword of dwDriverID to identify
HANDLE ghModule;
extern HWND ghwndConfig;

/* Link to DefDriverProc in MMSystem explicitly, so we don't get the
** one in USER by mistake.
*/
#ifndef WIN32
extern DWORD FAR PASCAL mmDefDriverProc(DWORD, HANDLE, UINT, DWORD, DWORD);
#else
#define mmDefDriverProc DefDriverProc
#endif

#ifndef WIN32
BOOL FAR PASCAL LibMain (HANDLE hModule, int cbHeap, LPSTR lpchCmdLine)
{
    ghModule = hModule;
    return TRUE;
}
#else

BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    if (Reason == DLL_PROCESS_ATTACH) {
        ghModule = hModule;  // All we need to save is our module handle...
    } else {
        if (Reason == DLL_PROCESS_DETACH) {
        }
    }
    return TRUE;
}

#endif // WIN16

/***************************************************************************
 *
 * @doc     INTERNAL
 *
 * @api     DWORD | DriverProc | The entry point for an installable driver.
 *
 * @parm    DWORD | dwDriverId | For most messages, dwDriverId is the DWORD
 *          value that the driver returns in response to a DRV_OPEN message.
 *          Each time that the driver is opened, through the DrvOpen API,
 *          the driver receives a DRV_OPEN message and can return an
 *          arbitrary, non-zero, value. The installable driver interface
 *          saves this value and returns a unique driver handle to the
 *          application. Whenever the application sends a message to the
 *          driver using the driver handle, the interface routes the message
 *          to this entry point and passes the corresponding dwDriverId.
 *
 *          This mechanism allows the driver to use the same or different
 *          identifiers for multiple opens but ensures that driver handles
 *          are unique at the application interface layer.
 *
 *          The following messages are not related to a particular open
 *          instance of the driver. For these messages, the dwDriverId
 *          will always be  ZERO.
 *
 *              DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * @parm    UINT | wMessage | The requested action to be performed. Message
 *          values below DRV_RESERVED are used for globally defined messages.
 *          Message values from DRV_RESERVED to DRV_USER are used for
 *          defined driver portocols. Messages above DRV_USER are used
 *          for driver specific messages.
 *
 * @parm    DWORD | dwParam1 | Data for this message.  Defined separately for
 *          each message
 *
 * @parm    DWORD | dwParam2 | Data for this message.  Defined separately for
 *          each message
 *
 * @rdesc Defined separately for each message.
 *
 ***************************************************************************/

DWORD FAR PASCAL _LOADDS DriverProc (DWORD dwDriverID, HANDLE hDriver, UINT wMessage,
    DWORD dwParam1, DWORD dwParam2)
{
    DWORD dwRes = 0L;


    /*
     * critical sections are now per-device. This means they
     * cannot be held around the whole driver-proc, since until we open
     * the device, we don't have a critical section to hold.
     * The critical section is allocated in mciSpecial on opening. It is
     * also held in mciDriverEntry, in GraphicWndProc, and around
     * all worker thread draw functions.
     */


    switch (wMessage)
        {

        // Standard, globally used messages.

        case DRV_LOAD:

            if (GraphicInit())       // Initialize graphic mgmt.
                dwRes = 1L;
            else
                dwRes = 0L;

            break;

        case DRV_FREE:

            GraphicFree();
            dwRes = 1L;
            break;

        case DRV_OPEN:

            if (!dwParam2)
                dwRes = CONFIG_ID;
            else
                dwRes = GraphicDrvOpen((LPMCI_OPEN_DRIVER_PARMS)dwParam2);

            break;

        case DRV_CLOSE:
	    /* If we have a configure dialog up, fail the close.
	    ** Otherwise, we'll be unloaded while we still have the
	    ** configuration window up.
	    */
	    if (ghwndConfig)
		dwRes = 0L;
	    else
		dwRes = 1L;
            break;

        case DRV_ENABLE:

            dwRes = 1L;
            break;

        case DRV_DISABLE:

            dwRes = 1L;
            break;

        case DRV_QUERYCONFIGURE:

            dwRes = 1L;	/* Yes, we can be configured */
            break;

        case DRV_CONFIGURE:
            ConfigDialog((HWND)(UINT)dwParam1, NULL);
            dwRes = 1L;
            break;

#ifndef WIN32
        //
        //  sent when a application is terminating
        //
        //  lParam1:
        //      DRVEA_ABNORMALEXIT
        //      DRVEA_NORMALEXIT
        //
        case DRV_EXITAPPLICATION:
            AppExit(GetCurrentTask(), (BOOL)dwParam1 == DRVEA_NORMALEXIT);
            break;
#endif

        default:

            if (!HIWORD(dwDriverID) &&
                wMessage >= DRV_MCI_FIRST &&
                wMessage <= DRV_MCI_LAST)

                dwRes = mciDriverEntry ((UINT)dwDriverID,
                                        wMessage,
                                        dwParam1,
                                        (LPMCI_GENERIC_PARMS)dwParam2);
            else
                dwRes = mmDefDriverProc(dwDriverID,
                                      hDriver,
                                      wMessage,
                                      dwParam1,
                                      dwParam2);
            break;
        }

    return dwRes;
}

#ifndef WIN32
/*****************************************************************************
 * @doc INTERNAL
 *
 * @func void | AppExit |
 *      a application is exiting
 *
 ****************************************************************************/

void NEAR PASCAL AppExit(HTASK htask, BOOL fNormalExit)
{
    //
    //  walk the list of open MCIAVI instances and see if
    //  the dying task is the background task and do cleanup.
    //
    NPMCIGRAPHIC npMCI;
    extern NPMCIGRAPHIC npMCIList; // in graphic.c

    for (npMCI=npMCIList; npMCI; npMCI = npMCI->npMCINext) {

        if (npMCI->hTask == htask) {
            DPF(("Calling mciaviTaskCleanup()\n"));
            mciaviTaskCleanup(npMCI);
            return;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\graphic.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   graphic.c - Multimedia Systems Media Control Interface
            driver for AVI.

*****************************************************************************/

#include "graphic.h"
//#include "dispdib.h"
#include "cnfgdlg.h"
#include <string.h>
#ifdef EXPIRE
#include <dos.h>
#endif
#include "avitask.h"

#ifdef DEBUG
#define static
#endif

//
//  This is the version number of MSVIDEO.DLL we need in order to run
//  build 81 is when we added the VideoForWindowsVersion() function to
//  MSVIDEO.DLL
//
//  in build 85
//    we removed the ICDecompressOpen() function and it became a macro.
//    we added a parameter to ICGetDisplayFormat()
//    we make DrawDibProfileDisplay() take a parameter
//
//  in build 108
//    Added ICOpenFunction() to open a hic using a function directly,
//	without calling ICInstall
//    Added some more ICDRAW_ messages
//
//  in build 109
//    Addded ICMessage() to compman
//    removed ICDrawSuggest() made it a macro.
//    Added ICMODE_FASTDECOMPRESS to ICLocate()
//
//  Under NT the first build is sufficient !!! Is this true now?
//
#ifdef WIN32
#define MSVIDEO_VERSION     (0x01000000)          // 1.00.00.00
#else
#define MSVIDEO_VERSION     (0x010a0000l+109)     // 1.10.00.109
#endif

/* statics */
static INT              swCommandTable = -1;

#ifdef WIN32
static SZCODE		szDisplayDibLib[] = TEXT("DISPDB32.DLL");
#else
static SZCODE		szDisplayDibLib[] = TEXT("DISPDIB.DLL");
#endif

/*
 * files should be UNICODE. function names should not
 */
static SZCODEA          szDisplayDib[]    = "DisplayDib";
static SZCODEA          szDisplayDibEx[]  = "DisplayDibEx";
#ifdef WIN32
STATICDT SZCODE         szMSVideo[]       = TEXT("MSVFW32");  // With GetModuleHandle
#else
static SZCODE           szMSVideo[]       = TEXT("MSVIDEO");
#endif

BOOL   gfEvil;          // TRUE if we cant close cuz dialog box is up
BOOL   gfEvilSysMenu;   // TRUE if we cant close cuz system menu is up

NPMCIGRAPHIC npMCIList; // list of all open instances.

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | GraphicInit | This function is called when the DriverProc
 *      gets a DRV_LOAD message.
 *
 ***************************************************************************/
BOOL FAR PASCAL GraphicInit(void)
{
    InitializeDebugOutput("MCIAVI");

    if (!GraphicWindowInit())
	return FALSE;

    swCommandTable = mciLoadCommandResource(ghModule, TEXT("mciavi"), 0);

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicDrvOpen | This function is called when the DriverProc
 *      gets a DRV_OPEN message. This happens each time that a new movie
 *      is opened thru MCI.
 *
 * @parm LPMCI_OPEN_DRIVER_PARMS | lpOpen | Far pointer to the standard
 *      MCI open parameters
 *
 * @rdesc Returns the mci device id. The installable driver interface will
 *      pass this ID to the DriverProc in the dwDriverID parameter on all
 *      subsequent messages. To fail the open, return 0L.
 *
 ***************************************************************************/

DWORD PASCAL GraphicDrvOpen(LPMCI_OPEN_DRIVER_PARMS lpOpen)
{
    /* Specify the custom command table and the device type  */

    lpOpen->wCustomCommandTable = swCommandTable;
    lpOpen->wType = MCI_DEVTYPE_DIGITAL_VIDEO;

    /* Set the device ID to the MCI Device ID */

    return (DWORD) (UINT)lpOpen->wDeviceID;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | GraphicFree | This function is called when the DriverProc
 *      gets a DRV_FREE message. This happens when the drivers open count
 *      reaches 0.
 *
 ***************************************************************************/

void PASCAL GraphicFree(void)
{
    if (swCommandTable != -1) {
	    mciFreeCommandResource(swCommandTable);
	    swCommandTable = -1;
    }

#ifdef WIN32
    /*
     * unregister class so we can re-register it next time we are loaded
     */
    GraphicWindowFree();
#endif
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicDelayedNotify | This is a utility function that
 *      sends a notification saved with GraphicSaveCallback to mmsystem
 *      which posts a message to the application.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data.
 *
 * @parm UINT | wStatus | The type of notification to use can be one of
 *      MCI_NOTIFY_SUCCESSFUL, MCI_NOTIFY_SUPERSEDED, MCI_NOTIFY_ABORTED
 *      or MCI_NOTIFY_FAILURE (see MCI ispec.)
 *
 ***************************************************************************/

void FAR PASCAL GraphicDelayedNotify(NPMCIGRAPHIC npMCI, UINT wStatus)
{
    /* Send any saved notification */

    if (npMCI->hCallback) {

	// If the system menu is the only thing keeping us from closing, bring
	// it down and then close.
	if (gfEvilSysMenu)
	    SendMessage(npMCI->hwnd, WM_CANCELMODE, 0, 0);

	// If a dialog box is up, and keeping us from closing, we can't send the
	// notify or it will close us.
	if (!gfEvil)
    	    mciDriverNotify(npMCI->hCallback, npMCI->wDevID, wStatus);

    	npMCI->hCallback = NULL;
    }
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicImmediateNotify | This is a utility function that
 *      sends a successful notification message to mmsystem if the
 *      notification flag is set and the error field is 0.
 *
 * @parm UINT | wDevID | device ID.
 *
 * @parm LPMCI_GENERIC_PARMS | lpParms | Far pointer to an MCI parameter
 *      block. The first field of every MCI parameter block is the
 *      callback handle.
 *
 * @parm DWORD | dwFlags | Parm. block flags - used to check whether the
 *      callback handle is valid.
 *
 * @parm DWORD | dwErr | Notification only occurs if the command is not
 *      returning an error.
 *
 ***************************************************************************/

void FAR PASCAL GraphicImmediateNotify(UINT wDevID,
    LPMCI_GENERIC_PARMS lpParms,
    DWORD dwFlags, DWORD dwErr)
{
    if (!LOWORD(dwErr) && (dwFlags & MCI_NOTIFY)) {
	//Don't have an npMCI - see GraphicDelayedNotify
	//if (gfEvil)
	    //SendMessage(npMCI->hwnd, WM_CANCELMODE, 0, 0);

	// If a dialog box is up, and keeping us from closing, we can't send the
	// notify or it will close us.
	if (!gfEvil) // !!! EVIL !!!
            mciDriverNotify((HANDLE) (UINT)lpParms->dwCallback,
					wDevID, MCI_NOTIFY_SUCCESSFUL);
    }
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicSaveCallback | This is a utility function that saves
 *      a new callback in the instance data block.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data.
 *
 * @parm HANDLE | hCallback | callback handle
 *
 ***************************************************************************/

void NEAR PASCAL GraphicSaveCallback (NPMCIGRAPHIC npMCI, HANDLE hCallback)
{
    /* If there's an old callback, kill it. */
    GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUPERSEDED);

    /* Save new notification callback window handle */
    npMCI->hCallback = hCallback;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicClose | This function closes the movie and
 *  releases the instance data.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD PASCAL GraphicClose (NPMCIGRAPHIC npMCI)
{
    DWORD dwRet = 0L;
    NPMCIGRAPHIC p;

    if (npMCI) {
	
        dwRet = DeviceClose (npMCI);
        Assert(dwRet == 0);

	// If the system menu is the only thing keeping us from closing, bring
	// it down and then close.
	if (gfEvilSysMenu)
	    SendMessage(npMCI->hwnd, WM_CANCELMODE, 0, 0);

      	if (gfEvil) {
	    DPF(("************************************************\n"));
	    DPF(("** EVIL: Failing the close because we'd die   **\n"));
            DPF(("************************************************\n"));
            LeaveCrit(npMCI);
	    return MCIERR_DRIVER_INTERNAL;
        }
	
        /* If the default window still exists, close and destroy it. */
        if (IsWindow(npMCI->hwndDefault)) {
	    if (!DestroyWindow(npMCI->hwndDefault))
		dwRet = MCIERR_DRIVER_INTERNAL;
	}

	if (npMCI->szFilename) {
	    LocalFree((HANDLE) (npMCI->szFilename));
	}

        //
        // find this instance on the list
        //
        if (npMCI == npMCIList) {
            npMCIList = npMCI->npMCINext;
        }
        else {
            for (p=npMCIList; p && p->npMCINext != npMCI; p=p->npMCINext)
                ;

            Assert(p && p->npMCINext == npMCI);

            p->npMCINext = npMCI->npMCINext;
        }

#ifdef WIN32
	// Delete the critical section object
	LeaveCriticalSection(&npMCI->CritSec);
	DeleteCriticalSection(&npMCI->CritSec);
#endif


	/* Free the instance data block allocated in GraphicOpen */

	LocalFree((HANDLE)npMCI);
    }
	
    return dwRet;
}

DWORD NEAR PASCAL FixFileName(NPMCIGRAPHIC npMCI, LPCTSTR lpName)
{
    TCHAR	ach[256];

    ach[(sizeof(ach)/sizeof(TCHAR)) - 1] = TEXT('\0');

#ifndef WIN32
    _fstrncpy(ach, (LPTSTR) lpName, (sizeof(ach)/sizeof(TCHAR)) - (1*sizeof(TCHAR)));
#else
    wcsncpy(ach, (LPTSTR) lpName, (sizeof(ach)/sizeof(TCHAR)) - (1*sizeof(TCHAR)));
#endif

    //
    // treat any string that starts with a '@' as valid and pass it to the
    // device any way.
    //
    if (ach[0] != '@')
    {
    if (!mmioOpen(ach, NULL, MMIO_PARSE))
	return MCIERR_FILENAME_REQUIRED;	
    }

    npMCI->szFilename = (NPTSTR) LocalAlloc(LPTR,
				    sizeof(TCHAR) * (lstrlen(ach) + 1));

    if (!npMCI->szFilename) {
	return MCIERR_OUT_OF_MEMORY;
    }

    lstrcpy(npMCI->szFilename, ach);

    return 0L;
}

/**************************************************************************

***************************************************************************/

#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))
//#define SLASH(c)     ((c) == '/' || (c) == '\\')  // Filename Ascii??

STATICFN LPCTSTR FAR FileName(LPCTSTR szPath)
{
    LPCTSTR   sz;

    sz = &szPath[lstrlen(szPath)];
    for (; sz>szPath && !SLASH(*sz) && *sz!=TEXT(':');)
        sz = CharPrev(szPath, sz);
    return (sz>szPath ? sz + 1 : sz);
}

/****************************************************************************
****************************************************************************/

STATICFN DWORD NEAR PASCAL GetMSVideoVersion()
{
    HANDLE h;

    extern DWORD FAR PASCAL VideoForWindowsVersion(void);

    //
    // don't call VideoForWindowsVersion() if it does not exist or KERNEL
    // will kill us with a undef dynalink error.
    //
    if ((h = GetModuleHandle(szMSVideo)) && GetProcAddress(h, (LPSTR) MAKEINTATOM(2)))
        return VideoForWindowsVersion();
    else
        return 0;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicOpen | This function opens a movie file,
 *      initializes an instance data block, and creates the default
 *      stage window.
 *
 * @parm NPMCIGRAPHIC FAR * | lpnpMCI | Far pointer to a near pointer
 *      to instance data block to be filled in by this function.
 *
 * @parm DWORD | dwFlags | Flags for the open message.
 *
 * @parm LPMCI_DGV_OPEN_PARMS | Parameters for the open message.
 *
 * @parm UINT | wDeviceID | The MCI Device ID for this instance.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD PASCAL GraphicOpen (NPMCIGRAPHIC FAR * lpnpMCI, DWORD dwFlags,
    LPMCI_DGV_OPEN_PARMS lpOpen, UINT wDeviceID)
{
    NPMCIGRAPHIC npMCI;
    DWORD	dwStyle;
    HWND	hWnd;
    HWND	hWndParent;
    DWORD	dwRet;

    if (dwFlags & MCI_OPEN_SHAREABLE) {

        if (lpOpen->lpstrElementName == NULL ||
            lpOpen->lpstrElementName[0] != '@') {
            return MCIERR_UNSUPPORTED_FUNCTION;
        }
    }

    //
    //  check the verion of MSVIDEO.DLL before going any further
    //  if we run a "new" version of MCIAVI on a old MSVIDEO.DLL
    //  then bad things will happen.  We assume all MSVIDEO.DLLs
    //  will be backward compatible so we check for any version
    //  greater than the expected version.
    //

    DPF(("Video For Windows Version %d.%02d.%02d.%02d\n", HIBYTE(HIWORD(GetMSVideoVersion())), LOBYTE(HIWORD(GetMSVideoVersion())), HIBYTE(LOWORD(GetMSVideoVersion())), LOBYTE(LOWORD(GetMSVideoVersion())) ));

    if (GetMSVideoVersion() < MSVIDEO_VERSION)
    {
        TCHAR achError[128];
        TCHAR ach[40];

        LoadString(ghModule, MCIAVI_BADMSVIDEOVERSION, achError, sizeof(achError)/sizeof(TCHAR));
        LoadString(ghModule, MCIAVI_PRODUCTNAME, ach, sizeof(ach)/sizeof(TCHAR));
	MessageBox(NULL,achError,ach,
#ifdef BIDI
		MB_RTL_READING |
#endif
	MB_OK|MB_SYSTEMMODAL|MB_ICONEXCLAMATION);

        return MCIERR_DRIVER_INTERNAL;
    }

#ifndef WIN32
#pragma message("Support passing in MMIOHANDLEs with OPEN_ELEMENT_ID?")
#endif

    if (lpOpen->lpstrElementName == NULL) {
	// they're doing an "open new".

	// !!! handle this, probably by not actually reading a file.
	// ack.
    }

    /* Be sure we have a real, non-empty filename, not an id. */
    if ((!(dwFlags & MCI_OPEN_ELEMENT))
	    || (lpOpen->lpstrElementName == NULL)
	    || (*(lpOpen->lpstrElementName) == '\0'))
        return MCIERR_UNSUPPORTED_FUNCTION;

    // Allocate an instance data block. Code ASSUMES Zero Init.

    if (!(npMCI = (NPMCIGRAPHIC) LocalAlloc(LPTR, sizeof (MCIGRAPHIC))))
        return MCIERR_OUT_OF_MEMORY;

#ifdef WIN32
    // init the per-device critsec
    InitializeCriticalSection(&npMCI->CritSec);
    npMCI->lCritRefCount = 0;

#endif

    // now hold the critical section for the rest of the open
    EnterCrit(npMCI);
#ifdef DEBUG
    npMCI->mciid = MCIID;
#endif

    //
    // add this device to our list
    //
    npMCI->npMCINext = npMCIList;
    npMCIList = npMCI;

    npMCI->wMessageCurrent = MCI_OPEN;

    // Allocate some space for the filename
    // Copy the filename into the data block
    dwRet = FixFileName(npMCI, lpOpen->lpstrElementName);
    if (dwRet != 0L) {
	// note we hold the critical section into GraphicClose, and
	// release it just before deleting it within GraphicClose. This is
	// because we need to hold it during the call to DeviceClose.
	GraphicClose(npMCI);
	return dwRet;
    }
	
    // Create the default window - the caller may
    // supply style and parent window.

    if (dwFlags & MCI_DGV_OPEN_PARENT)
        hWndParent = lpOpen->hWndParent;
    else
        hWndParent = NULL;

    if (dwFlags & MCI_DGV_OPEN_WS) {
        // CW_USEDEFAULT can't be used with popups or children so
        // if the user provides the style, default to full-screen.

        dwStyle = lpOpen->dwStyle;
	hWnd =

        // Note:  The CreateWindow/Ex call is written this way as on Win32
        // CreateWindow is a MACRO, and hence the call must be contained
        // within the preprocessor block.
#ifdef BIDI
	CreateWindowEx(WS_EX_BIDI_SCROLL |  WS_EX_BIDI_MENU |WS_EX_BIDI_NOICON,
            szClassName,
            FileName(npMCI->szFilename),
            dwStyle,
            0, 0,
            GetSystemMetrics (SM_CXSCREEN),
            GetSystemMetrics (SM_CYSCREEN),
            hWndParent,
            NULL, ghModule, (LPTSTR)npMCI);
#else
	CreateWindow(
            szClassName,
            FileName(npMCI->szFilename),
            dwStyle,
            0, 0,
            GetSystemMetrics (SM_CXSCREEN),
            GetSystemMetrics (SM_CYSCREEN),
            hWndParent,
            NULL, ghModule, (LPTSTR)npMCI);
#endif
    } else {
        dwStyle = WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX |
                  WS_SYSMENU | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
        if (GetProfileInt("mciavi", "CreateVisible", 0)) {
            DPF0(("Creating the window visible\n"));
            dwStyle |= WS_VISIBLE;
        } else {
            DPF0(("Creating the window INvisible\n"));
        }
	hWnd =
#ifdef BIDI
	CreateWindowEx(WS_EX_BIDI_SCROLL |  WS_EX_BIDI_MENU |WS_EX_BIDI_NOICON,
	    szClassName,
	    FileName(npMCI->szFilename),
            dwStyle,
	    CW_USEDEFAULT, 0,
	    CW_USEDEFAULT, 0,
            hWndParent,
            NULL, ghModule, (LPTSTR)npMCI);
#else
	CreateWindow(
	    szClassName,
	    FileName(npMCI->szFilename),
            dwStyle,
	    CW_USEDEFAULT, 0,
	    CW_USEDEFAULT, 0,
            hWndParent,
            NULL, ghModule, (LPTSTR)npMCI);
#endif
    }

    if (!hWnd) {
	// see above - we release and delete the critsec within GraphicClose
        DPF0(("Failed to create the window\n"));
        GraphicClose(npMCI);
        return MCIERR_CREATEWINDOW;
    }

    /* Fill in some more of the instance data.
    ** The rest of the fields are filled in in DeviceOpen.
    */

    npMCI->hCallingTask = GetCurrentTask();
    npMCI->hCallback = NULL;
    npMCI->wDevID = wDeviceID;
    npMCI->hwndDefault = hWnd;
    npMCI->hwnd = hWnd;
    npMCI->dwTimeFormat = MCI_FORMAT_FRAMES;
    npMCI->dwSpeedFactor = 1000;
    npMCI->dwVolume = MAKELONG(500, 500);
    npMCI->lTo = 0L;
    npMCI->dwFlags = MCIAVI_PLAYAUDIO | MCIAVI_SHOWVIDEO;
    npMCI->dwOptionFlags = ReadConfigInfo() | MCIAVIO_STRETCHTOWINDOW;

    // perform device-specific initialization

    dwRet = DeviceOpen(npMCI, dwFlags);

    if (dwRet != 0) {
	// see above - we release and delete the critsec within GraphicClose
        GraphicClose(npMCI);
	return dwRet;
    }

    *lpnpMCI = npMCI;

    npMCI->wMessageCurrent = 0;

    LeaveCrit(npMCI);

    return 0L;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicLoad | This function supports the MCI_LOAD command.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the Load message.
 *
 * @parm LPMCI_DGV_LOAD_PARMS | lpLoad | Parameters for the LOAD message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/
DWORD NEAR PASCAL GraphicLoad(NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_LOAD_PARMS lpLoad)
{
#ifndef LOADACTUALLYWORKS
    return MCIERR_UNSUPPORTED_FUNCTION;
#else
    DWORD dw;

    if (!(dwFlags & MCI_LOAD_FILE))
	return MCIERR_MISSING_PARAMETER;

    dw = FixFileName(npMCI, lpLoad->lpfilename);

    if (dw)
	return dw;

    dw = DeviceLoad(npMCI);

    return dw;
#endif
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicSeek | This function sets the current frame. The
 *      device state after a seek is MCI_MODE_PAUSE
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the seek message.
 *
 * @parm LPMCI_DGV_SEEK_PARMS | lpSeek | Parameters for the seek message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicSeek (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_SEEK_PARMS lpSeek)
{
    LONG lTo;
    BOOL fTest = FALSE;
    /* Do some range checking then pass onto the device-specific routine. */

    if (dwFlags & MCI_TEST) {
	dwFlags &= ~(MCI_TEST);
	fTest = TRUE;
    }

    switch (dwFlags & (~(MCI_WAIT | MCI_NOTIFY))) {
        case MCI_TO:
	    lTo = ConvertToFrames(npMCI, lpSeek->dwTo);
            break;

        case MCI_SEEK_TO_START:
            lTo = 0;
            break;

        case MCI_SEEK_TO_END:
            lTo = npMCI->lFrames;
            break;

	case 0:
	    return MCIERR_MISSING_PARAMETER;

	default:
            if (dwFlags & ~(MCI_TO |
			    MCI_SEEK_TO_START |
			    MCI_SEEK_TO_END |
			    MCI_WAIT |
			    MCI_NOTIFY))
                return MCIERR_UNRECOGNIZED_KEYWORD;
	    else
                return MCIERR_FLAGS_NOT_COMPATIBLE;
	    break;
    }

    if (!IsWindow(npMCI->hwnd))
        return MCIERR_NO_WINDOW;

    if (lTo < 0 || lTo > npMCI->lFrames)
    	return MCIERR_OUTOFRANGE;

    if (fTest)
	return 0L;

    GraphicDelayedNotify (npMCI, MCI_NOTIFY_ABORTED);

    if (dwFlags & MCI_NOTIFY) {
        GraphicSaveCallback(npMCI, (HANDLE) (UINT)lpSeek->dwCallback);
    }

    /* Clear the 'repeat' flags */
    npMCI->dwFlags &= ~(MCIAVI_REPEATING);

    return DeviceSeek(npMCI, lTo, dwFlags);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicCue | This function gets the movie ready to play,
 *	but leaves it paused.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the cue message.
 *
 * @parm LPMCI_DGV_CUE_PARMS | lpCue | Parameters for the cue message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicCue(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_CUE_PARMS lpCue)
{
    LONG		lTo;
    DWORD		dwRet = 0L;

    if (dwFlags & MCI_DGV_CUE_INPUT)
        return MCIERR_UNSUPPORTED_FUNCTION;

    if (dwFlags & MCI_DGV_CUE_NOSHOW)
        return MCIERR_UNSUPPORTED_FUNCTION;

    if (dwFlags & MCI_TO) {
	lTo = ConvertToFrames(npMCI, lpCue->dwTo);

	if (lTo < 0L || lTo > npMCI->lFrames)
            return MCIERR_OUTOFRANGE;
    }

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
	return 0L;

    GraphicDelayedNotify(npMCI, MCI_NOTIFY_ABORTED);

    if (dwFlags & MCI_NOTIFY) {
        GraphicSaveCallback(npMCI, (HANDLE) (UINT)lpCue->dwCallback);
    }

    /* Clear the 'repeat' flags */
    npMCI->dwFlags &= ~(MCIAVI_REPEATING);

    /* Set up to play to end of file */
    npMCI->lTo = npMCI->lFrames;

    dwRet = DeviceCue(npMCI, lTo, dwFlags);

    return dwRet;
}

#ifndef WIN32
#ifdef EXPIRE
//
// return the current date....
//
//       dx = year
//       ah = month
//       al = day
//
#pragma optimize("", off)
DWORD DosGetDate(void)
{
    if (0)
	return 0;

    _asm {
        mov     ah,2ah
        int     21h
        mov     ax,dx
        mov     dx,cx
    }
}
#pragma optimize("", on)
#endif
#endif

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicPlay | This function starts playback of the movie. If
 *      the reverse flag is specified, the movie plays backwards. If the fast
 *      or slow flags are specified the movie plays faster or slower.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the play message.
 *
 * @parm LPMCI_DGV_PLAY_PARMS | lpPlay | Parameters for the play message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicPlay (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_PLAY_PARMS lpPlay )
{
    LONG		lTo, lFrom;
    DWORD		dwRet;
#ifdef EXPIRE
#pragma message("Remove the expiration code after Beta ships")
    if (DosGetDate() >= EXPIRE)
    {
        return MCIERR_AVI_EXPIRED;
    }
#endif

    if (!(dwFlags & (MCI_MCIAVI_PLAY_FULLSCREEN | MCI_MCIAVI_PLAY_WINDOW)) &&
		    (npMCI->dwOptionFlags & MCIAVIO_USEVGABYDEFAULT)) {
	if (npMCI->dwOptionFlags & MCIAVIO_ZOOMBY2)
	    dwFlags |= MCI_MCIAVI_PLAY_FULLBY2;
	else
	    dwFlags |= MCI_MCIAVI_PLAY_FULLSCREEN;
    }


    if (dwFlags & (MCI_MCIAVI_PLAY_FULLSCREEN | MCI_MCIAVI_PLAY_FULLBY2)) {
#if 0
        if (ghDISPDIB == NULL) {
            UINT w;

            w = SetErrorMode(SEM_NOOPENFILEERRORBOX);

#ifndef WIN32
            if ((ghDISPDIB = LoadLibrary(szDisplayDibLib)) > HINSTANCE_ERROR)
#else
            if ((ghDISPDIB = LoadLibrary(szDisplayDibLib)) != NULL)
#endif
            {
                (FARPROC)DisplayDibProc = GetProcAddress(ghDISPDIB, szDisplayDib);
                (FARPROC)DisplayDibExProc = GetProcAddress(ghDISPDIB, szDisplayDibEx);
            }
	    else
                ghDISPDIB = (HINSTANCE)-1;

            SetErrorMode(w);
	
            DPF(("ghDISPDIB=0x%04x, DisplayDibProc=0x%08lx\n", ghDISPDIB, DisplayDibProc));
	}
	if (DisplayDibProc == NULL)
	    return MCIERR_AVI_NODISPDIB;
#endif
    } else {
	if (!IsWindow(npMCI->hwnd))
	    return MCIERR_NO_WINDOW;
	
	npMCI->dwFlags |= MCIAVI_NEEDTOSHOW;
    }

    /* Range checks : 0 < 'from' <= 'to' <= last frame */

    if (dwFlags & MCI_TO) {
	lTo = ConvertToFrames(npMCI, lpPlay->dwTo);

        if (lTo < 0L || lTo > npMCI->lFrames)
            return MCIERR_OUTOFRANGE;
    } else if (dwFlags & MCI_DGV_PLAY_REVERSE)
	lTo = 0;
    else
        lTo = npMCI->lFrames;

    dwFlags |= MCI_TO;

    if (dwFlags & MCI_FROM) {
	lFrom = ConvertToFrames(npMCI, lpPlay->dwFrom);

        if (lFrom < 0L || lFrom > npMCI->lFrames)
	    return MCIERR_OUTOFRANGE;
    } else if (dwRet = DevicePosition(npMCI, &lFrom))
        return dwRet;

    /* check 'to' and 'from' relationship.  */
    if (lTo < lFrom)
	dwFlags |= MCI_DGV_PLAY_REVERSE;

    if ((lFrom < lTo) && (dwFlags & MCI_DGV_PLAY_REVERSE))
	return MCIERR_OUTOFRANGE;

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
	return 0L;

    /* We want any previous playing to be aborted if and only if a 'from'
    ** parameter is specified.  If only a new 'to' parameter is specified,
    ** we can just change the 'to' value, and play will stop at the
    ** proper time.
    */

    /* set the 'to' position after we've stopped, if we're stopping. */

    if (dwFlags & MCI_FROM) {
	/* If MCI_FROM flag is specified then reset the starting location */
	DeviceStop(npMCI, MCI_WAIT);
	npMCI->lFrom = lFrom;
    } else {
	/* We still set the "From" variable, so that we'll correctly
	** play from the current position.
	** !!! Should this be done instead by updating lFrom to be the
	** current position when playback ends?
	*/
	npMCI->lFrom = lFrom;
    }

    /* If we're changing the "to" position, abort any pending notify. */
    if (lTo != npMCI->lTo) {
	GraphicDelayedNotify (npMCI, MCI_NOTIFY_ABORTED);
    }

	
    /* Don't set up notify until here, so that the seek won't make it happen*/
    if (dwFlags & MCI_NOTIFY) {
        GraphicSaveCallback(npMCI, (HANDLE) (UINT)lpPlay->dwCallback);
    }

    /* Set up the 'repeat' flags */
    npMCI->dwFlags &= ~(MCIAVI_REPEATING);

    if (dwFlags & MCI_DGV_PLAY_REPEAT) {
	/* If from position isn't given, repeat from either the beginning or
	** end of file as appropriate.
	*/
	npMCI->lRepeatFrom =
	    (dwFlags & MCI_FROM) ? lFrom :
		((dwFlags & MCI_DGV_PLAY_REVERSE) ? npMCI->lFrames : 0);
    }

    /* Go ahead and actually play... */
    return DevicePlay(npMCI, lTo, dwFlags);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIWAVE
 *
 * @api DWORD | GraphicStep | This function steps through several frames
 *      of a movie. If the reverse flag is set, then the step is backwards.
 *      If the step count is not specified then it defaults to 1. If the
 *      step count plus the current position exceeds the movie length, the
 *      step is out of range.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the step message.
 *
 * @parm LPMCI_DGV_STEP_PARMS | lpStep | Parameters for the step message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicStep (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_STEP_PARMS lpStep)
{
    LONG	lFrameCur;
    LONG	lFrames;
    DWORD	dwRet;
    BOOL	fReverse;
    BOOL	fSeekExactOff;

    fReverse = (dwFlags & MCI_DGV_STEP_REVERSE) == MCI_DGV_STEP_REVERSE;

    // Default to 1 frame step if frame count is not specified

    if (dwFlags & MCI_DGV_STEP_FRAMES) {
	lFrames = (LONG) lpStep->dwFrames;
	
	if (fReverse) {
	    if (lFrames < 0)
		return MCIERR_FLAGS_NOT_COMPATIBLE;
	}
    } else
        lFrames = 1;


    lFrames = fReverse ? -lFrames : lFrames;

    /* stop before figuring out whether frame count is within range, */
    /* unless the TEST flag is set. */

    if (!(dwFlags & MCI_TEST)) {
	if (dwRet = DeviceStop(npMCI, MCI_WAIT))
	    return dwRet;
    }

    if (dwRet = DevicePosition(npMCI, &lFrameCur))
        return dwRet;

    if ((lFrames + lFrameCur > npMCI->lFrames) ||
		(lFrames + lFrameCur < 0))
        return MCIERR_OUTOFRANGE;

    if (!IsWindow(npMCI->hwnd))
        return MCIERR_NO_WINDOW;

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
	return 0L;

    GraphicDelayedNotify (npMCI, MCI_NOTIFY_ABORTED);

    /* Clear the 'repeat' flags */
    npMCI->dwFlags &= ~(MCIAVI_REPEATING);


    if (dwFlags & MCI_NOTIFY) {
        GraphicSaveCallback(npMCI, (HANDLE) (UINT)lpStep->dwCallback);
    }

    fSeekExactOff = (npMCI->dwOptionFlags & MCIAVIO_SEEKEXACT) == 0;

    npMCI->dwOptionFlags |= MCIAVIO_SEEKEXACT;

    npMCI->dwFlags |= MCIAVI_NEEDTOSHOW;

    if (fSeekExactOff) {
	/* If we were not in seek exact mode, make seek finish
	** before we turn seek exact back off.
	*/
	dwRet = DeviceSeek(npMCI, lFrames + lFrameCur, dwFlags | MCI_WAIT);
	npMCI->dwOptionFlags &= ~(MCIAVIO_SEEKEXACT);
    } else
	dwRet = DeviceSeek(npMCI, lFrames + lFrameCur, dwFlags);

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicStop | This function stops playback of the movie.
 *      After a stop the state will be MCI_MODE_STOP. The frame counter
 *	is not reset.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the stop message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicStop (NPMCIGRAPHIC npMCI, DWORD dwFlags,
					LPMCI_GENERIC_PARMS lpParms)
{
    if (!IsWindow(npMCI->hwnd))
        return MCIERR_NO_WINDOW;

    if (dwFlags & MCI_DGV_STOP_HOLD)
	return MCIERR_UNSUPPORTED_FUNCTION;

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
	return 0L;

    GraphicDelayedNotify (npMCI, MCI_NOTIFY_ABORTED);

    /* Do we need to handle notify here? */
    return DeviceStop(npMCI, dwFlags);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicPause | Pauses movie playback.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicPause(NPMCIGRAPHIC npMCI, DWORD dwFlags,
					LPMCI_GENERIC_PARMS lpParms)
{
    if (!IsWindow(npMCI->hwnd))
        return MCIERR_NO_WINDOW;

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
	return 0L;

    if (dwFlags & MCI_NOTIFY) {
        GraphicSaveCallback(npMCI, (HANDLE) (UINT)lpParms->dwCallback);
    }

    return DevicePause(npMCI, dwFlags);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicResume | This function resumes playback of a paused
 *      movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicResume (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_GENERIC_PARMS lpParms)
{
    DWORD	dwRet;
    UINT	wMode;

    //  Resume is only allowed if MCIAVI is paused or playing

    wMode = DeviceMode(npMCI);

    if (wMode != MCI_MODE_PAUSE && wMode != MCI_MODE_PLAY)
        return MCIERR_NONAPPLICABLE_FUNCTION;

    if (!IsWindow(npMCI->hwnd))
        return MCIERR_NO_WINDOW;

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
	return 0L;

    if (dwFlags & MCI_NOTIFY) {
	GraphicSaveCallback(npMCI, (HANDLE) (UINT)lpParms->dwCallback);
    }

    dwRet = DeviceResume(npMCI, dwFlags & MCI_WAIT);

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicStatus | This function returns numeric status info.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the status message.
 *
 * @parm LPMCI_STATUS_PARMS | lpPlay | Parameters for the status message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicStatus (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_STATUS_PARMS lpStatus)
{
    DWORD dwRet = 0L;

    if (dwFlags & (MCI_DGV_STATUS_DISKSPACE))
	return MCIERR_UNSUPPORTED_FUNCTION;

    if (dwFlags & MCI_STATUS_ITEM) {

        lpStatus->dwReturn = 0L;

        if ((dwFlags & MCI_TRACK) &&
		!((lpStatus->dwItem == MCI_STATUS_POSITION) ||
			(lpStatus->dwItem == MCI_STATUS_LENGTH)))
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        if ((dwFlags & MCI_STATUS_START) &&
			(lpStatus->dwItem != MCI_STATUS_POSITION))
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        if (dwFlags & MCI_DGV_STATUS_REFERENCE)
            return MCIERR_FLAGS_NOT_COMPATIBLE;
	
        switch (lpStatus->dwItem) {
            case MCI_STATUS_POSITION:
	
                if (dwFlags & MCI_TRACK) {
                    /* POSITION with TRACK means return the start of the  */
                    /* track. */

                    if (lpStatus->dwTrack != 1)
	                dwRet = MCIERR_OUTOFRANGE;
	            else
                        /* return start frame of track (always 0) */
                        lpStatus->dwReturn = 0L;
		} else if (dwFlags & MCI_STATUS_START)
                    // POSITION with START means return the starting playable
                    // position of the media.
                    lpStatus->dwReturn = 0L;
                else {
		    /* Otherwise return current frame */
		    dwRet = DevicePosition(npMCI, (LPLONG) &lpStatus->dwReturn);
		    lpStatus->dwReturn = ConvertFromFrames(npMCI,
						(LONG) lpStatus->dwReturn);
		}
                break;

            case MCI_STATUS_LENGTH:


                if (dwFlags & MCI_TRACK && lpStatus->dwTrack != 1) {
                    /* LENGTH with TRACK means return the length of track */

                    lpStatus->dwReturn = 0L;
                    dwRet = MCIERR_OUTOFRANGE;
		}
		
		lpStatus->dwReturn = ConvertFromFrames(npMCI, npMCI->lFrames);
                break;

            case MCI_STATUS_NUMBER_OF_TRACKS:
            case MCI_STATUS_CURRENT_TRACK:

                lpStatus->dwReturn = 1L;
        	break;

            case MCI_STATUS_READY:

                /* Return TRUE if device can receive commands */
		if (DeviceMode(npMCI) != MCI_MODE_NOT_READY)
		    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
		else
		    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
        	dwRet = MCI_RESOURCE_RETURNED;
	        break;

            case MCI_STATUS_MODE:
	    {
		WORD	wMode;
                wMode = DeviceMode(npMCI);
		lpStatus->dwReturn = MAKEMCIRESOURCE(wMode, wMode);
                dwRet = MCI_RESOURCE_RETURNED;
	    }
                break;

	    case MCI_DGV_STATUS_PAUSE_MODE:
		if (DeviceMode(npMCI) != MCI_MODE_PAUSE)
		    dwRet = MCIERR_NONAPPLICABLE_FUNCTION;
		else {
		    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_PLAY, MCI_MODE_PLAY);
		    dwRet = MCI_RESOURCE_RETURNED;
		}
		break;
		
            case MCI_STATUS_MEDIA_PRESENT:

                lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
        	dwRet = MCI_RESOURCE_RETURNED;
	        break;

            case MCI_DGV_STATUS_FORWARD:
		if (npMCI->dwFlags & MCIAVI_REVERSE)
		    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
		else
		    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
        	dwRet = MCI_RESOURCE_RETURNED;
	        break;

            case MCI_DGV_STATUS_HWND:
	
                lpStatus->dwReturn = (DWORD)(UINT)npMCI->hwnd;
                if (!IsWindow(npMCI->hwnd))
                    dwRet = MCIERR_NO_WINDOW;
	        break;

            case MCI_DGV_STATUS_HPAL:

//		lpStatus->dwReturn = (DWORD) (UINT) DrawDibGetPalette(npMCI->hdd);

		lpStatus->dwReturn = 0;
		
                if (npMCI->nVideoStreams == 0) {
		    dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                } else {
		    dwRet = ICSendMessage(npMCI->hicDraw, ICM_DRAW_GET_PALETTE, 0, 0);
		
		    if (dwRet == ICERR_UNSUPPORTED) {
			dwRet = MCIERR_UNSUPPORTED_FUNCTION;
		    } else {
			lpStatus->dwReturn = dwRet;
			dwRet = 0;
		    }
		}
		DPF2(("Status HPAL returns: %lu\n", lpStatus->dwReturn));
                break;

            case MCI_STATUS_TIME_FORMAT:

                lpStatus->dwReturn = MAKEMCIRESOURCE(npMCI->dwTimeFormat,
				npMCI->dwTimeFormat + MCI_FORMAT_RETURN_BASE);
        	dwRet = MCI_RESOURCE_RETURNED;
	        break;
		
	    case MCI_DGV_STATUS_AUDIO:
                lpStatus->dwReturn = (npMCI->dwFlags & MCIAVI_PLAYAUDIO) ?
					(MAKEMCIRESOURCE(MCI_ON, MCI_ON_S)) :
					(MAKEMCIRESOURCE(MCI_OFF, MCI_OFF_S));
		dwRet = MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER;
		break;

	    case MCI_DGV_STATUS_WINDOW_VISIBLE:
		if (npMCI->hwnd && IsWindowVisible(npMCI->hwnd))
		    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
		else
		    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
        	dwRet = MCI_RESOURCE_RETURNED;
	        break;

	    case MCI_DGV_STATUS_WINDOW_MINIMIZED:
		if (npMCI->hwnd && IsIconic(npMCI->hwnd))
		    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
		else
		    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
        	dwRet = MCI_RESOURCE_RETURNED;
	        break;

	    case MCI_DGV_STATUS_WINDOW_MAXIMIZED:
		if (npMCI->hwnd && IsZoomed(npMCI->hwnd))
		    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
		else
		    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
        	dwRet = MCI_RESOURCE_RETURNED;
	        break;

	    case MCI_DGV_STATUS_SAMPLESPERSEC:
	    case MCI_DGV_STATUS_AVGBYTESPERSEC:
	    case MCI_DGV_STATUS_BLOCKALIGN:
	    case MCI_DGV_STATUS_BITSPERSAMPLE:
		dwRet = MCIERR_UNSUPPORTED_FUNCTION;
		break;
		
            case MCI_DGV_STATUS_BITSPERPEL:
                if (npMCI->psiVideo)
                    lpStatus->dwReturn = ((LPBITMAPINFOHEADER)npMCI->psiVideo->lpFormat)->biBitCount;
                else
                    dwRet = MCIERR_UNSUPPORTED_FUNCTION;
		break;
		
#ifndef WIN32
#pragma message("Are we going to support brightness/color/contrast/tint?")
#endif
	    case MCI_DGV_STATUS_BRIGHTNESS:
	    case MCI_DGV_STATUS_COLOR:
	    case MCI_DGV_STATUS_CONTRAST:
	    case MCI_DGV_STATUS_TINT:
	    case MCI_DGV_STATUS_GAMMA:
	    case MCI_DGV_STATUS_SHARPNESS:
	    case MCI_DGV_STATUS_FILE_MODE:
	    case MCI_DGV_STATUS_FILE_COMPLETION:
	    case MCI_DGV_STATUS_KEY_INDEX:
	    case MCI_DGV_STATUS_KEY_COLOR:
		dwRet = MCIERR_UNSUPPORTED_FUNCTION;
		break;
		
	    case MCI_DGV_STATUS_FILEFORMAT:
// Fall through to Unsupported case...
//                lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_DGV_FF_AVI,
//						MCI_DGV_FF_AVI);
//		dwRet = MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER;
//		break;
//		
	    case MCI_DGV_STATUS_BASS:
	    case MCI_DGV_STATUS_TREBLE:
		dwRet = MCIERR_UNSUPPORTED_FUNCTION;
		break;
		
	    case MCI_DGV_STATUS_VOLUME:
	    {
		WORD	wLeftVolume, wRightVolume;
		// Be sure volume is up to date....
		DeviceGetVolume(npMCI);

		wLeftVolume = LOWORD(npMCI->dwVolume);
		wRightVolume = LOWORD(npMCI->dwVolume);

		switch (dwFlags & (MCI_DGV_STATUS_LEFT | MCI_DGV_STATUS_RIGHT)) {
		    case MCI_DGV_STATUS_LEFT:
			lpStatus->dwReturn = (DWORD) wLeftVolume;
		    break;
		
		    case 0:
			lpStatus->dwReturn = (DWORD) wRightVolume;
		    break;
		
		    default:
			lpStatus->dwReturn = ((DWORD) wLeftVolume + (DWORD) wRightVolume) / 2;
		    break;
		}
	    }
		break;

	    case MCI_DGV_STATUS_MONITOR:
                lpStatus->dwReturn = (DWORD)
				     MAKEMCIRESOURCE(MCI_DGV_MONITOR_FILE,
						MCI_DGV_FILE_S);
		dwRet = MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER;
		break;

	    case MCI_DGV_STATUS_SEEK_EXACTLY:
                lpStatus->dwReturn =
				(npMCI->dwOptionFlags & MCIAVIO_SEEKEXACT) ?
					(MAKEMCIRESOURCE(MCI_ON, MCI_ON_S)) :
					(MAKEMCIRESOURCE(MCI_OFF, MCI_OFF_S));
		dwRet = MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER;
		break;
		
	    case MCI_DGV_STATUS_SIZE:
		/* We haven't reserved any space, so return zero. */
		lpStatus->dwReturn = 0L;
		break;
		
	    case MCI_DGV_STATUS_SMPTE:
		dwRet = MCIERR_UNSUPPORTED_FUNCTION;
		break;

	    case MCI_DGV_STATUS_UNSAVED:
		lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
		dwRet = MCI_RESOURCE_RETURNED;
		break;
		
	    case MCI_DGV_STATUS_VIDEO:
                lpStatus->dwReturn = (npMCI->dwFlags & MCIAVI_SHOWVIDEO) ?
					(MAKEMCIRESOURCE(MCI_ON, MCI_ON_S)) :
					(MAKEMCIRESOURCE(MCI_OFF, MCI_OFF_S));
        	dwRet = MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER;
		break;
		
	    case MCI_DGV_STATUS_SPEED:
		lpStatus->dwReturn = npMCI->dwSpeedFactor;
		break;
		
	    case MCI_DGV_STATUS_FRAME_RATE:
	    {
		DWORD	dwTemp;

		dwTemp = npMCI->dwMicroSecPerFrame;
		
		/* If they haven't specifically asked for the "nominal"
		** rate of play, adjust by the current speed.
		*/
		if (!(dwFlags & MCI_DGV_STATUS_NOMINAL))
		    dwTemp = muldiv32(dwTemp, 1000L, npMCI->dwSpeedFactor);
		
		if (dwTemp == 0)
		    lpStatus->dwReturn = 1000;
		else
		    /* Our return value is in "thousandths of frames/sec",
		    ** and dwTemp is the number of microseconds per frame.
		    ** Thus, we divide a billion microseconds by dwTemp.
		    */
		    lpStatus->dwReturn = muldiv32(1000000L, 1000L, dwTemp);
		break;
	    }

	    case MCI_DGV_STATUS_AUDIO_STREAM:
		lpStatus->dwReturn = 0;
                if (npMCI->nAudioStreams) {
		    int	stream;

		    for (stream = 0; stream < npMCI->streams; stream++) {
			if (SH(stream).fccType == streamtypeAUDIO)
			    ++lpStatus->dwReturn;

			if (stream == npMCI->nAudioStream)
			    break;
		    }
		}
		break;
		
	    case MCI_DGV_STATUS_VIDEO_STREAM:
	    case MCI_DGV_STATUS_AUDIO_INPUT:
	    case MCI_DGV_STATUS_AUDIO_RECORD:
	    case MCI_DGV_STATUS_AUDIO_SOURCE:
	    case MCI_DGV_STATUS_VIDEO_RECORD:
	    case MCI_DGV_STATUS_VIDEO_SOURCE:
	    case MCI_DGV_STATUS_VIDEO_SRC_NUM:
	    case MCI_DGV_STATUS_MONITOR_METHOD:
	    case MCI_DGV_STATUS_STILL_FILEFORMAT:
		dwRet = MCIERR_UNSUPPORTED_FUNCTION;
		break;
		
	    case MCI_AVI_STATUS_FRAMES_SKIPPED:
                lpStatus->dwReturn = npMCI->lSkippedFrames;
		break;
		
	    case MCI_AVI_STATUS_AUDIO_BREAKS:
                lpStatus->dwReturn = npMCI->lAudioBreaks;
		break;
		
	    case MCI_AVI_STATUS_LAST_PLAY_SPEED:
		lpStatus->dwReturn = npMCI->dwSpeedPercentage;
		break;
		
            default:
                dwRet = MCIERR_UNSUPPORTED_FUNCTION;
        	break;
        } /* end switch (item) */
    } else if (dwFlags & MCI_DGV_STATUS_REFERENCE) {

	if (lpStatus->dwReference > (DWORD) npMCI->lFrames)
            dwRet = MCIERR_OUTOFRANGE;

        else if (npMCI->psiVideo) {
            lpStatus->dwReference = MovieToStream(npMCI->psiVideo,
                    lpStatus->dwReference);

            lpStatus->dwReturn = FindPrevKeyFrame(npMCI, npMCI->psiVideo,
                    lpStatus->dwReference);

            lpStatus->dwReturn = StreamToMovie(npMCI->psiVideo,
                    lpStatus->dwReturn);
        }
        else {
            lpStatus->dwReturn = 0;
        }
    } else /* item flag not set */
        dwRet = MCIERR_MISSING_PARAMETER;

    if ((dwFlags & MCI_TEST) && (LOWORD(dwRet) == 0)) {
	/* There is no error, but the test flag is on.  Return as little
	** as possible.
	*/
	dwRet = 0;
	lpStatus->dwReturn = 0;
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicInfo | This function returns alphanumeric information.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the info. message.
 *
 * @parm LPMCI_INFO_PARMS | lpPlay | Parameters for the info message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicInfo(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_INFO_PARMS lpInfo)
{
    DWORD	dwRet = 0L;
    TCHAR	ch = TEXT('\0');
    BOOL	fTest = FALSE;

    if (!lpInfo->lpstrReturn)
    	return MCIERR_PARAM_OVERFLOW;

    if (dwFlags & MCI_TEST)
	fTest = TRUE;

    dwFlags &= ~(MCI_WAIT | MCI_NOTIFY | MCI_TEST);

    switch (dwFlags) {
    case 0L:
	return MCIERR_MISSING_PARAMETER;
	
    case MCI_INFO_FILE:
	if (!npMCI)
	    return MCIERR_UNSUPPORTED_FUNCTION;
	
	if (lpInfo->dwRetSize < (DWORD)(lstrlen(npMCI->szFilename) + 1)) {
            ch = npMCI->szFilename[lpInfo->dwRetSize];
            npMCI->szFilename[lpInfo->dwRetSize] = '\0';
            dwRet = MCIERR_PARAM_OVERFLOW;
	}
        lstrcpy (lpInfo->lpstrReturn, npMCI->szFilename);
        if (ch)
            npMCI->szFilename[lpInfo->dwRetSize] = ch;
	break;
	
    case MCI_INFO_PRODUCT:

#ifdef DEBUG
        #include "..\verinfo\usa\verinfo.h"

        wsprintf(lpInfo->lpstrReturn,
            TEXT("VfW %d.%02d.%02d"), MMVERSION, MMREVISION, MMRELEASE);
#else
        /* !!! Not returning PARAM_OVERFLOW here but I am above - lazy eh */
        LoadString(ghModule, MCIAVI_PRODUCTNAME, lpInfo->lpstrReturn,
                (UINT)lpInfo->dwRetSize);
#endif
	break;

    case MCI_DGV_INFO_TEXT:
	if (!npMCI)
	    return MCIERR_UNSUPPORTED_FUNCTION;
	
     	if (IsWindow(npMCI->hwnd))
            GetWindowText(npMCI->hwnd, lpInfo->lpstrReturn,
					LOWORD(lpInfo->dwRetSize));
        else
            dwRet = MCIERR_NO_WINDOW;
	break;

    case MCI_INFO_VERSION:
	/* !!! Not returning PARAM_OVERFLOW here but I am above - lazy eh */
	LoadString(ghModule, MCIAVI_VERSION, lpInfo->lpstrReturn,
		(UINT)lpInfo->dwRetSize);
	break;

	case MCI_DGV_INFO_USAGE:
	    dwRet = MCIERR_UNSUPPORTED_FUNCTION;
	    break;

    case MCI_DGV_INFO_ITEM:
	switch (lpInfo->dwItem) {	
	case MCI_DGV_INFO_AUDIO_QUALITY:
	case MCI_DGV_INFO_VIDEO_QUALITY:
	case MCI_DGV_INFO_STILL_QUALITY:
	case MCI_DGV_INFO_AUDIO_ALG:
	case MCI_DGV_INFO_VIDEO_ALG:
	case MCI_DGV_INFO_STILL_ALG:
	default:
	    dwRet = MCIERR_UNSUPPORTED_FUNCTION;
	    break;
	}
	break;

    default:
    	dwRet = MCIERR_FLAGS_NOT_COMPATIBLE;
	break;
    }

    if (fTest && (LOWORD(dwRet) == 0)) {
	/* There is no error, but the test flag is on.  Return as little
	** as possible.
	*/
	dwRet = 0;
	if (lpInfo->dwRetSize)
	    lpInfo->lpstrReturn[0] = '\0';
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicSet | This function sets various options.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the set message.
 *
 * @parm LPMCI_SET_PARMS | lpSet | Parameters for the set message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicSet (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_SET_PARMS lpSet)
{
    DWORD	dwRet = 0L;
    DWORD	dwAction;

    if (dwFlags & MCI_DGV_SET_FILEFORMAT)
        return MCIERR_UNSUPPORTED_FUNCTION;

    if (dwFlags & MCI_DGV_SET_STILL)
        return MCIERR_UNSUPPORTED_FUNCTION;

    dwAction = dwFlags & (MCI_SET_TIME_FORMAT		|
                         MCI_SET_VIDEO			|
                         MCI_SET_AUDIO			|
			 MCI_DGV_SET_SEEK_EXACTLY	|
			 MCI_DGV_SET_SPEED
			     );
    dwFlags &= 	(MCI_SET_ON				|
                         MCI_SET_OFF			|
			 MCI_TEST
			     );

    /* First, check if the parameters are all okay */

    if (!dwAction)
        return MCIERR_UNSUPPORTED_FUNCTION;

    if (dwAction & MCI_SET_TIME_FORMAT) {
        if (lpSet->dwTimeFormat != MCI_FORMAT_FRAMES
		&& lpSet->dwTimeFormat != MCI_FORMAT_MILLISECONDS)
            return MCIERR_UNSUPPORTED_FUNCTION;
    }

    if ((dwAction & MCI_SET_AUDIO) &&
		(lpSet->dwAudio != MCI_SET_AUDIO_ALL)) {
        return MCIERR_UNSUPPORTED_FUNCTION;
    }

    if (dwAction & MCI_DGV_SET_SPEED) {
	if (lpSet->dwSpeed > 100000L)
	    return MCIERR_OUTOFRANGE;
    }

    switch (dwFlags & (MCI_SET_ON | MCI_SET_OFF)) {
	case 0:
	    if (dwAction & (MCI_SET_AUDIO |
				MCI_SET_VIDEO |
				MCI_DGV_SET_SEEK_EXACTLY))
		return MCIERR_MISSING_PARAMETER;
	    break;

	case MCI_SET_ON | MCI_SET_OFF:
	    return MCIERR_FLAGS_NOT_COMPATIBLE;

	default:
	    if (dwAction & (MCI_DGV_SET_SPEED | MCI_SET_TIME_FORMAT))
		return MCIERR_FLAGS_NOT_COMPATIBLE;
	    break;
    }

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
	return 0L;

    /* Now, actually carry out the command */
    if (dwAction & MCI_SET_TIME_FORMAT)
	npMCI->dwTimeFormat = lpSet->dwTimeFormat;

    if (dwAction & MCI_SET_VIDEO) {
	npMCI->dwFlags &= ~(MCIAVI_SHOWVIDEO);
	if (dwFlags & MCI_SET_ON) {
	    npMCI->dwFlags |= MCIAVI_SHOWVIDEO;
	    InvalidateRect(npMCI->hwnd, NULL, FALSE);
	}
    }

    if (dwAction & MCI_DGV_SET_SEEK_EXACTLY) {
	npMCI->dwOptionFlags &= ~(MCIAVIO_SEEKEXACT);
	if (dwFlags & MCI_SET_ON)
	    npMCI->dwOptionFlags |= MCIAVIO_SEEKEXACT;
    }

    if (dwAction & MCI_DGV_SET_SPEED) {
	dwRet = DeviceSetSpeed(npMCI, lpSet->dwSpeed);
    }

    if (dwRet == 0L && (dwAction & MCI_SET_AUDIO)) {
	dwRet = DeviceMute(npMCI, dwFlags & MCI_SET_OFF ? TRUE : FALSE);
    }
	
    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicSetAudio | This function sets various audio options.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the set audio message.
 *
 * @parm LPMCI_SET_PARMS | lpSet | Parameters for the set audio message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/
DWORD NEAR PASCAL GraphicSetAudio (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_SETAUDIO_PARMS lpSet)
{
    DWORD	dwRet = 0L;

    if (npMCI->nAudioStreams == 0) {
	return MCIERR_UNSUPPORTED_FUNCTION;
    }

    if ((dwFlags & MCI_DGV_SETAUDIO_ITEM) &&
	    (lpSet->dwItem == MCI_DGV_SETAUDIO_VOLUME) &&
	    (dwFlags & MCI_DGV_SETAUDIO_VALUE)) {
	WORD	wLeft, wRight;
	
	if (dwFlags & (MCI_DGV_SETAUDIO_ALG |
        	   MCI_DGV_SETAUDIO_QUALITY |
        	   MCI_DGV_SETAUDIO_RECORD |
        	   MCI_DGV_SETAUDIO_CLOCKTIME))
	    return MCIERR_UNSUPPORTED_FUNCTION;
        if (lpSet->dwValue > 1000L)
	    return MCIERR_OUTOFRANGE;
    	if (dwFlags & MCI_TEST)
	    return 0L;

	// Be sure volume is up to date....
	DeviceGetVolume(npMCI);
	
	wLeft = LOWORD(npMCI->dwVolume);
	wRight = HIWORD(npMCI->dwVolume);
	if (!(dwFlags & MCI_DGV_SETAUDIO_RIGHT))
	    wLeft = (WORD) lpSet->dwValue;
	
	if (!(dwFlags & MCI_DGV_SETAUDIO_LEFT))
	    wRight = (WORD) lpSet->dwValue;
	
	dwRet = DeviceSetVolume(npMCI, MAKELONG(wLeft, wRight));
    } else if ((dwFlags & MCI_DGV_SETAUDIO_ITEM) &&
	    (lpSet->dwItem == MCI_DGV_SETAUDIO_STREAM) &&
	    (dwFlags & MCI_DGV_SETAUDIO_VALUE)) {
	if (dwFlags & (MCI_DGV_SETAUDIO_ALG |
        	   MCI_DGV_SETAUDIO_QUALITY |
        	   MCI_DGV_SETAUDIO_RECORD |
        	   MCI_DGV_SETAUDIO_LEFT |
        	   MCI_DGV_SETAUDIO_CLOCKTIME |
        	   MCI_DGV_SETAUDIO_RIGHT))
	    return MCIERR_UNSUPPORTED_FUNCTION;
	if (lpSet->dwValue > (DWORD) npMCI->nAudioStreams || lpSet->dwValue == 0)
	    return MCIERR_OUTOFRANGE;
    	if (dwFlags & MCI_TEST)
	    return 0L;
	dwRet = DeviceSetAudioStream(npMCI, (WORD) lpSet->dwValue);
    } else if (dwFlags & (MCI_DGV_SETAUDIO_ITEM |
		   MCI_DGV_SETAUDIO_VALUE |
		   MCI_DGV_SETAUDIO_ALG |
        	   MCI_DGV_SETAUDIO_QUALITY |
        	   MCI_DGV_SETAUDIO_RECORD |
        	   MCI_DGV_SETAUDIO_LEFT |
        	   MCI_DGV_SETAUDIO_CLOCKTIME |
        	   MCI_DGV_SETAUDIO_RIGHT))
	return MCIERR_UNSUPPORTED_FUNCTION;

    switch (dwFlags & (MCI_SET_ON | MCI_SET_OFF)) {
    case MCI_SET_ON:
	if (!(dwFlags & MCI_TEST))
	    dwRet = DeviceMute(npMCI, FALSE);
	break;
    case MCI_SET_OFF:
	if (!(dwFlags & MCI_TEST))
	    dwRet = DeviceMute(npMCI, TRUE);
	break;
    case MCI_SET_ON | MCI_SET_OFF:
	dwRet = MCIERR_FLAGS_NOT_COMPATIBLE;
	break;

    default:
	if (!(dwFlags & MCI_DGV_SETAUDIO_ITEM))
	    dwRet = MCIERR_MISSING_PARAMETER;
	break;
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicSetVideo | This function sets various Video options.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the set video message.
 *
 * @parm LPMCI_SET_PARMS | lpSet | Parameters for the set video message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/
DWORD NEAR PASCAL GraphicSetVideo (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_SETVIDEO_PARMS lpSet)
{
    DWORD	dwRet = 0L;

    if (dwFlags & (MCI_DGV_SETVIDEO_OVER |
		    MCI_DGV_SETVIDEO_RECORD |
		    MCI_DGV_SETVIDEO_SRC_NUMBER |
		    MCI_DGV_SETVIDEO_QUALITY |
		    MCI_DGV_SETVIDEO_ALG |
		    MCI_DGV_SETVIDEO_STILL |
		    MCI_DGV_SETVIDEO_CLOCKTIME
			))
	return MCIERR_UNSUPPORTED_FUNCTION;

    if (dwFlags & MCI_DGV_SETVIDEO_ITEM) {
	switch (lpSet->dwItem) {
	    case MCI_DGV_SETVIDEO_PALHANDLE:
		if (dwFlags & MCI_DGV_SETVIDEO_VALUE) {
                    if (lpSet->dwValue &&
                        lpSet->dwValue != MCI_AVI_SETVIDEO_PALETTE_HALFTONE &&
#if 1
                        !IsGDIObject((HPALETTE) lpSet->dwValue))
#else
			GetObjectType((HPALETTE) lpSet->dwValue) != OBJ_PAL)
#endif
			return MCIERR_AVI_BADPALETTE;
		}
		
		if (!(dwFlags & MCI_TEST))
		    dwRet = DeviceSetPalette(npMCI,
				((dwFlags & MCI_DGV_SETVIDEO_VALUE) ?
					(HPALETTE) lpSet->dwValue : NULL));
                break;

            case MCI_DGV_SETVIDEO_STREAM:

                if (!(dwFlags & MCI_DGV_SETVIDEO_VALUE))
                    return MCIERR_UNSUPPORTED_FUNCTION;

                if (lpSet->dwValue == 0 ||
                    lpSet->dwValue > (DWORD)npMCI->nVideoStreams + npMCI->nOtherStreams)
                    return MCIERR_OUTOFRANGE;

                if (dwFlags & MCI_SET_ON)
                    DPF(("SetVideoStream to #%d on\n", (int)lpSet->dwValue));
                else if (dwFlags & MCI_SET_OFF)
                    DPF(("SetVideoStream to #%d off\n", (int)lpSet->dwValue));
                else
                    DPF(("SetVideoStream to #%d\n", (int)lpSet->dwValue));
		
                if (!(dwFlags & MCI_TEST)) {
                    dwRet = DeviceSetVideoStream(npMCI, (UINT)lpSet->dwValue,
                          !(dwFlags & MCI_SET_OFF));
                }
                break;
		
            case MCI_AVI_SETVIDEO_DRAW_PROCEDURE:

		if (DeviceMode(npMCI) != MCI_MODE_STOP)
                    return MCIERR_UNSUPPORTED_FUNCTION;
		
		if (npMCI->hicDrawDefault) {
		    if (npMCI->hicDrawDefault != (HIC) -1)
			ICClose(npMCI->hicDrawDefault);
		    npMCI->hicDrawDefault = 0;
		    npMCI->dwFlags &= ~(MCIAVI_USERDRAWPROC);
		}

                if (lpSet->dwValue) {

                    if (IsBadCodePtr((FARPROC) lpSet->dwValue)) {
                        DPF(("Bad code pointer!!!!\n"));
                        return MCIERR_OUTOFRANGE; //!!!MCIERR_BAD_PARAM;
                    }

                    npMCI->hicDrawDefault = ICOpenFunction(streamtypeVIDEO,
                        FOURCC_AVIDraw,ICMODE_DRAW,(FARPROC) lpSet->dwValue);

		    if (!npMCI->hicDrawDefault) {
			return MCIERR_INTERNAL;
		    }
		    DPF(("Successfully set new draw procedure....\n"));

		    npMCI->dwFlags |= MCIAVI_USERDRAWPROC;
                }

		npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
		InvalidateRect(npMCI->hwnd, NULL, FALSE);
		return 0;
		
	    default:
		dwRet = MCIERR_UNSUPPORTED_FUNCTION;
		break;
	}
    } else if (dwFlags & (MCI_SET_ON | MCI_SET_OFF)) {
	switch (dwFlags & (MCI_SET_ON | MCI_SET_OFF)) {
	case MCI_SET_ON:
	    if (!(dwFlags & MCI_TEST)) {
		InvalidateRect(npMCI->hwnd, NULL, FALSE);
		npMCI->dwFlags |= MCIAVI_SHOWVIDEO;
	    }
	    break;
	case MCI_SET_OFF:
	    if (!(dwFlags & MCI_TEST))
		npMCI->dwFlags &= ~(MCIAVI_SHOWVIDEO);
	    break;
	case MCI_SET_ON | MCI_SET_OFF:
	    dwRet = MCIERR_FLAGS_NOT_COMPATIBLE;
	    break;
	}
    } else
	dwRet = MCIERR_MISSING_PARAMETER;

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicSignal | This function sets signals.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the set PositionAdvise message.
 *
 * @parm LPMCI_SIGNAL_PARMS | lpSignal | Parameters for the signal
 *	message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/
DWORD NEAR PASCAL GraphicSignal(NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_SIGNAL_PARMS lpSignal)
{
    DWORD	dwRet = 0L;
    DWORD	dwUser;
    DWORD	dwPosition;
    DWORD	dwPeriod;

    dwUser = (dwFlags & MCI_DGV_SIGNAL_USERVAL) ? lpSignal->dwUserParm : 0L;

    if (dwFlags & MCI_DGV_SIGNAL_CANCEL) {
	if (dwFlags & (MCI_DGV_SIGNAL_AT |
	    	       MCI_DGV_SIGNAL_EVERY |
	    	       MCI_DGV_SIGNAL_POSITION))
	    return MCIERR_FLAGS_NOT_COMPATIBLE;

	if (!npMCI->dwSignals)
	    return MCIERR_NONAPPLICABLE_FUNCTION;

	if (dwUser && (npMCI->signal.dwUserParm != dwUser))
	    return MCIERR_NONAPPLICABLE_FUNCTION;

	if (!(dwFlags & MCI_TEST))
	    --npMCI->dwSignals;
    } else {
	if ((npMCI->dwSignals != 0) && (dwUser != npMCI->signal.dwUserParm)) {
	    /* !!! Should we allow more than one signal? */
	    return MCIERR_DGV_DEVICE_LIMIT;
	}

	if (dwFlags & MCI_DGV_SIGNAL_AT) {
	    /* Use position passed in */
	    dwPosition = ConvertToFrames(npMCI, lpSignal->dwPosition);
	    if (dwPosition > (DWORD) npMCI->lFrames)
		return MCIERR_OUTOFRANGE;
	} else {
	    /* Get current position */
	    DevicePosition(npMCI, (LPLONG) &dwPosition);
	}

	if (dwFlags & MCI_DGV_SIGNAL_EVERY) {
	    dwPeriod = (DWORD) ConvertToFrames(npMCI, lpSignal->dwPeriod);
	
	    if (dwPeriod == 0 || (dwPeriod > (DWORD) npMCI->lFrames))
		return MCIERR_OUTOFRANGE;
	} else {
	    /* It's a one-time signal */
	    dwPeriod = 0L;
	}

	if (dwFlags & MCI_TEST)
	    return 0;

	npMCI->signal.dwPosition = dwPosition;
	npMCI->signal.dwPeriod = dwPeriod;	
	npMCI->signal.dwUserParm = dwUser;
	npMCI->signal.dwCallback = lpSignal->dwCallback;
	npMCI->dwSignalFlags = dwFlags;

	/* The signal isn't really activated until we do this. */
	if (!npMCI->dwSignals)
	    ++npMCI->dwSignals;
    }
	
    return 0L;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicList | This function supports the MCI_LIST command.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the List message.
 *
 * @parm LPMCI_DGV_LIST_PARMS | lpList | Parameters for the list message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/
DWORD NEAR PASCAL GraphicList(NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_LIST_PARMS lpList)
{
    return MCIERR_UNSUPPORTED_FUNCTION;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicGetDevCaps | This function returns  device
 *      capabilities
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the GetDevCaps message.
 *
 * @parm LPMCI_GETDEVCAPS_PARMS | lpCaps | Parameters for the GetDevCaps
 *      message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicGetDevCaps (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_GETDEVCAPS_PARMS lpCaps )
{

    DWORD dwRet = 0L;


    if (dwFlags & MCI_GETDEVCAPS_ITEM)
        {

        switch (lpCaps->dwItem)
            {
            case MCI_GETDEVCAPS_CAN_RECORD:
            case MCI_GETDEVCAPS_CAN_EJECT:
            case MCI_GETDEVCAPS_CAN_SAVE:
            case MCI_DGV_GETDEVCAPS_CAN_LOCK:
            case MCI_DGV_GETDEVCAPS_CAN_STR_IN:
            case MCI_DGV_GETDEVCAPS_CAN_FREEZE:
            case MCI_DGV_GETDEVCAPS_HAS_STILL:
		
                lpCaps->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_DGV_GETDEVCAPS_CAN_REVERSE:
            case MCI_GETDEVCAPS_CAN_PLAY:
            case MCI_GETDEVCAPS_HAS_AUDIO:
            case MCI_GETDEVCAPS_HAS_VIDEO:
            case MCI_GETDEVCAPS_USES_FILES:
            case MCI_GETDEVCAPS_COMPOUND_DEVICE:
            case MCI_DGV_GETDEVCAPS_PALETTES:
            case MCI_DGV_GETDEVCAPS_CAN_STRETCH:
            case MCI_DGV_GETDEVCAPS_CAN_TEST:
                lpCaps->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_GETDEVCAPS_DEVICE_TYPE:

                lpCaps->dwReturn = MAKEMCIRESOURCE(MCI_DEVTYPE_DIGITAL_VIDEO,
					    MCI_DEVTYPE_DIGITAL_VIDEO);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

	    case MCI_DGV_GETDEVCAPS_MAX_WINDOWS:
	    case MCI_DGV_GETDEVCAPS_MAXIMUM_RATE:
	    case MCI_DGV_GETDEVCAPS_MINIMUM_RATE:
            default:

                dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                break;
            }
        }
    else
        dwRet = MCIERR_MISSING_PARAMETER;

    if ((dwFlags & MCI_TEST) && (LOWORD(dwRet) == 0)) {
	/* There is no error, but the test flag is on.  Return as little
	** as possible.
	*/
	dwRet = 0;
	lpCaps->dwReturn = 0;
    }

    return (dwRet);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicWindow | This function controls the stage window
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the window message.
 *
 * @parm LPMCI_DGV_WINDOW_PARMS | lpPlay | Parameters for the window message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicWindow (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_WINDOW_PARMS lpWindow)
{
    DWORD   dwRet = 0L;
    int	    i = 0;
    HWND    hWndNew;

    if (dwFlags & MCI_DGV_WINDOW_HWND) {
        // Set a new stage window. If the parameter is NULL, then
        // use the default window. Otherwise, hide the default
        // window and use the given window handle.

        if (!lpWindow->hWnd)
            hWndNew = npMCI->hwndDefault;
        else
            hWndNew = lpWindow->hWnd;

        if (!IsWindow(hWndNew))
            return MCIERR_NO_WINDOW;

	/* If the test flag is set, return without doing anything. */
	/* Question: do we have to check for more possible errors? */
	if (dwFlags & MCI_TEST)
	    return 0L;

        // only change if the new window handle is different from the current
        // stage window handle

        if (hWndNew != npMCI->hwnd) {
            dwRet = DeviceSetWindow(npMCI, hWndNew);

            if (npMCI->hwnd != npMCI->hwndDefault &&
				    IsWindow(npMCI->hwndDefault))
                ShowWindow(npMCI->hwndDefault, SW_HIDE);
	}
    }

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
	return dwRet;

    if (!dwRet) {
        if (IsWindow(npMCI->hwnd)) {
            if (dwFlags & MCI_DGV_WINDOW_STATE)
                ShowWindow (npMCI->hwnd, lpWindow->nCmdShow);

            if (dwFlags & MCI_DGV_WINDOW_TEXT)
                SetWindowText(npMCI->hwnd, lpWindow->lpstrText);
	} else
	    dwRet = MCIERR_NO_WINDOW;
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicPut | This function sets the offset and extent
 *      of the animation within the client area of the stage window.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the put message.
 *
 * @parm LPMCI_DGV_RECT_PARMS | lpDestination | Parameters for the
 *      destination message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicPut ( NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_RECT_PARMS lpParms)
{
    BOOL	frc;
    RECT	rc;

    if (dwFlags & (MCI_DGV_PUT_FRAME | MCI_DGV_PUT_VIDEO))
	return MCIERR_UNSUPPORTED_FUNCTION;

    frc = (dwFlags & MCI_DGV_RECT) == MCI_DGV_RECT;

    if (!IsWindow(npMCI->hwnd))
	return MCIERR_NO_WINDOW;

    switch (dwFlags & (MCI_DGV_PUT_SOURCE | MCI_DGV_PUT_DESTINATION |
			    MCI_DGV_PUT_WINDOW)) {
	case 0L:
	    return MCIERR_MISSING_PARAMETER;
	
	case MCI_DGV_PUT_SOURCE:
	    // If a rectangle is supplied, use it.
	    if (frc) {
		rc.left = lpParms->ptOffset.x;
		rc.top = lpParms->ptOffset.y;
		rc.right = lpParms->ptOffset.x + lpParms->ptExtent.x;
		rc.bottom = lpParms->ptOffset.y + lpParms->ptExtent.y;
		
		if (lpParms->ptExtent.x <= 0) {
		    rc.right = rc.left + (npMCI->rcDest.right - npMCI->rcDest.left);
		}
		if (lpParms->ptExtent.y <= 0) {
		    rc.bottom = rc.top + (npMCI->rcDest.bottom - npMCI->rcDest.top);
		}		
	    } else {
		/* Reset to default */
                rc = npMCI->rcMovie;
	    }
	    break;
	
	case MCI_DGV_PUT_DESTINATION:
	    // If a rectangle is supplied, use it.
	    if (frc) {
		rc.left = lpParms->ptOffset.x;
		rc.top = lpParms->ptOffset.y;
		rc.right = lpParms->ptOffset.x + lpParms->ptExtent.x;
		rc.bottom = lpParms->ptOffset.y + lpParms->ptExtent.y;
		
		if (lpParms->ptExtent.x <= 0) {
		    rc.right = rc.left + (npMCI->rcDest.right - npMCI->rcDest.left);
		}
		if (lpParms->ptExtent.y <= 0) {
		    rc.bottom = rc.top + (npMCI->rcDest.bottom - npMCI->rcDest.top);
		}
		
	    } else {
		/* Reset to size of stage window */
		GetClientRect(npMCI->hwnd, &rc);
	    }
	    break;
	
	case MCI_DGV_PUT_WINDOW:
	    if (dwFlags & MCI_TEST)
		return 0L;

	    // De-minimize their window, so we don't end up with
	    // a giant icon....
	    if (IsIconic(npMCI->hwnd))
		ShowWindow(npMCI->hwnd, SW_RESTORE);
	
	    // If a rectangle is supplied, use it.
	    if (frc) {
		RECT	rcOld;
		
		rc.left = lpParms->ptOffset.x;
		rc.right = lpParms->ptOffset.x + lpParms->ptExtent.x;
		rc.top = lpParms->ptOffset.y;
		rc.bottom = lpParms->ptOffset.y + lpParms->ptExtent.y;
		if (dwFlags & MCI_DGV_PUT_CLIENT) {
		    AdjustWindowRect(&rc,
				    GetWindowLong(npMCI->hwnd, GWL_STYLE),
				    FALSE);
		}

		// Default to just moving if width, height == 0....
		GetWindowRect(npMCI->hwnd, &rcOld);
		if (lpParms->ptExtent.x <= 0) {
		    rc.right = rc.left + (rcOld.right - rcOld.left);
		}
		if (lpParms->ptExtent.y <= 0) {
		    rc.bottom = rc.top + (rcOld.bottom - rcOld.top);
		}
		
		MoveWindow(npMCI->hwnd,
			    rc.left, rc.top,
			    rc.right - rc.left, rc.bottom - rc.top, TRUE);
	    } else {
		// !!! What should we do if there's no rectangle?
		
		/* Reset to "natural" size? */
                rc = npMCI->rcMovie;
		
		if (npMCI->dwOptionFlags & MCIAVIO_ZOOMBY2)
		    SetRect(&rc, 0, 0, rc.right*2, rc.bottom*2);
		
		AdjustWindowRect(&rc, GetWindowLong(npMCI->hwnd, GWL_STYLE),
					    FALSE);

		SetWindowPos(npMCI->hwnd, NULL, 0, 0,
				rc.right - rc.left, rc.bottom - rc.top,
				SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
	    }

	    // Premiere 1.0 depends on the window always being visible
	    // after a PUT_WINDOW command.  Make it so.
	    ShowWindow(npMCI->hwnd, SW_RESTORE);
	    return 0L;
	
	default:
	    return MCIERR_FLAGS_NOT_COMPATIBLE;
    }

    if (dwFlags & MCI_DGV_PUT_CLIENT)
	return MCIERR_FLAGS_NOT_COMPATIBLE;
	
    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
	return 0L;

    return DevicePut(npMCI, &rc, dwFlags);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicWhere | This function returns the current
 *	source and destination rectangles, in offset/extent form.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the query source message.
 *
 * @parm LPMCI_DGV_RECT_PARMS | lpParms | Parameters for the message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicWhere(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_RECT_PARMS lpParms)
{
    RECT	rc;

    if (dwFlags & (MCI_DGV_WHERE_FRAME | MCI_DGV_WHERE_VIDEO))
	return MCIERR_UNSUPPORTED_FUNCTION;

    // !!! WHERE_WINDOW?
	
    switch (dwFlags & (MCI_DGV_WHERE_SOURCE | MCI_DGV_WHERE_DESTINATION |
			    MCI_DGV_WHERE_WINDOW)) {
	case 0L:
	    return MCIERR_MISSING_PARAMETER;
	
	case MCI_DGV_WHERE_SOURCE:
	    if (dwFlags & MCI_DGV_WHERE_MAX) {
                lpParms->ptOffset.x = npMCI->rcMovie.left;
                lpParms->ptOffset.y = npMCI->rcMovie.top;
                lpParms->ptExtent.x = npMCI->rcMovie.right - npMCI->rcMovie.left;
                lpParms->ptExtent.y = npMCI->rcMovie.bottom - npMCI->rcMovie.top;
	    } else {
		lpParms->ptOffset.x = npMCI->rcSource.left;
		lpParms->ptOffset.y = npMCI->rcSource.top;
                lpParms->ptExtent.x = npMCI->rcSource.right  - npMCI->rcSource.left;
                lpParms->ptExtent.y = npMCI->rcSource.bottom - npMCI->rcSource.top;
	    }
	    break;
	
	case MCI_DGV_WHERE_DESTINATION:
	    if (dwFlags & MCI_DGV_WHERE_MAX) {
		/* Return size of window */
		GetClientRect(npMCI->hwnd, &rc);
		lpParms->ptOffset.x = 0;
		lpParms->ptOffset.y = 0;
		lpParms->ptExtent.x = rc.right;
		lpParms->ptExtent.y = rc.bottom;
	    } else {
		/* Return current destination size */
		lpParms->ptOffset.x = npMCI->rcDest.left;
		lpParms->ptOffset.y = npMCI->rcDest.top;
		lpParms->ptExtent.x = npMCI->rcDest.right - npMCI->rcDest.left;
		lpParms->ptExtent.y = npMCI->rcDest.bottom - npMCI->rcDest.top;
	    }
	    break;
	
	case MCI_DGV_WHERE_WINDOW:
	    if (dwFlags & MCI_DGV_WHERE_MAX) {
		/* Return maximum size of window */
		GetClientRect(npMCI->hwnd, &rc);
		lpParms->ptOffset.x = 0;
		lpParms->ptOffset.y = 0;
		lpParms->ptExtent.x = GetSystemMetrics(SM_CXSCREEN);
		lpParms->ptExtent.y = GetSystemMetrics(SM_CYSCREEN);
	    } else {
		/* Return size of window */
		GetWindowRect(npMCI->hwnd, &rc);
		lpParms->ptOffset.x = rc.left;
		lpParms->ptOffset.y = rc.top;
		lpParms->ptExtent.x = rc.right - rc.left;
		lpParms->ptExtent.y = rc.bottom - rc.top;
	    }
	    break;

	default:
	    return MCIERR_FLAGS_NOT_COMPATIBLE;
    }

    return 0L;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicRealize | This function realizes the current palette
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicRealize(NPMCIGRAPHIC npMCI, DWORD dwFlags)
{
    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
        return 0L;

    npMCI->fForceBackground = (dwFlags & MCI_DGV_REALIZE_BKGD) != 0;

    return DeviceRealize(npMCI);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicUpdate | This function refreshes the current frame.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the message.
 *
 * @parm LPMCI_DGV_UPDATE_PARMS | lpParms | Parameters for the message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicUpdate(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_UPDATE_PARMS lpParms)
{
    RECT    rc;

    rc.left   = lpParms->ptOffset.x;
    rc.top    = lpParms->ptOffset.y;
    rc.right  = lpParms->ptOffset.x + lpParms->ptExtent.x;
    rc.bottom = lpParms->ptOffset.y + lpParms->ptExtent.y;

    if (!(dwFlags & MCI_DGV_UPDATE_HDC)) {
	InvalidateRect(npMCI->hwnd, (dwFlags & MCI_DGV_RECT) ? &rc : NULL, TRUE);
	UpdateWindow(npMCI->hwnd);
        return 0;
    }

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
	return 0L;

    /* It's ok to pass a NULL rect to DeviceUpdate() */

#ifndef WIN32
#pragma message("!!! Fix update parms!")
#endif
    return DeviceUpdate (npMCI, dwFlags, lpParms->hDC, (dwFlags & MCI_DGV_RECT) ? &rc : NULL);
}

DWORD FAR PASCAL GraphicConfig(NPMCIGRAPHIC npMCI, DWORD dwFlags)
{
    DWORD dwOptions = npMCI->dwOptionFlags;

    if (!(dwFlags & MCI_TEST)) {
        gfEvil++;
        if (ConfigDialog(NULL, npMCI)) {

#ifdef DEBUG
            //
            // in DEBUG always reset the dest rect because the user may
            // have played with the DEBUG DrawDib options and we will
            // need to call DrawDibBegin() again.
            //
            if (TRUE) {
#else
            if ((npMCI->dwOptionFlags & (MCIAVIO_STUPIDMODE|MCIAVIO_ZOOMBY2))
                        != (dwOptions & (MCIAVIO_STUPIDMODE|MCIAVIO_ZOOMBY2)) ) {
#endif

		npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
                SetWindowToDefaultSize(npMCI);
                SetRectEmpty(&npMCI->rcDest); //This will force a change!
                ResetDestRect(npMCI);
            }
        }
        else {
            npMCI->dwOptionFlags = dwOptions;
        }
        gfEvil--;
    }

    return 0L;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | mciSpecial | This function handles all the MCI
 *      commands that don't require instance data such as open.
 *
 * @parm UINT | wDeviceID | The MCI device ID
 *
 * @parm UINT | wMessage | The requested action to be performed.
 *
 * @parm DWORD | dwFlags | Flags for the message.
 *
 * @parm DWORD | lpParms | Parameters for this message.
 *
 * @rdesc Error Constant. 0L on success
 *
 ***************************************************************************/

DWORD NEAR PASCAL mciSpecial (UINT wDeviceID, UINT wMessage, DWORD dwFlags, LPMCI_GENERIC_PARMS lpParms)
{
    NPMCIGRAPHIC npMCI = 0L;
    DWORD dwRet;

    /* since there in no instance block, there is no saved notification */
    /* to abort. */

    switch (wMessage) {
	case MCI_OPEN_DRIVER:
            if (dwFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))
                dwRet = GraphicOpen (&npMCI, dwFlags,
			    (LPMCI_DGV_OPEN_PARMS) lpParms, wDeviceID);
            else
                dwRet = 0L;

            mciSetDriverData (wDeviceID, (UINT)npMCI);
            break;

        case MCI_GETDEVCAPS:
            dwRet = GraphicGetDevCaps(NULL, dwFlags,
			    (LPMCI_GETDEVCAPS_PARMS)lpParms);
            break;

        case MCI_CONFIGURE:

            if (!(dwFlags & MCI_TEST))
                ConfigDialog(NULL, NULL);

	    dwRet = 0L;
	    break;

        case MCI_INFO:
            dwRet = GraphicInfo(NULL, dwFlags, (LPMCI_DGV_INFO_PARMS)lpParms);
            break;

        case MCI_CLOSE_DRIVER:
            dwRet = 0L;
            break;

        default:
            dwRet = MCIERR_UNSUPPORTED_FUNCTION;
            break;
    }

    GraphicImmediateNotify (wDeviceID, lpParms, dwFlags, dwRet);
    return (dwRet);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | mciDriverEntry | This function is the MCI handler
 *
 * @parm UINT | wDeviceID | The MCI device ID
 *
 * @parm UINT | wMessage | The requested action to be performed.
 *
 * @parm DWORD | dwFlags | Flags for the message.
 *
 * @parm DWORD | lpParms | Parameters for this message.
 *
 * @rdesc Error Constant. 0L on success
 *
 ***************************************************************************/

DWORD PASCAL mciDriverEntry (UINT wDeviceID, UINT wMessage, DWORD dwFlags, LPMCI_GENERIC_PARMS lpParms)
{
    NPMCIGRAPHIC npMCI = 0L;
    DWORD dwRet = MCIERR_UNRECOGNIZED_COMMAND;
    BOOL fDelayed = FALSE;
    BOOL fNested = FALSE;

    /* All current commands require a parameter block. */

    if (!lpParms && (dwFlags & MCI_NOTIFY))
        return (MCIERR_MISSING_PARAMETER);

    npMCI = (NPMCIGRAPHIC) (UINT)mciGetDriverData(wDeviceID);

    if (!npMCI)
        return mciSpecial(wDeviceID, wMessage, dwFlags, lpParms);

    /*
     * grab this device's critical section
     */
    EnterCrit(npMCI);


    if (npMCI->wMessageCurrent) {
	fNested = TRUE;
	
	if (wMessage != MCI_STATUS && wMessage != MCI_GETDEVCAPS &&
		    wMessage != MCI_INFO) {
	    DPF(("Warning!!!!!\n"));
	    DPF(("Warning!!!!!     MCIAVI reentered: received %x while processing %x\n", wMessage, npMCI->wMessageCurrent));
	    DPF(("Warning!!!!!\n"));
	    DPF(("Warning!!!!!\n"));
//	    Assert(0);
//	    LeaveCrit(npMCI);
//	    return MCIERR_DEVICE_NOT_READY;
	}
    } else	
	npMCI->wMessageCurrent = wMessage;

    switch (wMessage) {

	case MCI_CLOSE_DRIVER:

            /* Closing the driver causes any currently saved notifications */
            /* to abort. */

            GraphicDelayedNotify(npMCI, MCI_NOTIFY_ABORTED);

	    // note that GraphicClose will release and delete the critsec
 	    dwRet = GraphicClose(npMCI);

            mciSetDriverData(wDeviceID, 0L);
	
	    npMCI = NULL;
	    break;

    	case MCI_PLAY:
	
            dwRet = GraphicPlay(npMCI, dwFlags, (LPMCI_PLAY_PARMS)lpParms);
	    fDelayed = TRUE;
            break;

    	case MCI_CUE:
	
            dwRet = GraphicCue(npMCI, dwFlags, (LPMCI_DGV_CUE_PARMS)lpParms);
	    fDelayed = TRUE;
            break;

	case MCI_STEP:

            dwRet = GraphicStep(npMCI, dwFlags, (LPMCI_DGV_STEP_PARMS)lpParms);
	    fDelayed = TRUE;
	    break;
	
	case MCI_STOP:

            dwRet = GraphicStop(npMCI, dwFlags, lpParms);
            break;

	case MCI_SEEK:

            dwRet = GraphicSeek (npMCI, dwFlags, (LPMCI_SEEK_PARMS)lpParms);
	    fDelayed = TRUE;
            break;

	case MCI_PAUSE:

            dwRet = GraphicPause(npMCI, dwFlags, lpParms);
	    fDelayed = TRUE;
            break;

        case MCI_RESUME:

            dwRet = GraphicResume(npMCI, dwFlags, lpParms);
	    fDelayed = TRUE;
            break;

        case MCI_SET:

            dwRet = GraphicSet(npMCI, dwFlags,
				(LPMCI_DGV_SET_PARMS)lpParms);
	    break;

	case MCI_STATUS:

            dwRet = GraphicStatus(npMCI, dwFlags,
				(LPMCI_DGV_STATUS_PARMS)lpParms);
	    break;

	case MCI_INFO:

 	    dwRet = GraphicInfo (npMCI, dwFlags, (LPMCI_DGV_INFO_PARMS)lpParms);
	    break;

        case MCI_GETDEVCAPS:

            dwRet = GraphicGetDevCaps(npMCI, dwFlags, (LPMCI_GETDEVCAPS_PARMS)lpParms);
	    break;

        case MCI_REALIZE:

            dwRet = GraphicRealize(npMCI, dwFlags);
            break;

        case MCI_UPDATE:

            dwRet = GraphicUpdate(npMCI, dwFlags, (LPMCI_DGV_UPDATE_PARMS)lpParms);
            break;

	case MCI_WINDOW:
 	
            dwRet = GraphicWindow(npMCI, dwFlags, (LPMCI_DGV_WINDOW_PARMS)lpParms);
	    break;

        case MCI_PUT:

 	    dwRet = GraphicPut(npMCI, dwFlags, (LPMCI_DGV_RECT_PARMS)lpParms);
            break;
	
        case MCI_WHERE:

            dwRet = GraphicWhere(npMCI, dwFlags, (LPMCI_DGV_RECT_PARMS)lpParms);
            break;
	
	case MCI_CONFIGURE:
	    dwRet = GraphicConfig(npMCI, dwFlags);
	    break;

	case MCI_SETAUDIO:
	    dwRet = GraphicSetAudio(npMCI, dwFlags,
			(LPMCI_DGV_SETAUDIO_PARMS) lpParms);
	    break;

	case MCI_SETVIDEO:
	    dwRet = GraphicSetVideo(npMCI, dwFlags,
			(LPMCI_DGV_SETVIDEO_PARMS) lpParms);
	    break;

	case MCI_SIGNAL:
	    dwRet = GraphicSignal(npMCI, dwFlags,
			(LPMCI_DGV_SIGNAL_PARMS) lpParms);
	    break;
	
	case MCI_LIST:
	    dwRet = GraphicList(npMCI, dwFlags,
			(LPMCI_DGV_LIST_PARMS) lpParms);
	    break;

        case MCI_LOAD:
	    dwRet = GraphicLoad(npMCI, dwFlags,
				  (LPMCI_DGV_LOAD_PARMS) lpParms);
	    break;
	    	
        case MCI_RECORD:
        case MCI_SAVE:
	
        case MCI_CUT:
        case MCI_COPY:
        case MCI_PASTE:
        case MCI_UNDO:
	
	case MCI_DELETE:
	case MCI_CAPTURE:
	case MCI_QUALITY:
	case MCI_MONITOR:
	case MCI_RESERVE:
	case MCI_FREEZE:
	case MCI_UNFREEZE:
            dwRet = MCIERR_UNSUPPORTED_FUNCTION;
            break;
	
	    /* Do we need this case? */
	default:
            dwRet = MCIERR_UNRECOGNIZED_COMMAND;
            break;
    }

    if (!fDelayed || (dwFlags & MCI_TEST)) {
	/* We haven't processed the notify yet. */
        if (npMCI && (dwFlags & MCI_NOTIFY) && (!LOWORD(dwRet)))
	    /* Throw away the old notify */
            GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUPERSEDED);

	/* And send the new one out immediately. */
        GraphicImmediateNotify(wDeviceID, lpParms, dwFlags, dwRet);
    }

    /* If there's an error, don't save the callback.... */
    if (fDelayed && dwRet != 0 && (dwFlags & MCI_NOTIFY))
	npMCI->hCallback = 0;

    //
    //  see if we need to tell the DRAW device about moving.
    //  MPlayer is sending the status and position command alot
    //  so this is a "timer"
    //
    //  !!!do we need to do it this often?
    //
    if (npMCI && (npMCI->dwFlags & MCIAVI_WANTMOVE))
	CheckWindowMove(npMCI, FALSE);

    if (npMCI && !fNested)
	npMCI->wMessageCurrent = 0;

    // free critical section for this device - if we haven't deleted it
    // GraphicClose may have released and deleted it if we were deleting
    // the device instance.
    if (npMCI) {
	LeaveCrit(npMCI);
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | ConvertToFrames | Convert from the current time format into
 *	frames.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwTime | Input time.
 *
 ***************************************************************************/
STATICFN LONG NEAR PASCAL ConvertToFrames(NPMCIGRAPHIC npMCI, DWORD dwTime)
{
    if (npMCI->dwTimeFormat == MCI_FORMAT_FRAMES) {
	return (LONG) dwTime;
    } else {
	if (npMCI->dwMicroSecPerFrame > 1000) {
	/* This needs to round down--muldiv32 likes to round off. */
	return (LONG) muldivrd32(dwTime, 1000L, npMCI->dwMicroSecPerFrame);
	} else {
	    return (LONG) muldivru32(dwTime, 1000L, npMCI->dwMicroSecPerFrame);
        }
    }
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | ConvertFromFrames | Convert from frames into the current
 *	time format.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm LONG | lFrame | Frame number to convert.
 *
 ***************************************************************************/
DWORD NEAR PASCAL ConvertFromFrames(NPMCIGRAPHIC npMCI, LONG lFrame)
{
    if (npMCI->dwTimeFormat == MCI_FORMAT_FRAMES) {
	return (DWORD)lFrame;
    } else {
	if (npMCI->dwMicroSecPerFrame > 1000)
	return muldivru32(lFrame, npMCI->dwMicroSecPerFrame, 1000L);
	else
	    return muldivrd32(lFrame, npMCI->dwMicroSecPerFrame, 1000L);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\mciavi.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *
**	Copyright (C) Microsoft Corporation 1991-1993. All rights reserved.
**
**	Title: mciavi.h - Multimedia Systems Media Control Interface
**	AVI driver external header file
**
**	Version:	1.00	
**
**	Date:		16-JUL-1992
**
**	Depends on MMSYSTEM.H and WINDOWS.h
*/

/************************************************************************/


/*
** These three flags apply to the 'play' command:
**	play <alias> window		Play in normal window
**	play <alias> fullscreen		Play in 320x240 full-screen mode
**	play <alias> fullscreen by 2	Play fullscreen, zoomed by 2
*/
#define MCI_MCIAVI_PLAY_WINDOW		0x01000000L
#define	MCI_MCIAVI_PLAY_FULLSCREEN	0x02000000L
#define MCI_MCIAVI_PLAY_FULLBY2		0x04000000L
/*
** Debugging constants for AVI diagnostics
*/
/* 
** Returns number of frames not drawn during last play.  If this number
** is more than a small fraction of the number of frames that should have
** been displayed, things aren't looking good.
*/
#define MCI_AVI_STATUS_FRAMES_SKIPPED		0x8001L
/*
** Returns a number representing how well the last AVI play worked.
** A result of 1000 indicates that the AVI sequence took the amount
** of time to play that it should have; a result of 2000, for instance,
** would indicate that a 5-second AVI sequence took 10 seconds to play,
** implying that the audio and video were badly broken up.
*/
#define MCI_AVI_STATUS_LAST_PLAY_SPEED		0x8002L
/*
** Returns the number of times that the audio definitely broke up.
** (We count one for every time we're about to write some audio data
** to the driver, and we notice that it's already played all of the
** data we have.
*/
#define MCI_AVI_STATUS_AUDIO_BREAKS		0x8003L


#define MCI_AVI_SETVIDEO_DRAW_PROCEDURE		0x8000L


/*
** This constant specifies that the "halftone" palette should be
** used, rather than the default palette.
*/
#define MCI_AVI_SETVIDEO_PALETTE_HALFTONE       0x0000FFFFL

/*
**	Custom error return values
*/
#define MCIERR_AVI_OLDAVIFORMAT		(MCIERR_CUSTOM_DRIVER_BASE + 100)
#define MCIERR_AVI_NOTINTERLEAVED	(MCIERR_CUSTOM_DRIVER_BASE + 101)
#define MCIERR_AVI_NODISPDIB		(MCIERR_CUSTOM_DRIVER_BASE + 102)
#define MCIERR_AVI_CANTPLAYFULLSCREEN	(MCIERR_CUSTOM_DRIVER_BASE + 103)
#define MCIERR_AVI_TOOBIGFORVGA		(MCIERR_CUSTOM_DRIVER_BASE + 104)
#define MCIERR_AVI_NOCOMPRESSOR         (MCIERR_CUSTOM_DRIVER_BASE + 105)
#define MCIERR_AVI_DISPLAYERROR         (MCIERR_CUSTOM_DRIVER_BASE + 106)
#define MCIERR_AVI_AUDIOERROR		(MCIERR_CUSTOM_DRIVER_BASE + 107)
#define MCIERR_AVI_BADPALETTE		(MCIERR_CUSTOM_DRIVER_BASE + 108)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\math.asm ===
page    ,132
;---------------------------Module-Header-------------------------------;
; Module Name: MATH.ASM
;
; Contains FIXED point math routines.
;
; Created:  Sun 30-Aug-1987 19:28:30
; Author: Charles Whitmer [chuckwh]
;
; Copyright (c) 1987  Microsoft Corporation
;-----------------------------------------------------------------------;

?WIN	= 0
?PLM	= 1
?NODATA = 0

        .286

        .xlist
        include cmacros.inc
        include windows.inc
        .list

        externA __WinFlags

UQUAD   struc
uq0     dw      ?
uq1     dw      ?
uq2     dw      ?
uq3     dw      ?
UQUAD	ends

;       The following two equates are just used as shorthand
;       for the "word ptr" and "byte ptr" overrides.

wptr    equ     word ptr
bptr    equ     byte ptr

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

EAXtoDXAX   macro
        shld    edx,eax,16      ; move HIWORD(eax) to dx
        endm

DXAXtoEAX   macro
        ror     eax,16          ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax,edx,16      ; move LOWORD(edx) to HIWORD(eax)
        endm

neg32       macro hi, lo
        neg lo
        adc hi,0                ; carry set unless lo zero
        neg hi
        endm

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
	assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; long muldiv32(long, long, long)
;
; multiples two 32 bit values and then divides the result by a third
; 32 bit value with full 64 bit presision
;
; lResult = (lNumber * lNumerator) / lDenominator with correct rounding
;
; Entry:
;       lNumber = number to multiply by nNumerator
;       lNumerator = number to multiply by nNumber
;       lDenominator = number to divide the multiplication result by.
;   
; Returns:
;       DX:AX = result of multiplication and division.
;
; Error Returns:
;       none
; Registers Preserved:
;       DS,ES,SI,DI
; History:
;   Fri 05-Oct-1990 -by- Rob Williams [Robwi] 
;   Behavior consistent with MulDiv16 routine (signed, no int 0 on overflow)
;   Stole muldiv16 psuedocode
;
;   Wed 14-June-1990 -by-  Todd Laney [ToddLa]
;   converted it to 386/286 code. (by checking __WinFlags)
;
;   Tue 08-May-1990 -by-  Rob Williams [Robwi]
;   Wrote it.
;
;----------------------------Pseudo-Code--------------------------------;
; long FAR PASCAL muldiv32(long, long, long)
; long l;
; long Numer;
; long Denom;
; {
;
;   Sign = sign of Denom;   // Sign will keep track of final sign //
;
;
;   if (Denom < 0)
;   {
;	negate Denom;	// make sure Denom is positive //
;   }
;
;   if (l < 0)
;   {
;	negate l;	// make sure l is positive //
;   }
;
;   make Sign reflect any sign change;
;
;
;   if (Numer < 0)
;   {
;	negate Numer;	// make sure Numer is positive //
;   }
;
;   make Sign reflect any sign change;
;
;   Numer *= l;
;   Numer += (Denom/2); // adjust for rounding //
;
;   if (overflow)   // check for overflow, and handle divide by zero //
;   {
;	jump to md5;
;   }
;
;   result = Numer/Denom;
;
;   if (overflow)   // check again to see if overflow occured //
;   {
;	jump to md5;
;   }
;
;   if (Sign is negative)   // put sign on the result //
;   {
;	negate result;
;   }
;
;md6:
;   return(result);
;
;md5:
;   DX = 7FFF;	    // indicate overflow by //
;   AX = 0xFFFF     // return largest integer //
;   if (Sign is negative)
;   {
;	DX = 0x8000;	// with correct sign //
;	AX = 0x0000;	
;   }
;
;   jump to md6;
; }
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   muldiv32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  lNumber
;       ParmD  lNumerator
;       ParmD  lDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jz      md32_1
        jmp     NEAR PTR muldiv32_286
md32_1:
        errn$   muldiv32_386
cEnd    <nogen>

cProc   muldiv32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
        ParmD   lNumber
        ParmD   lNumerator
        ParmD   lDenominator
cBegin
        .386


        mov     ebx,lDenominator    ; get the demoninator
        mov     ecx,ebx	            ; ECX holds the final sign in hiword
        or      ebx,ebx             ; ensure the denominator is positive
        jns     md386_1
        neg     ebx

md386_1:
        mov     eax,lNumber         ; get the long we are multiplying
        xor     ecx,eax	            ; make ECX reflect any sign change
        or      eax,eax             ; ensure the long is positive
        jns     md386_2
        neg     eax

md386_2:
        mov     edx,lNumerator      ; get the numerator
        xor     ecx,edx	            ; make ECX reflect any sign change
        or      edx,edx             ; ensure the numerator is positive
        jns     md386_3
        neg     edx

md386_3:
        mul     edx                 ; multiply
        mov     cx,bx               ; get half of the demoninator to adjust for rounding
        sar     ebx,1               
        add     eax,ebx             ; adjust for possible rounding error
        adc     edx,0               ; this is really a long addition
        sal     ebx,1               ; restore the demoninator
        or      bx,cx               ; fix bottom bit
        cmp     edx,ebx             ; check for overflow
        jae     md386_5                 ; (ae handles /0 case)
        div     ebx                 ; divide
        or      eax,eax             ; If sign is set, then overflow occured
        js      md386_5                 ; Overflow.
        or      ecx,ecx             ; put the sign on the result
        jns     md386_6
        neg     eax

md386_6:
        EAXtoDXAX                   ; convert eax to dx:ax for 16 bit programs

        .286
cEnd 
        .386

md386_5:
        mov     eax,7FFFFFFFh       ; return the largest integer
        or      ecx,ecx             ; with the correct sign
        jns     md386_6
        not     eax
        jmp     md386_6

        .286

cProc   muldiv32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  lNumber             
        ParmD  lNumerator
        ParmD  lDenominator
        LocalW wSign

cBegin

        mov     dx,lDenominator.hi      ; get the demoninator
        mov     si,dx	                ; SI holds the final sign 
        or      dx,dx                   ; ensure the denominator is positive
        jns     md286_1
        neg32   dx, lDenominator.lo
        mov     lDenominator.hi, dx


md286_1:
        mov     ax,lNumber.lo           ; get the long we are multiplying
        mov     dx,lNumber.hi           
        xor     si,dx	                ; make ECX reflect any sign change
        or      dx,dx                   ; ensure the long is positive
        jns     md286_2
        neg32   dx, ax

md286_2:
        mov     bx,lNumerator.lo        ; get the numerator
        mov     cx,lNumerator.hi        ; get the numerator
        xor     si,cx	                ; make ECX reflect any sign change
        or      cx,cx                   ; ensure the numerator is positive
        jns     md286_3
        neg32   cx, bx

md286_3:
        mov     wSign, si               ; save sign
        call    dmul                    ; multiply (result in dx:cx:bx:ax)
        mov     si, lDenominator.hi
        mov     di, lDenominator.lo
        sar     si, 1                   ; get half of the demoninator 
        rcr     di, 1                   ; to adjust for rounding
        add     ax, di                  ; adjust for possible rounding error
        adc     bx, si
        adc     cx, 0
        adc     dx, 0                   ; this is really a long addition

        sal     di, 1                   ; restore the demoninator
        rcl     si, 1

        or      di, lDenominator.lo     ; fix bottom bit

        cmp     dx, si                  ; begin overflow check (unsigned for div 0 check)
        ja      md286_5                 ; overflow
        jb      md286_7                 ; no overflow
        cmp     cx, di       
        jae     md286_5                 ; overflow

md286_7:
        call    qdiv                    ; DX:AX is quotient     
        or      dx,dx                   ; If sign is set, then overflow occured
        js      md286_5                 ; Overflow.
        mov     cx, wSign
        or      cx,cx                   ; put the sign on the result
        jns     md286_6
        neg32   dx,ax

md286_6:

cEnd

md286_5:
        mov     cx, wSign
        mov     ax, 0FFFFh              ; return the largest integer
        mov     dx, 7FFFh
        or      cx, cx                  ; with the correct sign
        jns     md286_6
        not     dx
        not     ax
        jmp     md286_6

cProc   muldivru32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  lNumber
;       ParmD  lNumerator
;       ParmD  lDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jz      mdru32_1
        jmp     NEAR PTR muldivru32_286
mdru32_1:
        errn$   muldivru32_386
cEnd    <nogen>

cProc   muldivru32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
        ParmD   lNumber
        ParmD   lNumerator
        ParmD   lDenominator
cBegin
        .386


        mov     ebx,lDenominator    ; get the demoninator
        mov     ecx,ebx	            ; ECX holds the final sign in hiword
        or      ebx,ebx             ; ensure the denominator is positive
        jns     mdru386_1
        neg     ebx

mdru386_1:
        mov     eax,lNumber         ; get the long we are multiplying
        xor     ecx,eax	            ; make ECX reflect any sign change
        or      eax,eax             ; ensure the long is positive
        jns     mdru386_2
        neg     eax

mdru386_2:
        mov     edx,lNumerator      ; get the numerator
        xor     ecx,edx	            ; make ECX reflect any sign change
        or      edx,edx             ; ensure the numerator is positive
        jns     mdru386_3
        neg     edx

mdru386_3:
        mul     edx                 ; multiply
        mov     cx,bx               ; get demoninator - 1 to adjust for rounding
        sub     ebx,1               
        add     eax,ebx             ; adjust for possible rounding error
        adc     edx,0               ; this is really a long addition
        add     ebx,1               ; restore the demoninator
        cmp     edx,ebx             ; check for overflow
        jae     mdru386_5                 ; (ae handles /0 case)
        div     ebx                 ; divide
        or      eax,eax             ; If sign is set, then overflow occured
        js      mdru386_5                 ; Overflow.
        or      ecx,ecx             ; put the sign on the result
        jns     mdru386_6
        neg     eax

mdru386_6:
        EAXtoDXAX                   ; convert eax to dx:ax for 16 bit programs

        .286
cEnd 
        .386

mdru386_5:
        mov     eax,7FFFFFFFh       ; return the largest integer
        or      ecx,ecx             ; with the correct sign
        jns     mdru386_6
        not     eax
        jmp     mdru386_6

        .286

cProc   muldivru32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  lNumber             
        ParmD  lNumerator
        ParmD  lDenominator
        LocalW wSign

cBegin

        mov     dx,lDenominator.hi      ; get the demoninator
        mov     si,dx	                ; SI holds the final sign 
        or      dx,dx                   ; ensure the denominator is positive
        jns     mdru286_1
        neg32   dx, lDenominator.lo
        mov     lDenominator.hi, dx


mdru286_1:
        mov     ax,lNumber.lo           ; get the long we are multiplying
        mov     dx,lNumber.hi           
        xor     si,dx	                ; make ECX reflect any sign change
        or      dx,dx                   ; ensure the long is positive
        jns     mdru286_2
        neg32   dx, ax

mdru286_2:
        mov     bx,lNumerator.lo        ; get the numerator
        mov     cx,lNumerator.hi        ; get the numerator
        xor     si,cx	                ; make ECX reflect any sign change
        or      cx,cx                   ; ensure the numerator is positive
        jns     mdru286_3
        neg32   cx, bx

mdru286_3:
        mov     wSign, si               ; save sign
        call    dmul                    ; multiply (result in dx:cx:bx:ax)
        mov     si, lDenominator.hi
        mov     di, lDenominator.lo
        sub     di, 1                   ; get demoninator - 1 
        sbb     si, 0                   ; to adjust for rounding
        add     ax, di                  ; adjust for possible rounding error
        adc     bx, si
        adc     cx, 0
        adc     dx, 0                   ; this is really a long addition

        add	di, 1                   ; restore the demoninator
        adc     si, 0

        cmp     dx, si                  ; begin overflow check (unsigned for div 0 check)
        ja      mdru286_5                 ; overflow
        jb      mdru286_7                 ; no overflow
        cmp     cx, di       
        jae     mdru286_5                 ; overflow

mdru286_7:
        call    qdiv                    ; DX:AX is quotient     
        or      dx,dx                   ; If sign is set, then overflow occured
        js      mdru286_5                 ; Overflow.
        mov     cx, wSign
        or      cx,cx                   ; put the sign on the result
        jns     mdru286_6
        neg32   dx,ax

mdru286_6:

cEnd

mdru286_5:
        mov     cx, wSign
        mov     ax, 0FFFFh              ; return the largest integer
        mov     dx, 7FFFh
        or      cx, cx                  ; with the correct sign
        jns     mdru286_6
        not     dx
        not     ax
        jmp     mdru286_6

cProc   muldivrd32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  lNumber
;       ParmD  lNumerator
;       ParmD  lDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jz      mdrd32_1
        jmp     NEAR PTR muldivrd32_286
mdrd32_1:
        errn$   muldivrd32_386
cEnd    <nogen>

cProc   muldivrd32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
        ParmD   lNumber
        ParmD   lNumerator
        ParmD   lDenominator
cBegin
        .386


        mov     ebx,lDenominator    ; get the demoninator
        mov     ecx,ebx	            ; ECX holds the final sign in hiword
        or      ebx,ebx             ; ensure the denominator is positive
        jns     mdrd386_1
        neg     ebx

mdrd386_1:
        mov     eax,lNumber         ; get the long we are multiplying
        xor     ecx,eax	            ; make ECX reflect any sign change
        or      eax,eax             ; ensure the long is positive
        jns     mdrd386_2
        neg     eax

mdrd386_2:
        mov     edx,lNumerator      ; get the numerator
        xor     ecx,edx	            ; make ECX reflect any sign change
        or      edx,edx             ; ensure the numerator is positive
        jns     mdrd386_3
        neg     edx

mdrd386_3:
        mul     edx                 ; multiply

        div     ebx                 ; divide
        or      eax,eax             ; If sign is set, then overflow occured
        js      mdrd386_5                 ; Overflow.
        or      ecx,ecx             ; put the sign on the result
        jns     mdrd386_6
        neg     eax

mdrd386_6:
        EAXtoDXAX                   ; convert eax to dx:ax for 16 bit programs

        .286
cEnd 
        .386

mdrd386_5:
        mov     eax,7FFFFFFFh       ; return the largest integer
        or      ecx,ecx             ; with the correct sign
        jns     mdrd386_6
        not     eax
        jmp     mdrd386_6

        .286

cProc   muldivrd32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  lNumber             
        ParmD  lNumerator
        ParmD  lDenominator
        LocalW wSign

cBegin

        mov     dx,lDenominator.hi      ; get the demoninator
        mov     si,dx	                ; SI holds the final sign 
        or      dx,dx                   ; ensure the denominator is positive
        jns     mdrd286_1
        neg32   dx, lDenominator.lo
        mov     lDenominator.hi, dx


mdrd286_1:
        mov     ax,lNumber.lo           ; get the long we are multiplying
        mov     dx,lNumber.hi           
        xor     si,dx	                ; make ECX reflect any sign change
        or      dx,dx                   ; ensure the long is positive
        jns     mdrd286_2
        neg32   dx, ax

mdrd286_2:
        mov     bx,lNumerator.lo        ; get the numerator
        mov     cx,lNumerator.hi        ; get the numerator
        xor     si,cx	                ; make ECX reflect any sign change
        or      cx,cx                   ; ensure the numerator is positive
        jns     mdrd286_3
        neg32   cx, bx

mdrd286_3:
        mov     wSign, si               ; save sign
        call    dmul                    ; multiply (result in dx:cx:bx:ax)
        mov     si, lDenominator.hi
        mov     di, lDenominator.lo

        cmp     dx, si                  ; begin overflow check (unsigned for div 0 check)
        ja      mdrd286_5                 ; overflow
        jb      mdrd286_7                 ; no overflow
        cmp     cx, di       
        jae     mdrd286_5                 ; overflow

mdrd286_7:
        call    qdiv                    ; DX:AX is quotient     
        or      dx,dx                   ; If sign is set, then overflow occured
        js      mdrd286_5                 ; Overflow.
        mov     cx, wSign
        or      cx,cx                   ; put the sign on the result
        jns     mdrd286_6
        neg32   dx,ax

mdrd286_6:

cEnd

mdrd286_5:
        mov     cx, wSign
        mov     ax, 0FFFFh              ; return the largest integer
        mov     dx, 7FFFh
        or      cx, cx                  ; with the correct sign
        jns     mdrd286_6
        not     dx
        not     ax
        jmp     mdrd286_6


;---------------------------Public-Routine------------------------------;
; idmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 imul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 23:47:02  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   idmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order unsigned product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order signed product

        mov     ax,si
        imul    cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        cwd
        and     dx,bx
        sub     qTemp.uq2,dx            ; adjust for sign bit
        sbb     qTemp.uq3,0
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        cwd
	and	dx,di
        sub     qTemp.uq2,dx
        sbb     qTemp.uq3,0
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx

        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; dmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 mul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 02-Feb-1988 10:50:44  -by-  Charles Whitmer [chuckwh]
; Copied from idmul and modified.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   dmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order product

        mov     ax,si
        mul     cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx
        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; iqdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit IDIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two signed numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; This routine just keeps track of the signs and calls qdiv to do the
; real work.
;
; Entry:
;       DX:CX:BX:AX = QUAD Numerator
;       SI:DI       = LONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       DI,SI
; History:
;  Tue 26-Jan-1988 02:49:19  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;

WIMP    equ     1

IQDIV_RESULT_SIGN       equ     1
IQDIV_REM_SIGN          equ     2

        assumes ds,nothing
        assumes es,nothing

cProc   iqdiv,<PUBLIC,NEAR>
        localB  flags
cBegin
        mov     flags,0

; take the absolute value of the denominator

        or      si,si
        jns     denominator_is_cool
        xor     flags,IQDIV_RESULT_SIGN
        neg     di
        adc     si,0
        neg     si
denominator_is_cool:

; take the absolute value of the denominator

        or      dx,dx
        jns     numerator_is_cool
        xor     flags,IQDIV_RESULT_SIGN + IQDIV_REM_SIGN
        not     ax
        not     bx
        not     cx
        not     dx
        add     ax,1
        adc     bx,0
        adc     cx,0
        adc     dx,0
numerator_is_cool:

; do the unsigned division

        call    qdiv
ifdef WIMP
        jo      iqdiv_exit
endif

; check for overflow

        or      dx,dx
        jns     have_a_bit_to_spare
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     short iqdiv_exit
else
        int     0                       ; You're toast, Jack!
endif
have_a_bit_to_spare:

; negate the result, if required

        test    flags,IQDIV_RESULT_SIGN
        jz      result_is_done
        neg     ax
        adc     dx,0
        neg     dx
result_is_done:

; negate the remainder, if required

        test    flags,IQDIV_REM_SIGN
        jz      remainder_is_done
        neg     bx
        adc     cx,0
        neg     cx
remainder_is_done:
iqdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; qdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit DIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two unsigned numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; Entry:
;       DX:CX:BX:AX = UQUAD Numerator
;       SI:DI       = ULONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 00:02:09  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   qdiv,<PUBLIC,NEAR>,<si,di>
        localQ  uqNumerator
        localD  ulDenominator
        localD  ulQuotient
        localW  cShift
cBegin

; stuff the quad word into local memory

        mov     uqNumerator.uq0,ax
        mov     uqNumerator.uq1,bx
        mov     uqNumerator.uq2,cx
        mov     uqNumerator.uq3,dx


; check for overflow

qdiv_restart:
        cmp     si,dx
        ja      qdiv_no_overflow
        jb      qdiv_overflow
        cmp     di,cx
        ja      qdiv_no_overflow
qdiv_overflow:
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     qdiv_exit
else
        int     0                       ; You're toast, Jack!
        jmp     qdiv_restart
endif
qdiv_no_overflow:

; check for a zero Numerator

        or      ax,bx
        or      ax,cx
        or      ax,dx
        jz      qdiv_exit_relay         ; quotient = remainder = 0

; handle the special case when the denominator lives in the low word

        or      si,si
        jnz     not_that_special

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=0):DI

        cmp     di,1                    ; separate out the trivial case
        jz      div_by_one
        xchg    dx,cx                   ; CX = remainder.hi = 0
        mov     ax,bx
        div     di
        mov     bx,ax                   ; BX = quotient.hi
        mov     ax,uqNumerator.uq0
        div     di                      ; AX = quotient.lo
        xchg    bx,dx                   ; DX = quotient.hi, BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit_relay:
        jmp     qdiv_exit

; calculate (DX=0):(CX=0):BX:uqNumerator.uq0 / (SI=0):(DI=1)

div_by_one:
        xchg    dx,bx                   ; DX = quotient.hi, BX = remainder.lo = 0
        mov     ax,uqNumerator.uq0      ; AX = quotient.lo
        jmp     qdiv_exit
not_that_special:

; handle the special case when the denominator lives in the high word

        or      di,di
        jnz     not_this_special_either

; calculate DX:CX:BX:uqNumerator.uq0 / SI:(DI=0)

        cmp     si,1                    ; separate out the trivial case
        jz      div_by_10000h
        mov     ax,cx
        div     si
        mov     cx,ax                   ; CX = quotient.hi
        mov     ax,bx
        div     si                      ; AX = quotient.lo
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
        jmp     qdiv_exit

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=1):(DI=0)

div_by_10000h:
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi = 0
        mov     ax,bx                   ; AX = quotient.lo
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
        jmp     qdiv_exit
not_this_special_either:

; normalize the denominator

        mov     dx,si
        mov     ax,di
        call    ulNormalize             ; DX:AX = normalized denominator
        mov     cShift,cx               ; CX < 16
        mov     ulDenominator.lo,ax
        mov     ulDenominator.hi,dx


; shift the Numerator by the same amount

        jcxz    numerator_is_shifted
        mov     si,-1
        shl     si,cl
        not     si                      ; SI = mask
        mov     bx,uqNumerator.uq3
        shl     bx,cl
        mov     ax,uqNumerator.uq2
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq3,bx
        xor     ax,di
        mov     bx,uqNumerator.uq1
        rol     bx,cl
        mov     di,si
        and     di,bx
        or      ax,di
        mov     uqNumerator.uq2,ax
        xor     bx,di
        mov     ax,uqNumerator.uq0
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq1,bx
        xor     ax,di
        mov     uqNumerator.uq0,ax
numerator_is_shifted:

; set up registers for division

        mov     dx,uqNumerator.uq3
        mov     ax,uqNumerator.uq2
        mov     di,uqNumerator.uq1
        mov     cx,ulDenominator.hi
        mov     bx,ulDenominator.lo

; check for case when Denominator has only 16 bits

        or      bx,bx
        jnz     must_do_long_division
        div     cx
        mov     si,ax
        mov     ax,uqNumerator.uq1
        div     cx
        xchg    si,dx                   ; DX:AX = quotient
        mov     di,uqNumerator.uq0      ; SI:DI = remainder (shifted)
        jmp     short unshift_remainder
must_do_long_division:

; do the long division, part IZ@NL@%

        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      first_division_is_safe
        mov     ulQuotient.hi,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short first_adjuster
first_division_is_safe:
        div     cx
        mov     ulQuotient.hi,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     first_adjuster_done     ; The remainder is UNSIGNED!  We have
first_adjuster:                         ; to use the carry flag to keep track
        dec     ulQuotient.hi           ; of the sign.  The adjuster loop
        add     di,bx                   ; watches for a change to the carry
        adc     si,cx                   ; flag which would indicate a sign
        jnc     first_adjuster          ; change IF we had more bits to keep
first_adjuster_done:                    ; a sign in.

; do the long division, part II

        mov     dx,si
        mov     ax,di
        mov     di,uqNumerator.uq0
        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      second_division_is_safe
        mov     ulQuotient.lo,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short second_adjuster
second_division_is_safe:
        div     cx
        mov     ulQuotient.lo,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     second_adjuster_done
second_adjuster:
        dec     ulQuotient.lo
        add     di,bx
        adc     si,cx
        jnc     second_adjuster
second_adjuster_done:
        mov     ax,ulQuotient.lo
        mov     dx,ulQuotient.hi

; unshift the remainder in SI:DI

unshift_remainder:
        mov     cx,cShift
        jcxz    remainder_unshifted
        mov     bx,-1
        shr     bx,cl
        not     bx
        shr     di,cl
        ror     si,cl
        and     bx,si
        or      di,bx
        xor     si,bx
remainder_unshifted:
        mov     cx,si
        mov     bx,di
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; ulNormalize
;
; Normalizes a ULONG so that the highest order bit is 1.  Returns the
; number of shifts done.  Also returns ZF=1 if the ULONG was zero.
;
; Entry:
;       DX:AX = ULONG
; Returns:
;       DX:AX = normalized ULONG
;       CX    = shift count
;       ZF    = 1 if the ULONG is zero, 0 otherwise
; Registers Destroyed:
;       none
; History:
;  Mon 25-Jan-1988 22:07:03  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   ulNormalize,<PUBLIC,NEAR>
cBegin

; shift by words

        xor     cx,cx
        or      dx,dx
        js      ulNormalize_exit
        jnz     top_word_ok
        xchg    ax,dx
        or      dx,dx
        jz      ulNormalize_exit        ; the zero exit
        mov     cl,16
        js      ulNormalize_exit
top_word_ok:

; shift by bytes

        or      dh,dh
        jnz     top_byte_ok
        xchg    dh,dl
        xchg    dl,ah
        xchg    ah,al
        add     cl,8
        or      dh,dh
        js      ulNormalize_exit
top_byte_ok:

; do the rest by bits

        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
ulNormalize_exit:
cEnd

sEnd   CodeSeg

       end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\ntaviprt.h ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1991-1992. All rights reserved.

   Title:   ntaviprt.h - Definitions for the portable win16/32 version of AVI

*****************************************************************************/
#ifndef WIN32
    #define EnterCrit(a)
    #define LeaveCrit(a)
#else

    /*
     * we need to enter critical sections more than once on a thread
     * (eg when handling a message that requires sending another message
     * to the winproc). This is ok - the same thread can get a critical
     * section more than once. BUT - we need to release it the same number
     * of times.
     *
     * Problems occur in mciaviTaskWait when we release the critsec to yield
     * - we don't know how many times to release it and enter it again.
     *
     * Solution: keep a count of how many times we are in the critsec. When
     * entering, if the count is already > 0, increment it once more, and leave
     * the critsec (ensuring that the count is protected, but the critsec is
     * only one level deep). On leaving, only do a leave if the count reaches
     * 0.
     *
     * NB: Critical sections are now defined per device, in the MCIGRAPHIC
     * struct. This is needed to avoid critsec deadlocks when running multiple
     * 16-bit apps (if a WOW thread yields in any way - and there are a lot
     * of ways - while holding the critical section, and another WOW thread
     * tries to get the critical section, WOW will hang, since it won't
     * reschedule).
     */


#define EnterCrit(p)  { EnterCriticalSection(&(p)->CritSec); 	\
			if ((p)->lCritRefCount++ > 0)	\
                        	LeaveCriticalSection(&(p)->CritSec);\
                      }

#define LeaveCrit(p)  { if (--(p)->lCritRefCount <= 0) {	\
				LeaveCriticalSection(&(p)->CritSec);\
                                Sleep(0);               \
                        }				\
                      }

#define IsGDIObject(obj) (GetObjectType((HGDIOBJ)(obj)) != 0)

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\window.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   window.c - Multimedia Systems Media Control Interface
            driver for AVI.

*****************************************************************************/
#include "graphic.h"

#include "avitask.h"	// for TASKIDLE

//#define IDM_CONFIG              0x100
//#define IDM_SKIPFRAMES          0x110
#define IDM_MUTE                0x120
#define IDM_STRETCH             0x130

#ifdef WIN32
// Use a different class name on 32 bit systems to ease the 16/32
// coexistence problem.  (We might want both classes defined at once.)
TCHAR szClassName[] = TEXT("AVIWnd32");
#else
char szClassName[] = "AVIWnd";
#endif

DWORD NEAR PASCAL GraphicStop (NPMCIGRAPHIC npMCI, DWORD dwFlags);
DWORD NEAR PASCAL GraphicPause (NPMCIGRAPHIC npMCI, DWORD dwFlags);
DWORD NEAR PASCAL GraphicPlay (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_ANIM_PLAY_PARMS lpPlay );
DWORD NEAR PASCAL GraphicSeek (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_SEEK_PARMS lpSeek);

BOOL NEAR PASCAL GraphicWindowInit (void)
{
    WNDCLASS cls;

    // define the class of window we want to register

    cls.lpszClassName = szClassName;
    cls.style = CS_GLOBALCLASS | CS_OWNDC;
    cls.hCursor = LoadCursor (NULL, IDC_ARROW);
    cls.hIcon = NULL;
    cls.lpszMenuName = NULL;
////cls.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    cls.hbrBackground = GetStockObject(BLACK_BRUSH);
    cls.hInstance = ghModule;
    cls.lpfnWndProc = GraphicWndProc;
    cls.cbClsExtra = 0;
    cls.cbWndExtra = sizeof (NPMCIGRAPHIC);

    return RegisterClass (&cls);
}

#ifdef WIN32
/*
 * de-register the class on unloading the dll so that we can
 * successfully re-register the class next time we are loaded.
 * note that nt only unregisters a class when the app exits.
 */
BOOL NEAR PASCAL GraphicWindowFree(void)
{
	return(UnregisterClass(szClassName, ghModule));
}
#endif

DWORD FAR PASCAL GraphicConfig(NPMCIGRAPHIC npMCI, DWORD dwFlags);

#if 0
static void NEAR PASCAL Credits(HWND hwnd);
#endif

long FAR PASCAL _LOADDS GraphicWndProc (HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT		ps;
    NPMCIGRAPHIC	npMCI;
    HMENU               hmenu;
    HDC                 hdc;
    RECT                rc;
    MINMAXINFO FAR *    lpmmi;
    TCHAR                ach[80];

#ifndef WIN32
    WORD ww;

    ww = GetWindowWord (hwnd, 0);
#else
    DWORD ww;
    ww = GetWindowLong (hwnd, 0);
#endif

    if ((ww == 0) && (wMsg != WM_CREATE)) {
	DPF(("null npMCI in windowproc!"));
        return DefWindowProc(hwnd, wMsg, wParam, lParam);
    }

    npMCI = (NPMCIGRAPHIC)ww;


    if (npMCI) {
	EnterCrit(npMCI);
    }

    switch (wMsg)
        {

        case WM_CREATE:

            npMCI = (NPMCIGRAPHIC)(UINT)(DWORD)
			    ((LPCREATESTRUCT)lParam)->lpCreateParams;

	    EnterCrit(npMCI);

#ifndef WIN32
            SetWindowWord (hwnd, 0, (WORD)npMCI);
#else
            SetWindowLong (hwnd, 0, (UINT)npMCI);
#endif
	
	    hmenu = GetSystemMenu(hwnd, 0);
	
	    if (hmenu) {
		/* Our system menu is too long--get rid of extra stuff. */
//              DeleteMenu(hmenu, SC_RESTORE, MF_BYCOMMAND);
//              DeleteMenu(hmenu, SC_MINIMIZE, MF_BYCOMMAND);
		DeleteMenu(hmenu, SC_MAXIMIZE, MF_BYCOMMAND);
                DeleteMenu(hmenu, SC_TASKLIST, MF_BYCOMMAND);

		/* Add additional menu items to the end of the system menu */
//              AppendMenu(hmenu, MF_SEPARATOR, 0, 0L);

#ifdef IDM_CONFIG
                LoadString(ghModule, MCIAVI_MENU_CONFIG, ach, sizeof(ach)/sizeof(TCHAR));
                AppendMenu(hmenu, MF_STRING, IDM_CONFIG, ach);
#endif

                LoadString(ghModule, MCIAVI_MENU_STRETCH, ach, sizeof(ach)/sizeof(TCHAR));
                AppendMenu(hmenu, MF_STRING, IDM_STRETCH, ach);

                LoadString(ghModule, MCIAVI_MENU_MUTE, ach, sizeof(ach)/sizeof(TCHAR));
                AppendMenu(hmenu, MF_STRING, IDM_MUTE, ach);
	    }
	
            break;
	
	case WM_INITMENU:
	
	    hmenu = GetSystemMenu(hwnd, 0);
	
            if (hmenu) {
#ifdef IDM_SKIPFRAMES
                CheckMenuItem(hmenu, IDM_SKIPFRAMES, MF_BYCOMMAND |
			    ((npMCI->dwOptionFlags & MCIAVIO_SKIPFRAMES) ?
                                            MF_CHECKED : MF_UNCHECKED));
#endif
                CheckMenuItem(hmenu, IDM_STRETCH, MF_BYCOMMAND |
                            ((npMCI->dwOptionFlags & MCIAVIO_STRETCHTOWINDOW) ?
                                            MF_CHECKED : MF_UNCHECKED));

#ifdef IDM_CONFIG
		/* If in configure box, disable menu item. */
                EnableMenuItem(hmenu, IDM_CONFIG, MF_BYCOMMAND |
                            (npMCI->wMessageCurrent == 0 ?
                                                MF_ENABLED : MF_GRAYED));
#endif
					
		/* If in stupid mode, disable stretch menu item. */
                EnableMenuItem(hmenu, IDM_STRETCH, MF_BYCOMMAND |
                            ((!(npMCI->dwOptionFlags & MCIAVIO_STUPIDMODE)) ?
                                            MF_ENABLED : MF_GRAYED));
					
                EnableMenuItem(hmenu, IDM_MUTE, MF_BYCOMMAND |
                            (npMCI->nAudioStreams ?
                                            MF_ENABLED : MF_GRAYED));

                CheckMenuItem(hmenu, IDM_MUTE, MF_BYCOMMAND |
                            (!(npMCI->dwFlags & MCIAVI_PLAYAUDIO) ?
                                            MF_CHECKED : MF_UNCHECKED));
            }
	    break;
	
	case WM_SYSCOMMAND:
            switch (wParam & 0xfff0) {
	    case SC_KEYMENU:
	    case SC_MOUSEMENU:
                gfEvilSysMenu++;
		LeaveCrit(npMCI);  // Must not hold while in DefWindowProc
		lParam = DefWindowProc(hwnd, wMsg, wParam, lParam);
                gfEvilSysMenu--;
		return lParam;
		
#ifdef IDM_SKIPFRAMES
	    case IDM_SKIPFRAMES:
		npMCI->dwOptionFlags ^= MCIAVIO_SKIPFRAMES;
                break;
#endif
	    case IDM_STRETCH:
		npMCI->dwOptionFlags ^= MCIAVIO_STRETCHTOWINDOW;
		
		if (!(npMCI->dwOptionFlags & MCIAVIO_STRETCHTOWINDOW)) {
		    SetWindowToDefaultSize(npMCI);
                }
		
		ResetDestRect(npMCI);
                break;

            case IDM_MUTE:
                DeviceMute(npMCI, (npMCI->dwFlags & MCIAVI_PLAYAUDIO) != 0);
		break;

#ifdef IDM_CONFIG
	    case IDM_CONFIG:
		npMCI->wMessageCurrent = MCI_CONFIGURE;
                gfEvil++;
		GraphicConfig(npMCI, 0L);
                gfEvil--;
		npMCI->wMessageCurrent = 0;
                break;
#endif
            }
            break;

        case WM_CLOSE:

            // Hide default window

            DeviceStop(npMCI, MCI_WAIT);
            ShowWindow(hwnd, SW_HIDE);
            LeaveCrit(npMCI);
            return 0L;

        case WM_DESTROY:

            // The window may be destroyed 2 ways.
            //  a. the device is closed. In this case the animation is
            //  freed in DeviceClose which is called from GraphicClose
            //  and the animation ID is NULL by the time this window is
            //  destroyed.
            //  b. the window is closed. In this case, the animation is
            //  not closed and we should set the stage to NULL. A new
            //  default window will be created if needed.

            if (IsTask(npMCI->hTask)) {
                DeviceStop(npMCI, MCI_WAIT);
            }
	    if (npMCI->hwnd == npMCI->hwndDefault)
		npMCI->hwnd = NULL;
	    npMCI->hwndDefault = NULL;
            break;

        case WM_ERASEBKGND:
            hdc = (HDC) wParam;

	    if (!(npMCI->dwFlags & MCIAVI_SHOWVIDEO)) {
		FillRect(hdc, &npMCI->rcDest, GetStockObject(GRAY_BRUSH));
	    }
		
            SaveDC(hdc);

            ExcludeClipRect(hdc,
                npMCI->rcDest.left, npMCI->rcDest.top,
                npMCI->rcDest.right, npMCI->rcDest.bottom);

            GetClientRect(hwnd, &rc);
            FillRect(hdc, &rc, GetStockObject(BLACK_BRUSH));

            RestoreDC(hdc, -1);

	    /* Hack: if we're in a WAIT state, we won't get
            ** a WM_PAINT, so we need to invalidate the streams here
            */
            GetClipBox(hdc, &rc);
            StreamInvalidate(npMCI, &rc);
	
            LeaveCrit(npMCI);
            return 0L;

        case WM_PAINT:

#ifdef WIN32
	    /*
	     * on NT we have to poll more often to avoid deadlock between
	     * threads (a SetWindowPos call on one thread will cause
	     * the window-creating thread to issue the WM_SIZE message -
	     * synchronously). The side effect of this is that we poll
	     * for messages at times when it is not safe to process all
	     * messages.
             *
             * So unless we know it is safe to paint, we punt...
	     */
	    //if (npMCI->wTaskState != TASKIDLE)
            if ((npMCI->wTaskState != TASKIDLE) && (npMCI->wTaskState != TASKPAUSED))
            {
                npMCI->dwFlags |= MCIAVI_NEEDUPDATE;
                DPF0(("Punting on painting, wTaskState = %x", npMCI->wTaskState));
		break;
	    }
#endif
            hdc = BeginPaint(hwnd, &ps);
	
            GetClientRect(hwnd, &rc);

	    /* If updating fails, paint gray. */	
            if (DeviceUpdate(npMCI, MCI_DGV_UPDATE_PAINT, hdc, &ps.rcPaint)
			== MCIERR_DEVICE_NOT_READY) {
		GetClientRect(hwnd, &rc);
                FillRect(hdc, &rc, GetStockObject(DKGRAY_BRUSH));
	    }
            EndPaint(hwnd, &ps);
            return 0L;
	
	case WM_PALETTECHANGED:

	    // We're not using the default window.  We have no business here.
	    if (npMCI->hwnd != hwnd)
		break;

	    //
	    // someone has realized a palette - so we need to re-realize our
	    // palette (note that this will also cause drawdib to
	    // check for PAL_INDICES vs PAL_COLOURS.
	    //
	    if ((HWND) wParam != hwnd) {
		DeviceRealize(npMCI);
                InvalidateRect(hwnd, NULL, FALSE);
	    }
	    break;
	
	case WM_QUERYNEWPALETTE:

	    // We're not using the default window.  We have no business here.
	    if (npMCI->hwnd != hwnd)
		break;

            LeaveCrit(npMCI);     // tomor -- maybe this should be after?
            return DeviceRealize(npMCI);

        case WM_WINDOWPOSCHANGED:
            CheckWindowMove(npMCI, TRUE);
            break;

#ifdef WM_AVISWP
	case WM_AVISWP:
        {
            long res;
            res =  SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, lParam);
            LeaveCrit(npMCI);
            return(res);
        }
#endif

	case WM_SIZE:
            ResetDestRect(npMCI);
	    break;
	
        case WM_QUERYENDSESSION:
            DeviceStop(npMCI, MCI_WAIT);
            break;

        case WM_ENDSESSION:
            if (wParam)  {
                DestroyWindow(hwnd); // we may not be able to destroy window?
            }
	    break;

	case WM_GETMINMAXINFO:
	    lpmmi = (MINMAXINFO FAR *)(lParam);

	    lpmmi->ptMinTrackSize.x = GetSystemMetrics(SM_CXSIZE) * 2;
            break;

        case WM_NCACTIVATE:
        case WM_ACTIVATE:
            DeviceSetActive(npMCI, (BOOL)wParam);
            break;

        case WM_AUDIO_ON:
            Assert(npMCI->dwFlags & MCIAVI_PLAYAUDIO);
            Assert(npMCI->dwFlags & MCIAVI_LOSTAUDIO);
            Assert(npMCI->hWave == NULL);

            npMCI->dwFlags &= ~MCIAVI_PLAYAUDIO;
            DeviceMute(npMCI, FALSE);
            break;

        case WM_AUDIO_OFF:
            Assert(npMCI->dwFlags & MCIAVI_PLAYAUDIO);
            Assert(!(npMCI->dwFlags & MCIAVI_LOSTAUDIO));
            Assert(npMCI->hWave != NULL);

            DeviceMute(npMCI, TRUE);

            npMCI->dwFlags |= MCIAVI_LOSTAUDIO;
            npMCI->dwFlags |= MCIAVI_PLAYAUDIO;
            break;

#if 0
	case WM_LBUTTONDOWN:
	    {
		DWORD	dw;
		static DWORD dwLastClick;
		static DWORD dwClicks = 0;
		#define MAX_CLICKS	7
		/*     . = (0,300)  - = (300,1000)  word = (500,1500)	*/
		/*     AVI:   .-    ...-   ..				*/
		static DWORD adwClickHigh[MAX_CLICKS] =
		    {  300, 1500,  300,  300,  300, 1500,  300 };
		static DWORD adwClickLow[MAX_CLICKS] =
		    {    0,  500,    0,    0,    0,  500,    0 };
		
		dw = timeGetTime();
		if (((dw - dwLastClick) > adwClickLow[dwClicks]) &&
			((dw - dwLastClick) <= adwClickHigh[dwClicks]))
		    dwClicks++;
		else
		    dwClicks = 0;

		dwLastClick = dw;

		if (dwClicks == MAX_CLICKS) {
		    DeviceStop(npMCI, MCI_WAIT);
		    Credits(hwnd);
		    dwClicks = 0;
		}
	    }
#endif
        }

   if (npMCI) {
	LeaveCrit(npMCI);
   }

   return DefWindowProc(hwnd, wMsg, wParam, lParam);
}

#if 0
static void NEAR PASCAL Credits(HWND hwnd)
{
	/*  Credits...  */
	RECT		rc;
	RECT		rcUpdate;
	HDC		hdc;
	MSG		msg;
	int		dyLine;
	int		yLine;
	TEXTMETRIC	tm;
	DWORD		dwNextTime;
	long		lScroll;
	DWORD		rgb;
	HANDLE		hResInfo;
	HANDLE		hResData;
	LPSTR		pchSrc, pchDst;
	char		achLine[100];
	int		iEncrypt;

	#define EOFCHAR	'@'		// end of credits file

	/* load the credits */
	if ((hResInfo = FindResource(ghModule, TEXT("MMS"), TEXT("MMSCR"))) == NULL)
		return;
	if ((hResData = LoadResource(ghModule, hResInfo)) == NULL)
		return;
	if ((pchSrc = LockResource(hResData)) == NULL)
		return;

	/* we want to get all mouse and keyboard events, to make
	 * sure we stop the animation when the user clicks or
	 * hits a key
	 */
	SetFocus(hwnd);
	SetCapture(hwnd);

	/* Scroll the credits up, one pixel at a time.  pchSrc
	 * points to the encrypted data; achLine contains a decrypted
	 * line (null-terminated).  dyLine is the height of each
	 * line (constant), and yLine is between 0 and dyLine,
	 * indicating how many pixels of the line have been scrolled
	 * in vertically from the bottom
	 */
	hdc = GetDC(hwnd);
	SelectObject(hdc, GetStockObject(ANSI_VAR_FONT));
	GetClientRect(hwnd, &rc);
	SetTextAlign(hdc, TA_CENTER);
	SetBkColor(hdc, RGB(0, 0, 0));
	SetRect(&rcUpdate, 0, rc.bottom - 1, rc.right, rc.bottom);
	GetTextMetrics(hdc, &tm);
	if ((dyLine = tm.tmHeight + tm.tmExternalLeading) == 0)
		dyLine = 1;
	yLine = dyLine;
	dwNextTime = GetCurrentTime();	// time to do the next scroll
	lScroll = 0;
	iEncrypt = 0;
	while (TRUE) {
		/* If the user clicks the mouse or hits a key, exit.
		 * However, ignore WM_LBUTTONUP because they will have
		 * to let go of the mouse after clicking the icon.
		 * Also, ignore mouse move messages.
		 */
		if (PeekMessage(&msg, hwnd, WM_KEYFIRST, WM_KEYLAST,
				PM_NOREMOVE | PM_NOYIELD))
			break;			// exit on key hit

		if (PeekMessage(&msg, hwnd, WM_MOUSEFIRST, WM_MOUSELAST,
				PM_NOREMOVE | PM_NOYIELD)) {
			if ((msg.message == WM_MOUSEMOVE) ||
			    (msg.message == WM_LBUTTONUP)) {
				/* remove and ignore message */
				PeekMessage(&msg, hwnd, msg.message,
					msg.message,
					PM_REMOVE | PM_NOYIELD);
			}
			else
				break;		// exit on click
		}

		/* scroll at a fixed no. of vertical pixels per sec. */
		if (dwNextTime > GetCurrentTime())
			continue;
		dwNextTime += 50L;	// millseconds per scroll

		if (yLine == dyLine) {
			/* decrypt a line and copy to achLine */
			pchDst = achLine;
			while (TRUE) {
				*pchDst = (char) (*pchSrc++ ^
					(128 | (iEncrypt++ & 127)));
				if ((*pchDst == '\r') ||
				    (*pchDst == EOFCHAR))
					break;
				pchDst++;
			}

			if (*pchDst == EOFCHAR)
				break;		// no more lines
			*pchDst = 0;		// null-terminate
			pchSrc++, iEncrypt++;	// skip '\n'
			yLine = 0;
		}

		/* scroll screen up one pixel */
		BitBlt(hdc, 0, 0, rcUpdate.right, rcUpdate.top,
			hdc, 0, 1, SRCCOPY);

		/* vary the text colors through a "rainbow" */
		switch ((int) (lScroll++ / 4) % 5/*num-of-cases*/) {
		case 0: rgb = RGB(255,   0,   0); break;
		case 1: rgb = RGB(255, 255,   0); break;
		case 2: rgb = RGB(  0, 255,   0); break;
		case 3: rgb = RGB(  0, 255, 255); break;
		case 4: rgb = RGB(255,   0, 255); break;
		}
		SetTextColor(hdc, rgb);

		/* fill in the bottom pixel */
		SaveDC(hdc);
		yLine++;
		IntersectClipRect(hdc, rcUpdate.left, rcUpdate.top,
			rcUpdate.right, rcUpdate.bottom);
#ifdef WIN32
		ExtTextOutA(hdc, rc.right / 2, rc.bottom - yLine,
			ETO_OPAQUE, &rcUpdate,
			achLine, lstrlenA(achLine), NULL);
#else
		ExtTextOut(hdc, rc.right / 2, rc.bottom - yLine,
			ETO_OPAQUE, &rcUpdate,
			achLine, lstrlen(achLine), NULL);
#endif
		RestoreDC(hdc, -1);
	}

	ReleaseDC(hwnd, hdc);
	ReleaseCapture();
	UnlockResource(hResData);
	FreeResource(hResData);
	InvalidateRect(hwnd, NULL, TRUE);
}
#endif

void FAR PASCAL SetWindowToDefaultSize(NPMCIGRAPHIC npMCI)
{
    RECT rc;

    if (npMCI->hwnd && npMCI->hwnd == npMCI->hwndDefault) {
        rc = npMCI->rcMovie;

	if (npMCI->dwOptionFlags & MCIAVIO_ZOOMBY2)
	    SetRect(&rc, 0, 0, rc.right*2, rc.bottom*2);

        AdjustWindowRect(&rc, GetWindowLong(npMCI->hwnd, GWL_STYLE), FALSE);

	if (IsIconic(npMCI->hwnd)) {
	    WINDOWPLACEMENT wp;
	    wp.length = sizeof(wp);
	    GetWindowPlacement(npMCI->hwnd, &wp);
	    wp.rcNormalPosition.right = wp.rcNormalPosition.left +
					    (rc.right - rc.left);
	    wp.rcNormalPosition.bottom = wp.rcNormalPosition.top +
					    (rc.bottom - rc.top);
	    SetWindowPlacement(npMCI->hwnd, &wp);
	} else {
	    SetWindowPos(npMCI->hwnd, NULL, 0, 0,
                        rc.right - rc.left, rc.bottom - rc.top,
                        SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
	}
    }
}

void FAR PASCAL ResetDestRect(NPMCIGRAPHIC npMCI)
{
    RECT    rc;

    /* WM_SIZE messages (on NT at least) are sometimes sent
     * during CreateWindow processing (eg if the initial window size
     * is not CW_DEFAULT). Some fields in npMCI are only filled in
     * after CreateWindow has returned. So there is a danger that at this
     * point some fields are not valid.
     */

    if (npMCI->hwnd &&
        npMCI->hwnd == npMCI->hwndDefault &&
        (npMCI->dwOptionFlags & MCIAVIO_STRETCHTOWINDOW)) {
        GetClientRect(npMCI->hwnd, &rc);
    }

    else if (npMCI->streams > 0) {
        rc = npMCI->rcMovie;

        if (npMCI->dwOptionFlags & MCIAVIO_ZOOMBY2) {
            rc.right *= 2;
            rc.bottom *= 2;
        }
    }
    else {
        return;
    }

    if (!IsRectEmpty(&rc))
        DevicePut(npMCI, &rc, MCI_DGV_PUT_DESTINATION);
}

void CheckWindowMove(NPMCIGRAPHIC npMCI, BOOL fForce)
{
#ifdef WIN32
    POINT   dwOrg;
#else
    DWORD   dwOrg;
#endif
    UINT    wRgn;
    HDC     hdc;
    RECT    rc;
    BOOL    f;
    BOOL    fGetDC;

    if (!(npMCI->dwFlags & MCIAVI_WANTMOVE))
        return;

    if (!npMCI->hicDraw || !npMCI->hwnd || npMCI->nVideoStreams == 0)
        return;

    Assert(IsWindow(npMCI->hwnd));
    Assert(npMCI->paStreamInfo);
    Assert(npMCI->nVideoStreams > 0);

    //
    //  when the screen is locked for update by a window move operation
    //  we dont want to turn off the video.
    //
    //  we can tell if the screen is locked by checking a DC to the screen.
    //
    hdc = GetDC(NULL);
    f = GetClipBox(hdc, &rc) == NULLREGION;
    ReleaseDC(NULL, hdc);

    if (f)
    {
        npMCI->wRgnType = (UINT) -1;
        return;
    }

    if (fForce)
        npMCI->wRgnType = (UINT) -1;

    if (fGetDC = (npMCI->hdc == NULL))
        hdc = GetDC (npMCI->hwnd);
    else
        hdc = npMCI->hdc;

    wRgn = GetClipBox(hdc, &rc);
#ifdef WIN32
    GetDCOrgEx(hdc, &dwOrg);
#else
    dwOrg = GetDCOrg(hdc);
#endif

    if (fGetDC)
        ReleaseDC(npMCI->hwnd, hdc);

    if (wRgn == npMCI->wRgnType &&
#ifdef WIN32
        dwOrg.x == npMCI->dwOrg.x &&
        dwOrg.y == npMCI->dwOrg.y &&
#else
        dwOrg == npMCI->dwOrg &&
#endif
        EqualRect(&rc, &npMCI->rcClip))
        return;

    npMCI->wRgnType = wRgn;
    npMCI->dwOrg    = dwOrg;
    npMCI->rcClip   = rc;

    rc = npMCI->psiVideo->rcDest;
    ClientToScreen(npMCI->hwnd, (LPPOINT)&rc);
    ClientToScreen(npMCI->hwnd, (LPPOINT)&rc+1);

    if (wRgn == NULLREGION)
        SetRectEmpty(&rc);

    DPF2(("Sending ICM_DRAW_WINDOW message Rgn=%d, Org=(%d,%d) [%d, %d, %d, %d]\n", wRgn, dwOrg, rc));

    if (ICDrawWindow(npMCI->hicDraw, &rc) != ICERR_OK) {
        DPF2(("Draw device does not want ICM_DRAW_WINDOW messages!\n"));
        npMCI->dwFlags &= ~MCIAVI_WANTMOVE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi.16\libinit.asm ===
page	,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  LIBINIT.ASM
;
; library stub to do local init for a Dynamic linked library
;
; Created: 06-27-89
; Author:  Todd Laney [ToddLa]
;
; Exported Functions:   none
;
; Public Functions:     none
;
; Public Data:		none
;
; General Description:
;
; Restrictions:
;
;   This must be the first object file in the LINK line, this assures
;   that the reserved parameter block is at the *base* of DGROUP
;
;-----------------------------------------------------------------------;

?PLM=1      ; PASCAL Calling convention is DEFAULT
?WIN=1	    ; Windows calling convention

        .286
	.xlist
	include cmacros.inc
;       include windows.inc
        .list

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
;   externs from KERNEL
;
        externFP    <LocalInit>
        externFP    <FatalAppExit>

;-----------------------------------------------------------------------;
;
;   LibMain is the function in C code we will call on a DLL load.
;   it is assumed in the same segment as we are.
;
;;;;;;;;externNP    <LibMain>
        externFP    <LibMain>  ;; Use this line if LibMain is far call

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
sBegin  Data
assumes DS,Data
            org 0               ; base of DATA segment!

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd        Data

;-----------------------------------------------------------------------;

sBegin  CodeSeg
        assumes cs,CodeSeg

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used by a DLL)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
ifdef DEBUG
        ;
        ; if this module is not linked first the reserved parameter block
        ; will not be initialized correctly, check for this and
        ;
        lea     ax,pLocalHeap
        cmp     ax,6
        je      RsrvPtrsOk

RsrvPtrsHosed:
        int     3

        lea     ax,RsrvPtrsMsg
        cCall   FatalAppExit,<0,cs,ax>
        jmp     RsrvPtrsOk

RsrvPtrsMsg:
        db      'RsrvPtrs hosed!',0

RsrvPtrsOk:
endif
	;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
	;
	push	di
	push	cx
	push	es
	push	si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        cCall   LocalInit,<0,0,cx>

no_heap:
        cCall   LibMain
cEnd

;--------------------------Exported-Routine-----------------------------;
;
;   WEP()
;
;   called when the DLL is unloaded, it is passed 1 WORD parameter that
;   is TRUE if the system is going down, or zero if the app is
;
;   WARNING:
;
;       This function is basicly useless, you cant can any kernel function
;       that may cause the LoadModule() code to be reentered..
;
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   WEP,<FAR,PUBLIC,NODATA>,<>
        ParmW  WhyIsThisParamBogusDave?
cBegin
cEnd

sEnd    CodeSeg

        end     LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\aviffmt.h ===
/****************************************************************************/
/*                                                                          */
/*        AVIFFMT.H - Include file for working with AVI files               */
/*                                                                          */
/*        Note: You must include WINDOWS.H and MMSYSTEM.H before            */
/*        including this file.                                              */
/*                                                                          */
/*        Copyright (c) 1991-1992, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

/*
 *
 * An AVI file is the following RIFF form:
 *
 *	RIFF('AVI' 
 *	      LIST('hdrl'
 *		    avih(<MainAVIHeader>)
 *                  LIST ('strl'
 *                      strh(<Stream header>)
 *                      strf(<Stream format>)
 *                      ... additional header data
 *            LIST('movi'	 
 *      	  { LIST('rec' 
 *      		      SubChunk...
 *      		   )
 *      	      | SubChunk } ....	    
 *            )
 *            [ <AVIIndex> ]
 *      )
 *
 *      The first two characters of each chunk are the track number.
 *      SubChunk = {  xxdh(<AVI DIB header>)
 *                  | xxdb(<AVI DIB bits>)
 *                  | xxdc(<AVI compressed DIB bits>)
 *                  | xxpc(<AVI Palette Change>)
 *                  | xxwb(<AVI WAVE bytes>)
 *                  | xxws(<AVI Silence record>)
 *                  | xxmd(<MIDI data>)
 *                  | additional custom chunks }
 *
 */
/*
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * We need a better description of the AVI file header here.
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *
 * The grouping into LIST 'rec' chunks implies only that the contents of
 *   the chunk should be read into memory at the same time.  This
 *   grouping is only necessary for interleaved files.
 *       
 * For loading efficiency, the beginning of each LIST 'rec' chunk may
 * be aligned on a 2K boundary.  (Actually, the beginning of the LIST
 * chunk should be 12 bytes before a 2K boundary, so that the data chunks
 * inside the LIST chunk are aligned.)
 *
 * If the AVI file is being played from CD-ROM in, it is recommended that
 * the file be padded.
 *
 * Limitations for the Alpha release:
 *	If the AVI file has audio, each record LIST must contain exactly
 *	one audio chunk, which must be the first chunk.
 *	Each record must contain exactly one video chunk (possibly preceded
 *	by one or more palette change chunks).
 *	No wave format or DIB header chunks may occur outside of the header.
 */

#ifndef _INC_AVIFFMT
#define _INC_AVIFFMT

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

/* Macro to make a TWOCC out of two characters */
#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

typedef WORD TWOCC;

/* form types, list types, and chunk types */
#define formtypeAVI             mmioFOURCC('A', 'V', 'I', ' ')
#define listtypeAVIHEADER       mmioFOURCC('h', 'd', 'r', 'l')
#define ckidAVIMAINHDR          mmioFOURCC('a', 'v', 'i', 'h')
#define listtypeSTREAMHEADER    mmioFOURCC('s', 't', 'r', 'l')
#define ckidSTREAMHEADER        mmioFOURCC('s', 't', 'r', 'h')
#define ckidSTREAMFORMAT        mmioFOURCC('s', 't', 'r', 'f')
#define ckidSTREAMHANDLERDATA   mmioFOURCC('s', 't', 'r', 'd')

#define listtypeAVIMOVIE        mmioFOURCC('m', 'o', 'v', 'i')
#define listtypeAVIRECORD       mmioFOURCC('r', 'e', 'c', ' ')

#define ckidAVINEWINDEX         mmioFOURCC('i', 'd', 'x', '1')

/*
** Here are some stream types.  Currently, only audio and video
** are supported.
*/
#define streamtypeVIDEO         mmioFOURCC('v', 'i', 'd', 's')
#define streamtypeAUDIO         mmioFOURCC('a', 'u', 'd', 's')
#define streamtypeMIDI          mmioFOURCC('m', 'i', 'd', 's')
#define streamtypeTEXT          mmioFOURCC('t', 'x', 't', 's')

/*
** Here are some compression types.
*/
#define comptypeRLE0            mmioFOURCC('R','L','E','0')
#define comptypeRLE             mmioFOURCC('R','L','E',' ')
#define comptypeDIB             mmioFOURCC('D','I','B',' ')

#define cktypeDIBbits           aviTWOCC('d', 'b')
#define cktypeDIBcompressed     aviTWOCC('d', 'c')
#define cktypeDIBhalf           aviTWOCC('d', 'x')
#define cktypePALchange         aviTWOCC('p', 'c')
#define cktypeWAVEbytes         aviTWOCC('w', 'b')
#define cktypeWAVEsilence       aviTWOCC('w', 's')

#define cktypeMIDIdata          aviTWOCC('m', 'd')

#define cktypeDIBheader         aviTWOCC('d', 'h')
#define cktypeWAVEformat        aviTWOCC('w', 'f')

#define ckidAVIPADDING          mmioFOURCC('J', 'U', 'N', 'K')
#define ckidOLDPADDING          mmioFOURCC('p', 'a', 'd', 'd')


/*
** Useful macros
*/
#define ToHex(n)	((BYTE) (((n) > 9) ? ((n) - 10 + 'A') : ((n) + '0')))
#define FromHex(n)	(((n) >= 'A') ? ((n) + 10 - 'A') : ((n) - '0'))

/* Macro to get stream number out of a FOURCC ckid */
#define StreamFromFOURCC(fcc) ((WORD) ((FromHex(LOBYTE(LOWORD(fcc))) << 4) + \
                                             (FromHex(HIBYTE(LOWORD(fcc))))))

/* Macro to get TWOCC chunk type out of a FOURCC ckid */
#define TWOCCFromFOURCC(fcc)    HIWORD(fcc)

/* Macro to make a ckid for a chunk out of a TWOCC and a stream number
** from 0-255.
**
** Warning: This is a nasty macro, and MS C 6.0 compiles it incorrectly
** if optimizations are on.  Ack.
*/
#define MAKEAVICKID(tcc, stream) \
        MAKELONG((ToHex((stream) & 0x0f) << 8) | ToHex(((stream) & 0xf0) >> 4), tcc)



/*
** Main AVI File Header 
*/	     
		     
/* flags for use in <dwFlags> in AVIFileHdr */
#define AVIF_HASINDEX		0x00000010	// Index at end of file?
#define AVIF_MUSTUSEINDEX	0x00000020
#define AVIF_ISINTERLEAVED	0x00000100
#define AVIF_VARIABLESIZEREC	0x00000200
#define AVIF_NOPADDING		0x00000400
#define AVIF_WASCAPTUREFILE	0x00010000
#define AVIF_COPYRIGHTED	0x00020000

/* The AVI File Header LIST chunk should be padded to this size */
#define AVI_HEADERSIZE  2048                    // size of AVI header list

/*****************************************************************************
 * @doc EXTERNAL AVI_FFMT
 * 
 * @types MainAVIHeader | The <t MainAVIHeader> structure contains 
 *	global information for the entire AVI file.  It is contained 
 *	within an 'avih' chunk within the LIST 'hdrl' chunk at the
 *	beginning of an AVI RIFF file.
 * 
 * @field DWORD | dwMicroSecPerFrame | Specifies the number of 
 *    microseconds between frames.
 *
 * @field DWORD | dwMaxBytesPerSec | Specifies the approximate 
 *    maximum data rate of file.
 *
 * @field DWORD | dwReserved1 | Reserved. (This field should be set to 0.)
 *
 * @field DWORD | dwFlags | Specifies any applicable flags. 
 *    The following flags are defined: 
 *
 *	@flag AVIF_HASINDEX | Indicates
 *		the AVI file has an 'idx1' chunk containing an index
 *		at the end of the file.  For good performance, all AVI 
 *		files should contain an index.
 *
 *	@flag AVIF_MUSTUSEINDEX | Indicates that the
 *		index, rather than the physical ordering of the chunks
 *		in the file, should be used to determine the order of
 *		presentation of the data.  For example, this could be
 *		used for creating a list frames for editing.
 *		
 *	@flag AVIF_ISINTERLEAVED | Indicates 
 *		the AVI file is interleaved.  
 *
 *	@flag AVIF_WASCAPTUREFILE | Indicates 
 *		the AVI file is a specially allocated file used for
 *		capturing real-time video.  Applications should warn the
 *		user before writing over a file with this flag set 
 *		because the user probably defragmented
 *		this file.
 *
 *	@flag AVIF_COPYRIGHTED | Indicates the
 *		AVI file contains copyrighted data and software.
 *    When this flag is used, 
 *    software should not permit the data to be duplicated. 
 *
 * @field DWORD | dwTotalFrames | Specifies the number of 
 *    frames of data in file.
 *
 * @field DWORD | dwInitialFrames | Specifies the initial frame 
 * for interleaved files. Non-interleaved files should specify 
 *	zero.
 *
 * @field DWORD | dwStreams | Specifies the number of streams in the file.
 *	   For example, a file with audio and video has 2 streams.
 *
 * @field DWORD | dwSuggestedBufferSize | Specifies the suggested 
 *    buffer size for reading the file.  Generally, this size 
 *    should be large enough to contain the largest chunk in 
 *    the file. If set to zero, or if it is too small, the playback
 *	   software will have to reallocate memory during playback 
 *	   which will reduce performance.
 *    
 *	   For an interleaved file, this buffer size should be large
 *	   enough to read an entire record and not just a chunk.
 *
 * @field DWORD | dwWidth | Specifies the width of the AVI file in pixels.
 *
 * @field DWORD | dwHeight | Specifies the height of the AVI file in pixels.
 *
 * @field DWORD | dwScale | This field is used with
 *	<e MainAVIHeader.dwRate> to specify the time scale that
 *	applies to the AVI file. In addition, each stream 
 * can have its own time scale.
 *
 *	Dividing <e MainAVIHeader.dwRate> by <e AVIStreamHeader.dwScale>
 *	gives the number of samples per second.
 *
 * @field DWORD | dwRate | See <e MainAVIHeader.dwScale>.
 *
 * @field DWORD | dwStart | Specifies the starting time of the AVI file.
 * The units are defined by <e MainAVIHeader.dwRate> and 
 * <e MainAVIHeader.dwScale>. This field is usually set to zero.
 *
 * @field DWORD | dwLength | Specifies the length of the AVI file. 
 * The units are defined by <e AVIStreamHeader.dwRate> and 
 * <e AVIStreamHeader.dwScale>. This length is returned by MCIAVI when 
 * using the frames time format.
 *
 ****************************************************************************/

typedef struct 
{
    DWORD		dwMicroSecPerFrame;	// frame display rate (or 0L)
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwPaddingGranularity;	// pad to multiples of this
                                                // size; normally 2K.
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwTotalFrames;		// # frames in file
    DWORD		dwInitialFrames;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;
    
    DWORD		dwWidth;
    DWORD		dwHeight;
    
    /* Do we want the stuff below for the whole movie, or just
    ** for the individual streams?
    */
    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwStart;  /* Is this always zero? */
    DWORD		dwLength; /* In units above... */
} MainAVIHeader;


/*
** Stream header
*/

/* !!! Do we need to distinguish between discrete and continuous streams? */

#define AVISF_DISABLED			0x00000001
#define AVISF_VIDEO_PALCHANGES		0x00010000
/* Do we need identity palette support? */

/*****************************************************************************
 * @doc EXTERNAL AVI_FFMT
 * 
 * @types AVIStreamHeader | The <t AVIStreamHeader> structure contains 
 *	   header information for a single stream of an file. It is contained 
 *    within an 'strh' chunk within a LIST 'strl' chunk that is itself
 *	   contained within the LIST 'hdrl' chunk at the beginning of
 *    an AVI RIFF file.
 * 
 * @field FOURCC | fccType | Contains a four-character code which specifies
 *	   the type of data contained in the stream. The following values are 
 *	   currently defined:
 *
 *	@flag 'vids' | Indicates the stream contains video data.  The stream 
 *    format chunk contains a <t BITMAPINFO> structure which can include
 *		palette information.
 *
 *	@flag 'auds' | Indicates the stream contains video data.  The stream 
 *    format chunk contains a <t WAVEFORMATEX> or <t PCMWAVEFORMAT>
 *		structure.
 *
 *    New data types should be registered with the <MI>Multimedia Developer 
 *    Registration Kit<D>.
 *
 * @field FOURCC | fccHandler | Contains a four-character code that 
 *	   identifies a specific data handler.
 *
 * @field DWORD | dwFlags | Specifies any applicable flags. 
 *    The bits in the high-order word of these flags 
 *    are specific to the type of data contained in the stream.
 *    The following flags are currently defined:
 *
 *	@flag AVISF_DISABLED | Indicates 
 *		this stream should not be enabled by default.
 *
 *	@flag AVISF_VIDEO_PALCHANGES | Indicates 
 *		this video stream contains palette changes. This flag warns
 *		the playback software that it will need to animate the 
 *		palette.
 *
 * @field DWORD | dwReserved1 | Reserved. (Should be set to 0.)
 *
 * @field DWORD | dwInitialFrames | Reserved for interleaved files. 
 *	   (Set this to 0 for non-interleaved files.)
 *
 * @field DWORD | dwScale | This field is used together with
 *	<e AVIStreamHeader.dwRate> to specify the time scale that
 *	this stream will use.
 *
 *	Dividing <e AVIStreamHeader.dwRate> by <e AVIStreamHeader.dwScale>
 *	gives the number of samples per second.
 *
 *	For video streams, this rate should be the frame rate.
 *
 *	For audio streams, this rate should correspond to the time needed for
 *	<e WAVEFORMATEX.nBlockAlign> bytes of audio, which for PCM audio simply
 *	reduces to the sample rate.
 *
 * @field DWORD | dwRate | See <e AVIStreamHeader.dwScale>.
 *
 * @field DWORD | dwStart | Specifies the starting time of the AVI file.
 * The units are defined by the 
 *	<e MainAVIHeader.dwRate> and <e MainAVIHeader.dwScale> fields
 *	in the main file header. Normally, this is zero, but it can
 *	specify a delay time for a stream which does not start concurrently 
 *	with the file.
 *
 *	Note: The 1.0 release of the AVI tools does not support a non-zero
 *	starting time.
 *
 * @field DWORD | dwLength | Specifies the length of this stream. 
 * The units are defined by the 
 *	<e AVIStreamHeader.dwRate> and <e AVIStreamHeader.dwScale>
 *	fields of the stream's header. 
 *
 * @field DWORD | dwSuggestedBufferSize | Suggests how large a buffer
 *	should be used to read this stream.  Typically, this contains a
 *	value corresponding to the largest chunk present in the stream. 
 * Using the correct buffer size makes playback more efficient.
 * Use zero if you do not know the correct buffer size. 
 *
 * @field DWORD | dwQuality | Specifies an indicator of the quality 
 * of the data in the stream. Quality is 
 *	represented as a number between 0 and 10000.  For compressed data,
 *	this typically represent the value of the quality parameter
 *	passed to the compression software.
 *
 * @field DWORD | dwSampleSize | Specifies the size of a single sample 
 * of data. This is set to 
 *	zero if the samples can vary in size.  If this number is non-zero, then
 *	multiple samples of data can be grouped into a single chunk within
 *	the file.  If it is zero, each sample of data (such as a video
 *	frame) must be in a separate chunk.
 *
 *	For video streams, this number is typically zero, although it
 *	can be non-zero if all video frames are the same size.
 *
 *	For audio streams, this number should be the same as the
 *	<e WAVEFORMATEX.nBlockAlign> field of the <t WAVEFORMATEX> structure
 *	describing the audio.
 *
 ****************************************************************************/
typedef struct {
    FOURCC		fccType;
    FOURCC		fccHandler;
    DWORD		dwFlags;	/* Contains AVITF_* flags */
    WORD		wPriority;
    WORD		wLanguage;
    DWORD		dwInitialFrames;
    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwStart;
    DWORD		dwLength; /* In units above... */

    // new....
    DWORD		dwSuggestedBufferSize;
    DWORD		dwQuality;
    DWORD		dwSampleSize;
    RECT		rcFrame;    /* does each frame need this? */

    /* additional type-specific data goes in StreamInfo chunk */
    
    /* For video: position within rectangle... */
    /* For audio: volume?  stereo channel? */
} AVIStreamHeader;

typedef struct {
    RECT    rcFrame;
} AVIVideoStreamInfo;

typedef struct {
    WORD    wLeftVolume;    // !!! Range?
    WORD    wRightVolume;
    DWORD   dwLanguage;	    // !!! Is there a standard representation of this?
} AVIAudioStreamInfo;


#define AVIIF_LIST          0x00000001L // chunk is a 'LIST'
#define AVIIF_TWOCC         0x00000002L // ckid is a TWOCC?
#define AVIIF_KEYFRAME      0x00000010L // this frame is a key frame.
#define AVIIF_FIRSTPART     0x00000020L // this frame is the start of a partial frame.
#define AVIIF_LASTPART      0x00000040L // this frame is the end of a partial frame.
#define AVIIF_MIDPART       (AVIIF_LASTPART|AVIIF_FIRSTPART)
#define AVIIF_NOTIME	    0x00000100L // this frame doesn't take any time

#define AVIIF_COMPUSE       0x0FFF0000L // these bits are for compressor use

/*****************************************************************************
 * @doc EXTERNAL AVI_FFMT
 * 
 * @types AVIINDEXENTRY | The AVI file index consists of an array
 *	of <t AVIINDEXENTRY> structures contained within an 'idx1'
 *	chunk at the end of an AVI file. This chunk follows the main LIST 'movi'
 *	chunk which contains the actual data.
 * 
 * @field DWORD | ckid | Specifies a four-character code corresponding 
 *    to the chunk ID of a data chunk in the file.
 *
 * @field DWORD | dwFlags | Specifies any applicable flags. 
 *    The flags in the low-order word are reserved for AVI, 
 *    while those in the high-order word can be used
 *    for stream- and compressor/decompressor-specific information.
 *    
 *	The following values are currently defined:
 *
 *	@flag AVIIF_LIST | Indicates the specified
 *		chunk is a 'LIST' chunk, and the <e AVIINDEXENTRY.ckid>
 *		field contains the list type of the chunk.
 *
 *	@flag AVIIF_KEYFRAME | Indicates this chunk
 *		is a key frame. Key frames do not require
 *		additional preceding chunks to be properly decoded.
 *
 *	@flag AVIIF_NOTIME | Indicates this chunk should have no effect
 *		on timing or calculating time values based on the number of chunks.
 *		For example, palette change chunks in a video stream
 *		should have this flag set, so that they are not counted
 *		as taking up a frame's worth of time.
 *
 * @field DWORD | dwChunkOffset | Specifies the position in the file of the 
 *    specified chunk. The position value includes the eight byte RIFF header.
 *
 * @field DWORD | dwChunkLength | Specifies the length of the 
 *    specified chunk. The length value does not include the eight
 *    byte RIFF header.
 *
 ****************************************************************************/
typedef struct
{
    DWORD		ckid;
    DWORD		dwFlags;
    DWORD		dwChunkOffset;		// Position of chunk
    DWORD		dwChunkLength;		// Length of chunk
} AVIINDEXENTRY;


/*
** Palette change chunk
**
** Used in video streams.
*/
typedef struct 
{
    BYTE		bFirstEntry;	/* first entry to change */
    BYTE		bNumEntries;	/* # entries to change (0 if 256) */
    WORD		wFlags;		/* Mostly to preserve alignment... */
    PALETTEENTRY	peNew[];	/* New color specifications */
} AVIPALCHANGE;

/*****************************************************************************
 * @doc EXTERNAL AVI_FFMT
 * 
 * @types AVIPALCHANGE | The <t AVIPALCHANGE> structure is used in 
 *	video streams containing palettized data to indicate the
 *	palette should change for subsequent video data.
 * 
 * @field BYTE | bFirstEntry | Specifies the first palette entry to change.
 *
 * @field BYTE | bNumEntries | Specifies the number of entries to change.
 * 
 * @field WORD | wFlags | Reserved. (This should be set to 0.)
 * 
 * @field PALETTEENTRY | peNew | Specifies an array of new palette entries.
 *
 ****************************************************************************/

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif /* INC_AVIFFMT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\avidraw.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1991-1995. All rights reserved.

   Title:   avidraw.c - Functions that actually draw video for AVI.

*****************************************************************************/
#include "graphic.h"

//
// if the average key frame spacing is greater than this value, always
// force a buffer.
//
#define KEYFRAME_PANIC_SPACE       2500

#define YIELDATFUNNYTIMES

#define ALIGNULONG(i)     ((i+3)&(~3))                  /* ULONG aligned ! */
#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)


#ifdef _WIN32
#define LockCurrentTask(x)	(x)
#else
extern FAR PASCAL LockCurrentTask(BOOL);
#endif

BOOL NEAR PASCAL DrawBits(NPMCIGRAPHIC npMCI, DWORD ckid, DWORD cksize, BOOL fHurryUp);
void NEAR PASCAL UpdateDisplayDibPalette(NPMCIGRAPHIC npMCI);

BOOL NEAR PASCAL ProcessPaletteChange(NPMCIGRAPHIC npMCI, DWORD cksize)
{
    UINT wStartIndex;
    UINT wNumEntries;
    UINT w;
    LPPALETTEENTRY ppe;

    npMCI->dwFlags |= MCIAVI_PALCHANGED;
    DPF2(("Setting PALCHANGED\n"));

    while (cksize > 4) {
	wStartIndex = GET_BYTE();
	wNumEntries = GET_BYTE();

	/* Skip filler word */
	GET_WORD();

	/* Zero is used as a shorthand for 256 */
	if (wNumEntries == 0)
            wNumEntries = 256;

        ppe = (LPVOID)npMCI->lp;

        for (w=0; w<wNumEntries; w++)
        {
            npMCI->argb[wStartIndex+w].rgbRed   = ppe[w].peRed;
            npMCI->argb[wStartIndex+w].rgbGreen = ppe[w].peGreen;
            npMCI->argb[wStartIndex+w].rgbBlue  = ppe[w].peBlue;
        }

	SKIP_BYTES(wNumEntries * sizeof(PALETTEENTRY));
	cksize -= 4 + wNumEntries * sizeof(PALETTEENTRY);
    }

    if (npMCI->pbiFormat->biBitCount == 8) {
	hmemcpy((LPBYTE) npMCI->pbiFormat + npMCI->pbiFormat->biSize,
		(LPBYTE) npMCI->argb,
		sizeof(RGBQUAD) * npMCI->pbiFormat->biClrUsed);
    }

#ifdef DEBUG	
    /* Make sure we've used up the entire chunk... */
    if (cksize != 0) {
	DPF(("Problem with palc chunk\n"));
    }
#endif

    return TRUE;
}

/* Display the video from the current record.
*/
BOOL NEAR PASCAL DisplayVideoFrame(NPMCIGRAPHIC npMCI, BOOL fHurryUp)
{
    DWORD	ckid;
    DWORD	cksize;
    BOOL	fRet;
    int		stream;
    DWORD	dwRet;
    LONG        len;
    DWORD	dwDrawStart;
    LPVOID      lpSave;
    LPVOID      lpChunk;

    /* If we're allowed to skip frames, apply some relatively
    ** bogus heuristics to decide if we should do it, and
    ** pass the appropriate flag on to the driver.
    */
    if ((npMCI->lCurrentFrame & 0x0f) == 0) {
	fHurryUp = FALSE;
    }

    /* Even if SKIPFRAMES is off, count how many frames we _would_ have
    ** skipped if we could.
    */
    if (fHurryUp)
	++npMCI->dwSkippedFrames;

    if (!(npMCI->dwOptionFlags & MCIAVIO_SKIPFRAMES))
	fHurryUp = FALSE;

    /* Keep track of what we've drawn. */
    npMCI->lFrameDrawn = npMCI->lCurrentFrame;
    len = (LONG)npMCI->dwThisRecordSize;
    lpSave = npMCI->lp;

    /* If it's interleaved, adjust for the next record header.... */
    // !!! Only if not last frame?
    if (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED)
	len -= 3 * sizeof(DWORD);

    while (len >= 2 * sizeof(DWORD)) {

	/* Look at the next chunk */
	ckid = GET_DWORD();
	cksize = GET_DWORD();

	DPF3(("'Chunk %.4s': %lu bytes\n", (LPSTR) &ckid, cksize));
	
	if ((LONG) cksize > len) {
            AssertSz(FALSE, "Chunk obviously too big!");
	    break;
	}
	
        len -= ((cksize+1)&~1) + 8;

        if (len < -1) {
            AssertSz(FALSE, "Chunk overflowed what was read in!");
	    break;
	}

	lpChunk = npMCI->lp;
	
        stream = StreamFromFOURCC(ckid);

        if (stream == npMCI->nVideoStream) {

            if ((npMCI->lCurrentFrame < npMCI->lVideoStart) &&
                    !(npMCI->dwFlags & MCIAVI_REVERSE))
                goto skip;

            switch(TWOCCFromFOURCC(ckid)) {

            case cktypePALchange:
                ProcessPaletteChange(npMCI, cksize);
                npMCI->lLastPaletteChange = npMCI->lCurrentFrame;
                break;

            default:
                /* Some other chunk... */
                if (!fHurryUp && ckid) {
                    dwDrawStart = timeGetTime();
		}

                //!!! we need to handle half frames!!!

                fRet = DrawBits(npMCI, ckid, cksize, fHurryUp);

                if (!fRet)
                    return FALSE;

                if (npMCI->dwBufferedVideo)
                    npMCI->dwLastDrawTime = 0;
                else
                    if (!fHurryUp && ckid) {
                        npMCI->dwLastDrawTime = timeGetTime() - dwDrawStart;
		    }

                break;
            }
        } else if (stream >= 0 && stream < npMCI->streams &&
                        SI(stream)->hicDraw) {
            dwRet = ICDraw(SI(stream)->hicDraw, (fHurryUp ? ICDRAW_HURRYUP : 0L),
                                SI(stream)->lpFormat,
                                (ckid == 0) ? 0L : npMCI->lp, cksize, npMCI->lCurrentFrame);
            // !!! Error check?
        }
skip:
	/* If not interleaved, we're done. */
	if (npMCI->wPlaybackAlg != MCIAVI_ALG_INTERLEAVED)
	    return TRUE;

        /* Skip to the next chunk */
        npMCI->lp = (HPSTR) lpChunk + ((cksize+1)&~1);
    }

    npMCI->lp = lpSave;

    return TRUE;
}

//
// mark all streams in the passed RECT as dirty
//
void NEAR PASCAL StreamInvalidate(NPMCIGRAPHIC npMCI, LPRECT prc)
{
    int i;
    int n;
    STREAMINFO *psi;
    RECT rc;

    if (prc)
        DPF2(("StreamInvalidate: [%d, %d, %d, %d]\n", *prc));
    else
        DPF2(("StreamInvalidate: NULL\n", *prc));

    for (n=i=0; i<npMCI->streams; i++) {

        psi = SI(i);

        // we always update any visible error streams

        if (!(psi->dwFlags & STREAM_ERROR) &&
            !(psi->dwFlags & STREAM_ENABLED))
            continue;

        if (IsRectEmpty(&psi->rcDest))
            continue;

        if (prc && !IntersectRect(&rc, prc, &psi->rcDest))
            continue;

        n++;
        psi->dwFlags |= STREAM_NEEDUPDATE;
    }

    //
    // !!!is this right? or should we always dirty the movie?
    //
    if (n > 0)
        npMCI->dwFlags |= MCIAVI_NEEDUPDATE;
    else
        npMCI->dwFlags &= ~MCIAVI_NEEDUPDATE;
}

//
//  update all dirty streams
//
//  if fPaint is set paint the area even if the stream handler does not
//
BOOL NEAR PASCAL DoStreamUpdate(NPMCIGRAPHIC npMCI, BOOL fPaint)
{
    int i;
    BOOL f=TRUE;
    STREAMINFO *psi;

    // This routine is called on both the winproc and worker threads
    EnterHDCCrit(npMCI);            // Protect hdc use/changes
    Assert(npMCI->hdc);
    SaveDC(npMCI->hdc);

    for (i=0; i<npMCI->streams; i++) {

        psi = SI(i);

        //
        // this stream is clean, dont paint it.
        //
        if (!(psi->dwFlags & (STREAM_DIRTY|STREAM_NEEDUPDATE))) {

            ExcludeClipRect(npMCI->hdc,
                DEST(i).left,DEST(i).top,DEST(i).right,DEST(i).bottom);

            continue;
        }

        psi->dwFlags &= ~STREAM_NEEDUPDATE;
        psi->dwFlags &= ~STREAM_DIRTY;

        if (psi->dwFlags & STREAM_ERROR) {
            UINT u, cb;
            TCHAR ach[80];
            TCHAR szMessage[80];
            HBRUSH hbr = CreateHatchBrush(HS_BDIAGONAL, RGB(128,0,0));

            if (psi->sh.fccType == streamtypeVIDEO)
                 LoadString(ghModule, MCIAVI_CANT_DRAW_VIDEO, ach, NUMELMS(ach));
            else
                 LoadString(ghModule, MCIAVI_CANT_DRAW_STREAM, ach, NUMELMS(ach));

            FillRect(npMCI->hdc, &DEST(i), hbr);
            u = SetBkMode(npMCI->hdc, OPAQUE);
            cb = wsprintf(szMessage, ach,
                (LPVOID)&psi->sh.fccType,
                (LPVOID)&psi->sh.fccHandler);
            DrawText(npMCI->hdc, szMessage, cb, &DEST(i),
                 DT_NOPREFIX|DT_WORDBREAK|DT_VCENTER|DT_CENTER);
            SetBkMode(npMCI->hdc, u);
            DeleteObject(hbr);

            FrameRect(npMCI->hdc, &DEST(i), GetStockObject(BLACK_BRUSH));
        }

        else if (!(psi->dwFlags & STREAM_ENABLED)) {
            FillRect(npMCI->hdc, &DEST(i), GetStockObject(DKGRAY_BRUSH));
        }

        else if (psi->sh.fccType == streamtypeVIDEO &&
            !(npMCI->dwFlags & MCIAVI_SHOWVIDEO)) {

            continue;   // we will paint black here.
        }

        else if (npMCI->nVideoStreams > 0 && i == npMCI->nVideoStream) {
	    BOOL fDraw;
	    try {
		fDraw = DrawBits(npMCI, 0L, 0L, FALSE);
	    } except (EXCEPTION_EXECUTE_HANDLER) {
		fDraw = FALSE;
	    }

            if (!fDraw) {
                psi->dwFlags |= STREAM_NEEDUPDATE;
                f = FALSE;

                if (fPaint)         // will paint back if told to.
                    continue;
            }
        }
        else if (psi->hicDraw == NULL) {
            FillRect(npMCI->hdc, &DEST(i), GetStockObject(DKGRAY_BRUSH));
        }
        else if (ICDraw(psi->hicDraw,ICDRAW_UPDATE,psi->lpFormat,NULL,0,0) != 0) {

            psi->dwFlags |= STREAM_NEEDUPDATE;
            f = FALSE;

            // should other streams work like this?

            if (fPaint)             // will paint back if told to.
                continue;
        }

        //
        //  we painted so clean this area
        //
        ExcludeClipRect(npMCI->hdc,
            DEST(i).left,DEST(i).top,DEST(i).right,DEST(i).bottom);
    }

    // now paint black every where else

    FillRect(npMCI->hdc,&npMCI->rcDest,GetStockObject(BLACK_BRUSH));
    RestoreDC(npMCI->hdc, -1);
    LeaveHDCCrit(npMCI);

    //
    // do we still still need a update?
    //
    if (f) {
        npMCI->dwFlags &= ~MCIAVI_NEEDUPDATE;
    }
    else {
        DPF2(("StreamUpdate: update failed\n"));
        npMCI->dwFlags |= MCIAVI_NEEDUPDATE;
    }

    return f;
}

#ifdef _WIN32
    #define DWORG POINT
    #define GETDCORG(hdc, dwOrg)  GetDCOrgEx(hdc, &dwOrg)
#else
    #define DWORG DWORD
    #define GETDCORG(hdc, dwOrg)  dwOrg = GetDCOrg(hdc)
#endif

#ifdef DAYTONA
#define AlignPlaybackWindow(npMCI)
#else
STATICFN void NEAR PASCAL AlignPlaybackWindow(NPMCIGRAPHIC npMCI)
{
    DWORG dw;
    int x,y;
    HWND hwnd;      // the window we will move.
    RECT rc;

    // if (npMCI->hicDraw != npMCI->hicDrawInternal)
    //	    return;  !!! only align if using the default draw guy?

#pragma message("**** move this into the draw handler and/or DrawDib")
#pragma message("**** we need to query the alignment from the codec????")
    #define X_ALIGN 4
    #define Y_ALIGN 4

    // the MCIAVI_RELEASEDC flags means the DC came from a GetDC(npMCI->hwnd)

    if (!(npMCI->dwFlags & MCIAVI_RELEASEDC)) {
        DPF0(("Align: MCIAVI_RELEASEDC\n"));
        return;
    }

    //
    // dont align if the dest rect is not at 0,0
    //
    if (npMCI->rcMovie.left != 0 || npMCI->rcMovie.top != 0) {
        DPF0(("Align: not at 0,0\n"));
        return;
    }

    GETDCORG(npMCI->hdc, dw);
#ifdef _WIN32
    x = dw.x + npMCI->rcMovie.left;
    y = dw.y + npMCI->rcMovie.top;
#else
    x = LOWORD(dw) + npMCI->rcMovie.left;
    y = HIWORD(dw) + npMCI->rcMovie.top;
#endif

    if ((x & (X_ALIGN-1)) || (y & (Y_ALIGN-1)))
    {
        DPF0(("*** warning movie is not aligned! (%d,%d)***\n",x,y));

        //
        // find the first moveable window walking up the tree.
        //
        for (hwnd = npMCI->hwndPlayback; hwnd; hwnd = GetParent(hwnd))
        {
            LONG l = GetWindowLong(hwnd, GWL_STYLE);
	
            // this window is toplevel stop
            if (!(l & WS_CHILD))
                break;

            // this window is sizeable (should be movable too)
            if (l & WS_THICKFRAME)
                break;

            // this window has a caption (is moveable)
            if ((l & WS_CAPTION) == WS_CAPTION)
                break;
	}
	
        //
        // dont move the window if it does not want to be moved.
        //
        if (IsWindowVisible(hwnd) &&
           !IsZoomed(hwnd) &&
           !IsIconic(hwnd) &&
            IsWindowEnabled(hwnd))
        {
            GetClientRect(hwnd, &rc);
            ClientToScreen(hwnd, (LPPOINT)&rc);

            //
            // if the movie is not in the upper corner of the window
            // don't align
            //
            if (x < rc.left || x-rc.left > 16 ||
                y < rc.top  || y-rc.top > 16)
                return;

            GetWindowRect(hwnd, &rc);
            OffsetRect(&rc, -(x & (X_ALIGN-1)), -(y & (Y_ALIGN-1)));

            if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
                ScreenToClient(GetParent(hwnd), (LPPOINT)&rc);

            // dont move window off the screen.

            if (rc.left < 0 || rc.top < 0) {
                DPF0(("Align: not off the screen\n"));
                return;
            }

            DPF0(("*** moving window to [%d,%d,%d,%d]\n",rc));

	    // We must relinquish the critical section before moving the
	    // window otherwise the WinProc thread will not run
	    LeaveWinCrit(npMCI);
            SetWindowPos(hwnd,NULL,rc.left,rc.top,0,0,
                SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
	    EnterWinCrit(npMCI);
            DPF0(("Align: window moved\n"));
#ifdef _WIN32
// with fulldrag the window may move again between setting the
// position and checking here that it is aligned.  Do NOT assert...
	    return;
#endif

#ifdef DEBUG
            GETDCORG(npMCI->hdc, dw);
#ifdef _WIN32
	    x = dw.x + npMCI->rcMovie.left;
	    y = dw.y + npMCI->rcMovie.top;
#else
	    x = LOWORD(dw) + npMCI->rcMovie.left;
	    y = HIWORD(dw) + npMCI->rcMovie.top;
#endif
            Assert(!(x & (X_ALIGN-1)) && !(y & (Y_ALIGN-1)));
#endif
	}
    } else {
	DPF0(("Aligning playback window - no movement\n"));
    }
}
#endif
	
UINT NEAR PASCAL PrepareDC(NPMCIGRAPHIC npMCI)
{
    UINT u;
    int i;
    STREAMINFO *psi;

    HDCCritCheckIn(npMCI);
    DPF2(("*** PrepareDC(%04X)\n",npMCI->hdc));

    // If we simply
    //	Assert(npMCI->hdc != NULL);
    // and the assertion fails a message box appears.  Message boxes allow
    // processing to continue.  In all likelihood the avi will need repainting, and
    // a WM_PAINT (or a palette change) will cause GraphicWndProc to wake up while the
    // assertion is being displayed.  This will only add to the confusion.
    if (npMCI->hdc == NULL) {
	DPF0(("** NULL hdc from PrepareDC **\n"));
	return 0;
    }

    if (!(npMCI->dwFlags & MCIAVI_FULLSCREEN) &&
        !(npMCI->dwFlags & MCIAVI_SEEKING) &&
        !(npMCI->dwFlags & MCIAVI_UPDATING) &&
         (npMCI->dwFlags & MCIAVI_SHOWVIDEO) ) {
        AlignPlaybackWindow(npMCI);
    }

    if (npMCI->hicDraw) {
	DPF2(("Calling ICDrawRealize\n"));
        u = (UINT)ICDrawRealize(npMCI->hicDraw, npMCI->hdc, npMCI->fForceBackground);
    } else {
        u = 0;
    }

    //
    //  realize the other strems, but force them into the background.
    //
    for (i=0; i<npMCI->streams; i++) {
        psi = SI(i);

        if (!(psi->dwFlags & STREAM_ENABLED))
            continue;

        if (psi->dwFlags & STREAM_ERROR)
            continue;

        if (psi == npMCI->psiVideo)
            continue;

        if (psi->hicDraw == NULL)
            continue;

        if (psi->hicDraw == npMCI->hicDraw)
            continue;

        ICDrawRealize(psi->hicDraw, npMCI->hdc, TRUE);
    }

    //
    // return "master" stream realize value.
    //
    return u;
}

void NEAR PASCAL UnprepareDC(NPMCIGRAPHIC npMCI)
{
    Assert(npMCI->hdc);
    DPF2(("*** UnprepareDC(%04X)\n",npMCI->hdc));
    SelectPalette(npMCI->hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
    RealizePalette(npMCI->hdc);
    //RestoreDC(npMCI->hdc, -1);
}

/* This function is called to actually handle drawing.
**
** ckid and cksize specify the type and size of the data to be drawn;
** it's located at npMCI->lp.
**
** If the fHurryUp flag is set, that means that we're behind and we
** shouldn't draw now. all we do it update the current buffered image
** and return...
*/

BOOL NEAR PASCAL DrawBits(NPMCIGRAPHIC npMCI, DWORD ckid, DWORD cksize, BOOL fHurryUp)
{
    LPVOID	lp = npMCI->lp;
    LPBITMAPINFOHEADER	lpFormat = npMCI->pbiFormat;
    DWORD       dwRet;
    DWORD       dwFlags;
    STREAMINFO *psi;

    if (!npMCI->pbiFormat)
	return TRUE;

    if (npMCI->fNoDrawing || !(npMCI->dwFlags & MCIAVI_SHOWVIDEO))
        return TRUE;

    psi = SI(npMCI->nVideoStream);

    //
    //  let's compute the flags we need to pass to ICDecompress() and
    //  to ICDraw()
    //
    //      ICDRAW_HURRYUP      - we are behind
    //      ICDRAW_PREROLL      - we are seeking (before a play)
    //      ICDRAW_UPDATE       - update of frame (repaint, ...)
    //      ICDRAW_NOTKEYFRAME  - this frame data is not a key.
    //

    dwFlags = 0;

    if (psi->dwFlags & STREAM_NEEDUPDATE)
        dwFlags |= ICDRAW_UPDATE;

    if (cksize == 0)
        dwFlags |= ICDRAW_NULLFRAME;

    if (ckid == 0) {
        dwFlags |= ICDRAW_UPDATE;
        lp = 0;
    }
    else if (fHurryUp) {
        dwFlags |= ICDRAW_HURRYUP;
        psi->dwFlags |= STREAM_DIRTY;
    }
    else if (!(npMCI->dwFlags & MCIAVI_REVERSE) &&
             (npMCI->lCurrentFrame < npMCI->lRealStart)) {
        dwFlags |= ICDRAW_PREROLL;
        psi->dwFlags |= STREAM_DIRTY;
    }

    if (npMCI->hpFrameIndex) {
        if ((ckid == 0L || cksize == 0) ||
                    FramePrevKey(npMCI->lCurrentFrame) != npMCI->lCurrentFrame)
            dwFlags |= ICDRAW_NOTKEYFRAME;
    }

    //
    //  now draw the frame, decompress first if needed.
    //
    if (npMCI->hic) {

        if (ckid != 0L && cksize != 0) {

            TIMESTART(timeDecompress);

	    npMCI->pbiFormat->biSizeImage = cksize; // !!! Is this safe?

	    dwRet = ICDecompress(npMCI->hic,
		    dwFlags,
		    npMCI->pbiFormat,
		    npMCI->lp,
		    &npMCI->bih,
		    npMCI->hpDecompress);

	    TIMEEND(timeDecompress);

	    if (dwRet == ICERR_DONTDRAW) {
		return TRUE; // !!!???
            }

	    // ICERR_NEWPALETTE?

	    dwFlags &= (~ICDRAW_NOTKEYFRAME);	// It's a key frame now....
        }

        if (dwFlags & (ICDRAW_HURRYUP|ICDRAW_PREROLL))
            return TRUE;

	lpFormat = &npMCI->bih;
	lp = npMCI->hpDecompress;
	cksize = npMCI->bih.biSizeImage;
    }

    TIMESTART(timeDraw);

    if ((npMCI->dwFlags & MCIAVI_PALCHANGED) &&
        !(dwFlags & (ICDRAW_HURRYUP|ICDRAW_PREROLL))) {

#ifdef USEAVIFILE
        if (psi->ps) {
            if (npMCI->hic) {
                //!!! should be psi->lpFormat *not* npMCI->pbiFormat
                ICDecompressGetPalette(npMCI->hic, npMCI->pbiFormat, &npMCI->bih);
                ICDrawChangePalette(npMCI->hicDraw, &npMCI->bih);
            }
            else {
                ICDrawChangePalette(npMCI->hicDraw, npMCI->pbiFormat);
            }
        }
        else
#endif
        {
            DPF2(("Calling ICDrawChangePalette\n"));
            ICDrawChangePalette(npMCI->hicDraw, &npMCI->bih);
        }

        npMCI->dwFlags &= ~(MCIAVI_PALCHANGED);

        dwFlags &= ~ICDRAW_HURRYUP; // should realy draw this!
    }

    if ((npMCI->dwFlags & MCIAVI_SEEKING) &&
        !(dwFlags & ICDRAW_PREROLL))
        PrepareDC(npMCI);

    lpFormat->biSizeImage = cksize; // !!! ??? Is this safe?

    //
    // !!!do we realy realy want to do this here?
    // or just relay on the MPlay(er) status function
    //
////if (npMCI->dwFlags & MCIAVI_WANTMOVE)
////    CheckWindowMoveFast(npMCI);

    DPF3(("Calling ICDraw on frame %ld  (%08lx)\n", npMCI->lCurrentFrame, dwFlags));

    dwRet = ICDraw(npMCI->hicDraw, dwFlags, lpFormat, lp, cksize,
		   npMCI->lCurrentFrame - npMCI->lFramePlayStart);

    TIMEEND(timeDraw);

    if ((LONG) dwRet < ICERR_OK) {
	DPF(("Driver failed ICM_DRAW message err=%ld\n", dwRet));
	return FALSE;
    }
    else {

        psi->dwFlags &= ~STREAM_NEEDUPDATE;

        if (!(dwFlags & (ICDRAW_HURRYUP|ICDRAW_PREROLL)))
            psi->dwFlags &= ~STREAM_DIRTY;
    }

    if (ICERR_STOPDRAWING == dwRet) {
	npMCI->dwFlags |= MCIAVI_STOP;
    }

#ifdef INTERVAL_TIMES
    // grab the interframe interval as soon as the video is shown
    if (npMCI->wTaskState == TASKPLAYING) {
	DWORD   dwTime = timeGetTime();

	if (npMCI->nFrames > 0) {
	    long lMsecs = (LONG) dwTime - npMCI->dwStartTime;

	    if (lMsecs < npMCI->msFrameMin) {
		npMCI->msFrameMin = lMsecs;
	    }
	    if (lMsecs > npMCI->msFrameMax) {
		npMCI->msFrameMax = lMsecs;
	    }
	    npMCI->msFrameTotal += lMsecs;
	    npMCI->msSquares += (lMsecs * lMsecs);

	    if (lMsecs < NBUCKETS * BUCKETSIZE)
		npMCI->buckets[lMsecs/BUCKETSIZE]++;
	    else
		npMCI->buckets[NBUCKETS]++;

	    if (npMCI->nFrames < npMCI->cIntervals)
		*(npMCI->paIntervals+npMCI->nFrames) = lMsecs;
	}
	npMCI->nFrames++;
	npMCI->dwStartTime = dwTime;
    }
#endif

    return TRUE;
}

/***************************************************************************
 ***************************************************************************/

#if 0
static void FreeDecompressBuffer(NPMCIGRAPHIC npMCI)
{
    if (npMCI->hpDecompress)
	GlobalFreePtr(npMCI->hpDecompress);

    npMCI->hpDecompress = NULL;
    npMCI->cbDecompress = 0;
}
#endif

/***************************************************************************
 ***************************************************************************/

static BOOL GetDecompressBuffer(NPMCIGRAPHIC npMCI)
{
    int n = npMCI->nVideoStream;
    int dxDest = RCW(DEST(n));
    int dyDest = RCH(DEST(n));
    HPSTR   hp;

    npMCI->bih.biSizeImage = npMCI->bih.biHeight * DIBWIDTHBYTES(npMCI->bih);

    if ((LONG) npMCI->bih.biSizeImage <= npMCI->cbDecompress)
	return TRUE;

    if (!npMCI->hpDecompress)
	hp = GlobalAllocPtr(GHND|GMEM_SHARE, npMCI->bih.biSizeImage);
    else
	hp = GlobalReAllocPtr(npMCI->hpDecompress,
			      npMCI->bih.biSizeImage,
			      GMEM_MOVEABLE | GMEM_SHARE);

    if (hp == NULL) {
        npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
        return FALSE;
    }

    npMCI->hpDecompress = hp;
    npMCI->cbDecompress = npMCI->bih.biSizeImage;

    return TRUE;
}



/*
Possibilities:

1. We're starting to play.
We may need to switch into fullscreen mode.
We need a DrawBegin.


2. We're updating the screen.
Do we send a new DrawBegin?
Has anything changed since we last updated?  Perhaps we can use
a flag to say whether something has changed, and set it when we leave
fullscreen mode or when the window is stretched.

What if we're updating to memory?

3. We're playing, and the user has stretched the window.
The Draw device may need us to go back to a key frame.
If we have a separate decompressor, it may need us to go back to a key frame.


*/

#if 0
RestartCompressor()
{
    DWORD dwDrawFlags;

    dwDrawFlags = (npMCI->dwFlags & MCIAVI_FULLSCREEN) ?
				    ICDRAW_FULLSCREEN : ICDRAW_HDC;

    if (pfRestart)
	dwDrawFlags |= ICDRAW_CONTINUE;

    if (npMCI->dwFlags & MCIAVI_UPDATETOMEMORY)
	dwDrawFlags |= ICDRAW_MEMORYDC;


    if (npMCI->hic) {
	static struct  {
	    BITMAPINFOHEADER bi;
	    RGBQUAD          rgbq[256];
	}   dib;


    }
}
#endif


STATICFN BOOL TryDrawDevice(NPMCIGRAPHIC npMCI, HIC hicDraw, DWORD dwDrawFlags, BOOL fTryDecompress)
{
    LRESULT   dw;
    int     n = npMCI->nVideoStream;
    STREAMINFO *psi = SI(n);

    Assert(psi);

    if (hicDraw == NULL)
        return FALSE;

    // See if the standard draw device can handle the format
    dw = ICDrawBegin(hicDraw,
        dwDrawFlags,

        npMCI->hpal,           // palette to draw with
        npMCI->hwndPlayback,   // window to draw to
        npMCI->hdc,            // HDC to draw to

	RCX(DEST(n)),
	RCY(DEST(n)),
	RCW(DEST(n)),
	RCH(DEST(n)),

        npMCI->pbiFormat,

	RCX(SOURCE(n)),
	RCY(SOURCE(n)),
	RCW(SOURCE(n)),
	RCH(SOURCE(n)),

	// !!! First of all, these two are backwards.
	// !!! Secondly, what if PlayuSec == 0?
	npMCI->dwPlayMicroSecPerFrame,
	1000000L);

    if (dw == ICERR_OK) {
	npMCI->hic = 0;
	npMCI->hicDraw = hicDraw;

	return TRUE;
    }

    if (npMCI->hicDecompress && fTryDecompress) {
	RECT	rc;

	// Ask the draw device to suggest a format, then try to get our
	// decompressor to make that format.
	dw = ICDrawSuggestFormat(hicDraw,
				 npMCI->pbiFormat,
				 &npMCI->bih,
				 RCW(SOURCE(n)),
				 RCH(SOURCE(n)),
				 RCW(DEST(n)),
				 RCH(DEST(n)),
				 npMCI->hicDecompress);

        if ((LONG)dw >= 0)
            dw = ICDecompressQuery(npMCI->hicDecompress,
                    npMCI->pbiFormat,&npMCI->bih);

        if ((LONG)dw < 0) {
            //
            //  default to the right format for the screen, in case the draw guy
            //  fails the draw suggest.
            //
            ICGetDisplayFormat(npMCI->hicDecompress,
                    npMCI->pbiFormat,&npMCI->bih, 0,
                    MulDiv((int)npMCI->pbiFormat->biWidth, RCW(psi->rcDest),RCW(psi->rcSource)),
                    MulDiv((int)npMCI->pbiFormat->biHeight,RCH(psi->rcDest),RCH(psi->rcSource)));

            dw = ICDecompressQuery(npMCI->hicDecompress,
                    npMCI->pbiFormat,&npMCI->bih);

	    if (dw != ICERR_OK) {
		npMCI->dwTaskError = MCIERR_INTERNAL;
		return FALSE;
	    }
        }

        if (npMCI->bih.biBitCount <= 8) {
            ICDecompressGetPalette(npMCI->hicDecompress,
                        npMCI->pbiFormat, &npMCI->bih);
        }
	
#ifdef DEBUG
	DPF(("InitDecompress: Decompressing %dx%dx%d '%4.4ls' to %dx%dx%d\n",
	    (int)npMCI->pbiFormat->biWidth,
	    (int)npMCI->pbiFormat->biHeight,
	    (int)npMCI->pbiFormat->biBitCount,
	    (LPSTR)(
	    npMCI->pbiFormat->biCompression == BI_RGB ? "None" :
	    npMCI->pbiFormat->biCompression == BI_RLE8 ? "Rle8" :
	    npMCI->pbiFormat->biCompression == BI_RLE4 ? "Rle4" :
	    (LPSTR)&npMCI->pbiFormat->biCompression),
	    (int)npMCI->bih.biWidth,
	    (int)npMCI->bih.biHeight,
	    (int)npMCI->bih.biBitCount));
#endif

	if (!GetDecompressBuffer(npMCI))
	    return FALSE;

	//
	// setup the "real" source rect we will draw with.
	//
#if 0
	rc.left = (int) ((SOURCE(n).left * npMCI->bih.biWidth) / npMCI->pbiFormat->biWidth);
	rc.right = (int) ((SOURCE(n).right * npMCI->bih.biWidth) / npMCI->pbiFormat->biWidth);
	rc.top = (int) ((SOURCE(n).top * npMCI->bih.biHeight) / npMCI->pbiFormat->biHeight);
	rc.bottom = (int) ((SOURCE(n).bottom * npMCI->bih.biHeight) / npMCI->pbiFormat->biHeight);
#else
	rc = SOURCE(n);
	rc.left = (int) ((rc.left * npMCI->bih.biWidth) / npMCI->pbiFormat->biWidth);
	rc.right = (int) ((rc.right * npMCI->bih.biWidth) / npMCI->pbiFormat->biWidth);
	rc.top = (int) ((rc.top * npMCI->bih.biHeight) / npMCI->pbiFormat->biHeight);
	rc.bottom = (int) ((rc.bottom * npMCI->bih.biHeight) / npMCI->pbiFormat->biHeight);
#endif
	dw = ICDrawBegin(hicDraw,
	    dwDrawFlags,
	    npMCI->hpal,           // palette to draw with
	    npMCI->hwndPlayback,   // window to draw to
	    npMCI->hdc,            // HDC to draw to
	    RCX(DEST(n)),
	    RCY(DEST(n)),
	    RCW(DEST(n)),
	    RCH(DEST(n)),
	    &npMCI->bih,

	    rc.left, rc.top,
	    rc.right  - rc.left,
	    rc.bottom - rc.top,

	    // !!! First of all, these two are backwards.
	    // !!! Secondly, what if PlayuSec == 0?
	    npMCI->dwPlayMicroSecPerFrame,
	    1000000L);

	if (dw == ICERR_OK) {
	    npMCI->hic = npMCI->hicDecompress;
	    npMCI->hicDraw = hicDraw;
	
	    // Now, we have the format we'd like the decompressor to decompress to...
            dw = ICDecompressBegin(npMCI->hicDecompress,
				   npMCI->pbiFormat,
				   &npMCI->bih);

	    if (dw != ICERR_OK) {
		DPF(("DrawBegin: decompressor succeeded query, failed begin!\n"));
		ICDrawEnd(npMCI->hicDraw);

		return FALSE;
	    }
	    return TRUE;
	}

	if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	    npMCI->dwTaskError = MCIERR_AVI_NODISPDIB;
	}
    }

    return FALSE;
}

#ifndef DEBUG
INLINE
#endif
STATICFN BOOL FindDrawDevice(NPMCIGRAPHIC npMCI, DWORD dwDrawFlags)
{
    if (npMCI->dwFlags & MCIAVI_USERDRAWPROC) {
	// If the user has set a draw procedure, try it.
	if (TryDrawDevice(npMCI, npMCI->hicDrawDefault, dwDrawFlags, TRUE)) {
	    if (npMCI->hic) {
                DPF2(("Using decompressor, then application's draw device...\n"));
	    } else {
                DPF2(("Using application's draw device...\n"));
            }
	    return TRUE;
        }

	// If it fails, it fails.
	DPF(("Can't use application's draw device!\n"));
	return FALSE;
    }

    // First, try a pure draw device we've found.
    if (TryDrawDevice(npMCI, SI(npMCI->nVideoStream)->hicDraw, dwDrawFlags, FALSE)) {
        DPF2(("Draw device is drawing to the screen...\n"));
	return TRUE;
    }

    // Next, try see if the decompressor we found can draw too.
    // Should this even get asked before the guy above?!!!!
    if (TryDrawDevice(npMCI, npMCI->hicDecompress, dwDrawFlags, FALSE)) {
        DPF2(("Decompressor is drawing to the screen...\n"));
	return TRUE;
    }

    // No?  Then, get the standard draw device, for fullscreen or not.
    if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	// !!! If it's fullscreen, should we force a re-begin?
	// !!! Assume fullscreen only happens when play is starting?

	if (npMCI->hicDrawFull == NULL) {
            DPF2(("Opening default fullscreen codec...\n"));
            npMCI->hicDrawFull = ICOpen(streamtypeVIDEO,
                FOURCC_AVIFull,ICMODE_DRAW);

	    if (!npMCI->hicDrawFull)
		npMCI->hicDrawFull = (HIC) -1;
	}

	npMCI->hicDraw = npMCI->hicDrawFull;
    } else {
	if (npMCI->hicDrawDefault == NULL) {
            DPF2(("Opening default draw codec...\n"));
            npMCI->hicDrawDefault = ICOpen(streamtypeVIDEO,
                FOURCC_AVIDraw,ICMODE_DRAW);

	if (!npMCI->hicDrawDefault)
	    npMCI->hicDrawDefault = (HIC) -1;
        }

	npMCI->hicDraw = npMCI->hicDrawDefault;
    }

    // If there's an installed draw device, try it.
    if (npMCI->hicDraw && npMCI->hicDraw != (HIC) -1) {
	if (TryDrawDevice(npMCI, npMCI->hicDraw, dwDrawFlags, TRUE)) {
	    if (npMCI->hic) {
                DPF2(("Using decompressor, then default draw device...\n"));
	    } else {
                DPF2(("Using default draw device...\n"));
	    }
            return TRUE;
	}
    }

    if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	if (!npMCI->hicInternalFull)
	    npMCI->hicInternalFull = ICOpenFunction(streamtypeVIDEO,
		FOURCC_AVIFull,ICMODE_DRAW,(FARPROC)ICAVIFullProc);

	npMCI->hicDraw = npMCI->hicInternalFull;
    } else {
	if (!npMCI->hicInternal) {
	    npMCI->hicInternal = ICOpenFunction(streamtypeVIDEO,
		FOURCC_AVIDraw,ICMODE_DRAW,(FARPROC)ICAVIDrawProc);
#ifdef DEBUG
	    {
                // This is a hack to get the hdd back from AVIDrawOpen
		extern HDRAWDIB ghdd;
		npMCI->hdd = ghdd;
		ghdd = NULL;
	    }
#endif
	}

	npMCI->hicDraw = npMCI->hicInternal;
    }

    // As a last resort, try the built-in draw device.
    if (TryDrawDevice(npMCI, npMCI->hicDraw, dwDrawFlags, TRUE)) {
	if (npMCI->hic) {
            DPF2(("Using decompressor, then built-in draw device...\n"));
	} else {
            DPF2(("Using built-in draw device...\n"));
	}
	return TRUE;
    }

    // if we are failing because fullscreen, then return an error
    // indicating this
    if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	npMCI->dwTaskError = MCIERR_AVI_NODISPDIB;
    }
    return FALSE;
}

/**************************************************************************
* @doc  INTERNAL DRAWDIB
*
* @api BOOL | DibEq | This function compares two dibs.
*
* @parm LPBITMAPINFOHEADER lpbi1 | Pointer to one bitmap.
*       this DIB is assumed to have the colors after the BITMAPINFOHEADER
*
* @parm LPBITMAPINFOHEADER | lpbi2 | Pointer to second bitmap.
*       this DIB is assumed to have the colors after biSize bytes.
*
* @rdesc Returns TRUE if bitmaps are identical, FALSE otherwise.
*
**************************************************************************/
INLINE BOOL DibEq(LPBITMAPINFOHEADER lpbi1, LPBITMAPINFOHEADER lpbi2)
{
    return
        lpbi1->biCompression == lpbi2->biCompression   &&
        lpbi1->biSize        == lpbi2->biSize          &&
        lpbi1->biWidth       == lpbi2->biWidth         &&
        lpbi1->biHeight      == lpbi2->biHeight        &&
        lpbi1->biBitCount    == lpbi2->biBitCount;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | DrawBegin
 *
 *
 ***************************************************************************/
BOOL FAR PASCAL DrawBegin(NPMCIGRAPHIC npMCI, BOOL FAR *pfRestart)
{
    DWORD	dwDrawFlags;
    HIC		hicLast = npMCI->hic;
    HIC         hicLastDraw = npMCI->hicDraw;
    BITMAPINFOHEADER	bihDecompLast = npMCI->bih;

    if (npMCI->nVideoStreams == 0)
	return TRUE;

    if (!npMCI->pbiFormat)
        return TRUE;

    npMCI->fNoDrawing = FALSE;

    // if fullscreen, make sure we re-initialize....
    if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
    }

    dwDrawFlags = (npMCI->dwFlags & MCIAVI_FULLSCREEN) ?
				    ICDRAW_FULLSCREEN : ICDRAW_HDC;

    if (pfRestart) {
	dwDrawFlags |= ICDRAW_CONTINUE;
	*pfRestart = TRUE;
    }

    if (npMCI->dwFlags & MCIAVI_UPDATETOMEMORY)
	dwDrawFlags |= ICDRAW_MEMORYDC;

    // !!! What about "stupid mode"?

    //
    // if the file has no keyframes force a buffer
    //
    if (npMCI->dwKeyFrameInfo == 0)
        dwDrawFlags |= ICDRAW_BUFFER;

    //
    // if the file has few keyframes also force a buffer.
    //
    if (MovieToTime(npMCI->dwKeyFrameInfo) > KEYFRAME_PANIC_SPACE)
        dwDrawFlags |= ICDRAW_BUFFER;

    if (dwDrawFlags & ICDRAW_BUFFER)
        DPF(("Forcing a decompress buffer because too few key frames\n"));

    if (npMCI->wTaskState > TASKIDLE &&
	    !(npMCI->dwFlags & MCIAVI_SEEKING) &&
	    !(npMCI->dwFlags & MCIAVI_FULLSCREEN) &&
	    (npMCI->dwFlags & MCIAVI_ANIMATEPALETTE)) {
	dwDrawFlags |= ICDRAW_ANIMATE;
#if 0
//
// I moved all this into ShowStage() where you could claim it realy belongs.
//
        if (npMCI->hwnd == npMCI->hwndDefault &&
	    !(GetWindowLong(npMCI->hwnd, GWL_STYLE) & WS_CHILD))
            SetActiveWindow(npMCI->hwnd);
#endif
    }

    if (npMCI->hdc == NULL) {
        DPF2(("DrawBegin() with NULL hdc!\n"));
    }

    if (FindDrawDevice(npMCI, dwDrawFlags)) {
	if (npMCI->hicDraw != hicLastDraw || (npMCI->hic != hicLast) ||
	    (npMCI->hic && !DibEq(&npMCI->bih, &bihDecompLast))) {
	    // !!! This obviously shouldn't always be invalidated!
            //
	    // make sure the current image buffer is invalidated
            //
            DPF2(("Draw device is different; restarting....\n"));
            npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;

            npMCI->dwFlags |= MCIAVI_WANTMOVE;

	    if (pfRestart)
		*pfRestart = TRUE;
        }

        if (npMCI->dwFlags & MCIAVI_WANTMOVE)
            CheckWindowMove(npMCI, TRUE);

//	if (pfRestart)
//           *pfRestart = (dw == ICERR_GOTOKEYFRAME);

	npMCI->dwFlags &= ~(MCIAVI_NEEDDRAWBEGIN);

#if 0
	//
	// tell the compressor some interesting info.
	//

	if (npMCI->hicDraw) { // !!! Does npMCI->hic need to know this?
	    ICSendMessage(npMCI->hic, ICM_SET, ICM_FRAMERATE, npMCI->dwPlayMicroSecPerFrame);
	    ICSendMessage(npMCI->hic, ICM_SET, ICM_KEYFRAMERATE, npMCI->dwKeyFrameInfo);
	}
#endif

	return TRUE;
    }

    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | DrawEnd
 *
 * @parm NPMCIGRAPHIC | npMCI | pointer to instance data block.
 *
 ***************************************************************************/
void NEAR PASCAL DrawEnd(NPMCIGRAPHIC npMCI)
{
    if (!npMCI->pbiFormat)
	return;

    ICDrawEnd(npMCI->hicDraw);

    // if we were fullscreen, we now need to repaint and things....
    if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
    }

    /*
    ** let DrawDib clean up if we're animating the palette.
    */
    if (npMCI->wTaskState > TASKIDLE &&
        !(npMCI->dwFlags & MCIAVI_SEEKING) &&
        !(npMCI->dwFlags & MCIAVI_FULLSCREEN) &&
        !(npMCI->dwFlags & MCIAVI_UPDATING) &&
         (npMCI->dwFlags & MCIAVI_ANIMATEPALETTE)) {
	npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
	InvalidateRect(npMCI->hwndPlayback, NULL, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\aviplay.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1995. All rights reserved.

   Title:   aviplay.c - Code for actually playing AVI files, part of
	       AVI's background task.

*****************************************************************************/

#include "graphic.h"

#define AVIREADMANY             // read more than one record at a time

#ifdef _WIN32
//#define AVIREAD               // multi-threaded async read of file
#else
#undef AVIREAD
#endif

#ifdef AVIREAD
#include "aviread.h"
#endif

#define BOUND(x, low, high)     max(min(x, high), low)

#define ALIGNULONG(i)     ((i+3)&(~3))                  /* ULONG aligned ! */

#ifdef INTERVAL_TIMES
BOOL   fOneIntervalPerLine=FALSE;
#endif
//
// redefine StreamFromFOURCC to only handle 0-9 streams!
//
#undef StreamFromFOURCC
#define StreamFromFOURCC(fcc) (UINT)(HIBYTE(LOWORD(fcc)) - (BYTE)'0')

#ifdef DEBUG
static char szBadFrame[] = "Bad frame number";
static char szBadPos[]   = "Bad stream position";
#define AssertFrame(i)   AssertSz((long)(i) <= npMCI->lFrames && (long)(i) >= -(long)npMCI->wEarlyRecords, szBadFrame)
#define AssertPos(psi,i) AssertSz((long)(i) <= psi->lEnd && (long)(i) >= psi->lStart, szBadPos)
#else
#define AssertFrame(i)
#define AssertPos(psi,i)
#endif

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)

LONG NEAR PASCAL WhatFrameIsItTimeFor(NPMCIGRAPHIC npMCI);
LONG NEAR PASCAL HowLongTill(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL TimeToQuit(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL WaitTillNextFrame(NPMCIGRAPHIC npMCI);

void NEAR PASCAL FindKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos);
LONG NEAR PASCAL FindPrevKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos);
LONG NEAR PASCAL FindNextKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos);

BOOL NEAR PASCAL CalculateTargetFrame(NPMCIGRAPHIC npMCI);
DWORD NEAR PASCAL CalculatePosition(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL ReadRecord(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL ReadNextVideoFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi);
STATICFN INLINE DWORD NEAR PASCAL ReadNextChunk(NPMCIGRAPHIC npMCI);

BOOL NEAR PASCAL ReadBuffer(NPMCIGRAPHIC npMCI, LONG off, LONG len);
BOOL NEAR PASCAL AllocateReadBuffer(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL ResizeReadBuffer(NPMCIGRAPHIC npMCI, DWORD dwNewSize);
void NEAR PASCAL ReleaseReadBuffer(NPMCIGRAPHIC npMCI);

BOOL NEAR PASCAL ProcessPaletteChanges(NPMCIGRAPHIC npMCI, LONG lFrame);

STATICFN INLINE void DealWithOtherStreams(NPMCIGRAPHIC npMCI, LONG lFrame);
STATICFN INLINE BOOL NEAR PASCAL StreamRead(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos);

#ifdef _WIN32
#define AllocMem(dw) GlobalLock(GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE, (dw)))
#define FreeMem(lp) GlobalFreePtr(lp)
#else
static LPVOID AllocMem(DWORD dw);
#define FreeMem(lp) GlobalFree((HGLOBAL)SELECTOROF(lp))
#endif

INT     gwSkipTolerance = 4;
INT     gwHurryTolerance = 2;
INT     gwMaxSkipEver = 60;
#define YIELDEVERY      8

#ifdef DEBUG
#define WAITHISTOGRAM           /* Extra debugging information */
#define SHOWSKIPPED
//#define BEHINDHIST
#define DRAWTIMEHIST
#define READTIMEHIST
#define TIMEPLAY
#endif

#ifdef WAITHISTOGRAM
    UINT        wHist[100];
#endif

#define HIGHRESTIMER

#ifdef SHOWSKIPPED
#define NUMSKIPSSHOWN   25
    LONG        lSkipped[NUMSKIPSSHOWN];
    UINT        wSkipped = 0;
#endif
#ifdef BEHINDHIST
#define NUMBEHIND       50
#define BEHINDOFFSET    10
    WORD        wBehind[NUMBEHIND];
#endif
#ifdef DRAWTIMEHIST
#define NUMDRAWN        100
    DWORD       dwDrawTime[NUMDRAWN];
    UINT        wDrawn;
#endif
#ifdef READTIMEHIST
#define NUMREAD        100
    DWORD       dwReadTime[NUMREAD];
    UINT        wRead;
#endif

// If available, use a correctly functioning waveOutGetPosition
BOOL	gfUseGetPosition;
LONG	giGetPositionAdjust;

#ifdef AVIREAD
/*
 * the aviread object creates a worker thread to read the file
 * asynchronously. That thread calls this callback function
 * to actually read a buffer from the file. The 'instance data' DWORD in
 * this case is npMCI. see aviread.h for outline.
 */
BOOL mciaviReadBuffer(PBYTE pData, DWORD_PTR dwInstanceData, long lSize, long * lpNextSize)
{
    NPMCIGRAPHIC npMCI = (NPMCIGRAPHIC) dwInstanceData;
    DWORD size;
    DWORD UNALIGNED * lp;

    if(mmioRead(npMCI->hmmio, pData, lSize) != lSize) {
	return(FALSE);
    }

    /* we've read in the complete chunk, plus the FOURCC, size and formtype of
     * the next chunk. So the size of the next chunk is the last but one
     * DWORD in this buffer
     */
    lp = (DWORD UNALIGNED *) (pData + lSize - 2 * sizeof(DWORD));
    size = *lp;

    /* don't forget to add on the FOURCC and size dwords */
    *lpNextSize = size + 2 * sizeof(DWORD);

    return(TRUE);
}
#endif

//
// call this to find out the current position. This function
// should be safe to call from the user thread as well as from the
// worker thread

DWORD InternalGetPosition(NPMCIGRAPHIC npMCI, LPLONG lpl)
{
    LONG    l;

    l = npMCI->lCurrentFrame - npMCI->dwBufferedVideo;


    if ((npMCI->wTaskState == TASKCUEING) &&
       !(npMCI->dwFlags & MCIAVI_SEEKING) &&
       l < npMCI->lRealStart)
	l = npMCI->lRealStart;

    if (l < 0)
	l = 0;

    *lpl = l;

    return 0L;
}




STATICFN DWORD NEAR PASCAL PrepareToPlay(NPMCIGRAPHIC npMCI);
STATICFN DWORD NEAR PASCAL PrepareToPlay2(NPMCIGRAPHIC npMCI);
void  NEAR PASCAL CleanUpPlay(NPMCIGRAPHIC npMCI);
void  NEAR PASCAL CheckSignals(NPMCIGRAPHIC npMCI, LONG lFrame);

BOOL  NEAR PASCAL PlayNonInterleaved(NPMCIGRAPHIC npMCI);
BOOL  NEAR PASCAL PlayInterleaved(NPMCIGRAPHIC npMCI);
BOOL  NEAR PASCAL PlayAudioOnly(NPMCIGRAPHIC npMCI);
BOOL  NEAR PASCAL PlayNonIntFromCD(NPMCIGRAPHIC npMCI);
/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api UINT | mciaviPlayFile | Play an AVI file.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc Notification code that should be returned.
 *
 ***************************************************************************/

UINT NEAR PASCAL mciaviPlayFile (NPMCIGRAPHIC npMCI, BOOL bSetEvent)
{
    BOOL        fContinue;
    DWORD       dwFlags = npMCI->dwFlags;

    BOOL (NEAR PASCAL *Play)(NPMCIGRAPHIC npMCI);

#ifdef WAITHISTOGRAM
    UINT        w;
#endif
#ifdef SHOWSKIPPED
    wSkipped = 0;
#endif
#ifdef WAITHISTOGRAM
    //for (w = 0; (int)w < (sizeof(wHist)/sizeof(wHist[0])); w++)
	//wHist[w] = 0;
    ZeroMemory(wHist, sizeof(wHist));
#endif
#ifdef BEHINDHIST
    //for (w = 0; w < NUMBEHIND; w++)
	//wBehind[w] = 0;
    ZeroMemory(wBehind, sizeof(wBehind));
#endif
#ifdef DRAWTIMEHIST
    wDrawn = 0;
    //for (w = 0; w < NUMDRAWN; w++)
	//dwDrawTime[w] = 0;
    ZeroMemory(dwDrawTime, sizeof(dwDrawTime));
#endif
#ifdef READTIMEHIST
    wRead = 0;
    //for (w = 0; w < NUMREAD; w++)
	//dwReadTime[w] = 0;
    ZeroMemory(dwReadTime, sizeof(dwReadTime));
#endif


#ifdef HIGHRESTIMER
    /* Figure out how much time each frame takes */
    /* Then set a high resolution timer, unless  */
    /* we are in the special "play every frame". */

    if (npMCI->dwSpeedFactor) {

        // Only if we are worried about timing each frame...
	// Set a timer resolution for a fraction of the frame rate
	// Initially we set the timer to 4ms.  This initial guess can
	// be overridden by a registry setting.
	// Note: there is no UI (yet?) for writing a value to the registry

        if ((npMCI->msPeriodResolution = mmGetProfileInt(szIni, TEXT("TimerResolution"), 4))
           && (0 == timeBeginPeriod(npMCI->msPeriodResolution))) {
	    // Timer successfully set
            DPF1(("Set timer resolution to %d milliseconds\n", npMCI->msPeriodResolution));
        } else {
            TIMECAPS tc;
            if ((timeGetDevCaps(&tc, sizeof(tc)) == 0)  &&
                (0 == timeBeginPeriod(tc.wPeriodMin))) {
                    npMCI->msPeriodResolution = tc.wPeriodMin;
                    DPF1(("Set timer resolution to the minimum of %d milliseconds\n", npMCI->msPeriodResolution));
            } else {
                // Reset, so we do not try and call timeEndPeriod
                // (note: the value may have been set by mmGetProfileInt)
    	        npMCI->msPeriodResolution = 0;
                DPF1(("NO high resolution timer set\n"));
            }
        }
    }
#endif


Repeat:


    // internal task state (used only by worker thread to
    // distinguish cueing/seeking/playing)
    npMCI->wTaskState = TASKSTARTING;


    TIMEZERO(timePlay);
    TIMEZERO(timePrepare);
    TIMEZERO(timeCleanup);
    TIMEZERO(timePaused);
    TIMEZERO(timeRead);
    TIMEZERO(timeWait);
    TIMEZERO(timeYield);
    TIMEZERO(timeVideo);
    TIMEZERO(timeOther);
    TIMEZERO(timeAudio);
    TIMEZERO(timeDraw);
    TIMEZERO(timeDecompress);

    TIMESTART(timePrepare);
    npMCI->dwTaskError = PrepareToPlay(npMCI);

    TIMEEND(timePrepare);

#ifdef INTERVAL_TIMES
    // interframe timing
    npMCI->nFrames = 0;
    npMCI->msFrameTotal = 0;
    npMCI->msSquares = 0;
    npMCI->msFrameMax = 0;
    npMCI->msFrameMin = 9999;
    npMCI->msReadMaxBytesPer = 0;
    npMCI->msReadMax = 0;
    npMCI->nReads = 0;
    npMCI->msReadTotal = 0;
    npMCI->msReadTimeuS = 0;

    {
        int i;
	PLONG pL;
        //for (i = 0; i < NBUCKETS; i++) {
        //    npMCI->buckets[i] = 0;
        //}
	ZeroMemory(npMCI->buckets, NBUCKETS*sizeof(LONG));
	pL = npMCI->paIntervals;
	if (pL) {
	    ZeroMemory(pL, (npMCI->cIntervals)*sizeof(LONG));
	}
    }
#endif


    //
    //  pick a play function.
    //
    switch (npMCI->wPlaybackAlg) {
	case MCIAVI_ALG_INTERLEAVED:
	    Play = PlayInterleaved;
	    break;

#ifdef USENONINTFROMCD	
	case MCIAVI_ALG_CDROM:
	    Play = PlayNonIntFromCD;
	    break;
#endif

	case MCIAVI_ALG_HARDDISK:
	    Play = PlayNonInterleaved;
	    break;

	case MCIAVI_ALG_AUDIOONLY:
	    Play = PlayAudioOnly;
	    break;

	default:
	    Assert(0);
	    return MCI_NOTIFY_ABORTED; //???
    }

    // bias lTo by dwBufferedVideo so we play to the right place
    npMCI->lTo += npMCI->dwBufferedVideo;

    npMCI->lFramePlayStart = npMCI->lRealStart;

    DPF(("Playing from %ld to %ld, starting at %ld.  Flags=%0.8x\n", npMCI->lFrom, npMCI->lTo, npMCI->lCurrentFrame, npMCI->dwFlags));

    // at this point we have detected any errors that we are going to detect
    // during startup. we can complete the synchronous portion of the command
    // if requested to do so
    if (bSetEvent) {
	bSetEvent = FALSE;
	TaskReturns(npMCI, npMCI->dwTaskError);
    }

    if (npMCI->dwTaskError != 0L)
	goto SKIP_PLAYING;



    /* We're done initializing; now we're warming up to play. */
    npMCI->wTaskState = TASKCUEING;

    TIMESTART(timePlay);

  try {
  // If the avi file is corrupt we want to try and catch errors without
  // aborting the application.  Hence we need this try/except clause at
  // this very high level.  It PROBABLY costs too much to set up the
  // exception handler every time we want to draw a single frame.

    /* Loop until things are done */
    while (1) {

	if (npMCI->dwFlags & MCIAVI_REVERSE) {
	    if (npMCI->lCurrentFrame < npMCI->lTo)
		break;
	} else {
	    if (npMCI->lCurrentFrame > npMCI->lTo)
		break;
	}

	if ((npMCI->wTaskState != TASKPLAYING) &&
		!(npMCI->dwFlags & MCIAVI_UPDATING)) {

	    TIMESTART(timeYield);
	    aviTaskCheckRequests(npMCI);
	    TIMEEND(timeYield);
	}

	fContinue = Play(npMCI);

	if (fContinue) fContinue = !TimeToQuit(npMCI);

	if (!fContinue)
	    break;

	//
	//  while playing we may need to update
	//
	//  always mark the movie as clean, even if a stream fails to update
	//  otherwise we will need to stop play and restart.
	//
	if (!(npMCI->dwFlags & MCIAVI_SEEKING) &&
	     (npMCI->dwFlags & MCIAVI_NEEDUPDATE)) {
	    DoStreamUpdate(npMCI, FALSE);

	    if (npMCI->dwFlags & MCIAVI_NEEDUPDATE) {
		DOUT("Update failed while playing, I dont care!\n");
		npMCI->dwFlags &= ~MCIAVI_NEEDUPDATE;   //!!! I dont care if it failed
	    }
	}

	/* Increment the frame number.  If we're done, don't increment
	** it an extra time, but just get out.
	*/
	if (npMCI->dwFlags & MCIAVI_REVERSE) {
	    if (npMCI->lCurrentFrame > npMCI->lTo)
		--npMCI->lCurrentFrame;
	    else
		break;
	} else {
	    if (npMCI->lCurrentFrame < npMCI->lTo)
		++npMCI->lCurrentFrame;
	    else {

		// need to ensure that we wait for audio to complete on the
		// last frame played
		if ((npMCI->lFrom != npMCI->lTo) &&
		    (npMCI->wTaskState == TASKPLAYING)) {

		    npMCI->lCurrentFrame++;
		    WaitTillNextFrame(npMCI);
		    npMCI->lCurrentFrame--;
		}

		break;
	    }
	}
    }
  } except (EXCEPTION_EXECUTE_HANDLER) {
      npMCI->dwTaskError = MCIERR_DRIVER_INTERNAL;
  }

    TIMEEND(timePlay);

    if (npMCI->lCurrentFrame != npMCI->lTo) {

	DPF(("Ended at %ld, not %ld (drawn = %ld).\n", npMCI->lCurrentFrame, npMCI->lTo, npMCI->lFrameDrawn));

	//
	// if we ended early lets set lCurrentFrame to the last frame
	// drawn to guarantee we can re-paint the frame, we dont
	// want to do this when we play to end because after playing
	// from A to B the current position *must* be B or preston will
	// enter a bug.
	//
	// but only set this if lFrameDraw is valid
	//

	if (npMCI->lFrameDrawn > (-(LONG)npMCI->wEarlyRecords))
	    npMCI->lCurrentFrame = npMCI->lFrameDrawn;
    }

SKIP_PLAYING:
    /* Flush any extra changes out to screen */

    DPF2(("Updating unfinished changes....\n"));

    // Make sure we really draw.... !!!do we need this?
    // npMCI->lRealStart = npMCI->lCurrentFrame;

    if (npMCI->hdc)
	DoStreamUpdate(npMCI, FALSE);

    npMCI->lTo -= npMCI->dwBufferedVideo;
    npMCI->lCurrentFrame -= npMCI->dwBufferedVideo;
    npMCI->dwBufferedVideo = 0;

    if (npMCI->lCurrentFrame < 0) {
	DPF2(("Adjusting position to be >= 0.\n"));
	npMCI->lCurrentFrame = 0;
    }

    if (npMCI->lTo < 0)
	npMCI->lTo = 0;

    /* Adjust position to be > start? */
    /* Adjust position to be > where it was when we began? */

    npMCI->dwTotalMSec += Now() - npMCI->dwMSecPlayStart;

    TIMESTART(timeCleanup);
    DPF(("Cleaning up the play\n"));
    CleanUpPlay(npMCI);
    TIMEEND(timeCleanup);

#ifdef AVIREAD
    /* shut down async reader */
    if (npMCI->hAviRd) {
	avird_endread(npMCI->hAviRd);
	npMCI->hAviRd = NULL;
    }
#endif

    /* If we're repeating, do it.  It sure would be nice if we could repeat
    ** without de-allocating and then re-allocating all of our buffers....
    */
    if (npMCI->dwTaskError == 0 && (!(npMCI->dwFlags & MCIAVI_STOP)) &&
		(npMCI->dwFlags & MCIAVI_REPEATING)) {
	npMCI->lFrom = npMCI->lRepeatFrom;

	//
	//  DrawEnd() likes to clear this flag so make sure it gets set
	//  in the repeat case.
	//
	if (dwFlags & MCIAVI_FULLSCREEN)
	    npMCI->dwFlags |= MCIAVI_FULLSCREEN;

	//
	// make sure we set the task state back before we repeat.
	// otherwise our code will think we are playing, for example.
	// if the audio code thinks we are playing and see's the wave buffers
	// are empty it will reset the wave device then restart it when
	// they get full again, this is bad if we are pre-rolling audio.
	//
	npMCI->wTaskState = TASKSTARTING;

	DPF((".........repeating\n"));
	goto Repeat;
    }

    /* Turn off flags only used during play. */
    npMCI->dwFlags &= ~(MCIAVI_STOP | MCIAVI_PAUSE | MCIAVI_SEEKING |
	    MCIAVI_REPEATING | MCIAVI_FULLSCREEN);

    if (npMCI->wTaskState == TASKPLAYING) {
	DWORD   dwCorrectTime;
	DWORD   dwFramesPlayed;

	dwFramesPlayed = (npMCI->dwFlags & MCIAVI_REVERSE) ?
	    npMCI->lFramePlayStart - npMCI->lCurrentFrame :
	    npMCI->lCurrentFrame - npMCI->lFramePlayStart;

	dwCorrectTime = muldiv32(dwFramesPlayed,
				muldiv32(npMCI->dwMicroSecPerFrame,
					1000L,
					(npMCI->dwSpeedFactor == 0 ?
						1000 : npMCI->dwSpeedFactor)),
				1000);

	if (dwCorrectTime != 0 && npMCI->dwTotalMSec != 0)
	    npMCI->dwSpeedPercentage = muldiv32(dwCorrectTime, 100,
						npMCI->dwTotalMSec);
	else
	    npMCI->dwSpeedPercentage = 100;

	if (dwFramesPlayed > 15) {
	    npMCI->lFramesPlayed      = (LONG)dwFramesPlayed;
	    npMCI->lFramesSeekedPast  = (LONG)npMCI->dwFramesSeekedPast;
	    npMCI->lSkippedFrames     = (LONG)npMCI->dwSkippedFrames;
	    npMCI->lAudioBreaks       = (LONG)npMCI->dwAudioBreaks;
	}

#ifdef DEBUG
	if (npMCI->dwFramesSeekedPast) {
	    DPF(("Didn't even read %ld frames.\n", npMCI->dwFramesSeekedPast));
	}
	if (npMCI->dwSkippedFrames && dwFramesPlayed > 0) {
	    DPF(("Skipped %ld of %ld frames. (%ld%%)\n",
			npMCI->dwSkippedFrames, dwFramesPlayed,
			npMCI->dwSkippedFrames*100/dwFramesPlayed));
	}
	if (npMCI->dwAudioBreaks) {
	    DPF(("Audio broke up %lu times.\n", npMCI->dwAudioBreaks));
	}
#ifndef TIMEPLAY
	DPF(("Played at %lu%% of correct speed.\n", npMCI->dwSpeedPercentage));
	DPF(("Correct time = %lu ms, Actual = %lu ms.\n",
				    dwCorrectTime, npMCI->dwTotalMSec));
#endif
#endif

    // don't print pages of stuff when we've just stopped temporarily,
    // it gets on my nerves.
    if (! (npMCI->dwFlags & MCIAVI_UPDATING)) {
#ifdef DEBUG
        extern int giDebugLevel, giTimingLevel;
        int oldDebugLevel = giDebugLevel;
        giDebugLevel = max(giTimingLevel, oldDebugLevel);
#endif

#ifdef SHOWSKIPPED
	if (wSkipped) {
	    DPF(("Skipped: "));
	    for (w = 0; w < wSkipped; w++) {
		DPF(("!%ld ", lSkipped[w]));
	    }
	    DPF(("!\n"));
	}
#endif

#ifdef WAITHISTOGRAM
	if (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED) {
	    DPF(("Wait histogram: "));
	    for (w = 0; (int)w <= (int)npMCI->wABs; w++) {
		if (wHist[w]) {
		    DPF(("![%d]: %d  ",w,wHist[w]));
		}
	    }
	    DPF(("!\n"));
	}
#endif
#ifdef BEHINDHIST
	DPF(("Behind histogram: "));
	for (w = 0; w <= NUMBEHIND; w++) {
	    if (wBehind[w]) {
		DPF(("![%d]: %d  ",w - BEHINDOFFSET,wBehind[w]));
	    }
	}
	DPF(("!\n"));
#endif
#ifdef DRAWTIMEHIST
	DPF(("Draw times: "));
	for (w = 0; w < wDrawn; w++) {
	    DPF(("!%lu ", dwDrawTime[w]));
	}
	DPF(("!\n"));
#endif

#ifdef READTIMEHIST
	DPF(("Read times: "));
	for (w = 0; w < wRead; w++) {
	    DPF(("!%lu ", dwReadTime[w]));
	}
	DPF(("!\n"));
#endif

#ifdef TIMEPLAY
	#define SEC(time)    (UINT)(npMCI->time / 1000l) , (UINT)(npMCI->time % 1000l)
	#define SECX(time,t) SEC(time) , (npMCI->t ? (UINT)(npMCI->time * 100l / npMCI->t) : 0)

	DPF(("***********************************************************\r\n"));
	DPF(("    timePlay:         %3d.%03dsec\r\n",SEC(timePlay)));
	DPF(("     timeRead:        %3d.%03dsec (%d%%)\r\n",SECX(timeRead, timePlay)));
	DPF(("     timeWait:        %3d.%03dsec (%d%%)\r\n",SECX(timeWait, timePlay)));
	DPF(("     timeYield:       %3d.%03dsec (%d%%)\r\n",SECX(timeYield, timePlay)));
	DPF(("     timeVideo:       %3d.%03dsec (%d%%)\r\n",SECX(timeVideo, timePlay)));
	DPF(("      timeDraw:       %3d.%03dsec (%d%%)\r\n",SECX(timeDraw, timeVideo)));
	DPF(("      timeDecompress: %3d.%03dsec (%d%%)\r\n",SECX(timeDecompress, timeVideo)));
	DPF(("     timeAudio:       %3d.%03dsec (%d%%)\r\n",SECX(timeAudio, timePlay)));
	DPF(("     timeOther:       %3d.%03dsec (%d%%)\r\n",SECX(timeOther, timePlay)));
	DPF(("    timePaused:       %3d.%03dsec\r\n",SEC(timePaused)));
	DPF(("    timePrepare:      %3d.%03dsec\r\n",SEC(timePrepare)));
	DPF(("    timeCleanup:      %3d.%03dsec\r\n",SEC(timeCleanup)));
	DPF(("***********************************************************\r\n"));
#endif

#ifdef INTERVAL_TIMES
// frame interval timing

        if (npMCI->nFrames > 2) {
            int i;

            DPF(("-- %ld frames, ave interval %ld ms\r\n", npMCI->nFrames,
                npMCI->msFrameTotal/(npMCI->nFrames-1)));
            DPF(("-- min %ld ms, max %ld ms\r\n", npMCI->msFrameMin, npMCI->msFrameMax));
            DPF(("-- sd = sqrt(%ld)\r\n",
                        (npMCI->msSquares -
                          MulDiv(npMCI->msFrameTotal,
                                 npMCI->msFrameTotal,
                                 npMCI->nFrames-1)
                        ) / (npMCI->nFrames-2)
               ));
            for (i = 3; i < NBUCKETS-3; i++) {
                DPF(("%d ms:  %d\r\n", i * 10, npMCI->buckets[i]));
            }

	    DPF(("Actual intervals:\r\n"));
	    for (i = 1; i < min(npMCI->cIntervals,npMCI->nFrames); i++) {
		DPF(("!%3ld ", *(npMCI->paIntervals+i)));
                if ((fOneIntervalPerLine) || ((i % 20) == 0))
		    DPF(("!\n"));
	    }
	    DPF(("!\r\n"));
	}

	if (npMCI->nReads > 0) {
	    DPF(("-- %ld disk reads, ave %ld ms, max %ld ms\r\n",
		 npMCI->nReads,
		 npMCI->msReadTotal/(npMCI->nReads),
		 npMCI->msReadMax));
	}
#ifdef DEBUG
	giDebugLevel = oldDebugLevel;
#endif
#endif
    }


    }

#ifdef HIGHRESTIMER

    /* If we set a high resolution timer earlier... */
    if (npMCI->msPeriodResolution) {
	// Clear the timer resolution
	timeEndPeriod(npMCI->msPeriodResolution);
        DPF1(("Cleared the timer resolution from %d milliseconds\n", npMCI->msPeriodResolution));
        npMCI->msPeriodResolution = 0;
    }
#endif

    // if we are not stopping temporarily, then set task state to idle
    if (! (npMCI->dwFlags & MCIAVI_UPDATING)) {
	npMCI->wTaskState = TASKIDLE;
    }


    DPF(("mciaviPlayFile ending, dwTaskError==%d\n",npMCI->dwTaskError));
    if (npMCI->dwTaskError)
	return MCI_NOTIFY_FAILURE;

    if (npMCI->dwFlags & MCIAVI_REVERSE) {
	if (npMCI->lCurrentFrame <= npMCI->lTo)
	    return MCI_NOTIFY_SUCCESSFUL;
    } else {
	if (npMCI->lCurrentFrame >= npMCI->lTo)
	    return MCI_NOTIFY_SUCCESSFUL;
    }

    return MCI_NOTIFY_ABORTED;
}

static BOOL NEAR PASCAL RestartAVI(NPMCIGRAPHIC npMCI);
static BOOL NEAR PASCAL PauseAVI(NPMCIGRAPHIC npMCI);
static BOOL NEAR PASCAL BePaused(NPMCIGRAPHIC npMCI);

/******************************************************************************
 *****************************************************************************/

#ifdef DEBUG

INLINE void FillR(HDC hdc, LPRECT prc, DWORD rgb)
{
    SetBkColor(hdc,rgb);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL);
}

void StatusBar(NPMCIGRAPHIC npMCI, int n, int dx, int max, int cur)
{
    HDC hdc;
    RECT rc;

    if (npMCI->dwFlags & MCIAVI_FULLSCREEN)
	return;

    if (cur > max)
	cur = max+1;

    if (cur < 0)
	cur = 0;

    /*
     * If the window is iconic, or there is no title bar, return
     * without painting the status bars.
     */

    if (!IsWindow(npMCI->hwndPlayback) || IsIconic(npMCI->hwndPlayback)) {
        return;
    }
    if (!(GetWindowLong((npMCI->hwndPlayback), GWL_STYLE) & WS_CAPTION)) {
        return;
    }

    hdc = GetWindowDC(npMCI->hwndPlayback);

    //
    //  show the amount of audio and how far behind we are
    //
    rc.left = 32;
    rc.top  = 4 + n*5;
    rc.bottom = rc.top + 4;

    rc.right = rc.left + cur * dx;

    FillR(hdc, &rc, RGB(255,255,0));

    rc.left = rc.right;
    rc.right = rc.left + (max - cur) * dx;

    FillR(hdc, &rc, RGB(255,0,0));

    ReleaseDC(npMCI->hwndPlayback, hdc);
}

#else

#define StatusBar(p,a,b,c,d)

#endif

/******************************************************************************
 *****************************************************************************/

BOOL NEAR PASCAL PlayInterleaved(NPMCIGRAPHIC npMCI)
{
    LONG iFrame;
    LONG iKey;
    LONG iNextKey;
    LONG iPrevKey;
    BOOL fHurryUp=FALSE;
    int  iHurryUp=0;
    BOOL fPlayedAudio = FALSE;
    BOOL f;

    DPF2(("PlayInterleaved, npMCI=%8x\n",npMCI));

    /* If lCurrentFrame == lFrames, we're really at the end of
    ** the file, so there isn't another record to read.
    */
    if (npMCI->lCurrentFrame < npMCI->lFrames) {
	/* Read new record into buffer */

	DPF2(("Reading", iFrame = (LONG)timeGetTime()));
	TIMESTART(timeRead);
	f = ReadRecord(npMCI);
	TIMEEND(timeRead);
	DPF2((".done %ldms\n", (LONG)timeGetTime() - iFrame));

	if (!f) {
	    npMCI->dwTaskError = MCIERR_INVALID_FILE;
	    DPF(("Error reading frame #%ld\n", npMCI->lCurrentFrame));
	    return FALSE;
	}


	if (npMCI->hWave && npMCI->lCurrentFrame >= npMCI->lAudioStart) {
	    TIMESTART(timeAudio);
	    if (!PlayRecordAudio(npMCI, &fHurryUp, &fPlayedAudio)) {
		DPF(("Error playing frame #%ld audio\n", npMCI->lCurrentFrame));
		return FALSE;
	    }
	    TIMEEND(timeAudio);
	}
    }

    /* If we're at the right frame, and we haven't started yet,
    ** then begin play and start timing.
    */

    if ((npMCI->lCurrentFrame > npMCI->lRealStart + (LONG) npMCI->dwBufferedVideo) &&
			(npMCI->wTaskState != TASKPLAYING)) {

	if (!(npMCI->dwFlags & MCIAVI_PAUSE)) {
	    goto RestartPlay0;
	} else {
	    // We were paused already, and now we're restarting or pausing
	    // again... so we've already done the KeepFilling stuff to pre-fill
	    // our buffers. If we don't skip over the KeepFilling stuff we'll
	    // roll ahead.
	    PauseAVI(npMCI);
	    goto BePaused0;
        }
    }

    if (npMCI->wTaskState == TASKPLAYING) {
	if (npMCI->dwFlags & MCIAVI_PAUSE) {

	    PauseAVI(npMCI);

#ifndef _WIN32
// no way do we want to do this on NT.  If you get a slow disk, you will
// never get to pause because we can't get the stuff in fast enough to keep up
// !!! The above is not necessarily true

	    /* The line below says that if we're trying to pause,
	    ** but we're behind on our audio, we should keep playing
	    ** for a little bit so that our audio buffers get full.
	    ** This way we'll be all cued up when we RESUME and be less
	    ** likely to fall behind.
	    ** The jerky playback fix makes us use big buffers now so
	    ** the last buffer can never be totally filled, so it's OK
	    ** to stop after filling up (total - 1) buffers.
	    */
	    if (fPlayedAudio && npMCI->wABFull < npMCI->wABs - 1)
		goto KeepFilling;
#endif


BePaused0:
	    BePaused(npMCI);

RestartPlay0:
	    if (npMCI->dwFlags & MCIAVI_STOP)
		return FALSE;

	    if (TimeToQuit(npMCI))
		return FALSE;

	    RestartAVI(npMCI);
	}
    }

#ifndef _WIN32
KeepFilling:
#endif
    if (npMCI->lCurrentFrame > npMCI->lVideoStart &&
	npMCI->lCurrentFrame < npMCI->lFrames &&
	npMCI->wTaskState == TASKPLAYING) {

	iFrame = WhatFrameIsItTimeFor(npMCI);

	if (iFrame >= npMCI->lFrames)
	    goto dontskip;

	iHurryUp = (int)(iFrame - npMCI->lCurrentFrame);
	fHurryUp = iHurryUp > gwHurryTolerance;


	if (iHurryUp > 1 && npMCI->hpFrameIndex && (npMCI->dwOptionFlags & MCIAVIO_SKIPFRAMES)) {

	    //
	    //  WE ARE BEHIND!!! by one or more frames.
	    //
	    //  if we are late we can do one of the following:
	    //
	    //      dont draw frames but keep reading/decompressing them
	    //      (ie set fHurryUp)
	    //
	    //      skip ahead to a key frame.
	    //
	    // !!! If we're very close to the next key frame, be more
	    // willing to skip ahead....
	    //

	    if (iHurryUp > gwSkipTolerance) {

		iNextKey = FrameNextKey(iFrame);
		iPrevKey = FramePrevKey(iFrame);

		if (iPrevKey > npMCI->lCurrentFrame &&
		    iFrame - iPrevKey < gwHurryTolerance &&
		    iNextKey - iFrame > gwSkipTolerance) {

		    DPF2(("Skipping from %ld to PREV KEY %ld (time for %ld next key=%ld).\n", npMCI->lCurrentFrame, iPrevKey, iFrame, iNextKey));
		    iKey = iPrevKey;
		}
		// !!! We'll only skip if the key frame is at most as far
		// ahead as we are behind.....
		else if (iNextKey > npMCI->lCurrentFrame &&
		    iNextKey <= iFrame + gwSkipTolerance /*gwMaxSkipEver*/) {
		    DPF2(("Skipping from %ld to NEXT KEY %ld (time for %ld prev key=%ld).\n", npMCI->lCurrentFrame, iNextKey, iFrame, iPrevKey));
		    iKey = iNextKey;
		} else {
		    DPF2(("WANTED to skip from %ld to %ld (time for %ld)!\n", npMCI->lCurrentFrame,iNextKey,iFrame));
		    goto dontskip;
		}

		npMCI->lVideoStart = iKey;
		npMCI->dwSkippedFrames += iKey - npMCI->lCurrentFrame;
dontskip:
		fHurryUp = TRUE;
	    }
	    else {
		iKey = FrameNextKey(npMCI->lCurrentFrame);

		if (iKey - npMCI->lCurrentFrame > 0 &&
		    iKey - npMCI->lCurrentFrame <= gwHurryTolerance) {
		    DPF2(("Skipping from %ld to next key frame %ld (time for %ld).\n", npMCI->lCurrentFrame, iKey, iFrame));

		    npMCI->dwSkippedFrames += iKey - npMCI->lCurrentFrame;
		    npMCI->lVideoStart = iKey;
		    fHurryUp = TRUE;
		}
	    }
	}
    }

    if (npMCI->dwFlags & MCIAVI_WAVEPAUSED)
	fHurryUp = TRUE;

    /* If we've actually started timing:
    **  Check if we should send a signal.
    **  Check to see if we should break out of the loop.
    **  Wait until it's time for the next frame.
    */
    if (npMCI->wTaskState == TASKPLAYING &&
	npMCI->lCurrentFrame >= npMCI->lVideoStart) {

	if (npMCI->dwSignals)
	    CheckSignals(npMCI, npMCI->lCurrentFrame - npMCI->dwBufferedVideo);

#ifdef WAITHISTOGRAM
	/* Adjust to achieve proper tension. */
	if (fPlayedAudio) {
	    /* If we're playing, keep statistics about how we're doing. */
	    ++wHist[npMCI->wABFull];
	}
#endif

	if (!WaitTillNextFrame(npMCI))
	    return FALSE;
    }

    if (npMCI->lCurrentFrame >= npMCI->lVideoStart &&
	npMCI->lCurrentFrame < npMCI->lFrames) {

#ifdef SHOWSKIPPED
	if (fHurryUp && wSkipped < NUMSKIPSSHOWN) {
	    lSkipped[wSkipped++] = npMCI->lCurrentFrame;
	}
#endif
	/* hold critsec round all worker thread drawing */
	EnterHDCCrit(npMCI);
	TIMESTART(timeVideo);
	if (!DisplayVideoFrame(npMCI, fHurryUp)) {
	    npMCI->dwTaskError = MCIERR_AVI_DISPLAYERROR;
	    TIMEZERO(timeVideo);
	    LeaveHDCCrit(npMCI);
	    return FALSE;
	}

	TIMEEND(timeVideo);
	LeaveHDCCrit(npMCI);

#ifdef DRAWTIMEHIST
	if (!fHurryUp && (wDrawn < NUMDRAWN)) {
	    dwDrawTime[wDrawn++] = npMCI->dwLastDrawTime;
	}
#endif
    }

    StatusBar(npMCI, 0, 4, npMCI->wABs, npMCI->wABFull);
    StatusBar(npMCI, 1, 4, npMCI->wABs, npMCI->wABs - iHurryUp);

#ifdef AVIREAD
    if ((npMCI->hAviRd) && (npMCI->lpBuffer != NULL)) {
	/* finished with this buffer - put back on queue */
	avird_emptybuffer(npMCI->hAviRd, npMCI->lpBuffer);
	npMCI->lpBuffer = NULL;
    }
#endif

    DPF2(("PlayInterleaved...ENDING, npMCI=%8x, TaskState=%d\n", npMCI, npMCI->wTaskState));
    return TRUE;
}

/******************************************************************************
 *****************************************************************************/

BOOL NEAR PASCAL PlayNonInterleaved(NPMCIGRAPHIC npMCI)
{
    BOOL fHurryUp = FALSE;
    int  iHurryUp;
    LONG iFrame;
    LONG iKey;
    LONG iNextKey;
    LONG iPrevKey;

    DPF2(("PlayNonInterleaved, npMCI=%8x\n",npMCI));
    if (npMCI->hWave) {
	TIMESTART(timeAudio);
	KeepPlayingAudio(npMCI);
	TIMEEND(timeAudio);
    }

    if (npMCI->wTaskState == TASKPLAYING) {

	iFrame = WhatFrameIsItTimeFor(npMCI);

	if (iFrame >= npMCI->lFrames)
	    goto dontskip;

	if (npMCI->dwFlags & MCIAVI_REVERSE) {

	    /* Since we're going backwards, always skip to key frame. */
	    DPF3(("  Current = %ld, time for %ld.\n", npMCI->lCurrentFrame, iFrame));

	    iFrame = FramePrevKey(iFrame);

	    // !!! Send signals for skipped frames?
	    npMCI->dwFramesSeekedPast += npMCI->lCurrentFrame - iFrame;
	    npMCI->dwSkippedFrames += npMCI->lCurrentFrame - iFrame;
	    npMCI->lCurrentFrame = iFrame;
	} else if (npMCI->lCurrentFrame < npMCI->lFrames) {

#ifdef BEHINDHIST
	    {
	    int      iDelta;
	    iDelta = iFrame - npMCI->lCurrentFrame + BEHINDOFFSET;
	    iDelta = min(NUMBEHIND, max(0, iDelta));
	    wBehind[iDelta]++;
	    }
#endif
	    iHurryUp = (int)(iFrame - npMCI->lCurrentFrame);
	    fHurryUp = iHurryUp > gwHurryTolerance;

	    if (iHurryUp > 1 && npMCI->hpFrameIndex && (npMCI->dwOptionFlags & MCIAVIO_SKIPFRAMES)) {

		//
		//  WE ARE BEHIND!!! by one or more frames.
		//
		//  if we are late we can do one of the following:
		//
		//      dont draw frames but keep reading/decompressing them
		//      (ie set fHurryUp)
		//
		//      skip ahead to a key frame.
		//
		// !!! If we're very close to the next key frame, be more
		// willing to skip ahead....
		//

		if (iHurryUp > gwSkipTolerance) {

		    iNextKey = FrameNextKey(iFrame);
		    iPrevKey = FramePrevKey(iFrame);

		    if (iPrevKey > npMCI->lCurrentFrame &&
			iFrame - iPrevKey < gwHurryTolerance &&
			iNextKey - iFrame > gwSkipTolerance) {

			DPF2(("Skipping from %ld to PREV KEY %ld (time for %ld next key=%ld).\n", npMCI->lCurrentFrame, iPrevKey, iFrame, iNextKey));

			iKey = iPrevKey;
			fHurryUp = TRUE;
		    }
		    // !!! We'll only skip if the key frame is at most as far
		    // ahead as we are behind.....
		    else if (iNextKey > npMCI->lCurrentFrame &&
			iNextKey <= iFrame + gwSkipTolerance /*gwMaxSkipEver*/) {
			DPF2(("Skipping from %ld to NEXT KEY %ld (time for %ld prev key=%ld).\n", npMCI->lCurrentFrame, iNextKey, iFrame, iPrevKey));
			iKey = iNextKey;        // assume next key
			fHurryUp = FALSE;
		    } else {
			DPF2(("WANTED to skip from %ld to %ld (time for %ld)!\n", npMCI->lCurrentFrame,iNextKey,iFrame));
			goto dontskip;
		    }

		    npMCI->dwFramesSeekedPast += iKey - npMCI->lCurrentFrame;
		    npMCI->dwSkippedFrames += iKey - npMCI->lCurrentFrame;
		    npMCI->lCurrentFrame = iKey;
dontskip:
		    ;
		}
		else if (FramePrevKey(iFrame) == iFrame) {
		    DPF2(("Skipping from %ld to %ld (time for key frame).\n", npMCI->lCurrentFrame, iFrame));

		    iKey = iFrame;
		    npMCI->dwFramesSeekedPast += iKey - npMCI->lCurrentFrame;
		    npMCI->dwSkippedFrames += iKey - npMCI->lCurrentFrame;
		    npMCI->lCurrentFrame = iKey;

		    fHurryUp = FALSE;
		}
		else {
		    iKey = FrameNextKey(npMCI->lCurrentFrame);

		    if (iKey > npMCI->lCurrentFrame &&
			iKey - npMCI->lCurrentFrame <= gwHurryTolerance) {
			DPF2(("Skipping from %ld to next key frame %ld (time for %ld).\n", npMCI->lCurrentFrame, iKey, iFrame));

			npMCI->dwFramesSeekedPast += iKey - npMCI->lCurrentFrame;
			npMCI->dwSkippedFrames += iKey - npMCI->lCurrentFrame;
			npMCI->lCurrentFrame = iKey;

			fHurryUp = ((iKey - iFrame) > gwHurryTolerance);
		    }
		}
	    }

	    StatusBar(npMCI, 0, 4, npMCI->wABs, npMCI->wABFull);
	    StatusBar(npMCI, 1, 4, npMCI->wABs, npMCI->wABs - iHurryUp);
	}
    }

    // !!! Somewhere in here, read other streams.
    // Should this be before, or after, video?

    /* If lCurrentFrame == lFrames, we're really at the end of
    ** the file, so there isn't another record to read.
    */
    if (npMCI->lCurrentFrame < npMCI->lFrames) {
	/* Read new record into buffer */

	npMCI->dwLastReadTime = (DWORD)(-(LONG)timeGetTime());
	TIMESTART(timeRead);
	if (!ReadNextVideoFrame(npMCI, NULL)) {
	    npMCI->dwTaskError = MCIERR_INVALID_FILE;
	    DPF2(("Error reading frame #%ld\n", npMCI->lCurrentFrame));
	    return FALSE;
	}
	TIMEEND(timeRead);

	npMCI->dwLastReadTime += timeGetTime();
	npMCI->lLastRead = npMCI->lCurrentFrame;

#ifdef READTIMEHIST
	if (wRead < NUMREAD) {
	    dwReadTime[wRead++] = npMCI->dwLastReadTime;
    }
#endif
    }

    /* If we're at the right frame, and we haven't started yet,
    ** then begin play and start timing.
    */
    if ((((npMCI->lCurrentFrame > (npMCI->lRealStart +
					(LONG) npMCI->dwBufferedVideo)) &&
			(npMCI->lCurrentFrame < (npMCI->lTo))) ||
			(npMCI->dwFlags & MCIAVI_REVERSE)) &&
			(npMCI->wTaskState != TASKPLAYING) &&
			!(npMCI->dwFlags & MCIAVI_SEEKING)) {
	if (!(npMCI->dwFlags & MCIAVI_PAUSE)) {
	    goto RestartPlay;
	} else
	    goto PauseNow;
    }

    /* If we've actually started timing:
    **  Check if we should send a signal.
    **  Check to see if we should return FALSE out of the loop.
    **  Wait until it's time for the next frame.
    */
    if (npMCI->wTaskState == TASKPLAYING) {
	if (npMCI->dwFlags & MCIAVI_PAUSE) {
PauseNow:
	    PauseAVI(npMCI);

	    BePaused(npMCI);

RestartPlay:
	    if (TimeToQuit(npMCI))
		return FALSE;

	    RestartAVI(npMCI);
	}

	if (npMCI->dwSignals)
	    CheckSignals(npMCI, npMCI->lCurrentFrame - npMCI->dwBufferedVideo);

	if (npMCI->lCurrentFrame < npMCI->lFrames + (LONG) npMCI->dwBufferedVideo) {
	    while (1) {
		iFrame = WhatFrameIsItTimeFor(npMCI);

		TIMESTART(timeYield);
		aviTaskCheckRequests(npMCI);
		TIMEEND(timeYield);

		if (npMCI->dwFlags & MCIAVI_REVERSE) {
		    if (iFrame <= npMCI->lCurrentFrame)
			break;

		    if (npMCI->lCurrentFrame < npMCI->lTo)
			break;
		} else {
		    if (iFrame >= npMCI->lCurrentFrame)
			break;

		    if (npMCI->lCurrentFrame > npMCI->lTo)
			break;
		}

		if (npMCI->hWave) {
		    TIMESTART(timeAudio);
		    KeepPlayingAudio(npMCI);
		    TIMEEND(timeAudio);
		}

		DPF3(("Waiting:  Current = %ld, time for %ld.\n", npMCI->lCurrentFrame, iFrame));
		if (!(npMCI->dwFlags & MCIAVI_REVERSE)) {
		    WaitTillNextFrame(npMCI);
		}

		if (TimeToQuit(npMCI))
		    return FALSE;
	    }
	}

	if (TimeToQuit(npMCI))
	    return FALSE;
    }

    if (((npMCI->lCurrentFrame >= npMCI->lVideoStart) &&
	    (npMCI->lCurrentFrame < npMCI->lFrames)) ||
	(npMCI->dwFlags & MCIAVI_REVERSE)) {

	// Quick exit if we are being told to stop
	if (npMCI->dwFlags & MCIAVI_STOP) {
	    return(FALSE);
	}

	EnterHDCCrit(npMCI);
	TIMESTART(timeVideo);
	if (!DisplayVideoFrame(npMCI, fHurryUp)) {
	    npMCI->dwTaskError = MCIERR_AVI_DISPLAYERROR;
	    TIMEZERO(timeVideo);
	    LeaveHDCCrit(npMCI);
	    return FALSE;
	}
	
	TIMEEND(timeVideo);
	LeaveHDCCrit(npMCI);
#ifdef DRAWTIMEHIST
	if (!fHurryUp && (wDrawn < NUMDRAWN)) {
	    dwDrawTime[wDrawn++] = npMCI->dwLastDrawTime;
	}
#endif
    }

    //
    // now is a good time to deal with other streams
    //
    if (npMCI->nOtherStreams > 0 || npMCI->nVideoStreams > 1) {

	if (npMCI->wTaskState != TASKPLAYING)
	    iFrame = npMCI->lCurrentFrame;

	TIMESTART(timeOther);
	DealWithOtherStreams(npMCI, iFrame);
	TIMEEND(timeOther);
    }

    DPF2(("PlayNONInterleaved...ENDING, npMCI=%8x, TaskState=%d\n", npMCI, npMCI->wTaskState));
    return TRUE;
}

/******************************************************************************
 *****************************************************************************/

BOOL NEAR PASCAL PlayAudioOnly(NPMCIGRAPHIC npMCI)
{
    DPF2(("PlayAudioOnly, npMCI=%8x\n",npMCI));
    npMCI->lFrameDrawn = npMCI->lCurrentFrame;

    if (npMCI->hWave) {
	TIMESTART(timeAudio);
	KeepPlayingAudio(npMCI);
	TIMEEND(timeAudio);
    }

    /* If we're at the right frame, and we haven't started yet,
    ** then begin play and start timing.
    */
    if ((npMCI->wTaskState != TASKPLAYING) &&
			!(npMCI->dwFlags & MCIAVI_SEEKING)) {
	if (!(npMCI->dwFlags & MCIAVI_PAUSE)) {
	    goto RestartPlay;
	} else
	    goto PauseNow;
    }

    /* If we've actually started timing:
    **  Check if we should send a signal.
    **  Check to see if we should return FALSE out of the loop.
    **  Wait until it's time for the next frame.
    */
    if (npMCI->wTaskState == TASKPLAYING) {

	npMCI->lCurrentFrame = WhatFrameIsItTimeFor(npMCI);

	if (npMCI->dwFlags & MCIAVI_PAUSE) {
PauseNow:
	    PauseAVI(npMCI);

	    BePaused(npMCI);

RestartPlay:
	    if (TimeToQuit(npMCI))
		return FALSE;

	    RestartAVI(npMCI);
	}

	if (npMCI->dwSignals)
	    CheckSignals(npMCI, npMCI->lCurrentFrame - npMCI->dwBufferedVideo);

	//
	// dont yield if updating
	//
	if (!(npMCI->dwFlags & MCIAVI_UPDATING)) {
	    TIMESTART(timeYield);
	    aviTaskCheckRequests(npMCI);
	    TIMEEND(timeYield);
	}

	if (TimeToQuit(npMCI))
	    return FALSE;
    }

    return TRUE;
}

/******************************************************************************
 *****************************************************************************/

#ifdef USENONINTFROMCD	
#pragma message("PlayNonIntFromCD needs fixed?")

BOOL NEAR PASCAL PlayNonIntFromCD(NPMCIGRAPHIC npMCI)
{
    BOOL fHurryUp = FALSE;
    LONG lNewFrame;
    DWORD ckid;
    UINT wStream;

    DPF2(("PlayNonIntFromCD, npMCI=%8x\n",npMCI));
AnotherChunk:
    /* If lCurrentFrame == lFrames, we're really at the end of
    ** the file, so there isn't another record to read.
    */
    if (npMCI->lCurrentFrame < npMCI->lFrames) {
	/* Read new record into buffer */

	TIMESTART(timeRead);
	ckid = ReadNextChunk(npMCI);
	TIMEEND(timeRead);

	if (ckid == 0) {
	    npMCI->dwTaskError = MCIERR_INVALID_FILE;
	    DPF(("Error reading frame #%ld\n", npMCI->lCurrentFrame));
	    return FALSE;
	}

	npMCI->lLastRead = npMCI->lCurrentFrame;
	wStream = StreamFromFOURCC(ckid);

	if (wStream == (UINT) npMCI->nVideoStream) {
	    if (TWOCCFromFOURCC(ckid) == cktypePALchange) {
		npMCI->lp += 2 * sizeof(DWORD);
		ProcessPaletteChange(npMCI, npMCI->dwThisRecordSize -
							    2 * sizeof(DWORD));
		npMCI->lLastPaletteChange = npMCI->lCurrentFrame;
		goto AnotherChunk;
	    }
	} else if (wStream == (UINT) npMCI->nAudioStream) {
	    TIMESTART(timeAudio);
	    if (npMCI->hWave)
		HandleAudioChunk(npMCI);
	    TIMEEND(timeAudio);
	    goto AnotherChunk;
	} else {
	    goto AnotherChunk;
	}
    }

    if (npMCI->wTaskState == TASKPLAYING) {
	lNewFrame = WhatFrameIsItTimeFor(npMCI);

	DPF3(("  Current = %ld, time for %ld.\n", npMCI->lCurrentFrame, lNewFrame));
	if (npMCI->lCurrentFrame < lNewFrame) {
	    fHurryUp = TRUE;
	}
    }

    /* If we're at the right frame, and we haven't started yet,
    ** then begin play and start timing.
    */
    if ((npMCI->lCurrentFrame > npMCI->lRealStart + (LONG) npMCI->dwBufferedVideo) &&
			(npMCI->lCurrentFrame < npMCI->lTo) &&
			(npMCI->wTaskState != TASKPLAYING)) {

	if (!(npMCI->dwFlags & MCIAVI_PAUSE)) {
	    goto RestartPlay;
	} else
	    goto PauseNow;
    }

    /* If we've actually started timing:
    **  Check if we should send a signal.
    **  Check to see if we should return FALSE out of the loop.
    **  Wait until it's time for the next frame.
    */
    if (npMCI->wTaskState == TASKPLAYING) {
	if (npMCI->dwFlags & MCIAVI_PAUSE) {
PauseNow:
	    PauseAVI(npMCI);

	    BePaused(npMCI);

RestartPlay:
	    if (TimeToQuit(npMCI))
		return FALSE;

	    RestartAVI(npMCI);
	}

	if (npMCI->dwSignals)
	    CheckSignals(npMCI, npMCI->lCurrentFrame - npMCI->dwBufferedVideo);

WaitMore:              ///////WAITING//////////
	lNewFrame = WhatFrameIsItTimeFor(npMCI);

	TIMESTART(timeYield);
	aviTaskCheckRequests(npMCI);
	TIMEEND(timeYield);

	if (lNewFrame < npMCI->lCurrentFrame) {
	    DPF3(("Waiting:  Current = %ld, time for %ld.\n", npMCI->lCurrentFrame, lNewFrame));
	    WaitTillNextFrame(npMCI);
	    if (TimeToQuit(npMCI))
		return FALSE;
	    else
		goto WaitMore;
	}
    }

    if (npMCI->lCurrentFrame >= npMCI->lVideoStart) {
	TIMESTART(timeVideo);
	EnterHDCCrit(npMCI);
	if (!DisplayVideoFrame(npMCI, fHurryUp)) {
	    npMCI->dwTaskError = MCIERR_AVI_DISPLAYERROR;
	    TIMEZERO(timeVideo);
	    LeaveHDCCrit(npMCI);
	    return FALSE;
	}
	TIMEEND(timeVideo);
	LeaveHDCCrit(npMCI);
    }

    return TRUE;
}
#endif


/******************************************************************************
 *****************************************************************************/

STATICFN INLINE LONG waveTime(NPMCIGRAPHIC npMCI, LONG lTime)
{
	if (gfUseGetPosition && npMCI->wABFull > 0) {
	    MMTIME	mmtime;
            LONG        lTimeInc;
	
            mmtime.wType = TIME_SAMPLES;
	
            waveOutGetPosition(npMCI->hWave, &mmtime, sizeof(mmtime));
            if (mmtime.wType == TIME_SAMPLES)
		lTimeInc = muldiv32(mmtime.u.sample,
				  1000L, npMCI->pWF->nSamplesPerSec);
	    else if (mmtime.wType == TIME_BYTES)
		lTimeInc = muldiv32(mmtime.u.cb,
		                  1000L, npMCI->pWF->nAvgBytesPerSec);
	    else
		goto ack2;

            //DPF0(("lTime: %3d,  LastDraw: %4d,  lTimeInc: %5d ",
            //       lTime,        npMCI->dwLastDrawTime,        lTimeInc));
            lTime = lTimeInc + npMCI->dwLastDrawTime;
	    // !!! this is too accurate: adjust by 100ms to match old SB...
	    lTime = max(0, lTime - giGetPositionAdjust);
	} else {
ack2:
	lTime += muldiv32(npMCI->dwAudioPlayed,
			   1000L, npMCI->pWF->nAvgBytesPerSec);
        }
	return(lTime);
}


INLINE LONG GetVideoTime(NPMCIGRAPHIC npMCI)
{
    //
    //  NOTE we must grab dwTimingStart *before* calling
    //  timeGetTime() because dwTimingStart is changed in the wave
    //  callback and we dont want to have time go backward.
    //
    LONG lTime = npMCI->dwTimingStart;

    lTime = (LONG)timeGetTime() - lTime
	+ npMCI->dwLastDrawTime
//      + npMCI->dwLastReadTime
	;

    Assert(lTime >= 0);

    if (npMCI->hWave) {

	if (npMCI->dwFlags & MCIAVI_WAVEPAUSED)	{
	    lTime = 0;
    }

	lTime = waveTime(npMCI, lTime);
    }
    return(lTime);
}

/* This function returns what frame we should be on. */
LONG NEAR PASCAL WhatFrameIsItTimeFor(NPMCIGRAPHIC npMCI)
{
    LONG        lTime;
    LONG        lFrame;

    // If timing is off, it's always just time to play the current frame.
    if (npMCI->dwPlayMicroSecPerFrame == 0)
	return npMCI->lCurrentFrame;

    //
    // if we have not started playing npMCI->dwTimingStart is bogus
    //
    Assert(npMCI->wTaskState == TASKPLAYING);
    AssertFrame(npMCI->lCurrentFrame - (LONG)npMCI->dwBufferedVideo);

    lTime = GetVideoTime(npMCI);

    /* Convert from MS to frames.... */
    //force round down - subtract half a frame
    lTime -= (npMCI->dwPlayMicroSecPerFrame / 2000);
    if (lTime < 0) {
	lTime = 0;
	lFrame = 0;
    } else {
	lFrame = muldiv32(lTime, 1000, npMCI->dwPlayMicroSecPerFrame);
    }

    if (npMCI->dwFlags & MCIAVI_REVERSE) {

	lFrame = npMCI->lFramePlayStart - lFrame;

	if (lFrame < npMCI->lTo)
	    lFrame = npMCI->lTo;
    }
    else {
	lFrame = lFrame + npMCI->lFramePlayStart + npMCI->dwBufferedVideo;

	if ((lFrame > npMCI->lTo) && (lFrame > npMCI->lCurrentFrame))
	    lFrame = npMCI->lTo;
    }




    if (lFrame > npMCI->lFrames + (LONG)npMCI->dwBufferedVideo || lFrame < 0) {
	DPF(("WhatFrameIsItTimeFor: bad frame %ld\n", lFrame));
	AssertSz(0, "bad frame in WhatFrameIsItTimeFor");
	lFrame = npMCI->lCurrentFrame;
    }

    return lFrame;
}

/******************************************************************************
 *****************************************************************************/

/* This function returns time to go until the target frame */
LONG NEAR PASCAL HowLongTill(NPMCIGRAPHIC npMCI)
{
    LONG        lTime;
    LONG        lTimeTarget;
    LONG        lFrameTarget = npMCI->lCurrentFrame;

    // If timing is off, it's always just time to play the current frame.
    if (npMCI->dwPlayMicroSecPerFrame == 0)
	return 0;

    //
    // if we have not started playing npMCI->dwTimingStart is bogus
    //
    Assert(npMCI->wTaskState == TASKPLAYING);

    // no longer valid because of last-frame-audio fix
    //AssertFrame(npMCI->lCurrentFrame - (LONG)npMCI->dwBufferedVideo);

    lTime = GetVideoTime(npMCI);

    if (npMCI->dwFlags & MCIAVI_REVERSE)
	lFrameTarget = npMCI->lFramePlayStart - lFrameTarget;
    else
	lFrameTarget -= npMCI->lFramePlayStart + npMCI->dwBufferedVideo;

    lTimeTarget = muldiv32(lFrameTarget, npMCI->dwPlayMicroSecPerFrame, 1000);

    //DPF0(("! >> %5d\n", lTimeTarget - lTime));
    return lTimeTarget - lTime;
}

/******************************************************************************
 *****************************************************************************/

static BOOL NEAR PASCAL PauseAVI(NPMCIGRAPHIC npMCI)
{
    DPF2(("PauseAVI\n"));
    if (npMCI->wTaskState == TASKPLAYING) {
	int stream;

	if (npMCI->hWave)
	    waveOutPause(npMCI->hWave);

	if (npMCI->hicDraw)
	    ICDrawStop(npMCI->hicDraw);

	for (stream = 0; stream < npMCI->streams; stream++) {
	    if (SI(stream)->hicDraw)
		ICDrawStop(SI(stream)->hicDraw);
	}

	npMCI->dwPauseTime = Now();
	npMCI->dwTotalMSec += npMCI->dwPauseTime - npMCI->dwMSecPlayStart;
    }

    if (npMCI->dwFlags & MCIAVI_WAITING) {
	// waiting for completion of a pause or cue request
	DPF3(("Releasing UI waiter\n"));
	SetEvent(npMCI->hEventAllDone);
	npMCI->dwFlags &= ~MCIAVI_WAITING;
    }

    // this flag is set to indicate that notify should be issued
    // when we reach a paused state (eg on Cue).
    if (npMCI->dwFlags & MCIAVI_CUEING) {
	/* If we're cueing, report that it was successful. */
	npMCI->dwFlags &= ~(MCIAVI_CUEING);
	GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUCCESSFUL);
    }


    DPF2(("Pausing npMCI==%8x\n",npMCI));
    npMCI->wTaskState = TASKPAUSED;

    return TRUE;
}

/******************************************************************************
 *****************************************************************************/

static BOOL NEAR PASCAL BePaused(NPMCIGRAPHIC npMCI)
{
    DWORD dwObject;

    TIMEEND(timePlay);
    TIMESTART(timePaused);

    while (npMCI->dwFlags & MCIAVI_PAUSE) {

	if (npMCI->dwFlags & MCIAVI_STOP)
	    return FALSE;

	if (npMCI->dwFlags & MCIAVI_NEEDUPDATE) {
	    /* Since we're paused and we have nothing better
	    ** to do, update the screen.
	    */
	    DoStreamUpdate(npMCI, FALSE);
	}

	// block until told to do something else

	// need to handle send-messages to the ole windows -see mciaviTask()

    	do {
	    dwObject = MsgWaitForMultipleObjects(2, &npMCI->hEventSend,
			FALSE, INFINITE, QS_SENDMESSAGE);
	    if (dwObject == WAIT_OBJECT_0 + 2) {
		MSG msg;

		// just a single peekmessage with NOREMOVE will
		// process the inter-thread send and not affect the queue
		PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
	    }
	} while (dwObject == WAIT_OBJECT_0 + 2);

    	// find out what needed doing
	aviTaskCheckRequests(npMCI);

        if (npMCI->dwFlags & MCIAVI_WAITING) {
	    // waiting for completion of a pause or cue request
	    SetEvent(npMCI->hEventAllDone);
	    npMCI->dwFlags &= ~MCIAVI_WAITING;
	}

    }

    TIMEEND(timePaused);
    TIMESTART(timePlay);

    return TRUE;
}


/******************************************************************************
 *****************************************************************************/

static BOOL NEAR PASCAL RestartAVI(NPMCIGRAPHIC npMCI)
{
    int stream;

    Assert(npMCI->wTaskState != TASKPLAYING);

    /* Mark that play has actually begun */
    npMCI->wTaskState = TASKPLAYING;
    DPF(("Restart AVI, TaskState now TASKPLAYING, npMCI=%8x\n", npMCI));

#ifndef _WIN32
    TIMESTART(timeYield);
    aviTaskYield();
    aviTaskYield();
    aviTaskYield();
    TIMEEND(timeYield);
    DPF2(("Starting (done yielding)\n"));
#endif


    /* Reset clock and restart */

    if (npMCI->dwPauseTime == 0) {
	Assert(npMCI->dwTimingStart == 0);
    }

    npMCI->dwMSecPlayStart = Now(); // get the time we started playing

    //
    // if we were paused subtract off the time we spent paused from
    // the timing start
    //
    if (npMCI->dwPauseTime == 0)
	npMCI->dwTimingStart = npMCI->dwMSecPlayStart;
    else
	npMCI->dwTimingStart += (npMCI->dwMSecPlayStart - npMCI->dwPauseTime);

    if (npMCI->hWave)
	waveOutRestart(npMCI->hWave);

    if (npMCI->hicDraw)
	ICDrawStart(npMCI->hicDraw);

    for (stream = 0; stream < npMCI->streams; stream++) {
	if (SI(stream)->hicDraw)
	    ICDrawStart(SI(stream)->hicDraw);
    }

    DPF(("Returning from RestartAVI\n"));
    return TRUE;
}

/* This function sets up things that will be needed to play.
**
** Returns zero if no error, otherwise an MCI error code.
**
** Note: Even if this function returns an error, CleanUpPlay()
** will still be called, so we don't have to cleanup here.
*/
STATICFN DWORD NEAR PASCAL PrepareToPlay(NPMCIGRAPHIC npMCI)
{
    BOOL        fCDFile;
    BOOL        fNetFile;
    BOOL        fHardFile;

    Assert(npMCI->wTaskState != TASKPLAYING);

    //
    // lets choose the play back method:
    //
    //      playing reverse: (random access!)
    //          use MCIAVI_ALG_HARDDISK always (random access mode)
    //
    //      audio is preloaded: (will never happen?)
    //          on a CD-ROM   use MCIAVI_ALG_INTERLEAVED
    //          on a HARDDISK use MCIAVI_ALG_HARDDISK
    //          on a NET      use MCIAVI_ALG_HARDDISK
    //
    //      file is interleaved:
    //          on a CD-ROM   use MCIAVI_ALG_INTERLEAVED
    //          on a HARDDISK use MCIAVI_ALG_HARDDISK
    //          on a NET      use MCIAVI_ALG_HARDDISK
    //
    //      file is not interleaved:
    //          on a CD-ROM   use MCIAVI_ALG_CDROM
    //          on a HARDDISK use MCIAVI_ALG_HARDDISK
    //          on a NET      use MCIAVI_ALG_HARDDISK
    //

    fCDFile   = npMCI->uDriveType == DRIVE_CDROM;
    fNetFile  = npMCI->uDriveType == DRIVE_REMOTE;
    fHardFile = !fCDFile && !fNetFile;

    if (npMCI->nVideoStreams == 0 && npMCI->nOtherStreams == 0) {
	npMCI->wPlaybackAlg = MCIAVI_ALG_AUDIOONLY;
    } else if (npMCI->dwFlags & MCIAVI_REVERSE || npMCI->pf) {
        // avifile-handled files are always played as non-interleaved
        // though audio buffering might be different
	npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
    }
    else if (npMCI->dwFlags & MCIAVI_NOTINTERLEAVED) {
#if 0
	if (fCDFile)
	    npMCI->wPlaybackAlg = MCIAVI_ALG_CDROM;
	else
#endif
	if (fNetFile)
	    npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
	else
	    npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
    }
    else {
	if (fCDFile)
	    npMCI->wPlaybackAlg = MCIAVI_ALG_INTERLEAVED;
#if 0
	else if (fNetFile)
	    npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
	else
	    npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
#else
	else if (fNetFile)
	    npMCI->wPlaybackAlg = MCIAVI_ALG_INTERLEAVED;
	else
	    npMCI->wPlaybackAlg = MCIAVI_ALG_INTERLEAVED;
#endif
    }

    // Interleaved playback doesn't work well at very low speeds!
    if ((npMCI->dwSpeedFactor < 100) &&
	(npMCI->wPlaybackAlg != MCIAVI_ALG_HARDDISK) &&
	(npMCI->wPlaybackAlg != MCIAVI_ALG_AUDIOONLY)) {
	DPF(("Was going to play interleaved, but speed < 10%% of normal...\n"));
	npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
    }

#if 0
//
// sigh! we need to always have the index read now, so we do it in
// aviopen
//
    /* Be sure the index has been read, if we need it. */

    if (npMCI->hpFrameIndex == NULL)
	if (npMCI->wPlaybackAlg != MCIAVI_ALG_INTERLEAVED || npMCI->lFrom > 0)
	ReadIndex(npMCI);
#endif

#ifdef DEBUG
    switch (npMCI->wPlaybackAlg) {
	case MCIAVI_ALG_INTERLEAVED:
	    Assert(!(npMCI->dwFlags & MCIAVI_NOTINTERLEAVED));
	    DPF(("playing a interleaved file\n"));
	    break;

	case MCIAVI_ALG_CDROM:
	    Assert(npMCI->dwFlags & MCIAVI_NOTINTERLEAVED);
	    DPF(("playing a non interleaved file from CD-ROM\n"));
	    break;

	case MCIAVI_ALG_HARDDISK:
	    if (npMCI->dwFlags & MCIAVI_NOTINTERLEAVED)
		DPF(("random access play (non-interleaved file)\n"));
	    else
		DPF(("random access play (interleaved file)\n"));
	    break;

	case MCIAVI_ALG_AUDIOONLY:
	    Assert(npMCI->nAudioStreams);
	    DPF(("audio-only!\n"));
	    break;

	default:
	    Assert(0);
	    break;
    }
#endif

#if 0
    //
    // set a MMIO buffer if we are playing interleaved off a non cd-rom
    //
    if (npMCI->hmmio && fNetFile && npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED) {

	#define BUFFER_SIZE (32l*1024)

	if (npMCI->lpMMIOBuffer == NULL) {

	    DPF(("Using %u byte MMIO buffer...\n", BUFFER_SIZE));

	    npMCI->lpMMIOBuffer = AllocMem(BUFFER_SIZE);

	    mmioSetBuffer(npMCI->hmmio, npMCI->lpMMIOBuffer, BUFFER_SIZE, 0);
	}

	//!!! should we do this for a seek?
	//!!! should we free this in CleanUpPlay?
    }
    else {
	if (npMCI->lpMMIOBuffer != NULL)
	    FreeMem(npMCI->lpMMIOBuffer);

	npMCI->lpMMIOBuffer = NULL;

	if (npMCI->hmmio)
	    mmioSetBuffer(npMCI->hmmio, NULL, 0, 0);
    }
#endif

    // !!!!
#ifdef DEBUG
    gwHurryTolerance = mmGetProfileInt(szIni, TEXT("Hurry"), 2);
    gwSkipTolerance = mmGetProfileInt(szIni, TEXT("Skip"), gwHurryTolerance * 2);
    gwMaxSkipEver = mmGetProfileInt(szIni, TEXT("MaxSkip"), max(60, gwSkipTolerance * 10));

#endif

    gfUseGetPosition = DEFAULTUSEGETPOSITION;	// !!! Detect WSS 1.0, 2.0?
    gfUseGetPosition = mmGetProfileInt(szIni, TEXT("GetPosition"), gfUseGetPosition);
    giGetPositionAdjust = mmGetProfileInt(szIni, TEXT("GetPositionAdjust"), 100);

#ifdef DEBUG
    if (gfUseGetPosition) {
	DPF2(("Using waveOutGetPosition adjusted by %dms instead of done bits...\n", giGetPositionAdjust));
    } else {
	DPF2(("NOT using waveOutGetPosition\n"));
    }
#endif

    Assert(npMCI->lTo <= npMCI->lFrames);
    Assert(npMCI->lFrom >= 0);

    /* Clear out variables, so we'll know what needs to be released. */
    /* Access to these variables should only ever be on the task thread */
    npMCI->hWave = NULL;
    npMCI->lpAudio = NULL;
    npMCI->lpBuffer = NULL;
    npMCI->dwBufferSize = 0L;
    npMCI->wABFull = 0;

    npMCI->dwSkippedFrames = 0L;
    npMCI->dwFramesSeekedPast = 0L;
    npMCI->dwAudioBreaks = 0L;

    npMCI->dwTotalMSec = 0;
    npMCI->dwLastDrawTime = 0;
    npMCI->dwLastReadTime = 0;
    npMCI->dwBufferedVideo = 0;
    npMCI->dwPauseTime = 0;
    npMCI->dwTimingStart = 0;

    /* Figure out how fast we're playing.... */
    if (npMCI->dwSpeedFactor)
	npMCI->dwPlayMicroSecPerFrame = muldiv32(npMCI->dwMicroSecPerFrame,
						 1000L,
						 npMCI->dwSpeedFactor);
    else
	npMCI->dwPlayMicroSecPerFrame = 0; // Special "play every frame" mode

    /* If we're already at the end, and we're going to repeat from the
    ** start of the file, just repeat now.
    */
    if ((npMCI->lFrom == npMCI->lTo) &&
		(npMCI->dwFlags & MCIAVI_REPEATING) &&
		(npMCI->lFrom != npMCI->lRepeatFrom)) {
	DPF(("Repeating from beginning before we've even started....\n"));
	npMCI->lFrom = npMCI->lRepeatFrom;
    }

    if (npMCI->lFrom == npMCI->lTo) {
	npMCI->dwFlags |= MCIAVI_SEEKING;
	npMCI->dwFlags &= ~(MCIAVI_REVERSE | MCIAVI_REPEATING);
    }

    if (npMCI->dwFlags & MCIAVI_SEEKING)
	goto PlayWithoutWave;

    if (npMCI->hicDraw) {
	ICGetBuffersWanted(npMCI->hicDraw, &npMCI->dwBufferedVideo);
    }
#ifdef DEBUG
    npMCI->dwBufferedVideo = mmGetProfileInt(szIni, TEXT("Buffer"), (int) npMCI->dwBufferedVideo);
#endif
    if (npMCI->dwFlags & MCIAVI_REVERSE) {
	npMCI->dwBufferedVideo = 0;
    }

    if (npMCI->dwBufferedVideo) {
	DPF(("Buffering %lu frames of video ahead....\n", npMCI->dwBufferedVideo));
    }

    //
    //  now initialize the audio stream
    //


    /* Open up our wave output device, if appropriate.
     * Appropriate means that there are audio streams,
     * 		that we are not muted,
     *		that the user has not turned sound off
     *		that we have not had the wave device stolen
     *		and that the wave stream is ok
     */
    if ((npMCI->nAudioStreams > 0)
      	&& (npMCI->dwFlags & MCIAVI_PLAYAUDIO)
      	&& !(npMCI->dwFlags & MCIAVI_LOSEAUDIO)
      	&& !(npMCI->dwOptionFlags & MCIAVIO_NOSOUND)
      	&& (npMCI->dwPlayMicroSecPerFrame != 0)) {

	npMCI->dwTaskError = SetUpAudio(npMCI, TRUE);

	if ((npMCI->dwTaskError == MCIERR_OUT_OF_MEMORY) &&
	    (npMCI->wPlaybackAlg != MCIAVI_ALG_AUDIOONLY)) {
	    DPF(("Not enough memory to play audio; continuing onward....\n"));
	    CleanUpAudio(npMCI);
	    npMCI->dwTaskError = 0;
	}

	if (npMCI->dwTaskError == MCIERR_WAVE_OUTPUTSINUSE) {
#ifdef STEALWAVE
	    //
	    //  we did not get a wave device, time to go steal one.
	    //
	    //  only do this if we got a real play command
	    //  from the user, and not a internal play command
	    //  (like when repeating or restarting)
	    //
	    //  MCIAVI_NEEDTOSHOW is set when the play command
	    //  came in through graphic.c (ie from the outside world)
	    //
	    if (npMCI->dwFlags & MCIAVI_NEEDTOSHOW) {
		if (StealWaveDevice(npMCI))
		    // Some other AVI task was prepared to release the
		    // wave device that they were holding.  This gives us
		    // a second chance to set up for playing audio.
		    npMCI->dwTaskError = SetUpAudio(npMCI, TRUE);
	    }
#endif // STEALWAVE

	    if (npMCI->dwTaskError == MCIERR_WAVE_OUTPUTSINUSE) {
		//
		// even though we did not steal the wave device we still
		// want it if it becomes available
		//
		npMCI->dwFlags |= MCIAVI_LOSTAUDIO;     // we want it
	    }
	}

	/*
	 * We will fail to play even without a wave device available
	 * in the following circumstances:
	 *
	 * 1: Playback algorithm is audio only
	 * 2: Wave failure is not ...OUTPUTSINUSE or ...OUTPUTSUNSUITABLE
	 *
	 * In all other cases we continue and play without wave
	 */

	if (npMCI->dwTaskError) {
	    if ( ((npMCI->dwTaskError != MCIERR_WAVE_OUTPUTSINUSE) &&
		    (npMCI->dwTaskError != MCIERR_WAVE_OUTPUTSUNSUITABLE))
               || (npMCI->wPlaybackAlg == MCIAVI_ALG_AUDIOONLY)
	       )
	    {
		// Must call CleanUpAudio(npMCI) to release buffers
		return npMCI->dwTaskError;
	    }

	    // Reset the error and continue
	    npMCI->dwTaskError = 0;
	}

    } else {
	DPF2(("Playing silently, nAudioStreams=%d, PlayAudio=%x\n",
		npMCI->nAudioStreams, npMCI->dwFlags & MCIAVI_PLAYAUDIO));
	// Was someone stealing our wave device?
        npMCI->dwFlags &= ~MCIAVI_LOSEAUDIO;  // OK - reset the flag
    }

PlayWithoutWave:
    return(PrepareToPlay2(npMCI));
}

INLINE STATICFN DWORD NEAR PASCAL PrepareToPlay2(NPMCIGRAPHIC npMCI)
{
    int         stream;
    UINT        w;
    DWORD       dwPosition;

    if (npMCI->dwFlags & MCIAVI_NEEDTOSHOW) {
	ShowStage(npMCI);
    }
    /* Get and prepare the DC we're going to be playing into */

    // must hold the critsec when getting dc to avoid
    // interaction with window thread calling DeviceRealize

    EnterHDCCrit(npMCI);

    if (npMCI->hdc == NULL) {
	npMCI->hdc = GetDC(npMCI->hwndPlayback);    // Shouldn't use cached DC!

	if (npMCI->hdc == NULL) {
	    LeaveHDCCrit(npMCI);
	    return MCIERR_DRIVER_INTERNAL;
	}

	npMCI->dwFlags |= MCIAVI_RELEASEDC;
    }

    if (npMCI->dwFlags & MCIAVI_SEEKING) {
	//
	// audio only
	//
	if (npMCI->nVideoStreams == 0 && npMCI->nOtherStreams == 0) {
	    npMCI->lCurrentFrame = npMCI->lFrom;
	    LeaveHDCCrit(npMCI);
	    return 0;
	}
    }

    /* Start up the external decompressor, if any */
    /* !!!We should check these for errors */

    if (!DrawBegin(npMCI, NULL)) {
	LeaveHDCCrit(npMCI);
	return npMCI->dwTaskError ? npMCI->dwTaskError : MCIERR_DRIVER_INTERNAL;
    }


    if (!(npMCI->dwFlags & MCIAVI_SEEKING)) {
	PrepareDC(npMCI);
    }
    // critsec just held around getting and preparing dc - look at
    // InternalRealize to see the function we are protecting against.
    LeaveHDCCrit(npMCI);

    /*
    **  what if selecting the palette causes palette changes? we should
    **  yield and let the palette changes happen.
    */

    if (npMCI->hicDraw && !(npMCI->dwFlags & MCIAVI_SEEKING) &&
		(npMCI->dwBufferedVideo > 0)) {
	ICDrawFlush(npMCI->hicDraw);
	npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
    }

    if (npMCI->dwFlags & MCIAVI_FULLSCREEN) {
	/* Clear out key state flags:
	** We watch for escape, space, and the left button.
	** Unfortunately, we must look for LBUTTON and RBUTTON in case
	** the user has switched mouse buttons.  In that instance, the
	** UI might believe that the Left mouse button is physically the
	** right-hand one, but GetAsyncKeyState looks at the physical
	** left-hand mouse button.
	*/
	GetAsyncKeyState(VK_ESCAPE);
	GetAsyncKeyState(VK_SPACE);
	GetAsyncKeyState(VK_LBUTTON);
	GetAsyncKeyState(VK_RBUTTON);
    }

    /* Figure out where in the file to start playing from */
    CalculateTargetFrame(npMCI);

    // !!! ACK: We're starting from after where we planned to finish....
    if ((npMCI->dwFlags & MCIAVI_REVERSE) &&
	(npMCI->lCurrentFrame <= npMCI->lTo)) {
	npMCI->dwFlags |= MCIAVI_SEEKING;
    }

    // !!! This should be in CalcTarget
    if (npMCI->dwFlags & MCIAVI_SEEKING)
	npMCI->lTo = npMCI->lRealStart;

    //
    // start all the streams
    //
    for (stream = 0; stream < npMCI->streams; stream++) {

	STREAMINFO *psi = SI(stream);

#ifdef USEAVIFILE
	if (!(npMCI->dwFlags & MCIAVI_SEEKING)) {
	    if (SI(stream)->ps) {
		AVIStreamBeginStreaming(SI(stream)->ps,
			MovieToStream(SI(stream), npMCI->lFrom),
			MovieToStream(SI(stream), npMCI->lTo),
			npMCI->dwPlayMicroSecPerFrame); // !!!
	    }
	}
#endif

	//
	// NOTE DrawBegin() handled the default draw guy
	//
	if (psi->hicDraw && psi->hicDraw != npMCI->hicDraw) {

	    DWORD   dw;

	    dw = ICDrawBegin(psi->hicDraw,
		(npMCI->dwFlags & MCIAVI_FULLSCREEN) ?
			ICDRAW_FULLSCREEN : ICDRAW_HDC,

		npMCI->hpal,           // palette to draw with
		npMCI->hwndPlayback,   // window to draw to
		npMCI->hdc,            // HDC to draw to

		RCX(psi->rcDest),
		RCY(psi->rcDest),
		RCW(psi->rcDest),
		RCH(psi->rcDest),

		SI(stream)->lpFormat,

		RCX(psi->rcSource),
		RCY(psi->rcSource),
		RCW(psi->rcSource),
		RCH(psi->rcSource),

		muldiv32(psi->sh.dwRate, npMCI->dwSpeedFactor, 1000),
		psi->sh.dwScale);

	    if ((LONG)dw < 0) {
		// !!! Error checking?
		DPF(("Draw handler failed ICDrawBegin() (err = %ld)\n", dw));
	    }

	    //
	    // tell the draw handler the play range
	    //
	    ICDrawStartPlay(psi->hicDraw,psi->lPlayFrom, psi->lPlayTo);
	}
    }

    //
    // tell the draw handler the play range
    //
    if (npMCI->hicDraw) {
	ICDrawStartPlay(npMCI->hicDraw,npMCI->lRealStart,npMCI->lTo);
    }

    //
    //  seek to the right place in the file.
    //
    dwPosition = CalculatePosition(npMCI);

    if (dwPosition == 0) {
	return MCIERR_DRIVER_INTERNAL;
    }

#ifdef AVIREADMANY
    //
    //  see if we want to try to read two records at a shot, this
    //  should cut down the time spent in DOS doing reads.
    //
    //  we only can do this if we have a index, and the buffer
    //  sizes are "small enough"
    //
    //  if reading 2 buffers works good how about 3? 4?
    //
    //  this helps on CD's and Networks but makes things slower
    //  on KenO's hard disk, so dont do hard disks.
    //
    //  default is read many when coming from a Network, this is
    //  better than the old mmioSetBuffer() we used to do.
    //
    if (npMCI->uDriveType == DRIVE_REMOTE)
	npMCI->fReadMany = TRUE;
    else
	npMCI->fReadMany = FALSE;

    if (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED &&
	npMCI->dwSuggestedBufferSize <= 30*1024 &&
	mmGetProfileInt(szIni, TEXT("ReadMany"), npMCI->fReadMany) &&
	npMCI->hpFrameIndex) {

	npMCI->dwBufferSize = npMCI->dwSuggestedBufferSize * 2;
	npMCI->fReadMany = TRUE;
    }
    else {
	npMCI->fReadMany = FALSE;
    }

    if (npMCI->fReadMany) {
	DPF(("MCIAVI: reading two records at once (%ld bytes).\n", npMCI->dwBufferSize));
	npMCI->lLastRead = npMCI->lCurrentFrame - 2;
    }
#endif

    AllocateReadBuffer(npMCI);

    // look for palette changes between the last place we read and where
    // we're starting....
    ProcessPaletteChanges(npMCI, npMCI->lVideoStart);

    if (npMCI->hmmio) {
	/* Seek to the start of frame we're playing from */
	mmioSeek(npMCI->hmmio, dwPosition, SEEK_SET);
    }

#ifdef AVIREAD
    /* start the async read object if we are using interleaved
     * and therefore consecutive reads
     */
    if (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED) {

	/* start async reader  - allocates itself new buffers */
	npMCI->hAviRd = avird_startread(mciaviReadBuffer, (DWORD_PTR) npMCI,
					npMCI->dwNextRecordSize,
					npMCI->lCurrentFrame,
					min(npMCI->lTo+1, npMCI->lFrames));

	if (!npMCI->hAviRd) {
	    DPF(("async read failed - reading synchronously\n"));
	    ResizeReadBuffer(npMCI, npMCI->dwNextRecordSize);
	}

    } else {
	npMCI->hAviRd = NULL;
    }

    if (!npMCI->hAviRd)
#endif
    {
	if (!npMCI->lpBuffer) {
	    return MCIERR_OUT_OF_MEMORY;
	}
    }

    if (npMCI->hWave) {
	TIMESTART(timeAudio);
	if (npMCI->wPlaybackAlg == MCIAVI_ALG_HARDDISK ||
	    npMCI->wPlaybackAlg == MCIAVI_ALG_AUDIOONLY) {
	    /* Load audio into our buffers */
	    for (w = 0; w < npMCI->wABs; w++)
		KeepPlayingAudio(npMCI);
	} else if (npMCI->wPlaybackAlg == MCIAVI_ALG_CDROM) {
	    //!!!!
	    npMCI->wPlaybackAlg = MCIAVI_ALG_HARDDISK;
	}
	TIMEEND(timeAudio);
    }

    return 0L;          /* Success! */
}

/******************************************************************************
 *****************************************************************************/

void NEAR PASCAL CleanUpPlay(NPMCIGRAPHIC npMCI)
{
    int stream;

    if (npMCI->wTaskState == TASKPLAYING) {
	if (npMCI->hicDraw) {
	    ICDrawStop(npMCI->hicDraw);
	    ICDrawStopPlay(npMCI->hicDraw);
	}

	for (stream = 0; stream < npMCI->streams; stream++) {
	    if (SI(stream)->hicDraw) {
		ICDrawStop(SI(stream)->hicDraw);
		ICDrawStopPlay(SI(stream)->hicDraw);
	    }
	}

	if (npMCI->hWave) {
	    waveOutRestart(npMCI->hWave); // some wave devices need this
	    waveOutReset(npMCI->hWave);
	}
    } else if (npMCI->wTaskState == TASKCUEING) {
	if (npMCI->hicDraw) {
	    /* Kick the device in the head to make sure it draws when we seek. */
	    ICDrawRenderBuffer(npMCI->hicDraw);
	}
    }

    if (!(npMCI->dwFlags & MCIAVI_SEEKING) &&
		(npMCI->dwBufferedVideo > 0)) {
	ICDrawFlush(npMCI->hicDraw);
	npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
    }

    /* end drawing this will leave fullscreen mode etc. */
    DrawEnd(npMCI);

    for (stream = 0; stream < npMCI->streams; stream++) {
	if (SI(stream)->hicDraw) {
	    LRESULT   dw;
	    dw = ICDrawEnd(SI(stream)->hicDraw);
	    // !!! Error checking?
	}
#ifdef USEAVIFILE
	if (!(npMCI->dwFlags & MCIAVI_SEEKING)) {
	    if (SI(stream)->ps) {
		AVIStreamEndStreaming(SI(stream)->ps);
	    }
	}
#endif
    }

    /* Clean up and close our wave output device. */
    if (npMCI->hWave) {

	Assert(!(npMCI->dwFlags & MCIAVI_LOSTAUDIO));
	// We should never hold the
	// wave device AND have MCIAVI_LOSTAUDIO turned on.

	CleanUpAudio(npMCI);

#ifdef STEALWAVE
	//
	// if we are not being forced to give up the audio try to
	// give it to someone.	Unless we are repeating.  In which
	// case someone might steal it from us, but we do not want
	// to waste time looking for another user.  We have it; we
	// will keep it until forced to release it.
	//
	if (!(npMCI->dwFlags & MCIAVI_NEEDTOSHOW) &&
	    !(npMCI->dwFlags & MCIAVI_REPEATING)  &&
	    !(npMCI->dwFlags & MCIAVI_UPDATING))
	    GiveWaveDevice(npMCI);
	else {
	    DPF2(("Not giving the wave device away, flags=%x\n",npMCI->dwFlags));
	}
#endif
    } else {
	//
	//  done playing, we dont want a wave device any more
	//  LATER: do we really want to turn this flag off if we are
	//  repeating?  Today it is benign as the flag will be turned
	//  back on again when the video restarts.  It will then try and
	//  open the audio, fail because it is in use, and turn on LOSTAUDIO.
	//  It would be more efficient to rely on the wave device being
	//  returned to us and not try to reopen it.
	//
	npMCI->dwFlags &= ~MCIAVI_LOSTAUDIO;
    }

    /* Release the DC we played into. */

    // worker thread must hold critsec round all access to hdc
    // (can be used by DeviceRealize on winproc thread)
    EnterHDCCrit(npMCI);

    if (npMCI->hdc) {
	//
	// we MUST call this otherwise our palette will stay selected
	// as the foreground palette and it may get deleted (ie by
	// DrawDibBegin) while still the foreground palette and GDI
	// get's real pissed about this.
	//
	UnprepareDC(npMCI);
#if 0
	if (npMCI->dwFlags & MCIAVI_ANIMATEPALETTE)
	    RealizePalette(npMCI->hdc);
#endif
	if (npMCI->dwFlags & MCIAVI_RELEASEDC) {
	    ReleaseDC(npMCI->hwndPlayback, npMCI->hdc);
	    HDCCritCheckIn(npMCI);
	    npMCI->hdc = NULL;
	    npMCI->dwFlags &= ~MCIAVI_RELEASEDC;
	}
    }
    LeaveHDCCrit(npMCI);

#ifdef AVIREAD
    /* shut down async reader */
    if (npMCI->hAviRd) {
	avird_endread(npMCI->hAviRd);
	npMCI->hAviRd = NULL;
    } else
#endif
    {
	/* we weren't using async reader - so release the buffer we
	 * allocated
	 */
	ReleaseReadBuffer(npMCI);
    }

}

/******************************************************************************
 *****************************************************************************/

// !!! Should this take a "how many frames to check for" parameter,
// in case we need to check for signals on several frames at once?

void NEAR PASCAL CheckSignals(NPMCIGRAPHIC npMCI, LONG lFrame)
{
    LONG        lTemp;

    lTemp = npMCI->signal.dwPeriod == 0 ? lFrame :
			(((lFrame - npMCI->signal.dwPosition) %
					    npMCI->signal.dwPeriod) +
				npMCI->signal.dwPosition);

    if ((DWORD) lTemp == npMCI->signal.dwPosition) {
	/* Send the signal in the right time format */
	SEND_DGVSIGNAL(npMCI->dwSignalFlags,
			    npMCI->signal.dwCallback,
			    0,
			    (HANDLE) npMCI->wDevID,
			    npMCI->signal.dwUserParm,
			    ConvertFromFrames(npMCI, lFrame));
	// !!! Needs to use time format at time of signal command!
    }
}

/******************************************************************************
 *****************************************************************************/

BOOL NEAR PASCAL WaitTillNextFrame(NPMCIGRAPHIC npMCI)
{
#ifdef _WIN32
    LONG WaitForFrame;
#endif
    LONG  lMaxWait;
#ifdef DEBUG
    int iWait = 0;
    StatusBar(npMCI,2,1,4,iWait); // we should not wait more than 4 times...
#endif

    /* Here we wait for a while if we're ahead
     *   of schedule (so that we can yield nicely instead of blocking
     *   in the driver, for instance, and also so that we'll work off
     *   faster devices.)
     */

    /* Always yield at least once in a while  (every 8 frames ~ 1/2 sec)*/
    if ((npMCI->lCurrentFrame % YIELDEVERY) == 0) {
	TIMESTART(timeYield);
	aviTaskCheckRequests(npMCI);
	TIMEEND(timeYield);
    }

    if (npMCI->dwFlags & MCIAVI_WAVEPAUSED)
	return TRUE;

    if (TimeToQuit(npMCI))
	return FALSE;

    Assert(npMCI->wTaskState == TASKPLAYING);

    // with the change to play the last frame of audio, these two asserts
    // are no longer valid. We will wait until it's time for frame lTo+1
    // and stop then (before attempting to read or draw it).
    //AssertFrame(npMCI->lCurrentFrame - (LONG)npMCI->dwBufferedVideo);
    //Assert(npMCI->lCurrentFrame <= npMCI->lTo);

    Assert(!(npMCI->dwFlags & MCIAVI_REVERSE));

    /* The maximum wait time is 95% of the correct frame rate, or 100ms
     * (to cope with a very slow frame rate)
     */
    lMaxWait = min(100, muldiv32(npMCI->dwMicroSecPerFrame,
			950L,
			(npMCI->dwSpeedFactor == 0 ?
				1000 : npMCI->dwSpeedFactor)));

    if (HowLongTill(npMCI) > 0) {

	while ((WaitForFrame=HowLongTill(npMCI)) > 0) {
		     ///////WAITING//////////
	    StatusBar(npMCI,2,1,4,++iWait);

	    // use sleep regardless of accuracy as polling hurts on NT
	    if (npMCI->msPeriodResolution > 0) {

		// NOTE:  There are no fudge factors in here.  This code
		// needs to be tuned to allow for the overhead of calculating
		// the wait time, for the overhead of the timer, etc.

		// Don't wait for more than one frame time at a time....
		if (WaitForFrame > lMaxWait) {
		    WaitForFrame = lMaxWait;
		}

		DPF2(("Sleeping for %d milliseconds\n", WaitForFrame));
		TIMESTART(timeWait);
		Sleep(WaitForFrame);
		TIMEEND(timeWait);
	    } else {
		Sleep(0);
	    }

	    // check if anything interesting has happened
	    TIMESTART(timeYield);
	    aviTaskCheckRequests(npMCI);
	    TIMEEND(timeYield);
	    if (TimeToQuit(npMCI)) {
		return FALSE;
	    }
	}
    } else {
	// force some cpu idle time at least every 1/2 second, to ensure
	// that other processes do get some time (eg for 16-bit hook procs).
	/* Always yield at least once in a while  (every 8 frames ~ 1/2 sec)*/
	if ((npMCI->lCurrentFrame % YIELDEVERY) == 0) {

	    TIMESTART(timeWait);
	    Sleep(1);
	    TIMEEND(timeWait);

	    TIMESTART(timeYield);
	    aviTaskCheckRequests(npMCI);
	    TIMEEND(timeYield);

	    if (TimeToQuit(npMCI)) {
		return FALSE;
	    }
	}
    }

    return TRUE;
}

/* Idea: this should go from the current frame to the frame
** we actually have to be at to start playing from.
**
** If fPlaying is set, that means we're really going to play.
**
** When this finishes:
**      lAudioStart is set to the first frame with meaningful audio info
**      lVideoStart is the first frame with meaningful video info
**      lRealStart is the first frame that's 'real', namely
**              the original value of lCurrentFrame.  If the
**              SEEK EXACT flag is not set, then lRealStart may
**              actually not be what lCurrentFrame was, indicating
**              that play may start from somewhere else.
**      lCurrentFrame gets set to the first frame we have to read from.
**
** !!! This also needs to look for "palette key frames" or something.
*/
BOOL NEAR PASCAL CalculateTargetFrame(NPMCIGRAPHIC npMCI)
{
    int         i;
    LONG        lVideoPlace;
    BOOL        fForceBeginning = FALSE;
    int		lMovieStart=0xffffffff;	    // Max UINT (or -1 when signed)
    int		lStreamStart;

    npMCI->lCurrentFrame = npMCI->lFrom;
    npMCI->lRealStart = npMCI->lFrom;

    //
    //  walk all streams and figure out where to start
    //
    for (i=0; i<npMCI->streams; i++) {

	STREAMINFO *psi = SI(i);

	if (!(psi->dwFlags & STREAM_ENABLED))
	    continue;

	if (psi->dwFlags & STREAM_ERROR)
	    continue;

	if (psi->dwFlags & STREAM_AUDIO)
	    continue;

	//
	// map from movie time to stream time.
	//
	psi->lPlayFrom = MovieToStream(psi, npMCI->lFrom);
	psi->lPlayTo   = MovieToStream(psi, npMCI->lTo);

	psi->dwFlags &= ~STREAM_ACTIVE;

	//
	// is this stream part of play?
	//
	if (psi->lPlayFrom < psi->lStart && psi->lPlayTo < psi->lStart)
	    continue;

	if (psi->lPlayFrom >= psi->lEnd && psi->lPlayTo >= psi->lEnd)
	    continue;

	psi->dwFlags |= STREAM_ACTIVE;

	psi->lPlayFrom  = BOUND(psi->lPlayFrom,psi->lStart,psi->lEnd);
	psi->lPlayTo    = BOUND(psi->lPlayTo,  psi->lStart,psi->lEnd);
	psi->lPlayStart = FindPrevKeyFrame(npMCI,psi,psi->lPlayFrom);

	//
	// if the main frame is invalid invalidate the stream too.
	//
	if (npMCI->lFrameDrawn <= (-(LONG)npMCI->wEarlyRecords)) {
	    psi->lFrameDrawn = -4242;
	}

	//
	//  if we have a drawn frame use it!
	//
	if ((psi->lFrameDrawn  > psi->lPlayStart) &&
	    (psi->lFrameDrawn <= psi->lPlayFrom))
	    psi->lPlayStart = npMCI->lFrameDrawn + 1;

	lStreamStart = StreamToMovie(psi, (DWORD)psi->lPlayStart);
	if ((DWORD)lMovieStart > (DWORD)lStreamStart) {
	    (DWORD)lMovieStart = (DWORD)lStreamStart;
	}

	//
	//  if seek exactly is off start play at the key frame
	//
	if (!(npMCI->dwOptionFlags & MCIAVIO_SEEKEXACT)) {

	    if (psi->lPlayFrom == psi->lPlayTo)
		 psi->lPlayTo = psi->lPlayStart;

	    psi->lPlayFrom = psi->lPlayStart;

	    //!!! is this right for reverse?

	    if (StreamToMovie(psi, psi->lPlayFrom) < npMCI->lFrom) {
//              npMCI->lRealStart = StreamToMovie(psi, psi->lPlayFrom);
//              npMCI->lFrom = npMCI->lRealStart;
	    }
	}

//      if (StreamToMovie(psi, psi->lPlayStart) < npMCI->lCurrentFrame)
//          npMCI->lCurrentFrame = StreamToMovie(psi, psi->lPlayStart);

	DPF(("CalculateTargetFrame:  Stream #%d: from:%ld, to:%ld, start:%ld\n", i, psi->lPlayFrom, psi->lPlayTo, psi->lPlayStart));
    }

    //
    // we are done with now special case the video and audio streams.
    // note: if lMovieStart has NOT been altered above then it will be -1
    //
    if (npMCI->lFrom < lMovieStart) {
	npMCI->lFrom = lMovieStart;
    }

    /* If we're starting from the beginning, don't force the index
    ** to be read, but use it if we've already read it.
    */
    if (npMCI->lFrom == 0 && npMCI->hpFrameIndex == NULL)
	goto ForceBeginning;

    if (!npMCI->pbiFormat) {
	npMCI->lVideoStart = npMCI->lFrom;

	if (npMCI->lVideoStart >= npMCI->lFrames)
	    npMCI->lVideoStart = npMCI->lFrames - 1;

	lVideoPlace = npMCI->lVideoStart;
    } else
    if (npMCI->dwFlags & MCIAVI_HASINDEX) {

	if (npMCI->hpFrameIndex == NULL)
	    goto ForceBeginning;

	//
	// get nearest key frame
	//
	npMCI->lVideoStart = FramePrevKey(npMCI->lFrom);

	if (npMCI->lVideoStart) {
	    lVideoPlace = npMCI->lVideoStart;
	} else {
	    /* Didn't find a key frame--retreat to the beginning. */
	    npMCI->lVideoStart = -(LONG)npMCI->wEarlyVideo;
	    lVideoPlace = 0;
	}

	if ((npMCI->lFrameDrawn > npMCI->lVideoStart) &&
		(npMCI->lFrameDrawn <= npMCI->lFrom)) {
	    npMCI->lVideoStart = npMCI->lFrameDrawn + 1;
	    if (npMCI->lVideoStart >= npMCI->lFrames)
		npMCI->lVideoStart = npMCI->lFrames - 1;
	    lVideoPlace = npMCI->lFrameDrawn;
	}
    } else {
	/* Always go back to frame 0 */
ForceBeginning:
	npMCI->lVideoStart = - (LONG) npMCI->wEarlyVideo;
	lVideoPlace = 0;
	fForceBeginning = TRUE;
    }

    if (!(npMCI->dwOptionFlags & MCIAVIO_SEEKEXACT)) {
	npMCI->lRealStart = lVideoPlace;
    }

    if (npMCI->hWave) {
	npMCI->lAudioStart = npMCI->lRealStart - (LONG) npMCI->wEarlyAudio;
    }

    if (npMCI->hWave && (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED))
	npMCI->lCurrentFrame = min(npMCI->lAudioStart, npMCI->lVideoStart);
    else
	npMCI->lCurrentFrame = npMCI->lVideoStart;

    if (npMCI->lRealStart < npMCI->lCurrentFrame)
	npMCI->lCurrentFrame = npMCI->lRealStart;

    if (fForceBeginning) {
	if (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED)
	    npMCI->lCurrentFrame = - (LONG) npMCI->wEarlyRecords;
	else
	    npMCI->lCurrentFrame = - (LONG) npMCI->wEarlyVideo;
    }

    if (npMCI->hWave) {
	LONG l;

	/* Figure out what sample of audio we should be starting at */

	//
	//  convert frame number to block
	//
	npMCI->dwAudioPos = MovieToStream(npMCI->psiAudio, npMCI->lRealStart);

	//
	// now convert block to byte position
	//
	npMCI->dwAudioPos = npMCI->dwAudioPos * npMCI->pWF->nBlockAlign;

	Assert(npMCI->dwAudioPos % npMCI->pWF->nBlockAlign == 0);

	if (npMCI->dwAudioPos > npMCI->dwAudioLength)
	    npMCI->dwAudioPos = npMCI->dwAudioLength;

	npMCI->dwAudioPlayed = 0L;

	//
	//  convert the audio start back to a frame number.
	//  and posibly readjust the video start time.
	//
	l = npMCI->lRealStart - StreamToMovie(npMCI->psiAudio,
		npMCI->dwAudioPos/npMCI->pWF->nBlockAlign);

	if (l < 0)
	    DPF(("Audio will be ahead of the video by %ld frames\n", -l));
	else if (l > 0)
	    DPF(("Audio will be behind the video by %ld frames\n", l));
    }

#ifdef DEBUG
    Assert(npMCI->lCurrentFrame < npMCI->lFrames);
    if (npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED) {
	Assert(npMCI->lCurrentFrame >= - (LONG) npMCI->wEarlyRecords);
    }
    if (npMCI->hWave) {
	Assert(npMCI->lAudioStart <= npMCI->lFrames);
    }
    Assert(npMCI->lVideoStart < npMCI->lFrames);
#endif

    return TRUE;
}


/******************************************************************************
 *****************************************************************************/

void ReturnToOriginalPalette(NPMCIGRAPHIC npMCI)
{
    if (npMCI->bih.biClrUsed) {
	hmemcpy(npMCI->argb, npMCI->argbOriginal,
		npMCI->bih.biClrUsed * sizeof(RGBQUAD));

	if (npMCI->pbiFormat->biBitCount == 8) {
	    hmemcpy((LPBYTE) npMCI->pbiFormat + npMCI->pbiFormat->biSize,
		    (LPBYTE) npMCI->argb,
		    sizeof(RGBQUAD) * npMCI->pbiFormat->biClrUsed);
	}

	npMCI->dwFlags |= MCIAVI_PALCHANGED;
	npMCI->lLastPaletteChange = 0;
    }
}


/* Returns the position in the file where the frame referenced
** by lCurrentFrame is.
**
**  input   npMCI->lCurrentFrame
**
**  output  npMCI->dwNextRecordSize set correctly
**          npMCI->lLastRead set correctly
**          returns offset to read from
**
** If there's an error, returns zero.
*/
DWORD NEAR PASCAL CalculatePosition(NPMCIGRAPHIC npMCI)
{
    DWORD       dwPosition;

    AssertFrame(npMCI->lCurrentFrame);

    if (npMCI->pf || npMCI->nVideoStreams == 0)
	return 1;

    if (npMCI->lCurrentFrame + npMCI->wEarlyRecords == 0) {
ForceBeginning:
	npMCI->lCurrentFrame = - (LONG)npMCI->wEarlyRecords;
//!!!BeforeBeginning:
	dwPosition = npMCI->dwFirstRecordPosition;
	npMCI->dwNextRecordSize = npMCI->dwFirstRecordSize;
	npMCI->dwNextRecordType = npMCI->dwFirstRecordType;
    } else if (npMCI->dwFlags & MCIAVI_HASINDEX) {
	if (npMCI->hpFrameIndex == NULL)
	    goto ForceBeginning;

	dwPosition = FrameOffset(npMCI->lCurrentFrame);
	npMCI->dwNextRecordSize = FrameLength(npMCI->lCurrentFrame) + 8;
	npMCI->dwNextRecordType = 0;
    } else {
	goto ForceBeginning;
    }

    npMCI->lLastRead = npMCI->lCurrentFrame - 1;

    DPF3(("Frame %ld: Seeking to position %lX\n", npMCI->lCurrentFrame, dwPosition));

    DPF3(("CalculatePosition: next record = %lu bytes.\n", npMCI->dwNextRecordSize));

    mmioSeek(npMCI->hmmio, dwPosition, SEEK_SET);

    return dwPosition;
}

/***************************************************************************
 *
 ***************************************************************************/

BOOL NEAR PASCAL ReadIndexChunk(NPMCIGRAPHIC npMCI, LONG iIndex)
{
    Assert(iIndex >= 0 && iIndex < (LONG)npMCI->macIndex);

    return ReadBuffer(npMCI, (LONG)IndexOffset(iIndex), (LONG)IndexLength(iIndex) + 8);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | DealWithOtherStreams | does what is says
 *
 *  this function is called inside of the non-interlaved play loop.
 *  it's mission is to catch the "other" streams up to the current time.
 *
 *  right now all we do is go to key frames, we should fix this
 *
 * @parm NPMCIGRAPHIC | npMCI | pointer to instance data block.
 *
 ***************************************************************************/

STATICFN INLINE void DealWithOtherStreams(NPMCIGRAPHIC npMCI, LONG lFrame)
{
    int i;
    STREAMINFO *psi;
    LONG lPos;
    LONG err;

    for (i=0; i<npMCI->streams; i++) {

	// If this is the active audio or video stream, then ignore it
	if ((i == npMCI->nVideoStream)
	    || (i == npMCI->nAudioStream))
	    continue;

	psi = SI(i);

	if (!(psi->dwFlags & STREAM_ENABLED))
	    continue;

	if (psi->hicDraw == NULL)
	    continue;

	lPos = MovieToStream(psi, lFrame);

	if (lPos < psi->lPlayStart || lPos > psi->lPlayTo) {
	    DPF2(("OtherStream(%d): out of range lPos = %ld [%ld, %ld]\n", i, lPos, psi->lPlayStart, psi->lPlayTo));
	    continue;
	}

	//
	// we have the right thing drawn now
	//
	// !!!we should not always go to a key frame.
	//
	//
	if (psi->lFrameDrawn >= psi->lLastKey &&
	    psi->lFrameDrawn <= lPos &&
	    lPos < psi->lNextKey) {
	    DPF2(("OtherStream(%d) lPos = %ld, lFrameDrawn=%ld, NextKey=%ld\n", i, lPos, psi->lFrameDrawn, psi->lNextKey));
	    continue;
	}

	FindKeyFrame(npMCI, psi, lPos);

	DPF2(("OtherStream(%d): pos=%ld (prev key=%ld, next key=%ld)\n",i,lPos,psi->lLastKey,psi->lNextKey));

	lPos = psi->lLastKey;

	if (!StreamRead(npMCI, psi, lPos)) {
	    DPF2(("StreamRead failed\n"));
	    continue;
	} else {
	    DPF2(("Read stream, ThisRecordSize==%d, biSizeImage==%d\n",
		npMCI->dwThisRecordSize, 0));
	}

	//
	//  now draw the data.
	//
	err = (LONG)ICDraw(psi->hicDraw, 0L, psi->lpFormat,
		npMCI->lpBuffer,npMCI->dwThisRecordSize,
		psi->lLastKey - psi->lPlayFrom);

	if (err >= 0) {
	    psi->dwFlags &= ~STREAM_NEEDUPDATE;
	    psi->lFrameDrawn = lPos;
	}
	else {
	    DPF2(("Draw failed!\n"));
	}
    }
}

/***************************************************************************
 *
 * FindKeyFrame
 *
 *  given a stream position, find the previous and next key frame
 *  cacheing the last ones found to make it sort of fast.
 *
 ***************************************************************************/

void NEAR PASCAL FindKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos)
{
    if (psi == NULL)
	psi = npMCI->psiVideo;

    Assert(psi);
//  AssertPos(psi, lPos);

    //
    //  if we are in the current key range return it.
    //
    if (psi->lLastKey <= lPos && lPos < psi->lNextKey)
	return;

    if (lPos < psi->lStart || lPos >= psi->lEnd)
	return;

    //
    //  otherwise query from the stream
    //
#ifdef USEAVIFILE
    if (psi->ps) {
	if (lPos == psi->lNextKey)
	    psi->lLastKey = psi->lNextKey;
	else
	    psi->lLastKey = AVIStreamFindSample(psi->ps, lPos, FIND_KEY|FIND_PREV);

	psi->lNextKey = AVIStreamFindSample(psi->ps, lPos+1, FIND_KEY|FIND_NEXT);

	if (psi->lLastKey == -1)
	    ; // psi->lLastKey = psi->lStart;

	if (psi->lNextKey == -1)
	    psi->lNextKey = psi->lEnd+1;
    }
#endif
    else if (psi->dwFlags & STREAM_VIDEO) {
	//
	// for a video stream either read our index or assume no key frames.
	//
	if (npMCI->hpFrameIndex && psi == npMCI->psiVideo) {
	    psi->lLastKey = FramePrevKey(lPos);
	    psi->lNextKey = FrameNextKey(lPos);
	}
	else {
	    psi->lLastKey = psi->lStart;
	    psi->lNextKey = psi->lEnd+1;
	}
    }
    else {
	//
	// for a non-video stream assume all key frames
	//
	psi->lLastKey = lPos;
	psi->lNextKey = lPos+1;
    }

    return;
}

/***************************************************************************
 ***************************************************************************/

LONG NEAR PASCAL FindPrevKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos)
{
    FindKeyFrame(npMCI, psi, lPos);
    return psi->lLastKey;
}

/***************************************************************************
 ***************************************************************************/

LONG NEAR PASCAL FindNextKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos)
{
    FindKeyFrame(npMCI, psi, lPos);
    return psi->lNextKey;
}

/***************************************************************************
 ***************************************************************************/

BOOL NEAR PASCAL ProcessPaletteChanges(NPMCIGRAPHIC npMCI, LONG lFrame)
{
    LONG        iPalette;
    LONG        iFrame;
    STREAMINFO *psi;

    if (!(npMCI->dwFlags & MCIAVI_ANIMATEPALETTE))
	return TRUE;

    psi = npMCI->psiVideo;
    Assert(psi);

#ifdef USEAVIFILE
    if (psi->ps) {

	DWORD       dw;
	//
	//  we are in the palette range nothing to do.
	//
	if (npMCI->lLastPaletteChange <= lFrame &&
	    npMCI->lNextPaletteChange >  lFrame) {

	    return TRUE;
	}

	dw = psi->cbFormat;

	//!!! should be psi->lpFormat
	if (AVIStreamReadFormat(psi->ps, lFrame, npMCI->pbiFormat, &dw) != 0) {
	    DOUT("Unable to read Stream format\n");
	    return FALSE;
	}

	npMCI->lLastPaletteChange = lFrame;
	npMCI->lNextPaletteChange = AVIStreamFindSample(psi->ps, lFrame+1, FIND_NEXT|FIND_FORMAT);

	if (npMCI->lNextPaletteChange == -1)
	    npMCI->lNextPaletteChange = npMCI->lFrames+2;

	npMCI->dwFlags |= MCIAVI_PALCHANGED;
	return TRUE;
    }
#endif

    DPF2(("Looking for palette changes at %ld, last=%ld\n", lFrame, npMCI->lLastPaletteChange));

    if (lFrame < npMCI->lLastPaletteChange) {
	ReturnToOriginalPalette(npMCI);
    }

    /* If there's no index, assume we're starting from the beginning
    ** and thus we don't have to worry about palette changes.
    */
    if (npMCI->hpFrameIndex == NULL)
	return TRUE;

    //
    // walk from the last palette change to the current frame, and apply any
    // palette changes we find.
    //
    for (iFrame = npMCI->lLastPaletteChange,
	 iPalette = FramePalette(iFrame);
	 iFrame <= lFrame;
	 iFrame++) {

	if (iPalette != FramePalette(iFrame)) {

	    iPalette = FramePalette(iFrame);

	    /* We've found a palette change we need to deal with */
	    DPF2(("Processing palette change at frame %ld.\n", iFrame));

	    Assert(iPalette >= 0 && iPalette < (LONG)npMCI->macIndex);

	    if (!ReadIndexChunk(npMCI, iPalette))
		    return FALSE;

	    npMCI->lp += 2 * sizeof(DWORD);
	    ProcessPaletteChange(npMCI, IndexLength(iPalette));

	    npMCI->lLastPaletteChange = iFrame;
	}
    }

    return TRUE;
}

BOOL NEAR PASCAL ReadRecord(NPMCIGRAPHIC npMCI)
{
    DWORD UNALIGNED FAR * pdw;

    AssertFrame(npMCI->lCurrentFrame);

#ifdef AVIREADMANY
    if (npMCI->fReadMany) {
	//
	//  either read two records or return the one we read last time.
	//
	Assert(npMCI->hpFrameIndex);
	Assert(npMCI->lCurrentFrame - npMCI->lLastRead > 0);
	Assert(npMCI->lCurrentFrame - npMCI->lLastRead <= 2);

	if (npMCI->lLastRead == npMCI->lCurrentFrame-1) {
	    //
	    //  return the second half of the buffer.
	    //
	    npMCI->lp = npMCI->lpBuffer + (UINT)npMCI->dwThisRecordSize;
	    npMCI->dwThisRecordSize = npMCI->dwNextRecordSize;
	}
	else {
	    //
	    //  read in two buffers, and return the first one
	    //
	    //  figure out how much to read by looking at the index
	    //  we dont have to worry about the last frame because
	    //  the dummy index entry on the end is 0 in length.
	    //
	    npMCI->dwThisRecordSize = FrameLength(npMCI->lCurrentFrame) + 8;
	    npMCI->dwNextRecordSize = FrameLength(npMCI->lCurrentFrame+1) + 8;

	    if (!ReadBuffer(npMCI, -1,
		npMCI->dwThisRecordSize + npMCI->dwNextRecordSize))
		return FALSE;

	    npMCI->lLastRead = npMCI->lCurrentFrame;
	    npMCI->lp = npMCI->lpBuffer;
	    npMCI->dwThisRecordSize -= npMCI->dwNextRecordSize;
	}

#ifdef DEBUG
	pdw = (LPDWORD)(npMCI->lp + npMCI->dwThisRecordSize - 3 * sizeof(DWORD));

	if (npMCI->lCurrentFrame < npMCI->lFrames - 1) {
	    Assert(pdw[0] == FOURCC_LIST);
	    Assert(pdw[2] == listtypeAVIRECORD);
	}
#endif
	return TRUE;
    }
    else
#endif

#ifdef AVIREAD
    if (npMCI->hAviRd) {
	/* async reader is going - get the next buffer from him */
	npMCI->lpBuffer = avird_getnextbuffer(npMCI->hAviRd, &dwThisBuffer);
	npMCI->dwThisRecordSize = npMCI->dwNextRecordSize;

	if ((dwThisBuffer == 0) || (npMCI->lpBuffer == NULL)) {
	    npMCI->dwTaskError = MCIERR_FILE_READ;
	    return FALSE;
	}

    } else
#endif
    {
	if (!ReadBuffer(npMCI, -1, (LONG)npMCI->dwNextRecordSize))
	    return FALSE;
    }

    pdw = (DWORD UNALIGNED FAR *)(npMCI->lp + npMCI->dwThisRecordSize - 3 * sizeof(DWORD));

    npMCI->dwNextRecordType = pdw[0];
    npMCI->dwNextRecordSize = pdw[1] + 2 * sizeof(DWORD);

#ifdef DEBUG
    if (npMCI->lCurrentFrame < npMCI->lFrames - 1) {
	Assert(pdw[0] == FOURCC_LIST);
	Assert(pdw[2] == listtypeAVIRECORD);
    }
#endif

    return TRUE;
}

STATICFN INLINE DWORD NEAR PASCAL ReadNextChunk(NPMCIGRAPHIC npMCI)
{
    LPDWORD pdw;
    DWORD dw;

ReadAgain:
    dw = npMCI->dwNextRecordType;

    if (!ReadBuffer(npMCI, -1, (LONG)npMCI->dwNextRecordSize))
	return 0;

    pdw = (LPDWORD)(npMCI->lp + npMCI->dwNextRecordSize - 2 * sizeof(DWORD));

    if (dw == FOURCC_LIST)
	pdw--;

    npMCI->dwNextRecordType = pdw[0];
    npMCI->dwNextRecordSize = pdw[1] + 2 * sizeof(DWORD);

    if (dw == ckidAVIPADDING)
	goto ReadAgain;

    return dw;
}

STATICFN INLINE BOOL NEAR PASCAL StreamRead(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lPos)
{
    LONG  lSize;

    Assert(psi);
#ifdef USEAVIFILE
    Assert(psi->ps);
#endif

    //
    // if we are before the start or after the end, read nothing.
    //
    if (lPos < psi->lStart || lPos >= psi->lEnd) {
	lSize = 0;
	goto done;
    }

#ifdef USEAVIFILE
    if (AVIStreamRead(psi->ps, lPos, 1,
	(LPSTR)npMCI->lpBuffer,npMCI->dwBufferSize,&lSize, NULL) != 0) {

	//
	// the read failed try incressing the buffer size
	//
	AVIStreamRead(psi->ps, lPos, 1, NULL, 0, &lSize, NULL);

	if (lSize > (LONG) (npMCI->dwBufferSize)) {

	    DPF2(("ReadStream: Enlarging buffer....\n"));

	    if (!ResizeReadBuffer(npMCI, lSize)) {
		DPF(("Failed to increase buffer size!\n"));
		npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
		return FALSE;
	    }
	}

	if (AVIStreamRead(psi->ps, lPos, 1,
		(LPSTR)npMCI->lpBuffer,npMCI->dwBufferSize,&lSize,NULL) != 0) {
	    npMCI->dwTaskError = MCIERR_FILE_READ;
	    return FALSE;
	}
    }
#endif

done:
    npMCI->lp = npMCI->lpBuffer;
    npMCI->dwThisRecordSize = lSize;
    return TRUE;
}

BOOL NEAR PASCAL ReadNextVideoFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi)
{
    MMCKINFO    ck;

    if (psi == NULL)
	psi = npMCI->psiVideo;

    Assert(psi);
    AssertFrame(npMCI->lCurrentFrame);

#ifdef USEAVIFILE
    if (psi->ps) {
	LONG        lSize;
	LONG        lPos;

	//
	// map from movie time into this stream.
	//
	lPos = MovieToStream(psi, npMCI->lCurrentFrame);

	//
	// if we are before the start or after the end, read nothing.
	//
	if (lPos <  (LONG)psi->sh.dwStart ||
	    lPos >= (LONG)psi->sh.dwStart+(LONG)psi->sh.dwLength) {
	    lSize = 0;
	    goto done;
	}

	//
	// if this frame has a new palette then deal with it
	//
	if (npMCI->dwFlags & MCIAVI_ANIMATEPALETTE) {
	    ProcessPaletteChanges(npMCI, lPos);
	}

	if (AVIStreamRead(psi->ps, lPos, 1,
		      (LPSTR) npMCI->lpBuffer + 2 * sizeof(DWORD),
		      npMCI->dwBufferSize - 2 * sizeof(DWORD),
		      &lSize, NULL) != 0) {
	    //
	    // the read failed try incressing the buffer size
	    //
	    AVIStreamRead(psi->ps, lPos, 1, NULL, 0, &lSize, NULL);

	    if (lSize > (LONG) (npMCI->dwBufferSize - 2 * sizeof(DWORD))) {

		DPF2(("ReadNextVideoFrame: Enlarging buffer....\n"));

		if (!ResizeReadBuffer(npMCI, lSize + 2 * sizeof(DWORD))) {
		    DPF(("Failed to increase buffer size!\n"));
		    npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
		    return FALSE;
		}
	    }

	    if (AVIStreamRead(psi->ps, lPos, 1,
		      (LPSTR) npMCI->lpBuffer + 2 * sizeof(DWORD),
		      npMCI->dwBufferSize - 2 * sizeof(DWORD),
		      &lSize, NULL) != 0) {
		return FALSE;
	    }
	}

done:
	((DWORD FAR *)npMCI->lpBuffer)[0] = MAKEAVICKID(cktypeDIBbits,
							npMCI->nVideoStream);
	((DWORD FAR *)npMCI->lpBuffer)[1] = lSize;

	npMCI->lp = npMCI->lpBuffer;

	npMCI->dwThisRecordSize = lSize + 2 * sizeof(DWORD);

	return TRUE;
    }
#endif
    //
    // if we are not reading the "next" frame then figure out where it is.
    //
    if (npMCI->lLastRead != npMCI->lCurrentFrame-1)
	CalculatePosition(npMCI);

    //
    // dwNextRecordSize is the size to read
    // and we are seeked to the right place.
    //
    if (npMCI->hpFrameIndex) {

	//
	// if this frame has a new palette then deal with it
	//
	if (npMCI->dwFlags & MCIAVI_ANIMATEPALETTE) {
	     if (FramePalette(npMCI->lCurrentFrame) !=
		 FramePalette(npMCI->lLastPaletteChange))

		ProcessPaletteChanges(npMCI, npMCI->lCurrentFrame);
	}

	//
	// now just go read the frame from the disk.
	//
	// if interleaved add 8 to skip the 'REC'!!!!
	//
	return ReadBuffer(npMCI,
	    (LONG)FrameOffset(npMCI->lCurrentFrame),
	    (LONG)FrameLength(npMCI->lCurrentFrame) + 8);
    } else {
ReadAgainNoIndex:
	for (;;) {
	    if (mmioDescend(npMCI->hmmio, &ck, NULL, 0) != 0) {
		DPF(("Unable to descend!\n"));
		npMCI->dwTaskError = MCIERR_INVALID_FILE;
		return FALSE;
	    }

	    /* If it's a list, stay descended in it. */
	    /* Hack: we never ascend.            */
	    if (ck.ckid == FOURCC_LIST)
		continue;

#ifdef ALPHAFILES
	    /* Skip wave bytes, since they've been preloaded. */
	    if (npMCI->dwFlags & MCIAVI_USINGALPHAFORMAT) {
		if ((ck.ckid != ckidAVIPADDING) &&
			(ck.ckid != ckidOLDPADDING) &&
			(ck.ckid != ckidWAVEbytes))
		    break;
	    } else
#endif
	    {
		if (StreamFromFOURCC(ck.ckid) == (WORD)npMCI->nVideoStream)
		    break;
	    }

	    mmioAscend(npMCI->hmmio, &ck, 0);
	}

	if (ck.cksize + 2 * sizeof(DWORD) > npMCI->dwBufferSize) {
	    if (!ResizeReadBuffer(npMCI, ck.cksize + 2 * sizeof(DWORD))) {
		DPF(("ReadNextVideoFrame: Failed to increase buffer size!\n"));
		npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
		return FALSE;
	    }
	}

	*((LPMMCKINFO) npMCI->lpBuffer) = ck;
	if (mmioRead(npMCI->hmmio, npMCI->lpBuffer + 2 * sizeof(DWORD),
			    ck.cksize) != (LONG) ck.cksize) {
	    npMCI->dwTaskError = MCIERR_INVALID_FILE;
	    return FALSE;
	}

	mmioAscend(npMCI->hmmio, &ck, 0);
	npMCI->lp = npMCI->lpBuffer;

	npMCI->dwThisRecordSize = ck.cksize + 2 * sizeof(DWORD);

	if (TWOCCFromFOURCC(ck.ckid) == cktypePALchange) {
	    npMCI->lp += 2 * sizeof(DWORD);
	    ProcessPaletteChange(npMCI, ck.cksize);
	    npMCI->lLastPaletteChange = npMCI->lCurrentFrame;
	    goto ReadAgainNoIndex;
	}
    }

    return TRUE;
}

BOOL NEAR PASCAL TimeToQuit(NPMCIGRAPHIC npMCI)
{
    /* If we're using DisplayDib, give the user a chance to break. */

    if ((npMCI->dwFlags & MCIAVI_FULLSCREEN) &&
		!(npMCI->dwFlags & MCIAVI_NOBREAK) &&
		(npMCI->wTaskState == TASKPLAYING)) {

	// Check each of the "stop" events
	if (1 & GetAsyncKeyState(VK_LBUTTON)) {
	    npMCI->dwFlags |= MCIAVI_STOP;
	}
	else if
	      (1 & GetAsyncKeyState(VK_RBUTTON)) {
	    npMCI->dwFlags |= MCIAVI_STOP;
	}
	else if
	      (1 & GetAsyncKeyState(VK_ESCAPE)) {
	    npMCI->dwFlags |= MCIAVI_STOP;
	}
	else if
	      (1 & GetAsyncKeyState(VK_SPACE)) {
	    npMCI->dwFlags |= MCIAVI_STOP;
	}
    }

    // this will be set by aviTaskCheckRequests if there is
    // a request that we need to stop to handle
    if (npMCI->dwFlags & MCIAVI_STOP)
	return TRUE;

#ifdef _WIN32
    if (TestNTFlags(npMCI, NTF_RETRYAUDIO)) {
	ResetNTFlags(npMCI, NTF_RETRYAUDIO);
	/*
	 * IF we get access to the wave device, set the flag that
	 * will cause the play to be restarted, then abort this play.
	 */
	SetUpAudio(npMCI, TRUE);
	if (npMCI->hWave) {
	     SetNTFlags(npMCI, NTF_RESTARTFORAUDIO);
	     return(TRUE);
	}
    }
#endif
    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | AllocateReadBuffer | Allocates buffers needed to read
 *      disk information in to.  The amount of memory to allocate
 *      is in npMCI->dwBufferSize.
 *
 * @parm NPMCIGRAPHIC | npMCI | pointer to instance data block.
 *
 * @rdesc TRUE means OK, otherwise unable to allocate memory.
 *
 ***************************************************************************/
BOOL NEAR PASCAL AllocateReadBuffer(NPMCIGRAPHIC npMCI)
{
    if (npMCI->dwBufferSize == 0)
	npMCI->dwBufferSize = npMCI->dwSuggestedBufferSize;

    if (npMCI->dwBufferSize <= 8 * sizeof(DWORD))
    {
	if (npMCI->dwBytesPerSec > 0 &&
	    npMCI->dwBytesPerSec < 600l*1024 &&
	    npMCI->dwMicroSecPerFrame > 0)

	    npMCI->dwBufferSize = (muldiv32(npMCI->dwBytesPerSec,
			npMCI->dwMicroSecPerFrame,1000000L) + 2047) & ~2047;
	else
	    npMCI->dwBufferSize = 10*1024;

	npMCI->dwSuggestedBufferSize = npMCI->dwBufferSize;
    }

    DPF3(("allocating %lu byte read buffer.\n", npMCI->dwBufferSize));

    if (npMCI->lpBuffer) {
	DPF(("Already have buffer in AllocateReadBuffer!\n"));
	return ResizeReadBuffer(npMCI, npMCI->dwBufferSize);
    }

    //!!! we dont need DOS memory when we have a MMIO buffer!
    //!!! we dont need DOS memory when we are using AVIFile???

    if (npMCI->lpMMIOBuffer != NULL || npMCI->pf)
	npMCI->lpBuffer = GlobalAllocPtr(GHND | GMEM_SHARE, npMCI->dwBufferSize);
    else
	npMCI->lpBuffer = AllocMem(npMCI->dwBufferSize);

    return npMCI->lpBuffer != NULL;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | ResizeReadBuffer | Enlarges buffer needed to read
 *      disk information in to.
 *
 * @parm NPMCIGRAPHIC | npMCI | pointer to instance data block.
 *
 * @parm DWORD | dwNewSize | new amount of memory to allocate
 *
 * @rdesc TRUE means OK, otherwise unable to allocate memory.
 *
 ***************************************************************************/
BOOL NEAR PASCAL ResizeReadBuffer(NPMCIGRAPHIC npMCI, DWORD dwNewSize)
{
    if (dwNewSize > npMCI->dwSuggestedBufferSize && !npMCI->fReadMany)
	npMCI->dwSuggestedBufferSize = dwNewSize;

    if (dwNewSize <= npMCI->dwBufferSize)
	return TRUE;

    DPF(("Increasing buffer size to %ld (was %ld).\n", dwNewSize, npMCI->dwBufferSize));

    ReleaseReadBuffer(npMCI);
    npMCI->dwBufferSize = dwNewSize;
    return AllocateReadBuffer(npMCI);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | ReleaseReadBuffer | Releases read buffer.
 *
 * @parm NPMCIGRAPHIC | npMCI | pointer to instance data block.
 *
 ***************************************************************************/
void NEAR PASCAL ReleaseReadBuffer(NPMCIGRAPHIC npMCI)
{
    if (npMCI->lpBuffer) {
	DPF3(("Releasing read buffer.\n"));

	GlobalFreePtr(npMCI->lpBuffer);

	npMCI->lpBuffer = NULL;
	npMCI->dwBufferSize = 0L;
	npMCI->fReadMany = FALSE;
    }
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | ReadBuffer
 *
 ***************************************************************************/

BOOL NEAR PASCAL ReadBuffer(NPMCIGRAPHIC npMCI, LONG off, LONG len)
{
    npMCI->lp = npMCI->lpBuffer;
    npMCI->dwThisRecordSize = len;

    if (len == 0) {
	((DWORD FAR *)npMCI->lpBuffer)[0] = 0; //!!!lpIndexEntry->ckid;
	((DWORD FAR *)npMCI->lpBuffer)[1] = 0;
	npMCI->dwThisRecordSize = 8;
	return TRUE;
    }

    if (len > (LONG)npMCI->dwBufferSize) {
	if (!ResizeReadBuffer(npMCI, len)) {
	    DPF(("Failed to increase buffer size!\n"));
	    npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
	    return FALSE;
	}

	npMCI->lp = npMCI->lpBuffer;
    }

    if (off >= 0)
	DPF2(("ReadBuffer %ld bytes at %ld\n", len, off));
    else
	DPF2(("ReadBuffer %ld bytes\n", len));

    if (off >= 0)
	mmioSeek(npMCI->hmmio, off, SEEK_SET);

#ifdef INTERVAL_TIMES
{
    LONG    lReadStart = -(LONG)timeGetTime();
#endif

    if (mmioRead(npMCI->hmmio, npMCI->lp, len) != len) {
	npMCI->dwTaskError = MCIERR_FILE_READ;
	return FALSE;
    }

#ifdef INTERVAL_TIMES
    lReadStart += timeGetTime();
    npMCI->nReads++;
    npMCI->msReadTotal += lReadStart;
    if (lReadStart > npMCI->msReadMax) {
	npMCI->msReadMax = lReadStart;
    }
}
#endif
    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LPVOID | AllocMem | try to allocate DOS memory (< 1Mb)
 *
 * @parm DWORD | dw | size in bytes
 *
 ***************************************************************************/

#ifndef _WIN32
static LPVOID AllocMem(DWORD dw)
{
    /* Memory allocation internal routines */

    extern DWORD FAR PASCAL GlobalDosAlloc(DWORD);

    LPVOID p;

    if (p = (LPVOID)MAKELONG(0, LOWORD(GlobalDosAlloc(dw))))
	{
	DPF(("Got %ld bytes DOS memory\n", dw));
	GlobalReAlloc((HANDLE)HIWORD((DWORD)p), 0, GMEM_MODIFY|GMEM_SHARE);
	return p;
	}
    else
    {
	DPF(("unable to get %ld bytes of DOS memory\n", dw));
	return GlobalLock(GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE, dw));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\aviread.h ===
/*
 * Copyright (C) Microsoft Corporation 1992. All rights reserved.
 */


/*
 * aviread.h	interface functions to read module providing asynchronous
 *		reading of mmio files.
 *		Only in WIN32 case.
 *
 * 		Creating an avird object causes a worker thread to start
 *		up and callback to a caller-defined function to read blocks
 *		and queue them.
 *		The caller can then call avird_getnextbuffer to get each buffer
 * 		in turn, and once finished with them, should call
 *		avird_emptybuffer: this will notify the avird object that
 *		the buffer is no longer wanted and can be used to read
 *		ahead further blocks.
 */

#ifdef _WIN32

/* handles to avird */
typedef struct avird_header *	HAVIRD;

/* caller passes us a AVIRD_FUNC pointer to a function that
 * will fill the buffer. It takes four args: the buffer to be filled,
 * a dword instance data (containing the mmio handle or npMCI or whatever),
 * a long giving the
 * size of the block to read, and a pointer to the long where it should
 * return the size of the next block. This function will be never
 * be called out of sequence, so assuming the file pointer is at the
 * correct place before calling avird_startread, blocks will be read
 * in sequence by this function (on the worker thread). The function should
 * return FALSE if the read failed in any way.
 */
typedef BOOL (*AVIRD_FUNC)(PBYTE pData, DWORD_PTR dwInstanceData, long lSize, long * plNextSize);

/*
 * start an avird operation and return a handle to use in subsequent
 * calls. This will cause an asynchronous read (achieved using a separate
 * thread) to start reading the next few buffers. it will not read past
 * nblocks assuming that filler will start at firstblock.
 */
HAVIRD avird_startread(AVIRD_FUNC func, DWORD_PTR dwInstanceData, long lFirstSize,
			int firstblock, int nblocks);


/*
 * return the next buffer from an HAVIRD object. also set plSize to
 * the size of the buffer. Returns NULL if there was an error reading
 * the buffer.
 */
PBYTE avird_getnextbuffer(HAVIRD havird, long * plSize);

/*
 * return a buffer that has been finished with (is now empty)
 */
void avird_emptybuffer(HAVIRD havird, PBYTE pBuffer);

/*
 * delete an avird object. the worker thread will be stopped and all
 * data allocated will be freed. The HAVIRD handle is no longer valid after
 * this call.
 */
void avird_endread(HAVIRD havird);


#endif /* _WIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\avisound.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1991-1992. All rights reserved.

   Title:   avisound.c - Code for playing audio in AVI files.

*****************************************************************************/
#include "graphic.h"

#define AUDIO_PANIC 10
static UINT nAudioPanic;

//
// redefine StreamFromFOURCC to only handle 0-9 streams!
//
#undef StreamFromFOURCC
#define StreamFromFOURCC(fcc) (UINT)(HIBYTE(LOWORD(fcc)) - (BYTE)'0')

void FAR PASCAL _LOADDS mciaviWaveOutFunc(HWAVEOUT hWaveOut, UINT wMsg,
		    DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

#ifndef _WIN32
#define GetDS() (HGLOBAL)HIWORD((DWORD)(LPVOID)&ghModule)
#endif //WIN16

#ifdef REMOTESTEAL
#if 0 // COMMENTARY
    Wave devices can only be used by one task at a time.  When there are
    multiple processes involved we need to have some way of passing the
    wave device around between processes.  Because each process executes
    asynchronously we choose an asynchronous method of passing the wave
    device.

    When we start playing an attempt is made to open the wave device.  If
    successful we write our playback window handle to a known (volatile)
    area of the registry.

    When we stop playing and release the wave device we clear the registry.

    If we cannot open a wave device, we inspect the registry to see if
    another process has it open.  If YES, then we post a WM_AUDIO_OFF message
    to the registered window handle, passing our playback window handle as
    a parameter.  We then continue to play silently.

    Receiving WM_AUDIO_OFF:
	if we are playing with a wave device we stop temporarily, post a
	message to the task wanting the wave device along with our window
	handle (so that the wave device can be returned to us).

    When we have finished with the wave device we check hwndLostAudio to
    see if there is a window we should tell to pick up the wave device.
    If so, we post WM_AUDIO_ON to that window.

#endif// COMMENTARY

// hwndLostAudio is set to the window handle of the device from which we
//	stole the audio device.  It is passed as a parameter on the
//	WM_AUDIO_ON message to tell us to whom we should return the
//	wave device when we have finished with it.

// hwndWantAudio contains transitory state.  It is set on receipt of a
//	WM_AUDIO_OFF message to tell us the window that wants to grab the
//	wave device.  If we are playing, we temporarily stop which causes
//	the wave device to be released.  Immediately the wave device is
//	released we post a message to hwndWantAudio and reset the variable.
//	If we receive a WM_AUDIO_OFF message while we are not playing (which
//	can happen due to asynchronous execution) hwndWantAudio is not set.

HWND hwndLostAudio=0;  // Window handle of the window who gave up audio
HWND hwndWantAudio=0;  // Window handle of the window which wants the audio

HKEY	hkey = 0;  // Handle to area of registry for inter process steal

#define REMOTEWAVEHWND  TEXT("RemoteWaveWindow")
#define WAVEOWNER       TEXT("WaveOwner")

TCHAR szRemoteWaveHwnd[] = REMOTEWAVEHWND;
TCHAR szWaveOwner[] = WAVEOWNER;
#include <profile.key>
#endif

/******************************************************************************
*****************************************************************************/

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | SetUpAudio | set up wave device and associated data
 *
 * @parm NPMCIGRAPHIC | npMCI | near ptr to the instance data
 *
 * @parm BOOL | fPlaying |
 *
 ***************************************************************************/

DWORD FAR PASCAL SetUpAudio(NPMCIGRAPHIC npMCI, BOOL fPlaying)
{
    UINT	w;
    DWORD	dw;
    LPWAVEHDR   lpWaveHdr;
    STREAMINFO *psi;

    if (npMCI->nAudioStreams == 0) {
	npMCI->wABs = 0;
	npMCI->wABOptimal = 0;
	return 0L;
    }

    nAudioPanic = mmGetProfileInt(szIni, TEXT("AudioPanic"), AUDIO_PANIC);

    psi = SI(npMCI->nAudioStream);
    Assert(psi->sh.fccType == streamtypeAUDIO);
    Assert(psi->cbFormat);
    Assert(psi->lpFormat);

    if (!npMCI->pWF) {
        npMCI->pWF = (NPWAVEFORMAT)LocalAlloc(LPTR, (UINT)psi->cbFormat);

	if (!npMCI->pWF) {
	    return MCIERR_OUT_OF_MEMORY;
	}
    }

    hmemcpy(npMCI->pWF,psi->lpFormat,psi->cbFormat);

    npMCI->wEarlyAudio = (UINT)psi->sh.dwInitialFrames;
    DPF1(("Setting up audio... wEarlyAudio==%d\n", npMCI->wEarlyAudio));
    npMCI->dwAudioLength = psi->sh.dwLength * psi->sh.dwSampleSize;

    if (npMCI->dwAudioLength < 1000L) {
        DPF(("AudioLength is bogus"));
        npMCI->dwAudioLength = muldiv32((npMCI->pWF->nAvgBytesPerSec + 100) *
                npMCI->lFrames,npMCI->dwMicroSecPerFrame,1000000L);
    }

    if (!fPlaying) {
	// We are not actually playing.  Check to see if we will be able
	// to handle the format of the wave data.
        if (IsNTWOW()) {
            /* See if we can cope with this wave format. */
            w = waveOutOpen(&npMCI->hWave, (UINT)WAVE_MAPPER,
        		(const LPWAVEFORMATEX) npMCI->pWF,
        		(DWORD_PTR) NULL,
        		(DWORD_PTR) (LPMCIGRAPHIC) npMCI,
                        (DWORD) WAVE_FORMAT_QUERY);
	    if (WAVERR_BADFORMAT == w)
		return(MCIERR_WAVE_OUTPUTSUNSUITABLE);	// Try 16 bit codec
	    else
		return(0);  // We might be able to cope with this format
        }
    }

    //
    // choose the audio playback method depending on how we are going to
    // receive audio data from the file.
    //
    switch (npMCI->wPlaybackAlg) {
        case MCIAVI_ALG_HARDDISK:
	case MCIAVI_ALG_AUDIOONLY:

            if (!npMCI->pf && !npMCI->hmmioAudio) {
                MMIOINFO            mmioInfo;

                _fmemset(&mmioInfo, 0, sizeof(MMIOINFO));
                mmioInfo.htask = (HANDLE) npMCI->hCallingTask; //ntmmsystem bug, should be threadid which is dword
                npMCI->hmmioAudio = mmioOpen(npMCI->szFilename, &mmioInfo,
                                        MMIO_READ | MMIO_DENYWRITE);

                if (npMCI->hmmioAudio == NULL)
                    npMCI->hmmioAudio = mmioOpen(npMCI->szFilename, &mmioInfo,
                                        MMIO_READ);

                if (!npMCI->hmmioAudio) {
		    Assert(0);
		    return MCIERR_DRIVER_INTERNAL;
		}
            }

            // !!! We use four 1/2 second buffers.  This is arbitrary.
            npMCI->wABs = 4;
            npMCI->wABOptimal = 0;
            npMCI->dwABSize = npMCI->pWF->nAvgBytesPerSec / 2;
	    break;

        case MCIAVI_ALG_CDROM:
            //!!!! we need to tune this!!!!
            // !!! We use four 1/4 second buffers.  This is arbitrary.
            npMCI->wABs = mmGetProfileInt(szIni, TEXT("CDAudioBuffers"), 4);
            npMCI->wABOptimal = 0;
            npMCI->dwABSize = npMCI->pWF->nAvgBytesPerSec /
			      mmGetProfileInt(szIni, TEXT("CDAudioBufSize"), 4);
            break;

        case MCIAVI_ALG_INTERLEAVED:
#define BUFMOD	    4096  	// had better be a power of 2!
            /* Fix up some values based on the header information */
            dw = muldiv32(npMCI->dwMicroSecPerFrame,
                    npMCI->pWF->nAvgBytesPerSec,1000000L);

            npMCI->dwABSize = (dw + BUFMOD - 1) & ~(BUFMOD - 1L);

            npMCI->wABs = npMCI->wEarlyAudio + 2 + (WORD) npMCI->dwBufferedVideo;

            /* Soundblaster hack: waveoutdone only accurate to 2K. */

            //!!!!!!!!!! is this right.

            if (npMCI->dwMicroSecPerFrame) {
                npMCI->wABOptimal = npMCI->wABs -
                        (UINT) (muldiv32(BUFMOD, 1, muldiv32(npMCI->dwMicroSecPerFrame,
                        npMCI->pWF->nAvgBytesPerSec,1000000L)));
            } else {
                npMCI->wABOptimal = 0;
            }

            //!!! hack so we can do burst reading, up to 1sec
            //npMCI->wABs += (int)muldiv32(1000000l, 1, npMCI->dwMicroSecPerFrame);

	    // !!!!!!
	    // !!!!!!
	    npMCI->wABOptimal = 0;
	    npMCI->wABs = (UINT) muldivru32(npMCI->wABs, dw, npMCI->dwABSize) + 1;
	
            DPF2(("Using %u audio buffers of %lu bytes, of which %u should be full.\n", npMCI->wABs, npMCI->dwABSize, npMCI->wABOptimal));
            break;

        default:
            Assert(0);
            return 0L;
    }

    npMCI->dwABSize -= npMCI->dwABSize % npMCI->pWF->nBlockAlign;

    if (!fPlaying) {
	return 0L;
    }

    /* This code adjusts the wave format block to play
    ** the audio at the correct speed to match the frame rate.
    */

    npMCI->pWF->nSamplesPerSec = muldiv32(npMCI->pWF->nSamplesPerSec,
					    npMCI->dwMicroSecPerFrame,
					    npMCI->dwPlayMicroSecPerFrame);

    npMCI->pWF->nAvgBytesPerSec = muldiv32(npMCI->pWF->nAvgBytesPerSec,
					    npMCI->dwMicroSecPerFrame,
					    npMCI->dwPlayMicroSecPerFrame);

    if (npMCI->pWF->wFormatTag == WAVE_FORMAT_PCM) {
	/* Make sure this is exactly right... */
	npMCI->pWF->nAvgBytesPerSec =
            npMCI->pWF->nSamplesPerSec * npMCI->pWF->nBlockAlign;
    }

    /* Kill any currently playing sound */
    sndPlaySound(NULL, 0);

    DPF2(("Opening wave device....\n"));
    /* Try to open a wave device. */
    w = waveOutOpen(&npMCI->hWave, (UINT)WAVE_MAPPER,
		(const LPWAVEFORMATEX) npMCI->pWF,
		(DWORD_PTR) &mciaviWaveOutFunc,
		(DWORD_PTR) (LPMCIGRAPHIC) npMCI,
                (DWORD)CALLBACK_FUNCTION);

    if (w) {
	DPF(("Unable to open wave device.\n"));

	npMCI->hWave = NULL;
        return w == WAVERR_BADFORMAT ?
			    MCIERR_WAVE_OUTPUTSUNSUITABLE :
			    MCIERR_WAVE_OUTPUTSINUSE;
    }

    // We now have the wave device, so turn off the flag that says we
    // lost it.
    npMCI->dwFlags &= ~MCIAVI_LOSTAUDIO;

#ifndef _WIN32 // No need to lock it on NT - although we could with Virtual mem
              // functions
    //
    // page lock our DS so our wave callback function can
    // touch it without worry. see mciaviWaveOutFunc()
    //
    GlobalPageLock(GetDS());
#endif //WIN16

    /* Pause the wave output device, so it won't start playing
    ** when we're loading up the buffers.
    */
    if (waveOutPause(npMCI->hWave) != 0) {
	DPF(("Error from waveOutPause!\n"));
	return MCIERR_DRIVER_INTERNAL;
    }

    if (npMCI->dwFlags & MCIAVI_VOLUMESET) {
	InternalSetVolume(npMCI, npMCI->dwVolume);
    } else {
	// must be done on worker thread
	InternalGetVolume(npMCI);
    }

#ifdef DEBUG
    Assert(!(npMCI->lpAudio));
#endif
    npMCI->lpAudio = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE,
		    npMCI->wABs * (npMCI->dwABSize + sizeof(WAVEHDR)));

    if (!npMCI->lpAudio) {
        // The wave device will be released when CleanUpAudio is called
	return MCIERR_OUT_OF_MEMORY;
    }

    npMCI->dwAudioPlayed = 0L;
    npMCI->wNextAB = 0;
    npMCI->dwUsedThisAB = 0;

    /* Allocate and prepare our buffers */
    for (w = 0; w < npMCI->wABs; w++) {
	lpWaveHdr = (LPWAVEHDR) (npMCI->lpAudio + (w * sizeof(WAVEHDR)));

	lpWaveHdr->lpData = (HPSTR) npMCI->lpAudio +
				    npMCI->wABs * sizeof(WAVEHDR) +
				    w * npMCI->dwABSize;
	lpWaveHdr->dwBufferLength = npMCI->dwABSize;
	lpWaveHdr->dwBytesRecorded = 0L;
	lpWaveHdr->dwUser = 0L;
	lpWaveHdr->dwFlags = 0L;
	lpWaveHdr->dwLoops = 0L;
	lpWaveHdr->lpNext = 0L;
	lpWaveHdr->reserved = 0;
    }

    for (w = 0; w < npMCI->wABs; w++) {
	lpWaveHdr = (LPWAVEHDR) (npMCI->lpAudio + (w * sizeof(WAVEHDR)));

	if (waveOutPrepareHeader(npMCI->hWave, lpWaveHdr, sizeof(WAVEHDR))
			!= 0) {
	    return MCIERR_OUT_OF_MEMORY;
	}
	lpWaveHdr->dwFlags |= WHDR_DONE;
    }

#ifdef REMOTESTEAL
    // Set a registry key so that other processes know who has the
    // wave device... if it fails we do not bother to try and
    // recover.  It only means that the sound will not follow the
    // active video
    {
	TCHAR achName[100];
	DWORD dwRet;
	DWORD dwDisposition;

	lstrcpy(achName, KEYNAME);
	lstrcat(achName, szWaveOwner);

	EnterList();
        if (hkey || (ERROR_SUCCESS == (dwRet = RegCreateKeyEx(ROOTKEY, achName, 0,
			    TEXT("VFW"), REG_OPTION_VOLATILE, KEY_ALL_ACCESS,
			    NULL, &hkey, &dwDisposition)))) {

	    // Write both out process id and the handle of the event
	    // that needs to be signalled.  Any remote process out there
	    // that want to steal our wave device will duplicate the handle
	    // to the event, for which our process id is required.
	    DWORD pid = GetCurrentProcessId();
	    RegSetValueEx(hkey, szRemoteWaveHwnd, 0, REG_DWORD,
			    (CONST BYTE *)&npMCI->hwndDefault, sizeof(npMCI->hwndDefault));
	}
	LeaveList();
    }
#endif

    return 0L;
}

DWORD FAR PASCAL CleanUpAudio(NPMCIGRAPHIC npMCI)
{
    UINT	w;

    /* Clear flags relating to playing audio */
    npMCI->dwFlags &= ~(MCIAVI_WAVEPAUSED | MCIAVI_LOSEAUDIO);

    if (npMCI->lpAudio) {
        waveOutRestart(npMCI->hWave); // just in case we are paused
	waveOutReset(npMCI->hWave);

	for (w = 0; w < npMCI->wABs; w++) {
	    LPWAVEHDR	lpWaveHdr;

	    lpWaveHdr = (LPWAVEHDR) (npMCI->lpAudio
					    + (w * sizeof(WAVEHDR)));

#ifndef _WIN32
	    //don't touch prepared data
	    lpWaveHdr->lpData = npMCI->lpAudio
				    + npMCI->wABs * sizeof(WAVEHDR)
				    + w * npMCI->dwABSize;
	    lpWaveHdr->dwBufferLength = npMCI->dwABSize;
#endif

	    /* Do we need to check for an error from this? */
	    waveOutUnprepareHeader(npMCI->hWave, lpWaveHdr,
						    sizeof(WAVEHDR));
	}
	GlobalFreePtr(npMCI->lpAudio);
	npMCI->lpAudio = NULL;

	Assert(npMCI->wABFull == 0);
    }

    DPF2(("Closing wave device.\n"));
#ifdef REMOTESTEAL
    EnterList()
    if (hkey) {
        RegDeleteValue(hkey, szRemoteWaveHwnd);
    }
    LeaveList()
#endif
    waveOutClose(npMCI->hWave);
    npMCI->hWave = 0;

#ifdef REMOTESTEAL
    // If we are being asked to give the audio to someone else...
    // tell them to pick it up, and tell them that we want it back.
    // We do this here rather than in GiveWaveDevice as GiveWaveDevice
    // may not be called.
    if (hwndWantAudio) {
	if (IsWindow(hwndWantAudio)) {
	    PostMessage(hwndWantAudio, WM_AUDIO_ON, (WPARAM)npMCI->hwndDefault, 0);
	}
	hwndWantAudio = 0;
    }
#endif // REMOTESTEAL

#ifndef _WIN32
    GlobalPageUnlock(GetDS());
#endif //WIN16

    return 0L;
}

BOOL NEAR PASCAL WaitForFreeAudioBuffer(NPMCIGRAPHIC npMCI, BOOL FAR *lpfHurry)
{
    LPWAVEHDR   lpWaveHdr;

    lpWaveHdr = (LPWAVEHDR) (npMCI->lpAudio
				+ (npMCI->wNextAB * sizeof(WAVEHDR)));

    /* Use the number of full audio buffers to decide if we're behind. */
    if (npMCI->wABFull < npMCI->wABOptimal) {
        *lpfHurry = TRUE;
    }

    /* If all of the audio buffers are full, we have to wait. */
    if (npMCI->wABFull == npMCI->wABs) {

        DWORD time = timeGetTime();

        #define AUDIO_WAIT_TIMEOUT 2000

        DOUT2("waiting for audio buffer.");

        // we better not wait if the device is not playing!
        Assert(!(npMCI->dwFlags & MCIAVI_WAVEPAUSED));

#ifdef XDEBUG
        GetAsyncKeyState(VK_ESCAPE);
        GetAsyncKeyState(VK_F2);
        GetAsyncKeyState(VK_F3);
        GetAsyncKeyState(VK_F4);
#endif
        while (npMCI->wABFull == npMCI->wABs) {

            if (npMCI->dwFlags & MCIAVI_STOP)
                return FALSE;

            aviTaskCheckRequests(npMCI);

            //
            //  the "Fahrenheit VA Audio Wave Driver" may get confused
            //  if you call waveOutPause() and waveOutRestart() alot
            //  and it will stay paused no matter what you do, it has
            //  all our buffers and it still does not make any sound
            //  you can call waveOutRestart() until you are blue in
            //  the face, it will do nothing.
            //
            //  so this is why this routine can time out, after waiting
            //  2 seconds or so we just toss all the audio in the buffers
            //  and start over.
            //
            if (timeGetTime() - time > AUDIO_WAIT_TIMEOUT) {
                DOUT("Gave up waiting, reseting wave device\n");
                gfUseGetPosition = 0;
                // Can no longer rely on waveOutGetPosition returning
                // the right value.
                waveOutReset(npMCI->hWave);
                break;
            }

#ifdef XDEBUG
            if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) {
                DPF(("STOPPED WAITING! wABFull = %d, wABs = %d\n", npMCI->wABFull,npMCI->wABs));
                return FALSE;
            }

            if (GetAsyncKeyState(VK_F2) & 0x0001) {
                DOUT("Trying waveOutRestart\n");
                waveOutRestart(npMCI->hWave);
            }

            if (GetAsyncKeyState(VK_F3) & 0x0001) {
                DOUT("Trying waveOutReset\n");
                gfUseGetPosition = 0;
                // Can no longer rely on waveOutGetPosition returning
                // the right value.
                waveOutReset(npMCI->hWave);
            }

            if (GetAsyncKeyState(VK_F4) & 0x0001) {

                int i,n;

                for (i=n=0; i<(int)npMCI->wABs; i++) {

                    if (((LPWAVEHDR)npMCI->lpAudio)[i].dwFlags & WHDR_DONE) {
                        DPF(("Buffer #%d is done!\n", i));
                        n++;
                    }
                    else {
                        DPF(("Buffer #%d is not done\n", i));
                    }
                }

                if (n > 0)
                    DPF(("%d buffers are done but our callback did not get called!\n", n));
            }
#endif
        }

        DOUT2("done\n");
    }

    /* Debugging check that wave has finished playing--should never happen */
    Assert(lpWaveHdr->dwFlags & WHDR_DONE);

#ifndef _WIN32
// don't touch prepared data
    lpWaveHdr->lpData = npMCI->lpAudio +
				npMCI->wABs * sizeof(WAVEHDR) +
				npMCI->wNextAB * npMCI->dwABSize;
#endif

    return TRUE;
}

#ifndef _WIN32
#pragma optimize("", off)
#endif

BOOL NEAR PASCAL ReadSomeAudio(NPMCIGRAPHIC npMCI, BYTE _huge * lpAudio,
				DWORD dwStart, DWORD FAR * pdwLength)
{
    DWORD	dwIndex = 0;
    DWORD	ckidAudio;
    DWORD	dwAudioPos = 0L;
    AVIINDEXENTRY far * lpIndexEntry;

    Assert(npMCI->wPlaybackAlg == MCIAVI_ALG_HARDDISK ||
           npMCI->wPlaybackAlg == MCIAVI_ALG_AUDIOONLY);

    Assert(npMCI->hpIndex);

    /*
    ** Figure out what type of chunk we're looking for,
    */
    ckidAudio = MAKEAVICKID(cktypeWAVEbytes, npMCI->nAudioStream);

    lpIndexEntry = (AVIINDEXENTRY FAR *) npMCI->hpIndex;

    for (dwIndex = 0; dwIndex < npMCI->macIndex;
                dwIndex++, ++((AVIINDEXENTRY _huge *) lpIndexEntry)) {

	if (lpIndexEntry->ckid != ckidAudio)
	    continue;
	
	if (dwAudioPos + lpIndexEntry->dwChunkLength > dwStart) {
	    DWORD	dwLengthNow;
	    DWORD	dwSeekTo;
	
	    dwLengthNow = lpIndexEntry->dwChunkLength;
	    dwSeekTo = lpIndexEntry->dwChunkOffset + 8;
	
	    if (dwAudioPos + dwLengthNow > dwStart + *pdwLength) {
		/* Attempted optimization: If we've already read some
		** data, and we can't read the next whole chunk, let's
		** leave it for later.
		*/
		if (dwAudioPos > dwStart && (!(npMCI->dwFlags & MCIAVI_REVERSE)))
		    break;
		dwLengthNow = dwStart + *pdwLength - dwAudioPos;
	    }
	
	    if (dwAudioPos < dwStart) {
		dwLengthNow -= (dwStart - dwAudioPos);
		dwSeekTo += (dwStart - dwAudioPos);
	    }

            mmioSeek(npMCI->hmmioAudio, dwSeekTo, SEEK_SET);

	    if (mmioRead(npMCI->hmmioAudio, lpAudio, dwLengthNow)
			    != (LONG) dwLengthNow) {
		DPF(("Error reading audio data (%lx bytes at %lx)\n", dwLengthNow, dwSeekTo));
		return FALSE;
	    }
	    lpAudio += dwLengthNow;	
	}
	
	dwAudioPos += lpIndexEntry->dwChunkLength;
	
	if (dwAudioPos >= dwStart + *pdwLength)
	    return TRUE;
    }

    if (dwAudioPos < dwStart)
	*pdwLength = 0;	    // return FALSE?
    else
	*pdwLength = dwAudioPos - dwStart;

    return TRUE;
}
#ifndef _WIN32
#pragma optimize("", on)
#endif
	
BOOL NEAR PASCAL ReverseWaveBuffer(NPMCIGRAPHIC npMCI, LPWAVEHDR lpWaveHdr)
{
    DWORD   dwLeft = lpWaveHdr->dwBufferLength;
    BYTE _huge *hp1;
    BYTE _huge *hp2;
    DWORD   dwBlock = npMCI->pWF->nBlockAlign;
    BYTE    bTemp;
    DWORD   dw;

    Assert(npMCI->dwFlags & MCIAVI_REVERSE);
    Assert(npMCI->wPlaybackAlg == MCIAVI_ALG_HARDDISK ||
	   npMCI->wPlaybackAlg == MCIAVI_ALG_AUDIOONLY);

    /* This routine doesn't like it when the data doesn't end on a
    ** block boundary, so make it so.  This should never happen.
    */
    Assert((dwLeft % dwBlock) == 0);
    dwLeft -= dwLeft % dwBlock;

    hp1 = lpWaveHdr->lpData;
    hp2 = ((HPSTR) lpWaveHdr->lpData) + (dwLeft - dwBlock);

    while ((LONG) dwLeft > (LONG) dwBlock) {
	for (dw = 0; dw < dwBlock; dw++) {
	    bTemp = *hp1;
	    *hp1++ = *hp2;
	    *hp2++ = bTemp;
	}
	hp2 -= dwBlock * 2;
	dwLeft -= dwBlock * 2;
    }

    return TRUE;
}

void FAR PASCAL BuildVolumeTable(NPMCIGRAPHIC npMCI)
{
    int	    vol;
    int     i;

    if (!npMCI->pWF || npMCI->pWF->wFormatTag != WAVE_FORMAT_PCM)
        return;

    if (((NPPCMWAVEFORMAT) npMCI->pWF)->wBitsPerSample != 8)
        return;

    vol = (LOWORD(npMCI->dwVolume) + HIWORD(npMCI->dwVolume)) / 2;
    vol = (int) (((LONG) vol * 256) / 500);

    if (!npMCI->pVolumeTable)
        npMCI->pVolumeTable = (void *)LocalAlloc(LPTR, 256);

    if (!npMCI->pVolumeTable)
        return;

    for (i = 0; i < 256; i++) {
        npMCI->pVolumeTable[i] = (BYTE) min(255, max(0,
                (int) ((((LONG) (i - 128) * vol) / 256) + 128)));
    }
}

BOOL NEAR PASCAL AdjustVolume(NPMCIGRAPHIC npMCI, LPWAVEHDR lpWaveHdr)
{
    DWORD   dwLeft = lpWaveHdr->dwBufferLength;
    BYTE FAR *pb;

    if (npMCI->pWF->wFormatTag != WAVE_FORMAT_PCM)
	return FALSE;

    if (!npMCI->pVolumeTable)
        return FALSE;

    if (((NPPCMWAVEFORMAT)npMCI->pWF)->wBitsPerSample != 8)
        return FALSE;

    pb = lpWaveHdr->lpData;

#ifndef _WIN32
    if (OFFSETOF(pb) + dwLeft > 64l*1024) {
	while (dwLeft--) {
            *pb = npMCI->pVolumeTable[*pb];
            ((BYTE _huge *)pb)++;
	}
    }
    else {
        while ((int)dwLeft--)
            *pb++ = npMCI->pVolumeTable[*pb];
    }
#else
    while ((int)dwLeft--)
        *pb++ = npMCI->pVolumeTable[*pb];
#endif

    return TRUE;
}

BOOL NEAR PASCAL PlaySomeAudio(NPMCIGRAPHIC npMCI, LPWAVEHDR lpWaveHdr)
{
    if (npMCI->pVolumeTable)
        AdjustVolume(npMCI, lpWaveHdr);

    lpWaveHdr->dwFlags &= ~WHDR_DONE;

    /* If we're playing and we've used all of our audio buffers, pause the
    ** wave device until we can fill more of them up.
    **
    ** we need to be carefull not to do this on the last frame!!!
    */
    if ((npMCI->wTaskState == TASKPLAYING) &&
        !(npMCI->dwFlags & MCIAVI_WAVEPAUSED) &&
        (npMCI->wABFull == 0 || npMCI->nAudioBehind > nAudioPanic)) {

        if (npMCI->wABFull > 0) {
            DPF(("Audio panic stop\n"));
        } else {
            DPF(("Audio queue empty; pausing wave device\n"));
        }

        //
        // some audio cards dont like starving it confuses them
        // it is kind of rude any way.  we are going to cause a audio break
        // anyway so if we lose a little bit of audio (a few frames or so)
        // no one will even notice (any worse than the audio break)
        //
        if (npMCI->wABFull <= 1) {
            DOUT("Trying audio hack!\n");
            gfUseGetPosition = 0;
            // Can no longer rely on waveOutGetPosition returning
            // the right value.
            waveOutReset(npMCI->hWave);
        }

        ++npMCI->dwAudioBreaks;
        waveOutPause(npMCI->hWave);

        ICDrawStop(npMCI->hicDraw);
	npMCI->dwFlags |= MCIAVI_WAVEPAUSED;
    }


    if (waveOutWrite(npMCI->hWave, lpWaveHdr, sizeof(WAVEHDR)) != 0) {
        DPF(("Error from waveOutWrite!\n"));
	npMCI->dwTaskError = MCIERR_AVI_AUDIOERROR;

        // if this fails, you can end up looping indefinitely in
        // PlayRecordAudio in the while(cksize) loop - cksize is never
        // decremented because the current audio buffer stays full.
        // Need to throw this stuff away or we lock up.
        npMCI->dwUsedThisAB = 0;


	return FALSE;
    } else {
#ifdef _WIN32
	InterlockedIncrement(&npMCI->wABFull);
#else
	++npMCI->wABFull;
#endif

	/* Use the next wave buffer next time */
	++npMCI->wNextAB;
	if (npMCI->wNextAB == npMCI->wABs)
	    npMCI->wNextAB = 0;
	
	npMCI->dwUsedThisAB = 0;
    }

    if (npMCI->wABFull < min(npMCI->wABOptimal, npMCI->wABFull/2))
        npMCI->nAudioBehind++;
    else
        npMCI->nAudioBehind=0;

    /* If we paused the wave device to let ourselves catch up, and
    ** we've caught up enough, restart the device.
    */
    if ((npMCI->dwFlags & MCIAVI_WAVEPAUSED) &&
        npMCI->wTaskState == TASKPLAYING &&
        npMCI->wABFull == npMCI->wABs) {

        DPF2(("restarting wave device\n"));
        waveOutRestart(npMCI->hWave);

	ICDrawStart(npMCI->hicDraw);
        npMCI->dwFlags &= ~(MCIAVI_WAVEPAUSED);
        npMCI->nAudioBehind = 0;
    }

    return TRUE;
}

/* Play the current record's audio */
BOOL NEAR PASCAL PlayRecordAudio(NPMCIGRAPHIC npMCI, BOOL FAR *pfHurryUp,
				    BOOL FAR *pfPlayedAudio)
{
    LPWAVEHDR	lpWaveHdr;
    FOURCC	ckid;
    DWORD	cksize;
    LPSTR	lpSave;
    BYTE _huge *lpData;
    BOOL	fRet = TRUE;
////BOOL        fSilence;
    LONG        len;
    DWORD       dwBytesThisChunk;

    Assert(npMCI->wPlaybackAlg == MCIAVI_ALG_INTERLEAVED);

    lpSave = npMCI->lp;

    *pfPlayedAudio = FALSE;

    /* Remember!
    **
    ** In the new file format, things shouldn't necessarily need to
    ** be ordered with the wave stuff always first.
    */

    len = (LONG)npMCI->dwThisRecordSize;

    while (len > 3 * sizeof(DWORD)) {

	/* Look at the next chunk */
	ckid = GET_DWORD();
        cksize = GET_DWORD();

        lpData = npMCI->lp;

	if ((DWORD) cksize > (DWORD) len) {
            DPF(("Chunk obviously too big!"));
	    break;
	}

        len -= ((cksize + 1) & ~1) + 8;
        SKIP_BYTES((cksize + 1) & ~1);

        if (StreamFromFOURCC(ckid) != (UINT)npMCI->nAudioStream)
            continue;

	*pfPlayedAudio = TRUE;

	while (cksize) {
	    dwBytesThisChunk = cksize;

	    lpWaveHdr = ((LPWAVEHDR)npMCI->lpAudio) + npMCI->wNextAB;

	    if (!npMCI->dwUsedThisAB) {
		if (!WaitForFreeAudioBuffer(npMCI, pfHurryUp))
		    /* We had to stop waiting--the stop flag was probably set. */
		    goto exit;
	    }

	    if (dwBytesThisChunk > npMCI->dwABSize - npMCI->dwUsedThisAB) {
		// DPF(("Audio Record is too big!\n"));
		dwBytesThisChunk = npMCI->dwABSize - npMCI->dwUsedThisAB;
	    }

	    hmemcpy((BYTE _huge *)lpWaveHdr->lpData + npMCI->dwUsedThisAB,
		    lpData, dwBytesThisChunk);

	    cksize -= dwBytesThisChunk;
	    lpData += dwBytesThisChunk;
	    npMCI->dwUsedThisAB += dwBytesThisChunk;
	
	    if (npMCI->dwUsedThisAB == npMCI->dwABSize) {
		lpWaveHdr->dwBufferLength = npMCI->dwUsedThisAB;

		fRet = PlaySomeAudio(npMCI, lpWaveHdr);
	    }
	}

    }

    if ((*pfPlayedAudio == FALSE) && (npMCI->dwUsedThisAB)) {

	// this is interleaved. therefore if we have some audio waiting,
	// and there was no audio in this record, it's because we've
	// used up all the audio -> so play remaining audio or
	// it will never be queued.

	lpWaveHdr = ((LPWAVEHDR)npMCI->lpAudio) + npMCI->wNextAB;
	lpWaveHdr->dwBufferLength = npMCI->dwUsedThisAB;
	fRet = PlaySomeAudio(npMCI, lpWaveHdr);
    }

    /* Use the number of full audio buffers to decide if we're behind. */
    if (npMCI->wABFull >= npMCI->wABOptimal) {
         *pfHurryUp = FALSE;
    }

exit:
    npMCI->lp = lpSave;

    return fRet;
}

/* For "preload audio" or "random access audio" modes, do what needs
** to be done to keep our buffers full.
*/
BOOL NEAR PASCAL KeepPlayingAudio(NPMCIGRAPHIC npMCI)
{
    LPWAVEHDR	lpWaveHdr;
    DWORD	dwBytesTotal = 0L;
    LONG        lNewAudioPos;
////BOOL        fFirstTime = TRUE;

    Assert(npMCI->wPlaybackAlg == MCIAVI_ALG_HARDDISK ||
	   npMCI->wPlaybackAlg == MCIAVI_ALG_AUDIOONLY);

PlayMore:
    lpWaveHdr = ((LPWAVEHDR)npMCI->lpAudio) + npMCI->wNextAB;

    if (npMCI->dwFlags & MCIAVI_REVERSE) {
	lNewAudioPos = npMCI->dwAudioPos - npMCI->dwABSize;
	if (lNewAudioPos < 0)
	    lNewAudioPos = 0;
	dwBytesTotal = npMCI->dwAudioPos - lNewAudioPos;
    } else {
	lNewAudioPos = npMCI->dwAudioPos + npMCI->dwABSize;
	if (lNewAudioPos > (LONG) npMCI->dwAudioLength)
	    lNewAudioPos = npMCI->dwAudioLength;
	dwBytesTotal = lNewAudioPos - npMCI->dwAudioPos;
    }

    if (dwBytesTotal == 0) {

        if (npMCI->dwFlags & MCIAVI_WAVEPAUSED) {

            DOUT("no more audio to play, restarting wave device\n");

            waveOutRestart(npMCI->hWave);
            ICDrawStart(npMCI->hicDraw);
            npMCI->dwFlags &= ~(MCIAVI_WAVEPAUSED);
            npMCI->nAudioBehind = 0;
        }

        return TRUE;
    }

    /* If all of the audio buffers are full, we have nothing to do */
    if (npMCI->wABFull == npMCI->wABs)
	return TRUE;

#if 0
    //!!!! Should we be yielding at all in here?
    //!!! NO NO! not if updating!!!!
    if (!fFirstTime) {
	aviTaskYield();
    }
    fFirstTime = FALSE;
#endif

    if (npMCI->dwFlags & MCIAVI_REVERSE)
	npMCI->dwAudioPos = lNewAudioPos;

#ifdef USEAVIFILE
    if (npMCI->pf) {
	LONG	    lPos;
	LONG	    lLength;

        lPos = npMCI->dwAudioPos / SH(npMCI->nAudioStream).dwSampleSize;
	lLength = dwBytesTotal / SH(npMCI->nAudioStream).dwSampleSize;

        AVIStreamRead(SI(npMCI->nAudioStream)->ps,
		      lPos, lLength,
		      lpWaveHdr->lpData,
		      npMCI->dwABSize,
		      NULL, NULL);
    }
    else
#endif
    {
	if (!ReadSomeAudio(npMCI, lpWaveHdr->lpData,
			npMCI->dwAudioPos,
			&dwBytesTotal))
	    return FALSE;
		
	if (dwBytesTotal == 0)
		return TRUE;
    }

    if (!(npMCI->dwFlags & MCIAVI_REVERSE))
	npMCI->dwAudioPos += dwBytesTotal;

    lpWaveHdr->dwBufferLength = dwBytesTotal;

    if (npMCI->dwFlags & MCIAVI_REVERSE) {
	ReverseWaveBuffer(npMCI, lpWaveHdr);
    }

    if (!PlaySomeAudio(npMCI, lpWaveHdr))
	return FALSE;

//  return TRUE;

    goto PlayMore;
}


#ifdef USENONINTFROMCD
/* Play the current chunk's audio */
BOOL NEAR PASCAL HandleAudioChunk(NPMCIGRAPHIC npMCI)
{
    LPWAVEHDR	lpWaveHdr;
    FOURCC	ckid;
    DWORD	cksize;
    BYTE _huge *lpData;
    BOOL	fRet = TRUE;
    BOOL	fSilence;
    DWORD	dwBytesTotal = 0L;
    DWORD       dwBytesThisChunk;
    DWORD       dwBytesThisBuffer;
    BOOL        fHurryUp;

    Assert(npMCI->wPlaybackAlg == MCIAVI_ALG_CDROM);

    while ((DWORD) (npMCI->lp - npMCI->lpBuffer)
            < npMCI->dwThisRecordSize - 3 * sizeof(DWORD)) {

	/* Look at the next chunk */
	ckid = GET_DWORD();
	cksize = GET_DWORD();

	lpData = npMCI->lp;
	SKIP_BYTES(cksize + (cksize & 1));

	fSilence = (TWOCCFromFOURCC(ckid) == cktypeWAVEsilence);

	if (fSilence) {
	    if (cksize != sizeof(DWORD)) {
		DPF(("Wave silence chunk of bad length!\n"));
		fRet = FALSE;
		npMCI->dwTaskError = MCIERR_INVALID_FILE;
		goto exit;
	    }
	    dwBytesThisChunk = PEEK_DWORD();
	} else {
	    dwBytesThisChunk = cksize;
	}

	while (dwBytesThisChunk > 0) {
	    lpWaveHdr = ((LPWAVEHDR)npMCI->lpAudio) + npMCI->wNextAB;

	    if (!WaitForFreeAudioBuffer(npMCI, &fHurryUp))
		/* We had to stop waiting--the stop flag was probably set. */
		goto exit;
	
	    dwBytesThisBuffer = min(dwBytesThisChunk,
			    npMCI->dwABSize - npMCI->dwUsedThisAB);

	    if (!fSilence) {
		/* Move the data into the buffer */
		hmemcpy((BYTE _huge *) lpWaveHdr->lpData + npMCI->dwUsedThisAB,
			lpData,
			dwBytesThisBuffer);
		lpData += dwBytesThisBuffer;
	    } else {
		/* Fill the buffer with silence */
		/* This isn't right for 16-bit! */
#ifndef _WIN32
    #pragma message("WAVE silence chunks don't work right now.")
#endif
	//      fmemfill((BYTE _huge *)lpWaveHdr->lpData + npMCI->dwUsedThisAB,
	//				dwBytesThisBuffer, 0x80);
	    }
	
	    dwBytesThisChunk -= dwBytesThisBuffer;
	    npMCI->dwUsedThisAB += dwBytesThisBuffer;

//	    if (npMCI->dwUsedThisAB == npMCI->dwABSize) {
		lpWaveHdr->dwBufferLength = npMCI->dwUsedThisAB;

		fRet = PlaySomeAudio(npMCI, lpWaveHdr);
//	    }
	}
    }

exit:
    return fRet;
}
#endif


/******************************************************************************
*****************************************************************************/


// We need to talk to a worker thread for another AVI device
extern DWORD mciaviTaskRequest(NPMCIGRAPHIC npMCI, UINT message,
				DWORD dwFlags, LPARAM lParam,
				DWORD dwCallback, BOOL bDelayedComplete);

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | StealWaveDevice | steal the audio device from another
 * instance of MCIAVI.
 *
 * @parm NPMCIGRAPHIC | npMCI | near ptr to the instance data
 *
 ***************************************************************************/

BOOL FAR PASCAL StealWaveDevice(NPMCIGRAPHIC npMCI)
{
#ifdef STEALWAVE
    NPMCIGRAPHIC np;
    Assert(npMCI->hWave == NULL);

#if defined(_WIN32) && defined(DEBUG)
    if (mmGetProfileInt(szIni, TEXT("NoStealing"), 0)) {
        return(FALSE);
    }
#endif

    DPF2(("StealWaveDevice '%ls' hTask=%04X\n", (LPSTR)npMCI->szFilename, npMCI->hTask));
#if 0
    if (npMCI->dwFlags & MCIAVI_SEEKING) {
	DPF0(("Do we really want to get a wave device for seeking?\n"));
    }
#endif
    EnterList();

    //
    //  walk the list of open MCIAVI instances and find one that
    //  could give up the wave device
    //
    for (np=npMCIList; np; np = np->npMCINext) {

        if (np->hWave) {
	    DWORD dwRetRequest;
            DPF2(("**** Stealing the wave device from '%ls'  (hTask=%4X).\n", (LPSTR)np->szFilename, np->hTask));

	    // Requesting the current wave device owner to release ownership.
	    // By sending the request directly to the worker thread we avoid
	    // some of the problems we might have if we had to talk to the
	    // winproc thread.  This operation is synchronous.  We do not
	    // want the request to complete until the wave device has been
	    // released.  If we sent to the window, then the winproc thread
	    // would have to send a synchronous request to its worker.  This
	    // is too tedious, and we do not have (at time of writing) the
	    // mechanisms for supporting this way of working.

	    LeaveList();
            dwRetRequest = mciaviTaskRequest(np, AVI_WAVESTEAL, 0, (LPARAM) 0, 0, FALSE);
	    if (dwRetRequest == 0) {
		return TRUE;
	    } else {
		return(FALSE);
	    }
        }
    }

    DPF2(("StealWaveDevice can't find a local device to steal\n"));
#ifdef REMOTESTEAL
    // Read the registry key of the task with the wave device.
    // If it fails we do not bother to try and
    // recover.  It only means that the sound will not follow the
    // active video
    {
	TCHAR achName[100];
	DWORD dwRet;
	DWORD dwType;
	HWND hwndRemote;
	DWORD cbData = sizeof(hwndRemote);

	lstrcpy(achName, KEYNAME);
	lstrcat(achName, szWaveOwner);

        if (hkey || (ERROR_SUCCESS == (dwRet = RegOpenKeyEx(ROOTKEY, achName,
			    0, KEY_ALL_ACCESS, &hkey)))) {

	    dwRet = RegQueryValueEx(hkey, szRemoteWaveHwnd, 0, &dwType,
			    (LPBYTE)&hwndRemote, &cbData);
	    if (dwRet == ERROR_SUCCESS) {
		DPF2(("Posting WM_AUDIO_OFF to hwnd %x\n", hwndRemote));
		PostMessage(hwndRemote, WM_AUDIO_OFF, (WPARAM)npMCI->hwndDefault, 0);
	    } else {
		// Could not read wave owner stuff from registry
	    }
	} else {
    	    // No wave owner stored in registry
	}
    }
#endif // REMOTESTEAL
    LeaveList();
#endif // STEALWAVE

    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | GiveWaveDevice | give away the audio device
 * instance of MCIAVI.
 *
 * @parm NPMCIGRAPHIC | npMCI | near ptr to the instance data
 *
 ***************************************************************************/
BOOL FAR PASCAL GiveWaveDevice(NPMCIGRAPHIC npMCI)
{
#ifdef STEALWAVE
    extern NPMCIGRAPHIC npMCIList; // in graphic.c
    NPMCIGRAPHIC np;

    Assert(npMCI->hWave == NULL);
    DPF2(("GiveWaveDevice '%ls' hTask=%04X\n", (LPTSTR)npMCI->szFilename, npMCI->hTask));

    if (hwndLostAudio) {
	BOOL fRet = FALSE;
	if (IsWindow(hwndLostAudio)) {
	    DPF3(("Posting AUDIO_ON message to %x\n", hwndLostAudio));
	    fRet = PostMessage(hwndLostAudio, WM_AUDIO_ON, 0, 0);
	} else {
	    DPF3(("Lost audio window %x is no longer valid\n", hwndLostAudio));
	}
	hwndLostAudio = 0;
	if (fRet) return TRUE;
    }

    EnterList();

    //
    //  walk the list of open MCIAVI instances and find one that
    //  wants a wave device.  Then hint to that task that it can
    //  try and grab the wave device back.
    //  MORE inter process stuff required.
    //
    for (np=npMCIList; np; np = np->npMCINext) {

        if ((np->dwFlags & MCIAVI_LOSTAUDIO)
            && (!TestNTFlags(npMCI, NTF_CLOSING))
           )
        {
            DPF2(("**** Giving wave device to '%ls'   hTask=%04X \n", (LPSTR)np->szFilename, np->hTask));

            Assert(np!=npMCI);

            LeaveList();

            mciaviTaskRequest(np, AVI_WAVERETURN, 0, (LPARAM) 0, 0, FALSE);
            return TRUE;
        }
    }

    LeaveList();
#endif // STEALWAVE
    return FALSE;
}



#ifndef _WIN32
#pragma alloc_text(FIX, mciaviWaveOutFunc)
#pragma optimize("", off)
#endif

void FAR PASCAL _LOADDS mciaviWaveOutFunc(HWAVEOUT hWaveOut, UINT wMsg,
		    DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    NPMCIGRAPHIC npMCI;
    LPWAVEHDR    lpwh;

#ifndef _WIN32
    _asm _emit 0x66  ; pushad
    _asm _emit 0x60
#endif

    npMCI = (NPMCIGRAPHIC) dwInstance;
    lpwh = (LPWAVEHDR) dwParam1;

    switch(wMsg) {
	case MM_WOM_DONE:
	
#ifdef _WIN32
	    InterlockedDecrement(&npMCI->wABFull);
#else
            npMCI->wABFull--;
#endif
            npMCI->dwAudioPlayed += lpwh->dwBufferLength;
#ifdef USE_PERFORMANCE_TIMING
	    GETTIME(npMCI->dwTimingStart);
#else
	    npMCI->dwTimingStart = timeGetTime();
#endif
	    break;
    }

#ifndef _WIN32
    _asm _emit 0x66  ; popad
    _asm _emit 0x61
#endif
}

#ifndef _WIN32
#pragma optimize("", off)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\aviread.c ===
/*************************************************************************
 * Copyright (C) Microsoft Corporation 1992. All rights reserved.
 *
 *************************************************************************/

/*
 * aviread.c: read blocks from the avi file (using worker thread).
 *	      Only built in WIN32 case.
 */

//#define AVIREAD
#ifdef AVIREAD

#include <windows.h>
#include <mmsystem.h>
#include <ntavi.h> 	// This must be included, for both versions

#include <string.h>     // needed for memmove in nt
#include <mmddk.h>
#include <memory.h>
#include "common.h"
#include "ntaviprt.h"
#include "aviread.h"
#include "aviffmt.h"
#include "graphic.h"


/*
 * overview of operation:
 *
 * creation of a avird object (via avird_startread) creates an avird_header
 * data structure and a worker thread. The data structure is protected by
 * a critical section, and contains two semaphores. the semEmpty semaphore is
 * initialised to the number of buffers allocated (normally 2), and the
 * semFull semaphore is initialised to 0 (there are initially no full buffers).
 *
 * The worker thread then loops waiting on semEmpty to get empty buffers,
 * and once it finds them, filling them and signalling via semFull that they
 * are ready. It fills them by callbacks to a AVIRD_FUNC function that
 * we were given a pointer to on object creation.
 *
 * Getting a buffer via avird_getnextbuffer waits on semFull until there
 * are full buffers, and returns the first on the list, after moving
 * it to the 'in use' list. The caller
 * will use/play the data in the buffer, and then call avird_emptybuffer:
 *  - this finds the buffer on the 'in use' list, moves it to the
 * 'empty' list and then signals the worker thread via
 * semEmpty.
 *
 * The worker thread checks the object state each time it is woken up. If this
 * state is 'closing' (bOK == FALSE), the thread frees all memory and exits.
 * avird_endread changes the object state and signals semEmpty to wake up the
 * worker thread.
 */


/*
 * each buffer is represented by one of these headers
 */
typedef struct avird_buffer {

    /*
     * size of the buffer in bytes
     */
    long	lSize;

    /* size of read data in bytes */
    long	lDataSize;


    /*
     * pointer to the next buffer in this state
     */
    struct avird_buffer * pNextBuffer;

    /* FALSE if buffer read failed */
    BOOL bOK;

    /* request sequence */
    int nSeq;

    /*
     * pointer to the actual block of buffer data
     */
    PBYTE	pData;
} AVIRD_BUFFER, * PAVIRD_BUFFER;



/* handles to HAVIRD are pointers to this data structure, but the
 * contents of the struct are known only within this module
 */
typedef struct avird_header {
    /*
     * always hold the critical section before checking/changing the
     * object state or any buffer state
     */
    CRITICAL_SECTION	critsec;

    /*
     * the count of this semaphore is the count of empty buffers
     * waiting to be picked up by the worker thread
     */
    HANDLE		semEmpty;

    /*
     * the count of this semaphore is the count of full buffers waiting
     * to be picked up by the caller.
     */
    HANDLE		semFull;

    /* object state - FALSE indicates close-down request. */
    BOOL		bOK;


    /* pointer to list of buffer headers ready to be filled */
    PAVIRD_BUFFER	pEmpty;

    /* pointer to a list of buffer headers in use by the client */
    PAVIRD_BUFFER	pInUse;

    /*
     * pointer to an ordered list of buffer headers ready to be
     * picked up by the client.
     */
    PAVIRD_BUFFER	pFull;

    /*
     * function to call to fill a buffer
     */
    AVIRD_FUNC		pFunc;

    /* instance arg to pass to pFunc() */
    DWORD		dwInstanceData;

    /* size of next buffer to be read */
    long		lNextSize;

    /* request sequence */
    int nNext;
    /* total in sequence */
    int nBlocks;


} AVIRD_HEADER, * PAVIRD_HEADER;


/* number of buffers to queue up */
#define MAX_Q_BUFS	4


/*
 * worker thread function
 */
DWORD avird_worker(LPVOID lpvThreadData);


/*
 * function to delete whole AVIRD_HEADER data structure.
 */
void avird_freeall(PAVIRD_HEADER phdr);

/*
 * start an avird operation and return a handle to use in subsequent
 * calls. This will cause an asynchronous read (achieved using a separate
 * thread) to start reading the next few buffers
 */
HAVIRD
avird_startread(AVIRD_FUNC func, DWORD dwInstanceData, long lFirstSize,
		int nFirst, int nBlocks)
{
    PAVIRD_HEADER phdr;
    PAVIRD_BUFFER pbuf;
    int i;
    HANDLE hThread;
    DWORD dwThreadId;
    int nBufferSize;

    /*
     * allocate and init the header
     */
    phdr = (PAVIRD_HEADER) LocalLock(LocalAlloc(LHND, sizeof(AVIRD_HEADER)));

    if (phdr == NULL) {
	return(NULL);
    }

    InitializeCriticalSection(&phdr->critsec);
    phdr->semEmpty = CreateSemaphore(NULL, MAX_Q_BUFS, MAX_Q_BUFS, NULL);
    phdr->semFull = CreateSemaphore(NULL, 0, MAX_Q_BUFS, NULL);
    phdr->bOK = TRUE;

    phdr->pInUse = NULL;
    phdr->pFull = NULL;
    phdr->pEmpty = NULL;

    phdr->pFunc = func;
    phdr->dwInstanceData = dwInstanceData;
    phdr->lNextSize = lFirstSize;
    phdr->nNext = nFirst;
    phdr->nBlocks = nBlocks;

    /*
     * round sizes up to 2k to reduce cost of small increases
     */
    nBufferSize = (lFirstSize + 2047) & ~2047;
    /*
     * allocate and init the buffers
     */
    for (i = 0; i < MAX_Q_BUFS; i++) {
	pbuf = (PAVIRD_BUFFER) LocalLock(LocalAlloc(LHND, sizeof(AVIRD_BUFFER)));

	pbuf->lSize = nBufferSize;
	pbuf->pData = (PBYTE) LocalLock(LocalAlloc(LHND, pbuf->lSize));

	pbuf->pNextBuffer = phdr->pEmpty;
	phdr->pEmpty = pbuf;
    }

    /*
     * create the worker thread
     */
    hThread = CreateThread(NULL, 0, avird_worker, (LPVOID)phdr, 0, &dwThreadId);
    if (hThread) {
	/* thread was created ok */
	CloseHandle(hThread);
	return( phdr);
    } else {
	avird_freeall(phdr);
	return(NULL);
    }
}

/*
 * return the next buffer from an HAVIRD object.
 */
PBYTE
avird_getnextbuffer(HAVIRD havird, long * plSize)
{
    PAVIRD_HEADER phdr = havird;
    PAVIRD_BUFFER pbuf;



    /* wait for a full buffer -report if actual wait needed*/
    if (WaitForSingleObject(phdr->semFull, 0) == WAIT_TIMEOUT) {
	DPF(("..waiting.."));
	WaitForSingleObject(phdr->semFull, INFINITE);
    }


    /* always hold critsec before messing with queues */
    EnterCriticalSection(&phdr->critsec);

    /* de-queue first full buffer and place on InUse queue */
    pbuf = phdr->pFull;
    phdr->pFull = pbuf->pNextBuffer;
    pbuf->pNextBuffer  = phdr->pInUse;
    phdr->pInUse = pbuf;

    /* finished with critical section */
    LeaveCriticalSection(&phdr->critsec);

    if (!pbuf->bOK) {
	/* buffer read failed */
	DPF(("reporting read failure on %d\n", pbuf->nSeq));
	if (plSize) {
	    *plSize = 0;
	}
    	return(NULL);
    }

    /* return size of buffer if requested */
    if (plSize) {
	*plSize = pbuf->lDataSize;
    }


    return(pbuf->pData);
}




/*
 * return to the queue a buffer that has been finished with (is now empty)
 *
 * causes the worker thread to be woken up and to start filling the buffer
 * again.
 */
void
avird_emptybuffer(HAVIRD havird, PBYTE pBuffer)
{
    PAVIRD_HEADER phdr = havird;
    PAVIRD_BUFFER pbuf, pprev;


    /* always get the critsec before messing with queues */
    EnterCriticalSection(&phdr->critsec);

    pprev = NULL;
    for (pbuf = phdr->pInUse; pbuf != NULL; pbuf = pbuf->pNextBuffer) {

	if (pbuf->pData == pBuffer) {

	    /* this is the buffer */
	    break;
	}
	pprev = pbuf;
    }

    if (pbuf != NULL) {
	 /* de-queue from InUse and place on empty q */
	if (pprev) {
	    pprev->pNextBuffer = pbuf->pNextBuffer;
	} else {
	    phdr->pInUse = pbuf->pNextBuffer;
	}
	pbuf->pNextBuffer = phdr->pEmpty;
	phdr->pEmpty = pbuf;

	/* mark as not validly read */
	pbuf->bOK = FALSE;

	/* signal that there is another buffer to fill */
    	ReleaseSemaphore(phdr->semEmpty, 1, NULL);
    } else {
	DPF(("buffer 0x%x not found on InUse list\n", pBuffer));
    }

    LeaveCriticalSection(&phdr->critsec);

}


/*
 * delete an avird object. the worker thread will be stopped and all
 * data allocated will be freed. The HAVIRD handle is no longer valid after
 * this call.
 */
void
avird_endread(HAVIRD havird)
{
    PAVIRD_HEADER phdr = havird;

    DPF(("killing an avird object\n"));

    /* get the critsec before messing with states */
    EnterCriticalSection(&phdr->critsec);

    /* tell the worker thread to do all the work */
    phdr->bOK = FALSE;

    /* wake up the worker thread */
    ReleaseSemaphore(phdr->semEmpty, 1, NULL);

    /*
     * we must hold the critsec past the semaphore signal: if we
     * release the critsec first, the worker thread might see the
     * state change before we have signalled the semaphore. He would
     * then potentially have destroyed the semaphore AND freed the
     * AVIRD_HEADER structure by the time we tried to signal the
     * semaphore. This way, we are sure that until we release the
     * critsec, everything is still valid
     */

    LeaveCriticalSection(&phdr->critsec);

    /* all done - phdr now may not exist */
}

/*
 * worker thread function.
 *
 * loop waiting for semEmpty to tell us there are empty buffers. When
 * we see one, fill it with phdr->pFunc and move it to the
 * full queue. Each time we are woken up, check the state. If it
 * changes to false, delete the whole thing and exit.
 *
 * the argument we are passed is the PAVIRD_HEADER.
 */

DWORD
avird_worker(LPVOID lpvThreadData)
{
    PAVIRD_HEADER phdr = (PAVIRD_HEADER) lpvThreadData;
    PAVIRD_BUFFER pbuf, pprev;
    long lNextSize;
    HANDLE hmem;

    DPF(("Worker %d started\n", GetCurrentThreadId()));

    for (; ;) {

	/* wait for an empty buffer (or state change) */
	WaitForSingleObject(phdr->semEmpty, INFINITE);


	/* get the critical section before touching the state, queues */
	EnterCriticalSection(&phdr->critsec);

	if (phdr->bOK == FALSE) {
	    /* all over bar the shouting */
	    DPF(("%d exiting\n", GetCurrentThreadId()));
	    avird_freeall(phdr);
	    ExitThread(0);
	}


	/* dequeue the first empty buffer */
	pbuf = phdr->pEmpty;

	Assert(pbuf != NULL);

	phdr->pEmpty = pbuf->pNextBuffer;

	lNextSize = phdr->lNextSize;

	pbuf->nSeq = phdr->nNext++;

	if (pbuf->nSeq < phdr->nBlocks) {
	    /* we can now release the critsec until we need to re-Q the filled buf*/
	    LeaveCriticalSection(&phdr->critsec);

	    /* resize the buffer if not big enough */
	    if (pbuf->lSize < lNextSize) {

		hmem = LocalHandle(pbuf->pData);
		LocalUnlock(hmem);
		LocalFree(hmem);

		pbuf->lSize = ((lNextSize + 2047) & ~2047);
		pbuf->pData = LocalLock(LocalAlloc(LHND, pbuf->lSize));
	    }

	    /* record the data content of the buffer */
	    pbuf->lDataSize = lNextSize;
	
	    /* call the filler function */
	    if ((*phdr->pFunc)(pbuf->pData, phdr->dwInstanceData, lNextSize,
			    &lNextSize)) {
		pbuf->bOK = TRUE;
	    } else {
		DPF(("filler reported failure on %d\n", pbuf->nSeq));
	    }

	    /* get the critsec before messing with q's or states */
	    EnterCriticalSection(&phdr->critsec);

	    /* size for next read */
	    phdr->lNextSize = lNextSize;
    	}

	/* place buffer at end of Full queue */
	if (phdr->pFull == NULL) {
	    phdr->pFull = pbuf;
	} else {
	    for (pprev = phdr->pFull; pprev->pNextBuffer != NULL; ) {
		pprev = pprev->pNextBuffer;
	    }
	    pprev->pNextBuffer = pbuf;
	}
	pbuf->pNextBuffer = NULL;

	LeaveCriticalSection(&phdr->critsec);

	/* signal calling thread that there's another buffer for him  */
	ReleaseSemaphore(phdr->semFull, 1, NULL);
    }
    /* silence compiler */
    return (0);
}

/*
 * free one buffer and buffer header
 */
void
avird_freebuffer(PAVIRD_BUFFER pbuf)
{
    HANDLE hmem;

    hmem = LocalHandle( (PSTR)pbuf->pData);
    LocalUnlock(hmem);
    LocalFree(hmem);

    hmem = LocalHandle( (PSTR)pbuf);
    LocalUnlock(hmem);
    LocalFree(hmem);
}


/*
 * function to delete whole AVIRD_HEADER data structure.
 *
 * called on calling thread if start-up fails, or on worker thread if
 * asked to shutdown.
 */
void
avird_freeall(PAVIRD_HEADER phdr)
{
    PAVIRD_BUFFER pbuf, pnext;
    HANDLE hmem;

    if (phdr->semEmpty) {
	CloseHandle(phdr->semEmpty);
    }

    if (phdr->semEmpty) {
	CloseHandle(phdr->semFull);
    }

    DeleteCriticalSection(&phdr->critsec);


    for (pbuf = phdr->pInUse; pbuf != NULL; pbuf = pnext) {
	DPF(("In Use buffers at EndRead\n"));

	pnext = pbuf->pNextBuffer;
	avird_freebuffer(pbuf);
    }

    for (pbuf = phdr->pEmpty; pbuf != NULL; pbuf = pnext) {
	pnext = pbuf->pNextBuffer;
	avird_freebuffer(pbuf);
    }

    for (pbuf = phdr->pFull; pbuf != NULL; pbuf = pnext) {
	pnext = pbuf->pNextBuffer;
	avird_freebuffer(pbuf);
    }


    hmem = LocalHandle((PSTR) phdr);
    LocalUnlock(hmem);
    LocalFree(hmem);
}

#endif //AVIREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\aviopen.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   aviopen.c - open a AVI file

*****************************************************************************/
#include "graphic.h"
#ifdef _WIN32
#include <wchar.h>
#endif

#ifdef USEAVIFILE
    #include <initguid.h>
    #include <scode.h>

    DEFINE_AVIGUID(IID_IAVIFile,            0x00020020, 0, 0);
    DEFINE_AVIGUID(IID_IAVIStream,          0x00020021, 0, 0);
#endif

#define comptypeNONE mmioFOURCC('N','O','N','E')

//
//  special error to force using AVIFile to try and open this file.
//
#define AVIERR_NOT_AVIFILE  4242

//
//  if this is defined we will always use AVIFILE.DLL, except for
//  1:1 interleaved files.
//
#ifdef USEAVIFILE
#define USE_AVIFILE_FOR_NON_INT
#endif

#ifdef _WIN32
BOOL runningInWow = 0; // Assume we are not in WOW
#endif


/***************************************************************************
 * Local function declarations
 ***************************************************************************/

STATICFN BOOL NEAR PASCAL InitStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi);
STATICFN BOOL NEAR PASCAL InitVideoStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi);
STATICFN BOOL NEAR PASCAL InitAudioStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi);
STATICFN BOOL NEAR PASCAL InitOtherStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi);
STATICFN void NEAR PASCAL CloseStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi);


STATICFN BOOL NEAR PASCAL ParseNewHeader(NPMCIGRAPHIC npMCI);

STATICFN BOOL NEAR PASCAL OpenRiffAVIFile(NPMCIGRAPHIC npMCI, BOOL bForce);
STATICFN BOOL NEAR PASCAL OpenWithAVIFile(NPMCIGRAPHIC npMCI);
STATICFN BOOL NEAR PASCAL OpenInterface(NPMCIGRAPHIC npMCI);
#ifdef USEAVIFILE
STATICFN BOOL NEAR PASCAL OpenAVIFile(NPMCIGRAPHIC npMCI, IAVIFile FAR *pf);
STATICFN BOOL NEAR PASCAL OpenAVIStream(NPMCIGRAPHIC npMCI, int stream, IAVIStream FAR *pf);
#endif

INLINE static BOOL NEAR PASCAL IsRectBogus(RECT *prc);
#ifndef _WIN32
static LONG NEAR PASCAL atol(char *sz);
#endif // !_WIN32

#ifdef _WIN32XXXX
    #define GetFileDriveType GetDriveType
#else
    static  UINT NEAR PASCAL GetFileDriveType(LPTSTR szPath);
#endif


#ifndef _WIN32
SZCODE szOLENLSDLL[] = "OLE2NLS.DLL";
SZCODE szOLENLSAPI[] = "GetUserDefaultLangID";
#endif

//
// due to OLE, all ole calls must be single-threaded and thus on
// the app thread. so we moved the Open call to the app thread



//
// -- called on app thread -------------------------------------------------
//

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | mciaviOpenFile | Open an AVI file.
 *      the filename we are to open is passed to npMCI->szFileName.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

BOOL FAR PASCAL mciaviOpenFile(NPMCIGRAPHIC npMCI)
{
    //
    // mciaviOpenFile should not be called with a file open!
    //
    DPF(("mciaviOpenFile, name = >>%ls<<\n", npMCI->szFilename));
    Assert(npMCI->streams == 0);
    Assert(npMCI->hmmio == NULL);
    Assert(npMCI->hpIndex == NULL);
    Assert(!(npMCI->dwFlags & (
			MCIAVI_NOTINTERLEAVED |
			MCIAVI_ANIMATEPALETTE |
			MCIAVI_CANDRAW |
			MCIAVI_HASINDEX)));
    //
    //  !!!support open new
    //
    if (npMCI->szFilename[0] == '\0') {
    }

    //
    // what media is this file coming from, will be important later
    // when we play.
    //
    if (npMCI->szFilename[0] == TEXT('@')) {
	npMCI->uDriveType = DRIVE_INTERFACE;
	if (IsNTWOW()) {
	    DPF2(("Rejecting open from WOW because of an interface pointer\n"));
	    npMCI->dwTaskError=MCIERR_UNSUPPORTED_FUNCTION;
	    return(FALSE);
	    // Cannot support a 16 bit interface pointer from 32 bit code
	}
    }
    else
	npMCI->uDriveType = GetFileDriveType(npMCI->szFilename);

#ifdef DEBUG
    switch (npMCI->uDriveType) {
	case DRIVE_CDROM:
	    DOUT2("Media is a CD-ROM\n");
	    break;

	case DRIVE_REMOTE:
	    DOUT2("Media is a Network\n");
	    break;

	case DRIVE_FIXED:
	    DOUT2("Media is a Hard disk\n");
	    break;

	case DRIVE_REMOVABLE:
	    DOUT2("Media is a floppy disk\n");
	    break;

	case DRIVE_INTERFACE:
	    DOUT2("Media is OLE COM Interface\n");
	    break;

	default:
	    DPF(("Unknown Media type %d\n", npMCI->uDriveType));
	    break;
    }
#endif

#ifdef USEAVIFILE
    //
    // if the "filename" is of the form: '@########' then we assume we
    // have been pased a interface pointer of some sort.
    //
    if (npMCI->szFilename[0] == TEXT('@') &&
	OpenInterface(npMCI))
	goto DoneOpening;

    // !!! This will open even AVI files this way!
    if ((npMCI->dwOptionFlags & MCIAVIO_USEAVIFILE) &&
	OpenWithAVIFile(npMCI))
	goto DoneOpening;
#endif

    if (!OpenRiffAVIFile(npMCI, FALSE)) {


#ifdef USEAVIFILE
	//
	//  unable to open RIFF file, if it was because it was
	//  not a AVI file, then give AVIFile a try.
	//
	if (npMCI->dwTaskError == AVIERR_NOT_AVIFILE) {

	    npMCI->dwTaskError = 0;

	    if (OpenWithAVIFile(npMCI))
		goto DoneOpening;

	    // if this is a riff file that we could open but chose
	    // to pass to avifile, and avifile is not present, then we need
	    // to pass it back to OpenRiffAVIFile and force it to try
	    // and open it properly.

	    npMCI->dwTaskError = 0;
	    if (OpenRiffAVIFile(npMCI, TRUE))
		goto DoneOpening;

	    if (npMCI->dwTaskError == AVIERR_NOT_AVIFILE) {
		npMCI->dwTaskError = MCIERR_INVALID_FILE;
		// We cannot return an AVI specific error as there is
		// no way for the UI to get access to the error text.
		// Hence we use a generic mci error.
	    }
	}
#endif
	goto error;
    }

DoneOpening:
    npMCI->dwTaskError = 0;
    return TRUE;

error:
    mciaviCloseFile(npMCI);

    if (npMCI->dwTaskError == 0)
	npMCI->dwTaskError = MCIERR_INVALID_FILE;

    return FALSE;
}

#ifdef USEAVIFILE

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | OpenWithAVIFile | Open an file using AVIFile
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

STATICFN BOOL NEAR PASCAL OpenWithAVIFile(NPMCIGRAPHIC npMCI)
{
    IAVIFile FAR *pf = NULL;

    if (!InitAVIFile(npMCI))
	return FALSE;

    AVIFileOpen(&pf, npMCI->szFilename, MMIO_READ, 0);

    if (pf == NULL) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
	return FALSE;
    }

    if (!OpenAVIFile(npMCI, pf)) {
	mciaviCloseFile(npMCI);
	pf->lpVtbl->Release(pf);
	return FALSE;
    }

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | OpenInterface | Open an interface pointer
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

STATICFN BOOL NEAR PASCAL OpenInterface(NPMCIGRAPHIC npMCI)
{
    IUnknown FAR *p;
    IAVIFile FAR *pf=NULL;
    IAVIStream FAR *ps=NULL;

    if (!InitAVIFile(npMCI))
	return FALSE;

    if (npMCI->szFilename[0] != TEXT('@')) {
	DPF1(("Failing to open interface for file %ls\n",npMCI->szFilename));
	return FALSE;
    }

#ifdef UNICODE
    p = (IUnknown FAR *)wcstol(npMCI->szFilename+1, NULL, 10);
#else
    p = (IUnknown FAR *)atol(npMCI->szFilename+1);
#endif

#ifdef USE_ISVALIDINTERFACE
    if (!IsValidInterface(p))
	return FALSE;
#endif

#ifndef _WIN32
    //!!!we need to do the PSP stuff? or will the TASK stuff in
    //!!!COMPOBJ mess us up?
    {
    extern void FAR SetPSP(UINT psp);
    SetPSP(npMCI->pspParent);
    }
#endif

    p->lpVtbl->QueryInterface(p, &IID_IAVIFile, (LPVOID FAR *)&pf);

    if (pf != NULL)
    {
	if (OpenAVIFile(npMCI, pf))
	    return TRUE;

	pf->lpVtbl->Release(pf);
	pf = NULL;  // AVIMakeFileFromStreams need not set pf to NULL
    }

    p->lpVtbl->QueryInterface(p, &IID_IAVIStream, (LPVOID FAR *)&ps);

    if (ps != NULL)
    {
	AVIMakeFileFromStreams(&pf, 1, &ps);
	ps->lpVtbl->Release(ps);

	if (pf == NULL)
	    return FALSE;

	if (OpenAVIFile(npMCI, pf))
	    return TRUE;

	pf->lpVtbl->Release(pf);
	//return FALSE;
    }

    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | OpenAVIFile | Open an a AVIFile object
 *
 *  NOTE we do not do call AddRef() we assume we dont need to.
 *       neither do we Release().  If we fail, our caller will Release(),
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *        On a successful return npMCI->pf will be loaded with the
 *        input IAVIFILE interface pointer.
 *
 ***************************************************************************/

STATICFN BOOL NEAR PASCAL OpenAVIFile(NPMCIGRAPHIC npMCI, IAVIFile FAR *pf)
{
    AVIFILEINFOW info;
    HRESULT hr;
    IAVIStream FAR *ps;
    STREAMINFO *psi;
    int i;

    Assert(npMCI->pf == NULL);

    _fmemset(&info, 0, sizeof(info));
    hr = pf->lpVtbl->Info(pf, &info, sizeof(info));

    if (FAILED(GetScode(hr))) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
	return FALSE;
    }

    DPF1(("OpenAVIFile: %ls\n\t#Streams=%d,  Width=%d    Height=%d\n",
	    info.szFileType, info.dwStreams, info.dwWidth, info.dwHeight));

    //
    // get rid of bad files
    //
    if (info.dwStreams == 0 || info.dwStreams > 255 || info.dwLength == 0) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
	return FALSE;
    }

    //
    // save the interface pointer
    // make a copy of the VTable, for later use
    //
    npMCI->pf = pf;
////npMCI->vt = *pf->lpVtbl;

    npMCI->dwFlags |= MCIAVI_HASINDEX;

    npMCI->dwMicroSecPerFrame = muldiv32(info.dwScale, 1000000, info.dwRate);

    npMCI->lFrames  = (LONG)info.dwLength;
    npMCI->dwRate   = info.dwRate;
    npMCI->dwScale  = info.dwScale;

    npMCI->streams  = (int)info.dwStreams;

    npMCI->dwBytesPerSec = info.dwMaxBytesPerSec;
    npMCI->dwSuggestedBufferSize = info.dwSuggestedBufferSize + 2*sizeof(DWORD);

    SetRect(&npMCI->rcMovie,0,0,(int)info.dwWidth,(int)info.dwHeight);

    npMCI->paStreamInfo = (STREAMINFO*)
	LocalAlloc(LPTR,npMCI->streams * sizeof(STREAMINFO));

    if (npMCI->paStreamInfo == NULL) {
	npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
	npMCI->pf = NULL;
	return FALSE;
    }

    for (i = 0; i < npMCI->streams; i++) {

	ps = NULL;
	AVIFileGetStream(pf, &ps, 0, i);

	if (ps == NULL) {
	    npMCI->dwTaskError = MCIERR_INVALID_FILE;
	    npMCI->pf = NULL;
	    return FALSE;
	}

	if (!OpenAVIStream(npMCI, i, ps))
	    DPF(("Error opening stream %d!\n", i));

	if (npMCI->dwTaskError) {
	    npMCI->pf = NULL;
	    ps->lpVtbl->Release(ps);
	    return FALSE;
	}
    }

    //
    // compute the key frames every value
    //
    // do this by finding the key frame average over the first few frames.
    //
    #define NFRAMES 250

    if (psi = npMCI->psiVideo) {
	LONG l;
	int nKeyFrames=0;
	int nFrames = (int) min(npMCI->lFrames, NFRAMES);

	for (l=0; l<nFrames; l++) {
	    if (AVIStreamFindSample(psi->ps, psi->sh.dwStart+l, FIND_PREV|FIND_KEY) == l)
		nKeyFrames++;
	}

	if (nKeyFrames > 1)
	    npMCI->dwKeyFrameInfo = (DWORD)((nFrames + nKeyFrames/2)/nKeyFrames);
	else
	    npMCI->dwKeyFrameInfo = 0;
    }

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | OpenAVIStream | Open an a AVIStream object
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

STATICFN BOOL NEAR PASCAL OpenAVIStream(NPMCIGRAPHIC npMCI, int stream, IAVIStream FAR *ps)
{
    STREAMINFO* psi;
    AVISTREAMINFOW info;
    HRESULT hr;

    _fmemset(&info, 0, sizeof(info));
    hr = ps->lpVtbl->Info(ps, &info, sizeof(info));

    if (FAILED(GetScode(hr))) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
	return FALSE;
    }

    DPF(("OpenAVIStream(%d) %4.4hs:%4.4hs %ls\n", stream, (LPSTR)&info.fccType, (LPSTR)&info.fccHandler, info.szName));

    //
    // init the STREAMINFO from the IAVIStream
    //
    psi = SI(stream);

    psi->ps = ps;           // save interface
////psi->vt = *ps->lpVtbl;  // save VTable   !!!needed?

    psi->sh.fccType                 = info.fccType;
    psi->sh.fccHandler              = info.fccHandler;
    psi->sh.dwFlags                 = info.dwFlags;
    psi->sh.wPriority               = info.wPriority;
    psi->sh.wLanguage               = info.wLanguage;
    psi->sh.dwInitialFrames         = 0; // info.dwInitialFrames;
    psi->sh.dwScale                 = info.dwScale;
    psi->sh.dwRate                  = info.dwRate;
    psi->sh.dwStart                 = info.dwStart;
    psi->sh.dwLength                = info.dwLength;
    psi->sh.dwSuggestedBufferSize   = info.dwSuggestedBufferSize;
    psi->sh.dwQuality               = info.dwQuality;
    psi->sh.dwSampleSize            = info.dwSampleSize;
    psi->sh.rcFrame                 = info.rcFrame;

    //
    // get the format of the stream.
    //
    AVIStreamFormatSize(ps, 0, &psi->cbFormat);
    psi->lpFormat = GlobalAllocPtr(GMEM_MOVEABLE, psi->cbFormat);

    if (!psi->lpFormat) {
	npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
	return FALSE;
    }

    AVIStreamReadFormat(psi->ps, 0, psi->lpFormat, &psi->cbFormat);

    //
    // get the extra data for the stream.
    //
    AVIStreamReadData(psi->ps,ckidSTREAMHANDLERDATA, NULL, &psi->cbData);

    if (psi->cbData > 0) {
	psi->lpData = GlobalAllocPtr(GMEM_MOVEABLE, psi->cbData);

	if (!psi->lpData) {
	    npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
	    return FALSE;
	}

	AVIStreamReadData(psi->ps, ckidSTREAMHANDLERDATA, NULL, &psi->cbData);
    }

    return InitStream(npMCI, psi);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | InitAVIFile | called to RTL to AVIFILE.DLL
 *
 * @rdesc TRUE means OK, otherwise error
 *
 ***************************************************************************/

#ifdef _WIN32
    SZCODE szAVIFILE[] = TEXT("AVIFIL32.DLL");

#ifdef USE_ISVALIDINTERFACE
    SZCODE szCOMPOBJ[] = TEXT("COMPOB32");
#endif
#else
    SZCODE szAVIFILE[] = "AVIFILE.DLL";
#ifdef USE_ISVALIDINTERFACE
    SZCODE szCOMPOBJ[] = "COMPOBJ";
#endif
#endif

// On NT the entry points will NOT be unicode strings, as there is
// no unicode version of GetProcAddress.  BUT SZCODE generate UNICODE...

// on the other hand, the entry points will all be unicode entrypoints 'W'

#ifdef UNICODE
#define UNICODE_APPEND "W"
#else
#define UNICODE_APPEND
#endif

SZCODEA szAVIFileInit[]      = "AVIFileInit";
SZCODEA szAVIFileExit[]      = "AVIFileExit";

#ifdef USE_ISVALIDINTERFACE
SZCODEA szIsValidInterface[] = "IsValidInterface";
#endif

SZCODEA szAVIMakeFileFromStreams[] = "AVIMakeFileFromStreams";
SZCODEA szAVIStreamBeginStreaming[] = "AVIStreamBeginStreaming";
SZCODEA szAVIStreamEndStreaming[] = "AVIStreamEndStreaming";
SZCODEA szAVIFileOpen[]      = "AVIFileOpen" UNICODE_APPEND;

BOOL FAR InitAVIFile(NPMCIGRAPHIC npMCI)
{
    UINT u;

    if (hdllAVIFILE == (HMODULE)-1)
	// We have already tried to load AVIFILE and failed
	return FALSE;

    if (hdllAVIFILE == NULL) {

	u = SetErrorMode(SEM_NOOPENFILEERRORBOX);
#ifdef _WIN32
	// The load and free of szAVIFILE is safe as it is protected by
	// the npMCI device critical section.  This means that open/close
	// events will be synchronised.
#endif
	hdllAVIFILE = LoadLibrary(szAVIFILE);
	SetErrorMode(u);

#ifndef _WIN32
	if ((UINT)hdllAVIFILE <= (UINT)HINSTANCE_ERROR)
	    hdllAVIFILE = NULL;
#endif

	if (hdllAVIFILE == NULL) {
	    hdllAVIFILE = (HMODULE)-1;
	    DPF(("Failed to load AVIFILE dll - error %d\n", GetLastError()));
	    return FALSE;
	}

#ifdef USE_ISVALIDINTERFACE
	hdllCOMPOBJ = GetModuleHandle(szCOMPOBJ);
	Assert(hdllCOMPOBJ != NULL);

	(FARPROC)XIsValidInterface = GetProcAddress(hdllCOMPOBJ, szIsValidInterface);

	Assert(XIsValidInterface != NULL);
#endif

	(FARPROC)XAVIFileInit = GetProcAddress(hdllAVIFILE, szAVIFileInit);
	(FARPROC)XAVIFileExit = GetProcAddress(hdllAVIFILE, szAVIFileExit);
	(FARPROC)XAVIFileOpen = GetProcAddress(hdllAVIFILE, szAVIFileOpen);
	(FARPROC)XAVIMakeFileFromStreams = GetProcAddress(hdllAVIFILE, szAVIMakeFileFromStreams);
	(FARPROC)XAVIStreamBeginStreaming = GetProcAddress(hdllAVIFILE, szAVIStreamBeginStreaming);
	(FARPROC)XAVIStreamEndStreaming = GetProcAddress(hdllAVIFILE, szAVIStreamEndStreaming);

	Assert(XAVIFileInit != NULL);
	Assert(XAVIFileExit != NULL);
	Assert(XAVIFileOpen != NULL);
	Assert(XAVIMakeFileFromStreams != NULL);
    }

    //
    // we need to call AVIFileInit() and AVIFileExit() for each task that
    // is using AVIFile or things will not work right.
    //
    if (!(npMCI->dwFlags & MCIAVI_USING_AVIFILE)) {

	npMCI->dwFlags |= MCIAVI_USING_AVIFILE;

	AVIFileInit();     // Should we check the return code?
	uAVIFILE++;
    }

    return TRUE;
}

// must be called from app thread too!

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | FreeAVIFile | called to un-RTL to AVIFILE.DLL
 *
 * @rdesc TRUE means OK, otherwise error
 *
 ***************************************************************************/

BOOL FAR FreeAVIFile(NPMCIGRAPHIC npMCI)
{
    if (!(npMCI->dwFlags & MCIAVI_USING_AVIFILE))
	return FALSE;

    Assert(hdllAVIFILE != (HMODULE)-1 && hdllAVIFILE != NULL);

    // free this tasks use of AVIFile
    AVIFileExit();

    // if no more people using AVIFile let the DLLs go.
    Assert(uAVIFILE > 0);
    uAVIFILE--;

    if (uAVIFILE == 0) {
	FreeLibrary(hdllAVIFILE);
	hdllAVIFILE = NULL;
#ifdef USE_ISVALIDINTERFACE
	hdllCOMPOBJ = NULL;
#endif
    }

    return TRUE;
}

#endif /* USEAVIFILE */

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | OpenRiffAVIFile | Open an RIFF AVI file
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm BOOL | bForce | if FALSE, return error for files that
 * we think should be opened by AVIFILE instead.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

STATICFN BOOL NEAR PASCAL OpenRiffAVIFile(NPMCIGRAPHIC npMCI, BOOL bForce)
{
    HMMIO               hmmio;
    HANDLE              h = NULL;
    BOOL                fRet = TRUE;
    MMIOINFO            mmioInfo;
    MMCKINFO            ckRIFF;
    MMCKINFO            ckLIST;
    MMCKINFO            ckRECORD;

    _fmemset(&mmioInfo, 0, sizeof(MMIOINFO));
    mmioInfo.htask = (HANDLE)npMCI->hCallingTask;

    hmmio = mmioOpen(npMCI->szFilename, &mmioInfo, MMIO_READ | MMIO_DENYWRITE);

    if (hmmio == NULL)
	hmmio = mmioOpen(npMCI->szFilename, &mmioInfo, MMIO_READ);

    if (!hmmio) {
	switch (mmioInfo.wErrorRet) {
	    case MMIOERR_OUTOFMEMORY:
		npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
		break;
	    case MMIOERR_FILENOTFOUND:
	    case MMIOERR_CANNOTOPEN:
	    default:
		npMCI->dwTaskError = MCIERR_FILE_NOT_FOUND;
		break;
	}
	fRet = FALSE;
	goto exit;
    }

    npMCI->hmmio = hmmio;

    /*
    ** Descend into RIFF file
    */
    if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0) {
	goto ERROR_BADFILE;
    }

    /*
     * check for a 'QuickTime AVI' file, a QuickTime AVI file is a
     * QuickTime public movie with a AVI file in the 'mdat' atom.
     */
    if (ckRIFF.cksize == mmioFOURCC('m','d','a','t'))
    {
	DPF(("File is a QuickTime public movie\n"));

	/*
	 * now the 'mdat' atom better be a RIFF/AVI or we cant handle it.
	 */
	if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0) {
	    goto ERROR_BADFILE;
	}
    }

    /* Make sure it's a RIFF file */
    if (ckRIFF.ckid != FOURCC_RIFF) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
	goto ERROR_NOT_AVIFILE;
    }

    /* Otherwise, it should be an AVI file */
    if (ckRIFF.fccType != formtypeAVI) {
	npMCI->dwTaskError = MCIERR_INVALID_FILE;
	goto ERROR_NOT_AVIFILE;
    }

    /*
    ** Descend into header LIST
    */
    ckLIST.fccType = listtypeAVIHEADER;
    if (mmioDescend(hmmio, &ckLIST, &ckRIFF, MMIO_FINDLIST) != 0) {
	goto ERROR_BADFILE;
    }

    /* Leave space at end of buffer for pad word */
    h = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, ckLIST.cksize -
				    sizeof(DWORD) +
				    sizeof(DWORD));

    if (!h) {
	npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
	return FALSE;
    }

    npMCI->lp = npMCI->lpBuffer = (LPSTR) GlobalLock(h);

    DPF(("Reading header list: %lu bytes.\n", ckLIST.cksize - sizeof(DWORD)));

    if (mmioRead(hmmio, npMCI->lp, ckLIST.cksize - sizeof(DWORD))
			    != (LONG) (ckLIST.cksize - sizeof(DWORD))) {
	npMCI->dwTaskError = MCIERR_FILE_READ;
	goto ERROR_RETURN;
    }

#ifdef USE_AVIFILE_FOR_NON_INT
    //
    //  we check here for AVI RIFF files we dont want to handle with our
    //  built in code, and want to pass on to AVIFILE.DLL
    //
    //  we handle the following files:
    //
    //      interleaved
    //
    //  we pass on the following files to AVIFILE.DLL
    //
    //      non-interleaved
    //
    //  pretty simple right now, just interleaved non-interlaved
    //  but could get as complex as you want.
    //
    // if there is a problem with avifile (eg dll not present) we will
    // be called with bForce TRUE: this means we should open it if at
    // all possible
    //
    if (!bForce) {
	MainAVIHeader FAR * lpHdr;

	lpHdr = (MainAVIHeader FAR *)((BYTE FAR *)npMCI->lp + 8);

	if (!(lpHdr->dwFlags & AVIF_ISINTERLEAVED) ||
	    lpHdr->dwInitialFrames == 0) {

	    DOUT("File is not interleaved, giving it to AVIFILE.DLL\n");
	    goto ERROR_NOT_AVIFILE;
	}

	//
	// ok now we have a 1:1 interleved file.
	//
	// always use our code on a CD-ROM, but on other media...
	//
	switch (npMCI->uDriveType) {
	    case DRIVE_CDROM:
		break;

	    case DRIVE_REMOTE:
	    case DRIVE_FIXED:
	    case DRIVE_REMOVABLE:
		break;

	    default:
		break;
	}
    }
#endif

    if (PEEK_DWORD() == ckidAVIMAINHDR) {
	if (!ParseNewHeader(npMCI))
	    goto ERROR_RETURN;
    } else {
	goto ERROR_BADFILE;
    }

    /* Ascend out of header LIST */
    if (mmioAscend(hmmio, &ckLIST, 0) != 0) {
	npMCI->dwTaskError = MCIERR_FILE_READ;
	goto ERROR_RETURN;
    }

    /* Initially, no frame has been drawn */
    npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;

    /*
    ** Descend into big 'Movie LIST'
    */
    ckLIST.fccType = listtypeAVIMOVIE;
    if (mmioDescend(hmmio, &ckLIST, &ckRIFF, MMIO_FINDLIST) != 0) {
	goto ERROR_BADFILE;
    }

    npMCI->dwMovieListOffset = ckLIST.dwDataOffset;

    /* Calculate end of 'movi' list, in case we need to read the index */
    npMCI->dwBigListEnd = ckLIST.dwDataOffset + ckLIST.cksize +
				(ckLIST.cksize & 1);

    /*
    ** Descend into header of first chunk
    */
    if (mmioDescend(hmmio, &ckRECORD, &ckLIST, 0) != 0) {
	goto ERROR_BADFILE;
    }
    npMCI->dwFirstRecordType = ckRECORD.ckid;
    npMCI->dwFirstRecordSize = ckRECORD.cksize + 2 * sizeof(DWORD);
    npMCI->dwFirstRecordPosition = mmioSeek(hmmio, 0, SEEK_CUR);

    if (mmioAscend(hmmio, &ckRECORD, 0) != 0) {
	npMCI->dwTaskError = MCIERR_FILE_READ;
	goto ERROR_RETURN;
    }

#ifdef DEBUG
    DPF2(("First record (%4.4s) 0x%lx bytes at position 0x%lx.\n",
		(LPSTR)&npMCI->dwFirstRecordType,
		npMCI->dwFirstRecordSize,
		npMCI->dwFirstRecordPosition));

    if (npMCI->dwFirstRecordPosition & 0x7ff) {
	DPF(("!!\n"));
	DPF(("!!  This file is not properly aligned to a 2K boundary.\n"));
	DPF(("!!  It may not play well from CD-ROM.\n"));
	DPF(("!!\n"));
    }
#endif

exit:
    if (!fRet)
	mciaviCloseFile(npMCI);

    if (h) {
	npMCI->lpBuffer = NULL;
	npMCI->dwBufferSize = 0L;
	GlobalUnlock(h);
	GlobalFree(h);
    }

    return fRet;

ERROR_NOT_AVIFILE:
#ifdef USEAVIFILE
    npMCI->dwTaskError = AVIERR_NOT_AVIFILE;  // mark as not a AVI file
    goto ERROR_RETURN;                        // we will be called a second time
#endif

ERROR_BADFILE:
    npMCI->dwTaskError = MCIERR_INVALID_FILE; // something wrong with the file

ERROR_RETURN:
    fRet = FALSE;
    goto exit;
}

/***************************************************************************
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | ParseNewHeader | 'nuf said
 *
 ***************************************************************************/

STATICFN BOOL NEAR PASCAL ParseNewHeader(NPMCIGRAPHIC npMCI)
{
    DWORD               dwHeaderSize;
    MainAVIHeader FAR * lpHdr;
    int                 stream;

    if (GET_DWORD() != ckidAVIMAINHDR) {
	goto FileError;
    }

    dwHeaderSize = GET_DWORD(); /* Skip size */

    /* Now, we're pointing at the actual header */
    lpHdr = (MainAVIHeader FAR *) npMCI->lp;

    npMCI->lFrames = (LONG)lpHdr->dwTotalFrames;
    npMCI->dwMicroSecPerFrame = lpHdr->dwMicroSecPerFrame;
    npMCI->dwRate = 1000000;
    npMCI->dwScale = npMCI->dwMicroSecPerFrame;

    /* Reject some bad values */
    if (!lpHdr->dwStreams || lpHdr->dwStreams > 255 || !npMCI->lFrames) {
	goto FileError;
    }

    npMCI->streams = (int) lpHdr->dwStreams;
    npMCI->dwBytesPerSec = lpHdr->dwMaxBytesPerSec;
    npMCI->wEarlyRecords = (UINT) lpHdr->dwInitialFrames;
    npMCI->dwSuggestedBufferSize = lpHdr->dwSuggestedBufferSize;

    SetRect(&npMCI->rcMovie,0,0,(int)lpHdr->dwWidth,(int)lpHdr->dwHeight);

    npMCI->dwFlags |= MCIAVI_HASINDEX;

    if (!(lpHdr->dwFlags & AVIF_ISINTERLEAVED)) {
	DPF(("File is not interleaved.\n"));
	npMCI->dwFlags |= MCIAVI_NOTINTERLEAVED;
    }

    SKIP_BYTES(dwHeaderSize);   /* Skip rest of chunk */

    npMCI->paStreamInfo = (STREAMINFO NEAR *)
		    LocalAlloc(LPTR, npMCI->streams * sizeof(STREAMINFO));
    // !!! error check

    for (stream = 0; stream < npMCI->streams; stream++) {
	AVIStreamHeader FAR *   lpStream;
	HPSTR                   hpNextChunk;
	STREAMINFO *            psi = &npMCI->paStreamInfo[stream];

	if (GET_DWORD() != FOURCC_LIST) {
	    goto FileError;
	}

	dwHeaderSize = GET_DWORD(); /* Skip size */

	hpNextChunk = npMCI->lp + (dwHeaderSize + (dwHeaderSize & 1));

	if (GET_DWORD() != listtypeSTREAMHEADER) {
	    goto FileError;
	}

	/* Now, we're at the begging of the stream's header chunks. */

	if (GET_DWORD() != ckidSTREAMHEADER) {
	    goto FileError;
	}

	dwHeaderSize = GET_DWORD(); /* Skip size */

	/* Now, we're pointing at the stream header */
	lpStream = (AVIStreamHeader FAR *) npMCI->lp;
	hmemcpy(&psi->sh, lpStream, min(dwHeaderSize, sizeof(psi->sh)));

	//
	// reject files with more than one video stream.
	//
	if (psi->sh.fccType == streamtypeVIDEO &&
	    npMCI->nVideoStreams >= 1) {
	    DPF(("File has multiple video streams, giving it to AVIFILE.DLL\n"));
	    goto DontHandleThisFile;
	}

	SKIP_BYTES(dwHeaderSize);

	/* Read the  format */
	if (GET_DWORD() != ckidSTREAMFORMAT) {
	    goto FileError;
	}

	dwHeaderSize = GET_DWORD(); /* Skip size */

	if (dwHeaderSize > 16384L) {
	    goto FileError;
	}

	psi->cbFormat = dwHeaderSize;
	psi->lpFormat = GlobalAllocPtr(GHND,dwHeaderSize);
	if (!psi->lpFormat) {
	    npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
	    return FALSE;
	}

	hmemcpy(psi->lpFormat, npMCI->lp, dwHeaderSize);

	SKIP_BYTES(dwHeaderSize);

	if (PEEK_DWORD() == ckidSTREAMHANDLERDATA) {
	    GET_DWORD();
	    dwHeaderSize = GET_DWORD(); /* Skip size */

	    psi->cbData = dwHeaderSize;
	    psi->lpData = GlobalAllocPtr(GHND,dwHeaderSize);

	    if (!psi->lpData) {
		npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
		return FALSE;
	    }

	    hmemcpy(psi->lpData, npMCI->lp, dwHeaderSize);

	    /* Skip to end of Data chunk */
	    SKIP_BYTES(dwHeaderSize);
	} else {
	    psi->cbData = 0;
	    psi->lpData = NULL;
	}

	InitStream(npMCI, psi);

	npMCI->lp = hpNextChunk;
    }

    if (npMCI->dwTaskError) {
	return FALSE;
    }
    return TRUE;

FileError:
    npMCI->dwTaskError = MCIERR_INVALID_FILE;
    return FALSE;

DontHandleThisFile:
    npMCI->dwTaskError = AVIERR_NOT_AVIFILE;
    return FALSE;
}

//
// --- called on worker thread ---------------------------------------------
//

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | OpenFileInit | called after a file is opened to init things
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

BOOL NEAR PASCAL OpenFileInit(NPMCIGRAPHIC npMCI)
{
    int i;
    RECT rc;

    //
    //  lets make sure we opened something.
    //
    if (npMCI->streams == 0)
	return FALSE;

    if (npMCI->nVideoStreams + npMCI->nAudioStreams + npMCI->nOtherStreams == 0)
	return FALSE;

    if (npMCI->nVideoStreams == 0)
	npMCI->dwFlags &= ~MCIAVI_SHOWVIDEO;

    if (npMCI->nAudioStreams == 0)
	npMCI->dwFlags &= ~MCIAVI_PLAYAUDIO; // No audio streams means silence

    if (IsNTWOW()) {
	if (!npMCI->pbiFormat) {
	// Although there are valid video streams we do not appear to have
	// access to a decompressor that knows what to do with them.  Hence
	// if we are in NT/WOW we fail the open, the call will return to
	// 16 bit land and there might be a codec there that can cope
	    return(FALSE);
	}
    }


    if (npMCI->nAudioStreams > 1) {
	UINT        wLang;
	int         stream;

#ifndef _WIN32
	UINT (WINAPI * GetUserDefaultLangID)(void);
	UINT        u;
	HANDLE      hdll;

	u = SetErrorMode(SEM_NOOPENFILEERRORBOX);
	hdll = LoadLibrary(szOLENLSDLL);
	SetErrorMode(u);

	wLang = 0;
	if ((UINT)hdll > (UINT)HINSTANCE_ERROR)
	{
	    if ((FARPROC) GetUserDefaultLangID = GetProcAddress(hdll, szOLENLSAPI)) {
		wLang = GetUserDefaultLangID();
	    }
	    FreeLibrary(hdll);
	}
#else
	wLang = GetUserDefaultLangID();
#endif
	DPF(("Current language: %x\n", wLang));

	if (wLang > 0) {
	    for (stream = 0; stream < npMCI->streams; stream++) {
		if (SH(stream).fccType == streamtypeAUDIO) {

		    if (!(SH(stream).dwFlags & STREAM_ENABLED))
			continue;

		    if (SH(stream).wLanguage == wLang) {
			npMCI->nAudioStream = stream;
			npMCI->psiAudio = SI(stream);
			break;
		    }
		}
	    }
	}
    }

    if (npMCI->dwFlags & MCIAVI_NOTINTERLEAVED) {
	npMCI->wEarlyRecords = npMCI->wEarlyVideo;
    }
    else {
	npMCI->wEarlyRecords = max(npMCI->wEarlyVideo, npMCI->wEarlyAudio);
    }

    if (npMCI->wEarlyRecords == 0 &&
	    !(npMCI->dwFlags & MCIAVI_NOTINTERLEAVED)) {
	DPF(("Interleaved file with no audio skew?\n"));
	npMCI->dwFlags |= MCIAVI_NOTINTERLEAVED;
    }

    if (npMCI->dwFlags & MCIAVI_ANIMATEPALETTE) {
	DPF(("This AVI file has palette changes.\n"));

	if (npMCI->nVideoStreams > 1) {
	    npMCI->dwFlags &= ~MCIAVI_ANIMATEPALETTE;
	    DPF(("...But we are going to ignore them?\n"));
	}
    }

    //
    // this must be set
    //
    if (npMCI->dwSuggestedBufferSize == 0) {
	for (i=0; i<npMCI->streams; i++)
	    npMCI->dwSuggestedBufferSize =
		max(SH(i).dwSuggestedBufferSize,npMCI->dwSuggestedBufferSize);
    }

    //
    // check all fields in the main header
    //
    if (npMCI->dwScale == 0 ||
	npMCI->dwRate == 0) {
    }

////will be set when header parsed
////npMCI->dwMicroSecPerFrame      = muldiv32(npMCI->dwScale, 1000000, npMCI->dwRate);
    npMCI->dwPlayMicroSecPerFrame  = npMCI->dwMicroSecPerFrame;

#define COMMON_SCALE    10000
    //
    // convert the rate/scale into something that is normalized to 1000
    //
    npMCI->dwRate = muldiv32(npMCI->dwRate, COMMON_SCALE, npMCI->dwScale);
    npMCI->dwScale = COMMON_SCALE;

    //
    // walk all streams and fix them up.
    //
    for (i=0; i<npMCI->streams; i++) {
	STREAMINFO *psi = SI(i);
	LONG lStart;
	LONG lEnd;

	//
	// convert the rate/scale into something that is normalized to 1000
	//
	psi->sh.dwRate = muldiv32(psi->sh.dwRate, COMMON_SCALE, psi->sh.dwScale);
	psi->sh.dwScale = COMMON_SCALE;

	//
	// trim any streams that hang over the movie.
	//
	lStart = MovieToStream(psi, 0);
	lEnd   = MovieToStream(psi, npMCI->lFrames);

	if ((LONG)(psi->sh.dwStart + psi->sh.dwLength) > lEnd) {

	    DPF(("Stream #%d is too long, was %ld now %ld\n", i,
		psi->sh.dwLength, lEnd - psi->sh.dwStart));

	    psi->sh.dwLength = lEnd - psi->sh.dwStart;
	}
    }

    //
    // If this is WOW we had better check that there is an audio codec
    // available.  If not, we let the 16 bit side open the video.
    //
    if (IsNTWOW()) {
	if (SetUpAudio(npMCI, FALSE)) return FALSE;
    }

    //
    // fix up the movie rect
    //
    if (IsRectEmpty(&npMCI->rcMovie)) {
	DPF2(("Movie rect is empty\n"));

	SetRectEmpty(&rc);

	for (i=0; i<npMCI->streams; i++) {
	    UnionRect(&rc,&rc,&SH(i).rcFrame);
	}

	npMCI->rcMovie = rc;
	DPF2(("Movie rect was empty, now [%d, %d, %d, %d]\n", rc));
    } else {
	rc = npMCI->rcMovie;
    }


    // check we can access the interface ptr - the main reason for this
    // is that if we have pasted this interface ptr, we cannot access it on
    // the worker thread (which is where we are now). Clean up the error handling
    // by actually detecting this case.

    if (npMCI->pf) {
	IAVIStream * ps;
	long l;
	if ((l = AVIFileGetStream(npMCI->pf, &ps, 0, 0)) != 0) {
	    DPF(("avifile err %d", l));
	    npMCI->dwTaskError = l;
	    return FALSE;
	} else {
	    if (ps->lpVtbl->FindSample(ps, 0, FIND_FROM_START|FIND_NEXT|FIND_ANY) < 0) {
		npMCI->dwTaskError = MCIERR_DEVICE_NOT_READY;
		ps->lpVtbl->Release(ps);
		return FALSE;
	    }
	    ps->lpVtbl->Release(ps);
	}
    }


    //
    // always read the index, so we can skip frames even on CD!
    //
    ReadIndex(npMCI);

    DPF(("Key frames are every (on average): %ld frames (%ld ms)\n",npMCI->dwKeyFrameInfo, MovieToTime(npMCI->dwKeyFrameInfo)));

    // force things to happen, in case we're re-loading
    SetRectEmpty(&npMCI->rcSource);
    SetRectEmpty(&npMCI->rcDest);

    /* this will call DrawDibBegin() ... */
    if (TryPutRect(npMCI, MCI_DGV_PUT_SOURCE, &rc, &npMCI->dwTaskError)) {
	return FALSE;
    }

    /*
     * also set the dest rect. This should be done
     * by the WM_SIZE message sent during SetWindowToDefaultSize.
     * On NT, the WM_SIZE message is not sent synchronously since it
     * is an inter-thread sendmessage (the winproc is on the original thread
     * whereas we are currently running on the avi thread). The winproc
     * thread may well not get the WM_SIZE message until much too late, so
     * set the dest rect here. Note: don't use ResetDestRect since that
     * also relies on the window size, which is not set yet.
     */

    /* double frame size of destination if zoom by 2 */

    if (npMCI->dwOptionFlags & MCIAVIO_ZOOMBY2)
	SetRect(&rc, 0, 0, rc.right*2, rc.bottom*2);

    if (TryPutRect(npMCI, MCI_DGV_PUT_DESTINATION, &rc, &npMCI->dwTaskError)) {
	return FALSE;
    }
    if (npMCI->dwTaskError) {
	return FALSE;
    }

    //
    // size the window and things.
    //
    SetWindowToDefaultSize(npMCI, FALSE);

    DrawBegin(npMCI, NULL);
    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | mciaviCloseFile | Close an AVI file.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc TRUE means OK, otherwise mci error in dwTaskError
 *
 ***************************************************************************/

BOOL FAR PASCAL mciaviCloseFile (NPMCIGRAPHIC npMCI)
{
    if (!npMCI)
	return FALSE;

    if (npMCI->lpMMIOBuffer) {
	GlobalFreePtr(npMCI->lpMMIOBuffer);
	npMCI->lpMMIOBuffer = NULL;
    }

    npMCI->hicDraw = NULL;

    if (npMCI->hicDrawDefault) {
	if (npMCI->hicDrawDefault != (HIC) -1)
	    ICClose(npMCI->hicDrawDefault);
	npMCI->hicDrawDefault = NULL;
    }

    if (npMCI->hicDrawFull) {
	if (npMCI->hicDrawFull != (HIC) -1)
	    ICClose(npMCI->hicDrawFull);
	npMCI->hicDrawFull = NULL;
    }

    if (npMCI->hicDecompress) {
	// !!! What if we never began it?
	ICDecompressEnd(npMCI->hicDecompress);

	ICClose(npMCI->hicDecompress);
	npMCI->hicDecompress = NULL;
    }

    if (npMCI->hicInternal) {
	ICClose(npMCI->hicInternal);
	npMCI->hicInternal = NULL;
    }

    if (npMCI->hicInternalFull) {
	ICClose(npMCI->hicInternalFull);
	npMCI->hicInternalFull = NULL;
    }

    if (npMCI->hmmio) {
	mmioClose(npMCI->hmmio, 0);
	npMCI->hmmio = NULL;
    }

    if (npMCI->hmmioAudio) {
	mmioClose(npMCI->hmmioAudio, 0);
	npMCI->hmmioAudio = NULL;
    }

    if (npMCI->pWF) {
	LocalFree((HANDLE) npMCI->pWF);
	npMCI->pWF = NULL;
    }

    if (npMCI->pbiFormat) {
	GlobalFreePtr(npMCI->pbiFormat);
	npMCI->pbiFormat = NULL;
    }

//  if (npMCI->hpal) {
//      DeleteObject(npMCI->hpal);
//      npMCI->hpal = NULL;
//  }

    if (npMCI->hpDecompress) {
	GlobalFreePtr(npMCI->hpDecompress);
	npMCI->hpDecompress = NULL;
    }

    if (npMCI->hpIndex) {
	GlobalFreePtr(npMCI->hpIndex);
	npMCI->hpIndex = NULL;
    }

    if (npMCI->hpFrameIndex) {
	GlobalUnlock(npMCI->hgFrameIndex);
	GlobalFree(npMCI->hgFrameIndex);

	npMCI->hpFrameIndex = NULL;
	npMCI->hgFrameIndex = 0;
    }

    if (npMCI->pVolumeTable) {
	LocalFree((HLOCAL)npMCI->pVolumeTable);
	npMCI->pVolumeTable = NULL;
    }

#ifdef USEAVIFILE
    if (npMCI->pf) {
	AVIFileClose(npMCI->pf);
	npMCI->pf = NULL;
    }
#endif

    if (npMCI->paStreamInfo) {
	int i;

	for (i = 0; i < npMCI->streams; i++) {
	    CloseStream(npMCI, &npMCI->paStreamInfo[i]);
	}

	LocalFree((HLOCAL)npMCI->paStreamInfo);
	npMCI->paStreamInfo = NULL;
    }

    npMCI->streams = 0;
    npMCI->nAudioStreams = 0;
    npMCI->nVideoStreams = 0;
    npMCI->nErrorStreams = 0;
    npMCI->nOtherStreams = 0;

    npMCI->wEarlyVideo = 0;
    npMCI->wEarlyAudio = 0;
    npMCI->wEarlyRecords = 0;

    //!!! I bet we need to clear more
    npMCI->dwFlags &= ~(MCIAVI_NOTINTERLEAVED |
			MCIAVI_ANIMATEPALETTE |
			MCIAVI_CANDRAW |
			MCIAVI_HASINDEX);

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | CloseStream | Close an StreamAVI file.
 *
 ***************************************************************************/

STATICFN void NEAR PASCAL CloseStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi)
{
    psi->dwFlags &= ~STREAM_ENABLED;
////psi->sh.fccType = 0;
////psi->sh.fccHandler = 0;

    if (psi->lpFormat) {
	GlobalFreePtr(psi->lpFormat);
	psi->lpFormat = NULL;
    }

    if (psi->lpData) {
	GlobalFreePtr(psi->lpData);
	psi->lpData = NULL;
    }

    if (psi->hicDraw) {
	ICClose(psi->hicDraw);
	psi->hicDraw = NULL;
    }

#ifdef USEAVIFILE
    if (psi->ps) {
	AVIStreamClose(psi->ps);
	psi->ps = NULL;
    }
#endif
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | InitStream | initialize a stream
 *
 ***************************************************************************/

STATICFN BOOL NEAR PASCAL InitStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi)
{
    BOOL f;

    //
    // set flags
    //
    if (psi->sh.dwFlags & AVISF_VIDEO_PALCHANGES)
	psi->dwFlags |= STREAM_PALCHANGES;

    psi->lStart = (LONG)psi->sh.dwStart;
    psi->lEnd   = (LONG)psi->sh.dwStart + psi->sh.dwLength;

    if (psi->sh.fccType == streamtypeVIDEO &&
	!(npMCI->dwFlags & MCIAVI_NOTINTERLEAVED))
	psi->lStart -= (LONG)psi->sh.dwInitialFrames;

    switch(psi->sh.fccType) {
	case streamtypeVIDEO:
	    f = InitVideoStream(npMCI, psi);
	    break;

	case streamtypeAUDIO:
	    f = InitAudioStream(npMCI, psi);
	    break;

	default:
	    f = InitOtherStream(npMCI, psi);
	    break;
	    }

    if (!f)  {
	psi->dwFlags |= STREAM_ERROR;
	npMCI->nErrorStreams++;
	CloseStream(npMCI, psi);
    }

    //
    // disable the stream if the file header says to
    //
    if (psi->sh.dwFlags & AVISF_DISABLED) {
	psi->dwFlags &= ~STREAM_ENABLED;
    }

    return f;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | InitVideoStream | initialize a video stream
 *
 ***************************************************************************/

STATICFN BOOL NEAR PASCAL InitVideoStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi)
{
    LPBITMAPINFOHEADER lpbi;
    int stream = (int) (INT_PTR) (psi - npMCI->paStreamInfo);

    npMCI->wEarlyVideo = (UINT)psi->sh.dwInitialFrames;

    if (psi->sh.dwFlags & AVISF_VIDEO_PALCHANGES) {
	//!!! is this right.
	npMCI->dwFlags |= MCIAVI_ANIMATEPALETTE;
    }

    if (IsRectBogus(&psi->sh.rcFrame)) {
	DPF(("BOGUS Stream rectangle [%d %d %d %d]\n", psi->sh.rcFrame));
	SetRectEmpty(&psi->sh.rcFrame);
    }

    // In case the rectangle is totally wrong, chop it down to size....
    // !!! What if the user _wants_ a zero-size RECT?
    IntersectRect(&psi->sh.rcFrame, &psi->sh.rcFrame, &npMCI->rcMovie);
    if (IsRectEmpty(&psi->sh.rcFrame)) {
	DPF2(("Video stream rect is empty, correcting\n"));
	SetRect(&psi->sh.rcFrame, 0, 0,
	    (int)((LPBITMAPINFOHEADER)psi->lpFormat)->biWidth,
	    (int)((LPBITMAPINFOHEADER)psi->lpFormat)->biHeight);
    }

    //
    // make sure the biCompression is right for RLE files.
    //
    lpbi = (LPBITMAPINFOHEADER)psi->lpFormat;

    if (psi->sh.fccHandler == 0) {

	if (lpbi->biCompression == 0)
	    psi->sh.fccHandler = comptypeDIB;

	if (lpbi->biCompression == BI_RLE8 && lpbi->biBitCount == 8)
	    psi->sh.fccHandler = comptypeRLE;

	if (lpbi->biCompression > 256)
	    psi->sh.fccHandler = lpbi->biCompression;
    }

    if (lpbi->biCompression <= BI_RLE8 && lpbi->biBitCount == 8) {

	if (psi->sh.fccHandler == comptypeRLE0 ||
	    psi->sh.fccHandler == comptypeRLE)
	    lpbi->biCompression = BI_RLE8;

// Assuming a DIB handler has RGB data will blow up files that have RLE data.
// Unfortunately, VidEdit writes out files like this.
//        if (psi->sh.fccHandler == comptypeDIB)
//            lpbi->biCompression = BI_RGB;
    }

    //
    // make sure the color table is set to the right size
    //
    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
	lpbi->biClrUsed = (1 << (int)lpbi->biBitCount);

    //
    // try to open draw handler
    //
    if (psi->sh.fccHandler) {
	psi->hicDraw = ICDrawOpen(psi->sh.fccType,psi->sh.fccHandler,psi->lpFormat);

	if (psi->hicDraw)
	    DPF(("Opened draw handler %4.4hs:%4.4hs (Stream %d)\n", (LPSTR)&psi->sh.fccType,(LPSTR)&psi->sh.fccHandler, stream));
	else
	    DPF(("Failed to open draw handler for %4.4hs:%4.4hs (Stream %d)\n", (LPSTR)&psi->sh.fccType,(LPSTR)&psi->sh.fccHandler, stream));
    }

    //
    // one video stream is the master, he controls the palette etc
    // for lack of a better default the first valid (i.e. one we can
    // handle) video stream will
    // become the master.
    //
    if (npMCI->pbiFormat == NULL) {

	npMCI->nVideoStream = stream;
	npMCI->psiVideo = psi;

	npMCI->pbiFormat = (LPBITMAPINFOHEADER)
		    GlobalAllocPtr(GMEM_MOVEABLE, psi->cbFormat);

	if (!npMCI->pbiFormat) {
	    npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
	    return FALSE;
	}

	//
	// copy the entire format over
	//
	hmemcpy(npMCI->pbiFormat,psi->lpFormat,psi->cbFormat);

	npMCI->bih = *npMCI->pbiFormat;
	npMCI->bih.biSize = sizeof(BITMAPINFOHEADER);
	npMCI->bih.biCompression = BI_RGB;

	if (npMCI->bih.biClrUsed) {
	    /* save the original colors. */
	    hmemcpy(npMCI->argb, (LPBYTE)npMCI->pbiFormat + npMCI->pbiFormat->biSize,
			    (int)npMCI->bih.biClrUsed * sizeof(RGBQUAD));
	    hmemcpy(npMCI->argbOriginal, (LPSTR) npMCI->pbiFormat + npMCI->pbiFormat->biSize,
			    (int)npMCI->bih.biClrUsed * sizeof(RGBQUAD));
	}

	//
	// now open the decompressor, try fastdecompress if it will do it.
	//
	npMCI->hicDecompress = ICLocate(ICTYPE_VIDEO,psi->sh.fccHandler,
		    psi->lpFormat,NULL,ICMODE_FASTDECOMPRESS);

	// fast decompress may not be supported
	if (npMCI->hicDecompress == NULL) {
	    npMCI->hicDecompress = ICDecompressOpen(ICTYPE_VIDEO,
			psi->sh.fccHandler,psi->lpFormat,NULL);
	}

	//
	// set any state data.
	//
	if (npMCI->hicDecompress && psi->cbData) {
	    ICSetState(npMCI->hicDecompress, psi->lpData, psi->cbData);
	}

	if (psi->hicDraw == NULL && npMCI->hicDecompress == NULL &&
	    psi->sh.fccHandler != comptypeRLE0 &&
	    psi->sh.fccHandler != comptypeNONE &&
	    psi->sh.fccHandler != comptypeDIB &&
	    psi->sh.fccHandler != comptypeRLE &&
	    psi->sh.fccHandler != 0) {

	    DPF(("Unable to open compressor '%4.4hs'!!!\n", (LPSTR) &psi->sh.fccHandler));

	    npMCI->nVideoStream = -1;
	    npMCI->psiVideo = NULL;

	    GlobalFreePtr(npMCI->pbiFormat);
	    npMCI->pbiFormat = NULL;

	    //
	    // we would like to return a custom error but by the time the
	    // user (application) comes to retrieve the error text MCI will
	    // have unloaded us (because the open failed) and therefore
	    // will not be able to get our specific error text.
	    // Hence we return a bogus generic error.
	    //
#ifdef _WIN32
	    SetLastError(MCIERR_AVI_NOCOMPRESSOR);
#endif
	    if (npMCI->streams == 1)    // this is the only stream
		npMCI->dwTaskError = MMSYSERR_NODRIVER; // MCIERR_AVI_NOCOMPRESSOR;

	    return FALSE;   // cant load this video stream
	}
    }
    else {
	//
	// this is not the default video stream find a draw handler that
	// can deal with the stream.
	//

	//
	// try VIDS.DRAW
	//
	// if that fails open a draw handler not-specific to the format
	//
	if (psi->hicDraw == NULL) {

	    psi->hicDraw = ICOpen(psi->sh.fccType,FOURCC_AVIDraw,ICMODE_DRAW);

	    if (psi->hicDraw)
		DOUT("Opened draw handler VIDS.DRAW\n");

	    if (psi->hicDraw && ICDrawQuery(psi->hicDraw,psi->lpFormat) != ICERR_OK) {
		DOUT("Closing VIDS.DRAW because it cant handle this format");
		ICClose(psi->hicDraw);
		psi->hicDraw = NULL;
	    }
	}

	//
	// if that fails open our internal handler.
	//
	if (psi->hicDraw == NULL) {

	    psi->hicDraw = ICOpenFunction(psi->sh.fccType,
		FOURCC_AVIDraw,ICMODE_DRAW,(FARPROC)ICAVIDrawProc);

	    if (psi->hicDraw)
		DOUT("Opened Internal draw handler\n");
	}
    }

    npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;

    psi->dwFlags |= STREAM_VIDEO;       // is a video stream
    psi->dwFlags |= STREAM_ENABLED;
    npMCI->nVideoStreams++;

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | InitAudioStream | initialize a audio stream
 *
 ***************************************************************************/

STATICFN BOOL NEAR PASCAL InitAudioStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi)
{
    int stream = (int) (INT_PTR) (psi - npMCI->paStreamInfo);
    LPWAVEFORMAT pwf;

    npMCI->wEarlyAudio = (UINT)psi->sh.dwInitialFrames;

    pwf = (LPWAVEFORMAT)psi->lpFormat;

    if (pwf->nChannels == 0 || pwf->nSamplesPerSec == 0) {
	return FALSE;
    }

    if (pwf->wFormatTag == WAVE_FORMAT_PCM) {
	pwf->nBlockAlign = pwf->nChannels *
	    ((((LPPCMWAVEFORMAT)pwf)->wBitsPerSample + 7) / 8);

	pwf->nAvgBytesPerSec = pwf->nBlockAlign * pwf->nSamplesPerSec;
    }

    psi->sh.dwSampleSize = pwf->nBlockAlign;

    psi->dwFlags |= STREAM_AUDIO;       // audio stream
    psi->dwFlags |= STREAM_ENABLED;     // enabled by default.

    //
    //  make sure dwRate and dwScale are right
    //  dwRate/dwScale should be blocks/sec
    //
    Assert(muldiv32(pwf->nAvgBytesPerSec,1000,pwf->nBlockAlign) ==
	   muldiv32(psi->sh.dwRate, 1000, psi->sh.dwScale));

    //
    //  just to be safe set these ourself to the right value.
    //
    psi->sh.dwRate  = pwf->nAvgBytesPerSec;
    psi->sh.dwScale = pwf->nBlockAlign;

    //
    // only one audio stream can be active at once
    // for lack of a better default the first audio stream will
    // become the active one.
    //
    if (npMCI->nAudioStreams == 0) {
	npMCI->nAudioStream = stream;
	npMCI->psiAudio = psi;
    }

    npMCI->nAudioStreams++;
    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | InitOtherStream | initialize a random stream
 *
 ***************************************************************************/

STATICFN BOOL NEAR PASCAL InitOtherStream(NPMCIGRAPHIC npMCI, STREAMINFO *psi)
{
    int stream = (int) (INT_PTR) (psi - npMCI->paStreamInfo);

    /* Open the specified video compressor */
    psi->hicDraw = ICDrawOpen(psi->sh.fccType,psi->sh.fccHandler,psi->lpFormat);

    if (psi->hicDraw == NULL) {
	DPF(("Unable to play stream!\n"));
	return FALSE;
    }

    if (psi->cbData > 0) {
	ICSetState(psi->hicDraw, psi->lpData, psi->cbData);
    }

    psi->dwFlags |= STREAM_ENABLED;
////psi->dwFlags |= STREAM_OTHER;
    npMCI->nOtherStreams++;
    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | CleanIndex | This function cleans up the index loaded by
 *  ReadIndex() it does the following when cleaning up the index:
 *
 *      converts all offsets to be absolute
 *
 *      converts "alpha" format index's into new format.
 *
 *      computes the max buffer size needed to read this file.
 *
 ***************************************************************************/

INLINE static BOOL NEAR CleanIndex(NPMCIGRAPHIC npMCI)
{
    LONG        lScan;
    AVIINDEXENTRY FAR * px;
    AVIINDEXENTRY FAR * pxRec=NULL;
    DWORD       lIndexAdjust;

    Assert(npMCI->hpIndex != NULL);

    px = (AVIINDEXENTRY FAR *)npMCI->hpIndex;

#ifdef ALPHAFILES
    if (npMCI->dwFlags & MCIAVI_USINGALPHAFORMAT)
	lIndexAdjust = 0;
    else
#endif
    if (// (avihdr.dwFlags & AVIF_MUSTUSEINDEX) ||
		(px->dwChunkOffset < 100))
	lIndexAdjust = npMCI->dwMovieListOffset;
    else
	lIndexAdjust = (npMCI->dwMovieListOffset + sizeof(DWORD)) -
			    px->dwChunkOffset;

//!!! only compute this for the video stream! (or interleaved...)
    npMCI->dwSuggestedBufferSize = 0; // lets get this exactly right

    DPF(("Adjusting index by %ld bytes....\n", lIndexAdjust));

    /* Can we do anything to see if the index is valid? */
    for (lScan = 0; lScan < (LONG)npMCI->macIndex;
		lScan++, ++((AVIINDEXENTRY _huge *)px)) {
	DWORD   ckid;

	//
	// adjust the offset to be absolute
	//
	px->dwChunkOffset += lIndexAdjust;

	// get ckid
	ckid = px->ckid;

	//
	// make sure the buffer size is right, ignore audio chunks because
	// they are either in a 'rec' or we will be reading them into
	// internal buffers not the main buffer.365
	//
	if (((npMCI->dwFlags & MCIAVI_NOTINTERLEAVED) ||
	    ckid == listtypeAVIRECORD) &&
	    TWOCCFromFOURCC(ckid) != cktypeWAVEbytes) {

	    if (px->dwChunkLength + 8 > npMCI->dwSuggestedBufferSize)
		npMCI->dwSuggestedBufferSize = px->dwChunkLength + 12;
	}

#ifdef ALPHAFILES
	//
	// convert a "old" index to a new index
	//
	if (npMCI->dwFlags & MCIAVI_USINGALPHAFORMAT) {
	    switch(ckid) {
		case ckidDIBbits:
		    px->dwFlags |= AVIIF_KEYFRAME;
		    px->ckid = MAKEAVICKID(cktypeDIBbits, 0);
		    break;

		case ckidDIBcompressed:
		    px->ckid = MAKEAVICKID(cktypeDIBcompressed, 0);
		    break;

		case ckidDIBhalfframe:
		    px->ckid = MAKEAVICKID(cktypeDIBhalf, 0);
		    break;

		case ckidPALchange:
		    px->ckid = MAKEAVICKID(cktypePALchange, 0);
		    break;

		case ckidWAVEbytes:
		    px->ckid = MAKEAVICKID(cktypeWAVEbytes, 1);
		    break;

		case ckidWAVEsilence:
		    px->ckid = MAKEAVICKID(cktypeWAVEsilence, 1);
		    break;

		case ckidAVIPADDING:
		case ckidOLDPADDING:
		    px->ckid = ckidAVIPADDING;
		    break;
	    }

	    ckid = px->ckid;
	}
#endif

	//
	// do special things with the video stream.
	//

	if (StreamFromFOURCC(ckid) == (UINT)npMCI->nVideoStream) {

	    //
	    // fix up bogus index's by adding any missing AVIIF_KEYFRAME
	    // bits. ie this only applies for RLE files.
	    //
	    if (TWOCCFromFOURCC(ckid) == cktypeDIBbits &&
		VIDFMT(npMCI->nVideoStream)->biCompression <= BI_RLE8)

		px->dwFlags |= AVIIF_KEYFRAME;

	    //
	    // for video streams, make sure the palette changes are marked
	    // as a no time chunk
	    //
	    if (TWOCCFromFOURCC(ckid) == cktypePALchange)
		px->dwFlags |= AVIIF_NOTIME/*|AVIIF_PALCHANGE*/;

	    //
	    //  make sure the 'REC ' list has the right flags.
	    //
	    if (pxRec) {
		if ((px->dwFlags & AVIIF_KEYFRAME) !=
		    (pxRec->dwFlags & AVIIF_KEYFRAME)) {

		    // Record list does not have correct flags

		    pxRec->dwFlags &= ~AVIIF_KEYFRAME;
		    pxRec->dwFlags |= (px->dwFlags & AVIIF_KEYFRAME);
		}
	    }
	}

	if (ckid == listtypeAVIRECORD) {

	    pxRec = px;

	    if (npMCI->dwFlags & MCIAVI_NOTINTERLEAVED) {
		DPF(("Non interleaved file with a 'REC ' in it?\n"));
		npMCI->wEarlyRecords = max(npMCI->wEarlyVideo, npMCI->wEarlyAudio);

		if (npMCI->wEarlyRecords > 0) {
		    DPF(("Interlaved file with bad header\n"));
		    npMCI->dwFlags &= ~MCIAVI_NOTINTERLEAVED;
		}
	    }
	}
    }

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | MakeFrameIndex | makes the frame index
 *
 *      the frame index is a array of AVIFRAMEINDEX entries, one for each
 *      frame in the movie.  using the frame index we can easily find
 *      a given frame, along with it's keyframe and palette.
 *
 ***************************************************************************/

static BOOL NEAR MakeFrameIndex(NPMCIGRAPHIC npMCI)
{
    LONG        nFrames;
    LONG        iFrameStart;
    LONG        iFrame;
    LONG        iKeyFrame;
    LONG        nKeyFrames;
    LONG        iScan;
    LONG        iNewIndex;
    LONG        iPalette;
    BOOL        fInterleaved;
    DWORD       ckid;
    STREAMINFO *psi;

    AVIINDEXENTRY _huge * pNewIndex;
    AVIINDEXENTRY _huge * pIndexEntry;
    AVIFRAMEINDEX _huge * pFrameIndex;

    if (npMCI->nVideoStreams == 0)
	return TRUE;

    if (npMCI->hpFrameIndex != NULL)
	return TRUE;

    psi = npMCI->psiVideo;
    Assert(psi != NULL);

    fInterleaved = !(npMCI->dwFlags & MCIAVI_NOTINTERLEAVED);

    if (fInterleaved &&
	muldiv32(npMCI->dwRate, 1000, npMCI->dwScale) !=
	muldiv32(psi->sh.dwRate, 1000, psi->sh.dwScale)) {
	//
	//  master video stream should match the movie rate!
	//
	AssertSz(FALSE, "Video stream differnet rate than movie");
	npMCI->dwRate  = psi->sh.dwRate;
	npMCI->dwScale = psi->sh.dwScale;
    }

    if (fInterleaved)
	iFrameStart = -(LONG)npMCI->wEarlyRecords;
    else
	iFrameStart = -(LONG)npMCI->wEarlyVideo;

    nFrames = npMCI->lFrames - iFrameStart;

    // hpFrameIndex is modified to point partway into the block.
    // therefore we need to remember the handle of the block so we
    // can free it correctly (esp on NT)
    if ( (npMCI->hgFrameIndex = GlobalAlloc(GMEM_SHARE|GHND, (DWORD)(nFrames+1) * sizeof(AVIFRAMEINDEX)))
      && (npMCI->hpFrameIndex = GlobalLock(npMCI->hgFrameIndex))) {
    } else {
	// We failed to allocate, or we failed to lock down.  Clean up
	// and return an error.
	if (npMCI->hgFrameIndex) {
	    GlobalFree(npMCI->hgFrameIndex);
	    npMCI->hgFrameIndex = 0;
	}
	DPF(("Couldn't allocate memory for frame index!\n"));
	return FALSE;
    }

    //
    //  do this so we can just index the array with the frame number
    //  (positive or neg)
    //
    npMCI->hpFrameIndex += (-iFrameStart);

    pFrameIndex = npMCI->hpFrameIndex;

    iFrame    = iFrameStart;
    iKeyFrame = -(LONG)npMCI->wEarlyVideo; // iFrameStart;
    iNewIndex = 0;
    iPalette  = -1; // first palette
    nKeyFrames= 0;

#ifdef USEAVIFILE
    if (npMCI->pf) {
	PAVISTREAM ps = SI(npMCI->nVideoStream)->ps;

	for (iFrame = 0; iFrame < npMCI->lFrames; iFrame++) {

	    LONG iKey;

	    iKey      = AVIStreamFindSample(ps,iFrame,FIND_PREV|FIND_KEY);
	    iPalette  = AVIStreamFindSample(ps,iFrame,FIND_PREV|FIND_FORMAT);

	    if (iKey != -1)
		iKeyFrame = iKey;

	    if (iPalette == -1)
		iPalette = 0;

	    pFrameIndex[iFrame].iPrevKey = (UINT)(iFrame - iKeyFrame);
	    pFrameIndex[iFrame].iNextKey = 0;
	    pFrameIndex[iFrame].iPalette = (WORD)iPalette;
	    pFrameIndex[iFrame].dwOffset = 0;
	    pFrameIndex[iFrame].dwLength = 0;

	    Assert(iPalette <= 0xFFFF);

	    if (iFrame - iKeyFrame > 0xFFFF) {
		//!!! we need to set a flag!
		//!!! we need to throw out the index!
		AssertSz(FALSE, "File has too few key frames");
		pFrameIndex[iFrame].iPrevKey = 0;
	    }
	}

	goto ack;
    }
#endif

    Assert(npMCI->hpIndex != NULL);
    Assert(npMCI->macIndex != 0L);
    pNewIndex   = npMCI->hpIndex;
    pIndexEntry = npMCI->hpIndex;

    for (iScan = 0; iScan < (LONG)npMCI->macIndex; iScan++, pIndexEntry++) {

	ckid = pIndexEntry->ckid;

	//
	// check for palette changes.
	//
	if (StreamFromFOURCC(ckid) == (UINT)npMCI->nVideoStream &&
	    TWOCCFromFOURCC(ckid) == cktypePALchange) {

	    iPalette = iNewIndex;

	    pNewIndex[iNewIndex++] = *pIndexEntry;

	    if (fInterleaved)
		pFrameIndex[iFrame-1].iPalette = (WORD)iPalette;
	}

	//
	// remove the video stream from the master index
	//
	if ((ckid != listtypeAVIRECORD) &&
	    (StreamFromFOURCC(ckid) != (UINT)npMCI->nVideoStream)) {
	    pNewIndex[iNewIndex++] = *pIndexEntry;
	}

	//
	//  in interleaved files a "frame" happens every list record
	//
	//  in non-interleaved files a "frame" happens every piece of
	//  data in the video stream (except no time chunks)
	//
	if (fInterleaved) {

	    if (ckid != listtypeAVIRECORD)
		continue;

	} else {

	    if ((StreamFromFOURCC(ckid) != (UINT)npMCI->nVideoStream) ||
		(pIndexEntry->dwFlags & AVIIF_NOTIME))

		continue;
	}

	AssertSz(iFrame < npMCI->lFrames,"Too many frames in index!");

	if (iFrame >= npMCI->lFrames) {
	    break;
	}

	if (pIndexEntry->dwFlags & AVIIF_KEYFRAME) {
	    iKeyFrame = iFrame;
	    nKeyFrames++;
	}

	pFrameIndex[iFrame].iPrevKey = (UINT)(iFrame - iKeyFrame);
	pFrameIndex[iFrame].iNextKey = 0;
	pFrameIndex[iFrame].iPalette = (WORD)iPalette;
	pFrameIndex[iFrame].dwOffset = pIndexEntry->dwChunkOffset;
	pFrameIndex[iFrame].dwLength = pIndexEntry->dwChunkLength;

	if (fInterleaved)
	    pFrameIndex[iFrame].dwOffset += 3 * sizeof(DWORD);

	Assert(iPalette <= 0xFFFF);

	if (iFrame - iKeyFrame > 0xFFFF) {
	    //!!! we need to set a flag!
	    //!!! we need to throw out the index!
	    AssertSz(FALSE, "File has too few key frames");
	    pFrameIndex[iFrame].iPrevKey = 0;
	}

	iFrame++;
    }
ack:
    //
    //  iFrame better equal npMCI->lFrames
    //
    Assert(iFrame == npMCI->lFrames);

    if (iFrame < npMCI->lFrames)
	npMCI->lFrames = iFrame;

    //
    // make a "dummy" last frame
    //
    pFrameIndex[iFrame].iPrevKey = (UINT)(iFrame - iKeyFrame);
    pFrameIndex[iFrame].iNextKey = 0;
    pFrameIndex[iFrame].iPalette = (WORD)iPalette;
    pFrameIndex[iFrame].dwOffset = 0;
    pFrameIndex[iFrame].dwLength = 0;

    //
    // compute the key frames every value
    //
    if (nKeyFrames) {

	if (nKeyFrames > 1)
	    npMCI->dwKeyFrameInfo = (DWORD)((nFrames + nKeyFrames/2)/nKeyFrames);
	else
	    npMCI->dwKeyFrameInfo = 0;
    }

    //
    //  now go through the index, and fix all the iNextKey fields
    //
    pFrameIndex = npMCI->hpFrameIndex;
////iKeyFrame = npMCI->lFrames; //!!! what should this be set to? zero?

    for (iFrame = npMCI->lFrames; iFrame>=iFrameStart; iFrame--)
    {
	if (pFrameIndex[iFrame].iPrevKey == 0)
	    iKeyFrame = iFrame;

	if (iKeyFrame >= iFrame)
	    pFrameIndex[iFrame].iNextKey = (UINT)(iKeyFrame - iFrame);
	else
	    pFrameIndex[iFrame].iNextKey = 0xFFFF;      // way far away

	if (iKeyFrame - iFrame > 0xFFFF) {
	    //!!! we need to set a flag!
	    //!!! we need to throw out the index!
	    AssertSz(FALSE, "File has too few key frames");
	    pFrameIndex[iFrame].iNextKey = 0;
	}
    }

    //
    // we dont need the index, if we are using AVIFile or
    // we have a interleaved file.  when the file is interleaved
    // we never do random access (except for palette changes)
    //
    // !!!this is not true, we need the index iff we have a audio only
    // file or we play a interleaved file real slow.
    //
    if (npMCI->pf /* ||
	(fInterleaved && !(npMCI->dwFlags & MCIAVI_ANIMATEPALETTE))*/ ) {
	DOUT("The Master index must go!\n");
	iNewIndex = 0;
    }

    //
    // now re-alloc the master index down to size.
    //
    // !!! do we even need the master index anymore, for interleaved files?
    //
    DPF(("Master index was %ld entries now %ld\n",npMCI->macIndex, iNewIndex));

    npMCI->macIndex = iNewIndex;

    if (iNewIndex > 0) {
	npMCI->hpIndex = (AVIINDEXENTRY _huge *)
		GlobalReAllocPtr(npMCI->hpIndex,
				 (LONG)iNewIndex * sizeof(AVIINDEXENTRY),
				 GMEM_MOVEABLE | GMEM_SHARE);

	Assert(npMCI->hpIndex != NULL);
    }
    else {
	if (npMCI->hpIndex)
	    GlobalFreePtr(npMCI->hpIndex);
	npMCI->hpIndex = NULL;
    }

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | ReadIndex | Read the index into npMCI->hpIndex.  Should
 *      only be called if the HASINDEX flag is set.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data
 *
 * @rdesc TRUE means no errors, false means unable to read index.
 *
 ***************************************************************************/
BOOL FAR PASCAL ReadIndex(NPMCIGRAPHIC npMCI)
{
    MMCKINFO    ck;
    DWORD       dwOldPos;

    if (npMCI->hpIndex || npMCI->hpFrameIndex)
	return TRUE;

    if (!(npMCI->dwFlags & MCIAVI_HASINDEX))
	return FALSE;

    if (npMCI->pf) {
	MakeFrameIndex(npMCI);
	return TRUE;
    }

#if 0
    if (GetCurrentTask() != npMCI->hTask) {

	/* this function is called (from GraphicStatus) when
	 * possibly playing - so we have to suspend play while we read
	 * the index.
	 */
    // won't work with the current multi-thread design
    //   TEMPORARYSTATE  ts;

    //   if (StopTemporarily(npMCI, &ts) == 0) {
    //       mciaviTaskMessage(npMCI, TASKREADINDEX);
    //        RestartAgain(npMCI, &ts);
    //        return (npMCI->hpIndex != NULL);
    //    }
	return(FALSE);
    }
#else
    if (GetCurrentTask() != npMCI->hTask)
	return FALSE;
#endif

    dwOldPos = mmioSeek(npMCI->hmmio, 0, SEEK_CUR);

    DPF(("Reading index: starting from %lx\n", npMCI->dwBigListEnd));

    if (mmioSeek(npMCI->hmmio, npMCI->dwBigListEnd, SEEK_SET) == -1) {
IndexReadError:
	DPF(("Error reading index!\n"));
	npMCI->dwFlags &= ~(MCIAVI_HASINDEX);
	mmioSeek(npMCI->hmmio, dwOldPos, SEEK_SET);
	return FALSE;
    }

    ck.ckid = ckidAVINEWINDEX;
    if (mmioDescend(npMCI->hmmio, &ck, NULL, MMIO_FINDCHUNK) != 0) {
	goto IndexReadError;
    }

    /* A zero-size index isn't much good. */
    if (ck.cksize == 0)
	goto IndexReadError;

    npMCI->macIndex = ck.cksize / sizeof(AVIINDEXENTRY);
    npMCI->hpIndex = (AVIINDEXENTRY _huge *)
		     GlobalAllocPtr(GMEM_SHARE | GMEM_MOVEABLE, ck.cksize);

    if (!npMCI->hpIndex) {
	DPF(("Insufficient memory to read index.\n"));
	goto IndexReadError;
    }

#ifndef _WIN32
    Assert(OFFSETOF(npMCI->hpIndex) == 0);
#endif

    if (mmioRead(npMCI->hmmio, (HPSTR) npMCI->hpIndex, ck.cksize) != (LONG) ck.cksize) {
	Assert(0);
	goto IndexReadError;
    }

    CleanIndex(npMCI);
    MakeFrameIndex(npMCI);

////should we do this for audio? remove video data?
////MakeStreamIndex(npMCI, ???);

    mmioSeek(npMCI->hmmio, dwOldPos, SEEK_SET);
    return TRUE;
}

/***************************************************************************
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | IsRectBogus | 'nuf said
 *
 ***************************************************************************/

INLINE static BOOL NEAR PASCAL IsRectBogus(RECT* prc)
{
    if (prc->right  - prc->left <= 0 ||
	prc->bottom - prc->top <= 0 ||
	prc->bottom <= 0 ||
	prc->right <= 0)

	return TRUE;
    else
	return FALSE;
}

#ifndef _WIN32  // _WIN32 has one!
/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | atol | local version of atol
 *
 ***************************************************************************/

static LONG NEAR PASCAL atol(char *sz)
{
    LONG l = 0;

    while (*sz && *sz >= '0' && *sz <= '9')
	l = l*10 + *sz++ - '0';

    return l;
}
#endif

#ifndef _WIN32

/*--------------------------------------------------------------------------
 *
 *  IsCDROMDrive() -
 *
 * Purpose:  Return non-zero if a RAM drive
 *
 *  wDrive   drive index (0=A, 1=B, ...)
 *
 *  return   TRUE/FALSE
 *-------------------------------------------------------------------------*/

#pragma optimize("", off)
static BOOL NEAR PASCAL IsCDROMDrive(UINT wDrive)
{
    BOOL f;

    _asm {
	mov ax, 1500h     /* first test for presence of MSCDEX */
	xor bx, bx
	int 2fh
	mov ax, bx        /* MSCDEX is not there if bx is still zero */
	or  ax, ax        /* ...so return FALSE from this function */
	jz  no_mscdex
	mov ax, 150bh     /* MSCDEX driver check API */
	mov cx, wDrive    /* ...cx is drive index */
	int 2fh
no_mscdex:
	mov f,ax
    }
    return f;
}
#pragma optimize("", on)

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | IsNetFile | is the passed file on a network drive?
 *
 ***************************************************************************/

static BOOL NEAR PASCAL IsNetFile(LPTSTR szFile)
{
    OFSTRUCT            of;

    if (OpenFile(szFile, &of, OF_PARSE) == -1)
	return FALSE;

    AnsiUpper(of.szPathName);

    if (of.szPathName[0] == '\\' && of.szPathName[1] == '\\')
	return TRUE;

    if (of.szPathName[0] == '/' && of.szPathName[1] == '/')
	return TRUE;

    if (of.szPathName[1] == ':' &&
	GetDriveType(of.szPathName[0] - 'A') == DRIVE_REMOTE &&
	!IsCDROMDrive(of.szPathName[0] - 'A'))

	return TRUE;

    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api BOOL | IsCDROMFile | is the passed file on a CD-ROM drive?
 *
 ***************************************************************************/

static BOOL NEAR PASCAL IsCDROMFile(LPTSTR szFile)
{
    OFSTRUCT of;

    if (OpenFile(szFile, &of, OF_PARSE) == -1)
	return FALSE;

    AnsiUpper(of.szPathName);

    if (of.szPathName[0] == '\\' && of.szPathName[1] == '\\')
	return FALSE;

    if (of.szPathName[0] == '/' && of.szPathName[1] == '/')
	return FALSE;

    if (of.szPathName[1] == ':' &&
	GetDriveType(of.szPathName[0] - 'A') == DRIVE_REMOTE &&
	IsCDROMDrive(of.szPathName[0] - 'A'))

	return TRUE;

    return FALSE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api UINT | GetFileDriveType | return drive type given a file
 *
 *      DRIVE_CDROM
 *      DRIVE_REMOTE
 *      DRIVE_FIXED
 *      DRIVE_REMOVABLE
 *
 ***************************************************************************/

static UINT NEAR PASCAL GetFileDriveType(LPSTR szPath)
{
    if (IsCDROMFile(szPath))
	return DRIVE_CDROM;

    if (IsNetFile(szPath))
	return DRIVE_REMOTE;

    if (szPath[1] == ':')
	return GetDriveType(szPath[0] - 'A');

    return 0;
}
#else // _WIN32
/*
 * We cannot pass the call directly to GetDriveType as we have a full
 * pathname - and that gets rejected by GetFileDriveType.  Using a
 * static variable is ok - the open call is serialised.  The assumption
 * is that this routine is ONLY called with complete path information.
 */

TCHAR DriveType[4] = TEXT(".:\\");
static UINT NEAR PASCAL GetFileDriveType(LPTSTR szPath)
{

    Assert(szPath != NULL);
    if (*szPath == TEXT('\\')) {
	Assert(szPath[1] == TEXT('\\'));
	return(DRIVE_REMOTE);
    }

    if (szPath[1] == TEXT(':')) {
	DriveType[0] = szPath[0];
	return GetDriveType(DriveType);
    }

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\avifilex.h ===
////////////////////////////////////////////////////////////////////////////
//
// stuff needed for MCIAVI to run-time-link to AVIFile for playback.
// because most everything from AVIFILE.DLL is a OLE interface, we dont need
// to RTL to many functions.
//
////////////////////////////////////////////////////////////////////////////

#define USEAVIFILE      //!!! hey lets use AVIFile.

#ifdef USEAVIFILE

//#define _INC_AVIFMT     100     /* version number * 100 + revision */
#include <vfw.h>

UINT    uAVIFILE;
HMODULE hdllAVIFILE;
#ifdef USE_ISVALIDINTERFACE
HMODULE hdllCOMPOBJ;
#endif

//
//  RTL to AVIFile...
//
void    (STDAPICALLTYPE *XAVIFileInit)(void);
void    (STDAPICALLTYPE *XAVIFileExit)(void);
HRESULT (STDAPICALLTYPE *XAVIFileOpen)(PAVIFILE FAR * ppfile,LPCTSTR szFile,UINT uMode,LPCLSID lpHandler);
HRESULT (STDAPICALLTYPE *XAVIMakeFileFromStreams)(PAVIFILE FAR *,int,PAVISTREAM FAR *);
HRESULT (STDAPICALLTYPE *XAVIStreamBeginStreaming)(PAVISTREAM   pavi,
			       LONG	    lStart,
			       LONG	    lEnd,
			       LONG	    lRate);
HRESULT (STDAPICALLTYPE *XAVIStreamEndStreaming)(PAVISTREAM   pavi);


#undef  AVIFileInit
#undef  AVIFileExit
#undef AVIFileOpen
#undef AVIFileInfo

#define AVIFileInit         XAVIFileInit
#define AVIFileExit         XAVIFileExit
#define AVIFileOpen         XAVIFileOpen
#define AVIMakeFileFromStreams  XAVIMakeFileFromStreams
#define AVIStreamBeginStreaming  XAVIStreamBeginStreaming
#define AVIStreamEndStreaming  XAVIStreamEndStreaming

#undef  AVIFileClose
#define AVIFileClose(p)                 (p)->lpVtbl->Release(p)
#define AVIFileInfo(p,a,b)              (p)->lpVtbl->Info(p, a, b)
#define AVIFileGetStream(p,a,b,c)       (p)->lpVtbl->GetStream(p,a,b,c)

#undef  AVIStreamClose
#define AVIStreamClose(p)               (p)->lpVtbl->Release(p)

#undef  AVIStreamInfo
#define AVIStreamInfo(p,a,b)            (p)->lpVtbl->Info(p, a, b)
#define AVIStreamReadFormat(p,a,b,c)    (p)->lpVtbl->ReadFormat(p, a, b, c)
#define AVIStreamReadData(p,a,b,c)      (p)->lpVtbl->ReadData(p, a, b, c)
#define AVIStreamFindSample(p,a,b)      (p)->lpVtbl->FindSample(p, a, b)

#define AVIStreamRead(p,a,b,c,d,e,f)    (p)->lpVtbl->Read(p,a,b,c,d,e,f)

// no IsValidInterface in nt 1.1 yet
#ifdef USE_ISVALIDINTERFACE

// RTL to COMPOBJ
EXTERN_C BOOL STDAPICALLTYPE IsValidInterface(LPVOID pv);
BOOL    (STDAPICALLTYPE *XIsValidInterface)(LPVOID pv);

#define IsValidInterface XIsValidInterface
#endif

#endif  // USEAVIFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\cnfgdlg.h ===
//
// the configure dialog
//
#define IDA_CONFIG                  100

#define ID_WINDOW                   101
#define ID_VGA240                   102
#define ID_VGA200                   103
#define ID_ZOOM2                    104
#define ID_FAILIFNOWAVE		    105
#define ID_SEEKEXACT		    106
#define ID_STUPIDMODE		    107
#define ID_SKIPFRAMES               108
#define ID_DEFAULT                  109
#define ID_DEBUG                    110
#define ID_INFO                     111
#define ID_SIZE                     112
#define ID_ICON                     113
#define ID_REJECT                   114
#define ID_USEDCI                   115

//
//  the debug options dialog.
//
#define IDA_DEBUG                   200
#define IDA_REJECT                  201
#define ID_SCREEN                   202
#define ID_BITMAP                   203
#define ID_SUCKS                    204
#define ID_RATE                     205
#define ID_LEVEL                    206
#define ID_BUILD                    207
#define ID_USE_AVIFILE              208
#define ID_NO_SOUND                 209     // Play without sound
#define ID_RATE_LABEL               210
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\common.c ===
/* common.c
 *
 * Common functions useful for Windows programs.
 */



//#include <windows.h>
#include <stdarg.h>
#include "graphic.h"
#include "profile.h"

#ifdef DEBUG  // On NT, ntavi.h might do an undef debug...
#include "common.h"

/* globals */
int		giDebugLevel = -1;	// current debug level (0 = disabled)
int		gfhDebugFile = -1;	// file handle for debug output (or -1)
int		giTimingLevel = -1;


/* InitializeDebugOutput(szAppName)
 *
 * Read the current debug level of this application (named <szAppName>)
 * from the [debug] section of win.ini, as well as the current location
 * for debug output.
 */
void FAR PASCAL
InitializeDebugOutput(LPSTR szAppName)
{
    char	achLocation[300]; // debug output location

    /* debugging is disabled by default (and if an error occurs below) */
    giDebugLevel = -1;
    gfhDebugFile = -1;

    /* get the debug output location */
    if ( (mmGetProfileStringA("debug", "Location", "", achLocation,
                         sizeof(achLocation)) == sizeof(achLocation)) ||
         (achLocation[0] == 0) )
    	return;

    if (achLocation[0] == '>')
    {
    	/* <achLocation> is the name of a file to overwrite (if
    	 * a single '>' is given) or append to (if '>>' is given)
    	 */
    	if (achLocation[1] == '>')
    		gfhDebugFile = _lopen(achLocation + 2, OF_WRITE);
    	else
    		gfhDebugFile = _lcreat(achLocation + 1, 0);
    	
    	if (gfhDebugFile < 0)
    		return;
    	
    	if (achLocation[1] == '>')
    		_llseek(gfhDebugFile, 0, SEEK_END);
    }
    else
    if (lstrcmpiA(achLocation, "aux") == 0)
    {
    	/* use OutputDebugString() for debug output */
    }
    else
    if ((lstrcmpiA(achLocation, "com1") == 0)
       || (lstrcmpiA(achLocation, "com2") == 0))
    {
            gfhDebugFile = _lopen(achLocation, OF_WRITE);
    }
    else
    {
    	/* invalid "location=" -- keep debugging disabled */
    	return;
    }

    /* get the debug level */
    giDebugLevel = mmGetProfileIntA("debug", szAppName, 0);
    giTimingLevel = mmGetProfileIntA("debug", "Timing", 0);
}


/* TerminateDebugOutput()
 *
 * Terminate debug output for this application.
 */
void FAR PASCAL
TerminateDebugOutput(void)
{
	if (gfhDebugFile >= 0)
		_lclose(gfhDebugFile);
	gfhDebugFile = -1;
	giDebugLevel = -1;
}


/* _Assert(szExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
#ifndef _WIN32
#pragma optimize("", off)
#define ASSERTPREFIX
#else
#define ASSERTPREFIX "(NT) "
#endif

void FAR PASCAL
_Assert(char *szExp, char *szFile, int iLine)
{
	static char	ach[300];	// debug output (avoid stack overflow)
	int		id;
	int		iExitCode;
	void FAR PASCAL DebugBreak(void);

	/* display error message */

        if (szExp)
            wsprintfA(ach, ASSERTPREFIX "(%s)\nFile %s, line %d", (LPSTR)szExp, (LPSTR)szFile, iLine);
        else
            wsprintfA(ach, ASSERTPREFIX "File %s, line %d", (LPSTR)szFile, iLine);

	MessageBeep(MB_ICONHAND);
	id = MessageBoxA(NULL, ach, "Assertion Failed",
#ifdef BIDI
		MB_RTL_READING |
#endif
		MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

	/* abort, debug, or ignore */
	switch (id)
	{

	case IDABORT:

		/* kill this application */
		iExitCode = 0;
#ifndef _WIN32
		_asm
		{
			mov	ah, 4Ch
			mov	al, BYTE PTR iExitCode
			int     21h
		}
#else
                FatalAppExit(0, TEXT("Good Bye"));
#endif // WIN16
		break;

	case IDRETRY:
		/* break into the debugger */
		DebugBreak();
		break;

	case IDIGNORE:
		/* ignore the assertion failure */
		break;
	}
}
#ifndef _WIN32
#pragma optimize("", on)
#endif

/* _DebugPrintf(szFormat, ...)
 *
 * If the application's debug level is at or above <iDebugLevel>,
 * then output debug string <szFormat> with formatting codes
 * replaced with arguments in the argument list pointed to by <szArg1>.
 */
#define MODNAME "MCIAVI"
void FAR CDECL
_DebugPrintf(LPSTR szFormat, ...)
{
	static char	ach[300];	// debug output (avoid stack overflow)
	int		cch;		// length of debug output string

#ifndef _WIN32
        NPSTR           pchSrc, pchDst;
        if (*szFormat == '!') {
            ++szFormat;
        }
        wvsprintf(ach, szFormat, (LPVOID)(&szFormat+1));
#else
        UINT n;
        va_list va;

        va_start(va, szFormat);
        if (*szFormat == '!') {
            ++szFormat;
            n=0;
        } else if (*szFormat=='.') {
            n=0;
        } else {
            n = wsprintfA(ach, MODNAME ": (tid %x) ", GetCurrentThreadId());
        }
        wvsprintfA(ach+n, szFormat, va);
        va_end(va);
#endif

#ifndef _WIN32
	/* expand the newlines into carrige-return-line-feed pairs;
	 * first, figure out how long the new (expanded) string will be
	 */
	for (pchSrc = pchDst = ach; *pchSrc != 0; pchSrc++, pchDst++)
		if (*pchSrc == '\n')
			pchDst++;
	
	/* is <ach> large enough? */
	cch = pchDst - ach;
        Assert(cch < sizeof(ach));
	*pchDst-- = 0;

	/* working backwards, expand \n's to \r\n's */
	while (pchSrc-- > ach)
		if ((*pchDst-- = *pchSrc) == '\n')
			*pchDst-- = '\r';

#else
       cch = strlen(ach);
#endif //no expansion on Win32
	/* output the debug string */
	if (gfhDebugFile > 0)
            _lwrite(gfhDebugFile, ach, cch);
	else {
            OutputDebugStringA(ach);
        }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\common.h ===
/* common.h
 *
 * Common functions useful for Windows programs.
 *
 * InitializeDebugOutput(szAppName):
 *
 *	Read debug level for this application (named <szAppName>) from
 *	win.ini's [debug] section, which should look like this:
 *
 *	   [debug]
 *	   location=aux			; use OutputDebugString() to output
 *	   foobar=2			; this app has debug level 2
 *	   blorg=0			; this app has debug output disabled
 *
 *	If you want debug output to go to a file instead of to the AUX
 *	device (or the debugger), use "location=>filename".  To append to
 *	the file instead of rewriting the file, use "location=>>filename".
 *
 *	If DEBUG is not #define'd, then the call to InitializeDebugOutput()
 *	generates no code,
 *
 * TerminateDebugOutput():
 *
 *	End debug output for this application.  If DEBUG is not #define'd,
 *	then the call to InitializeDebugOutput() generates no code.
 *
 * DPF((szFormat, args...))
 *
 *	If debugging output for this applicaton is enabled (see
 *	InitializeDebugOutput()), print debug output specified by format
 *	string <szFormat>, which may contain wsprintf()-style formatting
 *	codes corresponding to arguments <args>.  Example:
 *
 *		DPF(("in WriteFile(): szFile='%s', dwFlags=0x%08lx\n",
 *	     	(LSPTR) szFile, dwFlags));
 *
 * DPF2((szFormat, args...))
 * DPF3((szFormat, args...))
 * DPF4((szFormat, args...))
 *
 *	Like DPF, but only output the debug string if the debug level for
 *	this application is at least 2, 3, or 4, respectively.
 *
 * Assert(fExpr)
 *
 *	If DEBUG is #define'd, then generate an "assertion failed" message box
 *	allowing the user to abort the program, enter the debugger (the "Retry"
 *	button), or ignore the error.  If DEBUG is not #define'd then Assert()
 *	generates no code.
 *
 * AssertEval(fExpr)
 *
 *	Like Assert(), but evaluate and return <fExpr>, even if DEBUG
 *	is not #define'd.  (Use if you want the BOOL expression to be
 *	evaluated even in a retail build.)
 */

#ifdef DEBUG
	/* Assert() macros */
	#undef Assert
	#undef AssertSz
	#undef AssertEval
        #define AssertSz(x,sz)           ((x) ? (void)0 : (void)_Assert(sz, __FILE__, __LINE__))
        #define Assert(expr)             AssertSz(expr, #expr)
        #define AssertEval(expr)         Assert(expr)

	/* debug printf macros */
	#define DPF( _x_ )	if (giDebugLevel >= 1) _DebugPrintf _x_
        #define DPF0( _x_ )                            _DebugPrintf _x_
	#define DPF1( _x_ )	if (giDebugLevel >= 1) _DebugPrintf _x_
	#define DPF2( _x_ )	if (giDebugLevel >= 2) _DebugPrintf _x_
	#define DPF3( _x_ )	if (giDebugLevel >= 3) _DebugPrintf _x_
        #define DPF4( _x_ )     if (giDebugLevel >= 4) _DebugPrintf _x_

        #define DOUT( _x_ )      if (giDebugLevel >= 1) {static char _based(_segname("_CODE")) smag[] = _x_; _DebugPrintf(smag); }
        #define DOUT0( _x_ )                            {static char _based(_segname("_CODE")) smag[] = _x_; _DebugPrintf(smag); }
        #define DOUT1( _x_ )     if (giDebugLevel >= 1) {static char _based(_segname("_CODE")) smag[] = _x_; _DebugPrintf(smag); }
        #define DOUT2( _x_ )     if (giDebugLevel >= 2) {static char _based(_segname("_CODE")) smag[] = _x_; _DebugPrintf(smag); }
        #define DOUT3( _x_ )     if (giDebugLevel >= 3) {static char _based(_segname("_CODE")) smag[] = _x_; _DebugPrintf(smag); }
        #define DOUT4( _x_ )     if (giDebugLevel >= 4) {static char _based(_segname("_CODE")) smag[] = _x_; _DebugPrintf(smag); }

	/* prototypes */
	void FAR PASCAL InitializeDebugOutput(LPSTR szAppName);
	void FAR PASCAL TerminateDebugOutput(void);
        void FAR PASCAL _Assert(char *szExp, char *szFile, int iLine);
        void FAR CDECL _DebugPrintf(LPSTR szFormat, ...);
        extern int	giDebugLevel;	// current debug level

#else
	/* Assert() macros */
        #define AssertSz(expr,x)         ((void)0)
        #define Assert(expr)             ((void)0)
	#define AssertEval(expr)	 (expr)

	/* debug printf macros */
	#define DPF( x )
	#define DPF0( x )
	#define DPF1( x )
	#define DPF2( x )
	#define DPF3( x )
        #define DPF4( x )

        #define DOUT( x )
        #define DOUT0( x )
        #define DOUT1( x )
        #define DOUT2( x )
        #define DOUT3( x )
        #define DOUT4( x )

	/* stubs for debugging function prototypes */
	#define InitializeDebugOutput(szAppName)	0
	#define TerminateDebugOutput()			0
#endif


/* flags for _llseek() */
#ifndef SEEK_SET
	#define SEEK_SET	0	// seek relative to start of file
	#define SEEK_CUR	1	// seek relative to current position
	#define SEEK_END	2	// seek relative to end of file
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\avitask.h ===
/****************************************************************************

Task State : MCIAVI has a separate background task for every open
instance of mciavi. The task handle and task state are stored in
the per-instance data structure.  The task can be in one of four
states.

   TASKABORT : Set by the AVI task when it fails to open the requested
   file during initialisation.


N.B.  TASKINIT is no longer used
   TASKINIT : This is the initial task state set when the
   instance data structure is initialized in mwOpenDevice()
   before the actual task is created by mmTaskCreate().
   After the task is created, mwOpenDevice() waits until
   the task state changes to TASKIDLE before returning
   success so that the background task is definitely initialized
   after an open call.

   TASKIDLE : The task sets the state to TASKIDLE and blocks whenever
   there is nothing to do. When the task wakes, the state is either
   TASKCLOSE if the instance is being closed or else TASKBUSY
   if  the task is to begin  recording or playback of the file.

   TASKCLOSE : mwCloseDevice() stops playback or recording which forces
   the task state to TASKIDLE and then sets the state to TASKCLOSE and
   wakes the task so that the task will destroy itself.

   TASKSTARTING: The task is in this state when it is initializing for
   playback, but hasn't started yet.  This is used so that the calling
   task can wait for play to start before returning "no error" as the
   result of an MCI play command.

   TASKCUEING: The task is in this state when it is reading extra
   records and buffering up audio before actually starting to play.

   TASKPAUSED: The task is in this state while it is paused.
   TASKPLAYING: The task is in this state during playback

****************************************************************************/

#define TASKABORT               0
//#define TASKBEINGCREATED	1
//#define TASKINIT		2
#define TASKIDLE		3
#define TASKSTARTING		4
#define TASKCUEING		5
#define TASKPLAYING		6
#define TASKPAUSED		7
#define TASKCLOSE		8
//				9
//				10
//#define TASKREADINDEX		11
//#define TASKRELOAD		12



// inter-thread requests - from user to worker
#define AVI_CLOSE		1
#define AVI_PLAY		2
#define AVI_STOP		3
#define AVI_REALIZE		4
#define AVI_UPDATE		5
#define AVI_PAUSE		6
#define AVI_CUE			7
#define AVI_SEEK		8
#define AVI_WINDOW		9
#define AVI_SETSPEED		10
#define AVI_MUTE		11
#define AVI_SETVOLUME		12
#define AVI_AUDIOSTREAM		13
#define AVI_VIDEOSTREAM		14
#define AVI_PUT			15
#define AVI_PALETTE		16
#define AVI_RESUME		17
#define AVI_GETVOLUME		18
#define AVI_WAVESTEAL		19
#define AVI_WAVERETURN		20
#define AVI_PALETTECOLOR	21


/* A function back in device.c */
void NEAR PASCAL ShowStage(NPMCIGRAPHIC npMCI);

//
//  call this to RTL to AVIFile.
//
BOOL FAR InitAVIFile(NPMCIGRAPHIC npMCI);
BOOL FAR FreeAVIFile(NPMCIGRAPHIC npMCI);

/* Functions in avitask.c */
void FAR PASCAL _LOADDS mciaviTask(DWORD_PTR dwInst);
void FAR PASCAL mciaviTaskCleanup(NPMCIGRAPHIC npMCI);

/* Functions in aviplay.c */
UINT NEAR PASCAL mciaviPlayFile(NPMCIGRAPHIC npMCI, BOOL bSetEvent);

/* Functions in avidraw.c */
/* !!! Should this be externally visible? */
BOOL NEAR PASCAL DoStreamUpdate(NPMCIGRAPHIC npMCI, BOOL fPaint);
void NEAR PASCAL StreamInvalidate(NPMCIGRAPHIC npMCI, LPRECT prc);

UINT NEAR PASCAL PrepareDC(NPMCIGRAPHIC npMCI);
void NEAR PASCAL UnprepareDC(NPMCIGRAPHIC npMCI);

BOOL FAR PASCAL DrawBegin(NPMCIGRAPHIC npMCI, BOOL FAR *fRestart);
void NEAR PASCAL DrawEnd(NPMCIGRAPHIC npMCI);

BOOL NEAR PASCAL DisplayVideoFrame(NPMCIGRAPHIC npMCI, BOOL fHurryUp);
BOOL NEAR PASCAL ProcessPaletteChange(NPMCIGRAPHIC npMCI, DWORD cksize);


/* Functions in avisound.c */
BOOL NEAR PASCAL PlayRecordAudio(NPMCIGRAPHIC npMCI, BOOL FAR *pfHurryUp,
				    BOOL FAR *pfPlayedAudio);
BOOL NEAR PASCAL KeepPlayingAudio(NPMCIGRAPHIC npMCI);
BOOL NEAR PASCAL HandleAudioChunk(NPMCIGRAPHIC npMCI);

DWORD FAR PASCAL SetUpAudio(NPMCIGRAPHIC npMCI, BOOL fPlaying);
DWORD FAR PASCAL CleanUpAudio(NPMCIGRAPHIC npMCI);
void  FAR PASCAL BuildVolumeTable(NPMCIGRAPHIC npMCI);
BOOL  FAR PASCAL StealWaveDevice(NPMCIGRAPHIC npMCI);
BOOL  FAR PASCAL GiveWaveDevice(NPMCIGRAPHIC npMCI);

/* Functions in aviopen.c */
BOOL FAR PASCAL mciaviCloseFile(NPMCIGRAPHIC npMCI);

// now called on app thread
BOOL FAR PASCAL mciaviOpenFile(NPMCIGRAPHIC npMCI);
// called on worker thread to complete
BOOL NEAR PASCAL OpenFileInit(NPMCIGRAPHIC npMCI);


/* Messages used to control switching of audio between (and within)
 * applications.  These messages are POSTED, hence audio switching will
 * be asynchronous.  The timing depends on various factors: machine load,
 * video speed, etc..  We should probably do this via RegisterWindowMessage
 */
#define WM_AUDIO_ON  WM_USER+100
#define WM_AUDIO_OFF WM_USER+101

// messages sent to winproc thread - set up using RegisterWindowMessage
// in drvproc.c
#define AVIM_DESTROY		(WM_USER+103)
#define AVIM_SHOWSTAGE		(WM_USER+104)

//#define AVIM_DESTROY		(mAVIM_DESTROY)
//#define AVIM_SHOWSTAGE	(mAVIM_SHOWSTAGE)
//extern UINT mAVIM_DESTROY;
//extern UINT mAVIM_SHOWSTAGE;


// in hmemcpy.asm
#ifndef _WIN32
LPVOID FAR PASCAL MemCopy(LPVOID dest, LPVOID source, LONG count);
#else
#define MemCopy memmove
#endif // WIN16

#define GET_BYTE()		(*((BYTE _huge *) (npMCI->lp))++)
#ifdef _WIN32
#define GET_WORD()		(*((UNALIGNED WORD _huge *) (npMCI->lp))++)
#define GET_DWORD()		(*((UNALIGNED DWORD _huge *) (npMCI->lp))++)
#define PEEK_DWORD()		(*((UNALIGNED DWORD _huge *) (npMCI->lp)))
#else
#define GET_WORD()		(*((WORD _huge *) (npMCI->lp))++)
#define GET_DWORD()		(*((DWORD _huge *) (npMCI->lp))++)
#define PEEK_DWORD()		(*((DWORD _huge *) (npMCI->lp)))
#endif
#define SKIP_BYTES(nBytes)	((npMCI->lp) += (nBytes))

#define Now()		(timeGetTime())

void NEAR PASCAL aviTaskCheckRequests(NPMCIGRAPHIC npMCI);

BOOL FAR PASCAL ReadIndex(NPMCIGRAPHIC npMCI);

LONG NEAR PASCAL FindPrevKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lFrame);
LONG NEAR PASCAL FindNextKeyFrame(NPMCIGRAPHIC npMCI, STREAMINFO *psi, LONG lFrame);

//
// try to set the dest or source rect without stopping play.
// called both at stop time and at play time
//
// returns TRUE if stop needed, or else FALSE if all handled.
// lpdwErr is set to a non-zero error if any error occured (in which case
// FALSE will be returned.
//
BOOL TryPutRect(NPMCIGRAPHIC npMCI, DWORD dwFlags, LPRECT lprc, LPDWORD lpdwErr);

// called on worker thread only
DWORD InternalSetVolume(NPMCIGRAPHIC npMCI, DWORD dwVolume);
DWORD InternalGetVolume(NPMCIGRAPHIC npMCI);
DWORD Internal_Update(NPMCIGRAPHIC npMCI, DWORD dwFlags, HDC hdc, LPRECT lprc);

// called on winproc or worker thread
DWORD InternalRealize(NPMCIGRAPHIC npMCI);
BOOL TryStreamUpdate(
    NPMCIGRAPHIC npMCI,
    DWORD dwFlags,
    HDC hdc,
    LPRECT lprc
);


// called to release the synchronous portion of a command
void TaskReturns(NPMCIGRAPHIC npMCI, DWORD dwErr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\avitask.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1995. All rights reserved.

   Title:   avitask.c - Background task that actually manipulates AVI files.

*****************************************************************************/
#include "graphic.h"

STATICFN BOOL OnTask_ProcessRequest(NPMCIGRAPHIC npMCI);
STATICFN void OnTask_WinProcRequests(NPMCIGRAPHIC npMCI, BOOL bPlaying);
STATICFN void OnTask_StopTemporarily(NPMCIGRAPHIC npMCI);
STATICFN void OnTask_RestartAgain(NPMCIGRAPHIC npMCI, BOOL bSetEvent);

STATICFN DWORD InternalPlayStart(
    NPMCIGRAPHIC npMCI,
    DWORD dwFlags,
    long lReqTo,
    long lReqFrom,
    DWORD_PTR dwCallback
);

BOOL TryStreamUpdate(
    NPMCIGRAPHIC npMCI,
    DWORD dwFlags,
    HDC hdc,
    LPRECT lprc
);


/*
 * design overview under construction
 *
 * this file contains the core code for the worker thread that manages
 * playback on request from the user's thread. The worker thread also
 * creates a wndproc thread that owns the default playback window.
 */



// set the error flag and signal completion of request
void
TaskReturns(NPMCIGRAPHIC npMCI, DWORD dwErr)
{
    npMCI->dwReturn = dwErr;

    // clear the hEventSend manual-reset event now that we
    // have processed it
    ResetEvent(npMCI->hEventSend);

#ifdef DEBUG
    // make the message invalid
    npMCI->message = 0;
#endif

    // Wake up the thread that made the request
    DPF2(("...[%x] ok", npMCI->hRequestor));
    SetEvent(npMCI->hEventResponse);
}


/*
 * KillWinProcThread:
 *
 * If the winproc thread exists, send a message to the window to cause
 * the thread to destroy the window and terminate.
 */
STATICFN void KillWinProcThread(NPMCIGRAPHIC npMCI)
{
    // kill the winproc thread and wait for it to die
    if (npMCI->hThreadWinproc) {

	INT_PTR bOK = TRUE;

	if (npMCI->hwndDefault) {
	    // must destroy on creating thread
	    bOK = SendMessage(npMCI->hwndDefault, AVIM_DESTROY, 0, 0);
	    if (!bOK) {
		DPF1(("failed to destroy window: %d", GetLastError()));
	    } else {
		Assert(!IsWindow(npMCI->hwndDefault));
	    }
	}

	// wait for winproc thread to destroy itself when the window goes
	if (bOK) {
	    WaitForSingleObject(npMCI->hThreadWinproc, INFINITE);
	}
	CloseHandle(npMCI->hThreadWinproc);
	npMCI->hThreadWinproc = 0;

    }
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | mciaviTask |  This function is the background task which plays
 *      AVI files. It is called as a result of the call to mmTaskCreate()
 *      in DeviceOpen(). When this function returns, the task is destroyed.
 *
 * @parm DWORD | dwInst | instance data passed to mmCreateTask - contains
 *      a pointer to an instance data block.
 *
 ***************************************************************************/

void FAR PASCAL _LOADDS mciaviTask(DWORD_PTR dwInst)
{
    NPMCIGRAPHIC npMCI;
    DWORD dwThreadId;
    BOOL bExit = FALSE;

    npMCI = (NPMCIGRAPHIC) dwInst;

    // Set this task's error mode to the same as the parent's.
    SetErrorMode(npMCI->uErrorMode);

    DPF1(("Bkgd Task hTask=%04X\n", GetCurrentTask()));

    /* We must set hTask up before changing the TaskState as the UI */
    /* thread can abort as soon as wTaskState is altered            */
    /* NB: this comment is no longer true.  Since the rewrite of    */
    /* mciavi the UI thread will create the task thread and wait    */
    /* until it is explicitly signalled.                            */
    npMCI->hTask = GetCurrentTask();
    npMCI->wTaskState = TASKIDLE;
    npMCI->dwTaskError = 0;


    // create a critical section to protect window-update code between
    // the worker and the winproc thread
    InitializeCriticalSection(&npMCI->HDCCritSec);
    SetNTFlags(npMCI, NTF_DELETEHDCCRITSEC);

    // create a critical section to protect window-request code between
    // the worker and the winproc thread
    InitializeCriticalSection(&npMCI->WinCritSec);
    SetNTFlags(npMCI, NTF_DELETEWINCRITSEC);

    // create an event to wait on for the winproc thread  to tell us that
    // init is ok.
    npMCI->hEventWinProcOK = CreateEvent(NULL, FALSE, FALSE, NULL);

    // also a second event that the winproc signals when it has
    // requests for us
    npMCI->heWinProcRequest = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (!npMCI->hEventWinProcOK || !npMCI->heWinProcRequest) {

	npMCI->dwTaskError = MCIERR_OUT_OF_MEMORY;
	mciaviTaskCleanup(npMCI);
	// Abort this thread.  Our waiter will wake up when our thread
	// handle is signalled.
	return;
    }


    // create a second background task to create the default window and
    // own the winproc.
#if 0
    if (mmTaskCreate((LPTASKCALLBACK) aviWinProcTask,
		     &npMCI->hThreadWinproc,
		     (DWORD)(UINT)npMCI) == 0)
#else
    if (npMCI->hThreadWinproc = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)aviWinProcTask,
				   (LPVOID)npMCI, 0, &dwThreadId ))
#endif
    {
	// wait to be sure that window can be created
	// hThreadWinproc will be signalled if the thread exits.
	if (WaitForMultipleObjects(2, &npMCI->hThreadWinproc,
		FALSE, INFINITE) == WAIT_OBJECT_0) {

	    // thread aborted
	    npMCI->dwTaskError = MCIERR_CREATEWINDOW;

	    // dont wait for this thread in cleanup phase
	    CloseHandle(npMCI->hThreadWinproc);
	    npMCI->hThreadWinproc = 0;
	
	    mciaviTaskCleanup(npMCI);
            // Abort this thread.  Our waiter will wake up when our thread
            // handle is signalled.
	    return;
	}
    } else {
	// could not create winproc thread
	npMCI->dwTaskError = MCIERR_CREATEWINDOW;
	mciaviTaskCleanup(npMCI);
        // Abort this thread.  Our waiter will wake up when our thread
        // handle is signalled.
	return;
    }


    /* Open the file  */

    // open has now been done on app thread -complete init here.
    if (!OpenFileInit(npMCI)) {
        DPF1(("Failed to complete open of AVI file\n"));
	mciaviTaskCleanup(npMCI);
        // Abort this thread.  Our waiter will wake up when our thread
        // handle is signalled.
	return;
    }


    // signal that the open is complete
    TaskReturns(npMCI, 0);


    // now loop waiting for requests and processing them
    // ProcessRequest returns TRUE when it is time to exit

    // hEventSend is manual-reset so we can poll it during play.
    // it is reset in TaskReturns just before we signal the response
    // event.

    // hEventAllDone is set here for bDelayedComplete requests
    // (eg play+wait) when the entire request is satisfied and
    // the worker thread is back to idle. hEventResponse is set in
    // ProcessMessage when the request itself is complete - eg for play, once
    // play has started the event will be set.

    // we can't handle more than one thread potentially blocking on
    // hEventAllDone at one time, so while one thread has made a request
    // that could block on hEventAllDone, no other such request is permitted
    // from other threads. In other words, while one (user) thread has
    // requested a play+wait, other threads can request stop, but not
    // play + wait.

    while (!bExit) {
	DWORD dwObject;

	npMCI->wTaskState = TASKIDLE;

#ifdef DEBUG
	// A complex assertion.  If we have stopped temporarily, then we
	// do not want to go back to sleep.
	if ((npMCI->dwFlags & MCIAVI_UPDATING)
	    && (WAIT_TIMEOUT
		== WaitForMultipleObjects(IDLEWAITFOR, &npMCI->hEventSend, FALSE, 0))
	) {
	    Assert(!"About to go to sleep when we should be restarting!");
	}
#endif

	// the OLE guys are kind enough to create windows on this thread.
	// so we need to handle sent messages here to avoid deadlocks.
	// same is true of the similar loop in BePaused()

    	do {
#ifdef DEBUG
	    if (npMCI->hWaiter) {
		DPF(("About to call MsgWaitForMultipleObjects while hWaiter=%x\n", npMCI->hWaiter));
	    }
#endif
	    dwObject = MsgWaitForMultipleObjects(IDLEWAITFOR, &npMCI->hEventSend,
			FALSE, INFINITE, QS_SENDMESSAGE);

	    DPF2(("Task woken up, dwObject=%x, hWaiter=%x\n", dwObject, npMCI->hWaiter));

	    if (dwObject == WAIT_OBJECT_0 + IDLEWAITFOR) {
		MSG msg;

		// just a single peekmessage with NOREMOVE will
		// process the inter-thread send and not affect the queue
		PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
	    }
	} while (dwObject == WAIT_OBJECT_0 + IDLEWAITFOR);

	switch (dwObject) {
	case WAIT_OBJECT_0:
	    // check that the message has actually been set
	    Assert(npMCI->message != 0);

	    if (npMCI->bDelayedComplete) {
		if (npMCI->hWaiter && (npMCI->hWaiter != npMCI->hRequestor)) {
		    TaskReturns(npMCI, MCIERR_DEVICE_NOT_READY);
		    continue;
		} else {
		    DPF2(("Setting hWaiter to %x\n", npMCI->hRequestor));
		    npMCI->hWaiter = npMCI->hRequestor;
		}
	    }
	
	    DPF2(("get %d [%x]...", npMCI->message, npMCI->hRequestor));

	    // we must reset this event here, or OnTask_PeekRequest will
	    // think it is a new request and will process and
	    // potentially complete it!!
	    ResetEvent(npMCI->hEventSend);

	    bExit = OnTask_ProcessRequest(npMCI);

	    break;

	case WAIT_OBJECT_0+1:
	default:
	    //
	    // winproc request to do something to the task - while idle
	    //
#ifdef DEBUG
            if (dwObject != WAIT_OBJECT_0+1) {
                DPF2(("dwObject == %d\n", dwObject));
            }
#endif
	    Assert(dwObject == WAIT_OBJECT_0+1);
	    OnTask_WinProcRequests(npMCI, FALSE);

	    // this request may have resulted in a temporary stop - so we
	    // need to restart
	    if (npMCI->dwFlags & MCIAVI_UPDATING) {
		OnTask_RestartAgain(npMCI, FALSE);
	    }

	}

        // if we have stopped temporarily to restart with new params,
        // then don't signal completion.  However if we did restart
	// and now everything is quiescent, signal any waiter that happens
	// to be around.  This code is common to both the winproc request
	// and user request legs, as it is possible to stop and restart
	// from both winproc and user requests.
        if (npMCI->hWaiter && (!(npMCI->dwFlags & MCIAVI_UPDATING))) {
	    SetEvent(npMCI->hEventAllDone);
        } else {
	    if (npMCI->hWaiter) {
		DPF2(("Would have Set hEventAllDone, but am updating\n"));
	    }
        }

	// QUERY: if we had processed all the requests, and therefore the
	// two events on which we were waiting had been reset, AND
	// MCIAVI_UPDATING is set (due to a temporary stop) then perhaps
	// we ought to call OnTask_RestartAgain here.  This would mean that
	// all the ugly RestartAgain calls within OnTask_ProcessRequest
	// could be removed.

    }

    // be sure to wake him up before cleanup just in case
    if (npMCI->hWaiter) {
	DPF2(("Setting hEventAllDone before closing\n"));
	SetEvent(npMCI->hEventAllDone);
    }

    // close the window and destroy the winproc thread before any other
    // cleanup, so that paints or realizes don't happen during
    // a partially closed state

    KillWinProcThread(npMCI);

    mciaviCloseFile(npMCI);

    mciaviTaskCleanup(npMCI);
    return;

}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | mciaviTaskCleanup |  called when the background task
 *      is being destroyed.  This is where critical cleanup goes.
 *
 ***************************************************************************/

void FAR PASCAL mciaviTaskCleanup(NPMCIGRAPHIC npMCI)
{
     npMCI->hTask = 0;


    /* Closing the driver causes any currently saved notifications */
    /* to abort. */

    GraphicDelayedNotify(npMCI, MCI_NOTIFY_ABORTED);

    GdiFlush();

    // if still alive, kill the winproc thread and wait for it to die
    KillWinProcThread(npMCI);

    // free winproc <-> worker thread communication resources
    if (npMCI->hEventWinProcOK) {
	CloseHandle(npMCI->hEventWinProcOK);
    }
    if (npMCI->heWinProcRequest) {
	CloseHandle(npMCI->heWinProcRequest);
    }


    if (TestNTFlags(npMCI, NTF_DELETEWINCRITSEC)) {
        DeleteCriticalSection(&npMCI->WinCritSec);
    }

    if (TestNTFlags(npMCI, NTF_DELETEHDCCRITSEC)) {
        DeleteCriticalSection(&npMCI->HDCCritSec);
    }


    //
    //  call a MSVideo shutdown routine.
    //
}







// task message functions


// utility functions called on worker thread
/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | ShowStage | This utility function brings the default stage
 * window to the foreground on play, seek, step and pause commands. It
 * does nothing if the stage window is not the default window
 *
 * @parm NPMCIGRAPHIC | npMCI | near ptr to the instance data
 *
 ***************************************************************************/

void NEAR PASCAL ShowStage(NPMCIGRAPHIC npMCI)
{

    if (!(npMCI->dwFlags & MCIAVI_NEEDTOSHOW))
        return;


    // don't show stage if we are working in response to a winproc
    // update request, as this could cause deadlock and is any case
    // pointless - if the window is now hidden, we can't possibly need
    // to paint it!
    if (npMCI->bDoingWinUpdate) {
	return;
    }


    if ((npMCI->dwFlags & MCIAVI_SHOWVIDEO) &&
	    npMCI->hwndPlayback == npMCI->hwndDefault &&
////////////!(GetWindowLong(npMCI->hwnd, GWL_STYLE) & WS_CHILD) &&
	    (!IsWindowVisible (npMCI->hwndPlayback) ||
		npMCI->hwndPlayback != GetActiveWindow ())) {

		    // if this is our window, then we need to show it
		    // ourselves
		    if (npMCI->hwndDefault == npMCI->hwndPlayback) {
			WinCritCheckOut(npMCI);
			PostMessage(npMCI->hwndPlayback, AVIM_SHOWSTAGE, 0, 0);
		    } else {
			SetWindowPos(npMCI->hwndPlayback, HWND_TOP, 0, 0, 0, 0,
			    SWP_NOMOVE | SWP_NOSIZE |
			    SWP_SHOWWINDOW |
			    (IsWindowVisible(npMCI->hwndPlayback) ? SWP_NOACTIVATE : 0));
		    }
    }

    //
    // if the movie has palette changes we need to make it the active
    // window otherwise the palette animation will not work right
    //
    if ((npMCI->dwFlags & MCIAVI_ANIMATEPALETTE) &&
            !(npMCI->dwFlags & MCIAVI_SEEKING) &&
            !(npMCI->dwFlags & MCIAVI_FULLSCREEN) &&
            !(npMCI->dwFlags & MCIAVI_UPDATING) &&
            npMCI->hwndPlayback == npMCI->hwndDefault &&
            !(GetWindowLong(npMCI->hwndPlayback, GWL_STYLE) & WS_CHILD)) {
        // if this is our window, then we need to show it
        // ourselves
        if (npMCI->hwndDefault == npMCI->hwndPlayback) {

            // force activation even if visible
	    WinCritCheckOut(npMCI);
            PostMessage(npMCI->hwndPlayback, AVIM_SHOWSTAGE, TRUE, 0);
        } else {
            SetActiveWindow(npMCI->hwndPlayback);
        }
    }

    npMCI->dwFlags &= ~(MCIAVI_NEEDTOSHOW);
}


//
// called to save state if we stop temporarily to change something.
// we will restart with OnTask_RestartAgain. Called on worker thread from
// somewhere in aviTaskCheckRequests
STATICFN void OnTask_StopTemporarily(NPMCIGRAPHIC npMCI)
{
    // save old state and flags
    npMCI->oldState = npMCI->wTaskState;
    npMCI->oldTo = npMCI->lTo;
    npMCI->oldFrom = npMCI->lFrom;
    npMCI->oldFlags = npMCI->dwFlags;
    npMCI->oldCallback = (DWORD_PTR) npMCI->hCallback;

    npMCI->dwFlags |= (MCIAVI_UPDATING | MCIAVI_STOP);
    DPF(("StopTemp: OldState=%d, oldTo=%d, oldFrom=%d, oldFlags=%8x\n",
	npMCI->oldState, npMCI->oldTo, npMCI->oldFrom, npMCI->oldFlags));
}


// called from worker thread on completion of a (idle-time) request
// to restart a suspended play function
//
// responsible for signalling hEventResponse once the restart is complete
// (or failed).
STATICFN void OnTask_RestartAgain(NPMCIGRAPHIC npMCI, BOOL bSetEvent)
{
    DWORD dwErr;
    DWORD dwFlags = 0;
    long lFrom;
    UINT wNotify;

    // we're restarting after a temporary stop- so clear the flag.
    // also turn off REPEATING - we might reset this in a moment
    npMCI->dwFlags &= ~(MCIAVI_UPDATING | MCIAVI_REPEATING);

    // Turn on the repeating flag if it was originally set
    npMCI->dwFlags |= (npMCI->oldFlags & MCIAVI_REPEATING);

    if (npMCI->oldFlags & MCIAVI_REVERSE) {
	dwFlags |= MCI_DGV_PLAY_REVERSE;
    }

    switch (npMCI->oldState) {
	case TASKPAUSED:
	    // get to the old From frame and pause when you get there
	    npMCI->dwFlags |= MCIAVI_PAUSE;  // Make sure we end up paused
	    // NOTE: InternalPlayStart no longer clears the PAUSE flag
	    lFrom = npMCI->oldFrom;
	    break;

        case TASKCUEING:

	    // npMCI->dwFlags should still say whether to pause at
	    // end of cueing or play
	    lFrom = npMCI->oldFrom;
	    dwFlags |= MCI_TO;	  // Stop when we get to the right frame
	    break;

        case TASKPLAYING:

	    lFrom = npMCI->lCurrentFrame;
	    dwFlags |= MCI_TO;
	    break;

        default:

	    DPF(("asked to restart to idle (%d) state", npMCI->oldState));
	    if (bSetEvent) {
		TaskReturns(npMCI, 0);
	    }
	    return;
    }


    DPF2(("RestartAgain calling InternalPlayStart, flags=%8x\n",dwFlags));
    dwErr = InternalPlayStart(npMCI, dwFlags,
		npMCI->oldTo, lFrom, npMCI->oldCallback);

    if (bSetEvent && dwErr) {
	TaskReturns(npMCI, dwErr);
    }

    if (!dwErr) {
	wNotify = mciaviPlayFile(npMCI, bSetEvent);

	// if we stopped to pick up new params without actually completing the
	// the play (OnTask_StopTemporarily) then MCIAVI_UPDATING will be set

	if (! (npMCI->dwFlags & MCIAVI_UPDATING)) {
	    // perform any notification
	    if (wNotify != MCI_NOTIFY_FAILURE) {
		GraphicDelayedNotify(npMCI, wNotify);
	    }
	}
    }
}


/***************************************************************************
 *
 *  IsScreenDC() - returns true if the passed DC is a DC to the screen.
 *                 NOTE this checks for a DCOrg != 0, bitmaps always have
 *                 a origin of (0,0)  This will give the wrong info a
 *                 fullscreen DC.
 *
 ***************************************************************************/

#ifndef _WIN32
#define IsScreenDC(hdc)     (GetDCOrg(hdc) != 0L)
#else
INLINE BOOL IsScreenDC(HDC hdc)
{
    return (WindowFromDC(hdc) != NULL);
}
#endif



// called from several task side functions to initiate play
// when stopped. All you need to do is call mciaviPlayFile
// once this function returns
STATICFN DWORD
InternalPlayStart(
    NPMCIGRAPHIC npMCI,
    DWORD dwFlags,
    long lReqTo,
    long lReqFrom,
    DWORD_PTR dwCallback
)
{
    long lTo, lFrom;
    DWORD dwRet;

    if (dwFlags & (MCI_MCIAVI_PLAY_FULLSCREEN | MCI_MCIAVI_PLAY_FULLBY2)) {
	// do nothing here - handled in fullproc
    } else {
	if (!IsWindow(npMCI->hwndPlayback)) {
	    return MCIERR_NO_WINDOW;
	}

	npMCI->dwFlags |= MCIAVI_NEEDTOSHOW;
    }


    /* Range checks : 0 < 'from' <= 'to' <= last frame */

    if (dwFlags & MCI_TO) {
	lTo = lReqTo;

        if (lTo < 0L || lTo > npMCI->lFrames) {
	    return MCIERR_OUTOFRANGE;
	}
    } else {
        if (dwFlags & MCI_DGV_PLAY_REVERSE)
            lTo = 0;
        else
            lTo = npMCI->lFrames;

        dwFlags |= MCI_TO;
    }


    // if no from setting, then get current position
    if (dwFlags & MCI_FROM) {
	lFrom = lReqFrom;

        if (lFrom < 0L || lFrom > npMCI->lFrames) {
	    return MCIERR_OUTOFRANGE;
	}
    } else if (dwRet = InternalGetPosition(npMCI, &lFrom)) {
    	return dwRet;
    }

    /* check 'to' and 'from' relationship.  */
    if (lTo < lFrom)
	dwFlags |= MCI_DGV_PLAY_REVERSE;

    if ((lFrom < lTo) && (dwFlags & MCI_DGV_PLAY_REVERSE)) {
	return MCIERR_OUTOFRANGE;
    }

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST) {
	return 0;
    }


    npMCI->lFrom = lFrom;

	
    if (dwFlags & MCI_DGV_PLAY_REPEAT) {
	/* If from position isn't given, repeat from either the beginning or
	** end of file as appropriate.
	*/
	npMCI->lRepeatFrom =
	    (dwFlags & MCI_FROM) ? lFrom :
		((dwFlags & MCI_DGV_PLAY_REVERSE) ? npMCI->lFrames : 0);
    }


    /* if not already playing, start the task up. */

    /* First, figure out what mode to use. */
    if (dwFlags & (MCI_MCIAVI_PLAY_FULLSCREEN | MCI_MCIAVI_PLAY_FULLBY2)) {
        if (npMCI->rcDest.right - npMCI->rcDest.left >
            npMCI->rcMovie.right - npMCI->rcMovie.left)
	    dwFlags |= MCI_MCIAVI_PLAY_FULLBY2;
	
        if ((dwFlags & MCI_MCIAVI_PLAY_FULLBY2) &&
                (npMCI->rcMovie.right  <= 160) &&
                (npMCI->rcMovie.bottom <= 120)) {
            npMCI->dwFlags |= MCIAVI_ZOOMBY2;
	} else {
	    npMCI->dwFlags &= ~(MCIAVI_ZOOMBY2);
	}


	if ((dwFlags & MCI_WAIT) && !(npMCI->dwFlags & MCIAVI_REPEATING))
	    npMCI->dwFlags |= MCIAVI_NOBREAK;
	else
	    npMCI->dwFlags &= ~(MCIAVI_NOBREAK);
		
	npMCI->dwFlags |= MCIAVI_FULLSCREEN;
    } else {
	npMCI->dwFlags &= ~(MCIAVI_FULLSCREEN);
    }


    // Make sure flags are cleared if they should be
    //npMCI->dwFlags &= ~(MCIAVI_PAUSE | MCIAVI_CUEING | MCIAVI_REVERSE);
    // PAUSE is NOT turned off, otherwise we cannot RestartAgain to a
    // paused state.
    npMCI->dwFlags &= ~(MCIAVI_CUEING | MCIAVI_REVERSE);

    if (dwFlags & MCI_DGV_PLAY_REPEAT) {
	npMCI->dwFlags |= MCIAVI_REPEATING;
    }

    /* Don't set up notify until here, so that the seek won't make it happen*/
    // idle so no current notify
    if (dwFlags & MCI_NOTIFY) {
        GraphicSaveCallback(npMCI, (HANDLE) (UINT_PTR)dwCallback);
    }


    if (lTo > npMCI->lFrames)
        lTo = npMCI->lFrames;

    if (lTo < 0)
        lTo = 0;

    if (dwFlags & MCI_TO)
	npMCI->lTo = lTo;

    DPF2(("InternalPlayStart  Flags=%8x, ReqTo=%d  ReqFrom=%d   To=%d\n",
	    dwFlags, lReqTo, lReqFrom, lTo));

    if (dwFlags & MCI_DGV_PLAY_REVERSE)
	npMCI->dwFlags |= MCIAVI_REVERSE;


    if (npMCI->dwFlags & MCIAVI_NEEDTOSHOW) {
	ShowStage(npMCI);
	//
	// leave this set so the play code knows this is a "real" play
	// coming from the user, not an internal play/stop
	//
	// if the window needs shown we want to do it here if we can
	// not in the background task.
	//
	npMCI->dwFlags |= MCIAVI_NEEDTOSHOW;
    }


    return 0;


}


// called at task idle time to initiate a play request -
// the worker thread is NOT busy playing, seeking, cueing or paused
// at this point.
//
// responsible for calling TaskReturns() appropriately.
void
OnTask_Play(NPMCIGRAPHIC npMCI)
{

    DWORD dwRet;
    DWORD dwMCIFlags = npMCI->dwParamFlags;
    LPMCI_DGV_PLAY_PARMS lpPlay = (LPMCI_DGV_PLAY_PARMS)npMCI->lParam;
    long lTo, lFrom;
    UINT wNotify;

    if (lpPlay != NULL) {
	lTo = lpPlay->dwTo;
	lFrom = lpPlay->dwFrom;
    } else {
	dwMCIFlags &= ~(MCI_TO | MCI_FROM);
    }

    npMCI->dwFlags &= ~MCIAVI_REPEATING;

    // need to convert to frames before calling InternalPlayStart
    if (dwMCIFlags & MCI_TO) {
	lTo = ConvertToFrames(npMCI, lTo);
    }
    if (dwMCIFlags & MCI_FROM) {
	lFrom = ConvertToFrames(npMCI, lFrom);
    }

    dwRet = InternalPlayStart(npMCI, dwMCIFlags, lTo, lFrom,
	    	npMCI->dwReqCallback);

    if (dwRet || (dwMCIFlags & MCI_TEST)) {
	TaskReturns(npMCI, dwRet);
	return;
    }

    // actually play the file
    wNotify = mciaviPlayFile(npMCI, TRUE);

    // if we stopped to pick up new params without actually completing the
    // the play (OnTask_StopTemporarily) then MCIAVI_UPDATING will be set

    if (! (npMCI->dwFlags & MCIAVI_UPDATING)) {
	// perform any notification
	if (wNotify != MCI_NOTIFY_FAILURE) {
	    GraphicDelayedNotify(npMCI, wNotify);
	}
    }

    return;
}

//
// called to process a play request when play is actually happening.
// if parameters can be adjusted without stopping the current play,
// returns FALSE. Also if the request is rejected (and hEventResponse
// signalled) because of some error, returns FALSE indicating no need to
// stop. Otherwise returns TRUE, so that OnTask_Play() will
// be called after stopping the current play.
BOOL
OnTask_PlayDuringPlay(NPMCIGRAPHIC npMCI)
{

    DWORD dwFlags = npMCI->dwParamFlags;
    LPMCI_DGV_PLAY_PARMS lpPlay = (LPMCI_DGV_PLAY_PARMS)npMCI->lParam;
    long lTo, lFrom;
    DWORD dwRet;


    // since this is a real play request coming from the user we need
    // to show the stage window
    if (dwFlags & (MCI_MCIAVI_PLAY_FULLSCREEN | MCI_MCIAVI_PLAY_FULLBY2)) {
	// do nothing here - handled in fullproc
    } else {
	npMCI->dwFlags |= MCIAVI_NEEDTOSHOW;
    }

    // can be called with null lpPlay (in the resume case)
    // in this case, to and from will be left unchanged
    // if you pass lpPlay, then to and from will be set to defaults even
    // if you don't set MCI_TO and MCI_FROM

    if (lpPlay == NULL) {
	dwFlags &= ~(MCI_TO | MCI_FROM);
    }


    /* Range checks : 0 < 'from' <= 'to' <= last frame */

    if (dwFlags & MCI_TO) {
	lTo = ConvertToFrames(npMCI, lpPlay->dwTo);

        if (lTo < 0L || lTo > npMCI->lFrames) {
	    TaskReturns(npMCI, MCIERR_OUTOFRANGE);
	    return FALSE;
	}
    } else {
	// don't touch to and from for resume
	if (lpPlay) {
	    if (dwFlags & MCI_DGV_PLAY_REVERSE)
		lTo = 0;
	    else
		lTo = npMCI->lFrames;

	    dwFlags |= MCI_TO;
	} else {
	    lTo = npMCI->lTo;
	}
    }


    // if no from setting, then get current position
    if (dwFlags & MCI_FROM) {
	lFrom = ConvertToFrames(npMCI, lpPlay->dwFrom);

        if (lFrom < 0L || lFrom > npMCI->lFrames) {
	    TaskReturns(npMCI, MCIERR_OUTOFRANGE);
	    return FALSE;
	}
    } else if (dwRet = InternalGetPosition(npMCI, &lFrom)) {
	TaskReturns(npMCI, dwRet);
	return FALSE;
    }

    /* check 'to' and 'from' relationship.  */
    if (lTo < lFrom)
	dwFlags |= MCI_DGV_PLAY_REVERSE;

    if ((lFrom < lTo) && (dwFlags & MCI_DGV_PLAY_REVERSE)) {
	TaskReturns(npMCI, MCIERR_OUTOFRANGE);
	return FALSE;
    }

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST) {
	TaskReturns(npMCI, 0L);
	return FALSE;
    }

    /* We want any previous playing to be aborted if and only if a 'from'
    ** parameter is specified.  If only a new 'to' parameter is specified,
    ** we can just change the 'to' value, and play will stop at the
    ** proper time.
    **
    ** Also abort the play if we have lost the audio.  An explicit play
    ** command has been issued and we should try and get the audio again.
    */

    // if it's new from position or we are seeking to the wrong stop,
    // or we are reversing the direction of play,
    // or we had lost the audio
    // then we need to stop.
    if (   (dwFlags & MCI_FROM)
	|| (dwFlags & (MCI_MCIAVI_PLAY_FULLSCREEN | MCI_MCIAVI_PLAY_FULLBY2))
	|| ((npMCI->dwFlags & MCIAVI_SEEKING) && (npMCI->lTo != lFrom))
	|| (npMCI->wTaskState == TASKCUEING)
	|| (npMCI->dwFlags & MCIAVI_LOSTAUDIO)
	|| (((npMCI->dwFlags & MCIAVI_REVERSE) != 0) != ((dwFlags & MCI_DGV_PLAY_REVERSE) != 0))
	) {

	// we can't continue the play - we have to stop, and then pick up
	// this request again in OnTask_Play().

	// this will abort the current notify
	return TRUE;
    }

    // ok to continue the current play with revised params.

    // set the from position correctly
    npMCI->lFrom = lFrom;


    /* If we're changing the "to" position, abort any pending notify. */
    if (lTo != npMCI->lTo) {
	GraphicDelayedNotify (npMCI, MCI_NOTIFY_ABORTED);
    }
	
    /* Don't set up notify until here, so that the seek won't make it happen*/
    if (dwFlags & MCI_NOTIFY) {
        GraphicSaveCallback(npMCI, (HANDLE) (UINT_PTR)npMCI->dwReqCallback);
    }

    // Make sure flags are cleared if they should be
    npMCI->dwFlags &= ~(MCIAVI_PAUSE | MCIAVI_CUEING | MCIAVI_REVERSE | MCIAVI_LOSEAUDIO);

    /* Set up the 'repeat' flags */
    npMCI->dwFlags &= ~(MCIAVI_REPEATING);

    if (dwFlags & MCI_DGV_PLAY_REPEAT) {
	/* If from position isn't given, repeat from either the beginning or
	** end of file as appropriate.
	**
	** if no lpPlay is given, then don't change repeatfrom
	*/

	if (lpPlay) {
	    npMCI->lRepeatFrom =
		(dwFlags & MCI_FROM) ? lFrom :
		    ((dwFlags & MCI_DGV_PLAY_REVERSE) ? npMCI->lFrames : 0);
	}
	npMCI->dwFlags |= MCIAVI_REPEATING;
    }

    /* if not already playing, start the task up. */

    if (lTo > npMCI->lFrames)
        lTo = npMCI->lFrames;

    if (lTo < 0)
        lTo = 0;

    if (dwFlags & MCI_TO)
	npMCI->lTo = lTo;

    if (dwFlags & MCI_DGV_PLAY_REVERSE)
	npMCI->dwFlags |= MCIAVI_REVERSE;

    if (npMCI->dwFlags & MCIAVI_NEEDTOSHOW) {
	ShowStage(npMCI);
	//
	// leave this set so the play code knows this is a "real" play
	// coming from the user, not an internal play/stop
	//
	// if the window needs shown we want to do it here if we can
	// not in the background task.
	//
	npMCI->dwFlags |= MCIAVI_NEEDTOSHOW;
    }


    //everything adjusted - tell user ok and return to playing
    TaskReturns(npMCI, 0);
    return FALSE;

}

void OnTask_Realize(NPMCIGRAPHIC npMCI)
{
    DWORD dw;

    EnterHDCCrit(npMCI);
    dw = InternalRealize(npMCI);
    LeaveHDCCrit(npMCI);
    TaskReturns(npMCI, dw);

}

DWORD InternalRealize(NPMCIGRAPHIC npMCI)
{
    BOOL fGetDC;
    BOOL fPalChanged;
#ifndef _WIN32
    BOOL fAlreadyDoneThat;
#endif

    HDCCritCheckIn(npMCI);
    if (npMCI->dwFlags & MCIAVI_WANTMOVE)
	CheckWindowMove(npMCI, TRUE);

#ifndef _WIN32
    if (fAlreadyDoneThat = (BOOL)(npMCI->dwFlags & MCIAVI_UPDATING)) {
	DPF(("Re-entering InternalRealize - but we don't care, npMCI=%8x\n",npMCI));
    }
#endif

    if (!IsTask(npMCI->hTask))
        return(0L);

    if (fGetDC = (npMCI->hdc == NULL)) {
	npMCI->hdc = GetDC(npMCI->hwndPlayback);
        Assert(npMCI->hdc != NULL);
    }

#ifndef _WIN32
    // this only prevents playback window alignment - which is not done
    // for NT anyway
    npMCI->dwFlags |= MCIAVI_UPDATING;
#endif

    fPalChanged = PrepareDC(npMCI) > 0;

#ifndef _WIN32
    if (!fAlreadyDoneThat)
        npMCI->dwFlags &= ~MCIAVI_UPDATING;
#endif

    if (fGetDC) {
        UnprepareDC(npMCI);
        ReleaseDC(npMCI->hwndPlayback, npMCI->hdc);
	npMCI->hdc = NULL;
	HDCCritCheckIn(npMCI);
    }

    if (fPalChanged)
        InvalidateRect(npMCI->hwndPlayback, &npMCI->rcDest, TRUE);

    CheckIfActive(npMCI);

    return 0L;
}



void OnTask_Update(NPMCIGRAPHIC npMCI)
{
    RECT    rc;
    LPMCI_DGV_UPDATE_PARMS lpParms = (LPMCI_DGV_UPDATE_PARMS) npMCI->lParam;
    DWORD dwFlags = npMCI->dwFlags;
    DWORD dwErr;

    rc.left   = lpParms->ptOffset.x;
    rc.top    = lpParms->ptOffset.y;
    rc.right  = lpParms->ptOffset.x + lpParms->ptExtent.x;
    rc.bottom = lpParms->ptOffset.y + lpParms->ptExtent.y;

    dwErr = Internal_Update (npMCI, dwFlags, lpParms->hDC, (dwFlags & MCI_DGV_RECT) ? &rc : NULL);

    //now, where were we ?
    if (!dwErr && (npMCI->dwFlags & MCIAVI_UPDATING)) {
	OnTask_RestartAgain(npMCI, TRUE);
    } else {
	TaskReturns(npMCI, dwErr);
    }
}



BOOL OnTask_UpdateDuringPlay(NPMCIGRAPHIC npMCI)
{
    RECT    userrc, rc;
    LPMCI_DGV_UPDATE_PARMS lpParms = (LPMCI_DGV_UPDATE_PARMS) npMCI->lParam;
    DWORD dwFlags = npMCI->dwFlags;
    HDC hdc = lpParms->hDC;

    userrc.left   = lpParms->ptOffset.x;
    userrc.top    = lpParms->ptOffset.y;
    userrc.right  = lpParms->ptOffset.x + lpParms->ptExtent.x;
    userrc.bottom = lpParms->ptOffset.y + lpParms->ptExtent.y;

    //
    // mark the proper streams dirty, this will set the proper update flags
    //
    if (hdc)
        GetClipBox(hdc, &rc);
    else
        rc = npMCI->rcDest;

    if (dwFlags & MCI_DGV_RECT)
        IntersectRect(&rc, &rc, &userrc);

    StreamInvalidate(npMCI, &rc);

    //
    // if they are drawing to the screen *assume* they wanted to set
    // the MCI_DGV_UPDATE_PAINT flag
    //
    if (IsScreenDC(hdc))
        dwFlags |= MCI_DGV_UPDATE_PAINT;


    // we are playing now (we have a dc). just realize
    // the palette and set the update flag
    // unless we are painting to a memory dc.
    //
    // if we are paused, fall through so we can handle the case where
    // a update fails
    //
    // !!!mabey we should rework this code to do this even if playing?
    //
    if (npMCI->hdc &&
            (dwFlags & MCI_DGV_UPDATE_PAINT) &&
            (npMCI->wTaskState != TASKPAUSED) &&

            //!!! what is this?
            ((npMCI->wTaskState != TASKCUEING) ||
                (npMCI->lCurrentFrame <= 1) ||
                (npMCI->lCurrentFrame > npMCI->lRealStart - 30)) ) {

        Assert(npMCI->wTaskState == TASKPLAYING ||
               npMCI->wTaskState == TASKCUEING);

	EnterHDCCrit(npMCI);
	UnprepareDC(npMCI);
        PrepareDC(npMCI);  // re-prepare
	LeaveHDCCrit(npMCI);

	// all ok - no need for stop.
	TaskReturns(npMCI, 0);
	return FALSE;
    }

    // try to use DoStreamUpdate - if this fails, we need to stop
    if (TryStreamUpdate(npMCI, dwFlags, hdc,
	(dwFlags & MCI_DGV_RECT) ? &userrc : NULL)) {

	    // we are playing and so have an hdc. However, we have just
	    // done a update to another hdc. switching back to the original
	    // hdc without this will fail
	    PrepareDC(npMCI);

	    TaskReturns(npMCI, 0);
	    return FALSE;
    }

    // otherwise we need to stop to do this

    // indicate that we should restart after doing this, and
    // save enough state to do this
    OnTask_StopTemporarily(npMCI);

    return TRUE;
}


// attempt repaint using DoStreamUpdate - if this fails (eg wrong frame)
// then you need to use mciaviPlayFile to do it (to/from same frame)
BOOL
TryStreamUpdate(
    NPMCIGRAPHIC npMCI,
    DWORD dwFlags,
    HDC hdc,
    LPRECT lprc
)
{
    HDC hdcSave;
    BOOL f;

    //
    // are we updating to a memory bitmap?
    //
    if (!(dwFlags & MCI_DGV_UPDATE_PAINT))
        npMCI->dwFlags |= MCIAVI_UPDATETOMEMORY;

    //
    // if we are using a draw device (or are in stupid mode) make sure we seek
    // to the frame we want and dont use the current decompress buffer that
    // may not be correct.
    //
    if ((npMCI->dwFlags & MCIAVI_UPDATETOMEMORY) ||
        (npMCI->dwFlags & MCIAVI_STUPIDMODE)) {
        DPF(("DeviceUpdate: decompress buffer may be bad, ignoring it....\n"));
	npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
    }

    //
    // honor the passed rect
    //
    if (lprc) {
	Assert(hdc);
        SaveDC(hdc);
        IntersectClipRect(hdc, lprc->left, lprc->top,
                               lprc->right, lprc->bottom);
    }

    //
    //  Always do an Update, if the update succeeds and we are at the right
    //  frame keep it.
    //
    //  if it fails or the frame is wrong need to re-draw using play.
    //
    //  we need to do this because even though lFrameDrawn is a valid
    //  frame the draw handler may fail a update anyway (for example
    //  when decompressing to screen) so lFrameDrawn can be bogus and
    //  we do not know it until we try it.
    //


    if (npMCI->lFrameDrawn <= npMCI->lCurrentFrame &&
        npMCI->lFrameDrawn >= 0) {

        DPF2(("Update: redrawing frame %ld, current = %ld.\n", npMCI->lFrameDrawn, npMCI->lCurrentFrame));

	/* Save the DC, in case we're playing, but need to update
	** to a memory bitmap.
	*/

	// worker thread must hold critsec round all drawing
        EnterHDCCrit(npMCI);
	hdcSave = npMCI->hdc;
        npMCI->hdc = hdc;

	/* Realize the palette here, because it will cause strange
        ** things to happen if we do it in the task.
        */
	if (npMCI->dwFlags & MCIAVI_NEEDDRAWBEGIN) {
	    DrawBegin(npMCI, NULL);

	    if (npMCI->lFrameDrawn < npMCI->lVideoStart) {
		npMCI->hdc = hdcSave;
		HDCCritCheckIn(npMCI);
		npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
                LeaveHDCCrit(npMCI);
		return FALSE;	// need to use play
	    }
	}

        PrepareDC(npMCI);        // make sure the palette is in there

        f = DoStreamUpdate(npMCI, FALSE);

        UnprepareDC(npMCI);      // be sure to put things back....
	Assert(hdc == npMCI->hdc);
	HDCCritCheckIn(npMCI);
        npMCI->hdc = hdcSave;
	LeaveHDCCrit(npMCI);

        if (!f) {
            DPF(("DeviceUpdate failed! invalidating lFrameDrawn\n"));
            npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
	    Assert(!lprc);
        }
        else if (npMCI->lFrameDrawn >= npMCI->lCurrentFrame-1) {
	    if (lprc) {
		RestoreDC(hdc, -1);
	    }
	
	    npMCI->dwFlags &= ~(MCIAVI_UPDATING|MCIAVI_UPDATETOMEMORY);
	
	    if (npMCI->dwFlags & MCIAVI_NEEDUPDATE) {
		DPF(("**** we did a DeviceUpdate but still dirty?\n"));
	    }
	
	    return TRUE;
        }
	//return FALSE;  Drop through
    }

    return FALSE;

}

// called in stopped case to paint from OnTask_Update, and
// also on winproc thread (when stopped). Not called during play.

DWORD Internal_Update(NPMCIGRAPHIC npMCI, DWORD dwFlags, HDC hdc, LPRECT lprc)
{
    DWORD   dwErr = 0L;
    HWND    hCallback;
    HCURSOR hcurPrev;
    RECT    rc;
    LONG lFrameDrawn;


    if (npMCI->dwFlags & MCIAVI_WANTMOVE)
	CheckWindowMove(npMCI, TRUE);

    //
    // see if we are the active movie now.
    //
    CheckIfActive(npMCI);

    //
    // mark the proper streams dirty, this will set the proper update flags
    //
    if (hdc)
        GetClipBox(hdc, &rc);
    else
        rc = npMCI->rcDest;

    if (lprc)
        IntersectRect(&rc, &rc, lprc);

    StreamInvalidate(npMCI, &rc);

    //
    // if they are drawing to the screen *assume* they wanted to set
    // the MCI_DGV_UPDATE_PAINT flag
    //
    if (IsScreenDC(hdc))
        dwFlags |= MCI_DGV_UPDATE_PAINT;

    lFrameDrawn = npMCI->lFrameDrawn;       // save this for compare


    // try to use DoStreamUpdate
    if (TryStreamUpdate(npMCI, dwFlags, hdc, lprc)) {
	return 0;
    }

    // no - need to use Play

    // note we are already stopped at this point.


    //
    // the problem this tries to fix is the following:
    // sometimes we are at N+1 but frame N is on the
    // screen, if we now play to N+1 a mismatch will occur
    //
    if (lFrameDrawn >= 0 && lFrameDrawn == npMCI->lCurrentFrame-1)
	npMCI->lFrom = npMCI->lTo = lFrameDrawn;
    else
	npMCI->lFrom = npMCI->lTo = npMCI->lCurrentFrame;

    /* Realize the palette here, because it will cause strange
    ** things to happen if we do it in the task.
    */
    EnterHDCCrit(npMCI);
    npMCI->hdc = hdc;
    PrepareDC(npMCI);        // make sure the palette is in there
    LeaveHDCCrit(npMCI);

    hcurPrev =  SetCursor(LoadCursor(NULL, IDC_WAIT));

    /* Hide any notification, so it won't get sent... */
    hCallback = npMCI->hCallback;
    npMCI->hCallback = NULL;

    mciaviPlayFile(npMCI, FALSE);

    npMCI->hCallback = hCallback;

    // We may have just yielded.. so only set the cursor back if we
    // are still the wait cursor.
    if (hcurPrev) {
        hcurPrev = SetCursor(hcurPrev);
        if (hcurPrev != LoadCursor(NULL, IDC_WAIT))
            SetCursor(hcurPrev);
    }

    //HDCCritCheckIn(npMCI) ??? This is an atomic operation - and
    //                          why are we setting it to NULL here ??
    npMCI->hdc = NULL;

    if (lprc) {
        RestoreDC(hdc, -1);
    }
    npMCI->dwFlags &= ~(MCIAVI_UPDATETOMEMORY);


    if (npMCI->dwFlags & MCIAVI_NEEDUPDATE) {
        DPF(("**** we did a DeviceUpdate but still dirty?\n"));
    }

    return dwErr;
}


void
OnTask_PauseDuringPlay(NPMCIGRAPHIC npMCI)
{
    DWORD dwFlags = npMCI->dwParamFlags;
    DPF3(("Pause during play\n"));

    // no pause during cueing
    if (npMCI->wTaskState == TASKCUEING) {
	// leave event sent - wait till later
	return;
    }

    // save the notify
    if (dwFlags & MCI_NOTIFY) {
        GraphicSaveCallback(npMCI, (HANDLE) (UINT_PTR)npMCI->dwReqCallback);
    }

    // what about delayed completion pause ?
    // especially "pause" followed by "pause wait"
    if (dwFlags & MCI_WAIT) {
        // indicate hEventAllDone should be set on Pause, not
        // on idle (ie at final stop)
	npMCI->dwFlags |= MCIAVI_WAITING;
    }

    if (npMCI->wTaskState == TASKPAUSED) {
	// all done already
	if (dwFlags & MCI_NOTIFY) {
	    GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUCCESSFUL);
	}

    } else if (npMCI->wTaskState == TASKPLAYING) {

	// remember to pause
        npMCI->dwFlags |= MCIAVI_PAUSE;

	if (dwFlags & MCI_NOTIFY) {
	    // remember to send a notify when we pause
	    npMCI->dwFlags |= MCIAVI_CUEING;
    	}
    }

    TaskReturns(npMCI, 0);
}

void
OnTask_Cue(NPMCIGRAPHIC npMCI, DWORD dwFlags, long lTo)
{
    UINT wNotify;

    DPF3(("OnTask_Cue: dwFlags=%8x, To=%d\n", dwFlags, lTo));

    GraphicDelayedNotify(npMCI, MCI_NOTIFY_ABORTED);

    if (dwFlags & MCI_NOTIFY) {
        GraphicSaveCallback(npMCI, (HANDLE) (UINT_PTR)npMCI->dwReqCallback);
    }

    /* Clear the 'repeat' flags */
    npMCI->dwFlags &= ~(MCIAVI_REPEATING);


    if (dwFlags & MCI_TO) {
	npMCI->lFrom = lTo;
    } else if (npMCI->wTaskState == TASKIDLE) {
	npMCI->lFrom = npMCI->lCurrentFrame;
    }

    /* If we're ever resumed, we want to go to the end of the file. */
    npMCI->lTo = npMCI->lFrames;

    npMCI->dwFlags |= MCIAVI_PAUSE | MCIAVI_CUEING;

    if (dwFlags & MCI_WAIT) {
	npMCI->dwFlags |= MCIAVI_WAITING;
    }

    wNotify = mciaviPlayFile(npMCI, TRUE);

    // if we stopped to pick up new params without actually completing the
    // the play (OnTask_StopTemporarily) then MCIAVI_UPDATING will be set

    if (! (npMCI->dwFlags & MCIAVI_UPDATING)) {
	// perform any notification
	if (wNotify != MCI_NOTIFY_FAILURE) {
	    GraphicDelayedNotify(npMCI, wNotify);
	}
    }
}



BOOL
OnTask_CueDuringPlay(NPMCIGRAPHIC npMCI)
{
    DWORD dw = 0L;
    DWORD dwFlags = npMCI->dwParamFlags;
    long lTo = (LONG) npMCI->lParam;

    DPF3(("OnTask_CueDuringPlay\n"));

    if (npMCI->dwFlags & MCIAVI_SEEKING) {
	/* We're currently seeking, so we have to start again to get audio
	** to work.
	*/
	return TRUE;
    }


    if (dwFlags & MCI_TO) {
	return TRUE;
    }

    /* Clear the 'repeat' flags */
    npMCI->dwFlags &= ~(MCIAVI_REPEATING);

    GraphicDelayedNotify(npMCI, MCI_NOTIFY_ABORTED);

    if (dwFlags & MCI_NOTIFY) {
        GraphicSaveCallback(npMCI, (HANDLE) (UINT_PTR)npMCI->dwReqCallback);
    }

    /* If we're ever resumed, we want to go to the end of the file. */
    npMCI->lTo = npMCI->lFrames;

    if (npMCI->wTaskState == TASKPAUSED) {
	/* We're already paused at the right place, so
	** that means we did it.
	*/
	if (dwFlags & MCI_NOTIFY)
	    GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUCCESSFUL);

	// complete completed
	TaskReturns(npMCI, 0);

	// delayed completion is also done!
	if (dwFlags & MCI_WAIT) {
	    SetEvent(npMCI->hEventAllDone);
	}

	// don't drop through to the second TaskReturns() below!
	return FALSE;

    } else if ((npMCI->wTaskState == TASKCUEING) ||
	    	 (npMCI->wTaskState == TASKPLAYING)) {

	// ask for pause on completion of cueing/playing,
	// and for notify and hEventAllDone when pause reached

	npMCI->dwFlags |= MCIAVI_PAUSE | MCIAVI_CUEING;

	if (dwFlags & MCI_WAIT) {
	    npMCI->dwFlags |= MCIAVI_WAITING;
	}


    } else {
	TaskReturns (npMCI, MCIERR_NONAPPLICABLE_FUNCTION);
	return FALSE;
    }

    TaskReturns(npMCI, 0);
    return FALSE;
}


void OnTask_Seek(NPMCIGRAPHIC npMCI)
{
    UINT wNotify;
    DWORD dwFlags = npMCI->dwParamFlags;
    long lTo = (long) npMCI->lParam;

    DPF3(("DeviceSeek - to frame %d (CurrentFrame==%d)  Current State is %d\n", lTo, npMCI->lCurrentFrame, npMCI->wTaskState));
    /* The window will be shown by the play code. */

    // task state is now TASKIDLE and blocked

    if (dwFlags & MCI_NOTIFY) {
        GraphicSaveCallback(npMCI, (HANDLE) (UINT_PTR)npMCI->dwReqCallback);
    }

    /* Clear the 'repeat' flags */
    npMCI->dwFlags &= ~(MCIAVI_REPEATING);



    if (npMCI->lCurrentFrame != lTo) {

	/* Essentially, we are telling the task: play just frame <lTo>.
	** When it gets there, it will update the screen for us.
	*/
	npMCI->lFrom = npMCI->lTo = lTo;

	wNotify = mciaviPlayFile(npMCI, TRUE);

	// if we stopped to pick up new params without actually completing the
	// the play (OnTask_StopTemporarily) then MCIAVI_UPDATING will be set

	if (! (npMCI->dwFlags & MCIAVI_UPDATING)) {
	    // perform any notification
	    if (wNotify != MCI_NOTIFY_FAILURE) {
		GraphicDelayedNotify(npMCI, wNotify);
	    }
	}

    } else {
	// task complete
	TaskReturns(npMCI, 0);

	/* Be sure the window gets shown and the notify gets sent,
	** even though we don't have to do anything.
	*/
	if (npMCI->dwFlags & MCIAVI_NEEDTOSHOW)
	    ShowStage(npMCI);

	if (dwFlags & MCI_NOTIFY)
	    GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUCCESSFUL);	
    }
}

OnTask_SeekDuringPlay(NPMCIGRAPHIC npMCI)
{
    long lTo = (long) npMCI->lParam;
    DWORD dwFlags = npMCI->dwParamFlags;


    DPF3(("DeviceSeek - to frame %d (CurrentFrame==%d)  Current State is %d\n", lTo, npMCI->lCurrentFrame, npMCI->wTaskState));
    /* The window will be shown by the play code. */


    /* If we can just shorten a previous seek, do it. */
    if ((npMCI->wTaskState == TASKCUEING) &&
	    (npMCI->dwFlags & MCIAVI_SEEKING) &&
	    (npMCI->lCurrentFrame <= lTo) &&
	    (npMCI->lTo >= lTo)) {

	npMCI->lTo = lTo;

	/* Clear the 'repeat' flags */
	npMCI->dwFlags &= ~(MCIAVI_REPEATING);

	GraphicDelayedNotify (npMCI, MCI_NOTIFY_ABORTED);

	if (dwFlags & MCI_NOTIFY) {
	    GraphicSaveCallback(npMCI, (HANDLE) (UINT_PTR)npMCI->dwReqCallback);
	}

	TaskReturns(npMCI, 0);
	return FALSE;
    }

    // we have to stop to do this seek
    return TRUE;
}


void OnTask_SetWindow(NPMCIGRAPHIC npMCI)
{

    npMCI->hwndPlayback = (HWND) npMCI->lParam;

    npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
    InvalidateRect(npMCI->hwndPlayback, &npMCI->rcDest, FALSE);

    /* Should we update the window here? */

    /* Start playing again in the new window (if we had to stop) */

    //now, where were we ?
    if (npMCI->dwFlags & MCIAVI_UPDATING) {
	OnTask_RestartAgain(npMCI, TRUE);
    } else {
	TaskReturns(npMCI, 0);
    }
}

void OnTask_SetSpeed(NPMCIGRAPHIC npMCI)
{
    npMCI->dwSpeedFactor = (DWORD)npMCI->lParam;

    // if we stopped to do this, then restart whatever we were doing
    if (npMCI->dwFlags & MCIAVI_UPDATING) {
	OnTask_RestartAgain(npMCI, TRUE);
    } else {
	TaskReturns(npMCI, 0);
    }
}


BOOL
OnTask_SetSpeedDuringPlay(NPMCIGRAPHIC npMCI)
{
    /* If new speed is the same as the old speed, done. */
    if ((DWORD)npMCI->lParam == npMCI->dwSpeedFactor) {
	TaskReturns(npMCI, 0);
	return FALSE;
    }

    // otherwise we have to stop and restart
    OnTask_StopTemporarily(npMCI);
    return TRUE;
}


void OnTask_WaveSteal(NPMCIGRAPHIC npMCI) {

    DPF2(("OnTask_WaveSteal, '%ls' hTask=%04X\n", (LPSTR)npMCI->szFilename, npMCI->hTask));

    // if we stopped to do this, then restart whatever we were doing
    if (npMCI->dwFlags & MCIAVI_UPDATING) {
	// We stopped to do this...
        EnterWinCrit(npMCI);

        // Turn the lose audio flag on so that when we restart we do not
	// try and pick up the wave device.  The flag will be reset in
	// SetUpAudio.

        npMCI->dwFlags |= MCIAVI_LOSEAUDIO;

	// Hint that we would like sound again
        npMCI->dwFlags |= MCIAVI_LOSTAUDIO;

        LeaveWinCrit(npMCI);
        OnTask_RestartAgain(npMCI, TRUE);

    	Assert(!(npMCI->dwFlags & MCIAVI_LOSEAUDIO));
	// The flag has been reset by SetUpAudio

	// By using MCIAVI_LOSEAUDIO we do not have to change the state of
	// the MCIAVI_PLAYAUDIO flag.  This is goodness as that flag controls
	// the mute state - and that is independent of the availability of a
	// wave device, activation and/or deactivation.
    } else {
        TaskReturns(npMCI, 0);
    }
}

void OnTask_WaveReturn(NPMCIGRAPHIC npMCI) {

    // Turn off the flag that caused us to get called.
    // Note: if the audio device is still unavailable, this flag will get
    // turned on again when we fail to open the device.
    npMCI->dwFlags &= ~MCIAVI_LOSTAUDIO;

    DPF2(("OnTask_WaveReturn... pick up the audio\n"));
    // if we stopped to do this, then restart whatever we were doing
    if (npMCI->dwFlags & MCIAVI_UPDATING) {
	OnTask_RestartAgain(npMCI, TRUE);
    } else {
	TaskReturns(npMCI, 0);
    }
}

BOOL OnTask_WaveStealDuringPlay(NPMCIGRAPHIC npMCI) {

    DPF2(("OnTask_WaveStealDuringPlay, '%ls' hTask=%04X\n", (LPSTR)npMCI->szFilename, npMCI->hTask));
    /* If we do not have the audio, just return. */
    if (npMCI->hWave == 0) {
	TaskReturns(npMCI, 0);
        return FALSE;
    }

    /* Stop before changing sound status */
    OnTask_StopTemporarily(npMCI);
    return(TRUE);
}

/*
 * A wave device may have become available.  Stop and try to pick it up.
 */

BOOL OnTask_WaveReturnDuringPlay(NPMCIGRAPHIC npMCI) {


    /* If there's no audio, just return. */
    if (npMCI->nAudioStreams == 0) {
        npMCI->dwFlags &= ~MCIAVI_LOSTAUDIO;
	TaskReturns(npMCI, 0);
        return FALSE;
    }

    /* Stop before changing sound status */
    OnTask_StopTemporarily(npMCI);
    return(TRUE);
}

BOOL
OnTask_MuteDuringPlay(NPMCIGRAPHIC npMCI)
{
    // If npMCI->lParam is TRUE, this means that we are to mute the
    // device - hence turn off the PLAYAUDIO flag.

    DWORD fPlayAudio = (DWORD)((BOOL) npMCI->lParam ? 0 : MCIAVI_PLAYAUDIO);

    /* If there's no audio, just return. Should this be an error? */
    if (npMCI->nAudioStreams == 0) {
	TaskReturns(npMCI, 0);
        return FALSE;
    }

    /* If the mute state isn't changing, don't do anything. */
    if ( (npMCI->dwFlags & MCIAVI_PLAYAUDIO) == fPlayAudio) {
        TaskReturns(npMCI, 0);
        return FALSE;
    }

    DPF2(("DeviceMute, fPlayAudio = %x, npMCI=%8x\n", fPlayAudio, npMCI));

    /* Stop before changing mute */
    OnTask_StopTemporarily(npMCI);

    return TRUE;
}


void
OnTask_Mute(NPMCIGRAPHIC npMCI)
{

    // If npMCI->lParam is TRUE, this means that we are to mute the
    // device - hence turn off the PLAYAUDIO flag.
    // We do not bother to check a change in state.  That is only
    // relevant if we are already playing when we only want to stop
    // for a change in state.

    BOOL fMute = (BOOL)npMCI->lParam;

    /* If there's no audio, just return. Should this be an error? */
    if (npMCI->nAudioStreams != 0) {

	EnterWinCrit(npMCI);
        if (fMute)
            npMCI->dwFlags &= ~MCIAVI_PLAYAUDIO;
        else
            npMCI->dwFlags |= MCIAVI_PLAYAUDIO;
    	LeaveWinCrit(npMCI);
    }

    // if we stopped to do this, then restart whatever we were doing
    if (npMCI->dwFlags & MCIAVI_UPDATING) {
	OnTask_RestartAgain(npMCI, TRUE);
    } else {
	TaskReturns(npMCI, 0);
    }
}


// all access to the hWave *must* be restricted to the thread that created
// the wave device. So even getting the volume must be done on the
// worker thread only
//
// this function gets the current volume setting and stores it in
// npMCI->dwVolume

DWORD
InternalGetVolume(NPMCIGRAPHIC npMCI)
{
    DWORD	dw = 0;
    DWORD	dwVolume = 0;

    if (npMCI->hWave) {
	// Get the current audio volume....
	dw = waveOutMessage(npMCI->hWave, WODM_GETVOLUME,
			    (DWORD_PTR) (DWORD FAR *)&dwVolume, 0);

    } else if (!(npMCI->dwFlags & MCIAVI_VOLUMESET)) {
	// We have no device open, and the user hasn't chosen a
	// volume yet.

        //
        // Try to find out what the current "default" volume is.
        //
        // I really doubt zero is the current volume, try to work
        // with broken cards like the windows sound system.
        //
        dw = waveOutGetVolume((HWAVEOUT)(UINT)WAVE_MAPPER, &dwVolume);

        if ((dw != 0) || (dwVolume != 0)) {

	    dw = waveOutGetVolume((HWAVEOUT)0, &dwVolume);
	}

	// don't accept default volume of 0
	if ((dwVolume == 0) && (dw == 0)) {
	    dw = MCIERR_NONAPPLICABLE_FUNCTION;
	}

    }
    if (dw == 0) {
	npMCI->dwVolume = MAKELONG((UINT)muldiv32(LOWORD(dwVolume), 500L, 32768L),
				   (UINT)muldiv32(HIWORD(dwVolume), 500L, 32768L));
    }
    return dw;

}

DWORD
InternalSetVolume(NPMCIGRAPHIC npMCI, DWORD dwVolume)
{
    DWORD dw = 0;

    npMCI->dwVolume = dwVolume;

    EnterWinCrit(npMCI);
    npMCI->dwFlags |= MCIAVI_VOLUMESET;
    LeaveWinCrit(npMCI);

    /* clear flag to emulate volume */;
    npMCI->fEmulatingVolume = FALSE;

    /* If there's no audio, just return. Should this be an error? */
    if (npMCI->nAudioStreams != 0) {

	if (npMCI->hWave) {
	    WORD	wLeft;
	    WORD	wRight;

	    if (LOWORD(dwVolume) >= 1000)
		wLeft = 0xFFFF;
	    else
		wLeft = (WORD) muldiv32(LOWORD(dwVolume), 32768L, 500L);

	    if (HIWORD(dwVolume) >= 1000)
		wRight = 0xFFFF;
	    else
		wRight = (WORD) muldiv32(HIWORD(dwVolume), 32768L, 500L);

	    // !!! Support left and right volume?
	    dw = waveOutMessage(npMCI->hWave, WODM_SETVOLUME,
				MAKELONG(wLeft, wRight), 0);

	    if (dw != MMSYSERR_NOERROR && LOWORD(dwVolume) != 500) {
		npMCI->fEmulatingVolume = TRUE;
		BuildVolumeTable(npMCI);
	    }

	    dw = 0;
	}
    }
    return dw;
}

INLINE void
OnTask_SetVolume(NPMCIGRAPHIC npMCI)
{
    DWORD dwVolume = (DWORD) npMCI->lParam;

    TaskReturns(npMCI, InternalSetVolume(npMCI, dwVolume));
}

void OnTask_SetAudioStream(NPMCIGRAPHIC npMCI)
{
    UINT wAudioStream = npMCI->dwParamFlags;
    int		stream;

    /* If there's no audio, we're done. Should this be an error? */

    if (npMCI->nAudioStreams != 0) {

	for (stream = 0; stream < npMCI->streams; stream++) {
	    if (SH(stream).fccType == streamtypeAUDIO) {
		--wAudioStream;

		if (wAudioStream == 0)
		    break;
	    }
	}

	Assert(stream < npMCI->streams);

	npMCI->psiAudio = SI(stream);
	npMCI->nAudioStream = stream;
    }

    // if we stopped to do this, then restart whatever we were doing
    if (npMCI->dwFlags & MCIAVI_UPDATING) {
	OnTask_RestartAgain(npMCI, TRUE);
    } else {
	TaskReturns(npMCI, 0);
    }
}

void
OnTask_SetVideoStream(NPMCIGRAPHIC npMCI)
{
    UINT uStream = npMCI->dwParamFlags;
    BOOL fOn = (BOOL) npMCI->lParam;
    DWORD	dw = 0L;
    int         stream;
    STREAMINFO *psi;

    //
    // find the Nth non-audio, non-error stream
    //
    for (stream = 0; stream < npMCI->streams; stream++) {

        psi = SI(stream);

        if (psi->sh.fccType == streamtypeAUDIO)
            continue;

        if (psi->dwFlags & STREAM_ERROR)
            continue;

        if (--uStream == 0)
            break;
    }

    if (stream == npMCI->streams) {
        dw = MCIERR_OUTOFRANGE;
    } else {


        if (fOn)
            psi->dwFlags |= STREAM_ENABLED;
        else
            psi->dwFlags &= ~STREAM_ENABLED;

        if (fOn && psi->sh.fccType == streamtypeVIDEO) {
            //!!! should we change the master timebase?
            DOUT("Setting main video stream\n");
#if 0
//
//  the master video stream is too special cased to change!
//
            npMCI->psiVideo = psi;
            npMCI->nVideoStream = stream;
#endif
        }

        if (!fOn && npMCI->nVideoStream == stream) {
            DOUT("Turning off main video stream\n");
            npMCI->dwFlags &= ~MCIAVI_SHOWVIDEO;
        }

        //
        //  now we turn MCIAVI_SHOWVIDEO off if no video/other streams
        //  are enabled.
        //
        npMCI->dwFlags &= ~MCIAVI_SHOWVIDEO;    // assume off.

        for (stream = 0; stream < npMCI->streams; stream++) {

            psi = SI(stream);

            if (psi->sh.fccType == streamtypeAUDIO)
                continue;

            if (psi->dwFlags & STREAM_ERROR)
                continue;

            if (!(psi->dwFlags & STREAM_ENABLED))
                continue;

            // at least one stream is enabled show "video"
            npMCI->dwFlags |= MCIAVI_SHOWVIDEO;
        }

        if (!(npMCI->dwFlags & MCIAVI_SHOWVIDEO))
            DOUT("All streams off\n");
    }

    // if we stopped to do this, then restart whatever we were doing
    if ( (dw == 0) && (npMCI->dwFlags & MCIAVI_UPDATING)) {
	OnTask_RestartAgain(npMCI, TRUE);
    } else {
	TaskReturns(npMCI, dw);
    }

}

/***************************************************************************
 *
 ***************************************************************************/

static void MapRect(RECT *prc, RECT*prcIn, RECT *prcFrom, RECT *prcTo)
{
    if (IsRectEmpty(prcFrom)) {
        SetRectEmpty(prc);
    }
    else {
        prc->left  = prcTo->left + MulDiv(prcIn->left  - prcFrom->left, prcTo->right  - prcTo->left, prcFrom->right  - prcFrom->left);
        prc->top   = prcTo->top  + MulDiv(prcIn->top   - prcFrom->top,  prcTo->bottom - prcTo->top,  prcFrom->bottom - prcFrom->top);
        prc->right = prcTo->left + MulDiv(prcIn->right - prcFrom->left, prcTo->right  - prcTo->left, prcFrom->right  - prcFrom->left);
        prc->bottom= prcTo->top  + MulDiv(prcIn->bottom- prcFrom->top,  prcTo->bottom - prcTo->top,  prcFrom->bottom - prcFrom->top);
    }
}

/***************************************************************************
 *
 ***************************************************************************/

static void MapStreamRects(NPMCIGRAPHIC npMCI)
{
    int i;

    //
    //  now set the source and dest rects for each stream.
    //
    for (i=0; i<npMCI->streams; i++)
    {
        //
        // make sure the stream rect is in bounds
        //

        IntersectRect(&SI(i)->rcSource, &SH(i).rcFrame, &npMCI->rcSource);

        //
        // now map the stream source rect onto the destination
        //
        MapRect(&SI(i)->rcDest, &SI(i)->rcSource, &npMCI->rcSource, &npMCI->rcDest);
	
        //
        // make the stream source RECT (rcSource) relative to the
        // stream rect (rcFrame)
        //
        OffsetRect(&SI(i)->rcSource,-SH(i).rcFrame.left,-SH(i).rcFrame.top);
	
    }
}

//
// try to set the dest or source rect without stopping play.
// called both at stop time and at play time
//
// returns TRUE if stop needed, or else FALSE if all handled.
// lpdwErr is set to a non-zero error if any error occured (in which case
// FALSE will be returned.
//
BOOL
TryPutRect(NPMCIGRAPHIC npMCI, DWORD dwFlags, LPRECT lprc, LPDWORD lpdwErr)
{

    RECT    rc;
    PRECT   prcPut;
    DWORD   dw = 0;


    // assume no error
    *lpdwErr = 0;

    if (dwFlags & MCI_DGV_PUT_DESTINATION) {
        DPF2(("DevicePut: destination [%d, %d, %d, %d]\n", *lprc));
        prcPut = &npMCI->rcDest;
    } else {
        DPF2(("DevicePut: source [%d, %d, %d, %d]\n", *lprc));
        prcPut = &npMCI->rcSource;

        //
        // make sure source rectangle is in range.
        //
        //  !!!should we return a error, or just fix the rectangle???
        //
	// ?? Why do we use an intermediate structure?
        rc = npMCI->rcMovie;
        IntersectRect(lprc, &rc, lprc);     // fix up the passed rect.
    }

    //
    // check for a bogus rect. either a NULL or inverted rect is considered
    // invalid.
    //
    // !!!NOTE we should handle a inverted rect (mirrored stretch)
    //
    if (lprc->left >= lprc->right ||
        lprc->top  >= lprc->bottom) {
		
	// this is fine if there are no video streams
	if (npMCI->nVideoStreams <= 0) {
	    // no video so all ok
	    return FALSE;
	}

        DPF2(("DevicePut: invalid rectangle [%d, %d, %d, %d]\n", *lprc));
	*lpdwErr = MCIERR_OUTOFRANGE;
	return FALSE;
    }

    /* make sure the rect changed */
    if (EqualRect(prcPut,lprc)) {
	return FALSE;
    }

    InvalidateRect(npMCI->hwndPlayback, &npMCI->rcDest, TRUE);
    rc = *prcPut;           /* save it */
    *prcPut = *lprc;        /* change it */
    InvalidateRect(npMCI->hwndPlayback, &npMCI->rcDest, FALSE);

    /* have both the dest and source been set? */
    if (IsRectEmpty(&npMCI->rcDest) || IsRectEmpty(&npMCI->rcSource)) {
	return FALSE;
    }

    MapStreamRects(npMCI);
    StreamInvalidate(npMCI, NULL);      // invalidate the world

    if (npMCI->wTaskState == TASKIDLE) {
	DPF2(("TryPutRect: Idle, force DrawBegin on update\n"));
	npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
    }
    else {
	BOOL	fRestart = FALSE;
	
        //
        //  we dont need to start/stop just begin again.
        //
	DPF2(("TryPutRect: Calling DrawBegin()\n"));
	if (!DrawBegin(npMCI, &fRestart)) {
	    *lpdwErr =  npMCI->dwTaskError;
	    return FALSE;
	}

        if (!DoStreamUpdate(npMCI, FALSE)) {
	    DPF(("TryPutRect: Failed update, forcing restart....\n"));
	    npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
	    fRestart = TRUE;
	}
	
	if (fRestart) {
	    // restart needed
	    return TRUE;
        }
    }

    // all ok
    return FALSE;
}

void
OnTask_Put(NPMCIGRAPHIC npMCI)
{

    DWORD dwFlags = npMCI->dwParamFlags;
    LPRECT lprc = (LPRECT) npMCI->lParam;
    DWORD dw = 0;
	
	//If the user is doing an MCI_PUT to set the rectangle we should
	//stop any previous requests to set the rectangle.
	npMCI->dwWinProcRequests &= ~WINPROC_RESETDEST;

    if (TryPutRect(npMCI, dwFlags, lprc, &dw)) {

	// what to do now? It says we need to stop, but we
	// are stopped.
	TaskReturns(npMCI, MCIERR_DEVICE_NOT_READY);
	return;
    }

    // if we stopped to do this, then restart whatever we were doing
    if ((dw == 0) && (npMCI->dwFlags & MCIAVI_UPDATING)) {

	// !!! We used to call InitDecompress here...
	npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;

	OnTask_RestartAgain(npMCI, TRUE);
    } else {
	TaskReturns(npMCI, dw);
    }
}

BOOL
OnTask_PutDuringPlay(NPMCIGRAPHIC npMCI)
{
    DWORD dwFlags = npMCI->dwParamFlags;
    LPRECT lprc = (LPRECT) npMCI->lParam;
    DWORD dw = 0;
	

    if (TryPutRect(npMCI, dwFlags, lprc, &dw)) {

	// need to stop to handle this one.

	// !!! Set a flag here to prevent any more drawing
	npMCI->fNoDrawing = TRUE;

	OnTask_StopTemporarily(npMCI);
	return TRUE;
    }

    // handled ok or error - no stop needed
    TaskReturns(npMCI, dw);
    return FALSE;
}

void OnTask_Palette(NPMCIGRAPHIC npMCI)
{
    HPALETTE hpal = (HPALETTE)npMCI->lParam;

    // Remember this for later.

    npMCI->hpal = hpal;

    npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
    InvalidateRect(npMCI->hwndPlayback, NULL, TRUE);

    // !!! Do we need to stop and restart here?
    // Answer: probably not, because if they care about the palette not being
    // messed up, they probably never allowed us to be shown at all.

    TaskReturns(npMCI, 0);
    return;
}

void OnTask_PaletteColor(NPMCIGRAPHIC npMCI)
{
    DWORD index = (DWORD)npMCI->lParam;
    DWORD color = (DWORD)npMCI->dwParamFlags;

    // !!! Do we need to stop and restart here?
    // Answer: probably not, because if they care about the palette not being
    // messed up, they probably never allowed us to be shown at all.
    // Note: chicago code does stop... but they stop for most things.
    //	(it would be cleaner to stop and restart...)

    // Pound the new color into the old format.
    ((DWORD FAR *) ((BYTE FAR *) npMCI->pbiFormat +
		   npMCI->pbiFormat->biSize))[index] = color;

    ((DWORD FAR *) npMCI->argb)[index] = color;

    npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
    InvalidateRect(npMCI->hwndPlayback, NULL, TRUE);
    TaskReturns(npMCI, 0);
    return;
}


/*
 * OnTask_ProcessRequest
 *
 * Process a request on the worker thread. Set hEventResponse if completed
 * in error, or once the request has been completed (in the case of async
 * requests such as play, set the event once play has begun ok
 *
 * return TRUE if it is time for the thread to exit, or else false.
 *
 */
BOOL
OnTask_ProcessRequest(NPMCIGRAPHIC npMCI)
{
    switch(npMCI->message) {

    case AVI_CLOSE:
	// release the requesting thread so he can go and wait on the
	// worker thread exit
	TaskReturns(npMCI, 0);

	// now go and exit
	return TRUE;

    case AVI_RESUME:
	// same as play, except that repeat and reverse flags need
	// to be set on worker thread
	npMCI->dwParamFlags |=
	    ((npMCI->dwFlags & MCIAVI_REVERSE)? MCI_DGV_PLAY_REVERSE : 0);
	// fall through
    case AVI_PLAY:
	OnTask_Play(npMCI);
	break;

    case AVI_STOP:
	npMCI->dwFlags &= ~MCIAVI_REPEATING;  // Give the wave device away
	TaskReturns(npMCI, 0);
	break;

    case AVI_REALIZE:
	OnTask_Realize(npMCI);
	break;

    case AVI_UPDATE:
	OnTask_Update(npMCI);
	break;

    case AVI_PAUSE:
	// not playing, so same as cue to current frame
	OnTask_Cue(npMCI, npMCI->dwParamFlags | MCI_TO, npMCI->lCurrentFrame);
	break;

    case AVI_CUE:
	OnTask_Cue(npMCI, npMCI->dwParamFlags, (LONG) npMCI->lParam);
	break;

    case AVI_SEEK:
	OnTask_Seek(npMCI);
	break;

    case AVI_WINDOW:
	OnTask_SetWindow(npMCI);
	break;

    case AVI_MUTE:
	OnTask_Mute(npMCI);
	break;

    case AVI_SETSPEED:
	OnTask_SetSpeed(npMCI);
	break;

    case AVI_SETVOLUME:
	OnTask_SetVolume(npMCI);
	break;

    case AVI_GETVOLUME:
	TaskReturns(npMCI, InternalGetVolume(npMCI));
	break;

    case AVI_AUDIOSTREAM:
	OnTask_SetAudioStream(npMCI);
	break;

    case AVI_VIDEOSTREAM:
	OnTask_SetVideoStream(npMCI);
	break;

    case AVI_PUT:
	OnTask_Put(npMCI);
	break;

    case AVI_PALETTE:
	OnTask_Palette(npMCI);
	break;

    case AVI_PALETTECOLOR:
	OnTask_PaletteColor(npMCI);
	break;

    case AVI_WAVESTEAL:
	OnTask_WaveSteal(npMCI);
	break;

    case AVI_WAVERETURN:
	OnTask_WaveReturn(npMCI);
	break;

    default:
	TaskReturns(npMCI, MCIERR_UNSUPPORTED_FUNCTION);
	break;
    }
    return FALSE;
}


// OnTask_PeekRequest
//
// called from aviTaskCheckRequests() to process a message at play time.
// if the message requires a stop, then this function returns TRUE and
// leaves the message unprocessed.
//
// otherwise the message is fully processed. This must include resetting
// hEventSend
//
INLINE STATICFN BOOL
OnTask_PeekRequest(NPMCIGRAPHIC npMCI)
{
    switch(npMCI->message) {

// always need to stop
    case AVI_CLOSE:
    case AVI_STOP:
	npMCI->dwFlags &= ~MCIAVI_REPEATING;  // Give the wave device away
	return TRUE;


// may need to stop

    case AVI_RESUME:
	// same as play, except that repeat and reverse flags need
	// to be set on worker thread
	npMCI->dwParamFlags |=
	    ((npMCI->dwFlags & MCIAVI_REPEATING)? MCI_DGV_PLAY_REPEAT : 0) |
	    ((npMCI->dwFlags & MCIAVI_REVERSE)? MCI_DGV_PLAY_REVERSE : 0);
	// fall through
    case AVI_PLAY:
	return OnTask_PlayDuringPlay(npMCI);

    case AVI_UPDATE:
	return OnTask_UpdateDuringPlay(npMCI);

    case AVI_SEEK:
	return OnTask_SeekDuringPlay(npMCI);

    case AVI_CUE:
	return OnTask_CueDuringPlay(npMCI);

    case AVI_MUTE:
	return OnTask_MuteDuringPlay(npMCI);

    case AVI_WAVESTEAL:
	return OnTask_WaveStealDuringPlay(npMCI);

    case AVI_WAVERETURN:
	return OnTask_WaveReturnDuringPlay(npMCI);

    case AVI_SETSPEED:
	return OnTask_SetSpeedDuringPlay(npMCI);

    case AVI_PUT:
	return OnTask_PutDuringPlay(npMCI);


// need temporary stop
    case AVI_WINDOW:
    case AVI_AUDIOSTREAM:
    case AVI_VIDEOSTREAM:
	OnTask_StopTemporarily(npMCI);
	return TRUE;


// never need to stop
    case AVI_REALIZE:
	OnTask_Realize(npMCI);
	break;

    case AVI_PAUSE:
	OnTask_PauseDuringPlay(npMCI);
	break;

    case AVI_SETVOLUME:
	OnTask_SetVolume(npMCI);
	break;

    case AVI_GETVOLUME:
	TaskReturns(npMCI, InternalGetVolume(npMCI));
	break;

    case AVI_PALETTE:
	OnTask_Palette(npMCI);
	break;

    case AVI_PALETTECOLOR:
        OnTask_PaletteColor(npMCI);
        break;

    default:
	TaskReturns(npMCI, MCIERR_UNSUPPORTED_FUNCTION);
	break;
    }
    return FALSE;
}

/*
 * This routine is called from the IDLE loop and at key points while
 * playing.  If it is possible to service the request, the state of the
 * device is updated and the request flag is cleared.
 *
 * If the request cannot be handled now (e.g. while playing) the flag
 * is not set and we will be called again (e.g. when idle).
 *
 * If we need to stop to service the request (i.e. to regain the sound
 * device) we return TRUE.  In all other cases we return FALSE.  The
 * return value is only checked if we are actually playing.
 */

STATICFN void OnTask_WinProcRequests(NPMCIGRAPHIC npMCI, BOOL bPlaying)
{

    DWORD requests;
    EnterWinCrit(npMCI);

    // grab the request bits now, so we don't need to hold the
    // critsec while servicing them.
    // any that are not cleared will be or-ed back in at the end
    requests = npMCI->dwWinProcRequests;
    npMCI->dwWinProcRequests = 0;
    LeaveWinCrit(npMCI);


    if (requests & WINPROC_STOP) {
	requests &= ~WINPROC_STOP;
	npMCI->dwFlags |= MCIAVI_STOP;
    }

    if (requests & WINPROC_MUTE) {
	if (bPlaying) {
	    OnTask_StopTemporarily(npMCI);
	} else {
	    // toggle audio flag
	    npMCI->dwFlags ^= MCIAVI_PLAYAUDIO;
	    requests &= ~WINPROC_MUTE;
	}
    }

    if (requests & WINPROC_SOUND) {
	// We might be able to pick up the sound.  This is only of interest
	// if we are currently playing, do not have a sound device, and want
	// the audio.
	if (bPlaying && (NULL == npMCI->hWave) && (MCIAVI_PLAYAUDIO & npMCI->dwFlags)) {
	    OnTask_StopTemporarily(npMCI);
	} else {
	    // We have finished this request.  Make sure we try and
	    // get sound when we restart
	    requests &= ~WINPROC_SOUND;
	    npMCI->dwFlags &= ~MCIAVI_LOSEAUDIO;
	}
    }

#ifdef REMOTESTEAL
    if (requests & WINPROC_SILENT) {
	extern HWND hwndWantAudio;
	DPF2(("WINPROC_SILENT request made, bPlaying=%x\n", bPlaying));
	// If we are playing, and we have a wave device, stop.
	// When we are recalled, we will start again without the wave device.
	if (bPlaying && npMCI->hWave) {
	    OnTask_StopTemporarily(npMCI);
	    // Stopping will cause the wave device to be released, which
	    // means a message will be posted to whoever wanted the wave
	    // device
	} else {
	    // If we are playing, we do not have a wave device, and we
	    // do not want to stop.
	    // Otherwise we want to lose our wave device.
	    // Either way, we will finish with WINPROC_SILENT on this pass
	    requests &= ~WINPROC_SILENT;
	    hwndWantAudio = 0;  // In case we did not have to stop
	    if (!bPlaying) {
		// Remember we lost audio, and start again without audio
		npMCI->dwFlags |= MCIAVI_LOSTAUDIO;
		npMCI->dwFlags |= MCIAVI_LOSEAUDIO;
	    }
	}
    }

#endif

    if (requests & WINPROC_RESETDEST) {

	RECT rc;
	DWORD dw;

	if (npMCI->hwndPlayback &&
	    npMCI->hwndPlayback == npMCI->hwndDefault &&
	    (npMCI->dwOptionFlags & MCIAVIO_STRETCHTOWINDOW)) {
		GetClientRect(npMCI->hwndPlayback, &rc);
	} else if (npMCI->streams > 0) {
	    rc = npMCI->rcMovie;

	    if (npMCI->dwOptionFlags & MCIAVIO_ZOOMBY2) {
		rc.right *= 2;
		rc.bottom *= 2;
	    }
	}

	if (TryPutRect(npMCI, MCI_DGV_PUT_DESTINATION, &rc, &dw) && bPlaying) {
	    OnTask_StopTemporarily(npMCI);
	} else {
	    requests &= ~WINPROC_RESETDEST;
	}
    }

    if (requests & WINPROC_ACTIVE) {

	// We are being made active.  The only extra work we must do
	// is grab the wave device - if we have ever lost it.

	// If we are playing, and we do not have the audio, and we want
	// the audio...
	if (bPlaying
	    && (npMCI->hWave == 0)
            && (npMCI->dwFlags & MCIAVI_PLAYAUDIO)) {

	    // Let's try and make the sound active by stealing the wave device
	    // Must stop before trying to reset the sound
	    if (StealWaveDevice(npMCI)) {

		OnTask_StopTemporarily(npMCI);
		// Force ourselves to be called again.  Doing it this way
		// means that we will be recalled.  We cannot rely on
		// WINPROC_ACTIVE staying around.  A deactivation could
		// cause the flag to be cleared
	        requests |= WINPROC_SOUND;
	    }
	} else {
	    // We had not lost the wave device...
	    // OR we are playing silently, and so there is no point
	    // in trying to steal it.
	    // We are finished.
	}

	// Clear WINPROC_ACTIVE - all processing done.
	// Note: we might have set WINPROC_SOUND, which will cause this
	// routine to be recalled.  Once recalled, then playing can restart
	requests &= ~ WINPROC_ACTIVE;

    } else {  // We never have both INACTIVE and ACTIVE at the same time
        if (requests & WINPROC_INACTIVE) {
	    //!!!need to support this
	    requests &= ~WINPROC_INACTIVE;
        }
    }

    EnterWinCrit(npMCI);     // Do we really need this one here??

    if (requests & WINPROC_UPDATE) {
	if (bPlaying) {
	    npMCI->dwFlags |= MCIAVI_NEEDUPDATE;
	} else {

	    HDC hdc;

	    // don't do this if the window is now hidden
	    // or showstage will be called with the critsec and deadlock
	    if (IsWindowVisible(npMCI->hwndPlayback)) {
		EnterHDCCrit(npMCI);
		npMCI->bDoingWinUpdate = TRUE;

		hdc = GetDC(npMCI->hwndPlayback);
		Assert(hdc);
		Internal_Update(npMCI, MCI_DGV_UPDATE_PAINT, hdc, NULL);
		ReleaseDC(npMCI->hwndPlayback, hdc);

		npMCI->bDoingWinUpdate = FALSE;
		LeaveHDCCrit(npMCI);
	    }
	}
	requests &= ~WINPROC_UPDATE;
    }

    if (requests & WINPROC_REALIZE) {
	EnterHDCCrit(npMCI);
	InternalRealize(npMCI);
	LeaveHDCCrit(npMCI);
	requests &= ~ WINPROC_REALIZE;
    }

    // or back the bits we didn't clear
    npMCI->dwWinProcRequests |= requests;

    // if we processed all the bits (and no new bits were set)
    if (! npMCI->dwWinProcRequests) {
	ResetEvent(npMCI->heWinProcRequest);
    }

    LeaveWinCrit(npMCI);
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void| aviTaskCheckRequests | called on the worker thread at least once per
 *
 * frame. We use this to check for requests from the user thread.
 *
 *
 ***************************************************************************/

void NEAR PASCAL aviTaskCheckRequests(NPMCIGRAPHIC npMCI)
{
    HANDLE hWaiter;

    if (WaitForSingleObject(npMCI->hEventSend, 0) == WAIT_OBJECT_0) {

	// there is a request

	Assert(npMCI->message != 0);

        // check the waiter

        // if this is an async request with wait, we need to set hWaiter
        // so that hEventAllDone is set correctly. If we stop
        // and process this message in the idle loop, then we don't want to
        // set hWaiter here, or EventAllDone could be signalled when we
        // stop - before we've even started this request.

        // so we need to check the validity (no waiting if another thread is
        // waiting) and pick up the waiter and bDelayed while the critsec
        // is still held, but only set hWaiter if the request was processed
        // here.

        // no - that leaves a timing window when hWaiter is not set and the
        // critsec is not held. Set hWaiter, but be prepared to unset it
        // if we postpone processing during the idle loop (in which case,
        // the waiter will hold the critsec until we have stopped).

        hWaiter = npMCI->hWaiter;

        if (npMCI->bDelayedComplete) {

            if (npMCI->hWaiter && (npMCI->hWaiter != npMCI->hRequestor)) {
                TaskReturns(npMCI, MCIERR_DEVICE_NOT_READY);
                return;
            } else {
		DPF2(("Replacing hWaiter in aviTaskCheckRequests... was %x, now %x\n", npMCI->hWaiter, npMCI->hRequestor));
                npMCI->hWaiter = npMCI->hRequestor;
            }
        }

	DPF2(("peek %d [%x] ...", npMCI->message, npMCI->hRequestor));

	if (OnTask_PeekRequest(npMCI)) {
	    // we need to stop

	    // must be set on WORKER THREAD ONLY
	    npMCI->dwFlags |= MCIAVI_STOP;
	    DPF2(("Need to stop - replacing hWaiter (was %x, now %x)\n", npMCI->hWaiter, hWaiter));

            // replace hWaiter so idle loop does not set hEventAllDone for
            // a request he has not yet started.
            npMCI->hWaiter = hWaiter;
	}
	// else the request has already been dealt with
    }

    // did the winproc have any requests
    if (WaitForSingleObject(npMCI->heWinProcRequest, 0) == WAIT_OBJECT_0) {

	//
	// We have a request from the window thread.  Go process it
	//
	OnTask_WinProcRequests(npMCI, TRUE);
    }
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | CheckIfActive | check to see if we are the active movie
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data block.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

void CheckIfActive(NPMCIGRAPHIC npMCI)
{
    BOOL fActive;
    HWND hwndA;


    if (!IsTask(npMCI->hTask)) return;

    //
    //  are we the foreground window?
    //
    //  ??? should the value of <npMCI->fForceBackground> matter?
    //
    //  IMPORTANT:  This does NOT work under NT.  The best that can
    //  be done is to check GetForegroundWindow
#ifndef _WIN32
    hwndA = GetActiveWindow();

    fActive = (hwndA == npMCI->hwndPlayback) ||
              (GetFocus() == npMCI->hwndPlayback) ||
              (IsWindow(hwndA) && IsChild(hwndA, npMCI->hwndPlayback) && !npMCI->fForceBackground);
#else
    hwndA = GetForegroundWindow();

    fActive = (hwndA == npMCI->hwndPlayback) ||
              (IsWindow(hwndA) && IsChild(hwndA, npMCI->hwndPlayback) && !npMCI->fForceBackground);
#endif

    DeviceSetActive(npMCI, fActive);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\device.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1995. All rights reserved.

   Title:   device.c - Multimedia Systems Media Control Interface
            driver for AVI.

*****************************************************************************/
#include "graphic.h"
#include "avitask.h"

#define ALIGNULONG(i)     ((i+3)&(~3))                  /* ULONG aligned ! */
#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)


// from wownt32.h
VOID (WINAPI * pWOWYield16)(VOID);



#ifdef DEBUG
    #define AssertUserThread(npMCI) 			\
	{  						\
	    DWORD thread = GetCurrentThreadId();	\
	    Assert((npMCI)->hTask != (HTASK)thread);	\
	    Assert(!((npMCI)->hwndDefault) || ((DWORD_PTR)GetWindowTask((npMCI)->hwndDefault) != thread));\
	}
#else
    #define AssertUserThread(npMCI)
#endif

/*
 * send a request to the worker thread, and wait for it to complete,
 * then return the result
 *
 * We must hold the CmdCritSec to stop other threads from making requests.
 *
 * if bDelayedComplete is true, the request is one that has two phases:
 *
 *   phase 1: 	initiating the operation (eg starting play). No other
 *		requests are permitted during this phase, so we hold the
 *		critical section and wait. No yielding of any sort is safe
 *		at this point, since re-entry on the same thread is not
 *		something we can handle well. This means that the worker
 *		thread must not do anything before setting hEventResponse
 *		that could block on our processing a sendmessage
 *
 *   phase 2:	while the play is taking place, we must process messages,
 *		yield to the app and allow other requests (eg stop).
 *		For this, we wait on a second event, timing out and yielding
 *              to the driver 10 times a second.
 *		
 */
DWORD
mciaviTaskRequest(
    NPMCIGRAPHIC npMCI,
    UINT message,
    DWORD dwFlags,
    LPARAM lParam,
    LPARAM dwCallback,
    BOOL bDelayedComplete
)
{
    DWORD dwRet;
    MSG msg;

#ifdef _WIN32
    // the gdi request queue is per-thread. We must flush the
    // app thread q here, or updates done to the window at the apps
    // request may appear before updates done by the app itself beforehand
    GdiFlush();
#endif

    // get the critsec that controls sending requests
    EnterCriticalSection(&npMCI->CmdCritSec);

    if (IsBadReadPtr(npMCI, sizeof(MCIGRAPHIC))) {
	// device has been closed beneath us!
	DPF(("help - npMCI has gone away"));
	// not safe to leave critsec or dec count
	return MCIERR_DEVICE_NOT_READY;
    }

    if (npMCI->EntryCount++ > 0) {
        DPF(("re-entering requestor on same thread (SendMessage?)"));
	//DebugBreak();
        npMCI->EntryCount--;
        LeaveCriticalSection(&npMCI->CmdCritSec);

        return MCIERR_DEVICE_NOT_READY;
	//return 0;
    }


    if (!IsTask(npMCI->hTask)) {
	// worker thread has gone away (previous close ?)
	npMCI->EntryCount--;
	LeaveCriticalSection(&npMCI->CmdCritSec);
    	DPF(("worker thread has gone away"));
	return MCIERR_DEVICE_NOT_READY;
    }

    // the response event should not be set yet!
    Assert(WaitForSingleObject(npMCI->hEventResponse, 0) == WAIT_TIMEOUT);


    // write the params
    npMCI->message = message;
    npMCI->dwParamFlags = dwFlags;
    npMCI->lParam = lParam;
    npMCI->dwReqCallback = dwCallback;
    npMCI->bDelayedComplete = bDelayedComplete;

    // we are the requesting task (we will be thrown out if this is
    // bDelayedComplete and there is an outstanding bDelayedComplete
    // from someone else)
    npMCI->hRequestor = GetCurrentTask();

    // signal that there is a request
    SetEvent(npMCI->hEventSend);

    // and wait for the response.
    //
    // in the play-wait case, this wait will complete once the play
    // has started. So at this point, no yields.

    // send-message processing needed for RealizePalette on worker thread
#if 1
    // this could cause re-entry on this thread, and the critical section
    // will not prevent that. Hence the EntryCount checks.
    while (MsgWaitForMultipleObjects(1, &npMCI->hEventResponse, FALSE,
            INFINITE, QS_SENDMESSAGE) != WAIT_OBJECT_0) {
        DPF2(("rec'd sendmessage during wait\n"));

	// this peekmessage allows an inter-thread sendmessage to complete.
	// no message needs to be removed or processed- the range filtering is
	// essentially irrelevant for this.
        PeekMessage(&msg, NULL, WM_QUERYNEWPALETTE, WM_QUERYNEWPALETTE, PM_NOREMOVE);

    }
#else
    WaitForSingleObject(npMCI->hEventResponse, INFINITE);
#endif

    // pick up the return value
    dwRet = npMCI->dwReturn;
    DPF2(("Task returns %d\n", dwRet));

    // release the critsec now that request is all done
    if (--npMCI->EntryCount != 0) {
	DPF(("EntryCount not 0 on exit"));
    }
    LeaveCriticalSection(&npMCI->CmdCritSec);

    // if this is a two-phased operation such as play + wait
    // we must do the yielding wait here
    if (!dwRet && bDelayedComplete) {
	DWORD dw;
	UINT  nYieldInterval = 300;
#ifdef DEBUG
        nYieldInterval = mmGetProfileInt(szIni, TEXT("YieldInterval"), nYieldInterval);
#endif
	do {
	    if (mciDriverYield(npMCI->wDevID)) {

		// app says we must stop now. do this by issuing a stop
		// request and carry on waiting for the play+wait to finish
		mciaviTaskRequest(npMCI, AVI_STOP, 0, 0, 0, FALSE);
	    }

	    dw = WaitForSingleObject(npMCI->hEventAllDone, nYieldInterval);

	    // this peekmessage allows an inter-thread sendmessage to complete.
	    // no message needs to be removed or processed- the range filtering is
	    // essentially irrelevant for this.
	    PeekMessage(&msg, NULL, WM_QUERYNEWPALETTE, WM_QUERYNEWPALETTE, PM_NOREMOVE);

	} while(dw != WAIT_OBJECT_0);

	// until this is cleared, no other task can issue delayed requests
	npMCI->hWaiter = 0;
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceOpen | Open an AVI file.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm LPSTR | lpName | file name.
 *
 * @parm DWORD | dwFlags | Open flags.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceOpen(NPMCIGRAPHIC npMCI, DWORD dwFlags)
{
    DWORD	dwRet;

    AssertUserThread(npMCI);

    // init the yield proc we will need for wow yielding
    if (IsNTWOW()) {
	if (pWOWYield16 == 0) {

	    HMODULE hmod;

	    hmod = GetModuleHandle(TEXT("wow32.dll"));
	    if (hmod != NULL) {
		(FARPROC)pWOWYield16 = GetProcAddress(hmod, "WOWYield16");
	    }
	}
    }



    // note that DeviceClose *will* be called anyway, even if DeviceOpen
    // fails, so make sure that allocations and events can be cleaned up
    // correctly.

    npMCI->uErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS |
				     SEM_NOOPENFILEERRORBOX);

    // must open the file on this app thread for ole reasons
    if (!mciaviOpenFile(npMCI)) {
	SetErrorMode(npMCI->uErrorMode);
	return npMCI->dwTaskError;
    }
    // OpenFileInit() on worker thread completes this open later.


    // create the communication channel to the worker thread, and
    // then start the thread

    // do this first, so that whenever we call DeviceClose we can always
    // safely do the Delete..
    InitializeCriticalSection(&npMCI->CmdCritSec);
    SetNTFlags(npMCI, NTF_DELETECMDCRITSEC);   // Remember to do the delete
    npMCI->EntryCount = 0;

    // must be manual-reset to allow polling during play.
    npMCI->hEventSend = CreateEvent(NULL, TRUE, FALSE, NULL);

    npMCI->hEventResponse = CreateEvent(NULL, FALSE, FALSE, NULL);
    npMCI->hEventAllDone = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!npMCI->hEventSend || !npMCI->hEventResponse || !npMCI->hEventAllDone) {

	// cleanup of events actually allocated will be done in DeviceClose
	return MCIERR_OUT_OF_MEMORY;
    }


    // create the worker thread

#if 0
    if (mmTaskCreate(mciaviTask, &npMCI->hThreadTermination,
	    (DWORD)(UINT)npMCI) == 0)
#else
    // We do not want the thread id, but CreateThread blows up if we pass
    // a null parameter.  Hence overload dwRet...
    if (npMCI->hThreadTermination = CreateThread(NULL, 0,
					(LPTHREAD_START_ROUTINE)mciaviTask,
					(LPVOID)npMCI, 0, &dwRet))

#endif
    {
	// check that the thread is actually created

	// either hEventResponse will be set, indicating that
	// the thread completed, or hThreadTermination will be
	// set, indicating that the thread aborted.
#if 0
	if (WaitForMultipleObjects(2,
	    &npMCI->hEventResponse, FALSE, INFINITE) == WAIT_OBJECT_0)
	{

	    // task completed ok
	    Assert(IsTask(npMCI->hTask));
	}
#else
	// We must process messages during this phase... IF messages
	// must be processed by this thread before the AVI window can
	// be created.  The most likely case is when a parent window
	// is passed and the parent window belongs to this (the UI)
	// thread.  If no messages need to be processed (i.e. the AVI
	// window being created has no parent) then we could use the
	// simpler code above.  DO THIS LATER.

	UINT n;

	while (WAIT_OBJECT_0+2 <= (n = MsgWaitForMultipleObjects(2,
	    &npMCI->hEventResponse, FALSE, INFINITE, QS_SENDMESSAGE)))
	{

	    MSG msg;
	    if (n!=WAIT_OBJECT_0+2) {
	        DPF0(("MsgWaitForMultipleObjects gave an unexpected return of %d\n", n));
	    }
	    PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
	    // PeekMessage with PM_NOREMOVE causes the inter thread
	    // sent messages to be processed
	}

	dwRet = 0;
	if (n == WAIT_OBJECT_0) {

	    // task completed ok
	    Assert(IsTask(npMCI->hTask));
	}
#endif
	else {
	    // hThreadTermination has been signalled - abort
	    CloseHandle(npMCI->hThreadTermination);
            npMCI->hThreadTermination = 0;
	    dwRet = npMCI->dwTaskError;
	    Assert(dwRet);
	}
    } else {
        npMCI->hTask = 0;
        dwRet = MCIERR_OUT_OF_MEMORY;
	npMCI->dwTaskError = GetLastError();
    }

    SetErrorMode(npMCI->uErrorMode);

    if (dwRet != 0) {
	// open failed - the necessary cleanup will be done in DeviceClose
	// which will be called after a bad return from DeviceOpen.  In
	// fact graphic.c (which calls DeviceOpen) will call GraphicClose
	// when DeviceOpen fails.  GraphicClose will then call DeviceClose
	// which will delete the cmdCritSec
    }

    return dwRet;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceClose | Close an AVI file.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceClose (NPMCIGRAPHIC npMCI)
{
    DWORD dw = 0L;

    if (npMCI && IsTask(npMCI->hTask)) {

	AssertUserThread(npMCI);
	// tell the worker to close and wait for it to happen
	mciaviTaskRequest(npMCI, AVI_CLOSE, 0, 0, 0, FALSE);
    }

    // must wait for thread to exit
    if (npMCI->hThreadTermination != 0) {

        /*
        ** Wait for the thread to complete so the DLL doesn't get unloaded
        ** while it's still executing code in that thread
        */

	// we must allow sendmessage at this point since the winproc thread
	// will block until it can send messages to our thread, and we are
	// waiting for the winproc thread to exit.
	// do not do this between setting hEventSend and receiving hEventResponse
	// though or we could re-enter the Request block and get confused
	// about whether we have seen hEventResponse.

	// we also need to yield in case we are on a wow thread - any
	// interthread sendmessage to another wow thread will block until
	// we yield here allowing other wow threads to run
	
	DWORD dw;

	do {

	    if (pWOWYield16) {
		pWOWYield16();
	    }

	    dw = MsgWaitForMultipleObjects(
		    1,
		    &npMCI->hThreadTermination,
		    FALSE,
		    100,
		    QS_SENDMESSAGE);

	
	    if (dw == WAIT_OBJECT_0 + 1) {

                MSG msg;
                DPF2(("rec'd sendmessage during shutdown wait\n"));

                // just a single peekmessage with NOREMOVE will
                // process the inter-thread send and not affect the queue
                PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
	    }
        } while (dw != WAIT_OBJECT_0);

	CloseHandle(npMCI->hThreadTermination);
        npMCI->hThreadTermination = 0;

    }

    if (TestNTFlags(npMCI, NTF_DELETECMDCRITSEC)) {
        DeleteCriticalSection(&npMCI->CmdCritSec);
    }
    if (npMCI->hEventSend) {
	CloseHandle(npMCI->hEventSend);
    }
    if (npMCI->hEventAllDone) {
	CloseHandle(npMCI->hEventAllDone);
    }
    if (npMCI->hEventResponse) {
	CloseHandle(npMCI->hEventResponse);
    }

    // uninitialize AVIFile and hence OLE - must be done on app thread
#ifdef USEAVIFILE
    //
    // we must do this so COMPOBJ will shut down right.
    //
    FreeAVIFile(npMCI);
#endif



    return dw;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DevicePlay | Play an AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwFlags | MCI flags from command.
 *
 * @parm LPMCI_DGV_PLAY_PARMS | lpPlay | Parameters for the play message.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL
DevicePlay(
    NPMCIGRAPHIC npMCI,
    DWORD dwFlags,
    LPMCI_DGV_PLAY_PARMS lpPlay,
    LPARAM dwCallback
)
{
    BOOL bWait = FALSE;
    DWORD dwErr;

    if (!IsTask(npMCI->hTask))
	return MCIERR_DEVICE_NOT_READY;

    // all handled by the worker thread
    AssertUserThread(npMCI);

    if (dwFlags & MCI_WAIT) {
	bWait = TRUE;
    }
    dwErr =  mciaviTaskRequest(npMCI,
	      AVI_PLAY, dwFlags, (LPARAM) lpPlay, dwCallback, bWait);

    if (dwFlags & (MCI_MCIAVI_PLAY_FULLSCREEN | MCI_MCIAVI_PLAY_FULLBY2)) {
	MSG	msg;
	
        DPF(("DevicePlay, removing stray messages\n"));
	/* Remove stray mouse and keyboard events after DispDib. */
	while (PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST,
					PM_NOYIELD | PM_REMOVE) ||
			PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
					PM_NOYIELD | PM_REMOVE))
	    ;
    }

    return dwErr;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceRealize | Updates the frame into the given DC
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data block.
 *
 * @parm BOOL | fForceBackground | Realize as background palette?
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceRealize(NPMCIGRAPHIC npMCI)
{
    BOOL bWait = FALSE;

    if (!IsTask(npMCI->hTask))
	return MCIERR_DEVICE_NOT_READY;

    // all handled by the worker thread
    AssertUserThread(npMCI);

    return mciaviTaskRequest(npMCI, AVI_REALIZE, 0, 0, 0, FALSE);

}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceStop | Stop an AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwFlags | Flags.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceStop(NPMCIGRAPHIC npMCI, DWORD dwFlags)
{
    DWORD dw = 0L;

    /* Stop the record or playback if the task is currently playing */

    if (!IsTask(npMCI->hTask)) {
        DPF0(("DeviceStop called on a dead task, npMCI=%8x\n", npMCI));
	return MCIERR_DEVICE_NOT_READY;
    }
	
    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_STOP, 0, 0, 0, FALSE);
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceUpdate | Updates the frame into the given DC
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data block.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceUpdate(
    NPMCIGRAPHIC npMCI,
    DWORD dwFlags,
    LPMCI_DGV_UPDATE_PARMS lpParms)
{

    if (!IsTask(npMCI->hTask))
        return MCIERR_DEVICE_NOT_READY;


    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_UPDATE, dwFlags, (LPARAM) lpParms, 0, FALSE);


}



/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DevicePause | Pause an AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwFlags | Flags.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DevicePause(NPMCIGRAPHIC npMCI, DWORD dwFlags, LPARAM dwCallback)
{
    if (!IsTask(npMCI->hTask))
        return MCIERR_DEVICE_NOT_READY;

    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_PAUSE, dwFlags, 0, dwCallback,
	    (dwFlags & MCI_WAIT));

}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceCue | Cue an AVI movie for playing.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm LONG | lTo | Frame to seek to, if MCI_TO set in <p dwFlags>.
 *
 * @parm DWORD | dwFlags | MCI flags from command.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceCue(NPMCIGRAPHIC npMCI, LONG lTo, DWORD dwFlags, LPARAM dwCallback)
{

    if (!IsTask(npMCI->hTask))
        return MCIERR_DEVICE_NOT_READY;

    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_CUE, dwFlags, lTo, dwCallback,
	    (dwFlags & MCI_WAIT));

}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceResume | Play an AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwFlags | MCI flags from command.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceResume(NPMCIGRAPHIC npMCI, DWORD dwFlags, LPARAM dwCallback)
{
    DWORD   dw = 0L;

    BOOL bWait = FALSE;

    if (!IsTask(npMCI->hTask))
	return MCIERR_DEVICE_NOT_READY;

    // all handled by the worker thread
    AssertUserThread(npMCI);

    if (dwFlags & MCI_WAIT) {
	bWait = TRUE;
    }
    return  mciaviTaskRequest(npMCI,
	      AVI_RESUME, dwFlags, 0, dwCallback, bWait);
}



/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSeek | Seek to a position in an AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm LONG | lTo | Frame to seek to.
 *
 * @parm DWORD | dwFlags | MCI flags from command.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceSeek(NPMCIGRAPHIC npMCI, LONG lTo, DWORD dwFlags, LPARAM dwCallback)
{
    if (!IsTask(npMCI->hTask))
        return MCIERR_DEVICE_NOT_READY;


    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_SEEK, dwFlags, lTo, dwCallback,
	    (dwFlags & MCI_WAIT));
}



/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSetActive | is the movie active?
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data block.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceSetActive(NPMCIGRAPHIC npMCI, BOOL fActive)
{
    // We cannot call   AssertUserThread(npMCI);
    // This routine is called on the winproc thread, as well as the user
    // thread.

    if (fActive)
        // We must explicitly request a unicode string.  %s will not
        // work as dprintf uses wvsprintfA
        DPF(("**** '%ls' is active.\n", (LPTSTR)npMCI->szFilename));

    return 0;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceStatus | Returns the current status
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data block.
 *
 * @rdesc Returns value for MCI's return value
 *
 ***************************************************************************/

UINT PASCAL DeviceMode(NPMCIGRAPHIC npMCI)
{
    if (!IsTask(npMCI->hTask)) {
	return MCI_MODE_NOT_READY;
    }

    // there is no point in synchronizing with the worker thread for
    // this since the task state will be transient anyway.
    // just grab a snapshot and return that.
    AssertUserThread(npMCI);

    switch (npMCI->wTaskState) {
	case TASKIDLE:	
	    return MCI_MODE_STOP;
	
        case TASKCUEING:	

	    // problem: some apps (notably mplayer) will be surprised to
	    // get MCI_MODE_SEEK immediately after issuing a PLAY command.
	    // on win-16 the yielding model meant that the app would not
	    // normally get control back until after the play proper had
	    // started and so would never see the cueing state.

	    // to avoid this confusion (and the bugs that arise from it), we
	    // never return MCI_MODE_SEEK: we report this mode as playing.
	    // this is often what would be seen on win-16 anyway (even in the
	    // case of a PLAY command ?).

            // Except... for apps that really do seek this can fool them into
            // thinking that they are playing.  So... we modify the algorithm
            // to return MODE_SEEK if lTo==lFrom (why is obvious) OR if
            // lRealStart==lTo.  This latter is because if you seek in mplayer
            // by dragging the thumb the image is only updated every key frame.
            // lRealStart is updated to this key frame while seeking

            //DPF0(("F: %8x, To=%d,  From=%d  lReal=%d lDrawn=%d Current=%d\n",
            //        npMCI->dwFlags, npMCI->lTo, npMCI->lFrom, npMCI->lRealStart, npMCI->lFrameDrawn, npMCI->lCurrentFrame));
            if ((npMCI->lTo == npMCI->lFrom)
                || (npMCI->lTo == npMCI->lRealStart)) {
                return(MCI_MODE_SEEK);
            }
	    return MCI_MODE_PLAY;
	
	case TASKSTARTING:	// ready? of course we're ready
	case TASKPLAYING:	
	    return MCI_MODE_PLAY;
	
	case TASKPAUSED:	
	    return MCI_MODE_PAUSE;
	
	default:
            DPF(("Unexpected state %d in DeviceMode()\n", npMCI->wTaskState));
            // fall through to the known states
	//case TASKBEINGCREATED:	
	//case TASKINIT:	
	case TASKCLOSE:	
	//case TASKREADINDEX:	
	    return MCI_MODE_NOT_READY;
    }
}



/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DevicePosition | Returns the current frame
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data block.
 *
 * @parm LPLONG | lpl | returns current frame
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DevicePosition(NPMCIGRAPHIC npMCI, LPLONG lpl)
{

    // read a snapshot of the current state without
    // synchronising with the worker thread!

    AssertUserThread(npMCI);
    return InternalGetPosition(npMCI, lpl);
}




/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSetWindow | Set window for display
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm HWND | hwnd | Window to display into.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 * @comm Should this only take effect at time of next play?
 *
 ***************************************************************************/

DWORD PASCAL DeviceSetWindow(NPMCIGRAPHIC npMCI, HWND hwnd)
{
    if (!IsTask(npMCI->hTask))
        return MCIERR_DEVICE_NOT_READY;


    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_WINDOW, 0, (LPARAM) hwnd, 0, FALSE);
}





/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSpeed | Adjust the playback speed of an AVI movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwNewSpeed | New speed, where 1000 is 'normal' speed.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 * @comm If we are currently playing, we stop the device, set our flag,
 *	and start playing again where we left off.  If we were paused,
 *	we end up stopped.  Is this bad?
 *      ** It is if you paused to change the speed then try and resume **
 *
 ***************************************************************************/

DWORD PASCAL DeviceSetSpeed(NPMCIGRAPHIC npMCI, DWORD dwNewSpeed)
{

    if (!IsTask(npMCI->hTask))
        return MCIERR_DEVICE_NOT_READY;


    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_SETSPEED, 0, (LPARAM) dwNewSpeed, 0, FALSE);
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceMute | Turn AVI sound on/off.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm BOOL | fMute | TRUE If sound should be turned off, FALSE
 *      if sound should stay on.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 * @comm If we are currently playing, we stop the device, set our flag,
 *	and start playing again where we left off.  If we were paused,
 *	we end up stopped.  Is this bad?
 *
 ***************************************************************************/

DWORD PASCAL DeviceMute(NPMCIGRAPHIC npMCI, BOOL fMute)
{

    if (!IsTask(npMCI->hTask))
        return MCIERR_DEVICE_NOT_READY;

    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_MUTE, 0, (LPARAM) fMute, 0, FALSE);
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSetVolume | Set AVI volume.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | dwVolume | ranges from 0 to 1000.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 * @comm If we are currently playing, we try to change the volume of the
 *	wave out device.
 *
 ***************************************************************************/

DWORD PASCAL DeviceSetVolume(NPMCIGRAPHIC npMCI, DWORD dwVolume)
{
    DWORD	dw = 0L;

    // switch audio off completely if setting volume level to 0, and back on
    // again if not.
    dw = DeviceMute(npMCI, (dwVolume == 0));
    if (dw != 0) {
	return dw;
    }

    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_SETVOLUME, 0, (LPARAM) dwVolume, 0, FALSE);
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceGetVolume | Check the wave output device's current
 *	volume.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 * @comm The volume is left in npMCI->dwVolume
 *
 * Issue: On devices with global volume control, like an SBPro, how should
 *	things work?
 *
 ***************************************************************************/
DWORD PASCAL DeviceGetVolume(NPMCIGRAPHIC npMCI)
{
    // all reference to the hWave *must* be done on the worker thread

    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_GETVOLUME, 0, 0, 0, FALSE);
}



/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSetAudioStream | Choose which audio stream to use.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm WORD | wStream | ranges from 1 to the number of streams.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceSetAudioStream(NPMCIGRAPHIC npMCI, UINT wAudioStream)
{
    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_AUDIOSTREAM, wAudioStream, 0, 0, FALSE);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSetVideoStream | Choose which video stream is the
 *  "default".  Also can enable/disable a stream.  this works for both
 *  video and "other" streams.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm WORD | wStream | ranges from 1 to the number of streams.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/

DWORD PASCAL DeviceSetVideoStream(NPMCIGRAPHIC npMCI, UINT uStream, BOOL fOn)
{
    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_AUDIOSTREAM, uStream, (BOOL)fOn, 0, FALSE);
}



/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DevicePut | Change source or destination rectangle
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm LPRECT | lprc | Pointer to new rectangle to use.
 *
 * @parm DWORD | dwFlags | Flags: will be either MCI_DGV_PUT_DESTINATION
 *	or MCI_DGV_PUT_SOURCE.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 * @comm
 *	If we end up using a custom stretch buffer, it would go here.
 *
 ***************************************************************************/
DWORD FAR PASCAL DevicePut(NPMCIGRAPHIC npMCI, LPRECT lprc, DWORD dwFlags)
{
    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_PUT, dwFlags, (LPARAM)lprc, 0, FALSE);
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSetPalette | Changes the override palette.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm HPALETTE | hpal | New palette to use.
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/
DWORD FAR PASCAL DeviceSetPalette(NPMCIGRAPHIC npMCI, HPALETTE hpal)
{
    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_PALETTE, 0, (LPARAM) hpal, 0, FALSE);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | DeviceSetPaletteColor | Changes the a single color
 *	in the movie's palette.
 *
 * @parm NPMCIGRAPHIC | npMCI | Pointer to instance data.
 *
 * @parm DWORD | index | color index to change
 *
 * @parm DWORD | color | color value to use
 *
 * @rdesc 0 means OK, otherwise mci error
 *
 ***************************************************************************/
DWORD FAR PASCAL DeviceSetPaletteColor(NPMCIGRAPHIC npMCI, DWORD index, DWORD color)
{

    AssertUserThread(npMCI);
    return mciaviTaskRequest(npMCI, AVI_PALETTECOLOR, color, (LPARAM) index, 0, FALSE);
}

//
// user-thread version of ResetDestRect - note that there is a similar
// winproc-thread-only version in window.c
//
void FAR PASCAL ResetDestRect(NPMCIGRAPHIC npMCI, BOOL fUseDefaultSizing)
{
    RECT    rc;

    /* WM_SIZE messages (on NT at least) are sometimes sent
     * during CreateWindow processing (eg if the initial window size
     * is not CW_DEFAULT). Some fields in npMCI are only filled in
     * after CreateWindow has returned. So there is a danger that at this
     * point some fields are not valid.
     */

    if (npMCI->hwndPlayback &&
        npMCI->hwndPlayback == npMCI->hwndDefault &&
        (npMCI->dwOptionFlags & MCIAVIO_STRETCHTOWINDOW)) {
        GetClientRect(npMCI->hwndPlayback, &rc);
    }

    // Only allow ZOOMBY2 and fixed % defaults for our default playback window
    else if ((npMCI->streams > 0) && (npMCI->hwndPlayback == npMCI->hwndDefault)) {
        rc = npMCI->rcMovie;

		if (fUseDefaultSizing)
			AlterRectUsingDefaults(npMCI, &rc);
    }
    else {
        return;
    }

    if (!IsRectEmpty(&rc)) {
		DevicePut(npMCI, &rc, MCI_DGV_PUT_DESTINATION);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\config.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1995. All rights reserved.

   Title:   config.c - Multimedia Systems Media Control Interface
            driver for AVI - configuration dialog.

*****************************************************************************/
#include "graphic.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof((x))/sizeof((x)[0]))
#endif

/*
#ifndef _WIN32
#define SZCODE char _based(_segname("_CODE"))
#else
#define SZCODE const TCHAR
#endif
*/

SZCODE szDEFAULTVIDEO[] = TEXT ("DefaultVideo");
SZCODE szSEEKEXACT[]    = TEXT ("AccurateSeek");
SZCODE szZOOMBY2[]              = TEXT ("ZoomBy2");
//SZCODE szSTUPIDMODE[] = TEXT ("DontBufferOffscreen");
SZCODE szSKIPFRAMES[]   = TEXT ("SkipFrames");
SZCODE szUSEAVIFILE[]   = TEXT ("UseAVIFile");
SZCODE szNOSOUND[]              = TEXT("NoSound");

const TCHAR szIni[]     = TEXT ("MCIAVI");

SZCODE gszMCIAVIOpt[]   = TEXT ("Software\\Microsoft\\Multimedia\\Video For Windows\\MCIAVI");
SZCODE gszDefVideoOpt[] = TEXT ("DefaultOptions");

#ifdef _WIN32
/* Registry values are stored as REG_DWORD */
int sz1 = 1;
int sz0 = 0;
#else
SZCODE sz1[] = TEXT("1");
SZCODE sz0[] = TEXT("0");
#endif

SZCODE szIntl[]         = TEXT ("Intl");
SZCODE szDecimal[]      = TEXT ("sDecimal");
SZCODE szThousand[] = TEXT ("sThousand");

SZCODE szDrawDib[]      = TEXT("DrawDib");
SZCODE szDVA[]          = TEXT("DVA");


typedef BOOL (WINAPI *SHOWMMCPLPROPSHEETW)(
                                                        HWND hwndParent,
                                                        LPCWSTR szPropSheetID,
                                                        LPWSTR  szTabName,
                                                        LPWSTR  szCaption);

/* Make sure we only have one configure box up at a time.... */
HWND    ghwndConfig = NULL;

//      Converts a Wide byte character string to a single byte character string
BOOL FAR PASCAL UnicodeToAnsi (
        char * pszDest,
        TCHAR * pszSrc,
        UINT cchMaxLen)
{

        if ((pszDest == NULL) ||
                (pszSrc == NULL) ||
                (cchMaxLen == 0))
                return FALSE;

        WideCharToMultiByte (CP_ACP, 0, pszSrc, -1,
                             pszDest, cchMaxLen,
                             NULL, NULL);
        return TRUE;
}



DWORD ReadOptionsFromReg(void)
{
        HKEY    hkVideoOpt;
        DWORD   dwType;
        DWORD   dwOpt;
        DWORD   cbSize;

    if (RegCreateKey(HKEY_CURRENT_USER, (LPTSTR)gszMCIAVIOpt, &hkVideoOpt))
                return 0;

        cbSize = sizeof(DWORD);
        if (RegQueryValueEx(hkVideoOpt,(LPTSTR)gszDefVideoOpt,
                                                NULL, &dwType, (LPBYTE)&dwOpt, &cbSize))
        {
                dwOpt = 0;
                RegSetValueEx(hkVideoOpt, (LPTSTR)gszDefVideoOpt, 0, REG_DWORD,(LPBYTE)&dwOpt, sizeof(DWORD));
        }

        RegCloseKey(hkVideoOpt);

        return dwOpt;
}


DWORD FAR PASCAL ReadConfigInfo(void)
{
    DWORD       dwOptions = 0L;

        dwOptions = ReadOptionsFromReg();

        //
    // ask the display device if it can do 256 color.
    //
#ifndef _WIN32
    int         i;

/*
**      Bugbug - not apparently used, so why do it ?!?
**
    HDC         hdc;
    hdc = GetDC(NULL);
    i = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
    ReleaseDC(NULL, hdc);
**
**
*/

    i = mmGetProfileInt(szIni, szDEFAULTVIDEO,
                (i < 8 && (GetWinFlags() & WF_CPU286)) ? 240 : 0);

    if (i >= 200)
                dwOptions |= MCIAVIO_USEVGABYDEFAULT;
#endif

////if (mmGetProfileInt(szIni, szSEEKEXACT, 1))
        // Note: We always want this option.
        dwOptions |= MCIAVIO_SEEKEXACT;

//    if (mmGetProfileInt(szIni, szZOOMBY2, 0))
//              dwOptions |= MCIAVIO_ZOOMBY2;

////if (mmGetProfileInt(szIni, szFAILIFNOWAVE, 0))
////    dwOptions |= MCIAVIO_FAILIFNOWAVE;

//  if (mmGetProfileInt(szIni, szSTUPIDMODE, 0))
//              dwOptions |= MCIAVIO_STUPIDMODE;

        // Note:  These settings are still in WIN.INI, not the registry
        //        I know.
    if (mmGetProfileInt(szIni, szSKIPFRAMES, 1))
        dwOptions |= MCIAVIO_SKIPFRAMES;

    if (mmGetProfileInt(szIni, szUSEAVIFILE, 0))
        dwOptions |= MCIAVIO_USEAVIFILE;

    if (mmGetProfileInt(szIni, szNOSOUND, 0))
        dwOptions |= MCIAVIO_NOSOUND;

    if (mmGetProfileInt(szDrawDib, szDVA, TRUE))
        dwOptions |= MCIAVIO_USEDCI;

        return dwOptions;
}

void FAR PASCAL WriteConfigInfo(DWORD dwOptions)
{
#ifndef _WIN32
    // !!! This shouldn't get written out if it is the default!
    mmWriteProfileString(szIni, szDEFAULTVIDEO,
         (dwOptions & MCIAVIO_USEVGABYDEFAULT) ? szVIDEO240 : szVIDEOWINDOW);
#endif

////mmWriteProfileInt(szIni, szSEEKEXACT,
////        (dwOptions & MCIAVIO_SEEKEXACT) ? sz1 : sz0);

//    mmWriteProfileInt(szIni, szZOOMBY2,
//          (dwOptions & MCIAVIO_ZOOMBY2) ? sz1 : sz0);

    mmWriteProfileInt(szDrawDib, szDVA,
            (dwOptions & MCIAVIO_USEDCI) ? sz1 : sz0);

////mmWriteProfileInt(szIni, szFAILIFNOWAVE,
////        (dwOptions & MCIAVIO_FAILIFNOWAVE) ? sz1 : sz0);

//  mmWriteProfileInt(szIni, szSTUPIDMODE,
//            (dwOptions & MCIAVIO_STUPIDMODE) ? sz1 : sz0);

    mmWriteProfileInt(szIni, szSKIPFRAMES,
            (dwOptions & MCIAVIO_SKIPFRAMES) ? sz1 : sz0);

    mmWriteProfileInt(szIni, szUSEAVIFILE,
            (dwOptions & MCIAVIO_USEAVIFILE) ? sz1 : sz0);

    mmWriteProfileInt(szIni, szNOSOUND,
            (dwOptions & MCIAVIO_NOSOUND) ? sz1 : sz0);
}


BOOL FAR PASCAL ConfigDialog(HWND hWnd, NPMCIGRAPHIC npMCI)
{
        #define MAX_WINDOWS 10
    HWND                                hWndActive[MAX_WINDOWS];
    BOOL                                fResult = FALSE;
    INT                                 ii;
    HWND                                hWndTop;
    HINSTANCE                   hInst;
    SHOWMMCPLPROPSHEETW  fnShow;
    DWORD                               dwOptionFlags;
    WCHAR                               szCaptionW[128];
        WCHAR                           szTabW[40];
        UINT                cchLen;

    LoadStringW(ghModule, IDS_VIDEOCAPTION, szCaptionW, ARRAYSIZE(szCaptionW));

    //Maybe the user is trying to get this dialog back because it is lost somewhere on
    //his/her desktop. Bring back to the top. (SetFocus does not work across threads).
    if (ghwndConfig)
        {
        BringWindowToTop(FindWindowW(NULL, szCaptionW));
        return FALSE;
    }

    if (hWnd == NULL)
        hWnd = GetActiveWindow();

    //
    // Enumerate all the Top level windows of this task and disable them!
    //
    for (hWndTop = GetWindow(GetDesktopWindow(), GW_CHILD), ii=0;
         hWndTop && ii < MAX_WINDOWS;
         hWndTop = GetWindow(hWndTop, GW_HWNDNEXT)) {

        if (IsWindowEnabled(hWndTop) &&
            IsWindowVisible(hWndTop) &&
                (HTASK)GetWindowTask(hWndTop) == GetCurrentTask() &&
                hWndTop != hWnd)
                {
                        // don't disable our parent
            hWndActive[ii++] = hWndTop;
            EnableWindow(hWndTop, FALSE);
        }
    }

    //
    // Don't let anyone try to bring up another config sheet
    //
    if (hWnd)
                ghwndConfig = hWnd;
    else
                ghwndConfig = (HWND)0x800;    // just in case - make sure it's non-zero

    //
    // Bring up the MCIAVI configure sheet from inside mmsys.cpl
    //
        hInst = LoadLibrary (TEXT ("mmsys.cpl"));
    if (hInst)
        {
                fnShow = (SHOWMMCPLPROPSHEETW)GetProcAddress(hInst, "ShowMMCPLPropertySheetW");

                if (fnShow)
                {
                        // Note: This string is not localizable
                        static const WCHAR szVideoW[] = L"VIDEO";

                        LoadStringW(ghModule, IDS_VIDEO, szTabW, ARRAYSIZE(szTabW));
                        fResult = fnShow(hWnd, szVideoW, szTabW, szCaptionW);

                        //
                        // Make sure the dialog changes get picked up right away
                        // Only change those possibly affected by the dialog.
                        // !!! This is a little hacky; knowing which ones get changed
                        //
                        if (npMCI && fResult)
                        {
                                dwOptionFlags = ReadConfigInfo();
                                npMCI->dwOptionFlags &= ~MCIAVIO_WINDOWSIZEMASK;
                                npMCI->dwOptionFlags &= ~MCIAVIO_ZOOMBY2;
                                npMCI->dwOptionFlags &= ~MCIAVIO_USEVGABYDEFAULT;
                                npMCI->dwOptionFlags |= dwOptionFlags &
                                                                                (MCIAVIO_WINDOWSIZEMASK | MCIAVIO_ZOOMBY2 |
                                                                                 MCIAVIO_USEVGABYDEFAULT);
                        }
                }

                FreeLibrary(hInst);
        }

    //
    // Restore all windows
    //
    while (ii-- > 0)
        EnableWindow(hWndActive[ii], TRUE);

    if (hWnd)
        SetActiveWindow(hWnd);

    ghwndConfig = NULL;

    return fResult;
}

// This function should be called only to verify that we should be using
//
//
//

#ifdef _WIN32

TCHAR szWow32[] = TEXT("wow32.dll");
CHAR szWOWUseMciavi16Proc[] = "WOWUseMciavi16";

typedef BOOL (*PFNWOWUSEMCIAVI16PROC)(VOID);

BOOL FAR PASCAL WowUseMciavi16(VOID)
{
   HMODULE hWow32;
   BOOL fUseMciavi16 = FALSE;
   PFNWOWUSEMCIAVI16PROC pfnWOWUseMciavi16Proc;

   if (NULL != (hWow32 = GetModuleHandle(szWow32))) {
      pfnWOWUseMciavi16Proc = (PFNWOWUSEMCIAVI16PROC)GetProcAddress(hWow32, szWOWUseMciavi16Proc);
      if (NULL != pfnWOWUseMciavi16Proc) {
         fUseMciavi16 = (*pfnWOWUseMciavi16Proc)();
      }
   }

   return(fUseMciavi16);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\fullproc.c ===
/****************************************************************************
 *
 *  DRAWPROC.C
 *
 *  Standard AVI drawing handler.
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#ifdef _WIN32
#include "graphic.h"
#include <mmddk.h>
#include "profile.h"
#endif
#include <win32.h>
#include <vfw.h>
#include <dispdib.h>

#ifdef _WIN32
static SZCODE szAtomFlag[] = TEXT("aviFullscreen");

static SZCODE szDisplayDibLib[] = TEXT("DISPDB32.DLL");
#else
static SZCODE szDisplayDibLib[] = TEXT("DISPDIB.DLL");
#endif
static SZCODEA szDisplayDibEx[]  = "DisplayDibEx";

#define FOURCC_VIDS         mmioFOURCC('v','i','d','s')
#define FOURCC_AVIFull      mmioFOURCC('F','U','L','L')
#define VERSION_AVIFull     0x00010000      // 1.00

#ifndef HUGE
    #define HUGE _huge
#endif

extern FAR PASCAL LockCurrentTask(BOOL);

static int siUsage = 0;

static HINSTANCE	ghDISPDIB = NULL; // handle to DISPDIB.DLL module
UINT (FAR PASCAL *DisplayDibExProc)(LPBITMAPINFOHEADER lpbi, int x, int y, LPSTR hpBits, UINT wFlags)=NULL;

/***************************************************************************
 ***************************************************************************/

typedef struct {
    int                 xDst;           // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;
    int                 xSrc;           // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;
    HWND		hwnd;
    HWND                hwndOldFocus;
    BOOL                fRle;
    DWORD               biSizeImage;
} INSTINFO, *PINSTINFO;

// static stuff in this file.
LRESULT FAR PASCAL _loadds ICAVIFullProc(DWORD_PTR id, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2);
static LRESULT AVIFullOpen(ICOPEN FAR * icopen);
static LONG AVIFullClose(PINSTINFO pi);
static LONG AVIFullGetInfo(ICINFO FAR *icinfo, LONG lSize);
static LONG AVIFullQuery(PINSTINFO pi, LPBITMAPINFOHEADER lpbiIn);
static LONG AVIFullSuggestFormat(PINSTINFO pi, ICDRAWSUGGEST FAR *lpicd, LONG cbicd);
static LONG AVIFullBegin(PINSTINFO pi, ICDRAWBEGIN FAR *lpicd, LONG cbicd);
static LONG AVIFullDraw(PINSTINFO pi, ICDRAW FAR *lpicd, LONG cbicd);
static LONG AVIFullEnd(PINSTINFO pi);


/* -------------------------------------------------------------------------
** Private Globals
** These are only valid in the process that started playing the movie.
** -------------------------------------------------------------------------
*/
#include "common.h"

HWND        hwndFullScreen;
HDC         hdcFullScreen;
HDRAWDIB    hdd;
BOOL        fClassRegistered;
int         dxScreen;
int         dyScreen;
int         iMovieSizeMultiplier;


/***************************************************************************
 ***************************************************************************/

LRESULT FAR PASCAL _loadds ICAVIFullProc(DWORD_PTR id, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2)
{
    INSTINFO *pi = (INSTINFO *)id;

    switch (uiMessage)
    {
        case DRV_LOAD:
	    return 1;
	
        case DRV_FREE:
            return 1;

        /*********************************************************************
            open
        *********************************************************************/

        case DRV_OPEN:
	    if (ghDISPDIB == NULL) {
		UINT w;

		w = SetErrorMode(SEM_NOOPENFILEERRORBOX);

		if ((INT_PTR)(ghDISPDIB = (HINSTANCE)LoadLibrary(szDisplayDibLib)) > HINSTANCE_ERROR) {
		    (FARPROC)DisplayDibExProc = GetProcAddress(ghDISPDIB, szDisplayDibEx);
		}
		else
		    ghDISPDIB = (HINSTANCE)-1;

		SetErrorMode(w);
	    }

	    if (DisplayDibExProc == NULL)
		DisplayDibExProc = DisplayDibEx;
	
            if (lParam2 == 0L)
                return 1;

            return AVIFullOpen((ICOPEN FAR *)lParam2);

	case DRV_CLOSE:
	    if (id == 1)
		return 1;

            return AVIFullClose(pi);

        /*********************************************************************
            Configure/Info messages
        *********************************************************************/

        case DRV_QUERYCONFIGURE:    // configuration from drivers applet
            return 0;

        case DRV_CONFIGURE:
            return 1;

        case ICM_CONFIGURE:
        case ICM_ABOUT:
            return ICERR_UNSUPPORTED;

        /*********************************************************************
            state messages
        *********************************************************************/

        case ICM_GETSTATE:
        case ICM_SETSTATE:
            return 0L;

#if 0
        case ICM_GETINFO:
            return AVIFullGetInfo((ICINFO FAR *)lParam1, lParam2);
#endif

        /*********************************************************************
            decompress messages
        *********************************************************************/

        case ICM_DRAW_QUERY:
            return AVIFullQuery(pi, (LPBITMAPINFOHEADER)lParam1);

	case ICM_DRAW_SUGGESTFORMAT:
	    return AVIFullSuggestFormat(pi, (ICDRAWSUGGEST FAR *) lParam1, (LONG) lParam2);

        case ICM_DRAW_BEGIN:
	    return AVIFullBegin(pi, (ICDRAWBEGIN FAR *) lParam1, (LONG) lParam2);

        case ICM_DRAW_REALIZE:
            if (DisplayDibExProc == DisplayDibEx) {

                if (hdd == NULL || hdcFullScreen == NULL) {
                    break;
                }

                return DrawDibRealize( hdd, hdcFullScreen, (BOOL)lParam2 );
            }
            break;

	case ICM_DRAW_GET_PALETTE:
            if (DisplayDibExProc == DisplayDibEx) {

	        if (NULL != hdd) {
	            return (LONG_PTR)DrawDibGetPalette(hdd);
                }
            }
            break;


        case ICM_DRAW:
            return AVIFullDraw(pi, (ICDRAW FAR *)lParam1, (LONG) lParam2);

	case ICM_DRAW_CHANGEPALETTE:
	    DisplayDibExProc((LPBITMAPINFOHEADER) lParam1, 0, 0, NULL,
			DISPLAYDIB_NOWAIT | DISPLAYDIB_NOIMAGE);

	    return ICERR_OK;

        case ICM_DRAW_END:
            return AVIFullEnd(pi);

        /*********************************************************************
            standard driver messages
        *********************************************************************/

        case DRV_DISABLE:
        case DRV_ENABLE:
            return 1;

        case DRV_INSTALL:
        case DRV_REMOVE:
            return 1;
    }

    if (uiMessage < DRV_USER)
        return DefDriverProc(id,hDriver,uiMessage,lParam1,lParam2);
    else
        return ICERR_UNSUPPORTED;
}

/*****************************************************************************
 *
 * AVIFullOpen() is called from the DRV_OPEN message
 *
 ****************************************************************************/

static LONG_PTR AVIFullOpen(ICOPEN FAR * icopen)
{
    INSTINFO *  pinst;

    //
    // refuse to open if we are not being opened as a Video compressor
    //
    if (icopen->dwFlags & ICMODE_COMPRESS)
        return 0;

    if (icopen->dwFlags & ICMODE_DECOMPRESS)
        return 0;

    pinst = (INSTINFO *)LocalAlloc(LPTR, sizeof(INSTINFO));

    if (!pinst)
    {
        icopen->dwError = ICERR_MEMORY;
        return 0;
    }

    ++siUsage;

    //
    // return success.
    //
    icopen->dwError = ICERR_OK;

    return (LONG_PTR) (UINT_PTR) pinst;
}

/*****************************************************************************
 *
 * Close() is called on the DRV_CLOSE message.
 *
 ****************************************************************************/
static LONG AVIFullClose(PINSTINFO pi)
{
    LocalFree((HLOCAL) pi);

    if (--siUsage == 0) {
	/* unload DISPDIB library (if loaded) */
	if (ghDISPDIB != NULL && ghDISPDIB != (HINSTANCE) -1)
	    FreeLibrary(ghDISPDIB), ghDISPDIB = NULL;
    }

    return 1;
}

#if 0
/*****************************************************************************
 *
 * AVIFullGetInfo() implements the ICM_GETINFO message
 *
 ****************************************************************************/
static LONG AVIFullGetInfo(ICINFO FAR *icinfo, LONG lSize)
{
    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (lSize < sizeof(ICINFO))
        return 0;

    icinfo->dwSize	    = sizeof(ICINFO);
    icinfo->fccType         = FOURCC_VIDS;
    icinfo->fccHandler      = FOURCC_AVIFull;
    icinfo->dwFlags	    = VIDCF_DRAW;
    icinfo->dwVersion       = VERSION_AVIFull;
    icinfo->dwVersionICM    = ICVERSION;
    lstrcpy(icinfo->szDescription, szDescription);
    lstrcpy(icinfo->szName, szName);

    return sizeof(ICINFO);
}
#endif

/*****************************************************************************
 *
 * AVIFullQuery() implements ICM_DRAW_QUERY
 *
 ****************************************************************************/
static LONG AVIFullQuery(PINSTINFO pi,
			 LPBITMAPINFOHEADER lpbiIn)
{
    //
    // determine if the input DIB data is in a format we like.
    //
    if (lpbiIn == NULL)
        return ICERR_BADFORMAT;

    if (DisplayDibExProc(lpbiIn, 0, 0, 0,
                DISPLAYDIB_MODE_DEFAULT|DISPLAYDIB_NOWAIT|DISPLAYDIB_TEST) != 0)
	return ICERR_BADFORMAT;

    return ICERR_OK;
}


static LONG AVIFullSuggestFormat(PINSTINFO pi, ICDRAWSUGGEST FAR *lpicd, LONG cbicd)
{
    HIC hic;
    static int iFull = -1;
    int	iDepth;

    if (iFull < 0) {
	BITMAPINFOHEADER bih;

	bih.biSize = sizeof(bih);
	bih.biBitCount = 16;
	bih.biCompression = BI_RGB;
	bih.biWidth = 160;
	bih.biHeight = 120;

	iFull = (AVIFullQuery(pi, &bih) == ICERR_OK) ? 1 : 0;
    }

    iDepth = lpicd->lpbiIn->biBitCount > 8 && iFull == 1 ? 16 : 8;

    if (lpicd->lpbiSuggest == NULL)
	return sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD);

    hic = ICGetDisplayFormat(NULL, lpicd->lpbiIn,
			     lpicd->lpbiSuggest,
			     iDepth, 0, 0);

    if (hic)
	ICClose(hic);


    return sizeof(BITMAPINFOHEADER) + lpicd->lpbiSuggest->biClrUsed * sizeof(RGBQUAD);
}

/*****************************************************************************
 *
 * AVIFullBegin() implements ICM_DRAW_BEGIN
 *
 ****************************************************************************/

static LONG AVIFullBegin(PINSTINFO pi, ICDRAWBEGIN FAR *lpicd, LONG cbicd)
{
    UINT	w;
    LONG	lRet;
    UINT        wFlags = DISPLAYDIB_BEGIN | DISPLAYDIB_NOWAIT;

    if (!(lpicd->dwFlags & ICDRAW_FULLSCREEN))
	return ICERR_UNSUPPORTED; // !!! Necessary?

    lRet = AVIFullQuery(pi, lpicd->lpbi);
    if (lRet != 0 || (lpicd->dwFlags & ICDRAW_QUERY))
	return lRet;

    // Copy over whatever we want to remember
    pi->hwnd = lpicd->hwnd;
    pi->xDst = lpicd->xDst;
    pi->yDst = lpicd->yDst;
    pi->dxDst = lpicd->dxDst;
    pi->dyDst = lpicd->dyDst;
    pi->xSrc = lpicd->xSrc;
    pi->ySrc = lpicd->ySrc;
    pi->dxSrc = lpicd->dxSrc;
    pi->dySrc = lpicd->dySrc;

    if (pi->dxDst > pi->dxSrc)
	wFlags |= DISPLAYDIB_ZOOM2;

    //
    //  remember if this is RLE because we may need to hack it later.
    //
    pi->fRle = lpicd->lpbi->biCompression == BI_RLE8;
    pi->biSizeImage = (DWORD)(((UINT)lpicd->lpbi->biWidth+3)&~3)*(DWORD)(UINT)lpicd->lpbi->biHeight;

    pi->hwndOldFocus = GetFocus();
    SetFocus(NULL);

    /*
    ** If we are using the built in fullscreen support we have to
    ** get the hdd and set its palette here.  This is because I am unable to
    ** pass this information to DispDib code (there arn't any free parameters).
    */
    if (DisplayDibExProc == DisplayDibEx) {

        hdd = DrawDibOpen();

        if (lpicd->hpal == (HPALETTE)MCI_AVI_SETVIDEO_PALETTE_HALFTONE) {
            DrawDibSetPalette(hdd, NULL);
        }
        else {
            DrawDibSetPalette(hdd, lpicd->hpal);
        }
    }


    // Don't animate if we're realizing in the background
    if (lpicd->dwFlags & ICDRAW_ANIMATE) {
        wFlags |= DISPLAYDIB_ANIMATE;
    }

    if (lpicd->hpal == (HPALETTE)MCI_AVI_SETVIDEO_PALETTE_HALFTONE) {
        wFlags |= DISPLAYDIB_HALFTONE;
    }

    //
    // we dont need to do this, DISPDIB will do it for us
    //
#if 0
    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
    LockCurrentTask(TRUE);
#endif

    /* Capture the mouse, so other apps don't get called. */
    SetCapture(pi->hwnd);

    /* We don't explicitly specify a graphics mode; DispDib will
    ** choose one for us.
    */
    w = DisplayDibExProc(lpicd->lpbi, 0, 0, NULL, wFlags );

    switch (w) {
	case DISPLAYDIB_INVALIDFORMAT:
	    return ICERR_BADFORMAT;
	
	case 0:
	    return ICERR_OK;

	default:
	    return ICERR_UNSUPPORTED;
    }
}


/*****************************************************************************
 *
 * AVIFullDraw() implements ICM_DRAW
 *
 ****************************************************************************/

STATICFN LONG AVIFullDraw(PINSTINFO pi, ICDRAW FAR *lpicd, LONG cbicd)
{
    UINT    wFlags;
    UINT    w;

    wFlags = DISPLAYDIB_NOPALETTE | DISPLAYDIB_NOWAIT;

    if (pi->dxDst > pi->dxSrc) {
	wFlags |= DISPLAYDIB_ZOOM2;
    }

    if (lpicd->dwFlags & ICDRAW_NULLFRAME) {
	return ICERR_OK;  // !!!
    }

    if (lpicd->dwFlags & ICDRAW_PREROLL) {
	if (((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression == BI_RGB) // !!!
	    return ICERR_OK;
    }

    if (lpicd->dwFlags & ICDRAW_HURRYUP)
	; // !!! DONTDRAW?

    if (lpicd->lpData == NULL)
        return ICERR_UNSUPPORTED;

    //
    // We need a hack here for the RLE case, to make sure that
    // DIBs are marked correctly as BI_RLE8 or BI_RGB....
    //
    if (pi->fRle) {
        if (lpicd->cbData == pi->biSizeImage)
            ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression = BI_RGB;
	else {
            ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression = BI_RLE8;
	    // We MUST set the correct size
	    ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biSizeImage = lpicd->cbData;
	}
    }

    w = DisplayDibExProc(lpicd->lpFormat, 0, 0, lpicd->lpData, wFlags);

    if (pi->fRle)
        ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression = BI_RLE8;

    switch (w) {
	case DISPLAYDIB_STOP: 		return ICERR_STOPDRAWING;
	case DISPLAYDIB_NOERROR: 	return ICERR_OK;
	default: 			return ICERR_ERROR;
    }
}

/*****************************************************************************
 *
 * AVIFullEnd() implements ICM_DRAW_END
 *
 ****************************************************************************/

static LONG AVIFullEnd(PINSTINFO pi)
{
    MSG  msg;
	
    DisplayDibExProc(NULL, 0, 0, NULL, DISPLAYDIB_END | DISPLAYDIB_NOWAIT);

    //
    // we dont need to do this, DISPDIB will do it for us
    //
#if 0
    LockCurrentTask(FALSE);

    /* Can we assume the error mode should be 0? */
    SetErrorMode(0);
#endif

    ReleaseCapture();

    /* Clear out left-over key messages */
    while (PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST,
			PM_REMOVE | PM_NOYIELD))
	;
    /* Clear out left-over mouse messages */
    while (PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
			PM_REMOVE | PM_NOYIELD))
	;
    SetFocus(pi->hwndOldFocus);

    return ICERR_OK;
}




/* -------------------------------------------------------------------------
** Private constants
** -------------------------------------------------------------------------
*/
#define CX_MAX_MOVIE_DEFAULT  640
#define CY_MAX_MOVIE_DEFAULT  480

/* -------------------------------------------------------------------------
** Private functions prototypes
** -------------------------------------------------------------------------
*/
LRESULT CALLBACK
FullScreenWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
KeyboardHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    );

UINT
DisplayDibEnter(
    LPBITMAPINFOHEADER lpbi,
    UINT wFlags
    );

void
DisplayDibLeave(
    UINT wFlags
    );

int
DisplayCalcMovieMultiplier(
    int cxOriginal,
    int cyOriginal,
    DWORD dwCompression
    );







/* -------------------------------------------------------------------------
** Global data shared between all processes that attach to this library.
** This is required to make the keyboard hook work correctly.
** -------------------------------------------------------------------------
*/
//#define StopRequested()  (fStop)
#define   StopRequested()  (GlobalFindAtom(szAtomFlag))

#pragma data_seg( ".sdata" , "DATA")
BOOL    fStop;
HHOOK   hHookK;
#pragma data_seg()





/******************************Public*Routine******************************\
* @doc EXTERNAL DISPDIB
*
* @api UINT | DisplayDibEx | This function displays a 256-color bitmap on a
*    standard VGA display. It reduces the display resolution to 320-by-200
*    or 320-by-240 and uses the full screen to display the bitmap, clipping
*    and centering it as necessary. The function normally does not return to
*    the application until the user presses a key or clicks a mouse button.
*
*    To call <f DisplayDibEx>, an application must be the active
*    application. All inactive applications and GDI screen updates
*    are suspended while <f DisplayDib> temporarily reconfigures
*    the display.
*
* @parm LPBITMAPINFO | lpbi | Specifies a pointer to a <t BITMAPINFO>
*    header describing the bitmap to be displayed.
*
* @parm int | x | x position to place DIB iff DISPLAYDIB_NOCENTER flags is set
*      the lower left is (0,0)
*
* @parm int | y | y position to place DIB iff DISPLAYDIB_NOCENTER flags is set
*      the lower left is (0,0)
*
* @parm LPSTR | lpBits | Specifies a pointer to the bitmap bits. If this
*     parameter is NULL, the bits are assumed to follow the
*     <t BITMAPINFO> structure pointed to by <p lpbi>.
*
* @parm UINT | wFlags | Specifies options for displaying the bitmap. Use
*  the following flags:
*
* @flag  DISPLAYDIB_MODE_DEFAULT | Use the default mode (320 by 240)
*    to display the bitmap.
* @flag  DISPLAYDIB_MODE_320x200x8 | Use 320-by-200 mode to display
*    the bitmap.
* @flag  DISPLAYDIB_MODE_320x240x8 | Use 320-by-240 mode to display
*    the bitmap. This is the default.
* @flag  DISPLAYDIB_NOWAIT | Return immediately after displaying the
*  bitmap; don't wait for a key press or mouse click before returning.
* @flag  DISPLAYDIB_NOPALETTE      | Ignore the palette associated
*    with the bitmap. You can use this flag when displaying a series
*    of bitmaps that use a common palette.
* @flag  DISPLAYDIB_NOCENTER       | Don't center the image. The function
*  displays the bitmap in the lower-left corner of the display.
* @flag  DISPLAYDIB_NOIMAGE        | Don't draw image
* @flag  DISPLAYDIB_ZOOM2          | Stretch image by 2
* @flag  DISPLAYDIB_DONTLOCKTASK   | dont lock out other tasks
* @flag  DISPLAYDIB_TEST           | dont do any thing just test for support
* @flag  DISPLAYDIB_BEGIN          | Switch to the low-resolution
*    display mode and set the palette. The bitmap is not displayed.
*
*    If you are displaying a series of images that use the same palette,
*    you can call <f DisplayDib> with this flag to prepare the display for
*    the bitmaps, then make a series of <f DisplayDib> calls with the
*    DISPLAYDIB_NOPALETTE flag. This technique
*    eliminates the screen flicker that occurs when the display is
*    switched between the low-resolution and standard VGA modes.
*    To return the display to standard VGA mode, subsequently
*    call <f DisplayDib> with the DISPLAYDIB_END flag.
*
* @flag  DISPLAYDIB_END            | Switch back to standard VGA mode
*    and return without displaying a bitmap. Signifies the end of multiple
*    calls to <f DisplayDib>. With this flag, you can specify
*    NULL for the <p lpbi> and <p lpBits> parameters.
*
* @rdesc Returns zero if successful, otherwise returns an error code.
*  Error codes are as follows:
*
* @flag  DISPLAYDIB_NOTSUPPORTED   | <f DisplayDib> is not supported
*   in the current mode.
* @flag  DISPLAYDIB_INVALIDDIB     | The bitmap specified by
*   <p lpbi> is not a valid bitmap.
* @flag  DISPLAYDIB_INVALIDFORMAT  | The bitmap specified by
*   <p lpbi> specifes a type of bitmap that is not supported.
* @flag  DISPLAYDIB_INVALIDTASK    | The caller is an inactive application.
*   <f DisplayDib> can only be called by an active application.
*
* @comm The <f DisplayDib> function displays bitmaps described with
*    the Windows 3.0 <t BITMAPINFO> data structure in either BI_RGB
*    or BI_RLE8 format; it does not support bitmaps described with
*    the OS/2 <t BITMAPCOREHEADER> data structure.
*
*    When <f DisplayDib> switches to a low-resolution display, it
*    disables the current display driver. As a result, you cannot use GDI
*    functions to update the display while <f DisplayDib> is displaying a
*    bitmap.
*
*
* History:
* 23-03-94 - StephenE - Created
*
\**************************************************************************/
UINT FAR PASCAL
DisplayDibEx(
    LPBITMAPINFOHEADER lpbi,
    int x,
    int y,
    LPSTR lpBits,
    UINT wFlags
    )
{
    DWORD       wNumColors;
    LONG        yExt;
    LONG        xExt;
    int         xScreen,yScreen;

    /*
    ** If not already done so:
    **      Register our class and Create our window "fullscreen"
    */
    if (wFlags & DISPLAYDIB_BEGIN) {

        DPF4(( "DISPLAYDIB_BEGIN..." ));

        return DisplayDibEnter( lpbi, wFlags );
    }

    /*
    ** Just testing return OK
    */
    else if (wFlags & DISPLAYDIB_TEST) {

        DPF1(( "lpbi->biCompression = 0x%X = %c%c%c%c",
                lpbi->biCompression,
                *((LPSTR)&lpbi->biCompression + 0),
                *((LPSTR)&lpbi->biCompression + 1),
                *((LPSTR)&lpbi->biCompression + 2),
                *((LPSTR)&lpbi->biCompression + 3) ));

        DPF4(( "DISPLAYDIB_TEST... returning OK" ));
        return DISPLAYDIB_NOERROR;
    }

    /*
    ** Palette change message
    */
    else if ( (wFlags & (DISPLAYDIB_NOWAIT | DISPLAYDIB_NOIMAGE)) ==
              (DISPLAYDIB_NOWAIT | DISPLAYDIB_NOIMAGE) ) {

        PALETTEENTRY    ape[256];
        LPRGBQUAD       lprgb;
        int             i;

        lprgb = (LPRGBQUAD) ((LPBYTE) lpbi + lpbi->biSize);

        for (i = 0; i < (int) lpbi->biClrUsed; i++) {
            ape[i].peRed = lprgb[i].rgbRed;
            ape[i].peGreen = lprgb[i].rgbGreen;
            ape[i].peBlue = lprgb[i].rgbBlue;
            ape[i].peFlags = 0;
        }

        DrawDibChangePalette(hdd, 0, (int)lpbi->biClrUsed, (LPPALETTEENTRY)ape);

        return DISPLAYDIB_NOERROR;
    }

    /*
    ** Time to kill the window and the class
    */
    else if (wFlags & DISPLAYDIB_END) {

        DPF4(( "DISPLAYDIB_END..." ));
        DisplayDibLeave( wFlags );
        return DISPLAYDIB_NOERROR;
    }

    /*
    ** Do the drawing here !!
    */
    else if ( !StopRequested() ) {

        /*
        ** If we were'nt asked to draw anything just return.
        */
        if ( wFlags & DISPLAYDIB_NOIMAGE ) {
            return DISPLAYDIB_NOERROR;
        }

        xExt = lpbi->biWidth;
        yExt = lpbi->biHeight;

        if ( wFlags & DISPLAYDIB_ZOOM2 ) {

            xExt <<= 1;
            yExt <<= 1;
        }
        else if ( iMovieSizeMultiplier ) {
			//The movie needs to be stretched to full screen.
			xExt = GetSystemMetrics( SM_CXSCREEN );
            yExt = GetSystemMetrics( SM_CYSCREEN );
        }

        wNumColors  = lpbi->biClrUsed;
        if (wNumColors == 0 && lpbi->biBitCount <= 8) {
            wNumColors = 1 << (UINT)lpbi->biBitCount;
        }

        /*
        ** setup pointers
        */
        if (lpBits == NULL) {
            lpBits = (LPBYTE)lpbi + lpbi->biSize + wNumColors * sizeof(RGBQUAD);
        }

        /*
        **  center the image
        */
        if (!(wFlags & DISPLAYDIB_NOCENTER)) {

            xScreen = ((int)dxScreen - xExt) / 2;
            yScreen = ((int)dyScreen - yExt) / 2;
        }
        else {

            xScreen = 0;
            yScreen = 0;
        }

        DPF4(( "Drawing to the screen..." ));
        DrawDibDraw( hdd, hdcFullScreen,
                     xScreen, yScreen, xExt, yExt,
                     lpbi, lpBits,
                     0, 0, lpbi->biWidth, lpbi->biHeight,
                     DDF_SAME_HDC | DDF_SAME_DRAW );


        /*
        ** Hack time !!
        **
        ** We have to remove keyboard message from the queue to enable the
        ** keyboard hook to see them !!
        */
        {
            MSG msg;

            PeekMessage( &msg, NULL, WM_KEYFIRST, WM_KEYLAST,
                         PM_REMOVE | PM_NOYIELD );
        }

        return DISPLAYDIB_NOERROR;
        // return fStop;
    }

    /*
    ** The user pressed a key... time to stop
    */
    else {

        DPF1(( "The keyboard hook is telling us to stop..." ));
        //DisplayDibLeave( wFlags );
        return DISPLAYDIB_STOP;
    }

}



/*****************************Private*Routine******************************\
* DisplayDibEnter
*
*
*
* History:
* 23-03-94 - StephenE - Created
*
\**************************************************************************/
UINT
DisplayDibEnter(
    LPBITMAPINFOHEADER lpbi,
    UINT wFlags
    )
{
    WNDCLASS    wc;
    HINSTANCE   hInst = GetModuleHandle( NULL );


    /*
    ** If our class isn't already registered with windows register it
    */
    fClassRegistered = GetClassInfo( hInst, TEXT("SJE_FULLSCREEN"), &wc );
    if ( fClassRegistered == FALSE ) {

        ZeroMemory( &wc, sizeof(wc) );

        wc.style         = CS_OWNDC;
        wc.lpfnWndProc   = FullScreenWndProc;
        wc.hInstance     = hInst;
        wc.hbrBackground = (HBRUSH)GetStockObject( BLACK_BRUSH );
        wc.lpszClassName = TEXT("SJE_FULLSCREEN");
        fClassRegistered = RegisterClass( &wc );
        DPF4(( "Class registered... %s", fClassRegistered ? "OK" : "FAILED" ));
    }


    if ( fClassRegistered ) {

        /*
        ** Do we already have a window ??
        */
        if ( hwndFullScreen == NULL ) {

            hwndFullScreen = CreateWindowEx( WS_EX_TOPMOST,
                                            TEXT("SJE_FULLSCREEN"),
                                            NULL,
                                            WS_POPUP,
                                            0, 0, 0, 0,
                                            NULL, NULL,
                                            hInst, NULL );

            DPF4(( "Window created... %s", hwndFullScreen ? "OK" : "FAILED" ));
        }

        if ( hwndFullScreen ) {

            LONG    yExt;
            LONG    xExt;

            fStop = FALSE;
            hHookK = SetWindowsHookEx( WH_KEYBOARD, KeyboardHookProc,
                                       ghModule,
                                       0 );
            DPF4(( "Hook created... %s", hHookK ? "OK" : "FAILED" ));

            dxScreen = GetSystemMetrics( SM_CXSCREEN );
            dyScreen = GetSystemMetrics( SM_CYSCREEN );

            hdcFullScreen = GetDC( hwndFullScreen );
            SetStretchBltMode(hdcFullScreen, COLORONCOLOR);

            xExt = lpbi->biWidth;
            yExt = lpbi->biHeight;

            iMovieSizeMultiplier =
                DisplayCalcMovieMultiplier( xExt, yExt, lpbi->biCompression );

            if ( wFlags & DISPLAYDIB_ZOOM2 ) {

                xExt <<= 1;
                yExt <<= 1;
            }
            else if ( iMovieSizeMultiplier ) {
				//The movie needs to be stretched to full screen.
                xExt = GetSystemMetrics( SM_CXSCREEN );
                yExt = GetSystemMetrics( SM_CYSCREEN );
            }

            if ( wFlags & DISPLAYDIB_ANIMATE ) {
                wFlags = DDF_ANIMATE;
            }
            else if ( wFlags & DISPLAYDIB_HALFTONE ) {
                wFlags = DDF_HALFTONE;
            }
            else {
                wFlags = 0;
            }

            DPF1(( "Drawing at %d by %d... Flags = 0x%X", xExt, yExt, wFlags ));
            DrawDibBegin( hdd, hdcFullScreen, xExt, yExt,
                          lpbi, lpbi->biWidth, lpbi->biHeight, wFlags );

            MoveWindow( hwndFullScreen, 0, 0, dxScreen, dyScreen, FALSE );
            ShowWindow( hwndFullScreen, SW_SHOW );
            UpdateWindow( hwndFullScreen );

            ShowCursor( FALSE );
            SetForegroundWindow( hwndFullScreen );
            SetFocus( hwndFullScreen );
        }
    }

    return hwndFullScreen != NULL ? DISPLAYDIB_NOERROR : DISPLAYDIB_NOTSUPPORTED;
}



/*****************************Private*Routine******************************\
* DisplayDibLeave
*
*
*
* History:
* 23-03-94 - StephenE - Created
*
\**************************************************************************/
void
DisplayDibLeave(
    UINT wFlags
    )
{
    if (hwndFullScreen) {
        DestroyWindow( hwndFullScreen );
        hwndFullScreen = NULL;
    }

}

/*****************************Private*Routine******************************\
* DisplayCalcMovieMultiplier
*
* Determines the largest movie that the display is capable of displaying.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
DisplayCalcMovieMultiplier(
    int cxOriginal,
    int cyOriginal,
    DWORD dwCompression
    )
{
    SYSTEM_INFO     SysInfo;
    int             iMult;
    int             iMultTemp;
    int             cxOriginalSave, cyOriginalSave;
    int             iMax = 8;


    GetSystemInfo( &SysInfo );
    iMultTemp = iMult = 0;
    cxOriginalSave = cxOriginal;
    cyOriginalSave = cyOriginal;


    switch ( SysInfo.wProcessorArchitecture ) {

    case PROCESSOR_ARCHITECTURE_INTEL:
        if ( SysInfo.wProcessorLevel <= 3 ) {
            break;
        } else
        if ( SysInfo.wProcessorLevel == 4 ) {
            iMax = 2;
            iMax = mmGetProfileInt(szIni, TEXT("MaxFullScreenShift"), iMax);
            //DPF0(("Setting the maximum shift multiplier to %d\n", iMax));
        }

        /*
        ** maybe later we will do something more different for i486's
        ** for now they just fall through to the RISC / Pentium default
        ** case below.
        */

    default:

        while ( ( (cxOriginal<<=1) <= CX_MAX_MOVIE_DEFAULT)
             && ( (cyOriginal<<=1) <= CY_MAX_MOVIE_DEFAULT)
             && (iMax >= iMult)) {
            ++iMult;
        }
        break;
    }

    return iMult;
}


/******************************Public*Routine******************************\
* FullScreenWndProc
*
*
*
* History:
* 23-03-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
FullScreenWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch ( message ) {

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            RECT        rc;

            DPF4(( "Window needs painting" ));
            BeginPaint( hwnd, &ps );
            GetUpdateRect( hwnd, &rc, FALSE );
            FillRect( hdcFullScreen, &rc, GetStockObject( BLACK_BRUSH ) );
            EndPaint( hwnd, &ps );
        }
        break;

    case WM_PALETTECHANGED:
        if ( (HWND)wParam == hwnd ) {
            break;
        }

        /* fall thru */

    case WM_QUERYNEWPALETTE:
        if ( DrawDibRealize( hdd, hdcFullScreen, FALSE ) > 0 ) {
            InvalidateRect( hwnd, NULL, TRUE );
            return TRUE;
        }
        break;

    case WM_DESTROY:
        {
            ATOM atm;
            DPF4(( "Window destroyed releasing DC" ));
            ReleaseDC( hwnd, hdcFullScreen );
            DrawDibEnd( hdd );
            DrawDibClose( hdd );
            hdd = NULL;
            hdcFullScreen = NULL;

            UnregisterClass( TEXT("SJE_FULLSCREEN"), GetModuleHandle( NULL ) );

            fClassRegistered = FALSE;

            ShowCursor( TRUE );
            UnhookWindowsHookEx( hHookK );
            while (atm = GlobalFindAtom(szAtomFlag)) {
                GlobalDeleteAtom(atm);
            }
        }

        break;

        //case WM_KILLFOCUS:
        //case WM_ACTIVATE:
        //case WM_SETFOCUS:
        //    DPF0(("FullWindowProc, message==%8x, wp/lp  %8x/%8x\n", message, wParam, lParam));

    default:
        return DefWindowProc( hwnd, message, wParam, lParam );
    }

    return (LRESULT)FALSE;
}



/******************************Public*Routine******************************\
* KeyboardHookProc
*
*
*
* History:
* 23-03-94 - StephenE - Created
*
\**************************************************************************/

LRESULT CALLBACK
KeyboardHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //DPF0(("HookProc, ncode == %d, lParam==%8x\n", nCode, lParam));
    if ( nCode == HC_ACTION) {

        DPF1(( "lParam = 0x%X", lParam ));
        DPF1(( "!  wParam = 0x%X\n", wParam ));

        /*
        ** Don't mess about with the control or shift key.  This is because
        ** mciwnd uses them to start playing fullscreen.  This causes the movie
        ** to start start playing and then immediately stop.  0x001D0000 is
        ** the scan code for the control keys, 0x002A0000 is the scan code
        ** for the shift key.
        */
        if ( (lParam & 0x00FF0000) == 0x001D0000
          || (lParam & 0x00FF0000) == 0x002A0000 ) {

            return CallNextHookEx( hHookK, nCode, wParam, lParam );
        }


        /*
        ** The most significant bit of lParam is set if the key is being
        ** released.  We are only interested in keydowns.  Bits 16 - 23 are
        ** the hardware scan code of the key being pressed, 0x00010000
        ** is the scan code for the escape key.
        */
        if ( !(lParam & 0x80000000) || ((lParam & 0x00FF0000) == 0x00010000)) {

            if (!fStop) {

                fStop = TRUE;
                GlobalAddAtom(szAtomFlag);

                /*
                ** Don't let windows see this message.
                */
                return -1;
            }

            DPF1(( "Stop requested from the keyboard hook" ));
        }
    }

    return CallNextHookEx( hHookK, nCode, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\drawproc.c ===
/****************************************************************************
 *
 *  DRAWPROC.C
 *
 *  Standard AVI drawing handler.
 *
 *      InstallAVIDrawHandler()
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#define NOAVIFILE
#include <vfw.h>
#include "common.h"
#include "mciavi.h"

#define FOURCC_VIDS         mmioFOURCC('v','i','d','s')
#define FOURCC_AVIDraw      mmioFOURCC('D','R','A','W')
#define VERSION_AVIDraw     0x00010000      // 1.00

#ifdef DEBUG
    HDRAWDIB ghdd;
#endif

#ifndef HUGE
    #define HUGE _huge
#endif

/***************************************************************************
 ***************************************************************************/

typedef struct {
    HDRAWDIB		hdd;

    HDC                 hdc;            // HDC to draw to
			
    int                 xDst;           // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;
    int                 xSrc;           // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;
    BOOL                fBackground;

    BOOL                fRle;
    DWORD               biSizeImage;
    BOOL		fNeedUpdate;

    LONG                rate;           // playback rate (uSec / frame)
} INSTINFO, *PINSTINFO;

// static stuff in this file.
LONG_PTR FAR PASCAL _loadds ICAVIDrawProc(DWORD_PTR id, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2);

static LONG_PTR AVIDrawOpen(ICOPEN FAR * icopen);
static LONG AVIDrawClose(PINSTINFO pi);
static LONG AVIDrawGetInfo(ICINFO FAR *icinfo, LONG lSize);
static LONG AVIDrawQuery(PINSTINFO pi, LPBITMAPINFOHEADER lpbiIn);
static LONG AVIDrawSuggestFormat(PINSTINFO pi, ICDRAWSUGGEST FAR *lpicd, LONG cbicd);
STATICFN LONG AVIDrawBegin(PINSTINFO pi, ICDRAWBEGIN FAR *lpicd, LONG cbicd);
STATICFN LONG AVIDraw(PINSTINFO pi, ICDRAW FAR *lpicd, LONG cbicd);
static LONG AVIDrawEnd(PINSTINFO pi);
static LONG AVIDrawChangePalette(PINSTINFO pi, LPBITMAPINFOHEADER lpbi);

/***************************************************************************
 ***************************************************************************/

LONG_PTR FAR PASCAL _loadds ICAVIDrawProc(DWORD_PTR id, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2)
{
    INSTINFO *pi = (INSTINFO *)id;

    switch (uiMessage)
    {
        case DRV_LOAD:
        case DRV_FREE:
            return 1;

        /*********************************************************************
            open
        *********************************************************************/

        case DRV_OPEN:
            if (lParam2 == 0L)
                return 1;

            return AVIDrawOpen((ICOPEN FAR *)lParam2);

	case DRV_CLOSE:
            return AVIDrawClose(pi);

        /*********************************************************************
            Configure/Info messages
        *********************************************************************/

        case DRV_QUERYCONFIGURE:    // configuration from drivers applet
            return 0;

        case DRV_CONFIGURE:
            return 1;

        case ICM_CONFIGURE:
        case ICM_ABOUT:
            return ICERR_UNSUPPORTED;

        /*********************************************************************
            state messages
        *********************************************************************/

        case ICM_GETSTATE:
        case ICM_SETSTATE:
            return 0L;

//      case ICM_GETINFO:
//          return AVIDrawGetInfo((ICINFO FAR *)lParam1, lParam2);

        /*********************************************************************
            decompress messages
        *********************************************************************/

        case ICM_DRAW_QUERY:
            return AVIDrawQuery(pi, (LPBITMAPINFOHEADER)lParam1);

	case ICM_DRAW_SUGGESTFORMAT:
	    return AVIDrawSuggestFormat(pi, (ICDRAWSUGGEST FAR *) lParam1, (LONG) lParam2);

        case ICM_DRAW_BEGIN:
	    return AVIDrawBegin(pi, (ICDRAWBEGIN FAR *) lParam1, (LONG) lParam2);

	case ICM_DRAW_REALIZE:
	    pi->hdc = (HDC) lParam1;
	
	    if (!pi->hdc || !pi->hdd)
		break;

	    pi->fBackground = (BOOL) lParam2;
	
	    return DrawDibRealize(pi->hdd, pi->hdc, pi->fBackground);

	case ICM_DRAW_GET_PALETTE:
	    if (!pi->hdd)
		break;

	    return (LONG_PTR) DrawDibGetPalette(pi->hdd);
	
        case ICM_DRAW:
            return AVIDraw(pi, (ICDRAW FAR *)lParam1, (LONG) lParam2);

	case ICM_DRAW_CHANGEPALETTE:
	    return AVIDrawChangePalette(pi, (LPBITMAPINFOHEADER) lParam1);
	
        case ICM_DRAW_END:
            return AVIDrawEnd(pi);

        case ICM_DRAW_START:
            return DrawDibStart(pi->hdd, pi->rate);

        case ICM_DRAW_STOP:
            return DrawDibStop(pi->hdd);

        /*********************************************************************
            standard driver messages
        *********************************************************************/

        case DRV_DISABLE:
        case DRV_ENABLE:
            return 1;

        case DRV_INSTALL:
        case DRV_REMOVE:
            return 1;
    }

    return ICERR_UNSUPPORTED;
}

/*****************************************************************************
 *
 * AVIDrawOpen() is called from the DRV_OPEN message
 *
 ****************************************************************************/

static LONG_PTR AVIDrawOpen(ICOPEN FAR * icopen)
{
    INSTINFO *  pinst;

    if (icopen->dwFlags & ICMODE_COMPRESS)
        return 0;

    if (icopen->dwFlags & ICMODE_DECOMPRESS)
        return 0;

    pinst = (INSTINFO *)LocalAlloc(LPTR, sizeof(INSTINFO));

    if (!pinst)
    {
        icopen->dwError = ICERR_MEMORY;
        return 0;
    }

    DPF2(("*** AVIDrawOpen()\n"));

    //
    // init structure
    //
    pinst->hdd = DrawDibOpen();

#ifdef DEBUG
     // hack: put the hdd where FindDrawDevice can find it
    ghdd = pinst->hdd;
#endif

    //
    // return success.
    //
    icopen->dwError = ICERR_OK;

    return (LONG_PTR) (UINT_PTR) pinst;
}

/*****************************************************************************
 *
 * Close() is called on the DRV_CLOSE message.
 *
 ****************************************************************************/
static LONG AVIDrawClose(PINSTINFO pi)
{
    DPF2(("*** AVIDrawClose()\n"));

    if (pi->hdd) {
	DrawDibClose(pi->hdd);
    }
    LocalFree((HLOCAL) pi);

    return 1;
}

#if 0
/*****************************************************************************
 *
 * AVIDrawGetInfo() implements the ICM_GETINFO message
 *
 ****************************************************************************/
static LONG AVIDrawGetInfo(ICINFO FAR *icinfo, LONG lSize)
{
    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (lSize < sizeof(ICINFO))
        return 0;

    icinfo->dwSize	    = sizeof(ICINFO);
    icinfo->fccType         = FOURCC_VIDS;
    icinfo->fccHandler      = FOURCC_AVIDraw;
    icinfo->dwFlags	    = VIDCF_DRAW;    // supports inter-frame
    icinfo->dwVersion       = VERSION_AVIDraw;
    icinfo->dwVersionICM    = ICVERSION;
    icinfo->szName[0]       = 0;
    icinfo->szDescription[0]= 0;

    return sizeof(ICINFO);
}
#endif

/*****************************************************************************
 *
 * AVIDrawQuery() implements ICM_DRAW_QUERY
 *
 ****************************************************************************/
static LONG AVIDrawQuery(PINSTINFO pi,
			 LPBITMAPINFOHEADER lpbiIn)
{
    //
    // determine if the input DIB data is in a format we like.
    //
    if (lpbiIn == NULL)
        return ICERR_BADFORMAT;

    //
    // determine if the input DIB data is in a format we like.
    //

    // !!! Do we need a DrawDibQuery or something here to let this handle
    // any compressed format?

#ifdef DRAWDIBNODECOMPRESS
    if (lpbiIn->biCompression != BI_RGB &&
#if 0
        !(lpbiIn->biBitCount == 8 && lpbiIn->biCompression == BI_RLE8))
#else
	1)
#endif
        return ICERR_BADFORMAT;
#endif

    return ICERR_OK;
}


static LONG AVIDrawSuggestFormat(PINSTINFO pi, ICDRAWSUGGEST FAR *lpicd, LONG cbicd)
{
    HIC hic;

    if (lpicd->lpbiSuggest == NULL)
	return sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD);

    hic = ICGetDisplayFormat(NULL, lpicd->lpbiIn, lpicd->lpbiSuggest,
			     0, lpicd->dxDst, lpicd->dyDst);

    if (hic)
	ICClose(hic);


    return sizeof(BITMAPINFOHEADER) + lpicd->lpbiSuggest->biClrUsed * sizeof(RGBQUAD);
}

/*****************************************************************************
 *
 * AVIDrawBegin() implements ICM_DRAW_BEGIN
 *
 ****************************************************************************/

STATICFN LONG AVIDrawBegin(PINSTINFO pi, ICDRAWBEGIN FAR *lpicd, LONG cbicd)
{
    LONG    l;
    UINT    wFlags;

    if (lpicd->dwFlags & ICDRAW_FULLSCREEN)
        return ICERR_UNSUPPORTED;

    l = AVIDrawQuery(pi, lpicd->lpbi);

    if ((l != ICERR_OK) || (lpicd->dwFlags & ICDRAW_QUERY))
	return l;

    // Copy over whatever we want to remember
    pi->xDst = lpicd->xDst;
    pi->yDst = lpicd->yDst;
    pi->dxDst = lpicd->dxDst;
    pi->dyDst = lpicd->dyDst;
    pi->xSrc = lpicd->xSrc;
    pi->ySrc = lpicd->ySrc;
    pi->dxSrc = lpicd->dxSrc;
    pi->dySrc = lpicd->dySrc;
    pi->rate = muldiv32(lpicd->dwScale,1000000,lpicd->dwRate);
    pi->hdc = lpicd->hdc;

    // !!! Should this be done somewhere else? drawdib mabey!

    if (pi->hdc)
        SetStretchBltMode(pi->hdc, COLORONCOLOR);

    wFlags = 0;

    // !!! We need some way to have a "stupid" mode here....
    if (lpicd->dwFlags & ICDRAW_BUFFER)
        wFlags |= DDF_BUFFER;

    // Don't animate if we're realizing in the background
    if (lpicd->dwFlags & ICDRAW_ANIMATE && !(pi->fBackground))
        wFlags |= DDF_ANIMATE;

    //
    //  remember if this is RLE because we may need to hack it later.
    //
    pi->fRle = lpicd->lpbi->biCompression == BI_RLE8;
    pi->biSizeImage = (DWORD)(((UINT)lpicd->lpbi->biWidth+3)&~3)*(DWORD)(UINT)lpicd->lpbi->biHeight;

    DPF2(("*** AVIDrawBegin()\n"));

    if (lpicd->hpal == (HPALETTE)MCI_AVI_SETVIDEO_PALETTE_HALFTONE) {
        DrawDibSetPalette(pi->hdd, NULL);
        wFlags |= DDF_HALFTONE;
    }
    else
        DrawDibSetPalette(pi->hdd, lpicd->hpal);

    if (!DrawDibBegin(pi->hdd, pi->hdc,
		 pi->dxDst, pi->dyDst,
		 lpicd->lpbi,
		 pi->dxSrc, pi->dySrc,
		 wFlags))
	return ICERR_UNSUPPORTED;

    if (pi->hdc)
        DrawDibRealize(pi->hdd, pi->hdc, pi->fBackground);

    return ICERR_OK;
}


/*****************************************************************************
 *
 * AVIDraw() implements ICM_DRAW
 *
 ****************************************************************************/

STATICFN LONG AVIDraw(PINSTINFO pi, ICDRAW FAR *lpicd, LONG cbicd)
{
    UINT  wFlags;
    BOOL  f;

    wFlags = DDF_SAME_DRAW|DDF_SAME_HDC;  // !!! Right flags?

    if ((lpicd->lpData == NULL) || (lpicd->cbData == 0)) {

        if ((lpicd->dwFlags & ICDRAW_UPDATE) || pi->fNeedUpdate) {
            DrawDibRealize(pi->hdd, pi->hdc, pi->fBackground);
            wFlags |= DDF_UPDATE;
	    pi->fNeedUpdate = FALSE;
	    lpicd->lpData = NULL;
	    lpicd->cbData = 0;
        }
	else
            return ICERR_OK;  // no data to draw.
    }
    else {
        if (lpicd->dwFlags & ICDRAW_PREROLL) {
            wFlags |= DDF_DONTDRAW;
	    pi->fNeedUpdate = TRUE;
	} else if (lpicd->dwFlags & ICDRAW_HURRYUP) {
            wFlags |= DDF_HURRYUP;
	    pi->fNeedUpdate = TRUE;
	} else
	    pi->fNeedUpdate = FALSE;

        if (lpicd->dwFlags & ICDRAW_NOTKEYFRAME)
            wFlags |= DDF_NOTKEYFRAME;

        //
        // if we get a update while playing and we are drawing RLE delta's
        // make sure we update.
        //
        if (pi->fRle && (lpicd->dwFlags & ICDRAW_UPDATE)) {
            DrawDibDraw(pi->hdd, pi->hdc, pi->xDst, pi->yDst,
                0,0,NULL,NULL,0,0,0,0,DDF_UPDATE|DDF_SAME_HDC|DDF_SAME_DRAW);
        }
    }

    //
    // We need a hack here for the RLE case, to make sure that
    // DIBs are marked correctly as BI_RLE8 or BI_RGB....
    //
    if (pi->fRle) {
	DPF2(("pi->fRle is true, cbData==%d, biSizeImage=%d\n",
            lpicd->cbData, pi->biSizeImage));

        if (lpicd->cbData == pi->biSizeImage)
            ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression = BI_RGB;
        else {
            ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression = BI_RLE8;
	    // We MUST set the correct size
	    ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biSizeImage = lpicd->cbData;
	}
    }

    f = DrawDibDraw(pi->hdd, pi->hdc,
		pi->xDst, pi->yDst,
		pi->dxDst, pi->dyDst,
		lpicd->lpFormat,
                lpicd->lpData,
		pi->xSrc, pi->ySrc,
		pi->dxSrc, pi->dySrc,
                wFlags);

    if (pi->fRle)
        ((LPBITMAPINFOHEADER)lpicd->lpFormat)->biCompression = BI_RLE8;

    if (!f) {

	if (wFlags & DDF_UPDATE)
            DPF(("DrawDibUpdate failed\n"));
        else
            DPF(("DrawDibDraw failed\n"));

	if (wFlags & DDF_UPDATE) {
	    if (lpicd->dwFlags & ICDRAW_UPDATE)
		return ICERR_CANTUPDATE;
	    else
		return ICERR_OK;
	} else
            return ICERR_ERROR;
    }

    return ICERR_OK;
}

static LONG AVIDrawChangePalette(PINSTINFO pi, LPBITMAPINFOHEADER lpbi)
{
    PALETTEENTRY    ape[256];
    LPRGBQUAD	    lprgb;
    int i;

    lprgb = (LPRGBQUAD) ((LPBYTE) lpbi + lpbi->biSize);

    for (i = 0; i < (int) lpbi->biClrUsed; i++) {
	ape[i].peRed = lprgb[i].rgbRed;
	ape[i].peGreen = lprgb[i].rgbGreen;
	ape[i].peBlue = lprgb[i].rgbBlue;
	ape[i].peFlags = 0;
    }
	
    DrawDibChangePalette(pi->hdd, 0, (int) lpbi->biClrUsed,
				 (LPPALETTEENTRY)ape);

    return ICERR_OK;
}

/*****************************************************************************
 *
 * AVIDrawEnd() implements ICM_DRAW_END
 *
 ****************************************************************************/

static LONG AVIDrawEnd(PINSTINFO pi)
{
    return ICERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\gmem.h ===
/*
 * GMEM.H - Macros for windows 3.0 memory management in protected mode
 *
 * because windows 3.0 runs in pmode GlobalLock and GlobalUnlock are
 * unnessary.  The "Selector" to a memory object will always be the
 * same for the life of the memory object.
 *
 * these macros take advantage of the following win3 memory "facts"
 *
 *      a SELECTOR (to a global object) is a HANDLE
 *      a HANDLE is *not* a SELECTOR!!!!!!!!
 *
 *      GlobalLock() and GlobalUnlock() do *not* keep lock counts
 *
 *      GlobalLock() is the only way to convert a HANDLE to a SELECTOR
 *
 * functions:
 *
 *      GHandle(sel)                convert a SELECTOR to a HANDLE
 *      GSelector(h)                convert a HANDLE to a SELECTOR
 *
 *      GAllocSel(ulBytes)          allocate a SELECTOR ulBytes in size
 *      GAllocPtr(ulBytes)          allocate a POINTER ulBytes in size
 *
 *      GReAllocSel(sel,ulBytes)    re-alloc a SELECTOR
 *      GReAllocPtr(lp,ulBytes)     re-alloc a POINTER
 *
 *      GSizeSel(sel)               return the size in bytes of a SELECTOR
 *
 *      GLockSel(sel)               convert a SELECTOR into a POINTER
 *      GUnlockSel(sel)             does nothing
 *
 *      GFreeSel(sel)               free a SELECTOR
 *      GFreePtr(lp)                free a POINTER
 *
 * 5/31/90 ToddLa
 *
 */

HANDLE __H;

#ifndef _WIN32
#define MAKEP(sel,off)      ((LPVOID)MAKELONG(off,sel))

#define GHandle(sel)        ((HANDLE)(sel))  /* GlobalHandle? */
#define GSelector(h)        (HIWORD((DWORD)GlobalLock(h)))

#else

#define MAKEP(sel,off)       GlobalLock((LPVOID)(sel))
#define GHandle(sel)        ((HANDLE)(sel))  /* GlobalHandle? */
#define GSelector(h)        (((DWORD)(h)))

#endif // WIN16

#define GAllocSelF(f,ulBytes) ((__H=GlobalAlloc(f,(LONG)(ulBytes))) ? GSelector(__H) : NULL )
#define GAllocPtrF(f,ulBytes) MAKEP(GAllocSelF(f,ulBytes),0)
#define GAllocF(f,ulBytes)    GAllocSelF(f,ulBytes)

#define GAllocSel(ulBytes)    GAllocSelF(GMEM_MOVEABLE,ulBytes)
#define GAllocPtr(ulBytes)    GAllocPtrF(GMEM_MOVEABLE,ulBytes)
#define GAlloc(ulBytes)       GAllocSelF(GMEM_MOVEABLE,ulBytes)

#define GReAllocSel(sel,ulBytes)   ((__H=GlobalReAlloc((HANDLE)(sel),(LONG)(ulBytes),0)) ? GSelector(__H) : NULL )
#ifndef _WIN32
#define GReAllocPtr(lp,ulBytes)    MAKEP(GReAllocSel(HIWORD((DWORD)(lp)),ulBytes),0)
#else
#define GReAllocPtr(lp,ulBytes)    MAKEP(GReAllocSel(GlobalHandle(lp),ulBytes),0)
#endif
#define GReAlloc(sel,ulBytes)      GReAllocSel(sel,ulBytes)

#define GSizeSel(sel)       GlobalSize((HANDLE)(sel))
#define GSize(sel)          GSizeSel(sel)

#define GLockSel(sel)       MAKEP(sel,0)
#ifndef _WIN32
#define GUnlockSel(sel)     /* nothing */
#else
#define GUnlockSel(sel)     GlobalUnlock(sel)
#endif
#define GLock(sel)          GLockSel(sel)
#define GUnlock(sel)        GUnlockSel(sel)

#define GFreeSel(sel)       (GlobalUnlock(GHandle(sel)),GlobalFree(GHandle(sel)))
#ifndef _WIN32
#define GFreePtr(lp)        GFreeSel(HIWORD((DWORD)(lp)))
#else
#define GFreePtr(lp)        GFreeSel(GlobalHandle(lp))
#endif
#define GFree(sel)          GFreeSel(sel)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\drvproc.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   drvproc.c - Multimedia Systems Media Control Interface
            driver for AVI.

*****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>	// for {struct _TEB} defintion
#include "graphic.h"
#include "cnfgdlg.h"            // to get IDA_CONFIG
#include "avitask.h"            // to get mciaviTaskCleanup()

#ifndef _WIN32 // Not used in 32 bit world
void NEAR PASCAL AppExit(HTASK htask, BOOL fNormalExit);
#endif

#define CONFIG_ID   10000L  // Use the hiword of dwDriverID to identify
HANDLE ghModule;
extern HWND ghwndConfig;
extern const TCHAR szIni[];

/* Link to DefDriverProc in MMSystem explicitly, so we don't get the
** one in USER by mistake.
*/
#ifndef _WIN32
extern DWORD FAR PASCAL mmDefDriverProc(DWORD, HANDLE, UINT, DWORD, DWORD);
#else
#define mmDefDriverProc DefDriverProc
#endif

#ifndef _WIN32
BOOL FAR PASCAL LibMain (HANDLE hModule, int cbHeap, LPSTR lpchCmdLine)
{
    ghModule = hModule;
    return TRUE;
}
#else
#if 0
// Get the module handle on DRV_LOAD
BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    if (Reason == DLL_PROCESS_ATTACH) {
        ghModule = hModule;  // All we need to save is our module handle...
    } else {
        if (Reason == DLL_PROCESS_DETACH) {
        }
    }
    return TRUE;
}

#endif
#endif // WIN16

/***************************************************************************
 *
 * @doc     INTERNAL
 *
 * @api     DWORD | DriverProc | The entry point for an installable driver.
 *
 * @parm    DWORD | dwDriverId | For most messages, dwDriverId is the DWORD
 *          value that the driver returns in response to a DRV_OPEN message.
 *          Each time that the driver is opened, through the DrvOpen API,
 *          the driver receives a DRV_OPEN message and can return an
 *          arbitrary, non-zero, value. The installable driver interface
 *          saves this value and returns a unique driver handle to the
 *          application. Whenever the application sends a message to the
 *          driver using the driver handle, the interface routes the message
 *          to this entry point and passes the corresponding dwDriverId.
 *
 *          This mechanism allows the driver to use the same or different
 *          identifiers for multiple opens but ensures that driver handles
 *          are unique at the application interface layer.
 *
 *          The following messages are not related to a particular open
 *          instance of the driver. For these messages, the dwDriverId
 *          will always be  ZERO.
 *
 *              DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * @parm    UINT | wMessage | The requested action to be performed. Message
 *          values below DRV_RESERVED are used for globally defined messages.
 *          Message values from DRV_RESERVED to DRV_USER are used for
 *          defined driver portocols. Messages above DRV_USER are used
 *          for driver specific messages.
 *
 * @parm    DWORD | dwParam1 | Data for this message.  Defined separately for
 *          each message
 *
 * @parm    DWORD | dwParam2 | Data for this message.  Defined separately for
 *          each message
 *
 * @rdesc Defined separately for each message.
 *
 ***************************************************************************/

LRESULT FAR PASCAL _LOADDS DriverProc (DWORD_PTR dwDriverID, HANDLE hDriver, UINT wMessage,
    LPARAM dwParam1, LPARAM dwParam2)
{
    DWORD_PTR dwRes = 0L;


    /*
     * critical sections are now per-device. This means they
     * cannot be held around the whole driver-proc, since until we open
     * the device, we don't have a critical section to hold.
     * The critical section is allocated in mciSpecial on opening. It is
     * also held in mciDriverEntry, in GraphicWndProc, and around
     * all worker thread draw functions.
     */


    switch (wMessage)
        {

        // Standard, globally used messages.

        case DRV_LOAD:
	{
	    struct _TEB *pteb;
            BOOL bWow64;

#ifdef _WIN32
            if (ghModule) {
                Assert(!"Did not expect ghModule to be non-NULL");
            }
            ghModule = GetDriverModuleHandle(hDriver);  // Remember

	    // The WOW guys say that the proper method of detecting
	    // whether we're talking to a 16-bit app is to test
	    // NtCurrentTeb()->WOW32Reserved; if it's nonzero, it's 16-bit.
	    // In the (unlikely) event that we can't test that, default
	    // to using the old detection method.
            // On 64-bit systems WOW32Reserved is used for something else.
	    //
            if (!IsWow64Process(GetCurrentProcess(), &bWow64)) {
                break;
            }
            if (!bWow64) {
    	        if ((pteb = NtCurrentTeb()) != NULL) {
                    runningInWow = (pteb->WOW32Reserved != 0) ? TRUE : FALSE;
    	        } else {
                    #define GET_MAPPING_MODULE_NAME         TEXT("wow32.dll")
                    runningInWow = (GetModuleHandle(GET_MAPPING_MODULE_NAME) != NULL);
                }
            }
#endif
            if (GraphicInit())       // Initialize graphic mgmt.
                dwRes = 1L;
            else
                dwRes = 0L;

            break;
	}

        case DRV_FREE:

            GraphicFree();
            dwRes = 1L;
            DPF(("Returning from DRV_FREE\n"));
            Assert(npMCIList == NULL);
            ghModule = NULL;
            break;

        case DRV_OPEN:

            if (!dwParam2)
                dwRes = CONFIG_ID;
            else
                dwRes = GraphicDrvOpen((LPMCI_OPEN_DRIVER_PARMS)dwParam2);

            break;

        case DRV_CLOSE:
	    /* If we have a configure dialog up, fail the close.
	    ** Otherwise, we'll be unloaded while we still have the
	    ** configuration window up.
	    */
	    if (ghwndConfig)
		dwRes = 0L;
	    else
		dwRes = 1L;
            break;

        case DRV_ENABLE:

            dwRes = 1L;
            break;

        case DRV_DISABLE:

            dwRes = 1L;
            break;

        case DRV_QUERYCONFIGURE:

            dwRes = 1L;	/* Yes, we can be configured */
            break;

        case DRV_CONFIGURE:
            ConfigDialog((HWND)(UINT)dwParam1, NULL);
            dwRes = 1L;
            break;

#ifndef _WIN32
        //
        //  sent when a application is terminating
        //
        //  lParam1:
        //      DRVEA_ABNORMALEXIT
        //      DRVEA_NORMALEXIT
        //
        case DRV_EXITAPPLICATION:
            AppExit(GetCurrentTask(), (BOOL)dwParam1 == DRVEA_NORMALEXIT);
            break;
#endif

        default:

            if (!HIWORD(dwDriverID) &&
                wMessage >= DRV_MCI_FIRST &&
                wMessage <= DRV_MCI_LAST)

                dwRes = mciDriverEntry ((UINT) (UINT_PTR) dwDriverID,
                                        wMessage,
                                        (UINT) dwParam1,
                                        (LPMCI_GENERIC_PARMS)dwParam2);
            else
                dwRes = mmDefDriverProc(dwDriverID,
                                      hDriver,
                                      wMessage,
                                      dwParam1,
                                      dwParam2);
            break;
        }

    return dwRes;
}

#ifndef _WIN32
/*****************************************************************************
 * @doc INTERNAL
 *
 * @func void | AppExit |
 *      a application is exiting
 *
 ****************************************************************************/

void NEAR PASCAL AppExit(HTASK htask, BOOL fNormalExit)
{
    //
    //  walk the list of open MCIAVI instances and see if
    //  the dying task is the background task and do cleanup.
    //
    NPMCIGRAPHIC npMCI;

    // Note: we do not have EnterList/LeaveList macros here as this is
    // explicitly NOT Win32 code.
    for (npMCI=npMCIList; npMCI; npMCI = npMCI->npMCINext) {

        if (npMCI->hTask == htask) {
            DPF(("Calling mciaviTaskCleanup()\n"));
            mciaviTaskCleanup(npMCI);
            return;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\graph16.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   graphic.c - Multimedia Systems Media Control Interface
            driver for AVI.

*****************************************************************************/

#include <win32.h>
#include <mmddk.h>
#include <vfw.h>
#include "common.h"
#include "digitalv.h"

#include "mciavi.h"

HANDLE ghModule;
typedef DWORD NPMCIGRAPHIC;

#define MCIAVI_PRODUCTNAME       2
#define MCIAVI_VERSION           3

BOOL FAR PASCAL  GraphicInit (void);
BOOL NEAR PASCAL  GraphicWindowInit (void);

void  PASCAL  GraphicFree (void);
DWORD PASCAL  GraphicDrvOpen (LPMCI_OPEN_DRIVER_PARMS lpParms);
void  FAR PASCAL  GraphicDelayedNotify (NPMCIGRAPHIC npMCI, UINT wStatus);
void FAR PASCAL GraphicImmediateNotify (UINT wDevID,
    LPMCI_GENERIC_PARMS lpParms,
    DWORD dwFlags, DWORD dwErr);
DWORD PASCAL  GraphicClose(NPMCIGRAPHIC npMCI);
DWORD PASCAL GraphicOpen (NPMCIGRAPHIC FAR * lpnpMCI, DWORD dwFlags,
    LPMCI_DGV_OPEN_PARMS lpOpen, UINT wDeviceID);
DWORD FAR PASCAL GraphicInfo(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_INFO_PARMS lpInfo);
DWORD FAR PASCAL GraphicPlay (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_PLAY_PARMS lpPlay );
DWORD FAR PASCAL GraphicCue(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_CUE_PARMS lpCue);
DWORD FAR PASCAL GraphicStep (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_STEP_PARMS lpStep);
DWORD FAR PASCAL GraphicStop (NPMCIGRAPHIC npMCI, DWORD dwFlags,
					LPMCI_GENERIC_PARMS lpParms);
DWORD FAR PASCAL GraphicSeek (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_SEEK_PARMS lpSeek);
DWORD FAR PASCAL GraphicPause(NPMCIGRAPHIC npMCI, DWORD dwFlags,
					LPMCI_GENERIC_PARMS lpParms);
DWORD FAR PASCAL GraphicStatus (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_STATUS_PARMS lpStatus);
DWORD FAR PASCAL GraphicSet (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_SET_PARMS lpSet);
DWORD FAR PASCAL GraphicResume (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_GENERIC_PARMS lpParms);
DWORD FAR PASCAL GraphicRealize(NPMCIGRAPHIC npMCI, DWORD dwFlags);
DWORD FAR PASCAL GraphicUpdate(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_UPDATE_PARMS lpParms);
DWORD FAR PASCAL GraphicWindow (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_WINDOW_PARMS lpWindow);
DWORD FAR PASCAL GraphicConfig(NPMCIGRAPHIC npMCI, DWORD dwFlags);
DWORD FAR PASCAL GraphicSetAudio (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_SETAUDIO_PARMS lpSet);
DWORD FAR PASCAL GraphicSetVideo (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_SETVIDEO_PARMS lpSet);
DWORD FAR PASCAL GraphicSignal(NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_SIGNAL_PARMS lpSignal);

DWORD FAR PASCAL GraphicWhere(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_RECT_PARMS lpParms);
DWORD FAR PASCAL GraphicPut ( NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_RECT_PARMS lpParms);
BOOL FAR PASCAL ConfigDialog(HWND hwnd, NPMCIGRAPHIC npMCI);



DWORD PASCAL mciDriverEntry(UINT wDeviceID, UINT wMessage, DWORD dwFlags, LPMCI_GENERIC_PARMS lpParms);

void  CheckWindowMove(NPMCIGRAPHIC npMCI, BOOL fForce);


/* statics */
static INT              swCommandTable = -1;

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicDrvOpen | This function is called when the DriverProc
 *      gets a DRV_OPEN message. This happens each time that a new movie
 *      is opened thru MCI.
 *
 * @parm LPMCI_OPEN_DRIVER_PARMS | lpOpen | Far pointer to the standard
 *      MCI open parameters
 *
 * @rdesc Returns the mci device id. The installable driver interface will
 *      pass this ID to the DriverProc in the dwDriverID parameter on all
 *      subsequent messages. To fail the open, return 0L.
 *
 ***************************************************************************/

DWORD PASCAL GraphicDrvOpen(LPMCI_OPEN_DRIVER_PARMS lpOpen)
{
    /* Specify the custom command table and the device type  */

    lpOpen->wCustomCommandTable = swCommandTable;
    lpOpen->wType = MCI_DEVTYPE_DIGITAL_VIDEO;

    /* Set the device ID to the MCI Device ID */

    return (DWORD) (UINT)lpOpen->wDeviceID;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | GraphicFree | This function is called when the DriverProc
 *      gets a DRV_FREE message. This happens when the drivers open count
 *      reaches 0.
 *
 ***************************************************************************/

void PASCAL GraphicFree16(void)
{
    if (swCommandTable != -1) {
	mciFreeCommandResource(swCommandTable);
	swCommandTable = -1;
    }

    GraphicFree();
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicInfo | This function returns alphanumeric information.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the info. message.
 *
 * @parm LPMCI_INFO_PARMS | lpPlay | Parameters for the info message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicInfo16(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_INFO_PARMS lpInfo)
{
    DWORD	dwRet = 0L;
    TCHAR	ch = TEXT('\0');
    BOOL	fTest = FALSE;

    if (!lpInfo->lpstrReturn)
    	return MCIERR_PARAM_OVERFLOW;

    if (dwFlags & MCI_TEST)
	fTest = TRUE;

    dwFlags &= ~(MCI_WAIT | MCI_NOTIFY | MCI_TEST);

    switch (dwFlags) {
    case 0L:
	return MCIERR_MISSING_PARAMETER;
	
        /* !!! Not returning PARAM_OVERFLOW here but I am above - lazy eh */
        LoadString(ghModule, MCIAVI_PRODUCTNAME, lpInfo->lpstrReturn,
                (UINT)lpInfo->dwRetSize);
	break;

    case MCI_INFO_VERSION:
	/* !!! Not returning PARAM_OVERFLOW here but I am above - lazy eh */
	LoadString(ghModule, MCIAVI_VERSION, lpInfo->lpstrReturn,
		(UINT)lpInfo->dwRetSize);
	break;

	case MCI_DGV_INFO_USAGE:
	    dwRet = MCIERR_UNSUPPORTED_FUNCTION;
	    break;

    case MCI_DGV_INFO_ITEM:
	switch (lpInfo->dwItem) {	
	case MCI_DGV_INFO_AUDIO_QUALITY:
	case MCI_DGV_INFO_VIDEO_QUALITY:
	case MCI_DGV_INFO_STILL_QUALITY:
	case MCI_DGV_INFO_AUDIO_ALG:
	case MCI_DGV_INFO_VIDEO_ALG:
	case MCI_DGV_INFO_STILL_ALG:
	default:
	    dwRet = MCIERR_UNSUPPORTED_FUNCTION;
	    break;
	}
	break;

    default:
    	dwRet = MCIERR_FLAGS_NOT_COMPATIBLE;
	break;
    }

    if (fTest && (LOWORD(dwRet) == 0)) {
	/* There is no error, but the test flag is on.  Return as little
	** as possible.
	*/
	dwRet = 0;
	if (lpInfo->dwRetSize)
	    lpInfo->lpstrReturn[0] = '\0';
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicList | This function supports the MCI_LIST command.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the List message.
 *
 * @parm LPMCI_DGV_LIST_PARMS | lpList | Parameters for the list message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/
DWORD NEAR PASCAL GraphicList(NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_LIST_PARMS lpList)
{
    return MCIERR_UNSUPPORTED_FUNCTION;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicGetDevCaps | This function returns  device
 *      capabilities
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the GetDevCaps message.
 *
 * @parm LPMCI_GETDEVCAPS_PARMS | lpCaps | Parameters for the GetDevCaps
 *      message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicGetDevCaps (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_GETDEVCAPS_PARMS lpCaps )
{

    DWORD dwRet = 0L;


    if (dwFlags & MCI_GETDEVCAPS_ITEM)
        {

        switch (lpCaps->dwItem)
            {
            case MCI_GETDEVCAPS_CAN_RECORD:
            case MCI_GETDEVCAPS_CAN_EJECT:
            case MCI_GETDEVCAPS_CAN_SAVE:
            case MCI_DGV_GETDEVCAPS_CAN_LOCK:
            case MCI_DGV_GETDEVCAPS_CAN_STR_IN:
            case MCI_DGV_GETDEVCAPS_CAN_FREEZE:
            case MCI_DGV_GETDEVCAPS_HAS_STILL:
		
                lpCaps->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_DGV_GETDEVCAPS_CAN_REVERSE:
            case MCI_GETDEVCAPS_CAN_PLAY:
            case MCI_GETDEVCAPS_HAS_AUDIO:
            case MCI_GETDEVCAPS_HAS_VIDEO:
            case MCI_GETDEVCAPS_USES_FILES:
            case MCI_GETDEVCAPS_COMPOUND_DEVICE:
            case MCI_DGV_GETDEVCAPS_PALETTES:
            case MCI_DGV_GETDEVCAPS_CAN_STRETCH:
            case MCI_DGV_GETDEVCAPS_CAN_TEST:
                lpCaps->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_GETDEVCAPS_DEVICE_TYPE:

                lpCaps->dwReturn = MAKEMCIRESOURCE(MCI_DEVTYPE_DIGITAL_VIDEO,
					    MCI_DEVTYPE_DIGITAL_VIDEO);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

	    case MCI_DGV_GETDEVCAPS_MAX_WINDOWS:
	    case MCI_DGV_GETDEVCAPS_MAXIMUM_RATE:
	    case MCI_DGV_GETDEVCAPS_MINIMUM_RATE:
            default:

                dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                break;
            }
        }
    else
        dwRet = MCIERR_MISSING_PARAMETER;

    if ((dwFlags & MCI_TEST) && (LOWORD(dwRet) == 0)) {
	/* There is no error, but the test flag is on.  Return as little
	** as possible.
	*/
	dwRet = 0;
	lpCaps->dwReturn = 0;
    }

    return (dwRet);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | mciSpecial | This function handles all the MCI
 *      commands that don't require instance data such as open.
 *
 * @parm UINT | wDeviceID | The MCI device ID
 *
 * @parm UINT | wMessage | The requested action to be performed.
 *
 * @parm DWORD | dwFlags | Flags for the message.
 *
 * @parm DWORD | lpParms | Parameters for this message.
 *
 * @rdesc Error Constant. 0L on success
 *
 ***************************************************************************/

DWORD NEAR PASCAL mciSpecial (UINT wDeviceID, UINT wMessage, DWORD dwFlags, LPMCI_GENERIC_PARMS lpParms)
{
    NPMCIGRAPHIC npMCI = 0L;
    DWORD dwRet;

    /* since there in no instance block, there is no saved notification */
    /* to abort. */

    switch (wMessage) {
	case MCI_OPEN_DRIVER:
            if (dwFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))
                dwRet = GraphicOpen (&npMCI, dwFlags,
			    (LPMCI_DGV_OPEN_PARMS) lpParms, wDeviceID);
            else
                dwRet = 0L;

            mciSetDriverData (wDeviceID, (UINT)npMCI);
            break;

        case MCI_GETDEVCAPS:
            dwRet = GraphicGetDevCaps(NULL, dwFlags,
			    (LPMCI_GETDEVCAPS_PARMS)lpParms);
            break;

        case MCI_CONFIGURE:

            if (!(dwFlags & MCI_TEST))
                ConfigDialog(NULL, NULL);
	    dwRet = 0L;
	    break;

        case MCI_INFO:
            dwRet = GraphicInfo16(NULL, dwFlags, (LPMCI_DGV_INFO_PARMS)lpParms);
            break;

        case MCI_CLOSE_DRIVER:
            dwRet = 0L;
            break;

        default:
            dwRet = MCIERR_UNSUPPORTED_FUNCTION;
            break;
    }

    GraphicImmediateNotify (wDeviceID, lpParms, dwFlags, dwRet);
    return (dwRet);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | mciDriverEntry | This function is the MCI handler
 *
 * @parm UINT | wDeviceID | The MCI device ID
 *
 * @parm UINT | wMessage | The requested action to be performed.
 *
 * @parm DWORD | dwFlags | Flags for the message.
 *
 * @parm DWORD | lpParms | Parameters for this message.
 *
 * @rdesc Error Constant. 0L on success
 *
 ***************************************************************************/

DWORD PASCAL mciDriverEntry (UINT wDeviceID, UINT wMessage, DWORD dwFlags, LPMCI_GENERIC_PARMS lpParms)
{
    NPMCIGRAPHIC npMCI = 0L;
    DWORD dwRet = MCIERR_UNRECOGNIZED_COMMAND;
    BOOL fDelayed = FALSE;
    BOOL fNested = FALSE;

    /* All current commands require a parameter block. */

    if (!lpParms && (dwFlags & MCI_NOTIFY))
        return (MCIERR_MISSING_PARAMETER);

    npMCI = (NPMCIGRAPHIC) (UINT)mciGetDriverData(wDeviceID);

    if (!npMCI)
        return mciSpecial(wDeviceID, wMessage, dwFlags, lpParms);

#if 0
#ifdef DEBUG
    else
        Assert(npMCI->mciid == MCIID);
#endif

    if (npMCI->wMessageCurrent) {
	fNested = TRUE;
	
	if (wMessage != MCI_STATUS && wMessage != MCI_GETDEVCAPS &&
		    wMessage != MCI_INFO) {
	    //DPF(("Warning!!!!!\n"));
	    //DPF(("Warning!!!!!     MCIAVI reentered: received %x while processing %x\n", wMessage, npMCI->wMessageCurrent));
	    //DPF(("Warning!!!!!\n"));
//	    Assert(0);
//	    return MCIERR_DEVICE_NOT_READY;
	}
    } else	
	npMCI->wMessageCurrent = wMessage;
#endif
    switch (wMessage) {

	case MCI_CLOSE_DRIVER:


            // Question:  Should we set the driver data to NULL
            // before closing the device?  It would seem the right order.
            // So... we have moved this line before the call to GraphicClose
            mciSetDriverData(wDeviceID, 0L);

	    // note that GraphicClose will release and delete the critsec
 	    dwRet = GraphicClose(npMCI);
	
	    npMCI = NULL;
	    break;

    	case MCI_PLAY:
	
            dwRet = GraphicPlay(npMCI, dwFlags, (LPMCI_PLAY_PARMS)lpParms);
	    fDelayed = TRUE;
            break;

    	case MCI_CUE:
	
            dwRet = GraphicCue(npMCI, dwFlags, (LPMCI_DGV_CUE_PARMS)lpParms);
	    fDelayed = TRUE;
            break;

	case MCI_STEP:

            dwRet = GraphicStep(npMCI, dwFlags, (LPMCI_DGV_STEP_PARMS)lpParms);
	    fDelayed = TRUE;
	    break;
	
	case MCI_STOP:

            dwRet = GraphicStop(npMCI, dwFlags, lpParms);
            break;

	case MCI_SEEK:

            dwRet = GraphicSeek (npMCI, dwFlags, (LPMCI_SEEK_PARMS)lpParms);
	    fDelayed = TRUE;
            break;

	case MCI_PAUSE:

            dwRet = GraphicPause(npMCI, dwFlags, lpParms);
	    fDelayed = TRUE;
            break;

        case MCI_RESUME:

            dwRet = GraphicResume(npMCI, dwFlags, lpParms);
	    fDelayed = TRUE;
            break;

        case MCI_SET:

            dwRet = GraphicSet(npMCI, dwFlags,
				(LPMCI_DGV_SET_PARMS)lpParms);
	    break;

	case MCI_STATUS:

            dwRet = GraphicStatus(npMCI, dwFlags,
				(LPMCI_DGV_STATUS_PARMS)lpParms);
	    break;

	case MCI_INFO:

 	    dwRet = GraphicInfo (npMCI, dwFlags, (LPMCI_DGV_INFO_PARMS)lpParms);
	    break;

        case MCI_GETDEVCAPS:

            dwRet = GraphicGetDevCaps(npMCI, dwFlags, (LPMCI_GETDEVCAPS_PARMS)lpParms);
	    break;

        case MCI_REALIZE:

            dwRet = GraphicRealize(npMCI, dwFlags);
            break;

        case MCI_UPDATE:

            dwRet = GraphicUpdate(npMCI, dwFlags, (LPMCI_DGV_UPDATE_PARMS)lpParms);
            break;

	case MCI_WINDOW:
 	
            dwRet = GraphicWindow(npMCI, dwFlags, (LPMCI_DGV_WINDOW_PARMS)lpParms);
	    break;

        case MCI_PUT:

 	    dwRet = GraphicPut(npMCI, dwFlags, (LPMCI_DGV_RECT_PARMS)lpParms);
            break;
	
        case MCI_WHERE:

            dwRet = GraphicWhere(npMCI, dwFlags, (LPMCI_DGV_RECT_PARMS)lpParms);
            break;
	
	case MCI_CONFIGURE:
	    dwRet = GraphicConfig(npMCI, dwFlags);
	    break;

	case MCI_SETAUDIO:
	    dwRet = GraphicSetAudio(npMCI, dwFlags,
			(LPMCI_DGV_SETAUDIO_PARMS) lpParms);
	    break;

	case MCI_SETVIDEO:
	    dwRet = GraphicSetVideo(npMCI, dwFlags,
			(LPMCI_DGV_SETVIDEO_PARMS) lpParms);
	    break;

	case MCI_SIGNAL:
	    dwRet = GraphicSignal(npMCI, dwFlags,
			(LPMCI_DGV_SIGNAL_PARMS) lpParms);
	    break;
	
	case MCI_LIST:
	    dwRet = GraphicList(npMCI, dwFlags,
			(LPMCI_DGV_LIST_PARMS) lpParms);
	    break;

#if 0
        case MCI_LOAD:
	    dwRet = GraphicLoad(npMCI, dwFlags,
				  (LPMCI_DGV_LOAD_PARMS) lpParms);
	    break;
#endif
	
        case MCI_RECORD:
        case MCI_SAVE:
	
        case MCI_CUT:
        case MCI_COPY:
        case MCI_PASTE:
        case MCI_UNDO:
	
	case MCI_DELETE:
	case MCI_CAPTURE:
	case MCI_QUALITY:
	case MCI_MONITOR:
	case MCI_RESERVE:
	case MCI_FREEZE:
	case MCI_UNFREEZE:
            dwRet = MCIERR_UNSUPPORTED_FUNCTION;
            break;
	
	    /* Do we need this case? */
	default:
            dwRet = MCIERR_UNRECOGNIZED_COMMAND;
            break;
    }

    if (!fDelayed || (dwFlags & MCI_TEST)) {
	/* We haven't processed the notify yet. */
        if (npMCI && (dwFlags & MCI_NOTIFY) && (!LOWORD(dwRet)))
	    /* Throw away the old notify */
            GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUPERSEDED);

	/* And send the new one out immediately. */
        GraphicImmediateNotify(wDeviceID, lpParms, dwFlags, dwRet);
    }

    if (npMCI) {
        /* Everything from here on relies on npMCI still being around */

#if 0
        /* If there's an error, don't save the callback.... */
        if (fDelayed && dwRet != 0 && (dwFlags & MCI_NOTIFY)) {

	    // this might be too late, of course, but shouldn't do
	    // any harm
    	    npMCI->hCallback = 0;
	}

        //
        //  see if we need to tell the DRAW device about moving.
        //  MPlayer is sending the status and position command alot
        //  so this is a "timer"
        //
        //  !!!do we need to do it this often?
        //
        if (npMCI->dwFlags & MCIAVI_WANTMOVE)
    	    CheckWindowMove(npMCI, FALSE);

        if (!fNested)
	    npMCI->wMessageCurrent = 0;
#endif
    }

    return dwRet;
}

#define CONFIG_ID   10000L  // Use the hiword of dwDriverID to identify
extern HWND ghwndConfig;

/* Link to DefDriverProc in MMSystem explicitly, so we don't get the
** one in USER by mistake.
*/
#ifndef _WIN32
extern DWORD FAR PASCAL mmDefDriverProc(DWORD, HANDLE, UINT, DWORD, DWORD);
#else
#define mmDefDriverProc DefDriverProc
#endif

#ifndef _WIN32
BOOL FAR PASCAL LibMain (HANDLE hModule, int cbHeap, LPSTR lpchCmdLine)
{
    ghModule = hModule;
    return TRUE;
}
#else
#if 0
// Get the module handle on DRV_LOAD
BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    if (Reason == DLL_PROCESS_ATTACH) {
        ghModule = hModule;  // All we need to save is our module handle...
    } else {
        if (Reason == DLL_PROCESS_DETACH) {
        }
    }
    return TRUE;
}

#endif
#endif // WIN16

/***************************************************************************
 *
 * @doc     INTERNAL
 *
 * @api     DWORD | DriverProc | The entry point for an installable driver.
 *
 * @parm    DWORD | dwDriverId | For most messages, dwDriverId is the DWORD
 *          value that the driver returns in response to a DRV_OPEN message.
 *          Each time that the driver is opened, through the DrvOpen API,
 *          the driver receives a DRV_OPEN message and can return an
 *          arbitrary, non-zero, value. The installable driver interface
 *          saves this value and returns a unique driver handle to the
 *          application. Whenever the application sends a message to the
 *          driver using the driver handle, the interface routes the message
 *          to this entry point and passes the corresponding dwDriverId.
 *
 *          This mechanism allows the driver to use the same or different
 *          identifiers for multiple opens but ensures that driver handles
 *          are unique at the application interface layer.
 *
 *          The following messages are not related to a particular open
 *          instance of the driver. For these messages, the dwDriverId
 *          will always be  ZERO.
 *
 *              DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * @parm    UINT | wMessage | The requested action to be performed. Message
 *          values below DRV_RESERVED are used for globally defined messages.
 *          Message values from DRV_RESERVED to DRV_USER are used for
 *          defined driver portocols. Messages above DRV_USER are used
 *          for driver specific messages.
 *
 * @parm    DWORD | dwParam1 | Data for this message.  Defined separately for
 *          each message
 *
 * @parm    DWORD | dwParam2 | Data for this message.  Defined separately for
 *          each message
 *
 * @rdesc Defined separately for each message.
 *
 ***************************************************************************/

DWORD FAR PASCAL _LOADDS DriverProc (DWORD dwDriverID, HANDLE hDriver, UINT wMessage,
    DWORD dwParam1, DWORD dwParam2)
{
    DWORD dwRes = 0L;


    /*
     * critical sections are now per-device. This means they
     * cannot be held around the whole driver-proc, since until we open
     * the device, we don't have a critical section to hold.
     * The critical section is allocated in mciSpecial on opening. It is
     * also held in mciDriverEntry, in GraphicWndProc, and around
     * all worker thread draw functions.
     */


    switch (wMessage)
        {

        // Standard, globally used messages.

        case DRV_LOAD:

#ifdef _WIN32
            if (ghModule) {
                Assert(!"Did not expect ghModule to be non-NULL");
            }
            ghModule = GetDriverModuleHandle(hDriver);  // Remember

            #define GET_MAPPING_MODULE_NAME         TEXT("wow32.dll")
            runningInWow = (GetModuleHandle(GET_MAPPING_MODULE_NAME) != NULL);
#endif
            if (GraphicInit())       // Initialize graphic mgmt.
                dwRes = 1L;
            else
                dwRes = 0L;

            break;

        case DRV_FREE:

            GraphicFree16();
            dwRes = 1L;
            //DPF(("Returning from DRV_FREE\n"));
#if 0
            Assert(npMCIList == NULL);
#endif
            ghModule = NULL;
            break;

        case DRV_OPEN:

            if (!dwParam2)
                dwRes = CONFIG_ID;
            else
                dwRes = GraphicDrvOpen((LPMCI_OPEN_DRIVER_PARMS)dwParam2);

            break;

        case DRV_CLOSE:
	    /* If we have a configure dialog up, fail the close.
	    ** Otherwise, we'll be unloaded while we still have the
	    ** configuration window up.
	    */
#if 0
	    if (ghwndConfig)
		dwRes = 0L;
	    else
#endif
		dwRes = 1L;
            break;

        case DRV_ENABLE:

            dwRes = 1L;
            break;

        case DRV_DISABLE:

            dwRes = 1L;
            break;

        case DRV_QUERYCONFIGURE:

            dwRes = 1L;	/* Yes, we can be configured */
            break;

        case DRV_CONFIGURE:
            ConfigDialog((HWND)(UINT)dwParam1, NULL);
            dwRes = 1L;
            break;

        default:

            if (!HIWORD(dwDriverID) &&
                wMessage >= DRV_MCI_FIRST &&
                wMessage <= DRV_MCI_LAST)

                dwRes = mciDriverEntry ((UINT)dwDriverID,
                                        wMessage,
                                        dwParam1,
                                        (LPMCI_GENERIC_PARMS)dwParam2);
            else
                dwRes = mmDefDriverProc(dwDriverID,
                                      hDriver,
                                      wMessage,
                                      dwParam1,
                                      dwParam2);
            break;
        }

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\graphic.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   graphic.c - Multimedia Systems Media Control Interface
            driver for AVI.

*****************************************************************************/

// Define HEARTBEAT to create a permanent thread which can periodically
// dump mciavi device status
//#define HEARTBEAT

#include "graphic.h"
#include "dispdib.h"
//#include "cnfgdlg.h"
#include <string.h>
#ifdef EXPIRE
#include <dos.h>
#endif
#include "avitask.h"

#ifdef DEBUG
#define static
#endif

#ifdef _WIN32
extern BOOL FAR PASCAL WowUseMciavi16(VOID);
#endif


//
//  This is the version number of MSVIDEO.DLL we need in order to run
//  build 81 is when we added the VideoForWindowsVersion() function to
//  MSVIDEO.DLL
//
//  in build 85
//    we removed the ICDecompressOpen() function and it became a macro.
//    we added a parameter to ICGetDisplayFormat()
//    we make DrawDibProfileDisplay() take a parameter
//
//  in build 108
//    Added ICOpenFunction() to open a hic using a function directly,
//      without calling ICInstall
//    Added some more ICDRAW_ messages
//
//  in build 109
//    Addded ICMessage() to compman
//    removed ICDrawSuggest() made it a macro.
//    Added ICMODE_FASTDECOMPRESS to ICLocate()
//
//  Under NT the first build is sufficient !!! Is this true now?
//
#ifdef _WIN32
#define MSVIDEO_VERSION     (0x01000000)          // 1.00.00.00
#else
#define MSVIDEO_VERSION     (0x010a0000l+109)     // 1.10.00.109
#endif

/* statics */
static INT              swCommandTable = -1;

#if 0
#ifdef _WIN32
static SZCODE           szDisplayDibLib[] = TEXT("DISPDB32.DLL");
#else
static SZCODE           szDisplayDibLib[] = TEXT("DISPDIB.DLL");
#endif
#endif

/*
 * files should be UNICODE. function names should not
 */

#ifdef _WIN32
STATICDT SZCODE         szMSVideo[]       = TEXT("MSVFW32");  // With GetModuleHandle
         const TCHAR    szReject[]        = TEXT("RejectWOWOpenCalls");
#else
static SZCODE           szMSVideo[]       = TEXT("MSVIDEO");
#endif

BOOL   gfEvil;          // TRUE if we cant close cuz dialog box is up
BOOL   gfEvilSysMenu;   // TRUE if we cant close cuz system menu is up

NPMCIGRAPHIC npMCIList; // list of all open instances.
#ifdef _WIN32
CRITICAL_SECTION MCIListCritSec;  // Must protect access to MCIList entries
#ifdef DEBUG
DWORD            ListOwner;
#endif // debug
#endif


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | GraphicInit | This function is called when the DriverProc
 *      gets a DRV_LOAD message.
 *
 ***************************************************************************/
BOOL FAR PASCAL GraphicInit(void)
{
    InitializeDebugOutput("MCIAVI");

    if (!GraphicWindowInit())
        return FALSE;

    // The command table is name MCIAVI - same as the Ini/Registry/Module
    swCommandTable = mciLoadCommandResource(ghModule, szIni, 0);
#ifdef _WIN32
    InitializeCriticalSection(&MCIListCritSec);
#endif

    return TRUE;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicDrvOpen | This function is called when the DriverProc
 *      gets a DRV_OPEN message. This happens each time that a new movie
 *      is opened thru MCI.
 *
 * @parm LPMCI_OPEN_DRIVER_PARMS | lpOpen | Far pointer to the standard
 *      MCI open parameters
 *
 * @rdesc Returns the mci device id. The installable driver interface will
 *      pass this ID to the DriverProc in the dwDriverID parameter on all
 *      subsequent messages. To fail the open, return 0L.
 *
 ***************************************************************************/

DWORD PASCAL GraphicDrvOpen(LPMCI_OPEN_DRIVER_PARMS lpOpen)
{
    /* Specify the custom command table and the device type  */

    lpOpen->wCustomCommandTable = swCommandTable;
    lpOpen->wType = MCI_DEVTYPE_DIGITAL_VIDEO;

    /* Set the device ID to the MCI Device ID */

    return (DWORD) (UINT)lpOpen->wDeviceID;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api void | GraphicFree | This function is called when the DriverProc
 *      gets a DRV_FREE message. This happens when the drivers open count
 *      reaches 0.
 *
 ***************************************************************************/
#ifdef HEARTBEAT
BOOL    fTerminate      = FALSE;
HANDLE  hHeartBeatThread= 0;
#endif

void PASCAL GraphicFree(void)
{
    if (swCommandTable != -1) {
                mciFreeCommandResource(swCommandTable);
                swCommandTable = -1;
    }

#ifdef HEARTBEAT
    if (hHeartBeatThread) {
                fTerminate=TRUE;
                WaitForSingleObject(hHeartBeatThread, 5000);
                CloseHandle(hHeartBeatThread);
    }
#endif

#ifdef _WIN32
    /*
     * unregister class so we can re-register it next time we are loaded
     */
    GraphicWindowFree();
#ifdef REMOTESTEAL
    if (hkey) {
                RegCloseKey(hkey);
                hkey = 0;
    }
#endif
    DeleteCriticalSection(&MCIListCritSec);
#endif
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicDelayedNotify | This is a utility function that
 *      sends a notification saved with GraphicSaveCallback to mmsystem
 *      which posts a message to the application. Called on either worker
 *      or (occasionally if ever?) user thread.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data.
 *
 * @parm UINT | wStatus | The type of notification to use can be one of
 *      MCI_NOTIFY_SUCCESSFUL, MCI_NOTIFY_SUPERSEDED, MCI_NOTIFY_ABORTED
 *      or MCI_NOTIFY_FAILURE (see MCI ispec.)
 *
 ***************************************************************************/

void FAR PASCAL GraphicDelayedNotify(NPMCIGRAPHIC npMCI, UINT wStatus)
{
    /* Send any saved notification */

    if (npMCI->hCallback) {

        DPF2(("GraphicDelayedNotify, npMCI=%8x, Status is %x\n", npMCI, wStatus));
        // If the system menu is the only thing keeping us from closing, bring
        // it down and then close.
        if (gfEvilSysMenu)
            SendMessage(npMCI->hwndPlayback, WM_CANCELMODE, 0, 0);

        // If a dialog box is up, and keeping us from closing, we can't send the
        // notify or it will close us.
        if (!gfEvil)
            mciDriverNotify(npMCI->hCallback, npMCI->wDevID, wStatus);

        npMCI->hCallback = NULL;
    }
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicImmediateNotify | This is a utility function that
 *      sends a successful notification message to mmsystem if the
 *      notification flag is set and the error field is 0.
 *
 * @parm UINT | wDevID | device ID.
 *
 * @parm LPMCI_GENERIC_PARMS | lpParms | Far pointer to an MCI parameter
 *      block. The first field of every MCI parameter block is the
 *      callback handle.
 *
 * @parm DWORD | dwFlags | Parm. block flags - used to check whether the
 *      callback handle is valid.
 *
 * @parm DWORD | dwErr | Notification only occurs if the command is not
 *      returning an error.
 *
 ***************************************************************************/

void FAR PASCAL GraphicImmediateNotify(UINT wDevID,
    LPMCI_GENERIC_PARMS lpParms,
    DWORD dwFlags, DWORD dwErr)
{
    if (!LOWORD(dwErr) && (dwFlags & MCI_NOTIFY)) {
        //Don't have an npMCI - see GraphicDelayedNotify
        //if (gfEvil)
            //SendMessage(npMCI->hwndPlayback, WM_CANCELMODE, 0, 0);

        // If a dialog box is up, and keeping us from closing, we can't send the
        // notify or it will close us.
        if (!gfEvil) // !!! EVIL !!!
            mciDriverNotify((HANDLE) (UINT)lpParms->dwCallback,
                                        wDevID, MCI_NOTIFY_SUCCESSFUL);
    }
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicSaveCallback | This is a utility function that saves
 *      a new callback in the instance data block.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data.
 *
 * @parm HANDLE | hCallback | callback handle
 *
 ***************************************************************************/

void NEAR PASCAL GraphicSaveCallback (NPMCIGRAPHIC npMCI, HANDLE hCallback)
{
    /* If there's an old callback, kill it. */
    GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUPERSEDED);

    /* Save new notification callback window handle */
    npMCI->hCallback = hCallback;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicClose | This function closes the movie and
 *  releases the instance data.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD PASCAL GraphicClose (NPMCIGRAPHIC npMCI)
{
    DWORD dwRet = 0L;
    NPMCIGRAPHIC p;

    if (npMCI) {

        SetNTFlags(npMCI, NTF_CLOSING);
#ifdef DEBUG
        npMCI->mciid = MCIIDX;
        if (TestNTFlags(npMCI, NTF_AUDIO_OFF)) {
            DPF1(("Trying to close while audio command active\n"));
            DebugBreak();
        }
#endif

        dwRet = DeviceClose (npMCI);
        Assert(dwRet == 0);

        // If the system menu is the only thing keeping us from closing, bring
        // it down and then close.
        if (gfEvilSysMenu)
            SendMessage(npMCI->hwndPlayback, WM_CANCELMODE, 0, 0);

        if (gfEvil) {
            DPF(("************************************************\n"));
            DPF(("** EVIL: Failing the close because we'd die   **\n"));
            DPF(("************************************************\n"));
            ResetNTFlags(npMCI, NTF_CLOSING);


            return MCIERR_DRIVER_INTERNAL;
        }

        //
        // find this instance on the list - and remove it
        // Do this before destroying any element in this instance
        //
        EnterList();
        if (npMCI == npMCIList) {
            npMCIList = npMCI->npMCINext;
        }
        else {
            for (p=npMCIList; p && p->npMCINext != npMCI; p=p->npMCINext)
                ;

            Assert(p && p->npMCINext == npMCI);

            p->npMCINext = npMCI->npMCINext;
        }
        LeaveList();

        if (npMCI->szFilename) {
            LocalFree((HANDLE) (npMCI->szFilename));
        }


#ifdef _WIN32

#ifdef DEBUG
       if (npMCI->hmmio) {
           DPF1(("hmmio is still open, npMCI=%8x\n", npMCI));
       }
       if (npMCI->hmmioAudio) {
           DPF1(("hmmioAudio is still open, npMCI=%8x\n", npMCI));
       }
#endif

#endif

#ifdef INTERVAL_TIMES
    // Free the bucket space
    if (npMCI->paIntervals) {
        LocalFree(npMCI->paIntervals);
    }
#endif

        /* Free the instance data block allocated in GraphicOpen */

        LocalFree((HANDLE)npMCI);
    }

    return dwRet;
}

DWORD NEAR PASCAL FixFileName(NPMCIGRAPHIC npMCI, LPCTSTR lpName)
{
    TCHAR       ach[256];

    ach[(NUMELMS(ach)) - 1] = TEXT('\0');

#ifndef _WIN32
    _fstrncpy(ach, (LPTSTR) lpName, NUMELMS(ach) - 1);
#else
    wcsncpy(ach, (LPTSTR) lpName, NUMELMS(ach) - 1);
#endif

    //
    // treat any string that starts with a '@' as valid and pass it to the
    // device any way.
    //
    if (ach[0] != TEXT('@'))
    {
        if (!mmioOpen(ach, NULL, MMIO_PARSE))
            return MCIERR_FILENAME_REQUIRED;
    }

    Assert(0 == npMCI->szFilename);
    npMCI->szFilename = (NPTSTR) LocalAlloc(LPTR,
                                    sizeof(TCHAR) * (lstrlen(ach) + 1));

    if (!npMCI->szFilename) {
        return MCIERR_OUT_OF_MEMORY;
    }

    lstrcpy(npMCI->szFilename, ach);

    return 0L;
}


/**************************************************************************

***************************************************************************/


#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))

LPCTSTR FAR FileName(LPCTSTR szPath)
{
    LPCTSTR   sz;

    sz = &szPath[lstrlen(szPath)];
    for (; sz>szPath && !SLASH(*sz) && *sz!=TEXT(':');) {
        LPCTSTR pszOld = sz;
        if ((sz = CharPrev(szPath, sz)) == pszOld)
           break;
    }
    return (sz>szPath ? sz + 1 : sz);
}


/****************************************************************************
****************************************************************************/

STATICFN DWORD NEAR PASCAL GetMSVideoVersion()
{
    HANDLE h;

    extern DWORD FAR PASCAL VideoForWindowsVersion(void);

    //
    // don't call VideoForWindowsVersion() if it does not exist or KERNEL
    // will kill us with a undef dynalink error.
    //
    if ((h = GetModuleHandle(szMSVideo)) && GetProcAddress(h, (LPSTR) MAKEINTATOM(2)))
        return VideoForWindowsVersion();
    else
        return 0;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicOpen | This function opens a movie file,
 *      initializes an instance data block, and creates the default
 *      stage window.
 *
 * @parm NPMCIGRAPHIC FAR * | lpnpMCI | Far pointer to a near pointer
 *      to instance data block to be filled in by this function.
 *
 * @parm DWORD | dwFlags | Flags for the open message.
 *
 * @parm LPMCI_DGV_OPEN_PARMS | Parameters for the open message.
 *
 * @parm UINT | wDeviceID | The MCI Device ID for this instance.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/
DWORD PASCAL GraphicOpen (NPMCIGRAPHIC FAR * lpnpMCI, DWORD dwFlags,
    LPMCI_DGV_OPEN_PARMS lpOpen, UINT wDeviceID)
{
    NPMCIGRAPHIC npMCI;
    DWORD       dwRet;

    if (IsNTWOW()) {
        // Thunking nasties... by default we will open a 16 bit request
        // on the 32 bit side.  Most of the time this is what is wanted.
        // However, there can be situations when the user must stay on the
        // 16 bit side (e.g. use of 16 bit drawprocs).  This is not known
        // at this stage.  Hence we provide a way through the configure
        // dialog for the user to tell us to reject 16 bit open calls.
        // The call will then return to 16 bit where it will work.
        // However, we provide a way for applications to override this
        // default.

        // All that is said above is good. Except not many people will notice
        // this little "Advanced" button ... In any event code below
        // uses wow32's special function to extract this needed information
        // (compatibility flag)

#ifdef _WIN32
        if (WowUseMciavi16()) {
           DPF2(("Compat Flag -- mciavi16 should be used\n"));
           return(MCIERR_DEVICE_OPEN);
        }
#endif

        if ((mmGetProfileInt(szIni, szReject, 0) && !(dwFlags & MCI_DGV_OPEN_32BIT))
           || (dwFlags & MCI_DGV_OPEN_16BIT) ) {
            DPF2(("Opening device on 16 bit side\n"));
            return MCIERR_DEVICE_OPEN; // return an error... any error

        }

        /*
        ** The only wow apps that I now off that specify the MCI_DGV_OPEN_PARENT
        ** flag are MS Dangerous Creatures and Tool Book.  These apps go on to
        ** subclass the AVIWnd32 window.  This is very bad on WOW as the
        ** subclassing stops all messages being processed for the AVIWnd32
        ** window.  Therefore, I will reject all open requests that specify
        ** this MCI_DGV_OPEN_PARENT flag.  This is pretty drastic but I don't
        ** know of any other way of identifying these rogue apps.
        **
        ** StephenE 16th Aug 1994.
        */
        else if (dwFlags & MCI_DGV_OPEN_PARENT) {
            //if (dwFlags & MCI_DGV_OPEN_32BIT) {
            //    DPF0(("Now what are we meant to do???\n"));
            //}
            DPF2(("Failing open because APP specified MCI_DGV_OPEN_PARENT\n"));
            return MCIERR_DEVICE_OPEN; // return an error... any error
        }
        else {
            DPF2(("might be able to open device on 32 bit side\n"));
        }
    }

    if (dwFlags & MCI_OPEN_SHAREABLE) {

        if (lpOpen->lpstrElementName == NULL ||
            lpOpen->lpstrElementName[0] != '@') {
            return MCIERR_UNSUPPORTED_FUNCTION;
        }
    }

    //
    //  check the verion of MSVIDEO.DLL before going any further
    //  if we run a "new" version of MCIAVI on a old MSVIDEO.DLL
    //  then bad things will happen.  We assume all MSVIDEO.DLLs
    //  will be backward compatible so we check for any version
    //  greater than the expected version.
    //

    DPF(("GraphicOpen: Video For Windows Version %d.%02d.%02d.%02d\n", HIBYTE(HIWORD(GetMSVideoVersion())), LOBYTE(HIWORD(GetMSVideoVersion())), HIBYTE(LOWORD(GetMSVideoVersion())), LOBYTE(LOWORD(GetMSVideoVersion())) ));

    if (GetMSVideoVersion() < MSVIDEO_VERSION)
    {
        TCHAR achError[128];
        TCHAR ach[40];

        LoadString(ghModule, MCIAVI_BADMSVIDEOVERSION, achError, NUMELMS(achError));
        LoadString(ghModule, MCIAVI_PRODUCTNAME, ach, NUMELMS(ach));
        MessageBox(NULL,achError,ach,
#ifdef BIDI
                MB_RTL_READING |
#endif
        MB_OK|MB_SYSTEMMODAL|MB_ICONEXCLAMATION);

        return MCIERR_DRIVER_INTERNAL;
    }

#ifndef _WIN32
#pragma message("Support passing in MMIOHANDLEs with OPEN_ELEMENT_ID?")
#endif

    if (lpOpen->lpstrElementName == NULL) {
        // they're doing an "open new".

        // !!! handle this, probably by not actually reading a file.
        // ack.
    }

    /* Be sure we have a real, non-empty filename, not an id. */
    if ((!(dwFlags & MCI_OPEN_ELEMENT))
            || (lpOpen->lpstrElementName == NULL)
            || (*(lpOpen->lpstrElementName) == '\0'))
        return MCIERR_UNSUPPORTED_FUNCTION;

    // Allocate an instance data block. Code ASSUMES Zero Init.

    if (!(npMCI = (NPMCIGRAPHIC) LocalAlloc(LPTR, sizeof (MCIGRAPHIC))))
        return MCIERR_OUT_OF_MEMORY;

#ifdef DEBUG
    npMCI->mciid = MCIID;
#ifdef HEARTBEAT
    {
        // Create a thread that regularly dumps the state of AVI devices.
        DWORD   HeartBeat(LPVOID lpvThreadData);
        if (!hHeartBeatThread) {
            DWORD       dwThreadId;
            hHeartBeatThread = CreateThread(NULL, 0, HeartBeat, (LPVOID)0, 0, &dwThreadId);
            if (hHeartBeatThread) {
                // We hold the thread handle open until we are unloaded
                DPF(("Created a heart beat thread, id=%x\n", dwThreadId));
            } else {
                // Errors are ignored...
            }
        }
    }
#endif
#endif

    //
    // add this device to our list
    //
    EnterList();
    npMCI->npMCINext = npMCIList;
    npMCIList = npMCI;
    LeaveList();

    npMCI->wMessageCurrent = MCI_OPEN;


    // Allocate some space for the filename
    // Copy the filename into the data block
    dwRet = FixFileName(npMCI, lpOpen->lpstrElementName);
    if (dwRet != 0L) {
        GraphicClose(npMCI);
        return dwRet;
    }

    // For the default window, the caller may
    // supply style and parent window. Note that the window
    // is now created on the background thread in mcaviTask.

    if (dwFlags & MCI_DGV_OPEN_PARENT) {
        if (!IsWindow(lpOpen->hWndParent)) {
            DPF(("Invalid parent window (%d) supplied\n", lpOpen->hWndParent));
            GraphicClose(npMCI);
            return(MCIERR_CREATEWINDOW);
        }
        npMCI->hwndParent = lpOpen->hWndParent;
    }
    else
        npMCI->hwndParent = NULL;

    if (dwFlags & MCI_DGV_OPEN_WS) {
        npMCI->dwStyle = lpOpen->dwStyle;
    } else {
        npMCI->dwStyle = WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX |
                  WS_SYSMENU | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
    }

    /* Fill in some more of the instance data.
    ** The rest of the fields are completed in DeviceOpen.
    */

    // see comment in graphic.h
    // If the default window won't be resizable, I don't think we should pay
    // attention to zoom by 2 or fixed % window size defaults.
    npMCI->fOKToUseDefaultSizing = (BOOL)((npMCI->dwStyle & WS_THICKFRAME) != 0);

    npMCI->hCallingTask = GetCurrentTask();
    npMCI->hCallback = NULL;
    npMCI->wDevID = wDeviceID;
    npMCI->hwndDefault = NULL;
    npMCI->hwndPlayback = NULL;
    npMCI->dwTimeFormat = MCI_FORMAT_FRAMES;
    npMCI->dwSpeedFactor = 1000;
    npMCI->dwVolume = MAKELONG(500, 500);
    npMCI->lTo = 0L;
    npMCI->dwFlags = MCIAVI_PLAYAUDIO | MCIAVI_SHOWVIDEO;
    npMCI->dwOptionFlags = ReadConfigInfo() | MCIAVIO_STRETCHTOWINDOW;

    // perform device-specific initialization

    dwRet = DeviceOpen(npMCI, dwFlags);

    if (dwRet != 0) {
        // see above - we release and delete the critsec within GraphicClose
        GraphicClose(npMCI);
        return dwRet;
    }

    // Reset these globals every time we open a device.  This is better
    // than setting them every time we start playing...
    gwHurryTolerance = mmGetProfileInt(szIni, TEXT("Hurry"), 2);
    gwSkipTolerance = mmGetProfileInt(szIni, TEXT("Skip"), gwHurryTolerance * 2);
    gwMaxSkipEver = mmGetProfileInt(szIni, TEXT("MaxSkip"), max(60, gwSkipTolerance * 10));

#ifdef INTERVAL_TIMES
    // Allocate the bucket space
    {
        LONG n = npMCI->lFrames;
        // Allocate bucket space for the whole movie... might be
        // expensive(!) so we reduce the count if no memory is
        // available
        DPF2(("Trying to allocate bucket space for %d frames\n", n));
        while( !(npMCI->paIntervals = LocalAlloc(LPTR, n*sizeof(LONG))) && n>10)
            n /= 2;

        if (npMCI->paIntervals) {
            npMCI->cIntervals = n;
            DPF2(("Allocated bucket space for %d frames\n", n));
        }
    }
#endif

    *lpnpMCI = npMCI;

    npMCI->wMessageCurrent = 0;

    return 0L;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicLoad | This function supports the MCI_LOAD command.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the Load message.
 *
 * @parm LPMCI_DGV_LOAD_PARMS | lpLoad | Parameters for the LOAD message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/
DWORD NEAR PASCAL GraphicLoad(NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_LOAD_PARMS lpLoad)
{
    return MCIERR_UNSUPPORTED_FUNCTION;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicSeek | This function sets the current frame. The
 *      device state after a seek is MCI_MODE_PAUSE
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the seek message.
 *
 * @parm LPMCI_DGV_SEEK_PARMS | lpSeek | Parameters for the seek message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicSeek (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_SEEK_PARMS lpSeek)
{
    LONG        lTo;
    BOOL        fTest = FALSE;
    LPARAM       dwCallback = 0;

    /* Do some range checking then pass onto the device-specific routine. */

    if (dwFlags & MCI_TEST) {
        dwFlags &= ~(MCI_TEST);
        fTest = TRUE;
    }

    /* Ignore the WAIT and NOTIFY flags when parsing the seek parameters */

    switch (dwFlags & (~(MCI_WAIT | MCI_NOTIFY))) {
        case MCI_TO:
            lTo = ConvertToFrames(npMCI, lpSeek->dwTo);
            break;

        case MCI_SEEK_TO_START:
            lTo = 0;
            break;

        case MCI_SEEK_TO_END:
            lTo = npMCI->lFrames;
            break;

        case 0:
            return MCIERR_MISSING_PARAMETER;

        default:
            if (dwFlags & ~(MCI_TO |
                            MCI_SEEK_TO_START |
                            MCI_SEEK_TO_END |
                            MCI_WAIT |
                            MCI_NOTIFY))
                return MCIERR_UNRECOGNIZED_KEYWORD;
            else
                return MCIERR_FLAGS_NOT_COMPATIBLE;
            break;
    }

    if (!IsWindow(npMCI->hwndPlayback))
        return MCIERR_NO_WINDOW;

    if (lTo < 0 || lTo > npMCI->lFrames)
        return MCIERR_OUTOFRANGE;

    if (fTest)
        return 0L;

    if (dwFlags & (MCI_NOTIFY)) {
        dwCallback = lpSeek->dwCallback;
    }

    return DeviceSeek(npMCI, lTo, dwFlags, dwCallback);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicCue | This function gets the movie ready to play,
 *      but leaves it paused.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the cue message.
 *
 * @parm LPMCI_DGV_CUE_PARMS | lpCue | Parameters for the cue message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicCue(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_CUE_PARMS lpCue)
{
    LONG                lTo;
    DWORD               dwRet = 0L;

    if (dwFlags & MCI_DGV_CUE_INPUT)
        return MCIERR_UNSUPPORTED_FUNCTION;

    if (dwFlags & MCI_DGV_CUE_NOSHOW)
        return MCIERR_UNSUPPORTED_FUNCTION;

    if (dwFlags & MCI_TO) {
        lTo = ConvertToFrames(npMCI, lpCue->dwTo);

        if (lTo < 0L || lTo > npMCI->lFrames)
            return MCIERR_OUTOFRANGE;
    }

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
        return 0L;


    dwRet = DeviceCue(npMCI, lTo, dwFlags, lpCue->dwCallback);

    return dwRet;
}

#ifndef _WIN32
#ifdef EXPIRE
//
// return the current date....
//
//       dx = year
//       ah = month
//       al = day
//
#pragma optimize("", off)
DWORD DosGetDate(void)
{
    if (0)
        return 0;

    _asm {
        mov     ah,2ah
        int     21h
        mov     ax,dx
        mov     dx,cx
    }
}
#pragma optimize("", on)
#endif
#endif

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicPlay | This function starts playback of the movie. If
 *      the reverse flag is specified, the movie plays backwards. If the fast
 *      or slow flags are specified the movie plays faster or slower.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the play message.
 *
 * @parm LPMCI_DGV_PLAY_PARMS | lpPlay | Parameters for the play message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicPlay (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_PLAY_PARMS lpPlay )
{
        HINSTANCE       hInst;
    TCHAR       achMod[MAX_PATH];
    BOOL        fMPlayer;

#ifdef EXPIRE
#pragma message("Remove the expiration code after Beta ships")
    if (DosGetDate() >= EXPIRE)
    {
        return MCIERR_AVI_EXPIRED;
    }
#endif

    // If we haven't specifically asked for fullscreen or window, and we are
    // the default window, listen to the configure options and maybe force
    // fullscreen.  We will also obey the fullscreen default for MPLAYER's
    // window, to make mplayer just like using the default window.
    hInst = GetWindowInstance(npMCI->hwndPlayback);
    if (hInst)
                GetModuleFileName(hInst, achMod, sizeof(achMod) / sizeof(achMod[0]));
    fMPlayer = lstrcmpi(FileName(achMod), TEXT ("MPLAY32.EXE")) == 0;

    if (!(dwFlags & (MCI_MCIAVI_PLAY_FULLSCREEN | MCI_MCIAVI_PLAY_WINDOW))
                && (npMCI->hwndPlayback == npMCI->hwndDefault || fMPlayer)) {

        if ((npMCI->dwOptionFlags & MCIAVIO_USEVGABYDEFAULT) ||
                (npMCI->rcDest.left == 0 &&
                        npMCI->rcDest.right == GetSystemMetrics(SM_CXSCREEN)) ||
                (npMCI->rcDest.top == 0 &&
                        npMCI->rcDest.bottom == GetSystemMetrics(SM_CYSCREEN))) {
            dwFlags |= MCI_MCIAVI_PLAY_FULLSCREEN;
        }
    }

        // see comment in graphic.h on npMCI->fOKToUseDefaultSizing
        // We're playing, which will end up showing the window
        // and we may want to pay attention to the registry default
        // sizing (zoom by 2, fixed % of screen size, etc.)
        // We also do this code when somebody calls "window state show".
        // As an extra note I should say that it's important that we
        // don't change it until now so that if somebody opens a file
        // and does a "where destination" they get the original size,
        // because if they're playing in their own window, it will
        // not be altered anyway.
        if (npMCI->fOKToUseDefaultSizing) {
            SetWindowToDefaultSize(npMCI, TRUE);
            ResetDestRect(npMCI, TRUE);
        }

        // Never do this again
        npMCI->fOKToUseDefaultSizing = FALSE;


    // everything else needs to be on the worker thread to be reliable.
    return DevicePlay(npMCI, dwFlags, lpPlay, lpPlay->dwCallback);
}



/***************************************************************************
 *
 * @doc INTERNAL MCIWAVE
 *
 * @api DWORD | GraphicStep | This function steps through several frames
 *      of a movie. If the reverse flag is set, then the step is backwards.
 *      If the step count is not specified then it defaults to 1. If the
 *      step count plus the current position exceeds the movie length, the
 *      step is out of range.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the step message.
 *
 * @parm LPMCI_DGV_STEP_PARMS | lpStep | Parameters for the step message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicStep (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_STEP_PARMS lpStep)
{
    LONG        lFrameCur;
    LONG        lFrames;
    DWORD       dwRet;
    BOOL        fReverse;
    BOOL        fSeekExactOff;

    fReverse = (dwFlags & MCI_DGV_STEP_REVERSE) == MCI_DGV_STEP_REVERSE;

    // Default to 1 frame step if frame count is not specified

    if (dwFlags & MCI_DGV_STEP_FRAMES) {
        lFrames = (LONG) lpStep->dwFrames;

        if (fReverse) {
            if (lFrames < 0)
                return MCIERR_FLAGS_NOT_COMPATIBLE;
        }
    } else
        lFrames = 1;


    lFrames = fReverse ? -lFrames : lFrames;

    /* stop before figuring out whether frame count is within range, */
    /* unless the TEST flag is set. */

    if (!(dwFlags & MCI_TEST)) {
        if (dwRet = DeviceStop(npMCI, MCI_WAIT))
            return dwRet;
    }

    if (dwRet = DevicePosition(npMCI, &lFrameCur))
        return dwRet;

    if ((lFrames + lFrameCur > npMCI->lFrames) ||
                (lFrames + lFrameCur < 0))
        return MCIERR_OUTOFRANGE;

    if (!IsWindow(npMCI->hwndPlayback))
        return MCIERR_NO_WINDOW;

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
        return 0L;


    fSeekExactOff = (npMCI->dwOptionFlags & MCIAVIO_SEEKEXACT) == 0;

    npMCI->dwOptionFlags |= MCIAVIO_SEEKEXACT;

    npMCI->dwFlags |= MCIAVI_NEEDTOSHOW;

    if (fSeekExactOff) {
        /* If we were not in seek exact mode, make seek finish
        ** before we turn seek exact back off.
        */
        dwRet = DeviceSeek(npMCI, lFrames + lFrameCur, dwFlags | MCI_WAIT,
                    lpStep->dwCallback);
        npMCI->dwOptionFlags &= ~(MCIAVIO_SEEKEXACT);
    } else {
        dwRet = DeviceSeek(npMCI, lFrames + lFrameCur, dwFlags,
                    lpStep->dwCallback);
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicStop | This function stops playback of the movie.
 *      After a stop the state will be MCI_MODE_STOP. The frame counter
 *      is not reset.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the stop message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicStop (NPMCIGRAPHIC npMCI, DWORD dwFlags,
                                        LPMCI_GENERIC_PARMS lpParms)
{
    if (!IsWindow(npMCI->hwndPlayback))
        return MCIERR_NO_WINDOW;

    if (dwFlags & MCI_DGV_STOP_HOLD)
        return MCIERR_UNSUPPORTED_FUNCTION;

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
        return 0L;

    // this notify should be done on the worker thread if needed, but actually
    // I don't think we need it, since the play code will issue it (either
    // as an abort or as a success if it reached the right target).
    //GraphicDelayedNotify (npMCI, MCI_NOTIFY_ABORTED);

    /* Do we need to handle notify here? */
    /* Do we have the swing at Luton? */
    return DeviceStop(npMCI, dwFlags);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicPause | Pauses movie playback.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicPause(NPMCIGRAPHIC npMCI, DWORD dwFlags,
                                        LPMCI_GENERIC_PARMS lpParms)
{
    LPARAM dwCallback;
    if (!IsWindow(npMCI->hwndPlayback))
        return MCIERR_NO_WINDOW;

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
        return 0L;

    if (lpParms) {
        dwCallback = lpParms->dwCallback;
    } else {
        dwCallback = 0;
    }
    return DevicePause(npMCI, dwFlags, dwCallback);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicResume | This function resumes playback of a paused
 *      movie.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicResume (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_GENERIC_PARMS lpParms)
{
    LPARAM      dwCallback;

    //  Resume used to be only allowed if MCIAVI is paused or playing
    //  This is a little strange as some of the MCI commands automatically
    //  change PAUSED into STOPPED. There is no reason why we shouldn't
    //  treat resume as equivalent to play.  (As does CDPLAYER.)
    //
    // if you decide to disagree, then don't forget that the DeviceMode()
    // check can only safely be done *on the worker thread*


    if (!IsWindow(npMCI->hwndPlayback))
        return MCIERR_NO_WINDOW;

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
        return 0L;


    if (lpParms) {
        dwCallback = lpParms->dwCallback;
    } else {
        dwCallback = 0;
    }
    return DeviceResume(npMCI, dwFlags & MCI_WAIT, dwCallback);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicStatus | This function returns numeric status info.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the status message.
 *
 * @parm LPMCI_STATUS_PARMS | lpPlay | Parameters for the status message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicStatus (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_STATUS_PARMS lpStatus)
{
    DWORD dwRet = 0L;

    if (dwFlags & (MCI_DGV_STATUS_DISKSPACE))
        return MCIERR_UNSUPPORTED_FUNCTION;

    if (dwFlags & MCI_STATUS_ITEM) {

        lpStatus->dwReturn = 0L;

        if ((dwFlags & MCI_TRACK) &&
                !((lpStatus->dwItem == MCI_STATUS_POSITION) ||
                        (lpStatus->dwItem == MCI_STATUS_LENGTH)))
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        if ((dwFlags & MCI_STATUS_START) &&
                        (lpStatus->dwItem != MCI_STATUS_POSITION))
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        if (dwFlags & MCI_DGV_STATUS_REFERENCE)
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        switch (lpStatus->dwItem) {
            case MCI_STATUS_POSITION:

                if (dwFlags & MCI_TRACK) {
                    /* POSITION with TRACK means return the start of the  */
                    /* track. */

                    if (lpStatus->dwTrack != 1)
                        dwRet = MCIERR_OUTOFRANGE;
                    else
                        /* return start frame of track (always 0) */
                        lpStatus->dwReturn = 0L;
                } else if (dwFlags & MCI_STATUS_START)
                    // POSITION with START means return the starting playable
                    // position of the media.
                    lpStatus->dwReturn = 0L;
                else {
                    /* Otherwise return current frame */
                    dwRet = DevicePosition(npMCI, (LPLONG) &lpStatus->dwReturn);
                    lpStatus->dwReturn = ConvertFromFrames(npMCI,
                                                (LONG) lpStatus->dwReturn);
                }
                break;

            case MCI_STATUS_LENGTH:


                if (dwFlags & MCI_TRACK && lpStatus->dwTrack != 1) {
                    /* LENGTH with TRACK means return the length of track */

                    lpStatus->dwReturn = 0L;
                    dwRet = MCIERR_OUTOFRANGE;
                }

                lpStatus->dwReturn = ConvertFromFrames(npMCI, npMCI->lFrames);
                break;

            case MCI_STATUS_NUMBER_OF_TRACKS:
            case MCI_STATUS_CURRENT_TRACK:

                lpStatus->dwReturn = 1L;
                break;

            case MCI_STATUS_READY:

                /* Return TRUE if device can receive commands */
                if (DeviceMode(npMCI) != MCI_MODE_NOT_READY)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_STATUS_MODE:
            {
                WORD    wMode;
                wMode = (WORD) DeviceMode(npMCI);
                lpStatus->dwReturn = (DWORD) MAKEMCIRESOURCE(wMode, wMode);
                dwRet = MCI_RESOURCE_RETURNED;
            }
                break;

            case MCI_DGV_STATUS_PAUSE_MODE:
                if (DeviceMode(npMCI) != MCI_MODE_PAUSE)
                    dwRet = MCIERR_NONAPPLICABLE_FUNCTION;
                else {
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_PLAY, MCI_MODE_PLAY);
                    dwRet = MCI_RESOURCE_RETURNED;
                }
                break;

            case MCI_STATUS_MEDIA_PRESENT:

                lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_DGV_STATUS_FORWARD:
                if (npMCI->dwFlags & MCIAVI_REVERSE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_DGV_STATUS_HWND:

                lpStatus->dwReturn = (DWORD_PTR)(UINT_PTR)npMCI->hwndPlayback;
                if (!IsWindow(npMCI->hwndPlayback))
                    dwRet = MCIERR_NO_WINDOW;
                break;

            case MCI_DGV_STATUS_HPAL:

//              lpStatus->dwReturn = (DWORD) (UINT) DrawDibGetPalette(npMCI->hdd);

                lpStatus->dwReturn = 0;

                if (npMCI->nVideoStreams == 0) {
                    dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                } else {
                    LRESULT l = ICSendMessage(npMCI->hicDraw, ICM_DRAW_GET_PALETTE, 0, 0);

                    if (l == ICERR_UNSUPPORTED) {
                        dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                    } else {
                        lpStatus->dwReturn = l;
                        dwRet = 0;
                    }
                }
                DPF2(("Status HPAL returns: %lu\n", lpStatus->dwReturn));
                break;

            case MCI_STATUS_TIME_FORMAT:

                lpStatus->dwReturn = MAKEMCIRESOURCE(npMCI->dwTimeFormat,
                                npMCI->dwTimeFormat + MCI_FORMAT_RETURN_BASE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_DGV_STATUS_AUDIO:
                lpStatus->dwReturn = (npMCI->dwFlags & MCIAVI_PLAYAUDIO) ?
                                        (MAKEMCIRESOURCE(MCI_ON, MCI_ON_S)) :
                                        (MAKEMCIRESOURCE(MCI_OFF, MCI_OFF_S));
                dwRet = MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER;
                break;

            case MCI_DGV_STATUS_WINDOW_VISIBLE:
                if (npMCI->hwndPlayback && IsWindowVisible(npMCI->hwndPlayback))
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_DGV_STATUS_WINDOW_MINIMIZED:
                if (npMCI->hwndPlayback && IsIconic(npMCI->hwndPlayback))
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_DGV_STATUS_WINDOW_MAXIMIZED:
                if (npMCI->hwndPlayback && IsZoomed(npMCI->hwndPlayback))
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_DGV_STATUS_SAMPLESPERSEC:
            case MCI_DGV_STATUS_AVGBYTESPERSEC:
            case MCI_DGV_STATUS_BLOCKALIGN:
            case MCI_DGV_STATUS_BITSPERSAMPLE:
                dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                break;

            case MCI_DGV_STATUS_BITSPERPEL:
                if (npMCI->psiVideo)
                    lpStatus->dwReturn = ((LPBITMAPINFOHEADER)npMCI->psiVideo->lpFormat)->biBitCount;
                else
                    dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                break;

#ifndef _WIN32
#pragma message("Are we going to support brightness/color/contrast/tint?")
#endif
            case MCI_DGV_STATUS_BRIGHTNESS:
            case MCI_DGV_STATUS_COLOR:
            case MCI_DGV_STATUS_CONTRAST:
            case MCI_DGV_STATUS_TINT:
            case MCI_DGV_STATUS_GAMMA:
            case MCI_DGV_STATUS_SHARPNESS:
            case MCI_DGV_STATUS_FILE_MODE:
            case MCI_DGV_STATUS_FILE_COMPLETION:
            case MCI_DGV_STATUS_KEY_INDEX:
            case MCI_DGV_STATUS_KEY_COLOR:
                dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                break;

            case MCI_DGV_STATUS_FILEFORMAT:
// Fall through to Unsupported case...
//                lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_DGV_FF_AVI,
//                                              MCI_DGV_FF_AVI);
//              dwRet = MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER;
//              break;
//
            case MCI_DGV_STATUS_BASS:
            case MCI_DGV_STATUS_TREBLE:
                dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                break;

            case MCI_DGV_STATUS_VOLUME:
            {
                WORD    wLeftVolume, wRightVolume;
                // Be sure volume is up to date....
                DeviceGetVolume(npMCI);

                wLeftVolume = LOWORD(npMCI->dwVolume);
                wRightVolume = LOWORD(npMCI->dwVolume);

                switch (dwFlags & (MCI_DGV_STATUS_LEFT | MCI_DGV_STATUS_RIGHT)) {
                    case MCI_DGV_STATUS_LEFT:
                        lpStatus->dwReturn = (DWORD) wLeftVolume;
                    break;

                    case 0:
                        lpStatus->dwReturn = (DWORD) wRightVolume;
                    break;

                    default:
                        lpStatus->dwReturn = ((DWORD) wLeftVolume + (DWORD) wRightVolume) / 2;
                    break;
                }
            }
                break;

            case MCI_DGV_STATUS_MONITOR:
                lpStatus->dwReturn = (DWORD)
                                     MAKEMCIRESOURCE(MCI_DGV_MONITOR_FILE,
                                                MCI_DGV_FILE_S);
                dwRet = MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER;
                break;

            case MCI_DGV_STATUS_SEEK_EXACTLY:
                lpStatus->dwReturn =
                                (npMCI->dwOptionFlags & MCIAVIO_SEEKEXACT) ?
                                        (MAKEMCIRESOURCE(MCI_ON, MCI_ON_S)) :
                                        (MAKEMCIRESOURCE(MCI_OFF, MCI_OFF_S));
                dwRet = MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER;
                break;

            case MCI_DGV_STATUS_SIZE:
                /* We haven't reserved any space, so return zero. */
                lpStatus->dwReturn = 0L;
                break;

            case MCI_DGV_STATUS_SMPTE:
                dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                break;

            case MCI_DGV_STATUS_UNSAVED:
                lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_DGV_STATUS_VIDEO:
                lpStatus->dwReturn = (npMCI->dwFlags & MCIAVI_SHOWVIDEO) ?
                                        (MAKEMCIRESOURCE(MCI_ON, MCI_ON_S)) :
                                        (MAKEMCIRESOURCE(MCI_OFF, MCI_OFF_S));
                dwRet = MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER;
                break;

            case MCI_DGV_STATUS_SPEED:
                lpStatus->dwReturn = npMCI->dwSpeedFactor;
                break;

            case MCI_DGV_STATUS_FRAME_RATE:
            {
                DWORD   dwTemp;

                dwTemp = npMCI->dwMicroSecPerFrame;

                /* If they haven't specifically asked for the "nominal"
                ** rate of play, adjust by the current speed.
                */
                if (!(dwFlags & MCI_DGV_STATUS_NOMINAL))
                    dwTemp = muldiv32(dwTemp, 1000L, npMCI->dwSpeedFactor);

                if (dwTemp == 0)
                    lpStatus->dwReturn = 1000;
                else
                    /* Our return value is in "thousandths of frames/sec",
                    ** and dwTemp is the number of microseconds per frame.
                    ** Thus, we divide a billion microseconds by dwTemp.
                    */
                    lpStatus->dwReturn = muldiv32(1000000L, 1000L, dwTemp);
                break;
            }

            case MCI_DGV_STATUS_AUDIO_STREAM:
                lpStatus->dwReturn = 0;
                if (npMCI->nAudioStreams) {
                    int stream;

                    for (stream = 0; stream < npMCI->streams; stream++) {
                        if (SH(stream).fccType == streamtypeAUDIO)
                            ++lpStatus->dwReturn;

                        if (stream == npMCI->nAudioStream)
                            break;
                    }
                }
                break;

            case MCI_DGV_STATUS_VIDEO_STREAM:
            case MCI_DGV_STATUS_AUDIO_INPUT:
            case MCI_DGV_STATUS_AUDIO_RECORD:
            case MCI_DGV_STATUS_AUDIO_SOURCE:
            case MCI_DGV_STATUS_VIDEO_RECORD:
            case MCI_DGV_STATUS_VIDEO_SOURCE:
            case MCI_DGV_STATUS_VIDEO_SRC_NUM:
            case MCI_DGV_STATUS_MONITOR_METHOD:
            case MCI_DGV_STATUS_STILL_FILEFORMAT:
                dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                break;

            case MCI_AVI_STATUS_FRAMES_SKIPPED:
                lpStatus->dwReturn = npMCI->lSkippedFrames;
                break;

            case MCI_AVI_STATUS_AUDIO_BREAKS:
                lpStatus->dwReturn = npMCI->lAudioBreaks;
                break;

            case MCI_AVI_STATUS_LAST_PLAY_SPEED:
                lpStatus->dwReturn = npMCI->dwSpeedPercentage;
                break;

            default:
                dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                break;
        } /* end switch (item) */
    } else if (dwFlags & MCI_DGV_STATUS_REFERENCE) {

        if (lpStatus->dwReference > (DWORD) npMCI->lFrames)
            dwRet = MCIERR_OUTOFRANGE;

        else if (npMCI->psiVideo) {
            DWORD dwReference;
            dwReference = MovieToStream(npMCI->psiVideo,
                    lpStatus->dwReference);

            lpStatus->dwReturn = FindPrevKeyFrame(npMCI, npMCI->psiVideo,
                    dwReference);

            lpStatus->dwReturn = StreamToMovie(npMCI->psiVideo,
                    (DWORD) lpStatus->dwReturn);
        }
        else {
            lpStatus->dwReturn = 0;
        }
    } else /* item flag not set */
        dwRet = MCIERR_MISSING_PARAMETER;

    if ((dwFlags & MCI_TEST) && (LOWORD(dwRet) == 0)) {
        /* There is no error, but the test flag is on.  Return as little
        ** as possible.
        */
        dwRet = 0;
        lpStatus->dwReturn = 0;
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicInfo | This function returns alphanumeric information.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the info. message.
 *
 * @parm LPMCI_INFO_PARMS | lpPlay | Parameters for the info message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicInfo(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_INFO_PARMS lpInfo)
{
    DWORD       dwRet = 0L;
    TCHAR       ch = TEXT('\0');
    BOOL        fTest = FALSE;

    if (!lpInfo->lpstrReturn)
        return MCIERR_PARAM_OVERFLOW;

    if (dwFlags & MCI_TEST)
        fTest = TRUE;

    dwFlags &= ~(MCI_WAIT | MCI_NOTIFY | MCI_TEST);

    switch (dwFlags) {
    case 0L:
        return MCIERR_MISSING_PARAMETER;

    case MCI_INFO_FILE:
        if (!npMCI)
            return MCIERR_UNSUPPORTED_FUNCTION;

        if (lpInfo->dwRetSize < (DWORD)(lstrlen(npMCI->szFilename) + 1)) {
            ch = npMCI->szFilename[lpInfo->dwRetSize];
            npMCI->szFilename[lpInfo->dwRetSize] = '\0';
            dwRet = MCIERR_PARAM_OVERFLOW;
        }
        lstrcpy (lpInfo->lpstrReturn, npMCI->szFilename);
        if (ch)
            npMCI->szFilename[lpInfo->dwRetSize] = ch;
        break;

    case MCI_INFO_PRODUCT:

#ifdef _WIN32
    {
        UINT n;
#ifdef DEBUG
        TCHAR versionstring[80];
#endif
        n = LoadString(ghModule, MCIAVI_PRODUCTNAME, lpInfo->lpstrReturn,
                (UINT)lpInfo->dwRetSize);
#ifdef DEBUG
        #include "verinfo.h"

        n += wsprintf(versionstring,
            TEXT(" (%d.%02d.%02d)"), MMVERSION, MMREVISION, MMRELEASE);
        if (n <= lpInfo->dwRetSize) {
            lstrcat(lpInfo->lpstrReturn, versionstring);
        }
#endif
    }
#else // Win16 version follows
#ifdef DEBUG
        #include "..\verinfo\usa\verinfo.h"

        wsprintf(lpInfo->lpstrReturn,
            TEXT("VfW %d.%02d.%02d"), MMVERSION, MMREVISION, MMRELEASE);
#else
        /* !!! Not returning PARAM_OVERFLOW here but I am above - lazy eh */
        LoadString(ghModule, MCIAVI_PRODUCTNAME, lpInfo->lpstrReturn,
                (UINT)lpInfo->dwRetSize);
#endif
#endif
        break;

    case MCI_DGV_INFO_TEXT:
        if (!npMCI)
            return MCIERR_UNSUPPORTED_FUNCTION;

        if (IsWindow(npMCI->hwndPlayback))
            GetWindowText(npMCI->hwndPlayback, lpInfo->lpstrReturn,
                                        LOWORD(lpInfo->dwRetSize));
        else
            dwRet = MCIERR_NO_WINDOW;
        break;

    case MCI_INFO_VERSION:
        /* !!! Not returning PARAM_OVERFLOW here but I am above - lazy eh */
        LoadString(ghModule, MCIAVI_VERSION, lpInfo->lpstrReturn,
                (UINT)lpInfo->dwRetSize);
        break;

        case MCI_DGV_INFO_USAGE:
            dwRet = MCIERR_UNSUPPORTED_FUNCTION;
            break;

    case MCI_DGV_INFO_ITEM:
        switch (lpInfo->dwItem) {
        case MCI_DGV_INFO_AUDIO_QUALITY:
        case MCI_DGV_INFO_VIDEO_QUALITY:
        case MCI_DGV_INFO_STILL_QUALITY:
        case MCI_DGV_INFO_AUDIO_ALG:
        case MCI_DGV_INFO_VIDEO_ALG:
        case MCI_DGV_INFO_STILL_ALG:
        default:
            dwRet = MCIERR_UNSUPPORTED_FUNCTION;
            break;
        }
        break;

    default:
        dwRet = MCIERR_FLAGS_NOT_COMPATIBLE;
        break;
    }

    if (fTest && (LOWORD(dwRet) == 0)) {
        /* There is no error, but the test flag is on.  Return as little
        ** as possible.
        */
        dwRet = 0;
        if (lpInfo->dwRetSize)
            lpInfo->lpstrReturn[0] = '\0';
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicSet | This function sets various options.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the set message.
 *
 * @parm LPMCI_SET_PARMS | lpSet | Parameters for the set message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicSet (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_SET_PARMS lpSet)
{
    DWORD       dwRet = 0L;
    DWORD       dwAction;

    if (dwFlags & MCI_DGV_SET_FILEFORMAT)
        return MCIERR_UNSUPPORTED_FUNCTION;

    if (dwFlags & MCI_DGV_SET_STILL)
        return MCIERR_UNSUPPORTED_FUNCTION;

    dwAction = dwFlags & (MCI_SET_TIME_FORMAT           |
                         MCI_SET_VIDEO                  |
                         MCI_SET_AUDIO                  |
                         MCI_DGV_SET_SEEK_EXACTLY       |
                         MCI_DGV_SET_SPEED
                             );

    /* Turn off all but the following three flags */
    dwFlags &=  (MCI_SET_ON                             |
                         MCI_SET_OFF                    |
                         MCI_TEST
                             );

    /* First, check if the parameters are all okay */

    if (!dwAction)
        return MCIERR_UNSUPPORTED_FUNCTION;

    if (dwAction & MCI_SET_TIME_FORMAT) {
        if (lpSet->dwTimeFormat != MCI_FORMAT_FRAMES
                && lpSet->dwTimeFormat != MCI_FORMAT_MILLISECONDS)
            return MCIERR_UNSUPPORTED_FUNCTION;
    }

    if ((dwAction & MCI_SET_AUDIO) &&
                (lpSet->dwAudio != MCI_SET_AUDIO_ALL)) {
        return MCIERR_UNSUPPORTED_FUNCTION;
    }

    if (dwAction & MCI_DGV_SET_SPEED) {
        if (lpSet->dwSpeed > 100000L)
            return MCIERR_OUTOFRANGE;
    }

    switch (dwFlags & (MCI_SET_ON | MCI_SET_OFF)) {
        case 0:
            if (dwAction & (MCI_SET_AUDIO |
                                MCI_SET_VIDEO |
                                MCI_DGV_SET_SEEK_EXACTLY))
                return MCIERR_MISSING_PARAMETER;
            break;

        case MCI_SET_ON | MCI_SET_OFF:
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        default:
            if (dwAction & (MCI_DGV_SET_SPEED | MCI_SET_TIME_FORMAT))
                return MCIERR_FLAGS_NOT_COMPATIBLE;
            break;
    }

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
        return 0L;

    /* Now, actually carry out the command */
    if (dwAction & MCI_SET_TIME_FORMAT)
        npMCI->dwTimeFormat = lpSet->dwTimeFormat;

    if (dwAction & MCI_SET_VIDEO) {
        npMCI->dwFlags &= ~(MCIAVI_SHOWVIDEO);
        if (dwFlags & MCI_SET_ON) {
            npMCI->dwFlags |= MCIAVI_SHOWVIDEO;
            InvalidateRect(npMCI->hwndPlayback, NULL, FALSE);
        }
    }

    if (dwAction & MCI_DGV_SET_SEEK_EXACTLY) {
        npMCI->dwOptionFlags &= ~(MCIAVIO_SEEKEXACT);
        if (dwFlags & MCI_SET_ON)
            npMCI->dwOptionFlags |= MCIAVIO_SEEKEXACT;
    }

    if (dwAction & MCI_DGV_SET_SPEED) {
        dwRet = DeviceSetSpeed(npMCI, lpSet->dwSpeed);
    }

    if (dwRet == 0L && (dwAction & MCI_SET_AUDIO)) {
        dwRet = DeviceMute(npMCI, dwFlags & MCI_SET_OFF ? TRUE : FALSE);
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicSetAudio | This function sets various audio options.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the set audio message.
 *
 * @parm LPMCI_SET_PARMS | lpSet | Parameters for the set audio message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/
DWORD NEAR PASCAL GraphicSetAudio (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_SETAUDIO_PARMS lpSet)
{
    DWORD       dwRet = 0L;

    if (npMCI->nAudioStreams == 0) {
        return MCIERR_UNSUPPORTED_FUNCTION;
    }

    if ((dwFlags & MCI_DGV_SETAUDIO_ITEM) &&
            (lpSet->dwItem == MCI_DGV_SETAUDIO_VOLUME) &&
            (dwFlags & MCI_DGV_SETAUDIO_VALUE)) {
        WORD    wLeft, wRight;

        if (dwFlags & (MCI_DGV_SETAUDIO_ALG |
                   MCI_DGV_SETAUDIO_QUALITY |
                   MCI_DGV_SETAUDIO_RECORD |
                   MCI_DGV_SETAUDIO_CLOCKTIME))
            return MCIERR_UNSUPPORTED_FUNCTION;
        if (lpSet->dwValue > 1000L)
            return MCIERR_OUTOFRANGE;
        if (dwFlags & MCI_TEST)
            return 0L;

        // Be sure volume is up to date....
        DeviceGetVolume(npMCI);

        wLeft = LOWORD(npMCI->dwVolume);
        wRight = HIWORD(npMCI->dwVolume);
        if (!(dwFlags & MCI_DGV_SETAUDIO_RIGHT))
            wLeft = (WORD) lpSet->dwValue;

        if (!(dwFlags & MCI_DGV_SETAUDIO_LEFT))
            wRight = (WORD) lpSet->dwValue;

        dwRet = DeviceSetVolume(npMCI, MAKELONG(wLeft, wRight));
    } else if ((dwFlags & MCI_DGV_SETAUDIO_ITEM) &&
            (lpSet->dwItem == MCI_DGV_SETAUDIO_STREAM) &&
            (dwFlags & MCI_DGV_SETAUDIO_VALUE)) {
        if (dwFlags & (MCI_DGV_SETAUDIO_ALG |
                   MCI_DGV_SETAUDIO_QUALITY |
                   MCI_DGV_SETAUDIO_RECORD |
                   MCI_DGV_SETAUDIO_LEFT |
                   MCI_DGV_SETAUDIO_CLOCKTIME |
                   MCI_DGV_SETAUDIO_RIGHT))
            return MCIERR_UNSUPPORTED_FUNCTION;
        if (lpSet->dwValue > (DWORD) npMCI->nAudioStreams || lpSet->dwValue == 0)
            return MCIERR_OUTOFRANGE;
        if (dwFlags & MCI_TEST)
            return 0L;
        dwRet = DeviceSetAudioStream(npMCI, (WORD) lpSet->dwValue);
    } else if (dwFlags & (MCI_DGV_SETAUDIO_ITEM |
                   MCI_DGV_SETAUDIO_VALUE |
                   MCI_DGV_SETAUDIO_ALG |
                   MCI_DGV_SETAUDIO_QUALITY |
                   MCI_DGV_SETAUDIO_RECORD |
                   MCI_DGV_SETAUDIO_LEFT |
                   MCI_DGV_SETAUDIO_CLOCKTIME |
                   MCI_DGV_SETAUDIO_RIGHT))
        return MCIERR_UNSUPPORTED_FUNCTION;

    dwRet = 0;
    switch (dwFlags & (MCI_SET_ON | MCI_SET_OFF)) {

        case MCI_SET_ON | MCI_SET_OFF:
            dwRet = MCIERR_FLAGS_NOT_COMPATIBLE;
            break;

        case MCI_SET_OFF:
            dwRet = (DWORD)TRUE;
            // Drop through and call DeviceMute

        case MCI_SET_ON:
            if (!(dwFlags & MCI_TEST))
                dwRet = DeviceMute(npMCI, dwRet);
            else
                dwRet = 0;
            break;

        default:
            if (!(dwFlags & MCI_DGV_SETAUDIO_ITEM))
                dwRet = MCIERR_MISSING_PARAMETER;
            break;
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicSetVideo | This function sets various Video options.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the set video message.
 *
 * @parm LPMCI_SET_PARMS | lpSet | Parameters for the set video message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/
DWORD NEAR PASCAL GraphicSetVideo (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_SETVIDEO_PARMS lpSet)
{
    DWORD       dwRet = 0L;

    if (dwFlags & (MCI_DGV_SETVIDEO_RECORD |
                    MCI_DGV_SETVIDEO_SRC_NUMBER |
                    MCI_DGV_SETVIDEO_QUALITY |
                    MCI_DGV_SETVIDEO_ALG |
                    MCI_DGV_SETVIDEO_STILL |
                    MCI_DGV_SETVIDEO_CLOCKTIME
                        ))
        return MCIERR_UNSUPPORTED_FUNCTION;

    if ((dwFlags & MCI_DGV_SETVIDEO_OVER) &&
            (lpSet->dwItem != MCI_AVI_SETVIDEO_PALETTE_COLOR))
        return MCIERR_UNSUPPORTED_FUNCTION;

    if (dwFlags & MCI_DGV_SETVIDEO_ITEM) {
        switch (lpSet->dwItem) {
            case MCI_AVI_SETVIDEO_PALETTE_COLOR:
                if (!(dwFlags & MCI_DGV_SETVIDEO_OVER))
                    return MCIERR_MISSING_PARAMETER;

                if (lpSet->dwOver >= npMCI->pbiFormat->biClrUsed) {
                    return MCIERR_OUTOFRANGE;
                }

                return DeviceSetPaletteColor(npMCI,
                          lpSet->dwOver,
                          lpSet->dwValue);

            case MCI_DGV_SETVIDEO_PALHANDLE:
                if (dwFlags & MCI_DGV_SETVIDEO_VALUE) {
                    if (lpSet->dwValue &&
                        lpSet->dwValue != MCI_AVI_SETVIDEO_PALETTE_HALFTONE &&
                        GetObjectType((HPALETTE) lpSet->dwValue) != OBJ_PAL)
                        return MCIERR_AVI_BADPALETTE;
                }

                if (!(dwFlags & MCI_TEST))
                    dwRet = DeviceSetPalette(npMCI,
                                ((dwFlags & MCI_DGV_SETVIDEO_VALUE) ?
                                        (HPALETTE) lpSet->dwValue : NULL));
                break;

            case MCI_DGV_SETVIDEO_STREAM:

                if (!(dwFlags & MCI_DGV_SETVIDEO_VALUE))
                    return MCIERR_UNSUPPORTED_FUNCTION;

                if (lpSet->dwValue == 0 ||
                    lpSet->dwValue > (DWORD)npMCI->nVideoStreams + npMCI->nOtherStreams)
                    return MCIERR_OUTOFRANGE;

                if (dwFlags & MCI_SET_ON)
                    DPF(("SetVideoStream to #%d on\n", (int)lpSet->dwValue));
                else if (dwFlags & MCI_SET_OFF)
                    DPF(("SetVideoStream to #%d off\n", (int)lpSet->dwValue));
                else
                    DPF(("SetVideoStream to #%d\n", (int)lpSet->dwValue));

                if (!(dwFlags & MCI_TEST)) {
                    dwRet = DeviceSetVideoStream(npMCI, (UINT)lpSet->dwValue,
                          !(dwFlags & MCI_SET_OFF));
                }
                break;

            case MCI_AVI_SETVIDEO_DRAW_PROCEDURE:

                if (DeviceMode(npMCI) != MCI_MODE_STOP)
                    return MCIERR_UNSUPPORTED_FUNCTION;

                if (npMCI->hicDrawDefault) {
                    if (npMCI->hicDrawDefault != (HIC) -1)
                        ICClose(npMCI->hicDrawDefault);
                    npMCI->hicDrawDefault = 0;
                    npMCI->dwFlags &= ~(MCIAVI_USERDRAWPROC);
                }

                if (lpSet->dwValue) {

                    if (IsBadCodePtr((FARPROC) lpSet->dwValue)) {
                        DPF(("Bad code pointer!!!!\n"));
                        return MCIERR_OUTOFRANGE; //!!!MCIERR_BAD_PARAM;
                    }

                    npMCI->hicDrawDefault = ICOpenFunction(streamtypeVIDEO,
                        FOURCC_AVIDraw,ICMODE_DRAW,(FARPROC) lpSet->dwValue);

                    if (!npMCI->hicDrawDefault) {
                        return MCIERR_INTERNAL;
                    }
                    DPF(("Successfully set new draw procedure....\n"));

                    npMCI->dwFlags |= MCIAVI_USERDRAWPROC;
                }

                npMCI->dwFlags |= MCIAVI_NEEDDRAWBEGIN;
                InvalidateRect(npMCI->hwndPlayback, NULL, FALSE);
                return 0;

            default:
                dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                break;
        }
    } else if (dwFlags & (MCI_SET_ON | MCI_SET_OFF)) {
        switch (dwFlags & (MCI_SET_ON | MCI_SET_OFF)) {
        case MCI_SET_ON:
            if (!(dwFlags & MCI_TEST)) {
                InvalidateRect(npMCI->hwndPlayback, NULL, FALSE);
                npMCI->dwFlags |= MCIAVI_SHOWVIDEO;
            }
            break;
        case MCI_SET_OFF:
            if (!(dwFlags & MCI_TEST))
                npMCI->dwFlags &= ~(MCIAVI_SHOWVIDEO);
            break;
        case MCI_SET_ON | MCI_SET_OFF:
            dwRet = MCIERR_FLAGS_NOT_COMPATIBLE;
            break;
        }
    } else
        dwRet = MCIERR_MISSING_PARAMETER;

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicSignal | This function sets signals.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the set PositionAdvise message.
 *
 * @parm LPMCI_SIGNAL_PARMS | lpSignal | Parameters for the signal
 *      message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/
DWORD NEAR PASCAL GraphicSignal(NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_SIGNAL_PARMS lpSignal)
{
    DWORD       dwRet = 0L;
    DWORD       dwUser;
    DWORD       dwPosition;
    DWORD       dwPeriod;

    dwUser = (dwFlags & MCI_DGV_SIGNAL_USERVAL) ? lpSignal->dwUserParm : 0L;

    if (dwFlags & MCI_DGV_SIGNAL_CANCEL) {
        if (dwFlags & (MCI_DGV_SIGNAL_AT |
                       MCI_DGV_SIGNAL_EVERY |
                       MCI_DGV_SIGNAL_POSITION))
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        if (!npMCI->dwSignals)
            return MCIERR_NONAPPLICABLE_FUNCTION;

        if (dwUser && (npMCI->signal.dwUserParm != dwUser))
            return MCIERR_NONAPPLICABLE_FUNCTION;

        if (!(dwFlags & MCI_TEST))
            --npMCI->dwSignals;
    } else {
        if ((npMCI->dwSignals != 0) && (dwUser != npMCI->signal.dwUserParm)) {
            /* !!! Should we allow more than one signal? */
            return MCIERR_DGV_DEVICE_LIMIT;
        }

        if (dwFlags & MCI_DGV_SIGNAL_AT) {
            /* Use position passed in */
            dwPosition = ConvertToFrames(npMCI, lpSignal->dwPosition);
            if (dwPosition > (DWORD) npMCI->lFrames)
                return MCIERR_OUTOFRANGE;
        } else {
            /* Get current position */
            DevicePosition(npMCI, (LPLONG) &dwPosition);
        }

        if (dwFlags & MCI_DGV_SIGNAL_EVERY) {
            dwPeriod = (DWORD) ConvertToFrames(npMCI, lpSignal->dwPeriod);

            if (dwPeriod == 0 || (dwPeriod > (DWORD) npMCI->lFrames))
                return MCIERR_OUTOFRANGE;
        } else {
            /* It's a one-time signal */
            dwPeriod = 0L;
        }

        if (dwFlags & MCI_TEST)
            return 0;

        npMCI->signal.dwPosition = dwPosition;
        npMCI->signal.dwPeriod = dwPeriod;
        npMCI->signal.dwUserParm = dwUser;
        npMCI->signal.dwCallback = lpSignal->dwCallback;
        npMCI->dwSignalFlags = dwFlags;

        /* The signal isn't really activated until we do this. */
        if (!npMCI->dwSignals)
            ++npMCI->dwSignals;
    }

    return 0L;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicList | This function supports the MCI_LIST command.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the List message.
 *
 * @parm LPMCI_DGV_LIST_PARMS | lpList | Parameters for the list message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/
DWORD NEAR PASCAL GraphicList(NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_LIST_PARMS lpList)
{
    return MCIERR_UNSUPPORTED_FUNCTION;
}


/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicGetDevCaps | This function returns  device
 *      capabilities
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the GetDevCaps message.
 *
 * @parm LPMCI_GETDEVCAPS_PARMS | lpCaps | Parameters for the GetDevCaps
 *      message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicGetDevCaps (NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_GETDEVCAPS_PARMS lpCaps )
{

    DWORD dwRet = 0L;


    if (dwFlags & MCI_GETDEVCAPS_ITEM)
        {

        switch (lpCaps->dwItem)
            {
            case MCI_GETDEVCAPS_CAN_RECORD:
            case MCI_GETDEVCAPS_CAN_EJECT:
            case MCI_GETDEVCAPS_CAN_SAVE:
            case MCI_DGV_GETDEVCAPS_CAN_LOCK:
            case MCI_DGV_GETDEVCAPS_CAN_STR_IN:
            case MCI_DGV_GETDEVCAPS_CAN_FREEZE:
            case MCI_DGV_GETDEVCAPS_HAS_STILL:

                lpCaps->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_DGV_GETDEVCAPS_CAN_REVERSE:
            case MCI_GETDEVCAPS_CAN_PLAY:
            case MCI_GETDEVCAPS_HAS_AUDIO:
            case MCI_GETDEVCAPS_HAS_VIDEO:
            case MCI_GETDEVCAPS_USES_FILES:
            case MCI_GETDEVCAPS_COMPOUND_DEVICE:
            case MCI_DGV_GETDEVCAPS_PALETTES:
            case MCI_DGV_GETDEVCAPS_CAN_STRETCH:
            case MCI_DGV_GETDEVCAPS_CAN_TEST:
                lpCaps->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_GETDEVCAPS_DEVICE_TYPE:

                lpCaps->dwReturn = MAKEMCIRESOURCE(MCI_DEVTYPE_DIGITAL_VIDEO,
                                            MCI_DEVTYPE_DIGITAL_VIDEO);
                dwRet = MCI_RESOURCE_RETURNED;
                break;

            case MCI_DGV_GETDEVCAPS_MAX_WINDOWS:
            case MCI_DGV_GETDEVCAPS_MAXIMUM_RATE:
            case MCI_DGV_GETDEVCAPS_MINIMUM_RATE:
            default:

                dwRet = MCIERR_UNSUPPORTED_FUNCTION;
                break;
            }
        }
    else
        dwRet = MCIERR_MISSING_PARAMETER;

    if ((dwFlags & MCI_TEST) && (LOWORD(dwRet) == 0)) {
        /* There is no error, but the test flag is on.  Return as little
        ** as possible.
        */
        dwRet = 0;
        lpCaps->dwReturn = 0;
    }

    return (dwRet);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicWindow | This function controls the stage window
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the window message.
 *
 * @parm LPMCI_DGV_WINDOW_PARMS | lpPlay | Parameters for the window message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicWindow (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_WINDOW_PARMS lpWindow)
{
    DWORD   dwRet = 0L;
    int     i = 0;
    HWND    hWndNew;

    if (dwFlags & MCI_DGV_WINDOW_HWND) {
        // Set a new stage window. If the parameter is NULL, then
        // use the default window. Otherwise, hide the default
        // window and use the given window handle.

        if (!lpWindow->hWnd)
            hWndNew = npMCI->hwndDefault;
        else
            hWndNew = lpWindow->hWnd;

        if (!IsWindow(hWndNew))
            return MCIERR_NO_WINDOW;

        /* If the test flag is set, return without doing anything. */
        /* Question: do we have to check for more possible errors? */
        if (dwFlags & MCI_TEST)
            return 0L;

        // only change if the new window handle is different from the current
        // stage window handle

        if (hWndNew != npMCI->hwndPlayback) {
            dwRet = DeviceSetWindow(npMCI, hWndNew);


            if (npMCI->hwndPlayback != npMCI->hwndDefault) {

                // see comment in graphic.h
                // They've specified their own window for playback.  Don't use
                // the default registry sizing
                npMCI->fOKToUseDefaultSizing = FALSE;

                if (IsWindow(npMCI->hwndDefault))
                    ShowWindow(npMCI->hwndDefault, SW_HIDE);
            }
        }
    }

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
        return dwRet;

    if (!dwRet) {
                if (IsWindow(npMCI->hwndPlayback)) {
                        if (dwFlags & MCI_DGV_WINDOW_STATE) {
                                // see comment in graphic.h on npMCI->fOKToUseDefaultSizing
                                // This is the moment of truth.  We're showing the window
                                // and we may want to pay attention to the registry default
                                // sizing (zoom by 2, fixed % of screen size, etc.)
                                // As an extra note I should say that it's important that we
                                // don't change it until now so that if somebody opens a file
                                // and does a "where destination" they get the original size,
                                // because if they're playing in their own window, it will
                                // not be altered anyway.
                                if (lpWindow->nCmdShow != SW_HIDE) {
                                        if (npMCI->fOKToUseDefaultSizing) {
                                                SetWindowToDefaultSize(npMCI, TRUE);
                                                ResetDestRect(npMCI, TRUE);
                                        }

                                        // Never do this again
                                        npMCI->fOKToUseDefaultSizing = FALSE;
                                }

                        ShowWindow (npMCI->hwndPlayback, lpWindow->nCmdShow);
                        }

            if (dwFlags & MCI_DGV_WINDOW_TEXT)
                        SetWindowText(npMCI->hwndPlayback, lpWindow->lpstrText);
        } else
            dwRet = MCIERR_NO_WINDOW;
    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicPut | This function sets the offset and extent
 *      of the animation within the client area of the stage window.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the put message.
 *
 * @parm LPMCI_DGV_RECT_PARMS | lpDestination | Parameters for the
 *      destination message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicPut ( NPMCIGRAPHIC npMCI,
    DWORD dwFlags, LPMCI_DGV_RECT_PARMS lpParms)
{
    BOOL        frc;
    RECT        rc;

    if (dwFlags & (MCI_DGV_PUT_FRAME | MCI_DGV_PUT_VIDEO))
        return MCIERR_UNSUPPORTED_FUNCTION;

    frc = (dwFlags & MCI_DGV_RECT) == MCI_DGV_RECT;

    if (!IsWindow(npMCI->hwndPlayback))
        return MCIERR_NO_WINDOW;

    switch (dwFlags & (MCI_DGV_PUT_SOURCE | MCI_DGV_PUT_DESTINATION |
                            MCI_DGV_PUT_WINDOW)) {
        case 0L:
            return MCIERR_MISSING_PARAMETER;

        case MCI_DGV_PUT_SOURCE:
            // If a rectangle is supplied, use it.
            if (frc) {
                rc.left = lpParms->ptOffset.x;
                rc.top = lpParms->ptOffset.y;
                rc.right = lpParms->ptOffset.x + lpParms->ptExtent.x;
                rc.bottom = lpParms->ptOffset.y + lpParms->ptExtent.y;
                DPF2(("GraphicPut_Source: rc [%d %d %d %d]\n", rc));

                if (lpParms->ptExtent.x <= 0) {
                    rc.right = rc.left + (npMCI->rcDest.right - npMCI->rcDest.left);
                }
                if (lpParms->ptExtent.y <= 0) {
                    rc.bottom = rc.top + (npMCI->rcDest.bottom - npMCI->rcDest.top);
                }
            } else {
                /* Reset to default */
                rc = npMCI->rcMovie;
                DPF2(("GraphicPut_Source (default): rc [%d %d %d %d]\n", rc));
            }
            break;

        case MCI_DGV_PUT_DESTINATION:
            // If a rectangle is supplied, use it.
            if (frc) {
                rc.left = lpParms->ptOffset.x;
                rc.top = lpParms->ptOffset.y;
                rc.right = lpParms->ptOffset.x + lpParms->ptExtent.x;
                rc.bottom = lpParms->ptOffset.y + lpParms->ptExtent.y;
                DPF2(("GraphicPut_Destination: rc [%d %d %d %d]\n", rc));

                if (lpParms->ptExtent.x <= 0) {
                    rc.right = rc.left + (npMCI->rcDest.right - npMCI->rcDest.left);
                }
                if (lpParms->ptExtent.y <= 0) {
                    rc.bottom = rc.top + (npMCI->rcDest.bottom - npMCI->rcDest.top);
                }

            } else {
                /* Reset to size of stage window */
                GetClientRect(npMCI->hwndPlayback, &rc);
                DPF2(("GraphicPut_Destination (default): rc [%d %d %d %d]\n", rc));
            }
            break;

        case MCI_DGV_PUT_WINDOW:
            if (dwFlags & MCI_TEST)
                return 0L;

            // De-minimize their window, so we don't end up with
            // a giant icon....
            if (IsIconic(npMCI->hwndPlayback))
                ShowWindow(npMCI->hwndPlayback, SW_RESTORE);

            // If a rectangle is supplied, use it.
            if (frc) {
                RECT    rcOld;

                rc.left = lpParms->ptOffset.x;
                rc.right = lpParms->ptOffset.x + lpParms->ptExtent.x;
                rc.top = lpParms->ptOffset.y;
                rc.bottom = lpParms->ptOffset.y + lpParms->ptExtent.y;
                if (dwFlags & MCI_DGV_PUT_CLIENT) {
                    AdjustWindowRect(&rc,
                                    GetWindowLong(npMCI->hwndPlayback, GWL_STYLE),
                                    FALSE);
                }

                // Default to just moving if width, height == 0....
                GetWindowRect(npMCI->hwndPlayback, &rcOld);
                if (lpParms->ptExtent.x <= 0) {
                    rc.right = rc.left + (rcOld.right - rcOld.left);
                }
                if (lpParms->ptExtent.y <= 0) {
                    rc.bottom = rc.top + (rcOld.bottom - rcOld.top);
                }

                MoveWindow(npMCI->hwndPlayback,
                            rc.left, rc.top,
                            rc.right - rc.left, rc.bottom - rc.top, TRUE);
            } else {
                // !!! What should we do if there's no rectangle?

                /* Reset to "natural" size? */
                rc = npMCI->rcMovie;

                if (npMCI->dwOptionFlags & MCIAVIO_ZOOMBY2)
                    SetRect(&rc, 0, 0, rc.right*2, rc.bottom*2);

                AdjustWindowRect(&rc, GetWindowLong(npMCI->hwndPlayback, GWL_STYLE),
                                            FALSE);

                SetWindowPos(npMCI->hwndPlayback, NULL, 0, 0,
                                rc.right - rc.left, rc.bottom - rc.top,
                                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
            }

            // Premiere 1.0 depends on the window always being visible
            // after a PUT_WINDOW command.  Make it so.
            ShowWindow(npMCI->hwndPlayback, SW_RESTORE);
            return 0L;

        default:
            return MCIERR_FLAGS_NOT_COMPATIBLE;
    }

    if (dwFlags & MCI_DGV_PUT_CLIENT)
        return MCIERR_FLAGS_NOT_COMPATIBLE;

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
        return 0L;

    // see comment in graphic.h
    // Any "put" command is dicking with the playback window and I think that's
    // grounds to not use the default window sizing.
    npMCI->fOKToUseDefaultSizing = FALSE;

    return DevicePut(npMCI, &rc, dwFlags);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicWhere | This function returns the current
 *      source and destination rectangles, in offset/extent form.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the query source message.
 *
 * @parm LPMCI_DGV_RECT_PARMS | lpParms | Parameters for the message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicWhere(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_RECT_PARMS lpParms)
{
    RECT        rc;

    if (dwFlags & (MCI_DGV_WHERE_FRAME | MCI_DGV_WHERE_VIDEO))
        return MCIERR_UNSUPPORTED_FUNCTION;

    // !!! WHERE_WINDOW?

    switch (dwFlags & (MCI_DGV_WHERE_SOURCE | MCI_DGV_WHERE_DESTINATION |
                            MCI_DGV_WHERE_WINDOW)) {
        case 0L:
            return MCIERR_MISSING_PARAMETER;

        case MCI_DGV_WHERE_SOURCE:
            if (dwFlags & MCI_DGV_WHERE_MAX) {
                lpParms->ptOffset.x = npMCI->rcMovie.left;
                lpParms->ptOffset.y = npMCI->rcMovie.top;
                lpParms->ptExtent.x = npMCI->rcMovie.right - npMCI->rcMovie.left;
                lpParms->ptExtent.y = npMCI->rcMovie.bottom - npMCI->rcMovie.top;
                DPF2(("Where source (max): [%d, %d, %d, %d]\n", npMCI->rcMovie));
            } else {
                lpParms->ptOffset.x = npMCI->rcSource.left;
                lpParms->ptOffset.y = npMCI->rcSource.top;
                lpParms->ptExtent.x = npMCI->rcSource.right  - npMCI->rcSource.left;
                lpParms->ptExtent.y = npMCI->rcSource.bottom - npMCI->rcSource.top;
                DPF2(("Where source: [%d, %d, %d, %d]\n", npMCI->rcSource));
            }
            break;

        case MCI_DGV_WHERE_DESTINATION:
            if (dwFlags & MCI_DGV_WHERE_MAX) {
                /* Return size of window */
                GetClientRect(npMCI->hwndPlayback, &rc);
                lpParms->ptOffset.x = 0;
                lpParms->ptOffset.y = 0;
                lpParms->ptExtent.x = rc.right;
                lpParms->ptExtent.y = rc.bottom;
                DPF2(("Where destination (max): [%d, %d, %d, %d]\n", rc));
            } else {
                /* Return current destination size */
                lpParms->ptOffset.x = npMCI->rcDest.left;
                lpParms->ptOffset.y = npMCI->rcDest.top;
                lpParms->ptExtent.x = npMCI->rcDest.right - npMCI->rcDest.left;
                lpParms->ptExtent.y = npMCI->rcDest.bottom - npMCI->rcDest.top;
                DPF2(("Where destination: [%d, %d, %d, %d]\n", npMCI->rcDest));
            }
            break;

        case MCI_DGV_WHERE_WINDOW:
            if (dwFlags & MCI_DGV_WHERE_MAX) {
                /* Return maximum size of window */
                GetClientRect(npMCI->hwndPlayback, &rc);
                lpParms->ptOffset.x = 0;
                lpParms->ptOffset.y = 0;
                lpParms->ptExtent.x = GetSystemMetrics(SM_CXSCREEN);
                lpParms->ptExtent.y = GetSystemMetrics(SM_CYSCREEN);
            } else {
                /* Return size of window */
                GetWindowRect(npMCI->hwndPlayback, &rc);
                lpParms->ptOffset.x = rc.left;
                lpParms->ptOffset.y = rc.top;
                lpParms->ptExtent.x = rc.right - rc.left;
                lpParms->ptExtent.y = rc.bottom - rc.top;
            }
            break;

        default:
            return MCIERR_FLAGS_NOT_COMPATIBLE;
    }

    return 0L;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicRealize | This function realizes the current palette
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicRealize(NPMCIGRAPHIC npMCI, DWORD dwFlags)
{
    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
        return 0L;

    npMCI->fForceBackground = (dwFlags & MCI_DGV_REALIZE_BKGD) != 0;

    return DeviceRealize(npMCI);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicUpdate | This function refreshes the current frame.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the message.
 *
 * @parm LPMCI_DGV_UPDATE_PARMS | lpParms | Parameters for the message.
 *
 * @rdesc Returns an MCI error code.
 *
 ***************************************************************************/

DWORD NEAR PASCAL GraphicUpdate(NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_DGV_UPDATE_PARMS lpParms)
{
    RECT    rc;

    rc.left   = lpParms->ptOffset.x;
    rc.top    = lpParms->ptOffset.y;
    rc.right  = lpParms->ptOffset.x + lpParms->ptExtent.x;
    rc.bottom = lpParms->ptOffset.y + lpParms->ptExtent.y;

    if (!(dwFlags & MCI_DGV_UPDATE_HDC)) {
        InvalidateRect(npMCI->hwndPlayback, (dwFlags & MCI_DGV_RECT) ? &rc : NULL, TRUE);

        // this will cause the winproc thread to do the repaint now
        UpdateWindow(npMCI->hwndPlayback);
        return 0;
    }

    /* If the test flag is set, return without doing anything. */
    /* Question: do we have to check for more possible errors? */
    if (dwFlags & MCI_TEST)
        return 0L;

    return DeviceUpdate (npMCI, dwFlags, lpParms);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | GraphicConfig | This function brings up the configure dialog.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwFlags | Flags for the message.
 *        The only flag bit checked is MCI_TEST
 *
 * @rdesc Returns 0.
 *
 ***************************************************************************/

DWORD FAR PASCAL GraphicConfig(NPMCIGRAPHIC npMCI, DWORD dwFlags)
{
    DWORD dwOptions = npMCI->dwOptionFlags;

    if (!(dwFlags & MCI_TEST)) {
        BOOL f;
        gfEvil++;

        f = ConfigDialog(NULL, npMCI);
        if (f) {

#ifdef DEBUG
            //
            // in DEBUG always reset the dest rect because the user may
            // have played with the DEBUG DrawDib options and we will
            // need to call DrawDibBegin() again.
            //
            if (TRUE) {
#else
            if ((npMCI->dwOptionFlags & (MCIAVIO_STUPIDMODE|MCIAVIO_ZOOMBY2
                                        |MCIAVIO_WINDOWSIZEMASK))
                        != (dwOptions & (MCIAVIO_STUPIDMODE|MCIAVIO_ZOOMBY2
                                        |MCIAVIO_WINDOWSIZEMASK)) ) {
#endif

                npMCI->lFrameDrawn = (- (LONG) npMCI->wEarlyRecords) - 1;
                SetWindowToDefaultSize(npMCI, TRUE);

                // don't do this on the user thread
                //SetRectEmpty(&npMCI->rcDest); //This will force a change!

                ResetDestRect(npMCI, TRUE);
            }
        }
        else {
            npMCI->dwOptionFlags = dwOptions;
        }
        gfEvil--;
    }

    return 0L;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | mciSpecial | This function handles all the MCI
 *      commands that don't require instance data such as open.
 *
 * @parm UINT | wDeviceID | The MCI device ID
 *
 * @parm UINT | wMessage | The requested action to be performed.
 *
 * @parm DWORD | dwFlags | Flags for the message.
 *
 * @parm DWORD | lpParms | Parameters for this message.
 *
 * @rdesc Error Constant. 0L on success
 *
 ***************************************************************************/

DWORD NEAR PASCAL mciSpecial (UINT wDeviceID, UINT wMessage, DWORD dwFlags, LPMCI_GENERIC_PARMS lpParms)
{
    NPMCIGRAPHIC npMCI = 0L;
    DWORD dwRet;

    /* since there in no instance block, there is no saved notification */
    /* to abort. */

    switch (wMessage) {
        case MCI_OPEN_DRIVER:
            if (dwFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))
                dwRet = GraphicOpen (&npMCI, dwFlags,
                            (LPMCI_DGV_OPEN_PARMS) lpParms, wDeviceID);
            else
                dwRet = 0L;

            mciSetDriverData (wDeviceID, (UINT_PTR)npMCI);
            break;

        case MCI_GETDEVCAPS:
            dwRet = GraphicGetDevCaps(NULL, dwFlags,
                            (LPMCI_GETDEVCAPS_PARMS)lpParms);
            break;

        case MCI_CONFIGURE:

            if (!(dwFlags & MCI_TEST))
                ConfigDialog(NULL, NULL);

            dwRet = 0L;
            break;

        case MCI_INFO:
            dwRet = GraphicInfo(NULL, dwFlags, (LPMCI_DGV_INFO_PARMS)lpParms);
            break;

        case MCI_CLOSE_DRIVER:
            dwRet = 0L;
            break;

        default:
            dwRet = MCIERR_UNSUPPORTED_FUNCTION;
            break;
    }

    GraphicImmediateNotify (wDeviceID, lpParms, dwFlags, dwRet);
    return (dwRet);
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | mciDriverEntry | This function is the MCI handler
 *
 * @parm UINT | wDeviceID | The MCI device ID
 *
 * @parm UINT | wMessage | The requested action to be performed.
 *
 * @parm DWORD | dwFlags | Flags for the message.
 *
 * @parm DWORD | lpParms | Parameters for this message.
 *
 * @rdesc Error Constant. 0L on success
 *
 ***************************************************************************/

DWORD PASCAL mciDriverEntry (UINT wDeviceID, UINT wMessage, DWORD dwFlags, LPMCI_GENERIC_PARMS lpParms)
{
    NPMCIGRAPHIC npMCI = 0L;
    DWORD dwRet = MCIERR_UNRECOGNIZED_COMMAND;
    BOOL fDelayed = FALSE;
    BOOL fNested = FALSE;

    /* All current commands require a parameter block. */

    if (!lpParms && (dwFlags & MCI_NOTIFY))
        return (MCIERR_MISSING_PARAMETER);

    npMCI = (NPMCIGRAPHIC) mciGetDriverData(wDeviceID);

    if (!npMCI)
        return mciSpecial(wDeviceID, wMessage, dwFlags, lpParms);
#ifdef DEBUG
    else
        Assert(npMCI->mciid == MCIID);
#endif

    /*
    ** If a WOW app has subclassed the AVIWnd32 window,
    ** this is very bad as it stops all "Sent" message processing on
    ** that window, "Posted" messages seem to be OK.  This means
    ** that it is not possible to close the movie window.
    */
    if ( IsNTWOW() ) {

          DPF2(( "WOW mcidriverentry\n"));
          if ( IsWindow(npMCI->hwndDefault) ) {

              WNDPROC wndProc = (WNDPROC)GetWindowLongPtr( npMCI->hwndDefault,
                                                        GWLP_WNDPROC );
              if ( wndProc != GraphicWndProc ) {

                  DPF2(( "WOW app has subclassed AVIWnd32 window - correcting\n" ));
                  SetWindowLongPtr( npMCI->hwndDefault, GWLP_WNDPROC,
                                 (LONG_PTR)GraphicWndProc );
              }
              wndProc = (WNDPROC)GetClassLongPtr(npMCI->hwndDefault, GCLP_WNDPROC);
              if (wndProc != GraphicWndProc) {
                  DPF2(( "WOW app has subclassed AVIWnd32 class! - correcting\n" ));
                  SetClassLongPtr( npMCI->hwndDefault, GCLP_WNDPROC,
                                 (LONG_PTR)GraphicWndProc );
              }
          }
    }

    if (npMCI->wMessageCurrent) {
        fNested = TRUE;

        if (wMessage != MCI_STATUS && wMessage != MCI_GETDEVCAPS &&
                    wMessage != MCI_INFO) {
            DPF(("Warning!!!!!\n"));
            DPF(("Warning!!!!!     MCIAVI reentered: received %x while processing %x\n", wMessage, npMCI->wMessageCurrent));
            DPF(("Warning!!!!!\n"));
//          Assert(0);
//          return MCIERR_DEVICE_NOT_READY;
        }
    } else
        npMCI->wMessageCurrent = wMessage;

    switch (wMessage) {

        case MCI_CLOSE_DRIVER:


            // Question:  Should we set the driver data to NULL
            // before closing the device?  It would seem the right order.
            // So... we have moved this line before the call to GraphicClose
            mciSetDriverData(wDeviceID, 0L);

            // note that GraphicClose will release and delete the critsec
            dwRet = GraphicClose(npMCI);

            npMCI = NULL;
            break;

        case MCI_PLAY:

            dwRet = GraphicPlay(npMCI, dwFlags, (LPMCI_PLAY_PARMS)lpParms);
            fDelayed = TRUE;
            break;

        case MCI_CUE:

            dwRet = GraphicCue(npMCI, dwFlags, (LPMCI_DGV_CUE_PARMS)lpParms);
            fDelayed = TRUE;
            break;

        case MCI_STEP:

            dwRet = GraphicStep(npMCI, dwFlags, (LPMCI_DGV_STEP_PARMS)lpParms);
            fDelayed = TRUE;
            break;

        case MCI_STOP:

            dwRet = GraphicStop(npMCI, dwFlags, lpParms);
            break;

        case MCI_SEEK:

            dwRet = GraphicSeek (npMCI, dwFlags, (LPMCI_SEEK_PARMS)lpParms);
            fDelayed = TRUE;
            break;

        case MCI_PAUSE:

            dwRet = GraphicPause(npMCI, dwFlags, lpParms);
            fDelayed = TRUE;
            break;

        case MCI_RESUME:

            dwRet = GraphicResume(npMCI, dwFlags, lpParms);
            fDelayed = TRUE;
            break;

        case MCI_SET:

            dwRet = GraphicSet(npMCI, dwFlags,
                                (LPMCI_DGV_SET_PARMS)lpParms);
            break;

        case MCI_STATUS:

            dwRet = GraphicStatus(npMCI, dwFlags,
                                (LPMCI_DGV_STATUS_PARMS)lpParms);
            break;

        case MCI_INFO:

            dwRet = GraphicInfo (npMCI, dwFlags, (LPMCI_DGV_INFO_PARMS)lpParms);
            break;

        case MCI_GETDEVCAPS:

            dwRet = GraphicGetDevCaps(npMCI, dwFlags, (LPMCI_GETDEVCAPS_PARMS)lpParms);
            break;

        case MCI_REALIZE:

            dwRet = GraphicRealize(npMCI, dwFlags);
            break;

        case MCI_UPDATE:

            dwRet = GraphicUpdate(npMCI, dwFlags, (LPMCI_DGV_UPDATE_PARMS)lpParms);
            break;

        case MCI_WINDOW:

            dwRet = GraphicWindow(npMCI, dwFlags, (LPMCI_DGV_WINDOW_PARMS)lpParms);
            break;

        case MCI_PUT:

            dwRet = GraphicPut(npMCI, dwFlags, (LPMCI_DGV_RECT_PARMS)lpParms);
            break;

        case MCI_WHERE:

            dwRet = GraphicWhere(npMCI, dwFlags, (LPMCI_DGV_RECT_PARMS)lpParms);
            break;

        case MCI_CONFIGURE:
            dwRet = GraphicConfig(npMCI, dwFlags);
            break;

        case MCI_SETAUDIO:
            dwRet = GraphicSetAudio(npMCI, dwFlags,
                        (LPMCI_DGV_SETAUDIO_PARMS) lpParms);
            break;

        case MCI_SETVIDEO:
            dwRet = GraphicSetVideo(npMCI, dwFlags,
                        (LPMCI_DGV_SETVIDEO_PARMS) lpParms);
            break;

        case MCI_SIGNAL:
            dwRet = GraphicSignal(npMCI, dwFlags,
                        (LPMCI_DGV_SIGNAL_PARMS) lpParms);
            break;

        case MCI_LIST:
            dwRet = GraphicList(npMCI, dwFlags,
                        (LPMCI_DGV_LIST_PARMS) lpParms);
            break;

        case MCI_LOAD:
            dwRet = GraphicLoad(npMCI, dwFlags,
                                  (LPMCI_DGV_LOAD_PARMS) lpParms);
            break;

        case MCI_RECORD:
        case MCI_SAVE:

        case MCI_CUT:
        case MCI_COPY:
        case MCI_PASTE:
        case MCI_UNDO:

        case MCI_DELETE:
        case MCI_CAPTURE:
        case MCI_QUALITY:
        case MCI_MONITOR:
        case MCI_RESERVE:
        case MCI_FREEZE:
        case MCI_UNFREEZE:
            dwRet = MCIERR_UNSUPPORTED_FUNCTION;
            break;

            /* Do we need this case? */
        default:
            dwRet = MCIERR_UNRECOGNIZED_COMMAND;
            break;
    }

    if (!fDelayed || (dwFlags & MCI_TEST)) {
        /* We haven't processed the notify yet. */
        if (npMCI && (dwFlags & MCI_NOTIFY) && (!LOWORD(dwRet)))
            /* Throw away the old notify */
            GraphicDelayedNotify(npMCI, MCI_NOTIFY_SUPERSEDED);

        /* And send the new one out immediately. */
        GraphicImmediateNotify(wDeviceID, lpParms, dwFlags, dwRet);
    }

    if (npMCI) {
        /* Everything from here on relies on npMCI still being around */

        /* If there's an error, don't save the callback.... */
        if (fDelayed && dwRet != 0 && (dwFlags & MCI_NOTIFY)) {

            // this might be too late, of course, but shouldn't do
            // any harm
            npMCI->hCallback = 0;
        }

        //
        //  see if we need to tell the DRAW device about moving.
        //  MPlayer is sending the status and position command alot
        //  so this is a "timer"
        //
        //  !!!do we need to do it this often?
        //
        if (npMCI->dwFlags & MCIAVI_WANTMOVE)
            CheckWindowMove(npMCI, FALSE);

        if (!fNested)
            npMCI->wMessageCurrent = 0;

    }

    return dwRet;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | ConvertToFrames | Convert from the current time format into
 *      frames.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm DWORD | dwTime | Input time.
 *
 ***************************************************************************/
LONG NEAR PASCAL ConvertToFrames(NPMCIGRAPHIC npMCI, DWORD dwTime)
{
    if (npMCI->dwTimeFormat == MCI_FORMAT_FRAMES) {
        return (LONG) dwTime;
    } else {
        if (npMCI->dwMicroSecPerFrame > 1000) {
        /* This needs to round down--muldiv32 likes to round off. */
        return (LONG) muldivrd32(dwTime, 1000L, npMCI->dwMicroSecPerFrame);
        } else {
            return (LONG) muldivru32(dwTime, 1000L, npMCI->dwMicroSecPerFrame);
        }
    }
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api DWORD | ConvertFromFrames | Convert from frames into the current
 *      time format.
 *
 * @parm NPMCIGRAPHIC | npMCI | Near pointer to instance data block
 *
 * @parm LONG | lFrame | Frame number to convert.
 *
 ***************************************************************************/
DWORD NEAR PASCAL ConvertFromFrames(NPMCIGRAPHIC npMCI, LONG lFrame)
{
    if (npMCI->dwTimeFormat == MCI_FORMAT_FRAMES) {
        return (DWORD)lFrame;
    } else {
        if (npMCI->dwMicroSecPerFrame > 1000)
        return muldivru32(lFrame, npMCI->dwMicroSecPerFrame, 1000L);
        else
            return muldivrd32(lFrame, npMCI->dwMicroSecPerFrame, 1000L);
    }
}

#ifdef HEARTBEAT
DWORD Interval = 60000; // 1 minute
DWORD HeartBeatBreak = FALSE;
DWORD HeartBeatDump = FALSE;

DWORD HeartBeat(LPVOID lpvThreadData)
{

    NPMCIGRAPHIC npMCI;
    int n;
    while (TRUE) {

        for (n=Interval/1000; n--; ) {
            Sleep(1000);
            if (fTerminate) {
                ExitThread(0);
            }
        }

        if (HeartBeatDump) {

            LPTSTR pszFilename;

            EnterList();
            npMCI = npMCIList;
            while (npMCI) {

                pszFilename = npMCI->szFilename;
                if (!pszFilename) {
                    pszFilename = L"<NULL>";
                }
                DPF0(("\nDevice dump : %8x : Name > %ls <\n"
                           "\t: CmdCritSec owner=%x, count=%x "
                           "\t: WinCritSec owner=%x, count=%x "
                             ": HDCCritSec owner=%x, count=%x\n"
                           "\t State=%x   hWave=%x",
                       npMCI,
                        pszFilename,
                        (npMCI->CmdCritSec).OwningThread, (npMCI->CmdCritSec).RecursionCount,
                        (npMCI->WinCritSec).OwningThread, (npMCI->WinCritSec).RecursionCount,
                        (npMCI->HDCCritSec).OwningThread, (npMCI->HDCCritSec).RecursionCount,
                        npMCI->wTaskState, npMCI->hWave));

                npMCI = npMCI->npMCINext;
            }
            LeaveList();
        }

        if (HeartBeatBreak) {
            DebugBreak();
        }
    }
    return (0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\graphic.h ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1995. All rights reserved.

   Title:   graphic.h - Multimedia Systems Media Control Interface
	    driver for AVI.

*****************************************************************************/

//  This stuff is not going to work 64-bit
#pragma warning(disable:4312)

#define NOSHELLDEBUG
#include <windows.h>
#ifndef RC_INVOKED
#include <windowsx.h>
#else
#define MMNODRV
#define MMNOSOUND
#define MMNOWAVE
#define MMNOMIDI
#define MMNOAUX
#define MMNOMIXER
#define MMNOTIMER
#define MMNOJOY
#define MMNOMMIO
#define MMNOMMSYSTEM
#define MMNOMIDIDEV
#define MMNOWAVEDEV
#define MMNOAUXDEV
#define MMNOMIXERDEV
#define MMNOTIMERDEV
#define MMNOJOYDEV
#define MMNOTASKDEV
#endif
#define MCI_USE_OFFEXT
#include <mmsystem.h>
#include <win32.h>      // This must be included, for both versions
#include <mmddk.h>
#include "ntaviprt.h"
#include "common.h"
#include <vfw.h>
#include "digitalv.h"

/*
** Here are some compression types.
*/
#define comptypeRLE0            mmioFOURCC('R','L','E','0')
#define comptypeRLE             mmioFOURCC('R','L','E',' ')

#ifndef RC_INVOKED      // Don't overload RC!
#include "avifilex.h"   // include AVIFile stuff.
#endif // !RC_INVOKED

#include "mciavi.h"

#include "profile.h"

extern const TCHAR szIni[];
extern const TCHAR szReject[];

#ifdef _WIN32
//#define STATEEVENT
/*
 * This define causes the code to be compiled with a event defined.  This
 * event is signalled every time (almost) the task thread changes state.
 * Hence the routine waiting for a particular state need not poll.
 */

/*
 * On NT keep track of whether this process is WOW or not.  Set during
 * DRV_LOAD processing.
 */
extern BOOL runningInWow;
#define IsNTWOW()  runningInWow

#else  // WIN 16

#define IsNTWOW() 0

#endif

#if !defined NUMELMS
 #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

// Define this to make the code expire on a given date....
// #define EXPIRE (1994 * 65536 + 1 * 256 + 1)        // expire 1/1/1994

#ifndef DRIVE_CDROM
    #define DRIVE_CDROM 5
#endif

#define DRIVE_INTERFACE     42

#ifdef EXPIRE
#define MCIERR_AVI_EXPIRED              9999
#endif

#define MCIAVI_PRODUCTNAME       2
#define MCIAVI_VERSION           3
#define MCIAVI_BADMSVIDEOVERSION 4

#define MCIAVI_MENU_CONFIG       5
#define MCIAVI_MENU_STRETCH      6
#define MCIAVI_MENU_MUTE         7

#define MCIAVI_CANT_DRAW_VIDEO   8
#define MCIAVI_CANT_DRAW_STREAM  9

#define INFO_VIDEOFORMAT         10
#define INFO_MONOFORMAT          11
#define INFO_STEREOFORMAT        12
#define INFO_LENGTH              13
#define INFO_FILE                14
#define INFO_KEYFRAMES           15
#define INFO_AUDIO               16
#define INFO_SKIP                17
#define INFO_ADPCM               18
#define INFO_DATARATE            19
#define INFO_SKIPAUDIO           20
#define INFO_FILETYPE            21
#define INFO_FILETYPE_AVI        22
#define INFO_FILETYPE_INT        23
#define INFO_FILETYPE_ALPHA      24
#define INFO_FRAMERATE           25
#define INFO_STREAM              26
#define INFO_DISABLED            27
#define INFO_ALLKEYFRAMES        28
#define INFO_NOKEYFRAMES         29
#define INFO_COMPRESSED          30
#define INFO_NOTREAD             31
#define IDS_IRTL                 32
#define IDS_VIDEO                33
#define IDS_VIDEOCAPTION         34


#ifndef RC_INVOKED
#define MCIAVI_MAXSIGNALS       1
#define MCIAVI_MAXWINDOWS       8

/* Flags for dwFlags in MCIGRAPHIC */
#define MCIAVI_STOP             0x00000001L     /* We need to stop      */
#define MCIAVI_PAUSE            0x00000002L     /* We need to be paused */
#define MCIAVI_CUEING           0x00000004L     /* We are in a cue command */
#define MCIAVI_WAITING          0x00000008L     /* We are waiting for a command to finish */
#define MCIAVI_PLAYAUDIO        0x00000010L     /* Audio enabled        */
#define MCIAVI_LOSTAUDIO        0x00000020L     /* cant get audio device*/
#define MCIAVI_SHOWVIDEO        0x00000040L     /* Video enabled        */
#define MCIAVI_USING_AVIFILE    0x00000080L     /* RTL to AVIFile */
#define MCIAVI_USINGDISPDIB     0x00000100L     /* Now in MCGA mode     */
#define MCIAVI_NEEDTOSHOW       0x00000200L     /* window needs to be shown */
#define MCIAVI_WANTMOVE         0x00000400L     /* call CheckWindowMove alot */
#define MCIAVI_ANIMATEPALETTE   0x00000800L     /* Palette animated */
#define MCIAVI_NEEDUPDATE       0x00001000L     /* Need to redraw full  */
#define MCIAVI_PALCHANGED       0x00002000L     /* Need to update palette */
#define MCIAVI_STUPIDMODE       0x00004000L     /* dont buffer mode  */
#define MCIAVI_CANDRAW          0x00008000L     /* display driver can draw format */
#define MCIAVI_FULLSCREEN       0x00010000L     /* draw fullscreen. */
#define MCIAVI_NEEDDRAWBEGIN    0x00020000L     /* compressor is drawing */
#define MCIAVI_UPDATETOMEMORY   0x00040000L     /* drawing to a bitmap */
#define MCIAVI_WAVEPAUSED       0x00080000L     /* waveOut is temporarily paused */
#define MCIAVI_NOTINTERLEAVED   0x00100000L     /* file is not interleaved. */
#define MCIAVI_USERDRAWPROC     0x00200000L     /* user has set draw proc*/
#define MCIAVI_LOSEAUDIO        0x00400000L     /* do not open wave device */
#define MCIAVI_VOLUMESET        0x00800000L     /* Volume has been changed. */
#define MCIAVI_HASINDEX         0x01000000L     /* File has index.      */
#define MCIAVI_RELEASEDC        0x02000000L     /* we got the DC via GetDC */
#define MCIAVI_SEEKING          0x04000000L     /* audio disabled for seek. */
#define MCIAVI_UPDATING         0x08000000L     /* handling WM_PAINT-don't yield. */
#define MCIAVI_REPEATING        0x10000000L     /* repeat when play finishes. */
#define MCIAVI_REVERSE          0x20000000L     /* playing backwards.... */
#define MCIAVI_NOBREAK          0x40000000L     /* don't allow break out of DISPDIB */
#define MCIAVI_ZOOMBY2          0x80000000L     /* fullscreen zoomed by 2 */

/* Flags for dwOptionFlags */
#define MCIAVIO_SEEKEXACT       0x00000001L     /* If off, seek goes to
						** previous key frame
						** instead of real
						** target frame.        */
#define MCIAVIO_SKIPFRAMES      0x00000002L     /* Skip frames to keep
						** synchronized.        */
#define MCIAVIO_STRETCHTOWINDOW 0x00000004L     /* Resize destination
						** rectangle if window
						** resized.             */

#define MCIAVIO_STUPIDMODE      0x00000020L     /* Don't do nice updating. */

#define MCIAVIO_ZOOMBY2         0x00000100L
#define MCIAVIO_USEVGABYDEFAULT 0x00000200L
#define MCIAVIO_USEAVIFILE      0x00000400L
#define MCIAVIO_NOSOUND         0x00000800L
#define MCIAVIO_USEDCI          0x00001000L

#define MCIAVIO_1QSCREENSIZE    0x00010000L
#define MCIAVIO_2QSCREENSIZE    0x00020000L
#define MCIAVIO_3QSCREENSIZE    0x00040000L
#define MCIAVIO_MAXWINDOWSIZE   0x00080000L
#define MCIAVIO_DEFWINDOWSIZE   0x00000000L
#define MCIAVIO_WINDOWSIZEMASK  0x000F0000L


#define MCIAVI_ALG_INTERLEAVED  0x0001
#define MCIAVI_ALG_CDROM        0x0002
#define MCIAVI_ALG_HARDDISK     0x0003
#define MCIAVI_ALG_AUDIOONLY    0x0004
#define MCIAVI_ALG_AVIFILE      0x0005

//
//  the frame index is indexed by frame number, it is used for
//  varible sizeed, fixed rate streams.
//
typedef struct
{
    WORD                iPrevKey;           // prev "key" frame
    WORD                iNextKey;           // next "key" frame
    WORD                iPalette;           // palette frame (this points into index!)
    UINT                wSmag;              //
    DWORD               dwOffset;           // Position of chunk (file offset)
    DWORD               dwLength;           // Length of chunk (in bytes)
} AVIFRAMEINDEX;

#define NOBASED32

#if defined(_WIN32) || defined(NOBASED32)
    #define BASED32(p)      _huge
    #define P32(t,p)        ((t _huge *)(p))
    #define B32(t,p)        ((t _huge *)(p))
#else
    #define BASED32(p)      _based32((_segment)SELECTOROF(p))
    #define P32(t,p)        ((t BASED32(p) *)OFFSETOF(p))
    #define B32(t,p)        ((t BASED32(p) *)0)
#endif

#define Frame(n)        (P32(AVIFRAMEINDEX,npMCI->hpFrameIndex) + (DWORD)(n))
#define FrameNextKey(n) (LONG)((n) + (DWORD)Frame(n)->iNextKey)
#define FramePrevKey(n) (LONG)((n) - (DWORD)Frame(n)->iPrevKey)
#define FramePalette(n) (LONG)(Frame(n)->iPalette)
#define FrameOffset(n)  (DWORD)(Frame(n)->dwOffset)
#define FrameLength(n)  (DWORD)(Frame(n)->dwLength)

#define UseIndex(p)     SillyGlobal = (p)
#define Index(n)        (B32(AVIINDEXENTRY,npMCI->hpIndex) + (long)(n))
#define IndexOffset(n)  Index(n)->dwChunkOffset
#define IndexLength(n)  Index(n)->dwChunkLength
#define IndexFlags(n)   Index(n)->dwFlags
#define IndexID(n)      Index(n)->ckid

typedef struct {
    DWORD               dwFlags;        /* flags, STREAM_ENABLED... */
    AVIStreamHeader     sh;             /* AVIStreamHeader...*/

    DWORD               cbFormat;       /* Stream format...*/
    LPVOID              lpFormat;

    DWORD               cbData;         /* Extra stream data...*/
    LPVOID              lpData;

    HIC                 hicDraw;        /* Draw codec...*/

    RECT                rcSource;       /* rectangles...*/
    RECT                rcDest;

    LONG                lStart;         /* start */
    LONG                lEnd;           /* end */

    LONG                lPlayStart;     /* play start */
    LONG                lPlayFrom;      /* play from */
    LONG                lPlayTo;        /* play to */

    LONG                lFrameDrawn;    /* we drew this */
    LONG                lPos;           /* current pos */
    LONG                lNext;          /* next pos */
    LONG                lLastKey;       /* key frame */
    LONG                lNextKey;       /* next key frame */

#ifdef USEAVIFILE
    PAVISTREAM          ps;
////IAVIStreamVtbl      vt;     // so we can call direct.
#endif
} STREAMINFO;

#define STREAM_ENABLED      0x0001  // stream is enabled for play
#define STREAM_ACTIVE       0x0002  // stream is active for *current* play
#define STREAM_NEEDUPDATE   0x0004  // stream needs update (paint)
#define STREAM_ERROR        0x0008  // stream did not load
#define STREAM_DIRTY        0x0010  // stream not showing current frame.

#define STREAM_SKIP         0x0100  // can skip data
#define STREAM_PALCHANGES   0x0200  // stream has palette changes
#define STREAM_VIDEO        0x0400  // is a video stream
#define STREAM_AUDIO        0x0800  // is a audio stream
#define STREAM_PALCHANGED   0x1000  // palette has changed
#define STREAM_WANTIDLE     0x2000  // should get idle time
#define STREAM_WANTMOVE     0x4000  // should get ICM_DRAW_WINDOW message

#define SI(stream)      (npMCI->paStreamInfo + stream)
#define SH(stream)      (SI(stream)->sh)

#define SOURCE(stream)  (SI(stream)->rcSource)
#define DEST(stream)    (SI(stream)->rcDest)
#define FRAME(stream)   (SH(stream).rcFrame)

#define FORMAT(stream) (SI(stream)->lpFormat)
#define VIDFMT(stream) ((LPBITMAPINFOHEADER) FORMAT(stream))
#define AUDFMT(stream) ((LPPCMWAVEFORMAT) FORMAT(stream))

//
// map from "movie" time into stream time.
//
#define TimeToMovie(t)         muldiv32(t, npMCI->dwRate, npMCI->dwScale*1000)
#define MovieToTime(l)         muldiv32(l, npMCI->dwScale*1000, npMCI->dwRate)
#define TimeToStream(psi, t)   muldiv32(t, psi->sh.dwRate,       psi->sh.dwScale*1000)
#define StreamToTime(psi, l)   muldiv32(l, psi->sh.dwScale*1000, psi->sh.dwRate)

//
//  NOTE all dwScale's are equal so we can do this without as many
//  multiplies
//
#if 0
#define MovieToStream(psi, l)  muldiv32(l, npMCI->dwScale * psi->sh.dwRate, npMCI->dwRate * psi->sh.dwScale)
#define StreamToMovie(psi, l)  muldiv32(l, npMCI->dwScale * psi->sh.dwRate, npMCI->dwRate * psi->sh.dwScale)
#else
#define MovieToStream(psi, l)  muldiv32(l, psi->sh.dwRate, npMCI->dwRate)
#define StreamToMovie(psi, l)  muldiv32(l, psi->sh.dwRate, npMCI->dwRate)
#endif

/*
 * dwNTFlags definitions
 */
//#define NTF_AUDIO_ON       0x00000001   Messages are not used to regain wave device
#define NTF_AUDIO_OFF        0x00000002
#define NTF_CLOSING          0x80000000
#define NTF_RETRYAUDIO       0x00000004
#define NTF_RESTARTFORAUDIO  0x00000008
#define NTF_DELETEWINCRITSEC 0x00000010
#define NTF_DELETECMDCRITSEC 0x00000020
#define NTF_DELETEHDCCRITSEC 0x00000040
#ifdef _WIN32
    #define ResetNTFlags(npMCI, bits) (npMCI)->dwNTFlags &= ~(bits)
    #define SetNTFlags(npMCI, bits) (npMCI)->dwNTFlags |= (bits)
    #define TestNTFlags(npMCI, bits) ((npMCI)->dwNTFlags & (bits))
#ifdef REMOTESTEAL
    extern HKEY hkey;
#endif
#else
    #define ResetNTFlags(npMCI, bits)
    #define SetNTFlags(npMCI, bits)
    #define TestNTFlags(npMCI, bits) 0
#endif

/*
 * RECT macros to get X,Y,Width,Height
 */
#define RCX(rc)     ((rc).left)
#define RCY(rc)     ((rc).top)
#define RCW(rc)     ((rc).right - (rc).left)
#define RCH(rc)     ((rc).bottom - (rc).top)


#ifdef _WIN32
// interaction between worker and winproc thread.
// winproc thread sets these bits in npMCI->winproc_request
#define WINPROC_STOP            0x0001  // stop play
#define WINPROC_RESETDEST       0x0002  // reset dest rect (window sized)
#define WINPROC_MUTE            0x0004  // mute flag changed
#define WINPROC_ACTIVE          0x0008  // got activation
#define WINPROC_INACTIVE        0x0010  // lost activation
#define WINPROC_UPDATE          0x0020  // window needs painting
#define WINPROC_REALIZE         0x0040  // palette needs realizing
#define WINPROC_SILENT          0x0100  // go silent (release wave device)
#define WINPROC_SOUND           0x0200  // restore sound (get wave device)
#endif


/*
 * The major control block for an AVI device
 * Define markers to more easily identify the control block when dumping
 */
#define MCIID      (DWORD)(((WORD)('V' | ('F'<<8))) | ((WORD)('W' | ('>'<<8))<<16))
#define MCIIDX     (DWORD)(((WORD)('v' | ('f'<<8))) | ((WORD)('w' | ('-'<<8))<<16))

typedef struct _MCIGRAPHIC {

// --- these fields accessed by user thread -------------------------
#ifdef DEBUG
    DWORD        mciid;         /* visible identifier */
#endif

    struct _MCIGRAPHIC *npMCINext;


/*
** Basic MCI information
*/
    HWND        hCallback;      /* callback window handle */
    UINT        wDevID;         /* device ID */


// -----new inter-task communication zone
    CRITICAL_SECTION    CmdCritSec;     // hold this to make request

    // next two events must be contiguous - WaitForMultipleObjects
    HANDLE      hEventSend;             // set to signal a request
    HANDLE      heWinProcRequest;       // set when something to process
#define IDLEWAITFOR 2

    // note - next two events are passed as an array to WaitForMultipleObjects
    HANDLE      hEventResponse;         // signalled by worker on req done.
    HANDLE      hThreadTermination; /* Handle to wait on for thread to
				       terminate so it's safe to unload DLL
				       Must be closed by us                */

    HANDLE      hEventAllDone;  // signalled on end of play

    int         EntryCount;     // used to prevent re-entry on current thread

    UINT        message;        // request message (from mciDriverEntry)
    DWORD       dwParamFlags;   // request param
    LPARAM      lParam;         // request param
    DWORD       dwReturn;       // return value
    DWORD_PTR   dwReqCallback;  // callback for this request
    BOOL        bDelayedComplete;       // is async request with wait?
    HTASK       hRequestor;     // task id of requesting task

    DWORD       dwTaskError;    /* error return from task */

// --- read by user thread to optimise status/position queries------

    UINT        wTaskState;     /* current task state */
    DWORD       dwFlags;        /* flags */

    LONG        lCurrentFrame;  /* current frame */
    DWORD       dwBufferedVideo;
    LONG        lRealStart;     /* frame playback starts */

    // user thread uses this for volume setting only
    HWAVEOUT    hWave;          /* wave device handle */
    DWORD       dwVolume;        /* Audio volume, 1000 is full on */

    LONG        lFrames;        /* number of frames in movie */

// --- nothing below here touched by user thread (after init)--------------

#if 0 /////UNUSED
    // the original interface before we marshalled it
    PAVIFILE    pf_AppThread;

    // marshalled into this block for passing to worker thread
    HANDLE      hMarshalling;

#endif/////UNUSED

    // set to TRUE during processing of an Update requested by the winproc
    // thread - don't do ShowStage during this as could cause deadlock
    BOOL        bDoingWinUpdate;



/*
** Internal task operation status and flags
*/
#ifndef _WIN32
    UINT        pspTask;        /* background task's PSP */
    UINT        pspParent;      /* PSP of the calling app */
#else
    DWORD       dwNTFlags;      /* NT specific flags */

    HTASK       hWaiter;                // task waiting on hEventAllDone

    // communication between worker and winproc threads

    // note: next two events must be contiguous - passed to WaitForMultiple..
    HANDLE      hThreadWinproc;         // signalled on thread exit
    HANDLE      hEventWinProcOK;        // signalled on init ok

    HANDLE      hEventWinProcDie;       // tell winproc thread to die

    CRITICAL_SECTION WinCritSec;        // protect worker - winproc interaction
    CRITICAL_SECTION HDCCritSec;        // protect worker - winproc drawing
    // ** VERY IMPORTANT ** IF both critical sections are needed then they
    // MUST be obtained in this order: WinCrit, then HDCCrit

#ifdef DEBUG
    DWORD       WinCritSecOwner;
    LONG        WinCritSecDepth;
    DWORD       HDCCritSecOwner;
    LONG        HDCCritSecDepth;
#endif

    // winproc sets bits in this (protected by WinCritSec) to
    // request stop/mute actions asynchronously
    DWORD       dwWinProcRequests;

    // saved state over temporary stop
    UINT        oldState;
    long        oldTo;
    long        oldFrom;
    DWORD       oldFlags;
    DWORD_PTR   oldCallback;
#endif

    HTASK       hTask;          /* task id */
    HTASK       hCallingTask;   /* task who opened us */
    UINT        uErrorMode;     /* SetErrorMode value for calling task */
    UINT        wMessageCurrent;/* Command in progress, or zero */
    DWORD       dwOptionFlags;  /* more flags */

/*
** Additional information controlled by MCI commands
*/
    HPALETTE    hpal;           /* Palette forced with MCI commands */
    HWND        hwndPlayback;   /* window handle for playback */
    HWND        hwndDefault;    /* default window handle */
    HWND        hwndOldFocus;   /* window which had keyboard focus */
    BOOL        fForceBackground;/* Select palette in foreground or back? */
    DWORD       dwTimeFormat;   /* current time format */
    RECT        rcMovie;        /* main movie rect */
    RECT        rcSource;       /* drawing source rect */
    RECT        rcDest;         /* drawing destination rect */
#ifdef DEBUG
    LONG        PlaybackRate;   /* 1000 is normal, more is fast.... */
#endif
    DWORD       dwSpeedFactor;  /* 1000 is normal, more is fast.... */

    // What is this flag?  We only listen to the zoom by 2 or fixed % window
    // size registry defaults if we're using the default window, not if
    // somebody is playing in their own window.  But when we open an AVI,
    // (like we're doing now) we don't know yet what window they'll pick!
    // So let's make a note that so far there's no reason not to listen to
    // the defaults, and if anybody resizes, or changes the window handle,
    // or makes the default window not resizable, then we won't.
    BOOL                fOKToUseDefaultSizing;

/*
 * window creation parameters to open
 */
    DWORD       dwStyle;
    HWND        hwndParent;


/*
** Information about currently open file
*/
    UINT        uDriveType;     /* drive type */
    NPTSTR      szFilename;     /* AVI filename */
    DWORD       dwBytesPerSec;  /* file attributes */
    DWORD       dwRate;         /* master time base */
    DWORD       dwScale;
    DWORD       dwMicroSecPerFrame;
    DWORD       dwSuggestedBufferSize;
    DWORD       dwKeyFrameInfo; /* how often key frames occur */
    UINT        wEarlyAudio;    /* more file information */
    UINT        wEarlyVideo;
    UINT        wEarlyRecords;

    STREAMINFO NEAR *paStreamInfo;
    int         streams;        // total streams
    int         nAudioStreams;  // total audio streams
    int         nVideoStreams;  // total video streams
    int         nOtherStreams;  // total other streams
    int         nErrorStreams;  // total error streams

    int         nAudioStream;   // current audio stream.
    int         nVideoStream;   // "master" video stream

    STREAMINFO *psiAudio;       // points to video stream
    STREAMINFO *psiVideo;       // points to audio stream

#ifdef USEAVIFILE
    PAVIFILE        pf;
////IAVIFileVtbl    vt;    // so we can call direct.
#else
    LPVOID          pf;     // variable to be zero.
#endif

/*
** video stream junk
*/
    BOOL        fNoDrawing;
    LONG        lFrameDrawn;    /* number of last frame drawn */

    /* Drawing information */
    HDC         hdc;            /* DC we're playing into */

    /* Video format */
    BITMAPINFOHEADER    FAR *pbiFormat;       /* video format information */

    /* BitmapInfo used for drawing */
    BITMAPINFOHEADER    bih;         /* video format information */
    RGBQUAD             argb[256];   /* current drawing colors */
    RGBQUAD             argbOriginal[256]; /* original colors */

/*
** Installable compressor information
*/
    //!!! move all this into the screen draw function!!!
    //!!! all this should be in DrawDIB !!!
    HIC         hic;
    HIC         hicDraw;

    LONG        cbDecompress;
    HPSTR       hpDecompress;   /* pointer to full frame buffer */

/*
** Holding area for compressors we might use....
*/
    HIC         hicDecompress;
    HIC         hicDrawDefault;
    HIC         hicDrawFull;
    HIC         hicInternal;
    HIC         hicInternalFull;

    LONG        lLastPaletteChange;
    LONG        lNextPaletteChange;

/*
** wave stream junk
*/
    /* Wave format stuff */
    NPWAVEFORMAT pWF;           /* current wave format */
    UINT        wABs;           /* number of audio buffers */
    UINT        wABOptimal;     /* number full if synchronized */
    DWORD       dwABSize;       /* size of one audio buffer */

    HMMIO       hmmioAudio;

    BOOL        fEmulatingVolume;/* Are we doing volume by table lookup? */
    BYTE *      pVolumeTable;

    DWORD       dwAudioLength;
    DWORD       dwAudioPos;

    /* Wave Output Device */
    UINT        wABFull;        /* number now full */
    UINT        wNextAB;        /* next buffer in line */
    UINT        nAudioBehind;   /* how many audio below full */
    HPSTR       lpAudio;        /* pointer to audio buffers */
    DWORD       dwUsedThisAB;

/*
** File index information
*/
    AVIINDEXENTRY _huge *  hpIndex;        /* pointer to index */
    DWORD                   macIndex;       /* # records in index */

    AVIFRAMEINDEX _huge *  hpFrameIndex;   /* pointer to frame index */
    HANDLE      hgFrameIndex;           // handle to non-offset memory

/*
** play/seek params
*/
    LONG        lTo;            /* frame we're playing to */
    LONG        lFrom;          /* frame we're playing from */
    LONG        lRepeatFrom;    /* Frame to repeat from */

/*
** Information regarding current play
*/
    UINT        wPlaybackAlg;   /* playback algorithm in use */

    LONG        lAudioStart;    /* first audio frame to play */
    LONG        lVideoStart;    /* first video frame to play */

    LONG        lLastRead;

    /* Timing */
    LONG        lFramePlayStart;/* Frame playing started at */

    DWORD       dwTotalMSec;    /* Total time spent playing */

    DWORD       dwMSecPlayStart;/* Start time */
    DWORD       dwTimingStart;
    DWORD       dwPauseTime;
    DWORD       dwPlayMicroSecPerFrame;
    DWORD       dwAudioPlayed;

/*
** Timing information
*/
#ifdef DEBUG
#define INTERVAL_TIMES
#endif
#ifdef INTERVAL_TIMES
#define NBUCKETS    25
#define BUCKETSIZE  10
//#define NTIMES            200
// frame interval timing
    DWORD       dwStartTime;
    long        msFrameMax;
    long        msFrameMin;
    long        msFrameTotal;
    long        msSquares;
    long        nFrames;
    int         buckets[NBUCKETS+1];
    long *      paIntervals;
    long        cIntervals;
    //long      intervals[NTIMES];
    long        msReadTimeuS;
    long        msReadMaxBytesPer;
    long        msReadMax;
    long        msReadTotal;
    long        nReads;
#endif

    DWORD       dwLastDrawTime; /* How long did the last draw take? */
    DWORD       dwLastReadTime;
    DWORD       msPeriodResolution;   /* Clock resolution for this video */

    /* Timing information kept after play completes */
    DWORD       dwSkippedFrames;    /* Frames skipped during current play */
    DWORD       dwFramesSeekedPast; /* Frames not even read */
    DWORD       dwAudioBreaks;  /* # times audio broke up, approx. */
    DWORD       dwSpeedPercentage;  /* Ratio of ideal time to time taken */

    /* Timing information for last play */
    LONG        lFramesPlayed;
    LONG        lSkippedFrames;     /* Frames skipped during last play */
    LONG        lFramesSeekedPast;  /* Frames not even read */
    LONG        lAudioBreaks;       /* # times audio broke up, approx. */

/*
** Information for pending 'signal' command
*/
    DWORD       dwSignals;
    DWORD       dwSignalFlags;
    MCI_DGV_SIGNAL_PARMS signal;

/*
** Information for watching to see if window has moved.
*/
    UINT        wRgnType;       /* Region type, empty, simple, complex.... */
#ifdef _WIN32
    POINT       dwOrg;          /* Physical DC origin */
#else
    DWORD       dwOrg;          /* Physical DC origin */
#endif
    RECT        rcClip;         /* clip box */

/*
** specific to RIFF files
*/
    HMMIO       hmmio;          /* animation file handle */

    BOOL        fReadMany;      /* read more than one record */

    DWORD       dwFirstRecordPosition;
    DWORD       dwFirstRecordSize;
    DWORD       dwFirstRecordType;

    DWORD       dwNextRecordSize;       // used for ReadNextChunk
    DWORD       dwNextRecordType;

    DWORD       dwMovieListOffset;
    DWORD       dwBigListEnd;

    /* Read Buffer */
    HPSTR       lp;             /* work pointer */
    LPVOID      lpMMIOBuffer;   /* pointer to MMIO read buffer */
    HPSTR       lpBuffer;       /* pointer to read buffer */
    DWORD       dwBufferSize;   /* Read buffer size */
    DWORD       dwThisRecordSize; /* size of current record */

/*
** DEBUG stuff and more timing info.
*/

#ifdef DEBUG
    HANDLE      hdd;    //!!!

    LONG        timePlay;       /* total play time */
    LONG        timePrepare;    /* time to prepare for play */
    LONG        timeCleanup;    /* time to clean up play */
    LONG        timePaused;     /* paused time */
    LONG        timeRead;       /* time reading from disk */
    LONG        timeWait;       /* time waiting */
    LONG        timeYield;      /* time yielding to other apps */
    LONG        timeVideo;      /* time "drawing" video stream */
    LONG        timeAudio;      /* time "drawing" audio stream */
    LONG        timeOther;      /* time "drawing" other streams */
    LONG        timeDraw;       /* time drawing frame via DrawDib/DispDib/ICDraw */
    LONG        timeDecompress; /* time decompressing frame via ICDecompress */
#endif

#ifdef AVIREAD
    /*
     * handle to current async read object
     */
    HAVIRD      hAviRd;
    HPSTR       lpOldBuffer;
#endif

} MCIGRAPHIC, *NPMCIGRAPHIC, FAR *LPMCIGRAPHIC;

extern HANDLE ghModule;             // in DRVPROC.C
extern TCHAR  szClassName[];        // in WINDOW.C

/*
** Flags to protect ourselves in case we're closed with a dialog up...
*/
extern BOOL   gfEvil;               // in GRAPHIC.C
extern BOOL   gfEvilSysMenu;        // in GRAPHIC.C
extern HDRVR  ghdrvEvil;            // in GRAPHIC.C

/*
** Functions in GRAPHIC.C
*/
LPCTSTR FAR FileName(LPCTSTR szPath);

BOOL FAR PASCAL  GraphicInit (void);
BOOL NEAR PASCAL  GraphicWindowInit (void);

#ifdef _WIN32
BOOL NEAR PASCAL GraphicWindowFree(void);
void aviWinProcTask(DWORD_PTR dwInst);
#endif

void  PASCAL  GraphicFree (void);
DWORD PASCAL  GraphicDrvOpen (LPMCI_OPEN_DRIVER_PARMS lpParms);
void  FAR PASCAL  GraphicDelayedNotify (NPMCIGRAPHIC npMCI, UINT wStatus);
void FAR PASCAL GraphicImmediateNotify (UINT wDevID,
    LPMCI_GENERIC_PARMS lpParms,
    DWORD dwFlags, DWORD dwErr);
DWORD PASCAL  GraphicClose(NPMCIGRAPHIC npMCI);
DWORD NEAR PASCAL ConvertFromFrames(NPMCIGRAPHIC npMCI, LONG lFrame);
LONG NEAR PASCAL ConvertToFrames(NPMCIGRAPHIC npMCI, DWORD dwTime);

DWORD PASCAL mciDriverEntry(UINT wDeviceID, UINT wMessage, DWORD dwFlags, LPMCI_GENERIC_PARMS lpParms);

LRESULT FAR PASCAL _loadds GraphicWndProc(HWND, UINT, WPARAM, LPARAM);

void  CheckWindowMove(NPMCIGRAPHIC npMCI, BOOL fForce);
DWORD InternalGetPosition(NPMCIGRAPHIC npMCI, LPLONG lpl);

// now called only on worker thread
void NEAR PASCAL GraphicSaveCallback (NPMCIGRAPHIC npMCI, HANDLE hCallback);


/*
 * Functions in DEVICE.C
 *
 *  All these DeviceXXX functions are called on USER THREAD ONLY (ok?)
 *  EXCEPT for DeviceSetActive which is called on the winproc thread.
 *  (From InternalRealize...CheckIfActive...DeviceSetActive)
 */
DWORD PASCAL DeviceOpen(NPMCIGRAPHIC npMCI, DWORD dwFlags);
DWORD PASCAL DeviceClose(NPMCIGRAPHIC npMCI);
DWORD PASCAL DevicePlay(
    NPMCIGRAPHIC npMCI,
    DWORD dwFlags,
    LPMCI_DGV_PLAY_PARMS lpPlay,
    LPARAM dwCallback
);
DWORD PASCAL DeviceResume(NPMCIGRAPHIC npMCI, DWORD dwFlags, LPARAM dwCallback);
DWORD PASCAL DeviceCue(NPMCIGRAPHIC npMCI, LONG lTo, DWORD dwFlags, LPARAM dwCallback);
DWORD PASCAL DeviceStop(NPMCIGRAPHIC npMCI, DWORD dwFlags);
DWORD PASCAL DevicePause(NPMCIGRAPHIC npMCI, DWORD dwFlags, LPARAM dwCallback);
DWORD PASCAL DeviceSeek(NPMCIGRAPHIC npMCI, LONG lTo, DWORD dwFlags, LPARAM dwCallback);
DWORD PASCAL DeviceRealize(NPMCIGRAPHIC npMCI);
DWORD PASCAL DeviceUpdate(NPMCIGRAPHIC npMCI, DWORD dwFlags, LPMCI_DGV_UPDATE_PARMS lpParms);
UINT  PASCAL DeviceMode(NPMCIGRAPHIC npMCI);
DWORD PASCAL DevicePosition(NPMCIGRAPHIC npMCI, LPLONG lpl);
DWORD PASCAL DeviceSetWindow(NPMCIGRAPHIC npMCI, HWND hwnd);
DWORD PASCAL DeviceSetSpeed(NPMCIGRAPHIC npMCI, DWORD dwNewSpeed);
DWORD PASCAL DeviceMute(NPMCIGRAPHIC npMCI, BOOL fMute);
DWORD PASCAL DeviceSetVolume(NPMCIGRAPHIC npMCI, DWORD dwVolume);
DWORD PASCAL DeviceGetVolume(NPMCIGRAPHIC npMCI);
DWORD PASCAL DeviceSetAudioStream(NPMCIGRAPHIC npMCI, UINT uStream);
DWORD PASCAL DeviceSetVideoStream(NPMCIGRAPHIC npMCI, UINT uStream, BOOL fOn);
DWORD PASCAL DeviceSetActive(NPMCIGRAPHIC npMCI, BOOL fActive);

DWORD FAR PASCAL DevicePut(NPMCIGRAPHIC npMCI, LPRECT lprc, DWORD dwFlags);
DWORD FAR PASCAL DeviceSetPalette(NPMCIGRAPHIC npMCI, HPALETTE hpal);
DWORD FAR PASCAL DeviceSetPaletteColor(NPMCIGRAPHIC npMCI, DWORD index, DWORD color);


void CheckIfActive(NPMCIGRAPHIC npMCI);


// in window.c
void FAR PASCAL AlterRectUsingDefaults(NPMCIGRAPHIC npMCI, LPRECT lprc);
void FAR PASCAL SetWindowToDefaultSize(NPMCIGRAPHIC npMCI, BOOL fUseDefaultSizing);

// user thread version
void FAR PASCAL ResetDestRect(NPMCIGRAPHIC npMCI, BOOL fUseDefaultSizing);

// same as ResetDestRect, but called on winproc thread
void FAR PASCAL Winproc_DestRect(NPMCIGRAPHIC npMCI, BOOL fUseDefaultSizing);

DWORD FAR PASCAL ReadConfigInfo(void);
void  FAR PASCAL WriteConfigInfo(DWORD dwOptions);
BOOL  FAR PASCAL ConfigDialog(HWND, NPMCIGRAPHIC);

/*
** The Enumerate command isn't real: I'm just thinking about it.
*/
#define MCI_ENUMERATE                   0x0901
#define MCI_ENUMERATE_STREAM            0x00000001L

// constants for dwItem field of MCI_STATUS_PARMS parameter block
#define MCI_AVI_STATUS_STREAMCOUNT      0x10000001L
#define MCI_AVI_STATUS_STREAMTYPE       0x10000002L
#define MCI_AVI_STATUS_STREAMENABLED    0x10000003L

// flags for dwFlags field of MCI_STATUS_PARMS parameter block
#define MCI_AVI_STATUS_STREAM           0x10000000L

// flags for dwFlags field of MCI_SET_PARMS parameter block
#define MCI_AVI_SET_STREAM              0x10000000L
#define MCI_AVI_SET_USERPROC            0x20000000L

/*
** Internal flag that can be used with SEEK
*/
#define MCI_AVI_SEEK_SHOWWINDOW         0x10000000L

/*
** in AVIPLAY.C (and GRAPHIC.C)
*/
extern INT      gwSkipTolerance;
extern INT      gwHurryTolerance;
extern INT      gwMaxSkipEver;

extern BOOL     gfUseGetPosition;
extern LONG     giGetPositionAdjust;
#ifdef _WIN32
    #define DEFAULTUSEGETPOSITION TRUE
#else
    #define DEFAULTUSEGETPOSITION FALSE
#endif

/**************************************************************************
**************************************************************************/

#ifdef DEBUG
    #define TIMEZERO(time)   npMCI->time  = 0;
    #define TIMESTART(time)  npMCI->time -= (LONG)timeGetTime()
    #define TIMEEND(time)    npMCI->time += (LONG)timeGetTime()
#else
    #define TIMEZERO(time)
    #define TIMESTART(time)
    #define TIMEEND(time)
#endif

/**************************************************************************
**************************************************************************/

#define FOURCC_AVIDraw      mmioFOURCC('D','R','A','W')
#define FOURCC_AVIFull      mmioFOURCC('F','U','L','L')
LRESULT FAR PASCAL _loadds ICAVIDrawProc(DWORD_PTR id, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2);
LRESULT FAR PASCAL _loadds ICAVIFullProc(DWORD_PTR id, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2);

/**************************************************************************
**************************************************************************/

#include "avitask.h"

/**************************************************************************
 Macros and constants for accessing the list of open MCI devices.
 In the debug build we track who has access to the list.
**************************************************************************/

extern NPMCIGRAPHIC npMCIList; // in graphic.c

#ifdef _WIN32
extern CRITICAL_SECTION MCIListCritSec;  // in graphic.c

#ifdef DEBUG

// The debug versions of the macros track who owns the critical section
extern DWORD ListOwner;
#define EnterList()   { EnterCriticalSection(&MCIListCritSec);  \
			ListOwner=GetCurrentThreadId();\
		      }

#define LeaveList()   { ListOwner=0;\
			LeaveCriticalSection(&MCIListCritSec);\
		      }
#else  // !debug
#define EnterList()   EnterCriticalSection(&MCIListCritSec);
#define LeaveList()   LeaveCriticalSection(&MCIListCritSec);
#endif //DEBUG



// this critical section is used to protect drawing code from
// interaction between the winproc and the worker thread. the user
// thread should not need to hold this ever.

#ifdef DEBUG
// The debug versions of the EnterWinCrit/LeaveWinCrit macros track who
// owns the window critical section.  This makes it possible to Assert
// in the code that we are validly in (or out) of the critical section.
#define EnterWinCrit(p) {   EnterCriticalSection(&(p)->WinCritSec);     \
			    (p)->WinCritSecOwner=GetCurrentThreadId();  \
			    /* The first enter should mean that we do */\
			    /* NOT own the HDC critical section       */\
			    if (!((p)->WinCritSecDepth++))              \
				{ HDCCritCheckOut(p) };                 \
			}

#define LeaveWinCrit(p) {   if(0 == (--(p)->WinCritSecDepth))           \
				(p)->WinCritSecOwner=0;                 \
			    if ((p)->WinCritSecDepth<0) {               \
				DebugBreak();                           \
			    }                                           \
			    LeaveCriticalSection(&(p)->WinCritSec);     \
			}

#define WinCritCheckIn(p) if ((p)->WinCritSecOwner != GetCurrentThreadId())\
			   Assert(!"Should own the window critical section");
#define WinCritCheckOut(p) if ((p)->WinCritSecOwner == GetCurrentThreadId()) \
			   Assert(!"Should not own the window critical section");


#define EnterHDCCrit(p) {   EnterCriticalSection(&(p)->HDCCritSec);     \
			    (p)->HDCCritSecOwner=GetCurrentThreadId();  \
			    (p)->HDCCritSecDepth++;                     \
			}

#define LeaveHDCCrit(p) {   if(0 == (--(p)->HDCCritSecDepth))           \
				(p)->HDCCritSecOwner=0;                 \
			    if ((p)->HDCCritSecDepth<0) {               \
				DebugBreak();                           \
			    }                                           \
			    LeaveCriticalSection(&(p)->HDCCritSec);     \
			}

#define HDCCritCheckIn(p) if ((p)->HDCCritSecOwner != GetCurrentThreadId())\
			   Assert(!"Should own the hdc critical section");
#define HDCCritCheckOut(p) if ((p)->HDCCritSecOwner == GetCurrentThreadId()) \
			   Assert(!"Should not own the hdc critical section");


#else  // Non debug versions

#define EnterWinCrit(npMCI)     EnterCriticalSection(&npMCI->WinCritSec)
#define LeaveWinCrit(npMCI)     LeaveCriticalSection(&npMCI->WinCritSec)
#define WinCritCheckIn(p)
#define WinCritCheckOut(p)
#define EnterHDCCrit(npMCI)     EnterCriticalSection(&npMCI->HDCCritSec)
#define LeaveHDCCrit(npMCI)     LeaveCriticalSection(&npMCI->HDCCritSec)
#define HDCCritCheckIn(p)
#define HDCCritCheckOut(p)

#endif


#else   // !_WIN32
#define EnterList()
#define LeaveList()

#define EnterWinCrit(n)
#define LeaveWinCrit(n)
#endif
#endif           // RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\init.c ===
//==========================================================================;
//
//  init.c
//
//  Copyright (c) 1991-1993 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include <process.h>

#ifdef WIN4
//
//  WIN4 thunk connect function protos
//
#ifdef _WIN32
BOOL PASCAL mciup_ThunkConnect32(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);
#else
BOOL FAR PASCAL mciup_ThunkConnect16(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);
#endif
#endif

//
//
//
//
#ifdef WIN4
char    gmbszMCIAVI[]	      = "mciavi.drv";
char    gmbszMCIAVI32[]	      = "mciavi32.dll";
#endif


//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

#ifndef _WIN32

#ifdef WIN4
//--------------------------------------------------------------------------;
//
//
//
//
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
//  BOOL DllEntryPoint
//
//  Description:
//	This is a special 16-bit entry point called by the WIN4 kernel
//	for thunk initialization and cleanup.  It is called on each usage
//	increment or decrement.  Do not call GetModuleUsage within this
//	function as it is undefined whether the usage is updated before
//	or after this DllEntryPoint is called.
//
//  Arguments:
//	DWORD dwReason:
//		1 - attach (usage increment)
//		0 - detach (usage decrement)
//
//	HINSTANCE hinst:
//
//	WORD wDS:
//
//	WORD wHeapSize:
//
//	DWORD dwReserved1:
//
//	WORD wReserved2:
//
//  Return (BOOL):
//
//  Notes:
//	cEntered tracks reentry into DllEntryPoint.  This may happen due to
//	the thunk connections
//
//  History:
//      02/02/94    [frankye]
//
//--------------------------------------------------------------------------;
#pragma message ("--- Remove secret MSACM.INI AllowThunks ini switch")

BOOL FAR PASCAL _export DllEntryPoint
(
 DWORD	    dwReason,
 HINSTANCE  hinst,
 WORD	    wDS,
 WORD	    wHeapSize,
 DWORD	    dwReserved1,
 WORD	    wReserved2
)
{
    static UINT cEntered    = 0;
    BOOL f	    = TRUE;


    //
    //	Track reentry
    //
    //
    cEntered++;


    switch (dwReason)
    {
	case 0:
	case 1:
	    f = (0 != mciup_ThunkConnect16(gmbszMCIAVI, gmbszMCIAVI32,
					   hinst, dwReason));
	    break;

	default:
	    f = TRUE;
	    break;
    }

    //
    //	Track reentry
    //
    //
    cEntered--;

    return (f);
}
#endif

#else // _WIN32

//==========================================================================;
//
//  WIN 32 SPECIFIC SUPPORT
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL DllEntryPoint
//
//  Description:
//      This is the standard DLL entry point for Win 32.
//
//  Arguments:
//      HINSTANCE hinst: Our instance handle.
//
//      DWORD dwReason: The reason we've been called--process/thread attach
//      and detach.
//
//      LPVOID lpReserved: Reserved. Should be NULL--so ignore it.
//
//  Return (BOOL):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    cjp     [curtisp]
//	    initial
//	04/18/94    fdy	    [frankye]
//	    major mods for WIN4.  Yes, it looks real ugly now cuz of all
//	    the conditional compilation for WIN4, daytona, etc.  Don't
//	    have time to think of good way to structure all this right now.
//
//--------------------------------------------------------------------------;

BOOL CALLBACK DllEntryPoint
(
    HINSTANCE               hinst,
    DWORD                   dwReason,
    LPVOID                  lpReserved
)
{
    BOOL		f = TRUE;

    //
    //
    //
    if (DLL_PROCESS_ATTACH == dwReason)
    {
	DisableThreadLibraryCalls(hinst);

	//
	//  thunk connect
	//
	mciup_ThunkConnect32(gmbszMCIAVI, gmbszMCIAVI32, hinst, dwReason);
    }


    //
    //
    //
    if (DLL_PROCESS_DETACH == dwReason)
    {
	//
	//  thunk disconnect
	//
	mciup_ThunkConnect32(gmbszMCIAVI, gmbszMCIAVI32, hinst, dwReason);

    }
	

    return (f);
} // DllEntryPoint()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\makefile.inc ===
#
# Build the combined VFW library from the component libraries
#
#

OUTPUT = $(O)
VFW32_LIBS = ..\video\$(O)\msvfw32.lib \
             ..\avifile\$(O)\avifil32.lib \
             ..\avicap.io\$(O)\avicap32.lib

all: $(OUTPUT)\vfw32.lib

$(OUTPUT)\vfw32.lib: $(VFW32_LIBS)
   lib $(VFW32_LIBS) \
       /OUT:$(OUTPUT)\vfw32.lib -ignore:4006
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\libinit.asm ===
page	,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  LIBINIT.ASM
;
; library stub to do local init for a Dynamic linked library
;
; Created: 06-27-89
; Author:  Todd Laney [ToddLa]
;
; Exported Functions:   none
;
; Public Functions:     none
;
; Public Data:		none
;
; General Description:
;
; Restrictions:
;
;   This must be the first object file in the LINK line, this assures
;   that the reserved parameter block is at the *base* of DGROUP
;
;-----------------------------------------------------------------------;

?PLM=1      ; PASCAL Calling convention is DEFAULT
?WIN=1	    ; Windows calling convention

        .286
	.xlist
	include cmacros.inc
;       include windows.inc
        .list

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
;   externs from KERNEL
;
        externFP    <LocalInit>
        externFP    <FatalAppExit>

;-----------------------------------------------------------------------;
;
;   LibMain is the function in C code we will call on a DLL load.
;   it is assumed in the same segment as we are.
;
;;;;;;;;externNP    <LibMain>
        externFP    <LibMain>  ;; Use this line if LibMain is far call

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
sBegin  Data
assumes DS,Data
            org 0               ; base of DATA segment!

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd        Data

;-----------------------------------------------------------------------;

sBegin  CodeSeg
        assumes cs,CodeSeg

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used by a DLL)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
ifdef DEBUG
        ;
        ; if this module is not linked first the reserved parameter block
        ; will not be initialized correctly, check for this and
        ;
        lea     ax,pLocalHeap
        cmp     ax,6
        je      RsrvPtrsOk

RsrvPtrsHosed:
        int     3

        lea     ax,RsrvPtrsMsg
        cCall   FatalAppExit,<0,cs,ax>
        jmp     short RsrvPtrsOk

RsrvPtrsMsg:
        db      'RsrvPtrs hosed!',0

RsrvPtrsOk:
endif
	;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
	;
	push	di
	push	cx
	push	es
	push	si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        cCall   LocalInit,<0,0,cx>

no_heap:
        cCall   LibMain
cEnd

;--------------------------Exported-Routine-----------------------------;
;
;   WEP()
;
;   called when the DLL is unloaded, it is passed 1 WORD parameter that
;   is TRUE if the system is going down, or zero if the app is
;
;   WARNING:
;
;       This function is basicly useless, you cant can any kernel function
;       that may cause the LoadModule() code to be reentered..
;
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   WEP,<FAR,PUBLIC,NODATA>,<>
        ParmW  WhyIsThisParamBogusDave?
cBegin
cEnd

sEnd    CodeSeg

        end     LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\mciavi.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *
**	Copyright (C) Microsoft Corporation 1991-1996. All rights reserved.
**
**	Title: mciavi.h - Multimedia Systems Media Control Interface
**	AVI driver external header file
**
**	Version:	1.00	
**
**	Date:		16-JUL-1992
**
**	Depends on MMSYSTEM.H and WINDOWS.h
*/

/************************************************************************/


/*
** These three flags apply to the 'play' command:
**	play <alias> window		Play in normal window
**	play <alias> fullscreen		Play in 320x240 full-screen mode
**	play <alias> fullscreen by 2	Play fullscreen, zoomed by 2
*/
#define MCI_MCIAVI_PLAY_WINDOW		0x01000000L
#define	MCI_MCIAVI_PLAY_FULLSCREEN	0x02000000L
#define MCI_MCIAVI_PLAY_FULLBY2		0x04000000L
/*
** Debugging constants for AVI diagnostics
*/
/*
** Returns number of frames not drawn during last play.  If this number
** is more than a small fraction of the number of frames that should have
** been displayed, things aren't looking good.
*/
#define MCI_AVI_STATUS_FRAMES_SKIPPED		0x8001L
/*
** Returns a number representing how well the last AVI play worked.
** A result of 1000 indicates that the AVI sequence took the amount
** of time to play that it should have; a result of 2000, for instance,
** would indicate that a 5-second AVI sequence took 10 seconds to play,
** implying that the audio and video were badly broken up.
*/
#define MCI_AVI_STATUS_LAST_PLAY_SPEED		0x8002L
/*
** Returns the number of times that the audio definitely broke up.
** (We count one for every time we're about to write some audio data
** to the driver, and we notice that it's already played all of the
** data we have.
*/
#define MCI_AVI_STATUS_AUDIO_BREAKS		0x8003L


#define MCI_AVI_SETVIDEO_DRAW_PROCEDURE		0x8000L

#define MCI_AVI_SETVIDEO_PALETTE_COLOR		0x8100L


/*
** This constant specifies that the "halftone" palette should be
** used, rather than the default palette.
*/
#define MCI_AVI_SETVIDEO_PALETTE_HALFTONE       0x0000FFFFL

/*
**	Custom error return values
*/
#define MCIERR_AVI_OLDAVIFORMAT		(MCIERR_CUSTOM_DRIVER_BASE + 100)
#define MCIERR_AVI_NOTINTERLEAVED	(MCIERR_CUSTOM_DRIVER_BASE + 101)
#define MCIERR_AVI_NODISPDIB		(MCIERR_CUSTOM_DRIVER_BASE + 102)
#define MCIERR_AVI_CANTPLAYFULLSCREEN	(MCIERR_CUSTOM_DRIVER_BASE + 103)
#define MCIERR_AVI_TOOBIGFORVGA		(MCIERR_CUSTOM_DRIVER_BASE + 104)
#define MCIERR_AVI_NOCOMPRESSOR         (MCIERR_CUSTOM_DRIVER_BASE + 105)
#define MCIERR_AVI_DISPLAYERROR         (MCIERR_CUSTOM_DRIVER_BASE + 106)
#define MCIERR_AVI_AUDIOERROR		(MCIERR_CUSTOM_DRIVER_BASE + 107)
#define MCIERR_AVI_BADPALETTE		(MCIERR_CUSTOM_DRIVER_BASE + 108)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\ntaviprt.h ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1991-1992. All rights reserved.

   Title:   ntaviprt.h - Definitions for the portable win16/32 version of AVI

*****************************************************************************/
#ifndef _NTAVIPRT_H
#define _NTAVIPRT_H


#ifndef _WIN32


#else

#define IsGDIObject(obj) (GetObjectType((HGDIOBJ)(obj)) != 0)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\nocrap.h ===
// (C) Copyright Microsoft Corporation 1991.  All rights reserved.

// #define NOVIRTUALKEYCODES	// VK_*
#define NOSYSMETRICS		// SM_*
#define NOICONS			// IDI_*
#define NOKEYSTATES		// MK_*
#define NOSYSCOMMANDS		// SC_*
#define OEMRESOURCE		// OEM Resource values
#define NOATOM			// Atom Manager routines
#define NOCLIPBOARD		// Clipboard routines
// #define NOCTLMGR		// Control and Dialog routines
#define NODRAWTEXT		// DrawText() and DT_*
#define NOMETAFILE		// typedef METAFILEPICT
// #define NOMSG		// typedef MSG and associated routines
#define NOSOUND			// Sound driver routines
#define NOWH			// SetWindowsHook and WH_*
#define NOCOMM			// COMM driver routines
#define NOKANJI			// Kanji support stuff.
#define NOHELP			// Help engine interface.
#define NOPROFILER		// Profiler interface.
#define NODEFERWINDOWPOS	// DeferWindowPos routines

//#define NOWIN31                 // New Windows 3.1 APIs
#define NOGDICAPMASKS		// CC_*, LC_*, PC_*, CP_*, TC_*, RC_
// #define NOWINMESSAGES	// WM_*, EM_*, LB_*, CB_*
// #define NOWINSTYLES		// WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
// #define NOMENUS		// MF_*
// #define NORASTEROPS		// Binary and Tertiary raster ops
// #define NOSHOWWINDOW		// SW_*
#define NOCOLOR			// Screen colors
// #define NOGDI		// All GDI defines and routines
// #define NOKERNEL		// All KERNEL defines and routines
// #define NOUSER		// All USER defines and routines
#define NOMB			// MB_* and MessageBox()
// #define NOMEMMGR		// GMEM_*, LMEM_*, GHND, LHND, associated routines
// #define NOMINMAX		// Macros min(a,b) and max(a,b)
#define NOOPENFILE		// OpenFile(), OemToAnsi, AnsiToOem, and OF_*
#define NOSCROLL		// SB_* and scrolling routines
#define NOTEXTMETRIC		// typedef TEXTMETRIC and associated routines
// #define NOWINOFFSETS		// GWL_*, GCL_*, associated routines
#define NODRIVERS		// Installable driver defines
#define NODBCS			// DBCS support stuff.
#define NOSYSTEMPARAMSINFO		// SystemParameterInfo (SPI_*)
#define NOSCALABLEFONT		// Scalable font prototypes and data structures
// #define NOGDIOBJ		// GDI objects including pens, brushes and logfonts.
// #define NOBITMAP		// GDI bitmaps
#define NOLFILEIO		// _l* file I/O
#define NOLOGERROR		// LogError() and related definitions
#define NOPROFILER		// Profiler APIs


#define MMNOSOUND		// Sound support
// #define MMNOWAVE		// Waveform support
#define MMNOMIDI		// MIDI support
#define MMNOAUX			// Auxiliary output support
// #define MMNOTIMER		// Timer support
#define MMNOJOY			// Joystick support
// #define MMNOMCI		// MCI support
// #define MMNODRV		// Installable driver support 
// #define MMNOMMIO		// MMIO library support
// #define MMNOMMSYSTEM		// No mmsystem general functions

#define MMNOMIDIDEV		// MIDI support
#define MMNOWAVEDEV		// Waveform support
#define MMNOAUXDEV		// Auxiliary output support
#define MMNOTIMERDEV		// Timer support
#define MMNOJOYDEV		// Joystick support
// #define MMNOMCIDEV		// MCI support
// #define MMNOTASKDEV		// Task support
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\profile.c ===
/*
 * profile.c
 *
 * win32/win16 utility functions to read and write profile items
 * for multimedia tools
 */

#include <windows.h>
#include <windowsx.h>
#include <profile.key>

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
#ifdef _WIN32
UINT mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault)
{
    CHAR achName[MAX_PATH];
    HKEY hkey;
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;

    lstrcpyA(achName, KEYNAMEA);
    lstrcatA(achName, appname);
    if (RegOpenKeyA(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {

        cbData = sizeof(dwData);
        if (RegQueryValueExA(
            hkey,
            (LPSTR)valuename,
            NULL,
            &dwType,
            (PBYTE) &dwData,
            &cbData) == ERROR_SUCCESS) {
                if (dwType == REG_DWORD) {
                    value = (INT)dwData;
                }
        }

        RegCloseKey(hkey);
    }

    return((UINT)value);
}

UINT
mmGetProfileInt(LPCTSTR appname, LPCTSTR valuename, INT uDefault)
{
    TCHAR achName[MAX_PATH];
    HKEY hkey;
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;

    lstrcpy(achName, KEYNAME);
    lstrcat(achName, appname);
    if (RegOpenKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {

        cbData = sizeof(dwData);
        if (RegQueryValueEx(
            hkey,
            (LPTSTR)valuename,
            NULL,
            &dwType,
            (PBYTE) &dwData,
            &cbData) == ERROR_SUCCESS) {
                if (dwType == REG_DWORD) {
                    value = (INT)dwData;
                }
        }

        RegCloseKey(hkey);
    }

    return((UINT)value);
}
#endif


/*
 * write a UINT to the profile, if it is not the
 * same as the default or the value already there
 */
#ifdef _WIN32
VOID
mmWriteProfileInt(LPCTSTR appname, LPCTSTR valuename, INT Value)
{
    // If we would write the same as already there... return.
    if (mmGetProfileInt(appname, valuename, !Value) == (UINT)Value) {
        return;
    }

    {
        TCHAR achName[MAX_PATH];
        HKEY hkey;

        lstrcpy(achName, KEYNAME);
        lstrcat(achName, appname);
        if (RegCreateKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {
            RegSetValueEx(
                hkey,
                valuename,
                0,
                REG_DWORD,
                (PBYTE) &Value,
                sizeof(Value)
            );

            RegCloseKey(hkey);
        }
    }

}
#else
// For Win16 we use a macro and assume we have been passed a string value
//    char ach[12];
//
//    wsprintf(ach, "%d", Value);
//
//    WriteProfileString(
//        appname,
//        valuename,
//        ach);
}
#endif


/*
 * read a string from the profile into pResult.
 * result is number of bytes written into pResult
 */
#ifdef _WIN32
DWORD
mmGetProfileStringA(
    LPCSTR appname,
    LPCSTR valuename,
    LPCSTR pDefault,
    LPSTR pResult,
    int cbResult
)
{
    CHAR achName[MAX_PATH];
    HKEY hkey;
    DWORD dwType;

    lstrcpyA(achName, KEYNAMEA);
    lstrcatA(achName, appname);
    if (RegOpenKeyA(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {

        cbResult = cbResult * sizeof(TCHAR);
        if (RegQueryValueExA(
            hkey,
            (LPSTR)valuename,
            NULL,
            &dwType,
            (LPBYTE)pResult,
            &cbResult) == ERROR_SUCCESS) {

                if (dwType == REG_SZ) {
                    // cbResult is set to the size including null
                    RegCloseKey(hkey);
                    return(cbResult - 1);
                }
        }

        RegCloseKey(hkey);
    }

    // if we got here, we didn't find it, or it was the wrong type - return
    // the default string
    lstrcpyA(pResult, pDefault);
    return(lstrlenA(pDefault));
}

DWORD
mmGetProfileString(
    LPCTSTR appname,
    LPCTSTR valuename,
    LPCTSTR pDefault,
    LPTSTR pResult,
    int cbResult
)
{
    TCHAR achName[MAX_PATH];
    HKEY hkey;
    DWORD dwType;

    lstrcpy(achName, KEYNAME);
    lstrcat(achName, appname);
    if (RegOpenKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {

        cbResult = cbResult * sizeof(TCHAR);
        if (RegQueryValueEx(
            hkey,
            (LPTSTR)valuename,
            NULL,
            &dwType,
            (LPBYTE)pResult,
            &cbResult) == ERROR_SUCCESS) {

                if (dwType == REG_SZ) {
                    // cbResult is set to the size including null
                    RegCloseKey(hkey);
                    return(cbResult/sizeof(TCHAR) - 1);
                }
        }

        RegCloseKey(hkey);
    }

    // if we got here, we didn't find it, or it was the wrong type - return
    // the default string
    lstrcpy(pResult, pDefault);
    return(lstrlen(pDefault));
}
#endif


/*
 * write a string to the profile
 */
#ifdef _WIN32
VOID
mmWriteProfileString(LPCTSTR appname, LPCTSTR valuename, LPCTSTR pData)
{
    TCHAR achName[MAX_PATH];
    HKEY hkey;

    lstrcpy(achName, KEYNAME);
    lstrcat(achName, appname);
    if (RegCreateKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {
        if (pData) {
            RegSetValueEx(
                hkey,
                valuename,
                0,
                REG_SZ,
                (LPBYTE)pData,
                (lstrlen(pData) + 1) * sizeof(TCHAR)
            );
        } else {
            RegDeleteValue(
                hkey,
                (LPTSTR)valuename
            );
        }

        RegCloseKey(hkey);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\encrypt\encrypt.c ===
/* encrypt.c
 *
 * A dumb encryption/decryption algorithm -- for each character:
 *
 *	chOut = (char) (*chIn ^ (128 | (iEncrypt++ & 127)));
 *
 * This program does both encryption and decryption.
 */

#include <stdio.h>

int __cdecl main(int argc, char *argv[])
{
	FILE *	fpIn;
	FILE *	fpOut;
	int	iEncrypt=0;
	int	iCh;

	if ( argc != 3 ) {
		fprintf(stderr, "usage: encrypt infile outfile\n");
		return(1);
	}

	if ( (fpIn=fopen(argv[1], "rb") ) == NULL) {
		fprintf(stderr, "cant open %s\n", argv[1]);
		return(1);
	}

	if ( (fpOut=fopen(argv[2], "wb") ) == NULL) {
		fprintf(stderr, "cant open %s\n", argv[2]);
		return(1);
	}

	while ( (iCh=getc(fpIn)) != EOF )
		putc((char) (((char) iCh) ^ (128 | (iEncrypt++ & 127))), fpOut);

	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\profile.h ===
/*
 * utility functions to read and write values to the profile,
 * using win.ini for Win16 or current user\software\microsoft\mciavi
 * in the registry for Win32
 */


#ifndef _WIN32
// For Win16 calls, mmWriteProfileInt passes a STRING for parm 3
//VOID mmWriteProfileInt(LPSTR appname, LPSTR valuename, UINT uValue);

#define mmWriteProfileInt(app, value, default) \
          WriteProfileString(app, value, (LPSTR)default)

#define mmGetProfileInt(app, value, default) \
          GetProfileInt(app, value, (LPSTR)default)

#define mmGetProfileIntA(app, value, default) \
          GetProfileInt(app, value, (LPSTR)default)

#define mmWriteProfileString(appname, valuename, pData) \
          WriteProfileString(appname, valuename, pData)

#define mmGetProfileString(appname, valuename, pDefault, pResult, cbResult) \
          GetProfileString(appname, valuename, pDefault, pResult, cbResult)

#define mmGetProfileStringA(appname, valuename, pDefault, pResult, cbResult) \
          GetProfileString(appname, valuename, pDefault, pResult, cbResult)

#else

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT mmGetProfileInt(LPCTSTR appname, LPCTSTR valuename, INT uDefault);
UINT mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault);

/*
 * write an INT to the profile, if it is not the
 * same as the value already there
 */
VOID mmWriteProfileInt(LPCTSTR appname, LPCTSTR valuename, INT uValue);

/*
 * read a string from the profile into pResult.
 * result is number of bytes written into pResult
 */
DWORD
mmGetProfileString(
    LPCTSTR appname,
    LPCTSTR valuename,
    LPCTSTR pDefault,
    LPTSTR pResult,
    int cbResult
);

DWORD
mmGetProfileStringA(
    LPCSTR appname,
    LPCSTR valuename,
    LPCSTR pDefault,
    LPSTR pResult,
    int cbResult
);

/*
 * write a string to the profile
 */
VOID mmWriteProfileString(LPCTSTR appname, LPCTSTR valuename, LPCTSTR pData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciavi32\window.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   window.c - Multimedia Systems Media Control Interface
	    driver for AVI.

*****************************************************************************/
#include "graphic.h"

#include "avitask.h"    // for TASKIDLE

//#define IDM_CONFIG              0x100
//#define IDM_SKIPFRAMES          0x110
#define IDM_MUTE                0x120
#define IDM_STRETCH             0x130

#ifdef _WIN32
// Use a different class name on 32 bit systems to ease the 16/32
// coexistence problem.  (We might want both classes defined at once.)
TCHAR szClassName[] = TEXT("AVIWnd32");
#else
char szClassName[] = "AVIWnd";
#endif


DWORD NEAR PASCAL GraphicStop (NPMCIGRAPHIC npMCI, DWORD dwFlags);
DWORD NEAR PASCAL GraphicPause (NPMCIGRAPHIC npMCI, DWORD dwFlags);
DWORD NEAR PASCAL GraphicPlay (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_ANIM_PLAY_PARMS lpPlay );
DWORD NEAR PASCAL GraphicSeek (NPMCIGRAPHIC npMCI, DWORD dwFlags,
    LPMCI_SEEK_PARMS lpSeek);

BOOL NEAR PASCAL GraphicWindowInit (void)
{
    WNDCLASS cls;

    // define the class of window we want to register

    cls.lpszClassName = szClassName;
    cls.style = CS_GLOBALCLASS | CS_OWNDC;
    cls.hCursor = LoadCursor (NULL, IDC_ARROW);
    cls.hIcon = NULL;
    cls.lpszMenuName = NULL;
////cls.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    cls.hbrBackground = GetStockObject(BLACK_BRUSH);
    cls.hInstance = ghModule;
    cls.lpfnWndProc = GraphicWndProc;
    cls.cbClsExtra = 0;
    cls.cbWndExtra = sizeof (NPMCIGRAPHIC);

    return RegisterClass (&cls);
}

#ifdef _WIN32
/*
 * de-register the class on unloading the dll so that we can
 * successfully re-register the class next time we are loaded.
 * note that nt only unregisters a class when the app exits.
 */
BOOL NEAR PASCAL GraphicWindowFree(void)
{
	return(UnregisterClass(szClassName, ghModule));
}


/**************************************************************************
***************************************************************************/

//-----------------------------------------------------------------------
// this is the winproc thread's main function.
// we create the window and signal the event once initialization
// is complete. We then block either processing messages or waiting for
// hEventWinProcDie. When this is set, we clean up and exit

void aviWinProcTask(DWORD_PTR dwInst)
{
    NPMCIGRAPHIC npMCI = (NPMCIGRAPHIC) dwInst;
    HWND hWnd;
    MSG msg;

    // Create the default window - the caller may
    // supply style and parent window.

#ifdef DEBUG
    if (npMCI->hwndParent) {
	if ( !IsWindow(npMCI->hwndParent)) {
	    //DebugBreak();
	    // This should have been trapped before getting here
	}
    }
#endif

    if (npMCI->dwStyle != (DWORD) -1) {
	// CW_USEDEFAULT can't be used with popups or children so
	// if the user provides the style, default to full-screen.

	hWnd =

	// Note:  The CreateWindow/Ex call is written this way as on Win32
	// CreateWindow is a MACRO, and hence the call must be contained
	// within the preprocessor block.
	CreateWindowEx(
#ifdef BIDI
	    WS_EX_BIDI_SCROLL |  WS_EX_BIDI_MENU |WS_EX_BIDI_NOICON,
#else
	    0,
#endif
	    szClassName,
	    FileName(npMCI->szFilename),
	    npMCI->dwStyle,
	    0, 0,
	    GetSystemMetrics (SM_CXSCREEN),
	    GetSystemMetrics (SM_CYSCREEN),
	    npMCI->hwndParent,
	    NULL, ghModule, (LPTSTR)npMCI);
    } else {
	npMCI->dwStyle = WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX |
		  WS_SYSMENU | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
	hWnd =
	CreateWindowEx(
#ifdef BIDI
	    WS_EX_BIDI_SCROLL |  WS_EX_BIDI_MENU |WS_EX_BIDI_NOICON,
#else
	    0,
#endif
	    szClassName,
	    FileName(npMCI->szFilename),
	    npMCI->dwStyle,
	    CW_USEDEFAULT, 0,
	    CW_USEDEFAULT, 0,
	    npMCI->hwndParent,
	    NULL, ghModule, (LPTSTR)npMCI);
    }

    npMCI->hwndDefault = hWnd;
    npMCI->hwndPlayback = hWnd;


    if (!hWnd) {
	// fail to start up - just exit this function and the caller
	// will detect thread exit
	DPF(("CreateWindow failed, LastError=%d\n", GetLastError()));
	npMCI->dwReturn = MCIERR_CREATEWINDOW;
	return;
    }

    // window created ok - signal worker thread to continue
    SetEvent(npMCI->hEventWinProcOK);

    while (GetMessage(&msg, NULL, 0, 0)) {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    }

    // WM_QUIT received - exit now
    GdiFlush();
    return;

}

//
// Pass request bit(s) to worker thread.
// Use WinProcRequestEx when the WinCrit critical section is already held
//   and WINPROC_ACTIVE/INACTIVE is not being used
//
// Use WinProcRequest when the WinCrit critical section is required
//

void INLINE
WinProcRequestEx(NPMCIGRAPHIC npMCI, DWORD dwFlag)
{
    DPF2(("WinProcRequestEx... request %8x", dwFlag));
    npMCI->dwWinProcRequests |= dwFlag;
    SetEvent(npMCI->heWinProcRequest);
    DPF2(("!...Ex request %8x done\n", dwFlag));
}

void
WinProcRequest(NPMCIGRAPHIC npMCI, DWORD dwFlag)
{
    DPF2(("WinProcRequest... request %8x", dwFlag));
    EnterWinCrit(npMCI);
    DPF2(("!... request %8x ...", dwFlag));

    // If we are being made active or inactive, then ensure that only
    // one of the WINPROC_ACTIVE/WINPROC_INACTIVE bits is switched on.
    if (dwFlag & (WINPROC_ACTIVE | WINPROC_INACTIVE)) {
	npMCI->dwWinProcRequests &= ~(WINPROC_ACTIVE | WINPROC_INACTIVE);
    }
    npMCI->dwWinProcRequests |= dwFlag;

    SetEvent(npMCI->heWinProcRequest);

    DPF2(("!... request %8x done\n", dwFlag));
    LeaveWinCrit(npMCI);
}


#endif



DWORD FAR PASCAL GraphicConfig(NPMCIGRAPHIC npMCI, DWORD dwFlags);
#if 0
static void NEAR PASCAL Credits(HWND hwnd);
#endif

//
// Window proc is always run on the winproc thread. We hold
// a critical section during all paint/palette code to protect us
// against interaction with the worker thread. We do not hold this
// critical section for the whole winproc.
//
LRESULT FAR PASCAL _LOADDS GraphicWndProc (HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT         ps;
    NPMCIGRAPHIC        npMCI;
    HMENU               hmenu;
    HDC                 hdc;
    RECT                rc;
    MINMAXINFO FAR *    lpmmi;
    TCHAR               ach[80];

#ifndef _WIN32
    npMCI = (NPMCIGRAPHIC)GetWindowWord (hwnd, 0);
#else
    npMCI = (NPMCIGRAPHIC)GetWindowLongPtr (hwnd, 0);

    if (npMCI) {
	if (IsBadReadPtr(npMCI, sizeof(MCIGRAPHIC))
	  || !IsTask(npMCI->hTask)) {
	    DPF2(("WndProc called with msg %04x after task npMCI=%08x is dead\n", wMsg, npMCI));

	    // if the device is in some sort of shutdown state, only the
	    // messages below are safe to process. Note: not processing
	    // AVIM_DESTROY can lead to deadlock.
	    switch (wMsg) {
		case AVIM_DESTROY:
		    DestroyWindow(hwnd);
		    return 1L;
		case WM_DESTROY:
		    PostQuitMessage(0);
		    break;

		default:
		   return DefWindowProc(hwnd, wMsg, wParam, lParam);
	    }
	}
	Assert(wMsg != WM_CREATE);
    } else {

	// npMCI is NULL - only WM_CREATE can safely be processed

	// I think we can also safely process AVIM_DESTROY and that
	// will avoid a few potential hangs...
	if ((wMsg != WM_CREATE) && (wMsg != AVIM_DESTROY)) {
	    return DefWindowProc(hwnd, wMsg, wParam, lParam);
	}
    }
#endif

    switch (wMsg)
	{

	case WM_CREATE:

	    npMCI = (NPMCIGRAPHIC)(UINT_PTR)(DWORD_PTR)
			    ((LPCREATESTRUCT)lParam)->lpCreateParams;

#ifdef _WIN32
	    SetWindowLongPtr (hwnd, 0, (UINT_PTR)npMCI);
#else
	    SetWindowWord (hwnd, 0, (WORD)npMCI);
#endif
	
	    hmenu = GetSystemMenu(hwnd, 0);
	
	    if (hmenu) {
		/* Our system menu is too long--get rid of extra stuff. */
//              DeleteMenu(hmenu, SC_RESTORE, MF_BYCOMMAND);
//              DeleteMenu(hmenu, SC_MINIMIZE, MF_BYCOMMAND);
		DeleteMenu(hmenu, SC_MAXIMIZE, MF_BYCOMMAND);
		DeleteMenu(hmenu, SC_TASKLIST, MF_BYCOMMAND);

		/* Add additional menu items to the end of the system menu */
//              AppendMenu(hmenu, MF_SEPARATOR, 0, 0L);

#ifdef IDM_CONFIG
		LoadString(ghModule, MCIAVI_MENU_CONFIG, ach, NUMELMS(ach));
		AppendMenu(hmenu, MF_STRING, IDM_CONFIG, ach);
#endif

		LoadString(ghModule, MCIAVI_MENU_STRETCH, ach, NUMELMS(ach));
		AppendMenu(hmenu, MF_STRING, IDM_STRETCH, ach);

		LoadString(ghModule, MCIAVI_MENU_MUTE, ach, NUMELMS(ach));
		AppendMenu(hmenu, MF_STRING, IDM_MUTE, ach);
	    }
	
	    break;
	
	case WM_INITMENU:
	
	    hmenu = GetSystemMenu(hwnd, 0);
	
	    if (hmenu) {
#ifdef IDM_SKIPFRAMES
		CheckMenuItem(hmenu, IDM_SKIPFRAMES, MF_BYCOMMAND |
			    ((npMCI->dwOptionFlags & MCIAVIO_SKIPFRAMES) ?
					    MF_CHECKED : MF_UNCHECKED));
#endif
		CheckMenuItem(hmenu, IDM_STRETCH, MF_BYCOMMAND |
			    ((npMCI->dwOptionFlags & MCIAVIO_STRETCHTOWINDOW) ?
					    MF_CHECKED : MF_UNCHECKED));

#ifdef IDM_CONFIG
		/* If in configure box, disable menu item. */
		EnableMenuItem(hmenu, IDM_CONFIG, MF_BYCOMMAND |
			    (npMCI->wMessageCurrent == 0 ?
						MF_ENABLED : MF_GRAYED));
#endif
					
		/* If in stupid mode, disable stretch menu item. */
		EnableMenuItem(hmenu, IDM_STRETCH, MF_BYCOMMAND |
			    ((!(npMCI->dwOptionFlags & MCIAVIO_STUPIDMODE)) ?
					    MF_ENABLED : MF_GRAYED));
					
		EnableMenuItem(hmenu, IDM_MUTE, MF_BYCOMMAND |
			    (npMCI->nAudioStreams ?
					    MF_ENABLED : MF_GRAYED));

		CheckMenuItem(hmenu, IDM_MUTE, MF_BYCOMMAND |
			    (!(npMCI->dwFlags & MCIAVI_PLAYAUDIO) ?
					    MF_CHECKED : MF_UNCHECKED));
	    }
	    break;
	
	case WM_SYSCOMMAND:
	    switch (wParam & 0xfff0) {
	    case SC_KEYMENU:
	    case SC_MOUSEMENU:
		gfEvilSysMenu++;
		lParam = DefWindowProc(hwnd, wMsg, wParam, lParam);
		gfEvilSysMenu--;
		return lParam;
		
#ifdef IDM_SKIPFRAMES
	    case IDM_SKIPFRAMES:
		EnterWinCrit(npMCI);
		npMCI->dwOptionFlags ^= MCIAVIO_SKIPFRAMES;
		LeaveWinCrit(npMCI);
		break;
#endif
	    case IDM_STRETCH:
		EnterWinCrit(npMCI);

		npMCI->dwOptionFlags ^= MCIAVIO_STRETCHTOWINDOW;
		
		if (!(npMCI->dwOptionFlags & MCIAVIO_STRETCHTOWINDOW)) {
		    SetWindowToDefaultSize(npMCI, FALSE);
		}
		
		Winproc_DestRect(npMCI, FALSE);
		LeaveWinCrit(npMCI);
		break;

	    case IDM_MUTE:
		// just set request flag in npMCI
		WinProcRequest(npMCI, WINPROC_MUTE);
		break;

#ifdef IDM_CONFIG
	    case IDM_CONFIG:
		npMCI->wMessageCurrent = MCI_CONFIGURE;
		gfEvil++;
		dwOptions = npMCI->dwOptions;
		f = ConfigDialog(NULL, npMCI);
		if (f) {
	#ifdef DEBUG
		    //
		    // in DEBUG always reset the dest rect because the user may
		    // have played with the DEBUG DrawDib options and we will
		    // need to call DrawDibBegin() again.
		    //
		    if (TRUE)
	#else
		    if ((npMCI->dwOptionFlags & (MCIAVIO_STUPIDMODE|MCIAVIO_ZOOMBY2
						 |MCIAVIO_WINDOWSIZEMASK))
				!= (dwOptions & (MCIAVIO_STUPIDMODE|MCIAVIO_ZOOMBY2
						 |MCIAVIO_WINDOWSIZEMASK)) )
	#endif
		    {
	
			npMCI->lFrameDrawn =
				(- (LONG) npMCI->wEarlyRecords) - 1;
			//EnterWinCrit(npMCI);
			SetWindowToDefaultSize(npMCI, FALSE);
			Winproc_DestRect(npMCI, FALSE);
			//LeaveWinCrit(npMCI);
		    }
		} else {
		    npMCI->dwOptionFlags = dwOptions;
		}
		

		GraphicConfig(npMCI, 0L);
		gfEvil--;
		npMCI->wMessageCurrent = 0;
		break;
#endif
	    }
	    break;

	case WM_CLOSE:

	    // Hide default window

	    WinProcRequest(npMCI, WINPROC_STOP);
	    ShowWindow(hwnd, SW_HIDE);
	    return 0L;

// this stuff is here because of some bizarre inter-thread rules in nt
	case AVIM_DESTROY:
	    DestroyWindow(hwnd);
	    return 1L;

	case AVIM_SHOWSTAGE:
	    {
		BOOL bIsVis;

		// activate if not visible. force activation if requested
		// (if palette changes)
		if (wParam) {
		    bIsVis = FALSE;
		} else {
		    bIsVis = IsWindowVisible(hwnd);
		}

		SetWindowPos(npMCI->hwndPlayback, HWND_TOP, 0, 0, 0, 0,
		    SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW |
		    (bIsVis ? SWP_NOACTIVATE : 0));

		if (!bIsVis) {
		    SetForegroundWindow(hwnd);
		}
	    }
	    return 1L;



	case WM_DESTROY:

	    // The window may be destroyed 2 ways.
	    //  a. the device is closed. In this case the animation is
	    //  freed in DeviceClose which is called from GraphicClose
	    //  and the animation ID is NULL by the time this window is
	    //  destroyed.
	    //  b. the window is closed. In this case, the animation is
	    //  not closed and we should set the stage to NULL. A new
	    //  default window will be created if needed.

	    EnterWinCrit(npMCI);
	    if (IsTask(npMCI->hTask)) {
		WinProcRequestEx(npMCI, WINPROC_STOP);
	    }

	    if (npMCI->hwndPlayback == npMCI->hwndDefault)
		npMCI->hwndPlayback = NULL;
	    npMCI->hwndDefault = NULL;

	    LeaveWinCrit(npMCI);

	    // winproc thread can now exit
	    PostQuitMessage(0);
	    break;

	case WM_ERASEBKGND:

	    hdc = (HDC) wParam;

	    // We should not need any critical section as the system
	    // has given us a HDC as a message parameter.
	    Assert(hdc && (hdc != npMCI->hdc));
	    //EnterWinCrit(npMCI);

	    if (!(npMCI->dwFlags & MCIAVI_SHOWVIDEO)) {
		FillRect(hdc, &npMCI->rcDest, GetStockObject(GRAY_BRUSH));
	    }
		
	    SaveDC(hdc);

	    ExcludeClipRect(hdc,
		npMCI->rcDest.left, npMCI->rcDest.top,
		npMCI->rcDest.right, npMCI->rcDest.bottom);

	    GetClientRect(hwnd, &rc);
	    FillRect(hdc, &rc, GetStockObject(BLACK_BRUSH));

	    RestoreDC(hdc, -1);

#if 0
	    /* Hack: if we're in a WAIT state, we won't get
	    ** a WM_PAINT, so we need to invalidate the streams here
	    */
	    GetClipBox(hdc, &rc);
	    StreamInvalidate(npMCI, &rc);
#endif

	    //LeaveWinCrit(npMCI);

	    return 0L;

	case WM_PAINT:


	    // we always do this even if we leave it to the
	    // worker to paint, since otherwise we'll loop endlessly
	    // processing WM_PAINT
	    hdc = BeginPaint(hwnd, &ps);

	    rc = ps.rcPaint;

	    // if the worker thread is cueing, seeking or playing we don't
	    // actually want to paint (in case it is doing rle delta paints).
	    // now we've got the window critsec, it is safe to check
	    // the task state
	    if ((npMCI->wTaskState == TASKPLAYING) ||
		(npMCI->wTaskState == TASKCUEING)) {
		    npMCI->dwFlags |= MCIAVI_NEEDUPDATE;
	    } else {

		StreamInvalidate(npMCI, &rc);
		// we don't need to pass rc in as we are clipped to this
		// already and all they do is clip to it.

		// don't paint if there is a 'pf' since we only ever
		// reference this on the worker thread (OLE threading rules)
		if (npMCI->pf) {
		    WinProcRequest(npMCI, WINPROC_UPDATE);
		} else {

		    // note: TryStreamUpdate will get the HDC critical section
		    if (!TryStreamUpdate(npMCI, MCI_DGV_UPDATE_PAINT, hdc, NULL)) {

			// requires full play - ask worker thread to do this

			// to paint the frame at this point, we would have
			// to call mciaviPlayFile. This can only be safely called
			// on the worker thread. To avoid potential deadlock,
			// this paint has to be done asynchronously from us, and
			// also we lose the update rect information - the
			// worker will paint the entire destination rect.

#if 0 // looks bad - don't bother
			// paint gray first, in case the worker thread is busy
			// or it fails
			GetClientRect(hwnd, &rc);
			FillRect(hdc, &rc, GetStockObject(DKGRAY_BRUSH));
#endif          
			WinProcRequest(npMCI, WINPROC_UPDATE);

		    } else {
			// painted successfully on this thread

			// if we are playing and so have an hdc then we need to
			// reprepare the orig dc after switching back to it
			if (npMCI->wTaskState == TASKPAUSED) {
			    EnterHDCCrit(npMCI);
			    // if a new command has arrived the state may have changed
			    // underneath us.  If so, the dc may have been released.  We
			    // only want to call PrepareDC if npMCI->hdc is non null.
			    if(npMCI->hdc) PrepareDC(npMCI);
			    LeaveHDCCrit(npMCI);  // remember to release the critical section
			}
		    }
		}
	    }

	    EndPaint(hwnd, &ps);
	    return 0L;         // we do NOT call DefWindowProc
	
	case WM_PALETTECHANGED:

	    // We're not using the default window.  We have no business here.
	    if (npMCI->hwndPlayback != hwnd)
		break;

	    //
	    // someone has realized a palette - so we need to re-realize our
	    // palette (note that this will also cause drawdib to
	    // check for PAL_INDICES vs PAL_COLOURS.
	    //
	    if ((HWND) wParam != hwnd) {
		WinProcRequest(npMCI, WINPROC_REALIZE);

		// invalidate is done in InternalRealize
		//InvalidateRect(hwnd, NULL, FALSE);
	    }
	    break;
	
	case WM_QUERYNEWPALETTE:
	    {
#if 0
		LONG lRet;
#endif
		// We're not using the default window.  We have no business here.
		if (npMCI->hwndPlayback != hwnd)
		    break;

#if 0
    // not true = internalrealize has always returned 0, so why do this
    // on this thread?
		EnterHDCCrit(npMCI);

		// need to do this on winproc thread to get
		// correct return value.
		lRet = InternalRealize(npMCI);
		LeaveHDCCrit(npMCI);
		return(lRet);
#else
		WinProcRequest(npMCI, WINPROC_REALIZE);
		return 0;
#endif
	    }

	case WM_WINDOWPOSCHANGED:
	    //EnterWinCrit(npMCI);
	    //CheckWindowMove grabs the critical section when it needs it
	    CheckWindowMove(npMCI, TRUE);
	    //LeaveWinCrit(npMCI);
	    break;

	case WM_SIZE:
	    EnterWinCrit(npMCI);
	    Winproc_DestRect(npMCI, FALSE);
	    LeaveWinCrit(npMCI);
	    break;
	
	case WM_QUERYENDSESSION:

	    WinProcRequest(npMCI, WINPROC_STOP);

	    break;

	case WM_ENDSESSION:
	    if (wParam)  {
		DestroyWindow(hwnd); // we may not be able to destroy window?
	    }
	    break;

	case WM_GETMINMAXINFO:
	    lpmmi = (MINMAXINFO FAR *)(lParam);

	    lpmmi->ptMinTrackSize.x = GetSystemMetrics(SM_CXSIZE) * 2;
	    break;

	case WM_NCACTIVATE:
	    WinProcRequest(npMCI, wParam?WINPROC_ACTIVE : WINPROC_INACTIVE);
	    break;

#if 0
We should not need both ACTIVATE and NCACTIVATE - use the one that
arrives first (to give us a little more time and reduce the start up
latency)
	case WM_ACTIVATE:
	    WinProcRequest(npMCI, wParam?WINPROC_ACTIVE : WINPROC_INACTIVE);
	    break;
#endif

#ifdef REMOTESTEAL
	case WM_AUDIO_ON:     // Someone has released the wave device
	  {
	    extern HWND hwndLostAudio;
	    //Assert(npMCI->dwFlags & MCIAVI_PLAYAUDIO);
	    //Assert(npMCI->dwFlags & MCIAVI_LOSTAUDIO);
	    //Assert(npMCI->hWave == NULL);
	    // Timing might be such that these assertions are invalid

	    // If we are not playing then we might be able to forward
	    // the message to another... OR, tell the one giving up the
	    // audio that it can be reclaimed because we no longer have
	    // a use for it.
	    if (npMCI->wTaskState != TASKPLAYING) {
		if (!hwndLostAudio) {
		    hwndLostAudio = (HWND)wParam;
		}
		if (hwndLostAudio) {
		    DPF2(("Forwarding WM_AUDIO_ON message to %x...\n", hwndLostAudio));
		    if (IsWindow(hwndLostAudio)) {
			PostMessage(hwndLostAudio, WM_AUDIO_ON, 0, 0);
		    }
		    hwndLostAudio = 0;  // Prevent further messages
		}
	    } else {
		// we are playing
		// Save the window handle of the window releasing the sound
		DPF2(("Setting hwndLostAudio to %x (was %x)\n", wParam, hwndLostAudio));
		hwndLostAudio = (HWND)wParam;
		// if hwndLostAudio==0 then we do not return it to anyone

		WinProcRequest(npMCI, WINPROC_SOUND);
	    }
	    return 0;
	    break;
	  }

	case WM_AUDIO_OFF:    // Someone wants our wave device
	  {
	    extern HWND hwndWantAudio;
	    //Assert(npMCI->dwFlags & MCIAVI_PLAYAUDIO);
	    //Assert(!(npMCI->dwFlags & MCIAVI_LOSTAUDIO));
	    //Assert(npMCI->hWave != NULL);
	    // Timing might be such that these assertions are invalid

	    SetNTFlags(npMCI, NTF_AUDIO_OFF);
	    // Save the window handle of the window which wants sound
	    DPF2(("WM_AUDIO_OFF... hwndWantAudio set to %x (was %x)\n", wParam, hwndWantAudio));
	    hwndWantAudio = (HWND)wParam;
	    // if hwndWantAudio==0 then we do not release the wave device

	    if (IsWindow(hwndWantAudio)) {
		WinProcRequest(npMCI, WINPROC_SILENT);
	    } else {
		DPF(("WM_AUDIO_OFF... but the target window is invalid\n"));
	    }
	    ResetNTFlags(npMCI, NTF_AUDIO_OFF);
	    return 0;
	    break;
	  }
#endif // REMOTESTEAL

#if 0
	case WM_LBUTTONDOWN:
	    {
		DWORD   dw;
		static DWORD dwLastClick;
		static DWORD dwClicks = 0;
		#define MAX_CLICKS      7
		/*     . = (0,300)  - = (300,1000)  word = (500,1500)   */
		/*     AVI:   .-    ...-   ..                           */
		static DWORD adwClickHigh[MAX_CLICKS] =
		    {  300, 1500,  300,  300,  300, 1500,  300 };
		static DWORD adwClickLow[MAX_CLICKS] =
		    {    0,  500,    0,    0,    0,  500,    0 };
		
		dw = timeGetTime();
		if (((dw - dwLastClick) > adwClickLow[dwClicks]) &&
			((dw - dwLastClick) <= adwClickHigh[dwClicks]))
		    dwClicks++;
		else
		    dwClicks = 0;

		dwLastClick = dw;

		if (dwClicks == MAX_CLICKS) {
		    WinProcRequest(npMCI, WINPROC_STOP);
		    Credits(hwnd);
		    dwClicks = 0;
		}
	    }
#endif
	} // switch(wMsg)

    return DefWindowProc(hwnd, wMsg, wParam, lParam);
}

#if 0
static void NEAR PASCAL Credits(HWND hwnd)
{
	/*  Credits...  */
	RECT            rc;
	RECT            rcUpdate;
	HDC             hdc;
	MSG             msg;
	int             dyLine;
	int             yLine;
	TEXTMETRIC      tm;
	DWORD           dwNextTime;
	long            lScroll;
	DWORD           rgb;
	HANDLE          hResInfo;
	HANDLE          hResData;
	LPSTR           pchSrc, pchDst;
	char            achLine[100];
	int             iEncrypt;

	#define EOFCHAR '@'             // end of credits file

	/* load the credits */
	if ((hResInfo = FindResource(ghModule, TEXT("MMS"), TEXT("MMSCR"))) == NULL)
		return;
	if ((hResData = LoadResource(ghModule, hResInfo)) == NULL)
		return;
	if ((pchSrc = LockResource(hResData)) == NULL)
		return;

	/* we want to get all mouse and keyboard events, to make
	 * sure we stop the animation when the user clicks or
	 * hits a key
	 */
	SetFocus(hwnd);
	SetCapture(hwnd);

	/* Scroll the credits up, one pixel at a time.  pchSrc
	 * points to the encrypted data; achLine contains a decrypted
	 * line (null-terminated).  dyLine is the height of each
	 * line (constant), and yLine is between 0 and dyLine,
	 * indicating how many pixels of the line have been scrolled
	 * in vertically from the bottom
	 */
	hdc = GetDC(hwnd);
	SelectObject(hdc, GetStockObject(ANSI_VAR_FONT));
	GetClientRect(hwnd, &rc);
	SetTextAlign(hdc, TA_CENTER);
	SetBkColor(hdc, RGB(0, 0, 0));
	SetRect(&rcUpdate, 0, rc.bottom - 1, rc.right, rc.bottom);
	GetTextMetrics(hdc, &tm);
	if ((dyLine = tm.tmHeight + tm.tmExternalLeading) == 0)
		dyLine = 1;
	yLine = dyLine;
	dwNextTime = GetCurrentTime();  // time to do the next scroll
	lScroll = 0;
	iEncrypt = 0;
	while (TRUE) {
		/* If the user clicks the mouse or hits a key, exit.
		 * However, ignore WM_LBUTTONUP because they will have
		 * to let go of the mouse after clicking the icon.
		 * Also, ignore mouse move messages.
		 */
		if (PeekMessage(&msg, hwnd, WM_KEYFIRST, WM_KEYLAST,
				PM_NOREMOVE | PM_NOYIELD))
			break;                  // exit on key hit

		if (PeekMessage(&msg, hwnd, WM_MOUSEFIRST, WM_MOUSELAST,
				PM_NOREMOVE | PM_NOYIELD)) {
			if ((msg.message == WM_MOUSEMOVE) ||
			    (msg.message == WM_LBUTTONUP)) {
				/* remove and ignore message */
				PeekMessage(&msg, hwnd, msg.message,
					msg.message,
					PM_REMOVE | PM_NOYIELD);
			}
			else
				break;          // exit on click
		}

		/* scroll at a fixed no. of vertical pixels per sec. */
		if (dwNextTime > GetCurrentTime())
			continue;
		dwNextTime += 50L;      // millseconds per scroll

		if (yLine == dyLine) {
			/* decrypt a line and copy to achLine */
			pchDst = achLine;
			while (TRUE) {
				*pchDst = (char) (*pchSrc++ ^
					(128 | (iEncrypt++ & 127)));
				if ((*pchDst == '\r') ||
				    (*pchDst == EOFCHAR))
					break;
				pchDst++;
			}

			if (*pchDst == EOFCHAR)
				break;          // no more lines
			*pchDst = 0;            // null-terminate
			pchSrc++, iEncrypt++;   // skip '\n'
			yLine = 0;
		}

		/* scroll screen up one pixel */
		BitBlt(hdc, 0, 0, rcUpdate.right, rcUpdate.top,
			hdc, 0, 1, SRCCOPY);

		/* vary the text colors through a "rainbow" */
		switch ((int) (lScroll++ / 4) % 5/*num-of-cases*/) {
		case 0: rgb = RGB(255,   0,   0); break;
		case 1: rgb = RGB(255, 255,   0); break;
		case 2: rgb = RGB(  0, 255,   0); break;
		case 3: rgb = RGB(  0, 255, 255); break;
		case 4: rgb = RGB(255,   0, 255); break;
		}
		SetTextColor(hdc, rgb);

		/* fill in the bottom pixel */
		SaveDC(hdc);
		yLine++;
		IntersectClipRect(hdc, rcUpdate.left, rcUpdate.top,
			rcUpdate.right, rcUpdate.bottom);
#ifdef _WIN32
		ExtTextOutA(hdc, rc.right / 2, rc.bottom - yLine,
			ETO_OPAQUE, &rcUpdate,
			achLine, lstrlenA(achLine), NULL);
#else
		ExtTextOut(hdc, rc.right / 2, rc.bottom - yLine,
			ETO_OPAQUE, &rcUpdate,
			achLine, lstrlen(achLine), NULL);
#endif
		RestoreDC(hdc, -1);
	}

	ReleaseDC(hwnd, hdc);
	ReleaseCapture();
	UnlockResource(hResData);
	FreeResource(hResData);
	InvalidateRect(hwnd, NULL, TRUE);
}
#endif



//
// Obey the registry default sizing of Zoom by 2 and Fixed screen %.
// Takes a Rect and either zooms it by 2 or replaces it with a constant size
// or leaves it alone.
//
void FAR PASCAL AlterRectUsingDefaults(NPMCIGRAPHIC npMCI, LPRECT lprc)
{
	if (npMCI->dwOptionFlags & MCIAVIO_ZOOMBY2) {
	    SetRect(lprc, 0, 0, lprc->right*2, lprc->bottom*2);
	} else {
		if (npMCI->dwOptionFlags & MCIAVIO_WINDOWSIZEMASK) {
			lprc->right = GetSystemMetrics (SM_CXSCREEN);
		lprc->bottom = GetSystemMetrics (SM_CYSCREEN);
			
			switch(npMCI->dwOptionFlags & MCIAVIO_WINDOWSIZEMASK)
			{
			case MCIAVIO_1QSCREENSIZE:
				SetRect(lprc, 0, 0, lprc->right/4, lprc->bottom/4);
				break;
			
			case MCIAVIO_2QSCREENSIZE:
				SetRect(lprc, 0, 0, lprc->right/2, lprc->bottom/2);
				break;
		    
			case MCIAVIO_3QSCREENSIZE:
				SetRect(lprc, 0, 0, lprc->right*3/4, lprc->bottom*3/4);
				break;
		    
			case MCIAVIO_MAXWINDOWSIZE:
				SetRect(lprc, 0, 0, lprc->right, lprc->bottom);
				break;
			}
		}
	}
}


// Set the size of the default window to be the rcMovie size (default
// destination size).  Keep in mind a top level window might grow off screen,
// so adjust the position so that it remains on screen.
void FAR PASCAL SetWindowToDefaultSize(NPMCIGRAPHIC npMCI, BOOL fUseDefaultSizing)
{
    RECT                        rc, rcW;
    int                         xScreen, yScreen, x, y;
    WINDOWPLACEMENT wp;

    wp.length = sizeof(wp);

    if (npMCI->hwndPlayback && npMCI->hwndPlayback == npMCI->hwndDefault) {

		// Get the size of the movie, maybe alter it if the configure options
		// tell us to play zoomed or fullscreen or something, and adjust for
		// non-client area.
		//
	
		rc = npMCI->rcMovie;
		if (fUseDefaultSizing)
			AlterRectUsingDefaults(npMCI, &rc);
	AdjustWindowRect(&rc, GetWindowLong(npMCI->hwndPlayback, GWL_STYLE), FALSE);

		
		// For top-level windows, get the position where the playback window is
		// (or will be) on the screen.  Make it fit on the screen if possible.
		// Dorking with the position of the default window if it's a
		// child window is a bad idea.  First of all, SetWindowPos is going to
		// position it relative to its parent, and these calculations figure
		// out where we want it in screen coordinates.  Second of all, trying
		// to move a child so that it's on screen when the parent could be
		// offscreen itself or hiding the child window is just asking for
		// trouble.
		//
		
		if (!(GetWindowLong(npMCI->hwndPlayback, GWL_STYLE) & WS_CHILD)) {
			if (IsIconic(npMCI->hwndPlayback)) {
				GetWindowPlacement(npMCI->hwndPlayback, &wp);
				rcW = wp.rcNormalPosition;
			} else {
				GetWindowRect(npMCI->hwndPlayback, &rcW);
			}

			rcW.right = rcW.left + rc.right - rc.left;
			rcW.bottom = rcW.top + rc.bottom - rc.top;
			xScreen = GetSystemMetrics(SM_CXSCREEN);
	    yScreen = GetSystemMetrics(SM_CYSCREEN);
			
			if (rcW.right > xScreen) {
				x = min(rcW.left, rcW.right - xScreen);
				rcW.left -= x;
				rcW.right -= x;
			}

			if (rcW.bottom > yScreen) {
				y = min(rcW.top, rcW.bottom - yScreen);
				rcW.top -= y;
				rcW.bottom -= y;
			}

			if (IsIconic(npMCI->hwndPlayback)) {
				wp.rcNormalPosition = rcW;
				SetWindowPlacement(npMCI->hwndPlayback, &wp);
			} else {
				SetWindowPos(npMCI->hwndPlayback, NULL, rcW.left, rcW.top,
						rcW.right - rcW.left, rcW.bottom - rcW.top,
						    SWP_NOZORDER | SWP_NOACTIVATE);
			}

			// For a child window, we don't move it, we just size it.
			//
		} else {
			if (IsIconic(npMCI->hwndPlayback)) {
				GetWindowPlacement(npMCI->hwndPlayback, &wp);
				wp.rcNormalPosition.right = wp.rcNormalPosition.left +
											(rc.right - rc.left);
				wp.rcNormalPosition.bottom = wp.rcNormalPosition.top +
											(rc.bottom - rc.top);
				SetWindowPlacement(npMCI->hwndPlayback, &wp);
			} else {
				SetWindowPos(npMCI->hwndPlayback, NULL, 0, 0,
							rc.right - rc.left, rc.bottom - rc.top,
							SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
			}
		}
    }
}

void FAR PASCAL Winproc_DestRect(NPMCIGRAPHIC npMCI, BOOL fUseDefaultSizing)
{
    RECT    rc;

    /* WM_SIZE messages (on NT at least) are sometimes sent
     * during CreateWindow processing (eg if the initial window size
     * is not CW_DEFAULT). Some fields in npMCI are only filled in
     * after CreateWindow has returned. So there is a danger that at this
     * point some fields are not valid.
     */

    if (npMCI->hwndPlayback &&
	npMCI->hwndPlayback == npMCI->hwndDefault &&
	(npMCI->dwOptionFlags & MCIAVIO_STRETCHTOWINDOW)) {
	GetClientRect(npMCI->hwndPlayback, &rc);
    }

    // Only allow ZOOMBY2 and fixed % defaults for our default playback window
    else if (npMCI->streams > 0 && npMCI->hwndPlayback == npMCI->hwndDefault) { 
		rc = npMCI->rcMovie;

		// Note: irrelevant on winproc thread
		//if (fUseDefaultSizing)
		//      AlterRectUsingDefaults(npMCI, &rc);

    }
    else {
	return;
    }

    if (!IsRectEmpty(&rc)) {
		WinCritCheckIn(npMCI);
		WinProcRequestEx(npMCI, WINPROC_RESETDEST);  // faster form... we have the critical section
    }
}

#ifdef _WIN32
    #define DWORG POINT
    #define GETDCORG(hdc, dwOrg)  GetDCOrgEx(hdc, &dwOrg)
#else
    #define DWORG DWORD
    #define GETDCORG(hdc, dwOrg)  dwOrg = GetDCOrg(hdc)
#endif

void CheckWindowMove(NPMCIGRAPHIC npMCI, BOOL fForce)
{
    DWORG   dwOrg;
    UINT    wRgn;
    HDC     hdc;
    RECT    rc;
    BOOL    fNull;
    BOOL    fGetDC;

    if (!(npMCI->dwFlags & MCIAVI_WANTMOVE))
	return;

    if (!npMCI->hicDraw || !npMCI->hwndPlayback || npMCI->nVideoStreams == 0)
	return;

    Assert(IsWindow(npMCI->hwndPlayback));
    Assert(npMCI->paStreamInfo);
    Assert(npMCI->nVideoStreams > 0);

    //
    //  when the screen is locked for update by a window move operation
    //  we dont want to turn off the video.
    //
    //  we can tell if the screen is locked by checking a DC to the screen.
    //
    hdc = GetDC(NULL);
    fNull = GetClipBox(hdc, &rc);
    ReleaseDC(NULL, hdc);

    if (NULLREGION == fNull)
    {
	npMCI->wRgnType = (UINT) -1;
	return;
    }

    if (fForce)
	npMCI->wRgnType = (UINT) -1;


    // sync worker thread/winproc thread interaction
    EnterHDCCrit(npMCI);

    if (fGetDC = (npMCI->hdc == NULL)) {
	hdc = GetDC (npMCI->hwndPlayback);
    } else {
	hdc = npMCI->hdc;
    }

    wRgn = GetClipBox(hdc, &rc);

    GETDCORG(hdc, dwOrg);

    if (fGetDC)
	ReleaseDC(npMCI->hwndPlayback, hdc);

    if (wRgn == npMCI->wRgnType &&
#ifdef _WIN32
	dwOrg.x == npMCI->dwOrg.x &&
	dwOrg.y == npMCI->dwOrg.y &&
#else
	dwOrg == npMCI->dwOrg &&
#endif
	EqualRect(&rc, &npMCI->rcClip)) {

	LeaveHDCCrit(npMCI);
	return;
    }

    npMCI->wRgnType = wRgn;
    npMCI->dwOrg    = dwOrg;
    npMCI->rcClip   = rc;

    rc = npMCI->psiVideo->rcDest;
    ClientToScreen(npMCI->hwndPlayback, (LPPOINT)&rc);
    ClientToScreen(npMCI->hwndPlayback, (LPPOINT)&rc+1);

    if (wRgn == NULLREGION)
	SetRectEmpty(&rc);

    DPF2(("Sending ICM_DRAW_WINDOW message Rgn=%d, Org=(%d,%d) [%d, %d, %d, %d]\n", wRgn, dwOrg, rc));

    if (ICDrawWindow(npMCI->hicDraw, &rc) != ICERR_OK) {
	DPF2(("Draw device does not want ICM_DRAW_WINDOW messages!\n"));
	npMCI->dwFlags &= ~MCIAVI_WANTMOVE;
    }
    LeaveHDCCrit(npMCI);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\bmpload.c ===
#include "ctlspriv.h"

//
//  include HEX forms of some standard bitmaps
//
#include "toolbar.hex"
#include "thumb.hex"

// these are the default colors used to map the dib colors
// to the current system colors

#define RGB_BUTTONTEXT      (RGB(000,000,000))  // black
#define RGB_BUTTONSHADOW    (RGB(128,128,128))  // dark grey
#define RGB_BUTTONFACE      (RGB(192,192,192))  // bright grey
#define RGB_BUTTONHILIGHT   (RGB(255,255,255))  // white
#define RGB_BACKGROUNDSEL   (RGB(000,000,255))  // blue
#define RGB_BACKGROUND      (RGB(255,000,255))  // magenta
#define FlipColor(rgb)      (RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb)))

#define MAX_COLOR_MAPS      16

HBITMAP WINAPI CreateMappedDib(LPBITMAPINFOHEADER lpBitmapInfo,
      WORD wFlags, LPCOLORMAP lpColorMap, int iNumMaps)
{
  HDC			hdc, hdcMem = NULL;
  DWORD FAR		*p;
  DWORD FAR		*lpTable;
  LPBYTE 		lpBits;
  HBITMAP		hbm = NULL, hbmOld;
  int numcolors, i;
  int wid, hgt;
  DWORD			rgbMaskTable[16];
  DWORD                 rgbSave[16];
  DWORD			rgbBackground;
  static const COLORMAP SysColorMap[] = {
    {RGB_BUTTONTEXT,    COLOR_BTNTEXT},     // black
    {RGB_BUTTONSHADOW,  COLOR_BTNSHADOW},   // dark grey
    {RGB_BUTTONFACE,    COLOR_BTNFACE},     // bright grey
    {RGB_BUTTONHILIGHT, COLOR_BTNHIGHLIGHT},// white
    {RGB_BACKGROUNDSEL, COLOR_HIGHLIGHT},   // blue
    {RGB_BACKGROUND,    COLOR_WINDOW}       // magenta
  };
  #define NUM_DEFAULT_MAPS (sizeof(SysColorMap)/sizeof(COLORMAP))
  COLORMAP DefaultColorMap[NUM_DEFAULT_MAPS];
  COLORMAP DIBColorMap[MAX_COLOR_MAPS];

  if (!lpBitmapInfo)
    return NULL;

  hmemcpy(rgbSave, lpBitmapInfo+1, 16 * sizeof(RGBQUAD));

  /* Get system colors for the default color map */
  if (!lpColorMap) {
    lpColorMap = DefaultColorMap;
    iNumMaps = NUM_DEFAULT_MAPS;
    for (i=0; i < iNumMaps; i++) {
      lpColorMap[i].from = SysColorMap[i].from;
      lpColorMap[i].to = GetSysColor((int)SysColorMap[i].to);
    }
  }

  /* Transform RGB color map to a BGR DIB format color map */
  if (iNumMaps > MAX_COLOR_MAPS)
    iNumMaps = MAX_COLOR_MAPS;
  for (i=0; i < iNumMaps; i++) {
    DIBColorMap[i].to = FlipColor(lpColorMap[i].to);
    DIBColorMap[i].from = FlipColor(lpColorMap[i].from);
  }

  lpTable = p = (DWORD FAR *)((LPBYTE)lpBitmapInfo + (int)lpBitmapInfo->biSize);

  /* Replace button-face and button-shadow colors with the current values
   */
  numcolors = 16;

  // if we are creating a mask, build a color table with white
  // marking the transparent section (where it used to be background)
  // and black marking the opaque section (everything else).  this
  // table is used below to build the mask using the original DIB bits.
  if (wFlags & CMB_MASKED) {
      rgbBackground = FlipColor(RGB_BACKGROUND);
      for (i = 0; i < 16; i++) {
          if (p[i] == rgbBackground)
              rgbMaskTable[i] = 0xFFFFFF;	// transparent section
          else
              rgbMaskTable[i] = 0x000000;	// opaque section
      }
  }

  while (numcolors-- > 0) {
      for (i = 0; i < iNumMaps; i++) {
          if (*p == DIBColorMap[i].from) {
              *p = DIBColorMap[i].to;
              break;
          }
      }
      p++;
  }

  /* First skip over the header structure */
  lpBits = (LPVOID)((LPBYTE)lpBitmapInfo + (int)lpBitmapInfo->biSize);

  /* Skip the color table entries, if any */
  lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

  /* Create a color bitmap compatible with the display device */
  i = wid = (int)lpBitmapInfo->biWidth;
  hgt = (int)lpBitmapInfo->biHeight;
  hdc = GetDC(NULL);
  hdcMem = CreateCompatibleDC(hdc);
  if (!hdcMem)
      goto cleanup;

  // if creating a mask, the bitmap needs to be twice as wide.
  if (wFlags & CMB_MASKED)
      i = wid*2;

  if (wFlags & CMB_DISCARDABLE)
      hbm = CreateDiscardableBitmap(hdc, i, hgt);
  else
      hbm = CreateCompatibleBitmap(hdc, i, hgt);
  if (hbm) {
      hbmOld = SelectObject(hdcMem, hbm);

      // set the main image
      StretchDIBits(hdcMem, 0, 0, wid, hgt, 0, 0, wid, hgt, lpBits,
                 (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS, SRCCOPY);

      // if building a mask, replace the DIB's color table with the
      // mask's black/white table and set the bits.  in order to
      // complete the masked effect, the actual image needs to be
      // modified so that it has the color black in all sections
      // that are to be transparent.
      if (wFlags & CMB_MASKED) {
          hmemcpy(lpTable, (DWORD FAR *)rgbMaskTable, 16 * sizeof(RGBQUAD));
          StretchDIBits(hdcMem, wid, 0, wid, hgt, 0, 0, wid, hgt, lpBits,
                 (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS, SRCCOPY);
          BitBlt(hdcMem, 0, 0, wid, hgt, hdcMem, wid, 0, 0x00220326);   // DSna
      }
      SelectObject(hdcMem, hbmOld);
  }

cleanup:
  if (hdcMem)
      DeleteObject(hdcMem);
  ReleaseDC(NULL, hdc);

  hmemcpy(lpBitmapInfo+1, rgbSave, 16 * sizeof(RGBQUAD));
  return hbm;
}

HBITMAP WINAPI CreateMappedBitmap(HINSTANCE hInstance, int idBitmap,
      WORD wFlags, LPCOLORMAP lpColorMap, int iNumMaps)
{
  HANDLE    h;
  HANDLE    hRes;
  HBITMAP   hbm;
  LPBITMAPINFOHEADER lpbi;

  h = FindResource(hInstance, MAKEINTRESOURCE(idBitmap), RT_BITMAP);

  if (!h)
  {
      if (idBitmap == IDB_THUMB)
        lpbi = (LPVOID)Bitmap_Thumb;
      else
        lpbi = (LPVOID)Bitmap_Toolbar;

      return CreateMappedDib(lpbi, wFlags, lpColorMap, iNumMaps);
  }

  hRes = LoadResource(hInstance, h);

  /* Lock the bitmap and get a pointer to the color table. */
  lpbi = (LPBITMAPINFOHEADER)LockResource(hRes);
  if (!lpbi)
    return NULL;

  hbm = CreateMappedDib(lpbi, wFlags, lpColorMap, iNumMaps);

  UnlockResource(hRes);
  FreeResource(hRes);

  return hbm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\cutils.c ===
/*
**  CUTILS.C
**
**  Common utilities for common controls
**
*/

#include "ctlspriv.h"

in